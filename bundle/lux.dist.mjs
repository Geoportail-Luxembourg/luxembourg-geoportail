var CP = Object.defineProperty;
var IP = (t, e, r) => e in t ? CP(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var ei = (t, e, r) => (IP(t, typeof e != "symbol" ? e + "" : e, r), r);
function PP(t, e) {
  for (var r = 0; r < e.length; r++) {
    const n = e[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in t)) {
          const l = Object.getOwnPropertyDescriptor(n, i);
          l && Object.defineProperty(t, i, l.get ? l : {
            enumerable: !0,
            get: () => n[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
function Hl(t, e) {
  const r = /* @__PURE__ */ Object.create(null), n = t.split(",");
  for (let i = 0; i < n.length; i++)
    r[n[i]] = !0;
  return e ? (i) => !!r[i.toLowerCase()] : (i) => !!r[i];
}
function Uh(t) {
  if (Zt(t)) {
    const e = {};
    for (let r = 0; r < t.length; r++) {
      const n = t[r], i = Nn(n) ? LP(n) : Uh(n);
      if (i)
        for (const l in i)
          e[l] = i[l];
    }
    return e;
  } else {
    if (Nn(t))
      return t;
    if (rn(t))
      return t;
  }
}
const AP = /;(?![^(]*\))/g, OP = /:([^]+)/, RP = /\/\*.*?\*\//gs;
function LP(t) {
  const e = {};
  return t.replace(RP, "").split(AP).forEach((r) => {
    if (r) {
      const n = r.split(OP);
      n.length > 1 && (e[n[0].trim()] = n[1].trim());
    }
  }), e;
}
function Or(t) {
  let e = "";
  if (Nn(t))
    e = t;
  else if (Zt(t))
    for (let r = 0; r < t.length; r++) {
      const n = Or(t[r]);
      n && (e += n + " ");
    }
  else if (rn(t))
    for (const r in t)
      t[r] && (e += r + " ");
  return e.trim();
}
const DP = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", kP = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", NP = /* @__PURE__ */ Hl(DP), FP = /* @__PURE__ */ Hl(kP), zP = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", BP = /* @__PURE__ */ Hl(zP);
function vT(t) {
  return !!t || t === "";
}
const Vt = (t) => Nn(t) ? t : t == null ? "" : Zt(t) || rn(t) && (t.toString === ET || !ar(t.toString)) ? JSON.stringify(t, xT, 2) : String(t), xT = (t, e) => e && e.__v_isRef ? xT(t, e.value) : Zc(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce((r, [n, i]) => (r[`${n} =>`] = i, r), {})
} : wT(e) ? {
  [`Set(${e.size})`]: [...e.values()]
} : rn(e) && !Zt(e) && !TT(e) ? String(e) : e, dn = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, vh = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], Ui = () => {
}, bT = () => !1, UP = /^on[^a-z]/, $d = (t) => UP.test(t), vg = (t) => t.startsWith("onUpdate:"), kn = Object.assign, H0 = (t, e) => {
  const r = t.indexOf(e);
  r > -1 && t.splice(r, 1);
}, $P = Object.prototype.hasOwnProperty, Ar = (t, e) => $P.call(t, e), Zt = Array.isArray, Zc = (t) => py(t) === "[object Map]", wT = (t) => py(t) === "[object Set]", ar = (t) => typeof t == "function", Nn = (t) => typeof t == "string", K0 = (t) => typeof t == "symbol", rn = (t) => t !== null && typeof t == "object", Y0 = (t) => rn(t) && ar(t.then) && ar(t.catch), ET = Object.prototype.toString, py = (t) => ET.call(t), J0 = (t) => py(t).slice(8, -1), TT = (t) => py(t) === "[object Object]", Q0 = (t) => Nn(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Qm = /* @__PURE__ */ Hl(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), VP = /* @__PURE__ */ Hl("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), my = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (r) => e[r] || (e[r] = t(r));
}, jP = /-(\w)/g, Go = my((t) => t.replace(jP, (e, r) => r ? r.toUpperCase() : "")), GP = /\B([A-Z])/g, Mo = my((t) => t.replace(GP, "-$1").toLowerCase()), ru = my((t) => t.charAt(0).toUpperCase() + t.slice(1)), Bc = my((t) => t ? `on${ru(t)}` : ""), Td = (t, e) => !Object.is(t, e), Wf = (t, e) => {
  for (let r = 0; r < t.length; r++)
    t[r](e);
}, xg = (t, e, r) => {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !1,
    value: r
  });
}, qP = (t) => {
  const e = parseFloat(t);
  return isNaN(e) ? t : e;
}, Wv = (t) => {
  const e = Nn(t) ? Number(t) : NaN;
  return isNaN(e) ? t : e;
};
let Eb;
const ST = () => Eb || (Eb = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function bg(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
let Uo;
class MT {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Uo, !e && Uo && (this.index = (Uo.scopes || (Uo.scopes = [])).push(this) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const r = Uo;
      try {
        return Uo = this, e();
      } finally {
        Uo = r;
      }
    } else
      process.env.NODE_ENV !== "production" && bg("cannot run an inactive effect scope.");
  }
  on() {
    Uo = this;
  }
  off() {
    Uo = this.parent;
  }
  stop(e) {
    if (this._active) {
      let r, n;
      for (r = 0, n = this.effects.length; r < n; r++)
        this.effects[r].stop();
      for (r = 0, n = this.cleanups.length; r < n; r++)
        this.cleanups[r]();
      if (this.scopes)
        for (r = 0, n = this.scopes.length; r < n; r++)
          this.scopes[r].stop(!0);
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function CT(t) {
  return new MT(t);
}
function WP(t, e = Uo) {
  e && e.active && e.effects.push(t);
}
function IT() {
  return Uo;
}
function XP(t) {
  Uo ? Uo.cleanups.push(t) : process.env.NODE_ENV !== "production" && bg("onScopeDispose() is called when there is no active effect scope to be associated with.");
}
const Sd = (t) => {
  const e = new Set(t);
  return e.w = 0, e.n = 0, e;
}, PT = (t) => (t.w & Vl) > 0, AT = (t) => (t.n & Vl) > 0, ZP = ({ deps: t }) => {
  if (t.length)
    for (let e = 0; e < t.length; e++)
      t[e].w |= Vl;
}, HP = (t) => {
  const { deps: e } = t;
  if (e.length) {
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      PT(i) && !AT(i) ? i.delete(t) : e[r++] = i, i.w &= ~Vl, i.n &= ~Vl;
    }
    e.length = r;
  }
}, wg = /* @__PURE__ */ new WeakMap();
let Qf = 0, Vl = 1;
const Xv = 30;
let fo;
const Hc = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : ""), Zv = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class ex {
  constructor(e, r = null, n) {
    this.fn = e, this.scheduler = r, this.active = !0, this.deps = [], this.parent = void 0, WP(this, n);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = fo, r = Nl;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = fo, fo = this, Nl = !0, Vl = 1 << ++Qf, Qf <= Xv ? ZP(this) : Tb(this), this.fn();
    } finally {
      Qf <= Xv && HP(this), Vl = 1 << --Qf, fo = this.parent, Nl = r, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    fo === this ? this.deferStop = !0 : this.active && (Tb(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function Tb(t) {
  const { deps: e } = t;
  if (e.length) {
    for (let r = 0; r < e.length; r++)
      e[r].delete(t);
    e.length = 0;
  }
}
let Nl = !0;
const OT = [];
function uu() {
  OT.push(Nl), Nl = !1;
}
function hu() {
  const t = OT.pop();
  Nl = t === void 0 ? !0 : t;
}
function mo(t, e, r) {
  if (Nl && fo) {
    let n = wg.get(t);
    n || wg.set(t, n = /* @__PURE__ */ new Map());
    let i = n.get(r);
    i || n.set(r, i = Sd());
    const l = process.env.NODE_ENV !== "production" ? { effect: fo, target: t, type: e, key: r } : void 0;
    Hv(i, l);
  }
}
function Hv(t, e) {
  let r = !1;
  Qf <= Xv ? AT(t) || (t.n |= Vl, r = !PT(t)) : r = !t.has(fo), r && (t.add(fo), fo.deps.push(t), process.env.NODE_ENV !== "production" && fo.onTrack && fo.onTrack(Object.assign({ effect: fo }, e)));
}
function Vs(t, e, r, n, i, l) {
  const h = wg.get(t);
  if (!h)
    return;
  let s = [];
  if (e === "clear")
    s = [...h.values()];
  else if (r === "length" && Zt(t)) {
    const v = Number(n);
    h.forEach((E, T) => {
      (T === "length" || T >= v) && s.push(E);
    });
  } else
    switch (r !== void 0 && s.push(h.get(r)), e) {
      case "add":
        Zt(t) ? Q0(r) && s.push(h.get("length")) : (s.push(h.get(Hc)), Zc(t) && s.push(h.get(Zv)));
        break;
      case "delete":
        Zt(t) || (s.push(h.get(Hc)), Zc(t) && s.push(h.get(Zv)));
        break;
      case "set":
        Zc(t) && s.push(h.get(Hc));
        break;
    }
  const m = process.env.NODE_ENV !== "production" ? { target: t, type: e, key: r, newValue: n, oldValue: i, oldTarget: l } : void 0;
  if (s.length === 1)
    s[0] && (process.env.NODE_ENV !== "production" ? ch(s[0], m) : ch(s[0]));
  else {
    const v = [];
    for (const E of s)
      E && v.push(...E);
    process.env.NODE_ENV !== "production" ? ch(Sd(v), m) : ch(Sd(v));
  }
}
function ch(t, e) {
  const r = Zt(t) ? t : [...t];
  for (const n of r)
    n.computed && Sb(n, e);
  for (const n of r)
    n.computed || Sb(n, e);
}
function Sb(t, e) {
  (t !== fo || t.allowRecurse) && (process.env.NODE_ENV !== "production" && t.onTrigger && t.onTrigger(kn({ effect: t }, e)), t.scheduler ? t.scheduler() : t.run());
}
function KP(t, e) {
  var r;
  return (r = wg.get(t)) === null || r === void 0 ? void 0 : r.get(e);
}
const YP = /* @__PURE__ */ Hl("__proto__,__v_isRef,__isVue"), RT = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(K0)
), JP = /* @__PURE__ */ gy(), QP = /* @__PURE__ */ gy(!1, !0), eA = /* @__PURE__ */ gy(!0), tA = /* @__PURE__ */ gy(!0, !0), Mb = /* @__PURE__ */ rA();
function rA() {
  const t = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    t[e] = function(...r) {
      const n = ir(this);
      for (let l = 0, h = this.length; l < h; l++)
        mo(n, "get", l + "");
      const i = n[e](...r);
      return i === -1 || i === !1 ? n[e](...r.map(ir)) : i;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    t[e] = function(...r) {
      uu();
      const n = ir(this)[e].apply(this, r);
      return hu(), n;
    };
  }), t;
}
function nA(t) {
  const e = ir(this);
  return mo(e, "has", t), e.hasOwnProperty(t);
}
function gy(t = !1, e = !1) {
  return function(n, i, l) {
    if (i === "__v_isReactive")
      return !t;
    if (i === "__v_isReadonly")
      return t;
    if (i === "__v_isShallow")
      return e;
    if (i === "__v_raw" && l === (t ? e ? UT : BT : e ? zT : FT).get(n))
      return n;
    const h = Zt(n);
    if (!t) {
      if (h && Ar(Mb, i))
        return Reflect.get(Mb, i, l);
      if (i === "hasOwnProperty")
        return nA;
    }
    const s = Reflect.get(n, i, l);
    return (K0(i) ? RT.has(i) : YP(i)) || (t || mo(n, "get", i), e) ? s : tn(s) ? h && Q0(i) ? s : s.value : rn(s) ? t ? $T(s) : vy(s) : s;
  };
}
const iA = /* @__PURE__ */ LT(), oA = /* @__PURE__ */ LT(!0);
function LT(t = !1) {
  return function(r, n, i, l) {
    let h = r[n];
    if (jl(h) && tn(h) && !tn(i))
      return !1;
    if (!t && (!Eg(i) && !jl(i) && (h = ir(h), i = ir(i)), !Zt(r) && tn(h) && !tn(i)))
      return h.value = i, !0;
    const s = Zt(r) && Q0(n) ? Number(n) < r.length : Ar(r, n), m = Reflect.set(r, n, i, l);
    return r === ir(l) && (s ? Td(i, h) && Vs(r, "set", n, i, h) : Vs(r, "add", n, i)), m;
  };
}
function aA(t, e) {
  const r = Ar(t, e), n = t[e], i = Reflect.deleteProperty(t, e);
  return i && r && Vs(t, "delete", e, void 0, n), i;
}
function sA(t, e) {
  const r = Reflect.has(t, e);
  return (!K0(e) || !RT.has(e)) && mo(t, "has", e), r;
}
function lA(t) {
  return mo(t, "iterate", Zt(t) ? "length" : Hc), Reflect.ownKeys(t);
}
const DT = {
  get: JP,
  set: iA,
  deleteProperty: aA,
  has: sA,
  ownKeys: lA
}, kT = {
  get: eA,
  set(t, e) {
    return process.env.NODE_ENV !== "production" && bg(`Set operation on key "${String(e)}" failed: target is readonly.`, t), !0;
  },
  deleteProperty(t, e) {
    return process.env.NODE_ENV !== "production" && bg(`Delete operation on key "${String(e)}" failed: target is readonly.`, t), !0;
  }
}, cA = /* @__PURE__ */ kn({}, DT, {
  get: QP,
  set: oA
}), uA = /* @__PURE__ */ kn({}, kT, {
  get: tA
}), tx = (t) => t, yy = (t) => Reflect.getPrototypeOf(t);
function vm(t, e, r = !1, n = !1) {
  t = t.__v_raw;
  const i = ir(t), l = ir(e);
  r || (e !== l && mo(i, "get", e), mo(i, "get", l));
  const { has: h } = yy(i), s = n ? tx : r ? rx : Md;
  if (h.call(i, e))
    return s(t.get(e));
  if (h.call(i, l))
    return s(t.get(l));
  t !== i && t.get(e);
}
function xm(t, e = !1) {
  const r = this.__v_raw, n = ir(r), i = ir(t);
  return e || (t !== i && mo(n, "has", t), mo(n, "has", i)), t === i ? r.has(t) : r.has(t) || r.has(i);
}
function bm(t, e = !1) {
  return t = t.__v_raw, !e && mo(ir(t), "iterate", Hc), Reflect.get(t, "size", t);
}
function Cb(t) {
  t = ir(t);
  const e = ir(this);
  return yy(e).has.call(e, t) || (e.add(t), Vs(e, "add", t, t)), this;
}
function Ib(t, e) {
  e = ir(e);
  const r = ir(this), { has: n, get: i } = yy(r);
  let l = n.call(r, t);
  l ? process.env.NODE_ENV !== "production" && NT(r, n, t) : (t = ir(t), l = n.call(r, t));
  const h = i.call(r, t);
  return r.set(t, e), l ? Td(e, h) && Vs(r, "set", t, e, h) : Vs(r, "add", t, e), this;
}
function Pb(t) {
  const e = ir(this), { has: r, get: n } = yy(e);
  let i = r.call(e, t);
  i ? process.env.NODE_ENV !== "production" && NT(e, r, t) : (t = ir(t), i = r.call(e, t));
  const l = n ? n.call(e, t) : void 0, h = e.delete(t);
  return i && Vs(e, "delete", t, void 0, l), h;
}
function Ab() {
  const t = ir(this), e = t.size !== 0, r = process.env.NODE_ENV !== "production" ? Zc(t) ? new Map(t) : new Set(t) : void 0, n = t.clear();
  return e && Vs(t, "clear", void 0, void 0, r), n;
}
function wm(t, e) {
  return function(n, i) {
    const l = this, h = l.__v_raw, s = ir(h), m = e ? tx : t ? rx : Md;
    return !t && mo(s, "iterate", Hc), h.forEach((v, E) => n.call(i, m(v), m(E), l));
  };
}
function Em(t, e, r) {
  return function(...n) {
    const i = this.__v_raw, l = ir(i), h = Zc(l), s = t === "entries" || t === Symbol.iterator && h, m = t === "keys" && h, v = i[t](...n), E = r ? tx : e ? rx : Md;
    return !e && mo(l, "iterate", m ? Zv : Hc), {
      next() {
        const { value: T, done: S } = v.next();
        return S ? { value: T, done: S } : {
          value: s ? [E(T[0]), E(T[1])] : E(T),
          done: S
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function pl(t) {
  return function(...e) {
    if (process.env.NODE_ENV !== "production") {
      const r = e[0] ? `on key "${e[0]}" ` : "";
      console.warn(`${ru(t)} operation ${r}failed: target is readonly.`, ir(this));
    }
    return t === "delete" ? !1 : this;
  };
}
function hA() {
  const t = {
    get(l) {
      return vm(this, l);
    },
    get size() {
      return bm(this);
    },
    has: xm,
    add: Cb,
    set: Ib,
    delete: Pb,
    clear: Ab,
    forEach: wm(!1, !1)
  }, e = {
    get(l) {
      return vm(this, l, !1, !0);
    },
    get size() {
      return bm(this);
    },
    has: xm,
    add: Cb,
    set: Ib,
    delete: Pb,
    clear: Ab,
    forEach: wm(!1, !0)
  }, r = {
    get(l) {
      return vm(this, l, !0);
    },
    get size() {
      return bm(this, !0);
    },
    has(l) {
      return xm.call(this, l, !0);
    },
    add: pl("add"),
    set: pl("set"),
    delete: pl("delete"),
    clear: pl("clear"),
    forEach: wm(!0, !1)
  }, n = {
    get(l) {
      return vm(this, l, !0, !0);
    },
    get size() {
      return bm(this, !0);
    },
    has(l) {
      return xm.call(this, l, !0);
    },
    add: pl("add"),
    set: pl("set"),
    delete: pl("delete"),
    clear: pl("clear"),
    forEach: wm(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((l) => {
    t[l] = Em(l, !1, !1), r[l] = Em(l, !0, !1), e[l] = Em(l, !1, !0), n[l] = Em(l, !0, !0);
  }), [
    t,
    r,
    e,
    n
  ];
}
const [fA, dA, pA, mA] = /* @__PURE__ */ hA();
function _y(t, e) {
  const r = e ? t ? mA : pA : t ? dA : fA;
  return (n, i, l) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? n : Reflect.get(Ar(r, i) && i in n ? r : n, i, l);
}
const gA = {
  get: /* @__PURE__ */ _y(!1, !1)
}, yA = {
  get: /* @__PURE__ */ _y(!1, !0)
}, _A = {
  get: /* @__PURE__ */ _y(!0, !1)
}, vA = {
  get: /* @__PURE__ */ _y(!0, !0)
};
function NT(t, e, r) {
  const n = ir(r);
  if (n !== r && e.call(t, n)) {
    const i = J0(t);
    console.warn(`Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const FT = /* @__PURE__ */ new WeakMap(), zT = /* @__PURE__ */ new WeakMap(), BT = /* @__PURE__ */ new WeakMap(), UT = /* @__PURE__ */ new WeakMap();
function xA(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function bA(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : xA(J0(t));
}
function vy(t) {
  return jl(t) ? t : xy(t, !1, DT, gA, FT);
}
function wA(t) {
  return xy(t, !1, cA, yA, zT);
}
function $T(t) {
  return xy(t, !0, kT, _A, BT);
}
function uh(t) {
  return xy(t, !0, uA, vA, UT);
}
function xy(t, e, r, n, i) {
  if (!rn(t))
    return process.env.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(t)}`), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  const l = i.get(t);
  if (l)
    return l;
  const h = bA(t);
  if (h === 0)
    return t;
  const s = new Proxy(t, h === 2 ? n : r);
  return i.set(t, s), s;
}
function Aa(t) {
  return jl(t) ? Aa(t.__v_raw) : !!(t && t.__v_isReactive);
}
function jl(t) {
  return !!(t && t.__v_isReadonly);
}
function Eg(t) {
  return !!(t && t.__v_isShallow);
}
function Tg(t) {
  return Aa(t) || jl(t);
}
function ir(t) {
  const e = t && t.__v_raw;
  return e ? ir(e) : t;
}
function Ta(t) {
  return xg(t, "__v_skip", !0), t;
}
const Md = (t) => rn(t) ? vy(t) : t, rx = (t) => rn(t) ? $T(t) : t;
function VT(t) {
  Nl && fo && (t = ir(t), process.env.NODE_ENV !== "production" ? Hv(t.dep || (t.dep = Sd()), {
    target: t,
    type: "get",
    key: "value"
  }) : Hv(t.dep || (t.dep = Sd())));
}
function jT(t, e) {
  t = ir(t);
  const r = t.dep;
  r && (process.env.NODE_ENV !== "production" ? ch(r, {
    target: t,
    type: "set",
    key: "value",
    newValue: e
  }) : ch(r));
}
function tn(t) {
  return !!(t && t.__v_isRef === !0);
}
function Kr(t) {
  return GT(t, !1);
}
function yi(t) {
  return GT(t, !0);
}
function GT(t, e) {
  return tn(t) ? t : new EA(t, e);
}
class EA {
  constructor(e, r) {
    this.__v_isShallow = r, this.dep = void 0, this.__v_isRef = !0, this._rawValue = r ? e : ir(e), this._value = r ? e : Md(e);
  }
  get value() {
    return VT(this), this._value;
  }
  set value(e) {
    const r = this.__v_isShallow || Eg(e) || jl(e);
    e = r ? e : ir(e), Td(e, this._rawValue) && (this._rawValue = e, this._value = r ? e : Md(e), jT(this, e));
  }
}
function _e(t) {
  return tn(t) ? t.value : t;
}
const TA = {
  get: (t, e, r) => _e(Reflect.get(t, e, r)),
  set: (t, e, r, n) => {
    const i = t[e];
    return tn(i) && !tn(r) ? (i.value = r, !0) : Reflect.set(t, e, r, n);
  }
};
function qT(t) {
  return Aa(t) ? t : new Proxy(t, TA);
}
function Ob(t) {
  process.env.NODE_ENV !== "production" && !Tg(t) && console.warn("toRefs() expects a reactive object but received a plain one.");
  const e = Zt(t) ? new Array(t.length) : {};
  for (const r in t)
    e[r] = cd(t, r);
  return e;
}
class SA {
  constructor(e, r, n) {
    this._object = e, this._key = r, this._defaultValue = n, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return KP(ir(this._object), this._key);
  }
}
function cd(t, e, r) {
  const n = t[e];
  return tn(n) ? n : new SA(t, e, r);
}
var WT;
class MA {
  constructor(e, r, n, i) {
    this._setter = r, this.dep = void 0, this.__v_isRef = !0, this[WT] = !1, this._dirty = !0, this.effect = new ex(e, () => {
      this._dirty || (this._dirty = !0, jT(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = n;
  }
  get value() {
    const e = ir(this);
    return VT(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
WT = "__v_isReadonly";
function CA(t, e, r = !1) {
  let n, i;
  const l = ar(t);
  l ? (n = t, i = process.env.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : Ui) : (n = t.get, i = t.set);
  const h = new MA(n, i, l || !i, r);
  return process.env.NODE_ENV !== "production" && e && !r && (h.effect.onTrack = e.onTrack, h.effect.onTrigger = e.onTrigger), h;
}
const Kc = [];
function eg(t) {
  Kc.push(t);
}
function tg() {
  Kc.pop();
}
function st(t, ...e) {
  if (process.env.NODE_ENV === "production")
    return;
  uu();
  const r = Kc.length ? Kc[Kc.length - 1].component : null, n = r && r.appContext.config.warnHandler, i = IA();
  if (n)
    Ns(n, r, 11, [
      t + e.join(""),
      r && r.proxy,
      i.map(({ vnode: l }) => `at <${Iy(r, l.type)}>`).join(`
`),
      i
    ]);
  else {
    const l = [`[Vue warn]: ${t}`, ...e];
    i.length && l.push(`
`, ...PA(i)), console.warn(...l);
  }
  hu();
}
function IA() {
  let t = Kc[Kc.length - 1];
  if (!t)
    return [];
  const e = [];
  for (; t; ) {
    const r = e[0];
    r && r.vnode === t ? r.recurseCount++ : e.push({
      vnode: t,
      recurseCount: 0
    });
    const n = t.component && t.component.parent;
    t = n && n.vnode;
  }
  return e;
}
function PA(t) {
  const e = [];
  return t.forEach((r, n) => {
    e.push(...n === 0 ? [] : [`
`], ...AA(r));
  }), e;
}
function AA({ vnode: t, recurseCount: e }) {
  const r = e > 0 ? `... (${e} recursive calls)` : "", n = t.component ? t.component.parent == null : !1, i = ` at <${Iy(t.component, t.type, n)}`, l = ">" + r;
  return t.props ? [i, ...OA(t.props), l] : [i + l];
}
function OA(t) {
  const e = [], r = Object.keys(t);
  return r.slice(0, 3).forEach((n) => {
    e.push(...XT(n, t[n]));
  }), r.length > 3 && e.push(" ..."), e;
}
function XT(t, e, r) {
  return Nn(e) ? (e = JSON.stringify(e), r ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? r ? e : [`${t}=${e}`] : tn(e) ? (e = XT(t, ir(e.value), !0), r ? e : [`${t}=Ref<`, e, ">"]) : ar(e) ? [`${t}=fn${e.name ? `<${e.name}>` : ""}`] : (e = ir(e), r ? e : [`${t}=`, e]);
}
function RA(t, e) {
  process.env.NODE_ENV !== "production" && t !== void 0 && (typeof t != "number" ? st(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && st(`${e} is NaN - the duration expression might be incorrect.`));
}
const nx = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function Ns(t, e, r, n) {
  let i;
  try {
    i = n ? t(...n) : t();
  } catch (l) {
    by(l, e, r);
  }
  return i;
}
function na(t, e, r, n) {
  if (ar(t)) {
    const l = Ns(t, e, r, n);
    return l && Y0(l) && l.catch((h) => {
      by(h, e, r);
    }), l;
  }
  const i = [];
  for (let l = 0; l < t.length; l++)
    i.push(na(t[l], e, r, n));
  return i;
}
function by(t, e, r, n = !0) {
  const i = e ? e.vnode : null;
  if (e) {
    let l = e.parent;
    const h = e.proxy, s = process.env.NODE_ENV !== "production" ? nx[r] : r;
    for (; l; ) {
      const v = l.ec;
      if (v) {
        for (let E = 0; E < v.length; E++)
          if (v[E](t, h, s) === !1)
            return;
      }
      l = l.parent;
    }
    const m = e.appContext.config.errorHandler;
    if (m) {
      Ns(m, null, 10, [t, h, s]);
      return;
    }
  }
  LA(t, r, i, n);
}
function LA(t, e, r, n = !0) {
  if (process.env.NODE_ENV !== "production") {
    const i = nx[e];
    if (r && eg(r), st(`Unhandled error${i ? ` during execution of ${i}` : ""}`), r && tg(), n)
      throw t;
    console.error(t);
  } else
    console.error(t);
}
let Cd = !1, Kv = !1;
const Ki = [];
let Ka = 0;
const xh = [];
let Za = null, El = 0;
const ZT = /* @__PURE__ */ Promise.resolve();
let ix = null;
const DA = 100;
function Sg(t) {
  const e = ix || ZT;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function kA(t) {
  let e = Ka + 1, r = Ki.length;
  for (; e < r; ) {
    const n = e + r >>> 1;
    Id(Ki[n]) < t ? e = n + 1 : r = n;
  }
  return e;
}
function wy(t) {
  (!Ki.length || !Ki.includes(t, Cd && t.allowRecurse ? Ka + 1 : Ka)) && (t.id == null ? Ki.push(t) : Ki.splice(kA(t.id), 0, t), HT());
}
function HT() {
  !Cd && !Kv && (Kv = !0, ix = ZT.then(JT));
}
function NA(t) {
  const e = Ki.indexOf(t);
  e > Ka && Ki.splice(e, 1);
}
function KT(t) {
  Zt(t) ? xh.push(...t) : (!Za || !Za.includes(t, t.allowRecurse ? El + 1 : El)) && xh.push(t), HT();
}
function Rb(t, e = Cd ? Ka + 1 : 0) {
  for (process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()); e < Ki.length; e++) {
    const r = Ki[e];
    if (r && r.pre) {
      if (process.env.NODE_ENV !== "production" && ox(t, r))
        continue;
      Ki.splice(e, 1), e--, r();
    }
  }
}
function YT(t) {
  if (xh.length) {
    const e = [...new Set(xh)];
    if (xh.length = 0, Za) {
      Za.push(...e);
      return;
    }
    for (Za = e, process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), Za.sort((r, n) => Id(r) - Id(n)), El = 0; El < Za.length; El++)
      process.env.NODE_ENV !== "production" && ox(t, Za[El]) || Za[El]();
    Za = null, El = 0;
  }
}
const Id = (t) => t.id == null ? 1 / 0 : t.id, FA = (t, e) => {
  const r = Id(t) - Id(e);
  if (r === 0) {
    if (t.pre && !e.pre)
      return -1;
    if (e.pre && !t.pre)
      return 1;
  }
  return r;
};
function JT(t) {
  Kv = !1, Cd = !0, process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), Ki.sort(FA);
  const e = process.env.NODE_ENV !== "production" ? (r) => ox(t, r) : Ui;
  try {
    for (Ka = 0; Ka < Ki.length; Ka++) {
      const r = Ki[Ka];
      if (r && r.active !== !1) {
        if (process.env.NODE_ENV !== "production" && e(r))
          continue;
        Ns(r, null, 14);
      }
    }
  } finally {
    Ka = 0, Ki.length = 0, YT(t), Cd = !1, ix = null, (Ki.length || xh.length) && JT(t);
  }
}
function ox(t, e) {
  if (!t.has(e))
    t.set(e, 1);
  else {
    const r = t.get(e);
    if (r > DA) {
      const n = e.ownerInstance, i = n && fx(n.type);
      return st(`Maximum recursive updates exceeded${i ? ` in component <${i}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`), !0;
    } else
      t.set(e, r + 1);
  }
}
let Fl = !1;
const nh = /* @__PURE__ */ new Set();
process.env.NODE_ENV !== "production" && (ST().__VUE_HMR_RUNTIME__ = {
  createRecord: J_(QT),
  rerender: J_(UA),
  reload: J_($A)
});
const nu = /* @__PURE__ */ new Map();
function zA(t) {
  const e = t.type.__hmrId;
  let r = nu.get(e);
  r || (QT(e, t.type), r = nu.get(e)), r.instances.add(t);
}
function BA(t) {
  nu.get(t.type.__hmrId).instances.delete(t);
}
function QT(t, e) {
  return nu.has(t) ? !1 : (nu.set(t, {
    initialDef: ud(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function ud(t) {
  return LS(t) ? t.__vccOpts : t;
}
function UA(t, e) {
  const r = nu.get(t);
  !r || (r.initialDef.render = e, [...r.instances].forEach((n) => {
    e && (n.render = e, ud(n.type).render = e), n.renderCache = [], Fl = !0, n.update(), Fl = !1;
  }));
}
function $A(t, e) {
  const r = nu.get(t);
  if (!r)
    return;
  e = ud(e), Lb(r.initialDef, e);
  const n = [...r.instances];
  for (const i of n) {
    const l = ud(i.type);
    nh.has(l) || (l !== r.initialDef && Lb(l, e), nh.add(l)), i.appContext.optionsCache.delete(i.type), i.ceReload ? (nh.add(l), i.ceReload(e.styles), nh.delete(l)) : i.parent ? wy(i.parent.update) : i.appContext.reload ? i.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
  }
  KT(() => {
    for (const i of n)
      nh.delete(ud(i.type));
  });
}
function Lb(t, e) {
  kn(t, e);
  for (const r in t)
    r !== "__file" && !(r in e) && delete t[r];
}
function J_(t) {
  return (e, r) => {
    try {
      return t(e, r);
    } catch (n) {
      console.error(n), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.");
    }
  };
}
let Ya, ed = [], Yv = !1;
function Vd(t, ...e) {
  Ya ? Ya.emit(t, ...e) : Yv || ed.push({ event: t, args: e });
}
function eS(t, e) {
  var r, n;
  Ya = t, Ya ? (Ya.enabled = !0, ed.forEach(({ event: i, args: l }) => Ya.emit(i, ...l)), ed = []) : typeof window < "u" && window.HTMLElement && !(!((n = (r = window.navigator) === null || r === void 0 ? void 0 : r.userAgent) === null || n === void 0) && n.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((l) => {
    eS(l, e);
  }), setTimeout(() => {
    Ya || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Yv = !0, ed = []);
  }, 3e3)) : (Yv = !0, ed = []);
}
function VA(t, e) {
  Vd("app:init", t, e, {
    Fragment: pn,
    Text: qd,
    Comment: Ii,
    Static: rg
  });
}
function jA(t) {
  Vd("app:unmount", t);
}
const GA = /* @__PURE__ */ ax("component:added"), tS = /* @__PURE__ */ ax("component:updated"), qA = /* @__PURE__ */ ax("component:removed"), WA = (t) => {
  Ya && typeof Ya.cleanupBuffer == "function" && !Ya.cleanupBuffer(t) && qA(t);
};
function ax(t) {
  return (e) => {
    Vd(t, e.appContext.app, e.uid, e.parent ? e.parent.uid : void 0, e);
  };
}
const XA = /* @__PURE__ */ rS("perf:start"), ZA = /* @__PURE__ */ rS("perf:end");
function rS(t) {
  return (e, r, n) => {
    Vd(t, e.appContext.app, e.uid, e, r, n);
  };
}
function HA(t, e, r) {
  Vd("component:emit", t.appContext.app, t, e, r);
}
function KA(t, e, ...r) {
  if (t.isUnmounted)
    return;
  const n = t.vnode.props || dn;
  if (process.env.NODE_ENV !== "production") {
    const { emitsOptions: E, propsOptions: [T] } = t;
    if (E)
      if (!(e in E))
        (!T || !(Bc(e) in T)) && st(`Component emitted event "${e}" but it is neither declared in the emits option nor as an "${Bc(e)}" prop.`);
      else {
        const S = E[e];
        ar(S) && (S(...r) || st(`Invalid event arguments: event validation failed for event "${e}".`));
      }
  }
  let i = r;
  const l = e.startsWith("update:"), h = l && e.slice(7);
  if (h && h in n) {
    const E = `${h === "modelValue" ? "model" : h}Modifiers`, { number: T, trim: S } = n[E] || dn;
    S && (i = r.map((A) => Nn(A) ? A.trim() : A)), T && (i = r.map(qP));
  }
  if (process.env.NODE_ENV !== "production" && HA(t, e, i), process.env.NODE_ENV !== "production") {
    const E = e.toLowerCase();
    E !== e && n[Bc(E)] && st(`Event "${E}" is emitted in component ${Iy(t, t.type)} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Mo(e)}" instead of "${e}".`);
  }
  let s, m = n[s = Bc(e)] || n[s = Bc(Go(e))];
  !m && l && (m = n[s = Bc(Mo(e))]), m && na(m, t, 6, i);
  const v = n[s + "Once"];
  if (v) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[s])
      return;
    t.emitted[s] = !0, na(v, t, 6, i);
  }
}
function nS(t, e, r = !1) {
  const n = e.emitsCache, i = n.get(t);
  if (i !== void 0)
    return i;
  const l = t.emits;
  let h = {}, s = !1;
  if (!ar(t)) {
    const m = (v) => {
      const E = nS(v, e, !0);
      E && (s = !0, kn(h, E));
    };
    !r && e.mixins.length && e.mixins.forEach(m), t.extends && m(t.extends), t.mixins && t.mixins.forEach(m);
  }
  return !l && !s ? (rn(t) && n.set(t, null), null) : (Zt(l) ? l.forEach((m) => h[m] = null) : kn(h, l), rn(t) && n.set(t, h), h);
}
function Ey(t, e) {
  return !t || !$d(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Ar(t, e[0].toLowerCase() + e.slice(1)) || Ar(t, Mo(e)) || Ar(t, e));
}
let _i = null, iS = null;
function Mg(t) {
  const e = _i;
  return _i = t, iS = t && t.type.__scopeId || null, e;
}
function jd(t, e = _i, r) {
  if (!e || t._n)
    return t;
  const n = (...i) => {
    n._d && Xb(-1);
    const l = Mg(e);
    let h;
    try {
      h = t(...i);
    } finally {
      Mg(l), n._d && Xb(1);
    }
    return process.env.NODE_ENV !== "production" && tS(e), h;
  };
  return n._n = !0, n._c = !0, n._d = !0, n;
}
let Jv = !1;
function Cg() {
  Jv = !0;
}
function Q_(t) {
  const { type: e, vnode: r, proxy: n, withProxy: i, props: l, propsOptions: [h], slots: s, attrs: m, emit: v, render: E, renderCache: T, data: S, setupState: A, ctx: L, inheritAttrs: B } = t;
  let j, q;
  const H = Mg(t);
  process.env.NODE_ENV !== "production" && (Jv = !1);
  try {
    if (r.shapeFlag & 4) {
      const he = i || n;
      j = Sa(E.call(he, he, T, l, A, S, L)), q = m;
    } else {
      const he = e;
      process.env.NODE_ENV !== "production" && m === l && Cg(), j = Sa(he.length > 1 ? he(l, process.env.NODE_ENV !== "production" ? {
        get attrs() {
          return Cg(), m;
        },
        slots: s,
        emit: v
      } : { attrs: m, slots: s, emit: v }) : he(l, null)), q = e.props ? m : JA(m);
    }
  } catch (he) {
    dd.length = 0, by(he, t, 1), j = $t(Ii);
  }
  let ne = j, ee;
  if (process.env.NODE_ENV !== "production" && j.patchFlag > 0 && j.patchFlag & 2048 && ([ne, ee] = YA(j)), q && B !== !1) {
    const he = Object.keys(q), { shapeFlag: Te } = ne;
    if (he.length) {
      if (Te & 7)
        h && he.some(vg) && (q = QA(q, h)), ne = as(ne, q);
      else if (process.env.NODE_ENV !== "production" && !Jv && ne.type !== Ii) {
        const ve = Object.keys(m), Oe = [], Me = [];
        for (let Re = 0, He = ve.length; Re < He; Re++) {
          const Ve = ve[Re];
          $d(Ve) ? vg(Ve) || Oe.push(Ve[2].toLowerCase() + Ve.slice(3)) : Me.push(Ve);
        }
        Me.length && st(`Extraneous non-props attributes (${Me.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`), Oe.length && st(`Extraneous non-emits event listeners (${Oe.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
      }
    }
  }
  return r.dirs && (process.env.NODE_ENV !== "production" && !Db(ne) && st("Runtime directive used on component with non-element root node. The directives will not function as intended."), ne = as(ne), ne.dirs = ne.dirs ? ne.dirs.concat(r.dirs) : r.dirs), r.transition && (process.env.NODE_ENV !== "production" && !Db(ne) && st("Component inside <Transition> renders non-element root node that cannot be animated."), ne.transition = r.transition), process.env.NODE_ENV !== "production" && ee ? ee(ne) : j = ne, Mg(H), j;
}
const YA = (t) => {
  const e = t.children, r = t.dynamicChildren, n = oS(e);
  if (!n)
    return [t, void 0];
  const i = e.indexOf(n), l = r ? r.indexOf(n) : -1, h = (s) => {
    e[i] = s, r && (l > -1 ? r[l] = s : s.patchFlag > 0 && (t.dynamicChildren = [...r, s]));
  };
  return [Sa(n), h];
};
function oS(t) {
  let e;
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (Rh(n)) {
      if (n.type !== Ii || n.children === "v-if") {
        if (e)
          return;
        e = n;
      }
    } else
      return;
  }
  return e;
}
const JA = (t) => {
  let e;
  for (const r in t)
    (r === "class" || r === "style" || $d(r)) && ((e || (e = {}))[r] = t[r]);
  return e;
}, QA = (t, e) => {
  const r = {};
  for (const n in t)
    (!vg(n) || !(n.slice(9) in e)) && (r[n] = t[n]);
  return r;
}, Db = (t) => t.shapeFlag & 7 || t.type === Ii;
function eO(t, e, r) {
  const { props: n, children: i, component: l } = t, { props: h, children: s, patchFlag: m } = e, v = l.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (i || s) && Fl || e.dirs || e.transition)
    return !0;
  if (r && m >= 0) {
    if (m & 1024)
      return !0;
    if (m & 16)
      return n ? kb(n, h, v) : !!h;
    if (m & 8) {
      const E = e.dynamicProps;
      for (let T = 0; T < E.length; T++) {
        const S = E[T];
        if (h[S] !== n[S] && !Ey(v, S))
          return !0;
      }
    }
  } else
    return (i || s) && (!s || !s.$stable) ? !0 : n === h ? !1 : n ? h ? kb(n, h, v) : !0 : !!h;
  return !1;
}
function kb(t, e, r) {
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !0;
  for (let i = 0; i < n.length; i++) {
    const l = n[i];
    if (e[l] !== t[l] && !Ey(r, l))
      return !0;
  }
  return !1;
}
function tO({ vnode: t, parent: e }, r) {
  for (; e && e.subTree === t; )
    (t = e.vnode).el = r, e = e.parent;
}
const rO = (t) => t.__isSuspense;
function nO(t, e) {
  e && e.pendingBranch ? Zt(t) ? e.effects.push(...t) : e.effects.push(t) : KT(t);
}
function aS(t, e) {
  if (!Zn)
    process.env.NODE_ENV !== "production" && st("provide() can only be used inside setup().");
  else {
    let r = Zn.provides;
    const n = Zn.parent && Zn.parent.provides;
    n === r && (r = Zn.provides = Object.create(n)), r[t] = e;
  }
}
function bh(t, e, r = !1) {
  const n = Zn || _i;
  if (n) {
    const i = n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides;
    if (i && t in i)
      return i[t];
    if (arguments.length > 1)
      return r && ar(e) ? e.call(n.proxy) : e;
    process.env.NODE_ENV !== "production" && st(`injection "${String(t)}" not found.`);
  } else
    process.env.NODE_ENV !== "production" && st("inject() can only be used inside setup() or functional components.");
}
function Da(t, e) {
  return sx(t, null, e);
}
const Tm = {};
function An(t, e, r) {
  return process.env.NODE_ENV !== "production" && !ar(e) && st("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), sx(t, e, r);
}
function sx(t, e, { immediate: r, deep: n, flush: i, onTrack: l, onTrigger: h } = dn) {
  process.env.NODE_ENV !== "production" && !e && (r !== void 0 && st('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), n !== void 0 && st('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));
  const s = (ee) => {
    st("Invalid watch source: ", ee, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.");
  }, m = IT() === (Zn == null ? void 0 : Zn.scope) ? Zn : null;
  let v, E = !1, T = !1;
  if (tn(t) ? (v = () => t.value, E = Eg(t)) : Aa(t) ? (v = () => t, n = !0) : Zt(t) ? (T = !0, E = t.some((ee) => Aa(ee) || Eg(ee)), v = () => t.map((ee) => {
    if (tn(ee))
      return ee.value;
    if (Aa(ee))
      return Wc(ee);
    if (ar(ee))
      return Ns(ee, m, 2);
    process.env.NODE_ENV !== "production" && s(ee);
  })) : ar(t) ? e ? v = () => Ns(t, m, 2) : v = () => {
    if (!(m && m.isUnmounted))
      return S && S(), na(t, m, 3, [A]);
  } : (v = Ui, process.env.NODE_ENV !== "production" && s(t)), e && n) {
    const ee = v;
    v = () => Wc(ee());
  }
  let S, A = (ee) => {
    S = H.onStop = () => {
      Ns(ee, m, 4);
    };
  }, L;
  if (Ad)
    if (A = Ui, e ? r && na(e, m, 3, [
      v(),
      T ? [] : void 0,
      A
    ]) : v(), i === "sync") {
      const ee = fR();
      L = ee.__watcherHandles || (ee.__watcherHandles = []);
    } else
      return Ui;
  let B = T ? new Array(t.length).fill(Tm) : Tm;
  const j = () => {
    if (!!H.active)
      if (e) {
        const ee = H.run();
        (n || E || (T ? ee.some((he, Te) => Td(he, B[Te])) : Td(ee, B))) && (S && S(), na(e, m, 3, [
          ee,
          B === Tm ? void 0 : T && B[0] === Tm ? [] : B,
          A
        ]), B = ee);
      } else
        H.run();
  };
  j.allowRecurse = !!e;
  let q;
  i === "sync" ? q = j : i === "post" ? q = () => Eo(j, m && m.suspense) : (j.pre = !0, m && (j.id = m.uid), q = () => wy(j));
  const H = new ex(v, q);
  process.env.NODE_ENV !== "production" && (H.onTrack = l, H.onTrigger = h), e ? r ? j() : B = H.run() : i === "post" ? Eo(H.run.bind(H), m && m.suspense) : H.run();
  const ne = () => {
    H.stop(), m && m.scope && H0(m.scope.effects, H);
  };
  return L && L.push(ne), ne;
}
function iO(t, e, r) {
  const n = this.proxy, i = Nn(t) ? t.includes(".") ? sS(n, t) : () => n[t] : t.bind(n, n);
  let l;
  ar(e) ? l = e : (l = e.handler, r = e);
  const h = Zn;
  Lh(this);
  const s = sx(i, l.bind(n), r);
  return h ? Lh(h) : Jc(), s;
}
function sS(t, e) {
  const r = e.split(".");
  return () => {
    let n = t;
    for (let i = 0; i < r.length && n; i++)
      n = n[r[i]];
    return n;
  };
}
function Wc(t, e) {
  if (!rn(t) || t.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(t)))
    return t;
  if (e.add(t), tn(t))
    Wc(t.value, e);
  else if (Zt(t))
    for (let r = 0; r < t.length; r++)
      Wc(t[r], e);
  else if (wT(t) || Zc(t))
    t.forEach((r) => {
      Wc(r, e);
    });
  else if (TT(t))
    for (const r in t)
      Wc(t[r], e);
  return t;
}
function oO() {
  const t = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return aa(() => {
    t.isMounted = !0;
  }), fS(() => {
    t.isUnmounting = !0;
  }), t;
}
const Jo = [Function, Array], aO = {
  name: "BaseTransition",
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Jo,
    onEnter: Jo,
    onAfterEnter: Jo,
    onEnterCancelled: Jo,
    onBeforeLeave: Jo,
    onLeave: Jo,
    onAfterLeave: Jo,
    onLeaveCancelled: Jo,
    onBeforeAppear: Jo,
    onAppear: Jo,
    onAfterAppear: Jo,
    onAppearCancelled: Jo
  },
  setup(t, { slots: e }) {
    const r = My(), n = oO();
    let i;
    return () => {
      const l = e.default && uS(e.default(), !0);
      if (!l || !l.length)
        return;
      let h = l[0];
      if (l.length > 1) {
        let B = !1;
        for (const j of l)
          if (j.type !== Ii) {
            if (process.env.NODE_ENV !== "production" && B) {
              st("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
              break;
            }
            if (h = j, B = !0, process.env.NODE_ENV === "production")
              break;
          }
      }
      const s = ir(t), { mode: m } = s;
      if (process.env.NODE_ENV !== "production" && m && m !== "in-out" && m !== "out-in" && m !== "default" && st(`invalid <transition> mode: ${m}`), n.isLeaving)
        return ev(h);
      const v = Nb(h);
      if (!v)
        return ev(h);
      const E = Qv(v, s, n, r);
      e0(v, E);
      const T = r.subTree, S = T && Nb(T);
      let A = !1;
      const { getTransitionKey: L } = v.type;
      if (L) {
        const B = L();
        i === void 0 ? i = B : B !== i && (i = B, A = !0);
      }
      if (S && S.type !== Ii && (!jc(v, S) || A)) {
        const B = Qv(S, s, n, r);
        if (e0(S, B), m === "out-in")
          return n.isLeaving = !0, B.afterLeave = () => {
            n.isLeaving = !1, r.update.active !== !1 && r.update();
          }, ev(h);
        m === "in-out" && v.type !== Ii && (B.delayLeave = (j, q, H) => {
          const ne = cS(n, S);
          ne[String(S.key)] = S, j._leaveCb = () => {
            q(), j._leaveCb = void 0, delete E.delayedLeave;
          }, E.delayedLeave = H;
        });
      }
      return h;
    };
  }
}, lS = aO;
function cS(t, e) {
  const { leavingVNodes: r } = t;
  let n = r.get(e.type);
  return n || (n = /* @__PURE__ */ Object.create(null), r.set(e.type, n)), n;
}
function Qv(t, e, r, n) {
  const { appear: i, mode: l, persisted: h = !1, onBeforeEnter: s, onEnter: m, onAfterEnter: v, onEnterCancelled: E, onBeforeLeave: T, onLeave: S, onAfterLeave: A, onLeaveCancelled: L, onBeforeAppear: B, onAppear: j, onAfterAppear: q, onAppearCancelled: H } = e, ne = String(t.key), ee = cS(r, t), he = (Oe, Me) => {
    Oe && na(Oe, n, 9, Me);
  }, Te = (Oe, Me) => {
    const Re = Me[1];
    he(Oe, Me), Zt(Oe) ? Oe.every((He) => He.length <= 1) && Re() : Oe.length <= 1 && Re();
  }, ve = {
    mode: l,
    persisted: h,
    beforeEnter(Oe) {
      let Me = s;
      if (!r.isMounted)
        if (i)
          Me = B || s;
        else
          return;
      Oe._leaveCb && Oe._leaveCb(!0);
      const Re = ee[ne];
      Re && jc(t, Re) && Re.el._leaveCb && Re.el._leaveCb(), he(Me, [Oe]);
    },
    enter(Oe) {
      let Me = m, Re = v, He = E;
      if (!r.isMounted)
        if (i)
          Me = j || m, Re = q || v, He = H || E;
        else
          return;
      let Ve = !1;
      const dt = Oe._enterCb = (xe) => {
        Ve || (Ve = !0, xe ? he(He, [Oe]) : he(Re, [Oe]), ve.delayedLeave && ve.delayedLeave(), Oe._enterCb = void 0);
      };
      Me ? Te(Me, [Oe, dt]) : dt();
    },
    leave(Oe, Me) {
      const Re = String(t.key);
      if (Oe._enterCb && Oe._enterCb(!0), r.isUnmounting)
        return Me();
      he(T, [Oe]);
      let He = !1;
      const Ve = Oe._leaveCb = (dt) => {
        He || (He = !0, Me(), dt ? he(L, [Oe]) : he(A, [Oe]), Oe._leaveCb = void 0, ee[Re] === t && delete ee[Re]);
      };
      ee[Re] = t, S ? Te(S, [Oe, Ve]) : Ve();
    },
    clone(Oe) {
      return Qv(Oe, e, r, n);
    }
  };
  return ve;
}
function ev(t) {
  if (Gd(t))
    return t = as(t), t.children = null, t;
}
function Nb(t) {
  return Gd(t) ? t.children ? t.children[0] : void 0 : t;
}
function e0(t, e) {
  t.shapeFlag & 6 && t.component ? e0(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
}
function uS(t, e = !1, r) {
  let n = [], i = 0;
  for (let l = 0; l < t.length; l++) {
    let h = t[l];
    const s = r == null ? h.key : String(r) + String(h.key != null ? h.key : l);
    h.type === pn ? (h.patchFlag & 128 && i++, n = n.concat(uS(h.children, e, s))) : (e || h.type !== Ii) && n.push(s != null ? as(h, { key: s }) : h);
  }
  if (i > 1)
    for (let l = 0; l < n.length; l++)
      n[l].patchFlag = -2;
  return n;
}
function vr(t) {
  return ar(t) ? { setup: t, name: t.name } : t;
}
const hd = (t) => !!t.type.__asyncLoader, Gd = (t) => t.type.__isKeepAlive;
function sO(t, e) {
  hS(t, "a", e);
}
function lO(t, e) {
  hS(t, "da", e);
}
function hS(t, e, r = Zn) {
  const n = t.__wdc || (t.__wdc = () => {
    let i = r;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return t();
  });
  if (Ty(e, n, r), r) {
    let i = r.parent;
    for (; i && i.parent; )
      Gd(i.parent.vnode) && cO(n, e, r, i), i = i.parent;
  }
}
function cO(t, e, r, n) {
  const i = Ty(e, t, n, !0);
  fu(() => {
    H0(n[e], i);
  }, r);
}
function Ty(t, e, r = Zn, n = !1) {
  if (r) {
    const i = r[t] || (r[t] = []), l = e.__weh || (e.__weh = (...h) => {
      if (r.isUnmounted)
        return;
      uu(), Lh(r);
      const s = na(e, r, t, h);
      return Jc(), hu(), s;
    });
    return n ? i.unshift(l) : i.push(l), l;
  } else if (process.env.NODE_ENV !== "production") {
    const i = Bc(nx[t].replace(/ hook$/, ""));
    st(`${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const qs = (t) => (e, r = Zn) => (!Ad || t === "sp") && Ty(t, (...n) => e(...n), r), uO = qs("bm"), aa = qs("m"), hO = qs("bu"), fO = qs("u"), fS = qs("bum"), fu = qs("um"), dO = qs("sp"), pO = qs("rtg"), mO = qs("rtc");
function gO(t, e = Zn) {
  Ty("ec", t, e);
}
function dS(t) {
  VP(t) && st("Do not use built-in directive ids as custom directive id: " + t);
}
function Fb(t, e) {
  const r = _i;
  if (r === null)
    return process.env.NODE_ENV !== "production" && st("withDirectives can only be used inside render functions."), t;
  const n = Cy(r) || r.proxy, i = t.dirs || (t.dirs = []);
  for (let l = 0; l < e.length; l++) {
    let [h, s, m, v = dn] = e[l];
    h && (ar(h) && (h = {
      mounted: h,
      updated: h
    }), h.deep && Wc(s), i.push({
      dir: h,
      instance: n,
      value: s,
      oldValue: void 0,
      arg: m,
      modifiers: v
    }));
  }
  return t;
}
function Pc(t, e, r, n) {
  const i = t.dirs, l = e && e.dirs;
  for (let h = 0; h < i.length; h++) {
    const s = i[h];
    l && (s.oldValue = l[h].value);
    let m = s.dir[n];
    m && (uu(), na(m, r, 8, [
      t.el,
      s,
      t,
      e
    ]), hu());
  }
}
const t0 = "components", yO = "directives";
function _O(t, e) {
  return pS(t0, t, !0, e) || t;
}
const vO = Symbol();
function xO(t) {
  return pS(yO, t);
}
function pS(t, e, r = !0, n = !1) {
  const i = _i || Zn;
  if (i) {
    const l = i.type;
    if (t === t0) {
      const s = fx(l, !1);
      if (s && (s === e || s === Go(e) || s === ru(Go(e))))
        return l;
    }
    const h = zb(i[t] || l[t], e) || zb(i.appContext[t], e);
    if (!h && n)
      return l;
    if (process.env.NODE_ENV !== "production" && r && !h) {
      const s = t === t0 ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      st(`Failed to resolve ${t.slice(0, -1)}: ${e}${s}`);
    }
    return h;
  } else
    process.env.NODE_ENV !== "production" && st(`resolve${ru(t.slice(0, -1))} can only be used in render() or setup().`);
}
function zb(t, e) {
  return t && (t[e] || t[Go(e)] || t[ru(Go(e))]);
}
function ka(t, e, r, n) {
  let i;
  const l = r && r[n];
  if (Zt(t) || Nn(t)) {
    i = new Array(t.length);
    for (let h = 0, s = t.length; h < s; h++)
      i[h] = e(t[h], h, void 0, l && l[h]);
  } else if (typeof t == "number") {
    process.env.NODE_ENV !== "production" && !Number.isInteger(t) && st(`The v-for range expect an integer value but got ${t}.`), i = new Array(t);
    for (let h = 0; h < t; h++)
      i[h] = e(h + 1, h, void 0, l && l[h]);
  } else if (rn(t))
    if (t[Symbol.iterator])
      i = Array.from(t, (h, s) => e(h, s, void 0, l && l[s]));
    else {
      const h = Object.keys(t);
      i = new Array(h.length);
      for (let s = 0, m = h.length; s < m; s++) {
        const v = h[s];
        i[s] = e(t[v], v, s, l && l[s]);
      }
    }
  else
    i = [];
  return r && (r[n] = i), i;
}
function bO(t, e, r = {}, n, i) {
  if (_i.isCE || _i.parent && hd(_i.parent) && _i.parent.isCE)
    return e !== "default" && (r.name = e), $t("slot", r, n && n());
  let l = t[e];
  process.env.NODE_ENV !== "production" && l && l.length > 1 && (st("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."), l = () => []), l && l._c && (l._d = !1), tt();
  const h = l && mS(l(r)), s = Un(pn, {
    key: r.key || h && h.key || `_${e}`
  }, h || (n ? n() : []), h && t._ === 1 ? 64 : -2);
  return !i && s.scopeId && (s.slotScopeIds = [s.scopeId + "-s"]), l && l._c && (l._d = !0), s;
}
function mS(t) {
  return t.some((e) => Rh(e) ? !(e.type === Ii || e.type === pn && !mS(e.children)) : !0) ? t : null;
}
const r0 = (t) => t ? OS(t) ? Cy(t) || t.proxy : r0(t.parent) : null, Yc = /* @__PURE__ */ kn(/* @__PURE__ */ Object.create(null), {
  $: (t) => t,
  $el: (t) => t.vnode.el,
  $data: (t) => t.data,
  $props: (t) => process.env.NODE_ENV !== "production" ? uh(t.props) : t.props,
  $attrs: (t) => process.env.NODE_ENV !== "production" ? uh(t.attrs) : t.attrs,
  $slots: (t) => process.env.NODE_ENV !== "production" ? uh(t.slots) : t.slots,
  $refs: (t) => process.env.NODE_ENV !== "production" ? uh(t.refs) : t.refs,
  $parent: (t) => r0(t.parent),
  $root: (t) => r0(t.root),
  $emit: (t) => t.emit,
  $options: (t) => cx(t),
  $forceUpdate: (t) => t.f || (t.f = () => wy(t.update)),
  $nextTick: (t) => t.n || (t.n = Sg.bind(t.proxy)),
  $watch: (t) => iO.bind(t)
}), lx = (t) => t === "_" || t === "$", tv = (t, e) => t !== dn && !t.__isScriptSetup && Ar(t, e), gS = {
  get({ _: t }, e) {
    const { ctx: r, setupState: n, data: i, props: l, accessCache: h, type: s, appContext: m } = t;
    if (process.env.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let v;
    if (e[0] !== "$") {
      const A = h[e];
      if (A !== void 0)
        switch (A) {
          case 1:
            return n[e];
          case 2:
            return i[e];
          case 4:
            return r[e];
          case 3:
            return l[e];
        }
      else {
        if (tv(n, e))
          return h[e] = 1, n[e];
        if (i !== dn && Ar(i, e))
          return h[e] = 2, i[e];
        if ((v = t.propsOptions[0]) && Ar(v, e))
          return h[e] = 3, l[e];
        if (r !== dn && Ar(r, e))
          return h[e] = 4, r[e];
        n0 && (h[e] = 0);
      }
    }
    const E = Yc[e];
    let T, S;
    if (E)
      return e === "$attrs" && (mo(t, "get", e), process.env.NODE_ENV !== "production" && Cg()), E(t);
    if ((T = s.__cssModules) && (T = T[e]))
      return T;
    if (r !== dn && Ar(r, e))
      return h[e] = 4, r[e];
    if (S = m.config.globalProperties, Ar(S, e))
      return S[e];
    process.env.NODE_ENV !== "production" && _i && (!Nn(e) || e.indexOf("__v") !== 0) && (i !== dn && lx(e[0]) && Ar(i, e) ? st(`Property ${JSON.stringify(e)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`) : t === _i && st(`Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`));
  },
  set({ _: t }, e, r) {
    const { data: n, setupState: i, ctx: l } = t;
    return tv(i, e) ? (i[e] = r, !0) : process.env.NODE_ENV !== "production" && i.__isScriptSetup && Ar(i, e) ? (st(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : n !== dn && Ar(n, e) ? (n[e] = r, !0) : Ar(t.props, e) ? (process.env.NODE_ENV !== "production" && st(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (process.env.NODE_ENV !== "production" && st(`Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`), !1) : (process.env.NODE_ENV !== "production" && e in t.appContext.config.globalProperties ? Object.defineProperty(l, e, {
      enumerable: !0,
      configurable: !0,
      value: r
    }) : l[e] = r, !0);
  },
  has({ _: { data: t, setupState: e, accessCache: r, ctx: n, appContext: i, propsOptions: l } }, h) {
    let s;
    return !!r[h] || t !== dn && Ar(t, h) || tv(e, h) || (s = l[0]) && Ar(s, h) || Ar(n, h) || Ar(Yc, h) || Ar(i.config.globalProperties, h);
  },
  defineProperty(t, e, r) {
    return r.get != null ? t._.accessCache[e] = 0 : Ar(r, "value") && this.set(t, e, r.value, null), Reflect.defineProperty(t, e, r);
  }
};
process.env.NODE_ENV !== "production" && (gS.ownKeys = (t) => (st("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."), Reflect.ownKeys(t)));
function wO(t) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => t
  }), Object.keys(Yc).forEach((r) => {
    Object.defineProperty(e, r, {
      configurable: !0,
      enumerable: !1,
      get: () => Yc[r](t),
      set: Ui
    });
  }), e;
}
function EO(t) {
  const { ctx: e, propsOptions: [r] } = t;
  r && Object.keys(r).forEach((n) => {
    Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[n],
      set: Ui
    });
  });
}
function TO(t) {
  const { ctx: e, setupState: r } = t;
  Object.keys(ir(r)).forEach((n) => {
    if (!r.__isScriptSetup) {
      if (lx(n[0])) {
        st(`setup() return property ${JSON.stringify(n)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(e, n, {
        enumerable: !0,
        configurable: !0,
        get: () => r[n],
        set: Ui
      });
    }
  });
}
function SO() {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, r) => {
    t[r] ? st(`${e} property "${r}" is already defined in ${t[r]}.`) : t[r] = e;
  };
}
let n0 = !0;
function MO(t) {
  const e = cx(t), r = t.proxy, n = t.ctx;
  n0 = !1, e.beforeCreate && Bb(e.beforeCreate, t, "bc");
  const {
    data: i,
    computed: l,
    methods: h,
    watch: s,
    provide: m,
    inject: v,
    created: E,
    beforeMount: T,
    mounted: S,
    beforeUpdate: A,
    updated: L,
    activated: B,
    deactivated: j,
    beforeDestroy: q,
    beforeUnmount: H,
    destroyed: ne,
    unmounted: ee,
    render: he,
    renderTracked: Te,
    renderTriggered: ve,
    errorCaptured: Oe,
    serverPrefetch: Me,
    expose: Re,
    inheritAttrs: He,
    components: Ve,
    directives: dt,
    filters: xe
  } = e, ze = process.env.NODE_ENV !== "production" ? SO() : null;
  if (process.env.NODE_ENV !== "production") {
    const [Ye] = t.propsOptions;
    if (Ye)
      for (const it in Ye)
        ze("Props", it);
  }
  if (v && CO(v, n, ze, t.appContext.config.unwrapInjectedRef), h)
    for (const Ye in h) {
      const it = h[Ye];
      ar(it) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(n, Ye, {
        value: it.bind(r),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : n[Ye] = it.bind(r), process.env.NODE_ENV !== "production" && ze("Methods", Ye)) : process.env.NODE_ENV !== "production" && st(`Method "${Ye}" has type "${typeof it}" in the component definition. Did you reference the function correctly?`);
    }
  if (i) {
    process.env.NODE_ENV !== "production" && !ar(i) && st("The data option must be a function. Plain object usage is no longer supported.");
    const Ye = i.call(r, r);
    if (process.env.NODE_ENV !== "production" && Y0(Ye) && st("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."), !rn(Ye))
      process.env.NODE_ENV !== "production" && st("data() should return an object.");
    else if (t.data = vy(Ye), process.env.NODE_ENV !== "production")
      for (const it in Ye)
        ze("Data", it), lx(it[0]) || Object.defineProperty(n, it, {
          configurable: !0,
          enumerable: !0,
          get: () => Ye[it],
          set: Ui
        });
  }
  if (n0 = !0, l)
    for (const Ye in l) {
      const it = l[Ye], kt = ar(it) ? it.bind(r, r) : ar(it.get) ? it.get.bind(r, r) : Ui;
      process.env.NODE_ENV !== "production" && kt === Ui && st(`Computed property "${Ye}" has no getter.`);
      const Er = !ar(it) && ar(it.set) ? it.set.bind(r) : process.env.NODE_ENV !== "production" ? () => {
        st(`Write operation failed: computed property "${Ye}" is readonly.`);
      } : Ui, mr = un({
        get: kt,
        set: Er
      });
      Object.defineProperty(n, Ye, {
        enumerable: !0,
        configurable: !0,
        get: () => mr.value,
        set: (Yt) => mr.value = Yt
      }), process.env.NODE_ENV !== "production" && ze("Computed", Ye);
    }
  if (s)
    for (const Ye in s)
      yS(s[Ye], n, r, Ye);
  if (m) {
    const Ye = ar(m) ? m.call(r) : m;
    Reflect.ownKeys(Ye).forEach((it) => {
      aS(it, Ye[it]);
    });
  }
  E && Bb(E, t, "c");
  function Pe(Ye, it) {
    Zt(it) ? it.forEach((kt) => Ye(kt.bind(r))) : it && Ye(it.bind(r));
  }
  if (Pe(uO, T), Pe(aa, S), Pe(hO, A), Pe(fO, L), Pe(sO, B), Pe(lO, j), Pe(gO, Oe), Pe(mO, Te), Pe(pO, ve), Pe(fS, H), Pe(fu, ee), Pe(dO, Me), Zt(Re))
    if (Re.length) {
      const Ye = t.exposed || (t.exposed = {});
      Re.forEach((it) => {
        Object.defineProperty(Ye, it, {
          get: () => r[it],
          set: (kt) => r[it] = kt
        });
      });
    } else
      t.exposed || (t.exposed = {});
  he && t.render === Ui && (t.render = he), He != null && (t.inheritAttrs = He), Ve && (t.components = Ve), dt && (t.directives = dt);
}
function CO(t, e, r = Ui, n = !1) {
  Zt(t) && (t = i0(t));
  for (const i in t) {
    const l = t[i];
    let h;
    rn(l) ? "default" in l ? h = bh(l.from || i, l.default, !0) : h = bh(l.from || i) : h = bh(l), tn(h) ? n ? Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => h.value,
      set: (s) => h.value = s
    }) : (process.env.NODE_ENV !== "production" && st(`injected property "${i}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`), e[i] = h) : e[i] = h, process.env.NODE_ENV !== "production" && r("Inject", i);
  }
}
function Bb(t, e, r) {
  na(Zt(t) ? t.map((n) => n.bind(e.proxy)) : t.bind(e.proxy), e, r);
}
function yS(t, e, r, n) {
  const i = n.includes(".") ? sS(r, n) : () => r[n];
  if (Nn(t)) {
    const l = e[t];
    ar(l) ? An(i, l) : process.env.NODE_ENV !== "production" && st(`Invalid watch handler specified by key "${t}"`, l);
  } else if (ar(t))
    An(i, t.bind(r));
  else if (rn(t))
    if (Zt(t))
      t.forEach((l) => yS(l, e, r, n));
    else {
      const l = ar(t.handler) ? t.handler.bind(r) : e[t.handler];
      ar(l) ? An(i, l, t) : process.env.NODE_ENV !== "production" && st(`Invalid watch handler specified by key "${t.handler}"`, l);
    }
  else
    process.env.NODE_ENV !== "production" && st(`Invalid watch option: "${n}"`, t);
}
function cx(t) {
  const e = t.type, { mixins: r, extends: n } = e, { mixins: i, optionsCache: l, config: { optionMergeStrategies: h } } = t.appContext, s = l.get(e);
  let m;
  return s ? m = s : !i.length && !r && !n ? m = e : (m = {}, i.length && i.forEach((v) => Ig(m, v, h, !0)), Ig(m, e, h)), rn(e) && l.set(e, m), m;
}
function Ig(t, e, r, n = !1) {
  const { mixins: i, extends: l } = e;
  l && Ig(t, l, r, !0), i && i.forEach((h) => Ig(t, h, r, !0));
  for (const h in e)
    if (n && h === "expose")
      process.env.NODE_ENV !== "production" && st('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');
    else {
      const s = IO[h] || r && r[h];
      t[h] = s ? s(t[h], e[h]) : e[h];
    }
  return t;
}
const IO = {
  data: Ub,
  props: Uc,
  emits: Uc,
  methods: Uc,
  computed: Uc,
  beforeCreate: co,
  created: co,
  beforeMount: co,
  mounted: co,
  beforeUpdate: co,
  updated: co,
  beforeDestroy: co,
  beforeUnmount: co,
  destroyed: co,
  unmounted: co,
  activated: co,
  deactivated: co,
  errorCaptured: co,
  serverPrefetch: co,
  components: Uc,
  directives: Uc,
  watch: AO,
  provide: Ub,
  inject: PO
};
function Ub(t, e) {
  return e ? t ? function() {
    return kn(ar(t) ? t.call(this, this) : t, ar(e) ? e.call(this, this) : e);
  } : e : t;
}
function PO(t, e) {
  return Uc(i0(t), i0(e));
}
function i0(t) {
  if (Zt(t)) {
    const e = {};
    for (let r = 0; r < t.length; r++)
      e[t[r]] = t[r];
    return e;
  }
  return t;
}
function co(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function Uc(t, e) {
  return t ? kn(kn(/* @__PURE__ */ Object.create(null), t), e) : e;
}
function AO(t, e) {
  if (!t)
    return e;
  if (!e)
    return t;
  const r = kn(/* @__PURE__ */ Object.create(null), t);
  for (const n in e)
    r[n] = co(t[n], e[n]);
  return r;
}
function OO(t, e, r, n = !1) {
  const i = {}, l = {};
  xg(l, Sy, 1), t.propsDefaults = /* @__PURE__ */ Object.create(null), _S(t, e, i, l);
  for (const h in t.propsOptions[0])
    h in i || (i[h] = void 0);
  process.env.NODE_ENV !== "production" && xS(e || {}, i, t), r ? t.props = n ? i : wA(i) : t.type.props ? t.props = i : t.props = l, t.attrs = l;
}
function RO(t) {
  for (; t; ) {
    if (t.type.__hmrId)
      return !0;
    t = t.parent;
  }
}
function LO(t, e, r, n) {
  const { props: i, attrs: l, vnode: { patchFlag: h } } = t, s = ir(i), [m] = t.propsOptions;
  let v = !1;
  if (!(process.env.NODE_ENV !== "production" && RO(t)) && (n || h > 0) && !(h & 16)) {
    if (h & 8) {
      const E = t.vnode.dynamicProps;
      for (let T = 0; T < E.length; T++) {
        let S = E[T];
        if (Ey(t.emitsOptions, S))
          continue;
        const A = e[S];
        if (m)
          if (Ar(l, S))
            A !== l[S] && (l[S] = A, v = !0);
          else {
            const L = Go(S);
            i[L] = o0(m, s, L, A, t, !1);
          }
        else
          A !== l[S] && (l[S] = A, v = !0);
      }
    }
  } else {
    _S(t, e, i, l) && (v = !0);
    let E;
    for (const T in s)
      (!e || !Ar(e, T) && ((E = Mo(T)) === T || !Ar(e, E))) && (m ? r && (r[T] !== void 0 || r[E] !== void 0) && (i[T] = o0(m, s, T, void 0, t, !0)) : delete i[T]);
    if (l !== s)
      for (const T in l)
        (!e || !Ar(e, T) && !0) && (delete l[T], v = !0);
  }
  v && Vs(t, "set", "$attrs"), process.env.NODE_ENV !== "production" && xS(e || {}, i, t);
}
function _S(t, e, r, n) {
  const [i, l] = t.propsOptions;
  let h = !1, s;
  if (e)
    for (let m in e) {
      if (Qm(m))
        continue;
      const v = e[m];
      let E;
      i && Ar(i, E = Go(m)) ? !l || !l.includes(E) ? r[E] = v : (s || (s = {}))[E] = v : Ey(t.emitsOptions, m) || (!(m in n) || v !== n[m]) && (n[m] = v, h = !0);
    }
  if (l) {
    const m = ir(r), v = s || dn;
    for (let E = 0; E < l.length; E++) {
      const T = l[E];
      r[T] = o0(i, m, T, v[T], t, !Ar(v, T));
    }
  }
  return h;
}
function o0(t, e, r, n, i, l) {
  const h = t[r];
  if (h != null) {
    const s = Ar(h, "default");
    if (s && n === void 0) {
      const m = h.default;
      if (h.type !== Function && ar(m)) {
        const { propsDefaults: v } = i;
        r in v ? n = v[r] : (Lh(i), n = v[r] = m.call(null, e), Jc());
      } else
        n = m;
    }
    h[0] && (l && !s ? n = !1 : h[1] && (n === "" || n === Mo(r)) && (n = !0));
  }
  return n;
}
function vS(t, e, r = !1) {
  const n = e.propsCache, i = n.get(t);
  if (i)
    return i;
  const l = t.props, h = {}, s = [];
  let m = !1;
  if (!ar(t)) {
    const E = (T) => {
      m = !0;
      const [S, A] = vS(T, e, !0);
      kn(h, S), A && s.push(...A);
    };
    !r && e.mixins.length && e.mixins.forEach(E), t.extends && E(t.extends), t.mixins && t.mixins.forEach(E);
  }
  if (!l && !m)
    return rn(t) && n.set(t, vh), vh;
  if (Zt(l))
    for (let E = 0; E < l.length; E++) {
      process.env.NODE_ENV !== "production" && !Nn(l[E]) && st("props must be strings when using array syntax.", l[E]);
      const T = Go(l[E]);
      $b(T) && (h[T] = dn);
    }
  else if (l) {
    process.env.NODE_ENV !== "production" && !rn(l) && st("invalid props options", l);
    for (const E in l) {
      const T = Go(E);
      if ($b(T)) {
        const S = l[E], A = h[T] = Zt(S) || ar(S) ? { type: S } : Object.assign({}, S);
        if (A) {
          const L = jb(Boolean, A.type), B = jb(String, A.type);
          A[0] = L > -1, A[1] = B < 0 || L < B, (L > -1 || Ar(A, "default")) && s.push(T);
        }
      }
    }
  }
  const v = [h, s];
  return rn(t) && n.set(t, v), v;
}
function $b(t) {
  return t[0] !== "$" ? !0 : (process.env.NODE_ENV !== "production" && st(`Invalid prop name: "${t}" is a reserved property.`), !1);
}
function a0(t) {
  const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : t === null ? "null" : "";
}
function Vb(t, e) {
  return a0(t) === a0(e);
}
function jb(t, e) {
  return Zt(e) ? e.findIndex((r) => Vb(r, t)) : ar(e) && Vb(e, t) ? 0 : -1;
}
function xS(t, e, r) {
  const n = ir(e), i = r.propsOptions[0];
  for (const l in i) {
    let h = i[l];
    h != null && DO(l, n[l], h, !Ar(t, l) && !Ar(t, Mo(l)));
  }
}
function DO(t, e, r, n) {
  const { type: i, required: l, validator: h } = r;
  if (l && n) {
    st('Missing required prop: "' + t + '"');
    return;
  }
  if (!(e == null && !r.required)) {
    if (i != null && i !== !0) {
      let s = !1;
      const m = Zt(i) ? i : [i], v = [];
      for (let E = 0; E < m.length && !s; E++) {
        const { valid: T, expectedType: S } = NO(e, m[E]);
        v.push(S || ""), s = T;
      }
      if (!s) {
        st(FO(t, e, v));
        return;
      }
    }
    h && !h(e) && st('Invalid prop: custom validator check failed for prop "' + t + '".');
  }
}
const kO = /* @__PURE__ */ Hl("String,Number,Boolean,Function,Symbol,BigInt");
function NO(t, e) {
  let r;
  const n = a0(e);
  if (kO(n)) {
    const i = typeof t;
    r = i === n.toLowerCase(), !r && i === "object" && (r = t instanceof e);
  } else
    n === "Object" ? r = rn(t) : n === "Array" ? r = Zt(t) : n === "null" ? r = t === null : r = t instanceof e;
  return {
    valid: r,
    expectedType: n
  };
}
function FO(t, e, r) {
  let n = `Invalid prop: type check failed for prop "${t}". Expected ${r.map(ru).join(" | ")}`;
  const i = r[0], l = J0(e), h = Gb(e, i), s = Gb(e, l);
  return r.length === 1 && qb(i) && !zO(i, l) && (n += ` with value ${h}`), n += `, got ${l} `, qb(l) && (n += `with value ${s}.`), n;
}
function Gb(t, e) {
  return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`;
}
function qb(t) {
  return ["string", "number", "boolean"].some((r) => t.toLowerCase() === r);
}
function zO(...t) {
  return t.some((e) => e.toLowerCase() === "boolean");
}
const bS = (t) => t[0] === "_" || t === "$stable", ux = (t) => Zt(t) ? t.map(Sa) : [Sa(t)], BO = (t, e, r) => {
  if (e._n)
    return e;
  const n = jd((...i) => (process.env.NODE_ENV !== "production" && Zn && st(`Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`), ux(e(...i))), r);
  return n._c = !1, n;
}, wS = (t, e, r) => {
  const n = t._ctx;
  for (const i in t) {
    if (bS(i))
      continue;
    const l = t[i];
    if (ar(l))
      e[i] = BO(i, l, n);
    else if (l != null) {
      process.env.NODE_ENV !== "production" && st(`Non-function value encountered for slot "${i}". Prefer function slots for better performance.`);
      const h = ux(l);
      e[i] = () => h;
    }
  }
}, ES = (t, e) => {
  process.env.NODE_ENV !== "production" && !Gd(t.vnode) && st("Non-function value encountered for default slot. Prefer function slots for better performance.");
  const r = ux(e);
  t.slots.default = () => r;
}, UO = (t, e) => {
  if (t.vnode.shapeFlag & 32) {
    const r = e._;
    r ? (t.slots = ir(e), xg(e, "_", r)) : wS(e, t.slots = {});
  } else
    t.slots = {}, e && ES(t, e);
  xg(t.slots, Sy, 1);
}, $O = (t, e, r) => {
  const { vnode: n, slots: i } = t;
  let l = !0, h = dn;
  if (n.shapeFlag & 32) {
    const s = e._;
    s ? process.env.NODE_ENV !== "production" && Fl ? kn(i, e) : r && s === 1 ? l = !1 : (kn(i, e), !r && s === 1 && delete i._) : (l = !e.$stable, wS(e, i)), h = e;
  } else
    e && (ES(t, e), h = { default: 1 });
  if (l)
    for (const s in i)
      !bS(s) && !(s in h) && delete i[s];
};
function TS() {
  return {
    app: null,
    config: {
      isNativeTag: bT,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let VO = 0;
function jO(t, e) {
  return function(n, i = null) {
    ar(n) || (n = Object.assign({}, n)), i != null && !rn(i) && (process.env.NODE_ENV !== "production" && st("root props passed to app.mount() must be an object."), i = null);
    const l = TS(), h = /* @__PURE__ */ new Set();
    let s = !1;
    const m = l.app = {
      _uid: VO++,
      _component: n,
      _props: i,
      _container: null,
      _context: l,
      _instance: null,
      version: Kb,
      get config() {
        return l.config;
      },
      set config(v) {
        process.env.NODE_ENV !== "production" && st("app.config cannot be replaced. Modify individual options instead.");
      },
      use(v, ...E) {
        return h.has(v) ? process.env.NODE_ENV !== "production" && st("Plugin has already been applied to target app.") : v && ar(v.install) ? (h.add(v), v.install(m, ...E)) : ar(v) ? (h.add(v), v(m, ...E)) : process.env.NODE_ENV !== "production" && st('A plugin must either be a function or an object with an "install" function.'), m;
      },
      mixin(v) {
        return l.mixins.includes(v) ? process.env.NODE_ENV !== "production" && st("Mixin has already been applied to target app" + (v.name ? `: ${v.name}` : "")) : l.mixins.push(v), m;
      },
      component(v, E) {
        return process.env.NODE_ENV !== "production" && c0(v, l.config), E ? (process.env.NODE_ENV !== "production" && l.components[v] && st(`Component "${v}" has already been registered in target app.`), l.components[v] = E, m) : l.components[v];
      },
      directive(v, E) {
        return process.env.NODE_ENV !== "production" && dS(v), E ? (process.env.NODE_ENV !== "production" && l.directives[v] && st(`Directive "${v}" has already been registered in target app.`), l.directives[v] = E, m) : l.directives[v];
      },
      mount(v, E, T) {
        if (s)
          process.env.NODE_ENV !== "production" && st("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
        else {
          process.env.NODE_ENV !== "production" && v.__vue_app__ && st("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");
          const S = $t(n, i);
          return S.appContext = l, process.env.NODE_ENV !== "production" && (l.reload = () => {
            t(as(S), v, T);
          }), E && e ? e(S, v) : t(S, v, T), s = !0, m._container = v, v.__vue_app__ = m, process.env.NODE_ENV !== "production" && (m._instance = S.component, VA(m, Kb)), Cy(S.component) || S.component.proxy;
        }
      },
      unmount() {
        s ? (t(null, m._container), process.env.NODE_ENV !== "production" && (m._instance = null, jA(m)), delete m._container.__vue_app__) : process.env.NODE_ENV !== "production" && st("Cannot unmount an app that is not mounted.");
      },
      provide(v, E) {
        return process.env.NODE_ENV !== "production" && v in l.provides && st(`App already provides property with key "${String(v)}". It will be overwritten with the new value.`), l.provides[v] = E, m;
      }
    };
    return m;
  };
}
function s0(t, e, r, n, i = !1) {
  if (Zt(t)) {
    t.forEach((S, A) => s0(S, e && (Zt(e) ? e[A] : e), r, n, i));
    return;
  }
  if (hd(n) && !i)
    return;
  const l = n.shapeFlag & 4 ? Cy(n.component) || n.component.proxy : n.el, h = i ? null : l, { i: s, r: m } = t;
  if (process.env.NODE_ENV !== "production" && !s) {
    st("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");
    return;
  }
  const v = e && e.r, E = s.refs === dn ? s.refs = {} : s.refs, T = s.setupState;
  if (v != null && v !== m && (Nn(v) ? (E[v] = null, Ar(T, v) && (T[v] = null)) : tn(v) && (v.value = null)), ar(m))
    Ns(m, s, 12, [h, E]);
  else {
    const S = Nn(m), A = tn(m);
    if (S || A) {
      const L = () => {
        if (t.f) {
          const B = S ? Ar(T, m) ? T[m] : E[m] : m.value;
          i ? Zt(B) && H0(B, l) : Zt(B) ? B.includes(l) || B.push(l) : S ? (E[m] = [l], Ar(T, m) && (T[m] = E[m])) : (m.value = [l], t.k && (E[t.k] = m.value));
        } else
          S ? (E[m] = h, Ar(T, m) && (T[m] = h)) : A ? (m.value = h, t.k && (E[t.k] = h)) : process.env.NODE_ENV !== "production" && st("Invalid template ref type:", m, `(${typeof m})`);
      };
      h ? (L.id = -1, Eo(L, r)) : L();
    } else
      process.env.NODE_ENV !== "production" && st("Invalid template ref type:", m, `(${typeof m})`);
  }
}
let Xf, Cl;
function Rs(t, e) {
  t.appContext.config.performance && Pg() && Cl.mark(`vue-${e}-${t.uid}`), process.env.NODE_ENV !== "production" && XA(t, e, Pg() ? Cl.now() : Date.now());
}
function Ls(t, e) {
  if (t.appContext.config.performance && Pg()) {
    const r = `vue-${e}-${t.uid}`, n = r + ":end";
    Cl.mark(n), Cl.measure(`<${Iy(t, t.type)}> ${e}`, r, n), Cl.clearMarks(r), Cl.clearMarks(n);
  }
  process.env.NODE_ENV !== "production" && ZA(t, e, Pg() ? Cl.now() : Date.now());
}
function Pg() {
  return Xf !== void 0 || (typeof window < "u" && window.performance ? (Xf = !0, Cl = window.performance) : Xf = !1), Xf;
}
function GO() {
  const t = [];
  if (process.env.NODE_ENV !== "production" && t.length) {
    const e = t.length > 1;
    console.warn(`Feature flag${e ? "s" : ""} ${t.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const Eo = nO;
function qO(t) {
  return WO(t);
}
function WO(t, e) {
  GO();
  const r = ST();
  r.__VUE__ = !0, process.env.NODE_ENV !== "production" && eS(r.__VUE_DEVTOOLS_GLOBAL_HOOK__, r);
  const { insert: n, remove: i, patchProp: l, createElement: h, createText: s, createComment: m, setText: v, setElementText: E, parentNode: T, nextSibling: S, setScopeId: A = Ui, insertStaticContent: L } = t, B = (re, pe, ke, Ze = null, Ge = null, rt = null, Xe = !1, Je = null, at = process.env.NODE_ENV !== "production" && Fl ? !1 : !!pe.dynamicChildren) => {
    if (re === pe)
      return;
    re && !jc(re, pe) && (Ze = Cr(re), on(re, Ge, rt, !0), re = null), pe.patchFlag === -2 && (at = !1, pe.dynamicChildren = null);
    const { type: Ke, ref: At, shapeFlag: mt } = pe;
    switch (Ke) {
      case qd:
        j(re, pe, ke, Ze);
        break;
      case Ii:
        q(re, pe, ke, Ze);
        break;
      case rg:
        re == null ? H(pe, ke, Ze, Xe) : process.env.NODE_ENV !== "production" && ne(re, pe, ke, Xe);
        break;
      case pn:
        dt(re, pe, ke, Ze, Ge, rt, Xe, Je, at);
        break;
      default:
        mt & 1 ? Te(re, pe, ke, Ze, Ge, rt, Xe, Je, at) : mt & 6 ? xe(re, pe, ke, Ze, Ge, rt, Xe, Je, at) : mt & 64 || mt & 128 ? Ke.process(re, pe, ke, Ze, Ge, rt, Xe, Je, at, kr) : process.env.NODE_ENV !== "production" && st("Invalid VNode type:", Ke, `(${typeof Ke})`);
    }
    At != null && Ge && s0(At, re && re.ref, rt, pe || re, !pe);
  }, j = (re, pe, ke, Ze) => {
    if (re == null)
      n(pe.el = s(pe.children), ke, Ze);
    else {
      const Ge = pe.el = re.el;
      pe.children !== re.children && v(Ge, pe.children);
    }
  }, q = (re, pe, ke, Ze) => {
    re == null ? n(pe.el = m(pe.children || ""), ke, Ze) : pe.el = re.el;
  }, H = (re, pe, ke, Ze) => {
    [re.el, re.anchor] = L(re.children, pe, ke, Ze, re.el, re.anchor);
  }, ne = (re, pe, ke, Ze) => {
    if (pe.children !== re.children) {
      const Ge = S(re.anchor);
      he(re), [pe.el, pe.anchor] = L(pe.children, ke, Ge, Ze);
    } else
      pe.el = re.el, pe.anchor = re.anchor;
  }, ee = ({ el: re, anchor: pe }, ke, Ze) => {
    let Ge;
    for (; re && re !== pe; )
      Ge = S(re), n(re, ke, Ze), re = Ge;
    n(pe, ke, Ze);
  }, he = ({ el: re, anchor: pe }) => {
    let ke;
    for (; re && re !== pe; )
      ke = S(re), i(re), re = ke;
    i(pe);
  }, Te = (re, pe, ke, Ze, Ge, rt, Xe, Je, at) => {
    Xe = Xe || pe.type === "svg", re == null ? ve(pe, ke, Ze, Ge, rt, Xe, Je, at) : Re(re, pe, Ge, rt, Xe, Je, at);
  }, ve = (re, pe, ke, Ze, Ge, rt, Xe, Je) => {
    let at, Ke;
    const { type: At, props: mt, shapeFlag: St, transition: Ut, dirs: Wt } = re;
    if (at = re.el = h(re.type, rt, mt && mt.is, mt), St & 8 ? E(at, re.children) : St & 16 && Me(re.children, at, null, Ze, Ge, rt && At !== "foreignObject", Xe, Je), Wt && Pc(re, null, Ze, "created"), Oe(at, re, re.scopeId, Xe, Ze), mt) {
      for (const We in mt)
        We !== "value" && !Qm(We) && l(at, We, null, mt[We], rt, re.children, Ze, Ge, xr);
      "value" in mt && l(at, "value", null, mt.value), (Ke = mt.onVnodeBeforeMount) && Wa(Ke, Ze, re);
    }
    process.env.NODE_ENV !== "production" && (Object.defineProperty(at, "__vnode", {
      value: re,
      enumerable: !1
    }), Object.defineProperty(at, "__vueParentComponent", {
      value: Ze,
      enumerable: !1
    })), Wt && Pc(re, null, Ze, "beforeMount");
    const Ce = (!Ge || Ge && !Ge.pendingBranch) && Ut && !Ut.persisted;
    Ce && Ut.beforeEnter(at), n(at, pe, ke), ((Ke = mt && mt.onVnodeMounted) || Ce || Wt) && Eo(() => {
      Ke && Wa(Ke, Ze, re), Ce && Ut.enter(at), Wt && Pc(re, null, Ze, "mounted");
    }, Ge);
  }, Oe = (re, pe, ke, Ze, Ge) => {
    if (ke && A(re, ke), Ze)
      for (let rt = 0; rt < Ze.length; rt++)
        A(re, Ze[rt]);
    if (Ge) {
      let rt = Ge.subTree;
      if (process.env.NODE_ENV !== "production" && rt.patchFlag > 0 && rt.patchFlag & 2048 && (rt = oS(rt.children) || rt), pe === rt) {
        const Xe = Ge.vnode;
        Oe(re, Xe, Xe.scopeId, Xe.slotScopeIds, Ge.parent);
      }
    }
  }, Me = (re, pe, ke, Ze, Ge, rt, Xe, Je, at = 0) => {
    for (let Ke = at; Ke < re.length; Ke++) {
      const At = re[Ke] = Je ? Tl(re[Ke]) : Sa(re[Ke]);
      B(null, At, pe, ke, Ze, Ge, rt, Xe, Je);
    }
  }, Re = (re, pe, ke, Ze, Ge, rt, Xe) => {
    const Je = pe.el = re.el;
    let { patchFlag: at, dynamicChildren: Ke, dirs: At } = pe;
    at |= re.patchFlag & 16;
    const mt = re.props || dn, St = pe.props || dn;
    let Ut;
    ke && Ac(ke, !1), (Ut = St.onVnodeBeforeUpdate) && Wa(Ut, ke, pe, re), At && Pc(pe, re, ke, "beforeUpdate"), ke && Ac(ke, !0), process.env.NODE_ENV !== "production" && Fl && (at = 0, Xe = !1, Ke = null);
    const Wt = Ge && pe.type !== "foreignObject";
    if (Ke ? (He(re.dynamicChildren, Ke, Je, ke, Ze, Wt, rt), process.env.NODE_ENV !== "production" && ke && ke.type.__hmrId && fd(re, pe)) : Xe || kt(re, pe, Je, null, ke, Ze, Wt, rt, !1), at > 0) {
      if (at & 16)
        Ve(Je, pe, mt, St, ke, Ze, Ge);
      else if (at & 2 && mt.class !== St.class && l(Je, "class", null, St.class, Ge), at & 4 && l(Je, "style", mt.style, St.style, Ge), at & 8) {
        const Ce = pe.dynamicProps;
        for (let We = 0; We < Ce.length; We++) {
          const br = Ce[We], Wr = mt[br], Xt = St[br];
          (Xt !== Wr || br === "value") && l(Je, br, Wr, Xt, Ge, re.children, ke, Ze, xr);
        }
      }
      at & 1 && re.children !== pe.children && E(Je, pe.children);
    } else
      !Xe && Ke == null && Ve(Je, pe, mt, St, ke, Ze, Ge);
    ((Ut = St.onVnodeUpdated) || At) && Eo(() => {
      Ut && Wa(Ut, ke, pe, re), At && Pc(pe, re, ke, "updated");
    }, Ze);
  }, He = (re, pe, ke, Ze, Ge, rt, Xe) => {
    for (let Je = 0; Je < pe.length; Je++) {
      const at = re[Je], Ke = pe[Je], At = at.el && (at.type === pn || !jc(at, Ke) || at.shapeFlag & 70) ? T(at.el) : ke;
      B(at, Ke, At, null, Ze, Ge, rt, Xe, !0);
    }
  }, Ve = (re, pe, ke, Ze, Ge, rt, Xe) => {
    if (ke !== Ze) {
      if (ke !== dn)
        for (const Je in ke)
          !Qm(Je) && !(Je in Ze) && l(re, Je, ke[Je], null, Xe, pe.children, Ge, rt, xr);
      for (const Je in Ze) {
        if (Qm(Je))
          continue;
        const at = Ze[Je], Ke = ke[Je];
        at !== Ke && Je !== "value" && l(re, Je, Ke, at, Xe, pe.children, Ge, rt, xr);
      }
      "value" in Ze && l(re, "value", ke.value, Ze.value);
    }
  }, dt = (re, pe, ke, Ze, Ge, rt, Xe, Je, at) => {
    const Ke = pe.el = re ? re.el : s(""), At = pe.anchor = re ? re.anchor : s("");
    let { patchFlag: mt, dynamicChildren: St, slotScopeIds: Ut } = pe;
    process.env.NODE_ENV !== "production" && (Fl || mt & 2048) && (mt = 0, at = !1, St = null), Ut && (Je = Je ? Je.concat(Ut) : Ut), re == null ? (n(Ke, ke, Ze), n(At, ke, Ze), Me(pe.children, ke, At, Ge, rt, Xe, Je, at)) : mt > 0 && mt & 64 && St && re.dynamicChildren ? (He(re.dynamicChildren, St, ke, Ge, rt, Xe, Je), process.env.NODE_ENV !== "production" && Ge && Ge.type.__hmrId ? fd(re, pe) : (pe.key != null || Ge && pe === Ge.subTree) && fd(re, pe, !0)) : kt(re, pe, ke, At, Ge, rt, Xe, Je, at);
  }, xe = (re, pe, ke, Ze, Ge, rt, Xe, Je, at) => {
    pe.slotScopeIds = Je, re == null ? pe.shapeFlag & 512 ? Ge.ctx.activate(pe, ke, Ze, Xe, at) : ze(pe, ke, Ze, Ge, rt, Xe, at) : Pe(re, pe, at);
  }, ze = (re, pe, ke, Ze, Ge, rt, Xe) => {
    const Je = re.component = nR(re, Ze, Ge);
    if (process.env.NODE_ENV !== "production" && Je.type.__hmrId && zA(Je), process.env.NODE_ENV !== "production" && (eg(re), Rs(Je, "mount")), Gd(re) && (Je.ctx.renderer = kr), process.env.NODE_ENV !== "production" && Rs(Je, "init"), oR(Je), process.env.NODE_ENV !== "production" && Ls(Je, "init"), Je.asyncDep) {
      if (Ge && Ge.registerDep(Je, Ye), !re.el) {
        const at = Je.subTree = $t(Ii);
        q(null, at, pe, ke);
      }
      return;
    }
    Ye(Je, re, pe, ke, Ge, rt, Xe), process.env.NODE_ENV !== "production" && (tg(), Ls(Je, "mount"));
  }, Pe = (re, pe, ke) => {
    const Ze = pe.component = re.component;
    if (eO(re, pe, ke))
      if (Ze.asyncDep && !Ze.asyncResolved) {
        process.env.NODE_ENV !== "production" && eg(pe), it(Ze, pe, ke), process.env.NODE_ENV !== "production" && tg();
        return;
      } else
        Ze.next = pe, NA(Ze.update), Ze.update();
    else
      pe.el = re.el, Ze.vnode = pe;
  }, Ye = (re, pe, ke, Ze, Ge, rt, Xe) => {
    const Je = () => {
      if (re.isMounted) {
        let { next: At, bu: mt, u: St, parent: Ut, vnode: Wt } = re, Ce = At, We;
        process.env.NODE_ENV !== "production" && eg(At || re.vnode), Ac(re, !1), At ? (At.el = Wt.el, it(re, At, Xe)) : At = Wt, mt && Wf(mt), (We = At.props && At.props.onVnodeBeforeUpdate) && Wa(We, Ut, At, Wt), Ac(re, !0), process.env.NODE_ENV !== "production" && Rs(re, "render");
        const br = Q_(re);
        process.env.NODE_ENV !== "production" && Ls(re, "render");
        const Wr = re.subTree;
        re.subTree = br, process.env.NODE_ENV !== "production" && Rs(re, "patch"), B(
          Wr,
          br,
          T(Wr.el),
          Cr(Wr),
          re,
          Ge,
          rt
        ), process.env.NODE_ENV !== "production" && Ls(re, "patch"), At.el = br.el, Ce === null && tO(re, br.el), St && Eo(St, Ge), (We = At.props && At.props.onVnodeUpdated) && Eo(() => Wa(We, Ut, At, Wt), Ge), process.env.NODE_ENV !== "production" && tS(re), process.env.NODE_ENV !== "production" && tg();
      } else {
        let At;
        const { el: mt, props: St } = pe, { bm: Ut, m: Wt, parent: Ce } = re, We = hd(pe);
        if (Ac(re, !1), Ut && Wf(Ut), !We && (At = St && St.onVnodeBeforeMount) && Wa(At, Ce, pe), Ac(re, !0), mt && qr) {
          const br = () => {
            process.env.NODE_ENV !== "production" && Rs(re, "render"), re.subTree = Q_(re), process.env.NODE_ENV !== "production" && Ls(re, "render"), process.env.NODE_ENV !== "production" && Rs(re, "hydrate"), qr(mt, re.subTree, re, Ge, null), process.env.NODE_ENV !== "production" && Ls(re, "hydrate");
          };
          We ? pe.type.__asyncLoader().then(
            () => !re.isUnmounted && br()
          ) : br();
        } else {
          process.env.NODE_ENV !== "production" && Rs(re, "render");
          const br = re.subTree = Q_(re);
          process.env.NODE_ENV !== "production" && Ls(re, "render"), process.env.NODE_ENV !== "production" && Rs(re, "patch"), B(null, br, ke, Ze, re, Ge, rt), process.env.NODE_ENV !== "production" && Ls(re, "patch"), pe.el = br.el;
        }
        if (Wt && Eo(Wt, Ge), !We && (At = St && St.onVnodeMounted)) {
          const br = pe;
          Eo(() => Wa(At, Ce, br), Ge);
        }
        (pe.shapeFlag & 256 || Ce && hd(Ce.vnode) && Ce.vnode.shapeFlag & 256) && re.a && Eo(re.a, Ge), re.isMounted = !0, process.env.NODE_ENV !== "production" && GA(re), pe = ke = Ze = null;
      }
    }, at = re.effect = new ex(
      Je,
      () => wy(Ke),
      re.scope
    ), Ke = re.update = () => at.run();
    Ke.id = re.uid, Ac(re, !0), process.env.NODE_ENV !== "production" && (at.onTrack = re.rtc ? (At) => Wf(re.rtc, At) : void 0, at.onTrigger = re.rtg ? (At) => Wf(re.rtg, At) : void 0, Ke.ownerInstance = re), Ke();
  }, it = (re, pe, ke) => {
    pe.component = re;
    const Ze = re.vnode.props;
    re.vnode = pe, re.next = null, LO(re, pe.props, Ze, ke), $O(re, pe.children, ke), uu(), Rb(), hu();
  }, kt = (re, pe, ke, Ze, Ge, rt, Xe, Je, at = !1) => {
    const Ke = re && re.children, At = re ? re.shapeFlag : 0, mt = pe.children, { patchFlag: St, shapeFlag: Ut } = pe;
    if (St > 0) {
      if (St & 128) {
        mr(Ke, mt, ke, Ze, Ge, rt, Xe, Je, at);
        return;
      } else if (St & 256) {
        Er(Ke, mt, ke, Ze, Ge, rt, Xe, Je, at);
        return;
      }
    }
    Ut & 8 ? (At & 16 && xr(Ke, Ge, rt), mt !== Ke && E(ke, mt)) : At & 16 ? Ut & 16 ? mr(Ke, mt, ke, Ze, Ge, rt, Xe, Je, at) : xr(Ke, Ge, rt, !0) : (At & 8 && E(ke, ""), Ut & 16 && Me(mt, ke, Ze, Ge, rt, Xe, Je, at));
  }, Er = (re, pe, ke, Ze, Ge, rt, Xe, Je, at) => {
    re = re || vh, pe = pe || vh;
    const Ke = re.length, At = pe.length, mt = Math.min(Ke, At);
    let St;
    for (St = 0; St < mt; St++) {
      const Ut = pe[St] = at ? Tl(pe[St]) : Sa(pe[St]);
      B(re[St], Ut, ke, null, Ge, rt, Xe, Je, at);
    }
    Ke > At ? xr(re, Ge, rt, !0, !1, mt) : Me(pe, ke, Ze, Ge, rt, Xe, Je, at, mt);
  }, mr = (re, pe, ke, Ze, Ge, rt, Xe, Je, at) => {
    let Ke = 0;
    const At = pe.length;
    let mt = re.length - 1, St = At - 1;
    for (; Ke <= mt && Ke <= St; ) {
      const Ut = re[Ke], Wt = pe[Ke] = at ? Tl(pe[Ke]) : Sa(pe[Ke]);
      if (jc(Ut, Wt))
        B(Ut, Wt, ke, null, Ge, rt, Xe, Je, at);
      else
        break;
      Ke++;
    }
    for (; Ke <= mt && Ke <= St; ) {
      const Ut = re[mt], Wt = pe[St] = at ? Tl(pe[St]) : Sa(pe[St]);
      if (jc(Ut, Wt))
        B(Ut, Wt, ke, null, Ge, rt, Xe, Je, at);
      else
        break;
      mt--, St--;
    }
    if (Ke > mt) {
      if (Ke <= St) {
        const Ut = St + 1, Wt = Ut < At ? pe[Ut].el : Ze;
        for (; Ke <= St; )
          B(null, pe[Ke] = at ? Tl(pe[Ke]) : Sa(pe[Ke]), ke, Wt, Ge, rt, Xe, Je, at), Ke++;
      }
    } else if (Ke > St)
      for (; Ke <= mt; )
        on(re[Ke], Ge, rt, !0), Ke++;
    else {
      const Ut = Ke, Wt = Ke, Ce = /* @__PURE__ */ new Map();
      for (Ke = Wt; Ke <= St; Ke++) {
        const Yr = pe[Ke] = at ? Tl(pe[Ke]) : Sa(pe[Ke]);
        Yr.key != null && (process.env.NODE_ENV !== "production" && Ce.has(Yr.key) && st("Duplicate keys found during update:", JSON.stringify(Yr.key), "Make sure keys are unique."), Ce.set(Yr.key, Ke));
      }
      let We, br = 0;
      const Wr = St - Wt + 1;
      let Xt = !1, gn = 0;
      const Br = new Array(Wr);
      for (Ke = 0; Ke < Wr; Ke++)
        Br[Ke] = 0;
      for (Ke = Ut; Ke <= mt; Ke++) {
        const Yr = re[Ke];
        if (br >= Wr) {
          on(Yr, Ge, rt, !0);
          continue;
        }
        let nt;
        if (Yr.key != null)
          nt = Ce.get(Yr.key);
        else
          for (We = Wt; We <= St; We++)
            if (Br[We - Wt] === 0 && jc(Yr, pe[We])) {
              nt = We;
              break;
            }
        nt === void 0 ? on(Yr, Ge, rt, !0) : (Br[nt - Wt] = Ke + 1, nt >= gn ? gn = nt : Xt = !0, B(Yr, pe[nt], ke, null, Ge, rt, Xe, Je, at), br++);
      }
      const Ir = Xt ? XO(Br) : vh;
      for (We = Ir.length - 1, Ke = Wr - 1; Ke >= 0; Ke--) {
        const Yr = Wt + Ke, nt = pe[Yr], Kt = Yr + 1 < At ? pe[Yr + 1].el : Ze;
        Br[Ke] === 0 ? B(null, nt, ke, Kt, Ge, rt, Xe, Je, at) : Xt && (We < 0 || Ke !== Ir[We] ? Yt(nt, ke, Kt, 2) : We--);
      }
    }
  }, Yt = (re, pe, ke, Ze, Ge = null) => {
    const { el: rt, type: Xe, transition: Je, children: at, shapeFlag: Ke } = re;
    if (Ke & 6) {
      Yt(re.component.subTree, pe, ke, Ze);
      return;
    }
    if (Ke & 128) {
      re.suspense.move(pe, ke, Ze);
      return;
    }
    if (Ke & 64) {
      Xe.move(re, pe, ke, kr);
      return;
    }
    if (Xe === pn) {
      n(rt, pe, ke);
      for (let mt = 0; mt < at.length; mt++)
        Yt(at[mt], pe, ke, Ze);
      n(re.anchor, pe, ke);
      return;
    }
    if (Xe === rg) {
      ee(re, pe, ke);
      return;
    }
    if (Ze !== 2 && Ke & 1 && Je)
      if (Ze === 0)
        Je.beforeEnter(rt), n(rt, pe, ke), Eo(() => Je.enter(rt), Ge);
      else {
        const { leave: mt, delayLeave: St, afterLeave: Ut } = Je, Wt = () => n(rt, pe, ke), Ce = () => {
          mt(rt, () => {
            Wt(), Ut && Ut();
          });
        };
        St ? St(rt, Wt, Ce) : Ce();
      }
    else
      n(rt, pe, ke);
  }, on = (re, pe, ke, Ze = !1, Ge = !1) => {
    const { type: rt, props: Xe, ref: Je, children: at, dynamicChildren: Ke, shapeFlag: At, patchFlag: mt, dirs: St } = re;
    if (Je != null && s0(Je, null, ke, re, !0), At & 256) {
      pe.ctx.deactivate(re);
      return;
    }
    const Ut = At & 1 && St, Wt = !hd(re);
    let Ce;
    if (Wt && (Ce = Xe && Xe.onVnodeBeforeUnmount) && Wa(Ce, pe, re), At & 6)
      Ht(re.component, ke, Ze);
    else {
      if (At & 128) {
        re.suspense.unmount(ke, Ze);
        return;
      }
      Ut && Pc(re, null, pe, "beforeUnmount"), At & 64 ? re.type.remove(re, pe, ke, Ge, kr, Ze) : Ke && (rt !== pn || mt > 0 && mt & 64) ? xr(Ke, pe, ke, !1, !0) : (rt === pn && mt & 384 || !Ge && At & 16) && xr(at, pe, ke), Ze && or(re);
    }
    (Wt && (Ce = Xe && Xe.onVnodeUnmounted) || Ut) && Eo(() => {
      Ce && Wa(Ce, pe, re), Ut && Pc(re, null, pe, "unmounted");
    }, ke);
  }, or = (re) => {
    const { type: pe, el: ke, anchor: Ze, transition: Ge } = re;
    if (pe === pn) {
      process.env.NODE_ENV !== "production" && re.patchFlag > 0 && re.patchFlag & 2048 && Ge && !Ge.persisted ? re.children.forEach((Xe) => {
        Xe.type === Ii ? i(Xe.el) : or(Xe);
      }) : Jt(ke, Ze);
      return;
    }
    if (pe === rg) {
      he(re);
      return;
    }
    const rt = () => {
      i(ke), Ge && !Ge.persisted && Ge.afterLeave && Ge.afterLeave();
    };
    if (re.shapeFlag & 1 && Ge && !Ge.persisted) {
      const { leave: Xe, delayLeave: Je } = Ge, at = () => Xe(ke, rt);
      Je ? Je(re.el, rt, at) : at();
    } else
      rt();
  }, Jt = (re, pe) => {
    let ke;
    for (; re !== pe; )
      ke = S(re), i(re), re = ke;
    i(pe);
  }, Ht = (re, pe, ke) => {
    process.env.NODE_ENV !== "production" && re.type.__hmrId && BA(re);
    const { bum: Ze, scope: Ge, update: rt, subTree: Xe, um: Je } = re;
    Ze && Wf(Ze), Ge.stop(), rt && (rt.active = !1, on(Xe, re, pe, ke)), Je && Eo(Je, pe), Eo(() => {
      re.isUnmounted = !0;
    }, pe), pe && pe.pendingBranch && !pe.isUnmounted && re.asyncDep && !re.asyncResolved && re.suspenseId === pe.pendingId && (pe.deps--, pe.deps === 0 && pe.resolve()), process.env.NODE_ENV !== "production" && WA(re);
  }, xr = (re, pe, ke, Ze = !1, Ge = !1, rt = 0) => {
    for (let Xe = rt; Xe < re.length; Xe++)
      on(re[Xe], pe, ke, Ze, Ge);
  }, Cr = (re) => re.shapeFlag & 6 ? Cr(re.component.subTree) : re.shapeFlag & 128 ? re.suspense.next() : S(re.anchor || re.el), an = (re, pe, ke) => {
    re == null ? pe._vnode && on(pe._vnode, null, null, !0) : B(pe._vnode || null, re, pe, null, null, null, ke), Rb(), YT(), pe._vnode = re;
  }, kr = {
    p: B,
    um: on,
    m: Yt,
    r: or,
    mt: ze,
    mc: Me,
    pc: kt,
    pbc: He,
    n: Cr,
    o: t
  };
  let Pn, qr;
  return e && ([Pn, qr] = e(kr)), {
    render: an,
    hydrate: Pn,
    createApp: jO(an, Pn)
  };
}
function Ac({ effect: t, update: e }, r) {
  t.allowRecurse = e.allowRecurse = r;
}
function fd(t, e, r = !1) {
  const n = t.children, i = e.children;
  if (Zt(n) && Zt(i))
    for (let l = 0; l < n.length; l++) {
      const h = n[l];
      let s = i[l];
      s.shapeFlag & 1 && !s.dynamicChildren && ((s.patchFlag <= 0 || s.patchFlag === 32) && (s = i[l] = Tl(i[l]), s.el = h.el), r || fd(h, s)), s.type === qd && (s.el = h.el), process.env.NODE_ENV !== "production" && s.type === Ii && !s.el && (s.el = h.el);
    }
}
function XO(t) {
  const e = t.slice(), r = [0];
  let n, i, l, h, s;
  const m = t.length;
  for (n = 0; n < m; n++) {
    const v = t[n];
    if (v !== 0) {
      if (i = r[r.length - 1], t[i] < v) {
        e[n] = i, r.push(n);
        continue;
      }
      for (l = 0, h = r.length - 1; l < h; )
        s = l + h >> 1, t[r[s]] < v ? l = s + 1 : h = s;
      v < t[r[l]] && (l > 0 && (e[n] = r[l - 1]), r[l] = n);
    }
  }
  for (l = r.length, h = r[l - 1]; l-- > 0; )
    r[l] = h, h = e[h];
  return r;
}
const ZO = (t) => t.__isTeleport, wh = (t) => t && (t.disabled || t.disabled === ""), Wb = (t) => typeof SVGElement < "u" && t instanceof SVGElement, l0 = (t, e) => {
  const r = t && t.to;
  if (Nn(r))
    if (e) {
      const n = e(r);
      return n || process.env.NODE_ENV !== "production" && st(`Failed to locate Teleport target with selector "${r}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`), n;
    } else
      return process.env.NODE_ENV !== "production" && st("Current renderer does not support string target for Teleports. (missing querySelector renderer option)"), null;
  else
    return process.env.NODE_ENV !== "production" && !r && !wh(t) && st(`Invalid Teleport target: ${r}`), r;
}, HO = {
  __isTeleport: !0,
  process(t, e, r, n, i, l, h, s, m, v) {
    const { mc: E, pc: T, pbc: S, o: { insert: A, querySelector: L, createText: B, createComment: j } } = v, q = wh(e.props);
    let { shapeFlag: H, children: ne, dynamicChildren: ee } = e;
    if (process.env.NODE_ENV !== "production" && Fl && (m = !1, ee = null), t == null) {
      const he = e.el = process.env.NODE_ENV !== "production" ? j("teleport start") : B(""), Te = e.anchor = process.env.NODE_ENV !== "production" ? j("teleport end") : B("");
      A(he, r, n), A(Te, r, n);
      const ve = e.target = l0(e.props, L), Oe = e.targetAnchor = B("");
      ve ? (A(Oe, ve), h = h || Wb(ve)) : process.env.NODE_ENV !== "production" && !q && st("Invalid Teleport target on mount:", ve, `(${typeof ve})`);
      const Me = (Re, He) => {
        H & 16 && E(ne, Re, He, i, l, h, s, m);
      };
      q ? Me(r, Te) : ve && Me(ve, Oe);
    } else {
      e.el = t.el;
      const he = e.anchor = t.anchor, Te = e.target = t.target, ve = e.targetAnchor = t.targetAnchor, Oe = wh(t.props), Me = Oe ? r : Te, Re = Oe ? he : ve;
      if (h = h || Wb(Te), ee ? (S(t.dynamicChildren, ee, Me, i, l, h, s), fd(t, e, !0)) : m || T(t, e, Me, Re, i, l, h, s, !1), q)
        Oe || Sm(e, r, he, v, 1);
      else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
        const He = e.target = l0(e.props, L);
        He ? Sm(e, He, null, v, 0) : process.env.NODE_ENV !== "production" && st("Invalid Teleport target on update:", Te, `(${typeof Te})`);
      } else
        Oe && Sm(e, Te, ve, v, 1);
    }
    MS(e);
  },
  remove(t, e, r, n, { um: i, o: { remove: l } }, h) {
    const { shapeFlag: s, children: m, anchor: v, targetAnchor: E, target: T, props: S } = t;
    if (T && l(E), (h || !wh(S)) && (l(v), s & 16))
      for (let A = 0; A < m.length; A++) {
        const L = m[A];
        i(L, e, r, !0, !!L.dynamicChildren);
      }
  },
  move: Sm,
  hydrate: KO
};
function Sm(t, e, r, { o: { insert: n }, m: i }, l = 2) {
  l === 0 && n(t.targetAnchor, e, r);
  const { el: h, anchor: s, shapeFlag: m, children: v, props: E } = t, T = l === 2;
  if (T && n(h, e, r), (!T || wh(E)) && m & 16)
    for (let S = 0; S < v.length; S++)
      i(v[S], e, r, 2);
  T && n(s, e, r);
}
function KO(t, e, r, n, i, l, { o: { nextSibling: h, parentNode: s, querySelector: m } }, v) {
  const E = e.target = l0(e.props, m);
  if (E) {
    const T = E._lpa || E.firstChild;
    if (e.shapeFlag & 16)
      if (wh(e.props))
        e.anchor = v(h(t), e, s(t), r, n, i, l), e.targetAnchor = T;
      else {
        e.anchor = h(t);
        let S = T;
        for (; S; )
          if (S = h(S), S && S.nodeType === 8 && S.data === "teleport anchor") {
            e.targetAnchor = S, E._lpa = e.targetAnchor && h(e.targetAnchor);
            break;
          }
        v(T, e, E, r, n, i, l);
      }
    MS(e);
  }
  return e.anchor && h(e.anchor);
}
const SS = HO;
function MS(t) {
  const e = t.ctx;
  if (e && e.ut) {
    let r = t.children[0].el;
    for (; r !== t.targetAnchor; )
      r.nodeType === 1 && r.setAttribute("data-v-owner", e.uid), r = r.nextSibling;
    e.ut();
  }
}
const pn = Symbol(process.env.NODE_ENV !== "production" ? "Fragment" : void 0), qd = Symbol(process.env.NODE_ENV !== "production" ? "Text" : void 0), Ii = Symbol(process.env.NODE_ENV !== "production" ? "Comment" : void 0), rg = Symbol(process.env.NODE_ENV !== "production" ? "Static" : void 0), dd = [];
let Ca = null;
function tt(t = !1) {
  dd.push(Ca = t ? null : []);
}
function YO() {
  dd.pop(), Ca = dd[dd.length - 1] || null;
}
let Pd = 1;
function Xb(t) {
  Pd += t;
}
function CS(t) {
  return t.dynamicChildren = Pd > 0 ? Ca || vh : null, YO(), Pd > 0 && Ca && Ca.push(t), t;
}
function vt(t, e, r, n, i, l) {
  return CS($e(t, e, r, n, i, l, !0));
}
function Un(t, e, r, n, i) {
  return CS($t(t, e, r, n, i, !0));
}
function Rh(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function jc(t, e) {
  return process.env.NODE_ENV !== "production" && e.shapeFlag & 6 && nh.has(e.type) ? (t.shapeFlag &= -257, e.shapeFlag &= -513, !1) : t.type === e.type && t.key === e.key;
}
const JO = (...t) => PS(...t), Sy = "__vInternal", IS = ({ key: t }) => t != null ? t : null, ng = ({ ref: t, ref_key: e, ref_for: r }) => t != null ? Nn(t) || tn(t) || ar(t) ? { i: _i, r: t, k: e, f: !!r } : t : null;
function $e(t, e = null, r = null, n = 0, i = null, l = t === pn ? 0 : 1, h = !1, s = !1) {
  const m = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && IS(e),
    ref: e && ng(e),
    scopeId: iS,
    slotScopeIds: null,
    children: r,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: l,
    patchFlag: n,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: _i
  };
  return s ? (hx(m, r), l & 128 && t.normalize(m)) : r && (m.shapeFlag |= Nn(r) ? 8 : 16), process.env.NODE_ENV !== "production" && m.key !== m.key && st("VNode created with invalid key (NaN). VNode type:", m.type), Pd > 0 && !h && Ca && (m.patchFlag > 0 || l & 6) && m.patchFlag !== 32 && Ca.push(m), m;
}
const $t = process.env.NODE_ENV !== "production" ? JO : PS;
function PS(t, e = null, r = null, n = 0, i = null, l = !1) {
  if ((!t || t === vO) && (process.env.NODE_ENV !== "production" && !t && st(`Invalid vnode type when creating vnode: ${t}.`), t = Ii), Rh(t)) {
    const s = as(t, e, !0);
    return r && hx(s, r), Pd > 0 && !l && Ca && (s.shapeFlag & 6 ? Ca[Ca.indexOf(t)] = s : Ca.push(s)), s.patchFlag |= -2, s;
  }
  if (LS(t) && (t = t.__vccOpts), e) {
    e = QO(e);
    let { class: s, style: m } = e;
    s && !Nn(s) && (e.class = Or(s)), rn(m) && (Tg(m) && !Zt(m) && (m = kn({}, m)), e.style = Uh(m));
  }
  const h = Nn(t) ? 1 : rO(t) ? 128 : ZO(t) ? 64 : rn(t) ? 4 : ar(t) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && h & 4 && Tg(t) && (t = ir(t), st("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `
Component that was made reactive: `, t)), $e(t, e, r, n, i, h, l, !0);
}
function QO(t) {
  return t ? Tg(t) || Sy in t ? kn({}, t) : t : null;
}
function as(t, e, r = !1) {
  const { props: n, ref: i, patchFlag: l, children: h } = t, s = e ? eR(n || {}, e) : n;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: s,
    key: s && IS(s),
    ref: e && e.ref ? r && i ? Zt(i) ? i.concat(ng(e)) : [i, ng(e)] : ng(e) : i,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && l === -1 && Zt(h) ? h.map(AS) : h,
    target: t.target,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    patchFlag: e && t.type !== pn ? l === -1 ? 16 : l | 16 : l,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: t.transition,
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && as(t.ssContent),
    ssFallback: t.ssFallback && as(t.ssFallback),
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
}
function AS(t) {
  const e = as(t);
  return Zt(t.children) && (e.children = t.children.map(AS)), e;
}
function Ag(t = " ", e = 0) {
  return $t(qd, null, t, e);
}
function Tt(t = "", e = !1) {
  return e ? (tt(), Un(Ii, null, t)) : $t(Ii, null, t);
}
function Sa(t) {
  return t == null || typeof t == "boolean" ? $t(Ii) : Zt(t) ? $t(
    pn,
    null,
    t.slice()
  ) : typeof t == "object" ? Tl(t) : $t(qd, null, String(t));
}
function Tl(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : as(t);
}
function hx(t, e) {
  let r = 0;
  const { shapeFlag: n } = t;
  if (e == null)
    e = null;
  else if (Zt(e))
    r = 16;
  else if (typeof e == "object")
    if (n & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), hx(t, i()), i._c && (i._d = !0));
      return;
    } else {
      r = 32;
      const i = e._;
      !i && !(Sy in e) ? e._ctx = _i : i === 3 && _i && (_i.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
  else
    ar(e) ? (e = { default: e, _ctx: _i }, r = 32) : (e = String(e), n & 64 ? (r = 16, e = [Ag(e)]) : r = 8);
  t.children = e, t.shapeFlag |= r;
}
function eR(...t) {
  const e = {};
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    for (const i in n)
      if (i === "class")
        e.class !== n.class && (e.class = Or([e.class, n.class]));
      else if (i === "style")
        e.style = Uh([e.style, n.style]);
      else if ($d(i)) {
        const l = e[i], h = n[i];
        h && l !== h && !(Zt(l) && l.includes(h)) && (e[i] = l ? [].concat(l, h) : h);
      } else
        i !== "" && (e[i] = n[i]);
  }
  return e;
}
function Wa(t, e, r, n = null) {
  na(t, e, 7, [
    r,
    n
  ]);
}
const tR = TS();
let rR = 0;
function nR(t, e, r) {
  const n = t.type, i = (e ? e.appContext : t.appContext) || tR, l = {
    uid: rR++,
    vnode: t,
    type: n,
    parent: e,
    appContext: i,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new MT(!0),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: vS(n, i),
    emitsOptions: nS(n, i),
    emit: null,
    emitted: null,
    propsDefaults: dn,
    inheritAttrs: n.inheritAttrs,
    ctx: dn,
    data: dn,
    props: dn,
    attrs: dn,
    slots: dn,
    refs: dn,
    setupState: dn,
    setupContext: null,
    suspense: r,
    suspenseId: r ? r.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return process.env.NODE_ENV !== "production" ? l.ctx = wO(l) : l.ctx = { _: l }, l.root = e ? e.root : l, l.emit = KA.bind(null, l), t.ce && t.ce(l), l;
}
let Zn = null;
const My = () => Zn || _i, Lh = (t) => {
  Zn = t, t.scope.on();
}, Jc = () => {
  Zn && Zn.scope.off(), Zn = null;
}, iR = /* @__PURE__ */ Hl("slot,component");
function c0(t, e) {
  const r = e.isNativeTag || bT;
  (iR(t) || r(t)) && st("Do not use built-in or reserved HTML elements as component id: " + t);
}
function OS(t) {
  return t.vnode.shapeFlag & 4;
}
let Ad = !1;
function oR(t, e = !1) {
  Ad = e;
  const { props: r, children: n } = t.vnode, i = OS(t);
  OO(t, r, i, e), UO(t, n);
  const l = i ? aR(t, e) : void 0;
  return Ad = !1, l;
}
function aR(t, e) {
  var r;
  const n = t.type;
  if (process.env.NODE_ENV !== "production") {
    if (n.name && c0(n.name, t.appContext.config), n.components) {
      const l = Object.keys(n.components);
      for (let h = 0; h < l.length; h++)
        c0(l[h], t.appContext.config);
    }
    if (n.directives) {
      const l = Object.keys(n.directives);
      for (let h = 0; h < l.length; h++)
        dS(l[h]);
    }
    n.compilerOptions && sR() && st('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.');
  }
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = Ta(new Proxy(t.ctx, gS)), process.env.NODE_ENV !== "production" && EO(t);
  const { setup: i } = n;
  if (i) {
    const l = t.setupContext = i.length > 1 ? lR(t) : null;
    Lh(t), uu();
    const h = Ns(i, t, 0, [process.env.NODE_ENV !== "production" ? uh(t.props) : t.props, l]);
    if (hu(), Jc(), Y0(h)) {
      if (h.then(Jc, Jc), e)
        return h.then((s) => {
          Zb(t, s, e);
        }).catch((s) => {
          by(s, t, 0);
        });
      if (t.asyncDep = h, process.env.NODE_ENV !== "production" && !t.suspense) {
        const s = (r = n.name) !== null && r !== void 0 ? r : "Anonymous";
        st(`Component <${s}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
      }
    } else
      Zb(t, h, e);
  } else
    RS(t, e);
}
function Zb(t, e, r) {
  ar(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : rn(e) ? (process.env.NODE_ENV !== "production" && Rh(e) && st("setup() should not return VNodes directly - return a render function instead."), process.env.NODE_ENV !== "production" && (t.devtoolsRawSetupState = e), t.setupState = qT(e), process.env.NODE_ENV !== "production" && TO(t)) : process.env.NODE_ENV !== "production" && e !== void 0 && st(`setup() should return an object. Received: ${e === null ? "null" : typeof e}`), RS(t, r);
}
let u0;
const sR = () => !u0;
function RS(t, e, r) {
  const n = t.type;
  if (!t.render) {
    if (!e && u0 && !n.render) {
      const i = n.template || cx(t).template;
      if (i) {
        process.env.NODE_ENV !== "production" && Rs(t, "compile");
        const { isCustomElement: l, compilerOptions: h } = t.appContext.config, { delimiters: s, compilerOptions: m } = n, v = kn(kn({
          isCustomElement: l,
          delimiters: s
        }, h), m);
        n.render = u0(i, v), process.env.NODE_ENV !== "production" && Ls(t, "compile");
      }
    }
    t.render = n.render || Ui;
  }
  Lh(t), uu(), MO(t), hu(), Jc(), process.env.NODE_ENV !== "production" && !n.render && t.render === Ui && !e && (n.template ? st('Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".') : st("Component is missing template or render function."));
}
function Hb(t) {
  return new Proxy(t.attrs, process.env.NODE_ENV !== "production" ? {
    get(e, r) {
      return Cg(), mo(t, "get", "$attrs"), e[r];
    },
    set() {
      return st("setupContext.attrs is readonly."), !1;
    },
    deleteProperty() {
      return st("setupContext.attrs is readonly."), !1;
    }
  } : {
    get(e, r) {
      return mo(t, "get", "$attrs"), e[r];
    }
  });
}
function lR(t) {
  const e = (n) => {
    if (process.env.NODE_ENV !== "production" && (t.exposed && st("expose() should be called only once per setup()."), n != null)) {
      let i = typeof n;
      i === "object" && (Zt(n) ? i = "array" : tn(n) && (i = "ref")), i !== "object" && st(`expose() should be passed a plain object, received ${i}.`);
    }
    t.exposed = n || {};
  };
  let r;
  return process.env.NODE_ENV !== "production" ? Object.freeze({
    get attrs() {
      return r || (r = Hb(t));
    },
    get slots() {
      return uh(t.slots);
    },
    get emit() {
      return (n, ...i) => t.emit(n, ...i);
    },
    expose: e
  }) : {
    get attrs() {
      return r || (r = Hb(t));
    },
    slots: t.slots,
    emit: t.emit,
    expose: e
  };
}
function Cy(t) {
  if (t.exposed)
    return t.exposeProxy || (t.exposeProxy = new Proxy(qT(Ta(t.exposed)), {
      get(e, r) {
        if (r in e)
          return e[r];
        if (r in Yc)
          return Yc[r](t);
      },
      has(e, r) {
        return r in e || r in Yc;
      }
    }));
}
const cR = /(?:^|[-_])(\w)/g, uR = (t) => t.replace(cR, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function fx(t, e = !0) {
  return ar(t) ? t.displayName || t.name : t.name || e && t.__name;
}
function Iy(t, e, r = !1) {
  let n = fx(e);
  if (!n && e.__file) {
    const i = e.__file.match(/([^/\\]+)\.\w+$/);
    i && (n = i[1]);
  }
  if (!n && t && t.parent) {
    const i = (l) => {
      for (const h in l)
        if (l[h] === e)
          return h;
    };
    n = i(t.components || t.parent.type.components) || i(t.appContext.components);
  }
  return n ? uR(n) : r ? "App" : "Anonymous";
}
function LS(t) {
  return ar(t) && "__vccOpts" in t;
}
const un = (t, e) => CA(t, e, Ad);
function DS(t, e, r) {
  const n = arguments.length;
  return n === 2 ? rn(e) && !Zt(e) ? Rh(e) ? $t(t, null, [e]) : $t(t, e) : $t(t, null, e) : (n > 3 ? r = Array.prototype.slice.call(arguments, 2) : n === 3 && Rh(r) && (r = [r]), $t(t, e, r));
}
const hR = Symbol(process.env.NODE_ENV !== "production" ? "ssrContext" : ""), fR = () => {
  {
    const t = bh(hR);
    return t || process.env.NODE_ENV !== "production" && st("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), t;
  }
};
function rv(t) {
  return !!(t && t.__v_isShallow);
}
function dR() {
  if (process.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const t = { style: "color:#3ba776" }, e = { style: "color:#0b1bc9" }, r = { style: "color:#b62e24" }, n = { style: "color:#9d288c" }, i = {
    header(T) {
      return rn(T) ? T.__isVue ? ["div", t, "VueInstance"] : tn(T) ? [
        "div",
        {},
        ["span", t, E(T)],
        "<",
        s(T.value),
        ">"
      ] : Aa(T) ? [
        "div",
        {},
        ["span", t, rv(T) ? "ShallowReactive" : "Reactive"],
        "<",
        s(T),
        `>${jl(T) ? " (readonly)" : ""}`
      ] : jl(T) ? [
        "div",
        {},
        ["span", t, rv(T) ? "ShallowReadonly" : "Readonly"],
        "<",
        s(T),
        ">"
      ] : null : null;
    },
    hasBody(T) {
      return T && T.__isVue;
    },
    body(T) {
      if (T && T.__isVue)
        return [
          "div",
          {},
          ...l(T.$)
        ];
    }
  };
  function l(T) {
    const S = [];
    T.type.props && T.props && S.push(h("props", ir(T.props))), T.setupState !== dn && S.push(h("setup", T.setupState)), T.data !== dn && S.push(h("data", ir(T.data)));
    const A = m(T, "computed");
    A && S.push(h("computed", A));
    const L = m(T, "inject");
    return L && S.push(h("injected", L)), S.push([
      "div",
      {},
      [
        "span",
        {
          style: n.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: T }]
    ]), S;
  }
  function h(T, S) {
    return S = kn({}, S), Object.keys(S).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        T
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(S).map((A) => [
          "div",
          {},
          ["span", n, A + ": "],
          s(S[A], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function s(T, S = !0) {
    return typeof T == "number" ? ["span", e, T] : typeof T == "string" ? ["span", r, JSON.stringify(T)] : typeof T == "boolean" ? ["span", n, T] : rn(T) ? ["object", { object: S ? ir(T) : T }] : ["span", r, String(T)];
  }
  function m(T, S) {
    const A = T.type;
    if (ar(A))
      return;
    const L = {};
    for (const B in T.ctx)
      v(A, B, S) && (L[B] = T.ctx[B]);
    return L;
  }
  function v(T, S, A) {
    const L = T[A];
    if (Zt(L) && L.includes(S) || rn(L) && S in L || T.extends && v(T.extends, S, A) || T.mixins && T.mixins.some((B) => v(B, S, A)))
      return !0;
  }
  function E(T) {
    return rv(T) ? "ShallowRef" : T.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i];
}
const Kb = "3.2.47", pR = "http://www.w3.org/2000/svg", Gc = typeof document < "u" ? document : null, Yb = Gc && /* @__PURE__ */ Gc.createElement("template"), mR = {
  insert: (t, e, r) => {
    e.insertBefore(t, r || null);
  },
  remove: (t) => {
    const e = t.parentNode;
    e && e.removeChild(t);
  },
  createElement: (t, e, r, n) => {
    const i = e ? Gc.createElementNS(pR, t) : Gc.createElement(t, r ? { is: r } : void 0);
    return t === "select" && n && n.multiple != null && i.setAttribute("multiple", n.multiple), i;
  },
  createText: (t) => Gc.createTextNode(t),
  createComment: (t) => Gc.createComment(t),
  setText: (t, e) => {
    t.nodeValue = e;
  },
  setElementText: (t, e) => {
    t.textContent = e;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => Gc.querySelector(t),
  setScopeId(t, e) {
    t.setAttribute(e, "");
  },
  insertStaticContent(t, e, r, n, i, l) {
    const h = r ? r.previousSibling : e.lastChild;
    if (i && (i === l || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), r), !(i === l || !(i = i.nextSibling)); )
        ;
    else {
      Yb.innerHTML = n ? `<svg>${t}</svg>` : t;
      const s = Yb.content;
      if (n) {
        const m = s.firstChild;
        for (; m.firstChild; )
          s.appendChild(m.firstChild);
        s.removeChild(m);
      }
      e.insertBefore(s, r);
    }
    return [
      h ? h.nextSibling : e.firstChild,
      r ? r.previousSibling : e.lastChild
    ];
  }
};
function gR(t, e, r) {
  const n = t._vtc;
  n && (e = (e ? [e, ...n] : [...n]).join(" ")), e == null ? t.removeAttribute("class") : r ? t.setAttribute("class", e) : t.className = e;
}
function yR(t, e, r) {
  const n = t.style, i = Nn(r);
  if (r && !i) {
    if (e && !Nn(e))
      for (const l in e)
        r[l] == null && h0(n, l, "");
    for (const l in r)
      h0(n, l, r[l]);
  } else {
    const l = n.display;
    i ? e !== r && (n.cssText = r) : e && t.removeAttribute("style"), "_vod" in t && (n.display = l);
  }
}
const _R = /[^\\];\s*$/, Jb = /\s*!important$/;
function h0(t, e, r) {
  if (Zt(r))
    r.forEach((n) => h0(t, e, n));
  else if (r == null && (r = ""), process.env.NODE_ENV !== "production" && _R.test(r) && st(`Unexpected semicolon at the end of '${e}' style value: '${r}'`), e.startsWith("--"))
    t.setProperty(e, r);
  else {
    const n = vR(t, e);
    Jb.test(r) ? t.setProperty(Mo(n), r.replace(Jb, ""), "important") : t[n] = r;
  }
}
const Qb = ["Webkit", "Moz", "ms"], nv = {};
function vR(t, e) {
  const r = nv[e];
  if (r)
    return r;
  let n = Go(e);
  if (n !== "filter" && n in t)
    return nv[e] = n;
  n = ru(n);
  for (let i = 0; i < Qb.length; i++) {
    const l = Qb[i] + n;
    if (l in t)
      return nv[e] = l;
  }
  return e;
}
const ew = "http://www.w3.org/1999/xlink";
function xR(t, e, r, n, i) {
  if (n && e.startsWith("xlink:"))
    r == null ? t.removeAttributeNS(ew, e.slice(6, e.length)) : t.setAttributeNS(ew, e, r);
  else {
    const l = BP(e);
    r == null || l && !vT(r) ? t.removeAttribute(e) : t.setAttribute(e, l ? "" : r);
  }
}
function bR(t, e, r, n, i, l, h) {
  if (e === "innerHTML" || e === "textContent") {
    n && h(n, i, l), t[e] = r == null ? "" : r;
    return;
  }
  if (e === "value" && t.tagName !== "PROGRESS" && !t.tagName.includes("-")) {
    t._value = r;
    const m = r == null ? "" : r;
    (t.value !== m || t.tagName === "OPTION") && (t.value = m), r == null && t.removeAttribute(e);
    return;
  }
  let s = !1;
  if (r === "" || r == null) {
    const m = typeof t[e];
    m === "boolean" ? r = vT(r) : r == null && m === "string" ? (r = "", s = !0) : m === "number" && (r = 0, s = !0);
  }
  try {
    t[e] = r;
  } catch (m) {
    process.env.NODE_ENV !== "production" && !s && st(`Failed setting prop "${e}" on <${t.tagName.toLowerCase()}>: value ${r} is invalid.`, m);
  }
  s && t.removeAttribute(e);
}
function wR(t, e, r, n) {
  t.addEventListener(e, r, n);
}
function ER(t, e, r, n) {
  t.removeEventListener(e, r, n);
}
function TR(t, e, r, n, i = null) {
  const l = t._vei || (t._vei = {}), h = l[e];
  if (n && h)
    h.value = n;
  else {
    const [s, m] = SR(e);
    if (n) {
      const v = l[e] = IR(n, i);
      wR(t, s, v, m);
    } else
      h && (ER(t, s, h, m), l[e] = void 0);
  }
}
const tw = /(?:Once|Passive|Capture)$/;
function SR(t) {
  let e;
  if (tw.test(t)) {
    e = {};
    let n;
    for (; n = t.match(tw); )
      t = t.slice(0, t.length - n[0].length), e[n[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : Mo(t.slice(2)), e];
}
let iv = 0;
const MR = /* @__PURE__ */ Promise.resolve(), CR = () => iv || (MR.then(() => iv = 0), iv = Date.now());
function IR(t, e) {
  const r = (n) => {
    if (!n._vts)
      n._vts = Date.now();
    else if (n._vts <= r.attached)
      return;
    na(PR(n, r.value), e, 5, [n]);
  };
  return r.value = t, r.attached = CR(), r;
}
function PR(t, e) {
  if (Zt(e)) {
    const r = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      r.call(t), t._stopped = !0;
    }, e.map((n) => (i) => !i._stopped && n && n(i));
  } else
    return e;
}
const rw = /^on[a-z]/, AR = (t, e, r, n, i = !1, l, h, s, m) => {
  e === "class" ? gR(t, n, i) : e === "style" ? yR(t, r, n) : $d(e) ? vg(e) || TR(t, e, r, n, h) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : OR(t, e, n, i)) ? bR(t, e, n, l, h, s, m) : (e === "true-value" ? t._trueValue = n : e === "false-value" && (t._falseValue = n), xR(t, e, n, i));
};
function OR(t, e, r, n) {
  return n ? !!(e === "innerHTML" || e === "textContent" || e in t && rw.test(e) && ar(r)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || rw.test(e) && Nn(r) ? !1 : e in t;
}
const ml = "transition", Zf = "animation", Py = (t, { slots: e }) => DS(lS, RR(t), e);
Py.displayName = "Transition";
const kS = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Py.props = /* @__PURE__ */ kn({}, lS.props, kS);
const Oc = (t, e = []) => {
  Zt(t) ? t.forEach((r) => r(...e)) : t && t(...e);
}, nw = (t) => t ? Zt(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;
function RR(t) {
  const e = {};
  for (const Ve in t)
    Ve in kS || (e[Ve] = t[Ve]);
  if (t.css === !1)
    return e;
  const { name: r = "v", type: n, duration: i, enterFromClass: l = `${r}-enter-from`, enterActiveClass: h = `${r}-enter-active`, enterToClass: s = `${r}-enter-to`, appearFromClass: m = l, appearActiveClass: v = h, appearToClass: E = s, leaveFromClass: T = `${r}-leave-from`, leaveActiveClass: S = `${r}-leave-active`, leaveToClass: A = `${r}-leave-to` } = t, L = LR(i), B = L && L[0], j = L && L[1], { onBeforeEnter: q, onEnter: H, onEnterCancelled: ne, onLeave: ee, onLeaveCancelled: he, onBeforeAppear: Te = q, onAppear: ve = H, onAppearCancelled: Oe = ne } = e, Me = (Ve, dt, xe) => {
    Rc(Ve, dt ? E : s), Rc(Ve, dt ? v : h), xe && xe();
  }, Re = (Ve, dt) => {
    Ve._isLeaving = !1, Rc(Ve, T), Rc(Ve, A), Rc(Ve, S), dt && dt();
  }, He = (Ve) => (dt, xe) => {
    const ze = Ve ? ve : H, Pe = () => Me(dt, Ve, xe);
    Oc(ze, [dt, Pe]), iw(() => {
      Rc(dt, Ve ? m : l), gl(dt, Ve ? E : s), nw(ze) || ow(dt, n, B, Pe);
    });
  };
  return kn(e, {
    onBeforeEnter(Ve) {
      Oc(q, [Ve]), gl(Ve, l), gl(Ve, h);
    },
    onBeforeAppear(Ve) {
      Oc(Te, [Ve]), gl(Ve, m), gl(Ve, v);
    },
    onEnter: He(!1),
    onAppear: He(!0),
    onLeave(Ve, dt) {
      Ve._isLeaving = !0;
      const xe = () => Re(Ve, dt);
      gl(Ve, T), NR(), gl(Ve, S), iw(() => {
        !Ve._isLeaving || (Rc(Ve, T), gl(Ve, A), nw(ee) || ow(Ve, n, j, xe));
      }), Oc(ee, [Ve, xe]);
    },
    onEnterCancelled(Ve) {
      Me(Ve, !1), Oc(ne, [Ve]);
    },
    onAppearCancelled(Ve) {
      Me(Ve, !0), Oc(Oe, [Ve]);
    },
    onLeaveCancelled(Ve) {
      Re(Ve), Oc(he, [Ve]);
    }
  });
}
function LR(t) {
  if (t == null)
    return null;
  if (rn(t))
    return [ov(t.enter), ov(t.leave)];
  {
    const e = ov(t);
    return [e, e];
  }
}
function ov(t) {
  const e = Wv(t);
  return process.env.NODE_ENV !== "production" && RA(e, "<transition> explicit duration"), e;
}
function gl(t, e) {
  e.split(/\s+/).forEach((r) => r && t.classList.add(r)), (t._vtc || (t._vtc = /* @__PURE__ */ new Set())).add(e);
}
function Rc(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.remove(n));
  const { _vtc: r } = t;
  r && (r.delete(e), r.size || (t._vtc = void 0));
}
function iw(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let DR = 0;
function ow(t, e, r, n) {
  const i = t._endId = ++DR, l = () => {
    i === t._endId && n();
  };
  if (r)
    return setTimeout(l, r);
  const { type: h, timeout: s, propCount: m } = kR(t, e);
  if (!h)
    return n();
  const v = h + "end";
  let E = 0;
  const T = () => {
    t.removeEventListener(v, S), l();
  }, S = (A) => {
    A.target === t && ++E >= m && T();
  };
  setTimeout(() => {
    E < m && T();
  }, s + 1), t.addEventListener(v, S);
}
function kR(t, e) {
  const r = window.getComputedStyle(t), n = (L) => (r[L] || "").split(", "), i = n(`${ml}Delay`), l = n(`${ml}Duration`), h = aw(i, l), s = n(`${Zf}Delay`), m = n(`${Zf}Duration`), v = aw(s, m);
  let E = null, T = 0, S = 0;
  e === ml ? h > 0 && (E = ml, T = h, S = l.length) : e === Zf ? v > 0 && (E = Zf, T = v, S = m.length) : (T = Math.max(h, v), E = T > 0 ? h > v ? ml : Zf : null, S = E ? E === ml ? l.length : m.length : 0);
  const A = E === ml && /\b(transform|all)(,|$)/.test(n(`${ml}Property`).toString());
  return {
    type: E,
    timeout: T,
    propCount: S,
    hasTransform: A
  };
}
function aw(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((r, n) => sw(r) + sw(t[n])));
}
function sw(t) {
  return Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function NR() {
  return document.body.offsetHeight;
}
const FR = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, ih = (t, e) => (r) => {
  if (!("key" in r))
    return;
  const n = Mo(r.key);
  if (e.some((i) => i === n || FR[i] === n))
    return t(r);
}, zR = /* @__PURE__ */ kn({ patchProp: AR }, mR);
let lw;
function NS() {
  return lw || (lw = qO(zR));
}
const cw = (...t) => {
  NS().render(...t);
}, BR = (...t) => {
  const e = NS().createApp(...t);
  process.env.NODE_ENV !== "production" && (UR(e), $R(e));
  const { mount: r } = e;
  return e.mount = (n) => {
    const i = VR(n);
    if (!i)
      return;
    const l = e._component;
    !ar(l) && !l.render && !l.template && (l.template = i.innerHTML), i.innerHTML = "";
    const h = r(i, !1, i instanceof SVGElement);
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), h;
  }, e;
};
function UR(t) {
  Object.defineProperty(t.config, "isNativeTag", {
    value: (e) => NP(e) || FP(e),
    writable: !1
  });
}
function $R(t) {
  {
    const e = t.config.isCustomElement;
    Object.defineProperty(t.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        st("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.");
      }
    });
    const r = t.config.compilerOptions, n = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom';
    Object.defineProperty(t.config, "compilerOptions", {
      get() {
        return st(n), r;
      },
      set() {
        st(n);
      }
    });
  }
}
function VR(t) {
  if (Nn(t)) {
    const e = document.querySelector(t);
    return process.env.NODE_ENV !== "production" && !e && st(`Failed to mount app: mount target selector "${t}" returned null.`), e;
  }
  return process.env.NODE_ENV !== "production" && window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && st('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'), t;
}
function jR() {
  dR();
}
process.env.NODE_ENV !== "production" && jR();
/*! @license DOMPurify 2.4.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.5/LICENSE */
function Il(t) {
  return Il = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Il(t);
}
function f0(t, e) {
  return f0 = Object.setPrototypeOf || function(n, i) {
    return n.__proto__ = i, n;
  }, f0(t, e);
}
function GR() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function ig(t, e, r) {
  return GR() ? ig = Reflect.construct : ig = function(i, l, h) {
    var s = [null];
    s.push.apply(s, l);
    var m = Function.bind.apply(i, s), v = new m();
    return h && f0(v, h.prototype), v;
  }, ig.apply(null, arguments);
}
function xa(t) {
  return qR(t) || WR(t) || XR(t) || ZR();
}
function qR(t) {
  if (Array.isArray(t))
    return d0(t);
}
function WR(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function XR(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return d0(t, e);
    var r = Object.prototype.toString.call(t).slice(8, -1);
    if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set")
      return Array.from(t);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return d0(t, e);
  }
}
function d0(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = new Array(e); r < e; r++)
    n[r] = t[r];
  return n;
}
function ZR() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var HR = Object.hasOwnProperty, uw = Object.setPrototypeOf, KR = Object.isFrozen, YR = Object.getPrototypeOf, JR = Object.getOwnPropertyDescriptor, go = Object.freeze, La = Object.seal, QR = Object.create, FS = typeof Reflect < "u" && Reflect, Og = FS.apply, p0 = FS.construct;
Og || (Og = function(e, r, n) {
  return e.apply(r, n);
});
go || (go = function(e) {
  return e;
});
La || (La = function(e) {
  return e;
});
p0 || (p0 = function(e, r) {
  return ig(e, xa(r));
});
var eL = oa(Array.prototype.forEach), hw = oa(Array.prototype.pop), Hf = oa(Array.prototype.push), og = oa(String.prototype.toLowerCase), av = oa(String.prototype.toString), tL = oa(String.prototype.match), ga = oa(String.prototype.replace), rL = oa(String.prototype.indexOf), nL = oa(String.prototype.trim), so = oa(RegExp.prototype.test), sv = iL(TypeError);
function oa(t) {
  return function(e) {
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
      n[i - 1] = arguments[i];
    return Og(t, e, n);
  };
}
function iL(t) {
  return function() {
    for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
      r[n] = arguments[n];
    return p0(t, r);
  };
}
function wr(t, e, r) {
  r = r || og, uw && uw(t, null);
  for (var n = e.length; n--; ) {
    var i = e[n];
    if (typeof i == "string") {
      var l = r(i);
      l !== i && (KR(e) || (e[n] = l), i = l);
    }
    t[i] = !0;
  }
  return t;
}
function Lc(t) {
  var e = QR(null), r;
  for (r in t)
    Og(HR, t, [r]) === !0 && (e[r] = t[r]);
  return e;
}
function Mm(t, e) {
  for (; t !== null; ) {
    var r = JR(t, e);
    if (r) {
      if (r.get)
        return oa(r.get);
      if (typeof r.value == "function")
        return oa(r.value);
    }
    t = YR(t);
  }
  function n(i) {
    return console.warn("fallback value for", i), null;
  }
  return n;
}
var fw = go(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), lv = go(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), cv = go(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), oL = go(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), uv = go(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), aL = go(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), dw = go(["#text"]), pw = go(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), hv = go(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mw = go(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Cm = go(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), sL = La(/\{\{[\w\W]*|[\w\W]*\}\}/gm), lL = La(/<%[\w\W]*|[\w\W]*%>/gm), cL = La(/\${[\w\W]*}/gm), uL = La(/^data-[\-\w.\u00B7-\uFFFF]/), hL = La(/^aria-[\-\w]+$/), fL = La(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
), dL = La(/^(?:\w+script|data):/i), pL = La(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
), mL = La(/^html$/i), gL = function() {
  return typeof window > "u" ? null : window;
}, yL = function(e, r) {
  if (Il(e) !== "object" || typeof e.createPolicy != "function")
    return null;
  var n = null, i = "data-tt-policy-suffix";
  r.currentScript && r.currentScript.hasAttribute(i) && (n = r.currentScript.getAttribute(i));
  var l = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(l, {
      createHTML: function(s) {
        return s;
      },
      createScriptURL: function(s) {
        return s;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + l + " could not be created."), null;
  }
};
function zS() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : gL(), e = function(J) {
    return zS(J);
  };
  if (e.version = "2.4.5", e.removed = [], !t || !t.document || t.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var r = t.document, n = t.document, i = t.DocumentFragment, l = t.HTMLTemplateElement, h = t.Node, s = t.Element, m = t.NodeFilter, v = t.NamedNodeMap, E = v === void 0 ? t.NamedNodeMap || t.MozNamedAttrMap : v, T = t.HTMLFormElement, S = t.DOMParser, A = t.trustedTypes, L = s.prototype, B = Mm(L, "cloneNode"), j = Mm(L, "nextSibling"), q = Mm(L, "childNodes"), H = Mm(L, "parentNode");
  if (typeof l == "function") {
    var ne = n.createElement("template");
    ne.content && ne.content.ownerDocument && (n = ne.content.ownerDocument);
  }
  var ee = yL(A, r), he = ee ? ee.createHTML("") : "", Te = n, ve = Te.implementation, Oe = Te.createNodeIterator, Me = Te.createDocumentFragment, Re = Te.getElementsByTagName, He = r.importNode, Ve = {};
  try {
    Ve = Lc(n).documentMode ? n.documentMode : {};
  } catch {
  }
  var dt = {};
  e.isSupported = typeof H == "function" && ve && typeof ve.createHTMLDocument < "u" && Ve !== 9;
  var xe = sL, ze = lL, Pe = cL, Ye = uL, it = hL, kt = dL, Er = pL, mr = fL, Yt = null, on = wr({}, [].concat(xa(fw), xa(lv), xa(cv), xa(uv), xa(dw))), or = null, Jt = wr({}, [].concat(xa(pw), xa(hv), xa(mw), xa(Cm))), Ht = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), xr = null, Cr = null, an = !0, kr = !0, Pn = !1, qr = !0, re = !1, pe = !1, ke = !1, Ze = !1, Ge = !1, rt = !1, Xe = !1, Je = !0, at = !1, Ke = "user-content-", At = !0, mt = !1, St = {}, Ut = null, Wt = wr({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Ce = null, We = wr({}, ["audio", "video", "img", "source", "image", "track"]), br = null, Wr = wr({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Xt = "http://www.w3.org/1998/Math/MathML", gn = "http://www.w3.org/2000/svg", Br = "http://www.w3.org/1999/xhtml", Ir = Br, Yr = !1, nt = null, Kt = wr({}, [Xt, gn, Br], av), Gt, Kn = ["application/xhtml+xml", "text/html"], qo = "text/html", Lt, vi = null, Vn = n.createElement("form"), sa = function(J) {
    return J instanceof RegExp || J instanceof Function;
  }, Tn = function(J) {
    vi && vi === J || ((!J || Il(J) !== "object") && (J = {}), J = Lc(J), Gt = Kn.indexOf(J.PARSER_MEDIA_TYPE) === -1 ? Gt = qo : Gt = J.PARSER_MEDIA_TYPE, Lt = Gt === "application/xhtml+xml" ? av : og, Yt = "ALLOWED_TAGS" in J ? wr({}, J.ALLOWED_TAGS, Lt) : on, or = "ALLOWED_ATTR" in J ? wr({}, J.ALLOWED_ATTR, Lt) : Jt, nt = "ALLOWED_NAMESPACES" in J ? wr({}, J.ALLOWED_NAMESPACES, av) : Kt, br = "ADD_URI_SAFE_ATTR" in J ? wr(
      Lc(Wr),
      J.ADD_URI_SAFE_ATTR,
      Lt
    ) : Wr, Ce = "ADD_DATA_URI_TAGS" in J ? wr(
      Lc(We),
      J.ADD_DATA_URI_TAGS,
      Lt
    ) : We, Ut = "FORBID_CONTENTS" in J ? wr({}, J.FORBID_CONTENTS, Lt) : Wt, xr = "FORBID_TAGS" in J ? wr({}, J.FORBID_TAGS, Lt) : {}, Cr = "FORBID_ATTR" in J ? wr({}, J.FORBID_ATTR, Lt) : {}, St = "USE_PROFILES" in J ? J.USE_PROFILES : !1, an = J.ALLOW_ARIA_ATTR !== !1, kr = J.ALLOW_DATA_ATTR !== !1, Pn = J.ALLOW_UNKNOWN_PROTOCOLS || !1, qr = J.ALLOW_SELF_CLOSE_IN_ATTR !== !1, re = J.SAFE_FOR_TEMPLATES || !1, pe = J.WHOLE_DOCUMENT || !1, Ge = J.RETURN_DOM || !1, rt = J.RETURN_DOM_FRAGMENT || !1, Xe = J.RETURN_TRUSTED_TYPE || !1, Ze = J.FORCE_BODY || !1, Je = J.SANITIZE_DOM !== !1, at = J.SANITIZE_NAMED_PROPS || !1, At = J.KEEP_CONTENT !== !1, mt = J.IN_PLACE || !1, mr = J.ALLOWED_URI_REGEXP || mr, Ir = J.NAMESPACE || Br, Ht = J.CUSTOM_ELEMENT_HANDLING || {}, J.CUSTOM_ELEMENT_HANDLING && sa(J.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Ht.tagNameCheck = J.CUSTOM_ELEMENT_HANDLING.tagNameCheck), J.CUSTOM_ELEMENT_HANDLING && sa(J.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Ht.attributeNameCheck = J.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), J.CUSTOM_ELEMENT_HANDLING && typeof J.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Ht.allowCustomizedBuiltInElements = J.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), re && (kr = !1), rt && (Ge = !0), St && (Yt = wr({}, xa(dw)), or = [], St.html === !0 && (wr(Yt, fw), wr(or, pw)), St.svg === !0 && (wr(Yt, lv), wr(or, hv), wr(or, Cm)), St.svgFilters === !0 && (wr(Yt, cv), wr(or, hv), wr(or, Cm)), St.mathMl === !0 && (wr(Yt, uv), wr(or, mw), wr(or, Cm))), J.ADD_TAGS && (Yt === on && (Yt = Lc(Yt)), wr(Yt, J.ADD_TAGS, Lt)), J.ADD_ATTR && (or === Jt && (or = Lc(or)), wr(or, J.ADD_ATTR, Lt)), J.ADD_URI_SAFE_ATTR && wr(br, J.ADD_URI_SAFE_ATTR, Lt), J.FORBID_CONTENTS && (Ut === Wt && (Ut = Lc(Ut)), wr(Ut, J.FORBID_CONTENTS, Lt)), At && (Yt["#text"] = !0), pe && wr(Yt, ["html", "head", "body"]), Yt.table && (wr(Yt, ["tbody"]), delete xr.tbody), go && go(J), vi = J);
  }, ni = wr({}, ["mi", "mo", "mn", "ms", "mtext"]), Rr = wr({}, ["foreignobject", "desc", "title", "annotation-xml"]), Na = wr({}, ["title", "style", "font", "a", "script"]), Ri = wr({}, lv);
  wr(Ri, cv), wr(Ri, oL);
  var Ao = wr({}, uv);
  wr(Ao, aL);
  var la = function(J) {
    var ue = H(J);
    (!ue || !ue.tagName) && (ue = {
      namespaceURI: Ir,
      tagName: "template"
    });
    var Ne = og(J.tagName), ot = og(ue.tagName);
    return nt[J.namespaceURI] ? J.namespaceURI === gn ? ue.namespaceURI === Br ? Ne === "svg" : ue.namespaceURI === Xt ? Ne === "svg" && (ot === "annotation-xml" || ni[ot]) : Boolean(Ri[Ne]) : J.namespaceURI === Xt ? ue.namespaceURI === Br ? Ne === "math" : ue.namespaceURI === gn ? Ne === "math" && Rr[ot] : Boolean(Ao[Ne]) : J.namespaceURI === Br ? ue.namespaceURI === gn && !Rr[ot] || ue.namespaceURI === Xt && !ni[ot] ? !1 : !Ao[Ne] && (Na[Ne] || !Ri[Ne]) : !!(Gt === "application/xhtml+xml" && nt[J.namespaceURI]) : !1;
  }, xi = function(J) {
    Hf(e.removed, {
      element: J
    });
    try {
      J.parentNode.removeChild(J);
    } catch {
      try {
        J.outerHTML = he;
      } catch {
        J.remove();
      }
    }
  }, Oo = function(J, ue) {
    try {
      Hf(e.removed, {
        attribute: ue.getAttributeNode(J),
        from: ue
      });
    } catch {
      Hf(e.removed, {
        attribute: null,
        from: ue
      });
    }
    if (ue.removeAttribute(J), J === "is" && !or[J])
      if (Ge || rt)
        try {
          xi(ue);
        } catch {
        }
      else
        try {
          ue.setAttribute(J, "");
        } catch {
        }
  }, Y = function(J) {
    var ue, Ne;
    if (Ze)
      J = "<remove></remove>" + J;
    else {
      var ot = tL(J, /^[\r\n\t ]+/);
      Ne = ot && ot[0];
    }
    Gt === "application/xhtml+xml" && Ir === Br && (J = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + J + "</body></html>");
    var lt = ee ? ee.createHTML(J) : J;
    if (Ir === Br)
      try {
        ue = new S().parseFromString(lt, Gt);
      } catch {
      }
    if (!ue || !ue.documentElement) {
      ue = ve.createDocument(Ir, "template", null);
      try {
        ue.documentElement.innerHTML = Yr ? he : lt;
      } catch {
      }
    }
    var Mt = ue.body || ue.documentElement;
    return J && Ne && Mt.insertBefore(n.createTextNode(Ne), Mt.childNodes[0] || null), Ir === Br ? Re.call(ue, pe ? "html" : "body")[0] : pe ? ue.documentElement : Mt;
  }, k = function(J) {
    return Oe.call(
      J.ownerDocument || J,
      J,
      m.SHOW_ELEMENT | m.SHOW_COMMENT | m.SHOW_TEXT,
      null,
      !1
    );
  }, U = function(J) {
    return J instanceof T && (typeof J.nodeName != "string" || typeof J.textContent != "string" || typeof J.removeChild != "function" || !(J.attributes instanceof E) || typeof J.removeAttribute != "function" || typeof J.setAttribute != "function" || typeof J.namespaceURI != "string" || typeof J.insertBefore != "function" || typeof J.hasChildNodes != "function");
  }, Z = function(J) {
    return Il(h) === "object" ? J instanceof h : J && Il(J) === "object" && typeof J.nodeType == "number" && typeof J.nodeName == "string";
  }, K = function(J, ue, Ne) {
    !dt[J] || eL(dt[J], function(ot) {
      ot.call(e, ue, Ne, vi);
    });
  }, le = function(J) {
    var ue;
    if (K("beforeSanitizeElements", J, null), U(J) || so(/[\u0080-\uFFFF]/, J.nodeName))
      return xi(J), !0;
    var Ne = Lt(J.nodeName);
    if (K("uponSanitizeElement", J, {
      tagName: Ne,
      allowedTags: Yt
    }), J.hasChildNodes() && !Z(J.firstElementChild) && (!Z(J.content) || !Z(J.content.firstElementChild)) && so(/<[/\w]/g, J.innerHTML) && so(/<[/\w]/g, J.textContent) || Ne === "select" && so(/<template/i, J.innerHTML))
      return xi(J), !0;
    if (!Yt[Ne] || xr[Ne]) {
      if (!xr[Ne] && fe(Ne) && (Ht.tagNameCheck instanceof RegExp && so(Ht.tagNameCheck, Ne) || Ht.tagNameCheck instanceof Function && Ht.tagNameCheck(Ne)))
        return !1;
      if (At && !Ut[Ne]) {
        var ot = H(J) || J.parentNode, lt = q(J) || J.childNodes;
        if (lt && ot)
          for (var Mt = lt.length, Pt = Mt - 1; Pt >= 0; --Pt)
            ot.insertBefore(B(lt[Pt], !0), j(J));
      }
      return xi(J), !0;
    }
    return J instanceof s && !la(J) || (Ne === "noscript" || Ne === "noembed") && so(/<\/no(script|embed)/i, J.innerHTML) ? (xi(J), !0) : (re && J.nodeType === 3 && (ue = J.textContent, ue = ga(ue, xe, " "), ue = ga(ue, ze, " "), ue = ga(ue, Pe, " "), J.textContent !== ue && (Hf(e.removed, {
      element: J.cloneNode()
    }), J.textContent = ue)), K("afterSanitizeElements", J, null), !1);
  }, me = function(J, ue, Ne) {
    if (Je && (ue === "id" || ue === "name") && (Ne in n || Ne in Vn))
      return !1;
    if (!(kr && !Cr[ue] && so(Ye, ue))) {
      if (!(an && so(it, ue))) {
        if (!or[ue] || Cr[ue]) {
          if (!(fe(J) && (Ht.tagNameCheck instanceof RegExp && so(Ht.tagNameCheck, J) || Ht.tagNameCheck instanceof Function && Ht.tagNameCheck(J)) && (Ht.attributeNameCheck instanceof RegExp && so(Ht.attributeNameCheck, ue) || Ht.attributeNameCheck instanceof Function && Ht.attributeNameCheck(ue)) || ue === "is" && Ht.allowCustomizedBuiltInElements && (Ht.tagNameCheck instanceof RegExp && so(Ht.tagNameCheck, Ne) || Ht.tagNameCheck instanceof Function && Ht.tagNameCheck(Ne))))
            return !1;
        } else if (!br[ue]) {
          if (!so(mr, ga(Ne, Er, ""))) {
            if (!((ue === "src" || ue === "xlink:href" || ue === "href") && J !== "script" && rL(Ne, "data:") === 0 && Ce[J])) {
              if (!(Pn && !so(kt, ga(Ne, Er, "")))) {
                if (Ne)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, fe = function(J) {
    return J.indexOf("-") > 0;
  }, ce = function(J) {
    var ue, Ne, ot, lt;
    K("beforeSanitizeAttributes", J, null);
    var Mt = J.attributes;
    if (!!Mt) {
      var Pt = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: or
      };
      for (lt = Mt.length; lt--; ) {
        ue = Mt[lt];
        var ur = ue, Rt = ur.name, Qt = ur.namespaceURI;
        if (Ne = Rt === "value" ? ue.value : nL(ue.value), ot = Lt(Rt), Pt.attrName = ot, Pt.attrValue = Ne, Pt.keepAttr = !0, Pt.forceKeepAttr = void 0, K("uponSanitizeAttribute", J, Pt), Ne = Pt.attrValue, !Pt.forceKeepAttr && (Oo(Rt, J), !!Pt.keepAttr)) {
          if (!qr && so(/\/>/i, Ne)) {
            Oo(Rt, J);
            continue;
          }
          re && (Ne = ga(Ne, xe, " "), Ne = ga(Ne, ze, " "), Ne = ga(Ne, Pe, " "));
          var gr = Lt(J.nodeName);
          if (!!me(gr, ot, Ne)) {
            if (at && (ot === "id" || ot === "name") && (Oo(Rt, J), Ne = Ke + Ne), ee && Il(A) === "object" && typeof A.getAttributeType == "function" && !Qt)
              switch (A.getAttributeType(gr, ot)) {
                case "TrustedHTML":
                  Ne = ee.createHTML(Ne);
                  break;
                case "TrustedScriptURL":
                  Ne = ee.createScriptURL(Ne);
                  break;
              }
            try {
              Qt ? J.setAttributeNS(Qt, Rt, Ne) : J.setAttribute(Rt, Ne), hw(e.removed);
            } catch {
            }
          }
        }
      }
      K("afterSanitizeAttributes", J, null);
    }
  }, ge = function ye(J) {
    var ue, Ne = k(J);
    for (K("beforeSanitizeShadowDOM", J, null); ue = Ne.nextNode(); )
      K("uponSanitizeShadowNode", ue, null), !le(ue) && (ue.content instanceof i && ye(ue.content), ce(ue));
    K("afterSanitizeShadowDOM", J, null);
  };
  return e.sanitize = function(ye) {
    var J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ue, Ne, ot, lt, Mt;
    if (Yr = !ye, Yr && (ye = "<!-->"), typeof ye != "string" && !Z(ye)) {
      if (typeof ye.toString != "function")
        throw sv("toString is not a function");
      if (ye = ye.toString(), typeof ye != "string")
        throw sv("dirty is not a string, aborting");
    }
    if (!e.isSupported) {
      if (Il(t.toStaticHTML) === "object" || typeof t.toStaticHTML == "function") {
        if (typeof ye == "string")
          return t.toStaticHTML(ye);
        if (Z(ye))
          return t.toStaticHTML(ye.outerHTML);
      }
      return ye;
    }
    if (ke || Tn(J), e.removed = [], typeof ye == "string" && (mt = !1), mt) {
      if (ye.nodeName) {
        var Pt = Lt(ye.nodeName);
        if (!Yt[Pt] || xr[Pt])
          throw sv("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (ye instanceof h)
      ue = Y("<!---->"), Ne = ue.ownerDocument.importNode(ye, !0), Ne.nodeType === 1 && Ne.nodeName === "BODY" || Ne.nodeName === "HTML" ? ue = Ne : ue.appendChild(Ne);
    else {
      if (!Ge && !re && !pe && ye.indexOf("<") === -1)
        return ee && Xe ? ee.createHTML(ye) : ye;
      if (ue = Y(ye), !ue)
        return Ge ? null : Xe ? he : "";
    }
    ue && Ze && xi(ue.firstChild);
    for (var ur = k(mt ? ye : ue); ot = ur.nextNode(); )
      ot.nodeType === 3 && ot === lt || le(ot) || (ot.content instanceof i && ge(ot.content), ce(ot), lt = ot);
    if (lt = null, mt)
      return ye;
    if (Ge) {
      if (rt)
        for (Mt = Me.call(ue.ownerDocument); ue.firstChild; )
          Mt.appendChild(ue.firstChild);
      else
        Mt = ue;
      return (or.shadowroot || or.shadowrootmod) && (Mt = He.call(r, Mt, !0)), Mt;
    }
    var Rt = pe ? ue.outerHTML : ue.innerHTML;
    return pe && Yt["!doctype"] && ue.ownerDocument && ue.ownerDocument.doctype && ue.ownerDocument.doctype.name && so(mL, ue.ownerDocument.doctype.name) && (Rt = "<!DOCTYPE " + ue.ownerDocument.doctype.name + `>
` + Rt), re && (Rt = ga(Rt, xe, " "), Rt = ga(Rt, ze, " "), Rt = ga(Rt, Pe, " ")), ee && Xe ? ee.createHTML(Rt) : Rt;
  }, e.setConfig = function(ye) {
    Tn(ye), ke = !0;
  }, e.clearConfig = function() {
    vi = null, ke = !1;
  }, e.isValidAttribute = function(ye, J, ue) {
    vi || Tn({});
    var Ne = Lt(ye), ot = Lt(J);
    return me(Ne, ot, ue);
  }, e.addHook = function(ye, J) {
    typeof J == "function" && (dt[ye] = dt[ye] || [], Hf(dt[ye], J));
  }, e.removeHook = function(ye) {
    if (dt[ye])
      return hw(dt[ye]);
  }, e.removeHooks = function(ye) {
    dt[ye] && (dt[ye] = []);
  }, e.removeAllHooks = function() {
    dt = {};
  }, e;
}
var _L = zS(), BS = !1;
function Im(t, e, r) {
  return Array.isArray(t) ? (t.length = Math.max(t.length, e), t.splice(e, 1, r), r) : (t[e] = r, r);
}
function fv(t, e) {
  if (Array.isArray(t)) {
    t.splice(e, 1);
    return;
  }
  delete t[e];
}
function vL(t, e) {
  var i;
  const r = (i = t.hooks) != null ? i : {};
  let n;
  for (n in r) {
    const l = r[n];
    l !== void 0 && e.addHook(n, l);
  }
}
function US() {
  return _L();
}
function xL(t = {}, e = US) {
  const r = e();
  vL(t, r);
  const n = function(i, l) {
    var T, S;
    const h = l.value;
    if (l.oldValue === h)
      return;
    const s = `${h}`, m = l.arg, v = t.namedConfigurations, E = (T = t.default) != null ? T : {};
    if (v && m !== void 0) {
      i.innerHTML = r.sanitize(
        s,
        (S = v[m]) != null ? S : E
      );
      return;
    }
    i.innerHTML = r.sanitize(
      s,
      E
    );
  };
  return {
    mounted: n,
    updated: n
  };
}
const bL = {
  install(t, e = {}, r = US) {
    t.directive(
      "dompurify-html",
      xL(e, r)
    );
  }
};
function wL() {
  return $S().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function $S() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
}
const EL = typeof Proxy == "function", TL = "devtools-plugin:setup", SL = "plugin:settings:set";
let Zu, m0;
function ML() {
  var t;
  return Zu !== void 0 || (typeof window < "u" && window.performance ? (Zu = !0, m0 = window.performance) : typeof global < "u" && ((t = global.perf_hooks) === null || t === void 0 ? void 0 : t.performance) ? (Zu = !0, m0 = global.perf_hooks.performance) : Zu = !1), Zu;
}
function CL() {
  return ML() ? m0.now() : Date.now();
}
class IL {
  constructor(e, r) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e, this.hook = r;
    const n = {};
    if (e.settings)
      for (const h in e.settings) {
        const s = e.settings[h];
        n[h] = s.defaultValue;
      }
    const i = `__vue-devtools-plugin-settings__${e.id}`;
    let l = Object.assign({}, n);
    try {
      const h = localStorage.getItem(i), s = JSON.parse(h);
      Object.assign(l, s);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return l;
      },
      setSettings(h) {
        try {
          localStorage.setItem(i, JSON.stringify(h));
        } catch {
        }
        l = h;
      },
      now() {
        return CL();
      }
    }, r && r.on(SL, (h, s) => {
      h === this.plugin.id && this.fallbacks.setSettings(s);
    }), this.proxiedOn = new Proxy({}, {
      get: (h, s) => this.target ? this.target.on[s] : (...m) => {
        this.onQueue.push({
          method: s,
          args: m
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (h, s) => this.target ? this.target[s] : s === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(s) ? (...m) => (this.targetQueue.push({
        method: s,
        args: m,
        resolve: () => {
        }
      }), this.fallbacks[s](...m)) : (...m) => new Promise((v) => {
        this.targetQueue.push({
          method: s,
          args: m,
          resolve: v
        });
      })
    });
  }
  async setRealTarget(e) {
    this.target = e;
    for (const r of this.onQueue)
      this.target.on[r.method](...r.args);
    for (const r of this.targetQueue)
      r.resolve(await this.target[r.method](...r.args));
  }
}
function VS(t, e) {
  const r = t, n = $S(), i = wL(), l = EL && r.enableEarlyProxy;
  if (i && (n.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !l))
    i.emit(TL, t, e);
  else {
    const h = l ? new IL(r, i) : null;
    (n.__VUE_DEVTOOLS_PLUGINS__ = n.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: r,
      setupFn: e,
      proxy: h
    }), h && e(h.proxiedTarget);
  }
}
/*!
  * pinia v2.0.33
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
let td;
const Od = (t) => td = t, jS = process.env.NODE_ENV !== "production" ? Symbol("pinia") : Symbol();
function iu(t) {
  return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
}
var ts;
(function(t) {
  t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
})(ts || (ts = {}));
const Ay = typeof window < "u", pd = (process.env.NODE_ENV !== "production" || !1) && process.env.NODE_ENV !== "test" && Ay, gw = /* @__PURE__ */ (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : { HTMLElement: null })();
function PL(t, { autoBom: e = !1 } = {}) {
  return e && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], { type: t.type }) : t;
}
function dx(t, e, r) {
  const n = new XMLHttpRequest();
  n.open("GET", t), n.responseType = "blob", n.onload = function() {
    WS(n.response, e, r);
  }, n.onerror = function() {
    console.error("could not download file");
  }, n.send();
}
function GS(t) {
  const e = new XMLHttpRequest();
  e.open("HEAD", t, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function ag(t) {
  try {
    t.dispatchEvent(new MouseEvent("click"));
  } catch {
    const r = document.createEvent("MouseEvents");
    r.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), t.dispatchEvent(r);
  }
}
const sg = typeof navigator == "object" ? navigator : { userAgent: "" }, qS = /* @__PURE__ */ (() => /Macintosh/.test(sg.userAgent) && /AppleWebKit/.test(sg.userAgent) && !/Safari/.test(sg.userAgent))(), WS = Ay ? typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !qS ? AL : "msSaveOrOpenBlob" in sg ? OL : RL : () => {
};
function AL(t, e = "download", r) {
  const n = document.createElement("a");
  n.download = e, n.rel = "noopener", typeof t == "string" ? (n.href = t, n.origin !== location.origin ? GS(n.href) ? dx(t, e, r) : (n.target = "_blank", ag(n)) : ag(n)) : (n.href = URL.createObjectURL(t), setTimeout(function() {
    URL.revokeObjectURL(n.href);
  }, 4e4), setTimeout(function() {
    ag(n);
  }, 0));
}
function OL(t, e = "download", r) {
  if (typeof t == "string")
    if (GS(t))
      dx(t, e, r);
    else {
      const n = document.createElement("a");
      n.href = t, n.target = "_blank", setTimeout(function() {
        ag(n);
      });
    }
  else
    navigator.msSaveOrOpenBlob(PL(t, r), e);
}
function RL(t, e, r, n) {
  if (n = n || open("", "_blank"), n && (n.document.title = n.document.body.innerText = "downloading..."), typeof t == "string")
    return dx(t, e, r);
  const i = t.type === "application/octet-stream", l = /constructor/i.test(String(gw.HTMLElement)) || "safari" in gw, h = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((h || i && l || qS) && typeof FileReader < "u") {
    const s = new FileReader();
    s.onloadend = function() {
      let m = s.result;
      if (typeof m != "string")
        throw n = null, new Error("Wrong reader.result type");
      m = h ? m : m.replace(/^data:[^;]*;/, "data:attachment/file;"), n ? n.location.href = m : location.assign(m), n = null;
    }, s.readAsDataURL(t);
  } else {
    const s = URL.createObjectURL(t);
    n ? n.location.assign(s) : location.href = s, n = null, setTimeout(function() {
      URL.revokeObjectURL(s);
    }, 4e4);
  }
}
function Ci(t, e) {
  const r = "\u{1F34D} " + t;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(r, e) : e === "error" ? console.error(r) : e === "warn" ? console.warn(r) : console.log(r);
}
function px(t) {
  return "_a" in t && "install" in t;
}
function XS() {
  if (!("clipboard" in navigator))
    return Ci("Your browser doesn't support the Clipboard API", "error"), !0;
}
function ZS(t) {
  return t instanceof Error && t.message.toLowerCase().includes("document is not focused") ? (Ci('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) : !1;
}
async function LL(t) {
  if (!XS())
    try {
      await navigator.clipboard.writeText(JSON.stringify(t.state.value)), Ci("Global state copied to clipboard.");
    } catch (e) {
      if (ZS(e))
        return;
      Ci("Failed to serialize the state. Check the console for more details.", "error"), console.error(e);
    }
}
async function DL(t) {
  if (!XS())
    try {
      t.state.value = JSON.parse(await navigator.clipboard.readText()), Ci("Global state pasted from clipboard.");
    } catch (e) {
      if (ZS(e))
        return;
      Ci("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(e);
    }
}
async function kL(t) {
  try {
    WS(new Blob([JSON.stringify(t.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (e) {
    Ci("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
let Is;
function NL() {
  Is || (Is = document.createElement("input"), Is.type = "file", Is.accept = ".json");
  function t() {
    return new Promise((e, r) => {
      Is.onchange = async () => {
        const n = Is.files;
        if (!n)
          return e(null);
        const i = n.item(0);
        return e(i ? { text: await i.text(), file: i } : null);
      }, Is.oncancel = () => e(null), Is.onerror = r, Is.click();
    });
  }
  return t;
}
async function FL(t) {
  try {
    const r = await (await NL())();
    if (!r)
      return;
    const { text: n, file: i } = r;
    t.state.value = JSON.parse(n), Ci(`Global state imported from "${i.name}".`);
  } catch (e) {
    Ci("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
function ba(t) {
  return {
    _custom: {
      display: t
    }
  };
}
const HS = "\u{1F34D} Pinia (root)", g0 = "_root";
function zL(t) {
  return px(t) ? {
    id: g0,
    label: HS
  } : {
    id: t.$id,
    label: t.$id
  };
}
function BL(t) {
  if (px(t)) {
    const r = Array.from(t._s.keys()), n = t._s;
    return {
      state: r.map((l) => ({
        editable: !0,
        key: l,
        value: t.state.value[l]
      })),
      getters: r.filter((l) => n.get(l)._getters).map((l) => {
        const h = n.get(l);
        return {
          editable: !1,
          key: l,
          value: h._getters.reduce((s, m) => (s[m] = h[m], s), {})
        };
      })
    };
  }
  const e = {
    state: Object.keys(t.$state).map((r) => ({
      editable: !0,
      key: r,
      value: t.$state[r]
    }))
  };
  return t._getters && t._getters.length && (e.getters = t._getters.map((r) => ({
    editable: !1,
    key: r,
    value: t[r]
  }))), t._customProperties.size && (e.customProperties = Array.from(t._customProperties).map((r) => ({
    editable: !0,
    key: r,
    value: t[r]
  }))), e;
}
function UL(t) {
  return t ? Array.isArray(t) ? t.reduce((e, r) => (e.keys.push(r.key), e.operations.push(r.type), e.oldValue[r.key] = r.oldValue, e.newValue[r.key] = r.newValue, e), {
    oldValue: {},
    keys: [],
    operations: [],
    newValue: {}
  }) : {
    operation: ba(t.type),
    key: ba(t.key),
    oldValue: t.oldValue,
    newValue: t.newValue
  } : {};
}
function $L(t) {
  switch (t) {
    case ts.direct:
      return "mutation";
    case ts.patchFunction:
      return "$patch";
    case ts.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let hh = !0;
const lg = [], $c = "pinia:mutations", Zi = "pinia", { assign: VL } = Object, Rg = (t) => "\u{1F34D} " + t;
function jL(t, e) {
  VS({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: lg,
    app: t
  }, (r) => {
    typeof r.now != "function" && Ci("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), r.addTimelineLayer({
      id: $c,
      label: "Pinia \u{1F34D}",
      color: 15064968
    }), r.addInspector({
      id: Zi,
      label: "Pinia \u{1F34D}",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            LL(e);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: async () => {
            await DL(e), r.sendInspectorTree(Zi), r.sendInspectorState(Zi);
          },
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            kL(e);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: async () => {
            await FL(e), r.sendInspectorTree(Zi), r.sendInspectorState(Zi);
          },
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: "Reset the state (option store only)",
          action: (n) => {
            const i = e._s.get(n);
            i ? i._isOptionsAPI ? (i.$reset(), Ci(`Store "${n}" reset.`)) : Ci(`Cannot reset "${n}" store because it's a setup store.`, "warn") : Ci(`Cannot reset "${n}" store because it wasn't found.`, "warn");
          }
        }
      ]
    }), r.on.inspectComponent((n, i) => {
      const l = n.componentInstance && n.componentInstance.proxy;
      if (l && l._pStores) {
        const h = n.componentInstance.proxy._pStores;
        Object.values(h).forEach((s) => {
          n.instanceData.state.push({
            type: Rg(s.$id),
            key: "state",
            editable: !0,
            value: s._isOptionsAPI ? {
              _custom: {
                value: ir(s.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => s.$reset()
                  }
                ]
              }
            } : Object.keys(s.$state).reduce((m, v) => (m[v] = s.$state[v], m), {})
          }), s._getters && s._getters.length && n.instanceData.state.push({
            type: Rg(s.$id),
            key: "getters",
            editable: !1,
            value: s._getters.reduce((m, v) => {
              try {
                m[v] = s[v];
              } catch (E) {
                m[v] = E;
              }
              return m;
            }, {})
          });
        });
      }
    }), r.on.getInspectorTree((n) => {
      if (n.app === t && n.inspectorId === Zi) {
        let i = [e];
        i = i.concat(Array.from(e._s.values())), n.rootNodes = (n.filter ? i.filter((l) => "$id" in l ? l.$id.toLowerCase().includes(n.filter.toLowerCase()) : HS.toLowerCase().includes(n.filter.toLowerCase())) : i).map(zL);
      }
    }), r.on.getInspectorState((n) => {
      if (n.app === t && n.inspectorId === Zi) {
        const i = n.nodeId === g0 ? e : e._s.get(n.nodeId);
        if (!i)
          return;
        i && (n.state = BL(i));
      }
    }), r.on.editInspectorState((n, i) => {
      if (n.app === t && n.inspectorId === Zi) {
        const l = n.nodeId === g0 ? e : e._s.get(n.nodeId);
        if (!l)
          return Ci(`store "${n.nodeId}" not found`, "error");
        const { path: h } = n;
        px(l) ? h.unshift("state") : (h.length !== 1 || !l._customProperties.has(h[0]) || h[0] in l.$state) && h.unshift("$state"), hh = !1, n.set(l, h, n.state.value), hh = !0;
      }
    }), r.on.editComponentState((n) => {
      if (n.type.startsWith("\u{1F34D}")) {
        const i = n.type.replace(/^\s*/, ""), l = e._s.get(i);
        if (!l)
          return Ci(`store "${i}" not found`, "error");
        const { path: h } = n;
        if (h[0] !== "state")
          return Ci(`Invalid path for store "${i}":
${h}
Only state can be modified.`);
        h[0] = "$state", hh = !1, n.set(l, h, n.state.value), hh = !0;
      }
    });
  });
}
function GL(t, e) {
  lg.includes(Rg(e.$id)) || lg.push(Rg(e.$id)), VS({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: lg,
    app: t,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: !0
      }
    }
  }, (r) => {
    const n = typeof r.now == "function" ? r.now.bind(r) : Date.now;
    e.$onAction(({ after: h, onError: s, name: m, args: v }) => {
      const E = KS++;
      r.addTimelineEvent({
        layerId: $c,
        event: {
          time: n(),
          title: "\u{1F6EB} " + m,
          subtitle: "start",
          data: {
            store: ba(e.$id),
            action: ba(m),
            args: v
          },
          groupId: E
        }
      }), h((T) => {
        qc = void 0, r.addTimelineEvent({
          layerId: $c,
          event: {
            time: n(),
            title: "\u{1F6EC} " + m,
            subtitle: "end",
            data: {
              store: ba(e.$id),
              action: ba(m),
              args: v,
              result: T
            },
            groupId: E
          }
        });
      }), s((T) => {
        qc = void 0, r.addTimelineEvent({
          layerId: $c,
          event: {
            time: n(),
            logType: "error",
            title: "\u{1F4A5} " + m,
            subtitle: "end",
            data: {
              store: ba(e.$id),
              action: ba(m),
              args: v,
              error: T
            },
            groupId: E
          }
        });
      });
    }, !0), e._customProperties.forEach((h) => {
      An(() => _e(e[h]), (s, m) => {
        r.notifyComponentUpdate(), r.sendInspectorState(Zi), hh && r.addTimelineEvent({
          layerId: $c,
          event: {
            time: n(),
            title: "Change",
            subtitle: h,
            data: {
              newValue: s,
              oldValue: m
            },
            groupId: qc
          }
        });
      }, { deep: !0 });
    }), e.$subscribe(({ events: h, type: s }, m) => {
      if (r.notifyComponentUpdate(), r.sendInspectorState(Zi), !hh)
        return;
      const v = {
        time: n(),
        title: $L(s),
        data: VL({ store: ba(e.$id) }, UL(h)),
        groupId: qc
      };
      qc = void 0, s === ts.patchFunction ? v.subtitle = "\u2935\uFE0F" : s === ts.patchObject ? v.subtitle = "\u{1F9E9}" : h && !Array.isArray(h) && (v.subtitle = h.type), h && (v.data["rawEvent(s)"] = {
        _custom: {
          display: "DebuggerEvent",
          type: "object",
          tooltip: "raw DebuggerEvent[]",
          value: h
        }
      }), r.addTimelineEvent({
        layerId: $c,
        event: v
      });
    }, { detached: !0, flush: "sync" });
    const i = e._hotUpdate;
    e._hotUpdate = Ta((h) => {
      i(h), r.addTimelineEvent({
        layerId: $c,
        event: {
          time: n(),
          title: "\u{1F525} " + e.$id,
          subtitle: "HMR update",
          data: {
            store: ba(e.$id),
            info: ba("HMR update")
          }
        }
      }), r.notifyComponentUpdate(), r.sendInspectorTree(Zi), r.sendInspectorState(Zi);
    });
    const { $dispose: l } = e;
    e.$dispose = () => {
      l(), r.notifyComponentUpdate(), r.sendInspectorTree(Zi), r.sendInspectorState(Zi), r.getSettings().logStoreChanges && Ci(`Disposed "${e.$id}" store \u{1F5D1}`);
    }, r.notifyComponentUpdate(), r.sendInspectorTree(Zi), r.sendInspectorState(Zi), r.getSettings().logStoreChanges && Ci(`"${e.$id}" store installed \u{1F195}`);
  });
}
let KS = 0, qc;
function yw(t, e) {
  const r = e.reduce((n, i) => (n[i] = ir(t)[i], n), {});
  for (const n in r)
    t[n] = function() {
      const i = KS, l = new Proxy(t, {
        get(...h) {
          return qc = i, Reflect.get(...h);
        },
        set(...h) {
          return qc = i, Reflect.set(...h);
        }
      });
      return r[n].apply(l, arguments);
    };
}
function qL({ app: t, store: e, options: r }) {
  if (!e.$id.startsWith("__hot:")) {
    if (r.state && (e._isOptionsAPI = !0), typeof r.state == "function") {
      yw(
        e,
        Object.keys(r.actions)
      );
      const n = e._hotUpdate;
      ir(e)._hotUpdate = function(i) {
        n.apply(this, arguments), yw(e, Object.keys(i._hmrPayload.actions));
      };
    }
    GL(
      t,
      e
    );
  }
}
function WL() {
  const t = CT(!0), e = t.run(() => Kr({}));
  let r = [], n = [];
  const i = Ta({
    install(l) {
      Od(i), i._a = l, l.provide(jS, i), l.config.globalProperties.$pinia = i, pd && jL(l, i), n.forEach((h) => r.push(h)), n = [];
    },
    use(l) {
      return !this._a && !BS ? n.push(l) : r.push(l), this;
    },
    _p: r,
    _a: null,
    _e: t,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return pd && typeof Proxy < "u" && i.use(qL), i;
}
function YS(t, e) {
  for (const r in e) {
    const n = e[r];
    if (!(r in t))
      continue;
    const i = t[r];
    iu(i) && iu(n) && !tn(n) && !Aa(n) ? t[r] = YS(i, n) : t[r] = n;
  }
  return t;
}
const JS = () => {
};
function _w(t, e, r, n = JS) {
  t.push(e);
  const i = () => {
    const l = t.indexOf(e);
    l > -1 && (t.splice(l, 1), n());
  };
  return !r && IT() && XP(i), i;
}
function Hu(t, ...e) {
  t.slice().forEach((r) => {
    r(...e);
  });
}
function y0(t, e) {
  t instanceof Map && e instanceof Map && e.forEach((r, n) => t.set(n, r)), t instanceof Set && e instanceof Set && e.forEach(t.add, t);
  for (const r in e) {
    if (!e.hasOwnProperty(r))
      continue;
    const n = e[r], i = t[r];
    iu(i) && iu(n) && t.hasOwnProperty(r) && !tn(n) && !Aa(n) ? t[r] = y0(i, n) : t[r] = n;
  }
  return t;
}
const XL = process.env.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : Symbol();
function ZL(t) {
  return !iu(t) || !t.hasOwnProperty(XL);
}
const { assign: Qo } = Object;
function vw(t) {
  return !!(tn(t) && t.effect);
}
function xw(t, e, r, n) {
  const { state: i, actions: l, getters: h } = e, s = r.state.value[t];
  let m;
  function v() {
    !s && (process.env.NODE_ENV === "production" || !n) && (r.state.value[t] = i ? i() : {});
    const E = process.env.NODE_ENV !== "production" && n ? Ob(Kr(i ? i() : {}).value) : Ob(r.state.value[t]);
    return Qo(E, l, Object.keys(h || {}).reduce((T, S) => (process.env.NODE_ENV !== "production" && S in E && console.warn(`[\u{1F34D}]: A getter cannot have the same name as another state property. Rename one of them. Found with "${S}" in store "${t}".`), T[S] = Ta(un(() => {
      Od(r);
      const A = r._s.get(t);
      return h[S].call(A, A);
    })), T), {}));
  }
  return m = _0(t, v, e, r, n, !0), m;
}
function _0(t, e, r = {}, n, i, l) {
  let h;
  const s = Qo({ actions: {} }, r);
  if (process.env.NODE_ENV !== "production" && !n._e.active)
    throw new Error("Pinia destroyed");
  const m = {
    deep: !0
  };
  process.env.NODE_ENV !== "production" && !BS && (m.onTrigger = (Me) => {
    v ? A = Me : v == !1 && !ve._hotUpdating && (Array.isArray(A) ? A.push(Me) : console.error("\u{1F34D} debuggerEvents should be an array. This is most likely an internal Pinia bug."));
  });
  let v, E, T = Ta([]), S = Ta([]), A;
  const L = n.state.value[t];
  !l && !L && (process.env.NODE_ENV === "production" || !i) && (n.state.value[t] = {});
  const B = Kr({});
  let j;
  function q(Me) {
    let Re;
    v = E = !1, process.env.NODE_ENV !== "production" && (A = []), typeof Me == "function" ? (Me(n.state.value[t]), Re = {
      type: ts.patchFunction,
      storeId: t,
      events: A
    }) : (y0(n.state.value[t], Me), Re = {
      type: ts.patchObject,
      payload: Me,
      storeId: t,
      events: A
    });
    const He = j = Symbol();
    Sg().then(() => {
      j === He && (v = !0);
    }), E = !0, Hu(T, Re, n.state.value[t]);
  }
  const H = l ? function() {
    const { state: Re } = r, He = Re ? Re() : {};
    this.$patch((Ve) => {
      Qo(Ve, He);
    });
  } : process.env.NODE_ENV !== "production" ? () => {
    throw new Error(`\u{1F34D}: Store "${t}" is built using the setup syntax and does not implement $reset().`);
  } : JS;
  function ne() {
    h.stop(), T = [], S = [], n._s.delete(t);
  }
  function ee(Me, Re) {
    return function() {
      Od(n);
      const He = Array.from(arguments), Ve = [], dt = [];
      function xe(Ye) {
        Ve.push(Ye);
      }
      function ze(Ye) {
        dt.push(Ye);
      }
      Hu(S, {
        args: He,
        name: Me,
        store: ve,
        after: xe,
        onError: ze
      });
      let Pe;
      try {
        Pe = Re.apply(this && this.$id === t ? this : ve, He);
      } catch (Ye) {
        throw Hu(dt, Ye), Ye;
      }
      return Pe instanceof Promise ? Pe.then((Ye) => (Hu(Ve, Ye), Ye)).catch((Ye) => (Hu(dt, Ye), Promise.reject(Ye))) : (Hu(Ve, Pe), Pe);
    };
  }
  const he = /* @__PURE__ */ Ta({
    actions: {},
    getters: {},
    state: [],
    hotState: B
  }), Te = {
    _p: n,
    $id: t,
    $onAction: _w.bind(null, S),
    $patch: q,
    $reset: H,
    $subscribe(Me, Re = {}) {
      const He = _w(T, Me, Re.detached, () => Ve()), Ve = h.run(() => An(() => n.state.value[t], (dt) => {
        (Re.flush === "sync" ? E : v) && Me({
          storeId: t,
          type: ts.direct,
          events: A
        }, dt);
      }, Qo({}, m, Re)));
      return He;
    },
    $dispose: ne
  }, ve = vy(process.env.NODE_ENV !== "production" || pd ? Qo(
    {
      _hmrPayload: he,
      _customProperties: Ta(/* @__PURE__ */ new Set())
    },
    Te
  ) : Te);
  n._s.set(t, ve);
  const Oe = n._e.run(() => (h = CT(), h.run(() => e())));
  for (const Me in Oe) {
    const Re = Oe[Me];
    if (tn(Re) && !vw(Re) || Aa(Re))
      process.env.NODE_ENV !== "production" && i ? Im(B.value, Me, cd(Oe, Me)) : l || (L && ZL(Re) && (tn(Re) ? Re.value = L[Me] : y0(Re, L[Me])), n.state.value[t][Me] = Re), process.env.NODE_ENV !== "production" && he.state.push(Me);
    else if (typeof Re == "function") {
      const He = process.env.NODE_ENV !== "production" && i ? Re : ee(Me, Re);
      Oe[Me] = He, process.env.NODE_ENV !== "production" && (he.actions[Me] = Re), s.actions[Me] = Re;
    } else
      process.env.NODE_ENV !== "production" && vw(Re) && (he.getters[Me] = l ? r.getters[Me] : Re, Ay && (Oe._getters || (Oe._getters = Ta([]))).push(Me));
  }
  if (Qo(ve, Oe), Qo(ir(ve), Oe), Object.defineProperty(ve, "$state", {
    get: () => process.env.NODE_ENV !== "production" && i ? B.value : n.state.value[t],
    set: (Me) => {
      if (process.env.NODE_ENV !== "production" && i)
        throw new Error("cannot set hotState");
      q((Re) => {
        Qo(Re, Me);
      });
    }
  }), process.env.NODE_ENV !== "production" && (ve._hotUpdate = Ta((Me) => {
    ve._hotUpdating = !0, Me._hmrPayload.state.forEach((Re) => {
      if (Re in ve.$state) {
        const He = Me.$state[Re], Ve = ve.$state[Re];
        typeof He == "object" && iu(He) && iu(Ve) ? YS(He, Ve) : Me.$state[Re] = Ve;
      }
      Im(ve, Re, cd(Me.$state, Re));
    }), Object.keys(ve.$state).forEach((Re) => {
      Re in Me.$state || fv(ve, Re);
    }), v = !1, E = !1, n.state.value[t] = cd(Me._hmrPayload, "hotState"), E = !0, Sg().then(() => {
      v = !0;
    });
    for (const Re in Me._hmrPayload.actions) {
      const He = Me[Re];
      Im(ve, Re, ee(Re, He));
    }
    for (const Re in Me._hmrPayload.getters) {
      const He = Me._hmrPayload.getters[Re], Ve = l ? un(() => (Od(n), He.call(ve, ve))) : He;
      Im(ve, Re, Ve);
    }
    Object.keys(ve._hmrPayload.getters).forEach((Re) => {
      Re in Me._hmrPayload.getters || fv(ve, Re);
    }), Object.keys(ve._hmrPayload.actions).forEach((Re) => {
      Re in Me._hmrPayload.actions || fv(ve, Re);
    }), ve._hmrPayload = Me._hmrPayload, ve._getters = Me._getters, ve._hotUpdating = !1;
  })), pd) {
    const Me = {
      writable: !0,
      configurable: !0,
      enumerable: !1
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((Re) => {
      Object.defineProperty(ve, Re, Qo({ value: ve[Re] }, Me));
    });
  }
  return n._p.forEach((Me) => {
    if (pd) {
      const Re = h.run(() => Me({
        store: ve,
        app: n._a,
        pinia: n,
        options: s
      }));
      Object.keys(Re || {}).forEach((He) => ve._customProperties.add(He)), Qo(ve, Re);
    } else
      Qo(ve, h.run(() => Me({
        store: ve,
        app: n._a,
        pinia: n,
        options: s
      })));
  }), process.env.NODE_ENV !== "production" && ve.$state && typeof ve.$state == "object" && typeof ve.$state.constructor == "function" && !ve.$state.constructor.toString().includes("[native code]") && console.warn(`[\u{1F34D}]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${ve.$id}".`), L && l && r.hydrate && r.hydrate(ve.$state, L), v = !0, E = !0, ve;
}
function du(t, e, r) {
  let n, i;
  const l = typeof e == "function";
  typeof t == "string" ? (n = t, i = l ? r : e) : (i = t, n = t.id);
  function h(s, m) {
    const v = My();
    if (s = (process.env.NODE_ENV === "test" && td && td._testing ? null : s) || v && bh(jS, null), s && Od(s), process.env.NODE_ENV !== "production" && !td)
      throw new Error(`[\u{1F34D}]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);
    s = td, s._s.has(n) || (l ? _0(n, e, i, s) : xw(n, i, s), process.env.NODE_ENV !== "production" && (h._pinia = s));
    const E = s._s.get(n);
    if (process.env.NODE_ENV !== "production" && m) {
      const T = "__hot:" + n, S = l ? _0(T, e, i, s, !0) : xw(T, Qo({}, i), s, !0);
      m._hotUpdate(S), delete s.state.value[T], s._s.delete(T);
    }
    if (process.env.NODE_ENV !== "production" && Ay && v && v.proxy && !m) {
      const T = v.proxy, S = "_pStores" in T ? T._pStores : T._pStores = {};
      S[n] = E;
    }
    return E;
  }
  return h.$id = n, h;
}
function mn(t) {
  {
    t = ir(t);
    const e = {};
    for (const r in t) {
      const n = t[r];
      (tn(n) || Aa(n)) && (e[r] = cd(t, r));
    }
    return e;
  }
}
var $h = {
  RADIANS: "radians",
  DEGREES: "degrees",
  FEET: "ft",
  METERS: "m",
  PIXELS: "pixels",
  TILE_PIXELS: "tile-pixels",
  USFEET: "us-ft"
}, ss = {};
ss[$h.RADIANS] = 6370997 / (2 * Math.PI);
ss[$h.DEGREES] = 2 * Math.PI * 6370997 / 360;
ss[$h.FEET] = 0.3048;
ss[$h.METERS] = 1;
ss[$h.USFEET] = 1200 / 3937;
const Fs = $h;
var HL = function() {
  function t(e) {
    this.code_ = e.code, this.units_ = e.units, this.extent_ = e.extent !== void 0 ? e.extent : null, this.worldExtent_ = e.worldExtent !== void 0 ? e.worldExtent : null, this.axisOrientation_ = e.axisOrientation !== void 0 ? e.axisOrientation : "enu", this.global_ = e.global !== void 0 ? e.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = e.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = e.metersPerUnit;
  }
  return t.prototype.canWrapX = function() {
    return this.canWrapX_;
  }, t.prototype.getCode = function() {
    return this.code_;
  }, t.prototype.getExtent = function() {
    return this.extent_;
  }, t.prototype.getUnits = function() {
    return this.units_;
  }, t.prototype.getMetersPerUnit = function() {
    return this.metersPerUnit_ || ss[this.units_];
  }, t.prototype.getWorldExtent = function() {
    return this.worldExtent_;
  }, t.prototype.getAxisOrientation = function() {
    return this.axisOrientation_;
  }, t.prototype.isGlobal = function() {
    return this.global_;
  }, t.prototype.setGlobal = function(e) {
    this.global_ = e, this.canWrapX_ = !!(e && this.extent_);
  }, t.prototype.getDefaultTileGrid = function() {
    return this.defaultTileGrid_;
  }, t.prototype.setDefaultTileGrid = function(e) {
    this.defaultTileGrid_ = e;
  }, t.prototype.setExtent = function(e) {
    this.extent_ = e, this.canWrapX_ = !!(this.global_ && e);
  }, t.prototype.setWorldExtent = function(e) {
    this.worldExtent_ = e;
  }, t.prototype.setGetPointResolution = function(e) {
    this.getPointResolutionFunc_ = e;
  }, t.prototype.getPointResolutionFunc = function() {
    return this.getPointResolutionFunc_;
  }, t;
}();
const mx = HL;
function hi(t, e, r) {
  return Math.min(Math.max(t, e), r);
}
var KL = function() {
  var t;
  return "cosh" in Math ? t = Math.cosh : t = function(e) {
    var r = Math.exp(e);
    return (r + 1 / r) / 2;
  }, t;
}(), YL = function() {
  var t;
  return "log2" in Math ? t = Math.log2 : t = function(e) {
    return Math.log(e) * Math.LOG2E;
  }, t;
}();
function JL(t, e, r, n, i, l) {
  var h = i - r, s = l - n;
  if (h !== 0 || s !== 0) {
    var m = ((t - r) * h + (e - n) * s) / (h * h + s * s);
    m > 1 ? (r = i, n = l) : m > 0 && (r += h * m, n += s * m);
  }
  return Eh(t, e, r, n);
}
function Eh(t, e, r, n) {
  var i = r - t, l = n - e;
  return i * i + l * l;
}
function QL(t) {
  for (var e = t.length, r = 0; r < e; r++) {
    for (var n = r, i = Math.abs(t[r][r]), l = r + 1; l < e; l++) {
      var h = Math.abs(t[l][r]);
      h > i && (i = h, n = l);
    }
    if (i === 0)
      return null;
    var s = t[n];
    t[n] = t[r], t[r] = s;
    for (var m = r + 1; m < e; m++)
      for (var v = -t[m][r] / t[r][r], E = r; E < e + 1; E++)
        r == E ? t[m][E] = 0 : t[m][E] += v * t[r][E];
  }
  for (var T = new Array(e), S = e - 1; S >= 0; S--) {
    T[S] = t[S][e] / t[S][S];
    for (var A = S - 1; A >= 0; A--)
      t[A][e] -= t[A][S] * T[S];
  }
  return T;
}
function eD(t) {
  return t * 180 / Math.PI;
}
function cg(t) {
  return t * Math.PI / 180;
}
function Qc(t, e) {
  var r = t % e;
  return r * e < 0 ? r + e : r;
}
function tD(t, e, r) {
  return t + r * (e - t);
}
function gx(t, e) {
  var r = Math.pow(10, e);
  return Math.round(t * r) / r;
}
function bw(t, e) {
  return Math.round(gx(t, e));
}
function fh(t, e) {
  return Math.floor(gx(t, e));
}
function Rl(t, e) {
  return Math.ceil(gx(t, e));
}
var rD = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Wd = 6378137, dh = Math.PI * Wd, nD = [-dh, -dh, dh, dh], iD = [-180, -85, 180, 85], Pm = Wd * Math.log(Math.tan(Math.PI / 2)), Ku = function(t) {
  rD(e, t);
  function e(r) {
    return t.call(this, {
      code: r,
      units: Fs.METERS,
      extent: nD,
      global: !0,
      worldExtent: iD,
      getPointResolution: function(n, i) {
        return n / KL(i[1] / Wd);
      }
    }) || this;
  }
  return e;
}(mx), ww = [
  new Ku("EPSG:3857"),
  new Ku("EPSG:102100"),
  new Ku("EPSG:102113"),
  new Ku("EPSG:900913"),
  new Ku("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new Ku("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function oD(t, e, r) {
  var n = t.length, i = r > 1 ? r : 2, l = e;
  l === void 0 && (i > 2 ? l = t.slice() : l = new Array(n));
  for (var h = 0; h < n; h += i) {
    l[h] = dh * t[h] / 180;
    var s = Wd * Math.log(Math.tan(Math.PI * (+t[h + 1] + 90) / 360));
    s > Pm ? s = Pm : s < -Pm && (s = -Pm), l[h + 1] = s;
  }
  return l;
}
function aD(t, e, r) {
  var n = t.length, i = r > 1 ? r : 2, l = e;
  l === void 0 && (i > 2 ? l = t.slice() : l = new Array(n));
  for (var h = 0; h < n; h += i)
    l[h] = 180 * t[h] / dh, l[h + 1] = 360 * Math.atan(Math.exp(t[h + 1] / Wd)) / Math.PI - 90;
  return l;
}
var sD = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), lD = 6378137, Ew = [-180, -90, 180, 90], cD = Math.PI * lD / 180, Dc = function(t) {
  sD(e, t);
  function e(r, n) {
    return t.call(this, {
      code: r,
      units: Fs.DEGREES,
      extent: Ew,
      axisOrientation: n,
      global: !0,
      metersPerUnit: cD,
      worldExtent: Ew
    }) || this;
  }
  return e;
}(mx), Tw = [
  new Dc("CRS:84"),
  new Dc("EPSG:4326", "neu"),
  new Dc("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new Dc("urn:ogc:def:crs:OGC:2:84"),
  new Dc("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new Dc("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new Dc("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
], v0 = {};
function uD(t) {
  return v0[t] || v0[t.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function hD(t, e) {
  v0[t] = e;
}
var In = typeof Object.assign == "function" ? Object.assign : function(t, e) {
  if (t == null)
    throw new TypeError("Cannot convert undefined or null to object");
  for (var r = Object(t), n = 1, i = arguments.length; n < i; ++n) {
    var l = arguments[n];
    if (l != null)
      for (var h in l)
        l.hasOwnProperty(h) && (r[h] = l[h]);
  }
  return r;
};
function Oy(t) {
  for (var e in t)
    delete t[e];
}
var fD = typeof Object.values == "function" ? Object.values : function(t) {
  var e = [];
  for (var r in t)
    e.push(t[r]);
  return e;
};
function dD(t) {
  var e;
  for (e in t)
    return !1;
  return !e;
}
var Th = {};
function Dh(t, e, r) {
  var n = t.getCode(), i = e.getCode();
  n in Th || (Th[n] = {}), Th[n][i] = r;
}
function QS(t, e) {
  var r;
  return t in Th && e in Th[t] && (r = Th[t][e]), r;
}
const zi = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function En() {
  return function() {
    throw new Error("Unimplemented abstract method.");
  }();
}
var pD = 0;
function So(t) {
  return t.ol_uid || (t.ol_uid = String(++pD));
}
var mD = "6.15.1", gD = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), yD = function(t) {
  gD(e, t);
  function e(r) {
    var n = this, i = "v" + mD.split("-")[0], l = "Assertion failed. See https://openlayers.org/en/" + i + "/doc/errors/#" + r + " for details.";
    return n = t.call(this, l) || this, n.code = r, n.name = "AssertionError", n.message = l, n;
  }
  return e;
}(Error);
const e2 = yD;
function en(t, e) {
  if (!t)
    throw new e2(e);
}
function x0(t) {
  for (var e = pu(), r = 0, n = t.length; r < n; ++r)
    ug(e, t[r]);
  return e;
}
function _D(t, e, r) {
  var n = Math.min.apply(null, t), i = Math.min.apply(null, e), l = Math.max.apply(null, t), h = Math.max.apply(null, e);
  return ou(n, i, l, h, r);
}
function vD(t, e) {
  return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t.slice();
}
function t2(t, e, r) {
  var n, i;
  return e < t[0] ? n = t[0] - e : t[2] < e ? n = e - t[2] : n = 0, r < t[1] ? i = t[1] - r : t[3] < r ? i = r - t[3] : i = 0, n * n + i * i;
}
function Xd(t, e) {
  return r2(t, e[0], e[1]);
}
function yx(t, e) {
  return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3];
}
function r2(t, e, r) {
  return t[0] <= e && e <= t[2] && t[1] <= r && r <= t[3];
}
function Sw(t, e) {
  var r = t[0], n = t[1], i = t[2], l = t[3], h = e[0], s = e[1], m = zi.UNKNOWN;
  return h < r ? m = m | zi.LEFT : h > i && (m = m | zi.RIGHT), s < n ? m = m | zi.BELOW : s > l && (m = m | zi.ABOVE), m === zi.UNKNOWN && (m = zi.INTERSECTING), m;
}
function pu() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function ou(t, e, r, n, i) {
  return i ? (i[0] = t, i[1] = e, i[2] = r, i[3] = n, i) : [t, e, r, n];
}
function Ry(t) {
  return ou(1 / 0, 1 / 0, -1 / 0, -1 / 0, t);
}
function xD(t, e) {
  var r = t[0], n = t[1];
  return ou(r, n, r, n, e);
}
function bD(t, e, r, n, i) {
  var l = Ry(i);
  return n2(l, t, e, r, n);
}
function Lg(t, e) {
  return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3];
}
function wD(t, e) {
  return e[0] < t[0] && (t[0] = e[0]), e[2] > t[2] && (t[2] = e[2]), e[1] < t[1] && (t[1] = e[1]), e[3] > t[3] && (t[3] = e[3]), t;
}
function ug(t, e) {
  e[0] < t[0] && (t[0] = e[0]), e[0] > t[2] && (t[2] = e[0]), e[1] < t[1] && (t[1] = e[1]), e[1] > t[3] && (t[3] = e[1]);
}
function n2(t, e, r, n, i) {
  for (; r < n; r += i)
    ED(t, e[r], e[r + 1]);
  return t;
}
function ED(t, e, r) {
  t[0] = Math.min(t[0], e), t[1] = Math.min(t[1], r), t[2] = Math.max(t[2], e), t[3] = Math.max(t[3], r);
}
function i2(t, e) {
  var r;
  return r = e(Ly(t)), r || (r = e(Dy(t)), r) || (r = e(ky(t)), r) || (r = e(Kl(t)), r) ? r : !1;
}
function b0(t) {
  var e = 0;
  return Ny(t) || (e = Cn(t) * Pi(t)), e;
}
function Ly(t) {
  return [t[0], t[1]];
}
function Dy(t) {
  return [t[2], t[1]];
}
function au(t) {
  return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2];
}
function TD(t, e) {
  var r;
  return e === "bottom-left" ? r = Ly(t) : e === "bottom-right" ? r = Dy(t) : e === "top-left" ? r = Kl(t) : e === "top-right" ? r = ky(t) : en(!1, 13), r;
}
function Sh(t, e, r, n, i) {
  var l = w0(t, e, r, n), h = l[0], s = l[1], m = l[2], v = l[3], E = l[4], T = l[5], S = l[6], A = l[7];
  return ou(Math.min(h, m, E, S), Math.min(s, v, T, A), Math.max(h, m, E, S), Math.max(s, v, T, A), i);
}
function w0(t, e, r, n) {
  var i = e * n[0] / 2, l = e * n[1] / 2, h = Math.cos(r), s = Math.sin(r), m = i * h, v = i * s, E = l * h, T = l * s, S = t[0], A = t[1];
  return [
    S - m + T,
    A - v - E,
    S - m - T,
    A - v + E,
    S + m - T,
    A + v + E,
    S + m + T,
    A + v - E,
    S - m + T,
    A - v - E
  ];
}
function Pi(t) {
  return t[3] - t[1];
}
function eu(t, e, r) {
  var n = r || pu();
  return Zd(t, e) ? (t[0] > e[0] ? n[0] = t[0] : n[0] = e[0], t[1] > e[1] ? n[1] = t[1] : n[1] = e[1], t[2] < e[2] ? n[2] = t[2] : n[2] = e[2], t[3] < e[3] ? n[3] = t[3] : n[3] = e[3]) : Ry(n), n;
}
function Kl(t) {
  return [t[0], t[3]];
}
function ky(t) {
  return [t[2], t[3]];
}
function Cn(t) {
  return t[2] - t[0];
}
function Zd(t, e) {
  return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1];
}
function Ny(t) {
  return t[2] < t[0] || t[3] < t[1];
}
function SD(t, e) {
  return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t;
}
function MD(t, e, r) {
  var n = !1, i = Sw(t, e), l = Sw(t, r);
  if (i === zi.INTERSECTING || l === zi.INTERSECTING)
    n = !0;
  else {
    var h = t[0], s = t[1], m = t[2], v = t[3], E = e[0], T = e[1], S = r[0], A = r[1], L = (A - T) / (S - E), B = void 0, j = void 0;
    !!(l & zi.ABOVE) && !(i & zi.ABOVE) && (B = S - (A - v) / L, n = B >= h && B <= m), !n && !!(l & zi.RIGHT) && !(i & zi.RIGHT) && (j = A - (S - m) * L, n = j >= s && j <= v), !n && !!(l & zi.BELOW) && !(i & zi.BELOW) && (B = S - (A - s) / L, n = B >= h && B <= m), !n && !!(l & zi.LEFT) && !(i & zi.LEFT) && (j = A - (S - h) * L, n = j >= s && j <= v);
  }
  return n;
}
function CD(t, e, r, n) {
  var i = [];
  if (n > 1)
    for (var l = t[2] - t[0], h = t[3] - t[1], s = 0; s < n; ++s)
      i.push(t[0] + l * s / n, t[1], t[2], t[1] + h * s / n, t[2] - l * s / n, t[3], t[0], t[3] - h * s / n);
  else
    i = [
      t[0],
      t[1],
      t[2],
      t[1],
      t[2],
      t[3],
      t[0],
      t[3]
    ];
  e(i, i, 2);
  for (var m = [], v = [], s = 0, E = i.length; s < E; s += 2)
    m.push(i[s]), v.push(i[s + 1]);
  return _D(m, v, r);
}
function ID(t, e) {
  for (var r = ("" + t).split("."), n = ("" + e).split("."), i = 0; i < Math.max(r.length, n.length); i++) {
    var l = parseInt(r[i] || "0", 10), h = parseInt(n[i] || "0", 10);
    if (l > h)
      return 1;
    if (h > l)
      return -1;
  }
  return 0;
}
function PD(t, e) {
  return t[0] += +e[0], t[1] += +e[1], t;
}
function Dg(t, e) {
  for (var r = !0, n = t.length - 1; n >= 0; --n)
    if (t[n] != e[n]) {
      r = !1;
      break;
    }
  return r;
}
function _x(t, e) {
  var r = Math.cos(e), n = Math.sin(e), i = t[0] * r - t[1] * n, l = t[1] * r + t[0] * n;
  return t[0] = i, t[1] = l, t;
}
function AD(t, e) {
  return t[0] *= e, t[1] *= e, t;
}
function OD(t, e) {
  if (e.canWrapX()) {
    var r = Cn(e.getExtent()), n = o2(t, e, r);
    n && (t[0] -= n * r);
  }
  return t;
}
function o2(t, e, r) {
  var n = e.getExtent(), i = 0;
  if (e.canWrapX() && (t[0] < n[0] || t[0] > n[2])) {
    var l = r || Cn(n);
    i = Math.floor((t[0] - n[0]) / l);
  }
  return i;
}
var RD = 63710088e-1;
function Mw(t, e, r) {
  var n = r || RD, i = cg(t[1]), l = cg(e[1]), h = (l - i) / 2, s = cg(e[0] - t[0]) / 2, m = Math.sin(h) * Math.sin(h) + Math.sin(s) * Math.sin(s) * Math.cos(i) * Math.cos(l);
  return 2 * n * Math.atan2(Math.sqrt(m), Math.sqrt(1 - m));
}
var E0 = !0;
function LD(t) {
  var e = t === void 0 ? !0 : t;
  E0 = !e;
}
function vx(t, e, r) {
  var n;
  if (e !== void 0) {
    for (var i = 0, l = t.length; i < l; ++i)
      e[i] = t[i];
    n = e;
  } else
    n = t.slice();
  return n;
}
function a2(t, e, r) {
  if (e !== void 0 && t !== e) {
    for (var n = 0, i = t.length; n < i; ++n)
      e[n] = t[n];
    t = e;
  }
  return t;
}
function s2(t) {
  hD(t.getCode(), t), Dh(t, t, vx);
}
function DD(t) {
  t.forEach(s2);
}
function fi(t) {
  return typeof t == "string" ? uD(t) : t || null;
}
function Cw(t, e, r, n) {
  t = fi(t);
  var i, l = t.getPointResolutionFunc();
  if (l) {
    if (i = l(e, r), n && n !== t.getUnits()) {
      var h = t.getMetersPerUnit();
      h && (i = i * h / ss[n]);
    }
  } else {
    var s = t.getUnits();
    if (s == Fs.DEGREES && !n || n == Fs.DEGREES)
      i = e;
    else {
      var m = bx(t, fi("EPSG:4326"));
      if (m === a2 && s !== Fs.DEGREES)
        i = e * t.getMetersPerUnit();
      else {
        var v = [
          r[0] - e / 2,
          r[1],
          r[0] + e / 2,
          r[1],
          r[0],
          r[1] - e / 2,
          r[0],
          r[1] + e / 2
        ];
        v = m(v, v, 2);
        var E = Mw(v.slice(0, 2), v.slice(2, 4)), T = Mw(v.slice(4, 6), v.slice(6, 8));
        i = (E + T) / 2;
      }
      var h = n ? ss[n] : t.getMetersPerUnit();
      h !== void 0 && (i /= h);
    }
  }
  return i;
}
function T0(t) {
  DD(t), t.forEach(function(e) {
    t.forEach(function(r) {
      e !== r && Dh(e, r, vx);
    });
  });
}
function kD(t, e, r, n) {
  t.forEach(function(i) {
    e.forEach(function(l) {
      Dh(i, l, r), Dh(l, i, n);
    });
  });
}
function xx(t, e) {
  return t ? typeof t == "string" ? fi(t) : t : fi(e);
}
function Iw(t) {
  return function(e, r, n) {
    for (var i = e.length, l = n !== void 0 ? n : 2, h = r !== void 0 ? r : new Array(i), s = 0; s < i; s += l)
      for (var m = t(e.slice(s, s + l)), v = m.length, E = 0, T = l; E < T; ++E)
        h[s + E] = E >= v ? e[s + E] : m[E];
    return h;
  };
}
function ND(t, e, r, n) {
  var i = fi(t), l = fi(e);
  Dh(i, l, Iw(r)), Dh(l, i, Iw(n));
}
function FD(t, e) {
  var r = Rd(t, e !== void 0 ? e : "EPSG:3857", "EPSG:4326"), n = r[0];
  return (n < -180 || n > 180) && (r[0] = Qc(n + 180, 360) - 180), r;
}
function Pl(t, e) {
  if (t === e)
    return !0;
  var r = t.getUnits() === e.getUnits();
  if (t.getCode() === e.getCode())
    return r;
  var n = bx(t, e);
  return n === vx && r;
}
function bx(t, e) {
  var r = t.getCode(), n = e.getCode(), i = QS(r, n);
  return i || (i = a2), i;
}
function kh(t, e) {
  var r = fi(t), n = fi(e);
  return bx(r, n);
}
function Rd(t, e, r) {
  var n = kh(e, r);
  return n(t, void 0, t.length);
}
function zD(t, e, r, n) {
  var i = kh(e, r);
  return CD(t, i, void 0, n);
}
var BD = null;
function UD() {
  return BD;
}
function S0(t, e) {
  return t;
}
function Ds(t, e) {
  return E0 && !Dg(t, [0, 0]) && t[0] >= -180 && t[0] <= 180 && t[1] >= -90 && t[1] <= 90 && (E0 = !1, console.warn("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.")), t;
}
function $D(t, e) {
  return t;
}
function Ll(t, e) {
  return t;
}
function Pw(t, e, r) {
  return function(n) {
    var i, l;
    if (t.canWrapX()) {
      var h = t.getExtent(), s = Cn(h);
      n = n.slice(0), l = o2(n, t, s), l && (n[0] = n[0] - l * s), n[0] = hi(n[0], h[0], h[2]), n[1] = hi(n[1], h[1], h[3]), i = r(n);
    } else
      i = r(n);
    return l && e.canWrapX() && (i[0] += l * Cn(e.getExtent())), i;
  };
}
function VD() {
  T0(ww), T0(Tw), kD(Tw, ww, oD, aD);
}
VD();
function jD(t) {
  var e = Object.keys(t.defs), r = e.length, n, i;
  for (n = 0; n < r; ++n) {
    var l = e[n];
    if (!fi(l)) {
      var h = t.defs(l), s = h.units;
      !s && h.projName === "longlat" && (s = Fs.DEGREES), s2(new mx({
        code: l,
        axisOrientation: h.axis,
        metersPerUnit: h.to_meter,
        units: s
      }));
    }
  }
  for (n = 0; n < r; ++n) {
    var m = e[n], v = fi(m);
    for (i = 0; i < r; ++i) {
      var E = e[i], T = fi(E);
      if (!QS(m, E))
        if (t.defs[m] === t.defs[E])
          T0([v, T]);
        else {
          var S = t(m, E);
          ND(v, T, Pw(v, T, S.forward), Pw(T, v, S.inverse));
        }
    }
  }
}
function GD(t) {
  t("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), t.WGS84 = t["EPSG:4326"], t["EPSG:3785"] = t["EPSG:3857"], t.GOOGLE = t["EPSG:3857"], t["EPSG:900913"] = t["EPSG:3857"], t["EPSG:102113"] = t["EPSG:3857"];
}
var su = 1, lu = 2, Mh = 3, qD = 4, M0 = 5, Aw = 6378137, WD = 6356752314e-3, Ow = 0.0066943799901413165, md = 484813681109536e-20, ct = Math.PI / 2, XD = 0.16666666666666666, ZD = 0.04722222222222222, HD = 0.022156084656084655, It = 1e-10, Fi = 0.017453292519943295, Qa = 57.29577951308232, Jr = Math.PI / 4, Ld = Math.PI * 2, ti = 3.14159265359, Io = {};
Io.greenwich = 0;
Io.lisbon = -9.131906111111;
Io.paris = 2.337229166667;
Io.bogota = -74.080916666667;
Io.madrid = -3.687938888889;
Io.rome = 12.452333333333;
Io.bern = 7.439583333333;
Io.jakarta = 106.807719444444;
Io.ferro = -17.666666666667;
Io.brussels = 4.367975;
Io.stockholm = 18.058277777778;
Io.athens = 23.7163375;
Io.oslo = 10.722916666667;
const KD = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var Rw = /[\s_\-\/\(\)]/g;
function Gl(t, e) {
  if (t[e])
    return t[e];
  for (var r = Object.keys(t), n = e.toLowerCase().replace(Rw, ""), i = -1, l, h; ++i < r.length; )
    if (l = r[i], h = l.toLowerCase().replace(Rw, ""), h === n)
      return t[l];
}
function C0(t) {
  var e = {}, r = t.split("+").map(function(s) {
    return s.trim();
  }).filter(function(s) {
    return s;
  }).reduce(function(s, m) {
    var v = m.split("=");
    return v.push(!0), s[v[0].toLowerCase()] = v[1], s;
  }, {}), n, i, l, h = {
    proj: "projName",
    datum: "datumCode",
    rf: function(s) {
      e.rf = parseFloat(s);
    },
    lat_0: function(s) {
      e.lat0 = s * Fi;
    },
    lat_1: function(s) {
      e.lat1 = s * Fi;
    },
    lat_2: function(s) {
      e.lat2 = s * Fi;
    },
    lat_ts: function(s) {
      e.lat_ts = s * Fi;
    },
    lon_0: function(s) {
      e.long0 = s * Fi;
    },
    lon_1: function(s) {
      e.long1 = s * Fi;
    },
    lon_2: function(s) {
      e.long2 = s * Fi;
    },
    alpha: function(s) {
      e.alpha = parseFloat(s) * Fi;
    },
    gamma: function(s) {
      e.rectified_grid_angle = parseFloat(s);
    },
    lonc: function(s) {
      e.longc = s * Fi;
    },
    x_0: function(s) {
      e.x0 = parseFloat(s);
    },
    y_0: function(s) {
      e.y0 = parseFloat(s);
    },
    k_0: function(s) {
      e.k0 = parseFloat(s);
    },
    k: function(s) {
      e.k0 = parseFloat(s);
    },
    a: function(s) {
      e.a = parseFloat(s);
    },
    b: function(s) {
      e.b = parseFloat(s);
    },
    r_a: function() {
      e.R_A = !0;
    },
    zone: function(s) {
      e.zone = parseInt(s, 10);
    },
    south: function() {
      e.utmSouth = !0;
    },
    towgs84: function(s) {
      e.datum_params = s.split(",").map(function(m) {
        return parseFloat(m);
      });
    },
    to_meter: function(s) {
      e.to_meter = parseFloat(s);
    },
    units: function(s) {
      e.units = s;
      var m = Gl(KD, s);
      m && (e.to_meter = m.to_meter);
    },
    from_greenwich: function(s) {
      e.from_greenwich = s * Fi;
    },
    pm: function(s) {
      var m = Gl(Io, s);
      e.from_greenwich = (m || parseFloat(s)) * Fi;
    },
    nadgrids: function(s) {
      s === "@null" ? e.datumCode = "none" : e.nadgrids = s;
    },
    axis: function(s) {
      var m = "ewnsud";
      s.length === 3 && m.indexOf(s.substr(0, 1)) !== -1 && m.indexOf(s.substr(1, 1)) !== -1 && m.indexOf(s.substr(2, 1)) !== -1 && (e.axis = s);
    },
    approx: function() {
      e.approx = !0;
    }
  };
  for (n in r)
    i = r[n], n in h ? (l = h[n], typeof l == "function" ? l(i) : e[l] = i) : e[n] = i;
  return typeof e.datumCode == "string" && e.datumCode !== "WGS84" && (e.datumCode = e.datumCode.toLowerCase()), e;
}
var Dd = 1, l2 = 2, c2 = 3, kg = 4, u2 = 5, wx = -1, YD = /\s/, JD = /[A-Za-z]/, QD = /[A-Za-z84_]/, Fy = /[,\]]/, h2 = /[\d\.E\-\+]/;
function Ws(t) {
  if (typeof t != "string")
    throw new Error("not a string");
  this.text = t.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Dd;
}
Ws.prototype.readCharicter = function() {
  var t = this.text[this.place++];
  if (this.state !== kg)
    for (; YD.test(t); ) {
      if (this.place >= this.text.length)
        return;
      t = this.text[this.place++];
    }
  switch (this.state) {
    case Dd:
      return this.neutral(t);
    case l2:
      return this.keyword(t);
    case kg:
      return this.quoted(t);
    case u2:
      return this.afterquote(t);
    case c2:
      return this.number(t);
    case wx:
      return;
  }
};
Ws.prototype.afterquote = function(t) {
  if (t === '"') {
    this.word += '"', this.state = kg;
    return;
  }
  if (Fy.test(t)) {
    this.word = this.word.trim(), this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in afterquote yet, index ' + this.place);
};
Ws.prototype.afterItem = function(t) {
  if (t === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = Dd;
    return;
  }
  if (t === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Dd, this.currentObject = this.stack.pop(), this.currentObject || (this.state = wx);
    return;
  }
};
Ws.prototype.number = function(t) {
  if (h2.test(t)) {
    this.word += t;
    return;
  }
  if (Fy.test(t)) {
    this.word = parseFloat(this.word), this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in number yet, index ' + this.place);
};
Ws.prototype.quoted = function(t) {
  if (t === '"') {
    this.state = u2;
    return;
  }
  this.word += t;
};
Ws.prototype.keyword = function(t) {
  if (QD.test(t)) {
    this.word += t;
    return;
  }
  if (t === "[") {
    var e = [];
    e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, this.state = Dd;
    return;
  }
  if (Fy.test(t)) {
    this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in keyword yet, index ' + this.place);
};
Ws.prototype.neutral = function(t) {
  if (JD.test(t)) {
    this.word = t, this.state = l2;
    return;
  }
  if (t === '"') {
    this.word = "", this.state = kg;
    return;
  }
  if (h2.test(t)) {
    this.word = t, this.state = c2;
    return;
  }
  if (Fy.test(t)) {
    this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in neutral yet, index ' + this.place);
};
Ws.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === wx)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function ek(t) {
  var e = new Ws(t);
  return e.output();
}
function Lw(t, e, r) {
  Array.isArray(e) && (r.unshift(e), e = null);
  var n = e ? {} : t, i = r.reduce(function(l, h) {
    return ph(h, l), l;
  }, n);
  e && (t[e] = i);
}
function ph(t, e) {
  if (!Array.isArray(t)) {
    e[t] = !0;
    return;
  }
  var r = t.shift();
  if (r === "PARAMETER" && (r = t.shift()), t.length === 1) {
    if (Array.isArray(t[0])) {
      e[r] = {}, ph(t[0], e[r]);
      return;
    }
    e[r] = t[0];
    return;
  }
  if (!t.length) {
    e[r] = !0;
    return;
  }
  if (r === "TOWGS84") {
    e[r] = t;
    return;
  }
  if (r === "AXIS") {
    r in e || (e[r] = []), e[r].push(t);
    return;
  }
  Array.isArray(r) || (e[r] = {});
  var n;
  switch (r) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      e[r] = {
        name: t[0].toLowerCase(),
        convert: t[1]
      }, t.length === 3 && ph(t[2], e[r]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      e[r] = {
        name: t[0],
        a: t[1],
        rf: t[2]
      }, t.length === 4 && ph(t[3], e[r]);
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      t[0] = ["name", t[0]], Lw(e, r, t);
      return;
    default:
      for (n = -1; ++n < t.length; )
        if (!Array.isArray(t[n]))
          return ph(t, e[r]);
      return Lw(e, r, t);
  }
}
var tk = 0.017453292519943295;
function rk(t, e) {
  var r = e[0], n = e[1];
  !(r in t) && n in t && (t[r] = t[n], e.length === 3 && (t[r] = e[2](t[r])));
}
function Ps(t) {
  return t * tk;
}
function nk(t) {
  if (t.type === "GEOGCS" ? t.projName = "longlat" : t.type === "LOCAL_CS" ? (t.projName = "identity", t.local = !0) : typeof t.PROJECTION == "object" ? t.projName = Object.keys(t.PROJECTION)[0] : t.projName = t.PROJECTION, t.AXIS) {
    for (var e = "", r = 0, n = t.AXIS.length; r < n; ++r) {
      var i = [t.AXIS[r][0].toLowerCase(), t.AXIS[r][1].toLowerCase()];
      i[0].indexOf("north") !== -1 || (i[0] === "y" || i[0] === "lat") && i[1] === "north" ? e += "n" : i[0].indexOf("south") !== -1 || (i[0] === "y" || i[0] === "lat") && i[1] === "south" ? e += "s" : i[0].indexOf("east") !== -1 || (i[0] === "x" || i[0] === "lon") && i[1] === "east" ? e += "e" : (i[0].indexOf("west") !== -1 || (i[0] === "x" || i[0] === "lon") && i[1] === "west") && (e += "w");
    }
    e.length === 2 && (e += "u"), e.length === 3 && (t.axis = e);
  }
  t.UNIT && (t.units = t.UNIT.name.toLowerCase(), t.units === "metre" && (t.units = "meter"), t.UNIT.convert && (t.type === "GEOGCS" ? t.DATUM && t.DATUM.SPHEROID && (t.to_meter = t.UNIT.convert * t.DATUM.SPHEROID.a) : t.to_meter = t.UNIT.convert));
  var l = t.GEOGCS;
  t.type === "GEOGCS" && (l = t), l && (l.DATUM ? t.datumCode = l.DATUM.name.toLowerCase() : t.datumCode = l.name.toLowerCase(), t.datumCode.slice(0, 2) === "d_" && (t.datumCode = t.datumCode.slice(2)), (t.datumCode === "new_zealand_geodetic_datum_1949" || t.datumCode === "new_zealand_1949") && (t.datumCode = "nzgd49"), (t.datumCode === "wgs_1984" || t.datumCode === "world_geodetic_system_1984") && (t.PROJECTION === "Mercator_Auxiliary_Sphere" && (t.sphere = !0), t.datumCode = "wgs84"), t.datumCode.slice(-6) === "_ferro" && (t.datumCode = t.datumCode.slice(0, -6)), t.datumCode.slice(-8) === "_jakarta" && (t.datumCode = t.datumCode.slice(0, -8)), ~t.datumCode.indexOf("belge") && (t.datumCode = "rnb72"), l.DATUM && l.DATUM.SPHEROID && (t.ellps = l.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), t.ellps.toLowerCase().slice(0, 13) === "international" && (t.ellps = "intl"), t.a = l.DATUM.SPHEROID.a, t.rf = parseFloat(l.DATUM.SPHEROID.rf, 10)), l.DATUM && l.DATUM.TOWGS84 && (t.datum_params = l.DATUM.TOWGS84), ~t.datumCode.indexOf("osgb_1936") && (t.datumCode = "osgb36"), ~t.datumCode.indexOf("osni_1952") && (t.datumCode = "osni52"), (~t.datumCode.indexOf("tm65") || ~t.datumCode.indexOf("geodetic_datum_of_1965")) && (t.datumCode = "ire65"), t.datumCode === "ch1903+" && (t.datumCode = "ch1903"), ~t.datumCode.indexOf("israel") && (t.datumCode = "isr93")), t.b && !isFinite(t.b) && (t.b = t.a);
  function h(v) {
    var E = t.to_meter || 1;
    return v * E;
  }
  var s = function(v) {
    return rk(t, v);
  }, m = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", Ps],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", Ps],
    ["x0", "false_easting", h],
    ["y0", "false_northing", h],
    ["long0", "central_meridian", Ps],
    ["lat0", "latitude_of_origin", Ps],
    ["lat0", "standard_parallel_1", Ps],
    ["lat1", "standard_parallel_1", Ps],
    ["lat2", "standard_parallel_2", Ps],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", Ps],
    ["srsCode", "name"]
  ];
  m.forEach(s), !t.long0 && t.longc && (t.projName === "Albers_Conic_Equal_Area" || t.projName === "Lambert_Azimuthal_Equal_Area") && (t.long0 = t.longc), !t.lat_ts && t.lat1 && (t.projName === "Stereographic_South_Pole" || t.projName === "Polar Stereographic (variant B)") && (t.lat0 = Ps(t.lat1 > 0 ? 90 : -90), t.lat_ts = t.lat1);
}
function f2(t) {
  var e = ek(t), r = e.shift(), n = e.shift();
  e.unshift(["name", n]), e.unshift(["type", r]);
  var i = {};
  return ph(e, i), nk(i), i;
}
function ho(t) {
  var e = this;
  if (arguments.length === 2) {
    var r = arguments[1];
    typeof r == "string" ? r.charAt(0) === "+" ? ho[t] = C0(arguments[1]) : ho[t] = f2(arguments[1]) : ho[t] = r;
  } else if (arguments.length === 1) {
    if (Array.isArray(t))
      return t.map(function(n) {
        Array.isArray(n) ? ho.apply(e, n) : ho(n);
      });
    if (typeof t == "string") {
      if (t in ho)
        return ho[t];
    } else
      "EPSG" in t ? ho["EPSG:" + t.EPSG] = t : "ESRI" in t ? ho["ESRI:" + t.ESRI] = t : "IAU2000" in t ? ho["IAU2000:" + t.IAU2000] = t : console.log(t);
    return;
  }
}
GD(ho);
function ik(t) {
  return typeof t == "string";
}
function ok(t) {
  return t in ho;
}
var ak = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function sk(t) {
  return ak.some(function(e) {
    return t.indexOf(e) > -1;
  });
}
var lk = ["3857", "900913", "3785", "102113"];
function ck(t) {
  var e = Gl(t, "authority");
  if (!!e) {
    var r = Gl(e, "epsg");
    return r && lk.indexOf(r) > -1;
  }
}
function uk(t) {
  var e = Gl(t, "extension");
  if (!!e)
    return Gl(e, "proj4");
}
function hk(t) {
  return t[0] === "+";
}
function fk(t) {
  if (ik(t)) {
    if (ok(t))
      return ho[t];
    if (sk(t)) {
      var e = f2(t);
      if (ck(e))
        return ho["EPSG:3857"];
      var r = uk(e);
      return r ? C0(r) : e;
    }
    if (hk(t))
      return C0(t);
  } else
    return t;
}
function Dw(t, e) {
  t = t || {};
  var r, n;
  if (!e)
    return t;
  for (n in e)
    r = e[n], r !== void 0 && (t[n] = r);
  return t;
}
function ls(t, e, r) {
  var n = t * e;
  return r / Math.sqrt(1 - n * n);
}
function Hd(t) {
  return t < 0 ? -1 : 1;
}
function Ft(t) {
  return Math.abs(t) <= ti ? t : t - Hd(t) * Ld;
}
function Oa(t, e, r) {
  var n = t * r, i = 0.5 * t;
  return n = Math.pow((1 - n) / (1 + n), i), Math.tan(0.5 * (ct - e)) / n;
}
function kd(t, e) {
  for (var r = 0.5 * t, n, i, l = ct - 2 * Math.atan(e), h = 0; h <= 15; h++)
    if (n = t * Math.sin(l), i = ct - 2 * Math.atan(e * Math.pow((1 - n) / (1 + n), r)) - l, l += i, Math.abs(i) <= 1e-10)
      return l;
  return -9999;
}
function dk() {
  var t = this.b / this.a;
  this.es = 1 - t * t, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = ls(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function pk(t) {
  var e = t.x, r = t.y;
  if (r * Qa > 90 && r * Qa < -90 && e * Qa > 180 && e * Qa < -180)
    return null;
  var n, i;
  if (Math.abs(Math.abs(r) - ct) <= It)
    return null;
  if (this.sphere)
    n = this.x0 + this.a * this.k0 * Ft(e - this.long0), i = this.y0 + this.a * this.k0 * Math.log(Math.tan(Jr + 0.5 * r));
  else {
    var l = Math.sin(r), h = Oa(this.e, r, l);
    n = this.x0 + this.a * this.k0 * Ft(e - this.long0), i = this.y0 - this.a * this.k0 * Math.log(h);
  }
  return t.x = n, t.y = i, t;
}
function mk(t) {
  var e = t.x - this.x0, r = t.y - this.y0, n, i;
  if (this.sphere)
    i = ct - 2 * Math.atan(Math.exp(-r / (this.a * this.k0)));
  else {
    var l = Math.exp(-r / (this.a * this.k0));
    if (i = kd(this.e, l), i === -9999)
      return null;
  }
  return n = Ft(this.long0 + e / (this.a * this.k0)), t.x = n, t.y = i, t;
}
var gk = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const yk = {
  init: dk,
  forward: pk,
  inverse: mk,
  names: gk
};
function _k() {
}
function kw(t) {
  return t;
}
var vk = ["longlat", "identity"];
const xk = {
  init: _k,
  forward: kw,
  inverse: kw,
  names: vk
};
var bk = [yk, xk], hg = {}, Ng = [];
function d2(t, e) {
  var r = Ng.length;
  return t.names ? (Ng[r] = t, t.names.forEach(function(n) {
    hg[n.toLowerCase()] = r;
  }), this) : (console.log(e), !0);
}
function wk(t) {
  if (!t)
    return !1;
  var e = t.toLowerCase();
  if (typeof hg[e] < "u" && Ng[hg[e]])
    return Ng[hg[e]];
}
function Ek() {
  bk.forEach(d2);
}
const Tk = {
  start: Ek,
  add: d2,
  get: wk
};
var cr = {};
cr.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
cr.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
cr.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
cr.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
cr.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
cr.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
cr.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
cr.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
cr.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
cr.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
cr.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
cr.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
cr.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
cr.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
cr.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
cr.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
cr.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
cr.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
cr.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
cr.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
cr.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
cr.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
cr.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
cr.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
cr.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
cr.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
cr.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
cr.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
cr.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
cr.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
cr.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
cr.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
cr.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
cr.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
cr.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
cr.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
cr.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
cr.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
cr.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
cr.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
cr.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var Sk = cr.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
cr.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function Mk(t, e, r, n) {
  var i = t * t, l = e * e, h = (i - l) / i, s = 0;
  n ? (t *= 1 - h * (XD + h * (ZD + h * HD)), i = t * t, h = 0) : s = Math.sqrt(h);
  var m = (i - l) / l;
  return {
    es: h,
    e: s,
    ep2: m
  };
}
function Ck(t, e, r, n, i) {
  if (!t) {
    var l = Gl(cr, n);
    l || (l = Sk), t = l.a, e = l.b, r = l.rf;
  }
  return r && !e && (e = (1 - 1 / r) * t), (r === 0 || Math.abs(t - e) < It) && (i = !0, e = t), {
    a: t,
    b: e,
    rf: r,
    sphere: i
  };
}
var Oi = {};
Oi.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
Oi.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
Oi.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
Oi.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
Oi.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
Oi.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
Oi.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
Oi.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
Oi.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
Oi.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
Oi.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
Oi.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
Oi.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
Oi.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
Oi.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
Oi.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
Oi.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function Ik(t, e, r, n, i, l, h) {
  var s = {};
  return t === void 0 || t === "none" ? s.datum_type = M0 : s.datum_type = qD, e && (s.datum_params = e.map(parseFloat), (s.datum_params[0] !== 0 || s.datum_params[1] !== 0 || s.datum_params[2] !== 0) && (s.datum_type = su), s.datum_params.length > 3 && (s.datum_params[3] !== 0 || s.datum_params[4] !== 0 || s.datum_params[5] !== 0 || s.datum_params[6] !== 0) && (s.datum_type = lu, s.datum_params[3] *= md, s.datum_params[4] *= md, s.datum_params[5] *= md, s.datum_params[6] = s.datum_params[6] / 1e6 + 1)), h && (s.datum_type = Mh, s.grids = h), s.a = r, s.b = n, s.es = i, s.ep2 = l, s;
}
var p2 = {};
function Pk(t, e) {
  var r = new DataView(e), n = Rk(r), i = Lk(r, n);
  i.nSubgrids > 1 && console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
  var l = Dk(r, i, n), h = { header: i, subgrids: l };
  return p2[t] = h, h;
}
function Ak(t) {
  if (t === void 0)
    return null;
  var e = t.split(",");
  return e.map(Ok);
}
function Ok(t) {
  if (t.length === 0)
    return null;
  var e = t[0] === "@";
  return e && (t = t.slice(1)), t === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : {
    name: t,
    mandatory: !e,
    grid: p2[t] || null,
    isNull: !1
  };
}
function mh(t) {
  return t / 3600 * Math.PI / 180;
}
function Rk(t) {
  var e = t.getInt32(8, !1);
  return e === 11 ? !1 : (e = t.getInt32(8, !0), e !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function Lk(t, e) {
  return {
    nFields: t.getInt32(8, e),
    nSubgridFields: t.getInt32(24, e),
    nSubgrids: t.getInt32(40, e),
    shiftType: I0(t, 56, 56 + 8).trim(),
    fromSemiMajorAxis: t.getFloat64(120, e),
    fromSemiMinorAxis: t.getFloat64(136, e),
    toSemiMajorAxis: t.getFloat64(152, e),
    toSemiMinorAxis: t.getFloat64(168, e)
  };
}
function I0(t, e, r) {
  return String.fromCharCode.apply(null, new Uint8Array(t.buffer.slice(e, r)));
}
function Dk(t, e, r) {
  for (var n = 176, i = [], l = 0; l < e.nSubgrids; l++) {
    var h = Nk(t, n, r), s = Fk(t, n, h, r), m = Math.round(
      1 + (h.upperLongitude - h.lowerLongitude) / h.longitudeInterval
    ), v = Math.round(
      1 + (h.upperLatitude - h.lowerLatitude) / h.latitudeInterval
    );
    i.push({
      ll: [mh(h.lowerLongitude), mh(h.lowerLatitude)],
      del: [mh(h.longitudeInterval), mh(h.latitudeInterval)],
      lim: [m, v],
      count: h.gridNodeCount,
      cvs: kk(s)
    });
  }
  return i;
}
function kk(t) {
  return t.map(function(e) {
    return [mh(e.longitudeShift), mh(e.latitudeShift)];
  });
}
function Nk(t, e, r) {
  return {
    name: I0(t, e + 8, e + 16).trim(),
    parent: I0(t, e + 24, e + 24 + 8).trim(),
    lowerLatitude: t.getFloat64(e + 72, r),
    upperLatitude: t.getFloat64(e + 88, r),
    lowerLongitude: t.getFloat64(e + 104, r),
    upperLongitude: t.getFloat64(e + 120, r),
    latitudeInterval: t.getFloat64(e + 136, r),
    longitudeInterval: t.getFloat64(e + 152, r),
    gridNodeCount: t.getInt32(e + 168, r)
  };
}
function Fk(t, e, r, n) {
  for (var i = e + 176, l = 16, h = [], s = 0; s < r.gridNodeCount; s++) {
    var m = {
      latitudeShift: t.getFloat32(i + s * l, n),
      longitudeShift: t.getFloat32(i + s * l + 4, n),
      latitudeAccuracy: t.getFloat32(i + s * l + 8, n),
      longitudeAccuracy: t.getFloat32(i + s * l + 12, n)
    };
    h.push(m);
  }
  return h;
}
function rs(t, e) {
  if (!(this instanceof rs))
    return new rs(t);
  e = e || function(v) {
    if (v)
      throw v;
  };
  var r = fk(t);
  if (typeof r != "object") {
    e(t);
    return;
  }
  var n = rs.projections.get(r.projName);
  if (!n) {
    e(t);
    return;
  }
  if (r.datumCode && r.datumCode !== "none") {
    var i = Gl(Oi, r.datumCode);
    i && (r.datum_params = r.datum_params || (i.towgs84 ? i.towgs84.split(",") : null), r.ellps = i.ellipse, r.datumName = i.datumName ? i.datumName : r.datumCode);
  }
  r.k0 = r.k0 || 1, r.axis = r.axis || "enu", r.ellps = r.ellps || "wgs84", r.lat1 = r.lat1 || r.lat0;
  var l = Ck(r.a, r.b, r.rf, r.ellps, r.sphere), h = Mk(l.a, l.b, l.rf, r.R_A), s = Ak(r.nadgrids), m = r.datum || Ik(
    r.datumCode,
    r.datum_params,
    l.a,
    l.b,
    h.es,
    h.ep2,
    s
  );
  Dw(this, r), Dw(this, n), this.a = l.a, this.b = l.b, this.rf = l.rf, this.sphere = l.sphere, this.es = h.es, this.e = h.e, this.ep2 = h.ep2, this.datum = m, this.init(), e(null, this);
}
rs.projections = Tk;
rs.projections.start();
function zk(t, e) {
  return t.datum_type !== e.datum_type || t.a !== e.a || Math.abs(t.es - e.es) > 5e-11 ? !1 : t.datum_type === su ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] : t.datum_type === lu ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] && t.datum_params[3] === e.datum_params[3] && t.datum_params[4] === e.datum_params[4] && t.datum_params[5] === e.datum_params[5] && t.datum_params[6] === e.datum_params[6] : !0;
}
function m2(t, e, r) {
  var n = t.x, i = t.y, l = t.z ? t.z : 0, h, s, m, v;
  if (i < -ct && i > -1.001 * ct)
    i = -ct;
  else if (i > ct && i < 1.001 * ct)
    i = ct;
  else {
    if (i < -ct)
      return { x: -1 / 0, y: -1 / 0, z: t.z };
    if (i > ct)
      return { x: 1 / 0, y: 1 / 0, z: t.z };
  }
  return n > Math.PI && (n -= 2 * Math.PI), s = Math.sin(i), v = Math.cos(i), m = s * s, h = r / Math.sqrt(1 - e * m), {
    x: (h + l) * v * Math.cos(n),
    y: (h + l) * v * Math.sin(n),
    z: (h * (1 - e) + l) * s
  };
}
function g2(t, e, r, n) {
  var i = 1e-12, l = i * i, h = 30, s, m, v, E, T, S, A, L, B, j, q, H, ne, ee = t.x, he = t.y, Te = t.z ? t.z : 0, ve, Oe, Me;
  if (s = Math.sqrt(ee * ee + he * he), m = Math.sqrt(ee * ee + he * he + Te * Te), s / r < i) {
    if (ve = 0, m / r < i)
      return Oe = ct, Me = -n, {
        x: t.x,
        y: t.y,
        z: t.z
      };
  } else
    ve = Math.atan2(he, ee);
  v = Te / m, E = s / m, T = 1 / Math.sqrt(1 - e * (2 - e) * E * E), L = E * (1 - e) * T, B = v * T, ne = 0;
  do
    ne++, A = r / Math.sqrt(1 - e * B * B), Me = s * L + Te * B - A * (1 - e * B * B), S = e * A / (A + Me), T = 1 / Math.sqrt(1 - S * (2 - S) * E * E), j = E * (1 - S) * T, q = v * T, H = q * L - j * B, L = j, B = q;
  while (H * H > l && ne < h);
  return Oe = Math.atan(q / Math.abs(j)), {
    x: ve,
    y: Oe,
    z: Me
  };
}
function Bk(t, e, r) {
  if (e === su)
    return {
      x: t.x + r[0],
      y: t.y + r[1],
      z: t.z + r[2]
    };
  if (e === lu) {
    var n = r[0], i = r[1], l = r[2], h = r[3], s = r[4], m = r[5], v = r[6];
    return {
      x: v * (t.x - m * t.y + s * t.z) + n,
      y: v * (m * t.x + t.y - h * t.z) + i,
      z: v * (-s * t.x + h * t.y + t.z) + l
    };
  }
}
function Uk(t, e, r) {
  if (e === su)
    return {
      x: t.x - r[0],
      y: t.y - r[1],
      z: t.z - r[2]
    };
  if (e === lu) {
    var n = r[0], i = r[1], l = r[2], h = r[3], s = r[4], m = r[5], v = r[6], E = (t.x - n) / v, T = (t.y - i) / v, S = (t.z - l) / v;
    return {
      x: E + m * T - s * S,
      y: -m * E + T + h * S,
      z: s * E - h * T + S
    };
  }
}
function Am(t) {
  return t === su || t === lu;
}
function $k(t, e, r) {
  if (zk(t, e) || t.datum_type === M0 || e.datum_type === M0)
    return r;
  var n = t.a, i = t.es;
  if (t.datum_type === Mh) {
    var l = Nw(t, !1, r);
    if (l !== 0)
      return;
    n = Aw, i = Ow;
  }
  var h = e.a, s = e.b, m = e.es;
  if (e.datum_type === Mh && (h = Aw, s = WD, m = Ow), i === m && n === h && !Am(t.datum_type) && !Am(e.datum_type))
    return r;
  if (r = m2(r, i, n), Am(t.datum_type) && (r = Bk(r, t.datum_type, t.datum_params)), Am(e.datum_type) && (r = Uk(r, e.datum_type, e.datum_params)), r = g2(r, m, h, s), e.datum_type === Mh) {
    var v = Nw(e, !0, r);
    if (v !== 0)
      return;
  }
  return r;
}
function Nw(t, e, r) {
  if (t.grids === null || t.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  for (var n = { x: -r.x, y: r.y }, i = { x: Number.NaN, y: Number.NaN }, l = [], h = 0; h < t.grids.length; h++) {
    var s = t.grids[h];
    if (l.push(s.name), s.isNull) {
      i = n;
      break;
    }
    if (s.mandatory, s.grid === null) {
      if (s.mandatory)
        return console.log("Unable to find mandatory grid '" + s.name + "'"), -1;
      continue;
    }
    var m = s.grid.subgrids[0], v = (Math.abs(m.del[1]) + Math.abs(m.del[0])) / 1e4, E = m.ll[0] - v, T = m.ll[1] - v, S = m.ll[0] + (m.lim[0] - 1) * m.del[0] + v, A = m.ll[1] + (m.lim[1] - 1) * m.del[1] + v;
    if (!(T > n.y || E > n.x || A < n.y || S < n.x) && (i = Vk(n, e, m), !isNaN(i.x)))
      break;
  }
  return isNaN(i.x) ? (console.log("Failed to find a grid shift table for location '" + -n.x * Qa + " " + n.y * Qa + " tried: '" + l + "'"), -1) : (r.x = -i.x, r.y = i.y, 0);
}
function Vk(t, e, r) {
  var n = { x: Number.NaN, y: Number.NaN };
  if (isNaN(t.x))
    return n;
  var i = { x: t.x, y: t.y };
  i.x -= r.ll[0], i.y -= r.ll[1], i.x = Ft(i.x - Math.PI) + Math.PI;
  var l = Fw(i, r);
  if (e) {
    if (isNaN(l.x))
      return n;
    l.x = i.x - l.x, l.y = i.y - l.y;
    var h = 9, s = 1e-12, m, v;
    do {
      if (v = Fw(l, r), isNaN(v.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      m = { x: i.x - (v.x + l.x), y: i.y - (v.y + l.y) }, l.x += m.x, l.y += m.y;
    } while (h-- && Math.abs(m.x) > s && Math.abs(m.y) > s);
    if (h < 0)
      return console.log("Inverse grid shift iterator failed to converge."), n;
    n.x = Ft(l.x + r.ll[0]), n.y = l.y + r.ll[1];
  } else
    isNaN(l.x) || (n.x = t.x + l.x, n.y = t.y + l.y);
  return n;
}
function Fw(t, e) {
  var r = { x: t.x / e.del[0], y: t.y / e.del[1] }, n = { x: Math.floor(r.x), y: Math.floor(r.y) }, i = { x: r.x - 1 * n.x, y: r.y - 1 * n.y }, l = { x: Number.NaN, y: Number.NaN }, h;
  if (n.x < 0 || n.x >= e.lim[0] || n.y < 0 || n.y >= e.lim[1])
    return l;
  h = n.y * e.lim[0] + n.x;
  var s = { x: e.cvs[h][0], y: e.cvs[h][1] };
  h++;
  var m = { x: e.cvs[h][0], y: e.cvs[h][1] };
  h += e.lim[0];
  var v = { x: e.cvs[h][0], y: e.cvs[h][1] };
  h--;
  var E = { x: e.cvs[h][0], y: e.cvs[h][1] }, T = i.x * i.y, S = i.x * (1 - i.y), A = (1 - i.x) * (1 - i.y), L = (1 - i.x) * i.y;
  return l.x = A * s.x + S * m.x + L * E.x + T * v.x, l.y = A * s.y + S * m.y + L * E.y + T * v.y, l;
}
function zw(t, e, r) {
  var n = r.x, i = r.y, l = r.z || 0, h, s, m, v = {};
  for (m = 0; m < 3; m++)
    if (!(e && m === 2 && r.z === void 0))
      switch (m === 0 ? (h = n, "ew".indexOf(t.axis[m]) !== -1 ? s = "x" : s = "y") : m === 1 ? (h = i, "ns".indexOf(t.axis[m]) !== -1 ? s = "y" : s = "x") : (h = l, s = "z"), t.axis[m]) {
        case "e":
          v[s] = h;
          break;
        case "w":
          v[s] = -h;
          break;
        case "n":
          v[s] = h;
          break;
        case "s":
          v[s] = -h;
          break;
        case "u":
          r[s] !== void 0 && (v.z = h);
          break;
        case "d":
          r[s] !== void 0 && (v.z = -h);
          break;
        default:
          return null;
      }
  return v;
}
function y2(t) {
  var e = {
    x: t[0],
    y: t[1]
  };
  return t.length > 2 && (e.z = t[2]), t.length > 3 && (e.m = t[3]), e;
}
function jk(t) {
  Bw(t.x), Bw(t.y);
}
function Bw(t) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(t))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof t != "number" || t !== t || !isFinite(t))
    throw new TypeError("coordinates must be finite numbers");
}
function Gk(t, e) {
  return (t.datum.datum_type === su || t.datum.datum_type === lu || t.datum.datum_type === Mh) && e.datumCode !== "WGS84" || (e.datum.datum_type === su || e.datum.datum_type === lu || e.datum.datum_type === Mh) && t.datumCode !== "WGS84";
}
function Fg(t, e, r, n) {
  var i;
  Array.isArray(r) ? r = y2(r) : r = {
    x: r.x,
    y: r.y,
    z: r.z,
    m: r.m
  };
  var l = r.z !== void 0;
  if (jk(r), t.datum && e.datum && Gk(t, e) && (i = new rs("WGS84"), r = Fg(t, i, r, n), t = i), n && t.axis !== "enu" && (r = zw(t, !1, r)), t.projName === "longlat")
    r = {
      x: r.x * Fi,
      y: r.y * Fi,
      z: r.z || 0
    };
  else if (t.to_meter && (r = {
    x: r.x * t.to_meter,
    y: r.y * t.to_meter,
    z: r.z || 0
  }), r = t.inverse(r), !r)
    return;
  if (t.from_greenwich && (r.x += t.from_greenwich), r = $k(t.datum, e.datum, r), !!r)
    return e.from_greenwich && (r = {
      x: r.x - e.from_greenwich,
      y: r.y,
      z: r.z || 0
    }), e.projName === "longlat" ? r = {
      x: r.x * Qa,
      y: r.y * Qa,
      z: r.z || 0
    } : (r = e.forward(r), e.to_meter && (r = {
      x: r.x / e.to_meter,
      y: r.y / e.to_meter,
      z: r.z || 0
    })), n && e.axis !== "enu" ? zw(e, !0, r) : (l || delete r.z, r);
}
var Uw = rs("WGS84");
function dv(t, e, r, n) {
  var i, l, h;
  return Array.isArray(r) ? (i = Fg(t, e, r, n) || { x: NaN, y: NaN }, r.length > 2 ? typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent" ? typeof i.z == "number" ? [i.x, i.y, i.z].concat(r.splice(3)) : [i.x, i.y, r[2]].concat(r.splice(3)) : [i.x, i.y].concat(r.splice(2)) : [i.x, i.y]) : (l = Fg(t, e, r, n), h = Object.keys(r), h.length === 2 || h.forEach(function(s) {
    if (typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent") {
      if (s === "x" || s === "y" || s === "z")
        return;
    } else if (s === "x" || s === "y")
      return;
    l[s] = r[s];
  }), l);
}
function $w(t) {
  return t instanceof rs ? t : t.oProj ? t.oProj : rs(t);
}
function Yi(t, e, r) {
  t = $w(t);
  var n = !1, i;
  return typeof e > "u" ? (e = t, t = Uw, n = !0) : (typeof e.x < "u" || Array.isArray(e)) && (r = e, e = t, t = Uw, n = !0), e = $w(e), r ? dv(t, e, r) : (i = {
    forward: function(l, h) {
      return dv(t, e, l, h);
    },
    inverse: function(l, h) {
      return dv(e, t, l, h);
    }
  }, n && (i.oProj = e), i);
}
var Vw = 6, _2 = "AJSAJS", v2 = "AFAFAF", gh = 65, wo = 73, ea = 79, rd = 86, nd = 90;
const qk = {
  forward: x2,
  inverse: Wk,
  toPoint: b2
};
function x2(t, e) {
  return e = e || 5, Hk(Xk({
    lat: t[1],
    lon: t[0]
  }), e);
}
function Wk(t) {
  var e = Ex(E2(t.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
}
function b2(t) {
  var e = Ex(E2(t.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function pv(t) {
  return t * (Math.PI / 180);
}
function jw(t) {
  return 180 * (t / Math.PI);
}
function Xk(t) {
  var e = t.lat, r = t.lon, n = 6378137, i = 669438e-8, l = 0.9996, h, s, m, v, E, T, S, A = pv(e), L = pv(r), B, j;
  j = Math.floor((r + 180) / 6) + 1, r === 180 && (j = 60), e >= 56 && e < 64 && r >= 3 && r < 12 && (j = 32), e >= 72 && e < 84 && (r >= 0 && r < 9 ? j = 31 : r >= 9 && r < 21 ? j = 33 : r >= 21 && r < 33 ? j = 35 : r >= 33 && r < 42 && (j = 37)), h = (j - 1) * 6 - 180 + 3, B = pv(h), s = i / (1 - i), m = n / Math.sqrt(1 - i * Math.sin(A) * Math.sin(A)), v = Math.tan(A) * Math.tan(A), E = s * Math.cos(A) * Math.cos(A), T = Math.cos(A) * (L - B), S = n * ((1 - i / 4 - 3 * i * i / 64 - 5 * i * i * i / 256) * A - (3 * i / 8 + 3 * i * i / 32 + 45 * i * i * i / 1024) * Math.sin(2 * A) + (15 * i * i / 256 + 45 * i * i * i / 1024) * Math.sin(4 * A) - 35 * i * i * i / 3072 * Math.sin(6 * A));
  var q = l * m * (T + (1 - v + E) * T * T * T / 6 + (5 - 18 * v + v * v + 72 * E - 58 * s) * T * T * T * T * T / 120) + 5e5, H = l * (S + m * Math.tan(A) * (T * T / 2 + (5 - v + 9 * E + 4 * E * E) * T * T * T * T / 24 + (61 - 58 * v + v * v + 600 * E - 330 * s) * T * T * T * T * T * T / 720));
  return e < 0 && (H += 1e7), {
    northing: Math.round(H),
    easting: Math.round(q),
    zoneNumber: j,
    zoneLetter: Zk(e)
  };
}
function Ex(t) {
  var e = t.northing, r = t.easting, n = t.zoneLetter, i = t.zoneNumber;
  if (i < 0 || i > 60)
    return null;
  var l = 0.9996, h = 6378137, s = 669438e-8, m, v = (1 - Math.sqrt(1 - s)) / (1 + Math.sqrt(1 - s)), E, T, S, A, L, B, j, q, H, ne = r - 5e5, ee = e;
  n < "N" && (ee -= 1e7), j = (i - 1) * 6 - 180 + 3, m = s / (1 - s), B = ee / l, q = B / (h * (1 - s / 4 - 3 * s * s / 64 - 5 * s * s * s / 256)), H = q + (3 * v / 2 - 27 * v * v * v / 32) * Math.sin(2 * q) + (21 * v * v / 16 - 55 * v * v * v * v / 32) * Math.sin(4 * q) + 151 * v * v * v / 96 * Math.sin(6 * q), E = h / Math.sqrt(1 - s * Math.sin(H) * Math.sin(H)), T = Math.tan(H) * Math.tan(H), S = m * Math.cos(H) * Math.cos(H), A = h * (1 - s) / Math.pow(1 - s * Math.sin(H) * Math.sin(H), 1.5), L = ne / (E * l);
  var he = H - E * Math.tan(H) / A * (L * L / 2 - (5 + 3 * T + 10 * S - 4 * S * S - 9 * m) * L * L * L * L / 24 + (61 + 90 * T + 298 * S + 45 * T * T - 252 * m - 3 * S * S) * L * L * L * L * L * L / 720);
  he = jw(he);
  var Te = (L - (1 + 2 * T + S) * L * L * L / 6 + (5 - 2 * S + 28 * T - 3 * S * S + 8 * m + 24 * T * T) * L * L * L * L * L / 120) / Math.cos(H);
  Te = j + jw(Te);
  var ve;
  if (t.accuracy) {
    var Oe = Ex({
      northing: t.northing + t.accuracy,
      easting: t.easting + t.accuracy,
      zoneLetter: t.zoneLetter,
      zoneNumber: t.zoneNumber
    });
    ve = {
      top: Oe.lat,
      right: Oe.lon,
      bottom: he,
      left: Te
    };
  } else
    ve = {
      lat: he,
      lon: Te
    };
  return ve;
}
function Zk(t) {
  var e = "Z";
  return 84 >= t && t >= 72 ? e = "X" : 72 > t && t >= 64 ? e = "W" : 64 > t && t >= 56 ? e = "V" : 56 > t && t >= 48 ? e = "U" : 48 > t && t >= 40 ? e = "T" : 40 > t && t >= 32 ? e = "S" : 32 > t && t >= 24 ? e = "R" : 24 > t && t >= 16 ? e = "Q" : 16 > t && t >= 8 ? e = "P" : 8 > t && t >= 0 ? e = "N" : 0 > t && t >= -8 ? e = "M" : -8 > t && t >= -16 ? e = "L" : -16 > t && t >= -24 ? e = "K" : -24 > t && t >= -32 ? e = "J" : -32 > t && t >= -40 ? e = "H" : -40 > t && t >= -48 ? e = "G" : -48 > t && t >= -56 ? e = "F" : -56 > t && t >= -64 ? e = "E" : -64 > t && t >= -72 ? e = "D" : -72 > t && t >= -80 && (e = "C"), e;
}
function Hk(t, e) {
  var r = "00000" + t.easting, n = "00000" + t.northing;
  return t.zoneNumber + t.zoneLetter + Kk(t.easting, t.northing, t.zoneNumber) + r.substr(r.length - 5, e) + n.substr(n.length - 5, e);
}
function Kk(t, e, r) {
  var n = w2(r), i = Math.floor(t / 1e5), l = Math.floor(e / 1e5) % 20;
  return Yk(i, l, n);
}
function w2(t) {
  var e = t % Vw;
  return e === 0 && (e = Vw), e;
}
function Yk(t, e, r) {
  var n = r - 1, i = _2.charCodeAt(n), l = v2.charCodeAt(n), h = i + t - 1, s = l + e, m = !1;
  h > nd && (h = h - nd + gh - 1, m = !0), (h === wo || i < wo && h > wo || (h > wo || i < wo) && m) && h++, (h === ea || i < ea && h > ea || (h > ea || i < ea) && m) && (h++, h === wo && h++), h > nd && (h = h - nd + gh - 1), s > rd ? (s = s - rd + gh - 1, m = !0) : m = !1, (s === wo || l < wo && s > wo || (s > wo || l < wo) && m) && s++, (s === ea || l < ea && s > ea || (s > ea || l < ea) && m) && (s++, s === wo && s++), s > rd && (s = s - rd + gh - 1);
  var v = String.fromCharCode(h) + String.fromCharCode(s);
  return v;
}
function E2(t) {
  if (t && t.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var e = t.length, r = null, n = "", i, l = 0; !/[A-Z]/.test(i = t.charAt(l)); ) {
    if (l >= 2)
      throw "MGRSPoint bad conversion from: " + t;
    n += i, l++;
  }
  var h = parseInt(n, 10);
  if (l === 0 || l + 3 > e)
    throw "MGRSPoint bad conversion from: " + t;
  var s = t.charAt(l++);
  if (s <= "A" || s === "B" || s === "Y" || s >= "Z" || s === "I" || s === "O")
    throw "MGRSPoint zone letter " + s + " not handled: " + t;
  r = t.substring(l, l += 2);
  for (var m = w2(h), v = Jk(r.charAt(0), m), E = Qk(r.charAt(1), m); E < eN(s); )
    E += 2e6;
  var T = e - l;
  if (T % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + t;
  var S = T / 2, A = 0, L = 0, B, j, q, H, ne;
  return S > 0 && (B = 1e5 / Math.pow(10, S), j = t.substring(l, l + S), A = parseFloat(j) * B, q = t.substring(l + S), L = parseFloat(q) * B), H = A + v, ne = L + E, {
    easting: H,
    northing: ne,
    zoneLetter: s,
    zoneNumber: h,
    accuracy: B
  };
}
function Jk(t, e) {
  for (var r = _2.charCodeAt(e - 1), n = 1e5, i = !1; r !== t.charCodeAt(0); ) {
    if (r++, r === wo && r++, r === ea && r++, r > nd) {
      if (i)
        throw "Bad character: " + t;
      r = gh, i = !0;
    }
    n += 1e5;
  }
  return n;
}
function Qk(t, e) {
  if (t > "V")
    throw "MGRSPoint given invalid Northing " + t;
  for (var r = v2.charCodeAt(e - 1), n = 0, i = !1; r !== t.charCodeAt(0); ) {
    if (r++, r === wo && r++, r === ea && r++, r > rd) {
      if (i)
        throw "Bad character: " + t;
      r = gh, i = !0;
    }
    n += 1e5;
  }
  return n;
}
function eN(t) {
  var e;
  switch (t) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0)
    return e;
  throw "Invalid zone letter: " + t;
}
function Nh(t, e, r) {
  if (!(this instanceof Nh))
    return new Nh(t, e, r);
  if (Array.isArray(t))
    this.x = t[0], this.y = t[1], this.z = t[2] || 0;
  else if (typeof t == "object")
    this.x = t.x, this.y = t.y, this.z = t.z || 0;
  else if (typeof t == "string" && typeof e > "u") {
    var n = t.split(",");
    this.x = parseFloat(n[0], 10), this.y = parseFloat(n[1], 10), this.z = parseFloat(n[2], 10) || 0;
  } else
    this.x = t, this.y = e, this.z = r || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Nh.fromMGRS = function(t) {
  return new Nh(b2(t));
};
Nh.prototype.toMGRS = function(t) {
  return x2([this.x, this.y], t);
};
var tN = 1, rN = 0.25, Gw = 0.046875, qw = 0.01953125, Ww = 0.01068115234375, nN = 0.75, iN = 0.46875, oN = 0.013020833333333334, aN = 0.007120768229166667, sN = 0.3645833333333333, lN = 0.005696614583333333, cN = 0.3076171875;
function T2(t) {
  var e = [];
  e[0] = tN - t * (rN + t * (Gw + t * (qw + t * Ww))), e[1] = t * (nN - t * (Gw + t * (qw + t * Ww)));
  var r = t * t;
  return e[2] = r * (iN - t * (oN + t * aN)), r *= t, e[3] = r * (sN - t * lN), e[4] = r * t * cN, e;
}
function zy(t, e, r, n) {
  return r *= e, e *= e, n[0] * t - r * (n[1] + e * (n[2] + e * (n[3] + e * n[4])));
}
var uN = 20;
function S2(t, e, r) {
  for (var n = 1 / (1 - e), i = t, l = uN; l; --l) {
    var h = Math.sin(i), s = 1 - e * h * h;
    if (s = (zy(i, h, Math.cos(i), r) - t) * (s * Math.sqrt(s)) * n, i -= s, Math.abs(s) < It)
      return i;
  }
  return i;
}
function hN() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = T2(this.es), this.ml0 = zy(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function fN(t) {
  var e = t.x, r = t.y, n = Ft(e - this.long0), i, l, h, s = Math.sin(r), m = Math.cos(r);
  if (this.es) {
    var E = m * n, T = Math.pow(E, 2), S = this.ep2 * Math.pow(m, 2), A = Math.pow(S, 2), L = Math.abs(m) > It ? Math.tan(r) : 0, B = Math.pow(L, 2), j = Math.pow(B, 2);
    i = 1 - this.es * Math.pow(s, 2), E = E / Math.sqrt(i);
    var q = zy(r, s, m, this.en);
    l = this.a * (this.k0 * E * (1 + T / 6 * (1 - B + S + T / 20 * (5 - 18 * B + j + 14 * S - 58 * B * S + T / 42 * (61 + 179 * j - j * B - 479 * B))))) + this.x0, h = this.a * (this.k0 * (q - this.ml0 + s * n * E / 2 * (1 + T / 12 * (5 - B + 9 * S + 4 * A + T / 30 * (61 + j - 58 * B + 270 * S - 330 * B * S + T / 56 * (1385 + 543 * j - j * B - 3111 * B)))))) + this.y0;
  } else {
    var v = m * Math.sin(n);
    if (Math.abs(Math.abs(v) - 1) < It)
      return 93;
    if (l = 0.5 * this.a * this.k0 * Math.log((1 + v) / (1 - v)) + this.x0, h = m * Math.cos(n) / Math.sqrt(1 - Math.pow(v, 2)), v = Math.abs(h), v >= 1) {
      if (v - 1 > It)
        return 93;
      h = 0;
    } else
      h = Math.acos(h);
    r < 0 && (h = -h), h = this.a * this.k0 * (h - this.lat0) + this.y0;
  }
  return t.x = l, t.y = h, t;
}
function dN(t) {
  var e, r, n, i, l = (t.x - this.x0) * (1 / this.a), h = (t.y - this.y0) * (1 / this.a);
  if (this.es)
    if (e = this.ml0 + h / this.k0, r = S2(e, this.es, this.en), Math.abs(r) < ct) {
      var T = Math.sin(r), S = Math.cos(r), A = Math.abs(S) > It ? Math.tan(r) : 0, L = this.ep2 * Math.pow(S, 2), B = Math.pow(L, 2), j = Math.pow(A, 2), q = Math.pow(j, 2);
      e = 1 - this.es * Math.pow(T, 2);
      var H = l * Math.sqrt(e) / this.k0, ne = Math.pow(H, 2);
      e = e * A, n = r - e * ne / (1 - this.es) * 0.5 * (1 - ne / 12 * (5 + 3 * j - 9 * L * j + L - 4 * B - ne / 30 * (61 + 90 * j - 252 * L * j + 45 * q + 46 * L - ne / 56 * (1385 + 3633 * j + 4095 * q + 1574 * q * j)))), i = Ft(this.long0 + H * (1 - ne / 6 * (1 + 2 * j + L - ne / 20 * (5 + 28 * j + 24 * q + 8 * L * j + 6 * L - ne / 42 * (61 + 662 * j + 1320 * q + 720 * q * j)))) / S);
    } else
      n = ct * Hd(h), i = 0;
  else {
    var s = Math.exp(l / this.k0), m = 0.5 * (s - 1 / s), v = this.lat0 + h / this.k0, E = Math.cos(v);
    e = Math.sqrt((1 - Math.pow(E, 2)) / (1 + Math.pow(m, 2))), n = Math.asin(e), h < 0 && (n = -n), m === 0 && E === 0 ? i = 0 : i = Ft(Math.atan2(m, E) + this.long0);
  }
  return t.x = i, t.y = n, t;
}
var pN = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const fg = {
  init: hN,
  forward: fN,
  inverse: dN,
  names: pN
};
function M2(t) {
  var e = Math.exp(t);
  return e = (e - 1 / e) / 2, e;
}
function Ma(t, e) {
  t = Math.abs(t), e = Math.abs(e);
  var r = Math.max(t, e), n = Math.min(t, e) / (r || 1);
  return r * Math.sqrt(1 + Math.pow(n, 2));
}
function mN(t) {
  var e = 1 + t, r = e - 1;
  return r === 0 ? t : t * Math.log(e) / r;
}
function gN(t) {
  var e = Math.abs(t);
  return e = mN(e * (1 + e / (Ma(1, e) + 1))), t < 0 ? -e : e;
}
function Tx(t, e) {
  for (var r = 2 * Math.cos(2 * e), n = t.length - 1, i = t[n], l = 0, h; --n >= 0; )
    h = -l + r * i + t[n], l = i, i = h;
  return e + h * Math.sin(2 * e);
}
function yN(t, e) {
  for (var r = 2 * Math.cos(e), n = t.length - 1, i = t[n], l = 0, h; --n >= 0; )
    h = -l + r * i + t[n], l = i, i = h;
  return Math.sin(e) * h;
}
function _N(t) {
  var e = Math.exp(t);
  return e = (e + 1 / e) / 2, e;
}
function C2(t, e, r) {
  for (var n = Math.sin(e), i = Math.cos(e), l = M2(r), h = _N(r), s = 2 * i * h, m = -2 * n * l, v = t.length - 1, E = t[v], T = 0, S = 0, A = 0, L, B; --v >= 0; )
    L = S, B = T, S = E, T = A, E = -L + s * S - m * T + t[v], A = -B + m * S + s * T;
  return s = n * h, m = i * l, [s * E - m * A, s * A + m * E];
}
function vN() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (fg.init.apply(this), this.forward = fg.forward, this.inverse = fg.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var t = this.es / (1 + Math.sqrt(1 - this.es)), e = t / (2 - t), r = e;
  this.cgb[0] = e * (2 + e * (-2 / 3 + e * (-2 + e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675)))))), this.cbg[0] = e * (-2 + e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725)))))), r = r * e, this.cgb[1] = r * (7 / 3 + e * (-8 / 5 + e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))))), this.cbg[1] = r * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), r = r * e, this.cgb[2] = r * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = r * (-26 / 15 + e * (34 / 21 + e * (8 / 5 + e * (-12686 / 2835)))), r = r * e, this.cgb[3] = r * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = r * (1237 / 630 + e * (-12 / 5 + e * (-24832 / 14175))), r = r * e, this.cgb[4] = r * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = r * (-734 / 315 + e * (109598 / 31185)), r = r * e, this.cgb[5] = r * (601676 / 22275), this.cbg[5] = r * (444337 / 155925), r = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + r * (1 / 4 + r * (1 / 64 + r / 256))), this.utg[0] = e * (-0.5 + e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800)))))), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = r * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = r * (13 / 48 + e * (-3 / 5 + e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))))), r = r * e, this.utg[2] = r * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = r * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), r = r * e, this.utg[3] = r * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = r * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), r = r * e, this.utg[4] = r * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = r * (34729 / 80640 + e * (-3418889 / 1995840)), r = r * e, this.utg[5] = r * (-20648693 / 638668800), this.gtu[5] = r * (212378941 / 319334400);
  var n = Tx(this.cbg, this.lat0);
  this.Zb = -this.Qn * (n + yN(this.gtu, 2 * n));
}
function xN(t) {
  var e = Ft(t.x - this.long0), r = t.y;
  r = Tx(this.cbg, r);
  var n = Math.sin(r), i = Math.cos(r), l = Math.sin(e), h = Math.cos(e);
  r = Math.atan2(n, h * i), e = Math.atan2(l * i, Ma(n, i * h)), e = gN(Math.tan(e));
  var s = C2(this.gtu, 2 * r, 2 * e);
  r = r + s[0], e = e + s[1];
  var m, v;
  return Math.abs(e) <= 2.623395162778 ? (m = this.a * (this.Qn * e) + this.x0, v = this.a * (this.Qn * r + this.Zb) + this.y0) : (m = 1 / 0, v = 1 / 0), t.x = m, t.y = v, t;
}
function bN(t) {
  var e = (t.x - this.x0) * (1 / this.a), r = (t.y - this.y0) * (1 / this.a);
  r = (r - this.Zb) / this.Qn, e = e / this.Qn;
  var n, i;
  if (Math.abs(e) <= 2.623395162778) {
    var l = C2(this.utg, 2 * r, 2 * e);
    r = r + l[0], e = e + l[1], e = Math.atan(M2(e));
    var h = Math.sin(r), s = Math.cos(r), m = Math.sin(e), v = Math.cos(e);
    r = Math.atan2(h * v, Ma(m, v * s)), e = Math.atan2(m, v * s), n = Ft(e + this.long0), i = Tx(this.cgb, r);
  } else
    n = 1 / 0, i = 1 / 0;
  return t.x = n, t.y = i, t;
}
var wN = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
const dg = {
  init: vN,
  forward: xN,
  inverse: bN,
  names: wN
};
function EN(t, e) {
  if (t === void 0) {
    if (t = Math.floor((Ft(e) + Math.PI) * 30 / Math.PI) + 1, t < 0)
      return 0;
    if (t > 60)
      return 60;
  }
  return t;
}
var TN = "etmerc";
function SN() {
  var t = EN(this.zone, this.long0);
  if (t === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(t) - 183) * Fi, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, dg.init.apply(this), this.forward = dg.forward, this.inverse = dg.inverse;
}
var MN = ["Universal Transverse Mercator System", "utm"];
const CN = {
  init: SN,
  names: MN,
  dependsOn: TN
};
function Sx(t, e) {
  return Math.pow((1 - t) / (1 + t), e);
}
var IN = 20;
function PN() {
  var t = Math.sin(this.lat0), e = Math.cos(this.lat0);
  e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(t / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + Jr) / (Math.pow(Math.tan(0.5 * this.lat0 + Jr), this.C) * Sx(this.e * t, this.ratexp));
}
function AN(t) {
  var e = t.x, r = t.y;
  return t.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * r + Jr), this.C) * Sx(this.e * Math.sin(r), this.ratexp)) - ct, t.x = this.C * e, t;
}
function ON(t) {
  for (var e = 1e-14, r = t.x / this.C, n = t.y, i = Math.pow(Math.tan(0.5 * n + Jr) / this.K, 1 / this.C), l = IN; l > 0 && (n = 2 * Math.atan(i * Sx(this.e * Math.sin(t.y), -0.5 * this.e)) - ct, !(Math.abs(n - t.y) < e)); --l)
    t.y = n;
  return l ? (t.x = r, t.y = n, t) : null;
}
var RN = ["gauss"];
const Mx = {
  init: PN,
  forward: AN,
  inverse: ON,
  names: RN
};
function LN() {
  Mx.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function DN(t) {
  var e, r, n, i;
  return t.x = Ft(t.x - this.long0), Mx.forward.apply(this, [t]), e = Math.sin(t.y), r = Math.cos(t.y), n = Math.cos(t.x), i = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * r * n), t.x = i * r * Math.sin(t.x), t.y = i * (this.cosc0 * e - this.sinc0 * r * n), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
}
function kN(t) {
  var e, r, n, i, l;
  if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, l = Math.sqrt(t.x * t.x + t.y * t.y)) {
    var h = 2 * Math.atan2(l, this.R2);
    e = Math.sin(h), r = Math.cos(h), i = Math.asin(r * this.sinc0 + t.y * e * this.cosc0 / l), n = Math.atan2(t.x * e, l * this.cosc0 * r - t.y * this.sinc0 * e);
  } else
    i = this.phic0, n = 0;
  return t.x = n, t.y = i, Mx.inverse.apply(this, [t]), t.x = Ft(t.x + this.long0), t;
}
var NN = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const FN = {
  init: LN,
  forward: DN,
  inverse: kN,
  names: NN
};
function zN(t, e, r) {
  return e *= r, Math.tan(0.5 * (ct + t)) * Math.pow((1 - e) / (1 + e), 0.5 * r);
}
function BN() {
  this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= It && (this.k0 = 0.5 * (1 + Hd(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= It && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= It && (this.k0 = 0.5 * this.cons * ls(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Oa(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = ls(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - ct, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function UN(t) {
  var e = t.x, r = t.y, n = Math.sin(r), i = Math.cos(r), l, h, s, m, v, E, T = Ft(e - this.long0);
  return Math.abs(Math.abs(e - this.long0) - Math.PI) <= It && Math.abs(r + this.lat0) <= It ? (t.x = NaN, t.y = NaN, t) : this.sphere ? (l = 2 * this.k0 / (1 + this.sinlat0 * n + this.coslat0 * i * Math.cos(T)), t.x = this.a * l * i * Math.sin(T) + this.x0, t.y = this.a * l * (this.coslat0 * n - this.sinlat0 * i * Math.cos(T)) + this.y0, t) : (h = 2 * Math.atan(this.ssfn_(r, n, this.e)) - ct, m = Math.cos(h), s = Math.sin(h), Math.abs(this.coslat0) <= It ? (v = Oa(this.e, r * this.con, this.con * n), E = 2 * this.a * this.k0 * v / this.cons, t.x = this.x0 + E * Math.sin(e - this.long0), t.y = this.y0 - this.con * E * Math.cos(e - this.long0), t) : (Math.abs(this.sinlat0) < It ? (l = 2 * this.a * this.k0 / (1 + m * Math.cos(T)), t.y = l * s) : (l = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * s + this.cosX0 * m * Math.cos(T))), t.y = l * (this.cosX0 * s - this.sinX0 * m * Math.cos(T)) + this.y0), t.x = l * m * Math.sin(T) + this.x0, t));
}
function $N(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, r, n, i, l, h = Math.sqrt(t.x * t.x + t.y * t.y);
  if (this.sphere) {
    var s = 2 * Math.atan(h / (2 * this.a * this.k0));
    return e = this.long0, r = this.lat0, h <= It ? (t.x = e, t.y = r, t) : (r = Math.asin(Math.cos(s) * this.sinlat0 + t.y * Math.sin(s) * this.coslat0 / h), Math.abs(this.coslat0) < It ? this.lat0 > 0 ? e = Ft(this.long0 + Math.atan2(t.x, -1 * t.y)) : e = Ft(this.long0 + Math.atan2(t.x, t.y)) : e = Ft(this.long0 + Math.atan2(t.x * Math.sin(s), h * this.coslat0 * Math.cos(s) - t.y * this.sinlat0 * Math.sin(s))), t.x = e, t.y = r, t);
  } else if (Math.abs(this.coslat0) <= It) {
    if (h <= It)
      return r = this.lat0, e = this.long0, t.x = e, t.y = r, t;
    t.x *= this.con, t.y *= this.con, n = h * this.cons / (2 * this.a * this.k0), r = this.con * kd(this.e, n), e = this.con * Ft(this.con * this.long0 + Math.atan2(t.x, -1 * t.y));
  } else
    i = 2 * Math.atan(h * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, h <= It ? l = this.X0 : (l = Math.asin(Math.cos(i) * this.sinX0 + t.y * Math.sin(i) * this.cosX0 / h), e = Ft(this.long0 + Math.atan2(t.x * Math.sin(i), h * this.cosX0 * Math.cos(i) - t.y * this.sinX0 * Math.sin(i)))), r = -1 * kd(this.e, Math.tan(0.5 * (ct + l)));
  return t.x = e, t.y = r, t;
}
var VN = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
const jN = {
  init: BN,
  forward: UN,
  inverse: $N,
  names: VN,
  ssfn_: zN
};
function GN() {
  var t = this.lat0;
  this.lambda0 = this.long0;
  var e = Math.sin(t), r = this.a, n = this.rf, i = 1 / n, l = 2 * i - Math.pow(i, 2), h = this.e = Math.sqrt(l);
  this.R = this.k0 * r * Math.sqrt(1 - l) / (1 - l * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + l / (1 - l) * Math.pow(Math.cos(t), 4)), this.b0 = Math.asin(e / this.alpha);
  var s = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), m = Math.log(Math.tan(Math.PI / 4 + t / 2)), v = Math.log((1 + h * e) / (1 - h * e));
  this.K = s - this.alpha * m + this.alpha * h / 2 * v;
}
function qN(t) {
  var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)), r = this.e / 2 * Math.log((1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))), n = -this.alpha * (e + r) + this.K, i = 2 * (Math.atan(Math.exp(n)) - Math.PI / 4), l = this.alpha * (t.x - this.lambda0), h = Math.atan(Math.sin(l) / (Math.sin(this.b0) * Math.tan(i) + Math.cos(this.b0) * Math.cos(l))), s = Math.asin(Math.cos(this.b0) * Math.sin(i) - Math.sin(this.b0) * Math.cos(i) * Math.cos(l));
  return t.y = this.R / 2 * Math.log((1 + Math.sin(s)) / (1 - Math.sin(s))) + this.y0, t.x = this.R * h + this.x0, t;
}
function WN(t) {
  for (var e = t.x - this.x0, r = t.y - this.y0, n = e / this.R, i = 2 * (Math.atan(Math.exp(r / this.R)) - Math.PI / 4), l = Math.asin(Math.cos(this.b0) * Math.sin(i) + Math.sin(this.b0) * Math.cos(i) * Math.cos(n)), h = Math.atan(Math.sin(n) / (Math.cos(this.b0) * Math.cos(n) - Math.sin(this.b0) * Math.tan(i))), s = this.lambda0 + h / this.alpha, m = 0, v = l, E = -1e3, T = 0; Math.abs(v - E) > 1e-7; ) {
    if (++T > 20)
      return;
    m = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + l / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(v)) / 2)), E = v, v = 2 * Math.atan(Math.exp(m)) - Math.PI / 2;
  }
  return t.x = s, t.y = v, t;
}
var XN = ["somerc"];
const ZN = {
  init: GN,
  forward: qN,
  inverse: WN,
  names: XN
};
var oh = 1e-7;
function HN(t) {
  var e = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], r = typeof t.PROJECTION == "object" ? Object.keys(t.PROJECTION)[0] : t.PROJECTION;
  return "no_uoff" in t || "no_off" in t || e.indexOf(r) !== -1;
}
function KN() {
  var t, e, r, n, i, l, h, s, m, v, E = 0, T, S = 0, A = 0, L = 0, B = 0, j = 0, q = 0;
  this.no_off = HN(this), this.no_rot = "no_rot" in this;
  var H = !1;
  "alpha" in this && (H = !0);
  var ne = !1;
  if ("rectified_grid_angle" in this && (ne = !0), H && (q = this.alpha), ne && (E = this.rectified_grid_angle * Fi), H || ne)
    S = this.longc;
  else if (A = this.long1, B = this.lat1, L = this.long2, j = this.lat2, Math.abs(B - j) <= oh || (t = Math.abs(B)) <= oh || Math.abs(t - ct) <= oh || Math.abs(Math.abs(this.lat0) - ct) <= oh || Math.abs(Math.abs(j) - ct) <= oh)
    throw new Error();
  var ee = 1 - this.es;
  e = Math.sqrt(ee), Math.abs(this.lat0) > It ? (s = Math.sin(this.lat0), r = Math.cos(this.lat0), t = 1 - this.es * s * s, this.B = r * r, this.B = Math.sqrt(1 + this.es * this.B * this.B / ee), this.A = this.B * this.k0 * e / t, n = this.B * e / (r * Math.sqrt(t)), i = n * n - 1, i <= 0 ? i = 0 : (i = Math.sqrt(i), this.lat0 < 0 && (i = -i)), this.E = i += n, this.E *= Math.pow(Oa(this.e, this.lat0, s), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = n = i = 1), H || ne ? (H ? (T = Math.asin(Math.sin(q) / n), ne || (E = q)) : (T = E, q = Math.asin(n * Math.sin(T))), this.lam0 = S - Math.asin(0.5 * (i - 1 / i) * Math.tan(T)) / this.B) : (l = Math.pow(Oa(this.e, B, Math.sin(B)), this.B), h = Math.pow(Oa(this.e, j, Math.sin(j)), this.B), i = this.E / l, m = (h - l) / (h + l), v = this.E * this.E, v = (v - h * l) / (v + h * l), t = A - L, t < -Math.pi ? L -= Ld : t > Math.pi && (L += Ld), this.lam0 = Ft(0.5 * (A + L) - Math.atan(v * Math.tan(0.5 * this.B * (A - L)) / m) / this.B), T = Math.atan(2 * Math.sin(this.B * Ft(A - this.lam0)) / (i - 1 / i)), E = q = Math.asin(n * Math.sin(T))), this.singam = Math.sin(T), this.cosgam = Math.cos(T), this.sinrot = Math.sin(E), this.cosrot = Math.cos(E), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(n * n - 1) / Math.cos(q))), this.lat0 < 0 && (this.u_0 = -this.u_0)), i = 0.5 * T, this.v_pole_n = this.ArB * Math.log(Math.tan(Jr - i)), this.v_pole_s = this.ArB * Math.log(Math.tan(Jr + i));
}
function YN(t) {
  var e = {}, r, n, i, l, h, s, m, v;
  if (t.x = t.x - this.lam0, Math.abs(Math.abs(t.y) - ct) > It) {
    if (h = this.E / Math.pow(Oa(this.e, t.y, Math.sin(t.y)), this.B), s = 1 / h, r = 0.5 * (h - s), n = 0.5 * (h + s), l = Math.sin(this.B * t.x), i = (r * this.singam - l * this.cosgam) / n, Math.abs(Math.abs(i) - 1) < It)
      throw new Error();
    v = 0.5 * this.ArB * Math.log((1 - i) / (1 + i)), s = Math.cos(this.B * t.x), Math.abs(s) < oh ? m = this.A * t.x : m = this.ArB * Math.atan2(r * this.cosgam + l * this.singam, s);
  } else
    v = t.y > 0 ? this.v_pole_n : this.v_pole_s, m = this.ArB * t.y;
  return this.no_rot ? (e.x = m, e.y = v) : (m -= this.u_0, e.x = v * this.cosrot + m * this.sinrot, e.y = m * this.cosrot - v * this.sinrot), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function JN(t) {
  var e, r, n, i, l, h, s, m = {};
  if (t.x = (t.x - this.x0) * (1 / this.a), t.y = (t.y - this.y0) * (1 / this.a), this.no_rot ? (r = t.y, e = t.x) : (r = t.x * this.cosrot - t.y * this.sinrot, e = t.y * this.cosrot + t.x * this.sinrot + this.u_0), n = Math.exp(-this.BrA * r), i = 0.5 * (n - 1 / n), l = 0.5 * (n + 1 / n), h = Math.sin(this.BrA * e), s = (h * this.cosgam + i * this.singam) / l, Math.abs(Math.abs(s) - 1) < It)
    m.x = 0, m.y = s < 0 ? -ct : ct;
  else {
    if (m.y = this.E / Math.sqrt((1 + s) / (1 - s)), m.y = kd(this.e, Math.pow(m.y, 1 / this.B)), m.y === 1 / 0)
      throw new Error();
    m.x = -this.rB * Math.atan2(i * this.cosgam - h * this.singam, Math.cos(this.BrA * e));
  }
  return m.x += this.lam0, m;
}
var QN = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const e3 = {
  init: KN,
  forward: YN,
  inverse: JN,
  names: QN
};
function t3() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < It)) {
    var t = this.b / this.a;
    this.e = Math.sqrt(1 - t * t);
    var e = Math.sin(this.lat1), r = Math.cos(this.lat1), n = ls(this.e, e, r), i = Oa(this.e, this.lat1, e), l = Math.sin(this.lat2), h = Math.cos(this.lat2), s = ls(this.e, l, h), m = Oa(this.e, this.lat2, l), v = Oa(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > It ? this.ns = Math.log(n / s) / Math.log(i / m) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = n / (this.ns * Math.pow(i, this.ns)), this.rh = this.a * this.f0 * Math.pow(v, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function r3(t) {
  var e = t.x, r = t.y;
  Math.abs(2 * Math.abs(r) - Math.PI) <= It && (r = Hd(r) * (ct - 2 * It));
  var n = Math.abs(Math.abs(r) - ct), i, l;
  if (n > It)
    i = Oa(this.e, r, Math.sin(r)), l = this.a * this.f0 * Math.pow(i, this.ns);
  else {
    if (n = r * this.ns, n <= 0)
      return null;
    l = 0;
  }
  var h = this.ns * Ft(e - this.long0);
  return t.x = this.k0 * (l * Math.sin(h)) + this.x0, t.y = this.k0 * (this.rh - l * Math.cos(h)) + this.y0, t;
}
function n3(t) {
  var e, r, n, i, l, h = (t.x - this.x0) / this.k0, s = this.rh - (t.y - this.y0) / this.k0;
  this.ns > 0 ? (e = Math.sqrt(h * h + s * s), r = 1) : (e = -Math.sqrt(h * h + s * s), r = -1);
  var m = 0;
  if (e !== 0 && (m = Math.atan2(r * h, r * s)), e !== 0 || this.ns > 0) {
    if (r = 1 / this.ns, n = Math.pow(e / (this.a * this.f0), r), i = kd(this.e, n), i === -9999)
      return null;
  } else
    i = -ct;
  return l = Ft(m / this.ns + this.long0), t.x = l, t.y = i, t;
}
var i3 = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const o3 = {
  init: t3,
  forward: r3,
  inverse: n3,
  names: i3
};
function a3() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function s3(t) {
  var e, r, n, i, l, h, s, m = t.x, v = t.y, E = Ft(m - this.long0);
  return e = Math.pow((1 + this.e * Math.sin(v)) / (1 - this.e * Math.sin(v)), this.alfa * this.e / 2), r = 2 * (Math.atan(this.k * Math.pow(Math.tan(v / 2 + this.s45), this.alfa) / e) - this.s45), n = -E * this.alfa, i = Math.asin(Math.cos(this.ad) * Math.sin(r) + Math.sin(this.ad) * Math.cos(r) * Math.cos(n)), l = Math.asin(Math.cos(r) * Math.sin(n) / Math.cos(i)), h = this.n * l, s = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(i / 2 + this.s45), this.n), t.y = s * Math.cos(h) / 1, t.x = s * Math.sin(h) / 1, this.czech || (t.y *= -1, t.x *= -1), t;
}
function l3(t) {
  var e, r, n, i, l, h, s, m, v = t.x;
  t.x = t.y, t.y = v, this.czech || (t.y *= -1, t.x *= -1), h = Math.sqrt(t.x * t.x + t.y * t.y), l = Math.atan2(t.y, t.x), i = l / Math.sin(this.s0), n = 2 * (Math.atan(Math.pow(this.ro0 / h, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(n) - Math.sin(this.ad) * Math.cos(n) * Math.cos(i)), r = Math.asin(Math.cos(n) * Math.sin(i) / Math.cos(e)), t.x = this.long0 - r / this.alfa, s = e, m = 0;
  var E = 0;
  do
    t.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(s)) / (1 - this.e * Math.sin(s)), this.e / 2)) - this.s45), Math.abs(s - t.y) < 1e-10 && (m = 1), s = t.y, E += 1;
  while (m === 0 && E < 15);
  return E >= 15 ? null : t;
}
var c3 = ["Krovak", "krovak"];
const u3 = {
  init: a3,
  forward: s3,
  inverse: l3,
  names: c3
};
function po(t, e, r, n, i) {
  return t * i - e * Math.sin(2 * i) + r * Math.sin(4 * i) - n * Math.sin(6 * i);
}
function Kd(t) {
  return 1 - 0.25 * t * (1 + t / 16 * (3 + 1.25 * t));
}
function Yd(t) {
  return 0.375 * t * (1 + 0.25 * t * (1 + 0.46875 * t));
}
function Jd(t) {
  return 0.05859375 * t * t * (1 + 0.75 * t);
}
function Qd(t) {
  return t * t * t * (35 / 3072);
}
function Fh(t, e, r) {
  var n = e * r;
  return t / Math.sqrt(1 - n * n);
}
function Vh(t) {
  return Math.abs(t) < ct ? t : t - Hd(t) * Math.PI;
}
function zg(t, e, r, n, i) {
  var l, h;
  l = t / e;
  for (var s = 0; s < 15; s++)
    if (h = (t - (e * l - r * Math.sin(2 * l) + n * Math.sin(4 * l) - i * Math.sin(6 * l))) / (e - 2 * r * Math.cos(2 * l) + 4 * n * Math.cos(4 * l) - 6 * i * Math.cos(6 * l)), l += h, Math.abs(h) <= 1e-10)
      return l;
  return NaN;
}
function h3() {
  this.sphere || (this.e0 = Kd(this.es), this.e1 = Yd(this.es), this.e2 = Jd(this.es), this.e3 = Qd(this.es), this.ml0 = this.a * po(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function f3(t) {
  var e, r, n = t.x, i = t.y;
  if (n = Ft(n - this.long0), this.sphere)
    e = this.a * Math.asin(Math.cos(i) * Math.sin(n)), r = this.a * (Math.atan2(Math.tan(i), Math.cos(n)) - this.lat0);
  else {
    var l = Math.sin(i), h = Math.cos(i), s = Fh(this.a, this.e, l), m = Math.tan(i) * Math.tan(i), v = n * Math.cos(i), E = v * v, T = this.es * h * h / (1 - this.es), S = this.a * po(this.e0, this.e1, this.e2, this.e3, i);
    e = s * v * (1 - E * m * (1 / 6 - (8 - m + 8 * T) * E / 120)), r = S - this.ml0 + s * l / h * E * (0.5 + (5 - m + 6 * T) * E / 24);
  }
  return t.x = e + this.x0, t.y = r + this.y0, t;
}
function d3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = t.x / this.a, r = t.y / this.a, n, i;
  if (this.sphere) {
    var l = r + this.lat0;
    n = Math.asin(Math.sin(l) * Math.cos(e)), i = Math.atan2(Math.tan(e), Math.cos(l));
  } else {
    var h = this.ml0 / this.a + r, s = zg(h, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(s) - ct) <= It)
      return t.x = this.long0, t.y = ct, r < 0 && (t.y *= -1), t;
    var m = Fh(this.a, this.e, Math.sin(s)), v = m * m * m / this.a / this.a * (1 - this.es), E = Math.pow(Math.tan(s), 2), T = e * this.a / m, S = T * T;
    n = s - m * Math.tan(s) / v * T * T * (0.5 - (1 + 3 * E) * T * T / 24), i = T * (1 - S * (E / 3 + (1 + 3 * E) * E * S / 15)) / Math.cos(s);
  }
  return t.x = Ft(i + this.long0), t.y = Vh(n), t;
}
var p3 = ["Cassini", "Cassini_Soldner", "cass"];
const m3 = {
  init: h3,
  forward: f3,
  inverse: d3,
  names: p3
};
function zl(t, e) {
  var r;
  return t > 1e-7 ? (r = t * e, (1 - t * t) * (e / (1 - r * r) - 0.5 / t * Math.log((1 - r) / (1 + r)))) : 2 * e;
}
var g3 = 1, y3 = 2, _3 = 3, v3 = 4;
function x3() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - ct) < It ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(t) < It ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
    var e;
    switch (this.qp = zl(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = P3(this.es), this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = zl(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function b3(t) {
  var e, r, n, i, l, h, s, m, v, E, T = t.x, S = t.y;
  if (T = Ft(T - this.long0), this.sphere) {
    if (l = Math.sin(S), E = Math.cos(S), n = Math.cos(T), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (r = this.mode === this.EQUIT ? 1 + E * n : 1 + this.sinph0 * l + this.cosph0 * E * n, r <= It)
        return null;
      r = Math.sqrt(2 / r), e = r * E * Math.sin(T), r *= this.mode === this.EQUIT ? l : this.cosph0 * l - this.sinph0 * E * n;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), Math.abs(S + this.lat0) < It)
        return null;
      r = Jr - S * 0.5, r = 2 * (this.mode === this.S_POLE ? Math.cos(r) : Math.sin(r)), e = r * Math.sin(T), r *= n;
    }
  } else {
    switch (s = 0, m = 0, v = 0, n = Math.cos(T), i = Math.sin(T), l = Math.sin(S), h = zl(this.e, l), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (s = h / this.qp, m = Math.sqrt(1 - s * s)), this.mode) {
      case this.OBLIQ:
        v = 1 + this.sinb1 * s + this.cosb1 * m * n;
        break;
      case this.EQUIT:
        v = 1 + m * n;
        break;
      case this.N_POLE:
        v = ct + S, h = this.qp - h;
        break;
      case this.S_POLE:
        v = S - ct, h = this.qp + h;
        break;
    }
    if (Math.abs(v) < It)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        v = Math.sqrt(2 / v), this.mode === this.OBLIQ ? r = this.ymf * v * (this.cosb1 * s - this.sinb1 * m * n) : r = (v = Math.sqrt(2 / (1 + m * n))) * s * this.ymf, e = this.xmf * v * m * i;
        break;
      case this.N_POLE:
      case this.S_POLE:
        h >= 0 ? (e = (v = Math.sqrt(h)) * i, r = n * (this.mode === this.S_POLE ? v : -v)) : e = r = 0;
        break;
    }
  }
  return t.x = this.a * e + this.x0, t.y = this.a * r + this.y0, t;
}
function w3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = t.x / this.a, r = t.y / this.a, n, i, l, h, s, m, v;
  if (this.sphere) {
    var E = 0, T, S = 0;
    if (T = Math.sqrt(e * e + r * r), i = T * 0.5, i > 1)
      return null;
    switch (i = 2 * Math.asin(i), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (S = Math.sin(i), E = Math.cos(i)), this.mode) {
      case this.EQUIT:
        i = Math.abs(T) <= It ? 0 : Math.asin(r * S / T), e *= S, r = E * T;
        break;
      case this.OBLIQ:
        i = Math.abs(T) <= It ? this.lat0 : Math.asin(E * this.sinph0 + r * S * this.cosph0 / T), e *= S * this.cosph0, r = (E - Math.sin(i) * this.sinph0) * T;
        break;
      case this.N_POLE:
        r = -r, i = ct - i;
        break;
      case this.S_POLE:
        i -= ct;
        break;
    }
    n = r === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(e, r);
  } else {
    if (v = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (e /= this.dd, r *= this.dd, m = Math.sqrt(e * e + r * r), m < It)
        return t.x = this.long0, t.y = this.lat0, t;
      h = 2 * Math.asin(0.5 * m / this.rq), l = Math.cos(h), e *= h = Math.sin(h), this.mode === this.OBLIQ ? (v = l * this.sinb1 + r * h * this.cosb1 / m, s = this.qp * v, r = m * this.cosb1 * l - r * this.sinb1 * h) : (v = r * h / m, s = this.qp * v, r = m * l);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (r = -r), s = e * e + r * r, !s)
        return t.x = this.long0, t.y = this.lat0, t;
      v = 1 - s / this.qp, this.mode === this.S_POLE && (v = -v);
    }
    n = Math.atan2(e, r), i = A3(Math.asin(v), this.apa);
  }
  return t.x = Ft(this.long0 + n), t.y = i, t;
}
var E3 = 0.3333333333333333, T3 = 0.17222222222222222, S3 = 0.10257936507936508, M3 = 0.06388888888888888, C3 = 0.0664021164021164, I3 = 0.016415012942191543;
function P3(t) {
  var e, r = [];
  return r[0] = t * E3, e = t * t, r[0] += e * T3, r[1] = e * M3, e *= t, r[0] += e * S3, r[1] += e * C3, r[2] = e * I3, r;
}
function A3(t, e) {
  var r = t + t;
  return t + e[0] * Math.sin(r) + e[1] * Math.sin(r + r) + e[2] * Math.sin(r + r + r);
}
var O3 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const R3 = {
  init: x3,
  forward: b3,
  inverse: w3,
  names: O3,
  S_POLE: g3,
  N_POLE: y3,
  EQUIT: _3,
  OBLIQ: v3
};
function ql(t) {
  return Math.abs(t) > 1 && (t = t > 1 ? 1 : -1), Math.asin(t);
}
function L3() {
  Math.abs(this.lat1 + this.lat2) < It || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = ls(this.e3, this.sin_po, this.cos_po), this.qs1 = zl(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = ls(this.e3, this.sin_po, this.cos_po), this.qs2 = zl(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = zl(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > It ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function D3(t) {
  var e = t.x, r = t.y;
  this.sin_phi = Math.sin(r), this.cos_phi = Math.cos(r);
  var n = zl(this.e3, this.sin_phi), i = this.a * Math.sqrt(this.c - this.ns0 * n) / this.ns0, l = this.ns0 * Ft(e - this.long0), h = i * Math.sin(l) + this.x0, s = this.rh - i * Math.cos(l) + this.y0;
  return t.x = h, t.y = s, t;
}
function k3(t) {
  var e, r, n, i, l, h;
  return t.x -= this.x0, t.y = this.rh - t.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(t.x * t.x + t.y * t.y), n = 1) : (e = -Math.sqrt(t.x * t.x + t.y * t.y), n = -1), i = 0, e !== 0 && (i = Math.atan2(n * t.x, n * t.y)), n = e * this.ns0 / this.a, this.sphere ? h = Math.asin((this.c - n * n) / (2 * this.ns0)) : (r = (this.c - n * n) / this.ns0, h = this.phi1z(this.e3, r)), l = Ft(i / this.ns0 + this.long0), t.x = l, t.y = h, t;
}
function N3(t, e) {
  var r, n, i, l, h, s = ql(0.5 * e);
  if (t < It)
    return s;
  for (var m = t * t, v = 1; v <= 25; v++)
    if (r = Math.sin(s), n = Math.cos(s), i = t * r, l = 1 - i * i, h = 0.5 * l * l / n * (e / (1 - m) - r / l + 0.5 / t * Math.log((1 - i) / (1 + i))), s = s + h, Math.abs(h) <= 1e-7)
      return s;
  return null;
}
var F3 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const z3 = {
  init: L3,
  forward: D3,
  inverse: k3,
  names: F3,
  phi1z: N3
};
function B3() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function U3(t) {
  var e, r, n, i, l, h, s, m, v = t.x, E = t.y;
  return n = Ft(v - this.long0), e = Math.sin(E), r = Math.cos(E), i = Math.cos(n), h = this.sin_p14 * e + this.cos_p14 * r * i, l = 1, h > 0 || Math.abs(h) <= It ? (s = this.x0 + this.a * l * r * Math.sin(n) / h, m = this.y0 + this.a * l * (this.cos_p14 * e - this.sin_p14 * r * i) / h) : (s = this.x0 + this.infinity_dist * r * Math.sin(n), m = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * r * i)), t.x = s, t.y = m, t;
}
function $3(t) {
  var e, r, n, i, l, h;
  return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, (e = Math.sqrt(t.x * t.x + t.y * t.y)) ? (i = Math.atan2(e, this.rc), r = Math.sin(i), n = Math.cos(i), h = ql(n * this.sin_p14 + t.y * r * this.cos_p14 / e), l = Math.atan2(t.x * r, e * this.cos_p14 * n - t.y * this.sin_p14 * r), l = Ft(this.long0 + l)) : (h = this.phic0, l = 0), t.x = l, t.y = h, t;
}
var V3 = ["gnom"];
const j3 = {
  init: B3,
  forward: U3,
  inverse: $3,
  names: V3
};
function G3(t, e) {
  var r = 1 - (1 - t * t) / (2 * t) * Math.log((1 - t) / (1 + t));
  if (Math.abs(Math.abs(e) - r) < 1e-6)
    return e < 0 ? -1 * ct : ct;
  for (var n = Math.asin(0.5 * e), i, l, h, s, m = 0; m < 30; m++)
    if (l = Math.sin(n), h = Math.cos(n), s = t * l, i = Math.pow(1 - s * s, 2) / (2 * h) * (e / (1 - t * t) - l / (1 - s * s) + 0.5 / t * Math.log((1 - s) / (1 + s))), n += i, Math.abs(i) <= 1e-10)
      return n;
  return NaN;
}
function q3() {
  this.sphere || (this.k0 = ls(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function W3(t) {
  var e = t.x, r = t.y, n, i, l = Ft(e - this.long0);
  if (this.sphere)
    n = this.x0 + this.a * l * Math.cos(this.lat_ts), i = this.y0 + this.a * Math.sin(r) / Math.cos(this.lat_ts);
  else {
    var h = zl(this.e, Math.sin(r));
    n = this.x0 + this.a * this.k0 * l, i = this.y0 + this.a * h * 0.5 / this.k0;
  }
  return t.x = n, t.y = i, t;
}
function X3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, r;
  return this.sphere ? (e = Ft(this.long0 + t.x / this.a / Math.cos(this.lat_ts)), r = Math.asin(t.y / this.a * Math.cos(this.lat_ts))) : (r = G3(this.e, 2 * t.y * this.k0 / this.a), e = Ft(this.long0 + t.x / (this.a * this.k0))), t.x = e, t.y = r, t;
}
var Z3 = ["cea"];
const H3 = {
  init: q3,
  forward: W3,
  inverse: X3,
  names: Z3
};
function K3() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function Y3(t) {
  var e = t.x, r = t.y, n = Ft(e - this.long0), i = Vh(r - this.lat0);
  return t.x = this.x0 + this.a * n * this.rc, t.y = this.y0 + this.a * i, t;
}
function J3(t) {
  var e = t.x, r = t.y;
  return t.x = Ft(this.long0 + (e - this.x0) / (this.a * this.rc)), t.y = Vh(this.lat0 + (r - this.y0) / this.a), t;
}
var Q3 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const eF = {
  init: K3,
  forward: Y3,
  inverse: J3,
  names: Q3
};
var Xw = 20;
function tF() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Kd(this.es), this.e1 = Yd(this.es), this.e2 = Jd(this.es), this.e3 = Qd(this.es), this.ml0 = this.a * po(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function rF(t) {
  var e = t.x, r = t.y, n, i, l, h = Ft(e - this.long0);
  if (l = h * Math.sin(r), this.sphere)
    Math.abs(r) <= It ? (n = this.a * h, i = -1 * this.a * this.lat0) : (n = this.a * Math.sin(l) / Math.tan(r), i = this.a * (Vh(r - this.lat0) + (1 - Math.cos(l)) / Math.tan(r)));
  else if (Math.abs(r) <= It)
    n = this.a * h, i = -1 * this.ml0;
  else {
    var s = Fh(this.a, this.e, Math.sin(r)) / Math.tan(r);
    n = s * Math.sin(l), i = this.a * po(this.e0, this.e1, this.e2, this.e3, r) - this.ml0 + s * (1 - Math.cos(l));
  }
  return t.x = n + this.x0, t.y = i + this.y0, t;
}
function nF(t) {
  var e, r, n, i, l, h, s, m, v;
  if (n = t.x - this.x0, i = t.y - this.y0, this.sphere)
    if (Math.abs(i + this.a * this.lat0) <= It)
      e = Ft(n / this.a + this.long0), r = 0;
    else {
      h = this.lat0 + i / this.a, s = n * n / this.a / this.a + h * h, m = h;
      var E;
      for (l = Xw; l; --l)
        if (E = Math.tan(m), v = -1 * (h * (m * E + 1) - m - 0.5 * (m * m + s) * E) / ((m - h) / E - 1), m += v, Math.abs(v) <= It) {
          r = m;
          break;
        }
      e = Ft(this.long0 + Math.asin(n * Math.tan(m) / this.a) / Math.sin(r));
    }
  else if (Math.abs(i + this.ml0) <= It)
    r = 0, e = Ft(this.long0 + n / this.a);
  else {
    h = (this.ml0 + i) / this.a, s = n * n / this.a / this.a + h * h, m = h;
    var T, S, A, L, B;
    for (l = Xw; l; --l)
      if (B = this.e * Math.sin(m), T = Math.sqrt(1 - B * B) * Math.tan(m), S = this.a * po(this.e0, this.e1, this.e2, this.e3, m), A = this.e0 - 2 * this.e1 * Math.cos(2 * m) + 4 * this.e2 * Math.cos(4 * m) - 6 * this.e3 * Math.cos(6 * m), L = S / this.a, v = (h * (T * L + 1) - L - 0.5 * T * (L * L + s)) / (this.es * Math.sin(2 * m) * (L * L + s - 2 * h * L) / (4 * T) + (h - L) * (T * A - 2 / Math.sin(2 * m)) - A), m -= v, Math.abs(v) <= It) {
        r = m;
        break;
      }
    T = Math.sqrt(1 - this.es * Math.pow(Math.sin(r), 2)) * Math.tan(r), e = Ft(this.long0 + Math.asin(n * T / this.a) / Math.sin(r));
  }
  return t.x = e, t.y = r, t;
}
var iF = ["Polyconic", "poly"];
const oF = {
  init: tF,
  forward: rF,
  inverse: nF,
  names: iF
};
function aF() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function sF(t) {
  var e, r = t.x, n = t.y, i = n - this.lat0, l = r - this.long0, h = i / md * 1e-5, s = l, m = 1, v = 0;
  for (e = 1; e <= 10; e++)
    m = m * h, v = v + this.A[e] * m;
  var E = v, T = s, S = 1, A = 0, L, B, j = 0, q = 0;
  for (e = 1; e <= 6; e++)
    L = S * E - A * T, B = A * E + S * T, S = L, A = B, j = j + this.B_re[e] * S - this.B_im[e] * A, q = q + this.B_im[e] * S + this.B_re[e] * A;
  return t.x = q * this.a + this.x0, t.y = j * this.a + this.y0, t;
}
function lF(t) {
  var e, r = t.x, n = t.y, i = r - this.x0, l = n - this.y0, h = l / this.a, s = i / this.a, m = 1, v = 0, E, T, S = 0, A = 0;
  for (e = 1; e <= 6; e++)
    E = m * h - v * s, T = v * h + m * s, m = E, v = T, S = S + this.C_re[e] * m - this.C_im[e] * v, A = A + this.C_im[e] * m + this.C_re[e] * v;
  for (var L = 0; L < this.iterations; L++) {
    var B = S, j = A, q, H, ne = h, ee = s;
    for (e = 2; e <= 6; e++)
      q = B * S - j * A, H = j * S + B * A, B = q, j = H, ne = ne + (e - 1) * (this.B_re[e] * B - this.B_im[e] * j), ee = ee + (e - 1) * (this.B_im[e] * B + this.B_re[e] * j);
    B = 1, j = 0;
    var he = this.B_re[1], Te = this.B_im[1];
    for (e = 2; e <= 6; e++)
      q = B * S - j * A, H = j * S + B * A, B = q, j = H, he = he + e * (this.B_re[e] * B - this.B_im[e] * j), Te = Te + e * (this.B_im[e] * B + this.B_re[e] * j);
    var ve = he * he + Te * Te;
    S = (ne * he + ee * Te) / ve, A = (ee * he - ne * Te) / ve;
  }
  var Oe = S, Me = A, Re = 1, He = 0;
  for (e = 1; e <= 9; e++)
    Re = Re * Oe, He = He + this.D[e] * Re;
  var Ve = this.lat0 + He * md * 1e5, dt = this.long0 + Me;
  return t.x = dt, t.y = Ve, t;
}
var cF = ["New_Zealand_Map_Grid", "nzmg"];
const uF = {
  init: aF,
  forward: sF,
  inverse: lF,
  names: cF
};
function hF() {
}
function fF(t) {
  var e = t.x, r = t.y, n = Ft(e - this.long0), i = this.x0 + this.a * n, l = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + r / 2.5)) * 1.25;
  return t.x = i, t.y = l, t;
}
function dF(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = Ft(this.long0 + t.x / this.a), r = 2.5 * (Math.atan(Math.exp(0.8 * t.y / this.a)) - Math.PI / 4);
  return t.x = e, t.y = r, t;
}
var pF = ["Miller_Cylindrical", "mill"];
const mF = {
  init: hF,
  forward: fF,
  inverse: dF,
  names: pF
};
var gF = 20;
function yF() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = T2(this.es);
}
function _F(t) {
  var e, r, n = t.x, i = t.y;
  if (n = Ft(n - this.long0), this.sphere) {
    if (!this.m)
      i = this.n !== 1 ? Math.asin(this.n * Math.sin(i)) : i;
    else
      for (var l = this.n * Math.sin(i), h = gF; h; --h) {
        var s = (this.m * i + Math.sin(i) - l) / (this.m + Math.cos(i));
        if (i -= s, Math.abs(s) < It)
          break;
      }
    e = this.a * this.C_x * n * (this.m + Math.cos(i)), r = this.a * this.C_y * i;
  } else {
    var m = Math.sin(i), v = Math.cos(i);
    r = this.a * zy(i, m, v, this.en), e = this.a * n * v / Math.sqrt(1 - this.es * m * m);
  }
  return t.x = e, t.y = r, t;
}
function vF(t) {
  var e, r, n, i;
  return t.x -= this.x0, n = t.x / this.a, t.y -= this.y0, e = t.y / this.a, this.sphere ? (e /= this.C_y, n = n / (this.C_x * (this.m + Math.cos(e))), this.m ? e = ql((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = ql(Math.sin(e) / this.n)), n = Ft(n + this.long0), e = Vh(e)) : (e = S2(t.y / this.a, this.es, this.en), i = Math.abs(e), i < ct ? (i = Math.sin(e), r = this.long0 + t.x * Math.sqrt(1 - this.es * i * i) / (this.a * Math.cos(e)), n = Ft(r)) : i - It < ct && (n = this.long0)), t.x = n, t.y = e, t;
}
var xF = ["Sinusoidal", "sinu"];
const bF = {
  init: yF,
  forward: _F,
  inverse: vF,
  names: xF
};
function wF() {
}
function EF(t) {
  for (var e = t.x, r = t.y, n = Ft(e - this.long0), i = r, l = Math.PI * Math.sin(r); ; ) {
    var h = -(i + Math.sin(i) - l) / (1 + Math.cos(i));
    if (i += h, Math.abs(h) < It)
      break;
  }
  i /= 2, Math.PI / 2 - Math.abs(r) < It && (n = 0);
  var s = 0.900316316158 * this.a * n * Math.cos(i) + this.x0, m = 1.4142135623731 * this.a * Math.sin(i) + this.y0;
  return t.x = s, t.y = m, t;
}
function TF(t) {
  var e, r;
  t.x -= this.x0, t.y -= this.y0, r = t.y / (1.4142135623731 * this.a), Math.abs(r) > 0.999999999999 && (r = 0.999999999999), e = Math.asin(r);
  var n = Ft(this.long0 + t.x / (0.900316316158 * this.a * Math.cos(e)));
  n < -Math.PI && (n = -Math.PI), n > Math.PI && (n = Math.PI), r = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(r) > 1 && (r = 1);
  var i = Math.asin(r);
  return t.x = n, t.y = i, t;
}
var SF = ["Mollweide", "moll"];
const MF = {
  init: wF,
  forward: EF,
  inverse: TF,
  names: SF
};
function CF() {
  Math.abs(this.lat1 + this.lat2) < It || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Kd(this.es), this.e1 = Yd(this.es), this.e2 = Jd(this.es), this.e3 = Qd(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = ls(this.e, this.sinphi, this.cosphi), this.ml1 = po(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < It ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = ls(this.e, this.sinphi, this.cosphi), this.ml2 = po(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = po(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function IF(t) {
  var e = t.x, r = t.y, n;
  if (this.sphere)
    n = this.a * (this.g - r);
  else {
    var i = po(this.e0, this.e1, this.e2, this.e3, r);
    n = this.a * (this.g - i);
  }
  var l = this.ns * Ft(e - this.long0), h = this.x0 + n * Math.sin(l), s = this.y0 + this.rh - n * Math.cos(l);
  return t.x = h, t.y = s, t;
}
function PF(t) {
  t.x -= this.x0, t.y = this.rh - t.y + this.y0;
  var e, r, n, i;
  this.ns >= 0 ? (r = Math.sqrt(t.x * t.x + t.y * t.y), e = 1) : (r = -Math.sqrt(t.x * t.x + t.y * t.y), e = -1);
  var l = 0;
  if (r !== 0 && (l = Math.atan2(e * t.x, e * t.y)), this.sphere)
    return i = Ft(this.long0 + l / this.ns), n = Vh(this.g - r / this.a), t.x = i, t.y = n, t;
  var h = this.g - r / this.a;
  return n = zg(h, this.e0, this.e1, this.e2, this.e3), i = Ft(this.long0 + l / this.ns), t.x = i, t.y = n, t;
}
var AF = ["Equidistant_Conic", "eqdc"];
const OF = {
  init: CF,
  forward: IF,
  inverse: PF,
  names: AF
};
function RF() {
  this.R = this.a;
}
function LF(t) {
  var e = t.x, r = t.y, n = Ft(e - this.long0), i, l;
  Math.abs(r) <= It && (i = this.x0 + this.R * n, l = this.y0);
  var h = ql(2 * Math.abs(r / Math.PI));
  (Math.abs(n) <= It || Math.abs(Math.abs(r) - ct) <= It) && (i = this.x0, r >= 0 ? l = this.y0 + Math.PI * this.R * Math.tan(0.5 * h) : l = this.y0 + Math.PI * this.R * -Math.tan(0.5 * h));
  var s = 0.5 * Math.abs(Math.PI / n - n / Math.PI), m = s * s, v = Math.sin(h), E = Math.cos(h), T = E / (v + E - 1), S = T * T, A = T * (2 / v - 1), L = A * A, B = Math.PI * this.R * (s * (T - L) + Math.sqrt(m * (T - L) * (T - L) - (L + m) * (S - L))) / (L + m);
  n < 0 && (B = -B), i = this.x0 + B;
  var j = m + T;
  return B = Math.PI * this.R * (A * j - s * Math.sqrt((L + m) * (m + 1) - j * j)) / (L + m), r >= 0 ? l = this.y0 + B : l = this.y0 - B, t.x = i, t.y = l, t;
}
function DF(t) {
  var e, r, n, i, l, h, s, m, v, E, T, S, A;
  return t.x -= this.x0, t.y -= this.y0, T = Math.PI * this.R, n = t.x / T, i = t.y / T, l = n * n + i * i, h = -Math.abs(i) * (1 + l), s = h - 2 * i * i + n * n, m = -2 * h + 1 + 2 * i * i + l * l, A = i * i / m + (2 * s * s * s / m / m / m - 9 * h * s / m / m) / 27, v = (h - s * s / 3 / m) / m, E = 2 * Math.sqrt(-v / 3), T = 3 * A / v / E, Math.abs(T) > 1 && (T >= 0 ? T = 1 : T = -1), S = Math.acos(T) / 3, t.y >= 0 ? r = (-E * Math.cos(S + Math.PI / 3) - s / 3 / m) * Math.PI : r = -(-E * Math.cos(S + Math.PI / 3) - s / 3 / m) * Math.PI, Math.abs(n) < It ? e = this.long0 : e = Ft(this.long0 + Math.PI * (l - 1 + Math.sqrt(1 + 2 * (n * n - i * i) + l * l)) / 2 / n), t.x = e, t.y = r, t;
}
var kF = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const NF = {
  init: RF,
  forward: LF,
  inverse: DF,
  names: kF
};
function FF() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}
function zF(t) {
  var e = t.x, r = t.y, n = Math.sin(t.y), i = Math.cos(t.y), l = Ft(e - this.long0), h, s, m, v, E, T, S, A, L, B, j, q, H, ne, ee, he, Te, ve, Oe, Me, Re, He, Ve;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= It ? (t.x = this.x0 + this.a * (ct - r) * Math.sin(l), t.y = this.y0 - this.a * (ct - r) * Math.cos(l), t) : Math.abs(this.sin_p12 + 1) <= It ? (t.x = this.x0 + this.a * (ct + r) * Math.sin(l), t.y = this.y0 + this.a * (ct + r) * Math.cos(l), t) : (ve = this.sin_p12 * n + this.cos_p12 * i * Math.cos(l), he = Math.acos(ve), Te = he ? he / Math.sin(he) : 1, t.x = this.x0 + this.a * Te * i * Math.sin(l), t.y = this.y0 + this.a * Te * (this.cos_p12 * n - this.sin_p12 * i * Math.cos(l)), t) : (h = Kd(this.es), s = Yd(this.es), m = Jd(this.es), v = Qd(this.es), Math.abs(this.sin_p12 - 1) <= It ? (E = this.a * po(h, s, m, v, ct), T = this.a * po(h, s, m, v, r), t.x = this.x0 + (E - T) * Math.sin(l), t.y = this.y0 - (E - T) * Math.cos(l), t) : Math.abs(this.sin_p12 + 1) <= It ? (E = this.a * po(h, s, m, v, ct), T = this.a * po(h, s, m, v, r), t.x = this.x0 + (E + T) * Math.sin(l), t.y = this.y0 + (E + T) * Math.cos(l), t) : (S = n / i, A = Fh(this.a, this.e, this.sin_p12), L = Fh(this.a, this.e, n), B = Math.atan((1 - this.es) * S + this.es * A * this.sin_p12 / (L * i)), j = Math.atan2(Math.sin(l), this.cos_p12 * Math.tan(B) - this.sin_p12 * Math.cos(l)), j === 0 ? Oe = Math.asin(this.cos_p12 * Math.sin(B) - this.sin_p12 * Math.cos(B)) : Math.abs(Math.abs(j) - Math.PI) <= It ? Oe = -Math.asin(this.cos_p12 * Math.sin(B) - this.sin_p12 * Math.cos(B)) : Oe = Math.asin(Math.sin(l) * Math.cos(B) / Math.sin(j)), q = this.e * this.sin_p12 / Math.sqrt(1 - this.es), H = this.e * this.cos_p12 * Math.cos(j) / Math.sqrt(1 - this.es), ne = q * H, ee = H * H, Me = Oe * Oe, Re = Me * Oe, He = Re * Oe, Ve = He * Oe, he = A * Oe * (1 - Me * ee * (1 - ee) / 6 + Re / 8 * ne * (1 - 2 * ee) + He / 120 * (ee * (4 - 7 * ee) - 3 * q * q * (1 - 7 * ee)) - Ve / 48 * ne), t.x = this.x0 + he * Math.sin(j), t.y = this.y0 + he * Math.cos(j), t));
}
function BF(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, r, n, i, l, h, s, m, v, E, T, S, A, L, B, j, q, H, ne, ee, he, Te, ve, Oe;
  return this.sphere ? (e = Math.sqrt(t.x * t.x + t.y * t.y), e > 2 * ct * this.a ? void 0 : (r = e / this.a, n = Math.sin(r), i = Math.cos(r), l = this.long0, Math.abs(e) <= It ? h = this.lat0 : (h = ql(i * this.sin_p12 + t.y * n * this.cos_p12 / e), s = Math.abs(this.lat0) - ct, Math.abs(s) <= It ? this.lat0 >= 0 ? l = Ft(this.long0 + Math.atan2(t.x, -t.y)) : l = Ft(this.long0 - Math.atan2(-t.x, t.y)) : l = Ft(this.long0 + Math.atan2(t.x * n, e * this.cos_p12 * i - t.y * this.sin_p12 * n))), t.x = l, t.y = h, t)) : (m = Kd(this.es), v = Yd(this.es), E = Jd(this.es), T = Qd(this.es), Math.abs(this.sin_p12 - 1) <= It ? (S = this.a * po(m, v, E, T, ct), e = Math.sqrt(t.x * t.x + t.y * t.y), A = S - e, h = zg(A / this.a, m, v, E, T), l = Ft(this.long0 + Math.atan2(t.x, -1 * t.y)), t.x = l, t.y = h, t) : Math.abs(this.sin_p12 + 1) <= It ? (S = this.a * po(m, v, E, T, ct), e = Math.sqrt(t.x * t.x + t.y * t.y), A = e - S, h = zg(A / this.a, m, v, E, T), l = Ft(this.long0 + Math.atan2(t.x, t.y)), t.x = l, t.y = h, t) : (e = Math.sqrt(t.x * t.x + t.y * t.y), j = Math.atan2(t.x, t.y), L = Fh(this.a, this.e, this.sin_p12), q = Math.cos(j), H = this.e * this.cos_p12 * q, ne = -H * H / (1 - this.es), ee = 3 * this.es * (1 - ne) * this.sin_p12 * this.cos_p12 * q / (1 - this.es), he = e / L, Te = he - ne * (1 + ne) * Math.pow(he, 3) / 6 - ee * (1 + 3 * ne) * Math.pow(he, 4) / 24, ve = 1 - ne * Te * Te / 2 - he * Te * Te * Te / 6, B = Math.asin(this.sin_p12 * Math.cos(Te) + this.cos_p12 * Math.sin(Te) * q), l = Ft(this.long0 + Math.asin(Math.sin(j) * Math.sin(Te) / Math.cos(B))), Oe = Math.sin(B), h = Math.atan2((Oe - this.es * ve * this.sin_p12) * Math.tan(B), Oe * (1 - this.es)), t.x = l, t.y = h, t));
}
var UF = ["Azimuthal_Equidistant", "aeqd"];
const $F = {
  init: FF,
  forward: zF,
  inverse: BF,
  names: UF
};
function VF() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function jF(t) {
  var e, r, n, i, l, h, s, m, v = t.x, E = t.y;
  return n = Ft(v - this.long0), e = Math.sin(E), r = Math.cos(E), i = Math.cos(n), h = this.sin_p14 * e + this.cos_p14 * r * i, l = 1, (h > 0 || Math.abs(h) <= It) && (s = this.a * l * r * Math.sin(n), m = this.y0 + this.a * l * (this.cos_p14 * e - this.sin_p14 * r * i)), t.x = s, t.y = m, t;
}
function GF(t) {
  var e, r, n, i, l, h, s;
  return t.x -= this.x0, t.y -= this.y0, e = Math.sqrt(t.x * t.x + t.y * t.y), r = ql(e / this.a), n = Math.sin(r), i = Math.cos(r), h = this.long0, Math.abs(e) <= It ? (s = this.lat0, t.x = h, t.y = s, t) : (s = ql(i * this.sin_p14 + t.y * n * this.cos_p14 / e), l = Math.abs(this.lat0) - ct, Math.abs(l) <= It ? (this.lat0 >= 0 ? h = Ft(this.long0 + Math.atan2(t.x, -t.y)) : h = Ft(this.long0 - Math.atan2(-t.x, t.y)), t.x = h, t.y = s, t) : (h = Ft(this.long0 + Math.atan2(t.x * n, e * this.cos_p14 * i - t.y * this.sin_p14 * n)), t.x = h, t.y = s, t));
}
var qF = ["ortho"];
const WF = {
  init: VF,
  forward: jF,
  inverse: GF,
  names: qF
};
var Bn = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, Qr = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function XF() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= ct - Jr / 2 ? this.face = Bn.TOP : this.lat0 <= -(ct - Jr / 2) ? this.face = Bn.BOTTOM : Math.abs(this.long0) <= Jr ? this.face = Bn.FRONT : Math.abs(this.long0) <= ct + Jr ? this.face = this.long0 > 0 ? Bn.RIGHT : Bn.LEFT : this.face = Bn.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function ZF(t) {
  var e = { x: 0, y: 0 }, r, n, i, l, h, s, m = { value: 0 };
  if (t.x -= this.long0, this.es !== 0 ? r = Math.atan(this.one_minus_f_squared * Math.tan(t.y)) : r = t.y, n = t.x, this.face === Bn.TOP)
    l = ct - r, n >= Jr && n <= ct + Jr ? (m.value = Qr.AREA_0, i = n - ct) : n > ct + Jr || n <= -(ct + Jr) ? (m.value = Qr.AREA_1, i = n > 0 ? n - ti : n + ti) : n > -(ct + Jr) && n <= -Jr ? (m.value = Qr.AREA_2, i = n + ct) : (m.value = Qr.AREA_3, i = n);
  else if (this.face === Bn.BOTTOM)
    l = ct + r, n >= Jr && n <= ct + Jr ? (m.value = Qr.AREA_0, i = -n + ct) : n < Jr && n >= -Jr ? (m.value = Qr.AREA_1, i = -n) : n < -Jr && n >= -(ct + Jr) ? (m.value = Qr.AREA_2, i = -n - ct) : (m.value = Qr.AREA_3, i = n > 0 ? -n + ti : -n - ti);
  else {
    var v, E, T, S, A, L, B;
    this.face === Bn.RIGHT ? n = Ch(n, +ct) : this.face === Bn.BACK ? n = Ch(n, +ti) : this.face === Bn.LEFT && (n = Ch(n, -ct)), S = Math.sin(r), A = Math.cos(r), L = Math.sin(n), B = Math.cos(n), v = A * B, E = A * L, T = S, this.face === Bn.FRONT ? (l = Math.acos(v), i = Om(l, T, E, m)) : this.face === Bn.RIGHT ? (l = Math.acos(E), i = Om(l, T, -v, m)) : this.face === Bn.BACK ? (l = Math.acos(-v), i = Om(l, T, -E, m)) : this.face === Bn.LEFT ? (l = Math.acos(-E), i = Om(l, T, v, m)) : (l = i = 0, m.value = Qr.AREA_0);
  }
  return s = Math.atan(12 / ti * (i + Math.acos(Math.sin(i) * Math.cos(Jr)) - ct)), h = Math.sqrt((1 - Math.cos(l)) / (Math.cos(s) * Math.cos(s)) / (1 - Math.cos(Math.atan(1 / Math.cos(i))))), m.value === Qr.AREA_1 ? s += ct : m.value === Qr.AREA_2 ? s += ti : m.value === Qr.AREA_3 && (s += 1.5 * ti), e.x = h * Math.cos(s), e.y = h * Math.sin(s), e.x = e.x * this.a + this.x0, e.y = e.y * this.a + this.y0, t.x = e.x, t.y = e.y, t;
}
function HF(t) {
  var e = { lam: 0, phi: 0 }, r, n, i, l, h, s, m, v, E, T = { value: 0 };
  if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, n = Math.atan(Math.sqrt(t.x * t.x + t.y * t.y)), r = Math.atan2(t.y, t.x), t.x >= 0 && t.x >= Math.abs(t.y) ? T.value = Qr.AREA_0 : t.y >= 0 && t.y >= Math.abs(t.x) ? (T.value = Qr.AREA_1, r -= ct) : t.x < 0 && -t.x >= Math.abs(t.y) ? (T.value = Qr.AREA_2, r = r < 0 ? r + ti : r - ti) : (T.value = Qr.AREA_3, r += ct), E = ti / 12 * Math.tan(r), h = Math.sin(E) / (Math.cos(E) - 1 / Math.sqrt(2)), s = Math.atan(h), i = Math.cos(r), l = Math.tan(n), m = 1 - i * i * l * l * (1 - Math.cos(Math.atan(1 / Math.cos(s)))), m < -1 ? m = -1 : m > 1 && (m = 1), this.face === Bn.TOP)
    v = Math.acos(m), e.phi = ct - v, T.value === Qr.AREA_0 ? e.lam = s + ct : T.value === Qr.AREA_1 ? e.lam = s < 0 ? s + ti : s - ti : T.value === Qr.AREA_2 ? e.lam = s - ct : e.lam = s;
  else if (this.face === Bn.BOTTOM)
    v = Math.acos(m), e.phi = v - ct, T.value === Qr.AREA_0 ? e.lam = -s + ct : T.value === Qr.AREA_1 ? e.lam = -s : T.value === Qr.AREA_2 ? e.lam = -s - ct : e.lam = s < 0 ? -s - ti : -s + ti;
  else {
    var S, A, L;
    S = m, E = S * S, E >= 1 ? L = 0 : L = Math.sqrt(1 - E) * Math.sin(s), E += L * L, E >= 1 ? A = 0 : A = Math.sqrt(1 - E), T.value === Qr.AREA_1 ? (E = A, A = -L, L = E) : T.value === Qr.AREA_2 ? (A = -A, L = -L) : T.value === Qr.AREA_3 && (E = A, A = L, L = -E), this.face === Bn.RIGHT ? (E = S, S = -A, A = E) : this.face === Bn.BACK ? (S = -S, A = -A) : this.face === Bn.LEFT && (E = S, S = A, A = -E), e.phi = Math.acos(-L) - ct, e.lam = Math.atan2(A, S), this.face === Bn.RIGHT ? e.lam = Ch(e.lam, -ct) : this.face === Bn.BACK ? e.lam = Ch(e.lam, -ti) : this.face === Bn.LEFT && (e.lam = Ch(e.lam, +ct));
  }
  if (this.es !== 0) {
    var B, j, q;
    B = e.phi < 0 ? 1 : 0, j = Math.tan(e.phi), q = this.b / Math.sqrt(j * j + this.one_minus_f_squared), e.phi = Math.atan(Math.sqrt(this.a * this.a - q * q) / (this.one_minus_f * q)), B && (e.phi = -e.phi);
  }
  return e.lam += this.long0, t.x = e.lam, t.y = e.phi, t;
}
function Om(t, e, r, n) {
  var i;
  return t < It ? (n.value = Qr.AREA_0, i = 0) : (i = Math.atan2(e, r), Math.abs(i) <= Jr ? n.value = Qr.AREA_0 : i > Jr && i <= ct + Jr ? (n.value = Qr.AREA_1, i -= ct) : i > ct + Jr || i <= -(ct + Jr) ? (n.value = Qr.AREA_2, i = i >= 0 ? i - ti : i + ti) : (n.value = Qr.AREA_3, i += ct)), i;
}
function Ch(t, e) {
  var r = t + e;
  return r < -ti ? r += Ld : r > +ti && (r -= Ld), r;
}
var KF = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const YF = {
  init: XF,
  forward: ZF,
  inverse: HF,
  names: KF
};
var P0 = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], id = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], I2 = 0.8487, P2 = 1.3523, A2 = Qa / 5, JF = 1 / A2, yh = 18, Bg = function(t, e) {
  return t[0] + e * (t[1] + e * (t[2] + e * t[3]));
}, QF = function(t, e) {
  return t[1] + e * (2 * t[2] + e * 3 * t[3]);
};
function e5(t, e, r, n) {
  for (var i = e; n; --n) {
    var l = t(i);
    if (i -= l, Math.abs(l) < r)
      break;
  }
  return i;
}
function t5() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function r5(t) {
  var e = Ft(t.x - this.long0), r = Math.abs(t.y), n = Math.floor(r * A2);
  n < 0 ? n = 0 : n >= yh && (n = yh - 1), r = Qa * (r - JF * n);
  var i = {
    x: Bg(P0[n], r) * e,
    y: Bg(id[n], r)
  };
  return t.y < 0 && (i.y = -i.y), i.x = i.x * this.a * I2 + this.x0, i.y = i.y * this.a * P2 + this.y0, i;
}
function n5(t) {
  var e = {
    x: (t.x - this.x0) / (this.a * I2),
    y: Math.abs(t.y - this.y0) / (this.a * P2)
  };
  if (e.y >= 1)
    e.x /= P0[yh][0], e.y = t.y < 0 ? -ct : ct;
  else {
    var r = Math.floor(e.y * yh);
    for (r < 0 ? r = 0 : r >= yh && (r = yh - 1); ; )
      if (id[r][0] > e.y)
        --r;
      else if (id[r + 1][0] <= e.y)
        ++r;
      else
        break;
    var n = id[r], i = 5 * (e.y - n[0]) / (id[r + 1][0] - n[0]);
    i = e5(function(l) {
      return (Bg(n, l) - e.y) / QF(n, l);
    }, i, It, 100), e.x /= Bg(P0[r], i), e.y = (5 * r + i) * Fi, t.y < 0 && (e.y = -e.y);
  }
  return e.x = Ft(e.x + this.long0), e;
}
var i5 = ["Robinson", "robin"];
const o5 = {
  init: t5,
  forward: r5,
  inverse: n5,
  names: i5
};
function a5() {
  this.name = "geocent";
}
function s5(t) {
  var e = m2(t, this.es, this.a);
  return e;
}
function l5(t) {
  var e = g2(t, this.es, this.a, this.b);
  return e;
}
var c5 = ["Geocentric", "geocentric", "geocent", "Geocent"];
const u5 = {
  init: a5,
  forward: s5,
  inverse: l5,
  names: c5
};
var Hi = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, Kf = {
  h: { def: 1e5, num: !0 },
  azi: { def: 0, num: !0, degrees: !0 },
  tilt: { def: 0, num: !0, degrees: !0 },
  long0: { def: 0, num: !0 },
  lat0: { def: 0, num: !0 }
};
function h5() {
  if (Object.keys(Kf).forEach(function(r) {
    if (typeof this[r] > "u")
      this[r] = Kf[r].def;
    else {
      if (Kf[r].num && isNaN(this[r]))
        throw new Error("Invalid parameter value, must be numeric " + r + " = " + this[r]);
      Kf[r].num && (this[r] = parseFloat(this[r]));
    }
    Kf[r].degrees && (this[r] = this[r] * Fi);
  }.bind(this)), Math.abs(Math.abs(this.lat0) - ct) < It ? this.mode = this.lat0 < 0 ? Hi.S_POLE : Hi.N_POLE : Math.abs(this.lat0) < It ? this.mode = Hi.EQUIT : (this.mode = Hi.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var t = this.tilt, e = this.azi;
  this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(t), this.sw = Math.sin(t);
}
function f5(t) {
  t.x -= this.long0;
  var e = Math.sin(t.y), r = Math.cos(t.y), n = Math.cos(t.x), i, l;
  switch (this.mode) {
    case Hi.OBLIQ:
      l = this.sinph0 * e + this.cosph0 * r * n;
      break;
    case Hi.EQUIT:
      l = r * n;
      break;
    case Hi.S_POLE:
      l = -e;
      break;
    case Hi.N_POLE:
      l = e;
      break;
  }
  switch (l = this.pn1 / (this.p - l), i = l * r * Math.sin(t.x), this.mode) {
    case Hi.OBLIQ:
      l *= this.cosph0 * e - this.sinph0 * r * n;
      break;
    case Hi.EQUIT:
      l *= e;
      break;
    case Hi.N_POLE:
      l *= -(r * n);
      break;
    case Hi.S_POLE:
      l *= r * n;
      break;
  }
  var h, s;
  return h = l * this.cg + i * this.sg, s = 1 / (h * this.sw * this.h1 + this.cw), i = (i * this.cg - l * this.sg) * this.cw * s, l = h * s, t.x = i * this.a, t.y = l * this.a, t;
}
function d5(t) {
  t.x /= this.a, t.y /= this.a;
  var e = { x: t.x, y: t.y }, r, n, i;
  i = 1 / (this.pn1 - t.y * this.sw), r = this.pn1 * t.x * i, n = this.pn1 * t.y * this.cw * i, t.x = r * this.cg + n * this.sg, t.y = n * this.cg - r * this.sg;
  var l = Ma(t.x, t.y);
  if (Math.abs(l) < It)
    e.x = 0, e.y = t.y;
  else {
    var h, s;
    switch (s = 1 - l * l * this.pfact, s = (this.p - Math.sqrt(s)) / (this.pn1 / l + l / this.pn1), h = Math.sqrt(1 - s * s), this.mode) {
      case Hi.OBLIQ:
        e.y = Math.asin(h * this.sinph0 + t.y * s * this.cosph0 / l), t.y = (h - this.sinph0 * Math.sin(e.y)) * l, t.x *= s * this.cosph0;
        break;
      case Hi.EQUIT:
        e.y = Math.asin(t.y * s / l), t.y = h * l, t.x *= s;
        break;
      case Hi.N_POLE:
        e.y = Math.asin(h), t.y = -t.y;
        break;
      case Hi.S_POLE:
        e.y = -Math.asin(h);
        break;
    }
    e.x = Math.atan2(t.x, t.y);
  }
  return t.x = e.x + this.long0, t.y = e.y, t;
}
var p5 = ["Tilted_Perspective", "tpers"];
const m5 = {
  init: h5,
  forward: f5,
  inverse: d5,
  names: p5
};
function g5() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var t = 1 - this.es, e = 1 / t;
    this.radius_p = Math.sqrt(t), this.radius_p2 = t, this.radius_p_inv2 = e, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function y5(t) {
  var e = t.x, r = t.y, n, i, l, h;
  if (e = e - this.long0, this.shape === "ellipse") {
    r = Math.atan(this.radius_p2 * Math.tan(r));
    var s = this.radius_p / Ma(this.radius_p * Math.cos(r), Math.sin(r));
    if (i = s * Math.cos(e) * Math.cos(r), l = s * Math.sin(e) * Math.cos(r), h = s * Math.sin(r), (this.radius_g - i) * i - l * l - h * h * this.radius_p_inv2 < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    n = this.radius_g - i, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(l / Ma(h, n)), t.y = this.radius_g_1 * Math.atan(h / n)) : (t.x = this.radius_g_1 * Math.atan(l / n), t.y = this.radius_g_1 * Math.atan(h / Ma(l, n)));
  } else
    this.shape === "sphere" && (n = Math.cos(r), i = Math.cos(e) * n, l = Math.sin(e) * n, h = Math.sin(r), n = this.radius_g - i, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(l / Ma(h, n)), t.y = this.radius_g_1 * Math.atan(h / n)) : (t.x = this.radius_g_1 * Math.atan(l / n), t.y = this.radius_g_1 * Math.atan(h / Ma(l, n))));
  return t.x = t.x * this.a, t.y = t.y * this.a, t;
}
function _5(t) {
  var e = -1, r = 0, n = 0, i, l, h, s;
  if (t.x = t.x / this.a, t.y = t.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (n = Math.tan(t.y / this.radius_g_1), r = Math.tan(t.x / this.radius_g_1) * Ma(1, n)) : (r = Math.tan(t.x / this.radius_g_1), n = Math.tan(t.y / this.radius_g_1) * Ma(1, r));
    var m = n / this.radius_p;
    if (i = r * r + m * m + e * e, l = 2 * this.radius_g * e, h = l * l - 4 * i * this.C, h < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    s = (-l - Math.sqrt(h)) / (2 * i), e = this.radius_g + s * e, r *= s, n *= s, t.x = Math.atan2(r, e), t.y = Math.atan(n * Math.cos(t.x) / e), t.y = Math.atan(this.radius_p_inv2 * Math.tan(t.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (n = Math.tan(t.y / this.radius_g_1), r = Math.tan(t.x / this.radius_g_1) * Math.sqrt(1 + n * n)) : (r = Math.tan(t.x / this.radius_g_1), n = Math.tan(t.y / this.radius_g_1) * Math.sqrt(1 + r * r)), i = r * r + n * n + e * e, l = 2 * this.radius_g * e, h = l * l - 4 * i * this.C, h < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    s = (-l - Math.sqrt(h)) / (2 * i), e = this.radius_g + s * e, r *= s, n *= s, t.x = Math.atan2(r, e), t.y = Math.atan(n * Math.cos(t.x) / e);
  }
  return t.x = t.x + this.long0, t;
}
var v5 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const x5 = {
  init: g5,
  forward: y5,
  inverse: _5,
  names: v5
};
function b5(t) {
  t.Proj.projections.add(fg), t.Proj.projections.add(dg), t.Proj.projections.add(CN), t.Proj.projections.add(FN), t.Proj.projections.add(jN), t.Proj.projections.add(ZN), t.Proj.projections.add(e3), t.Proj.projections.add(o3), t.Proj.projections.add(u3), t.Proj.projections.add(m3), t.Proj.projections.add(R3), t.Proj.projections.add(z3), t.Proj.projections.add(j3), t.Proj.projections.add(H3), t.Proj.projections.add(eF), t.Proj.projections.add(oF), t.Proj.projections.add(uF), t.Proj.projections.add(mF), t.Proj.projections.add(bF), t.Proj.projections.add(MF), t.Proj.projections.add(OF), t.Proj.projections.add(NF), t.Proj.projections.add($F), t.Proj.projections.add(WF), t.Proj.projections.add(YF), t.Proj.projections.add(o5), t.Proj.projections.add(u5), t.Proj.projections.add(m5), t.Proj.projections.add(x5);
}
Yi.defaultDatum = "WGS84";
Yi.Proj = rs;
Yi.WGS84 = new Yi.Proj("WGS84");
Yi.Point = Nh;
Yi.toPoint = y2;
Yi.defs = ho;
Yi.nadgrid = Pk;
Yi.transform = Fg;
Yi.mgrs = qk;
Yi.version = "__VERSION__";
b5(Yi);
function w5() {
  var t, e, r;
  Yi.defs("EPSG:32632", "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs"), Yi.defs("EPSG:32631", "+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs"), Yi.defs(
    "EPSG:2169",
    "+proj=tmerc +lat_0=49.83333333333334 +lon_0=6.166666666666667 +k=1 +x_0=80000 +y_0=100000 +ellps=intl +towgs84=-189.681,18.3463,-42.7695,-0.33746,-3.09264,2.53861,0.4598 +units=m +no_defs"
  ), jD(Yi), (t = fi("EPSG:32632")) == null || t.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]), (e = fi("EPSG:32631")) == null || e.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]), (r = fi("EPSG:2169")) == null || r.setExtent([
    48225.17,
    56225.6,
    105842.04,
    139616.4
  ]);
}
function E5(t, e, r) {
  const n = vr(t);
  class i extends Cx {
    constructor(h) {
      super(n, h, e, r);
    }
  }
  return ei(i, "def", n), i;
}
const T5 = typeof HTMLElement < "u" ? HTMLElement : class {
};
class Cx extends T5 {
  constructor(r, n = {}, i = {}, l) {
    super();
    ei(this, "_instance", null);
    ei(this, "_connected", !1);
    ei(this, "_resolved", !1);
    ei(this, "_numberProps", null);
    ei(this, "_styles");
    ei(this, "_slots");
    this._def = r, this._props = n, this._config = i, this._config = kn(
      {
        shadowRoot: !0
      },
      this._config
    ), this._config.shadowRoot ? this.shadowRoot && l ? l(this._createVNode(), this.shadowRoot) : (this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def)) : l && l(this._createVNode(), this._root);
  }
  get _root() {
    return this._config.shadowRoot ? this.shadowRoot : this;
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, Sg(() => {
      this._connected || (cw(null, this._root), this._instance = null);
    });
  }
  _resolveDef() {
    this._resolved = !0;
    for (let i = 0; i < this.attributes.length; i++)
      this._setAttr(this.attributes[i].name);
    new MutationObserver((i) => {
      for (const l of i)
        this._setAttr(l.attributeName);
    }).observe(this, { attributes: !0 });
    const r = (i, l = !1) => {
      const { props: h, styles: s } = i;
      let m;
      if (h && !Zt(h))
        for (const v in h) {
          const E = h[v];
          (E === Number || E && E.type === Number) && (v in this._props && (this._props[v] = Wv(this._props[v])), (m || (m = /* @__PURE__ */ Object.create(null)))[Go(v)] = !0);
        }
      this._numberProps = m, l && this._resolveProps(i), this._applyStyles(s), this._update();
    }, n = this._def.__asyncLoader;
    n ? n().then((i) => r(i, !0)) : r(this._def);
  }
  _resolveProps(r) {
    const { props: n } = r, i = Zt(n) ? n : Object.keys(n || {});
    for (const l of Object.keys(this))
      l[0] !== "_" && i.includes(l) && this._setProp(l, this[l], !0, !1);
    for (const l of i.map(Go))
      Object.defineProperty(this, l, {
        get() {
          return this._getProp(l);
        },
        set(h) {
          this._setProp(l, h);
        }
      });
  }
  _setAttr(r) {
    let n = this.getAttribute(r);
    const i = Go(r);
    this._numberProps && this._numberProps[i] && (n = Wv(n)), this._setProp(i, n, !1);
  }
  _getProp(r) {
    return this._props[r];
  }
  _setProp(r, n, i = !0, l = !0) {
    n !== this._props[r] && (this._props[r] = n, l && this._instance && this._update(), i && (n === !0 ? this.setAttribute(Mo(r), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(Mo(r), n + "") : n || this.removeAttribute(Mo(r))));
  }
  _update() {
    cw(this._createVNode(), this._root);
  }
  _createVNode() {
    const r = $t(this._def, kn({}, this._props));
    return this._instance || (r.ce = (n) => {
      this._instance = n, n.isCE = !0;
      const i = (h, s) => {
        this.dispatchEvent(
          new CustomEvent(h, {
            detail: s
          })
        );
      };
      n.emit = (h, ...s) => {
        i(h, s), Mo(h) !== h && i(Mo(h), s);
      };
      let l = this;
      for (; l = l && (l.parentNode || l.host); )
        if (l instanceof Cx) {
          n.parent = l._instance, n.provides = l._instance.provides;
          break;
        }
    }), r;
  }
  _applyStyles(r) {
    r && r.forEach((n) => {
      const i = document.createElement("style");
      i.textContent = n, this._root.appendChild(i);
    });
  }
}
var Ix = /* @__PURE__ */ ((t) => (t.INFO = "alert-info", t.WARNING = "alert-warning", t.ERROR = "alert-danger", t))(Ix || {});
const S5 = Ix.INFO, M5 = 7e3, C5 = 4e3, O2 = du(
  "alert-notifications",
  () => {
    const t = Kr([]);
    function e(n, i = S5, l) {
      const h = {
        message: n,
        type: i,
        duration: l != null ? l : i === Ix.WARNING ? C5 : M5
      };
      t.value.push(h);
    }
    function r(n) {
      t.value.splice(n, 1);
    }
    return {
      notifications: t,
      addNotification: e,
      removeNotification: r
    };
  },
  {}
), I5 = /* @__PURE__ */ vr({
  __name: "notification-item",
  props: {
    notification: { type: null, required: !0 }
  },
  emits: ["close"],
  setup(t) {
    const e = t, r = yi(!0);
    function n(i, l) {
      setTimeout(() => {
        r.value = !1;
      }, e.notification.duration), l();
    }
    return (i, l) => (tt(), Un(Py, {
      name: "fade-out",
      appear: "",
      "leave-active-class": "duration-200 ease-in",
      "leave-from-class": "opacity-100",
      "leave-to-class": "transform opacity-0",
      onEnter: n,
      onAfterLeave: l[0] || (l[0] = (h) => i.$emit("close"))
    }, {
      default: jd(() => [
        _e(r) ? (tt(), vt("div", {
          key: 0,
          class: Or(["lux-alert", `lux-${e.notification.type}`]),
          role: "alert"
        }, Vt(e.notification.message), 3)) : Tt("v-if", !0)
      ]),
      _: 1
    }));
  }
}), Mr = (t, e) => {
  const r = t.__vccOpts || t;
  for (const [n, i] of e)
    r[n] = i;
  return r;
}, P5 = /* @__PURE__ */ Mr(I5, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/alert-notifications/notification-item.vue"]]), A5 = {
  key: 0,
  class: "lux-notifications fixed w-[500px] top-10 left-1/2 ml-[-250px] z-50"
}, O5 = /* @__PURE__ */ vr({
  __name: "alert-notifications",
  setup(t) {
    const e = O2(), { notifications: r } = mn(e);
    function n(i) {
      e.removeNotification(i);
    }
    return (i, l) => (tt(), Un(SS, { to: "body" }, [
      _e(r).length ? (tt(), vt("div", A5, [
        (tt(!0), vt(pn, null, ka(_e(r), (h, s) => (tt(), Un(P5, {
          key: s,
          notification: h,
          onClose: () => n(s)
        }, null, 8, ["notification", "onClose"]))), 128))
      ])) : Tt("v-if", !0)
    ]));
  }
}), R5 = /* @__PURE__ */ Mr(O5, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/alert-notifications/alert-notifications.vue"]]), L5 = { class: "lux-dropdown" }, D5 = { class: "h-full" }, k5 = ["aria-expanded"], N5 = /* @__PURE__ */ $e("span", { class: "lux-caret" }, null, -1), F5 = { class: "lux-dropdown-wrapper" }, z5 = ["aria-label", "data-value"], B5 = /* @__PURE__ */ vr({
  __name: "dropdown-list",
  props: {
    placeholder: { type: String, required: !0 },
    options: { type: Array, required: !0, default: () => [{ label: "Default label", value: "Default value" }] },
    modelValue: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const r = t, n = yi(!1), i = yi();
    function l(v) {
      n.value = v === void 0 ? !n.value : v;
    }
    function h(v) {
      v.stopImmediatePropagation(), l();
    }
    function s(v) {
      i.value = v.target.dataset.value, e("change", i.value);
    }
    function m() {
      l(!1);
    }
    return aa(() => document.addEventListener("click", m)), fu(() => document.removeEventListener("click", m)), (v, E) => {
      var T, S;
      return tt(), vt("div", L5, [
        $e("div", D5, [
          $e("button", {
            type: "button",
            class: Or(["lux-btn lux-dropdown-btn", _e(n) ? "expanded" : ""]),
            "aria-expanded": _e(n),
            "aria-haspopup": "true",
            onClick: h
          }, [
            $e("span", null, Vt((S = r.placeholder) != null ? S : (T = r.options[0]) == null ? void 0 : T.label), 1),
            N5
          ], 10, k5)
        ]),
        $e("div", F5, [
          $e("ul", {
            class: Or(["lux-dropdown-list", _e(n) ? "" : "hidden"]),
            tabindex: "-1"
          }, [
            (tt(!0), vt(pn, null, ka(r.options, (A) => (tt(), vt("li", {
              key: A.value,
              class: Or(t.modelValue === A.value ? "selected" : "")
            }, [
              $e("button", {
                class: "lux-dropdown-list-item",
                "aria-label": A.ariaLabel,
                "data-value": A.value,
                onClick: s
              }, Vt(A.label), 9, z5)
            ], 2))), 128))
          ], 2)
        ])
      ]);
    };
  }
}), R2 = /* @__PURE__ */ Mr(B5, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/dropdown-list.vue"]]);
var U5 = function() {
  function t() {
    this.disposed = !1;
  }
  return t.prototype.dispose = function() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }, t.prototype.disposeInternal = function() {
  }, t;
}();
const Px = U5;
function Ax(t, e) {
  return t > e ? 1 : t < e ? -1 : 0;
}
function By(t, e, r) {
  var n = t.length;
  if (t[0] <= e)
    return 0;
  if (e <= t[n - 1])
    return n - 1;
  var i = void 0;
  if (r > 0) {
    for (i = 1; i < n; ++i)
      if (t[i] < e)
        return i - 1;
  } else if (r < 0) {
    for (i = 1; i < n; ++i)
      if (t[i] <= e)
        return i;
  } else
    for (i = 1; i < n; ++i) {
      if (t[i] == e)
        return i;
      if (t[i] < e)
        return typeof r == "function" ? r(e, t[i - 1], t[i]) > 0 ? i - 1 : i : t[i - 1] - e < e - t[i] ? i - 1 : i;
    }
  return n - 1;
}
function $5(t, e) {
  for (var r = Array.isArray(e) ? e : [e], n = r.length, i = 0; i < n; i++)
    t[t.length] = r[i];
}
function Ox(t, e) {
  var r = t.length;
  if (r !== e.length)
    return !1;
  for (var n = 0; n < r; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function V5(t, e, r) {
  var n = e || Ax;
  return t.every(function(i, l) {
    if (l === 0)
      return !0;
    var h = n(t[l - 1], i);
    return !(h > 0 || r && h === 0);
  });
}
function gd() {
  return !0;
}
function Uy() {
  return !1;
}
function Nd() {
}
function j5(t) {
  var e = !1, r, n, i;
  return function() {
    var l = Array.prototype.slice.call(arguments);
    return (!e || this !== i || !Ox(l, n)) && (e = !0, i = this, n = l, r = t.apply(this, arguments)), r;
  };
}
var Wl = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", G5 = Wl.indexOf("firefox") !== -1, q5 = Wl.indexOf("safari") !== -1 && Wl.indexOf("chrom") == -1;
q5 && (Wl.indexOf("version/15.4") >= 0 || Wl.match(/cpu (os|iphone os) 15_4 like mac os x/));
var W5 = Wl.indexOf("webkit") !== -1 && Wl.indexOf("edge") == -1, X5 = Wl.indexOf("macintosh") !== -1, L2 = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, D2 = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, Z5 = typeof Image < "u" && Image.prototype.decode, k2 = function() {
  var t = !1;
  try {
    var e = Object.defineProperty({}, "passive", {
      get: function() {
        t = !0;
      }
    });
    window.addEventListener("_", null, e), window.removeEventListener("_", null, e);
  } catch {
  }
  return t;
}();
new Array(6);
function Ih() {
  return [1, 0, 0, 1, 0, 0];
}
function Xi(t, e) {
  var r = e[0], n = e[1];
  return e[0] = t[0] * r + t[2] * n + t[4], e[1] = t[1] * r + t[3] * n + t[5], e;
}
function cu(t, e, r, n, i, l, h, s) {
  var m = Math.sin(l), v = Math.cos(l);
  return t[0] = n * v, t[1] = i * m, t[2] = -n * m, t[3] = i * v, t[4] = h * n * v - s * n * m + e, t[5] = h * i * m + s * i * v + r, t;
}
function Rx(t, e) {
  var r = H5(e);
  en(r !== 0, 32);
  var n = e[0], i = e[1], l = e[2], h = e[3], s = e[4], m = e[5];
  return t[0] = h / r, t[1] = -i / r, t[2] = -l / r, t[3] = n / r, t[4] = (l * m - h * s) / r, t[5] = -(n * m - i * s) / r, t;
}
function H5(t) {
  return t[0] * t[3] - t[1] * t[2];
}
var Zw;
function N2(t) {
  var e = "matrix(" + t.join(", ") + ")";
  if (D2)
    return e;
  var r = Zw || (Zw = document.createElement("div"));
  return r.style.transform = e, r.style.transform;
}
var K5 = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i, Y5 = /^([a-z]*)$|^hsla?\(.*\)$/i;
function J5(t) {
  return typeof t == "string" ? t : rz(t);
}
function Q5(t) {
  var e = document.createElement("div");
  if (e.style.color = t, e.style.color !== "") {
    document.body.appendChild(e);
    var r = getComputedStyle(e).color;
    return document.body.removeChild(e), r;
  } else
    return "";
}
var ez = function() {
  var t = 1024, e = {}, r = 0;
  return function(n) {
    var i;
    if (e.hasOwnProperty(n))
      i = e[n];
    else {
      if (r >= t) {
        var l = 0;
        for (var h in e)
          (l++ & 3) === 0 && (delete e[h], --r);
      }
      i = tz(n), e[n] = i, ++r;
    }
    return i;
  };
}();
function Hw(t) {
  return Array.isArray(t) ? t : ez(t);
}
function tz(t) {
  var e, r, n, i, l;
  if (Y5.exec(t) && (t = Q5(t)), K5.exec(t)) {
    var h = t.length - 1, s = void 0;
    h <= 4 ? s = 1 : s = 2;
    var m = h === 4 || h === 8;
    e = parseInt(t.substr(1 + 0 * s, s), 16), r = parseInt(t.substr(1 + 1 * s, s), 16), n = parseInt(t.substr(1 + 2 * s, s), 16), m ? i = parseInt(t.substr(1 + 3 * s, s), 16) : i = 255, s == 1 && (e = (e << 4) + e, r = (r << 4) + r, n = (n << 4) + n, m && (i = (i << 4) + i)), l = [e, r, n, i / 255];
  } else
    t.indexOf("rgba(") == 0 ? (l = t.slice(5, -1).split(",").map(Number), Kw(l)) : t.indexOf("rgb(") == 0 ? (l = t.slice(4, -1).split(",").map(Number), l.push(1), Kw(l)) : en(!1, 14);
  return l;
}
function Kw(t) {
  return t[0] = hi(t[0] + 0.5 | 0, 0, 255), t[1] = hi(t[1] + 0.5 | 0, 0, 255), t[2] = hi(t[2] + 0.5 | 0, 0, 255), t[3] = hi(t[3], 0, 1), t;
}
function rz(t) {
  var e = t[0];
  e != (e | 0) && (e = e + 0.5 | 0);
  var r = t[1];
  r != (r | 0) && (r = r + 0.5 | 0);
  var n = t[2];
  n != (n | 0) && (n = n + 0.5 | 0);
  var i = t[3] === void 0 ? 1 : Math.round(t[3] * 100) / 100;
  return "rgba(" + e + "," + r + "," + n + "," + i + ")";
}
var nz = function() {
  function t() {
    this.cache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
  }
  return t.prototype.clear = function() {
    this.cache_ = {}, this.cacheSize_ = 0;
  }, t.prototype.canExpireCache = function() {
    return this.cacheSize_ > this.maxCacheSize_;
  }, t.prototype.expire = function() {
    if (this.canExpireCache()) {
      var e = 0;
      for (var r in this.cache_) {
        var n = this.cache_[r];
        (e++ & 3) === 0 && !n.hasListener() && (delete this.cache_[r], --this.cacheSize_);
      }
    }
  }, t.prototype.get = function(e, r, n) {
    var i = Yw(e, r, n);
    return i in this.cache_ ? this.cache_[i] : null;
  }, t.prototype.set = function(e, r, n, i) {
    var l = Yw(e, r, n);
    this.cache_[l] = i, ++this.cacheSize_;
  }, t.prototype.setSize = function(e) {
    this.maxCacheSize_ = e, this.expire();
  }, t;
}();
function Yw(t, e, r) {
  var n = r ? J5(r) : "null";
  return e + ":" + t + ":" + n;
}
var F2 = new nz(), iz = function() {
  function t(e) {
    this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
  }
  return t.prototype.preventDefault = function() {
    this.defaultPrevented = !0;
  }, t.prototype.stopPropagation = function() {
    this.propagationStopped = !0;
  }, t;
}();
const Xs = iz, zh = {
  PROPERTYCHANGE: "propertychange"
};
var oz = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), az = function(t) {
  oz(e, t);
  function e(r) {
    var n = t.call(this) || this;
    return n.eventTarget_ = r, n.pendingRemovals_ = null, n.dispatching_ = null, n.listeners_ = null, n;
  }
  return e.prototype.addEventListener = function(r, n) {
    if (!(!r || !n)) {
      var i = this.listeners_ || (this.listeners_ = {}), l = i[r] || (i[r] = []);
      l.indexOf(n) === -1 && l.push(n);
    }
  }, e.prototype.dispatchEvent = function(r) {
    var n = typeof r == "string", i = n ? r : r.type, l = this.listeners_ && this.listeners_[i];
    if (!!l) {
      var h = n ? new Xs(r) : r;
      h.target || (h.target = this.eventTarget_ || this);
      var s = this.dispatching_ || (this.dispatching_ = {}), m = this.pendingRemovals_ || (this.pendingRemovals_ = {});
      i in s || (s[i] = 0, m[i] = 0), ++s[i];
      for (var v, E = 0, T = l.length; E < T; ++E)
        if ("handleEvent" in l[E] ? v = l[E].handleEvent(h) : v = l[E].call(this, h), v === !1 || h.propagationStopped) {
          v = !1;
          break;
        }
      if (--s[i] === 0) {
        var S = m[i];
        for (delete m[i]; S--; )
          this.removeEventListener(i, Nd);
        delete s[i];
      }
      return v;
    }
  }, e.prototype.disposeInternal = function() {
    this.listeners_ && Oy(this.listeners_);
  }, e.prototype.getListeners = function(r) {
    return this.listeners_ && this.listeners_[r] || void 0;
  }, e.prototype.hasListener = function(r) {
    return this.listeners_ ? r ? r in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }, e.prototype.removeEventListener = function(r, n) {
    var i = this.listeners_ && this.listeners_[r];
    if (i) {
      var l = i.indexOf(n);
      l !== -1 && (this.pendingRemovals_ && r in this.pendingRemovals_ ? (i[l] = Nd, ++this.pendingRemovals_[r]) : (i.splice(l, 1), i.length === 0 && delete this.listeners_[r]));
    }
  }, e;
}(Px);
const ep = az, _r = {
  CHANGE: "change",
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function Fr(t, e, r, n, i) {
  if (n && n !== t && (r = r.bind(n)), i) {
    var l = r;
    r = function() {
      t.removeEventListener(e, r), l.apply(this, arguments);
    };
  }
  var h = {
    target: t,
    type: e,
    listener: r
  };
  return t.addEventListener(e, r), h;
}
function Ug(t, e, r, n) {
  return Fr(t, e, r, n, !0);
}
function $n(t) {
  t && t.target && (t.target.removeEventListener(t.type, t.listener), Oy(t));
}
var sz = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), tp = function(t) {
  sz(e, t);
  function e() {
    var r = t.call(this) || this;
    return r.on = r.onInternal, r.once = r.onceInternal, r.un = r.unInternal, r.revision_ = 0, r;
  }
  return e.prototype.changed = function() {
    ++this.revision_, this.dispatchEvent(_r.CHANGE);
  }, e.prototype.getRevision = function() {
    return this.revision_;
  }, e.prototype.onInternal = function(r, n) {
    if (Array.isArray(r)) {
      for (var i = r.length, l = new Array(i), h = 0; h < i; ++h)
        l[h] = Fr(this, r[h], n);
      return l;
    } else
      return Fr(this, r, n);
  }, e.prototype.onceInternal = function(r, n) {
    var i;
    if (Array.isArray(r)) {
      var l = r.length;
      i = new Array(l);
      for (var h = 0; h < l; ++h)
        i[h] = Ug(this, r[h], n);
    } else
      i = Ug(this, r, n);
    return n.ol_key = i, i;
  }, e.prototype.unInternal = function(r, n) {
    var i = n.ol_key;
    if (i)
      z2(i);
    else if (Array.isArray(r))
      for (var l = 0, h = r.length; l < h; ++l)
        this.removeEventListener(r[l], n);
    else
      this.removeEventListener(r, n);
  }, e;
}(ep);
tp.prototype.on;
tp.prototype.once;
tp.prototype.un;
function z2(t) {
  if (Array.isArray(t))
    for (var e = 0, r = t.length; e < r; ++e)
      $n(t[e]);
  else
    $n(t);
}
var B2 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Jw = function(t) {
  B2(e, t);
  function e(r, n, i) {
    var l = t.call(this, r) || this;
    return l.key = n, l.oldValue = i, l;
  }
  return e;
}(Xs), lz = function(t) {
  B2(e, t);
  function e(r) {
    var n = t.call(this) || this;
    return n.on, n.once, n.un, So(n), n.values_ = null, r !== void 0 && n.setProperties(r), n;
  }
  return e.prototype.get = function(r) {
    var n;
    return this.values_ && this.values_.hasOwnProperty(r) && (n = this.values_[r]), n;
  }, e.prototype.getKeys = function() {
    return this.values_ && Object.keys(this.values_) || [];
  }, e.prototype.getProperties = function() {
    return this.values_ && In({}, this.values_) || {};
  }, e.prototype.hasProperties = function() {
    return !!this.values_;
  }, e.prototype.notify = function(r, n) {
    var i;
    i = "change:".concat(r), this.hasListener(i) && this.dispatchEvent(new Jw(i, r, n)), i = zh.PROPERTYCHANGE, this.hasListener(i) && this.dispatchEvent(new Jw(i, r, n));
  }, e.prototype.addChangeListener = function(r, n) {
    this.addEventListener("change:".concat(r), n);
  }, e.prototype.removeChangeListener = function(r, n) {
    this.removeEventListener("change:".concat(r), n);
  }, e.prototype.set = function(r, n, i) {
    var l = this.values_ || (this.values_ = {});
    if (i)
      l[r] = n;
    else {
      var h = l[r];
      l[r] = n, h !== n && this.notify(r, h);
    }
  }, e.prototype.setProperties = function(r, n) {
    for (var i in r)
      this.set(i, r[i], n);
  }, e.prototype.applyProperties = function(r) {
    !r.values_ || In(this.values_ || (this.values_ = {}), r.values_);
  }, e.prototype.unset = function(r, n) {
    if (this.values_ && r in this.values_) {
      var i = this.values_[r];
      delete this.values_[r], dD(this.values_) && (this.values_ = null), n || this.notify(r, i);
    }
  }, e;
}(tp);
const Zs = lz, ln = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
var cz = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), uz = function(t) {
  cz(e, t);
  function e(r) {
    var n = t.call(this) || this;
    n.on, n.once, n.un, n.background_ = r.background;
    var i = In({}, r);
    return typeof r.properties == "object" && (delete i.properties, In(i, r.properties)), i[ln.OPACITY] = r.opacity !== void 0 ? r.opacity : 1, en(typeof i[ln.OPACITY] == "number", 64), i[ln.VISIBLE] = r.visible !== void 0 ? r.visible : !0, i[ln.Z_INDEX] = r.zIndex, i[ln.MAX_RESOLUTION] = r.maxResolution !== void 0 ? r.maxResolution : 1 / 0, i[ln.MIN_RESOLUTION] = r.minResolution !== void 0 ? r.minResolution : 0, i[ln.MIN_ZOOM] = r.minZoom !== void 0 ? r.minZoom : -1 / 0, i[ln.MAX_ZOOM] = r.maxZoom !== void 0 ? r.maxZoom : 1 / 0, n.className_ = i.className !== void 0 ? i.className : "ol-layer", delete i.className, n.setProperties(i), n.state_ = null, n;
  }
  return e.prototype.getBackground = function() {
    return this.background_;
  }, e.prototype.getClassName = function() {
    return this.className_;
  }, e.prototype.getLayerState = function(r) {
    var n = this.state_ || {
      layer: this,
      managed: r === void 0 ? !0 : r
    }, i = this.getZIndex();
    return n.opacity = hi(Math.round(this.getOpacity() * 100) / 100, 0, 1), n.visible = this.getVisible(), n.extent = this.getExtent(), n.zIndex = i === void 0 && !n.managed ? 1 / 0 : i, n.maxResolution = this.getMaxResolution(), n.minResolution = Math.max(this.getMinResolution(), 0), n.minZoom = this.getMinZoom(), n.maxZoom = this.getMaxZoom(), this.state_ = n, n;
  }, e.prototype.getLayersArray = function(r) {
    return En();
  }, e.prototype.getLayerStatesArray = function(r) {
    return En();
  }, e.prototype.getExtent = function() {
    return this.get(ln.EXTENT);
  }, e.prototype.getMaxResolution = function() {
    return this.get(ln.MAX_RESOLUTION);
  }, e.prototype.getMinResolution = function() {
    return this.get(ln.MIN_RESOLUTION);
  }, e.prototype.getMinZoom = function() {
    return this.get(ln.MIN_ZOOM);
  }, e.prototype.getMaxZoom = function() {
    return this.get(ln.MAX_ZOOM);
  }, e.prototype.getOpacity = function() {
    return this.get(ln.OPACITY);
  }, e.prototype.getSourceState = function() {
    return En();
  }, e.prototype.getVisible = function() {
    return this.get(ln.VISIBLE);
  }, e.prototype.getZIndex = function() {
    return this.get(ln.Z_INDEX);
  }, e.prototype.setBackground = function(r) {
    this.background_ = r, this.changed();
  }, e.prototype.setExtent = function(r) {
    this.set(ln.EXTENT, r);
  }, e.prototype.setMaxResolution = function(r) {
    this.set(ln.MAX_RESOLUTION, r);
  }, e.prototype.setMinResolution = function(r) {
    this.set(ln.MIN_RESOLUTION, r);
  }, e.prototype.setMaxZoom = function(r) {
    this.set(ln.MAX_ZOOM, r);
  }, e.prototype.setMinZoom = function(r) {
    this.set(ln.MIN_ZOOM, r);
  }, e.prototype.setOpacity = function(r) {
    en(typeof r == "number", 64), this.set(ln.OPACITY, r);
  }, e.prototype.setVisible = function(r) {
    this.set(ln.VISIBLE, r);
  }, e.prototype.setZIndex = function(r) {
    this.set(ln.Z_INDEX, r);
  }, e.prototype.disposeInternal = function() {
    this.state_ && (this.state_.layer = null, this.state_ = null), t.prototype.disposeInternal.call(this);
  }, e;
}(Zs);
const U2 = uz, ns = {
  PRERENDER: "prerender",
  POSTRENDER: "postrender",
  PRECOMPOSE: "precompose",
  POSTCOMPOSE: "postcompose",
  RENDERCOMPLETE: "rendercomplete"
};
var hz = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), fz = function(t) {
  hz(e, t);
  function e(r) {
    var n = this, i = In({}, r);
    delete i.source, n = t.call(this, i) || this, n.on, n.once, n.un, n.mapPrecomposeKey_ = null, n.mapRenderKey_ = null, n.sourceChangeKey_ = null, n.renderer_ = null, n.rendered = !1, r.render && (n.render = r.render), r.map && n.setMap(r.map), n.addChangeListener(ln.SOURCE, n.handleSourcePropertyChange_);
    var l = r.source ? r.source : null;
    return n.setSource(l), n;
  }
  return e.prototype.getLayersArray = function(r) {
    var n = r || [];
    return n.push(this), n;
  }, e.prototype.getLayerStatesArray = function(r) {
    var n = r || [];
    return n.push(this.getLayerState()), n;
  }, e.prototype.getSource = function() {
    return this.get(ln.SOURCE) || null;
  }, e.prototype.getRenderSource = function() {
    return this.getSource();
  }, e.prototype.getSourceState = function() {
    var r = this.getSource();
    return r ? r.getState() : "undefined";
  }, e.prototype.handleSourceChange_ = function() {
    this.changed();
  }, e.prototype.handleSourcePropertyChange_ = function() {
    this.sourceChangeKey_ && ($n(this.sourceChangeKey_), this.sourceChangeKey_ = null);
    var r = this.getSource();
    r && (this.sourceChangeKey_ = Fr(r, _r.CHANGE, this.handleSourceChange_, this)), this.changed();
  }, e.prototype.getFeatures = function(r) {
    return this.renderer_ ? this.renderer_.getFeatures(r) : new Promise(function(n) {
      return n([]);
    });
  }, e.prototype.getData = function(r) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(r);
  }, e.prototype.render = function(r, n) {
    var i = this.getRenderer();
    if (i.prepareFrame(r))
      return this.rendered = !0, i.renderFrame(r, n);
  }, e.prototype.unrender = function() {
    this.rendered = !1;
  }, e.prototype.setMapInternal = function(r) {
    r || this.unrender(), this.set(ln.MAP, r);
  }, e.prototype.getMapInternal = function() {
    return this.get(ln.MAP);
  }, e.prototype.setMap = function(r) {
    this.mapPrecomposeKey_ && ($n(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), r || this.changed(), this.mapRenderKey_ && ($n(this.mapRenderKey_), this.mapRenderKey_ = null), r && (this.mapPrecomposeKey_ = Fr(r, ns.PRECOMPOSE, function(n) {
      var i = n, l = i.frameState.layerStatesArray, h = this.getLayerState(!1);
      en(!l.some(function(s) {
        return s.layer === h.layer;
      }), 67), l.push(h);
    }, this), this.mapRenderKey_ = Fr(this, _r.CHANGE, r.render, r), this.changed());
  }, e.prototype.setSource = function(r) {
    this.set(ln.SOURCE, r);
  }, e.prototype.getRenderer = function() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }, e.prototype.hasRenderer = function() {
    return !!this.renderer_;
  }, e.prototype.createRenderer = function() {
    return null;
  }, e.prototype.disposeInternal = function() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), t.prototype.disposeInternal.call(this);
  }, e;
}(U2);
function $g(t, e) {
  if (!t.visible)
    return !1;
  var r = e.resolution;
  if (r < t.minResolution || r >= t.maxResolution)
    return !1;
  var n = e.zoom;
  return n > t.minZoom && n <= t.maxZoom;
}
const rp = fz;
var dz = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), pz = function(t) {
  dz(e, t);
  function e(r) {
    var n = t.call(this) || this;
    return n.map_ = r, n;
  }
  return e.prototype.dispatchRenderEvent = function(r, n) {
    En();
  }, e.prototype.calculateMatrices2D = function(r) {
    var n = r.viewState, i = r.coordinateToPixelTransform, l = r.pixelToCoordinateTransform;
    cu(i, r.size[0] / 2, r.size[1] / 2, 1 / n.resolution, -1 / n.resolution, -n.rotation, -n.center[0], -n.center[1]), Rx(l, i);
  }, e.prototype.forEachFeatureAtCoordinate = function(r, n, i, l, h, s, m, v) {
    var E, T = n.viewState;
    function S(ze, Pe, Ye, it) {
      return h.call(s, Pe, ze ? Ye : null, it);
    }
    var A = T.projection, L = OD(r.slice(), A), B = [[0, 0]];
    if (A.canWrapX() && l) {
      var j = A.getExtent(), q = Cn(j);
      B.push([-q, 0], [q, 0]);
    }
    for (var H = n.layerStatesArray, ne = H.length, ee = [], he = [], Te = 0; Te < B.length; Te++)
      for (var ve = ne - 1; ve >= 0; --ve) {
        var Oe = H[ve], Me = Oe.layer;
        if (Me.hasRenderer() && $g(Oe, T) && m.call(v, Me)) {
          var Re = Me.getRenderer(), He = Me.getSource();
          if (Re && He) {
            var Ve = He.getWrapX() ? L : r, dt = S.bind(null, Oe.managed);
            he[0] = Ve[0] + B[Te][0], he[1] = Ve[1] + B[Te][1], E = Re.forEachFeatureAtCoordinate(he, n, i, dt, ee);
          }
          if (E)
            return E;
        }
      }
    if (ee.length !== 0) {
      var xe = 1 / ee.length;
      return ee.forEach(function(ze, Pe) {
        return ze.distanceSq += Pe * xe;
      }), ee.sort(function(ze, Pe) {
        return ze.distanceSq - Pe.distanceSq;
      }), ee.some(function(ze) {
        return E = ze.callback(ze.feature, ze.layer, ze.geometry);
      }), E;
    }
  }, e.prototype.forEachLayerAtPixel = function(r, n, i, l, h) {
    return En();
  }, e.prototype.hasFeatureAtCoordinate = function(r, n, i, l, h, s) {
    var m = this.forEachFeatureAtCoordinate(r, n, i, l, gd, this, h, s);
    return m !== void 0;
  }, e.prototype.getMap = function() {
    return this.map_;
  }, e.prototype.renderFrame = function(r) {
    En();
  }, e.prototype.scheduleExpireIconCache = function(r) {
    F2.canExpireCache() && r.postRenderFunctions.push(mz);
  }, e;
}(Px);
function mz(t, e) {
  F2.expire();
}
const gz = pz;
var yz = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), _z = function(t) {
  yz(e, t);
  function e(r, n, i, l) {
    var h = t.call(this, r) || this;
    return h.inversePixelTransform = n, h.frameState = i, h.context = l, h;
  }
  return e;
}(Xs);
const $2 = _z;
var Rm = "ol-hidden", mu = "ol-unselectable", Qw = "ol-unsupported", jh = "ol-control", eE = "ol-collapsed";
function Vg(t, e, r, n) {
  var i;
  return r && r.length ? i = r.shift() : D2 ? i = new OffscreenCanvas(t || 300, e || 300) : i = document.createElement("canvas"), t && (i.width = t), e && (i.height = e), i.getContext("2d", n);
}
function vz(t) {
  var e = t.canvas;
  e.width = 1, e.height = 1, t.clearRect(0, 0, 1, 1);
}
function jg(t, e) {
  var r = e.parentNode;
  r && r.replaceChild(t, e);
}
function A0(t) {
  return t && t.parentNode ? t.parentNode.removeChild(t) : null;
}
function xz(t) {
  for (; t.lastChild; )
    t.removeChild(t.lastChild);
}
function bz(t, e) {
  for (var r = t.childNodes, n = 0; ; ++n) {
    var i = r[n], l = e[n];
    if (!i && !l)
      break;
    if (i !== l) {
      if (!i) {
        t.appendChild(l);
        continue;
      }
      if (!l) {
        t.removeChild(i), --n;
        continue;
      }
      t.insertBefore(l, i);
    }
  }
}
var wz = new Zs(), Ez = new ep();
Ez.setSize = function() {
  console.warn("labelCache is deprecated.");
};
var Tz = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Sz = function(t) {
  Tz(e, t);
  function e(r) {
    var n = t.call(this, r) || this;
    n.fontChangeListenerKey_ = Fr(wz, zh.PROPERTYCHANGE, r.redrawText.bind(r)), n.element_ = document.createElement("div");
    var i = n.element_.style;
    i.position = "absolute", i.width = "100%", i.height = "100%", i.zIndex = "0", n.element_.className = mu + " ol-layers";
    var l = r.getViewport();
    return l.insertBefore(n.element_, l.firstChild || null), n.children_ = [], n.renderedVisible_ = !0, n;
  }
  return e.prototype.dispatchRenderEvent = function(r, n) {
    var i = this.getMap();
    if (i.hasListener(r)) {
      var l = new $2(r, void 0, n);
      i.dispatchEvent(l);
    }
  }, e.prototype.disposeInternal = function() {
    $n(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), t.prototype.disposeInternal.call(this);
  }, e.prototype.renderFrame = function(r) {
    if (!r) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(r), this.dispatchRenderEvent(ns.PRECOMPOSE, r);
    var n = r.layerStatesArray.sort(function(A, L) {
      return A.zIndex - L.zIndex;
    }), i = r.viewState;
    this.children_.length = 0;
    for (var l = [], h = null, s = 0, m = n.length; s < m; ++s) {
      var v = n[s];
      r.layerIndex = s;
      var E = v.layer, T = E.getSourceState();
      if (!$g(v, i) || T != "ready" && T != "undefined") {
        E.unrender();
        continue;
      }
      var S = E.render(r, h);
      !S || (S !== h && (this.children_.push(S), h = S), "getDeclutter" in E && l.push(
        E
      ));
    }
    for (var s = l.length - 1; s >= 0; --s)
      l[s].renderDeclutter(r);
    bz(this.element_, this.children_), this.dispatchRenderEvent(ns.POSTCOMPOSE, r), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(r);
  }, e.prototype.forEachLayerAtPixel = function(r, n, i, l, h) {
    for (var s = n.viewState, m = n.layerStatesArray, v = m.length, E = v - 1; E >= 0; --E) {
      var T = m[E], S = T.layer;
      if (S.hasRenderer() && $g(T, s) && h(S)) {
        var A = S.getRenderer(), L = A.getDataAtPixel(r, n, i);
        if (L) {
          var B = l(S, L);
          if (B)
            return B;
        }
      }
    }
  }, e;
}(gz);
const Mz = Sz, ra = {
  ADD: "add",
  REMOVE: "remove"
};
var V2 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), tE = {
  LENGTH: "length"
}, Lm = function(t) {
  V2(e, t);
  function e(r, n, i) {
    var l = t.call(this, r) || this;
    return l.element = n, l.index = i, l;
  }
  return e;
}(Xs), Cz = function(t) {
  V2(e, t);
  function e(r, n) {
    var i = t.call(this) || this;
    i.on, i.once, i.un;
    var l = n || {};
    if (i.unique_ = !!l.unique, i.array_ = r || [], i.unique_)
      for (var h = 0, s = i.array_.length; h < s; ++h)
        i.assertUnique_(i.array_[h], h);
    return i.updateLength_(), i;
  }
  return e.prototype.clear = function() {
    for (; this.getLength() > 0; )
      this.pop();
  }, e.prototype.extend = function(r) {
    for (var n = 0, i = r.length; n < i; ++n)
      this.push(r[n]);
    return this;
  }, e.prototype.forEach = function(r) {
    for (var n = this.array_, i = 0, l = n.length; i < l; ++i)
      r(n[i], i, n);
  }, e.prototype.getArray = function() {
    return this.array_;
  }, e.prototype.item = function(r) {
    return this.array_[r];
  }, e.prototype.getLength = function() {
    return this.get(tE.LENGTH);
  }, e.prototype.insertAt = function(r, n) {
    this.unique_ && this.assertUnique_(n), this.array_.splice(r, 0, n), this.updateLength_(), this.dispatchEvent(new Lm(ra.ADD, n, r));
  }, e.prototype.pop = function() {
    return this.removeAt(this.getLength() - 1);
  }, e.prototype.push = function(r) {
    this.unique_ && this.assertUnique_(r);
    var n = this.getLength();
    return this.insertAt(n, r), this.getLength();
  }, e.prototype.remove = function(r) {
    for (var n = this.array_, i = 0, l = n.length; i < l; ++i)
      if (n[i] === r)
        return this.removeAt(i);
  }, e.prototype.removeAt = function(r) {
    var n = this.array_[r];
    return this.array_.splice(r, 1), this.updateLength_(), this.dispatchEvent(new Lm(ra.REMOVE, n, r)), n;
  }, e.prototype.setAt = function(r, n) {
    var i = this.getLength();
    if (r < i) {
      this.unique_ && this.assertUnique_(n, r);
      var l = this.array_[r];
      this.array_[r] = n, this.dispatchEvent(new Lm(ra.REMOVE, l, r)), this.dispatchEvent(new Lm(ra.ADD, n, r));
    } else {
      for (var h = i; h < r; ++h)
        this.insertAt(h, void 0);
      this.insertAt(r, n);
    }
  }, e.prototype.updateLength_ = function() {
    this.set(tE.LENGTH, this.array_.length);
  }, e.prototype.assertUnique_ = function(r, n) {
    for (var i = 0, l = this.array_.length; i < l; ++i)
      if (this.array_[i] === r && i !== n)
        throw new e2(58);
  }, e;
}(Zs);
const Ia = Cz;
var j2 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Sl = function(t) {
  j2(e, t);
  function e(r, n) {
    var i = t.call(this, r) || this;
    return i.layer = n, i;
  }
  return e;
}(Xs), mv = {
  LAYERS: "layers"
}, Iz = function(t) {
  j2(e, t);
  function e(r) {
    var n = this, i = r || {}, l = In({}, i);
    delete l.layers;
    var h = i.layers;
    return n = t.call(this, l) || this, n.on, n.once, n.un, n.layersListenerKeys_ = [], n.listenerKeys_ = {}, n.addChangeListener(mv.LAYERS, n.handleLayersChanged_), h ? Array.isArray(h) ? h = new Ia(h.slice(), { unique: !0 }) : en(typeof h.getArray == "function", 43) : h = new Ia(void 0, { unique: !0 }), n.setLayers(h), n;
  }
  return e.prototype.handleLayerChange_ = function() {
    this.changed();
  }, e.prototype.handleLayersChanged_ = function() {
    this.layersListenerKeys_.forEach($n), this.layersListenerKeys_.length = 0;
    var r = this.getLayers();
    this.layersListenerKeys_.push(Fr(r, ra.ADD, this.handleLayersAdd_, this), Fr(r, ra.REMOVE, this.handleLayersRemove_, this));
    for (var n in this.listenerKeys_)
      this.listenerKeys_[n].forEach($n);
    Oy(this.listenerKeys_);
    for (var i = r.getArray(), l = 0, h = i.length; l < h; l++) {
      var s = i[l];
      this.registerLayerListeners_(s), this.dispatchEvent(new Sl("addlayer", s));
    }
    this.changed();
  }, e.prototype.registerLayerListeners_ = function(r) {
    var n = [
      Fr(r, zh.PROPERTYCHANGE, this.handleLayerChange_, this),
      Fr(r, _r.CHANGE, this.handleLayerChange_, this)
    ];
    r instanceof e && n.push(Fr(r, "addlayer", this.handleLayerGroupAdd_, this), Fr(r, "removelayer", this.handleLayerGroupRemove_, this)), this.listenerKeys_[So(r)] = n;
  }, e.prototype.handleLayerGroupAdd_ = function(r) {
    this.dispatchEvent(new Sl("addlayer", r.layer));
  }, e.prototype.handleLayerGroupRemove_ = function(r) {
    this.dispatchEvent(new Sl("removelayer", r.layer));
  }, e.prototype.handleLayersAdd_ = function(r) {
    var n = r.element;
    this.registerLayerListeners_(n), this.dispatchEvent(new Sl("addlayer", n)), this.changed();
  }, e.prototype.handleLayersRemove_ = function(r) {
    var n = r.element, i = So(n);
    this.listenerKeys_[i].forEach($n), delete this.listenerKeys_[i], this.dispatchEvent(new Sl("removelayer", n)), this.changed();
  }, e.prototype.getLayers = function() {
    return this.get(mv.LAYERS);
  }, e.prototype.setLayers = function(r) {
    var n = this.getLayers();
    if (n)
      for (var i = n.getArray(), l = 0, h = i.length; l < h; ++l)
        this.dispatchEvent(new Sl("removelayer", i[l]));
    this.set(mv.LAYERS, r);
  }, e.prototype.getLayersArray = function(r) {
    var n = r !== void 0 ? r : [];
    return this.getLayers().forEach(function(i) {
      i.getLayersArray(n);
    }), n;
  }, e.prototype.getLayerStatesArray = function(r) {
    var n = r !== void 0 ? r : [], i = n.length;
    this.getLayers().forEach(function(E) {
      E.getLayerStatesArray(n);
    });
    var l = this.getLayerState(), h = l.zIndex;
    !r && l.zIndex === void 0 && (h = 0);
    for (var s = i, m = n.length; s < m; s++) {
      var v = n[s];
      v.opacity *= l.opacity, v.visible = v.visible && l.visible, v.maxResolution = Math.min(v.maxResolution, l.maxResolution), v.minResolution = Math.max(v.minResolution, l.minResolution), v.minZoom = Math.max(v.minZoom, l.minZoom), v.maxZoom = Math.min(v.maxZoom, l.maxZoom), l.extent !== void 0 && (v.extent !== void 0 ? v.extent = eu(v.extent, l.extent) : v.extent = l.extent), v.zIndex === void 0 && (v.zIndex = h);
    }
    return n;
  }, e.prototype.getSourceState = function() {
    return "ready";
  }, e;
}(U2);
const $y = Iz;
var Pz = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Az = function(t) {
  Pz(e, t);
  function e(r, n, i) {
    var l = t.call(this, r) || this;
    return l.map = n, l.frameState = i !== void 0 ? i : null, l;
  }
  return e;
}(Xs);
const ah = Az;
var Oz = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Rz = function(t) {
  Oz(e, t);
  function e(r, n, i, l, h, s) {
    var m = t.call(this, r, n, h) || this;
    return m.originalEvent = i, m.pixel_ = null, m.coordinate_ = null, m.dragging = l !== void 0 ? l : !1, m.activePointers = s, m;
  }
  return Object.defineProperty(e.prototype, "pixel", {
    get: function() {
      return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
    },
    set: function(r) {
      this.pixel_ = r;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "coordinate", {
    get: function() {
      return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
    },
    set: function(r) {
      this.coordinate_ = r;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.preventDefault = function() {
    t.prototype.preventDefault.call(this), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }, e.prototype.stopPropagation = function() {
    t.prototype.stopPropagation.call(this), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }, e;
}(ah);
const bl = Rz, Xn = {
  SINGLECLICK: "singleclick",
  CLICK: _r.CLICK,
  DBLCLICK: _r.DBLCLICK,
  POINTERDRAG: "pointerdrag",
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, O0 = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
var Lz = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Dz = function(t) {
  Lz(e, t);
  function e(r, n) {
    var i = t.call(this, r) || this;
    i.map_ = r, i.clickTimeoutId_, i.emulateClicks_ = !1, i.dragging_ = !1, i.dragListenerKeys_ = [], i.moveTolerance_ = n === void 0 ? 1 : n, i.down_ = null;
    var l = i.map_.getViewport();
    return i.activePointers_ = [], i.trackedTouches_ = {}, i.element_ = l, i.pointerdownListenerKey_ = Fr(l, O0.POINTERDOWN, i.handlePointerDown_, i), i.originalPointerMoveEvent_, i.relayedListenerKey_ = Fr(l, O0.POINTERMOVE, i.relayMoveEvent_, i), i.boundHandleTouchMove_ = i.handleTouchMove_.bind(i), i.element_.addEventListener(_r.TOUCHMOVE, i.boundHandleTouchMove_, k2 ? { passive: !1 } : !1), i;
  }
  return e.prototype.emulateClick_ = function(r) {
    var n = new bl(Xn.CLICK, this.map_, r);
    this.dispatchEvent(n), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, n = new bl(Xn.DBLCLICK, this.map_, r), this.dispatchEvent(n)) : this.clickTimeoutId_ = setTimeout(
      function() {
        this.clickTimeoutId_ = void 0;
        var i = new bl(Xn.SINGLECLICK, this.map_, r);
        this.dispatchEvent(i);
      }.bind(this),
      250
    );
  }, e.prototype.updateActivePointers_ = function(r) {
    var n = r, i = n.pointerId;
    if (n.type == Xn.POINTERUP || n.type == Xn.POINTERCANCEL) {
      delete this.trackedTouches_[i];
      for (var l in this.trackedTouches_)
        if (this.trackedTouches_[l].target !== n.target) {
          delete this.trackedTouches_[l];
          break;
        }
    } else
      (n.type == Xn.POINTERDOWN || n.type == Xn.POINTERMOVE) && (this.trackedTouches_[i] = n);
    this.activePointers_ = fD(this.trackedTouches_);
  }, e.prototype.handlePointerUp_ = function(r) {
    this.updateActivePointers_(r);
    var n = new bl(Xn.POINTERUP, this.map_, r, void 0, void 0, this.activePointers_);
    this.dispatchEvent(n), this.emulateClicks_ && !n.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(r) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach($n), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }, e.prototype.isMouseActionButton_ = function(r) {
    return r.button === 0;
  }, e.prototype.handlePointerDown_ = function(r) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(r);
    var n = new bl(Xn.POINTERDOWN, this.map_, r, void 0, void 0, this.activePointers_);
    this.dispatchEvent(n), this.down_ = {};
    for (var i in r) {
      var l = r[i];
      this.down_[i] = typeof l == "function" ? Nd : l;
    }
    if (this.dragListenerKeys_.length === 0) {
      var h = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        Fr(h, Xn.POINTERMOVE, this.handlePointerMove_, this),
        Fr(h, Xn.POINTERUP, this.handlePointerUp_, this),
        Fr(this.element_, Xn.POINTERCANCEL, this.handlePointerUp_, this)
      ), this.element_.getRootNode && this.element_.getRootNode() !== h && this.dragListenerKeys_.push(Fr(this.element_.getRootNode(), Xn.POINTERUP, this.handlePointerUp_, this));
    }
  }, e.prototype.handlePointerMove_ = function(r) {
    if (this.isMoving_(r)) {
      this.updateActivePointers_(r), this.dragging_ = !0;
      var n = new bl(Xn.POINTERDRAG, this.map_, r, this.dragging_, void 0, this.activePointers_);
      this.dispatchEvent(n);
    }
  }, e.prototype.relayMoveEvent_ = function(r) {
    this.originalPointerMoveEvent_ = r;
    var n = !!(this.down_ && this.isMoving_(r));
    this.dispatchEvent(new bl(Xn.POINTERMOVE, this.map_, r, n));
  }, e.prototype.handleTouchMove_ = function(r) {
    var n = this.originalPointerMoveEvent_;
    (!n || n.defaultPrevented) && (typeof r.cancelable != "boolean" || r.cancelable === !0) && r.preventDefault();
  }, e.prototype.isMoving_ = function(r) {
    return this.dragging_ || Math.abs(r.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(r.clientY - this.down_.clientY) > this.moveTolerance_;
  }, e.prototype.disposeInternal = function() {
    this.relayedListenerKey_ && ($n(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(_r.TOUCHMOVE, this.boundHandleTouchMove_), this.pointerdownListenerKey_ && ($n(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach($n), this.dragListenerKeys_.length = 0, this.element_ = null, t.prototype.disposeInternal.call(this);
  }, e;
}(ep);
const kz = Dz, wl = {
  POSTRENDER: "postrender",
  MOVESTART: "movestart",
  MOVEEND: "moveend",
  LOADSTART: "loadstart",
  LOADEND: "loadend"
}, Mi = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};
var Gg = 1 / 0, Nz = function() {
  function t(e, r) {
    this.priorityFunction_ = e, this.keyFunction_ = r, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  return t.prototype.clear = function() {
    this.elements_.length = 0, this.priorities_.length = 0, Oy(this.queuedElements_);
  }, t.prototype.dequeue = function() {
    var e = this.elements_, r = this.priorities_, n = e[0];
    e.length == 1 ? (e.length = 0, r.length = 0) : (e[0] = e.pop(), r[0] = r.pop(), this.siftUp_(0));
    var i = this.keyFunction_(n);
    return delete this.queuedElements_[i], n;
  }, t.prototype.enqueue = function(e) {
    en(!(this.keyFunction_(e) in this.queuedElements_), 31);
    var r = this.priorityFunction_(e);
    return r != Gg ? (this.elements_.push(e), this.priorities_.push(r), this.queuedElements_[this.keyFunction_(e)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }, t.prototype.getCount = function() {
    return this.elements_.length;
  }, t.prototype.getLeftChildIndex_ = function(e) {
    return e * 2 + 1;
  }, t.prototype.getRightChildIndex_ = function(e) {
    return e * 2 + 2;
  }, t.prototype.getParentIndex_ = function(e) {
    return e - 1 >> 1;
  }, t.prototype.heapify_ = function() {
    var e;
    for (e = (this.elements_.length >> 1) - 1; e >= 0; e--)
      this.siftUp_(e);
  }, t.prototype.isEmpty = function() {
    return this.elements_.length === 0;
  }, t.prototype.isKeyQueued = function(e) {
    return e in this.queuedElements_;
  }, t.prototype.isQueued = function(e) {
    return this.isKeyQueued(this.keyFunction_(e));
  }, t.prototype.siftUp_ = function(e) {
    for (var r = this.elements_, n = this.priorities_, i = r.length, l = r[e], h = n[e], s = e; e < i >> 1; ) {
      var m = this.getLeftChildIndex_(e), v = this.getRightChildIndex_(e), E = v < i && n[v] < n[m] ? v : m;
      r[e] = r[E], n[e] = n[E], e = E;
    }
    r[e] = l, n[e] = h, this.siftDown_(s, e);
  }, t.prototype.siftDown_ = function(e, r) {
    for (var n = this.elements_, i = this.priorities_, l = n[r], h = i[r]; r > e; ) {
      var s = this.getParentIndex_(r);
      if (i[s] > h)
        n[r] = n[s], i[r] = i[s], r = s;
      else
        break;
    }
    n[r] = l, i[r] = h;
  }, t.prototype.reprioritize = function() {
    var e = this.priorityFunction_, r = this.elements_, n = this.priorities_, i = 0, l = r.length, h, s, m;
    for (s = 0; s < l; ++s)
      h = r[s], m = e(h), m == Gg ? delete this.queuedElements_[this.keyFunction_(h)] : (n[i] = m, r[i++] = h);
    r.length = i, n.length = i, this.heapify_();
  }, t;
}();
const Fz = Nz, tr = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
var zz = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Bz = function(t) {
  zz(e, t);
  function e(r, n) {
    var i = t.call(
      this,
      function(l) {
        return r.apply(null, l);
      },
      function(l) {
        return l[0].getKey();
      }
    ) || this;
    return i.boundHandleTileChange_ = i.handleTileChange.bind(i), i.tileChangeCallback_ = n, i.tilesLoading_ = 0, i.tilesLoadingKeys_ = {}, i;
  }
  return e.prototype.enqueue = function(r) {
    var n = t.prototype.enqueue.call(this, r);
    if (n) {
      var i = r[0];
      i.addEventListener(_r.CHANGE, this.boundHandleTileChange_);
    }
    return n;
  }, e.prototype.getTilesLoading = function() {
    return this.tilesLoading_;
  }, e.prototype.handleTileChange = function(r) {
    var n = r.target, i = n.getState();
    if (i === tr.LOADED || i === tr.ERROR || i === tr.EMPTY) {
      n.removeEventListener(_r.CHANGE, this.boundHandleTileChange_);
      var l = n.getKey();
      l in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[l], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }, e.prototype.loadMoreTiles = function(r, n) {
    for (var i = 0, l, h, s; this.tilesLoading_ < r && i < n && this.getCount() > 0; )
      h = this.dequeue()[0], s = h.getKey(), l = h.getState(), l === tr.IDLE && !(s in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[s] = !0, ++this.tilesLoading_, ++i, h.load());
  }, e;
}(Fz);
const Uz = Bz;
function $z(t, e, r, n, i) {
  if (!t || !(r in t.wantedTiles) || !t.wantedTiles[r][e.getKey()])
    return Gg;
  var l = t.viewState.center, h = n[0] - l[0], s = n[1] - l[1];
  return 65536 * Math.log(i) + Math.sqrt(h * h + s * s) / i;
}
const To = {
  ANIMATING: 0,
  INTERACTING: 1
}, ya = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};
var Vz = 42, Lx = 256;
function rE(t, e, r) {
  return function(n, i, l, h, s) {
    if (!!n) {
      if (!i && !e)
        return n;
      var m = e ? 0 : l[0] * i, v = e ? 0 : l[1] * i, E = s ? s[0] : 0, T = s ? s[1] : 0, S = t[0] + m / 2 + E, A = t[2] - m / 2 + E, L = t[1] + v / 2 + T, B = t[3] - v / 2 + T;
      S > A && (S = (A + S) / 2, A = S), L > B && (L = (B + L) / 2, B = L);
      var j = hi(n[0], S, A), q = hi(n[1], L, B);
      if (h && r && i) {
        var H = 30 * i;
        j += -H * Math.log(1 + Math.max(0, S - n[0]) / H) + H * Math.log(1 + Math.max(0, n[0] - A) / H), q += -H * Math.log(1 + Math.max(0, L - n[1]) / H) + H * Math.log(1 + Math.max(0, n[1] - B) / H);
      }
      return [j, q];
    }
  };
}
function jz(t) {
  return t;
}
function Dx(t, e, r, n) {
  var i = Cn(e) / r[0], l = Pi(e) / r[1];
  return n ? Math.min(t, Math.max(i, l)) : Math.min(t, Math.min(i, l));
}
function kx(t, e, r) {
  var n = Math.min(t, e), i = 50;
  return n *= Math.log(1 + i * Math.max(0, t / e - 1)) / i + 1, r && (n = Math.max(n, r), n /= Math.log(1 + i * Math.max(0, r / t - 1)) / i + 1), hi(n, r / 2, e * 2);
}
function Gz(t, e, r, n) {
  return function(i, l, h, s) {
    if (i !== void 0) {
      var m = t[0], v = t[t.length - 1], E = r ? Dx(m, r, h, n) : m;
      if (s) {
        var T = e !== void 0 ? e : !0;
        return T ? kx(i, E, v) : hi(i, v, E);
      }
      var S = Math.min(E, i), A = Math.floor(By(t, S, l));
      return t[A] > E && A < t.length - 1 ? t[A + 1] : t[A];
    } else
      return;
  };
}
function qz(t, e, r, n, i, l) {
  return function(h, s, m, v) {
    if (h !== void 0) {
      var E = i ? Dx(e, i, m, l) : e, T = r !== void 0 ? r : 0;
      if (v) {
        var S = n !== void 0 ? n : !0;
        return S ? kx(h, E, T) : hi(h, T, E);
      }
      var A = 1e-9, L = Math.ceil(Math.log(e / E) / Math.log(t) - A), B = -s * (0.5 - A) + 0.5, j = Math.min(E, h), q = Math.floor(Math.log(e / j) / Math.log(t) + B), H = Math.max(L, q), ne = e / Math.pow(t, H);
      return hi(ne, T, E);
    } else
      return;
  };
}
function nE(t, e, r, n, i) {
  return function(l, h, s, m) {
    if (l !== void 0) {
      var v = n ? Dx(t, n, s, i) : t, E = r !== void 0 ? r : !0;
      return !E || !m ? hi(l, e, v) : kx(l, v, e);
    } else
      return;
  };
}
function Nx(t) {
  if (t !== void 0)
    return 0;
}
function iE(t) {
  if (t !== void 0)
    return t;
}
function Wz(t) {
  var e = 2 * Math.PI / t;
  return function(r, n) {
    if (n)
      return r;
    if (r !== void 0)
      return r = Math.floor(r / e + 0.5) * e, r;
  };
}
function Xz(t) {
  var e = t || cg(5);
  return function(r, n) {
    if (n)
      return r;
    if (r !== void 0)
      return Math.abs(r) <= e ? 0 : r;
  };
}
function G2(t) {
  return Math.pow(t, 3);
}
function Gh(t) {
  return 1 - G2(1 - t);
}
function Zz(t) {
  return 3 * t * t - 2 * t * t * t;
}
function Hz(t) {
  return t;
}
const jo = {
  XY: "XY",
  XYZ: "XYZ",
  XYM: "XYM",
  XYZM: "XYZM"
};
function Kz(t, e, r, n, i, l) {
  for (var h = l || [], s = 0, m = e; m < r; m += n) {
    var v = t[m], E = t[m + 1];
    h[s++] = i[0] * v + i[2] * E + i[4], h[s++] = i[1] * v + i[3] * E + i[5];
  }
  return l && h.length != s && (h.length = s), h;
}
function Yz(t, e, r, n, i, l, h) {
  for (var s = h || [], m = Math.cos(i), v = Math.sin(i), E = l[0], T = l[1], S = 0, A = e; A < r; A += n) {
    var L = t[A] - E, B = t[A + 1] - T;
    s[S++] = E + L * m - B * v, s[S++] = T + L * v + B * m;
    for (var j = A + 2; j < A + n; ++j)
      s[S++] = t[j];
  }
  return h && s.length != S && (s.length = S), s;
}
function Jz(t, e, r, n, i, l, h, s) {
  for (var m = s || [], v = h[0], E = h[1], T = 0, S = e; S < r; S += n) {
    var A = t[S] - v, L = t[S + 1] - E;
    m[T++] = v + i * A, m[T++] = E + l * L;
    for (var B = S + 2; B < S + n; ++B)
      m[T++] = t[B];
  }
  return s && m.length != T && (m.length = T), m;
}
function Qz(t, e, r, n, i, l, h) {
  for (var s = h || [], m = 0, v = e; v < r; v += n) {
    s[m++] = t[v] + i, s[m++] = t[v + 1] + l;
    for (var E = v + 2; E < v + n; ++E)
      s[m++] = t[E];
  }
  return h && s.length != m && (s.length = m), s;
}
var e4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), oE = Ih(), t4 = function(t) {
  e4(e, t);
  function e() {
    var r = t.call(this) || this;
    return r.extent_ = pu(), r.extentRevision_ = -1, r.simplifiedGeometryMaxMinSquaredTolerance = 0, r.simplifiedGeometryRevision = 0, r.simplifyTransformedInternal = j5(function(n, i, l) {
      if (!l)
        return this.getSimplifiedGeometry(i);
      var h = this.clone();
      return h.applyTransform(l), h.getSimplifiedGeometry(i);
    }), r;
  }
  return e.prototype.simplifyTransformed = function(r, n) {
    return this.simplifyTransformedInternal(this.getRevision(), r, n);
  }, e.prototype.clone = function() {
    return En();
  }, e.prototype.closestPointXY = function(r, n, i, l) {
    return En();
  }, e.prototype.containsXY = function(r, n) {
    var i = this.getClosestPoint([r, n]);
    return i[0] === r && i[1] === n;
  }, e.prototype.getClosestPoint = function(r, n) {
    var i = n || [NaN, NaN];
    return this.closestPointXY(r[0], r[1], i, 1 / 0), i;
  }, e.prototype.intersectsCoordinate = function(r) {
    return this.containsXY(r[0], r[1]);
  }, e.prototype.computeExtent = function(r) {
    return En();
  }, e.prototype.getExtent = function(r) {
    if (this.extentRevision_ != this.getRevision()) {
      var n = this.computeExtent(this.extent_);
      (isNaN(n[0]) || isNaN(n[1])) && Ry(n), this.extentRevision_ = this.getRevision();
    }
    return SD(this.extent_, r);
  }, e.prototype.rotate = function(r, n) {
    En();
  }, e.prototype.scale = function(r, n, i) {
    En();
  }, e.prototype.simplify = function(r) {
    return this.getSimplifiedGeometry(r * r);
  }, e.prototype.getSimplifiedGeometry = function(r) {
    return En();
  }, e.prototype.getType = function() {
    return En();
  }, e.prototype.applyTransform = function(r) {
    En();
  }, e.prototype.intersectsExtent = function(r) {
    return En();
  }, e.prototype.translate = function(r, n) {
    En();
  }, e.prototype.transform = function(r, n) {
    var i = fi(r), l = i.getUnits() == Fs.TILE_PIXELS ? function(h, s, m) {
      var v = i.getExtent(), E = i.getWorldExtent(), T = Pi(E) / Pi(v);
      return cu(oE, E[0], E[3], T, -T, 0, 0, 0), Kz(h, 0, h.length, m, oE, s), kh(i, n)(h, s, m);
    } : kh(i, n);
    return this.applyTransform(l), this;
  }, e;
}(Zs);
const r4 = t4;
var n4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), i4 = function(t) {
  n4(e, t);
  function e() {
    var r = t.call(this) || this;
    return r.layout = jo.XY, r.stride = 2, r.flatCoordinates = null, r;
  }
  return e.prototype.computeExtent = function(r) {
    return bD(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, r);
  }, e.prototype.getCoordinates = function() {
    return En();
  }, e.prototype.getFirstCoordinate = function() {
    return this.flatCoordinates.slice(0, this.stride);
  }, e.prototype.getFlatCoordinates = function() {
    return this.flatCoordinates;
  }, e.prototype.getLastCoordinate = function() {
    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
  }, e.prototype.getLayout = function() {
    return this.layout;
  }, e.prototype.getSimplifiedGeometry = function(r) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), r < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && r <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    var n = this.getSimplifiedGeometryInternal(r), i = n.getFlatCoordinates();
    return i.length < this.flatCoordinates.length ? n : (this.simplifiedGeometryMaxMinSquaredTolerance = r, this);
  }, e.prototype.getSimplifiedGeometryInternal = function(r) {
    return this;
  }, e.prototype.getStride = function() {
    return this.stride;
  }, e.prototype.setFlatCoordinates = function(r, n) {
    this.stride = aE(r), this.layout = r, this.flatCoordinates = n;
  }, e.prototype.setCoordinates = function(r, n) {
    En();
  }, e.prototype.setLayout = function(r, n, i) {
    var l;
    if (r)
      l = aE(r);
    else {
      for (var h = 0; h < i; ++h)
        if (n.length === 0) {
          this.layout = jo.XY, this.stride = 2;
          return;
        } else
          n = n[0];
      l = n.length, r = o4(l);
    }
    this.layout = r, this.stride = l;
  }, e.prototype.applyTransform = function(r) {
    this.flatCoordinates && (r(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
  }, e.prototype.rotate = function(r, n) {
    var i = this.getFlatCoordinates();
    if (i) {
      var l = this.getStride();
      Yz(i, 0, i.length, l, r, n, i), this.changed();
    }
  }, e.prototype.scale = function(r, n, i) {
    var l = n;
    l === void 0 && (l = r);
    var h = i;
    h || (h = au(this.getExtent()));
    var s = this.getFlatCoordinates();
    if (s) {
      var m = this.getStride();
      Jz(s, 0, s.length, m, r, l, h, s), this.changed();
    }
  }, e.prototype.translate = function(r, n) {
    var i = this.getFlatCoordinates();
    if (i) {
      var l = this.getStride();
      Qz(i, 0, i.length, l, r, n, i), this.changed();
    }
  }, e;
}(r4);
function o4(t) {
  var e;
  return t == 2 ? e = jo.XY : t == 3 ? e = jo.XYZ : t == 4 && (e = jo.XYZM), e;
}
function aE(t) {
  var e;
  return t == jo.XY ? e = 2 : t == jo.XYZ || t == jo.XYM ? e = 3 : t == jo.XYZM && (e = 4), e;
}
const Fx = i4;
function sE(t, e, r, n, i, l, h) {
  var s = t[e], m = t[e + 1], v = t[r] - s, E = t[r + 1] - m, T;
  if (v === 0 && E === 0)
    T = e;
  else {
    var S = ((i - s) * v + (l - m) * E) / (v * v + E * E);
    if (S > 1)
      T = r;
    else if (S > 0) {
      for (var A = 0; A < n; ++A)
        h[A] = tD(t[e + A], t[r + A], S);
      h.length = n;
      return;
    } else
      T = e;
  }
  for (var A = 0; A < n; ++A)
    h[A] = t[T + A];
  h.length = n;
}
function q2(t, e, r, n, i) {
  var l = t[e], h = t[e + 1];
  for (e += n; e < r; e += n) {
    var s = t[e], m = t[e + 1], v = Eh(l, h, s, m);
    v > i && (i = v), l = s, h = m;
  }
  return i;
}
function a4(t, e, r, n, i) {
  for (var l = 0, h = r.length; l < h; ++l) {
    var s = r[l];
    i = q2(t, e, s, n, i), e = s;
  }
  return i;
}
function W2(t, e, r, n, i, l, h, s, m, v, E) {
  if (e == r)
    return v;
  var T, S;
  if (i === 0)
    if (S = Eh(h, s, t[e], t[e + 1]), S < v) {
      for (T = 0; T < n; ++T)
        m[T] = t[e + T];
      return m.length = n, S;
    } else
      return v;
  for (var A = E || [NaN, NaN], L = e + n; L < r; )
    if (sE(t, L - n, L, n, h, s, A), S = Eh(h, s, A[0], A[1]), S < v) {
      for (v = S, T = 0; T < n; ++T)
        m[T] = A[T];
      m.length = n, L += n;
    } else
      L += n * Math.max((Math.sqrt(S) - Math.sqrt(v)) / i | 0, 1);
  if (l && (sE(t, r - n, e, n, h, s, A), S = Eh(h, s, A[0], A[1]), S < v)) {
    for (v = S, T = 0; T < n; ++T)
      m[T] = A[T];
    m.length = n;
  }
  return v;
}
function s4(t, e, r, n, i, l, h, s, m, v, E) {
  for (var T = E || [NaN, NaN], S = 0, A = r.length; S < A; ++S) {
    var L = r[S];
    v = W2(t, e, L, n, i, l, h, s, m, v, T), e = L;
  }
  return v;
}
function l4(t, e, r, n) {
  for (var i = 0, l = r.length; i < l; ++i)
    t[e++] = r[i];
  return e;
}
function X2(t, e, r, n) {
  for (var i = 0, l = r.length; i < l; ++i)
    for (var h = r[i], s = 0; s < n; ++s)
      t[e++] = h[s];
  return e;
}
function c4(t, e, r, n, i) {
  for (var l = i || [], h = 0, s = 0, m = r.length; s < m; ++s) {
    var v = X2(t, e, r[s], n);
    l[h++] = v, e = v;
  }
  return l.length = h, l;
}
function u4(t, e, r, n, i, l, h) {
  var s = (r - e) / n;
  if (s < 3) {
    for (; e < r; e += n)
      l[h++] = t[e], l[h++] = t[e + 1];
    return h;
  }
  var m = new Array(s);
  m[0] = 1, m[s - 1] = 1;
  for (var v = [e, r - n], E = 0; v.length > 0; ) {
    for (var T = v.pop(), S = v.pop(), A = 0, L = t[S], B = t[S + 1], j = t[T], q = t[T + 1], H = S + n; H < T; H += n) {
      var ne = t[H], ee = t[H + 1], he = JL(ne, ee, L, B, j, q);
      he > A && (E = H, A = he);
    }
    A > i && (m[(E - e) / n] = 1, S + n < E && v.push(S, E), E + n < T && v.push(E, T));
  }
  for (var H = 0; H < s; ++H)
    m[H] && (l[h++] = t[e + H * n], l[h++] = t[e + H * n + 1]);
  return h;
}
function Yu(t, e) {
  return e * Math.round(t / e);
}
function h4(t, e, r, n, i, l, h) {
  if (e == r)
    return h;
  var s = Yu(t[e], i), m = Yu(t[e + 1], i);
  e += n, l[h++] = s, l[h++] = m;
  var v, E;
  do
    if (v = Yu(t[e], i), E = Yu(t[e + 1], i), e += n, e == r)
      return l[h++] = v, l[h++] = E, h;
  while (v == s && E == m);
  for (; e < r; ) {
    var T = Yu(t[e], i), S = Yu(t[e + 1], i);
    if (e += n, !(T == v && S == E)) {
      var A = v - s, L = E - m, B = T - s, j = S - m;
      if (A * j == L * B && (A < 0 && B < A || A == B || A > 0 && B > A) && (L < 0 && j < L || L == j || L > 0 && j > L)) {
        v = T, E = S;
        continue;
      }
      l[h++] = v, l[h++] = E, s = v, m = E, v = T, E = S;
    }
  }
  return l[h++] = v, l[h++] = E, h;
}
function f4(t, e, r, n, i, l, h, s) {
  for (var m = 0, v = r.length; m < v; ++m) {
    var E = r[m];
    h = h4(t, e, E, n, i, l, h), s.push(h), e = E;
  }
  return h;
}
function Z2(t, e, r, n, i) {
  for (var l = i !== void 0 ? i : [], h = 0, s = e; s < r; s += n)
    l[h++] = t.slice(s, s + n);
  return l.length = h, l;
}
function d4(t, e, r, n, i) {
  for (var l = i !== void 0 ? i : [], h = 0, s = 0, m = r.length; s < m; ++s) {
    var v = r[s];
    l[h++] = Z2(t, e, v, n, l[h]), e = v;
  }
  return l.length = h, l;
}
function H2(t, e, r, n) {
  for (var i = 0, l = t[r - n], h = t[r - n + 1]; e < r; e += n) {
    var s = t[e], m = t[e + 1];
    i += h * s - l * m, l = s, h = m;
  }
  return i / 2;
}
function p4(t, e, r, n) {
  for (var i = 0, l = 0, h = r.length; l < h; ++l) {
    var s = r[l];
    i += H2(t, e, s, n), e = s;
  }
  return i;
}
var m4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), g4 = function(t) {
  m4(e, t);
  function e(r, n) {
    var i = t.call(this) || this;
    return i.maxDelta_ = -1, i.maxDeltaRevision_ = -1, n !== void 0 && !Array.isArray(r[0]) ? i.setFlatCoordinates(
      n,
      r
    ) : i.setCoordinates(
      r,
      n
    ), i;
  }
  return e.prototype.clone = function() {
    return new e(this.flatCoordinates.slice(), this.layout);
  }, e.prototype.closestPointXY = function(r, n, i, l) {
    return l < t2(this.getExtent(), r, n) ? l : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(q2(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), W2(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !0, r, n, i, l));
  }, e.prototype.getArea = function() {
    return H2(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  }, e.prototype.getCoordinates = function() {
    return Z2(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  }, e.prototype.getSimplifiedGeometryInternal = function(r) {
    var n = [];
    return n.length = u4(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, r, n, 0), new e(n, jo.XY);
  }, e.prototype.getType = function() {
    return "LinearRing";
  }, e.prototype.intersectsExtent = function(r) {
    return !1;
  }, e.prototype.setCoordinates = function(r, n) {
    this.setLayout(n, r, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = X2(this.flatCoordinates, 0, r, this.stride), this.changed();
  }, e;
}(Fx);
const lE = g4;
var y4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), _4 = function(t) {
  y4(e, t);
  function e(r, n) {
    var i = t.call(this) || this;
    return i.setCoordinates(r, n), i;
  }
  return e.prototype.clone = function() {
    var r = new e(this.flatCoordinates.slice(), this.layout);
    return r.applyProperties(this), r;
  }, e.prototype.closestPointXY = function(r, n, i, l) {
    var h = this.flatCoordinates, s = Eh(r, n, h[0], h[1]);
    if (s < l) {
      for (var m = this.stride, v = 0; v < m; ++v)
        i[v] = h[v];
      return i.length = m, s;
    } else
      return l;
  }, e.prototype.getCoordinates = function() {
    return this.flatCoordinates ? this.flatCoordinates.slice() : [];
  }, e.prototype.computeExtent = function(r) {
    return xD(this.flatCoordinates, r);
  }, e.prototype.getType = function() {
    return "Point";
  }, e.prototype.intersectsExtent = function(r) {
    return r2(r, this.flatCoordinates[0], this.flatCoordinates[1]);
  }, e.prototype.setCoordinates = function(r, n) {
    this.setLayout(n, r, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = l4(this.flatCoordinates, 0, r, this.stride), this.changed();
  }, e;
}(Fx);
const v4 = _4;
function x4(t, e, r, n, i) {
  var l = i2(
    i,
    function(h) {
      return !Xc(t, e, r, n, h[0], h[1]);
    }
  );
  return !l;
}
function Xc(t, e, r, n, i, l) {
  for (var h = 0, s = t[r - n], m = t[r - n + 1]; e < r; e += n) {
    var v = t[e], E = t[e + 1];
    m <= l ? E > l && (v - s) * (l - m) - (i - s) * (E - m) > 0 && h++ : E <= l && (v - s) * (l - m) - (i - s) * (E - m) < 0 && h--, s = v, m = E;
  }
  return h !== 0;
}
function K2(t, e, r, n, i, l) {
  if (r.length === 0 || !Xc(t, e, r[0], n, i, l))
    return !1;
  for (var h = 1, s = r.length; h < s; ++h)
    if (Xc(t, r[h - 1], r[h], n, i, l))
      return !1;
  return !0;
}
function b4(t, e, r, n, i, l, h) {
  for (var s, m, v, E, T, S, A, L = i[l + 1], B = [], j = 0, q = r.length; j < q; ++j) {
    var H = r[j];
    for (E = t[H - n], S = t[H - n + 1], s = e; s < H; s += n)
      T = t[s], A = t[s + 1], (L <= S && A <= L || S <= L && L <= A) && (v = (L - S) / (A - S) * (T - E) + E, B.push(v)), E = T, S = A;
  }
  var ne = NaN, ee = -1 / 0;
  for (B.sort(Ax), E = B[0], s = 1, m = B.length; s < m; ++s) {
    T = B[s];
    var he = Math.abs(T - E);
    he > ee && (v = (E + T) / 2, K2(t, e, r, n, v, L) && (ne = v, ee = he)), E = T;
  }
  return isNaN(ne) && (ne = i[l]), h ? (h.push(ne, L, ee), h) : [ne, L, ee];
}
function w4(t, e, r, n, i) {
  var l;
  for (e += n; e < r; e += n)
    if (l = i(t.slice(e - n, e), t.slice(e, e + n)), l)
      return l;
  return !1;
}
function Y2(t, e, r, n, i) {
  var l = n2(pu(), t, e, r, n);
  return Zd(i, l) ? yx(i, l) || l[0] >= i[0] && l[2] <= i[2] || l[1] >= i[1] && l[3] <= i[3] ? !0 : w4(
    t,
    e,
    r,
    n,
    function(h, s) {
      return MD(i, h, s);
    }
  ) : !1;
}
function J2(t, e, r, n, i) {
  return !!(Y2(t, e, r, n, i) || Xc(t, e, r, n, i[0], i[1]) || Xc(t, e, r, n, i[0], i[3]) || Xc(t, e, r, n, i[2], i[1]) || Xc(t, e, r, n, i[2], i[3]));
}
function E4(t, e, r, n, i) {
  if (!J2(t, e, r[0], n, i))
    return !1;
  if (r.length === 1)
    return !0;
  for (var l = 1, h = r.length; l < h; ++l)
    if (x4(t, r[l - 1], r[l], n, i) && !Y2(t, r[l - 1], r[l], n, i))
      return !1;
  return !0;
}
function T4(t, e, r, n) {
  for (; e < r - n; ) {
    for (var i = 0; i < n; ++i) {
      var l = t[e + i];
      t[e + i] = t[r - n + i], t[r - n + i] = l;
    }
    e += n, r -= n;
  }
}
function Q2(t, e, r, n) {
  for (var i = 0, l = t[r - n], h = t[r - n + 1]; e < r; e += n) {
    var s = t[e], m = t[e + 1];
    i += (s - l) * (m + h), l = s, h = m;
  }
  return i === 0 ? void 0 : i > 0;
}
function S4(t, e, r, n, i) {
  for (var l = i !== void 0 ? i : !1, h = 0, s = r.length; h < s; ++h) {
    var m = r[h], v = Q2(t, e, m, n);
    if (h === 0) {
      if (l && v || !l && !v)
        return !1;
    } else if (l && !v || !l && v)
      return !1;
    e = m;
  }
  return !0;
}
function cE(t, e, r, n, i) {
  for (var l = i !== void 0 ? i : !1, h = 0, s = r.length; h < s; ++h) {
    var m = r[h], v = Q2(t, e, m, n), E = h === 0 ? l && v || !l && !v : l && !v || !l && v;
    E && T4(t, e, m, n), e = m;
  }
  return e;
}
var M4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), eM = function(t) {
  M4(e, t);
  function e(r, n, i) {
    var l = t.call(this) || this;
    return l.ends_ = [], l.flatInteriorPointRevision_ = -1, l.flatInteriorPoint_ = null, l.maxDelta_ = -1, l.maxDeltaRevision_ = -1, l.orientedRevision_ = -1, l.orientedFlatCoordinates_ = null, n !== void 0 && i ? (l.setFlatCoordinates(
      n,
      r
    ), l.ends_ = i) : l.setCoordinates(
      r,
      n
    ), l;
  }
  return e.prototype.appendLinearRing = function(r) {
    this.flatCoordinates ? $5(this.flatCoordinates, r.getFlatCoordinates()) : this.flatCoordinates = r.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }, e.prototype.clone = function() {
    var r = new e(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
    return r.applyProperties(this), r;
  }, e.prototype.closestPointXY = function(r, n, i, l) {
    return l < t2(this.getExtent(), r, n) ? l : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(a4(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), s4(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !0, r, n, i, l));
  }, e.prototype.containsXY = function(r, n) {
    return K2(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, r, n);
  }, e.prototype.getArea = function() {
    return p4(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
  }, e.prototype.getCoordinates = function(r) {
    var n;
    return r !== void 0 ? (n = this.getOrientedFlatCoordinates().slice(), cE(n, 0, this.ends_, this.stride, r)) : n = this.flatCoordinates, d4(n, 0, this.ends_, this.stride);
  }, e.prototype.getEnds = function() {
    return this.ends_;
  }, e.prototype.getFlatInteriorPoint = function() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      var r = au(this.getExtent());
      this.flatInteriorPoint_ = b4(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, r, 0), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  }, e.prototype.getInteriorPoint = function() {
    return new v4(this.getFlatInteriorPoint(), jo.XYM);
  }, e.prototype.getLinearRingCount = function() {
    return this.ends_.length;
  }, e.prototype.getLinearRing = function(r) {
    return r < 0 || this.ends_.length <= r ? null : new lE(this.flatCoordinates.slice(r === 0 ? 0 : this.ends_[r - 1], this.ends_[r]), this.layout);
  }, e.prototype.getLinearRings = function() {
    for (var r = this.layout, n = this.flatCoordinates, i = this.ends_, l = [], h = 0, s = 0, m = i.length; s < m; ++s) {
      var v = i[s], E = new lE(n.slice(h, v), r);
      l.push(E), h = v;
    }
    return l;
  }, e.prototype.getOrientedFlatCoordinates = function() {
    if (this.orientedRevision_ != this.getRevision()) {
      var r = this.flatCoordinates;
      S4(r, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = r : (this.orientedFlatCoordinates_ = r.slice(), this.orientedFlatCoordinates_.length = cE(this.orientedFlatCoordinates_, 0, this.ends_, this.stride)), this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }, e.prototype.getSimplifiedGeometryInternal = function(r) {
    var n = [], i = [];
    return n.length = f4(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(r), n, 0, i), new e(n, jo.XY, i);
  }, e.prototype.getType = function() {
    return "Polygon";
  }, e.prototype.intersectsExtent = function(r) {
    return E4(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, r);
  }, e.prototype.setCoordinates = function(r, n) {
    this.setLayout(n, r, 2), this.flatCoordinates || (this.flatCoordinates = []);
    var i = c4(this.flatCoordinates, 0, r, this.stride, this.ends_);
    this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
  }, e;
}(Fx);
function R0(t) {
  var e = t[0], r = t[1], n = t[2], i = t[3], l = [
    e,
    r,
    e,
    i,
    n,
    i,
    n,
    r,
    e,
    r
  ];
  return new eM(l, jo.XY, [
    l.length
  ]);
}
var C4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), gv = 0, I4 = function(t) {
  C4(e, t);
  function e(r) {
    var n = t.call(this) || this;
    n.on, n.once, n.un;
    var i = In({}, r);
    return n.hints_ = [0, 0], n.animations_ = [], n.updateAnimationKey_, n.projection_ = xx(i.projection, "EPSG:3857"), n.viewportSize_ = [100, 100], n.targetCenter_ = null, n.targetResolution_, n.targetRotation_, n.nextCenter_ = null, n.nextResolution_, n.nextRotation_, n.cancelAnchor_ = void 0, i.projection && LD(), i.center && (i.center = Ds(i.center, n.projection_)), i.extent && (i.extent = Ll(i.extent, n.projection_)), n.applyOptions_(i), n;
  }
  return e.prototype.applyOptions_ = function(r) {
    var n = In({}, r);
    for (var i in ya)
      delete n[i];
    this.setProperties(n, !0);
    var l = A4(r);
    this.maxResolution_ = l.maxResolution, this.minResolution_ = l.minResolution, this.zoomFactor_ = l.zoomFactor, this.resolutions_ = r.resolutions, this.padding_ = r.padding, this.minZoom_ = l.minZoom;
    var h = P4(r), s = l.constraint, m = O4(r);
    this.constraints_ = {
      center: h,
      resolution: s,
      rotation: m
    }, this.setRotation(r.rotation !== void 0 ? r.rotation : 0), this.setCenterInternal(r.center !== void 0 ? r.center : null), r.resolution !== void 0 ? this.setResolution(r.resolution) : r.zoom !== void 0 && this.setZoom(r.zoom);
  }, Object.defineProperty(e.prototype, "padding", {
    get: function() {
      return this.padding_;
    },
    set: function(r) {
      var n = this.padding_;
      this.padding_ = r;
      var i = this.getCenter();
      if (i) {
        var l = r || [0, 0, 0, 0];
        n = n || [0, 0, 0, 0];
        var h = this.getResolution(), s = h / 2 * (l[3] - n[3] + n[1] - l[1]), m = h / 2 * (l[0] - n[0] + n[2] - l[2]);
        this.setCenterInternal([i[0] + s, i[1] - m]);
      }
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getUpdatedOptions_ = function(r) {
    var n = this.getProperties();
    return n.resolution !== void 0 ? n.resolution = this.getResolution() : n.zoom = this.getZoom(), n.center = this.getCenterInternal(), n.rotation = this.getRotation(), In({}, n, r);
  }, e.prototype.animate = function(r) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    for (var n = new Array(arguments.length), i = 0; i < n.length; ++i) {
      var l = arguments[i];
      l.center && (l = In({}, l), l.center = Ds(l.center, this.getProjection())), l.anchor && (l = In({}, l), l.anchor = Ds(l.anchor, this.getProjection())), n[i] = l;
    }
    this.animateInternal.apply(this, n);
  }, e.prototype.animateInternal = function(r) {
    var n = arguments.length, i;
    n > 1 && typeof arguments[n - 1] == "function" && (i = arguments[n - 1], --n);
    for (var l = 0; l < n && !this.isDef(); ++l) {
      var h = arguments[l];
      h.center && this.setCenterInternal(h.center), h.zoom !== void 0 ? this.setZoom(h.zoom) : h.resolution && this.setResolution(h.resolution), h.rotation !== void 0 && this.setRotation(h.rotation);
    }
    if (l === n) {
      i && Dm(i, !0);
      return;
    }
    for (var s = Date.now(), m = this.targetCenter_.slice(), v = this.targetResolution_, E = this.targetRotation_, T = []; l < n; ++l) {
      var S = arguments[l], A = {
        start: s,
        complete: !1,
        anchor: S.anchor,
        duration: S.duration !== void 0 ? S.duration : 1e3,
        easing: S.easing || Zz,
        callback: i
      };
      if (S.center && (A.sourceCenter = m, A.targetCenter = S.center.slice(), m = A.targetCenter), S.zoom !== void 0 ? (A.sourceResolution = v, A.targetResolution = this.getResolutionForZoom(S.zoom), v = A.targetResolution) : S.resolution && (A.sourceResolution = v, A.targetResolution = S.resolution, v = A.targetResolution), S.rotation !== void 0) {
        A.sourceRotation = E;
        var L = Qc(S.rotation - E + Math.PI, 2 * Math.PI) - Math.PI;
        A.targetRotation = E + L, E = A.targetRotation;
      }
      R4(A) ? A.complete = !0 : s += A.duration, T.push(A);
    }
    this.animations_.push(T), this.setHint(To.ANIMATING, 1), this.updateAnimations_();
  }, e.prototype.getAnimating = function() {
    return this.hints_[To.ANIMATING] > 0;
  }, e.prototype.getInteracting = function() {
    return this.hints_[To.INTERACTING] > 0;
  }, e.prototype.cancelAnimations = function() {
    this.setHint(To.ANIMATING, -this.hints_[To.ANIMATING]);
    for (var r, n = 0, i = this.animations_.length; n < i; ++n) {
      var l = this.animations_[n];
      if (l[0].callback && Dm(l[0].callback, !1), !r)
        for (var h = 0, s = l.length; h < s; ++h) {
          var m = l[h];
          if (!m.complete) {
            r = m.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = r, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }, e.prototype.updateAnimations_ = function() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !!this.getAnimating()) {
      for (var r = Date.now(), n = !1, i = this.animations_.length - 1; i >= 0; --i) {
        for (var l = this.animations_[i], h = !0, s = 0, m = l.length; s < m; ++s) {
          var v = l[s];
          if (!v.complete) {
            var E = r - v.start, T = v.duration > 0 ? E / v.duration : 1;
            T >= 1 ? (v.complete = !0, T = 1) : h = !1;
            var S = v.easing(T);
            if (v.sourceCenter) {
              var A = v.sourceCenter[0], L = v.sourceCenter[1], B = v.targetCenter[0], j = v.targetCenter[1];
              this.nextCenter_ = v.targetCenter;
              var q = A + S * (B - A), H = L + S * (j - L);
              this.targetCenter_ = [q, H];
            }
            if (v.sourceResolution && v.targetResolution) {
              var ne = S === 1 ? v.targetResolution : v.sourceResolution + S * (v.targetResolution - v.sourceResolution);
              if (v.anchor) {
                var ee = this.getViewportSize_(this.getRotation()), he = this.constraints_.resolution(ne, 0, ee, !0);
                this.targetCenter_ = this.calculateCenterZoom(he, v.anchor);
              }
              this.nextResolution_ = v.targetResolution, this.targetResolution_ = ne, this.applyTargetState_(!0);
            }
            if (v.sourceRotation !== void 0 && v.targetRotation !== void 0) {
              var Te = S === 1 ? Qc(v.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : v.sourceRotation + S * (v.targetRotation - v.sourceRotation);
              if (v.anchor) {
                var ve = this.constraints_.rotation(Te, !0);
                this.targetCenter_ = this.calculateCenterRotate(ve, v.anchor);
              }
              this.nextRotation_ = v.targetRotation, this.targetRotation_ = Te;
            }
            if (this.applyTargetState_(!0), n = !0, !v.complete)
              break;
          }
        }
        if (h) {
          this.animations_[i] = null, this.setHint(To.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
          var Oe = l[0].callback;
          Oe && Dm(Oe, !0);
        }
      }
      this.animations_ = this.animations_.filter(Boolean), n && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this)));
    }
  }, e.prototype.calculateCenterRotate = function(r, n) {
    var i, l = this.getCenterInternal();
    return l !== void 0 && (i = [l[0] - n[0], l[1] - n[1]], _x(i, r - this.getRotation()), PD(i, n)), i;
  }, e.prototype.calculateCenterZoom = function(r, n) {
    var i, l = this.getCenterInternal(), h = this.getResolution();
    if (l !== void 0 && h !== void 0) {
      var s = n[0] - r * (n[0] - l[0]) / h, m = n[1] - r * (n[1] - l[1]) / h;
      i = [s, m];
    }
    return i;
  }, e.prototype.getViewportSize_ = function(r) {
    var n = this.viewportSize_;
    if (r) {
      var i = n[0], l = n[1];
      return [
        Math.abs(i * Math.cos(r)) + Math.abs(l * Math.sin(r)),
        Math.abs(i * Math.sin(r)) + Math.abs(l * Math.cos(r))
      ];
    } else
      return n;
  }, e.prototype.setViewportSize = function(r) {
    this.viewportSize_ = Array.isArray(r) ? r.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }, e.prototype.getCenter = function() {
    var r = this.getCenterInternal();
    return r && S0(r, this.getProjection());
  }, e.prototype.getCenterInternal = function() {
    return this.get(ya.CENTER);
  }, e.prototype.getConstraints = function() {
    return this.constraints_;
  }, e.prototype.getConstrainResolution = function() {
    return this.get("constrainResolution");
  }, e.prototype.getHints = function(r) {
    return r !== void 0 ? (r[0] = this.hints_[0], r[1] = this.hints_[1], r) : this.hints_.slice();
  }, e.prototype.calculateExtent = function(r) {
    var n = this.calculateExtentInternal(r);
    return $D(n, this.getProjection());
  }, e.prototype.calculateExtentInternal = function(r) {
    var n = r || this.getViewportSizeMinusPadding_(), i = this.getCenterInternal();
    en(i, 1);
    var l = this.getResolution();
    en(l !== void 0, 2);
    var h = this.getRotation();
    return en(h !== void 0, 3), Sh(i, l, h, n);
  }, e.prototype.getMaxResolution = function() {
    return this.maxResolution_;
  }, e.prototype.getMinResolution = function() {
    return this.minResolution_;
  }, e.prototype.getMaxZoom = function() {
    return this.getZoomForResolution(this.minResolution_);
  }, e.prototype.setMaxZoom = function(r) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: r }));
  }, e.prototype.getMinZoom = function() {
    return this.getZoomForResolution(this.maxResolution_);
  }, e.prototype.setMinZoom = function(r) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: r }));
  }, e.prototype.setConstrainResolution = function(r) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: r }));
  }, e.prototype.getProjection = function() {
    return this.projection_;
  }, e.prototype.getResolution = function() {
    return this.get(ya.RESOLUTION);
  }, e.prototype.getResolutions = function() {
    return this.resolutions_;
  }, e.prototype.getResolutionForExtent = function(r, n) {
    return this.getResolutionForExtentInternal(Ll(r, this.getProjection()), n);
  }, e.prototype.getResolutionForExtentInternal = function(r, n) {
    var i = n || this.getViewportSizeMinusPadding_(), l = Cn(r) / i[0], h = Pi(r) / i[1];
    return Math.max(l, h);
  }, e.prototype.getResolutionForValueFunction = function(r) {
    var n = r || 2, i = this.getConstrainedResolution(this.maxResolution_), l = this.minResolution_, h = Math.log(i / l) / Math.log(n);
    return function(s) {
      var m = i / Math.pow(n, s * h);
      return m;
    };
  }, e.prototype.getRotation = function() {
    return this.get(ya.ROTATION);
  }, e.prototype.getValueForResolutionFunction = function(r) {
    var n = Math.log(r || 2), i = this.getConstrainedResolution(this.maxResolution_), l = this.minResolution_, h = Math.log(i / l) / n;
    return function(s) {
      var m = Math.log(i / s) / n / h;
      return m;
    };
  }, e.prototype.getViewportSizeMinusPadding_ = function(r) {
    var n = this.getViewportSize_(r), i = this.padding_;
    return i && (n = [
      n[0] - i[1] - i[3],
      n[1] - i[0] - i[2]
    ]), n;
  }, e.prototype.getState = function() {
    var r = this.getProjection(), n = this.getResolution(), i = this.getRotation(), l = this.getCenterInternal(), h = this.padding_;
    if (h) {
      var s = this.getViewportSizeMinusPadding_();
      l = yv(l, this.getViewportSize_(), [s[0] / 2 + h[3], s[1] / 2 + h[0]], n, i);
    }
    return {
      center: l.slice(0),
      projection: r !== void 0 ? r : null,
      resolution: n,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: i,
      zoom: this.getZoom()
    };
  }, e.prototype.getZoom = function() {
    var r, n = this.getResolution();
    return n !== void 0 && (r = this.getZoomForResolution(n)), r;
  }, e.prototype.getZoomForResolution = function(r) {
    var n = this.minZoom_ || 0, i, l;
    if (this.resolutions_) {
      var h = By(this.resolutions_, r, 1);
      n = h, i = this.resolutions_[h], h == this.resolutions_.length - 1 ? l = 2 : l = i / this.resolutions_[h + 1];
    } else
      i = this.maxResolution_, l = this.zoomFactor_;
    return n + Math.log(i / r) / Math.log(l);
  }, e.prototype.getResolutionForZoom = function(r) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1)
        return 0;
      var n = hi(Math.floor(r), 0, this.resolutions_.length - 2), i = this.resolutions_[n] / this.resolutions_[n + 1];
      return this.resolutions_[n] / Math.pow(i, hi(r - n, 0, 1));
    } else
      return this.maxResolution_ / Math.pow(this.zoomFactor_, r - this.minZoom_);
  }, e.prototype.fit = function(r, n) {
    var i;
    if (en(Array.isArray(r) || typeof r.getSimplifiedGeometry == "function", 24), Array.isArray(r)) {
      en(!Ny(r), 25);
      var l = Ll(r, this.getProjection());
      i = R0(l);
    } else if (r.getType() === "Circle") {
      var l = Ll(r.getExtent(), this.getProjection());
      i = R0(l), i.rotate(this.getRotation(), au(l));
    } else {
      var h = UD();
      h ? i = r.clone().transform(h, this.getProjection()) : i = r;
    }
    this.fitInternal(i, n);
  }, e.prototype.rotatedExtentForGeometry = function(r) {
    for (var n = this.getRotation(), i = Math.cos(n), l = Math.sin(-n), h = r.getFlatCoordinates(), s = r.getStride(), m = 1 / 0, v = 1 / 0, E = -1 / 0, T = -1 / 0, S = 0, A = h.length; S < A; S += s) {
      var L = h[S] * i - h[S + 1] * l, B = h[S] * l + h[S + 1] * i;
      m = Math.min(m, L), v = Math.min(v, B), E = Math.max(E, L), T = Math.max(T, B);
    }
    return [m, v, E, T];
  }, e.prototype.fitInternal = function(r, n) {
    var i = n || {}, l = i.size;
    l || (l = this.getViewportSizeMinusPadding_());
    var h = i.padding !== void 0 ? i.padding : [0, 0, 0, 0], s = i.nearest !== void 0 ? i.nearest : !1, m;
    i.minResolution !== void 0 ? m = i.minResolution : i.maxZoom !== void 0 ? m = this.getResolutionForZoom(i.maxZoom) : m = 0;
    var v = this.rotatedExtentForGeometry(r), E = this.getResolutionForExtentInternal(v, [
      l[0] - h[1] - h[3],
      l[1] - h[0] - h[2]
    ]);
    E = isNaN(E) ? m : Math.max(E, m), E = this.getConstrainedResolution(E, s ? 0 : 1);
    var T = this.getRotation(), S = Math.sin(T), A = Math.cos(T), L = au(v);
    L[0] += (h[1] - h[3]) / 2 * E, L[1] += (h[0] - h[2]) / 2 * E;
    var B = L[0] * A - L[1] * S, j = L[1] * A + L[0] * S, q = this.getConstrainedCenter([B, j], E), H = i.callback ? i.callback : Nd;
    i.duration !== void 0 ? this.animateInternal({
      resolution: E,
      center: q,
      duration: i.duration,
      easing: i.easing
    }, H) : (this.targetResolution_ = E, this.targetCenter_ = q, this.applyTargetState_(!1, !0), Dm(H, !0));
  }, e.prototype.centerOn = function(r, n, i) {
    this.centerOnInternal(Ds(r, this.getProjection()), n, i);
  }, e.prototype.centerOnInternal = function(r, n, i) {
    this.setCenterInternal(yv(r, n, i, this.getResolution(), this.getRotation()));
  }, e.prototype.calculateCenterShift = function(r, n, i, l) {
    var h, s = this.padding_;
    if (s && r) {
      var m = this.getViewportSizeMinusPadding_(-i), v = yv(r, l, [m[0] / 2 + s[3], m[1] / 2 + s[0]], n, i);
      h = [
        r[0] - v[0],
        r[1] - v[1]
      ];
    }
    return h;
  }, e.prototype.isDef = function() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }, e.prototype.adjustCenter = function(r) {
    var n = S0(this.targetCenter_, this.getProjection());
    this.setCenter([
      n[0] + r[0],
      n[1] + r[1]
    ]);
  }, e.prototype.adjustCenterInternal = function(r) {
    var n = this.targetCenter_;
    this.setCenterInternal([
      n[0] + r[0],
      n[1] + r[1]
    ]);
  }, e.prototype.adjustResolution = function(r, n) {
    var i = n && Ds(n, this.getProjection());
    this.adjustResolutionInternal(r, i);
  }, e.prototype.adjustResolutionInternal = function(r, n) {
    var i = this.getAnimating() || this.getInteracting(), l = this.getViewportSize_(this.getRotation()), h = this.constraints_.resolution(this.targetResolution_ * r, 0, l, i);
    n && (this.targetCenter_ = this.calculateCenterZoom(h, n)), this.targetResolution_ *= r, this.applyTargetState_();
  }, e.prototype.adjustZoom = function(r, n) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -r), n);
  }, e.prototype.adjustRotation = function(r, n) {
    n && (n = Ds(n, this.getProjection())), this.adjustRotationInternal(r, n);
  }, e.prototype.adjustRotationInternal = function(r, n) {
    var i = this.getAnimating() || this.getInteracting(), l = this.constraints_.rotation(this.targetRotation_ + r, i);
    n && (this.targetCenter_ = this.calculateCenterRotate(l, n)), this.targetRotation_ += r, this.applyTargetState_();
  }, e.prototype.setCenter = function(r) {
    this.setCenterInternal(r && Ds(r, this.getProjection()));
  }, e.prototype.setCenterInternal = function(r) {
    this.targetCenter_ = r, this.applyTargetState_();
  }, e.prototype.setHint = function(r, n) {
    return this.hints_[r] += n, this.changed(), this.hints_[r];
  }, e.prototype.setResolution = function(r) {
    this.targetResolution_ = r, this.applyTargetState_();
  }, e.prototype.setRotation = function(r) {
    this.targetRotation_ = r, this.applyTargetState_();
  }, e.prototype.setZoom = function(r) {
    this.setResolution(this.getResolutionForZoom(r));
  }, e.prototype.applyTargetState_ = function(r, n) {
    var i = this.getAnimating() || this.getInteracting() || n, l = this.constraints_.rotation(this.targetRotation_, i), h = this.getViewportSize_(l), s = this.constraints_.resolution(this.targetResolution_, 0, h, i), m = this.constraints_.center(this.targetCenter_, s, h, i, this.calculateCenterShift(this.targetCenter_, s, l, h));
    this.get(ya.ROTATION) !== l && this.set(ya.ROTATION, l), this.get(ya.RESOLUTION) !== s && (this.set(ya.RESOLUTION, s), this.set("zoom", this.getZoom(), !0)), (!m || !this.get(ya.CENTER) || !Dg(this.get(ya.CENTER), m)) && this.set(ya.CENTER, m), this.getAnimating() && !r && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }, e.prototype.resolveConstraints = function(r, n, i) {
    var l = r !== void 0 ? r : 200, h = n || 0, s = this.constraints_.rotation(this.targetRotation_), m = this.getViewportSize_(s), v = this.constraints_.resolution(this.targetResolution_, h, m), E = this.constraints_.center(this.targetCenter_, v, m, !1, this.calculateCenterShift(this.targetCenter_, v, s, m));
    if (l === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = v, this.targetRotation_ = s, this.targetCenter_ = E, this.applyTargetState_();
      return;
    }
    var T = i || (l === 0 ? this.cancelAnchor_ : void 0);
    this.cancelAnchor_ = void 0, (this.getResolution() !== v || this.getRotation() !== s || !this.getCenterInternal() || !Dg(this.getCenterInternal(), E)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: s,
      center: E,
      resolution: v,
      duration: l,
      easing: Gh,
      anchor: T
    }));
  }, e.prototype.beginInteraction = function() {
    this.resolveConstraints(0), this.setHint(To.INTERACTING, 1);
  }, e.prototype.endInteraction = function(r, n, i) {
    var l = i && Ds(i, this.getProjection());
    this.endInteractionInternal(r, n, l);
  }, e.prototype.endInteractionInternal = function(r, n, i) {
    this.setHint(To.INTERACTING, -1), this.resolveConstraints(r, n, i);
  }, e.prototype.getConstrainedCenter = function(r, n) {
    var i = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(r, n || this.getResolution(), i);
  }, e.prototype.getConstrainedZoom = function(r, n) {
    var i = this.getResolutionForZoom(r);
    return this.getZoomForResolution(this.getConstrainedResolution(i, n));
  }, e.prototype.getConstrainedResolution = function(r, n) {
    var i = n || 0, l = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(r, i, l);
  }, e;
}(Zs);
function Dm(t, e) {
  setTimeout(function() {
    t(e);
  }, 0);
}
function P4(t) {
  if (t.extent !== void 0) {
    var e = t.smoothExtentConstraint !== void 0 ? t.smoothExtentConstraint : !0;
    return rE(t.extent, t.constrainOnlyCenter, e);
  }
  var r = xx(t.projection, "EPSG:3857");
  if (t.multiWorld !== !0 && r.isGlobal()) {
    var n = r.getExtent().slice();
    return n[0] = -1 / 0, n[2] = 1 / 0, rE(n, !1, !1);
  }
  return jz;
}
function A4(t) {
  var e, r, n, i = 28, l = 2, h = t.minZoom !== void 0 ? t.minZoom : gv, s = t.maxZoom !== void 0 ? t.maxZoom : i, m = t.zoomFactor !== void 0 ? t.zoomFactor : l, v = t.multiWorld !== void 0 ? t.multiWorld : !1, E = t.smoothResolutionConstraint !== void 0 ? t.smoothResolutionConstraint : !0, T = t.showFullExtent !== void 0 ? t.showFullExtent : !1, S = xx(t.projection, "EPSG:3857"), A = S.getExtent(), L = t.constrainOnlyCenter, B = t.extent;
  if (!v && !B && S.isGlobal() && (L = !1, B = A), t.resolutions !== void 0) {
    var j = t.resolutions;
    r = j[h], n = j[s] !== void 0 ? j[s] : j[j.length - 1], t.constrainResolution ? e = Gz(j, E, !L && B, T) : e = nE(r, n, E, !L && B, T);
  } else {
    var q = A ? Math.max(Cn(A), Pi(A)) : 360 * ss[Fs.DEGREES] / S.getMetersPerUnit(), H = q / Lx / Math.pow(l, gv), ne = H / Math.pow(l, i - gv);
    r = t.maxResolution, r !== void 0 ? h = 0 : r = H / Math.pow(m, h), n = t.minResolution, n === void 0 && (t.maxZoom !== void 0 ? t.maxResolution !== void 0 ? n = r / Math.pow(m, s) : n = H / Math.pow(m, s) : n = ne), s = h + Math.floor(Math.log(r / n) / Math.log(m)), n = r / Math.pow(m, s - h), t.constrainResolution ? e = qz(m, r, n, E, !L && B, T) : e = nE(r, n, E, !L && B, T);
  }
  return {
    constraint: e,
    maxResolution: r,
    minResolution: n,
    minZoom: h,
    zoomFactor: m
  };
}
function O4(t) {
  var e = t.enableRotation !== void 0 ? t.enableRotation : !0;
  if (e) {
    var r = t.constrainRotation;
    return r === void 0 || r === !0 ? Xz() : r === !1 ? iE : typeof r == "number" ? Wz(r) : iE;
  } else
    return Nx;
}
function R4(t) {
  return !(t.sourceCenter && t.targetCenter && !Dg(t.sourceCenter, t.targetCenter) || t.sourceResolution !== t.targetResolution || t.sourceRotation !== t.targetRotation);
}
function yv(t, e, r, n, i) {
  var l = Math.cos(-i), h = Math.sin(-i), s = t[0] * l - t[1] * h, m = t[1] * l + t[0] * h;
  s += (e[0] / 2 - r[0]) * n, m += (r[1] - e[1] / 2) * n, h = -h;
  var v = s * l - m * h, E = m * l + s * h;
  return [v, E];
}
const Al = I4;
function uE(t) {
  return t[0] > 0 && t[1] > 0;
}
function L4(t, e, r) {
  return r === void 0 && (r = [0, 0]), r[0] = t[0] * e + 0.5 | 0, r[1] = t[1] * e + 0.5 | 0, r;
}
function ks(t, e) {
  return Array.isArray(t) ? t : (e === void 0 ? e = [t, t] : (e[0] = t, e[1] = t), e);
}
var D4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}();
function tM(t) {
  if (t instanceof rp) {
    t.setMapInternal(null);
    return;
  }
  t instanceof $y && t.getLayers().forEach(tM);
}
function rM(t, e) {
  if (t instanceof rp) {
    t.setMapInternal(e);
    return;
  }
  if (t instanceof $y)
    for (var r = t.getLayers().getArray(), n = 0, i = r.length; n < i; ++n)
      rM(r[n], e);
}
var k4 = function(t) {
  D4(e, t);
  function e(r) {
    var n = t.call(this) || this;
    n.on, n.once, n.un;
    var i = N4(r);
    n.renderComplete_, n.loaded_ = !0, n.boundHandleBrowserEvent_ = n.handleBrowserEvent.bind(n), n.maxTilesLoading_ = r.maxTilesLoading !== void 0 ? r.maxTilesLoading : 16, n.pixelRatio_ = r.pixelRatio !== void 0 ? r.pixelRatio : L2, n.postRenderTimeoutHandle_, n.animationDelayKey_, n.animationDelay_ = function() {
      this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
    }.bind(n), n.coordinateToPixelTransform_ = Ih(), n.pixelToCoordinateTransform_ = Ih(), n.frameIndex_ = 0, n.frameState_ = null, n.previousExtent_ = null, n.viewPropertyListenerKey_ = null, n.viewChangeListenerKey_ = null, n.layerGroupPropertyListenerKeys_ = null, n.viewport_ = document.createElement("div"), n.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), n.viewport_.style.position = "relative", n.viewport_.style.overflow = "hidden", n.viewport_.style.width = "100%", n.viewport_.style.height = "100%", n.overlayContainer_ = document.createElement("div"), n.overlayContainer_.style.position = "absolute", n.overlayContainer_.style.zIndex = "0", n.overlayContainer_.style.width = "100%", n.overlayContainer_.style.height = "100%", n.overlayContainer_.style.pointerEvents = "none", n.overlayContainer_.className = "ol-overlaycontainer", n.viewport_.appendChild(n.overlayContainer_), n.overlayContainerStopEvent_ = document.createElement("div"), n.overlayContainerStopEvent_.style.position = "absolute", n.overlayContainerStopEvent_.style.zIndex = "0", n.overlayContainerStopEvent_.style.width = "100%", n.overlayContainerStopEvent_.style.height = "100%", n.overlayContainerStopEvent_.style.pointerEvents = "none", n.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", n.viewport_.appendChild(n.overlayContainerStopEvent_), n.mapBrowserEventHandler_ = null, n.moveTolerance_ = r.moveTolerance, n.keyboardEventTarget_ = i.keyboardEventTarget, n.targetChangeHandlerKeys_ = null, n.controls = i.controls || new Ia(), n.interactions = i.interactions || new Ia(), n.overlays_ = i.overlays, n.overlayIdIndex_ = {}, n.renderer_ = null, n.postRenderFunctions_ = [], n.tileQueue_ = new Uz(n.getTilePriority.bind(n), n.handleTileChange_.bind(n)), n.addChangeListener(Mi.LAYERGROUP, n.handleLayerGroupChanged_), n.addChangeListener(Mi.VIEW, n.handleViewChanged_), n.addChangeListener(Mi.SIZE, n.handleSizeChanged_), n.addChangeListener(Mi.TARGET, n.handleTargetChanged_), n.setProperties(i.values);
    var l = n;
    return r.view && !(r.view instanceof Al) && r.view.then(function(h) {
      l.setView(new Al(h));
    }), n.controls.addEventListener(
      ra.ADD,
      function(h) {
        h.element.setMap(this);
      }.bind(n)
    ), n.controls.addEventListener(
      ra.REMOVE,
      function(h) {
        h.element.setMap(null);
      }.bind(n)
    ), n.interactions.addEventListener(
      ra.ADD,
      function(h) {
        h.element.setMap(this);
      }.bind(n)
    ), n.interactions.addEventListener(
      ra.REMOVE,
      function(h) {
        h.element.setMap(null);
      }.bind(n)
    ), n.overlays_.addEventListener(
      ra.ADD,
      function(h) {
        this.addOverlayInternal_(
          h.element
        );
      }.bind(n)
    ), n.overlays_.addEventListener(
      ra.REMOVE,
      function(h) {
        var s = h.element, m = s.getId();
        m !== void 0 && delete this.overlayIdIndex_[m.toString()], h.element.setMap(null);
      }.bind(n)
    ), n.controls.forEach(
      function(h) {
        h.setMap(this);
      }.bind(n)
    ), n.interactions.forEach(
      function(h) {
        h.setMap(this);
      }.bind(n)
    ), n.overlays_.forEach(n.addOverlayInternal_.bind(n)), n;
  }
  return e.prototype.createRenderer = function() {
    throw new Error("Use a map type that has a createRenderer method");
  }, e.prototype.addControl = function(r) {
    this.getControls().push(r);
  }, e.prototype.addInteraction = function(r) {
    this.getInteractions().push(r);
  }, e.prototype.addLayer = function(r) {
    var n = this.getLayerGroup().getLayers();
    n.push(r);
  }, e.prototype.handleLayerAdd_ = function(r) {
    rM(r.layer, this);
  }, e.prototype.addOverlay = function(r) {
    this.getOverlays().push(r);
  }, e.prototype.addOverlayInternal_ = function(r) {
    var n = r.getId();
    n !== void 0 && (this.overlayIdIndex_[n.toString()] = r), r.setMap(this);
  }, e.prototype.disposeInternal = function() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.setTarget(null), t.prototype.disposeInternal.call(this);
  }, e.prototype.forEachFeatureAtPixel = function(r, n, i) {
    if (!(!this.frameState_ || !this.renderer_)) {
      var l = this.getCoordinateFromPixelInternal(r);
      i = i !== void 0 ? i : {};
      var h = i.hitTolerance !== void 0 ? i.hitTolerance : 0, s = i.layerFilter !== void 0 ? i.layerFilter : gd, m = i.checkWrapped !== !1;
      return this.renderer_.forEachFeatureAtCoordinate(l, this.frameState_, h, m, n, null, s, null);
    }
  }, e.prototype.getFeaturesAtPixel = function(r, n) {
    var i = [];
    return this.forEachFeatureAtPixel(r, function(l) {
      i.push(l);
    }, n), i;
  }, e.prototype.getAllLayers = function() {
    var r = [];
    function n(i) {
      i.forEach(function(l) {
        l instanceof $y ? n(l.getLayers()) : r.push(l);
      });
    }
    return n(this.getLayers()), r;
  }, e.prototype.forEachLayerAtPixel = function(r, n, i) {
    if (!(!this.frameState_ || !this.renderer_)) {
      var l = i || {}, h = l.hitTolerance !== void 0 ? l.hitTolerance : 0, s = l.layerFilter || gd;
      return this.renderer_.forEachLayerAtPixel(r, this.frameState_, h, n, s);
    }
  }, e.prototype.hasFeatureAtPixel = function(r, n) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    var i = this.getCoordinateFromPixelInternal(r);
    n = n !== void 0 ? n : {};
    var l = n.layerFilter !== void 0 ? n.layerFilter : gd, h = n.hitTolerance !== void 0 ? n.hitTolerance : 0, s = n.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(i, this.frameState_, h, s, l, null);
  }, e.prototype.getEventCoordinate = function(r) {
    return this.getCoordinateFromPixel(this.getEventPixel(r));
  }, e.prototype.getEventCoordinateInternal = function(r) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(r));
  }, e.prototype.getEventPixel = function(r) {
    var n = this.viewport_.getBoundingClientRect(), i = "changedTouches" in r ? r.changedTouches[0] : r;
    return [
      i.clientX - n.left,
      i.clientY - n.top
    ];
  }, e.prototype.getTarget = function() {
    return this.get(Mi.TARGET);
  }, e.prototype.getTargetElement = function() {
    var r = this.getTarget();
    return r !== void 0 ? typeof r == "string" ? document.getElementById(r) : r : null;
  }, e.prototype.getCoordinateFromPixel = function(r) {
    return S0(this.getCoordinateFromPixelInternal(r), this.getView().getProjection());
  }, e.prototype.getCoordinateFromPixelInternal = function(r) {
    var n = this.frameState_;
    return n ? Xi(n.pixelToCoordinateTransform, r.slice()) : null;
  }, e.prototype.getControls = function() {
    return this.controls;
  }, e.prototype.getOverlays = function() {
    return this.overlays_;
  }, e.prototype.getOverlayById = function(r) {
    var n = this.overlayIdIndex_[r.toString()];
    return n !== void 0 ? n : null;
  }, e.prototype.getInteractions = function() {
    return this.interactions;
  }, e.prototype.getLayerGroup = function() {
    return this.get(Mi.LAYERGROUP);
  }, e.prototype.setLayers = function(r) {
    var n = this.getLayerGroup();
    if (r instanceof Ia) {
      n.setLayers(r);
      return;
    }
    var i = n.getLayers();
    i.clear(), i.extend(r);
  }, e.prototype.getLayers = function() {
    var r = this.getLayerGroup().getLayers();
    return r;
  }, e.prototype.getLoadingOrNotReady = function() {
    for (var r = this.getLayerGroup().getLayerStatesArray(), n = 0, i = r.length; n < i; ++n) {
      var l = r[n];
      if (!!l.visible) {
        var h = l.layer.getRenderer();
        if (h && !h.ready)
          return !0;
        var s = l.layer.getSource();
        if (s && s.loading)
          return !0;
      }
    }
    return !1;
  }, e.prototype.getPixelFromCoordinate = function(r) {
    var n = Ds(r, this.getView().getProjection());
    return this.getPixelFromCoordinateInternal(n);
  }, e.prototype.getPixelFromCoordinateInternal = function(r) {
    var n = this.frameState_;
    return n ? Xi(n.coordinateToPixelTransform, r.slice(0, 2)) : null;
  }, e.prototype.getRenderer = function() {
    return this.renderer_;
  }, e.prototype.getSize = function() {
    return this.get(Mi.SIZE);
  }, e.prototype.getView = function() {
    return this.get(Mi.VIEW);
  }, e.prototype.getViewport = function() {
    return this.viewport_;
  }, e.prototype.getOverlayContainer = function() {
    return this.overlayContainer_;
  }, e.prototype.getOverlayContainerStopEvent = function() {
    return this.overlayContainerStopEvent_;
  }, e.prototype.getOwnerDocument = function() {
    var r = this.getTargetElement();
    return r ? r.ownerDocument : document;
  }, e.prototype.getTilePriority = function(r, n, i, l) {
    return $z(this.frameState_, r, n, i, l);
  }, e.prototype.handleBrowserEvent = function(r, n) {
    var i = n || r.type, l = new bl(i, this, r);
    this.handleMapBrowserEvent(l);
  }, e.prototype.handleMapBrowserEvent = function(r) {
    if (!!this.frameState_) {
      var n = r.originalEvent, i = n.type;
      if (i === O0.POINTERDOWN || i === _r.WHEEL || i === _r.KEYDOWN) {
        var l = this.getOwnerDocument(), h = this.viewport_.getRootNode ? this.viewport_.getRootNode() : l, s = n.target;
        if (this.overlayContainerStopEvent_.contains(s) || !(h === l ? l.documentElement : h).contains(s))
          return;
      }
      if (r.frameState = this.frameState_, this.dispatchEvent(r) !== !1)
        for (var m = this.getInteractions().getArray().slice(), v = m.length - 1; v >= 0; v--) {
          var E = m[v];
          if (!(E.getMap() !== this || !E.getActive() || !this.getTargetElement())) {
            var T = E.handleEvent(r);
            if (!T || r.propagationStopped)
              break;
          }
        }
    }
  }, e.prototype.handlePostRender = function() {
    var r = this.frameState_, n = this.tileQueue_;
    if (!n.isEmpty()) {
      var i = this.maxTilesLoading_, l = i;
      if (r) {
        var h = r.viewHints;
        if (h[To.ANIMATING] || h[To.INTERACTING]) {
          var s = Date.now() - r.time > 8;
          i = s ? 0 : 8, l = s ? 0 : 2;
        }
      }
      n.getTilesLoading() < i && (n.reprioritize(), n.loadMoreTiles(i, l));
    }
    r && this.renderer_ && !r.animate && (this.renderComplete_ === !0 ? (this.hasListener(ns.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(ns.RENDERCOMPLETE, r), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(new ah(wl.LOADEND, this, r)))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(new ah(wl.LOADSTART, this, r))));
    for (var m = this.postRenderFunctions_, v = 0, E = m.length; v < E; ++v)
      m[v](this, r);
    m.length = 0;
  }, e.prototype.handleSizeChanged_ = function() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }, e.prototype.handleTargetChanged_ = function() {
    if (this.mapBrowserEventHandler_) {
      for (var r = 0, n = this.targetChangeHandlerKeys_.length; r < n; ++r)
        $n(this.targetChangeHandlerKeys_[r]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(_r.CONTEXTMENU, this.boundHandleBrowserEvent_), this.viewport_.removeEventListener(_r.WHEEL, this.boundHandleBrowserEvent_), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, A0(this.viewport_);
    }
    var i = this.getTargetElement();
    if (!i)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      i.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = this.createRenderer()), this.mapBrowserEventHandler_ = new kz(this, this.moveTolerance_);
      for (var l in Xn)
        this.mapBrowserEventHandler_.addEventListener(Xn[l], this.handleMapBrowserEvent.bind(this));
      this.viewport_.addEventListener(_r.CONTEXTMENU, this.boundHandleBrowserEvent_, !1), this.viewport_.addEventListener(_r.WHEEL, this.boundHandleBrowserEvent_, k2 ? { passive: !1 } : !1);
      var h = this.getOwnerDocument().defaultView, s = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : i;
      this.targetChangeHandlerKeys_ = [
        Fr(s, _r.KEYDOWN, this.handleBrowserEvent, this),
        Fr(s, _r.KEYPRESS, this.handleBrowserEvent, this),
        Fr(h, _r.RESIZE, this.updateSize, this)
      ];
    }
    this.updateSize();
  }, e.prototype.handleTileChange_ = function() {
    this.render();
  }, e.prototype.handleViewPropertyChanged_ = function() {
    this.render();
  }, e.prototype.handleViewChanged_ = function() {
    this.viewPropertyListenerKey_ && ($n(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && ($n(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    var r = this.getView();
    r && (this.updateViewportSize_(), this.viewPropertyListenerKey_ = Fr(r, zh.PROPERTYCHANGE, this.handleViewPropertyChanged_, this), this.viewChangeListenerKey_ = Fr(r, _r.CHANGE, this.handleViewPropertyChanged_, this), r.resolveConstraints(0)), this.render();
  }, e.prototype.handleLayerGroupChanged_ = function() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach($n), this.layerGroupPropertyListenerKeys_ = null);
    var r = this.getLayerGroup();
    r && (this.handleLayerAdd_(new Sl("addlayer", r)), this.layerGroupPropertyListenerKeys_ = [
      Fr(r, zh.PROPERTYCHANGE, this.render, this),
      Fr(r, _r.CHANGE, this.render, this),
      Fr(r, "addlayer", this.handleLayerAdd_, this),
      Fr(r, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }, e.prototype.isRendered = function() {
    return !!this.frameState_;
  }, e.prototype.renderSync = function() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }, e.prototype.redrawText = function() {
    for (var r = this.getLayerGroup().getLayerStatesArray(), n = 0, i = r.length; n < i; ++n) {
      var l = r[n].layer;
      l.hasRenderer() && l.getRenderer().handleFontsChanged();
    }
  }, e.prototype.render = function() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }, e.prototype.removeControl = function(r) {
    return this.getControls().remove(r);
  }, e.prototype.removeInteraction = function(r) {
    return this.getInteractions().remove(r);
  }, e.prototype.removeLayer = function(r) {
    var n = this.getLayerGroup().getLayers();
    return n.remove(r);
  }, e.prototype.handleLayerRemove_ = function(r) {
    tM(r.layer);
  }, e.prototype.removeOverlay = function(r) {
    return this.getOverlays().remove(r);
  }, e.prototype.renderFrame_ = function(r) {
    var n = this, i = this.getSize(), l = this.getView(), h = this.frameState_, s = null;
    if (i !== void 0 && uE(i) && l && l.isDef()) {
      var m = l.getHints(this.frameState_ ? this.frameState_.viewHints : void 0), v = l.getState();
      if (s = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: Sh(v.center, v.resolution, v.rotation, i),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: i,
        tileQueue: this.tileQueue_,
        time: r,
        usedTiles: {},
        viewState: v,
        viewHints: m,
        wantedTiles: {},
        mapId: So(this),
        renderTargets: {}
      }, v.nextCenter && v.nextResolution) {
        var E = isNaN(v.nextRotation) ? v.rotation : v.nextRotation;
        s.nextExtent = Sh(v.nextCenter, v.nextResolution, E, i);
      }
    }
    if (this.frameState_ = s, this.renderer_.renderFrame(s), s) {
      if (s.animate && this.render(), Array.prototype.push.apply(this.postRenderFunctions_, s.postRenderFunctions), h) {
        var T = !this.previousExtent_ || !Ny(this.previousExtent_) && !Lg(s.extent, this.previousExtent_);
        T && (this.dispatchEvent(new ah(wl.MOVESTART, this, h)), this.previousExtent_ = Ry(this.previousExtent_));
      }
      var S = this.previousExtent_ && !s.viewHints[To.ANIMATING] && !s.viewHints[To.INTERACTING] && !Lg(s.extent, this.previousExtent_);
      S && (this.dispatchEvent(new ah(wl.MOVEEND, this, s)), vD(s.extent, this.previousExtent_));
    }
    this.dispatchEvent(new ah(wl.POSTRENDER, this, s)), this.renderComplete_ = this.hasListener(wl.LOADSTART) || this.hasListener(wl.LOADEND) || this.hasListener(ns.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0, this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(function() {
      n.postRenderTimeoutHandle_ = void 0, n.handlePostRender();
    }, 0));
  }, e.prototype.setLayerGroup = function(r) {
    var n = this.getLayerGroup();
    n && this.handleLayerRemove_(new Sl("removelayer", n)), this.set(Mi.LAYERGROUP, r);
  }, e.prototype.setSize = function(r) {
    this.set(Mi.SIZE, r);
  }, e.prototype.setTarget = function(r) {
    this.set(Mi.TARGET, r);
  }, e.prototype.setView = function(r) {
    if (!r || r instanceof Al) {
      this.set(Mi.VIEW, r);
      return;
    }
    this.set(Mi.VIEW, new Al());
    var n = this;
    r.then(function(i) {
      n.setView(new Al(i));
    });
  }, e.prototype.updateSize = function() {
    var r = this.getTargetElement(), n = void 0;
    if (r) {
      var i = getComputedStyle(r), l = r.offsetWidth - parseFloat(i.borderLeftWidth) - parseFloat(i.paddingLeft) - parseFloat(i.paddingRight) - parseFloat(i.borderRightWidth), h = r.offsetHeight - parseFloat(i.borderTopWidth) - parseFloat(i.paddingTop) - parseFloat(i.paddingBottom) - parseFloat(i.borderBottomWidth);
      !isNaN(l) && !isNaN(h) && (n = [l, h], !uE(n) && !!(r.offsetWidth || r.offsetHeight || r.getClientRects().length) && console.warn("No map visible because the map container's width or height are 0."));
    }
    this.setSize(n), this.updateViewportSize_();
  }, e.prototype.updateViewportSize_ = function() {
    var r = this.getView();
    if (r) {
      var n = void 0, i = getComputedStyle(this.viewport_);
      i.width && i.height && (n = [
        parseInt(i.width, 10),
        parseInt(i.height, 10)
      ]), r.setViewportSize(n);
    }
  }, e;
}(Zs);
function N4(t) {
  var e = null;
  t.keyboardEventTarget !== void 0 && (e = typeof t.keyboardEventTarget == "string" ? document.getElementById(t.keyboardEventTarget) : t.keyboardEventTarget);
  var r = {}, n = t.layers && typeof t.layers.getLayers == "function" ? t.layers : new $y({ layers: t.layers });
  r[Mi.LAYERGROUP] = n, r[Mi.TARGET] = t.target, r[Mi.VIEW] = t.view instanceof Al ? t.view : new Al();
  var i;
  t.controls !== void 0 && (Array.isArray(t.controls) ? i = new Ia(t.controls.slice()) : (en(typeof t.controls.getArray == "function", 47), i = t.controls));
  var l;
  t.interactions !== void 0 && (Array.isArray(t.interactions) ? l = new Ia(t.interactions.slice()) : (en(typeof t.interactions.getArray == "function", 48), l = t.interactions));
  var h;
  return t.overlays !== void 0 ? Array.isArray(t.overlays) ? h = new Ia(t.overlays.slice()) : (en(typeof t.overlays.getArray == "function", 49), h = t.overlays) : h = new Ia(), {
    controls: i,
    interactions: l,
    keyboardEventTarget: e,
    overlays: h,
    values: r
  };
}
const F4 = k4;
var z4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), B4 = function(t) {
  z4(e, t);
  function e(r) {
    var n = t.call(this) || this, i = r.element;
    return i && !r.target && !i.style.pointerEvents && (i.style.pointerEvents = "auto"), n.element = i || null, n.target_ = null, n.map_ = null, n.listenerKeys = [], r.render && (n.render = r.render), r.target && n.setTarget(r.target), n;
  }
  return e.prototype.disposeInternal = function() {
    A0(this.element), t.prototype.disposeInternal.call(this);
  }, e.prototype.getMap = function() {
    return this.map_;
  }, e.prototype.setMap = function(r) {
    this.map_ && A0(this.element);
    for (var n = 0, i = this.listenerKeys.length; n < i; ++n)
      $n(this.listenerKeys[n]);
    if (this.listenerKeys.length = 0, this.map_ = r, r) {
      var l = this.target_ ? this.target_ : r.getOverlayContainerStopEvent();
      l.appendChild(this.element), this.render !== Nd && this.listenerKeys.push(Fr(r, wl.POSTRENDER, this.render, this)), r.render();
    }
  }, e.prototype.render = function(r) {
  }, e.prototype.setTarget = function(r) {
    this.target_ = typeof r == "string" ? document.getElementById(r) : r;
  }, e;
}(Zs);
const qh = B4;
var U4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), $4 = function(t) {
  U4(e, t);
  function e(r) {
    var n = this, i = r || {};
    n = t.call(this, {
      element: document.createElement("div"),
      render: i.render,
      target: i.target
    }) || this, n.ulElement_ = document.createElement("ul"), n.collapsed_ = i.collapsed !== void 0 ? i.collapsed : !0, n.userCollapsed_ = n.collapsed_, n.overrideCollapsible_ = i.collapsible !== void 0, n.collapsible_ = i.collapsible !== void 0 ? i.collapsible : !0, n.collapsible_ || (n.collapsed_ = !1);
    var l = i.className !== void 0 ? i.className : "ol-attribution", h = i.tipLabel !== void 0 ? i.tipLabel : "Attributions", s = i.expandClassName !== void 0 ? i.expandClassName : l + "-expand", m = i.collapseLabel !== void 0 ? i.collapseLabel : "\u203A", v = i.collapseClassName !== void 0 ? i.collapseClassName : l + "-collapse";
    typeof m == "string" ? (n.collapseLabel_ = document.createElement("span"), n.collapseLabel_.textContent = m, n.collapseLabel_.className = v) : n.collapseLabel_ = m;
    var E = i.label !== void 0 ? i.label : "i";
    typeof E == "string" ? (n.label_ = document.createElement("span"), n.label_.textContent = E, n.label_.className = s) : n.label_ = E;
    var T = n.collapsible_ && !n.collapsed_ ? n.collapseLabel_ : n.label_;
    n.toggleButton_ = document.createElement("button"), n.toggleButton_.setAttribute("type", "button"), n.toggleButton_.setAttribute("aria-expanded", String(!n.collapsed_)), n.toggleButton_.title = h, n.toggleButton_.appendChild(T), n.toggleButton_.addEventListener(_r.CLICK, n.handleClick_.bind(n), !1);
    var S = l + " " + mu + " " + jh + (n.collapsed_ && n.collapsible_ ? " " + eE : "") + (n.collapsible_ ? "" : " ol-uncollapsible"), A = n.element;
    return A.className = S, A.appendChild(n.toggleButton_), A.appendChild(n.ulElement_), n.renderedAttributions_ = [], n.renderedVisible_ = !0, n;
  }
  return e.prototype.collectSourceAttributions_ = function(r) {
    for (var n = {}, i = [], l = !0, h = r.layerStatesArray, s = 0, m = h.length; s < m; ++s) {
      var v = h[s];
      if (!!$g(v, r.viewState)) {
        var E = v.layer.getSource();
        if (!!E) {
          var T = E.getAttributions();
          if (!!T) {
            var S = T(r);
            if (!!S)
              if (l = l && E.getAttributionsCollapsible() !== !1, Array.isArray(S))
                for (var A = 0, L = S.length; A < L; ++A)
                  S[A] in n || (i.push(S[A]), n[S[A]] = !0);
              else
                S in n || (i.push(S), n[S] = !0);
          }
        }
      }
    }
    return this.overrideCollapsible_ || this.setCollapsible(l), i;
  }, e.prototype.updateElement_ = function(r) {
    if (!r) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    var n = this.collectSourceAttributions_(r), i = n.length > 0;
    if (this.renderedVisible_ != i && (this.element.style.display = i ? "" : "none", this.renderedVisible_ = i), !Ox(n, this.renderedAttributions_)) {
      xz(this.ulElement_);
      for (var l = 0, h = n.length; l < h; ++l) {
        var s = document.createElement("li");
        s.innerHTML = n[l], this.ulElement_.appendChild(s);
      }
      this.renderedAttributions_ = n;
    }
  }, e.prototype.handleClick_ = function(r) {
    r.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }, e.prototype.handleToggle_ = function() {
    this.element.classList.toggle(eE), this.collapsed_ ? jg(this.collapseLabel_, this.label_) : jg(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }, e.prototype.getCollapsible = function() {
    return this.collapsible_;
  }, e.prototype.setCollapsible = function(r) {
    this.collapsible_ !== r && (this.collapsible_ = r, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }, e.prototype.setCollapsed = function(r) {
    this.userCollapsed_ = r, !(!this.collapsible_ || this.collapsed_ === r) && this.handleToggle_();
  }, e.prototype.getCollapsed = function() {
    return this.collapsed_;
  }, e.prototype.render = function(r) {
    this.updateElement_(r.frameState);
  }, e;
}(qh);
const nM = $4;
var V4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), j4 = function(t) {
  V4(e, t);
  function e(r) {
    var n = this, i = r || {};
    n = t.call(this, {
      element: document.createElement("div"),
      render: i.render,
      target: i.target
    }) || this;
    var l = i.className !== void 0 ? i.className : "ol-rotate", h = i.label !== void 0 ? i.label : "\u21E7", s = i.compassClassName !== void 0 ? i.compassClassName : "ol-compass";
    n.label_ = null, typeof h == "string" ? (n.label_ = document.createElement("span"), n.label_.className = s, n.label_.textContent = h) : (n.label_ = h, n.label_.classList.add(s));
    var m = i.tipLabel ? i.tipLabel : "Reset rotation", v = document.createElement("button");
    v.className = l + "-reset", v.setAttribute("type", "button"), v.title = m, v.appendChild(n.label_), v.addEventListener(_r.CLICK, n.handleClick_.bind(n), !1);
    var E = l + " " + mu + " " + jh, T = n.element;
    return T.className = E, T.appendChild(v), n.callResetNorth_ = i.resetNorth ? i.resetNorth : void 0, n.duration_ = i.duration !== void 0 ? i.duration : 250, n.autoHide_ = i.autoHide !== void 0 ? i.autoHide : !0, n.rotation_ = void 0, n.autoHide_ && n.element.classList.add(Rm), n;
  }
  return e.prototype.handleClick_ = function(r) {
    r.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }, e.prototype.resetNorth_ = function() {
    var r = this.getMap(), n = r.getView();
    if (!!n) {
      var i = n.getRotation();
      i !== void 0 && (this.duration_ > 0 && i % (2 * Math.PI) !== 0 ? n.animate({
        rotation: 0,
        duration: this.duration_,
        easing: Gh
      }) : n.setRotation(0));
    }
  }, e.prototype.render = function(r) {
    var n = r.frameState;
    if (!!n) {
      var i = n.viewState.rotation;
      if (i != this.rotation_) {
        var l = "rotate(" + i + "rad)";
        if (this.autoHide_) {
          var h = this.element.classList.contains(Rm);
          !h && i === 0 ? this.element.classList.add(Rm) : h && i !== 0 && this.element.classList.remove(Rm);
        }
        this.label_.style.transform = l;
      }
      this.rotation_ = i;
    }
  }, e;
}(qh);
const G4 = j4;
var q4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), W4 = function(t) {
  q4(e, t);
  function e(r) {
    var n = this, i = r || {};
    n = t.call(this, {
      element: document.createElement("div"),
      target: i.target
    }) || this;
    var l = i.className !== void 0 ? i.className : "ol-zoom", h = i.delta !== void 0 ? i.delta : 1, s = i.zoomInClassName !== void 0 ? i.zoomInClassName : l + "-in", m = i.zoomOutClassName !== void 0 ? i.zoomOutClassName : l + "-out", v = i.zoomInLabel !== void 0 ? i.zoomInLabel : "+", E = i.zoomOutLabel !== void 0 ? i.zoomOutLabel : "\u2013", T = i.zoomInTipLabel !== void 0 ? i.zoomInTipLabel : "Zoom in", S = i.zoomOutTipLabel !== void 0 ? i.zoomOutTipLabel : "Zoom out", A = document.createElement("button");
    A.className = s, A.setAttribute("type", "button"), A.title = T, A.appendChild(typeof v == "string" ? document.createTextNode(v) : v), A.addEventListener(_r.CLICK, n.handleClick_.bind(n, h), !1);
    var L = document.createElement("button");
    L.className = m, L.setAttribute("type", "button"), L.title = S, L.appendChild(typeof E == "string" ? document.createTextNode(E) : E), L.addEventListener(_r.CLICK, n.handleClick_.bind(n, -h), !1);
    var B = l + " " + mu + " " + jh, j = n.element;
    return j.className = B, j.appendChild(A), j.appendChild(L), n.duration_ = i.duration !== void 0 ? i.duration : 250, n;
  }
  return e.prototype.handleClick_ = function(r, n) {
    n.preventDefault(), this.zoomByDelta_(r);
  }, e.prototype.zoomByDelta_ = function(r) {
    var n = this.getMap(), i = n.getView();
    if (!!i) {
      var l = i.getZoom();
      if (l !== void 0) {
        var h = i.getConstrainedZoom(l + r);
        this.duration_ > 0 ? (i.getAnimating() && i.cancelAnimations(), i.animate({
          zoom: h,
          duration: this.duration_,
          easing: Gh
        })) : i.setZoom(h);
      }
    }
  }, e;
}(qh);
const iM = W4;
var X4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), hE = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "MSFullscreenChange"
], fE = {
  ENTERFULLSCREEN: "enterfullscreen",
  LEAVEFULLSCREEN: "leavefullscreen"
}, Z4 = function(t) {
  X4(e, t);
  function e(r) {
    var n = this, i = r || {};
    n = t.call(this, {
      element: document.createElement("div"),
      target: i.target
    }) || this, n.on, n.once, n.un, n.keys_ = i.keys !== void 0 ? i.keys : !1, n.source_ = i.source, n.isInFullscreen_ = !1, n.boundHandleMapTargetChange_ = n.handleMapTargetChange_.bind(n), n.cssClassName_ = i.className !== void 0 ? i.className : "ol-full-screen", n.documentListeners_ = [], n.activeClassName_ = i.activeClassName !== void 0 ? i.activeClassName.split(" ") : [n.cssClassName_ + "-true"], n.inactiveClassName_ = i.inactiveClassName !== void 0 ? i.inactiveClassName.split(" ") : [n.cssClassName_ + "-false"];
    var l = i.label !== void 0 ? i.label : "\u2922";
    n.labelNode_ = typeof l == "string" ? document.createTextNode(l) : l;
    var h = i.labelActive !== void 0 ? i.labelActive : "\xD7";
    n.labelActiveNode_ = typeof h == "string" ? document.createTextNode(h) : h;
    var s = i.tipLabel ? i.tipLabel : "Toggle full-screen";
    return n.button_ = document.createElement("button"), n.button_.title = s, n.button_.setAttribute("type", "button"), n.button_.appendChild(n.labelNode_), n.button_.addEventListener(_r.CLICK, n.handleClick_.bind(n), !1), n.setClassName_(n.button_, n.isInFullscreen_), n.element.className = "".concat(n.cssClassName_, " ").concat(mu, " ").concat(jh), n.element.appendChild(n.button_), n;
  }
  return e.prototype.handleClick_ = function(r) {
    r.preventDefault(), this.handleFullScreen_();
  }, e.prototype.handleFullScreen_ = function() {
    var r = this.getMap();
    if (!!r) {
      var n = r.getOwnerDocument();
      if (!!dE(n))
        if (pE(n))
          K4(n);
        else {
          var i = void 0;
          this.source_ ? i = typeof this.source_ == "string" ? n.getElementById(this.source_) : this.source_ : i = r.getTargetElement(), this.keys_ ? H4(i) : oM(i);
        }
    }
  }, e.prototype.handleFullScreenChange_ = function() {
    var r = this.getMap();
    if (!!r) {
      var n = this.isInFullscreen_;
      this.isInFullscreen_ = pE(r.getOwnerDocument()), n !== this.isInFullscreen_ && (this.setClassName_(this.button_, this.isInFullscreen_), this.isInFullscreen_ ? (jg(this.labelActiveNode_, this.labelNode_), this.dispatchEvent(fE.ENTERFULLSCREEN)) : (jg(this.labelNode_, this.labelActiveNode_), this.dispatchEvent(fE.LEAVEFULLSCREEN)), r.updateSize());
    }
  }, e.prototype.setClassName_ = function(r, n) {
    var i, l, h, s;
    n ? ((i = r.classList).remove.apply(i, this.inactiveClassName_), (l = r.classList).add.apply(l, this.activeClassName_)) : ((h = r.classList).remove.apply(h, this.activeClassName_), (s = r.classList).add.apply(s, this.inactiveClassName_));
  }, e.prototype.setMap = function(r) {
    var n = this.getMap();
    n && n.removeChangeListener(Mi.TARGET, this.boundHandleMapTargetChange_), t.prototype.setMap.call(this, r), this.handleMapTargetChange_(), r && r.addChangeListener(Mi.TARGET, this.boundHandleMapTargetChange_);
  }, e.prototype.handleMapTargetChange_ = function() {
    for (var r = this.documentListeners_, n = 0, i = r.length; n < i; ++n)
      $n(r[n]);
    r.length = 0;
    var l = this.getMap();
    if (l) {
      var h = l.getOwnerDocument();
      dE(h) ? this.element.classList.remove(Qw) : this.element.classList.add(Qw);
      for (var n = 0, i = hE.length; n < i; ++n)
        r.push(Fr(h, hE[n], this.handleFullScreenChange_, this));
      this.handleFullScreenChange_();
    }
  }, e;
}(qh);
function dE(t) {
  var e = t.body;
  return !!(e.webkitRequestFullscreen || e.msRequestFullscreen && t.msFullscreenEnabled || e.requestFullscreen && t.fullscreenEnabled);
}
function pE(t) {
  return !!(t.webkitIsFullScreen || t.msFullscreenElement || t.fullscreenElement);
}
function oM(t) {
  t.requestFullscreen ? t.requestFullscreen() : t.msRequestFullscreen ? t.msRequestFullscreen() : t.webkitRequestFullscreen && t.webkitRequestFullscreen();
}
function H4(t) {
  t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : oM(t);
}
function K4(t) {
  t.exitFullscreen ? t.exitFullscreen() : t.msExitFullscreen ? t.msExitFullscreen() : t.webkitExitFullscreen && t.webkitExitFullscreen();
}
const Y4 = Z4;
var J4 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Q4 = function(t) {
  J4(e, t);
  function e(r) {
    var n = this, i = r || {};
    n = t.call(this, {
      element: document.createElement("div"),
      target: i.target
    }) || this, n.extent = i.extent ? i.extent : null;
    var l = i.className !== void 0 ? i.className : "ol-zoom-extent", h = i.label !== void 0 ? i.label : "E", s = i.tipLabel !== void 0 ? i.tipLabel : "Fit to extent", m = document.createElement("button");
    m.setAttribute("type", "button"), m.title = s, m.appendChild(typeof h == "string" ? document.createTextNode(h) : h), m.addEventListener(_r.CLICK, n.handleClick_.bind(n), !1);
    var v = l + " " + mu + " " + jh, E = n.element;
    return E.className = v, E.appendChild(m), n;
  }
  return e.prototype.handleClick_ = function(r) {
    r.preventDefault(), this.handleZoomToExtent();
  }, e.prototype.handleZoomToExtent = function() {
    var r = this.getMap(), n = r.getView(), i = this.extent ? this.extent : n.getProjection().getExtent();
    n.fitInternal(R0(i));
  }, e;
}(qh);
const e6 = Q4;
function t6(t) {
  var e = t || {}, r = new Ia(), n = e.zoom !== void 0 ? e.zoom : !0;
  n && r.push(new iM(e.zoomOptions));
  var i = e.rotate !== void 0 ? e.rotate : !0;
  i && r.push(new G4(e.rotateOptions));
  var l = e.attribution !== void 0 ? e.attribution : !0;
  return l && r.push(new nM(e.attributionOptions)), r;
}
const mE = {
  ACTIVE: "active"
};
var r6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), n6 = function(t) {
  r6(e, t);
  function e(r) {
    var n = t.call(this) || this;
    return n.on, n.once, n.un, r && r.handleEvent && (n.handleEvent = r.handleEvent), n.map_ = null, n.setActive(!0), n;
  }
  return e.prototype.getActive = function() {
    return this.get(mE.ACTIVE);
  }, e.prototype.getMap = function() {
    return this.map_;
  }, e.prototype.handleEvent = function(r) {
    return !0;
  }, e.prototype.setActive = function(r) {
    this.set(mE.ACTIVE, r);
  }, e.prototype.setMap = function(r) {
    this.map_ = r;
  }, e;
}(Zs);
function i6(t, e, r) {
  var n = t.getCenterInternal();
  if (n) {
    var i = [n[0] + e[0], n[1] + e[1]];
    t.animateInternal({
      duration: r !== void 0 ? r : 250,
      easing: Hz,
      center: t.getConstrainedCenter(i)
    });
  }
}
function zx(t, e, r, n) {
  var i = t.getZoom();
  if (i !== void 0) {
    var l = t.getConstrainedZoom(i + e), h = t.getResolutionForZoom(l);
    t.getAnimating() && t.cancelAnimations(), t.animate({
      resolution: h,
      anchor: r,
      duration: n !== void 0 ? n : 250,
      easing: Gh
    });
  }
}
const np = n6;
var o6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), a6 = function(t) {
  o6(e, t);
  function e(r) {
    var n = t.call(this) || this, i = r || {};
    return n.delta_ = i.delta ? i.delta : 1, n.duration_ = i.duration !== void 0 ? i.duration : 250, n;
  }
  return e.prototype.handleEvent = function(r) {
    var n = !1;
    if (r.type == Xn.DBLCLICK) {
      var i = r.originalEvent, l = r.map, h = r.coordinate, s = i.shiftKey ? -this.delta_ : this.delta_, m = l.getView();
      zx(m, s, h, this.duration_), i.preventDefault(), n = !0;
    }
    return !n;
  }, e;
}(np);
const s6 = a6;
var l6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), c6 = function(t) {
  l6(e, t);
  function e(r) {
    var n = this, i = r || {};
    return n = t.call(
      this,
      i
    ) || this, i.handleDownEvent && (n.handleDownEvent = i.handleDownEvent), i.handleDragEvent && (n.handleDragEvent = i.handleDragEvent), i.handleMoveEvent && (n.handleMoveEvent = i.handleMoveEvent), i.handleUpEvent && (n.handleUpEvent = i.handleUpEvent), i.stopDown && (n.stopDown = i.stopDown), n.handlingDownUpSequence = !1, n.targetPointers = [], n;
  }
  return e.prototype.getPointerCount = function() {
    return this.targetPointers.length;
  }, e.prototype.handleDownEvent = function(r) {
    return !1;
  }, e.prototype.handleDragEvent = function(r) {
  }, e.prototype.handleEvent = function(r) {
    if (!r.originalEvent)
      return !0;
    var n = !1;
    if (this.updateTrackedPointers_(r), this.handlingDownUpSequence) {
      if (r.type == Xn.POINTERDRAG)
        this.handleDragEvent(r), r.originalEvent.preventDefault();
      else if (r.type == Xn.POINTERUP) {
        var i = this.handleUpEvent(r);
        this.handlingDownUpSequence = i && this.targetPointers.length > 0;
      }
    } else if (r.type == Xn.POINTERDOWN) {
      var l = this.handleDownEvent(r);
      this.handlingDownUpSequence = l, n = this.stopDown(l);
    } else
      r.type == Xn.POINTERMOVE && this.handleMoveEvent(r);
    return !n;
  }, e.prototype.handleMoveEvent = function(r) {
  }, e.prototype.handleUpEvent = function(r) {
    return !1;
  }, e.prototype.stopDown = function(r) {
    return r;
  }, e.prototype.updateTrackedPointers_ = function(r) {
    r.activePointers && (this.targetPointers = r.activePointers);
  }, e;
}(np);
function Bx(t) {
  for (var e = t.length, r = 0, n = 0, i = 0; i < e; i++)
    r += t[i].clientX, n += t[i].clientY;
  return [r / e, n / e];
}
const ip = c6;
function L0(t) {
  var e = arguments;
  return function(r) {
    for (var n = !0, i = 0, l = e.length; i < l && (n = n && e[i](r), !!n); ++i)
      ;
    return n;
  };
}
var u6 = function(t) {
  var e = t.originalEvent;
  return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, h6 = function(t) {
  var e = t.map.getTargetElement(), r = t.map.getOwnerDocument().activeElement;
  return e.contains(r);
}, aM = function(t) {
  return t.map.getTargetElement().hasAttribute("tabindex") ? h6(t) : !0;
}, f6 = gd, sM = function(t) {
  var e = t.originalEvent;
  return e.button == 0 && !(W5 && X5 && e.ctrlKey);
}, lM = function(t) {
  var e = t.originalEvent;
  return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, d6 = function(t) {
  var e = t.originalEvent;
  return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, cM = function(t) {
  var e = t.originalEvent, r = e.target.tagName;
  return r !== "INPUT" && r !== "SELECT" && r !== "TEXTAREA" && !e.target.isContentEditable;
}, _v = function(t) {
  var e = t.originalEvent;
  return en(e !== void 0, 56), e.pointerType == "mouse";
}, p6 = function(t) {
  var e = t.originalEvent;
  return en(e !== void 0, 56), e.isPrimary && e.button === 0;
}, m6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), g6 = function(t) {
  m6(e, t);
  function e(r) {
    var n = t.call(this, {
      stopDown: Uy
    }) || this, i = r || {};
    n.kinetic_ = i.kinetic, n.lastCentroid = null, n.lastPointersCount_, n.panning_ = !1;
    var l = i.condition ? i.condition : L0(lM, p6);
    return n.condition_ = i.onFocusOnly ? L0(aM, l) : l, n.noKinetic_ = !1, n;
  }
  return e.prototype.handleDragEvent = function(r) {
    this.panning_ || (this.panning_ = !0, this.getMap().getView().beginInteraction());
    var n = this.targetPointers, i = Bx(n);
    if (n.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(i[0], i[1]), this.lastCentroid) {
        var l = [
          this.lastCentroid[0] - i[0],
          i[1] - this.lastCentroid[1]
        ], h = r.map, s = h.getView();
        AD(l, s.getResolution()), _x(l, s.getRotation()), s.adjustCenterInternal(l);
      }
    } else
      this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = i, this.lastPointersCount_ = n.length, r.originalEvent.preventDefault();
  }, e.prototype.handleUpEvent = function(r) {
    var n = r.map, i = n.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        var l = this.kinetic_.getDistance(), h = this.kinetic_.getAngle(), s = i.getCenterInternal(), m = n.getPixelFromCoordinateInternal(s), v = n.getCoordinateFromPixelInternal([
          m[0] - l * Math.cos(h),
          m[1] - l * Math.sin(h)
        ]);
        i.animateInternal({
          center: i.getConstrainedCenter(v),
          duration: 500,
          easing: Gh
        });
      }
      return this.panning_ && (this.panning_ = !1, i.endInteraction()), !1;
    } else
      return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }, e.prototype.handleDownEvent = function(r) {
    if (this.targetPointers.length > 0 && this.condition_(r)) {
      var n = r.map, i = n.getView();
      return this.lastCentroid = null, i.getAnimating() && i.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    } else
      return !1;
  }, e;
}(ip);
const y6 = g6;
var _6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), v6 = function(t) {
  _6(e, t);
  function e(r) {
    var n = this, i = r || {};
    return n = t.call(this, {
      stopDown: Uy
    }) || this, n.condition_ = i.condition ? i.condition : u6, n.lastAngle_ = void 0, n.duration_ = i.duration !== void 0 ? i.duration : 250, n;
  }
  return e.prototype.handleDragEvent = function(r) {
    if (!!_v(r)) {
      var n = r.map, i = n.getView();
      if (i.getConstraints().rotation !== Nx) {
        var l = n.getSize(), h = r.pixel, s = Math.atan2(l[1] / 2 - h[1], h[0] - l[0] / 2);
        if (this.lastAngle_ !== void 0) {
          var m = s - this.lastAngle_;
          i.adjustRotationInternal(-m);
        }
        this.lastAngle_ = s;
      }
    }
  }, e.prototype.handleUpEvent = function(r) {
    if (!_v(r))
      return !0;
    var n = r.map, i = n.getView();
    return i.endInteraction(this.duration_), !1;
  }, e.prototype.handleDownEvent = function(r) {
    if (!_v(r))
      return !1;
    if (sM(r) && this.condition_(r)) {
      var n = r.map;
      return n.getView().beginInteraction(), this.lastAngle_ = void 0, !0;
    } else
      return !1;
  }, e;
}(ip);
const x6 = v6;
var b6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), w6 = function(t) {
  b6(e, t);
  function e(r) {
    var n = t.call(this) || this;
    return n.geometry_ = null, n.element_ = document.createElement("div"), n.element_.style.position = "absolute", n.element_.style.pointerEvents = "auto", n.element_.className = "ol-box " + r, n.map_ = null, n.startPixel_ = null, n.endPixel_ = null, n;
  }
  return e.prototype.disposeInternal = function() {
    this.setMap(null);
  }, e.prototype.render_ = function() {
    var r = this.startPixel_, n = this.endPixel_, i = "px", l = this.element_.style;
    l.left = Math.min(r[0], n[0]) + i, l.top = Math.min(r[1], n[1]) + i, l.width = Math.abs(n[0] - r[0]) + i, l.height = Math.abs(n[1] - r[1]) + i;
  }, e.prototype.setMap = function(r) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      var n = this.element_.style;
      n.left = "inherit", n.top = "inherit", n.width = "inherit", n.height = "inherit";
    }
    this.map_ = r, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }, e.prototype.setPixels = function(r, n) {
    this.startPixel_ = r, this.endPixel_ = n, this.createOrUpdateGeometry(), this.render_();
  }, e.prototype.createOrUpdateGeometry = function() {
    var r = this.startPixel_, n = this.endPixel_, i = [
      r,
      [r[0], n[1]],
      n,
      [n[0], r[1]]
    ], l = i.map(this.map_.getCoordinateFromPixelInternal, this.map_);
    l[4] = l[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([l]) : this.geometry_ = new eM([l]);
  }, e.prototype.getGeometry = function() {
    return this.geometry_;
  }, e;
}(Px);
const E6 = w6;
var uM = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), km = {
  BOXSTART: "boxstart",
  BOXDRAG: "boxdrag",
  BOXEND: "boxend",
  BOXCANCEL: "boxcancel"
}, vv = function(t) {
  uM(e, t);
  function e(r, n, i) {
    var l = t.call(this, r) || this;
    return l.coordinate = n, l.mapBrowserEvent = i, l;
  }
  return e;
}(Xs), T6 = function(t) {
  uM(e, t);
  function e(r) {
    var n = t.call(this) || this;
    n.on, n.once, n.un;
    var i = r || {};
    return n.box_ = new E6(i.className || "ol-dragbox"), n.minArea_ = i.minArea !== void 0 ? i.minArea : 64, i.onBoxEnd && (n.onBoxEnd = i.onBoxEnd), n.startPixel_ = null, n.condition_ = i.condition ? i.condition : sM, n.boxEndCondition_ = i.boxEndCondition ? i.boxEndCondition : n.defaultBoxEndCondition, n;
  }
  return e.prototype.defaultBoxEndCondition = function(r, n, i) {
    var l = i[0] - n[0], h = i[1] - n[1];
    return l * l + h * h >= this.minArea_;
  }, e.prototype.getGeometry = function() {
    return this.box_.getGeometry();
  }, e.prototype.handleDragEvent = function(r) {
    this.box_.setPixels(this.startPixel_, r.pixel), this.dispatchEvent(new vv(km.BOXDRAG, r.coordinate, r));
  }, e.prototype.handleUpEvent = function(r) {
    this.box_.setMap(null);
    var n = this.boxEndCondition_(r, this.startPixel_, r.pixel);
    return n && this.onBoxEnd(r), this.dispatchEvent(new vv(n ? km.BOXEND : km.BOXCANCEL, r.coordinate, r)), !1;
  }, e.prototype.handleDownEvent = function(r) {
    return this.condition_(r) ? (this.startPixel_ = r.pixel, this.box_.setMap(r.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(new vv(km.BOXSTART, r.coordinate, r)), !0) : !1;
  }, e.prototype.onBoxEnd = function(r) {
  }, e;
}(ip);
const S6 = T6;
var M6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), C6 = function(t) {
  M6(e, t);
  function e(r) {
    var n = this, i = r || {}, l = i.condition ? i.condition : d6;
    return n = t.call(this, {
      condition: l,
      className: i.className || "ol-dragzoom",
      minArea: i.minArea
    }) || this, n.duration_ = i.duration !== void 0 ? i.duration : 200, n.out_ = i.out !== void 0 ? i.out : !1, n;
  }
  return e.prototype.onBoxEnd = function(r) {
    var n = this.getMap(), i = n.getView(), l = this.getGeometry();
    if (this.out_) {
      var h = i.rotatedExtentForGeometry(l), s = i.getResolutionForExtentInternal(h), m = i.getResolution() / s;
      l = l.clone(), l.scale(m * m);
    }
    i.fitInternal(l, {
      duration: this.duration_,
      easing: Gh
    });
  }, e;
}(S6);
const I6 = C6, kc = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
var P6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), A6 = function(t) {
  P6(e, t);
  function e(r) {
    var n = t.call(this) || this, i = r || {};
    return n.defaultCondition_ = function(l) {
      return lM(l) && cM(l);
    }, n.condition_ = i.condition !== void 0 ? i.condition : n.defaultCondition_, n.duration_ = i.duration !== void 0 ? i.duration : 100, n.pixelDelta_ = i.pixelDelta !== void 0 ? i.pixelDelta : 128, n;
  }
  return e.prototype.handleEvent = function(r) {
    var n = !1;
    if (r.type == _r.KEYDOWN) {
      var i = r.originalEvent, l = i.keyCode;
      if (this.condition_(r) && (l == kc.DOWN || l == kc.LEFT || l == kc.RIGHT || l == kc.UP)) {
        var h = r.map, s = h.getView(), m = s.getResolution() * this.pixelDelta_, v = 0, E = 0;
        l == kc.DOWN ? E = -m : l == kc.LEFT ? v = -m : l == kc.RIGHT ? v = m : E = m;
        var T = [v, E];
        _x(T, s.getRotation()), i6(s, T, this.duration_), i.preventDefault(), n = !0;
      }
    }
    return !n;
  }, e;
}(np);
const O6 = A6;
var R6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), L6 = function(t) {
  R6(e, t);
  function e(r) {
    var n = t.call(this) || this, i = r || {};
    return n.condition_ = i.condition ? i.condition : cM, n.delta_ = i.delta ? i.delta : 1, n.duration_ = i.duration !== void 0 ? i.duration : 100, n;
  }
  return e.prototype.handleEvent = function(r) {
    var n = !1;
    if (r.type == _r.KEYDOWN || r.type == _r.KEYPRESS) {
      var i = r.originalEvent, l = i.charCode;
      if (this.condition_(r) && (l == "+".charCodeAt(0) || l == "-".charCodeAt(0))) {
        var h = r.map, s = l == "+".charCodeAt(0) ? this.delta_ : -this.delta_, m = h.getView();
        zx(m, s, void 0, this.duration_), i.preventDefault(), n = !0;
      }
    }
    return !n;
  }, e;
}(np);
const D6 = L6;
var k6 = function() {
  function t(e, r, n) {
    this.decay_ = e, this.minVelocity_ = r, this.delay_ = n, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  return t.prototype.begin = function() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }, t.prototype.update = function(e, r) {
    this.points_.push(e, r, Date.now());
  }, t.prototype.end = function() {
    if (this.points_.length < 6)
      return !1;
    var e = Date.now() - this.delay_, r = this.points_.length - 3;
    if (this.points_[r + 2] < e)
      return !1;
    for (var n = r - 3; n > 0 && this.points_[n + 2] > e; )
      n -= 3;
    var i = this.points_[r + 2] - this.points_[n + 2];
    if (i < 1e3 / 60)
      return !1;
    var l = this.points_[r] - this.points_[n], h = this.points_[r + 1] - this.points_[n + 1];
    return this.angle_ = Math.atan2(h, l), this.initialVelocity_ = Math.sqrt(l * l + h * h) / i, this.initialVelocity_ > this.minVelocity_;
  }, t.prototype.getDistance = function() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }, t.prototype.getAngle = function() {
    return this.angle_;
  }, t;
}();
const N6 = k6;
var F6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), xv = {
  TRACKPAD: "trackpad",
  WHEEL: "wheel"
}, z6 = function(t) {
  F6(e, t);
  function e(r) {
    var n = this, i = r || {};
    n = t.call(
      this,
      i
    ) || this, n.totalDelta_ = 0, n.lastDelta_ = 0, n.maxDelta_ = i.maxDelta !== void 0 ? i.maxDelta : 1, n.duration_ = i.duration !== void 0 ? i.duration : 250, n.timeout_ = i.timeout !== void 0 ? i.timeout : 80, n.useAnchor_ = i.useAnchor !== void 0 ? i.useAnchor : !0, n.constrainResolution_ = i.constrainResolution !== void 0 ? i.constrainResolution : !1;
    var l = i.condition ? i.condition : f6;
    return n.condition_ = i.onFocusOnly ? L0(aM, l) : l, n.lastAnchor_ = null, n.startTime_ = void 0, n.timeoutId_, n.mode_ = void 0, n.trackpadEventGap_ = 400, n.trackpadTimeoutId_, n.deltaPerZoom_ = 300, n;
  }
  return e.prototype.endInteraction_ = function() {
    this.trackpadTimeoutId_ = void 0;
    var r = this.getMap();
    if (!!r) {
      var n = r.getView();
      n.endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
    }
  }, e.prototype.handleEvent = function(r) {
    if (!this.condition_(r))
      return !0;
    var n = r.type;
    if (n !== _r.WHEEL)
      return !0;
    var i = r.map, l = r.originalEvent;
    l.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = r.coordinate);
    var h;
    if (r.type == _r.WHEEL && (h = l.deltaY, G5 && l.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (h /= L2), l.deltaMode === WheelEvent.DOM_DELTA_LINE && (h *= 40)), h === 0)
      return !1;
    this.lastDelta_ = h;
    var s = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = s), (!this.mode_ || s - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(h) < 4 ? xv.TRACKPAD : xv.WHEEL);
    var m = i.getView();
    if (this.mode_ === xv.TRACKPAD && !(m.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (m.getAnimating() && m.cancelAnimations(), m.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_), m.adjustZoom(-h / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = s, !1;
    this.totalDelta_ += h;
    var v = Math.max(this.timeout_ - (s - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, i), v), !1;
  }, e.prototype.handleWheelZoom_ = function(r) {
    var n = r.getView();
    n.getAnimating() && n.cancelAnimations();
    var i = -hi(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
    (n.getConstrainResolution() || this.constrainResolution_) && (i = i ? i > 0 ? 1 : -1 : 0), zx(n, i, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }, e.prototype.setMouseAnchor = function(r) {
    this.useAnchor_ = r, r || (this.lastAnchor_ = null);
  }, e;
}(np);
const B6 = z6;
var U6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), $6 = function(t) {
  U6(e, t);
  function e(r) {
    var n = this, i = r || {}, l = i;
    return l.stopDown || (l.stopDown = Uy), n = t.call(this, l) || this, n.anchor_ = null, n.lastAngle_ = void 0, n.rotating_ = !1, n.rotationDelta_ = 0, n.threshold_ = i.threshold !== void 0 ? i.threshold : 0.3, n.duration_ = i.duration !== void 0 ? i.duration : 250, n;
  }
  return e.prototype.handleDragEvent = function(r) {
    var n = 0, i = this.targetPointers[0], l = this.targetPointers[1], h = Math.atan2(l.clientY - i.clientY, l.clientX - i.clientX);
    if (this.lastAngle_ !== void 0) {
      var s = h - this.lastAngle_;
      this.rotationDelta_ += s, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), n = s;
    }
    this.lastAngle_ = h;
    var m = r.map, v = m.getView();
    if (v.getConstraints().rotation !== Nx) {
      var E = m.getViewport().getBoundingClientRect(), T = Bx(this.targetPointers);
      T[0] -= E.left, T[1] -= E.top, this.anchor_ = m.getCoordinateFromPixelInternal(T), this.rotating_ && (m.render(), v.adjustRotationInternal(n, this.anchor_));
    }
  }, e.prototype.handleUpEvent = function(r) {
    if (this.targetPointers.length < 2) {
      var n = r.map, i = n.getView();
      return i.endInteraction(this.duration_), !1;
    } else
      return !0;
  }, e.prototype.handleDownEvent = function(r) {
    if (this.targetPointers.length >= 2) {
      var n = r.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || n.getView().beginInteraction(), !0;
    } else
      return !1;
  }, e;
}(ip);
const V6 = $6;
var j6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), G6 = function(t) {
  j6(e, t);
  function e(r) {
    var n = this, i = r || {}, l = i;
    return l.stopDown || (l.stopDown = Uy), n = t.call(this, l) || this, n.anchor_ = null, n.duration_ = i.duration !== void 0 ? i.duration : 400, n.lastDistance_ = void 0, n.lastScaleDelta_ = 1, n;
  }
  return e.prototype.handleDragEvent = function(r) {
    var n = 1, i = this.targetPointers[0], l = this.targetPointers[1], h = i.clientX - l.clientX, s = i.clientY - l.clientY, m = Math.sqrt(h * h + s * s);
    this.lastDistance_ !== void 0 && (n = this.lastDistance_ / m), this.lastDistance_ = m;
    var v = r.map, E = v.getView();
    n != 1 && (this.lastScaleDelta_ = n);
    var T = v.getViewport().getBoundingClientRect(), S = Bx(this.targetPointers);
    S[0] -= T.left, S[1] -= T.top, this.anchor_ = v.getCoordinateFromPixelInternal(S), v.render(), E.adjustResolutionInternal(n, this.anchor_);
  }, e.prototype.handleUpEvent = function(r) {
    if (this.targetPointers.length < 2) {
      var n = r.map, i = n.getView(), l = this.lastScaleDelta_ > 1 ? 1 : -1;
      return i.endInteraction(this.duration_, l), !1;
    } else
      return !0;
  }, e.prototype.handleDownEvent = function(r) {
    if (this.targetPointers.length >= 2) {
      var n = r.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || n.getView().beginInteraction(), !0;
    } else
      return !1;
  }, e;
}(ip);
const q6 = G6, Mn = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
var W6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), X6 = function(t) {
  W6(e, t);
  function e(r) {
    var n = t.call(this) || this;
    return n.ready = !0, n.boundHandleImageChange_ = n.handleImageChange_.bind(n), n.layer_ = r, n.declutterExecutorGroup = null, n;
  }
  return e.prototype.getFeatures = function(r) {
    return En();
  }, e.prototype.getData = function(r) {
    return null;
  }, e.prototype.prepareFrame = function(r) {
    return En();
  }, e.prototype.renderFrame = function(r, n) {
    return En();
  }, e.prototype.loadedTileCallback = function(r, n, i) {
    r[n] || (r[n] = {}), r[n][i.tileCoord.toString()] = i;
  }, e.prototype.createLoadedTileFinder = function(r, n, i) {
    return function(l, h) {
      var s = this.loadedTileCallback.bind(this, i, l);
      return r.forEachLoadedTile(n, l, h, s);
    }.bind(this);
  }, e.prototype.forEachFeatureAtCoordinate = function(r, n, i, l, h) {
  }, e.prototype.getDataAtPixel = function(r, n, i) {
    return null;
  }, e.prototype.getLayer = function() {
    return this.layer_;
  }, e.prototype.handleFontsChanged = function() {
  }, e.prototype.handleImageChange_ = function(r) {
    var n = r.target;
    n.getState() === Mn.LOADED && this.renderIfReadyAndVisible();
  }, e.prototype.loadImage = function(r) {
    var n = r.getState();
    return n != Mn.LOADED && n != Mn.ERROR && r.addEventListener(_r.CHANGE, this.boundHandleImageChange_), n == Mn.IDLE && (r.load(), n = r.getState()), n == Mn.LOADED;
  }, e.prototype.renderIfReadyAndVisible = function() {
    var r = this.getLayer();
    r && r.getVisible() && r.getSourceState() === "ready" && r.changed();
  }, e.prototype.disposeInternal = function() {
    delete this.layer_, t.prototype.disposeInternal.call(this);
  }, e;
}(tp);
const Z6 = X6;
var H6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), sh = null;
function K6() {
  var t = document.createElement("canvas");
  t.width = 1, t.height = 1, sh = t.getContext("2d");
}
var Y6 = function(t) {
  H6(e, t);
  function e(r) {
    var n = t.call(this, r) || this;
    return n.container = null, n.renderedResolution, n.tempTransform = Ih(), n.pixelTransform = Ih(), n.inversePixelTransform = Ih(), n.context = null, n.containerReused = !1, n.pixelContext_ = null, n.frameState = null, n;
  }
  return e.prototype.getImageData = function(r, n, i) {
    sh || K6(), sh.clearRect(0, 0, 1, 1);
    var l;
    try {
      sh.drawImage(r, n, i, 1, 1, 0, 0, 1, 1), l = sh.getImageData(0, 0, 1, 1).data;
    } catch {
      return sh = null, null;
    }
    return l;
  }, e.prototype.getBackground = function(r) {
    var n = this.getLayer(), i = n.getBackground();
    return typeof i == "function" && (i = i(r.viewState.resolution)), i || void 0;
  }, e.prototype.useContainer = function(r, n, i) {
    var l = this.getLayer().getClassName(), h, s;
    if (r && r.className === l && (!i || r && r.style.backgroundColor && Ox(Hw(r.style.backgroundColor), Hw(i)))) {
      var m = r.firstElementChild;
      m instanceof HTMLCanvasElement && (s = m.getContext("2d"));
    }
    if (s && s.canvas.style.transform === n ? (this.container = r, this.context = s, this.containerReused = !0) : this.containerReused && (this.container = null, this.context = null, this.containerReused = !1), !this.container) {
      h = document.createElement("div"), h.className = l;
      var v = h.style;
      v.position = "absolute", v.width = "100%", v.height = "100%", s = Vg();
      var m = s.canvas;
      h.appendChild(m), v = m.style, v.position = "absolute", v.left = "0", v.transformOrigin = "top left", this.container = h, this.context = s;
    }
    !this.containerReused && i && !this.container.style.backgroundColor && (this.container.style.backgroundColor = i);
  }, e.prototype.clipUnrotated = function(r, n, i) {
    var l = Kl(i), h = ky(i), s = Dy(i), m = Ly(i);
    Xi(n.coordinateToPixelTransform, l), Xi(n.coordinateToPixelTransform, h), Xi(n.coordinateToPixelTransform, s), Xi(n.coordinateToPixelTransform, m);
    var v = this.inversePixelTransform;
    Xi(v, l), Xi(v, h), Xi(v, s), Xi(v, m), r.save(), r.beginPath(), r.moveTo(Math.round(l[0]), Math.round(l[1])), r.lineTo(Math.round(h[0]), Math.round(h[1])), r.lineTo(Math.round(s[0]), Math.round(s[1])), r.lineTo(Math.round(m[0]), Math.round(m[1])), r.clip();
  }, e.prototype.dispatchRenderEvent_ = function(r, n, i) {
    var l = this.getLayer();
    if (l.hasListener(r)) {
      var h = new $2(r, this.inversePixelTransform, i, n);
      l.dispatchEvent(h);
    }
  }, e.prototype.preRender = function(r, n) {
    this.frameState = n, this.dispatchRenderEvent_(ns.PRERENDER, r, n);
  }, e.prototype.postRender = function(r, n) {
    this.dispatchRenderEvent_(ns.POSTRENDER, r, n);
  }, e.prototype.getRenderTransform = function(r, n, i, l, h, s, m) {
    var v = h / 2, E = s / 2, T = l / n, S = -T, A = -r[0] + m, L = -r[1];
    return cu(this.tempTransform, v, E, T, S, -i, A, L);
  }, e.prototype.getDataAtPixel = function(r, n, i) {
    var l = Xi(this.inversePixelTransform, r.slice()), h = this.context, s = this.getLayer(), m = s.getExtent();
    if (m) {
      var v = Xi(n.pixelToCoordinateTransform, r.slice());
      if (!Xd(m, v))
        return null;
    }
    var E = Math.round(l[0]), T = Math.round(l[1]), S = this.pixelContext_;
    if (!S) {
      var A = document.createElement("canvas");
      A.width = 1, A.height = 1, S = A.getContext("2d"), this.pixelContext_ = S;
    }
    S.clearRect(0, 0, 1, 1);
    var L;
    try {
      S.drawImage(h.canvas, E, T, 1, 1, 0, 0, 1, 1), L = S.getImageData(0, 0, 1, 1).data;
    } catch (B) {
      return B.name === "SecurityError" ? (this.pixelContext_ = null, new Uint8Array()) : L;
    }
    return L[3] === 0 ? null : L;
  }, e.prototype.disposeInternal = function() {
    delete this.frameState, t.prototype.disposeInternal.call(this);
  }, e;
}(Z6);
const hM = Y6;
var J6 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Q6 = function(t) {
  J6(e, t);
  function e(r, n, i, l) {
    var h = t.call(this) || this;
    return h.extent = r, h.pixelRatio_ = i, h.resolution = n, h.state = l, h;
  }
  return e.prototype.changed = function() {
    this.dispatchEvent(_r.CHANGE);
  }, e.prototype.getExtent = function() {
    return this.extent;
  }, e.prototype.getImage = function() {
    return En();
  }, e.prototype.getPixelRatio = function() {
    return this.pixelRatio_;
  }, e.prototype.getResolution = function() {
    return this.resolution;
  }, e.prototype.getState = function() {
    return this.state;
  }, e.prototype.load = function() {
    En();
  }, e;
}(ep);
const fM = Q6;
var eB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), tB = function(t) {
  eB(e, t);
  function e(r, n, i, l, h, s) {
    var m = t.call(this, r, n, i, Mn.IDLE) || this;
    return m.src_ = l, m.image_ = new Image(), h !== null && (m.image_.crossOrigin = h), m.unlisten_ = null, m.state = Mn.IDLE, m.imageLoadFunction_ = s, m;
  }
  return e.prototype.getImage = function() {
    return this.image_;
  }, e.prototype.handleImageError_ = function() {
    this.state = Mn.ERROR, this.unlistenImage_(), this.changed();
  }, e.prototype.handleImageLoad_ = function() {
    this.resolution === void 0 && (this.resolution = Pi(this.extent) / this.image_.height), this.state = Mn.LOADED, this.unlistenImage_(), this.changed();
  }, e.prototype.load = function() {
    (this.state == Mn.IDLE || this.state == Mn.ERROR) && (this.state = Mn.LOADING, this.changed(), this.imageLoadFunction_(this, this.src_), this.unlisten_ = dM(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)));
  }, e.prototype.setImage = function(r) {
    this.image_ = r, this.resolution = Pi(this.extent) / this.image_.height;
  }, e.prototype.unlistenImage_ = function() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }, e;
}(fM);
function dM(t, e, r) {
  var n = t, i = !0, l = !1, h = !1, s = [
    Ug(n, _r.LOAD, function() {
      h = !0, l || e();
    })
  ];
  return n.src && Z5 ? (l = !0, n.decode().then(function() {
    i && e();
  }).catch(function(m) {
    i && (h ? e() : r());
  })) : s.push(Ug(n, _r.ERROR, r)), function() {
    i = !1, s.forEach($n);
  };
}
const rB = tB;
var nB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), iB = function(t) {
  nB(e, t);
  function e(r) {
    var n = t.call(this) || this;
    n.projection = fi(r.projection), n.attributions_ = gE(r.attributions), n.attributionsCollapsible_ = r.attributionsCollapsible !== void 0 ? r.attributionsCollapsible : !0, n.loading = !1, n.state_ = r.state !== void 0 ? r.state : "ready", n.wrapX_ = r.wrapX !== void 0 ? r.wrapX : !1, n.interpolate_ = !!r.interpolate, n.viewResolver = null, n.viewRejector = null;
    var i = n;
    return n.viewPromise_ = new Promise(function(l, h) {
      i.viewResolver = l, i.viewRejector = h;
    }), n;
  }
  return e.prototype.getAttributions = function() {
    return this.attributions_;
  }, e.prototype.getAttributionsCollapsible = function() {
    return this.attributionsCollapsible_;
  }, e.prototype.getProjection = function() {
    return this.projection;
  }, e.prototype.getResolutions = function() {
    return En();
  }, e.prototype.getView = function() {
    return this.viewPromise_;
  }, e.prototype.getState = function() {
    return this.state_;
  }, e.prototype.getWrapX = function() {
    return this.wrapX_;
  }, e.prototype.getInterpolate = function() {
    return this.interpolate_;
  }, e.prototype.refresh = function() {
    this.changed();
  }, e.prototype.setAttributions = function(r) {
    this.attributions_ = gE(r), this.changed();
  }, e.prototype.setState = function(r) {
    this.state_ = r, this.changed();
  }, e;
}(Zs);
function gE(t) {
  return t ? Array.isArray(t) ? function(e) {
    return t;
  } : typeof t == "function" ? t : function(e) {
    return [t];
  } : null;
}
const pM = iB;
function oB(t) {
  var e = t || {}, r = new Ia(), n = new N6(-5e-3, 0.05, 100), i = e.altShiftDragRotate !== void 0 ? e.altShiftDragRotate : !0;
  i && r.push(new x6());
  var l = e.doubleClickZoom !== void 0 ? e.doubleClickZoom : !0;
  l && r.push(new s6({
    delta: e.zoomDelta,
    duration: e.zoomDuration
  }));
  var h = e.dragPan !== void 0 ? e.dragPan : !0;
  h && r.push(new y6({
    onFocusOnly: e.onFocusOnly,
    kinetic: n
  }));
  var s = e.pinchRotate !== void 0 ? e.pinchRotate : !0;
  s && r.push(new V6());
  var m = e.pinchZoom !== void 0 ? e.pinchZoom : !0;
  m && r.push(new q6({
    duration: e.zoomDuration
  }));
  var v = e.keyboard !== void 0 ? e.keyboard : !0;
  v && (r.push(new O6()), r.push(new D6({
    delta: e.zoomDelta,
    duration: e.zoomDuration
  })));
  var E = e.mouseWheelZoom !== void 0 ? e.mouseWheelZoom : !0;
  E && r.push(new B6({
    onFocusOnly: e.onFocusOnly,
    duration: e.zoomDuration
  }));
  var T = e.shiftDragZoom !== void 0 ? e.shiftDragZoom : !0;
  return T && r.push(new I6({
    duration: e.zoomDuration
  })), r;
}
var aB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), sB = function(t) {
  aB(e, t);
  function e(r) {
    return r = In({}, r), r.controls || (r.controls = t6()), r.interactions || (r.interactions = oB({
      onFocusOnly: !0
    })), t.call(this, r) || this;
  }
  return e.prototype.createRenderer = function() {
    return new Mz(this);
  }, e;
}(F4);
const lB = sB, yd = "EPSG:3857", mM = "EPSG:4326", cB = "EPSG:2169";
let bv;
const yE = yi();
function zs() {
  function t() {
    return bv;
  }
  function e() {
    return yE.value = bv = new lB({
      view: new Al({
        zoom: 10,
        center: [682439, 6379152],
        multiWorld: !0
      }),
      controls: []
    }), bv;
  }
  function r(v, E) {
    return v === E;
  }
  function n(v, E) {
    var T;
    return (T = v.layers) == null ? void 0 : T.some((S) => r(E, S));
  }
  function i(v, E) {
    var S;
    return ((S = v == null ? void 0 : v.layers) == null ? void 0 : S.find((A) => A.id === E.id)) !== E;
  }
  function l(v, E) {
    return !(E === null || !("layers" in v) || !("layers" in E) || typeof E.layers > "u" || typeof v.layers > "u" || v.layers === E.layers);
  }
  function h(v, E) {
    return !("layers" in v) || typeof v.layers > "u" ? [] : E === null || !("layers" in E) ? v.layers.map((T, S) => ({ layer: T, position: S })) : v.layers === E.layers ? [] : v.layers.reduce(
      (T, S, A) => n(E, S) ? T : [
        ...T,
        {
          layer: S,
          position: A
        }
      ],
      []
    );
  }
  function s(v, E) {
    return l(v, E) ? E.layers.reduce(
      (T, S) => n(v, S) ? T : [...T, S],
      []
    ) : [];
  }
  function m(v, E) {
    return l(v, E) ? v.layers.reduce(
      (T, S) => i(E, S) ? [...T, S] : T,
      []
    ) : [];
  }
  return {
    olMap: yE,
    getOlMap: t,
    createMap: e,
    equalsLayer: r,
    hasLayer: n,
    layerHasChanged: i,
    contextHasChanged: l,
    getAddedLayers: h,
    getRemovedLayers: s,
    getMutatedLayers: m
  };
}
var uB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), hB = function(t) {
  uB(e, t);
  function e(r) {
    var n = r || {};
    return t.call(this, n) || this;
  }
  return e;
}(rp);
const fB = hB;
var gM = 0.5, wa = !0, qg = {
  imageSmoothingEnabled: !1,
  msImageSmoothingEnabled: !1
}, yM = {
  imageSmoothingEnabled: !0,
  msImageSmoothingEnabled: !0
}, dB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), pB = function(t) {
  dB(e, t);
  function e(r) {
    var n = t.call(this, r) || this;
    return n.image_ = null, n;
  }
  return e.prototype.getImage = function() {
    return this.image_ ? this.image_.getImage() : null;
  }, e.prototype.prepareFrame = function(r) {
    var n = r.layerStatesArray[r.layerIndex], i = r.pixelRatio, l = r.viewState, h = l.resolution, s = this.getLayer().getSource(), m = r.viewHints, v = r.extent;
    if (n.extent !== void 0 && (v = eu(v, Ll(n.extent, l.projection))), !m[To.ANIMATING] && !m[To.INTERACTING] && !Ny(v))
      if (s) {
        var E = l.projection;
        if (!wa) {
          var T = s.getProjection();
          T && (E = T);
        }
        var S = s.getImage(v, h, i, E);
        S && (this.loadImage(S) ? this.image_ = S : S.getState() === Mn.EMPTY && (this.image_ = null));
      } else
        this.image_ = null;
    return !!this.image_;
  }, e.prototype.getData = function(r) {
    var n = this.frameState;
    if (!n)
      return null;
    var i = this.getLayer(), l = Xi(n.pixelToCoordinateTransform, r.slice()), h = i.getExtent();
    if (h && !Xd(h, l))
      return null;
    var s = this.image_.getExtent(), m = this.image_.getImage(), v = Cn(s), E = Math.floor(m.width * ((l[0] - s[0]) / v));
    if (E < 0 || E >= m.width)
      return null;
    var T = Pi(s), S = Math.floor(m.height * ((s[3] - l[1]) / T));
    return S < 0 || S >= m.height ? null : this.getImageData(m, E, S);
  }, e.prototype.renderFrame = function(r, n) {
    var i = this.image_, l = i.getExtent(), h = i.getResolution(), s = i.getPixelRatio(), m = r.layerStatesArray[r.layerIndex], v = r.pixelRatio, E = r.viewState, T = E.center, S = E.resolution, A = v * h / (S * s), L = r.extent, B = E.resolution, j = E.rotation, q = Math.round(Cn(L) / B * v), H = Math.round(Pi(L) / B * v);
    cu(this.pixelTransform, r.size[0] / 2, r.size[1] / 2, 1 / v, 1 / v, j, -q / 2, -H / 2), Rx(this.inversePixelTransform, this.pixelTransform);
    var ne = N2(this.pixelTransform);
    this.useContainer(n, ne, this.getBackground(r));
    var ee = this.context, he = ee.canvas;
    he.width != q || he.height != H ? (he.width = q, he.height = H) : this.containerReused || ee.clearRect(0, 0, q, H);
    var Te = !1, ve = !0;
    if (m.extent) {
      var Oe = Ll(m.extent, E.projection);
      ve = Zd(Oe, r.extent), Te = ve && !yx(Oe, r.extent), Te && this.clipUnrotated(ee, r, Oe);
    }
    var Me = i.getImage(), Re = cu(this.tempTransform, q / 2, H / 2, A, A, 0, s * (l[0] - T[0]) / h, s * (T[1] - l[3]) / h);
    this.renderedResolution = h * v / s;
    var He = Me.width * Re[0], Ve = Me.height * Re[3];
    if (this.getLayer().getSource().getInterpolate() || In(ee, qg), this.preRender(ee, r), ve && He >= 0.5 && Ve >= 0.5) {
      var dt = Re[4], xe = Re[5], ze = m.opacity, Pe = void 0;
      ze !== 1 && (Pe = ee.globalAlpha, ee.globalAlpha = ze), ee.drawImage(Me, 0, 0, +Me.width, +Me.height, dt, xe, He, Ve), ze !== 1 && (ee.globalAlpha = Pe);
    }
    return this.postRender(ee, r), Te && ee.restore(), In(ee, yM), ne !== he.style.transform && (he.style.transform = ne), this.container;
  }, e;
}(hM);
const mB = pB;
var gB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), yB = function(t) {
  gB(e, t);
  function e(r) {
    return t.call(this, r) || this;
  }
  return e.prototype.createRenderer = function() {
    return new mB(this);
  }, e.prototype.getData = function(r) {
    return t.prototype.getData.call(this, r);
  }, e;
}(fB);
const _B = yB, Nm = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
var vB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), xB = function(t) {
  vB(e, t);
  function e(r) {
    var n = this, i = r || {}, l = In({}, i);
    return delete l.preload, delete l.useInterimTilesOnError, n = t.call(this, l) || this, n.on, n.once, n.un, n.setPreload(i.preload !== void 0 ? i.preload : 0), n.setUseInterimTilesOnError(i.useInterimTilesOnError !== void 0 ? i.useInterimTilesOnError : !0), n;
  }
  return e.prototype.getPreload = function() {
    return this.get(Nm.PRELOAD);
  }, e.prototype.setPreload = function(r) {
    this.set(Nm.PRELOAD, r);
  }, e.prototype.getUseInterimTilesOnError = function() {
    return this.get(Nm.USE_INTERIM_TILES_ON_ERROR);
  }, e.prototype.setUseInterimTilesOnError = function(r) {
    this.set(Nm.USE_INTERIM_TILES_ON_ERROR, r);
  }, e.prototype.getData = function(r) {
    return t.prototype.getData.call(this, r);
  }, e;
}(rp);
const bB = xB;
var wB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), EB = function(t) {
  wB(e, t);
  function e(r, n, i) {
    var l = t.call(this) || this, h = i || {};
    return l.tileCoord = r, l.state = n, l.interimTile = null, l.key = "", l.transition_ = h.transition === void 0 ? 250 : h.transition, l.transitionStarts_ = {}, l.interpolate = !!h.interpolate, l;
  }
  return e.prototype.changed = function() {
    this.dispatchEvent(_r.CHANGE);
  }, e.prototype.release = function() {
  }, e.prototype.getKey = function() {
    return this.key + "/" + this.tileCoord;
  }, e.prototype.getInterimTile = function() {
    if (!this.interimTile)
      return this;
    var r = this.interimTile;
    do {
      if (r.getState() == tr.LOADED)
        return this.transition_ = 0, r;
      r = r.interimTile;
    } while (r);
    return this;
  }, e.prototype.refreshInterimChain = function() {
    if (!!this.interimTile) {
      var r = this.interimTile, n = this;
      do {
        if (r.getState() == tr.LOADED) {
          r.interimTile = null;
          break;
        } else
          r.getState() == tr.LOADING ? n = r : r.getState() == tr.IDLE ? n.interimTile = r.interimTile : n = r;
        r = n.interimTile;
      } while (r);
    }
  }, e.prototype.getTileCoord = function() {
    return this.tileCoord;
  }, e.prototype.getState = function() {
    return this.state;
  }, e.prototype.setState = function(r) {
    if (this.state !== tr.ERROR && this.state > r)
      throw new Error("Tile load sequence violation");
    this.state = r, this.changed();
  }, e.prototype.load = function() {
    En();
  }, e.prototype.getAlpha = function(r, n) {
    if (!this.transition_)
      return 1;
    var i = this.transitionStarts_[r];
    if (!i)
      i = n, this.transitionStarts_[r] = i;
    else if (i === -1)
      return 1;
    var l = n - i + 1e3 / 60;
    return l >= this.transition_ ? 1 : G2(l / this.transition_);
  }, e.prototype.inTransition = function(r) {
    return this.transition_ ? this.transitionStarts_[r] !== -1 : !1;
  }, e.prototype.endTransition = function(r) {
    this.transition_ && (this.transitionStarts_[r] = -1);
  }, e;
}(ep);
const _M = EB;
var TB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), SB = function(t) {
  TB(e, t);
  function e(r, n, i, l, h, s) {
    var m = t.call(this, r, n, s) || this;
    return m.crossOrigin_ = l, m.src_ = i, m.key = i, m.image_ = new Image(), l !== null && (m.image_.crossOrigin = l), m.unlisten_ = null, m.tileLoadFunction_ = h, m;
  }
  return e.prototype.getImage = function() {
    return this.image_;
  }, e.prototype.setImage = function(r) {
    this.image_ = r, this.state = tr.LOADED, this.unlistenImage_(), this.changed();
  }, e.prototype.handleImageError_ = function() {
    this.state = tr.ERROR, this.unlistenImage_(), this.image_ = MB(), this.changed();
  }, e.prototype.handleImageLoad_ = function() {
    var r = this.image_;
    r.naturalWidth && r.naturalHeight ? this.state = tr.LOADED : this.state = tr.EMPTY, this.unlistenImage_(), this.changed();
  }, e.prototype.load = function() {
    this.state == tr.ERROR && (this.state = tr.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == tr.IDLE && (this.state = tr.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = dM(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)));
  }, e.prototype.unlistenImage_ = function() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }, e;
}(_M);
function MB() {
  var t = Vg(1, 1);
  return t.fillStyle = "rgba(0,0,0,0)", t.fillRect(0, 0, 1, 1), t.canvas;
}
const vM = SB;
var CB = 10, _E = 0.25, IB = function() {
  function t(e, r, n, i, l, h) {
    this.sourceProj_ = e, this.targetProj_ = r;
    var s = {}, m = kh(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(ne) {
      var ee = ne[0] + "/" + ne[1];
      return s[ee] || (s[ee] = m(ne)), s[ee];
    }, this.maxSourceExtent_ = i, this.errorThresholdSquared_ = l * l, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!i && !!this.sourceProj_.getExtent() && Cn(i) == Cn(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? Cn(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? Cn(this.targetProj_.getExtent()) : null;
    var v = Kl(n), E = ky(n), T = Dy(n), S = Ly(n), A = this.transformInv_(v), L = this.transformInv_(E), B = this.transformInv_(T), j = this.transformInv_(S), q = CB + (h ? Math.max(0, Math.ceil(YL(b0(n) / (h * h * 256 * 256)))) : 0);
    if (this.addQuad_(v, E, T, S, A, L, B, j, q), this.wrapsXInSource_) {
      var H = 1 / 0;
      this.triangles_.forEach(function(ne, ee, he) {
        H = Math.min(H, ne.source[0][0], ne.source[1][0], ne.source[2][0]);
      }), this.triangles_.forEach(function(ne) {
        if (Math.max(ne.source[0][0], ne.source[1][0], ne.source[2][0]) - H > this.sourceWorldWidth_ / 2) {
          var ee = [
            [ne.source[0][0], ne.source[0][1]],
            [ne.source[1][0], ne.source[1][1]],
            [ne.source[2][0], ne.source[2][1]]
          ];
          ee[0][0] - H > this.sourceWorldWidth_ / 2 && (ee[0][0] -= this.sourceWorldWidth_), ee[1][0] - H > this.sourceWorldWidth_ / 2 && (ee[1][0] -= this.sourceWorldWidth_), ee[2][0] - H > this.sourceWorldWidth_ / 2 && (ee[2][0] -= this.sourceWorldWidth_);
          var he = Math.min(ee[0][0], ee[1][0], ee[2][0]), Te = Math.max(ee[0][0], ee[1][0], ee[2][0]);
          Te - he < this.sourceWorldWidth_ / 2 && (ne.source = ee);
        }
      }.bind(this));
    }
    s = {};
  }
  return t.prototype.addTriangle_ = function(e, r, n, i, l, h) {
    this.triangles_.push({
      source: [i, l, h],
      target: [e, r, n]
    });
  }, t.prototype.addQuad_ = function(e, r, n, i, l, h, s, m, v) {
    var E = x0([l, h, s, m]), T = this.sourceWorldWidth_ ? Cn(E) / this.sourceWorldWidth_ : null, S = this.sourceWorldWidth_, A = this.sourceProj_.canWrapX() && T > 0.5 && T < 1, L = !1;
    if (v > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        var B = x0([e, r, n, i]), j = Cn(B) / this.targetWorldWidth_;
        L = j > _E || L;
      }
      !A && this.sourceProj_.isGlobal() && T && (L = T > _E || L);
    }
    if (!(!L && this.maxSourceExtent_ && isFinite(E[0]) && isFinite(E[1]) && isFinite(E[2]) && isFinite(E[3]) && !Zd(E, this.maxSourceExtent_))) {
      var q = 0;
      if (!L && (!isFinite(l[0]) || !isFinite(l[1]) || !isFinite(h[0]) || !isFinite(h[1]) || !isFinite(s[0]) || !isFinite(s[1]) || !isFinite(m[0]) || !isFinite(m[1]))) {
        if (v > 0)
          L = !0;
        else if (q = (!isFinite(l[0]) || !isFinite(l[1]) ? 8 : 0) + (!isFinite(h[0]) || !isFinite(h[1]) ? 4 : 0) + (!isFinite(s[0]) || !isFinite(s[1]) ? 2 : 0) + (!isFinite(m[0]) || !isFinite(m[1]) ? 1 : 0), q != 1 && q != 2 && q != 4 && q != 8)
          return;
      }
      if (v > 0) {
        if (!L) {
          var H = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2], ne = this.transformInv_(H), ee = void 0;
          if (A) {
            var he = (Qc(l[0], S) + Qc(s[0], S)) / 2;
            ee = he - Qc(ne[0], S);
          } else
            ee = (l[0] + s[0]) / 2 - ne[0];
          var Te = (l[1] + s[1]) / 2 - ne[1], ve = ee * ee + Te * Te;
          L = ve > this.errorThresholdSquared_;
        }
        if (L) {
          if (Math.abs(e[0] - n[0]) <= Math.abs(e[1] - n[1])) {
            var Oe = [(r[0] + n[0]) / 2, (r[1] + n[1]) / 2], Me = this.transformInv_(Oe), Re = [(i[0] + e[0]) / 2, (i[1] + e[1]) / 2], He = this.transformInv_(Re);
            this.addQuad_(e, r, Oe, Re, l, h, Me, He, v - 1), this.addQuad_(Re, Oe, n, i, He, Me, s, m, v - 1);
          } else {
            var Ve = [(e[0] + r[0]) / 2, (e[1] + r[1]) / 2], dt = this.transformInv_(Ve), xe = [(n[0] + i[0]) / 2, (n[1] + i[1]) / 2], ze = this.transformInv_(xe);
            this.addQuad_(e, Ve, xe, i, l, dt, ze, m, v - 1), this.addQuad_(Ve, r, n, xe, dt, h, s, ze, v - 1);
          }
          return;
        }
      }
      if (A) {
        if (!this.canWrapXInSource_)
          return;
        this.wrapsXInSource_ = !0;
      }
      (q & 11) == 0 && this.addTriangle_(e, n, i, l, s, m), (q & 14) == 0 && this.addTriangle_(e, n, r, l, s, h), q && ((q & 13) == 0 && this.addTriangle_(r, i, e, h, m, l), (q & 7) == 0 && this.addTriangle_(r, i, n, h, m, s));
    }
  }, t.prototype.calculateSourceExtent = function() {
    var e = pu();
    return this.triangles_.forEach(function(r, n, i) {
      var l = r.source;
      ug(e, l[0]), ug(e, l[1]), ug(e, l[2]);
    }), e;
  }, t.prototype.getTriangles = function() {
    return this.triangles_;
  }, t;
}();
const xM = IB;
var wv, bM = [];
function vE(t, e, r, n, i) {
  t.beginPath(), t.moveTo(0, 0), t.lineTo(e, r), t.lineTo(n, i), t.closePath(), t.save(), t.clip(), t.fillRect(0, 0, Math.max(e, n) + 1, Math.max(r, i)), t.restore();
}
function Ev(t, e) {
  return Math.abs(t[e * 4] - 210) > 2 || Math.abs(t[e * 4 + 3] - 0.75 * 255) > 2;
}
function PB() {
  if (wv === void 0) {
    var t = document.createElement("canvas").getContext("2d");
    t.globalCompositeOperation = "lighter", t.fillStyle = "rgba(210, 0, 0, 0.75)", vE(t, 4, 5, 4, 0), vE(t, 4, 5, 0, 5);
    var e = t.getImageData(0, 0, 3, 3).data;
    wv = Ev(e, 0) || Ev(e, 4) || Ev(e, 8);
  }
  return wv;
}
function Wg(t, e, r, n) {
  var i = Rd(r, e, t), l = Cw(e, n, r), h = e.getMetersPerUnit();
  h !== void 0 && (l *= h);
  var s = t.getMetersPerUnit();
  s !== void 0 && (l /= s);
  var m = t.getExtent();
  if (!m || Xd(m, i)) {
    var v = Cw(t, l, i) / l;
    isFinite(v) && v > 0 && (l /= v);
  }
  return l;
}
function AB(t, e, r, n) {
  var i = au(r), l = Wg(t, e, i, n);
  return (!isFinite(l) || l <= 0) && i2(r, function(h) {
    return l = Wg(t, e, h, n), isFinite(l) && l > 0;
  }), l;
}
function wM(t, e, r, n, i, l, h, s, m, v, E, T) {
  var S = Vg(Math.round(r * t), Math.round(r * e), bM);
  if (T || In(S, qg), m.length === 0)
    return S.canvas;
  S.scale(r, r);
  function A(ee) {
    return Math.round(ee * r) / r;
  }
  S.globalCompositeOperation = "lighter";
  var L = pu();
  m.forEach(function(ee, he, Te) {
    wD(L, ee.extent);
  });
  var B = Cn(L), j = Pi(L), q = Vg(Math.round(r * B / n), Math.round(r * j / n));
  T || In(q, qg);
  var H = r / n;
  m.forEach(function(ee, he, Te) {
    var ve = ee.extent[0] - L[0], Oe = -(ee.extent[3] - L[3]), Me = Cn(ee.extent), Re = Pi(ee.extent);
    ee.image.width > 0 && ee.image.height > 0 && q.drawImage(ee.image, v, v, ee.image.width - 2 * v, ee.image.height - 2 * v, ve * H, Oe * H, Me * H, Re * H);
  });
  var ne = Kl(h);
  return s.getTriangles().forEach(function(ee, he, Te) {
    var ve = ee.source, Oe = ee.target, Me = ve[0][0], Re = ve[0][1], He = ve[1][0], Ve = ve[1][1], dt = ve[2][0], xe = ve[2][1], ze = A((Oe[0][0] - ne[0]) / l), Pe = A(-(Oe[0][1] - ne[1]) / l), Ye = A((Oe[1][0] - ne[0]) / l), it = A(-(Oe[1][1] - ne[1]) / l), kt = A((Oe[2][0] - ne[0]) / l), Er = A(-(Oe[2][1] - ne[1]) / l), mr = Me, Yt = Re;
    Me = 0, Re = 0, He -= mr, Ve -= Yt, dt -= mr, xe -= Yt;
    var on = [
      [He, Ve, 0, 0, Ye - ze],
      [dt, xe, 0, 0, kt - ze],
      [0, 0, He, Ve, it - Pe],
      [0, 0, dt, xe, Er - Pe]
    ], or = QL(on);
    if (!!or) {
      if (S.save(), S.beginPath(), PB() || !T) {
        S.moveTo(Ye, it);
        for (var Jt = 4, Ht = ze - Ye, xr = Pe - it, Cr = 0; Cr < Jt; Cr++)
          S.lineTo(Ye + A((Cr + 1) * Ht / Jt), it + A(Cr * xr / (Jt - 1))), Cr != Jt - 1 && S.lineTo(Ye + A((Cr + 1) * Ht / Jt), it + A((Cr + 1) * xr / (Jt - 1)));
        S.lineTo(kt, Er);
      } else
        S.moveTo(Ye, it), S.lineTo(ze, Pe), S.lineTo(kt, Er);
      S.clip(), S.transform(or[0], or[2], or[1], or[3], ze, Pe), S.translate(L[0] - mr, L[3] - Yt), S.scale(n / r, -n / r), S.drawImage(q.canvas, 0, 0), S.restore();
    }
  }), E && (S.save(), S.globalCompositeOperation = "source-over", S.strokeStyle = "black", S.lineWidth = 1, s.getTriangles().forEach(function(ee, he, Te) {
    var ve = ee.target, Oe = (ve[0][0] - ne[0]) / l, Me = -(ve[0][1] - ne[1]) / l, Re = (ve[1][0] - ne[0]) / l, He = -(ve[1][1] - ne[1]) / l, Ve = (ve[2][0] - ne[0]) / l, dt = -(ve[2][1] - ne[1]) / l;
    S.beginPath(), S.moveTo(Re, He), S.lineTo(Oe, Me), S.lineTo(Ve, dt), S.closePath(), S.stroke();
  }), S.restore()), S.canvas;
}
var OB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), RB = function(t) {
  OB(e, t);
  function e(r, n, i, l, h, s, m, v, E, T, S, A) {
    var L = t.call(this, h, tr.IDLE, { interpolate: !!A }) || this;
    L.renderEdges_ = S !== void 0 ? S : !1, L.pixelRatio_ = m, L.gutter_ = v, L.canvas_ = null, L.sourceTileGrid_ = n, L.targetTileGrid_ = l, L.wrappedTileCoord_ = s || h, L.sourceTiles_ = [], L.sourcesListenerKeys_ = null, L.sourceZ_ = 0;
    var B = l.getTileCoordExtent(L.wrappedTileCoord_), j = L.targetTileGrid_.getExtent(), q = L.sourceTileGrid_.getExtent(), H = j ? eu(B, j) : B;
    if (b0(H) === 0)
      return L.state = tr.EMPTY, L;
    var ne = r.getExtent();
    ne && (q ? q = eu(q, ne) : q = ne);
    var ee = l.getResolution(L.wrappedTileCoord_[0]), he = AB(r, i, H, ee);
    if (!isFinite(he) || he <= 0)
      return L.state = tr.EMPTY, L;
    var Te = T !== void 0 ? T : gM;
    if (L.triangulation_ = new xM(r, i, H, q, he * Te, ee), L.triangulation_.getTriangles().length === 0)
      return L.state = tr.EMPTY, L;
    L.sourceZ_ = n.getZForResolution(he);
    var ve = L.triangulation_.calculateSourceExtent();
    if (q && (r.canWrapX() ? (ve[1] = hi(ve[1], q[1], q[3]), ve[3] = hi(ve[3], q[1], q[3])) : ve = eu(ve, q)), !b0(ve))
      L.state = tr.EMPTY;
    else {
      for (var Oe = n.getTileRangeForExtentAndZ(ve, L.sourceZ_), Me = Oe.minX; Me <= Oe.maxX; Me++)
        for (var Re = Oe.minY; Re <= Oe.maxY; Re++) {
          var He = E(L.sourceZ_, Me, Re, m);
          He && L.sourceTiles_.push(He);
        }
      L.sourceTiles_.length === 0 && (L.state = tr.EMPTY);
    }
    return L;
  }
  return e.prototype.getImage = function() {
    return this.canvas_;
  }, e.prototype.reproject_ = function() {
    var r = [];
    if (this.sourceTiles_.forEach(function(E, T, S) {
      E && E.getState() == tr.LOADED && r.push({
        extent: this.sourceTileGrid_.getTileCoordExtent(E.tileCoord),
        image: E.getImage()
      });
    }.bind(this)), this.sourceTiles_.length = 0, r.length === 0)
      this.state = tr.ERROR;
    else {
      var n = this.wrappedTileCoord_[0], i = this.targetTileGrid_.getTileSize(n), l = typeof i == "number" ? i : i[0], h = typeof i == "number" ? i : i[1], s = this.targetTileGrid_.getResolution(n), m = this.sourceTileGrid_.getResolution(this.sourceZ_), v = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
      this.canvas_ = wM(l, h, this.pixelRatio_, m, this.sourceTileGrid_.getExtent(), s, v, this.triangulation_, r, this.gutter_, this.renderEdges_, this.interpolate), this.state = tr.LOADED;
    }
    this.changed();
  }, e.prototype.load = function() {
    if (this.state == tr.IDLE) {
      this.state = tr.LOADING, this.changed();
      var r = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(function(n, i, l) {
        var h = n.getState();
        if (h == tr.IDLE || h == tr.LOADING) {
          r++;
          var s = Fr(n, _r.CHANGE, function(m) {
            var v = n.getState();
            (v == tr.LOADED || v == tr.ERROR || v == tr.EMPTY) && ($n(s), r--, r === 0 && (this.unlistenSources_(), this.reproject_()));
          }, this);
          this.sourcesListenerKeys_.push(s);
        }
      }.bind(this)), r === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function(n, i, l) {
        var h = n.getState();
        h == tr.IDLE && n.load();
      });
    }
  }, e.prototype.unlistenSources_ = function() {
    this.sourcesListenerKeys_.forEach($n), this.sourcesListenerKeys_ = null;
  }, e.prototype.release = function() {
    this.canvas_ && (vz(this.canvas_.getContext("2d")), bM.push(this.canvas_), this.canvas_ = null), t.prototype.release.call(this);
  }, e;
}(_M);
const EM = RB;
var TM = function() {
  function t(e, r, n, i) {
    this.minX = e, this.maxX = r, this.minY = n, this.maxY = i;
  }
  return t.prototype.contains = function(e) {
    return this.containsXY(e[1], e[2]);
  }, t.prototype.containsTileRange = function(e) {
    return this.minX <= e.minX && e.maxX <= this.maxX && this.minY <= e.minY && e.maxY <= this.maxY;
  }, t.prototype.containsXY = function(e, r) {
    return this.minX <= e && e <= this.maxX && this.minY <= r && r <= this.maxY;
  }, t.prototype.equals = function(e) {
    return this.minX == e.minX && this.minY == e.minY && this.maxX == e.maxX && this.maxY == e.maxY;
  }, t.prototype.extend = function(e) {
    e.minX < this.minX && (this.minX = e.minX), e.maxX > this.maxX && (this.maxX = e.maxX), e.minY < this.minY && (this.minY = e.minY), e.maxY > this.maxY && (this.maxY = e.maxY);
  }, t.prototype.getHeight = function() {
    return this.maxY - this.minY + 1;
  }, t.prototype.getSize = function() {
    return [this.getWidth(), this.getHeight()];
  }, t.prototype.getWidth = function() {
    return this.maxX - this.minX + 1;
  }, t.prototype.intersects = function(e) {
    return this.minX <= e.maxX && this.maxX >= e.minX && this.minY <= e.maxY && this.maxY >= e.minY;
  }, t;
}();
function Ju(t, e, r, n, i) {
  return i !== void 0 ? (i.minX = t, i.maxX = e, i.minY = r, i.maxY = n, i) : new TM(t, e, r, n);
}
const SM = TM;
var LB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), DB = function(t) {
  LB(e, t);
  function e(r) {
    var n = t.call(this, r) || this;
    return n.extentChanged = !0, n.renderedExtent_ = null, n.renderedPixelRatio, n.renderedProjection = null, n.renderedRevision, n.renderedTiles = [], n.newTiles_ = !1, n.tmpExtent = pu(), n.tmpTileRange_ = new SM(0, 0, 0, 0), n;
  }
  return e.prototype.isDrawableTile = function(r) {
    var n = this.getLayer(), i = r.getState(), l = n.getUseInterimTilesOnError();
    return i == tr.LOADED || i == tr.EMPTY || i == tr.ERROR && !l;
  }, e.prototype.getTile = function(r, n, i, l) {
    var h = l.pixelRatio, s = l.viewState.projection, m = this.getLayer(), v = m.getSource(), E = v.getTile(r, n, i, h, s);
    return E.getState() == tr.ERROR && (m.getUseInterimTilesOnError() ? m.getPreload() > 0 && (this.newTiles_ = !0) : E.setState(tr.LOADED)), this.isDrawableTile(E) || (E = E.getInterimTile()), E;
  }, e.prototype.getData = function(r) {
    var n = this.frameState;
    if (!n)
      return null;
    var i = this.getLayer(), l = Xi(n.pixelToCoordinateTransform, r.slice()), h = i.getExtent();
    if (h && !Xd(h, l))
      return null;
    for (var s = n.pixelRatio, m = n.viewState.projection, v = n.viewState, E = i.getRenderSource(), T = E.getTileGridForProjection(v.projection), S = E.getTilePixelRatio(n.pixelRatio), A = T.getZForResolution(v.resolution); A >= T.getMinZoom(); --A) {
      var L = T.getTileCoordForCoordAndZ(l, A), B = E.getTile(A, L[1], L[2], s, m);
      if (!(B instanceof vM || B instanceof EM))
        return null;
      if (B.getState() === tr.LOADED) {
        var j = T.getOrigin(A), q = ks(T.getTileSize(A)), H = T.getResolution(A), ne = Math.floor(S * ((l[0] - j[0]) / H - L[1] * q[0])), ee = Math.floor(S * ((j[1] - l[1]) / H - L[2] * q[1])), he = Math.round(S * E.getGutterForProjection(v.projection));
        return this.getImageData(B.getImage(), ne + he, ee + he);
      }
    }
    return null;
  }, e.prototype.loadedTileCallback = function(r, n, i) {
    return this.isDrawableTile(i) ? t.prototype.loadedTileCallback.call(this, r, n, i) : !1;
  }, e.prototype.prepareFrame = function(r) {
    return !!this.getLayer().getSource();
  }, e.prototype.renderFrame = function(r, n) {
    var i = r.layerStatesArray[r.layerIndex], l = r.viewState, h = l.projection, s = l.resolution, m = l.center, v = l.rotation, E = r.pixelRatio, T = this.getLayer(), S = T.getSource(), A = S.getRevision(), L = S.getTileGridForProjection(h), B = L.getZForResolution(s, S.zDirection), j = L.getResolution(B), q = r.extent, H = r.viewState.resolution, ne = S.getTilePixelRatio(E), ee = Math.round(Cn(q) / H * E), he = Math.round(Pi(q) / H * E), Te = i.extent && Ll(i.extent);
    Te && (q = eu(q, Ll(i.extent)));
    var ve = j * ee / 2 / ne, Oe = j * he / 2 / ne, Me = [
      m[0] - ve,
      m[1] - Oe,
      m[0] + ve,
      m[1] + Oe
    ], Re = L.getTileRangeForExtentAndZ(q, B), He = {};
    He[B] = {};
    var Ve = this.createLoadedTileFinder(S, h, He), dt = this.tmpExtent, xe = this.tmpTileRange_;
    this.newTiles_ = !1;
    for (var ze = v ? w0(l.center, H, v, r.size) : void 0, Pe = Re.minX; Pe <= Re.maxX; ++Pe)
      for (var Ye = Re.minY; Ye <= Re.maxY; ++Ye)
        if (!(v && !L.tileCoordIntersectsViewport([B, Pe, Ye], ze))) {
          var it = this.getTile(B, Pe, Ye, r);
          if (this.isDrawableTile(it)) {
            var kt = So(this);
            if (it.getState() == tr.LOADED) {
              He[B][it.tileCoord.toString()] = it;
              var Er = it.inTransition(kt);
              Er && i.opacity !== 1 && (it.endTransition(kt), Er = !1), !this.newTiles_ && (Er || this.renderedTiles.indexOf(it) === -1) && (this.newTiles_ = !0);
            }
            if (it.getAlpha(kt, r.time) === 1)
              continue;
          }
          var mr = L.getTileCoordChildTileRange(it.tileCoord, xe, dt), Yt = !1;
          mr && (Yt = Ve(B + 1, mr)), Yt || L.forEachTileCoordParentTileRange(it.tileCoord, Ve, xe, dt);
        }
    var on = j / s * E / ne;
    cu(this.pixelTransform, r.size[0] / 2, r.size[1] / 2, 1 / E, 1 / E, v, -ee / 2, -he / 2);
    var or = N2(this.pixelTransform);
    this.useContainer(n, or, this.getBackground(r));
    var Jt = this.context, Ht = Jt.canvas;
    Rx(this.inversePixelTransform, this.pixelTransform), cu(this.tempTransform, ee / 2, he / 2, on, on, 0, -ee / 2, -he / 2), Ht.width != ee || Ht.height != he ? (Ht.width = ee, Ht.height = he) : this.containerReused || Jt.clearRect(0, 0, ee, he), Te && this.clipUnrotated(Jt, r, Te), S.getInterpolate() || In(Jt, qg), this.preRender(Jt, r), this.renderedTiles.length = 0;
    var xr = Object.keys(He).map(Number);
    xr.sort(Ax);
    var Cr, an, kr;
    i.opacity === 1 && (!this.containerReused || S.getOpaque(r.viewState.projection)) ? xr = xr.reverse() : (Cr = [], an = []);
    for (var Pn = xr.length - 1; Pn >= 0; --Pn) {
      var qr = xr[Pn], re = S.getTilePixelSize(qr, E, h), pe = L.getResolution(qr), ke = pe / j, Ze = re[0] * ke * on, Ge = re[1] * ke * on, rt = L.getTileCoordForCoordAndZ(Kl(Me), qr), Xe = L.getTileCoordExtent(rt), Je = Xi(this.tempTransform, [
        ne * (Xe[0] - Me[0]) / j,
        ne * (Me[3] - Xe[3]) / j
      ]), at = ne * S.getGutterForProjection(h), Ke = He[qr];
      for (var At in Ke) {
        var it = Ke[At], mt = it.tileCoord, St = rt[1] - mt[1], Ut = Math.round(Je[0] - (St - 1) * Ze), Wt = rt[2] - mt[2], Ce = Math.round(Je[1] - (Wt - 1) * Ge), Pe = Math.round(Je[0] - St * Ze), Ye = Math.round(Je[1] - Wt * Ge), We = Ut - Pe, br = Ce - Ye, Wr = B === qr, Er = Wr && it.getAlpha(So(this), r.time) !== 1, Xt = !1;
        if (!Er)
          if (Cr) {
            kr = [Pe, Ye, Pe + We, Ye, Pe + We, Ye + br, Pe, Ye + br];
            for (var gn = 0, Br = Cr.length; gn < Br; ++gn)
              if (B !== qr && qr < an[gn]) {
                var Ir = Cr[gn];
                Zd([Pe, Ye, Pe + We, Ye + br], [Ir[0], Ir[3], Ir[4], Ir[7]]) && (Xt || (Jt.save(), Xt = !0), Jt.beginPath(), Jt.moveTo(kr[0], kr[1]), Jt.lineTo(kr[2], kr[3]), Jt.lineTo(kr[4], kr[5]), Jt.lineTo(kr[6], kr[7]), Jt.moveTo(Ir[6], Ir[7]), Jt.lineTo(Ir[4], Ir[5]), Jt.lineTo(Ir[2], Ir[3]), Jt.lineTo(Ir[0], Ir[1]), Jt.clip());
              }
            Cr.push(kr), an.push(qr);
          } else
            Jt.clearRect(Pe, Ye, We, br);
        this.drawTileImage(it, r, Pe, Ye, We, br, at, Wr), Cr && !Er ? (Xt && Jt.restore(), this.renderedTiles.unshift(it)) : this.renderedTiles.push(it), this.updateUsedTiles(r.usedTiles, S, it);
      }
    }
    return this.renderedRevision = A, this.renderedResolution = j, this.extentChanged = !this.renderedExtent_ || !Lg(this.renderedExtent_, Me), this.renderedExtent_ = Me, this.renderedPixelRatio = E, this.renderedProjection = h, this.manageTilePyramid(r, S, L, E, h, q, B, T.getPreload()), this.scheduleExpireCache(r, S), this.postRender(Jt, r), i.extent && Jt.restore(), In(Jt, yM), or !== Ht.style.transform && (Ht.style.transform = or), this.container;
  }, e.prototype.drawTileImage = function(r, n, i, l, h, s, m, v) {
    var E = this.getTileImage(r);
    if (!!E) {
      var T = So(this), S = n.layerStatesArray[n.layerIndex], A = S.opacity * (v ? r.getAlpha(T, n.time) : 1), L = A !== this.context.globalAlpha;
      L && (this.context.save(), this.context.globalAlpha = A), this.context.drawImage(E, m, m, E.width - 2 * m, E.height - 2 * m, i, l, h, s), L && this.context.restore(), A !== S.opacity ? n.animate = !0 : v && r.endTransition(T);
    }
  }, e.prototype.getImage = function() {
    var r = this.context;
    return r ? r.canvas : null;
  }, e.prototype.getTileImage = function(r) {
    return r.getImage();
  }, e.prototype.scheduleExpireCache = function(r, n) {
    if (n.canExpireCache()) {
      var i = function(l, h, s) {
        var m = So(l);
        m in s.usedTiles && l.expireCache(s.viewState.projection, s.usedTiles[m]);
      }.bind(null, n);
      r.postRenderFunctions.push(
        i
      );
    }
  }, e.prototype.updateUsedTiles = function(r, n, i) {
    var l = So(n);
    l in r || (r[l] = {}), r[l][i.getKey()] = !0;
  }, e.prototype.manageTilePyramid = function(r, n, i, l, h, s, m, v, E) {
    var T = So(n);
    T in r.wantedTiles || (r.wantedTiles[T] = {});
    var S = r.wantedTiles[T], A = r.tileQueue, L = i.getMinZoom(), B = r.viewState.rotation, j = B ? w0(r.viewState.center, r.viewState.resolution, B, r.size) : void 0, q = 0, H, ne, ee, he, Te, ve;
    for (ve = L; ve <= m; ++ve)
      for (ne = i.getTileRangeForExtentAndZ(s, ve, ne), ee = i.getResolution(ve), he = ne.minX; he <= ne.maxX; ++he)
        for (Te = ne.minY; Te <= ne.maxY; ++Te)
          B && !i.tileCoordIntersectsViewport([ve, he, Te], j) || (m - ve <= v ? (++q, H = n.getTile(ve, he, Te, l, h), H.getState() == tr.IDLE && (S[H.getKey()] = !0, A.isKeyQueued(H.getKey()) || A.enqueue([
            H,
            T,
            i.getTileCoordCenter(H.tileCoord),
            ee
          ])), E !== void 0 && E(H)) : n.useTile(ve, he, Te, h));
    n.updateCacheSize(q, h);
  }, e;
}(hM);
const kB = DB;
var NB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), FB = function(t) {
  NB(e, t);
  function e(r) {
    return t.call(this, r) || this;
  }
  return e.prototype.createRenderer = function() {
    return new kB(this);
  }, e;
}(bB);
const zB = FB;
var BB = function() {
  function t(e) {
    this.highWaterMark = e !== void 0 ? e : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  return t.prototype.canExpireCache = function() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }, t.prototype.expireCache = function(e) {
    for (; this.canExpireCache(); )
      this.pop();
  }, t.prototype.clear = function() {
    this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }, t.prototype.containsKey = function(e) {
    return this.entries_.hasOwnProperty(e);
  }, t.prototype.forEach = function(e) {
    for (var r = this.oldest_; r; )
      e(r.value_, r.key_, this), r = r.newer;
  }, t.prototype.get = function(e, r) {
    var n = this.entries_[e];
    return en(n !== void 0, 15), n === this.newest_ || (n === this.oldest_ ? (this.oldest_ = this.oldest_.newer, this.oldest_.older = null) : (n.newer.older = n.older, n.older.newer = n.newer), n.newer = null, n.older = this.newest_, this.newest_.newer = n, this.newest_ = n), n.value_;
  }, t.prototype.remove = function(e) {
    var r = this.entries_[e];
    return en(r !== void 0, 15), r === this.newest_ ? (this.newest_ = r.older, this.newest_ && (this.newest_.newer = null)) : r === this.oldest_ ? (this.oldest_ = r.newer, this.oldest_ && (this.oldest_.older = null)) : (r.newer.older = r.older, r.older.newer = r.newer), delete this.entries_[e], --this.count_, r.value_;
  }, t.prototype.getCount = function() {
    return this.count_;
  }, t.prototype.getKeys = function() {
    var e = new Array(this.count_), r = 0, n;
    for (n = this.newest_; n; n = n.older)
      e[r++] = n.key_;
    return e;
  }, t.prototype.getValues = function() {
    var e = new Array(this.count_), r = 0, n;
    for (n = this.newest_; n; n = n.older)
      e[r++] = n.value_;
    return e;
  }, t.prototype.peekLast = function() {
    return this.oldest_.value_;
  }, t.prototype.peekLastKey = function() {
    return this.oldest_.key_;
  }, t.prototype.peekFirstKey = function() {
    return this.newest_.key_;
  }, t.prototype.peek = function(e) {
    if (!!this.containsKey(e))
      return this.entries_[e].value_;
  }, t.prototype.pop = function() {
    var e = this.oldest_;
    return delete this.entries_[e.key_], e.newer && (e.newer.older = null), this.oldest_ = e.newer, this.oldest_ || (this.newest_ = null), --this.count_, e.value_;
  }, t.prototype.replace = function(e, r) {
    this.get(e), this.entries_[e].value_ = r;
  }, t.prototype.set = function(e, r) {
    en(!(e in this.entries_), 16);
    var n = {
      key_: e,
      newer: null,
      older: this.newest_,
      value_: r
    };
    this.newest_ ? this.newest_.newer = n : this.oldest_ = n, this.newest_ = n, this.entries_[e] = n, ++this.count_;
  }, t.prototype.setSize = function(e) {
    this.highWaterMark = e;
  }, t;
}();
const UB = BB;
function xE(t, e, r, n) {
  return n !== void 0 ? (n[0] = t, n[1] = e, n[2] = r, n) : [t, e, r];
}
function Vy(t, e, r) {
  return t + "/" + e + "/" + r;
}
function MM(t) {
  return Vy(t[0], t[1], t[2]);
}
function $B(t) {
  return t.split("/").map(Number);
}
function VB(t) {
  return (t[1] << t[0]) + t[2];
}
function jB(t, e) {
  var r = t[0], n = t[1], i = t[2];
  if (e.getMinZoom() > r || r > e.getMaxZoom())
    return !1;
  var l = e.getFullTileRange(r);
  return l ? l.containsXY(n, i) : !0;
}
var GB = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), qB = function(t) {
  GB(e, t);
  function e() {
    return t !== null && t.apply(this, arguments) || this;
  }
  return e.prototype.expireCache = function(r) {
    for (; this.canExpireCache(); ) {
      var n = this.peekLast();
      if (n.getKey() in r)
        break;
      this.pop().release();
    }
  }, e.prototype.pruneExceptNewestZ = function() {
    if (this.getCount() !== 0) {
      var r = this.peekFirstKey(), n = $B(r), i = n[0];
      this.forEach(function(l) {
        l.tileCoord[0] !== i && (this.remove(MM(l.tileCoord)), l.release());
      }.bind(this));
    }
  }, e;
}(UB);
const CM = qB, Tv = {
  TILELOADSTART: "tileloadstart",
  TILELOADEND: "tileloadend",
  TILELOADERROR: "tileloaderror"
};
var WB = [0, 0, 0], yl = 5, XB = function() {
  function t(e) {
    this.minZoom = e.minZoom !== void 0 ? e.minZoom : 0, this.resolutions_ = e.resolutions, en(V5(this.resolutions_, function(h, s) {
      return s - h;
    }, !0), 17);
    var r;
    if (!e.origins) {
      for (var n = 0, i = this.resolutions_.length - 1; n < i; ++n)
        if (!r)
          r = this.resolutions_[n] / this.resolutions_[n + 1];
        else if (this.resolutions_[n] / this.resolutions_[n + 1] !== r) {
          r = void 0;
          break;
        }
    }
    this.zoomFactor_ = r, this.maxZoom = this.resolutions_.length - 1, this.origin_ = e.origin !== void 0 ? e.origin : null, this.origins_ = null, e.origins !== void 0 && (this.origins_ = e.origins, en(this.origins_.length == this.resolutions_.length, 20));
    var l = e.extent;
    l !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = Kl(l)), en(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18), this.tileSizes_ = null, e.tileSizes !== void 0 && (this.tileSizes_ = e.tileSizes, en(this.tileSizes_.length == this.resolutions_.length, 19)), this.tileSize_ = e.tileSize !== void 0 ? e.tileSize : this.tileSizes_ ? null : Lx, en(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22), this.extent_ = l !== void 0 ? l : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], e.sizes !== void 0 ? this.fullTileRanges_ = e.sizes.map(function(h, s) {
      var m = new SM(Math.min(0, h[0]), Math.max(h[0] - 1, -1), Math.min(0, h[1]), Math.max(h[1] - 1, -1));
      if (l) {
        var v = this.getTileRangeForExtentAndZ(l, s);
        m.minX = Math.max(v.minX, m.minX), m.maxX = Math.min(v.maxX, m.maxX), m.minY = Math.max(v.minY, m.minY), m.maxY = Math.min(v.maxY, m.maxY);
      }
      return m;
    }, this) : l && this.calculateTileRanges_(l);
  }
  return t.prototype.forEachTileCoord = function(e, r, n) {
    for (var i = this.getTileRangeForExtentAndZ(e, r), l = i.minX, h = i.maxX; l <= h; ++l)
      for (var s = i.minY, m = i.maxY; s <= m; ++s)
        n([r, l, s]);
  }, t.prototype.forEachTileCoordParentTileRange = function(e, r, n, i) {
    var l, h, s, m = null, v = e[0] - 1;
    for (this.zoomFactor_ === 2 ? (h = e[1], s = e[2]) : m = this.getTileCoordExtent(e, i); v >= this.minZoom; ) {
      if (this.zoomFactor_ === 2 ? (h = Math.floor(h / 2), s = Math.floor(s / 2), l = Ju(h, h, s, s, n)) : l = this.getTileRangeForExtentAndZ(m, v, n), r(v, l))
        return !0;
      --v;
    }
    return !1;
  }, t.prototype.getExtent = function() {
    return this.extent_;
  }, t.prototype.getMaxZoom = function() {
    return this.maxZoom;
  }, t.prototype.getMinZoom = function() {
    return this.minZoom;
  }, t.prototype.getOrigin = function(e) {
    return this.origin_ ? this.origin_ : this.origins_[e];
  }, t.prototype.getResolution = function(e) {
    return this.resolutions_[e];
  }, t.prototype.getResolutions = function() {
    return this.resolutions_;
  }, t.prototype.getTileCoordChildTileRange = function(e, r, n) {
    if (e[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        var i = e[1] * 2, l = e[2] * 2;
        return Ju(i, i + 1, l, l + 1, r);
      }
      var h = this.getTileCoordExtent(e, n || this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(h, e[0] + 1, r);
    }
    return null;
  }, t.prototype.getTileRangeForTileCoordAndZ = function(e, r, n) {
    if (r > this.maxZoom || r < this.minZoom)
      return null;
    var i = e[0], l = e[1], h = e[2];
    if (r === i)
      return Ju(l, h, l, h, n);
    if (this.zoomFactor_) {
      var s = Math.pow(this.zoomFactor_, r - i), m = Math.floor(l * s), v = Math.floor(h * s);
      if (r < i)
        return Ju(m, m, v, v, n);
      var E = Math.floor(s * (l + 1)) - 1, T = Math.floor(s * (h + 1)) - 1;
      return Ju(m, E, v, T, n);
    }
    var S = this.getTileCoordExtent(e, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(S, r, n);
  }, t.prototype.getTileRangeExtent = function(e, r, n) {
    var i = this.getOrigin(e), l = this.getResolution(e), h = ks(this.getTileSize(e), this.tmpSize_), s = i[0] + r.minX * h[0] * l, m = i[0] + (r.maxX + 1) * h[0] * l, v = i[1] + r.minY * h[1] * l, E = i[1] + (r.maxY + 1) * h[1] * l;
    return ou(s, v, m, E, n);
  }, t.prototype.getTileRangeForExtentAndZ = function(e, r, n) {
    var i = WB;
    this.getTileCoordForXYAndZ_(e[0], e[3], r, !1, i);
    var l = i[1], h = i[2];
    return this.getTileCoordForXYAndZ_(e[2], e[1], r, !0, i), Ju(l, i[1], h, i[2], n);
  }, t.prototype.getTileCoordCenter = function(e) {
    var r = this.getOrigin(e[0]), n = this.getResolution(e[0]), i = ks(this.getTileSize(e[0]), this.tmpSize_);
    return [
      r[0] + (e[1] + 0.5) * i[0] * n,
      r[1] - (e[2] + 0.5) * i[1] * n
    ];
  }, t.prototype.getTileCoordExtent = function(e, r) {
    var n = this.getOrigin(e[0]), i = this.getResolution(e[0]), l = ks(this.getTileSize(e[0]), this.tmpSize_), h = n[0] + e[1] * l[0] * i, s = n[1] - (e[2] + 1) * l[1] * i, m = h + l[0] * i, v = s + l[1] * i;
    return ou(h, s, m, v, r);
  }, t.prototype.getTileCoordForCoordAndResolution = function(e, r, n) {
    return this.getTileCoordForXYAndResolution_(e[0], e[1], r, !1, n);
  }, t.prototype.getTileCoordForXYAndResolution_ = function(e, r, n, i, l) {
    var h = this.getZForResolution(n), s = n / this.getResolution(h), m = this.getOrigin(h), v = ks(this.getTileSize(h), this.tmpSize_), E = s * (e - m[0]) / n / v[0], T = s * (m[1] - r) / n / v[1];
    return i ? (E = Rl(E, yl) - 1, T = Rl(T, yl) - 1) : (E = fh(E, yl), T = fh(T, yl)), xE(h, E, T, l);
  }, t.prototype.getTileCoordForXYAndZ_ = function(e, r, n, i, l) {
    var h = this.getOrigin(n), s = this.getResolution(n), m = ks(this.getTileSize(n), this.tmpSize_), v = (e - h[0]) / s / m[0], E = (h[1] - r) / s / m[1];
    return i ? (v = Rl(v, yl) - 1, E = Rl(E, yl) - 1) : (v = fh(v, yl), E = fh(E, yl)), xE(n, v, E, l);
  }, t.prototype.getTileCoordForCoordAndZ = function(e, r, n) {
    return this.getTileCoordForXYAndZ_(e[0], e[1], r, !1, n);
  }, t.prototype.getTileCoordResolution = function(e) {
    return this.resolutions_[e[0]];
  }, t.prototype.getTileSize = function(e) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[e];
  }, t.prototype.getFullTileRange = function(e) {
    return this.fullTileRanges_ ? this.fullTileRanges_[e] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, e) : null;
  }, t.prototype.getZForResolution = function(e, r) {
    var n = By(this.resolutions_, e, r || 0);
    return hi(n, this.minZoom, this.maxZoom);
  }, t.prototype.tileCoordIntersectsViewport = function(e, r) {
    return J2(r, 0, r.length, 2, this.getTileCoordExtent(e));
  }, t.prototype.calculateTileRanges_ = function(e) {
    for (var r = this.resolutions_.length, n = new Array(r), i = this.minZoom; i < r; ++i)
      n[i] = this.getTileRangeForExtentAndZ(e, i);
    this.fullTileRanges_ = n;
  }, t;
}();
const IM = XB;
function PM(t) {
  var e = t.getDefaultTileGrid();
  return e || (e = YB(t), t.setDefaultTileGrid(e)), e;
}
function ZB(t, e, r) {
  var n = e[0], i = t.getTileCoordCenter(e), l = AM(r);
  if (Xd(l, i))
    return e;
  var h = Cn(l), s = Math.ceil((l[0] - i[0]) / h);
  return i[0] += h * s, t.getTileCoordForCoordAndZ(i, n);
}
function HB(t, e, r, n) {
  var i = n !== void 0 ? n : "top-left", l = KB(t, e, r);
  return new IM({
    extent: t,
    origin: TD(t, i),
    resolutions: l,
    tileSize: r
  });
}
function KB(t, e, r, n) {
  for (var i = e !== void 0 ? e : Vz, l = Pi(t), h = Cn(t), s = ks(r !== void 0 ? r : Lx), m = n > 0 ? n : Math.max(h / s[0], l / s[1]), v = i + 1, E = new Array(v), T = 0; T < v; ++T)
    E[T] = m / Math.pow(2, T);
  return E;
}
function YB(t, e, r, n) {
  var i = AM(t);
  return HB(i, e, r, n);
}
function AM(t) {
  t = fi(t);
  var e = t.getExtent();
  if (!e) {
    var r = 180 * ss[Fs.DEGREES] / t.getMetersPerUnit();
    e = ou(-r, -r, r, r);
  }
  return e;
}
var OM = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), JB = function(t) {
  OM(e, t);
  function e(r) {
    var n = t.call(this, {
      attributions: r.attributions,
      attributionsCollapsible: r.attributionsCollapsible,
      projection: r.projection,
      state: r.state,
      wrapX: r.wrapX,
      interpolate: r.interpolate
    }) || this;
    n.on, n.once, n.un, n.opaque_ = r.opaque !== void 0 ? r.opaque : !1, n.tilePixelRatio_ = r.tilePixelRatio !== void 0 ? r.tilePixelRatio : 1, n.tileGrid = r.tileGrid !== void 0 ? r.tileGrid : null;
    var i = [256, 256];
    return n.tileGrid && ks(n.tileGrid.getTileSize(n.tileGrid.getMinZoom()), i), n.tileCache = new CM(r.cacheSize || 0), n.tmpSize = [0, 0], n.key_ = r.key || "", n.tileOptions = {
      transition: r.transition,
      interpolate: r.interpolate
    }, n.zDirection = r.zDirection ? r.zDirection : 0, n;
  }
  return e.prototype.canExpireCache = function() {
    return this.tileCache.canExpireCache();
  }, e.prototype.expireCache = function(r, n) {
    var i = this.getTileCacheForProjection(r);
    i && i.expireCache(n);
  }, e.prototype.forEachLoadedTile = function(r, n, i, l) {
    var h = this.getTileCacheForProjection(r);
    if (!h)
      return !1;
    for (var s = !0, m, v, E, T = i.minX; T <= i.maxX; ++T)
      for (var S = i.minY; S <= i.maxY; ++S)
        v = Vy(n, T, S), E = !1, h.containsKey(v) && (m = h.get(v), E = m.getState() === tr.LOADED, E && (E = l(m) !== !1)), E || (s = !1);
    return s;
  }, e.prototype.getGutterForProjection = function(r) {
    return 0;
  }, e.prototype.getKey = function() {
    return this.key_;
  }, e.prototype.setKey = function(r) {
    this.key_ !== r && (this.key_ = r, this.changed());
  }, e.prototype.getOpaque = function(r) {
    return this.opaque_;
  }, e.prototype.getResolutions = function() {
    return this.tileGrid ? this.tileGrid.getResolutions() : null;
  }, e.prototype.getTile = function(r, n, i, l, h) {
    return En();
  }, e.prototype.getTileGrid = function() {
    return this.tileGrid;
  }, e.prototype.getTileGridForProjection = function(r) {
    return this.tileGrid ? this.tileGrid : PM(r);
  }, e.prototype.getTileCacheForProjection = function(r) {
    var n = this.getProjection();
    return en(
      n === null || Pl(n, r),
      68
    ), this.tileCache;
  }, e.prototype.getTilePixelRatio = function(r) {
    return this.tilePixelRatio_;
  }, e.prototype.getTilePixelSize = function(r, n, i) {
    var l = this.getTileGridForProjection(i), h = this.getTilePixelRatio(n), s = ks(l.getTileSize(r), this.tmpSize);
    return h == 1 ? s : L4(s, h, this.tmpSize);
  }, e.prototype.getTileCoordForTileUrlFunction = function(r, n) {
    var i = n !== void 0 ? n : this.getProjection(), l = this.getTileGridForProjection(i);
    return this.getWrapX() && i.isGlobal() && (r = ZB(l, r, i)), jB(r, l) ? r : null;
  }, e.prototype.clear = function() {
    this.tileCache.clear();
  }, e.prototype.refresh = function() {
    this.clear(), t.prototype.refresh.call(this);
  }, e.prototype.updateCacheSize = function(r, n) {
    var i = this.getTileCacheForProjection(n);
    r > i.highWaterMark && (i.highWaterMark = r);
  }, e.prototype.useTile = function(r, n, i, l) {
  }, e;
}(pM), QB = function(t) {
  OM(e, t);
  function e(r, n) {
    var i = t.call(this, r) || this;
    return i.tile = n, i;
  }
  return e;
}(Xs);
const e8 = JB;
function t8(t, e) {
  var r = /\{z\}/g, n = /\{x\}/g, i = /\{y\}/g, l = /\{-y\}/g;
  return function(h, s, m) {
    if (h)
      return t.replace(r, h[0].toString()).replace(n, h[1].toString()).replace(i, h[2].toString()).replace(l, function() {
        var v = h[0], E = e.getFullTileRange(v);
        en(E, 55);
        var T = E.getHeight() - h[2] - 1;
        return T.toString();
      });
  };
}
function r8(t, e) {
  for (var r = t.length, n = new Array(r), i = 0; i < r; ++i)
    n[i] = t8(t[i], e);
  return D0(n);
}
function D0(t) {
  return t.length === 1 ? t[0] : function(e, r, n) {
    if (e) {
      var i = VB(e), l = Qc(i, t.length);
      return t[l](e, r, n);
    } else
      return;
  };
}
function RM(t) {
  var e = [], r = /\{([a-z])-([a-z])\}/.exec(t);
  if (r) {
    var n = r[1].charCodeAt(0), i = r[2].charCodeAt(0), l = void 0;
    for (l = n; l <= i; ++l)
      e.push(t.replace(r[0], String.fromCharCode(l)));
    return e;
  }
  if (r = /\{(\d+)-(\d+)\}/.exec(t), r) {
    for (var h = parseInt(r[2], 10), s = parseInt(r[1], 10); s <= h; s++)
      e.push(t.replace(r[0], s.toString()));
    return e;
  }
  return e.push(t), e;
}
var n8 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), i8 = function(t) {
  n8(e, t);
  function e(r) {
    var n = t.call(this, {
      attributions: r.attributions,
      cacheSize: r.cacheSize,
      opaque: r.opaque,
      projection: r.projection,
      state: r.state,
      tileGrid: r.tileGrid,
      tilePixelRatio: r.tilePixelRatio,
      wrapX: r.wrapX,
      transition: r.transition,
      interpolate: r.interpolate,
      key: r.key,
      attributionsCollapsible: r.attributionsCollapsible,
      zDirection: r.zDirection
    }) || this;
    return n.generateTileUrlFunction_ = n.tileUrlFunction === e.prototype.tileUrlFunction, n.tileLoadFunction = r.tileLoadFunction, r.tileUrlFunction && (n.tileUrlFunction = r.tileUrlFunction), n.urls = null, r.urls ? n.setUrls(r.urls) : r.url && n.setUrl(r.url), n.tileLoadingKeys_ = {}, n;
  }
  return e.prototype.getTileLoadFunction = function() {
    return this.tileLoadFunction;
  }, e.prototype.getTileUrlFunction = function() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }, e.prototype.getUrls = function() {
    return this.urls;
  }, e.prototype.handleTileChange = function(r) {
    var n = r.target, i = So(n), l = n.getState(), h;
    l == tr.LOADING ? (this.tileLoadingKeys_[i] = !0, h = Tv.TILELOADSTART) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], h = l == tr.ERROR ? Tv.TILELOADERROR : l == tr.LOADED ? Tv.TILELOADEND : void 0), h != null && this.dispatchEvent(new QB(h, n));
  }, e.prototype.setTileLoadFunction = function(r) {
    this.tileCache.clear(), this.tileLoadFunction = r, this.changed();
  }, e.prototype.setTileUrlFunction = function(r, n) {
    this.tileUrlFunction = r, this.tileCache.pruneExceptNewestZ(), typeof n < "u" ? this.setKey(n) : this.changed();
  }, e.prototype.setUrl = function(r) {
    var n = RM(r);
    this.urls = n, this.setUrls(n);
  }, e.prototype.setUrls = function(r) {
    this.urls = r;
    var n = r.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(r8(r, this.tileGrid), n) : this.setKey(n);
  }, e.prototype.tileUrlFunction = function(r, n, i) {
  }, e.prototype.useTile = function(r, n, i) {
    var l = Vy(r, n, i);
    this.tileCache.containsKey(l) && this.tileCache.get(l);
  }, e;
}(e8);
const o8 = i8;
var a8 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), s8 = function(t) {
  a8(e, t);
  function e(r) {
    var n = this, i = r.imageSmoothing !== void 0 ? r.imageSmoothing : !0;
    return r.interpolate !== void 0 && (i = r.interpolate), n = t.call(this, {
      attributions: r.attributions,
      cacheSize: r.cacheSize,
      opaque: r.opaque,
      projection: r.projection,
      state: r.state,
      tileGrid: r.tileGrid,
      tileLoadFunction: r.tileLoadFunction ? r.tileLoadFunction : l8,
      tilePixelRatio: r.tilePixelRatio,
      tileUrlFunction: r.tileUrlFunction,
      url: r.url,
      urls: r.urls,
      wrapX: r.wrapX,
      transition: r.transition,
      interpolate: i,
      key: r.key,
      attributionsCollapsible: r.attributionsCollapsible,
      zDirection: r.zDirection
    }) || this, n.crossOrigin = r.crossOrigin !== void 0 ? r.crossOrigin : null, n.tileClass = r.tileClass !== void 0 ? r.tileClass : vM, n.tileCacheForProjection = {}, n.tileGridForProjection = {}, n.reprojectionErrorThreshold_ = r.reprojectionErrorThreshold, n.renderReprojectionEdges_ = !1, n;
  }
  return e.prototype.canExpireCache = function() {
    if (!wa)
      return t.prototype.canExpireCache.call(this);
    if (this.tileCache.canExpireCache())
      return !0;
    for (var r in this.tileCacheForProjection)
      if (this.tileCacheForProjection[r].canExpireCache())
        return !0;
    return !1;
  }, e.prototype.expireCache = function(r, n) {
    if (!wa) {
      t.prototype.expireCache.call(this, r, n);
      return;
    }
    var i = this.getTileCacheForProjection(r);
    this.tileCache.expireCache(this.tileCache == i ? n : {});
    for (var l in this.tileCacheForProjection) {
      var h = this.tileCacheForProjection[l];
      h.expireCache(h == i ? n : {});
    }
  }, e.prototype.getGutterForProjection = function(r) {
    return wa && this.getProjection() && r && !Pl(this.getProjection(), r) ? 0 : this.getGutter();
  }, e.prototype.getGutter = function() {
    return 0;
  }, e.prototype.getKey = function() {
    var r = t.prototype.getKey.call(this);
    return this.getInterpolate() || (r += ":disable-interpolation"), r;
  }, e.prototype.getOpaque = function(r) {
    return wa && this.getProjection() && r && !Pl(this.getProjection(), r) ? !1 : t.prototype.getOpaque.call(this, r);
  }, e.prototype.getTileGridForProjection = function(r) {
    if (!wa)
      return t.prototype.getTileGridForProjection.call(this, r);
    var n = this.getProjection();
    if (this.tileGrid && (!n || Pl(n, r)))
      return this.tileGrid;
    var i = So(r);
    return i in this.tileGridForProjection || (this.tileGridForProjection[i] = PM(r)), this.tileGridForProjection[i];
  }, e.prototype.getTileCacheForProjection = function(r) {
    if (!wa)
      return t.prototype.getTileCacheForProjection.call(this, r);
    var n = this.getProjection();
    if (!n || Pl(n, r))
      return this.tileCache;
    var i = So(r);
    return i in this.tileCacheForProjection || (this.tileCacheForProjection[i] = new CM(this.tileCache.highWaterMark)), this.tileCacheForProjection[i];
  }, e.prototype.createTile_ = function(r, n, i, l, h, s) {
    var m = [r, n, i], v = this.getTileCoordForTileUrlFunction(m, h), E = v ? this.tileUrlFunction(v, l, h) : void 0, T = new this.tileClass(m, E !== void 0 ? tr.IDLE : tr.EMPTY, E !== void 0 ? E : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
    return T.key = s, T.addEventListener(_r.CHANGE, this.handleTileChange.bind(this)), T;
  }, e.prototype.getTile = function(r, n, i, l, h) {
    var s = this.getProjection();
    if (!wa || !s || !h || Pl(s, h))
      return this.getTileInternal(r, n, i, l, s || h);
    var m = this.getTileCacheForProjection(h), v = [r, n, i], E = void 0, T = MM(v);
    m.containsKey(T) && (E = m.get(T));
    var S = this.getKey();
    if (E && E.key == S)
      return E;
    var A = this.getTileGridForProjection(s), L = this.getTileGridForProjection(h), B = this.getTileCoordForTileUrlFunction(v, h), j = new EM(s, A, h, L, v, B, this.getTilePixelRatio(l), this.getGutter(), function(q, H, ne, ee) {
      return this.getTileInternal(q, H, ne, ee, s);
    }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
    return j.key = S, E ? (j.interimTile = E, j.refreshInterimChain(), m.replace(T, j)) : m.set(T, j), j;
  }, e.prototype.getTileInternal = function(r, n, i, l, h) {
    var s = null, m = Vy(r, n, i), v = this.getKey();
    if (!this.tileCache.containsKey(m))
      s = this.createTile_(r, n, i, l, h, v), this.tileCache.set(m, s);
    else if (s = this.tileCache.get(m), s.key != v) {
      var E = s;
      s = this.createTile_(r, n, i, l, h, v), E.getState() == tr.IDLE ? s.interimTile = E.interimTile : s.interimTile = E, s.refreshInterimChain(), this.tileCache.replace(m, s);
    }
    return s;
  }, e.prototype.setRenderReprojectionEdges = function(r) {
    if (!(!wa || this.renderReprojectionEdges_ == r)) {
      this.renderReprojectionEdges_ = r;
      for (var n in this.tileCacheForProjection)
        this.tileCacheForProjection[n].clear();
      this.changed();
    }
  }, e.prototype.setTileGridForProjection = function(r, n) {
    if (wa) {
      var i = fi(r);
      if (i) {
        var l = So(i);
        l in this.tileGridForProjection || (this.tileGridForProjection[l] = n);
      }
    }
  }, e;
}(o8);
function l8(t, e) {
  t.getImage().src = e;
}
const c8 = s8;
var Ja = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, u8 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), h8 = function(t) {
  u8(e, t);
  function e(r, n, i, l, h, s, m) {
    var v = this, E = r.getExtent(), T = n.getExtent(), S = T ? eu(i, T) : i, A = au(S), L = Wg(r, n, A, l), B = gM, j = new xM(r, n, S, E, L * B, l), q = j.calculateSourceExtent(), H = s(q, L, h), ne = H ? Mn.IDLE : Mn.EMPTY, ee = H ? H.getPixelRatio() : 1;
    return v = t.call(this, i, l, ee, ne) || this, v.targetProj_ = n, v.maxSourceExtent_ = E, v.triangulation_ = j, v.targetResolution_ = l, v.targetExtent_ = i, v.sourceImage_ = H, v.sourcePixelRatio_ = ee, v.interpolate_ = m, v.canvas_ = null, v.sourceListenerKey_ = null, v;
  }
  return e.prototype.disposeInternal = function() {
    this.state == Mn.LOADING && this.unlistenSource_(), t.prototype.disposeInternal.call(this);
  }, e.prototype.getImage = function() {
    return this.canvas_;
  }, e.prototype.getProjection = function() {
    return this.targetProj_;
  }, e.prototype.reproject_ = function() {
    var r = this.sourceImage_.getState();
    if (r == Mn.LOADED) {
      var n = Cn(this.targetExtent_) / this.targetResolution_, i = Pi(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = wM(n, i, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [
        {
          extent: this.sourceImage_.getExtent(),
          image: this.sourceImage_.getImage()
        }
      ], 0, void 0, this.interpolate_);
    }
    this.state = r, this.changed();
  }, e.prototype.load = function() {
    if (this.state == Mn.IDLE) {
      this.state = Mn.LOADING, this.changed();
      var r = this.sourceImage_.getState();
      r == Mn.LOADED || r == Mn.ERROR ? this.reproject_() : (this.sourceListenerKey_ = Fr(this.sourceImage_, _r.CHANGE, function(n) {
        var i = this.sourceImage_.getState();
        (i == Mn.LOADED || i == Mn.ERROR) && (this.unlistenSource_(), this.reproject_());
      }, this), this.sourceImage_.load());
    }
  }, e.prototype.unlistenSource_ = function() {
    $n(
      this.sourceListenerKey_
    ), this.sourceListenerKey_ = null;
  }, e;
}(fM);
const f8 = h8;
var LM = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Sv = {
  IMAGELOADSTART: "imageloadstart",
  IMAGELOADEND: "imageloadend",
  IMAGELOADERROR: "imageloaderror"
}, d8 = function(t) {
  LM(e, t);
  function e(r, n) {
    var i = t.call(this, r) || this;
    return i.image = n, i;
  }
  return e;
}(Xs), p8 = function(t) {
  LM(e, t);
  function e(r) {
    var n = this, i = r.imageSmoothing !== void 0 ? r.imageSmoothing : !0;
    return r.interpolate !== void 0 && (i = r.interpolate), n = t.call(this, {
      attributions: r.attributions,
      projection: r.projection,
      state: r.state,
      interpolate: i
    }) || this, n.on, n.once, n.un, n.resolutions_ = r.resolutions !== void 0 ? r.resolutions : null, n.reprojectedImage_ = null, n.reprojectedRevision_ = 0, n;
  }
  return e.prototype.getResolutions = function() {
    return this.resolutions_;
  }, e.prototype.findNearestResolution = function(r) {
    if (this.resolutions_) {
      var n = By(this.resolutions_, r, 0);
      r = this.resolutions_[n];
    }
    return r;
  }, e.prototype.getImage = function(r, n, i, l) {
    var h = this.getProjection();
    if (!wa || !h || !l || Pl(h, l))
      return h && (l = h), this.getImageInternal(r, n, i, l);
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && Pl(this.reprojectedImage_.getProjection(), l) && this.reprojectedImage_.getResolution() == n && Lg(this.reprojectedImage_.getExtent(), r))
        return this.reprojectedImage_;
      this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
    }
    return this.reprojectedImage_ = new f8(h, l, r, n, i, function(s, m, v) {
      return this.getImageInternal(s, m, v, h);
    }.bind(this), this.getInterpolate()), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
  }, e.prototype.getImageInternal = function(r, n, i, l) {
    return En();
  }, e.prototype.handleImageChange = function(r) {
    var n = r.target, i;
    switch (n.getState()) {
      case Mn.LOADING:
        this.loading = !0, i = Sv.IMAGELOADSTART;
        break;
      case Mn.LOADED:
        this.loading = !1, i = Sv.IMAGELOADEND;
        break;
      case Mn.ERROR:
        this.loading = !1, i = Sv.IMAGELOADERROR;
        break;
      default:
        return;
    }
    this.hasListener(i) && this.dispatchEvent(new d8(i, n));
  }, e;
}(pM);
function m8(t, e) {
  t.getImage().src = e;
}
const g8 = p8;
function Xg(t, e) {
  var r = [];
  Object.keys(e).forEach(function(i) {
    e[i] !== null && e[i] !== void 0 && r.push(i + "=" + encodeURIComponent(e[i]));
  });
  var n = r.join("&");
  return t = t.replace(/[?&]$/, ""), t = t.indexOf("?") === -1 ? t + "?" : t + "&", t + n;
}
var Fm = "1.3.0", y8 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), _l = 4, bE = [101, 101], _8 = function(t) {
  y8(e, t);
  function e(r) {
    var n = this, i = r || {}, l = i.imageSmoothing !== void 0 ? i.imageSmoothing : !0;
    return i.interpolate !== void 0 && (l = i.interpolate), n = t.call(this, {
      attributions: i.attributions,
      interpolate: l,
      projection: i.projection,
      resolutions: i.resolutions
    }) || this, n.crossOrigin_ = i.crossOrigin !== void 0 ? i.crossOrigin : null, n.url_ = i.url, n.imageLoadFunction_ = i.imageLoadFunction !== void 0 ? i.imageLoadFunction : m8, n.params_ = i.params || {}, n.v13_ = !0, n.updateV13_(), n.serverType_ = i.serverType, n.hidpi_ = i.hidpi !== void 0 ? i.hidpi : !0, n.image_ = null, n.imageSize_ = [0, 0], n.renderedRevision_ = 0, n.ratio_ = i.ratio !== void 0 ? i.ratio : 1.5, n;
  }
  return e.prototype.getFeatureInfoUrl = function(r, n, i, l) {
    if (this.url_ !== void 0) {
      var h = fi(i), s = this.getProjection();
      s && s !== h && (n = Wg(s, h, r, n), r = Rd(r, h, s));
      var m = Sh(r, n, 0, bE), v = {
        SERVICE: "WMS",
        VERSION: Fm,
        REQUEST: "GetFeatureInfo",
        FORMAT: "image/png",
        TRANSPARENT: !0,
        QUERY_LAYERS: this.params_.LAYERS
      };
      In(v, this.params_, l);
      var E = fh((r[0] - m[0]) / n, _l), T = fh((m[3] - r[1]) / n, _l);
      return v[this.v13_ ? "I" : "X"] = E, v[this.v13_ ? "J" : "Y"] = T, this.getRequestUrl_(m, bE, 1, s || h, v);
    }
  }, e.prototype.getLegendUrl = function(r, n) {
    if (this.url_ !== void 0) {
      var i = {
        SERVICE: "WMS",
        VERSION: Fm,
        REQUEST: "GetLegendGraphic",
        FORMAT: "image/png"
      };
      if (n === void 0 || n.LAYER === void 0) {
        var l = this.params_.LAYERS, h = !Array.isArray(l) || l.length === 1;
        if (!h)
          return;
        i.LAYER = l;
      }
      if (r !== void 0) {
        var s = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, m = 28e-5;
        i.SCALE = r * s / m;
      }
      return In(i, n), Xg(this.url_, i);
    }
  }, e.prototype.getParams = function() {
    return this.params_;
  }, e.prototype.getImageInternal = function(r, n, i, l) {
    if (this.url_ === void 0)
      return null;
    n = this.findNearestResolution(n), i != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (i = 1);
    var h = n / i, s = au(r), m = Rl(Cn(r) / h, _l), v = Rl(Pi(r) / h, _l), E = Sh(s, h, 0, [
      m,
      v
    ]), T = Rl(this.ratio_ * Cn(r) / h, _l), S = Rl(this.ratio_ * Pi(r) / h, _l), A = Sh(s, h, 0, [
      T,
      S
    ]), L = this.image_;
    if (L && this.renderedRevision_ == this.getRevision() && L.getResolution() == n && L.getPixelRatio() == i && yx(L.getExtent(), E))
      return L;
    var B = {
      SERVICE: "WMS",
      VERSION: Fm,
      REQUEST: "GetMap",
      FORMAT: "image/png",
      TRANSPARENT: !0
    };
    In(B, this.params_), this.imageSize_[0] = bw(Cn(A) / h, _l), this.imageSize_[1] = bw(Pi(A) / h, _l);
    var j = this.getRequestUrl_(A, this.imageSize_, i, l, B);
    return this.image_ = new rB(A, n, i, j, this.crossOrigin_, this.imageLoadFunction_), this.renderedRevision_ = this.getRevision(), this.image_.addEventListener(_r.CHANGE, this.handleImageChange.bind(this)), this.image_;
  }, e.prototype.getImageLoadFunction = function() {
    return this.imageLoadFunction_;
  }, e.prototype.getRequestUrl_ = function(r, n, i, l, h) {
    if (en(this.url_ !== void 0, 9), h[this.v13_ ? "CRS" : "SRS"] = l.getCode(), "STYLES" in this.params_ || (h.STYLES = ""), i != 1)
      switch (this.serverType_) {
        case "geoserver":
          var s = 90 * i + 0.5 | 0;
          "FORMAT_OPTIONS" in h ? h.FORMAT_OPTIONS += ";dpi:" + s : h.FORMAT_OPTIONS = "dpi:" + s;
          break;
        case "mapserver":
          h.MAP_RESOLUTION = 90 * i;
          break;
        case "carmentaserver":
        case "qgis":
          h.DPI = 90 * i;
          break;
        default:
          en(!1, 8);
          break;
      }
    h.WIDTH = n[0], h.HEIGHT = n[1];
    var m = l.getAxisOrientation(), v;
    return this.v13_ && m.substr(0, 2) == "ne" ? v = [r[1], r[0], r[3], r[2]] : v = r, h.BBOX = v.join(","), Xg(this.url_, h);
  }, e.prototype.getUrl = function() {
    return this.url_;
  }, e.prototype.setImageLoadFunction = function(r) {
    this.image_ = null, this.imageLoadFunction_ = r, this.changed();
  }, e.prototype.setUrl = function(r) {
    r != this.url_ && (this.url_ = r, this.image_ = null, this.changed());
  }, e.prototype.updateParams = function(r) {
    In(this.params_, r), this.updateV13_(), this.image_ = null, this.changed();
  }, e.prototype.updateV13_ = function() {
    var r = this.params_.VERSION || Fm;
    this.v13_ = ID(r, "1.3") >= 0;
  }, e;
}(g8);
const v8 = _8;
var x8 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), b8 = function(t) {
  x8(e, t);
  function e(r) {
    var n = t.call(this, {
      extent: r.extent,
      origin: r.origin,
      origins: r.origins,
      resolutions: r.resolutions,
      tileSize: r.tileSize,
      tileSizes: r.tileSizes,
      sizes: r.sizes
    }) || this;
    return n.matrixIds_ = r.matrixIds, n;
  }
  return e.prototype.getMatrixId = function(r) {
    return this.matrixIds_[r];
  }, e.prototype.getMatrixIds = function() {
    return this.matrixIds_;
  }, e;
}(IM);
const w8 = b8;
var E8 = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), T8 = function(t) {
  E8(e, t);
  function e(r) {
    var n = this, i = r.imageSmoothing !== void 0 ? r.imageSmoothing : !0;
    r.interpolate !== void 0 && (i = r.interpolate);
    var l = r.requestEncoding !== void 0 ? r.requestEncoding : "KVP", h = r.tileGrid, s = r.urls;
    return s === void 0 && r.url !== void 0 && (s = RM(r.url)), n = t.call(this, {
      attributions: r.attributions,
      attributionsCollapsible: r.attributionsCollapsible,
      cacheSize: r.cacheSize,
      crossOrigin: r.crossOrigin,
      interpolate: i,
      projection: r.projection,
      reprojectionErrorThreshold: r.reprojectionErrorThreshold,
      tileClass: r.tileClass,
      tileGrid: h,
      tileLoadFunction: r.tileLoadFunction,
      tilePixelRatio: r.tilePixelRatio,
      urls: s,
      wrapX: r.wrapX !== void 0 ? r.wrapX : !1,
      transition: r.transition,
      zDirection: r.zDirection
    }) || this, n.version_ = r.version !== void 0 ? r.version : "1.0.0", n.format_ = r.format !== void 0 ? r.format : "image/jpeg", n.dimensions_ = r.dimensions !== void 0 ? r.dimensions : {}, n.layer_ = r.layer, n.matrixSet_ = r.matrixSet, n.style_ = r.style, n.requestEncoding_ = l, n.setKey(n.getKeyForDimensions_()), s && s.length > 0 && (n.tileUrlFunction = D0(s.map(n.createFromWMTSTemplate.bind(n)))), n;
  }
  return e.prototype.setUrls = function(r) {
    this.urls = r;
    var n = r.join(`
`);
    this.setTileUrlFunction(D0(r.map(this.createFromWMTSTemplate.bind(this))), n);
  }, e.prototype.getDimensions = function() {
    return this.dimensions_;
  }, e.prototype.getFormat = function() {
    return this.format_;
  }, e.prototype.getLayer = function() {
    return this.layer_;
  }, e.prototype.getMatrixSet = function() {
    return this.matrixSet_;
  }, e.prototype.getRequestEncoding = function() {
    return this.requestEncoding_;
  }, e.prototype.getStyle = function() {
    return this.style_;
  }, e.prototype.getVersion = function() {
    return this.version_;
  }, e.prototype.getKeyForDimensions_ = function() {
    var r = 0, n = [];
    for (var i in this.dimensions_)
      n[r++] = i + "-" + this.dimensions_[i];
    return n.join("/");
  }, e.prototype.updateDimensions = function(r) {
    In(this.dimensions_, r), this.setKey(this.getKeyForDimensions_());
  }, e.prototype.createFromWMTSTemplate = function(r) {
    var n = this.requestEncoding_, i = {
      layer: this.layer_,
      style: this.style_,
      tilematrixset: this.matrixSet_
    };
    n == "KVP" && In(i, {
      Service: "WMTS",
      Request: "GetTile",
      Version: this.version_,
      Format: this.format_
    }), r = n == "KVP" ? Xg(r, i) : r.replace(/\{(\w+?)\}/g, function(s, m) {
      return m.toLowerCase() in i ? i[m.toLowerCase()] : s;
    });
    var l = this.tileGrid, h = this.dimensions_;
    return function(s, m, v) {
      if (s) {
        var E = {
          TileMatrix: l.getMatrixId(s[0]),
          TileCol: s[1],
          TileRow: s[2]
        };
        In(E, h);
        var T = r;
        return n == "KVP" ? T = Xg(T, E) : T = T.replace(/\{(\w+?)\}/g, function(S, A) {
          return E[A];
        }), T;
      } else
        return;
    };
  }, e;
}(c8);
const S8 = T8;
var DM = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(Ja, function() {
    var r, n, i;
    function l(s, m) {
      if (!r)
        r = m;
      else if (!n)
        n = m;
      else {
        var v = "var sharedChunk = {}; (" + r + ")(sharedChunk); (" + n + ")(sharedChunk);", E = {};
        r(E), i = m(E), typeof window < "u" && (i.workerUrl = window.URL.createObjectURL(new Blob([v], { type: "text/javascript" })));
      }
    }
    l(["exports"], function(s) {
      var m = v;
      function v(c, o, u, d) {
        this.cx = 3 * c, this.bx = 3 * (u - c) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * o, this.by = 3 * (d - o) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = c, this.p1y = o, this.p2x = u, this.p2y = d;
      }
      function E(c, o, u, d) {
        const y = new m(c, o, u, d);
        return function(x) {
          return y.solve(x);
        };
      }
      v.prototype = { sampleCurveX: function(c) {
        return ((this.ax * c + this.bx) * c + this.cx) * c;
      }, sampleCurveY: function(c) {
        return ((this.ay * c + this.by) * c + this.cy) * c;
      }, sampleCurveDerivativeX: function(c) {
        return (3 * this.ax * c + 2 * this.bx) * c + this.cx;
      }, solveCurveX: function(c, o) {
        if (o === void 0 && (o = 1e-6), c < 0)
          return 0;
        if (c > 1)
          return 1;
        for (var u = c, d = 0; d < 8; d++) {
          var y = this.sampleCurveX(u) - c;
          if (Math.abs(y) < o)
            return u;
          var x = this.sampleCurveDerivativeX(u);
          if (Math.abs(x) < 1e-6)
            break;
          u -= y / x;
        }
        var w = 0, C = 1;
        for (u = c, d = 0; d < 20 && (y = this.sampleCurveX(u), !(Math.abs(y - c) < o)); d++)
          c > y ? w = u : C = u, u = 0.5 * (C - w) + w;
        return u;
      }, solve: function(c, o) {
        return this.sampleCurveY(this.solveCurveX(c, o));
      } };
      const T = E(0.25, 0.1, 0.25, 1);
      function S(c, o, u) {
        return Math.min(u, Math.max(o, c));
      }
      function A(c, o, u) {
        const d = u - o, y = ((c - o) % d + d) % d + o;
        return y === o ? u : y;
      }
      function L(c, ...o) {
        for (const u of o)
          for (const d in u)
            c[d] = u[d];
        return c;
      }
      let B = 1;
      function j(c, o) {
        c.forEach((u) => {
          o[u] && (o[u] = o[u].bind(o));
        });
      }
      function q(c, o, u) {
        const d = {};
        for (const y in c)
          d[y] = o.call(u || this, c[y], y, c);
        return d;
      }
      function H(c, o, u) {
        const d = {};
        for (const y in c)
          o.call(u || this, c[y], y, c) && (d[y] = c[y]);
        return d;
      }
      function ne(c) {
        return Array.isArray(c) ? c.map(ne) : typeof c == "object" && c ? q(c, ne) : c;
      }
      const ee = {};
      function he(c) {
        ee[c] || (typeof console < "u" && console.warn(c), ee[c] = !0);
      }
      function Te(c, o, u) {
        return (u.y - c.y) * (o.x - c.x) > (o.y - c.y) * (u.x - c.x);
      }
      function ve(c) {
        let o = 0;
        for (let u, d, y = 0, x = c.length, w = x - 1; y < x; w = y++)
          u = c[y], d = c[w], o += (d.x - u.x) * (u.y + d.y);
        return o;
      }
      function Oe() {
        return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
      }
      function Me(c) {
        const o = {};
        if (c.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (u, d, y, x) => {
          const w = y || x;
          return o[d] = !w || w.toLowerCase(), "";
        }), o["max-age"]) {
          const u = parseInt(o["max-age"], 10);
          isNaN(u) ? delete o["max-age"] : o["max-age"] = u;
        }
        return o;
      }
      let Re, He, Ve = null;
      function dt(c) {
        if (Ve == null) {
          const o = c.navigator ? c.navigator.userAgent : null;
          Ve = !!c.safari || !(!o || !(/\b(iPad|iPhone|iPod)\b/.test(o) || o.match("Safari") && !o.match("Chrome")));
        }
        return Ve;
      }
      function xe(c) {
        return typeof ImageBitmap < "u" && c instanceof ImageBitmap;
      }
      const ze = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(c) {
        const o = requestAnimationFrame(c);
        return { cancel: () => cancelAnimationFrame(o) };
      }, getImageData(c, o = 0) {
        const u = window.document.createElement("canvas"), d = u.getContext("2d");
        if (!d)
          throw new Error("failed to create canvas 2d context");
        return u.width = c.width, u.height = c.height, d.drawImage(c, 0, 0, c.width, c.height), d.getImageData(-o, -o, c.width + 2 * o, c.height + 2 * o);
      }, resolveURL: (c) => (Re || (Re = document.createElement("a")), Re.href = c, Re.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (He == null && (He = matchMedia("(prefers-reduced-motion: reduce)")), He.matches);
      } };
      var Pe = Ye;
      function Ye(c, o) {
        this.x = c, this.y = o;
      }
      Ye.prototype = { clone: function() {
        return new Ye(this.x, this.y);
      }, add: function(c) {
        return this.clone()._add(c);
      }, sub: function(c) {
        return this.clone()._sub(c);
      }, multByPoint: function(c) {
        return this.clone()._multByPoint(c);
      }, divByPoint: function(c) {
        return this.clone()._divByPoint(c);
      }, mult: function(c) {
        return this.clone()._mult(c);
      }, div: function(c) {
        return this.clone()._div(c);
      }, rotate: function(c) {
        return this.clone()._rotate(c);
      }, rotateAround: function(c, o) {
        return this.clone()._rotateAround(c, o);
      }, matMult: function(c) {
        return this.clone()._matMult(c);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(c) {
        return this.x === c.x && this.y === c.y;
      }, dist: function(c) {
        return Math.sqrt(this.distSqr(c));
      }, distSqr: function(c) {
        var o = c.x - this.x, u = c.y - this.y;
        return o * o + u * u;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(c) {
        return Math.atan2(this.y - c.y, this.x - c.x);
      }, angleWith: function(c) {
        return this.angleWithSep(c.x, c.y);
      }, angleWithSep: function(c, o) {
        return Math.atan2(this.x * o - this.y * c, this.x * c + this.y * o);
      }, _matMult: function(c) {
        var o = c[2] * this.x + c[3] * this.y;
        return this.x = c[0] * this.x + c[1] * this.y, this.y = o, this;
      }, _add: function(c) {
        return this.x += c.x, this.y += c.y, this;
      }, _sub: function(c) {
        return this.x -= c.x, this.y -= c.y, this;
      }, _mult: function(c) {
        return this.x *= c, this.y *= c, this;
      }, _div: function(c) {
        return this.x /= c, this.y /= c, this;
      }, _multByPoint: function(c) {
        return this.x *= c.x, this.y *= c.y, this;
      }, _divByPoint: function(c) {
        return this.x /= c.x, this.y /= c.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var c = this.y;
        return this.y = this.x, this.x = -c, this;
      }, _rotate: function(c) {
        var o = Math.cos(c), u = Math.sin(c), d = u * this.x + o * this.y;
        return this.x = o * this.x - u * this.y, this.y = d, this;
      }, _rotateAround: function(c, o) {
        var u = Math.cos(c), d = Math.sin(c), y = o.y + d * (this.x - o.x) + u * (this.y - o.y);
        return this.x = o.x + u * (this.x - o.x) - d * (this.y - o.y), this.y = y, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, Ye.convert = function(c) {
        return c instanceof Ye ? c : Array.isArray(c) ? new Ye(c[0], c[1]) : c;
      };
      const it = { MAX_PARALLEL_IMAGE_REQUESTS: 16, REGISTERED_PROTOCOLS: {} }, kt = "mapbox-tiles";
      let Er, mr, Yt = 500, on = 50;
      function or() {
        typeof caches > "u" || Er || (Er = caches.open(kt));
      }
      let Jt = 1 / 0;
      const Ht = { supported: !1, testSupport: function(c) {
        !an && Cr && (kr ? Pn(c) : xr = c);
      } };
      let xr, Cr, an = !1, kr = !1;
      function Pn(c) {
        const o = c.createTexture();
        c.bindTexture(c.TEXTURE_2D, o);
        try {
          if (c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, Cr), c.isContextLost())
            return;
          Ht.supported = !0;
        } catch {
        }
        c.deleteTexture(o), an = !0;
      }
      typeof document < "u" && (Cr = document.createElement("img"), Cr.onload = function() {
        xr && Pn(xr), xr = null, kr = !0;
      }, Cr.onerror = function() {
        an = !0, xr = null;
      }, Cr.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const qr = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
      typeof Object.freeze == "function" && Object.freeze(qr);
      class re extends Error {
        constructor(o, u, d, y) {
          super(`AJAXError: ${u} (${o}): ${d}`), this.status = o, this.statusText = u, this.url = d, this.body = y;
        }
      }
      const pe = Oe() ? () => self.worker && self.worker.referrer : () => (window.location.protocol === "blob:" ? window.parent : window).location.href;
      function ke(c, o) {
        const u = new AbortController(), d = new Request(c.url, { method: c.method || "GET", body: c.body, credentials: c.credentials, headers: c.headers, referrer: pe(), signal: u.signal });
        let y = !1, x = !1;
        return c.type === "json" && d.headers.set("Accept", "application/json"), ((w, C, I) => {
          if (x)
            return;
          const R = Date.now();
          fetch(d).then((N) => N.ok ? ((z, V, W) => {
            (c.type === "arrayBuffer" ? z.arrayBuffer() : c.type === "json" ? z.json() : z.text()).then((X) => {
              x || (V && W && function(se, ae, Ee) {
                if (or(), !Er)
                  return;
                const De = { status: ae.status, statusText: ae.statusText, headers: new Headers() };
                ae.headers.forEach((Ae, qe) => De.headers.set(qe, Ae));
                const we = Me(ae.headers.get("Cache-Control") || "");
                we["no-store"] || (we["max-age"] && De.headers.set("Expires", new Date(Ee + 1e3 * we["max-age"]).toUTCString()), new Date(De.headers.get("Expires")).getTime() - Ee < 42e4 || function(Ae, qe) {
                  if (mr === void 0)
                    try {
                      new Response(new ReadableStream()), mr = !0;
                    } catch {
                      mr = !1;
                    }
                  mr ? qe(Ae.body) : Ae.blob().then(qe);
                }(ae, (Ae) => {
                  const qe = new Response(Ae, De);
                  or(), Er && Er.then((je) => je.put(function(Et) {
                    const Ot = Et.indexOf("?");
                    return Ot < 0 ? Et : Et.slice(0, Ot);
                  }(se.url), qe)).catch((je) => he(je.message));
                }));
              }(d, V, W), y = !0, o(null, X, z.headers.get("Cache-Control"), z.headers.get("Expires")));
            }).catch((X) => {
              x || o(new Error(X.message));
            });
          })(N, null, R) : N.blob().then((z) => o(new re(N.status, N.statusText, c.url, z)))).catch((N) => {
            N.code !== 20 && o(new Error(N.message));
          });
        })(), { cancel: () => {
          x = !0, y || u.abort();
        } };
      }
      const Ze = function(c, o) {
        if (/:\/\//.test(c.url) && !/^https?:|^file:/.test(c.url)) {
          if (Oe() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", c, o);
          if (!Oe()) {
            const d = c.url.substring(0, c.url.indexOf("://"));
            return (it.REGISTERED_PROTOCOLS[d] || ke)(c, o);
          }
        }
        if (!(/^file:/.test(u = c.url) || /^file:/.test(pe()) && !/^\w+:/.test(u))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
            return ke(c, o);
          if (Oe() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", c, o, void 0, !0);
        }
        var u;
        return function(d, y) {
          const x = new XMLHttpRequest();
          x.open(d.method || "GET", d.url, !0), d.type === "arrayBuffer" && (x.responseType = "arraybuffer");
          for (const w in d.headers)
            x.setRequestHeader(w, d.headers[w]);
          return d.type === "json" && (x.responseType = "text", x.setRequestHeader("Accept", "application/json")), x.withCredentials = d.credentials === "include", x.onerror = () => {
            y(new Error(x.statusText));
          }, x.onload = () => {
            if ((x.status >= 200 && x.status < 300 || x.status === 0) && x.response !== null) {
              let w = x.response;
              if (d.type === "json")
                try {
                  w = JSON.parse(x.response);
                } catch (C) {
                  return y(C);
                }
              y(null, w, x.getResponseHeader("Cache-Control"), x.getResponseHeader("Expires"));
            } else {
              const w = new Blob([x.response], { type: x.getResponseHeader("Content-Type") });
              y(new re(x.status, x.statusText, d.url, w));
            }
          }, x.send(d.body), { cancel: () => x.abort() };
        }(c, o);
      }, Ge = function(c, o) {
        return Ze(L(c, { type: "arrayBuffer" }), o);
      };
      function rt(c) {
        const o = window.document.createElement("a");
        return o.href = c, o.protocol === window.document.location.protocol && o.host === window.document.location.host;
      }
      const Xe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let Je, at;
      Je = [], at = 0;
      const Ke = function(c, o) {
        if (Ht.supported && (c.headers || (c.headers = {}), c.headers.accept = "image/webp,*/*"), at >= it.MAX_PARALLEL_IMAGE_REQUESTS) {
          const x = { requestParameters: c, callback: o, cancelled: !1, cancel() {
            this.cancelled = !0;
          } };
          return Je.push(x), x;
        }
        at++;
        let u = !1;
        const d = () => {
          if (!u)
            for (u = !0, at--; Je.length && at < it.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const x = Je.shift(), { requestParameters: w, callback: C, cancelled: I } = x;
              I || (x.cancel = Ke(w, C).cancel);
            }
        }, y = Ge(c, (x, w, C, I) => {
          d(), x ? o(x) : w && function(R, N) {
            typeof createImageBitmap == "function" ? function(z, V) {
              const W = new Blob([new Uint8Array(z)], { type: "image/png" });
              createImageBitmap(W).then((X) => {
                V(null, X);
              }).catch((X) => {
                V(new Error(`Could not load image because of ${X.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
              });
            }(R, N) : function(z, V) {
              const W = new Image();
              W.onload = () => {
                V(null, W), URL.revokeObjectURL(W.src), W.onload = null, window.requestAnimationFrame(() => {
                  W.src = Xe;
                });
              }, W.onerror = () => V(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              const X = new Blob([new Uint8Array(z)], { type: "image/png" });
              W.src = z.byteLength ? URL.createObjectURL(X) : Xe;
            }(R, N);
          }(w, (R, N) => {
            R != null ? o(R) : N != null && o(null, N, { cacheControl: C, expires: I });
          });
        });
        return { cancel: () => {
          y.cancel(), d();
        } };
      };
      function At(c, o, u) {
        u[c] && u[c].indexOf(o) !== -1 || (u[c] = u[c] || [], u[c].push(o));
      }
      function mt(c, o, u) {
        if (u && u[c]) {
          const d = u[c].indexOf(o);
          d !== -1 && u[c].splice(d, 1);
        }
      }
      class St {
        constructor(o, u = {}) {
          L(this, u), this.type = o;
        }
      }
      class Ut extends St {
        constructor(o, u = {}) {
          super("error", L({ error: o }, u));
        }
      }
      class Wt {
        on(o, u) {
          return this._listeners = this._listeners || {}, At(o, u, this._listeners), this;
        }
        off(o, u) {
          return mt(o, u, this._listeners), mt(o, u, this._oneTimeListeners), this;
        }
        once(o, u) {
          return this._oneTimeListeners = this._oneTimeListeners || {}, At(o, u, this._oneTimeListeners), this;
        }
        fire(o, u) {
          typeof o == "string" && (o = new St(o, u || {}));
          const d = o.type;
          if (this.listens(d)) {
            o.target = this;
            const y = this._listeners && this._listeners[d] ? this._listeners[d].slice() : [];
            for (const C of y)
              C.call(this, o);
            const x = this._oneTimeListeners && this._oneTimeListeners[d] ? this._oneTimeListeners[d].slice() : [];
            for (const C of x)
              mt(d, C, this._oneTimeListeners), C.call(this, o);
            const w = this._eventedParent;
            w && (L(o, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), w.fire(o));
          } else
            o instanceof Ut && console.error(o.error);
          return this;
        }
        listens(o) {
          return this._listeners && this._listeners[o] && this._listeners[o].length > 0 || this._oneTimeListeners && this._oneTimeListeners[o] && this._oneTimeListeners[o].length > 0 || this._eventedParent && this._eventedParent.listens(o);
        }
        setEventedParent(o, u) {
          return this._eventedParent = o, this._eventedParentData = u, this;
        }
      }
      var Ce = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 }, elevationOffset: { type: "number", default: 450 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      class We {
        constructor(o, u, d, y) {
          this.message = (o ? `${o}: ` : "") + d, y && (this.identifier = y), u != null && u.__line__ && (this.line = u.__line__);
        }
      }
      function br(c) {
        const o = c.value;
        return o ? [new We(c.key, o, "constants have been deprecated as of v8")] : [];
      }
      function Wr(c, ...o) {
        for (const u of o)
          for (const d in u)
            c[d] = u[d];
        return c;
      }
      function Xt(c) {
        return c instanceof Number || c instanceof String || c instanceof Boolean ? c.valueOf() : c;
      }
      function gn(c) {
        if (Array.isArray(c))
          return c.map(gn);
        if (c instanceof Object && !(c instanceof Number || c instanceof String || c instanceof Boolean)) {
          const o = {};
          for (const u in c)
            o[u] = gn(c[u]);
          return o;
        }
        return Xt(c);
      }
      class Br extends Error {
        constructor(o, u) {
          super(u), this.message = u, this.key = o;
        }
      }
      class Ir {
        constructor(o, u = []) {
          this.parent = o, this.bindings = {};
          for (const [d, y] of u)
            this.bindings[d] = y;
        }
        concat(o) {
          return new Ir(this, o);
        }
        get(o) {
          if (this.bindings[o])
            return this.bindings[o];
          if (this.parent)
            return this.parent.get(o);
          throw new Error(`${o} not found in scope.`);
        }
        has(o) {
          return !!this.bindings[o] || !!this.parent && this.parent.has(o);
        }
      }
      const Yr = { kind: "null" }, nt = { kind: "number" }, Kt = { kind: "string" }, Gt = { kind: "boolean" }, Kn = { kind: "color" }, qo = { kind: "object" }, Lt = { kind: "value" }, vi = { kind: "collator" }, Vn = { kind: "formatted" }, sa = { kind: "padding" }, Tn = { kind: "resolvedImage" };
      function ni(c, o) {
        return { kind: "array", itemType: c, N: o };
      }
      function Rr(c) {
        if (c.kind === "array") {
          const o = Rr(c.itemType);
          return typeof c.N == "number" ? `array<${o}, ${c.N}>` : c.itemType.kind === "value" ? "array" : `array<${o}>`;
        }
        return c.kind;
      }
      const Na = [Yr, nt, Kt, Gt, Kn, Vn, qo, ni(Lt), sa, Tn];
      function Ri(c, o) {
        if (o.kind === "error")
          return null;
        if (c.kind === "array") {
          if (o.kind === "array" && (o.N === 0 && o.itemType.kind === "value" || !Ri(c.itemType, o.itemType)) && (typeof c.N != "number" || c.N === o.N))
            return null;
        } else {
          if (c.kind === o.kind)
            return null;
          if (c.kind === "value") {
            for (const u of Na)
              if (!Ri(u, o))
                return null;
          }
        }
        return `Expected ${Rr(c)} but found ${Rr(o)} instead.`;
      }
      function Ao(c, o) {
        return o.some((u) => u.kind === c.kind);
      }
      function la(c, o) {
        return o.some((u) => u === "null" ? c === null : u === "array" ? Array.isArray(c) : u === "object" ? c && !Array.isArray(c) && typeof c == "object" : u === typeof c);
      }
      var xi, Oo = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
      function Y(c) {
        return (c = Math.round(c)) < 0 ? 0 : c > 255 ? 255 : c;
      }
      function k(c) {
        return Y(c[c.length - 1] === "%" ? parseFloat(c) / 100 * 255 : parseInt(c));
      }
      function U(c) {
        return (o = c[c.length - 1] === "%" ? parseFloat(c) / 100 : parseFloat(c)) < 0 ? 0 : o > 1 ? 1 : o;
        var o;
      }
      function Z(c, o, u) {
        return u < 0 ? u += 1 : u > 1 && (u -= 1), 6 * u < 1 ? c + (o - c) * u * 6 : 2 * u < 1 ? o : 3 * u < 2 ? c + (o - c) * (2 / 3 - u) * 6 : c;
      }
      try {
        xi = {}.parseCSSColor = function(c) {
          var o, u = c.replace(/ /g, "").toLowerCase();
          if (u in Oo)
            return Oo[u].slice();
          if (u[0] === "#")
            return u.length === 4 ? (o = parseInt(u.substr(1), 16)) >= 0 && o <= 4095 ? [(3840 & o) >> 4 | (3840 & o) >> 8, 240 & o | (240 & o) >> 4, 15 & o | (15 & o) << 4, 1] : null : u.length === 7 && (o = parseInt(u.substr(1), 16)) >= 0 && o <= 16777215 ? [(16711680 & o) >> 16, (65280 & o) >> 8, 255 & o, 1] : null;
          var d = u.indexOf("("), y = u.indexOf(")");
          if (d !== -1 && y + 1 === u.length) {
            var x = u.substr(0, d), w = u.substr(d + 1, y - (d + 1)).split(","), C = 1;
            switch (x) {
              case "rgba":
                if (w.length !== 4)
                  return null;
                C = U(w.pop());
              case "rgb":
                return w.length !== 3 ? null : [k(w[0]), k(w[1]), k(w[2]), C];
              case "hsla":
                if (w.length !== 4)
                  return null;
                C = U(w.pop());
              case "hsl":
                if (w.length !== 3)
                  return null;
                var I = (parseFloat(w[0]) % 360 + 360) % 360 / 360, R = U(w[1]), N = U(w[2]), z = N <= 0.5 ? N * (R + 1) : N + R - N * R, V = 2 * N - z;
                return [Y(255 * Z(V, z, I + 1 / 3)), Y(255 * Z(V, z, I)), Y(255 * Z(V, z, I - 1 / 3)), C];
              default:
                return null;
            }
          }
          return null;
        };
      } catch {
      }
      class K {
        constructor(o, u, d, y = 1) {
          this.r = o, this.g = u, this.b = d, this.a = y;
        }
        static parse(o) {
          if (!o)
            return;
          if (o instanceof K)
            return o;
          if (typeof o != "string")
            return;
          const u = xi(o);
          return u ? new K(u[0] / 255 * u[3], u[1] / 255 * u[3], u[2] / 255 * u[3], u[3]) : void 0;
        }
        toString() {
          const [o, u, d, y] = this.toArray();
          return `rgba(${Math.round(o)},${Math.round(u)},${Math.round(d)},${y})`;
        }
        toArray() {
          const { r: o, g: u, b: d, a: y } = this;
          return y === 0 ? [0, 0, 0, 0] : [255 * o / y, 255 * u / y, 255 * d / y, y];
        }
      }
      K.black = new K(0, 0, 0, 1), K.white = new K(1, 1, 1, 1), K.transparent = new K(0, 0, 0, 0), K.red = new K(1, 0, 0, 1);
      class le {
        constructor(o, u, d) {
          this.sensitivity = o ? u ? "variant" : "case" : u ? "accent" : "base", this.locale = d, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(o, u) {
          return this.collator.compare(o, u);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class me {
        constructor(o, u, d, y, x) {
          this.text = o, this.image = u, this.scale = d, this.fontStack = y, this.textColor = x;
        }
      }
      class fe {
        constructor(o) {
          this.sections = o;
        }
        static fromString(o) {
          return new fe([new me(o, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((o) => o.text.length !== 0 || o.image && o.image.name.length !== 0);
        }
        static factory(o) {
          return o instanceof fe ? o : fe.fromString(o);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((o) => o.text).join("");
        }
      }
      class ce {
        constructor(o) {
          this.values = o.slice();
        }
        static parse(o) {
          if (o instanceof ce)
            return o;
          if (typeof o == "number")
            return new ce([o, o, o, o]);
          if (Array.isArray(o) && !(o.length < 1 || o.length > 4)) {
            for (const u of o)
              if (typeof u != "number")
                return;
            switch (o.length) {
              case 1:
                o = [o[0], o[0], o[0], o[0]];
                break;
              case 2:
                o = [o[0], o[1], o[0], o[1]];
                break;
              case 3:
                o = [o[0], o[1], o[2], o[1]];
            }
            return new ce(o);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      class ge {
        constructor(o) {
          this.name = o.name, this.available = o.available;
        }
        toString() {
          return this.name;
        }
        static fromString(o) {
          return o ? new ge({ name: o, available: !1 }) : null;
        }
      }
      function ye(c, o, u, d) {
        return typeof c == "number" && c >= 0 && c <= 255 && typeof o == "number" && o >= 0 && o <= 255 && typeof u == "number" && u >= 0 && u <= 255 ? d === void 0 || typeof d == "number" && d >= 0 && d <= 1 ? null : `Invalid rgba value [${[c, o, u, d].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof d == "number" ? [c, o, u, d] : [c, o, u]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function J(c) {
        if (c === null || typeof c == "string" || typeof c == "boolean" || typeof c == "number" || c instanceof K || c instanceof le || c instanceof fe || c instanceof ce || c instanceof ge)
          return !0;
        if (Array.isArray(c)) {
          for (const o of c)
            if (!J(o))
              return !1;
          return !0;
        }
        if (typeof c == "object") {
          for (const o in c)
            if (!J(c[o]))
              return !1;
          return !0;
        }
        return !1;
      }
      function ue(c) {
        if (c === null)
          return Yr;
        if (typeof c == "string")
          return Kt;
        if (typeof c == "boolean")
          return Gt;
        if (typeof c == "number")
          return nt;
        if (c instanceof K)
          return Kn;
        if (c instanceof le)
          return vi;
        if (c instanceof fe)
          return Vn;
        if (c instanceof ce)
          return sa;
        if (c instanceof ge)
          return Tn;
        if (Array.isArray(c)) {
          const o = c.length;
          let u;
          for (const d of c) {
            const y = ue(d);
            if (u) {
              if (u === y)
                continue;
              u = Lt;
              break;
            }
            u = y;
          }
          return ni(u || Lt, o);
        }
        return qo;
      }
      function Ne(c) {
        const o = typeof c;
        return c === null ? "" : o === "string" || o === "number" || o === "boolean" ? String(c) : c instanceof K || c instanceof fe || c instanceof ce || c instanceof ge ? c.toString() : JSON.stringify(c);
      }
      class ot {
        constructor(o, u) {
          this.type = o, this.value = u;
        }
        static parse(o, u) {
          if (o.length !== 2)
            return u.error(`'literal' expression requires exactly one argument, but found ${o.length - 1} instead.`);
          if (!J(o[1]))
            return u.error("invalid value");
          const d = o[1];
          let y = ue(d);
          const x = u.expectedType;
          return y.kind !== "array" || y.N !== 0 || !x || x.kind !== "array" || typeof x.N == "number" && x.N !== 0 || (y = x), new ot(y, d);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      class lt {
        constructor(o) {
          this.name = "ExpressionEvaluationError", this.message = o;
        }
        toJSON() {
          return this.message;
        }
      }
      const Mt = { string: Kt, number: nt, boolean: Gt, object: qo };
      class Pt {
        constructor(o, u) {
          this.type = o, this.args = u;
        }
        static parse(o, u) {
          if (o.length < 2)
            return u.error("Expected at least one argument.");
          let d, y = 1;
          const x = o[0];
          if (x === "array") {
            let C, I;
            if (o.length > 2) {
              const R = o[1];
              if (typeof R != "string" || !(R in Mt) || R === "object")
                return u.error('The item type argument of "array" must be one of string, number, boolean', 1);
              C = Mt[R], y++;
            } else
              C = Lt;
            if (o.length > 3) {
              if (o[2] !== null && (typeof o[2] != "number" || o[2] < 0 || o[2] !== Math.floor(o[2])))
                return u.error('The length argument to "array" must be a positive integer literal', 2);
              I = o[2], y++;
            }
            d = ni(C, I);
          } else {
            if (!Mt[x])
              throw new Error(`Types doesn't contain name = ${x}`);
            d = Mt[x];
          }
          const w = [];
          for (; y < o.length; y++) {
            const C = u.parse(o[y], y, Lt);
            if (!C)
              return null;
            w.push(C);
          }
          return new Pt(d, w);
        }
        evaluate(o) {
          for (let u = 0; u < this.args.length; u++) {
            const d = this.args[u].evaluate(o);
            if (!Ri(this.type, ue(d)))
              return d;
            if (u === this.args.length - 1)
              throw new lt(`Expected value to be of type ${Rr(this.type)}, but found ${Rr(ue(d))} instead.`);
          }
          throw new Error();
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return this.args.every((o) => o.outputDefined());
        }
      }
      const ur = { "to-boolean": Gt, "to-color": Kn, "to-number": nt, "to-string": Kt };
      class Rt {
        constructor(o, u) {
          this.type = o, this.args = u;
        }
        static parse(o, u) {
          if (o.length < 2)
            return u.error("Expected at least one argument.");
          const d = o[0];
          if (!ur[d])
            throw new Error(`Can't parse ${d} as it is not part of the known types`);
          if ((d === "to-boolean" || d === "to-string") && o.length !== 2)
            return u.error("Expected one argument.");
          const y = ur[d], x = [];
          for (let w = 1; w < o.length; w++) {
            const C = u.parse(o[w], w, Lt);
            if (!C)
              return null;
            x.push(C);
          }
          return new Rt(y, x);
        }
        evaluate(o) {
          if (this.type.kind === "boolean")
            return Boolean(this.args[0].evaluate(o));
          if (this.type.kind === "color") {
            let u, d;
            for (const y of this.args) {
              if (u = y.evaluate(o), d = null, u instanceof K)
                return u;
              if (typeof u == "string") {
                const x = o.parseColor(u);
                if (x)
                  return x;
              } else if (Array.isArray(u) && (d = u.length < 3 || u.length > 4 ? `Invalid rbga value ${JSON.stringify(u)}: expected an array containing either three or four numeric values.` : ye(u[0], u[1], u[2], u[3]), !d))
                return new K(u[0] / 255, u[1] / 255, u[2] / 255, u[3]);
            }
            throw new lt(d || `Could not parse color from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
          }
          if (this.type.kind === "padding") {
            let u;
            for (const d of this.args) {
              u = d.evaluate(o);
              const y = ce.parse(u);
              if (y)
                return y;
            }
            throw new lt(`Could not parse padding from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
          }
          if (this.type.kind === "number") {
            let u = null;
            for (const d of this.args) {
              if (u = d.evaluate(o), u === null)
                return 0;
              const y = Number(u);
              if (!isNaN(y))
                return y;
            }
            throw new lt(`Could not convert ${JSON.stringify(u)} to number.`);
          }
          return this.type.kind === "formatted" ? fe.fromString(Ne(this.args[0].evaluate(o))) : this.type.kind === "resolvedImage" ? ge.fromString(Ne(this.args[0].evaluate(o))) : Ne(this.args[0].evaluate(o));
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return this.args.every((o) => o.outputDefined());
        }
      }
      const Qt = ["Unknown", "Point", "LineString", "Polygon"];
      class gr {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Qt[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(o) {
          let u = this._parseColorCache[o];
          return u || (u = this._parseColorCache[o] = K.parse(o)), u;
        }
      }
      class jr {
        constructor(o, u, d, y) {
          this.name = o, this.type = u, this._evaluate = d, this.args = y;
        }
        evaluate(o) {
          return this._evaluate(o, this.args);
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return !1;
        }
        static parse(o, u) {
          const d = o[0], y = jr.definitions[d];
          if (!y)
            return u.error(`Unknown expression "${d}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const x = Array.isArray(y) ? y[0] : y.type, w = Array.isArray(y) ? [[y[1], y[2]]] : y.overloads, C = w.filter(([R]) => !Array.isArray(R) || R.length === o.length - 1);
          let I = null;
          for (const [R, N] of C) {
            I = new Js(u.registry, u.path, null, u.scope);
            const z = [];
            let V = !1;
            for (let W = 1; W < o.length; W++) {
              const X = o[W], se = Array.isArray(R) ? R[W - 1] : R.type, ae = I.parse(X, 1 + z.length, se);
              if (!ae) {
                V = !0;
                break;
              }
              z.push(ae);
            }
            if (!V)
              if (Array.isArray(R) && R.length !== z.length)
                I.error(`Expected ${R.length} arguments, but found ${z.length} instead.`);
              else {
                for (let W = 0; W < z.length; W++) {
                  const X = Array.isArray(R) ? R[W] : R.type, se = z[W];
                  I.concat(W + 1).checkSubtype(X, se.type);
                }
                if (I.errors.length === 0)
                  return new jr(d, x, N, z);
              }
          }
          if (C.length === 1)
            u.errors.push(...I.errors);
          else {
            const R = (C.length ? C : w).map(([z]) => {
              return V = z, Array.isArray(V) ? `(${V.map(Rr).join(", ")})` : `(${Rr(V.type)}...)`;
              var V;
            }).join(" | "), N = [];
            for (let z = 1; z < o.length; z++) {
              const V = u.parse(o[z], 1 + N.length);
              if (!V)
                return null;
              N.push(Rr(V.type));
            }
            u.error(`Expected arguments of type ${R}, but found (${N.join(", ")}) instead.`);
          }
          return null;
        }
        static register(o, u) {
          jr.definitions = u;
          for (const d in u)
            o[d] = jr;
        }
      }
      class ii {
        constructor(o, u, d) {
          this.type = vi, this.locale = d, this.caseSensitive = o, this.diacriticSensitive = u;
        }
        static parse(o, u) {
          if (o.length !== 2)
            return u.error("Expected one argument.");
          const d = o[1];
          if (typeof d != "object" || Array.isArray(d))
            return u.error("Collator options argument must be an object.");
          const y = u.parse(d["case-sensitive"] !== void 0 && d["case-sensitive"], 1, Gt);
          if (!y)
            return null;
          const x = u.parse(d["diacritic-sensitive"] !== void 0 && d["diacritic-sensitive"], 1, Gt);
          if (!x)
            return null;
          let w = null;
          return d.locale && (w = u.parse(d.locale, 1, Kt), !w) ? null : new ii(y, x, w);
        }
        evaluate(o) {
          return new le(this.caseSensitive.evaluate(o), this.diacriticSensitive.evaluate(o), this.locale ? this.locale.evaluate(o) : null);
        }
        eachChild(o) {
          o(this.caseSensitive), o(this.diacriticSensitive), this.locale && o(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      const yn = 8192;
      function bi(c, o) {
        c[0] = Math.min(c[0], o[0]), c[1] = Math.min(c[1], o[1]), c[2] = Math.max(c[2], o[0]), c[3] = Math.max(c[3], o[1]);
      }
      function Ks(c, o) {
        return !(c[0] <= o[0] || c[2] >= o[2] || c[1] <= o[1] || c[3] >= o[3]);
      }
      function ec(c, o) {
        const u = (180 + c[0]) / 360, d = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + c[1] * Math.PI / 360))) / 360, y = Math.pow(2, o.z);
        return [Math.round(u * y * yn), Math.round(d * y * yn)];
      }
      function Xr(c, o, u) {
        const d = c[0] - o[0], y = c[1] - o[1], x = c[0] - u[0], w = c[1] - u[1];
        return d * w - x * y == 0 && d * x <= 0 && y * w <= 0;
      }
      function Zh(c, o) {
        let u = !1;
        for (let w = 0, C = o.length; w < C; w++) {
          const I = o[w];
          for (let R = 0, N = I.length; R < N - 1; R++) {
            if (Xr(c, I[R], I[R + 1]))
              return !1;
            (y = I[R])[1] > (d = c)[1] != (x = I[R + 1])[1] > d[1] && d[0] < (x[0] - y[0]) * (d[1] - y[1]) / (x[1] - y[1]) + y[0] && (u = !u);
          }
        }
        var d, y, x;
        return u;
      }
      function Hh(c, o) {
        for (let u = 0; u < o.length; u++)
          if (Zh(c, o[u]))
            return !0;
        return !1;
      }
      function fp(c, o, u, d) {
        const y = d[0] - u[0], x = d[1] - u[1], w = (c[0] - u[0]) * x - y * (c[1] - u[1]), C = (o[0] - u[0]) * x - y * (o[1] - u[1]);
        return w > 0 && C < 0 || w < 0 && C > 0;
      }
      function dp(c, o, u) {
        for (const R of u)
          for (let N = 0; N < R.length - 1; ++N)
            if ((C = [(w = R[N + 1])[0] - (x = R[N])[0], w[1] - x[1]])[0] * (I = [(y = o)[0] - (d = c)[0], y[1] - d[1]])[1] - C[1] * I[0] != 0 && fp(d, y, x, w) && fp(x, w, d, y))
              return !0;
        var d, y, x, w, C, I;
        return !1;
      }
      function Kh(c, o) {
        for (let u = 0; u < c.length; ++u)
          if (!Zh(c[u], o))
            return !1;
        for (let u = 0; u < c.length - 1; ++u)
          if (dp(c[u], c[u + 1], o))
            return !1;
        return !0;
      }
      function Zy(c, o) {
        for (let u = 0; u < o.length; u++)
          if (Kh(c, o[u]))
            return !0;
        return !1;
      }
      function _u(c, o, u) {
        const d = [];
        for (let y = 0; y < c.length; y++) {
          const x = [];
          for (let w = 0; w < c[y].length; w++) {
            const C = ec(c[y][w], u);
            bi(o, C), x.push(C);
          }
          d.push(x);
        }
        return d;
      }
      function Yh(c, o, u) {
        const d = [];
        for (let y = 0; y < c.length; y++) {
          const x = _u(c[y], o, u);
          d.push(x);
        }
        return d;
      }
      function pp(c, o, u, d) {
        if (c[0] < u[0] || c[0] > u[2]) {
          const y = 0.5 * d;
          let x = c[0] - u[0] > y ? -d : u[0] - c[0] > y ? d : 0;
          x === 0 && (x = c[0] - u[2] > y ? -d : u[2] - c[0] > y ? d : 0), c[0] += x;
        }
        bi(o, c);
      }
      function mp(c, o, u, d) {
        const y = Math.pow(2, d.z) * yn, x = [d.x * yn, d.y * yn], w = [];
        for (const C of c)
          for (const I of C) {
            const R = [I.x + x[0], I.y + x[1]];
            pp(R, o, u, y), w.push(R);
          }
        return w;
      }
      function gp(c, o, u, d) {
        const y = Math.pow(2, d.z) * yn, x = [d.x * yn, d.y * yn], w = [];
        for (const I of c) {
          const R = [];
          for (const N of I) {
            const z = [N.x + x[0], N.y + x[1]];
            bi(o, z), R.push(z);
          }
          w.push(R);
        }
        if (o[2] - o[0] <= y / 2) {
          (C = o)[0] = C[1] = 1 / 0, C[2] = C[3] = -1 / 0;
          for (const I of w)
            for (const R of I)
              pp(R, o, u, y);
        }
        var C;
        return w;
      }
      class ps {
        constructor(o, u) {
          this.type = Gt, this.geojson = o, this.geometries = u;
        }
        static parse(o, u) {
          if (o.length !== 2)
            return u.error(`'within' expression requires exactly one argument, but found ${o.length - 1} instead.`);
          if (J(o[1])) {
            const d = o[1];
            if (d.type === "FeatureCollection")
              for (let y = 0; y < d.features.length; ++y) {
                const x = d.features[y].geometry.type;
                if (x === "Polygon" || x === "MultiPolygon")
                  return new ps(d, d.features[y].geometry);
              }
            else if (d.type === "Feature") {
              const y = d.geometry.type;
              if (y === "Polygon" || y === "MultiPolygon")
                return new ps(d, d.geometry);
            } else if (d.type === "Polygon" || d.type === "MultiPolygon")
              return new ps(d, d);
          }
          return u.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(o) {
          if (o.geometry() != null && o.canonicalID() != null) {
            if (o.geometryType() === "Point")
              return function(u, d) {
                const y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], w = u.canonicalID();
                if (d.type === "Polygon") {
                  const C = _u(d.coordinates, x, w), I = mp(u.geometry(), y, x, w);
                  if (!Ks(y, x))
                    return !1;
                  for (const R of I)
                    if (!Zh(R, C))
                      return !1;
                }
                if (d.type === "MultiPolygon") {
                  const C = Yh(d.coordinates, x, w), I = mp(u.geometry(), y, x, w);
                  if (!Ks(y, x))
                    return !1;
                  for (const R of I)
                    if (!Hh(R, C))
                      return !1;
                }
                return !0;
              }(o, this.geometries);
            if (o.geometryType() === "LineString")
              return function(u, d) {
                const y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], w = u.canonicalID();
                if (d.type === "Polygon") {
                  const C = _u(d.coordinates, x, w), I = gp(u.geometry(), y, x, w);
                  if (!Ks(y, x))
                    return !1;
                  for (const R of I)
                    if (!Kh(R, C))
                      return !1;
                }
                if (d.type === "MultiPolygon") {
                  const C = Yh(d.coordinates, x, w), I = gp(u.geometry(), y, x, w);
                  if (!Ks(y, x))
                    return !1;
                  for (const R of I)
                    if (!Zy(R, C))
                      return !1;
                }
                return !0;
              }(o, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      function tc(c) {
        if (c instanceof jr && (c.name === "get" && c.args.length === 1 || c.name === "feature-state" || c.name === "has" && c.args.length === 1 || c.name === "properties" || c.name === "geometry-type" || c.name === "id" || /^filter-/.test(c.name)) || c instanceof ps)
          return !1;
        let o = !0;
        return c.eachChild((u) => {
          o && !tc(u) && (o = !1);
        }), o;
      }
      function Ys(c) {
        if (c instanceof jr && c.name === "feature-state")
          return !1;
        let o = !0;
        return c.eachChild((u) => {
          o && !Ys(u) && (o = !1);
        }), o;
      }
      function vu(c, o) {
        if (c instanceof jr && o.indexOf(c.name) >= 0)
          return !1;
        let u = !0;
        return c.eachChild((d) => {
          u && !vu(d, o) && (u = !1);
        }), u;
      }
      class xu {
        constructor(o, u) {
          this.type = u.type, this.name = o, this.boundExpression = u;
        }
        static parse(o, u) {
          if (o.length !== 2 || typeof o[1] != "string")
            return u.error("'var' expression requires exactly one string literal argument.");
          const d = o[1];
          return u.scope.has(d) ? new xu(d, u.scope.get(d)) : u.error(`Unknown variable "${d}". Make sure "${d}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(o) {
          return this.boundExpression.evaluate(o);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
      }
      class Js {
        constructor(o, u = [], d, y = new Ir(), x = []) {
          this.registry = o, this.path = u, this.key = u.map((w) => `[${w}]`).join(""), this.scope = y, this.errors = x, this.expectedType = d;
        }
        parse(o, u, d, y, x = {}) {
          return u ? this.concat(u, d, y)._parse(o, x) : this._parse(o, x);
        }
        _parse(o, u) {
          function d(y, x, w) {
            return w === "assert" ? new Pt(x, [y]) : w === "coerce" ? new Rt(x, [y]) : y;
          }
          if (o !== null && typeof o != "string" && typeof o != "boolean" && typeof o != "number" || (o = ["literal", o]), Array.isArray(o)) {
            if (o.length === 0)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const y = o[0];
            if (typeof y != "string")
              return this.error(`Expression name must be a string, but found ${typeof y} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const x = this.registry[y];
            if (x) {
              let w = x.parse(o, this);
              if (!w)
                return null;
              if (this.expectedType) {
                const C = this.expectedType, I = w.type;
                if (C.kind !== "string" && C.kind !== "number" && C.kind !== "boolean" && C.kind !== "object" && C.kind !== "array" || I.kind !== "value")
                  if (C.kind !== "color" && C.kind !== "formatted" && C.kind !== "resolvedImage" || I.kind !== "value" && I.kind !== "string")
                    if (C.kind !== "padding" || I.kind !== "value" && I.kind !== "number" && I.kind !== "array") {
                      if (this.checkSubtype(C, I))
                        return null;
                    } else
                      w = d(w, C, u.typeAnnotation || "coerce");
                  else
                    w = d(w, C, u.typeAnnotation || "coerce");
                else
                  w = d(w, C, u.typeAnnotation || "assert");
              }
              if (!(w instanceof ot) && w.type.kind !== "resolvedImage" && Jh(w)) {
                const C = new gr();
                try {
                  w = new ot(w.type, w.evaluate(C));
                } catch (I) {
                  return this.error(I.message), null;
                }
              }
              return w;
            }
            return this.error(`Unknown expression "${y}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(o === void 0 ? "'undefined' value invalid. Use null instead." : typeof o == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof o} instead.`);
        }
        concat(o, u, d) {
          const y = typeof o == "number" ? this.path.concat(o) : this.path, x = d ? this.scope.concat(d) : this.scope;
          return new Js(this.registry, y, u || null, x, this.errors);
        }
        error(o, ...u) {
          const d = `${this.key}${u.map((y) => `[${y}]`).join("")}`;
          this.errors.push(new Br(d, o));
        }
        checkSubtype(o, u) {
          const d = Ri(o, u);
          return d && this.error(d), d;
        }
      }
      function Jh(c) {
        if (c instanceof xu)
          return Jh(c.boundExpression);
        if (c instanceof jr && c.name === "error" || c instanceof ii || c instanceof ps)
          return !1;
        const o = c instanceof Rt || c instanceof Pt;
        let u = !0;
        return c.eachChild((d) => {
          u = o ? u && Jh(d) : u && d instanceof ot;
        }), !!u && tc(c) && vu(c, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function bu(c, o) {
        const u = c.length - 1;
        let d, y, x = 0, w = u, C = 0;
        for (; x <= w; )
          if (C = Math.floor((x + w) / 2), d = c[C], y = c[C + 1], d <= o) {
            if (C === u || o < y)
              return C;
            x = C + 1;
          } else {
            if (!(d > o))
              throw new lt("Input is not a number.");
            w = C - 1;
          }
        return 0;
      }
      class rc {
        constructor(o, u, d) {
          this.type = o, this.input = u, this.labels = [], this.outputs = [];
          for (const [y, x] of d)
            this.labels.push(y), this.outputs.push(x);
        }
        static parse(o, u) {
          if (o.length - 1 < 4)
            return u.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
          if ((o.length - 1) % 2 != 0)
            return u.error("Expected an even number of arguments.");
          const d = u.parse(o[1], 1, nt);
          if (!d)
            return null;
          const y = [];
          let x = null;
          u.expectedType && u.expectedType.kind !== "value" && (x = u.expectedType);
          for (let w = 1; w < o.length; w += 2) {
            const C = w === 1 ? -1 / 0 : o[w], I = o[w + 1], R = w, N = w + 1;
            if (typeof C != "number")
              return u.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', R);
            if (y.length && y[y.length - 1][0] >= C)
              return u.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', R);
            const z = u.parse(I, N, x);
            if (!z)
              return null;
            x = x || z.type, y.push([C, z]);
          }
          return new rc(x, d, y);
        }
        evaluate(o) {
          const u = this.labels, d = this.outputs;
          if (u.length === 1)
            return d[0].evaluate(o);
          const y = this.input.evaluate(o);
          if (y <= u[0])
            return d[0].evaluate(o);
          const x = u.length;
          return y >= u[x - 1] ? d[x - 1].evaluate(o) : d[bu(u, y)].evaluate(o);
        }
        eachChild(o) {
          o(this.input);
          for (const u of this.outputs)
            o(u);
        }
        outputDefined() {
          return this.outputs.every((o) => o.outputDefined());
        }
      }
      function _n(c, o, u) {
        return c * (1 - u) + o * u;
      }
      var nc = Object.freeze({ __proto__: null, number: _n, color: function(c, o, u) {
        return new K(_n(c.r, o.r, u), _n(c.g, o.g, u), _n(c.b, o.b, u), _n(c.a, o.a, u));
      }, array: function(c, o, u) {
        return c.map((d, y) => _n(d, o[y], u));
      }, padding: function(c, o, u) {
        const d = c.values, y = o.values;
        return new ce([_n(d[0], y[0], u), _n(d[1], y[1], u), _n(d[2], y[2], u), _n(d[3], y[3], u)]);
      } });
      const yp = 0.95047, _p = 1.08883, Qh = 4 / 29, wu = 6 / 29, vp = 3 * wu * wu, Hy = Math.PI / 180, Ky = 180 / Math.PI;
      function ef(c) {
        return c > 0.008856451679035631 ? Math.pow(c, 1 / 3) : c / vp + Qh;
      }
      function tf(c) {
        return c > wu ? c * c * c : vp * (c - Qh);
      }
      function rf(c) {
        return 255 * (c <= 31308e-7 ? 12.92 * c : 1.055 * Math.pow(c, 1 / 2.4) - 0.055);
      }
      function nf(c) {
        return (c /= 255) <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      }
      function Lr(c) {
        const o = nf(c.r), u = nf(c.g), d = nf(c.b), y = ef((0.4124564 * o + 0.3575761 * u + 0.1804375 * d) / yp), x = ef((0.2126729 * o + 0.7151522 * u + 0.072175 * d) / 1);
        return { l: 116 * x - 16, a: 500 * (y - x), b: 200 * (x - ef((0.0193339 * o + 0.119192 * u + 0.9503041 * d) / _p)), alpha: c.a };
      }
      function xp(c) {
        let o = (c.l + 16) / 116, u = isNaN(c.a) ? o : o + c.a / 500, d = isNaN(c.b) ? o : o - c.b / 200;
        return o = 1 * tf(o), u = yp * tf(u), d = _p * tf(d), new K(rf(3.2404542 * u - 1.5371385 * o - 0.4985314 * d), rf(-0.969266 * u + 1.8760108 * o + 0.041556 * d), rf(0.0556434 * u - 0.2040259 * o + 1.0572252 * d), c.alpha);
      }
      function Yy(c, o, u) {
        const d = o - c;
        return c + u * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
      }
      const ic = { forward: Lr, reverse: xp, interpolate: function(c, o, u) {
        return { l: _n(c.l, o.l, u), a: _n(c.a, o.a, u), b: _n(c.b, o.b, u), alpha: _n(c.alpha, o.alpha, u) };
      } }, oc = { forward: function(c) {
        const { l: o, a: u, b: d } = Lr(c), y = Math.atan2(d, u) * Ky;
        return { h: y < 0 ? y + 360 : y, c: Math.sqrt(u * u + d * d), l: o, alpha: c.a };
      }, reverse: function(c) {
        const o = c.h * Hy, u = c.c;
        return xp({ l: c.l, a: Math.cos(o) * u, b: Math.sin(o) * u, alpha: c.alpha });
      }, interpolate: function(c, o, u) {
        return { h: Yy(c.h, o.h, u), c: _n(c.c, o.c, u), l: _n(c.l, o.l, u), alpha: _n(c.alpha, o.alpha, u) };
      } };
      var bp = Object.freeze({ __proto__: null, lab: ic, hcl: oc });
      class Qi {
        constructor(o, u, d, y, x) {
          this.type = o, this.operator = u, this.interpolation = d, this.input = y, this.labels = [], this.outputs = [];
          for (const [w, C] of x)
            this.labels.push(w), this.outputs.push(C);
        }
        static interpolationFactor(o, u, d, y) {
          let x = 0;
          if (o.name === "exponential")
            x = of(u, o.base, d, y);
          else if (o.name === "linear")
            x = of(u, 1, d, y);
          else if (o.name === "cubic-bezier") {
            const w = o.controlPoints;
            x = new m(w[0], w[1], w[2], w[3]).solve(of(u, 1, d, y));
          }
          return x;
        }
        static parse(o, u) {
          let [d, y, x, ...w] = o;
          if (!Array.isArray(y) || y.length === 0)
            return u.error("Expected an interpolation type expression.", 1);
          if (y[0] === "linear")
            y = { name: "linear" };
          else if (y[0] === "exponential") {
            const R = y[1];
            if (typeof R != "number")
              return u.error("Exponential interpolation requires a numeric base.", 1, 1);
            y = { name: "exponential", base: R };
          } else {
            if (y[0] !== "cubic-bezier")
              return u.error(`Unknown interpolation type ${String(y[0])}`, 1, 0);
            {
              const R = y.slice(1);
              if (R.length !== 4 || R.some((N) => typeof N != "number" || N < 0 || N > 1))
                return u.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              y = { name: "cubic-bezier", controlPoints: R };
            }
          }
          if (o.length - 1 < 4)
            return u.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
          if ((o.length - 1) % 2 != 0)
            return u.error("Expected an even number of arguments.");
          if (x = u.parse(x, 2, nt), !x)
            return null;
          const C = [];
          let I = null;
          d === "interpolate-hcl" || d === "interpolate-lab" ? I = Kn : u.expectedType && u.expectedType.kind !== "value" && (I = u.expectedType);
          for (let R = 0; R < w.length; R += 2) {
            const N = w[R], z = w[R + 1], V = R + 3, W = R + 4;
            if (typeof N != "number")
              return u.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', V);
            if (C.length && C[C.length - 1][0] >= N)
              return u.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', V);
            const X = u.parse(z, W, I);
            if (!X)
              return null;
            I = I || X.type, C.push([N, X]);
          }
          return I.kind === "number" || I.kind === "color" || I.kind === "padding" || I.kind === "array" && I.itemType.kind === "number" && typeof I.N == "number" ? new Qi(I, d, y, x, C) : u.error(`Type ${Rr(I)} is not interpolatable.`);
        }
        evaluate(o) {
          const u = this.labels, d = this.outputs;
          if (u.length === 1)
            return d[0].evaluate(o);
          const y = this.input.evaluate(o);
          if (y <= u[0])
            return d[0].evaluate(o);
          const x = u.length;
          if (y >= u[x - 1])
            return d[x - 1].evaluate(o);
          const w = bu(u, y), C = Qi.interpolationFactor(this.interpolation, y, u[w], u[w + 1]), I = d[w].evaluate(o), R = d[w + 1].evaluate(o);
          return this.operator === "interpolate" ? nc[this.type.kind.toLowerCase()](I, R, C) : this.operator === "interpolate-hcl" ? oc.reverse(oc.interpolate(oc.forward(I), oc.forward(R), C)) : ic.reverse(ic.interpolate(ic.forward(I), ic.forward(R), C));
        }
        eachChild(o) {
          o(this.input);
          for (const u of this.outputs)
            o(u);
        }
        outputDefined() {
          return this.outputs.every((o) => o.outputDefined());
        }
      }
      function of(c, o, u, d) {
        const y = d - u, x = c - u;
        return y === 0 ? 0 : o === 1 ? x / y : (Math.pow(o, x) - 1) / (Math.pow(o, y) - 1);
      }
      class Eu {
        constructor(o, u) {
          this.type = o, this.args = u;
        }
        static parse(o, u) {
          if (o.length < 2)
            return u.error("Expectected at least one argument.");
          let d = null;
          const y = u.expectedType;
          y && y.kind !== "value" && (d = y);
          const x = [];
          for (const C of o.slice(1)) {
            const I = u.parse(C, 1 + x.length, d, void 0, { typeAnnotation: "omit" });
            if (!I)
              return null;
            d = d || I.type, x.push(I);
          }
          if (!d)
            throw new Error("No output type");
          const w = y && x.some((C) => Ri(y, C.type));
          return new Eu(w ? Lt : d, x);
        }
        evaluate(o) {
          let u, d = null, y = 0;
          for (const x of this.args)
            if (y++, d = x.evaluate(o), d && d instanceof ge && !d.available && (u || (u = d.name), d = null, y === this.args.length && (d = u)), d !== null)
              break;
          return d;
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return this.args.every((o) => o.outputDefined());
        }
      }
      class Tu {
        constructor(o, u) {
          this.type = u.type, this.bindings = [].concat(o), this.result = u;
        }
        evaluate(o) {
          return this.result.evaluate(o);
        }
        eachChild(o) {
          for (const u of this.bindings)
            o(u[1]);
          o(this.result);
        }
        static parse(o, u) {
          if (o.length < 4)
            return u.error(`Expected at least 3 arguments, but found ${o.length - 1} instead.`);
          const d = [];
          for (let x = 1; x < o.length - 1; x += 2) {
            const w = o[x];
            if (typeof w != "string")
              return u.error(`Expected string, but found ${typeof w} instead.`, x);
            if (/[^a-zA-Z0-9_]/.test(w))
              return u.error("Variable names must contain only alphanumeric characters or '_'.", x);
            const C = u.parse(o[x + 1], x + 1);
            if (!C)
              return null;
            d.push([w, C]);
          }
          const y = u.parse(o[o.length - 1], o.length - 1, u.expectedType, d);
          return y ? new Tu(d, y) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class af {
        constructor(o, u, d) {
          this.type = o, this.index = u, this.input = d;
        }
        static parse(o, u) {
          if (o.length !== 3)
            return u.error(`Expected 2 arguments, but found ${o.length - 1} instead.`);
          const d = u.parse(o[1], 1, nt), y = u.parse(o[2], 2, ni(u.expectedType || Lt));
          return d && y ? new af(y.type.itemType, d, y) : null;
        }
        evaluate(o) {
          const u = this.index.evaluate(o), d = this.input.evaluate(o);
          if (u < 0)
            throw new lt(`Array index out of bounds: ${u} < 0.`);
          if (u >= d.length)
            throw new lt(`Array index out of bounds: ${u} > ${d.length - 1}.`);
          if (u !== Math.floor(u))
            throw new lt(`Array index must be an integer, but found ${u} instead.`);
          return d[u];
        }
        eachChild(o) {
          o(this.index), o(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class sf {
        constructor(o, u) {
          this.type = Gt, this.needle = o, this.haystack = u;
        }
        static parse(o, u) {
          if (o.length !== 3)
            return u.error(`Expected 2 arguments, but found ${o.length - 1} instead.`);
          const d = u.parse(o[1], 1, Lt), y = u.parse(o[2], 2, Lt);
          return d && y ? Ao(d.type, [Gt, Kt, nt, Yr, Lt]) ? new sf(d, y) : u.error(`Expected first argument to be of type boolean, string, number or null, but found ${Rr(d.type)} instead`) : null;
        }
        evaluate(o) {
          const u = this.needle.evaluate(o), d = this.haystack.evaluate(o);
          if (!d)
            return !1;
          if (!la(u, ["boolean", "string", "number", "null"]))
            throw new lt(`Expected first argument to be of type boolean, string, number or null, but found ${Rr(ue(u))} instead.`);
          if (!la(d, ["string", "array"]))
            throw new lt(`Expected second argument to be of type array or string, but found ${Rr(ue(d))} instead.`);
          return d.indexOf(u) >= 0;
        }
        eachChild(o) {
          o(this.needle), o(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class Su {
        constructor(o, u, d) {
          this.type = nt, this.needle = o, this.haystack = u, this.fromIndex = d;
        }
        static parse(o, u) {
          if (o.length <= 2 || o.length >= 5)
            return u.error(`Expected 3 or 4 arguments, but found ${o.length - 1} instead.`);
          const d = u.parse(o[1], 1, Lt), y = u.parse(o[2], 2, Lt);
          if (!d || !y)
            return null;
          if (!Ao(d.type, [Gt, Kt, nt, Yr, Lt]))
            return u.error(`Expected first argument to be of type boolean, string, number or null, but found ${Rr(d.type)} instead`);
          if (o.length === 4) {
            const x = u.parse(o[3], 3, nt);
            return x ? new Su(d, y, x) : null;
          }
          return new Su(d, y);
        }
        evaluate(o) {
          const u = this.needle.evaluate(o), d = this.haystack.evaluate(o);
          if (!la(u, ["boolean", "string", "number", "null"]))
            throw new lt(`Expected first argument to be of type boolean, string, number or null, but found ${Rr(ue(u))} instead.`);
          if (!la(d, ["string", "array"]))
            throw new lt(`Expected second argument to be of type array or string, but found ${Rr(ue(d))} instead.`);
          if (this.fromIndex) {
            const y = this.fromIndex.evaluate(o);
            return d.indexOf(u, y);
          }
          return d.indexOf(u);
        }
        eachChild(o) {
          o(this.needle), o(this.haystack), this.fromIndex && o(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class lf {
        constructor(o, u, d, y, x, w) {
          this.inputType = o, this.type = u, this.input = d, this.cases = y, this.outputs = x, this.otherwise = w;
        }
        static parse(o, u) {
          if (o.length < 5)
            return u.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
          if (o.length % 2 != 1)
            return u.error("Expected an even number of arguments.");
          let d, y;
          u.expectedType && u.expectedType.kind !== "value" && (y = u.expectedType);
          const x = {}, w = [];
          for (let R = 2; R < o.length - 1; R += 2) {
            let N = o[R];
            const z = o[R + 1];
            Array.isArray(N) || (N = [N]);
            const V = u.concat(R);
            if (N.length === 0)
              return V.error("Expected at least one branch label.");
            for (const X of N) {
              if (typeof X != "number" && typeof X != "string")
                return V.error("Branch labels must be numbers or strings.");
              if (typeof X == "number" && Math.abs(X) > Number.MAX_SAFE_INTEGER)
                return V.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof X == "number" && Math.floor(X) !== X)
                return V.error("Numeric branch labels must be integer values.");
              if (d) {
                if (V.checkSubtype(d, ue(X)))
                  return null;
              } else
                d = ue(X);
              if (x[String(X)] !== void 0)
                return V.error("Branch labels must be unique.");
              x[String(X)] = w.length;
            }
            const W = u.parse(z, R, y);
            if (!W)
              return null;
            y = y || W.type, w.push(W);
          }
          const C = u.parse(o[1], 1, Lt);
          if (!C)
            return null;
          const I = u.parse(o[o.length - 1], o.length - 1, y);
          return I ? C.type.kind !== "value" && u.concat(1).checkSubtype(d, C.type) ? null : new lf(d, y, C, x, w, I) : null;
        }
        evaluate(o) {
          const u = this.input.evaluate(o);
          return (ue(u) === this.inputType && this.outputs[this.cases[u]] || this.otherwise).evaluate(o);
        }
        eachChild(o) {
          o(this.input), this.outputs.forEach(o), o(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((o) => o.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class cf {
        constructor(o, u, d) {
          this.type = o, this.branches = u, this.otherwise = d;
        }
        static parse(o, u) {
          if (o.length < 4)
            return u.error(`Expected at least 3 arguments, but found only ${o.length - 1}.`);
          if (o.length % 2 != 0)
            return u.error("Expected an odd number of arguments.");
          let d;
          u.expectedType && u.expectedType.kind !== "value" && (d = u.expectedType);
          const y = [];
          for (let w = 1; w < o.length - 1; w += 2) {
            const C = u.parse(o[w], w, Gt);
            if (!C)
              return null;
            const I = u.parse(o[w + 1], w + 1, d);
            if (!I)
              return null;
            y.push([C, I]), d = d || I.type;
          }
          const x = u.parse(o[o.length - 1], o.length - 1, d);
          if (!x)
            return null;
          if (!d)
            throw new Error("Can't infer output type");
          return new cf(d, y, x);
        }
        evaluate(o) {
          for (const [u, d] of this.branches)
            if (u.evaluate(o))
              return d.evaluate(o);
          return this.otherwise.evaluate(o);
        }
        eachChild(o) {
          for (const [u, d] of this.branches)
            o(u), o(d);
          o(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([o, u]) => u.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class Mu {
        constructor(o, u, d, y) {
          this.type = o, this.input = u, this.beginIndex = d, this.endIndex = y;
        }
        static parse(o, u) {
          if (o.length <= 2 || o.length >= 5)
            return u.error(`Expected 3 or 4 arguments, but found ${o.length - 1} instead.`);
          const d = u.parse(o[1], 1, Lt), y = u.parse(o[2], 2, nt);
          if (!d || !y)
            return null;
          if (!Ao(d.type, [ni(Lt), Kt, Lt]))
            return u.error(`Expected first argument to be of type array or string, but found ${Rr(d.type)} instead`);
          if (o.length === 4) {
            const x = u.parse(o[3], 3, nt);
            return x ? new Mu(d.type, d, y, x) : null;
          }
          return new Mu(d.type, d, y);
        }
        evaluate(o) {
          const u = this.input.evaluate(o), d = this.beginIndex.evaluate(o);
          if (!la(u, ["string", "array"]))
            throw new lt(`Expected first argument to be of type array or string, but found ${Rr(ue(u))} instead.`);
          if (this.endIndex) {
            const y = this.endIndex.evaluate(o);
            return u.slice(d, y);
          }
          return u.slice(d);
        }
        eachChild(o) {
          o(this.input), o(this.beginIndex), this.endIndex && o(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function wp(c, o) {
        return c === "==" || c === "!=" ? o.kind === "boolean" || o.kind === "string" || o.kind === "number" || o.kind === "null" || o.kind === "value" : o.kind === "string" || o.kind === "number" || o.kind === "value";
      }
      function Ep(c, o, u, d) {
        return d.compare(o, u) === 0;
      }
      function Qs(c, o, u) {
        const d = c !== "==" && c !== "!=";
        return class kM {
          constructor(x, w, C) {
            this.type = Gt, this.lhs = x, this.rhs = w, this.collator = C, this.hasUntypedArgument = x.type.kind === "value" || w.type.kind === "value";
          }
          static parse(x, w) {
            if (x.length !== 3 && x.length !== 4)
              return w.error("Expected two or three arguments.");
            const C = x[0];
            let I = w.parse(x[1], 1, Lt);
            if (!I)
              return null;
            if (!wp(C, I.type))
              return w.concat(1).error(`"${C}" comparisons are not supported for type '${Rr(I.type)}'.`);
            let R = w.parse(x[2], 2, Lt);
            if (!R)
              return null;
            if (!wp(C, R.type))
              return w.concat(2).error(`"${C}" comparisons are not supported for type '${Rr(R.type)}'.`);
            if (I.type.kind !== R.type.kind && I.type.kind !== "value" && R.type.kind !== "value")
              return w.error(`Cannot compare types '${Rr(I.type)}' and '${Rr(R.type)}'.`);
            d && (I.type.kind === "value" && R.type.kind !== "value" ? I = new Pt(R.type, [I]) : I.type.kind !== "value" && R.type.kind === "value" && (R = new Pt(I.type, [R])));
            let N = null;
            if (x.length === 4) {
              if (I.type.kind !== "string" && R.type.kind !== "string" && I.type.kind !== "value" && R.type.kind !== "value")
                return w.error("Cannot use collator to compare non-string types.");
              if (N = w.parse(x[3], 3, vi), !N)
                return null;
            }
            return new kM(I, R, N);
          }
          evaluate(x) {
            const w = this.lhs.evaluate(x), C = this.rhs.evaluate(x);
            if (d && this.hasUntypedArgument) {
              const I = ue(w), R = ue(C);
              if (I.kind !== R.kind || I.kind !== "string" && I.kind !== "number")
                throw new lt(`Expected arguments for "${c}" to be (string, string) or (number, number), but found (${I.kind}, ${R.kind}) instead.`);
            }
            if (this.collator && !d && this.hasUntypedArgument) {
              const I = ue(w), R = ue(C);
              if (I.kind !== "string" || R.kind !== "string")
                return o(x, w, C);
            }
            return this.collator ? u(x, w, C, this.collator.evaluate(x)) : o(x, w, C);
          }
          eachChild(x) {
            x(this.lhs), x(this.rhs), this.collator && x(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const Jy = Qs("==", function(c, o, u) {
        return o === u;
      }, Ep), Qy = Qs("!=", function(c, o, u) {
        return o !== u;
      }, function(c, o, u, d) {
        return !Ep(0, o, u, d);
      }), e_ = Qs("<", function(c, o, u) {
        return o < u;
      }, function(c, o, u, d) {
        return d.compare(o, u) < 0;
      }), t_ = Qs(">", function(c, o, u) {
        return o > u;
      }, function(c, o, u, d) {
        return d.compare(o, u) > 0;
      }), r_ = Qs("<=", function(c, o, u) {
        return o <= u;
      }, function(c, o, u, d) {
        return d.compare(o, u) <= 0;
      }), n_ = Qs(">=", function(c, o, u) {
        return o >= u;
      }, function(c, o, u, d) {
        return d.compare(o, u) >= 0;
      });
      class uf {
        constructor(o, u, d, y, x) {
          this.type = Kt, this.number = o, this.locale = u, this.currency = d, this.minFractionDigits = y, this.maxFractionDigits = x;
        }
        static parse(o, u) {
          if (o.length !== 3)
            return u.error("Expected two arguments.");
          const d = u.parse(o[1], 1, nt);
          if (!d)
            return null;
          const y = o[2];
          if (typeof y != "object" || Array.isArray(y))
            return u.error("NumberFormat options argument must be an object.");
          let x = null;
          if (y.locale && (x = u.parse(y.locale, 1, Kt), !x))
            return null;
          let w = null;
          if (y.currency && (w = u.parse(y.currency, 1, Kt), !w))
            return null;
          let C = null;
          if (y["min-fraction-digits"] && (C = u.parse(y["min-fraction-digits"], 1, nt), !C))
            return null;
          let I = null;
          return y["max-fraction-digits"] && (I = u.parse(y["max-fraction-digits"], 1, nt), !I) ? null : new uf(d, x, w, C, I);
        }
        evaluate(o) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(o) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(o) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(o) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(o) : void 0 }).format(this.number.evaluate(o));
        }
        eachChild(o) {
          o(this.number), this.locale && o(this.locale), this.currency && o(this.currency), this.minFractionDigits && o(this.minFractionDigits), this.maxFractionDigits && o(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class Cu {
        constructor(o) {
          this.type = Vn, this.sections = o;
        }
        static parse(o, u) {
          if (o.length < 2)
            return u.error("Expected at least one argument.");
          const d = o[1];
          if (!Array.isArray(d) && typeof d == "object")
            return u.error("First argument must be an image or text section.");
          const y = [];
          let x = !1;
          for (let w = 1; w <= o.length - 1; ++w) {
            const C = o[w];
            if (x && typeof C == "object" && !Array.isArray(C)) {
              x = !1;
              let I = null;
              if (C["font-scale"] && (I = u.parse(C["font-scale"], 1, nt), !I))
                return null;
              let R = null;
              if (C["text-font"] && (R = u.parse(C["text-font"], 1, ni(Kt)), !R))
                return null;
              let N = null;
              if (C["text-color"] && (N = u.parse(C["text-color"], 1, Kn), !N))
                return null;
              const z = y[y.length - 1];
              z.scale = I, z.font = R, z.textColor = N;
            } else {
              const I = u.parse(o[w], 1, Lt);
              if (!I)
                return null;
              const R = I.type.kind;
              if (R !== "string" && R !== "value" && R !== "null" && R !== "resolvedImage")
                return u.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              x = !0, y.push({ content: I, scale: null, font: null, textColor: null });
            }
          }
          return new Cu(y);
        }
        evaluate(o) {
          return new fe(this.sections.map((u) => {
            const d = u.content.evaluate(o);
            return ue(d) === Tn ? new me("", d, null, null, null) : new me(Ne(d), null, u.scale ? u.scale.evaluate(o) : null, u.font ? u.font.evaluate(o).join(",") : null, u.textColor ? u.textColor.evaluate(o) : null);
          }));
        }
        eachChild(o) {
          for (const u of this.sections)
            o(u.content), u.scale && o(u.scale), u.font && o(u.font), u.textColor && o(u.textColor);
        }
        outputDefined() {
          return !1;
        }
      }
      class hf {
        constructor(o) {
          this.type = Tn, this.input = o;
        }
        static parse(o, u) {
          if (o.length !== 2)
            return u.error("Expected two arguments.");
          const d = u.parse(o[1], 1, Kt);
          return d ? new hf(d) : u.error("No image name provided.");
        }
        evaluate(o) {
          const u = this.input.evaluate(o), d = ge.fromString(u);
          return d && o.availableImages && (d.available = o.availableImages.indexOf(u) > -1), d;
        }
        eachChild(o) {
          o(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class ff {
        constructor(o) {
          this.type = nt, this.input = o;
        }
        static parse(o, u) {
          if (o.length !== 2)
            return u.error(`Expected 1 argument, but found ${o.length - 1} instead.`);
          const d = u.parse(o[1], 1);
          return d ? d.type.kind !== "array" && d.type.kind !== "string" && d.type.kind !== "value" ? u.error(`Expected argument of type string or array, but found ${Rr(d.type)} instead.`) : new ff(d) : null;
        }
        evaluate(o) {
          const u = this.input.evaluate(o);
          if (typeof u == "string" || Array.isArray(u))
            return u.length;
          throw new lt(`Expected value to be of type string or array, but found ${Rr(ue(u))} instead.`);
        }
        eachChild(o) {
          o(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const el = { "==": Jy, "!=": Qy, ">": t_, "<": e_, ">=": n_, "<=": r_, array: Pt, at: af, boolean: Pt, case: cf, coalesce: Eu, collator: ii, format: Cu, image: hf, in: sf, "index-of": Su, interpolate: Qi, "interpolate-hcl": Qi, "interpolate-lab": Qi, length: ff, let: Tu, literal: ot, match: lf, number: Pt, "number-format": uf, object: Pt, slice: Mu, step: rc, string: Pt, "to-boolean": Rt, "to-color": Rt, "to-number": Rt, "to-string": Rt, var: xu, within: ps };
      function Tp(c, [o, u, d, y]) {
        o = o.evaluate(c), u = u.evaluate(c), d = d.evaluate(c);
        const x = y ? y.evaluate(c) : 1, w = ye(o, u, d, x);
        if (w)
          throw new lt(w);
        return new K(o / 255 * x, u / 255 * x, d / 255 * x, x);
      }
      function Sp(c, o) {
        return c in o;
      }
      function Iu(c, o) {
        const u = o[c];
        return u === void 0 ? null : u;
      }
      function ms(c) {
        return { type: c };
      }
      function Mp(c) {
        return { result: "success", value: c };
      }
      function tl(c) {
        return { result: "error", value: c };
      }
      function hn(c) {
        return c["property-type"] === "data-driven" || c["property-type"] === "cross-faded-data-driven";
      }
      function Cp(c) {
        return !!c.expression && c.expression.parameters.indexOf("zoom") > -1;
      }
      function yr(c) {
        return !!c.expression && c.expression.interpolated;
      }
      function Dr(c) {
        return c instanceof Number ? "number" : c instanceof String ? "string" : c instanceof Boolean ? "boolean" : Array.isArray(c) ? "array" : c === null ? "null" : typeof c;
      }
      function sn(c) {
        return typeof c == "object" && c !== null && !Array.isArray(c);
      }
      function vn(c) {
        return c;
      }
      function ac(c, o) {
        const u = o.type === "color", d = c.stops && typeof c.stops[0][0] == "object", y = d || !(d || c.property !== void 0), x = c.type || (yr(o) ? "exponential" : "interval");
        if (u || o.type === "padding") {
          const R = u ? K.parse : ce.parse;
          (c = Wr({}, c)).stops && (c.stops = c.stops.map((N) => [N[0], R(N[1])])), c.default = R(c.default ? c.default : o.default);
        }
        if (c.colorSpace && c.colorSpace !== "rgb" && !bp[c.colorSpace])
          throw new Error(`Unknown color space: ${c.colorSpace}`);
        let w, C, I;
        if (x === "exponential")
          w = Ip;
        else if (x === "interval")
          w = o_;
        else if (x === "categorical") {
          w = i_, C = /* @__PURE__ */ Object.create(null);
          for (const R of c.stops)
            C[R[0]] = R[1];
          I = typeof c.stops[0][0];
        } else {
          if (x !== "identity")
            throw new Error(`Unknown function type "${x}"`);
          w = a_;
        }
        if (d) {
          const R = {}, N = [];
          for (let W = 0; W < c.stops.length; W++) {
            const X = c.stops[W], se = X[0].zoom;
            R[se] === void 0 && (R[se] = { zoom: se, type: c.type, property: c.property, default: c.default, stops: [] }, N.push(se)), R[se].stops.push([X[0].value, X[1]]);
          }
          const z = [];
          for (const W of N)
            z.push([R[W].zoom, ac(R[W], o)]);
          const V = { name: "linear" };
          return { kind: "composite", interpolationType: V, interpolationFactor: Qi.interpolationFactor.bind(void 0, V), zoomStops: z.map((W) => W[0]), evaluate: ({ zoom: W }, X) => Ip({ stops: z, base: c.base }, o, W).evaluate(W, X) };
        }
        if (y) {
          const R = x === "exponential" ? { name: "exponential", base: c.base !== void 0 ? c.base : 1 } : null;
          return { kind: "camera", interpolationType: R, interpolationFactor: Qi.interpolationFactor.bind(void 0, R), zoomStops: c.stops.map((N) => N[0]), evaluate: ({ zoom: N }) => w(c, o, N, C, I) };
        }
        return { kind: "source", evaluate(R, N) {
          const z = N && N.properties ? N.properties[c.property] : void 0;
          return z === void 0 ? rl(c.default, o.default) : w(c, o, z, C, I);
        } };
      }
      function rl(c, o, u) {
        return c !== void 0 ? c : o !== void 0 ? o : u !== void 0 ? u : void 0;
      }
      function i_(c, o, u, d, y) {
        return rl(typeof u === y ? d[u] : void 0, c.default, o.default);
      }
      function o_(c, o, u) {
        if (Dr(u) !== "number")
          return rl(c.default, o.default);
        const d = c.stops.length;
        if (d === 1 || u <= c.stops[0][0])
          return c.stops[0][1];
        if (u >= c.stops[d - 1][0])
          return c.stops[d - 1][1];
        const y = bu(c.stops.map((x) => x[0]), u);
        return c.stops[y][1];
      }
      function Ip(c, o, u) {
        const d = c.base !== void 0 ? c.base : 1;
        if (Dr(u) !== "number")
          return rl(c.default, o.default);
        const y = c.stops.length;
        if (y === 1 || u <= c.stops[0][0])
          return c.stops[0][1];
        if (u >= c.stops[y - 1][0])
          return c.stops[y - 1][1];
        const x = bu(c.stops.map((N) => N[0]), u), w = function(N, z, V, W) {
          const X = W - V, se = N - V;
          return X === 0 ? 0 : z === 1 ? se / X : (Math.pow(z, se) - 1) / (Math.pow(z, X) - 1);
        }(u, d, c.stops[x][0], c.stops[x + 1][0]), C = c.stops[x][1], I = c.stops[x + 1][1];
        let R = nc[o.type] || vn;
        if (c.colorSpace && c.colorSpace !== "rgb") {
          const N = bp[c.colorSpace];
          R = (z, V) => N.reverse(N.interpolate(N.forward(z), N.forward(V), w));
        }
        return typeof C.evaluate == "function" ? { evaluate(...N) {
          const z = C.evaluate.apply(void 0, N), V = I.evaluate.apply(void 0, N);
          if (z !== void 0 && V !== void 0)
            return R(z, V, w);
        } } : R(C, I, w);
      }
      function a_(c, o, u) {
        switch (o.type) {
          case "color":
            u = K.parse(u);
            break;
          case "formatted":
            u = fe.fromString(u.toString());
            break;
          case "resolvedImage":
            u = ge.fromString(u.toString());
            break;
          case "padding":
            u = ce.parse(u);
            break;
          default:
            Dr(u) === o.type || o.type === "enum" && o.values[u] || (u = void 0);
        }
        return rl(u, c.default, o.default);
      }
      jr.register(el, { error: [{ kind: "error" }, [Kt], (c, [o]) => {
        throw new lt(o.evaluate(c));
      }], typeof: [Kt, [Lt], (c, [o]) => Rr(ue(o.evaluate(c)))], "to-rgba": [ni(nt, 4), [Kn], (c, [o]) => o.evaluate(c).toArray()], rgb: [Kn, [nt, nt, nt], Tp], rgba: [Kn, [nt, nt, nt, nt], Tp], has: { type: Gt, overloads: [[[Kt], (c, [o]) => Sp(o.evaluate(c), c.properties())], [[Kt, qo], (c, [o, u]) => Sp(o.evaluate(c), u.evaluate(c))]] }, get: { type: Lt, overloads: [[[Kt], (c, [o]) => Iu(o.evaluate(c), c.properties())], [[Kt, qo], (c, [o, u]) => Iu(o.evaluate(c), u.evaluate(c))]] }, "feature-state": [Lt, [Kt], (c, [o]) => Iu(o.evaluate(c), c.featureState || {})], properties: [qo, [], (c) => c.properties()], "geometry-type": [Kt, [], (c) => c.geometryType()], id: [Lt, [], (c) => c.id()], zoom: [nt, [], (c) => c.globals.zoom], "heatmap-density": [nt, [], (c) => c.globals.heatmapDensity || 0], "line-progress": [nt, [], (c) => c.globals.lineProgress || 0], accumulated: [Lt, [], (c) => c.globals.accumulated === void 0 ? null : c.globals.accumulated], "+": [nt, ms(nt), (c, o) => {
        let u = 0;
        for (const d of o)
          u += d.evaluate(c);
        return u;
      }], "*": [nt, ms(nt), (c, o) => {
        let u = 1;
        for (const d of o)
          u *= d.evaluate(c);
        return u;
      }], "-": { type: nt, overloads: [[[nt, nt], (c, [o, u]) => o.evaluate(c) - u.evaluate(c)], [[nt], (c, [o]) => -o.evaluate(c)]] }, "/": [nt, [nt, nt], (c, [o, u]) => o.evaluate(c) / u.evaluate(c)], "%": [nt, [nt, nt], (c, [o, u]) => o.evaluate(c) % u.evaluate(c)], ln2: [nt, [], () => Math.LN2], pi: [nt, [], () => Math.PI], e: [nt, [], () => Math.E], "^": [nt, [nt, nt], (c, [o, u]) => Math.pow(o.evaluate(c), u.evaluate(c))], sqrt: [nt, [nt], (c, [o]) => Math.sqrt(o.evaluate(c))], log10: [nt, [nt], (c, [o]) => Math.log(o.evaluate(c)) / Math.LN10], ln: [nt, [nt], (c, [o]) => Math.log(o.evaluate(c))], log2: [nt, [nt], (c, [o]) => Math.log(o.evaluate(c)) / Math.LN2], sin: [nt, [nt], (c, [o]) => Math.sin(o.evaluate(c))], cos: [nt, [nt], (c, [o]) => Math.cos(o.evaluate(c))], tan: [nt, [nt], (c, [o]) => Math.tan(o.evaluate(c))], asin: [nt, [nt], (c, [o]) => Math.asin(o.evaluate(c))], acos: [nt, [nt], (c, [o]) => Math.acos(o.evaluate(c))], atan: [nt, [nt], (c, [o]) => Math.atan(o.evaluate(c))], min: [nt, ms(nt), (c, o) => Math.min(...o.map((u) => u.evaluate(c)))], max: [nt, ms(nt), (c, o) => Math.max(...o.map((u) => u.evaluate(c)))], abs: [nt, [nt], (c, [o]) => Math.abs(o.evaluate(c))], round: [nt, [nt], (c, [o]) => {
        const u = o.evaluate(c);
        return u < 0 ? -Math.round(-u) : Math.round(u);
      }], floor: [nt, [nt], (c, [o]) => Math.floor(o.evaluate(c))], ceil: [nt, [nt], (c, [o]) => Math.ceil(o.evaluate(c))], "filter-==": [Gt, [Kt, Lt], (c, [o, u]) => c.properties()[o.value] === u.value], "filter-id-==": [Gt, [Lt], (c, [o]) => c.id() === o.value], "filter-type-==": [Gt, [Kt], (c, [o]) => c.geometryType() === o.value], "filter-<": [Gt, [Kt, Lt], (c, [o, u]) => {
        const d = c.properties()[o.value], y = u.value;
        return typeof d == typeof y && d < y;
      }], "filter-id-<": [Gt, [Lt], (c, [o]) => {
        const u = c.id(), d = o.value;
        return typeof u == typeof d && u < d;
      }], "filter->": [Gt, [Kt, Lt], (c, [o, u]) => {
        const d = c.properties()[o.value], y = u.value;
        return typeof d == typeof y && d > y;
      }], "filter-id->": [Gt, [Lt], (c, [o]) => {
        const u = c.id(), d = o.value;
        return typeof u == typeof d && u > d;
      }], "filter-<=": [Gt, [Kt, Lt], (c, [o, u]) => {
        const d = c.properties()[o.value], y = u.value;
        return typeof d == typeof y && d <= y;
      }], "filter-id-<=": [Gt, [Lt], (c, [o]) => {
        const u = c.id(), d = o.value;
        return typeof u == typeof d && u <= d;
      }], "filter->=": [Gt, [Kt, Lt], (c, [o, u]) => {
        const d = c.properties()[o.value], y = u.value;
        return typeof d == typeof y && d >= y;
      }], "filter-id->=": [Gt, [Lt], (c, [o]) => {
        const u = c.id(), d = o.value;
        return typeof u == typeof d && u >= d;
      }], "filter-has": [Gt, [Lt], (c, [o]) => o.value in c.properties()], "filter-has-id": [Gt, [], (c) => c.id() !== null && c.id() !== void 0], "filter-type-in": [Gt, [ni(Kt)], (c, [o]) => o.value.indexOf(c.geometryType()) >= 0], "filter-id-in": [Gt, [ni(Lt)], (c, [o]) => o.value.indexOf(c.id()) >= 0], "filter-in-small": [Gt, [Kt, ni(Lt)], (c, [o, u]) => u.value.indexOf(c.properties()[o.value]) >= 0], "filter-in-large": [Gt, [Kt, ni(Lt)], (c, [o, u]) => function(d, y, x, w) {
        for (; x <= w; ) {
          const C = x + w >> 1;
          if (y[C] === d)
            return !0;
          y[C] > d ? w = C - 1 : x = C + 1;
        }
        return !1;
      }(c.properties()[o.value], u.value, 0, u.value.length - 1)], all: { type: Gt, overloads: [[[Gt, Gt], (c, [o, u]) => o.evaluate(c) && u.evaluate(c)], [ms(Gt), (c, o) => {
        for (const u of o)
          if (!u.evaluate(c))
            return !1;
        return !0;
      }]] }, any: { type: Gt, overloads: [[[Gt, Gt], (c, [o, u]) => o.evaluate(c) || u.evaluate(c)], [ms(Gt), (c, o) => {
        for (const u of o)
          if (u.evaluate(c))
            return !0;
        return !1;
      }]] }, "!": [Gt, [Gt], (c, [o]) => !o.evaluate(c)], "is-supported-script": [Gt, [Kt], (c, [o]) => {
        const u = c.globals && c.globals.isSupportedScript;
        return !u || u(o.evaluate(c));
      }], upcase: [Kt, [Kt], (c, [o]) => o.evaluate(c).toUpperCase()], downcase: [Kt, [Kt], (c, [o]) => o.evaluate(c).toLowerCase()], concat: [Kt, ms(Lt), (c, o) => o.map((u) => Ne(u.evaluate(c))).join("")], "resolved-locale": [Kt, [vi], (c, [o]) => o.evaluate(c).resolvedLocale()] });
      class Pu {
        constructor(o, u) {
          this.expression = o, this._warningHistory = {}, this._evaluator = new gr(), this._defaultValue = u ? function(d) {
            return d.type === "color" && sn(d.default) ? new K(0, 0, 0, 0) : d.type === "color" ? K.parse(d.default) || null : d.type === "padding" ? ce.parse(d.default) || null : d.default === void 0 ? null : d.default;
          }(u) : null, this._enumValues = u && u.type === "enum" ? u.values : null;
        }
        evaluateWithoutErrorHandling(o, u, d, y, x, w) {
          return this._evaluator.globals = o, this._evaluator.feature = u, this._evaluator.featureState = d, this._evaluator.canonical = y, this._evaluator.availableImages = x || null, this._evaluator.formattedSection = w, this.expression.evaluate(this._evaluator);
        }
        evaluate(o, u, d, y, x, w) {
          this._evaluator.globals = o, this._evaluator.feature = u || null, this._evaluator.featureState = d || null, this._evaluator.canonical = y, this._evaluator.availableImages = x || null, this._evaluator.formattedSection = w || null;
          try {
            const C = this.expression.evaluate(this._evaluator);
            if (C == null || typeof C == "number" && C != C)
              return this._defaultValue;
            if (this._enumValues && !(C in this._enumValues))
              throw new lt(`Expected value to be one of ${Object.keys(this._enumValues).map((I) => JSON.stringify(I)).join(", ")}, but found ${JSON.stringify(C)} instead.`);
            return C;
          } catch (C) {
            return this._warningHistory[C.message] || (this._warningHistory[C.message] = !0, typeof console < "u" && console.warn(C.message)), this._defaultValue;
          }
        }
      }
      function sc(c) {
        return Array.isArray(c) && c.length > 0 && typeof c[0] == "string" && c[0] in el;
      }
      function lc(c, o) {
        const u = new Js(el, [], o ? function(y) {
          const x = { color: Kn, string: Kt, number: nt, enum: Kt, boolean: Gt, formatted: Vn, padding: sa, resolvedImage: Tn };
          return y.type === "array" ? ni(x[y.value] || Lt, y.length) : x[y.type];
        }(o) : void 0), d = u.parse(c, void 0, void 0, void 0, o && o.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return d ? Mp(new Pu(d, o)) : tl(u.errors);
      }
      class cc {
        constructor(o, u) {
          this.kind = o, this._styleExpression = u, this.isStateDependent = o !== "constant" && !Ys(u.expression);
        }
        evaluateWithoutErrorHandling(o, u, d, y, x, w) {
          return this._styleExpression.evaluateWithoutErrorHandling(o, u, d, y, x, w);
        }
        evaluate(o, u, d, y, x, w) {
          return this._styleExpression.evaluate(o, u, d, y, x, w);
        }
      }
      class df {
        constructor(o, u, d, y) {
          this.kind = o, this.zoomStops = d, this._styleExpression = u, this.isStateDependent = o !== "camera" && !Ys(u.expression), this.interpolationType = y;
        }
        evaluateWithoutErrorHandling(o, u, d, y, x, w) {
          return this._styleExpression.evaluateWithoutErrorHandling(o, u, d, y, x, w);
        }
        evaluate(o, u, d, y, x, w) {
          return this._styleExpression.evaluate(o, u, d, y, x, w);
        }
        interpolationFactor(o, u, d) {
          return this.interpolationType ? Qi.interpolationFactor(this.interpolationType, o, u, d) : 0;
        }
      }
      function Pp(c, o) {
        const u = lc(c, o);
        if (u.result === "error")
          return u;
        const d = u.value.expression, y = tc(d);
        if (!y && !hn(o))
          return tl([new Br("", "data expressions not supported")]);
        const x = vu(d, ["zoom"]);
        if (!x && !Cp(o))
          return tl([new Br("", "zoom expressions not supported")]);
        const w = Ou(d);
        return w || x ? w instanceof Br ? tl([w]) : w instanceof Qi && !yr(o) ? tl([new Br("", '"interpolate" expressions cannot be used with this property')]) : Mp(w ? new df(y ? "camera" : "composite", u.value, w.labels, w instanceof Qi ? w.interpolation : void 0) : new cc(y ? "constant" : "source", u.value)) : tl([new Br("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class Au {
        constructor(o, u) {
          this._parameters = o, this._specification = u, Wr(this, ac(this._parameters, this._specification));
        }
        static deserialize(o) {
          return new Au(o._parameters, o._specification);
        }
        static serialize(o) {
          return { _parameters: o._parameters, _specification: o._specification };
        }
      }
      function Ou(c) {
        let o = null;
        if (c instanceof Tu)
          o = Ou(c.result);
        else if (c instanceof Eu) {
          for (const u of c.args)
            if (o = Ou(u), o)
              break;
        } else
          (c instanceof rc || c instanceof Qi) && c.input instanceof jr && c.input.name === "zoom" && (o = c);
        return o instanceof Br || c.eachChild((u) => {
          const d = Ou(u);
          d instanceof Br ? o = d : !o && d ? o = new Br("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : o && d && o !== d && (o = new Br("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), o;
      }
      function Ro(c) {
        const o = c.key, u = c.value, d = c.valueSpec || {}, y = c.objectElementValidators || {}, x = c.style, w = c.styleSpec;
        let C = [];
        const I = Dr(u);
        if (I !== "object")
          return [new We(o, u, `object expected, ${I} found`)];
        for (const R in u) {
          const N = R.split(".")[0], z = d[N] || d["*"];
          let V;
          if (y[N])
            V = y[N];
          else if (d[N])
            V = to;
          else if (y["*"])
            V = y["*"];
          else {
            if (!d["*"]) {
              C.push(new We(o, u[R], `unknown property "${R}"`));
              continue;
            }
            V = to;
          }
          C = C.concat(V({ key: (o && `${o}.`) + R, value: u[R], valueSpec: z, style: x, styleSpec: w, object: u, objectKey: R }, u));
        }
        for (const R in d)
          y[R] || d[R].required && d[R].default === void 0 && u[R] === void 0 && C.push(new We(o, u, `missing required property "${R}"`));
        return C;
      }
      function Ap(c) {
        const o = c.value, u = c.valueSpec, d = c.style, y = c.styleSpec, x = c.key, w = c.arrayElementValidator || to;
        if (Dr(o) !== "array")
          return [new We(x, o, `array expected, ${Dr(o)} found`)];
        if (u.length && o.length !== u.length)
          return [new We(x, o, `array length ${u.length} expected, length ${o.length} found`)];
        if (u["min-length"] && o.length < u["min-length"])
          return [new We(x, o, `array length at least ${u["min-length"]} expected, length ${o.length} found`)];
        let C = { type: u.value, values: u.values };
        y.$version < 7 && (C.function = u.function), Dr(u.value) === "object" && (C = u.value);
        let I = [];
        for (let R = 0; R < o.length; R++)
          I = I.concat(w({ array: o, arrayIndex: R, value: o[R], valueSpec: C, style: d, styleSpec: y, key: `${x}[${R}]` }));
        return I;
      }
      function pf(c) {
        const o = c.key, u = c.value, d = c.valueSpec;
        let y = Dr(u);
        return y === "number" && u != u && (y = "NaN"), y !== "number" ? [new We(o, u, `number expected, ${y} found`)] : "minimum" in d && u < d.minimum ? [new We(o, u, `${u} is less than the minimum value ${d.minimum}`)] : "maximum" in d && u > d.maximum ? [new We(o, u, `${u} is greater than the maximum value ${d.maximum}`)] : [];
      }
      function Op(c) {
        const o = c.valueSpec, u = Xt(c.value.type);
        let d, y, x, w = {};
        const C = u !== "categorical" && c.value.property === void 0, I = !C, R = Dr(c.value.stops) === "array" && Dr(c.value.stops[0]) === "array" && Dr(c.value.stops[0][0]) === "object", N = Ro({ key: c.key, value: c.value, valueSpec: c.styleSpec.function, style: c.style, styleSpec: c.styleSpec, objectElementValidators: { stops: function(W) {
          if (u === "identity")
            return [new We(W.key, W.value, 'identity function may not have a "stops" property')];
          let X = [];
          const se = W.value;
          return X = X.concat(Ap({ key: W.key, value: se, valueSpec: W.valueSpec, style: W.style, styleSpec: W.styleSpec, arrayElementValidator: z })), Dr(se) === "array" && se.length === 0 && X.push(new We(W.key, se, "array must have at least one stop")), X;
        }, default: function(W) {
          return to({ key: W.key, value: W.value, valueSpec: o, style: W.style, styleSpec: W.styleSpec });
        } } });
        return u === "identity" && C && N.push(new We(c.key, c.value, 'missing required property "property"')), u === "identity" || c.value.stops || N.push(new We(c.key, c.value, 'missing required property "stops"')), u === "exponential" && c.valueSpec.expression && !yr(c.valueSpec) && N.push(new We(c.key, c.value, "exponential functions not supported")), c.styleSpec.$version >= 8 && (I && !hn(c.valueSpec) ? N.push(new We(c.key, c.value, "property functions not supported")) : C && !Cp(c.valueSpec) && N.push(new We(c.key, c.value, "zoom functions not supported"))), u !== "categorical" && !R || c.value.property !== void 0 || N.push(new We(c.key, c.value, '"property" property is required')), N;
        function z(W) {
          let X = [];
          const se = W.value, ae = W.key;
          if (Dr(se) !== "array")
            return [new We(ae, se, `array expected, ${Dr(se)} found`)];
          if (se.length !== 2)
            return [new We(ae, se, `array length 2 expected, length ${se.length} found`)];
          if (R) {
            if (Dr(se[0]) !== "object")
              return [new We(ae, se, `object expected, ${Dr(se[0])} found`)];
            if (se[0].zoom === void 0)
              return [new We(ae, se, "object stop key must have zoom")];
            if (se[0].value === void 0)
              return [new We(ae, se, "object stop key must have value")];
            if (x && x > Xt(se[0].zoom))
              return [new We(ae, se[0].zoom, "stop zoom values must appear in ascending order")];
            Xt(se[0].zoom) !== x && (x = Xt(se[0].zoom), y = void 0, w = {}), X = X.concat(Ro({ key: `${ae}[0]`, value: se[0], valueSpec: { zoom: {} }, style: W.style, styleSpec: W.styleSpec, objectElementValidators: { zoom: pf, value: V } }));
          } else
            X = X.concat(V({ key: `${ae}[0]`, value: se[0], valueSpec: {}, style: W.style, styleSpec: W.styleSpec }, se));
          return sc(gn(se[1])) ? X.concat([new We(`${ae}[1]`, se[1], "expressions are not allowed in function stops.")]) : X.concat(to({ key: `${ae}[1]`, value: se[1], valueSpec: o, style: W.style, styleSpec: W.styleSpec }));
        }
        function V(W, X) {
          const se = Dr(W.value), ae = Xt(W.value), Ee = W.value !== null ? W.value : X;
          if (d) {
            if (se !== d)
              return [new We(W.key, Ee, `${se} stop domain type must match previous stop domain type ${d}`)];
          } else
            d = se;
          if (se !== "number" && se !== "string" && se !== "boolean")
            return [new We(W.key, Ee, "stop domain value must be a number, string, or boolean")];
          if (se !== "number" && u !== "categorical") {
            let De = `number expected, ${se} found`;
            return hn(o) && u === void 0 && (De += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new We(W.key, Ee, De)];
          }
          return u !== "categorical" || se !== "number" || isFinite(ae) && Math.floor(ae) === ae ? u !== "categorical" && se === "number" && y !== void 0 && ae < y ? [new We(W.key, Ee, "stop domain values must appear in ascending order")] : (y = ae, u === "categorical" && ae in w ? [new We(W.key, Ee, "stop domain values must be unique")] : (w[ae] = !0, [])) : [new We(W.key, Ee, `integer expected, found ${ae}`)];
        }
      }
      function gs(c) {
        const o = (c.expressionContext === "property" ? Pp : lc)(gn(c.value), c.valueSpec);
        if (o.result === "error")
          return o.value.map((d) => new We(`${c.key}${d.key}`, c.value, d.message));
        const u = o.value.expression || o.value._styleExpression.expression;
        if (c.expressionContext === "property" && c.propertyKey === "text-font" && !u.outputDefined())
          return [new We(c.key, c.value, `Invalid data expression for "${c.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (c.expressionContext === "property" && c.propertyType === "layout" && !Ys(u))
          return [new We(c.key, c.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (c.expressionContext === "filter" && !Ys(u))
          return [new We(c.key, c.value, '"feature-state" data expressions are not supported with filters.')];
        if (c.expressionContext && c.expressionContext.indexOf("cluster") === 0) {
          if (!vu(u, ["zoom", "feature-state"]))
            return [new We(c.key, c.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (c.expressionContext === "cluster-initial" && !tc(u))
            return [new We(c.key, c.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function uc(c) {
        const o = c.key, u = c.value, d = c.valueSpec, y = [];
        return Array.isArray(d.values) ? d.values.indexOf(Xt(u)) === -1 && y.push(new We(o, u, `expected one of [${d.values.join(", ")}], ${JSON.stringify(u)} found`)) : Object.keys(d.values).indexOf(Xt(u)) === -1 && y.push(new We(o, u, `expected one of [${Object.keys(d.values).join(", ")}], ${JSON.stringify(u)} found`)), y;
      }
      function nl(c) {
        if (c === !0 || c === !1)
          return !0;
        if (!Array.isArray(c) || c.length === 0)
          return !1;
        switch (c[0]) {
          case "has":
            return c.length >= 2 && c[1] !== "$id" && c[1] !== "$type";
          case "in":
            return c.length >= 3 && (typeof c[1] != "string" || Array.isArray(c[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return c.length !== 3 || Array.isArray(c[1]) || Array.isArray(c[2]);
          case "any":
          case "all":
            for (const o of c.slice(1))
              if (!nl(o) && typeof o != "boolean")
                return !1;
            return !0;
          default:
            return !0;
        }
      }
      const s_ = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function Ru(c) {
        if (c == null)
          return { filter: () => !0, needGeometry: !1 };
        nl(c) || (c = hc(c));
        const o = lc(c, s_);
        if (o.result === "error")
          throw new Error(o.value.map((u) => `${u.key}: ${u.message}`).join(", "));
        return { filter: (u, d, y) => o.value.evaluate(u, d, {}, y), needGeometry: Lp(c) };
      }
      function Rp(c, o) {
        return c < o ? -1 : c > o ? 1 : 0;
      }
      function Lp(c) {
        if (!Array.isArray(c))
          return !1;
        if (c[0] === "within")
          return !0;
        for (let o = 1; o < c.length; o++)
          if (Lp(c[o]))
            return !0;
        return !1;
      }
      function hc(c) {
        if (!c)
          return !0;
        const o = c[0];
        return c.length <= 1 ? o !== "any" : o === "==" ? mf(c[1], c[2], "==") : o === "!=" ? il(mf(c[1], c[2], "==")) : o === "<" || o === ">" || o === "<=" || o === ">=" ? mf(c[1], c[2], o) : o === "any" ? (u = c.slice(1), ["any"].concat(u.map(hc))) : o === "all" ? ["all"].concat(c.slice(1).map(hc)) : o === "none" ? ["all"].concat(c.slice(1).map(hc).map(il)) : o === "in" ? Lu(c[1], c.slice(2)) : o === "!in" ? il(Lu(c[1], c.slice(2))) : o === "has" ? fc(c[1]) : o === "!has" ? il(fc(c[1])) : o !== "within" || c;
        var u;
      }
      function mf(c, o, u) {
        switch (c) {
          case "$type":
            return [`filter-type-${u}`, o];
          case "$id":
            return [`filter-id-${u}`, o];
          default:
            return [`filter-${u}`, c, o];
        }
      }
      function Lu(c, o) {
        if (o.length === 0)
          return !1;
        switch (c) {
          case "$type":
            return ["filter-type-in", ["literal", o]];
          case "$id":
            return ["filter-id-in", ["literal", o]];
          default:
            return o.length > 200 && !o.some((u) => typeof u != typeof o[0]) ? ["filter-in-large", c, ["literal", o.sort(Rp)]] : ["filter-in-small", c, ["literal", o]];
        }
      }
      function fc(c) {
        switch (c) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", c];
        }
      }
      function il(c) {
        return ["!", c];
      }
      function dc(c) {
        return nl(gn(c.value)) ? gs(Wr({}, c, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Dp(c);
      }
      function Dp(c) {
        const o = c.value, u = c.key;
        if (Dr(o) !== "array")
          return [new We(u, o, `array expected, ${Dr(o)} found`)];
        const d = c.styleSpec;
        let y, x = [];
        if (o.length < 1)
          return [new We(u, o, "filter array must have at least 1 element")];
        switch (x = x.concat(uc({ key: `${u}[0]`, value: o[0], valueSpec: d.filter_operator, style: c.style, styleSpec: c.styleSpec })), Xt(o[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            o.length >= 2 && Xt(o[1]) === "$type" && x.push(new We(u, o, `"$type" cannot be use with operator "${o[0]}"`));
          case "==":
          case "!=":
            o.length !== 3 && x.push(new We(u, o, `filter array for operator "${o[0]}" must have 3 elements`));
          case "in":
          case "!in":
            o.length >= 2 && (y = Dr(o[1]), y !== "string" && x.push(new We(`${u}[1]`, o[1], `string expected, ${y} found`)));
            for (let w = 2; w < o.length; w++)
              y = Dr(o[w]), Xt(o[1]) === "$type" ? x = x.concat(uc({ key: `${u}[${w}]`, value: o[w], valueSpec: d.geometry_type, style: c.style, styleSpec: c.styleSpec })) : y !== "string" && y !== "number" && y !== "boolean" && x.push(new We(`${u}[${w}]`, o[w], `string, number, or boolean expected, ${y} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let w = 1; w < o.length; w++)
              x = x.concat(Dp({ key: `${u}[${w}]`, value: o[w], style: c.style, styleSpec: c.styleSpec }));
            break;
          case "has":
          case "!has":
            y = Dr(o[1]), o.length !== 2 ? x.push(new We(u, o, `filter array for "${o[0]}" operator must have 2 elements`)) : y !== "string" && x.push(new We(`${u}[1]`, o[1], `string expected, ${y} found`));
            break;
          case "within":
            y = Dr(o[1]), o.length !== 2 ? x.push(new We(u, o, `filter array for "${o[0]}" operator must have 2 elements`)) : y !== "object" && x.push(new We(`${u}[1]`, o[1], `object expected, ${y} found`));
        }
        return x;
      }
      function pc(c, o) {
        const u = c.key, d = c.style, y = c.styleSpec, x = c.value, w = c.objectKey, C = y[`${o}_${c.layerType}`];
        if (!C)
          return [];
        const I = w.match(/^(.*)-transition$/);
        if (o === "paint" && I && C[I[1]] && C[I[1]].transition)
          return to({ key: u, value: x, valueSpec: y.transition, style: d, styleSpec: y });
        const R = c.valueSpec || C[w];
        if (!R)
          return [new We(u, x, `unknown property "${w}"`)];
        let N;
        if (Dr(x) === "string" && hn(R) && !R.tokens && (N = /^{([^}]+)}$/.exec(x)))
          return [new We(u, x, `"${w}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(N[1])} }\`.`)];
        const z = [];
        return c.layerType === "symbol" && (w === "text-field" && d && !d.glyphs && z.push(new We(u, x, 'use of "text-field" requires a style "glyphs" property')), w === "text-font" && sn(gn(x)) && Xt(x.type) === "identity" && z.push(new We(u, x, '"text-font" does not support identity functions'))), z.concat(to({ key: c.key, value: x, valueSpec: R, style: d, styleSpec: y, expressionContext: "property", propertyType: o, propertyKey: w }));
      }
      function kp(c) {
        return pc(c, "paint");
      }
      function Np(c) {
        return pc(c, "layout");
      }
      function Fp(c) {
        let o = [];
        const u = c.value, d = c.key, y = c.style, x = c.styleSpec;
        u.type || u.ref || o.push(new We(d, u, 'either "type" or "ref" is required'));
        let w = Xt(u.type);
        const C = Xt(u.ref);
        if (u.id) {
          const I = Xt(u.id);
          for (let R = 0; R < c.arrayIndex; R++) {
            const N = y.layers[R];
            Xt(N.id) === I && o.push(new We(d, u.id, `duplicate layer id "${u.id}", previously used at line ${N.id.__line__}`));
          }
        }
        if ("ref" in u) {
          let I;
          ["type", "source", "source-layer", "filter", "layout"].forEach((R) => {
            R in u && o.push(new We(d, u[R], `"${R}" is prohibited for ref layers`));
          }), y.layers.forEach((R) => {
            Xt(R.id) === C && (I = R);
          }), I ? I.ref ? o.push(new We(d, u.ref, "ref cannot reference another ref layer")) : w = Xt(I.type) : o.push(new We(d, u.ref, `ref layer "${C}" not found`));
        } else if (w !== "background")
          if (u.source) {
            const I = y.sources && y.sources[u.source], R = I && Xt(I.type);
            I ? R === "vector" && w === "raster" ? o.push(new We(d, u.source, `layer "${u.id}" requires a raster source`)) : R === "raster" && w !== "raster" ? o.push(new We(d, u.source, `layer "${u.id}" requires a vector source`)) : R !== "vector" || u["source-layer"] ? R === "raster-dem" && w !== "hillshade" ? o.push(new We(d, u.source, "raster-dem source can only be used with layer type 'hillshade'.")) : w !== "line" || !u.paint || !u.paint["line-gradient"] || R === "geojson" && I.lineMetrics || o.push(new We(d, u, `layer "${u.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : o.push(new We(d, u, `layer "${u.id}" must specify a "source-layer"`)) : o.push(new We(d, u.source, `source "${u.source}" not found`));
          } else
            o.push(new We(d, u, 'missing required property "source"'));
        return o = o.concat(Ro({ key: d, value: u, valueSpec: x.layer, style: c.style, styleSpec: c.styleSpec, objectElementValidators: { "*": () => [], type: () => to({ key: `${d}.type`, value: u.type, valueSpec: x.layer.type, style: c.style, styleSpec: c.styleSpec, object: u, objectKey: "type" }), filter: dc, layout: (I) => Ro({ layer: u, key: I.key, value: I.value, style: I.style, styleSpec: I.styleSpec, objectElementValidators: { "*": (R) => Np(Wr({ layerType: w }, R)) } }), paint: (I) => Ro({ layer: u, key: I.key, value: I.value, style: I.style, styleSpec: I.styleSpec, objectElementValidators: { "*": (R) => kp(Wr({ layerType: w }, R)) } }) } })), o;
      }
      function ol(c) {
        const o = c.value, u = c.key, d = Dr(o);
        return d !== "string" ? [new We(u, o, `string expected, ${d} found`)] : [];
      }
      const zp = { promoteId: function({ key: c, value: o }) {
        if (Dr(o) === "string")
          return ol({ key: c, value: o });
        {
          const u = [];
          for (const d in o)
            u.push(...ol({ key: `${c}.${d}`, value: o[d] }));
          return u;
        }
      } };
      function mc(c) {
        const o = c.value, u = c.key, d = c.styleSpec, y = c.style;
        if (!o.type)
          return [new We(u, o, '"type" is required')];
        const x = Xt(o.type);
        let w;
        switch (x) {
          case "vector":
          case "raster":
          case "raster-dem":
            return w = Ro({ key: u, value: o, valueSpec: d[`source_${x.replace("-", "_")}`], style: c.style, styleSpec: d, objectElementValidators: zp }), w;
          case "geojson":
            if (w = Ro({ key: u, value: o, valueSpec: d.source_geojson, style: y, styleSpec: d, objectElementValidators: zp }), o.cluster)
              for (const C in o.clusterProperties) {
                const [I, R] = o.clusterProperties[C], N = typeof I == "string" ? [I, ["accumulated"], ["get", C]] : I;
                w.push(...gs({ key: `${u}.${C}.map`, value: R, expressionContext: "cluster-map" })), w.push(...gs({ key: `${u}.${C}.reduce`, value: N, expressionContext: "cluster-reduce" }));
              }
            return w;
          case "video":
            return Ro({ key: u, value: o, valueSpec: d.source_video, style: y, styleSpec: d });
          case "image":
            return Ro({ key: u, value: o, valueSpec: d.source_image, style: y, styleSpec: d });
          case "canvas":
            return [new We(u, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return uc({ key: `${u}.type`, value: o.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: y, styleSpec: d });
        }
      }
      function gc(c) {
        const o = c.value, u = c.styleSpec, d = u.light, y = c.style;
        let x = [];
        const w = Dr(o);
        if (o === void 0)
          return x;
        if (w !== "object")
          return x = x.concat([new We("light", o, `object expected, ${w} found`)]), x;
        for (const C in o) {
          const I = C.match(/^(.*)-transition$/);
          x = x.concat(I && d[I[1]] && d[I[1]].transition ? to({ key: C, value: o[C], valueSpec: u.transition, style: y, styleSpec: u }) : d[C] ? to({ key: C, value: o[C], valueSpec: d[C], style: y, styleSpec: u }) : [new We(C, o[C], `unknown property "${C}"`)]);
        }
        return x;
      }
      function eo(c) {
        const o = c.value, u = c.styleSpec, d = u.terrain, y = c.style;
        let x = [];
        const w = Dr(o);
        if (o === void 0)
          return x;
        if (w !== "object")
          return x = x.concat([new We("terrain", o, `object expected, ${w} found`)]), x;
        for (const C in o)
          x = x.concat(d[C] ? to({ key: C, value: o[C], valueSpec: d[C], style: y, styleSpec: u }) : [new We(C, o[C], `unknown property "${C}"`)]);
        return x;
      }
      const yc = { "*": () => [], array: Ap, boolean: function(c) {
        const o = c.value, u = c.key, d = Dr(o);
        return d !== "boolean" ? [new We(u, o, `boolean expected, ${d} found`)] : [];
      }, number: pf, color: function(c) {
        const o = c.key, u = c.value, d = Dr(u);
        return d !== "string" ? [new We(o, u, `color expected, ${d} found`)] : xi(u) === null ? [new We(o, u, `color expected, "${u}" found`)] : [];
      }, constants: br, enum: uc, filter: dc, function: Op, layer: Fp, object: Ro, source: mc, light: gc, terrain: eo, string: ol, formatted: function(c) {
        return ol(c).length === 0 ? [] : gs(c);
      }, resolvedImage: function(c) {
        return ol(c).length === 0 ? [] : gs(c);
      }, padding: function(c) {
        const o = c.key, u = c.value;
        if (Dr(u) === "array") {
          if (u.length < 1 || u.length > 4)
            return [new We(o, u, `padding requires 1 to 4 values; ${u.length} values found`)];
          const d = { type: "number" };
          let y = [];
          for (let x = 0; x < u.length; x++)
            y = y.concat(to({ key: `${o}[${x}]`, value: u[x], valueSpec: d }));
          return y;
        }
        return pf({ key: o, value: u, valueSpec: {} });
      } };
      function to(c) {
        const o = c.value, u = c.valueSpec, d = c.styleSpec;
        return u.expression && sn(Xt(o)) ? Op(c) : u.expression && sc(gn(o)) ? gs(c) : u.type && yc[u.type] ? yc[u.type](c) : Ro(Wr({}, c, { valueSpec: u.type ? d[u.type] : u }));
      }
      function l_(c) {
        const o = c.value, u = c.key, d = ol(c);
        return d.length || (o.indexOf("{fontstack}") === -1 && d.push(new We(u, o, '"glyphs" url must include a "{fontstack}" token')), o.indexOf("{range}") === -1 && d.push(new We(u, o, '"glyphs" url must include a "{range}" token'))), d;
      }
      function Fa(c, o = Ce) {
        let u = [];
        return u = u.concat(to({ key: "", value: c, valueSpec: o.$root, styleSpec: o, style: c, objectElementValidators: { glyphs: l_, "*": () => [] } })), c.constants && (u = u.concat(br({ key: "constants", value: c.constants, style: c, styleSpec: o }))), Bp(u);
      }
      function Bp(c) {
        return [].concat(c).sort((o, u) => o.line - u.line);
      }
      function ca(c) {
        return function(...o) {
          return Bp(c.apply(this, o));
        };
      }
      Fa.source = ca(mc), Fa.light = ca(gc), Fa.terrain = ca(eo), Fa.layer = ca(Fp), Fa.filter = ca(dc), Fa.paintProperty = ca(kp), Fa.layoutProperty = ca(Np);
      const _c = Fa, gf = _c.light, c_ = _c.paintProperty, u_ = _c.layoutProperty;
      function Du(c, o) {
        let u = !1;
        if (o && o.length)
          for (const d of o)
            c.fire(new Ut(new Error(d.message))), u = !0;
        return u;
      }
      class vc {
        constructor(o, u, d) {
          const y = this.cells = [];
          if (o instanceof ArrayBuffer) {
            this.arrayBuffer = o;
            const w = new Int32Array(this.arrayBuffer);
            o = w[0], this.d = (u = w[1]) + 2 * (d = w[2]);
            for (let I = 0; I < this.d * this.d; I++) {
              const R = w[3 + I], N = w[3 + I + 1];
              y.push(R === N ? null : w.subarray(R, N));
            }
            const C = w[3 + y.length + 1];
            this.keys = w.subarray(w[3 + y.length], C), this.bboxes = w.subarray(C), this.insert = this._insertReadonly;
          } else {
            this.d = u + 2 * d;
            for (let w = 0; w < this.d * this.d; w++)
              y.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = u, this.extent = o, this.padding = d, this.scale = u / o, this.uid = 0;
          const x = d / u * o;
          this.min = -x, this.max = o + x;
        }
        insert(o, u, d, y, x) {
          this._forEachCell(u, d, y, x, this._insertCell, this.uid++, void 0, void 0), this.keys.push(o), this.bboxes.push(u), this.bboxes.push(d), this.bboxes.push(y), this.bboxes.push(x);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(o, u, d, y, x, w) {
          this.cells[x].push(w);
        }
        query(o, u, d, y, x) {
          const w = this.min, C = this.max;
          if (o <= w && u <= w && C <= d && C <= y && !x)
            return Array.prototype.slice.call(this.keys);
          {
            const I = [];
            return this._forEachCell(o, u, d, y, this._queryCell, I, {}, x), I;
          }
        }
        _queryCell(o, u, d, y, x, w, C, I) {
          const R = this.cells[x];
          if (R !== null) {
            const N = this.keys, z = this.bboxes;
            for (let V = 0; V < R.length; V++) {
              const W = R[V];
              if (C[W] === void 0) {
                const X = 4 * W;
                (I ? I(z[X + 0], z[X + 1], z[X + 2], z[X + 3]) : o <= z[X + 2] && u <= z[X + 3] && d >= z[X + 0] && y >= z[X + 1]) ? (C[W] = !0, w.push(N[W])) : C[W] = !1;
              }
            }
          }
        }
        _forEachCell(o, u, d, y, x, w, C, I) {
          const R = this._convertToCellCoord(o), N = this._convertToCellCoord(u), z = this._convertToCellCoord(d), V = this._convertToCellCoord(y);
          for (let W = R; W <= z; W++)
            for (let X = N; X <= V; X++) {
              const se = this.d * X + W;
              if ((!I || I(this._convertFromCellCoord(W), this._convertFromCellCoord(X), this._convertFromCellCoord(W + 1), this._convertFromCellCoord(X + 1))) && x.call(this, o, u, d, y, se, w, C, I))
                return;
            }
        }
        _convertFromCellCoord(o) {
          return (o - this.padding) / this.scale;
        }
        _convertToCellCoord(o) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(o * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          const o = this.cells, u = 3 + this.cells.length + 1 + 1;
          let d = 0;
          for (let w = 0; w < this.cells.length; w++)
            d += this.cells[w].length;
          const y = new Int32Array(u + d + this.keys.length + this.bboxes.length);
          y[0] = this.extent, y[1] = this.n, y[2] = this.padding;
          let x = u;
          for (let w = 0; w < o.length; w++) {
            const C = o[w];
            y[3 + w] = x, y.set(C, x), x += C.length;
          }
          return y[3 + o.length] = x, y.set(this.keys, x), x += this.keys.length, y[3 + o.length + 1] = x, y.set(this.bboxes, x), x += this.bboxes.length, y.buffer;
        }
        static serialize(o, u) {
          const d = o.toArrayBuffer();
          return u && u.push(d), { buffer: d };
        }
        static deserialize(o) {
          return new vc(o.buffer);
        }
      }
      const ua = {};
      function Ct(c, o, u = {}) {
        if (ua[c])
          throw new Error(`${c} is already registered.`);
        Object.defineProperty(o, "_classRegistryKey", { value: c, writeable: !1 }), ua[c] = { klass: o, omit: u.omit || [], shallow: u.shallow || [] };
      }
      Ct("Object", Object), Ct("TransferableGridIndex", vc), Ct("Color", K), Ct("Error", Error), Ct("AJAXError", re), Ct("ResolvedImage", ge), Ct("StylePropertyFunction", Au), Ct("StyleExpression", Pu, { omit: ["_evaluator"] }), Ct("ZoomDependentExpression", df), Ct("ZoomConstantExpression", cc), Ct("CompoundExpression", jr, { omit: ["_evaluate"] });
      for (const c in el)
        el[c]._classRegistryKey || Ct(`Expression_${c}`, el[c]);
      function Up(c) {
        return c && typeof ArrayBuffer < "u" && (c instanceof ArrayBuffer || c.constructor && c.constructor.name === "ArrayBuffer");
      }
      function ys(c, o) {
        if (c == null || typeof c == "boolean" || typeof c == "number" || typeof c == "string" || c instanceof Boolean || c instanceof Number || c instanceof String || c instanceof Date || c instanceof RegExp || c instanceof Blob)
          return c;
        if (Up(c) || xe(c))
          return o && o.push(c), c;
        if (ArrayBuffer.isView(c)) {
          const u = c;
          return o && o.push(u.buffer), u;
        }
        if (c instanceof ImageData)
          return o && o.push(c.data.buffer), c;
        if (Array.isArray(c)) {
          const u = [];
          for (const d of c)
            u.push(ys(d, o));
          return u;
        }
        if (typeof c == "object") {
          const u = c.constructor, d = u._classRegistryKey;
          if (!d)
            throw new Error("can't serialize object of unregistered class");
          if (!ua[d])
            throw new Error(`${d} is not registered.`);
          const y = u.serialize ? u.serialize(c, o) : {};
          if (u.serialize) {
            if (o && y === o[o.length - 1])
              throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const x in c) {
              if (!c.hasOwnProperty(x) || ua[d].omit.indexOf(x) >= 0)
                continue;
              const w = c[x];
              y[x] = ua[d].shallow.indexOf(x) >= 0 ? w : ys(w, o);
            }
            c instanceof Error && (y.message = c.message);
          }
          if (y.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return d !== "Object" && (y.$name = d), y;
        }
        throw new Error("can't serialize object of type " + typeof c);
      }
      function za(c) {
        if (c == null || typeof c == "boolean" || typeof c == "number" || typeof c == "string" || c instanceof Boolean || c instanceof Number || c instanceof String || c instanceof Date || c instanceof RegExp || c instanceof Blob || Up(c) || xe(c) || ArrayBuffer.isView(c) || c instanceof ImageData)
          return c;
        if (Array.isArray(c))
          return c.map(za);
        if (typeof c == "object") {
          const o = c.$name || "Object";
          if (!ua[o])
            throw new Error(`can't deserialize unregistered class ${o}`);
          const { klass: u } = ua[o];
          if (!u)
            throw new Error(`can't deserialize unregistered class ${o}`);
          if (u.deserialize)
            return u.deserialize(c);
          const d = Object.create(u.prototype);
          for (const y of Object.keys(c)) {
            if (y === "$name")
              continue;
            const x = c[y];
            d[y] = ua[o].shallow.indexOf(y) >= 0 ? x : za(x);
          }
          return d;
        }
        throw new Error("can't deserialize object of type " + typeof c);
      }
      class yf {
        constructor() {
          this.first = !0;
        }
        update(o, u) {
          const d = Math.floor(o);
          return this.first ? (this.first = !1, this.lastIntegerZoom = d, this.lastIntegerZoomTime = 0, this.lastZoom = o, this.lastFloorZoom = d, !0) : (this.lastFloorZoom > d ? (this.lastIntegerZoom = d + 1, this.lastIntegerZoomTime = u) : this.lastFloorZoom < d && (this.lastIntegerZoom = d, this.lastIntegerZoomTime = u), o !== this.lastZoom && (this.lastZoom = o, this.lastFloorZoom = d, !0));
        }
      }
      const gt = { "Latin-1 Supplement": (c) => c >= 128 && c <= 255, Arabic: (c) => c >= 1536 && c <= 1791, "Arabic Supplement": (c) => c >= 1872 && c <= 1919, "Arabic Extended-A": (c) => c >= 2208 && c <= 2303, "Hangul Jamo": (c) => c >= 4352 && c <= 4607, "Unified Canadian Aboriginal Syllabics": (c) => c >= 5120 && c <= 5759, Khmer: (c) => c >= 6016 && c <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (c) => c >= 6320 && c <= 6399, "General Punctuation": (c) => c >= 8192 && c <= 8303, "Letterlike Symbols": (c) => c >= 8448 && c <= 8527, "Number Forms": (c) => c >= 8528 && c <= 8591, "Miscellaneous Technical": (c) => c >= 8960 && c <= 9215, "Control Pictures": (c) => c >= 9216 && c <= 9279, "Optical Character Recognition": (c) => c >= 9280 && c <= 9311, "Enclosed Alphanumerics": (c) => c >= 9312 && c <= 9471, "Geometric Shapes": (c) => c >= 9632 && c <= 9727, "Miscellaneous Symbols": (c) => c >= 9728 && c <= 9983, "Miscellaneous Symbols and Arrows": (c) => c >= 11008 && c <= 11263, "CJK Radicals Supplement": (c) => c >= 11904 && c <= 12031, "Kangxi Radicals": (c) => c >= 12032 && c <= 12255, "Ideographic Description Characters": (c) => c >= 12272 && c <= 12287, "CJK Symbols and Punctuation": (c) => c >= 12288 && c <= 12351, Hiragana: (c) => c >= 12352 && c <= 12447, Katakana: (c) => c >= 12448 && c <= 12543, Bopomofo: (c) => c >= 12544 && c <= 12591, "Hangul Compatibility Jamo": (c) => c >= 12592 && c <= 12687, Kanbun: (c) => c >= 12688 && c <= 12703, "Bopomofo Extended": (c) => c >= 12704 && c <= 12735, "CJK Strokes": (c) => c >= 12736 && c <= 12783, "Katakana Phonetic Extensions": (c) => c >= 12784 && c <= 12799, "Enclosed CJK Letters and Months": (c) => c >= 12800 && c <= 13055, "CJK Compatibility": (c) => c >= 13056 && c <= 13311, "CJK Unified Ideographs Extension A": (c) => c >= 13312 && c <= 19903, "Yijing Hexagram Symbols": (c) => c >= 19904 && c <= 19967, "CJK Unified Ideographs": (c) => c >= 19968 && c <= 40959, "Yi Syllables": (c) => c >= 40960 && c <= 42127, "Yi Radicals": (c) => c >= 42128 && c <= 42191, "Hangul Jamo Extended-A": (c) => c >= 43360 && c <= 43391, "Hangul Syllables": (c) => c >= 44032 && c <= 55215, "Hangul Jamo Extended-B": (c) => c >= 55216 && c <= 55295, "Private Use Area": (c) => c >= 57344 && c <= 63743, "CJK Compatibility Ideographs": (c) => c >= 63744 && c <= 64255, "Arabic Presentation Forms-A": (c) => c >= 64336 && c <= 65023, "Vertical Forms": (c) => c >= 65040 && c <= 65055, "CJK Compatibility Forms": (c) => c >= 65072 && c <= 65103, "Small Form Variants": (c) => c >= 65104 && c <= 65135, "Arabic Presentation Forms-B": (c) => c >= 65136 && c <= 65279, "Halfwidth and Fullwidth Forms": (c) => c >= 65280 && c <= 65519 };
      function ku(c) {
        for (const o of c)
          if (vf(o.charCodeAt(0)))
            return !0;
        return !1;
      }
      function h_(c) {
        for (const o of c)
          if (!_f(o.charCodeAt(0)))
            return !1;
        return !0;
      }
      function _f(c) {
        return !(gt.Arabic(c) || gt["Arabic Supplement"](c) || gt["Arabic Extended-A"](c) || gt["Arabic Presentation Forms-A"](c) || gt["Arabic Presentation Forms-B"](c));
      }
      function vf(c) {
        return !(c !== 746 && c !== 747 && (c < 4352 || !(gt["Bopomofo Extended"](c) || gt.Bopomofo(c) || gt["CJK Compatibility Forms"](c) && !(c >= 65097 && c <= 65103) || gt["CJK Compatibility Ideographs"](c) || gt["CJK Compatibility"](c) || gt["CJK Radicals Supplement"](c) || gt["CJK Strokes"](c) || !(!gt["CJK Symbols and Punctuation"](c) || c >= 12296 && c <= 12305 || c >= 12308 && c <= 12319 || c === 12336) || gt["CJK Unified Ideographs Extension A"](c) || gt["CJK Unified Ideographs"](c) || gt["Enclosed CJK Letters and Months"](c) || gt["Hangul Compatibility Jamo"](c) || gt["Hangul Jamo Extended-A"](c) || gt["Hangul Jamo Extended-B"](c) || gt["Hangul Jamo"](c) || gt["Hangul Syllables"](c) || gt.Hiragana(c) || gt["Ideographic Description Characters"](c) || gt.Kanbun(c) || gt["Kangxi Radicals"](c) || gt["Katakana Phonetic Extensions"](c) || gt.Katakana(c) && c !== 12540 || !(!gt["Halfwidth and Fullwidth Forms"](c) || c === 65288 || c === 65289 || c === 65293 || c >= 65306 && c <= 65310 || c === 65339 || c === 65341 || c === 65343 || c >= 65371 && c <= 65503 || c === 65507 || c >= 65512 && c <= 65519) || !(!gt["Small Form Variants"](c) || c >= 65112 && c <= 65118 || c >= 65123 && c <= 65126) || gt["Unified Canadian Aboriginal Syllabics"](c) || gt["Unified Canadian Aboriginal Syllabics Extended"](c) || gt["Vertical Forms"](c) || gt["Yijing Hexagram Symbols"](c) || gt["Yi Syllables"](c) || gt["Yi Radicals"](c))));
      }
      function $p(c) {
        return !(vf(c) || function(o) {
          return !!(gt["Latin-1 Supplement"](o) && (o === 167 || o === 169 || o === 174 || o === 177 || o === 188 || o === 189 || o === 190 || o === 215 || o === 247) || gt["General Punctuation"](o) && (o === 8214 || o === 8224 || o === 8225 || o === 8240 || o === 8241 || o === 8251 || o === 8252 || o === 8258 || o === 8263 || o === 8264 || o === 8265 || o === 8273) || gt["Letterlike Symbols"](o) || gt["Number Forms"](o) || gt["Miscellaneous Technical"](o) && (o >= 8960 && o <= 8967 || o >= 8972 && o <= 8991 || o >= 8996 && o <= 9e3 || o === 9003 || o >= 9085 && o <= 9114 || o >= 9150 && o <= 9165 || o === 9167 || o >= 9169 && o <= 9179 || o >= 9186 && o <= 9215) || gt["Control Pictures"](o) && o !== 9251 || gt["Optical Character Recognition"](o) || gt["Enclosed Alphanumerics"](o) || gt["Geometric Shapes"](o) || gt["Miscellaneous Symbols"](o) && !(o >= 9754 && o <= 9759) || gt["Miscellaneous Symbols and Arrows"](o) && (o >= 11026 && o <= 11055 || o >= 11088 && o <= 11097 || o >= 11192 && o <= 11243) || gt["CJK Symbols and Punctuation"](o) || gt.Katakana(o) || gt["Private Use Area"](o) || gt["CJK Compatibility Forms"](o) || gt["Small Form Variants"](o) || gt["Halfwidth and Fullwidth Forms"](o) || o === 8734 || o === 8756 || o === 8757 || o >= 9984 && o <= 10087 || o >= 10102 && o <= 10131 || o === 65532 || o === 65533);
        }(c));
      }
      function Vp(c) {
        return c >= 1424 && c <= 2303 || gt["Arabic Presentation Forms-A"](c) || gt["Arabic Presentation Forms-B"](c);
      }
      function f_(c, o) {
        return !(!o && Vp(c) || c >= 2304 && c <= 3583 || c >= 3840 && c <= 4255 || gt.Khmer(c));
      }
      function jp(c) {
        for (const o of c)
          if (Vp(o.charCodeAt(0)))
            return !0;
        return !1;
      }
      const xf = "deferred", bf = "loading", wf = "loaded";
      let Ef = null, $i = "unavailable", Ba = null;
      const Gp = function(c) {
        c && typeof c == "string" && c.indexOf("NetworkError") > -1 && ($i = "error"), Ef && Ef(c);
      };
      function al() {
        Tf.fire(new St("pluginStateChange", { pluginStatus: $i, pluginURL: Ba }));
      }
      const Tf = new Wt(), xc = function() {
        return $i;
      }, qp = function() {
        if ($i !== xf || !Ba)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        $i = bf, al(), Ba && Ge({ url: Ba }, (c) => {
          c ? Gp(c) : ($i = wf, al());
        });
      }, yo = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => $i === wf || yo.applyArabicShaping != null, isLoading: () => $i === bf, setState(c) {
        if (!Oe())
          throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");
        $i = c.pluginStatus, Ba = c.pluginURL;
      }, isParsed() {
        if (!Oe())
          throw new Error("rtl-text-plugin is only parsed on the worker-threads");
        return yo.applyArabicShaping != null && yo.processBidirectionalText != null && yo.processStyledBidirectionalText != null;
      }, getPluginURL() {
        if (!Oe())
          throw new Error("rtl-text-plugin url can only be queried from the worker threads");
        return Ba;
      } };
      class xn {
        constructor(o, u) {
          this.zoom = o, u ? (this.now = u.now, this.fadeDuration = u.fadeDuration, this.zoomHistory = u.zoomHistory, this.transition = u.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new yf(), this.transition = {});
        }
        isSupportedScript(o) {
          return function(u, d) {
            for (const y of u)
              if (!f_(y.charCodeAt(0), d))
                return !1;
            return !0;
          }(o, yo.isLoaded());
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const o = this.zoom, u = o - Math.floor(o), d = this.crossFadingFactor();
          return o > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: u + (1 - u) * d } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - d) * u };
        }
      }
      class bc {
        constructor(o, u) {
          this.property = o, this.value = u, this.expression = function(d, y) {
            if (sn(d))
              return new Au(d, y);
            if (sc(d)) {
              const x = Pp(d, y);
              if (x.result === "error")
                throw new Error(x.value.map((w) => `${w.key}: ${w.message}`).join(", "));
              return x.value;
            }
            {
              let x = d;
              return y.type === "color" && typeof d == "string" ? x = K.parse(d) : y.type !== "padding" || typeof d != "number" && !Array.isArray(d) || (x = ce.parse(d)), { kind: "constant", evaluate: () => x };
            }
          }(u === void 0 ? o.specification.default : u, o.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(o, u, d) {
          return this.property.possiblyEvaluate(this, o, u, d);
        }
      }
      class Nu {
        constructor(o) {
          this.property = o, this.value = new bc(o, void 0);
        }
        transitioned(o, u) {
          return new Xp(this.property, this.value, u, L({}, o.transition, this.transition), o.now);
        }
        untransitioned() {
          return new Xp(this.property, this.value, null, {}, 0);
        }
      }
      class Wp {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultTransitionablePropertyValues);
        }
        getValue(o) {
          return ne(this._values[o].value.value);
        }
        setValue(o, u) {
          Object.prototype.hasOwnProperty.call(this._values, o) || (this._values[o] = new Nu(this._values[o].property)), this._values[o].value = new bc(this._values[o].property, u === null ? void 0 : ne(u));
        }
        getTransition(o) {
          return ne(this._values[o].transition);
        }
        setTransition(o, u) {
          Object.prototype.hasOwnProperty.call(this._values, o) || (this._values[o] = new Nu(this._values[o].property)), this._values[o].transition = ne(u) || void 0;
        }
        serialize() {
          const o = {};
          for (const u of Object.keys(this._values)) {
            const d = this.getValue(u);
            d !== void 0 && (o[u] = d);
            const y = this.getTransition(u);
            y !== void 0 && (o[`${u}-transition`] = y);
          }
          return o;
        }
        transitioned(o, u) {
          const d = new Zp(this._properties);
          for (const y of Object.keys(this._values))
            d._values[y] = this._values[y].transitioned(o, u._values[y]);
          return d;
        }
        untransitioned() {
          const o = new Zp(this._properties);
          for (const u of Object.keys(this._values))
            o._values[u] = this._values[u].untransitioned();
          return o;
        }
      }
      class Xp {
        constructor(o, u, d, y, x) {
          this.property = o, this.value = u, this.begin = x + y.delay || 0, this.end = this.begin + y.duration || 0, o.specification.transition && (y.delay || y.duration) && (this.prior = d);
        }
        possiblyEvaluate(o, u, d) {
          const y = o.now || 0, x = this.value.possiblyEvaluate(o, u, d), w = this.prior;
          if (w) {
            if (y > this.end)
              return this.prior = null, x;
            if (this.value.isDataDriven())
              return this.prior = null, x;
            if (y < this.begin)
              return w.possiblyEvaluate(o, u, d);
            {
              const C = (y - this.begin) / (this.end - this.begin);
              return this.property.interpolate(w.possiblyEvaluate(o, u, d), x, function(I) {
                if (I <= 0)
                  return 0;
                if (I >= 1)
                  return 1;
                const R = I * I, N = R * I;
                return 4 * (I < 0.5 ? N : 3 * (I - R) + N - 0.75);
              }(C));
            }
          }
          return x;
        }
      }
      class Zp {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(o, u, d) {
          const y = new wc(this._properties);
          for (const x of Object.keys(this._values))
            y._values[x] = this._values[x].possiblyEvaluate(o, u, d);
          return y;
        }
        hasTransition() {
          for (const o of Object.keys(this._values))
            if (this._values[o].prior)
              return !0;
          return !1;
        }
      }
      class d_ {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultPropertyValues);
        }
        getValue(o) {
          return ne(this._values[o].value);
        }
        setValue(o, u) {
          this._values[o] = new bc(this._values[o].property, u === null ? void 0 : ne(u));
        }
        serialize() {
          const o = {};
          for (const u of Object.keys(this._values)) {
            const d = this.getValue(u);
            d !== void 0 && (o[u] = d);
          }
          return o;
        }
        possiblyEvaluate(o, u, d) {
          const y = new wc(this._properties);
          for (const x of Object.keys(this._values))
            y._values[x] = this._values[x].possiblyEvaluate(o, u, d);
          return y;
        }
      }
      class Wo {
        constructor(o, u, d) {
          this.property = o, this.value = u, this.parameters = d;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(o) {
          return this.value.kind === "constant" ? this.value.value : o;
        }
        evaluate(o, u, d, y) {
          return this.property.evaluate(this.value, this.parameters, o, u, d, y);
        }
      }
      class wc {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultPossiblyEvaluatedValues);
        }
        get(o) {
          return this._values[o];
        }
      }
      class Dt {
        constructor(o) {
          this.specification = o;
        }
        possiblyEvaluate(o, u) {
          if (o.isDataDriven())
            throw new Error("Value should not be data driven");
          return o.expression.evaluate(u);
        }
        interpolate(o, u, d) {
          const y = nc[this.specification.type];
          return y ? y(o, u, d) : o;
        }
      }
      class jt {
        constructor(o, u) {
          this.specification = o, this.overrides = u;
        }
        possiblyEvaluate(o, u, d, y) {
          return new Wo(this, o.expression.kind === "constant" || o.expression.kind === "camera" ? { kind: "constant", value: o.expression.evaluate(u, null, {}, d, y) } : o.expression, u);
        }
        interpolate(o, u, d) {
          if (o.value.kind !== "constant" || u.value.kind !== "constant")
            return o;
          if (o.value.value === void 0 || u.value.value === void 0)
            return new Wo(this, { kind: "constant", value: void 0 }, o.parameters);
          const y = nc[this.specification.type];
          return y ? new Wo(this, { kind: "constant", value: y(o.value.value, u.value.value, d) }, o.parameters) : o;
        }
        evaluate(o, u, d, y, x, w) {
          return o.kind === "constant" ? o.value : o.evaluate(u, d, y, x, w);
        }
      }
      class sl extends jt {
        possiblyEvaluate(o, u, d, y) {
          if (o.value === void 0)
            return new Wo(this, { kind: "constant", value: void 0 }, u);
          if (o.expression.kind === "constant") {
            const x = o.expression.evaluate(u, null, {}, d, y), w = o.property.specification.type === "resolvedImage" && typeof x != "string" ? x.name : x, C = this._calculate(w, w, w, u);
            return new Wo(this, { kind: "constant", value: C }, u);
          }
          if (o.expression.kind === "camera") {
            const x = this._calculate(o.expression.evaluate({ zoom: u.zoom - 1 }), o.expression.evaluate({ zoom: u.zoom }), o.expression.evaluate({ zoom: u.zoom + 1 }), u);
            return new Wo(this, { kind: "constant", value: x }, u);
          }
          return new Wo(this, o.expression, u);
        }
        evaluate(o, u, d, y, x, w) {
          if (o.kind === "source") {
            const C = o.evaluate(u, d, y, x, w);
            return this._calculate(C, C, C, u);
          }
          return o.kind === "composite" ? this._calculate(o.evaluate({ zoom: Math.floor(u.zoom) - 1 }, d, y), o.evaluate({ zoom: Math.floor(u.zoom) }, d, y), o.evaluate({ zoom: Math.floor(u.zoom) + 1 }, d, y), u) : o.value;
        }
        _calculate(o, u, d, y) {
          return y.zoom > y.zoomHistory.lastIntegerZoom ? { from: o, to: u } : { from: d, to: u };
        }
        interpolate(o) {
          return o;
        }
      }
      class Sf {
        constructor(o) {
          this.specification = o;
        }
        possiblyEvaluate(o, u, d, y) {
          if (o.value !== void 0) {
            if (o.expression.kind === "constant") {
              const x = o.expression.evaluate(u, null, {}, d, y);
              return this._calculate(x, x, x, u);
            }
            return this._calculate(o.expression.evaluate(new xn(Math.floor(u.zoom - 1), u)), o.expression.evaluate(new xn(Math.floor(u.zoom), u)), o.expression.evaluate(new xn(Math.floor(u.zoom + 1), u)), u);
          }
        }
        _calculate(o, u, d, y) {
          return y.zoom > y.zoomHistory.lastIntegerZoom ? { from: o, to: u } : { from: d, to: u };
        }
        interpolate(o) {
          return o;
        }
      }
      class Ua {
        constructor(o) {
          this.specification = o;
        }
        possiblyEvaluate(o, u, d, y) {
          return !!o.expression.evaluate(u, null, {}, d, y);
        }
        interpolate() {
          return !1;
        }
      }
      class pi {
        constructor(o) {
          this.properties = o, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const u in o) {
            const d = o[u];
            d.specification.overridable && this.overridableProperties.push(u);
            const y = this.defaultPropertyValues[u] = new bc(d, void 0), x = this.defaultTransitionablePropertyValues[u] = new Nu(d);
            this.defaultTransitioningPropertyValues[u] = x.untransitioned(), this.defaultPossiblyEvaluatedValues[u] = y.possiblyEvaluate({});
          }
        }
      }
      Ct("DataDrivenProperty", jt), Ct("DataConstantProperty", Dt), Ct("CrossFadedDataDrivenProperty", sl), Ct("CrossFadedProperty", Sf), Ct("ColorRampProperty", Ua);
      const $a = "-transition";
      class Xo extends Wt {
        constructor(o, u) {
          if (super(), this.id = o.id, this.type = o.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, o.type !== "custom" && (this.metadata = o.metadata, this.minzoom = o.minzoom, this.maxzoom = o.maxzoom, o.type !== "background" && (this.source = o.source, this.sourceLayer = o["source-layer"], this.filter = o.filter), u.layout && (this._unevaluatedLayout = new d_(u.layout)), u.paint)) {
            this._transitionablePaint = new Wp(u.paint);
            for (const d in o.paint)
              this.setPaintProperty(d, o.paint[d], { validate: !1 });
            for (const d in o.layout)
              this.setLayoutProperty(d, o.layout[d], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new wc(u.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(o) {
          return o === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(o);
        }
        setLayoutProperty(o, u, d = {}) {
          u != null && this._validate(u_, `layers.${this.id}.layout.${o}`, o, u, d) || (o !== "visibility" ? this._unevaluatedLayout.setValue(o, u) : this.visibility = u);
        }
        getPaintProperty(o) {
          return o.endsWith($a) ? this._transitionablePaint.getTransition(o.slice(0, -$a.length)) : this._transitionablePaint.getValue(o);
        }
        setPaintProperty(o, u, d = {}) {
          if (u != null && this._validate(c_, `layers.${this.id}.paint.${o}`, o, u, d))
            return !1;
          if (o.endsWith($a))
            return this._transitionablePaint.setTransition(o.slice(0, -$a.length), u || void 0), !1;
          {
            const y = this._transitionablePaint._values[o], x = y.property.specification["property-type"] === "cross-faded-data-driven", w = y.value.isDataDriven(), C = y.value;
            this._transitionablePaint.setValue(o, u), this._handleSpecialPaintPropertyUpdate(o);
            const I = this._transitionablePaint._values[o].value;
            return I.isDataDriven() || w || x || this._handleOverridablePaintPropertyUpdate(o, C, I);
          }
        }
        _handleSpecialPaintPropertyUpdate(o) {
        }
        _handleOverridablePaintPropertyUpdate(o, u, d) {
          return !1;
        }
        isHidden(o) {
          return !!(this.minzoom && o < this.minzoom) || !!(this.maxzoom && o >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(o) {
          this._transitioningPaint = this._transitionablePaint.transitioned(o, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(o, u) {
          o.getCrossfadeParameters && (this._crossfadeParameters = o.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(o, void 0, u)), this.paint = this._transitioningPaint.possiblyEvaluate(o, void 0, u);
        }
        serialize() {
          const o = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (o.layout = o.layout || {}, o.layout.visibility = this.visibility), H(o, (u, d) => !(u === void 0 || d === "layout" && !Object.keys(u).length || d === "paint" && !Object.keys(u).length));
        }
        _validate(o, u, d, y, x = {}) {
          return (!x || x.validate !== !1) && Du(this, o.call(_c, { key: u, layerType: this.type, objectKey: d, value: y, styleSpec: Ce, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const o in this.paint._values) {
            const u = this.paint.get(o);
            if (u instanceof Wo && hn(u.property.specification) && (u.value.kind === "source" || u.value.kind === "composite") && u.value.isStateDependent)
              return !0;
          }
          return !1;
        }
      }
      const Hp = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class Va {
        constructor(o, u) {
          this._structArray = o, this._pos1 = u * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class Rn {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(o, u) {
          return o._trim(), u && (o.isTransferred = !0, u.push(o.arrayBuffer)), { length: o.length, arrayBuffer: o.arrayBuffer };
        }
        static deserialize(o) {
          const u = Object.create(this.prototype);
          return u.arrayBuffer = o.arrayBuffer, u.length = o.length, u.capacity = o.arrayBuffer.byteLength / u.bytesPerElement, u._refreshViews(), u;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(o) {
          this.reserve(o), this.length = o;
        }
        reserve(o) {
          if (o > this.capacity) {
            this.capacity = Math.max(o, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const u = this.uint8;
            this._refreshViews(), u && this.uint8.set(u);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function jn(c, o = 1) {
        let u = 0, d = 0;
        return { members: c.map((y) => {
          const x = Hp[y.type].BYTES_PER_ELEMENT, w = u = Mf(u, Math.max(o, x)), C = y.components || 1;
          return d = Math.max(d, x), u += x * C, { name: y.name, type: y.type, components: C, offset: w };
        }), size: Mf(u, Math.max(d, o)), alignment: o };
      }
      function Mf(c, o) {
        return Math.ceil(c / o) * o;
      }
      class _s extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, u) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, o, u);
        }
        emplace(o, u, d) {
          const y = 2 * o;
          return this.int16[y + 0] = u, this.int16[y + 1] = d, o;
        }
      }
      _s.prototype.bytesPerElement = 4, Ct("StructArrayLayout2i4", _s);
      class g extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y) {
          const x = this.length;
          return this.resize(x + 1), this.emplace(x, o, u, d, y);
        }
        emplace(o, u, d, y, x) {
          const w = 4 * o;
          return this.int16[w + 0] = u, this.int16[w + 1] = d, this.int16[w + 2] = y, this.int16[w + 3] = x, o;
        }
      }
      g.prototype.bytesPerElement = 8, Ct("StructArrayLayout4i8", g);
      class a extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y, x, w) {
          const C = this.length;
          return this.resize(C + 1), this.emplace(C, o, u, d, y, x, w);
        }
        emplace(o, u, d, y, x, w, C) {
          const I = 6 * o;
          return this.int16[I + 0] = u, this.int16[I + 1] = d, this.int16[I + 2] = y, this.int16[I + 3] = x, this.int16[I + 4] = w, this.int16[I + 5] = C, o;
        }
      }
      a.prototype.bytesPerElement = 12, Ct("StructArrayLayout2i4i12", a);
      class f extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y, x, w) {
          const C = this.length;
          return this.resize(C + 1), this.emplace(C, o, u, d, y, x, w);
        }
        emplace(o, u, d, y, x, w, C) {
          const I = 4 * o, R = 8 * o;
          return this.int16[I + 0] = u, this.int16[I + 1] = d, this.uint8[R + 4] = y, this.uint8[R + 5] = x, this.uint8[R + 6] = w, this.uint8[R + 7] = C, o;
        }
      }
      f.prototype.bytesPerElement = 8, Ct("StructArrayLayout2i4ub8", f);
      class p extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, u) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, o, u);
        }
        emplace(o, u, d) {
          const y = 2 * o;
          return this.float32[y + 0] = u, this.float32[y + 1] = d, o;
        }
      }
      p.prototype.bytesPerElement = 8, Ct("StructArrayLayout2f8", p);
      class _ extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y, x, w, C, I, R, N) {
          const z = this.length;
          return this.resize(z + 1), this.emplace(z, o, u, d, y, x, w, C, I, R, N);
        }
        emplace(o, u, d, y, x, w, C, I, R, N, z) {
          const V = 10 * o;
          return this.uint16[V + 0] = u, this.uint16[V + 1] = d, this.uint16[V + 2] = y, this.uint16[V + 3] = x, this.uint16[V + 4] = w, this.uint16[V + 5] = C, this.uint16[V + 6] = I, this.uint16[V + 7] = R, this.uint16[V + 8] = N, this.uint16[V + 9] = z, o;
        }
      }
      _.prototype.bytesPerElement = 20, Ct("StructArrayLayout10ui20", _);
      class b extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y, x, w, C, I, R, N, z, V) {
          const W = this.length;
          return this.resize(W + 1), this.emplace(W, o, u, d, y, x, w, C, I, R, N, z, V);
        }
        emplace(o, u, d, y, x, w, C, I, R, N, z, V, W) {
          const X = 12 * o;
          return this.int16[X + 0] = u, this.int16[X + 1] = d, this.int16[X + 2] = y, this.int16[X + 3] = x, this.uint16[X + 4] = w, this.uint16[X + 5] = C, this.uint16[X + 6] = I, this.uint16[X + 7] = R, this.int16[X + 8] = N, this.int16[X + 9] = z, this.int16[X + 10] = V, this.int16[X + 11] = W, o;
        }
      }
      b.prototype.bytesPerElement = 24, Ct("StructArrayLayout4i4ui4i24", b);
      class M extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d) {
          const y = this.length;
          return this.resize(y + 1), this.emplace(y, o, u, d);
        }
        emplace(o, u, d, y) {
          const x = 3 * o;
          return this.float32[x + 0] = u, this.float32[x + 1] = d, this.float32[x + 2] = y, o;
        }
      }
      M.prototype.bytesPerElement = 12, Ct("StructArrayLayout3f12", M);
      class P extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, o);
        }
        emplace(o, u) {
          return this.uint32[1 * o + 0] = u, o;
        }
      }
      P.prototype.bytesPerElement = 4, Ct("StructArrayLayout1ul4", P);
      class O extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y, x, w, C, I, R) {
          const N = this.length;
          return this.resize(N + 1), this.emplace(N, o, u, d, y, x, w, C, I, R);
        }
        emplace(o, u, d, y, x, w, C, I, R, N) {
          const z = 10 * o, V = 5 * o;
          return this.int16[z + 0] = u, this.int16[z + 1] = d, this.int16[z + 2] = y, this.int16[z + 3] = x, this.int16[z + 4] = w, this.int16[z + 5] = C, this.uint32[V + 3] = I, this.uint16[z + 8] = R, this.uint16[z + 9] = N, o;
        }
      }
      O.prototype.bytesPerElement = 20, Ct("StructArrayLayout6i1ul2ui20", O);
      class D extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y, x, w) {
          const C = this.length;
          return this.resize(C + 1), this.emplace(C, o, u, d, y, x, w);
        }
        emplace(o, u, d, y, x, w, C) {
          const I = 6 * o;
          return this.int16[I + 0] = u, this.int16[I + 1] = d, this.int16[I + 2] = y, this.int16[I + 3] = x, this.int16[I + 4] = w, this.int16[I + 5] = C, o;
        }
      }
      D.prototype.bytesPerElement = 12, Ct("StructArrayLayout2i2i2i12", D);
      class F extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y, x) {
          const w = this.length;
          return this.resize(w + 1), this.emplace(w, o, u, d, y, x);
        }
        emplace(o, u, d, y, x, w) {
          const C = 4 * o, I = 8 * o;
          return this.float32[C + 0] = u, this.float32[C + 1] = d, this.float32[C + 2] = y, this.int16[I + 6] = x, this.int16[I + 7] = w, o;
        }
      }
      F.prototype.bytesPerElement = 16, Ct("StructArrayLayout2f1f2i16", F);
      class $ extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y) {
          const x = this.length;
          return this.resize(x + 1), this.emplace(x, o, u, d, y);
        }
        emplace(o, u, d, y, x) {
          const w = 12 * o, C = 3 * o;
          return this.uint8[w + 0] = u, this.uint8[w + 1] = d, this.float32[C + 1] = y, this.float32[C + 2] = x, o;
        }
      }
      $.prototype.bytesPerElement = 12, Ct("StructArrayLayout2ub2f12", $);
      class G extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d) {
          const y = this.length;
          return this.resize(y + 1), this.emplace(y, o, u, d);
        }
        emplace(o, u, d, y) {
          const x = 3 * o;
          return this.uint16[x + 0] = u, this.uint16[x + 1] = d, this.uint16[x + 2] = y, o;
        }
      }
      G.prototype.bytesPerElement = 6, Ct("StructArrayLayout3ui6", G);
      class ie extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y, x, w, C, I, R, N, z, V, W, X, se, ae, Ee) {
          const De = this.length;
          return this.resize(De + 1), this.emplace(De, o, u, d, y, x, w, C, I, R, N, z, V, W, X, se, ae, Ee);
        }
        emplace(o, u, d, y, x, w, C, I, R, N, z, V, W, X, se, ae, Ee, De) {
          const we = 24 * o, Ae = 12 * o, qe = 48 * o;
          return this.int16[we + 0] = u, this.int16[we + 1] = d, this.uint16[we + 2] = y, this.uint16[we + 3] = x, this.uint32[Ae + 2] = w, this.uint32[Ae + 3] = C, this.uint32[Ae + 4] = I, this.uint16[we + 10] = R, this.uint16[we + 11] = N, this.uint16[we + 12] = z, this.float32[Ae + 7] = V, this.float32[Ae + 8] = W, this.uint8[qe + 36] = X, this.uint8[qe + 37] = se, this.uint8[qe + 38] = ae, this.uint32[Ae + 10] = Ee, this.int16[we + 22] = De, o;
        }
      }
      ie.prototype.bytesPerElement = 48, Ct("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", ie);
      class Q extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y, x, w, C, I, R, N, z, V, W, X, se, ae, Ee, De, we, Ae, qe, je, Et, Ot, yt, ft, ut, _t) {
          const pt = this.length;
          return this.resize(pt + 1), this.emplace(pt, o, u, d, y, x, w, C, I, R, N, z, V, W, X, se, ae, Ee, De, we, Ae, qe, je, Et, Ot, yt, ft, ut, _t);
        }
        emplace(o, u, d, y, x, w, C, I, R, N, z, V, W, X, se, ae, Ee, De, we, Ae, qe, je, Et, Ot, yt, ft, ut, _t, pt) {
          const et = 34 * o, Bt = 17 * o;
          return this.int16[et + 0] = u, this.int16[et + 1] = d, this.int16[et + 2] = y, this.int16[et + 3] = x, this.int16[et + 4] = w, this.int16[et + 5] = C, this.int16[et + 6] = I, this.int16[et + 7] = R, this.uint16[et + 8] = N, this.uint16[et + 9] = z, this.uint16[et + 10] = V, this.uint16[et + 11] = W, this.uint16[et + 12] = X, this.uint16[et + 13] = se, this.uint16[et + 14] = ae, this.uint16[et + 15] = Ee, this.uint16[et + 16] = De, this.uint16[et + 17] = we, this.uint16[et + 18] = Ae, this.uint16[et + 19] = qe, this.uint16[et + 20] = je, this.uint16[et + 21] = Et, this.uint16[et + 22] = Ot, this.uint32[Bt + 12] = yt, this.float32[Bt + 13] = ft, this.float32[Bt + 14] = ut, this.float32[Bt + 15] = _t, this.float32[Bt + 16] = pt, o;
        }
      }
      Q.prototype.bytesPerElement = 68, Ct("StructArrayLayout8i15ui1ul4f68", Q);
      class te extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, o);
        }
        emplace(o, u) {
          return this.float32[1 * o + 0] = u, o;
        }
      }
      te.prototype.bytesPerElement = 4, Ct("StructArrayLayout1f4", te);
      class de extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d) {
          const y = this.length;
          return this.resize(y + 1), this.emplace(y, o, u, d);
        }
        emplace(o, u, d, y) {
          const x = 3 * o;
          return this.int16[x + 0] = u, this.int16[x + 1] = d, this.int16[x + 2] = y, o;
        }
      }
      de.prototype.bytesPerElement = 6, Ct("StructArrayLayout3i6", de);
      class be extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d) {
          const y = this.length;
          return this.resize(y + 1), this.emplace(y, o, u, d);
        }
        emplace(o, u, d, y) {
          const x = 4 * o;
          return this.uint32[2 * o + 0] = u, this.uint16[x + 2] = d, this.uint16[x + 3] = y, o;
        }
      }
      be.prototype.bytesPerElement = 8, Ct("StructArrayLayout1ul2ui8", be);
      class Se extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, u) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, o, u);
        }
        emplace(o, u, d) {
          const y = 2 * o;
          return this.uint16[y + 0] = u, this.uint16[y + 1] = d, o;
        }
      }
      Se.prototype.bytesPerElement = 4, Ct("StructArrayLayout2ui4", Se);
      class oe extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, o);
        }
        emplace(o, u) {
          return this.uint16[1 * o + 0] = u, o;
        }
      }
      oe.prototype.bytesPerElement = 2, Ct("StructArrayLayout1ui2", oe);
      class Le extends Rn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, u, d, y) {
          const x = this.length;
          return this.resize(x + 1), this.emplace(x, o, u, d, y);
        }
        emplace(o, u, d, y, x) {
          const w = 4 * o;
          return this.float32[w + 0] = u, this.float32[w + 1] = d, this.float32[w + 2] = y, this.float32[w + 3] = x, o;
        }
      }
      Le.prototype.bytesPerElement = 16, Ct("StructArrayLayout4f16", Le);
      class Ie extends Va {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new Pe(this.anchorPointX, this.anchorPointY);
        }
      }
      Ie.prototype.size = 20;
      class Be extends O {
        get(o) {
          return new Ie(this, o);
        }
      }
      Ct("CollisionBoxArray", Be);
      class Ue extends Va {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(o) {
          this._structArray.uint8[this._pos1 + 37] = o;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(o) {
          this._structArray.uint8[this._pos1 + 38] = o;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(o) {
          this._structArray.uint32[this._pos4 + 10] = o;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      Ue.prototype.size = 48;
      class Qe extends ie {
        get(o) {
          return new Ue(this, o);
        }
      }
      Ct("PlacedSymbolArray", Qe);
      class Fe extends Va {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(o) {
          this._structArray.uint32[this._pos4 + 12] = o;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 15];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 16];
        }
      }
      Fe.prototype.size = 68;
      class bt extends Q {
        get(o) {
          return new Fe(this, o);
        }
      }
      Ct("SymbolInstanceArray", bt);
      class ht extends te {
        getoffsetX(o) {
          return this.float32[1 * o + 0];
        }
      }
      Ct("GlyphOffsetArray", ht);
      class wt extends de {
        getx(o) {
          return this.int16[3 * o + 0];
        }
        gety(o) {
          return this.int16[3 * o + 1];
        }
        gettileUnitDistanceFromAnchor(o) {
          return this.int16[3 * o + 2];
        }
      }
      Ct("SymbolLineVertexArray", wt);
      class er extends Va {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      er.prototype.size = 8;
      class sr extends be {
        get(o) {
          return new er(this, o);
        }
      }
      Ct("FeatureIndexArray", sr);
      class zt extends _s {
      }
      class Ur extends _s {
      }
      class $r extends _s {
      }
      class Tr extends a {
      }
      class Pr extends f {
      }
      class Gr extends p {
      }
      class oi extends _ {
      }
      class Zo extends b {
      }
      class Lo extends M {
      }
      class Ho extends P {
      }
      class ja extends D {
      }
      class _o extends $ {
      }
      class Vi extends G {
      }
      class ha extends Se {
      }
      const Fu = jn([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Yn } = Fu;
      class hr {
        constructor(o = []) {
          this.segments = o;
        }
        prepareSegment(o, u, d, y) {
          let x = this.segments[this.segments.length - 1];
          return o > hr.MAX_VERTEX_ARRAY_LENGTH && he(`Max vertices per segment is ${hr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${o}`), (!x || x.vertexLength + o > hr.MAX_VERTEX_ARRAY_LENGTH || x.sortKey !== y) && (x = { vertexOffset: u.length, primitiveOffset: d.length, vertexLength: 0, primitiveLength: 0 }, y !== void 0 && (x.sortKey = y), this.segments.push(x)), x;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const o of this.segments)
            for (const u in o.vaos)
              o.vaos[u].destroy();
        }
        static simpleSegment(o, u, d, y) {
          return new hr([{ vertexOffset: o, primitiveOffset: u, vertexLength: d, primitiveLength: y, vaos: {}, sortKey: 0 }]);
        }
      }
      function Nr(c, o) {
        return 256 * (c = S(Math.floor(c), 0, 255)) + S(Math.floor(o), 0, 255);
      }
      hr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ct("SegmentVector", hr);
      const ai = jn([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var si = { exports: {} }, bn = { exports: {} };
      bn.exports = function(c, o) {
        var u, d, y, x, w, C, I, R;
        for (d = c.length - (u = 3 & c.length), y = o, w = 3432918353, C = 461845907, R = 0; R < d; )
          I = 255 & c.charCodeAt(R) | (255 & c.charCodeAt(++R)) << 8 | (255 & c.charCodeAt(++R)) << 16 | (255 & c.charCodeAt(++R)) << 24, ++R, y = 27492 + (65535 & (x = 5 * (65535 & (y = (y ^= I = (65535 & (I = (I = (65535 & I) * w + (((I >>> 16) * w & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * C + (((I >>> 16) * C & 65535) << 16) & 4294967295) << 13 | y >>> 19)) + ((5 * (y >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (x >>> 16) & 65535) << 16);
        switch (I = 0, u) {
          case 3:
            I ^= (255 & c.charCodeAt(R + 2)) << 16;
          case 2:
            I ^= (255 & c.charCodeAt(R + 1)) << 8;
          case 1:
            y ^= I = (65535 & (I = (I = (65535 & (I ^= 255 & c.charCodeAt(R))) * w + (((I >>> 16) * w & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * C + (((I >>> 16) * C & 65535) << 16) & 4294967295;
        }
        return y ^= c.length, y = 2246822507 * (65535 & (y ^= y >>> 16)) + ((2246822507 * (y >>> 16) & 65535) << 16) & 4294967295, y = 3266489909 * (65535 & (y ^= y >>> 13)) + ((3266489909 * (y >>> 16) & 65535) << 16) & 4294967295, (y ^= y >>> 16) >>> 0;
      };
      var vo = { exports: {} };
      vo.exports = function(c, o) {
        for (var u, d = c.length, y = o ^ d, x = 0; d >= 4; )
          u = 1540483477 * (65535 & (u = 255 & c.charCodeAt(x) | (255 & c.charCodeAt(++x)) << 8 | (255 & c.charCodeAt(++x)) << 16 | (255 & c.charCodeAt(++x)) << 24)) + ((1540483477 * (u >>> 16) & 65535) << 16), y = 1540483477 * (65535 & y) + ((1540483477 * (y >>> 16) & 65535) << 16) ^ (u = 1540483477 * (65535 & (u ^= u >>> 24)) + ((1540483477 * (u >>> 16) & 65535) << 16)), d -= 4, ++x;
        switch (d) {
          case 3:
            y ^= (255 & c.charCodeAt(x + 2)) << 16;
          case 2:
            y ^= (255 & c.charCodeAt(x + 1)) << 8;
          case 1:
            y = 1540483477 * (65535 & (y ^= 255 & c.charCodeAt(x))) + ((1540483477 * (y >>> 16) & 65535) << 16);
        }
        return y = 1540483477 * (65535 & (y ^= y >>> 13)) + ((1540483477 * (y >>> 16) & 65535) << 16), (y ^= y >>> 15) >>> 0;
      };
      var vs = bn.exports, Cf = vo.exports;
      si.exports = vs, si.exports.murmur3 = vs, si.exports.murmur2 = Cf;
      class ll {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(o, u, d, y) {
          this.ids.push(Kp(o)), this.positions.push(u, d, y);
        }
        getPositions(o) {
          if (!this.indexed)
            throw new Error("Trying to get index, but feature positions are not indexed");
          const u = Kp(o);
          let d = 0, y = this.ids.length - 1;
          for (; d < y; ) {
            const w = d + y >> 1;
            this.ids[w] >= u ? y = w : d = w + 1;
          }
          const x = [];
          for (; this.ids[d] === u; )
            x.push({ index: this.positions[3 * d], start: this.positions[3 * d + 1], end: this.positions[3 * d + 2] }), d++;
          return x;
        }
        static serialize(o, u) {
          const d = new Float64Array(o.ids), y = new Uint32Array(o.positions);
          return If(d, y, 0, d.length - 1), u && u.push(d.buffer, y.buffer), { ids: d, positions: y };
        }
        static deserialize(o) {
          const u = new ll();
          return u.ids = o.ids, u.positions = o.positions, u.indexed = !0, u;
        }
      }
      function Kp(c) {
        const o = +c;
        return !isNaN(o) && o <= Number.MAX_SAFE_INTEGER ? o : si.exports(String(c));
      }
      function If(c, o, u, d) {
        for (; u < d; ) {
          const y = c[u + d >> 1];
          let x = u - 1, w = d + 1;
          for (; ; ) {
            do
              x++;
            while (c[x] < y);
            do
              w--;
            while (c[w] > y);
            if (x >= w)
              break;
            Ga(c, x, w), Ga(o, 3 * x, 3 * w), Ga(o, 3 * x + 1, 3 * w + 1), Ga(o, 3 * x + 2, 3 * w + 2);
          }
          w - u < d - w ? (If(c, o, u, w), u = w + 1) : (If(c, o, w + 1, d), d = w);
        }
      }
      function Ga(c, o, u) {
        const d = c[o];
        c[o] = c[u], c[u] = d;
      }
      Ct("FeaturePositionMap", ll);
      class xs {
        constructor(o, u) {
          this.gl = o.gl, this.location = u;
        }
      }
      class bs extends xs {
        constructor(o, u) {
          super(o, u), this.current = 0;
        }
        set(o) {
          this.current !== o && (this.current = o, this.gl.uniform1f(this.location, o));
        }
      }
      class zu extends xs {
        constructor(o, u) {
          super(o, u), this.current = [0, 0, 0, 0];
        }
        set(o) {
          o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] && o[3] === this.current[3] || (this.current = o, this.gl.uniform4f(this.location, o[0], o[1], o[2], o[3]));
        }
      }
      class t1 extends xs {
        constructor(o, u) {
          super(o, u), this.current = K.transparent;
        }
        set(o) {
          o.r === this.current.r && o.g === this.current.g && o.b === this.current.b && o.a === this.current.a || (this.current = o, this.gl.uniform4f(this.location, o.r, o.g, o.b, o.a));
        }
      }
      const BC = new Float32Array(16);
      function p_(c) {
        return [Nr(255 * c.r, 255 * c.g), Nr(255 * c.b, 255 * c.a)];
      }
      class Pf {
        constructor(o, u, d) {
          this.value = o, this.uniformNames = u.map((y) => `u_${y}`), this.type = d;
        }
        setUniform(o, u, d) {
          o.set(d.constantOr(this.value));
        }
        getBinding(o, u, d) {
          return this.type === "color" ? new t1(o, u) : new bs(o, u);
        }
      }
      class Bu {
        constructor(o, u) {
          this.uniformNames = u.map((d) => `u_${d}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(o, u) {
          this.pixelRatioFrom = u.pixelRatio, this.pixelRatioTo = o.pixelRatio, this.patternFrom = u.tlbr, this.patternTo = o.tlbr;
        }
        setUniform(o, u, d, y) {
          const x = y === "u_pattern_to" ? this.patternTo : y === "u_pattern_from" ? this.patternFrom : y === "u_pixel_ratio_to" ? this.pixelRatioTo : y === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          x && o.set(x);
        }
        getBinding(o, u, d) {
          return d.substr(0, 9) === "u_pattern" ? new zu(o, u) : new bs(o, u);
        }
      }
      class ws {
        constructor(o, u, d, y) {
          this.expression = o, this.type = d, this.maxValue = 0, this.paintVertexAttributes = u.map((x) => ({ name: `a_${x}`, type: "Float32", components: d === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new y();
        }
        populatePaintArray(o, u, d, y, x) {
          const w = this.paintVertexArray.length, C = this.expression.evaluate(new xn(0), u, {}, y, [], x);
          this.paintVertexArray.resize(o), this._setPaintValue(w, o, C);
        }
        updatePaintArray(o, u, d, y) {
          const x = this.expression.evaluate({ zoom: 0 }, d, y);
          this._setPaintValue(o, u, x);
        }
        _setPaintValue(o, u, d) {
          if (this.type === "color") {
            const y = p_(d);
            for (let x = o; x < u; x++)
              this.paintVertexArray.emplace(x, y[0], y[1]);
          } else {
            for (let y = o; y < u; y++)
              this.paintVertexArray.emplace(y, d);
            this.maxValue = Math.max(this.maxValue, Math.abs(d));
          }
        }
        upload(o) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = o.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class fa {
        constructor(o, u, d, y, x, w) {
          this.expression = o, this.uniformNames = u.map((C) => `u_${C}_t`), this.type = d, this.useIntegerZoom = y, this.zoom = x, this.maxValue = 0, this.paintVertexAttributes = u.map((C) => ({ name: `a_${C}`, type: "Float32", components: d === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new w();
        }
        populatePaintArray(o, u, d, y, x) {
          const w = this.expression.evaluate(new xn(this.zoom), u, {}, y, [], x), C = this.expression.evaluate(new xn(this.zoom + 1), u, {}, y, [], x), I = this.paintVertexArray.length;
          this.paintVertexArray.resize(o), this._setPaintValue(I, o, w, C);
        }
        updatePaintArray(o, u, d, y) {
          const x = this.expression.evaluate({ zoom: this.zoom }, d, y), w = this.expression.evaluate({ zoom: this.zoom + 1 }, d, y);
          this._setPaintValue(o, u, x, w);
        }
        _setPaintValue(o, u, d, y) {
          if (this.type === "color") {
            const x = p_(d), w = p_(y);
            for (let C = o; C < u; C++)
              this.paintVertexArray.emplace(C, x[0], x[1], w[0], w[1]);
          } else {
            for (let x = o; x < u; x++)
              this.paintVertexArray.emplace(x, d, y);
            this.maxValue = Math.max(this.maxValue, Math.abs(d), Math.abs(y));
          }
        }
        upload(o) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = o.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(o, u) {
          const d = this.useIntegerZoom ? Math.floor(u.zoom) : u.zoom, y = S(this.expression.interpolationFactor(d, this.zoom, this.zoom + 1), 0, 1);
          o.set(y);
        }
        getBinding(o, u, d) {
          return new bs(o, u);
        }
      }
      class cl {
        constructor(o, u, d, y, x, w) {
          this.expression = o, this.type = u, this.useIntegerZoom = d, this.zoom = y, this.layerId = w, this.zoomInPaintVertexArray = new x(), this.zoomOutPaintVertexArray = new x();
        }
        populatePaintArray(o, u, d) {
          const y = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(o), this.zoomOutPaintVertexArray.resize(o), this._setPaintValues(y, o, u.patterns && u.patterns[this.layerId], d);
        }
        updatePaintArray(o, u, d, y, x) {
          this._setPaintValues(o, u, d.patterns && d.patterns[this.layerId], x);
        }
        _setPaintValues(o, u, d, y) {
          if (!y || !d)
            return;
          const { min: x, mid: w, max: C } = d, I = y[x], R = y[w], N = y[C];
          if (I && R && N)
            for (let z = o; z < u; z++)
              this.zoomInPaintVertexArray.emplace(z, R.tl[0], R.tl[1], R.br[0], R.br[1], I.tl[0], I.tl[1], I.br[0], I.br[1], R.pixelRatio, I.pixelRatio), this.zoomOutPaintVertexArray.emplace(z, R.tl[0], R.tl[1], R.br[0], R.br[1], N.tl[0], N.tl[1], N.br[0], N.br[1], R.pixelRatio, N.pixelRatio);
        }
        upload(o) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = o.createVertexBuffer(this.zoomInPaintVertexArray, ai.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = o.createVertexBuffer(this.zoomOutPaintVertexArray, ai.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class r1 {
        constructor(o, u, d) {
          this.binders = {}, this._buffers = [];
          const y = [];
          for (const x in o.paint._values) {
            if (!d(x))
              continue;
            const w = o.paint.get(x);
            if (!(w instanceof Wo && hn(w.property.specification)))
              continue;
            const C = UC(x, o.type), I = w.value, R = w.property.specification.type, N = w.property.useIntegerZoom, z = w.property.specification["property-type"], V = z === "cross-faded" || z === "cross-faded-data-driven";
            if (I.kind === "constant")
              this.binders[x] = V ? new Bu(I.value, C) : new Pf(I.value, C, R), y.push(`/u_${x}`);
            else if (I.kind === "source" || V) {
              const W = n1(x, R, "source");
              this.binders[x] = V ? new cl(I, R, N, u, W, o.id) : new ws(I, C, R, W), y.push(`/a_${x}`);
            } else {
              const W = n1(x, R, "composite");
              this.binders[x] = new fa(I, C, R, N, u, W), y.push(`/z_${x}`);
            }
          }
          this.cacheKey = y.sort().join("");
        }
        getMaxValue(o) {
          const u = this.binders[o];
          return u instanceof ws || u instanceof fa ? u.maxValue : 0;
        }
        populatePaintArrays(o, u, d, y, x) {
          for (const w in this.binders) {
            const C = this.binders[w];
            (C instanceof ws || C instanceof fa || C instanceof cl) && C.populatePaintArray(o, u, d, y, x);
          }
        }
        setConstantPatternPositions(o, u) {
          for (const d in this.binders) {
            const y = this.binders[d];
            y instanceof Bu && y.setConstantPatternPositions(o, u);
          }
        }
        updatePaintArrays(o, u, d, y, x) {
          let w = !1;
          for (const C in o) {
            const I = u.getPositions(C);
            for (const R of I) {
              const N = d.feature(R.index);
              for (const z in this.binders) {
                const V = this.binders[z];
                if ((V instanceof ws || V instanceof fa || V instanceof cl) && V.expression.isStateDependent === !0) {
                  const W = y.paint.get(z);
                  V.expression = W.value, V.updatePaintArray(R.start, R.end, N, o[C], x), w = !0;
                }
              }
            }
          }
          return w;
        }
        defines() {
          const o = [];
          for (const u in this.binders) {
            const d = this.binders[u];
            (d instanceof Pf || d instanceof Bu) && o.push(...d.uniformNames.map((y) => `#define HAS_UNIFORM_${y}`));
          }
          return o;
        }
        getBinderAttributes() {
          const o = [];
          for (const u in this.binders) {
            const d = this.binders[u];
            if (d instanceof ws || d instanceof fa)
              for (let y = 0; y < d.paintVertexAttributes.length; y++)
                o.push(d.paintVertexAttributes[y].name);
            else if (d instanceof cl)
              for (let y = 0; y < ai.members.length; y++)
                o.push(ai.members[y].name);
          }
          return o;
        }
        getBinderUniforms() {
          const o = [];
          for (const u in this.binders) {
            const d = this.binders[u];
            if (d instanceof Pf || d instanceof Bu || d instanceof fa)
              for (const y of d.uniformNames)
                o.push(y);
          }
          return o;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(o, u) {
          const d = [];
          for (const y in this.binders) {
            const x = this.binders[y];
            if (x instanceof Pf || x instanceof Bu || x instanceof fa) {
              for (const w of x.uniformNames)
                if (u[w]) {
                  const C = x.getBinding(o, u[w], w);
                  d.push({ name: w, property: y, binding: C });
                }
            }
          }
          return d;
        }
        setUniforms(o, u, d, y) {
          for (const { name: x, property: w, binding: C } of u)
            this.binders[w].setUniform(C, y, d.get(w), x);
        }
        updatePaintBuffers(o) {
          this._buffers = [];
          for (const u in this.binders) {
            const d = this.binders[u];
            if (o && d instanceof cl) {
              const y = o.fromScale === 2 ? d.zoomInPaintVertexBuffer : d.zoomOutPaintVertexBuffer;
              y && this._buffers.push(y);
            } else
              (d instanceof ws || d instanceof fa) && d.paintVertexBuffer && this._buffers.push(d.paintVertexBuffer);
          }
        }
        upload(o) {
          for (const u in this.binders) {
            const d = this.binders[u];
            (d instanceof ws || d instanceof fa || d instanceof cl) && d.upload(o);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const o in this.binders) {
            const u = this.binders[o];
            (u instanceof ws || u instanceof fa || u instanceof cl) && u.destroy();
          }
        }
      }
      class Ec {
        constructor(o, u, d = () => !0) {
          this.programConfigurations = {};
          for (const y of o)
            this.programConfigurations[y.id] = new r1(y, u, d);
          this.needsUpload = !1, this._featureMap = new ll(), this._bufferOffset = 0;
        }
        populatePaintArrays(o, u, d, y, x, w) {
          for (const C in this.programConfigurations)
            this.programConfigurations[C].populatePaintArrays(o, u, y, x, w);
          u.id !== void 0 && this._featureMap.add(u.id, d, this._bufferOffset, o), this._bufferOffset = o, this.needsUpload = !0;
        }
        updatePaintArrays(o, u, d, y) {
          for (const x of d)
            this.needsUpload = this.programConfigurations[x.id].updatePaintArrays(o, this._featureMap, u, x, y) || this.needsUpload;
        }
        get(o) {
          return this.programConfigurations[o];
        }
        upload(o) {
          if (this.needsUpload) {
            for (const u in this.programConfigurations)
              this.programConfigurations[u].upload(o);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const o in this.programConfigurations)
            this.programConfigurations[o].destroy();
        }
      }
      function UC(c, o) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[c] || [c.replace(`${o}-`, "").replace(/-/g, "_")];
      }
      function n1(c, o, u) {
        const d = { color: { source: p, composite: Le }, number: { source: te, composite: p } }, y = function(x) {
          return { "line-pattern": { source: oi, composite: oi }, "fill-pattern": { source: oi, composite: oi }, "fill-extrusion-pattern": { source: oi, composite: oi } }[x];
        }(c);
        return y && y[u] || d[o][u];
      }
      Ct("ConstantBinder", Pf), Ct("CrossFadedConstantBinder", Bu), Ct("SourceExpressionBinder", ws), Ct("CrossFadedCompositeBinder", cl), Ct("CompositeExpressionBinder", fa), Ct("ProgramConfiguration", r1, { omit: ["_buffers"] }), Ct("ProgramConfigurationSet", Ec);
      var Jn = 8192;
      const m_ = Math.pow(2, 14) - 1, i1 = -m_ - 1;
      function Tc(c) {
        const o = Jn / c.extent, u = c.loadGeometry();
        for (let d = 0; d < u.length; d++) {
          const y = u[d];
          for (let x = 0; x < y.length; x++) {
            const w = y[x], C = Math.round(w.x * o), I = Math.round(w.y * o);
            w.x = S(C, i1, m_), w.y = S(I, i1, m_), (C < w.x || C > w.x + 1 || I < w.y || I > w.y + 1) && he("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return u;
      }
      function Sc(c, o) {
        return { type: c.type, id: c.id, properties: c.properties, geometry: o ? Tc(c) : [] };
      }
      function Yp(c, o, u, d, y) {
        c.emplaceBack(2 * o + (d + 1) / 2, 2 * u + (y + 1) / 2);
      }
      class g_ {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((u) => u.id), this.index = o.index, this.hasPattern = !1, this.layoutVertexArray = new Ur(), this.indexArray = new Vi(), this.segments = new hr(), this.programConfigurations = new Ec(o.layers, o.zoom), this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
        }
        populate(o, u, d) {
          const y = this.layers[0], x = [];
          let w = null, C = !1;
          y.type === "circle" && (w = y.layout.get("circle-sort-key"), C = !w.isConstant());
          for (const { feature: I, id: R, index: N, sourceLayerIndex: z } of o) {
            const V = this.layers[0]._featureFilter.needGeometry, W = Sc(I, V);
            if (!this.layers[0]._featureFilter.filter(new xn(this.zoom), W, d))
              continue;
            const X = C ? w.evaluate(W, {}, d) : void 0, se = { id: R, properties: I.properties, type: I.type, sourceLayerIndex: z, index: N, geometry: V ? W.geometry : Tc(I), patterns: {}, sortKey: X };
            x.push(se);
          }
          C && x.sort((I, R) => I.sortKey - R.sortKey);
          for (const I of x) {
            const { geometry: R, index: N, sourceLayerIndex: z } = I, V = o[N].feature;
            this.addFeature(I, R, N, d), u.featureIndex.insert(V, R, N, z, this.index);
          }
        }
        update(o, u, d) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, u, this.stateDependentLayers, d);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, Yn), this.indexBuffer = o.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(o, u, d, y) {
          for (const x of u)
            for (const w of x) {
              const C = w.x, I = w.y;
              if (C < 0 || C >= Jn || I < 0 || I >= Jn)
                continue;
              const R = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, o.sortKey), N = R.vertexLength;
              Yp(this.layoutVertexArray, C, I, -1, -1), Yp(this.layoutVertexArray, C, I, 1, -1), Yp(this.layoutVertexArray, C, I, 1, 1), Yp(this.layoutVertexArray, C, I, -1, 1), this.indexArray.emplaceBack(N, N + 1, N + 2), this.indexArray.emplaceBack(N, N + 3, N + 2), R.vertexLength += 4, R.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, d, {}, y);
        }
      }
      function o1(c, o) {
        for (let u = 0; u < c.length; u++)
          if (Uu(o, c[u]))
            return !0;
        for (let u = 0; u < o.length; u++)
          if (Uu(c, o[u]))
            return !0;
        return !!y_(c, o);
      }
      function $C(c, o, u) {
        return !!Uu(c, o) || !!__(o, c, u);
      }
      function a1(c, o) {
        if (c.length === 1)
          return l1(o, c[0]);
        for (let u = 0; u < o.length; u++) {
          const d = o[u];
          for (let y = 0; y < d.length; y++)
            if (Uu(c, d[y]))
              return !0;
        }
        for (let u = 0; u < c.length; u++)
          if (l1(o, c[u]))
            return !0;
        for (let u = 0; u < o.length; u++)
          if (y_(c, o[u]))
            return !0;
        return !1;
      }
      function VC(c, o, u) {
        if (c.length > 1) {
          if (y_(c, o))
            return !0;
          for (let d = 0; d < o.length; d++)
            if (__(o[d], c, u))
              return !0;
        }
        for (let d = 0; d < c.length; d++)
          if (__(c[d], o, u))
            return !0;
        return !1;
      }
      function y_(c, o) {
        if (c.length === 0 || o.length === 0)
          return !1;
        for (let u = 0; u < c.length - 1; u++) {
          const d = c[u], y = c[u + 1];
          for (let x = 0; x < o.length - 1; x++)
            if (jC(d, y, o[x], o[x + 1]))
              return !0;
        }
        return !1;
      }
      function jC(c, o, u, d) {
        return Te(c, u, d) !== Te(o, u, d) && Te(c, o, u) !== Te(c, o, d);
      }
      function __(c, o, u) {
        const d = u * u;
        if (o.length === 1)
          return c.distSqr(o[0]) < d;
        for (let y = 1; y < o.length; y++)
          if (s1(c, o[y - 1], o[y]) < d)
            return !0;
        return !1;
      }
      function s1(c, o, u) {
        const d = o.distSqr(u);
        if (d === 0)
          return c.distSqr(o);
        const y = ((c.x - o.x) * (u.x - o.x) + (c.y - o.y) * (u.y - o.y)) / d;
        return c.distSqr(y < 0 ? o : y > 1 ? u : u.sub(o)._mult(y)._add(o));
      }
      function l1(c, o) {
        let u, d, y, x = !1;
        for (let w = 0; w < c.length; w++) {
          u = c[w];
          for (let C = 0, I = u.length - 1; C < u.length; I = C++)
            d = u[C], y = u[I], d.y > o.y != y.y > o.y && o.x < (y.x - d.x) * (o.y - d.y) / (y.y - d.y) + d.x && (x = !x);
        }
        return x;
      }
      function Uu(c, o) {
        let u = !1;
        for (let d = 0, y = c.length - 1; d < c.length; y = d++) {
          const x = c[d], w = c[y];
          x.y > o.y != w.y > o.y && o.x < (w.x - x.x) * (o.y - x.y) / (w.y - x.y) + x.x && (u = !u);
        }
        return u;
      }
      function GC(c, o, u) {
        const d = u[0], y = u[2];
        if (c.x < d.x && o.x < d.x || c.x > y.x && o.x > y.x || c.y < d.y && o.y < d.y || c.y > y.y && o.y > y.y)
          return !1;
        const x = Te(c, o, u[0]);
        return x !== Te(c, o, u[1]) || x !== Te(c, o, u[2]) || x !== Te(c, o, u[3]);
      }
      function Af(c, o, u) {
        const d = o.paint.get(c).value;
        return d.kind === "constant" ? d.value : u.programConfigurations.get(o.id).getMaxValue(c);
      }
      function Jp(c) {
        return Math.sqrt(c[0] * c[0] + c[1] * c[1]);
      }
      function Qp(c, o, u, d, y) {
        if (!o[0] && !o[1])
          return c;
        const x = Pe.convert(o)._mult(y);
        u === "viewport" && x._rotate(-d);
        const w = [];
        for (let C = 0; C < c.length; C++)
          w.push(c[C].sub(x));
        return w;
      }
      Ct("CircleBucket", g_, { omit: ["layers"] });
      const qC = new pi({ "circle-sort-key": new jt(Ce.layout_circle["circle-sort-key"]) });
      var WC = { paint: new pi({ "circle-radius": new jt(Ce.paint_circle["circle-radius"]), "circle-color": new jt(Ce.paint_circle["circle-color"]), "circle-blur": new jt(Ce.paint_circle["circle-blur"]), "circle-opacity": new jt(Ce.paint_circle["circle-opacity"]), "circle-translate": new Dt(Ce.paint_circle["circle-translate"]), "circle-translate-anchor": new Dt(Ce.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Dt(Ce.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Dt(Ce.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new jt(Ce.paint_circle["circle-stroke-width"]), "circle-stroke-color": new jt(Ce.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new jt(Ce.paint_circle["circle-stroke-opacity"]) }), layout: qC }, ji = 1e-6, Gi = typeof Float32Array < "u" ? Float32Array : Array;
      function c1() {
        var c = new Gi(9);
        return Gi != Float32Array && (c[1] = 0, c[2] = 0, c[3] = 0, c[5] = 0, c[6] = 0, c[7] = 0), c[0] = 1, c[4] = 1, c[8] = 1, c;
      }
      function v_(c) {
        return c[0] = 1, c[1] = 0, c[2] = 0, c[3] = 0, c[4] = 0, c[5] = 1, c[6] = 0, c[7] = 0, c[8] = 0, c[9] = 0, c[10] = 1, c[11] = 0, c[12] = 0, c[13] = 0, c[14] = 0, c[15] = 1, c;
      }
      function u1(c, o, u) {
        var d = o[0], y = o[1], x = o[2], w = o[3], C = o[4], I = o[5], R = o[6], N = o[7], z = o[8], V = o[9], W = o[10], X = o[11], se = o[12], ae = o[13], Ee = o[14], De = o[15], we = u[0], Ae = u[1], qe = u[2], je = u[3];
        return c[0] = we * d + Ae * C + qe * z + je * se, c[1] = we * y + Ae * I + qe * V + je * ae, c[2] = we * x + Ae * R + qe * W + je * Ee, c[3] = we * w + Ae * N + qe * X + je * De, c[4] = (we = u[4]) * d + (Ae = u[5]) * C + (qe = u[6]) * z + (je = u[7]) * se, c[5] = we * y + Ae * I + qe * V + je * ae, c[6] = we * x + Ae * R + qe * W + je * Ee, c[7] = we * w + Ae * N + qe * X + je * De, c[8] = (we = u[8]) * d + (Ae = u[9]) * C + (qe = u[10]) * z + (je = u[11]) * se, c[9] = we * y + Ae * I + qe * V + je * ae, c[10] = we * x + Ae * R + qe * W + je * Ee, c[11] = we * w + Ae * N + qe * X + je * De, c[12] = (we = u[12]) * d + (Ae = u[13]) * C + (qe = u[14]) * z + (je = u[15]) * se, c[13] = we * y + Ae * I + qe * V + je * ae, c[14] = we * x + Ae * R + qe * W + je * Ee, c[15] = we * w + Ae * N + qe * X + je * De, c;
      }
      Math.hypot || (Math.hypot = function() {
        for (var c = 0, o = arguments.length; o--; )
          c += arguments[o] * arguments[o];
        return Math.sqrt(c);
      });
      var Of, XC = u1;
      function h1() {
        var c = new Gi(3);
        return Gi != Float32Array && (c[0] = 0, c[1] = 0, c[2] = 0), c;
      }
      function f1(c, o, u) {
        var d = new Gi(3);
        return d[0] = c, d[1] = o, d[2] = u, d;
      }
      function em(c, o, u) {
        var d = o[0], y = o[1], x = o[2], w = o[3];
        return c[0] = u[0] * d + u[4] * y + u[8] * x + u[12] * w, c[1] = u[1] * d + u[5] * y + u[9] * x + u[13] * w, c[2] = u[2] * d + u[6] * y + u[10] * x + u[14] * w, c[3] = u[3] * d + u[7] * y + u[11] * x + u[15] * w, c;
      }
      function d1() {
        var c = new Gi(4);
        return Gi != Float32Array && (c[0] = 0, c[1] = 0, c[2] = 0), c[3] = 1, c;
      }
      function p1(c, o) {
        const u = em([], [c.x, c.y, 0, 1], o);
        return new Pe(u[0] / u[3], u[1] / u[3]);
      }
      h1(), Of = new Gi(4), Gi != Float32Array && (Of[0] = 0, Of[1] = 0, Of[2] = 0, Of[3] = 0), h1(), f1(1, 0, 0), f1(0, 1, 0), d1(), d1(), c1(), function() {
        var c;
        c = new Gi(2), Gi != Float32Array && (c[0] = 0, c[1] = 0);
      }();
      class m1 extends g_ {
      }
      Ct("HeatmapBucket", m1, { omit: ["layers"] });
      var ZC = { paint: new pi({ "heatmap-radius": new jt(Ce.paint_heatmap["heatmap-radius"]), "heatmap-weight": new jt(Ce.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Dt(Ce.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ua(Ce.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Dt(Ce.paint_heatmap["heatmap-opacity"]) }) };
      function x_(c, { width: o, height: u }, d, y) {
        if (y) {
          if (y instanceof Uint8ClampedArray)
            y = new Uint8Array(y.buffer);
          else if (y.length !== o * u * d)
            throw new RangeError(`mismatched image size. expected: ${y.length} but got: ${o * u * d}`);
        } else
          y = new Uint8Array(o * u * d);
        return c.width = o, c.height = u, c.data = y, c;
      }
      function g1(c, { width: o, height: u }, d) {
        if (o === c.width && u === c.height)
          return;
        const y = x_({}, { width: o, height: u }, d);
        b_(c, y, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(c.width, o), height: Math.min(c.height, u) }, d), c.width = o, c.height = u, c.data = y.data;
      }
      function b_(c, o, u, d, y, x) {
        if (y.width === 0 || y.height === 0)
          return o;
        if (y.width > c.width || y.height > c.height || u.x > c.width - y.width || u.y > c.height - y.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (y.width > o.width || y.height > o.height || d.x > o.width - y.width || d.y > o.height - y.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const w = c.data, C = o.data;
        if (w === C)
          throw new Error("srcData equals dstData, so image is already copied");
        for (let I = 0; I < y.height; I++) {
          const R = ((u.y + I) * c.width + u.x) * x, N = ((d.y + I) * o.width + d.x) * x;
          for (let z = 0; z < y.width * x; z++)
            C[N + z] = w[R + z];
        }
        return o;
      }
      class Rf {
        constructor(o, u) {
          x_(this, o, 1, u);
        }
        resize(o) {
          g1(this, o, 1);
        }
        clone() {
          return new Rf({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(o, u, d, y, x) {
          b_(o, u, d, y, x, 1);
        }
      }
      class Do {
        constructor(o, u) {
          x_(this, o, 4, u);
        }
        resize(o) {
          g1(this, o, 4);
        }
        replace(o, u) {
          u ? this.data.set(o) : this.data = o instanceof Uint8ClampedArray ? new Uint8Array(o.buffer) : o;
        }
        clone() {
          return new Do({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(o, u, d, y, x) {
          b_(o, u, d, y, x, 4);
        }
      }
      function y1(c) {
        const o = {}, u = c.resolution || 256, d = c.clips ? c.clips.length : 1, y = c.image || new Do({ width: u, height: d });
        if (Math.log(u) / Math.LN2 % 1 != 0)
          throw new Error(`width is not a power of 2 - ${u}`);
        const x = (w, C, I) => {
          o[c.evaluationKey] = I;
          const R = c.expression.evaluate(o);
          y.data[w + C + 0] = Math.floor(255 * R.r / R.a), y.data[w + C + 1] = Math.floor(255 * R.g / R.a), y.data[w + C + 2] = Math.floor(255 * R.b / R.a), y.data[w + C + 3] = Math.floor(255 * R.a);
        };
        if (c.clips)
          for (let w = 0, C = 0; w < d; ++w, C += 4 * u)
            for (let I = 0, R = 0; I < u; I++, R += 4) {
              const N = I / (u - 1), { start: z, end: V } = c.clips[w];
              x(C, R, z * (1 - N) + V * N);
            }
        else
          for (let w = 0, C = 0; w < u; w++, C += 4)
            x(0, C, w / (u - 1));
        return y;
      }
      Ct("AlphaImage", Rf), Ct("RGBAImage", Do);
      var HC = { paint: new pi({ "hillshade-illumination-direction": new Dt(Ce.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Dt(Ce.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Dt(Ce.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Dt(Ce.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Dt(Ce.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Dt(Ce.paint_hillshade["hillshade-accent-color"]) }) };
      const KC = jn([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: YC } = KC;
      var tm = { exports: {} };
      function rm(c, o, u) {
        u = u || 2;
        var d, y, x, w, C, I, R, N = o && o.length, z = N ? o[0] * u : c.length, V = _1(c, 0, z, u, !0), W = [];
        if (!V || V.next === V.prev)
          return W;
        if (N && (V = function(se, ae, Ee, De) {
          var we, Ae, qe, je = [];
          for (we = 0, Ae = ae.length; we < Ae; we++)
            (qe = _1(se, ae[we] * De, we < Ae - 1 ? ae[we + 1] * De : se.length, De, !1)) === qe.next && (qe.steiner = !0), je.push(oI(qe));
          for (je.sort(rI), we = 0; we < je.length; we++)
            Ee = nI(je[we], Ee);
          return Ee;
        }(c, o, V, u)), c.length > 80 * u) {
          d = x = c[0], y = w = c[1];
          for (var X = u; X < z; X += u)
            (C = c[X]) < d && (d = C), (I = c[X + 1]) < y && (y = I), C > x && (x = C), I > w && (w = I);
          R = (R = Math.max(x - d, w - y)) !== 0 ? 32767 / R : 0;
        }
        return Lf(V, W, u, d, y, R, 0), W;
      }
      function _1(c, o, u, d, y) {
        var x, w;
        if (y === T_(c, o, u, d) > 0)
          for (x = o; x < u; x += d)
            w = b1(x, c[x], c[x + 1], w);
        else
          for (x = u - d; x >= o; x -= d)
            w = b1(x, c[x], c[x + 1], w);
        return w && nm(w, w.next) && (kf(w), w = w.next), w;
      }
      function Mc(c, o) {
        if (!c)
          return c;
        o || (o = c);
        var u, d = c;
        do
          if (u = !1, d.steiner || !nm(d, d.next) && Fn(d.prev, d, d.next) !== 0)
            d = d.next;
          else {
            if (kf(d), (d = o = d.prev) === d.next)
              break;
            u = !0;
          }
        while (u || d !== o);
        return o;
      }
      function Lf(c, o, u, d, y, x, w) {
        if (c) {
          !w && x && function(N, z, V, W) {
            var X = N;
            do
              X.z === 0 && (X.z = w_(X.x, X.y, z, V, W)), X.prevZ = X.prev, X.nextZ = X.next, X = X.next;
            while (X !== N);
            X.prevZ.nextZ = null, X.prevZ = null, function(se) {
              var ae, Ee, De, we, Ae, qe, je, Et, Ot = 1;
              do {
                for (Ee = se, se = null, Ae = null, qe = 0; Ee; ) {
                  for (qe++, De = Ee, je = 0, ae = 0; ae < Ot && (je++, De = De.nextZ); ae++)
                    ;
                  for (Et = Ot; je > 0 || Et > 0 && De; )
                    je !== 0 && (Et === 0 || !De || Ee.z <= De.z) ? (we = Ee, Ee = Ee.nextZ, je--) : (we = De, De = De.nextZ, Et--), Ae ? Ae.nextZ = we : se = we, we.prevZ = Ae, Ae = we;
                  Ee = De;
                }
                Ae.nextZ = null, Ot *= 2;
              } while (qe > 1);
            }(X);
          }(c, d, y, x);
          for (var C, I, R = c; c.prev !== c.next; )
            if (C = c.prev, I = c.next, x ? QC(c, d, y, x) : JC(c))
              o.push(C.i / u | 0), o.push(c.i / u | 0), o.push(I.i / u | 0), kf(c), c = I.next, R = I.next;
            else if ((c = I) === R) {
              w ? w === 1 ? Lf(c = eI(Mc(c), o, u), o, u, d, y, x, 2) : w === 2 && tI(c, o, u, d, y, x) : Lf(Mc(c), o, u, d, y, x, 1);
              break;
            }
        }
      }
      function JC(c) {
        var o = c.prev, u = c, d = c.next;
        if (Fn(o, u, d) >= 0)
          return !1;
        for (var y = o.x, x = u.x, w = d.x, C = o.y, I = u.y, R = d.y, N = y < x ? y < w ? y : w : x < w ? x : w, z = C < I ? C < R ? C : R : I < R ? I : R, V = y > x ? y > w ? y : w : x > w ? x : w, W = C > I ? C > R ? C : R : I > R ? I : R, X = d.next; X !== o; ) {
          if (X.x >= N && X.x <= V && X.y >= z && X.y <= W && $u(y, C, x, I, w, R, X.x, X.y) && Fn(X.prev, X, X.next) >= 0)
            return !1;
          X = X.next;
        }
        return !0;
      }
      function QC(c, o, u, d) {
        var y = c.prev, x = c, w = c.next;
        if (Fn(y, x, w) >= 0)
          return !1;
        for (var C = y.x, I = x.x, R = w.x, N = y.y, z = x.y, V = w.y, W = C < I ? C < R ? C : R : I < R ? I : R, X = N < z ? N < V ? N : V : z < V ? z : V, se = C > I ? C > R ? C : R : I > R ? I : R, ae = N > z ? N > V ? N : V : z > V ? z : V, Ee = w_(W, X, o, u, d), De = w_(se, ae, o, u, d), we = c.prevZ, Ae = c.nextZ; we && we.z >= Ee && Ae && Ae.z <= De; ) {
          if (we.x >= W && we.x <= se && we.y >= X && we.y <= ae && we !== y && we !== w && $u(C, N, I, z, R, V, we.x, we.y) && Fn(we.prev, we, we.next) >= 0 || (we = we.prevZ, Ae.x >= W && Ae.x <= se && Ae.y >= X && Ae.y <= ae && Ae !== y && Ae !== w && $u(C, N, I, z, R, V, Ae.x, Ae.y) && Fn(Ae.prev, Ae, Ae.next) >= 0))
            return !1;
          Ae = Ae.nextZ;
        }
        for (; we && we.z >= Ee; ) {
          if (we.x >= W && we.x <= se && we.y >= X && we.y <= ae && we !== y && we !== w && $u(C, N, I, z, R, V, we.x, we.y) && Fn(we.prev, we, we.next) >= 0)
            return !1;
          we = we.prevZ;
        }
        for (; Ae && Ae.z <= De; ) {
          if (Ae.x >= W && Ae.x <= se && Ae.y >= X && Ae.y <= ae && Ae !== y && Ae !== w && $u(C, N, I, z, R, V, Ae.x, Ae.y) && Fn(Ae.prev, Ae, Ae.next) >= 0)
            return !1;
          Ae = Ae.nextZ;
        }
        return !0;
      }
      function eI(c, o, u) {
        var d = c;
        do {
          var y = d.prev, x = d.next.next;
          !nm(y, x) && v1(y, d, d.next, x) && Df(y, x) && Df(x, y) && (o.push(y.i / u | 0), o.push(d.i / u | 0), o.push(x.i / u | 0), kf(d), kf(d.next), d = c = x), d = d.next;
        } while (d !== c);
        return Mc(d);
      }
      function tI(c, o, u, d, y, x) {
        var w = c;
        do {
          for (var C = w.next.next; C !== w.prev; ) {
            if (w.i !== C.i && aI(w, C)) {
              var I = x1(w, C);
              return w = Mc(w, w.next), I = Mc(I, I.next), Lf(w, o, u, d, y, x, 0), void Lf(I, o, u, d, y, x, 0);
            }
            C = C.next;
          }
          w = w.next;
        } while (w !== c);
      }
      function rI(c, o) {
        return c.x - o.x;
      }
      function nI(c, o) {
        var u = function(y, x) {
          var w, C = x, I = y.x, R = y.y, N = -1 / 0;
          do {
            if (R <= C.y && R >= C.next.y && C.next.y !== C.y) {
              var z = C.x + (R - C.y) * (C.next.x - C.x) / (C.next.y - C.y);
              if (z <= I && z > N && (N = z, w = C.x < C.next.x ? C : C.next, z === I))
                return w;
            }
            C = C.next;
          } while (C !== x);
          if (!w)
            return null;
          var V, W = w, X = w.x, se = w.y, ae = 1 / 0;
          C = w;
          do
            I >= C.x && C.x >= X && I !== C.x && $u(R < se ? I : N, R, X, se, R < se ? N : I, R, C.x, C.y) && (V = Math.abs(R - C.y) / (I - C.x), Df(C, y) && (V < ae || V === ae && (C.x > w.x || C.x === w.x && iI(w, C))) && (w = C, ae = V)), C = C.next;
          while (C !== W);
          return w;
        }(c, o);
        if (!u)
          return o;
        var d = x1(u, c);
        return Mc(d, d.next), Mc(u, u.next);
      }
      function iI(c, o) {
        return Fn(c.prev, c, o.prev) < 0 && Fn(o.next, c, c.next) < 0;
      }
      function w_(c, o, u, d, y) {
        return (c = 1431655765 & ((c = 858993459 & ((c = 252645135 & ((c = 16711935 & ((c = (c - u) * y | 0) | c << 8)) | c << 4)) | c << 2)) | c << 1)) | (o = 1431655765 & ((o = 858993459 & ((o = 252645135 & ((o = 16711935 & ((o = (o - d) * y | 0) | o << 8)) | o << 4)) | o << 2)) | o << 1)) << 1;
      }
      function oI(c) {
        var o = c, u = c;
        do
          (o.x < u.x || o.x === u.x && o.y < u.y) && (u = o), o = o.next;
        while (o !== c);
        return u;
      }
      function $u(c, o, u, d, y, x, w, C) {
        return (y - w) * (o - C) >= (c - w) * (x - C) && (c - w) * (d - C) >= (u - w) * (o - C) && (u - w) * (x - C) >= (y - w) * (d - C);
      }
      function aI(c, o) {
        return c.next.i !== o.i && c.prev.i !== o.i && !function(u, d) {
          var y = u;
          do {
            if (y.i !== u.i && y.next.i !== u.i && y.i !== d.i && y.next.i !== d.i && v1(y, y.next, u, d))
              return !0;
            y = y.next;
          } while (y !== u);
          return !1;
        }(c, o) && (Df(c, o) && Df(o, c) && function(u, d) {
          var y = u, x = !1, w = (u.x + d.x) / 2, C = (u.y + d.y) / 2;
          do
            y.y > C != y.next.y > C && y.next.y !== y.y && w < (y.next.x - y.x) * (C - y.y) / (y.next.y - y.y) + y.x && (x = !x), y = y.next;
          while (y !== u);
          return x;
        }(c, o) && (Fn(c.prev, c, o.prev) || Fn(c, o.prev, o)) || nm(c, o) && Fn(c.prev, c, c.next) > 0 && Fn(o.prev, o, o.next) > 0);
      }
      function Fn(c, o, u) {
        return (o.y - c.y) * (u.x - o.x) - (o.x - c.x) * (u.y - o.y);
      }
      function nm(c, o) {
        return c.x === o.x && c.y === o.y;
      }
      function v1(c, o, u, d) {
        var y = om(Fn(c, o, u)), x = om(Fn(c, o, d)), w = om(Fn(u, d, c)), C = om(Fn(u, d, o));
        return y !== x && w !== C || !(y !== 0 || !im(c, u, o)) || !(x !== 0 || !im(c, d, o)) || !(w !== 0 || !im(u, c, d)) || !(C !== 0 || !im(u, o, d));
      }
      function im(c, o, u) {
        return o.x <= Math.max(c.x, u.x) && o.x >= Math.min(c.x, u.x) && o.y <= Math.max(c.y, u.y) && o.y >= Math.min(c.y, u.y);
      }
      function om(c) {
        return c > 0 ? 1 : c < 0 ? -1 : 0;
      }
      function Df(c, o) {
        return Fn(c.prev, c, c.next) < 0 ? Fn(c, o, c.next) >= 0 && Fn(c, c.prev, o) >= 0 : Fn(c, o, c.prev) < 0 || Fn(c, c.next, o) < 0;
      }
      function x1(c, o) {
        var u = new E_(c.i, c.x, c.y), d = new E_(o.i, o.x, o.y), y = c.next, x = o.prev;
        return c.next = o, o.prev = c, u.next = y, y.prev = u, d.next = u, u.prev = d, x.next = d, d.prev = x, d;
      }
      function b1(c, o, u, d) {
        var y = new E_(c, o, u);
        return d ? (y.next = d.next, y.prev = d, d.next.prev = y, d.next = y) : (y.prev = y, y.next = y), y;
      }
      function kf(c) {
        c.next.prev = c.prev, c.prev.next = c.next, c.prevZ && (c.prevZ.nextZ = c.nextZ), c.nextZ && (c.nextZ.prevZ = c.prevZ);
      }
      function E_(c, o, u) {
        this.i = c, this.x = o, this.y = u, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
      }
      function T_(c, o, u, d) {
        for (var y = 0, x = o, w = u - d; x < u; x += d)
          y += (c[w] - c[x]) * (c[x + 1] + c[w + 1]), w = x;
        return y;
      }
      function sI(c, o, u, d, y) {
        w1(c, o, u || 0, d || c.length - 1, y || lI);
      }
      function w1(c, o, u, d, y) {
        for (; d > u; ) {
          if (d - u > 600) {
            var x = d - u + 1, w = o - u + 1, C = Math.log(x), I = 0.5 * Math.exp(2 * C / 3), R = 0.5 * Math.sqrt(C * I * (x - I) / x) * (w - x / 2 < 0 ? -1 : 1);
            w1(c, o, Math.max(u, Math.floor(o - w * I / x + R)), Math.min(d, Math.floor(o + (x - w) * I / x + R)), y);
          }
          var N = c[o], z = u, V = d;
          for (Nf(c, u, o), y(c[d], N) > 0 && Nf(c, u, d); z < V; ) {
            for (Nf(c, z, V), z++, V--; y(c[z], N) < 0; )
              z++;
            for (; y(c[V], N) > 0; )
              V--;
          }
          y(c[u], N) === 0 ? Nf(c, u, V) : Nf(c, ++V, d), V <= o && (u = V + 1), o <= V && (d = V - 1);
        }
      }
      function Nf(c, o, u) {
        var d = c[o];
        c[o] = c[u], c[u] = d;
      }
      function lI(c, o) {
        return c < o ? -1 : c > o ? 1 : 0;
      }
      function S_(c, o) {
        const u = c.length;
        if (u <= 1)
          return [c];
        const d = [];
        let y, x;
        for (let w = 0; w < u; w++) {
          const C = ve(c[w]);
          C !== 0 && (c[w].area = Math.abs(C), x === void 0 && (x = C < 0), x === C < 0 ? (y && d.push(y), y = [c[w]]) : y.push(c[w]));
        }
        if (y && d.push(y), o > 1)
          for (let w = 0; w < d.length; w++)
            d[w].length <= o || (sI(d[w], o, 1, d[w].length - 1, cI), d[w] = d[w].slice(0, o));
        return d;
      }
      function cI(c, o) {
        return o.area - c.area;
      }
      function M_(c, o, u) {
        const d = u.patternDependencies;
        let y = !1;
        for (const x of o) {
          const w = x.paint.get(`${c}-pattern`);
          w.isConstant() || (y = !0);
          const C = w.constantOr(null);
          C && (y = !0, d[C.to] = !0, d[C.from] = !0);
        }
        return y;
      }
      function C_(c, o, u, d, y) {
        const x = y.patternDependencies;
        for (const w of o) {
          const C = w.paint.get(`${c}-pattern`).value;
          if (C.kind !== "constant") {
            let I = C.evaluate({ zoom: d - 1 }, u, {}, y.availableImages), R = C.evaluate({ zoom: d }, u, {}, y.availableImages), N = C.evaluate({ zoom: d + 1 }, u, {}, y.availableImages);
            I = I && I.name ? I.name : I, R = R && R.name ? R.name : R, N = N && N.name ? N.name : N, x[I] = !0, x[R] = !0, x[N] = !0, u.patterns[w.id] = { min: I, mid: R, max: N };
          }
        }
        return u;
      }
      tm.exports = rm, tm.exports.default = rm, rm.deviation = function(c, o, u, d) {
        var y = o && o.length, x = Math.abs(T_(c, 0, y ? o[0] * u : c.length, u));
        if (y)
          for (var w = 0, C = o.length; w < C; w++)
            x -= Math.abs(T_(c, o[w] * u, w < C - 1 ? o[w + 1] * u : c.length, u));
        var I = 0;
        for (w = 0; w < d.length; w += 3) {
          var R = d[w] * u, N = d[w + 1] * u, z = d[w + 2] * u;
          I += Math.abs((c[R] - c[z]) * (c[N + 1] - c[R + 1]) - (c[R] - c[N]) * (c[z + 1] - c[R + 1]));
        }
        return x === 0 && I === 0 ? 0 : Math.abs((I - x) / x);
      }, rm.flatten = function(c) {
        for (var o = c[0][0].length, u = { vertices: [], holes: [], dimensions: o }, d = 0, y = 0; y < c.length; y++) {
          for (var x = 0; x < c[y].length; x++)
            for (var w = 0; w < o; w++)
              u.vertices.push(c[y][x][w]);
          y > 0 && u.holes.push(d += c[y - 1].length);
        }
        return u;
      };
      class I_ {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((u) => u.id), this.index = o.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new $r(), this.indexArray = new Vi(), this.indexArray2 = new ha(), this.programConfigurations = new Ec(o.layers, o.zoom), this.segments = new hr(), this.segments2 = new hr(), this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
        }
        populate(o, u, d) {
          this.hasPattern = M_("fill", this.layers, u);
          const y = this.layers[0].layout.get("fill-sort-key"), x = !y.isConstant(), w = [];
          for (const { feature: C, id: I, index: R, sourceLayerIndex: N } of o) {
            const z = this.layers[0]._featureFilter.needGeometry, V = Sc(C, z);
            if (!this.layers[0]._featureFilter.filter(new xn(this.zoom), V, d))
              continue;
            const W = x ? y.evaluate(V, {}, d, u.availableImages) : void 0, X = { id: I, properties: C.properties, type: C.type, sourceLayerIndex: N, index: R, geometry: z ? V.geometry : Tc(C), patterns: {}, sortKey: W };
            w.push(X);
          }
          x && w.sort((C, I) => C.sortKey - I.sortKey);
          for (const C of w) {
            const { geometry: I, index: R, sourceLayerIndex: N } = C;
            if (this.hasPattern) {
              const z = C_("fill", this.layers, C, this.zoom, u);
              this.patternFeatures.push(z);
            } else
              this.addFeature(C, I, R, d, {});
            u.featureIndex.insert(o[R].feature, I, R, N, this.index);
          }
        }
        update(o, u, d) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, u, this.stateDependentLayers, d);
        }
        addFeatures(o, u, d) {
          for (const y of this.patternFeatures)
            this.addFeature(y, y.geometry, y.index, u, d);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, YC), this.indexBuffer = o.createIndexBuffer(this.indexArray), this.indexBuffer2 = o.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(o, u, d, y, x) {
          for (const w of S_(u, 500)) {
            let C = 0;
            for (const W of w)
              C += W.length;
            const I = this.segments.prepareSegment(C, this.layoutVertexArray, this.indexArray), R = I.vertexLength, N = [], z = [];
            for (const W of w) {
              if (W.length === 0)
                continue;
              W !== w[0] && z.push(N.length / 2);
              const X = this.segments2.prepareSegment(W.length, this.layoutVertexArray, this.indexArray2), se = X.vertexLength;
              this.layoutVertexArray.emplaceBack(W[0].x, W[0].y), this.indexArray2.emplaceBack(se + W.length - 1, se), N.push(W[0].x), N.push(W[0].y);
              for (let ae = 1; ae < W.length; ae++)
                this.layoutVertexArray.emplaceBack(W[ae].x, W[ae].y), this.indexArray2.emplaceBack(se + ae - 1, se + ae), N.push(W[ae].x), N.push(W[ae].y);
              X.vertexLength += W.length, X.primitiveLength += W.length;
            }
            const V = tm.exports(N, z);
            for (let W = 0; W < V.length; W += 3)
              this.indexArray.emplaceBack(R + V[W], R + V[W + 1], R + V[W + 2]);
            I.vertexLength += C, I.primitiveLength += V.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, d, x, y);
        }
      }
      Ct("FillBucket", I_, { omit: ["layers", "patternFeatures"] });
      const uI = new pi({ "fill-sort-key": new jt(Ce.layout_fill["fill-sort-key"]) });
      var hI = { paint: new pi({ "fill-antialias": new Dt(Ce.paint_fill["fill-antialias"]), "fill-opacity": new jt(Ce.paint_fill["fill-opacity"]), "fill-color": new jt(Ce.paint_fill["fill-color"]), "fill-outline-color": new jt(Ce.paint_fill["fill-outline-color"]), "fill-translate": new Dt(Ce.paint_fill["fill-translate"]), "fill-translate-anchor": new Dt(Ce.paint_fill["fill-translate-anchor"]), "fill-pattern": new sl(Ce.paint_fill["fill-pattern"]) }), layout: uI };
      const fI = jn([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), dI = jn([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: pI } = fI;
      var ul = {}, mI = Pe, E1 = Vu;
      function Vu(c, o, u, d, y) {
        this.properties = {}, this.extent = u, this.type = 0, this._pbf = c, this._geometry = -1, this._keys = d, this._values = y, c.readFields(gI, this, o);
      }
      function gI(c, o, u) {
        c == 1 ? o.id = u.readVarint() : c == 2 ? function(d, y) {
          for (var x = d.readVarint() + d.pos; d.pos < x; ) {
            var w = y._keys[d.readVarint()], C = y._values[d.readVarint()];
            y.properties[w] = C;
          }
        }(u, o) : c == 3 ? o.type = u.readVarint() : c == 4 && (o._geometry = u.pos);
      }
      function yI(c) {
        for (var o, u, d = 0, y = 0, x = c.length, w = x - 1; y < x; w = y++)
          d += ((u = c[w]).x - (o = c[y]).x) * (o.y + u.y);
        return d;
      }
      Vu.types = ["Unknown", "Point", "LineString", "Polygon"], Vu.prototype.loadGeometry = function() {
        var c = this._pbf;
        c.pos = this._geometry;
        for (var o, u = c.readVarint() + c.pos, d = 1, y = 0, x = 0, w = 0, C = []; c.pos < u; ) {
          if (y <= 0) {
            var I = c.readVarint();
            d = 7 & I, y = I >> 3;
          }
          if (y--, d === 1 || d === 2)
            x += c.readSVarint(), w += c.readSVarint(), d === 1 && (o && C.push(o), o = []), o.push(new mI(x, w));
          else {
            if (d !== 7)
              throw new Error("unknown command " + d);
            o && o.push(o[0].clone());
          }
        }
        return o && C.push(o), C;
      }, Vu.prototype.bbox = function() {
        var c = this._pbf;
        c.pos = this._geometry;
        for (var o = c.readVarint() + c.pos, u = 1, d = 0, y = 0, x = 0, w = 1 / 0, C = -1 / 0, I = 1 / 0, R = -1 / 0; c.pos < o; ) {
          if (d <= 0) {
            var N = c.readVarint();
            u = 7 & N, d = N >> 3;
          }
          if (d--, u === 1 || u === 2)
            (y += c.readSVarint()) < w && (w = y), y > C && (C = y), (x += c.readSVarint()) < I && (I = x), x > R && (R = x);
          else if (u !== 7)
            throw new Error("unknown command " + u);
        }
        return [w, I, C, R];
      }, Vu.prototype.toGeoJSON = function(c, o, u) {
        var d, y, x = this.extent * Math.pow(2, u), w = this.extent * c, C = this.extent * o, I = this.loadGeometry(), R = Vu.types[this.type];
        function N(W) {
          for (var X = 0; X < W.length; X++) {
            var se = W[X];
            W[X] = [360 * (se.x + w) / x - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (se.y + C) / x) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var z = [];
            for (d = 0; d < I.length; d++)
              z[d] = I[d][0];
            N(I = z);
            break;
          case 2:
            for (d = 0; d < I.length; d++)
              N(I[d]);
            break;
          case 3:
            for (I = function(W) {
              var X = W.length;
              if (X <= 1)
                return [W];
              for (var se, ae, Ee = [], De = 0; De < X; De++) {
                var we = yI(W[De]);
                we !== 0 && (ae === void 0 && (ae = we < 0), ae === we < 0 ? (se && Ee.push(se), se = [W[De]]) : se.push(W[De]));
              }
              return se && Ee.push(se), Ee;
            }(I), d = 0; d < I.length; d++)
              for (y = 0; y < I[d].length; y++)
                N(I[d][y]);
        }
        I.length === 1 ? I = I[0] : R = "Multi" + R;
        var V = { type: "Feature", geometry: { type: R, coordinates: I }, properties: this.properties };
        return "id" in this && (V.id = this.id), V;
      };
      var _I = E1, T1 = S1;
      function S1(c, o) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = c, this._keys = [], this._values = [], this._features = [], c.readFields(vI, this, o), this.length = this._features.length;
      }
      function vI(c, o, u) {
        c === 15 ? o.version = u.readVarint() : c === 1 ? o.name = u.readString() : c === 5 ? o.extent = u.readVarint() : c === 2 ? o._features.push(u.pos) : c === 3 ? o._keys.push(u.readString()) : c === 4 && o._values.push(function(d) {
          for (var y = null, x = d.readVarint() + d.pos; d.pos < x; ) {
            var w = d.readVarint() >> 3;
            y = w === 1 ? d.readString() : w === 2 ? d.readFloat() : w === 3 ? d.readDouble() : w === 4 ? d.readVarint64() : w === 5 ? d.readVarint() : w === 6 ? d.readSVarint() : w === 7 ? d.readBoolean() : null;
          }
          return y;
        }(u));
      }
      S1.prototype.feature = function(c) {
        if (c < 0 || c >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[c];
        var o = this._pbf.readVarint() + this._pbf.pos;
        return new _I(this._pbf, o, this.extent, this._keys, this._values);
      };
      var xI = T1;
      function bI(c, o, u) {
        if (c === 3) {
          var d = new xI(u, u.readVarint() + u.pos);
          d.length && (o[d.name] = d);
        }
      }
      ul.VectorTile = function(c, o) {
        this.layers = c.readFields(bI, {}, o);
      }, ul.VectorTileFeature = E1, ul.VectorTileLayer = T1;
      const wI = ul.VectorTileFeature.types, P_ = Math.pow(2, 13);
      function Ff(c, o, u, d, y, x, w, C) {
        c.emplaceBack(o, u, 2 * Math.floor(d * P_) + w, y * P_ * 2, x * P_ * 2, Math.round(C));
      }
      class A_ {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((u) => u.id), this.index = o.index, this.hasPattern = !1, this.layoutVertexArray = new Tr(), this.centroidVertexArray = new zt(), this.indexArray = new Vi(), this.programConfigurations = new Ec(o.layers, o.zoom), this.segments = new hr(), this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
        }
        populate(o, u, d) {
          this.features = [], this.hasPattern = M_("fill-extrusion", this.layers, u);
          for (const { feature: y, id: x, index: w, sourceLayerIndex: C } of o) {
            const I = this.layers[0]._featureFilter.needGeometry, R = Sc(y, I);
            if (!this.layers[0]._featureFilter.filter(new xn(this.zoom), R, d))
              continue;
            const N = { id: x, sourceLayerIndex: C, index: w, geometry: I ? R.geometry : Tc(y), properties: y.properties, type: y.type, patterns: {} };
            this.hasPattern ? this.features.push(C_("fill-extrusion", this.layers, N, this.zoom, u)) : this.addFeature(N, N.geometry, w, d, {}), u.featureIndex.insert(y, N.geometry, w, C, this.index, !0);
          }
        }
        addFeatures(o, u, d) {
          for (const y of this.features) {
            const { geometry: x } = y;
            this.addFeature(y, x, y.index, u, d);
          }
        }
        update(o, u, d) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, u, this.stateDependentLayers, d);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, pI), this.centroidVertexBuffer = o.createVertexBuffer(this.centroidVertexArray, dI.members, !0), this.indexBuffer = o.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(o, u, d, y, x) {
          const w = { x: 0, y: 0, vertexCount: 0 };
          for (const C of S_(u, 500)) {
            let I = 0;
            for (const X of C)
              I += X.length;
            let R = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const X of C) {
              if (X.length === 0 || TI(X))
                continue;
              let se = 0;
              for (let ae = 0; ae < X.length; ae++) {
                const Ee = X[ae];
                if (ae >= 1) {
                  const De = X[ae - 1];
                  if (!EI(Ee, De)) {
                    R.vertexLength + 4 > hr.MAX_VERTEX_ARRAY_LENGTH && (R = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const we = Ee.sub(De)._perp()._unit(), Ae = De.dist(Ee);
                    se + Ae > 32768 && (se = 0), Ff(this.layoutVertexArray, Ee.x, Ee.y, we.x, we.y, 0, 0, se), Ff(this.layoutVertexArray, Ee.x, Ee.y, we.x, we.y, 0, 1, se), w.x += 2 * Ee.x, w.y += 2 * Ee.y, w.vertexCount += 2, se += Ae, Ff(this.layoutVertexArray, De.x, De.y, we.x, we.y, 0, 0, se), Ff(this.layoutVertexArray, De.x, De.y, we.x, we.y, 0, 1, se), w.x += 2 * De.x, w.y += 2 * De.y, w.vertexCount += 2;
                    const qe = R.vertexLength;
                    this.indexArray.emplaceBack(qe, qe + 2, qe + 1), this.indexArray.emplaceBack(qe + 1, qe + 2, qe + 3), R.vertexLength += 4, R.primitiveLength += 2;
                  }
                }
              }
            }
            if (R.vertexLength + I > hr.MAX_VERTEX_ARRAY_LENGTH && (R = this.segments.prepareSegment(I, this.layoutVertexArray, this.indexArray)), wI[o.type] !== "Polygon")
              continue;
            const N = [], z = [], V = R.vertexLength;
            for (const X of C)
              if (X.length !== 0) {
                X !== C[0] && z.push(N.length / 2);
                for (let se = 0; se < X.length; se++) {
                  const ae = X[se];
                  Ff(this.layoutVertexArray, ae.x, ae.y, 0, 0, 1, 1, 0), w.x += ae.x, w.y += ae.y, w.vertexCount += 1, N.push(ae.x), N.push(ae.y);
                }
              }
            const W = tm.exports(N, z);
            for (let X = 0; X < W.length; X += 3)
              this.indexArray.emplaceBack(V + W[X], V + W[X + 2], V + W[X + 1]);
            R.primitiveLength += W.length / 3, R.vertexLength += I;
          }
          for (let C = 0; C < w.vertexCount; C++)
            this.centroidVertexArray.emplaceBack(Math.floor(w.x / w.vertexCount), Math.floor(w.y / w.vertexCount));
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, d, x, y);
        }
      }
      function EI(c, o) {
        return c.x === o.x && (c.x < 0 || c.x > Jn) || c.y === o.y && (c.y < 0 || c.y > Jn);
      }
      function TI(c) {
        return c.every((o) => o.x < 0) || c.every((o) => o.x > Jn) || c.every((o) => o.y < 0) || c.every((o) => o.y > Jn);
      }
      Ct("FillExtrusionBucket", A_, { omit: ["layers", "features"] });
      var SI = { paint: new pi({ "fill-extrusion-opacity": new Dt(Ce["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new jt(Ce["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Dt(Ce["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Dt(Ce["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new sl(Ce["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new jt(Ce["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new jt(Ce["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Dt(Ce["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) };
      function zf(c, o) {
        return c.x * o.x + c.y * o.y;
      }
      function M1(c, o) {
        if (c.length === 1) {
          let u = 0;
          const d = o[u++];
          let y;
          for (; !y || d.equals(y); )
            if (y = o[u++], !y)
              return 1 / 0;
          for (; u < o.length; u++) {
            const x = o[u], w = c[0], C = y.sub(d), I = x.sub(d), R = w.sub(d), N = zf(C, C), z = zf(C, I), V = zf(I, I), W = zf(R, C), X = zf(R, I), se = N * V - z * z, ae = (V * W - z * X) / se, Ee = (N * X - z * W) / se, De = d.z * (1 - ae - Ee) + y.z * ae + x.z * Ee;
            if (isFinite(De))
              return De;
          }
          return 1 / 0;
        }
        {
          let u = 1 / 0;
          for (const d of o)
            u = Math.min(u, d.z);
          return u;
        }
      }
      const MI = jn([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: CI } = MI, II = jn([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: PI } = II, AI = ul.VectorTileFeature.types, OI = Math.cos(Math.PI / 180 * 37.5), C1 = Math.pow(2, 14) / 0.5;
      class O_ {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((u) => u.id), this.index = o.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((u) => {
            this.gradients[u.id] = {};
          }), this.layoutVertexArray = new Pr(), this.layoutVertexArray2 = new Gr(), this.indexArray = new Vi(), this.programConfigurations = new Ec(o.layers, o.zoom), this.segments = new hr(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
        }
        populate(o, u, d) {
          this.hasPattern = M_("line", this.layers, u);
          const y = this.layers[0].layout.get("line-sort-key"), x = !y.isConstant(), w = [];
          for (const { feature: C, id: I, index: R, sourceLayerIndex: N } of o) {
            const z = this.layers[0]._featureFilter.needGeometry, V = Sc(C, z);
            if (!this.layers[0]._featureFilter.filter(new xn(this.zoom), V, d))
              continue;
            const W = x ? y.evaluate(V, {}, d) : void 0, X = { id: I, properties: C.properties, type: C.type, sourceLayerIndex: N, index: R, geometry: z ? V.geometry : Tc(C), patterns: {}, sortKey: W };
            w.push(X);
          }
          x && w.sort((C, I) => C.sortKey - I.sortKey);
          for (const C of w) {
            const { geometry: I, index: R, sourceLayerIndex: N } = C;
            if (this.hasPattern) {
              const z = C_("line", this.layers, C, this.zoom, u);
              this.patternFeatures.push(z);
            } else
              this.addFeature(C, I, R, d, {});
            u.featureIndex.insert(o[R].feature, I, R, N, this.index);
          }
        }
        update(o, u, d) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, u, this.stateDependentLayers, d);
        }
        addFeatures(o, u, d) {
          for (const y of this.patternFeatures)
            this.addFeature(y, y.geometry, y.index, u, d);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = o.createVertexBuffer(this.layoutVertexArray2, PI)), this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, CI), this.indexBuffer = o.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(o) {
          if (o.properties && Object.prototype.hasOwnProperty.call(o.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(o.properties, "mapbox_clip_end"))
            return { start: +o.properties.mapbox_clip_start, end: +o.properties.mapbox_clip_end };
        }
        addFeature(o, u, d, y, x) {
          const w = this.layers[0].layout, C = w.get("line-join").evaluate(o, {}), I = w.get("line-cap"), R = w.get("line-miter-limit"), N = w.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(o);
          for (const z of u)
            this.addLine(z, o, C, I, R, N);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, d, x, y);
        }
        addLine(o, u, d, y, x, w) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let Ee = 0; Ee < o.length - 1; Ee++)
              this.totalDistance += o[Ee].dist(o[Ee + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const C = AI[u.type] === "Polygon";
          let I = o.length;
          for (; I >= 2 && o[I - 1].equals(o[I - 2]); )
            I--;
          let R = 0;
          for (; R < I - 1 && o[R].equals(o[R + 1]); )
            R++;
          if (I < (C ? 3 : 2))
            return;
          d === "bevel" && (x = 1.05);
          const N = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, z = this.segments.prepareSegment(10 * I, this.layoutVertexArray, this.indexArray);
          let V, W, X, se, ae;
          this.e1 = this.e2 = -1, C && (V = o[I - 2], ae = o[R].sub(V)._unit()._perp());
          for (let Ee = R; Ee < I; Ee++) {
            if (X = Ee === I - 1 ? C ? o[R + 1] : void 0 : o[Ee + 1], X && o[Ee].equals(X))
              continue;
            ae && (se = ae), V && (W = V), V = o[Ee], ae = X ? X.sub(V)._unit()._perp() : se, se = se || ae;
            let De = se.add(ae);
            De.x === 0 && De.y === 0 || De._unit();
            const we = se.x * ae.x + se.y * ae.y, Ae = De.x * ae.x + De.y * ae.y, qe = Ae !== 0 ? 1 / Ae : 1 / 0, je = 2 * Math.sqrt(2 - 2 * Ae), Et = Ae < OI && W && X, Ot = se.x * ae.y - se.y * ae.x > 0;
            if (Et && Ee > R) {
              const ut = V.dist(W);
              if (ut > 2 * N) {
                const _t = V.sub(V.sub(W)._mult(N / ut)._round());
                this.updateDistance(W, _t), this.addCurrentVertex(_t, se, 0, 0, z), W = _t;
              }
            }
            const yt = W && X;
            let ft = yt ? d : C ? "butt" : y;
            if (yt && ft === "round" && (qe < w ? ft = "miter" : qe <= 2 && (ft = "fakeround")), ft === "miter" && qe > x && (ft = "bevel"), ft === "bevel" && (qe > 2 && (ft = "flipbevel"), qe < x && (ft = "miter")), W && this.updateDistance(W, V), ft === "miter")
              De._mult(qe), this.addCurrentVertex(V, De, 0, 0, z);
            else if (ft === "flipbevel") {
              if (qe > 100)
                De = ae.mult(-1);
              else {
                const ut = qe * se.add(ae).mag() / se.sub(ae).mag();
                De._perp()._mult(ut * (Ot ? -1 : 1));
              }
              this.addCurrentVertex(V, De, 0, 0, z), this.addCurrentVertex(V, De.mult(-1), 0, 0, z);
            } else if (ft === "bevel" || ft === "fakeround") {
              const ut = -Math.sqrt(qe * qe - 1), _t = Ot ? ut : 0, pt = Ot ? 0 : ut;
              if (W && this.addCurrentVertex(V, se, _t, pt, z), ft === "fakeround") {
                const et = Math.round(180 * je / Math.PI / 20);
                for (let Bt = 1; Bt < et; Bt++) {
                  let Nt = Bt / et;
                  if (Nt !== 0.5) {
                    const fn = Nt - 0.5;
                    Nt += Nt * fn * (Nt - 1) * ((1.0904 + we * (we * (3.55645 - 1.43519 * we) - 3.2452)) * fn * fn + (0.848013 + we * (0.215638 * we - 1.06021)));
                  }
                  const lr = ae.sub(se)._mult(Nt)._add(se)._unit()._mult(Ot ? -1 : 1);
                  this.addHalfVertex(V, lr.x, lr.y, !1, Ot, 0, z);
                }
              }
              X && this.addCurrentVertex(V, ae, -_t, -pt, z);
            } else if (ft === "butt")
              this.addCurrentVertex(V, De, 0, 0, z);
            else if (ft === "square") {
              const ut = W ? 1 : -1;
              this.addCurrentVertex(V, De, ut, ut, z);
            } else
              ft === "round" && (W && (this.addCurrentVertex(V, se, 0, 0, z), this.addCurrentVertex(V, se, 1, 1, z, !0)), X && (this.addCurrentVertex(V, ae, -1, -1, z, !0), this.addCurrentVertex(V, ae, 0, 0, z)));
            if (Et && Ee < I - 1) {
              const ut = V.dist(X);
              if (ut > 2 * N) {
                const _t = V.add(X.sub(V)._mult(N / ut)._round());
                this.updateDistance(V, _t), this.addCurrentVertex(_t, ae, 0, 0, z), V = _t;
              }
            }
          }
        }
        addCurrentVertex(o, u, d, y, x, w = !1) {
          const C = u.y * y - u.x, I = -u.y - u.x * y;
          this.addHalfVertex(o, u.x + u.y * d, u.y - u.x * d, w, !1, d, x), this.addHalfVertex(o, C, I, w, !0, -y, x), this.distance > C1 / 2 && this.totalDistance === 0 && (this.distance = 0, this.addCurrentVertex(o, u, d, y, x, w));
        }
        addHalfVertex({ x: o, y: u }, d, y, x, w, C, I) {
          const R = 0.5 * (this.lineClips ? this.scaledDistance * (C1 - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((o << 1) + (x ? 1 : 0), (u << 1) + (w ? 1 : 0), Math.round(63 * d) + 128, Math.round(63 * y) + 128, 1 + (C === 0 ? 0 : C < 0 ? -1 : 1) | (63 & R) << 2, R >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const N = I.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, N), I.primitiveLength++), w ? this.e2 = N : this.e1 = N;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(o, u) {
          this.distance += o.dist(u), this.updateScaledDistance();
        }
      }
      Ct("LineBucket", O_, { omit: ["layers", "patternFeatures"] });
      const RI = new pi({ "line-cap": new Dt(Ce.layout_line["line-cap"]), "line-join": new jt(Ce.layout_line["line-join"]), "line-miter-limit": new Dt(Ce.layout_line["line-miter-limit"]), "line-round-limit": new Dt(Ce.layout_line["line-round-limit"]), "line-sort-key": new jt(Ce.layout_line["line-sort-key"]) });
      var I1 = { paint: new pi({ "line-opacity": new jt(Ce.paint_line["line-opacity"]), "line-color": new jt(Ce.paint_line["line-color"]), "line-translate": new Dt(Ce.paint_line["line-translate"]), "line-translate-anchor": new Dt(Ce.paint_line["line-translate-anchor"]), "line-width": new jt(Ce.paint_line["line-width"]), "line-gap-width": new jt(Ce.paint_line["line-gap-width"]), "line-offset": new jt(Ce.paint_line["line-offset"]), "line-blur": new jt(Ce.paint_line["line-blur"]), "line-dasharray": new Sf(Ce.paint_line["line-dasharray"]), "line-pattern": new sl(Ce.paint_line["line-pattern"]), "line-gradient": new Ua(Ce.paint_line["line-gradient"]) }), layout: RI };
      const P1 = new class extends jt {
        possiblyEvaluate(c, o) {
          return o = new xn(Math.floor(o.zoom), { now: o.now, fadeDuration: o.fadeDuration, zoomHistory: o.zoomHistory, transition: o.transition }), super.possiblyEvaluate(c, o);
        }
        evaluate(c, o, u, d) {
          return o = L({}, o, { zoom: Math.floor(o.zoom) }), super.evaluate(c, o, u, d);
        }
      }(I1.paint.properties["line-width"].specification);
      function A1(c, o) {
        return o > 0 ? o + 2 * c : c;
      }
      P1.useIntegerZoom = !0;
      const LI = jn([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), DI = jn([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      jn([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const kI = jn([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
      jn([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const O1 = jn([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), NI = jn([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function FI(c, o, u) {
        return c.sections.forEach((d) => {
          d.text = function(y, x, w) {
            const C = x.layout.get("text-transform").evaluate(w, {});
            return C === "uppercase" ? y = y.toLocaleUpperCase() : C === "lowercase" && (y = y.toLocaleLowerCase()), yo.applyArabicShaping && (y = yo.applyArabicShaping(y)), y;
          }(d.text, o, u);
        }), c;
      }
      jn([{ name: "triangle", components: 3, type: "Uint16" }]), jn([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), jn([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), jn([{ type: "Float32", name: "offsetX" }]), jn([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
      const Bf = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
      var mi = 24, R_ = Zr, R1 = function(c, o, u, d, y) {
        var x, w, C = 8 * y - d - 1, I = (1 << C) - 1, R = I >> 1, N = -7, z = u ? y - 1 : 0, V = u ? -1 : 1, W = c[o + z];
        for (z += V, x = W & (1 << -N) - 1, W >>= -N, N += C; N > 0; x = 256 * x + c[o + z], z += V, N -= 8)
          ;
        for (w = x & (1 << -N) - 1, x >>= -N, N += d; N > 0; w = 256 * w + c[o + z], z += V, N -= 8)
          ;
        if (x === 0)
          x = 1 - R;
        else {
          if (x === I)
            return w ? NaN : 1 / 0 * (W ? -1 : 1);
          w += Math.pow(2, d), x -= R;
        }
        return (W ? -1 : 1) * w * Math.pow(2, x - d);
      }, L1 = function(c, o, u, d, y, x) {
        var w, C, I, R = 8 * x - y - 1, N = (1 << R) - 1, z = N >> 1, V = y === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, W = d ? 0 : x - 1, X = d ? 1 : -1, se = o < 0 || o === 0 && 1 / o < 0 ? 1 : 0;
        for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (C = isNaN(o) ? 1 : 0, w = N) : (w = Math.floor(Math.log(o) / Math.LN2), o * (I = Math.pow(2, -w)) < 1 && (w--, I *= 2), (o += w + z >= 1 ? V / I : V * Math.pow(2, 1 - z)) * I >= 2 && (w++, I /= 2), w + z >= N ? (C = 0, w = N) : w + z >= 1 ? (C = (o * I - 1) * Math.pow(2, y), w += z) : (C = o * Math.pow(2, z - 1) * Math.pow(2, y), w = 0)); y >= 8; c[u + W] = 255 & C, W += X, C /= 256, y -= 8)
          ;
        for (w = w << y | C, R += y; R > 0; c[u + W] = 255 & w, W += X, w /= 256, R -= 8)
          ;
        c[u + W - X] |= 128 * se;
      };
      function Zr(c) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(c) ? c : new Uint8Array(c || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      Zr.Varint = 0, Zr.Fixed64 = 1, Zr.Bytes = 2, Zr.Fixed32 = 5;
      var hl, L_ = 4294967296, D1 = 1 / L_, k1 = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
      function Es(c) {
        return c.type === Zr.Bytes ? c.readVarint() + c.pos : c.pos + 1;
      }
      function ju(c, o, u) {
        return u ? 4294967296 * o + (c >>> 0) : 4294967296 * (o >>> 0) + (c >>> 0);
      }
      function N1(c, o, u) {
        var d = o <= 16383 ? 1 : o <= 2097151 ? 2 : o <= 268435455 ? 3 : Math.floor(Math.log(o) / (7 * Math.LN2));
        u.realloc(d);
        for (var y = u.pos - 1; y >= c; y--)
          u.buf[y + d] = u.buf[y];
      }
      function zI(c, o) {
        for (var u = 0; u < c.length; u++)
          o.writeVarint(c[u]);
      }
      function BI(c, o) {
        for (var u = 0; u < c.length; u++)
          o.writeSVarint(c[u]);
      }
      function UI(c, o) {
        for (var u = 0; u < c.length; u++)
          o.writeFloat(c[u]);
      }
      function $I(c, o) {
        for (var u = 0; u < c.length; u++)
          o.writeDouble(c[u]);
      }
      function VI(c, o) {
        for (var u = 0; u < c.length; u++)
          o.writeBoolean(c[u]);
      }
      function jI(c, o) {
        for (var u = 0; u < c.length; u++)
          o.writeFixed32(c[u]);
      }
      function GI(c, o) {
        for (var u = 0; u < c.length; u++)
          o.writeSFixed32(c[u]);
      }
      function qI(c, o) {
        for (var u = 0; u < c.length; u++)
          o.writeFixed64(c[u]);
      }
      function WI(c, o) {
        for (var u = 0; u < c.length; u++)
          o.writeSFixed64(c[u]);
      }
      function am(c, o) {
        return (c[o] | c[o + 1] << 8 | c[o + 2] << 16) + 16777216 * c[o + 3];
      }
      function Gu(c, o, u) {
        c[u] = o, c[u + 1] = o >>> 8, c[u + 2] = o >>> 16, c[u + 3] = o >>> 24;
      }
      function F1(c, o) {
        return (c[o] | c[o + 1] << 8 | c[o + 2] << 16) + (c[o + 3] << 24);
      }
      function XI(c, o, u) {
        c === 1 && u.readMessage(ZI, o);
      }
      function ZI(c, o, u) {
        if (c === 3) {
          const { id: d, bitmap: y, width: x, height: w, left: C, top: I, advance: R } = u.readMessage(HI, {});
          o.push({ id: d, bitmap: new Rf({ width: x + 6, height: w + 6 }, y), metrics: { width: x, height: w, left: C, top: I, advance: R } });
        }
      }
      function HI(c, o, u) {
        c === 1 ? o.id = u.readVarint() : c === 2 ? o.bitmap = u.readBytes() : c === 3 ? o.width = u.readVarint() : c === 4 ? o.height = u.readVarint() : c === 5 ? o.left = u.readSVarint() : c === 6 ? o.top = u.readSVarint() : c === 7 && (o.advance = u.readVarint());
      }
      function z1(c) {
        let o = 0, u = 0;
        for (const w of c)
          o += w.w * w.h, u = Math.max(u, w.w);
        c.sort((w, C) => C.h - w.h);
        const d = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(o / 0.95)), u), h: 1 / 0 }];
        let y = 0, x = 0;
        for (const w of c)
          for (let C = d.length - 1; C >= 0; C--) {
            const I = d[C];
            if (!(w.w > I.w || w.h > I.h)) {
              if (w.x = I.x, w.y = I.y, x = Math.max(x, w.y + w.h), y = Math.max(y, w.x + w.w), w.w === I.w && w.h === I.h) {
                const R = d.pop();
                C < d.length && (d[C] = R);
              } else
                w.h === I.h ? (I.x += w.w, I.w -= w.w) : w.w === I.w ? (I.y += w.h, I.h -= w.h) : (d.push({ x: I.x + w.w, y: I.y, w: I.w - w.w, h: w.h }), I.y += w.h, I.h -= w.h);
              break;
            }
          }
        return { w: y, h: x, fill: o / (y * x) || 0 };
      }
      Zr.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(c, o, u) {
        for (u = u || this.length; this.pos < u; ) {
          var d = this.readVarint(), y = d >> 3, x = this.pos;
          this.type = 7 & d, c(y, o, this), this.pos === x && this.skip(d);
        }
        return o;
      }, readMessage: function(c, o) {
        return this.readFields(c, o, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var c = am(this.buf, this.pos);
        return this.pos += 4, c;
      }, readSFixed32: function() {
        var c = F1(this.buf, this.pos);
        return this.pos += 4, c;
      }, readFixed64: function() {
        var c = am(this.buf, this.pos) + am(this.buf, this.pos + 4) * L_;
        return this.pos += 8, c;
      }, readSFixed64: function() {
        var c = am(this.buf, this.pos) + F1(this.buf, this.pos + 4) * L_;
        return this.pos += 8, c;
      }, readFloat: function() {
        var c = R1(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, c;
      }, readDouble: function() {
        var c = R1(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, c;
      }, readVarint: function(c) {
        var o, u, d = this.buf;
        return o = 127 & (u = d[this.pos++]), u < 128 ? o : (o |= (127 & (u = d[this.pos++])) << 7, u < 128 ? o : (o |= (127 & (u = d[this.pos++])) << 14, u < 128 ? o : (o |= (127 & (u = d[this.pos++])) << 21, u < 128 ? o : function(y, x, w) {
          var C, I, R = w.buf;
          if (C = (112 & (I = R[w.pos++])) >> 4, I < 128 || (C |= (127 & (I = R[w.pos++])) << 3, I < 128) || (C |= (127 & (I = R[w.pos++])) << 10, I < 128) || (C |= (127 & (I = R[w.pos++])) << 17, I < 128) || (C |= (127 & (I = R[w.pos++])) << 24, I < 128) || (C |= (1 & (I = R[w.pos++])) << 31, I < 128))
            return ju(y, C, x);
          throw new Error("Expected varint not more than 10 bytes");
        }(o |= (15 & (u = d[this.pos])) << 28, c, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var c = this.readVarint();
        return c % 2 == 1 ? (c + 1) / -2 : c / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var c = this.readVarint() + this.pos, o = this.pos;
        return this.pos = c, c - o >= 12 && k1 ? function(u, d, y) {
          return k1.decode(u.subarray(d, y));
        }(this.buf, o, c) : function(u, d, y) {
          for (var x = "", w = d; w < y; ) {
            var C, I, R, N = u[w], z = null, V = N > 239 ? 4 : N > 223 ? 3 : N > 191 ? 2 : 1;
            if (w + V > y)
              break;
            V === 1 ? N < 128 && (z = N) : V === 2 ? (192 & (C = u[w + 1])) == 128 && (z = (31 & N) << 6 | 63 & C) <= 127 && (z = null) : V === 3 ? (I = u[w + 2], (192 & (C = u[w + 1])) == 128 && (192 & I) == 128 && ((z = (15 & N) << 12 | (63 & C) << 6 | 63 & I) <= 2047 || z >= 55296 && z <= 57343) && (z = null)) : V === 4 && (I = u[w + 2], R = u[w + 3], (192 & (C = u[w + 1])) == 128 && (192 & I) == 128 && (192 & R) == 128 && ((z = (15 & N) << 18 | (63 & C) << 12 | (63 & I) << 6 | 63 & R) <= 65535 || z >= 1114112) && (z = null)), z === null ? (z = 65533, V = 1) : z > 65535 && (z -= 65536, x += String.fromCharCode(z >>> 10 & 1023 | 55296), z = 56320 | 1023 & z), x += String.fromCharCode(z), w += V;
          }
          return x;
        }(this.buf, o, c);
      }, readBytes: function() {
        var c = this.readVarint() + this.pos, o = this.buf.subarray(this.pos, c);
        return this.pos = c, o;
      }, readPackedVarint: function(c, o) {
        if (this.type !== Zr.Bytes)
          return c.push(this.readVarint(o));
        var u = Es(this);
        for (c = c || []; this.pos < u; )
          c.push(this.readVarint(o));
        return c;
      }, readPackedSVarint: function(c) {
        if (this.type !== Zr.Bytes)
          return c.push(this.readSVarint());
        var o = Es(this);
        for (c = c || []; this.pos < o; )
          c.push(this.readSVarint());
        return c;
      }, readPackedBoolean: function(c) {
        if (this.type !== Zr.Bytes)
          return c.push(this.readBoolean());
        var o = Es(this);
        for (c = c || []; this.pos < o; )
          c.push(this.readBoolean());
        return c;
      }, readPackedFloat: function(c) {
        if (this.type !== Zr.Bytes)
          return c.push(this.readFloat());
        var o = Es(this);
        for (c = c || []; this.pos < o; )
          c.push(this.readFloat());
        return c;
      }, readPackedDouble: function(c) {
        if (this.type !== Zr.Bytes)
          return c.push(this.readDouble());
        var o = Es(this);
        for (c = c || []; this.pos < o; )
          c.push(this.readDouble());
        return c;
      }, readPackedFixed32: function(c) {
        if (this.type !== Zr.Bytes)
          return c.push(this.readFixed32());
        var o = Es(this);
        for (c = c || []; this.pos < o; )
          c.push(this.readFixed32());
        return c;
      }, readPackedSFixed32: function(c) {
        if (this.type !== Zr.Bytes)
          return c.push(this.readSFixed32());
        var o = Es(this);
        for (c = c || []; this.pos < o; )
          c.push(this.readSFixed32());
        return c;
      }, readPackedFixed64: function(c) {
        if (this.type !== Zr.Bytes)
          return c.push(this.readFixed64());
        var o = Es(this);
        for (c = c || []; this.pos < o; )
          c.push(this.readFixed64());
        return c;
      }, readPackedSFixed64: function(c) {
        if (this.type !== Zr.Bytes)
          return c.push(this.readSFixed64());
        var o = Es(this);
        for (c = c || []; this.pos < o; )
          c.push(this.readSFixed64());
        return c;
      }, skip: function(c) {
        var o = 7 & c;
        if (o === Zr.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (o === Zr.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (o === Zr.Fixed32)
          this.pos += 4;
        else {
          if (o !== Zr.Fixed64)
            throw new Error("Unimplemented type: " + o);
          this.pos += 8;
        }
      }, writeTag: function(c, o) {
        this.writeVarint(c << 3 | o);
      }, realloc: function(c) {
        for (var o = this.length || 16; o < this.pos + c; )
          o *= 2;
        if (o !== this.length) {
          var u = new Uint8Array(o);
          u.set(this.buf), this.buf = u, this.length = o;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(c) {
        this.realloc(4), Gu(this.buf, c, this.pos), this.pos += 4;
      }, writeSFixed32: function(c) {
        this.realloc(4), Gu(this.buf, c, this.pos), this.pos += 4;
      }, writeFixed64: function(c) {
        this.realloc(8), Gu(this.buf, -1 & c, this.pos), Gu(this.buf, Math.floor(c * D1), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(c) {
        this.realloc(8), Gu(this.buf, -1 & c, this.pos), Gu(this.buf, Math.floor(c * D1), this.pos + 4), this.pos += 8;
      }, writeVarint: function(c) {
        (c = +c || 0) > 268435455 || c < 0 ? function(o, u) {
          var d, y;
          if (o >= 0 ? (d = o % 4294967296 | 0, y = o / 4294967296 | 0) : (y = ~(-o / 4294967296), 4294967295 ^ (d = ~(-o % 4294967296)) ? d = d + 1 | 0 : (d = 0, y = y + 1 | 0)), o >= 18446744073709552e3 || o < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          u.realloc(10), function(x, w, C) {
            C.buf[C.pos++] = 127 & x | 128, x >>>= 7, C.buf[C.pos++] = 127 & x | 128, x >>>= 7, C.buf[C.pos++] = 127 & x | 128, x >>>= 7, C.buf[C.pos++] = 127 & x | 128, C.buf[C.pos] = 127 & (x >>>= 7);
          }(d, 0, u), function(x, w) {
            var C = (7 & x) << 4;
            w.buf[w.pos++] |= C | ((x >>>= 3) ? 128 : 0), x && (w.buf[w.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (w.buf[w.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (w.buf[w.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (w.buf[w.pos++] = 127 & x | ((x >>>= 7) ? 128 : 0), x && (w.buf[w.pos++] = 127 & x)))));
          }(y, u);
        }(c, this) : (this.realloc(4), this.buf[this.pos++] = 127 & c | (c > 127 ? 128 : 0), c <= 127 || (this.buf[this.pos++] = 127 & (c >>>= 7) | (c > 127 ? 128 : 0), c <= 127 || (this.buf[this.pos++] = 127 & (c >>>= 7) | (c > 127 ? 128 : 0), c <= 127 || (this.buf[this.pos++] = c >>> 7 & 127))));
      }, writeSVarint: function(c) {
        this.writeVarint(c < 0 ? 2 * -c - 1 : 2 * c);
      }, writeBoolean: function(c) {
        this.writeVarint(Boolean(c));
      }, writeString: function(c) {
        c = String(c), this.realloc(4 * c.length), this.pos++;
        var o = this.pos;
        this.pos = function(d, y, x) {
          for (var w, C, I = 0; I < y.length; I++) {
            if ((w = y.charCodeAt(I)) > 55295 && w < 57344) {
              if (!C) {
                w > 56319 || I + 1 === y.length ? (d[x++] = 239, d[x++] = 191, d[x++] = 189) : C = w;
                continue;
              }
              if (w < 56320) {
                d[x++] = 239, d[x++] = 191, d[x++] = 189, C = w;
                continue;
              }
              w = C - 55296 << 10 | w - 56320 | 65536, C = null;
            } else
              C && (d[x++] = 239, d[x++] = 191, d[x++] = 189, C = null);
            w < 128 ? d[x++] = w : (w < 2048 ? d[x++] = w >> 6 | 192 : (w < 65536 ? d[x++] = w >> 12 | 224 : (d[x++] = w >> 18 | 240, d[x++] = w >> 12 & 63 | 128), d[x++] = w >> 6 & 63 | 128), d[x++] = 63 & w | 128);
          }
          return x;
        }(this.buf, c, this.pos);
        var u = this.pos - o;
        u >= 128 && N1(o, u, this), this.pos = o - 1, this.writeVarint(u), this.pos += u;
      }, writeFloat: function(c) {
        this.realloc(4), L1(this.buf, c, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(c) {
        this.realloc(8), L1(this.buf, c, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(c) {
        var o = c.length;
        this.writeVarint(o), this.realloc(o);
        for (var u = 0; u < o; u++)
          this.buf[this.pos++] = c[u];
      }, writeRawMessage: function(c, o) {
        this.pos++;
        var u = this.pos;
        c(o, this);
        var d = this.pos - u;
        d >= 128 && N1(u, d, this), this.pos = u - 1, this.writeVarint(d), this.pos += d;
      }, writeMessage: function(c, o, u) {
        this.writeTag(c, Zr.Bytes), this.writeRawMessage(o, u);
      }, writePackedVarint: function(c, o) {
        o.length && this.writeMessage(c, zI, o);
      }, writePackedSVarint: function(c, o) {
        o.length && this.writeMessage(c, BI, o);
      }, writePackedBoolean: function(c, o) {
        o.length && this.writeMessage(c, VI, o);
      }, writePackedFloat: function(c, o) {
        o.length && this.writeMessage(c, UI, o);
      }, writePackedDouble: function(c, o) {
        o.length && this.writeMessage(c, $I, o);
      }, writePackedFixed32: function(c, o) {
        o.length && this.writeMessage(c, jI, o);
      }, writePackedSFixed32: function(c, o) {
        o.length && this.writeMessage(c, GI, o);
      }, writePackedFixed64: function(c, o) {
        o.length && this.writeMessage(c, qI, o);
      }, writePackedSFixed64: function(c, o) {
        o.length && this.writeMessage(c, WI, o);
      }, writeBytesField: function(c, o) {
        this.writeTag(c, Zr.Bytes), this.writeBytes(o);
      }, writeFixed32Field: function(c, o) {
        this.writeTag(c, Zr.Fixed32), this.writeFixed32(o);
      }, writeSFixed32Field: function(c, o) {
        this.writeTag(c, Zr.Fixed32), this.writeSFixed32(o);
      }, writeFixed64Field: function(c, o) {
        this.writeTag(c, Zr.Fixed64), this.writeFixed64(o);
      }, writeSFixed64Field: function(c, o) {
        this.writeTag(c, Zr.Fixed64), this.writeSFixed64(o);
      }, writeVarintField: function(c, o) {
        this.writeTag(c, Zr.Varint), this.writeVarint(o);
      }, writeSVarintField: function(c, o) {
        this.writeTag(c, Zr.Varint), this.writeSVarint(o);
      }, writeStringField: function(c, o) {
        this.writeTag(c, Zr.Bytes), this.writeString(o);
      }, writeFloatField: function(c, o) {
        this.writeTag(c, Zr.Fixed32), this.writeFloat(o);
      }, writeDoubleField: function(c, o) {
        this.writeTag(c, Zr.Fixed64), this.writeDouble(o);
      }, writeBooleanField: function(c, o) {
        this.writeVarintField(c, Boolean(o));
      } };
      class D_ {
        constructor(o, { pixelRatio: u, version: d, stretchX: y, stretchY: x, content: w }) {
          this.paddedRect = o, this.pixelRatio = u, this.stretchX = y, this.stretchY = x, this.content = w, this.version = d;
        }
        get tl() {
          return [this.paddedRect.x + 1, this.paddedRect.y + 1];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
        }
      }
      class B1 {
        constructor(o, u) {
          const d = {}, y = {};
          this.haveRenderCallbacks = [];
          const x = [];
          this.addImages(o, d, x), this.addImages(u, y, x);
          const { w, h: C } = z1(x), I = new Do({ width: w || 1, height: C || 1 });
          for (const R in o) {
            const N = o[R], z = d[R].paddedRect;
            Do.copy(N.data, I, { x: 0, y: 0 }, { x: z.x + 1, y: z.y + 1 }, N.data);
          }
          for (const R in u) {
            const N = u[R], z = y[R].paddedRect, V = z.x + 1, W = z.y + 1, X = N.data.width, se = N.data.height;
            Do.copy(N.data, I, { x: 0, y: 0 }, { x: V, y: W }, N.data), Do.copy(N.data, I, { x: 0, y: se - 1 }, { x: V, y: W - 1 }, { width: X, height: 1 }), Do.copy(N.data, I, { x: 0, y: 0 }, { x: V, y: W + se }, { width: X, height: 1 }), Do.copy(N.data, I, { x: X - 1, y: 0 }, { x: V - 1, y: W }, { width: 1, height: se }), Do.copy(N.data, I, { x: 0, y: 0 }, { x: V + X, y: W }, { width: 1, height: se });
          }
          this.image = I, this.iconPositions = d, this.patternPositions = y;
        }
        addImages(o, u, d) {
          for (const y in o) {
            const x = o[y], w = { x: 0, y: 0, w: x.data.width + 2, h: x.data.height + 2 };
            d.push(w), u[y] = new D_(w, x), x.hasRenderCallback && this.haveRenderCallbacks.push(y);
          }
        }
        patchUpdatedImages(o, u) {
          o.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const d in o.updatedImages)
            this.patchUpdatedImage(this.iconPositions[d], o.getImage(d), u), this.patchUpdatedImage(this.patternPositions[d], o.getImage(d), u);
        }
        patchUpdatedImage(o, u, d) {
          if (!o || !u || o.version === u.version)
            return;
          o.version = u.version;
          const [y, x] = o.tl;
          d.update(u.data, void 0, { x: y, y: x });
        }
      }
      Ct("ImagePosition", D_), Ct("ImageAtlas", B1), s.WritingMode = void 0, (hl = s.WritingMode || (s.WritingMode = {}))[hl.none = 0] = "none", hl[hl.horizontal = 1] = "horizontal", hl[hl.vertical = 2] = "vertical", hl[hl.horizontalOnly = 3] = "horizontalOnly";
      const sm = -17;
      class Uf {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(o, u) {
          const d = new Uf();
          return d.scale = o || 1, d.fontStack = u, d;
        }
        static forImage(o) {
          const u = new Uf();
          return u.imageName = o, u;
        }
      }
      class qu {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(o, u) {
          const d = new qu();
          for (let y = 0; y < o.sections.length; y++) {
            const x = o.sections[y];
            x.image ? d.addImageSection(x) : d.addTextSection(x, u);
          }
          return d;
        }
        length() {
          return this.text.length;
        }
        getSection(o) {
          return this.sections[this.sectionIndex[o]];
        }
        getSectionIndex(o) {
          return this.sectionIndex[o];
        }
        getCharCode(o) {
          return this.text.charCodeAt(o);
        }
        verticalizePunctuation() {
          this.text = function(o) {
            let u = "";
            for (let d = 0; d < o.length; d++) {
              const y = o.charCodeAt(d + 1) || null, x = o.charCodeAt(d - 1) || null;
              u += y && $p(y) && !Bf[o[d + 1]] || x && $p(x) && !Bf[o[d - 1]] || !Bf[o[d]] ? o[d] : Bf[o[d]];
            }
            return u;
          }(this.text);
        }
        trim() {
          let o = 0;
          for (let d = 0; d < this.text.length && cm[this.text.charCodeAt(d)]; d++)
            o++;
          let u = this.text.length;
          for (let d = this.text.length - 1; d >= 0 && d >= o && cm[this.text.charCodeAt(d)]; d--)
            u--;
          this.text = this.text.substring(o, u), this.sectionIndex = this.sectionIndex.slice(o, u);
        }
        substring(o, u) {
          const d = new qu();
          return d.text = this.text.substring(o, u), d.sectionIndex = this.sectionIndex.slice(o, u), d.sections = this.sections, d;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((o, u) => Math.max(o, this.sections[u].scale), 0);
        }
        addTextSection(o, u) {
          this.text += o.text, this.sections.push(Uf.forText(o.scale, o.fontStack || u));
          const d = this.sections.length - 1;
          for (let y = 0; y < o.text.length; ++y)
            this.sectionIndex.push(d);
        }
        addImageSection(o) {
          const u = o.image ? o.image.name : "";
          if (u.length === 0)
            return void he("Can't add FormattedSection with an empty image.");
          const d = this.getNextImageSectionCharCode();
          d ? (this.text += String.fromCharCode(d), this.sections.push(Uf.forImage(u)), this.sectionIndex.push(this.sections.length - 1)) : he("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function lm(c, o, u, d, y, x, w, C, I, R, N, z, V, W, X, se) {
        const ae = qu.fromFeature(c, y);
        let Ee;
        z === s.WritingMode.vertical && ae.verticalizePunctuation();
        const { processBidirectionalText: De, processStyledBidirectionalText: we } = yo;
        if (De && ae.sections.length === 1) {
          Ee = [];
          const je = De(ae.toString(), k_(ae, R, x, o, d, W, X));
          for (const Et of je) {
            const Ot = new qu();
            Ot.text = Et, Ot.sections = ae.sections;
            for (let yt = 0; yt < Et.length; yt++)
              Ot.sectionIndex.push(0);
            Ee.push(Ot);
          }
        } else if (we) {
          Ee = [];
          const je = we(ae.text, ae.sectionIndex, k_(ae, R, x, o, d, W, X));
          for (const Et of je) {
            const Ot = new qu();
            Ot.text = Et[0], Ot.sectionIndex = Et[1], Ot.sections = ae.sections, Ee.push(Ot);
          }
        } else
          Ee = function(je, Et) {
            const Ot = [], yt = je.text;
            let ft = 0;
            for (const ut of Et)
              Ot.push(je.substring(ft, ut)), ft = ut;
            return ft < yt.length && Ot.push(je.substring(ft, yt.length)), Ot;
          }(ae, k_(ae, R, x, o, d, W, X));
        const Ae = [], qe = { positionedLines: Ae, text: ae.toString(), top: N[1], bottom: N[1], left: N[0], right: N[0], writingMode: z, iconsInText: !1, verticalizable: !1 };
        return function(je, Et, Ot, yt, ft, ut, _t, pt, et, Bt, Nt, lr) {
          let fn = 0, wn = sm, Qn = 0, No = 0;
          const wi = pt === "right" ? 1 : pt === "left" ? 0 : 0.5;
          let Gn = 0;
          for (const qn of ft) {
            qn.trim();
            const Ti = qn.getMaxScale(), Di = (Ti - 1) * mi, qi = { positionedGlyphs: [], lineOffset: 0 };
            je.positionedLines[Gn] = qi;
            const no = qi.positionedGlyphs;
            let io = 0;
            if (!qn.length()) {
              wn += ut, ++Gn;
              continue;
            }
            for (let ci = 0; ci < qn.length(); ci++) {
              const dr = qn.getSection(ci), xo = qn.getSectionIndex(ci), Si = qn.getCharCode(ci);
              let ki = 0, Ko = null, da = null, pa = null, Ss = mi;
              const Yo = !(et === s.WritingMode.horizontal || !Nt && !vf(Si) || Nt && (cm[Si] || (li = Si, gt.Arabic(li) || gt["Arabic Supplement"](li) || gt["Arabic Extended-A"](li) || gt["Arabic Presentation Forms-A"](li) || gt["Arabic Presentation Forms-B"](li))));
              if (dr.imageName) {
                const Fo = yt[dr.imageName];
                if (!Fo)
                  continue;
                pa = dr.imageName, je.iconsInText = je.iconsInText || !0, da = Fo.paddedRect;
                const oo = Fo.displaySize;
                dr.scale = dr.scale * mi / lr, Ko = { width: oo[0], height: oo[1], left: 1, top: -3, advance: Yo ? oo[1] : oo[0] }, ki = Di + (mi - oo[1] * dr.scale), Ss = Ko.advance;
                const Ms = Yo ? oo[0] * dr.scale - mi * Ti : oo[1] * dr.scale - mi * Ti;
                Ms > 0 && Ms > io && (io = Ms);
              } else {
                const Fo = Ot[dr.fontStack], oo = Fo && Fo[Si];
                if (oo && oo.rect)
                  da = oo.rect, Ko = oo.metrics;
                else {
                  const Ms = Et[dr.fontStack], jf = Ms && Ms[Si];
                  if (!jf)
                    continue;
                  Ko = jf.metrics;
                }
                ki = (Ti - dr.scale) * mi;
              }
              Yo ? (je.verticalizable = !0, no.push({ glyph: Si, imageName: pa, x: fn, y: wn + ki, vertical: Yo, scale: dr.scale, fontStack: dr.fontStack, sectionIndex: xo, metrics: Ko, rect: da }), fn += Ss * dr.scale + Bt) : (no.push({ glyph: Si, imageName: pa, x: fn, y: wn + ki, vertical: Yo, scale: dr.scale, fontStack: dr.fontStack, sectionIndex: xo, metrics: Ko, rect: da }), fn += Ko.advance * dr.scale + Bt);
            }
            no.length !== 0 && (Qn = Math.max(fn - Bt, Qn), JI(no, 0, no.length - 1, wi, io)), fn = 0;
            const Sn = ut * Ti + io;
            qi.lineOffset = Math.max(io, Di), wn += Sn, No = Math.max(Sn, No), ++Gn;
          }
          var li;
          const Ei = wn - sm, { horizontalAlign: Li, verticalAlign: ro } = N_(_t);
          (function(qn, Ti, Di, qi, no, io, Sn, ci, dr) {
            const xo = (Ti - Di) * no;
            let Si = 0;
            Si = io !== Sn ? -ci * qi - sm : (-qi * dr + 0.5) * Sn;
            for (const ki of qn)
              for (const Ko of ki.positionedGlyphs)
                Ko.x += xo, Ko.y += Si;
          })(je.positionedLines, wi, Li, ro, Qn, No, ut, Ei, ft.length), je.top += -ro * Ei, je.bottom = je.top + Ei, je.left += -Li * Qn, je.right = je.left + Qn;
        }(qe, o, u, d, Ee, w, C, I, z, R, V, se), !function(je) {
          for (const Et of je)
            if (Et.positionedGlyphs.length !== 0)
              return !1;
          return !0;
        }(Ae) && qe;
      }
      const cm = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, KI = { 10: !0, 32: !0, 38: !0, 40: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 };
      function U1(c, o, u, d, y, x) {
        if (o.imageName) {
          const w = d[o.imageName];
          return w ? w.displaySize[0] * o.scale * mi / x + y : 0;
        }
        {
          const w = u[o.fontStack], C = w && w[c];
          return C ? C.metrics.advance * o.scale + y : 0;
        }
      }
      function $1(c, o, u, d) {
        const y = Math.pow(c - o, 2);
        return d ? c < o ? y / 2 : 2 * y : y + Math.abs(u) * u;
      }
      function YI(c, o, u) {
        let d = 0;
        return c === 10 && (d -= 1e4), u && (d += 150), c !== 40 && c !== 65288 || (d += 50), o !== 41 && o !== 65289 || (d += 50), d;
      }
      function V1(c, o, u, d, y, x) {
        let w = null, C = $1(o, u, y, x);
        for (const I of d) {
          const R = $1(o - I.x, u, y, x) + I.badness;
          R <= C && (w = I, C = R);
        }
        return { index: c, x: o, priorBreak: w, badness: C };
      }
      function j1(c) {
        return c ? j1(c.priorBreak).concat(c.index) : [];
      }
      function k_(c, o, u, d, y, x, w) {
        if (x !== "point")
          return [];
        if (!c)
          return [];
        const C = [], I = function(V, W, X, se, ae, Ee) {
          let De = 0;
          for (let we = 0; we < V.length(); we++) {
            const Ae = V.getSection(we);
            De += U1(V.getCharCode(we), Ae, se, ae, W, Ee);
          }
          return De / Math.max(1, Math.ceil(De / X));
        }(c, o, u, d, y, w), R = c.text.indexOf("\u200B") >= 0;
        let N = 0;
        for (let V = 0; V < c.length(); V++) {
          const W = c.getSection(V), X = c.getCharCode(V);
          if (cm[X] || (N += U1(X, W, d, y, o, w)), V < c.length() - 1) {
            const se = !((z = X) < 11904 || !(gt["Bopomofo Extended"](z) || gt.Bopomofo(z) || gt["CJK Compatibility Forms"](z) || gt["CJK Compatibility Ideographs"](z) || gt["CJK Compatibility"](z) || gt["CJK Radicals Supplement"](z) || gt["CJK Strokes"](z) || gt["CJK Symbols and Punctuation"](z) || gt["CJK Unified Ideographs Extension A"](z) || gt["CJK Unified Ideographs"](z) || gt["Enclosed CJK Letters and Months"](z) || gt["Halfwidth and Fullwidth Forms"](z) || gt.Hiragana(z) || gt["Ideographic Description Characters"](z) || gt["Kangxi Radicals"](z) || gt["Katakana Phonetic Extensions"](z) || gt.Katakana(z) || gt["Vertical Forms"](z) || gt["Yi Radicals"](z) || gt["Yi Syllables"](z)));
            (KI[X] || se || W.imageName) && C.push(V1(V + 1, N, I, C, YI(X, c.getCharCode(V + 1), se && R), !1));
          }
        }
        var z;
        return j1(V1(c.length(), N, I, C, 0, !0));
      }
      function N_(c) {
        let o = 0.5, u = 0.5;
        switch (c) {
          case "right":
          case "top-right":
          case "bottom-right":
            o = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            o = 0;
        }
        switch (c) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            u = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            u = 0;
        }
        return { horizontalAlign: o, verticalAlign: u };
      }
      function JI(c, o, u, d, y) {
        if (!d && !y)
          return;
        const x = c[u], w = (c[u].x + x.metrics.advance * x.scale) * d;
        for (let C = o; C <= u; C++)
          c[C].x -= w, c[C].y += y;
      }
      function QI(c, o, u) {
        const { horizontalAlign: d, verticalAlign: y } = N_(u), x = o[0] - c.displaySize[0] * d, w = o[1] - c.displaySize[1] * y;
        return { image: c, top: w, bottom: w + c.displaySize[1], left: x, right: x + c.displaySize[0] };
      }
      function G1(c, o, u, d, y, x) {
        const w = c.image;
        let C;
        if (w.content) {
          const ae = w.content, Ee = w.pixelRatio || 1;
          C = [ae[0] / Ee, ae[1] / Ee, w.displaySize[0] - ae[2] / Ee, w.displaySize[1] - ae[3] / Ee];
        }
        const I = o.left * x, R = o.right * x;
        let N, z, V, W;
        u === "width" || u === "both" ? (W = y[0] + I - d[3], z = y[0] + R + d[1]) : (W = y[0] + (I + R - w.displaySize[0]) / 2, z = W + w.displaySize[0]);
        const X = o.top * x, se = o.bottom * x;
        return u === "height" || u === "both" ? (N = y[1] + X - d[0], V = y[1] + se + d[2]) : (N = y[1] + (X + se - w.displaySize[1]) / 2, V = N + w.displaySize[1]), { image: w, top: N, right: z, bottom: V, left: W, collisionPadding: C };
      }
      const Ts = 128;
      function q1(c, o) {
        const { expression: u } = o;
        if (u.kind === "constant")
          return { kind: "constant", layoutSize: u.evaluate(new xn(c + 1)) };
        if (u.kind === "source")
          return { kind: "source" };
        {
          const { zoomStops: d, interpolationType: y } = u;
          let x = 0;
          for (; x < d.length && d[x] <= c; )
            x++;
          x = Math.max(0, x - 1);
          let w = x;
          for (; w < d.length && d[w] < c + 1; )
            w++;
          w = Math.min(d.length - 1, w);
          const C = d[x], I = d[w];
          return u.kind === "composite" ? { kind: "composite", minZoom: C, maxZoom: I, interpolationType: y } : { kind: "camera", minZoom: C, maxZoom: I, minSize: u.evaluate(new xn(C)), maxSize: u.evaluate(new xn(I)), interpolationType: y };
        }
      }
      class fl extends Pe {
        constructor(o, u, d, y) {
          super(o, u), this.angle = d, y !== void 0 && (this.segment = y);
        }
        clone() {
          return new fl(this.x, this.y, this.angle, this.segment);
        }
      }
      function W1(c, o, u, d, y) {
        if (o.segment === void 0)
          return !0;
        let x = o, w = o.segment + 1, C = 0;
        for (; C > -u / 2; ) {
          if (w--, w < 0)
            return !1;
          C -= c[w].dist(x), x = c[w];
        }
        C += c[w].dist(c[w + 1]), w++;
        const I = [];
        let R = 0;
        for (; C < u / 2; ) {
          const N = c[w], z = c[w + 1];
          if (!z)
            return !1;
          let V = c[w - 1].angleTo(N) - N.angleTo(z);
          for (V = Math.abs((V + 3 * Math.PI) % (2 * Math.PI) - Math.PI), I.push({ distance: C, angleDelta: V }), R += V; C - I[0].distance > d; )
            R -= I.shift().angleDelta;
          if (R > y)
            return !1;
          w++, C += N.dist(z);
        }
        return !0;
      }
      function X1(c) {
        let o = 0;
        for (let u = 0; u < c.length - 1; u++)
          o += c[u].dist(c[u + 1]);
        return o;
      }
      function Z1(c, o, u) {
        return c ? 0.6 * o * u : 0;
      }
      function H1(c, o) {
        return Math.max(c ? c.right - c.left : 0, o ? o.right - o.left : 0);
      }
      function eP(c, o, u, d, y, x) {
        const w = Z1(u, y, x), C = H1(u, d) * x;
        let I = 0;
        const R = X1(c) / 2;
        for (let N = 0; N < c.length - 1; N++) {
          const z = c[N], V = c[N + 1], W = z.dist(V);
          if (I + W > R) {
            const X = (R - I) / W, se = _n(z.x, V.x, X), ae = _n(z.y, V.y, X), Ee = new fl(se, ae, V.angleTo(z), N);
            return Ee._round(), !w || W1(c, Ee, C, w, o) ? Ee : void 0;
          }
          I += W;
        }
      }
      function tP(c, o, u, d, y, x, w, C, I) {
        const R = Z1(d, x, w), N = H1(d, y), z = N * w, V = c[0].x === 0 || c[0].x === I || c[0].y === 0 || c[0].y === I;
        return o - z < o / 4 && (o = z + o / 4), K1(c, V ? o / 2 * C % o : (N / 2 + 2 * x) * w * C % o, o, R, u, z, V, !1, I);
      }
      function K1(c, o, u, d, y, x, w, C, I) {
        const R = x / 2, N = X1(c);
        let z = 0, V = o - u, W = [];
        for (let X = 0; X < c.length - 1; X++) {
          const se = c[X], ae = c[X + 1], Ee = se.dist(ae), De = ae.angleTo(se);
          for (; V + u < z + Ee; ) {
            V += u;
            const we = (V - z) / Ee, Ae = _n(se.x, ae.x, we), qe = _n(se.y, ae.y, we);
            if (Ae >= 0 && Ae < I && qe >= 0 && qe < I && V - R >= 0 && V + R <= N) {
              const je = new fl(Ae, qe, De, X);
              je._round(), d && !W1(c, je, x, d, y) || W.push(je);
            }
          }
          z += Ee;
        }
        return C || W.length || w || (W = K1(c, z / 2, u, d, y, x, w, !0, I)), W;
      }
      function Y1(c, o, u, d, y) {
        const x = [];
        for (let w = 0; w < c.length; w++) {
          const C = c[w];
          let I;
          for (let R = 0; R < C.length - 1; R++) {
            let N = C[R], z = C[R + 1];
            N.x < o && z.x < o || (N.x < o ? N = new Pe(o, N.y + (o - N.x) / (z.x - N.x) * (z.y - N.y))._round() : z.x < o && (z = new Pe(o, N.y + (o - N.x) / (z.x - N.x) * (z.y - N.y))._round()), N.y < u && z.y < u || (N.y < u ? N = new Pe(N.x + (u - N.y) / (z.y - N.y) * (z.x - N.x), u)._round() : z.y < u && (z = new Pe(N.x + (u - N.y) / (z.y - N.y) * (z.x - N.x), u)._round()), N.x >= d && z.x >= d || (N.x >= d ? N = new Pe(d, N.y + (d - N.x) / (z.x - N.x) * (z.y - N.y))._round() : z.x >= d && (z = new Pe(d, N.y + (d - N.x) / (z.x - N.x) * (z.y - N.y))._round()), N.y >= y && z.y >= y || (N.y >= y ? N = new Pe(N.x + (y - N.y) / (z.y - N.y) * (z.x - N.x), y)._round() : z.y >= y && (z = new Pe(N.x + (y - N.y) / (z.y - N.y) * (z.x - N.x), y)._round()), I && N.equals(I[I.length - 1]) || (I = [N], x.push(I)), I.push(z)))));
          }
        }
        return x;
      }
      function J1(c, o, u, d) {
        const y = [], x = c.image, w = x.pixelRatio, C = x.paddedRect.w - 2, I = x.paddedRect.h - 2, R = c.right - c.left, N = c.bottom - c.top, z = x.stretchX || [[0, C]], V = x.stretchY || [[0, I]], W = (ut, _t) => ut + _t[1] - _t[0], X = z.reduce(W, 0), se = V.reduce(W, 0), ae = C - X, Ee = I - se;
        let De = 0, we = X, Ae = 0, qe = se, je = 0, Et = ae, Ot = 0, yt = Ee;
        if (x.content && d) {
          const ut = x.content;
          De = um(z, 0, ut[0]), Ae = um(V, 0, ut[1]), we = um(z, ut[0], ut[2]), qe = um(V, ut[1], ut[3]), je = ut[0] - De, Ot = ut[1] - Ae, Et = ut[2] - ut[0] - we, yt = ut[3] - ut[1] - qe;
        }
        const ft = (ut, _t, pt, et) => {
          const Bt = hm(ut.stretch - De, we, R, c.left), Nt = fm(ut.fixed - je, Et, ut.stretch, X), lr = hm(_t.stretch - Ae, qe, N, c.top), fn = fm(_t.fixed - Ot, yt, _t.stretch, se), wn = hm(pt.stretch - De, we, R, c.left), Qn = fm(pt.fixed - je, Et, pt.stretch, X), No = hm(et.stretch - Ae, qe, N, c.top), wi = fm(et.fixed - Ot, yt, et.stretch, se), Gn = new Pe(Bt, lr), li = new Pe(wn, lr), Ei = new Pe(wn, No), Li = new Pe(Bt, No), ro = new Pe(Nt / w, fn / w), qn = new Pe(Qn / w, wi / w), Ti = o * Math.PI / 180;
          if (Ti) {
            const no = Math.sin(Ti), io = Math.cos(Ti), Sn = [io, -no, no, io];
            Gn._matMult(Sn), li._matMult(Sn), Li._matMult(Sn), Ei._matMult(Sn);
          }
          const Di = ut.stretch + ut.fixed, qi = _t.stretch + _t.fixed;
          return { tl: Gn, tr: li, bl: Li, br: Ei, tex: { x: x.paddedRect.x + 1 + Di, y: x.paddedRect.y + 1 + qi, w: pt.stretch + pt.fixed - Di, h: et.stretch + et.fixed - qi }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: ro, pixelOffsetBR: qn, minFontScaleX: Et / w / R, minFontScaleY: yt / w / N, isSDF: u };
        };
        if (d && (x.stretchX || x.stretchY)) {
          const ut = Q1(z, ae, X), _t = Q1(V, Ee, se);
          for (let pt = 0; pt < ut.length - 1; pt++) {
            const et = ut[pt], Bt = ut[pt + 1];
            for (let Nt = 0; Nt < _t.length - 1; Nt++)
              y.push(ft(et, _t[Nt], Bt, _t[Nt + 1]));
          }
        } else
          y.push(ft({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: C + 1 }, { fixed: 0, stretch: I + 1 }));
        return y;
      }
      function um(c, o, u) {
        let d = 0;
        for (const y of c)
          d += Math.max(o, Math.min(u, y[1])) - Math.max(o, Math.min(u, y[0]));
        return d;
      }
      function Q1(c, o, u) {
        const d = [{ fixed: -1, stretch: 0 }];
        for (const [y, x] of c) {
          const w = d[d.length - 1];
          d.push({ fixed: y - w.stretch, stretch: w.stretch }), d.push({ fixed: y - w.stretch, stretch: w.stretch + (x - y) });
        }
        return d.push({ fixed: o + 1, stretch: u }), d;
      }
      function hm(c, o, u, d) {
        return c / o * u + d;
      }
      function fm(c, o, u, d) {
        return c - o * u / d;
      }
      Ct("Anchor", fl);
      class dm {
        constructor(o, u, d, y, x, w, C, I, R, N) {
          if (this.boxStartIndex = o.length, R) {
            let z = w.top, V = w.bottom;
            const W = w.collisionPadding;
            W && (z -= W[1], V += W[3]);
            let X = V - z;
            X > 0 && (X = Math.max(10, X), this.circleDiameter = X);
          } else {
            let z = w.top * C - I[0], V = w.bottom * C + I[2], W = w.left * C - I[3], X = w.right * C + I[1];
            const se = w.collisionPadding;
            if (se && (W -= se[0] * C, z -= se[1] * C, X += se[2] * C, V += se[3] * C), N) {
              const ae = new Pe(W, z), Ee = new Pe(X, z), De = new Pe(W, V), we = new Pe(X, V), Ae = N * Math.PI / 180;
              ae._rotate(Ae), Ee._rotate(Ae), De._rotate(Ae), we._rotate(Ae), W = Math.min(ae.x, Ee.x, De.x, we.x), X = Math.max(ae.x, Ee.x, De.x, we.x), z = Math.min(ae.y, Ee.y, De.y, we.y), V = Math.max(ae.y, Ee.y, De.y, we.y);
            }
            o.emplaceBack(u.x, u.y, W, z, X, V, d, y, x);
          }
          this.boxEndIndex = o.length;
        }
      }
      class rP {
        constructor(o = [], u = nP) {
          if (this.data = o, this.length = this.data.length, this.compare = u, this.length > 0)
            for (let d = (this.length >> 1) - 1; d >= 0; d--)
              this._down(d);
        }
        push(o) {
          this.data.push(o), this.length++, this._up(this.length - 1);
        }
        pop() {
          if (this.length === 0)
            return;
          const o = this.data[0], u = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = u, this._down(0)), o;
        }
        peek() {
          return this.data[0];
        }
        _up(o) {
          const { data: u, compare: d } = this, y = u[o];
          for (; o > 0; ) {
            const x = o - 1 >> 1, w = u[x];
            if (d(y, w) >= 0)
              break;
            u[o] = w, o = x;
          }
          u[o] = y;
        }
        _down(o) {
          const { data: u, compare: d } = this, y = this.length >> 1, x = u[o];
          for (; o < y; ) {
            let w = 1 + (o << 1), C = u[w];
            const I = w + 1;
            if (I < this.length && d(u[I], C) < 0 && (w = I, C = u[I]), d(C, x) >= 0)
              break;
            u[o] = C, o = w;
          }
          u[o] = x;
        }
      }
      function nP(c, o) {
        return c < o ? -1 : c > o ? 1 : 0;
      }
      function iP(c, o = 1, u = !1) {
        let d = 1 / 0, y = 1 / 0, x = -1 / 0, w = -1 / 0;
        const C = c[0];
        for (let W = 0; W < C.length; W++) {
          const X = C[W];
          (!W || X.x < d) && (d = X.x), (!W || X.y < y) && (y = X.y), (!W || X.x > x) && (x = X.x), (!W || X.y > w) && (w = X.y);
        }
        const I = Math.min(x - d, w - y);
        let R = I / 2;
        const N = new rP([], oP);
        if (I === 0)
          return new Pe(d, y);
        for (let W = d; W < x; W += I)
          for (let X = y; X < w; X += I)
            N.push(new Wu(W + R, X + R, R, c));
        let z = function(W) {
          let X = 0, se = 0, ae = 0;
          const Ee = W[0];
          for (let De = 0, we = Ee.length, Ae = we - 1; De < we; Ae = De++) {
            const qe = Ee[De], je = Ee[Ae], Et = qe.x * je.y - je.x * qe.y;
            se += (qe.x + je.x) * Et, ae += (qe.y + je.y) * Et, X += 3 * Et;
          }
          return new Wu(se / X, ae / X, 0, W);
        }(c), V = N.length;
        for (; N.length; ) {
          const W = N.pop();
          (W.d > z.d || !z.d) && (z = W, u && console.log("found best %d after %d probes", Math.round(1e4 * W.d) / 1e4, V)), W.max - z.d <= o || (R = W.h / 2, N.push(new Wu(W.p.x - R, W.p.y - R, R, c)), N.push(new Wu(W.p.x + R, W.p.y - R, R, c)), N.push(new Wu(W.p.x - R, W.p.y + R, R, c)), N.push(new Wu(W.p.x + R, W.p.y + R, R, c)), V += 4);
        }
        return u && (console.log(`num probes: ${V}`), console.log(`best distance: ${z.d}`)), z.p;
      }
      function oP(c, o) {
        return o.max - c.max;
      }
      function Wu(c, o, u, d) {
        this.p = new Pe(c, o), this.h = u, this.d = function(y, x) {
          let w = !1, C = 1 / 0;
          for (let I = 0; I < x.length; I++) {
            const R = x[I];
            for (let N = 0, z = R.length, V = z - 1; N < z; V = N++) {
              const W = R[N], X = R[V];
              W.y > y.y != X.y > y.y && y.x < (X.x - W.x) * (y.y - W.y) / (X.y - W.y) + W.x && (w = !w), C = Math.min(C, s1(y, W, X));
            }
          }
          return (w ? 1 : -1) * Math.sqrt(C);
        }(this.p, d), this.max = this.d + this.h * Math.SQRT2;
      }
      const F_ = Number.POSITIVE_INFINITY;
      function eb(c, o) {
        return o[1] !== F_ ? function(u, d, y) {
          let x = 0, w = 0;
          switch (d = Math.abs(d), y = Math.abs(y), u) {
            case "top-right":
            case "top-left":
            case "top":
              w = y - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              w = 7 - y;
          }
          switch (u) {
            case "top-right":
            case "bottom-right":
            case "right":
              x = -d;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              x = d;
          }
          return [x, w];
        }(c, o[0], o[1]) : function(u, d) {
          let y = 0, x = 0;
          d < 0 && (d = 0);
          const w = d / Math.sqrt(2);
          switch (u) {
            case "top-right":
            case "top-left":
              x = w - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              x = 7 - w;
              break;
            case "bottom":
              x = 7 - d;
              break;
            case "top":
              x = d - 7;
          }
          switch (u) {
            case "top-right":
            case "bottom-right":
              y = -w;
              break;
            case "top-left":
            case "bottom-left":
              y = w;
              break;
            case "left":
              y = d;
              break;
            case "right":
              y = -d;
          }
          return [y, x];
        }(c, o[0]);
      }
      function z_(c) {
        switch (c) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function aP(c, o, u, d, y, x, w, C, I, R, N) {
        let z = x.textMaxSize.evaluate(o, {});
        z === void 0 && (z = w);
        const V = c.layers[0].layout, W = V.get("icon-offset").evaluate(o, {}, N), X = rb(u.horizontal), se = w / 24, ae = c.tilePixelRatio * se, Ee = c.tilePixelRatio * z / 24, De = c.tilePixelRatio * C, we = c.tilePixelRatio * V.get("symbol-spacing"), Ae = V.get("text-padding") * c.tilePixelRatio, qe = function(et, Bt, Nt, lr = 1) {
          const fn = et.get("icon-padding").evaluate(Bt, {}, Nt), wn = fn && fn.values;
          return [wn[0] * lr, wn[1] * lr, wn[2] * lr, wn[3] * lr];
        }(V, o, N, c.tilePixelRatio), je = V.get("text-max-angle") / 180 * Math.PI, Et = V.get("text-rotation-alignment") !== "viewport" && V.get("symbol-placement") !== "point", Ot = V.get("icon-rotation-alignment") === "map" && V.get("symbol-placement") !== "point", yt = V.get("symbol-placement"), ft = we / 2, ut = V.get("icon-text-fit");
        let _t;
        d && ut !== "none" && (c.allowVerticalPlacement && u.vertical && (_t = G1(d, u.vertical, ut, V.get("icon-text-fit-padding"), W, se)), X && (d = G1(d, X, ut, V.get("icon-text-fit-padding"), W, se)));
        const pt = (et, Bt) => {
          Bt.x < 0 || Bt.x >= Jn || Bt.y < 0 || Bt.y >= Jn || function(Nt, lr, fn, wn, Qn, No, wi, Gn, li, Ei, Li, ro, qn, Ti, Di, qi, no, io, Sn, ci, dr, xo, Si, ki, Ko) {
            const da = Nt.addToLineVertexArray(lr, fn);
            let pa, Ss, Yo, Fo, oo = 0, Ms = 0, jf = 0, _b = 0, Z_ = -1, H_ = -1;
            const Cs = {};
            let vb = si.exports(""), K_ = 0, Y_ = 0;
            if (Gn._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [K_, Y_] = Gn.layout.get("text-offset").evaluate(dr, {}, ki).map((ao) => ao * mi) : (K_ = Gn.layout.get("text-radial-offset").evaluate(dr, {}, ki) * mi, Y_ = F_), Nt.allowVerticalPlacement && wn.vertical) {
              const ao = Gn.layout.get("text-rotate").evaluate(dr, {}, ki) + 90;
              Yo = new dm(li, lr, Ei, Li, ro, wn.vertical, qn, Ti, Di, ao), wi && (Fo = new dm(li, lr, Ei, Li, ro, wi, no, io, Di, ao));
            }
            if (Qn) {
              const ao = Gn.layout.get("icon-rotate").evaluate(dr, {}), qa = Gn.layout.get("icon-text-fit") !== "none", Gf = J1(Qn, ao, Si, qa), qf = wi ? J1(wi, ao, Si, qa) : void 0;
              Ss = new dm(li, lr, Ei, Li, ro, Qn, no, io, !1, ao), oo = 4 * Gf.length;
              const wb = Nt.iconSizeData;
              let Ic = null;
              wb.kind === "source" ? (Ic = [Ts * Gn.layout.get("icon-size").evaluate(dr, {})], Ic[0] > dl && he(`${Nt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : wb.kind === "composite" && (Ic = [Ts * xo.compositeIconSizes[0].evaluate(dr, {}, ki), Ts * xo.compositeIconSizes[1].evaluate(dr, {}, ki)], (Ic[0] > dl || Ic[1] > dl) && he(`${Nt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Nt.addSymbols(Nt.icon, Gf, Ic, ci, Sn, dr, s.WritingMode.none, lr, da.lineStartIndex, da.lineLength, -1, ki), Z_ = Nt.icon.placedSymbolArray.length - 1, qf && (Ms = 4 * qf.length, Nt.addSymbols(Nt.icon, qf, Ic, ci, Sn, dr, s.WritingMode.vertical, lr, da.lineStartIndex, da.lineLength, -1, ki), H_ = Nt.icon.placedSymbolArray.length - 1);
            }
            const xb = Object.keys(wn.horizontal);
            for (const ao of xb) {
              const qa = wn.horizontal[ao];
              if (!pa) {
                vb = si.exports(qa.text);
                const qf = Gn.layout.get("text-rotate").evaluate(dr, {}, ki);
                pa = new dm(li, lr, Ei, Li, ro, qa, qn, Ti, Di, qf);
              }
              const Gf = qa.positionedLines.length === 1;
              if (jf += tb(Nt, lr, qa, No, Gn, Di, dr, qi, da, wn.vertical ? s.WritingMode.horizontal : s.WritingMode.horizontalOnly, Gf ? xb : [ao], Cs, Z_, xo, ki), Gf)
                break;
            }
            wn.vertical && (_b += tb(Nt, lr, wn.vertical, No, Gn, Di, dr, qi, da, s.WritingMode.vertical, ["vertical"], Cs, H_, xo, ki));
            const vP = pa ? pa.boxStartIndex : Nt.collisionBoxArray.length, xP = pa ? pa.boxEndIndex : Nt.collisionBoxArray.length, bP = Yo ? Yo.boxStartIndex : Nt.collisionBoxArray.length, wP = Yo ? Yo.boxEndIndex : Nt.collisionBoxArray.length, EP = Ss ? Ss.boxStartIndex : Nt.collisionBoxArray.length, TP = Ss ? Ss.boxEndIndex : Nt.collisionBoxArray.length, SP = Fo ? Fo.boxStartIndex : Nt.collisionBoxArray.length, MP = Fo ? Fo.boxEndIndex : Nt.collisionBoxArray.length;
            let ma = -1;
            const _m = (ao, qa) => ao && ao.circleDiameter ? Math.max(ao.circleDiameter, qa) : qa;
            ma = _m(pa, ma), ma = _m(Yo, ma), ma = _m(Ss, ma), ma = _m(Fo, ma);
            const bb = ma > -1 ? 1 : 0;
            bb && (ma *= Ko / mi), Nt.glyphOffsetArray.length >= Xu.MAX_GLYPHS && he("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), dr.sortKey !== void 0 && Nt.addToSortKeyRanges(Nt.symbolInstances.length, dr.sortKey), Nt.symbolInstances.emplaceBack(lr.x, lr.y, Cs.right >= 0 ? Cs.right : -1, Cs.center >= 0 ? Cs.center : -1, Cs.left >= 0 ? Cs.left : -1, Cs.vertical || -1, Z_, H_, vb, vP, xP, bP, wP, EP, TP, SP, MP, Ei, jf, _b, oo, Ms, bb, 0, qn, K_, Y_, ma);
          }(c, Bt, et, u, d, y, _t, c.layers[0], c.collisionBoxArray, o.index, o.sourceLayerIndex, c.index, ae, [Ae, Ae, Ae, Ae], Et, I, De, qe, Ot, W, o, x, R, N, w);
        };
        if (yt === "line")
          for (const et of Y1(o.geometry, 0, 0, Jn, Jn)) {
            const Bt = tP(et, we, je, u.vertical || X, d, 24, Ee, c.overscaling, Jn);
            for (const Nt of Bt) {
              const lr = X;
              lr && sP(c, lr.text, ft, Nt) || pt(et, Nt);
            }
          }
        else if (yt === "line-center") {
          for (const et of o.geometry)
            if (et.length > 1) {
              const Bt = eP(et, je, u.vertical || X, d, 24, Ee);
              Bt && pt(et, Bt);
            }
        } else if (o.type === "Polygon")
          for (const et of S_(o.geometry, 0)) {
            const Bt = iP(et, 16);
            pt(et[0], new fl(Bt.x, Bt.y, 0));
          }
        else if (o.type === "LineString")
          for (const et of o.geometry)
            pt(et, new fl(et[0].x, et[0].y, 0));
        else if (o.type === "Point")
          for (const et of o.geometry)
            for (const Bt of et)
              pt([Bt], new fl(Bt.x, Bt.y, 0));
      }
      const dl = 32640;
      function tb(c, o, u, d, y, x, w, C, I, R, N, z, V, W, X) {
        const se = function(De, we, Ae, qe, je, Et, Ot, yt) {
          const ft = qe.layout.get("text-rotate").evaluate(Et, {}) * Math.PI / 180, ut = [];
          for (const _t of we.positionedLines)
            for (const pt of _t.positionedGlyphs) {
              if (!pt.rect)
                continue;
              const et = pt.rect || {};
              let Bt = 4, Nt = !0, lr = 1, fn = 0;
              const wn = (je || yt) && pt.vertical, Qn = pt.metrics.advance * pt.scale / 2;
              if (yt && we.verticalizable) {
                const Sn = (pt.scale - 1) * mi, ci = (mi - pt.metrics.width * pt.scale) / 2;
                fn = _t.lineOffset / 2 - (pt.imageName ? -ci : Sn);
              }
              if (pt.imageName) {
                const Sn = Ot[pt.imageName];
                Nt = Sn.sdf, lr = Sn.pixelRatio, Bt = 1 / lr;
              }
              const No = je ? [pt.x + Qn, pt.y] : [0, 0];
              let wi = je ? [0, 0] : [pt.x + Qn + Ae[0], pt.y + Ae[1] - fn], Gn = [0, 0];
              wn && (Gn = wi, wi = [0, 0]);
              const li = (pt.metrics.left - Bt) * pt.scale - Qn + wi[0], Ei = (-pt.metrics.top - Bt) * pt.scale + wi[1], Li = li + et.w * pt.scale / lr, ro = Ei + et.h * pt.scale / lr, qn = new Pe(li, Ei), Ti = new Pe(Li, Ei), Di = new Pe(li, ro), qi = new Pe(Li, ro);
              if (wn) {
                const Sn = new Pe(-Qn, Qn - sm), ci = -Math.PI / 2, dr = 12 - Qn, xo = new Pe(22 - dr, -(pt.imageName ? dr : 0)), Si = new Pe(...Gn);
                qn._rotateAround(ci, Sn)._add(xo)._add(Si), Ti._rotateAround(ci, Sn)._add(xo)._add(Si), Di._rotateAround(ci, Sn)._add(xo)._add(Si), qi._rotateAround(ci, Sn)._add(xo)._add(Si);
              }
              if (ft) {
                const Sn = Math.sin(ft), ci = Math.cos(ft), dr = [ci, -Sn, Sn, ci];
                qn._matMult(dr), Ti._matMult(dr), Di._matMult(dr), qi._matMult(dr);
              }
              const no = new Pe(0, 0), io = new Pe(0, 0);
              ut.push({ tl: qn, tr: Ti, bl: Di, br: qi, tex: et, writingMode: we.writingMode, glyphOffset: No, sectionIndex: pt.sectionIndex, isSDF: Nt, pixelOffsetTL: no, pixelOffsetBR: io, minFontScaleX: 0, minFontScaleY: 0 });
            }
          return ut;
        }(0, u, C, y, x, w, d, c.allowVerticalPlacement), ae = c.textSizeData;
        let Ee = null;
        ae.kind === "source" ? (Ee = [Ts * y.layout.get("text-size").evaluate(w, {})], Ee[0] > dl && he(`${c.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : ae.kind === "composite" && (Ee = [Ts * W.compositeTextSizes[0].evaluate(w, {}, X), Ts * W.compositeTextSizes[1].evaluate(w, {}, X)], (Ee[0] > dl || Ee[1] > dl) && he(`${c.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), c.addSymbols(c.text, se, Ee, C, x, w, R, o, I.lineStartIndex, I.lineLength, V, X);
        for (const De of N)
          z[De] = c.text.placedSymbolArray.length - 1;
        return 4 * se.length;
      }
      function rb(c) {
        for (const o in c)
          return c[o];
        return null;
      }
      function sP(c, o, u, d) {
        const y = c.compareText;
        if (o in y) {
          const x = y[o];
          for (let w = x.length - 1; w >= 0; w--)
            if (d.dist(x[w]) < u)
              return !0;
        } else
          y[o] = [];
        return y[o].push(d), !1;
      }
      const lP = ul.VectorTileFeature.types, cP = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function pm(c, o, u, d, y, x, w, C, I, R, N, z, V) {
        const W = C ? Math.min(dl, Math.round(C[0])) : 0, X = C ? Math.min(dl, Math.round(C[1])) : 0;
        c.emplaceBack(o, u, Math.round(32 * d), Math.round(32 * y), x, w, (W << 1) + (I ? 1 : 0), X, 16 * R, 16 * N, 256 * z, 256 * V);
      }
      function B_(c, o, u) {
        c.emplaceBack(o.x, o.y, u), c.emplaceBack(o.x, o.y, u), c.emplaceBack(o.x, o.y, u), c.emplaceBack(o.x, o.y, u);
      }
      function uP(c) {
        for (const o of c.sections)
          if (jp(o.text))
            return !0;
        return !1;
      }
      class U_ {
        constructor(o) {
          this.layoutVertexArray = new Zo(), this.indexArray = new Vi(), this.programConfigurations = o, this.segments = new hr(), this.dynamicLayoutVertexArray = new Lo(), this.opacityVertexArray = new Ho(), this.placedSymbolArray = new Qe();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(o, u, d, y) {
          this.isEmpty() || (d && (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, LI.members), this.indexBuffer = o.createIndexBuffer(this.indexArray, u), this.dynamicLayoutVertexBuffer = o.createVertexBuffer(this.dynamicLayoutVertexArray, DI.members, !0), this.opacityVertexBuffer = o.createVertexBuffer(this.opacityVertexArray, cP, !0), this.opacityVertexBuffer.itemSize = 1), (d || y) && this.programConfigurations.upload(o));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      Ct("SymbolBuffers", U_);
      class $_ {
        constructor(o, u, d) {
          this.layoutVertexArray = new o(), this.layoutAttributes = u, this.indexArray = new d(), this.segments = new hr(), this.collisionVertexArray = new _o();
        }
        upload(o) {
          this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = o.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = o.createVertexBuffer(this.collisionVertexArray, kI.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      Ct("CollisionBuffers", $_);
      class Xu {
        constructor(o) {
          this.collisionBoxArray = o.collisionBoxArray, this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((w) => w.id), this.index = o.index, this.pixelRatio = o.pixelRatio, this.sourceLayerIndex = o.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = v_([]), this.placementViewportMatrix = v_([]);
          const u = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = q1(this.zoom, u["text-size"]), this.iconSizeData = q1(this.zoom, u["icon-size"]);
          const d = this.layers[0].layout, y = d.get("symbol-sort-key"), x = d.get("symbol-z-order");
          this.canOverlap = j_(d, "text-overlap", "text-allow-overlap") !== "never" || j_(d, "icon-overlap", "icon-allow-overlap") !== "never" || d.get("text-ignore-placement") || d.get("icon-ignore-placement"), this.sortFeaturesByKey = x !== "viewport-y" && !y.isConstant(), this.sortFeaturesByY = (x === "viewport-y" || x === "auto" && !this.sortFeaturesByKey) && this.canOverlap, d.get("symbol-placement") === "point" && (this.writingModes = d.get("text-writing-mode").map((w) => s.WritingMode[w])), this.stateDependentLayerIds = this.layers.filter((w) => w.isStateDependent()).map((w) => w.id), this.sourceID = o.sourceID;
        }
        createArrays() {
          this.text = new U_(new Ec(this.layers, this.zoom, (o) => /^text/.test(o))), this.icon = new U_(new Ec(this.layers, this.zoom, (o) => /^icon/.test(o))), this.glyphOffsetArray = new ht(), this.lineVertexArray = new wt(), this.symbolInstances = new bt();
        }
        calculateGlyphDependencies(o, u, d, y, x) {
          for (let w = 0; w < o.length; w++)
            if (u[o.charCodeAt(w)] = !0, (d || y) && x) {
              const C = Bf[o.charAt(w)];
              C && (u[C.charCodeAt(0)] = !0);
            }
        }
        populate(o, u, d) {
          const y = this.layers[0], x = y.layout, w = x.get("text-font"), C = x.get("text-field"), I = x.get("icon-image"), R = (C.value.kind !== "constant" || C.value.value instanceof fe && !C.value.value.isEmpty() || C.value.value.toString().length > 0) && (w.value.kind !== "constant" || w.value.value.length > 0), N = I.value.kind !== "constant" || !!I.value.value || Object.keys(I.parameters).length > 0, z = x.get("symbol-sort-key");
          if (this.features = [], !R && !N)
            return;
          const V = u.iconDependencies, W = u.glyphDependencies, X = u.availableImages, se = new xn(this.zoom);
          for (const { feature: ae, id: Ee, index: De, sourceLayerIndex: we } of o) {
            const Ae = y._featureFilter.needGeometry, qe = Sc(ae, Ae);
            if (!y._featureFilter.filter(se, qe, d))
              continue;
            let je, Et;
            if (Ae || (qe.geometry = Tc(ae)), R) {
              const yt = y.getValueAndResolveTokens("text-field", qe, d, X), ft = fe.factory(yt);
              uP(ft) && (this.hasRTLText = !0), (!this.hasRTLText || xc() === "unavailable" || this.hasRTLText && yo.isParsed()) && (je = FI(ft, y, qe));
            }
            if (N) {
              const yt = y.getValueAndResolveTokens("icon-image", qe, d, X);
              Et = yt instanceof ge ? yt : ge.fromString(yt);
            }
            if (!je && !Et)
              continue;
            const Ot = this.sortFeaturesByKey ? z.evaluate(qe, {}, d) : void 0;
            if (this.features.push({ id: Ee, text: je, icon: Et, index: De, sourceLayerIndex: we, geometry: qe.geometry, properties: ae.properties, type: lP[ae.type], sortKey: Ot }), Et && (V[Et.name] = !0), je) {
              const yt = w.evaluate(qe, {}, d).join(","), ft = x.get("text-rotation-alignment") !== "viewport" && x.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(s.WritingMode.vertical) >= 0;
              for (const ut of je.sections)
                if (ut.image)
                  V[ut.image.name] = !0;
                else {
                  const _t = ku(je.toString()), pt = ut.fontStack || yt, et = W[pt] = W[pt] || {};
                  this.calculateGlyphDependencies(ut.text, et, ft, this.allowVerticalPlacement, _t);
                }
            }
          }
          x.get("symbol-placement") === "line" && (this.features = function(ae) {
            const Ee = {}, De = {}, we = [];
            let Ae = 0;
            function qe(yt) {
              we.push(ae[yt]), Ae++;
            }
            function je(yt, ft, ut) {
              const _t = De[yt];
              return delete De[yt], De[ft] = _t, we[_t].geometry[0].pop(), we[_t].geometry[0] = we[_t].geometry[0].concat(ut[0]), _t;
            }
            function Et(yt, ft, ut) {
              const _t = Ee[ft];
              return delete Ee[ft], Ee[yt] = _t, we[_t].geometry[0].shift(), we[_t].geometry[0] = ut[0].concat(we[_t].geometry[0]), _t;
            }
            function Ot(yt, ft, ut) {
              const _t = ut ? ft[0][ft[0].length - 1] : ft[0][0];
              return `${yt}:${_t.x}:${_t.y}`;
            }
            for (let yt = 0; yt < ae.length; yt++) {
              const ft = ae[yt], ut = ft.geometry, _t = ft.text ? ft.text.toString() : null;
              if (!_t) {
                qe(yt);
                continue;
              }
              const pt = Ot(_t, ut), et = Ot(_t, ut, !0);
              if (pt in De && et in Ee && De[pt] !== Ee[et]) {
                const Bt = Et(pt, et, ut), Nt = je(pt, et, we[Bt].geometry);
                delete Ee[pt], delete De[et], De[Ot(_t, we[Nt].geometry, !0)] = Nt, we[Bt].geometry = null;
              } else
                pt in De ? je(pt, et, ut) : et in Ee ? Et(pt, et, ut) : (qe(yt), Ee[pt] = Ae - 1, De[et] = Ae - 1);
            }
            return we.filter((yt) => yt.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((ae, Ee) => ae.sortKey - Ee.sortKey);
        }
        update(o, u, d) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(o, u, this.layers, d), this.icon.programConfigurations.updatePaintArrays(o, u, this.layers, d));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(o) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(o), this.iconCollisionBox.upload(o)), this.text.upload(o, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(o, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(o, u) {
          const d = this.lineVertexArray.length;
          if (o.segment !== void 0) {
            let y = o.dist(u[o.segment + 1]), x = o.dist(u[o.segment]);
            const w = {};
            for (let C = o.segment + 1; C < u.length; C++)
              w[C] = { x: u[C].x, y: u[C].y, tileUnitDistanceFromAnchor: y }, C < u.length - 1 && (y += u[C + 1].dist(u[C]));
            for (let C = o.segment || 0; C >= 0; C--)
              w[C] = { x: u[C].x, y: u[C].y, tileUnitDistanceFromAnchor: x }, C > 0 && (x += u[C - 1].dist(u[C]));
            for (let C = 0; C < u.length; C++) {
              const I = w[C];
              this.lineVertexArray.emplaceBack(I.x, I.y, I.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: d, lineLength: this.lineVertexArray.length - d };
        }
        addSymbols(o, u, d, y, x, w, C, I, R, N, z, V) {
          const W = o.indexArray, X = o.layoutVertexArray, se = o.segments.prepareSegment(4 * u.length, X, W, this.canOverlap ? w.sortKey : void 0), ae = this.glyphOffsetArray.length, Ee = se.vertexLength, De = this.allowVerticalPlacement && C === s.WritingMode.vertical ? Math.PI / 2 : 0, we = w.text && w.text.sections;
          for (let Ae = 0; Ae < u.length; Ae++) {
            const { tl: qe, tr: je, bl: Et, br: Ot, tex: yt, pixelOffsetTL: ft, pixelOffsetBR: ut, minFontScaleX: _t, minFontScaleY: pt, glyphOffset: et, isSDF: Bt, sectionIndex: Nt } = u[Ae], lr = se.vertexLength, fn = et[1];
            pm(X, I.x, I.y, qe.x, fn + qe.y, yt.x, yt.y, d, Bt, ft.x, ft.y, _t, pt), pm(X, I.x, I.y, je.x, fn + je.y, yt.x + yt.w, yt.y, d, Bt, ut.x, ft.y, _t, pt), pm(X, I.x, I.y, Et.x, fn + Et.y, yt.x, yt.y + yt.h, d, Bt, ft.x, ut.y, _t, pt), pm(X, I.x, I.y, Ot.x, fn + Ot.y, yt.x + yt.w, yt.y + yt.h, d, Bt, ut.x, ut.y, _t, pt), B_(o.dynamicLayoutVertexArray, I, De), W.emplaceBack(lr, lr + 1, lr + 2), W.emplaceBack(lr + 1, lr + 2, lr + 3), se.vertexLength += 4, se.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(et[0]), Ae !== u.length - 1 && Nt === u[Ae + 1].sectionIndex || o.programConfigurations.populatePaintArrays(X.length, w, w.index, {}, V, we && we[Nt]);
          }
          o.placedSymbolArray.emplaceBack(I.x, I.y, ae, this.glyphOffsetArray.length - ae, Ee, R, N, I.segment, d ? d[0] : 0, d ? d[1] : 0, y[0], y[1], C, 0, !1, 0, z);
        }
        _addCollisionDebugVertex(o, u, d, y, x, w) {
          return u.emplaceBack(0, 0), o.emplaceBack(d.x, d.y, y, x, Math.round(w.x), Math.round(w.y));
        }
        addCollisionDebugVertices(o, u, d, y, x, w, C) {
          const I = x.segments.prepareSegment(4, x.layoutVertexArray, x.indexArray), R = I.vertexLength, N = x.layoutVertexArray, z = x.collisionVertexArray, V = C.anchorX, W = C.anchorY;
          this._addCollisionDebugVertex(N, z, w, V, W, new Pe(o, u)), this._addCollisionDebugVertex(N, z, w, V, W, new Pe(d, u)), this._addCollisionDebugVertex(N, z, w, V, W, new Pe(d, y)), this._addCollisionDebugVertex(N, z, w, V, W, new Pe(o, y)), I.vertexLength += 4;
          const X = x.indexArray;
          X.emplaceBack(R, R + 1), X.emplaceBack(R + 1, R + 2), X.emplaceBack(R + 2, R + 3), X.emplaceBack(R + 3, R), I.primitiveLength += 4;
        }
        addDebugCollisionBoxes(o, u, d, y) {
          for (let x = o; x < u; x++) {
            const w = this.collisionBoxArray.get(x);
            this.addCollisionDebugVertices(w.x1, w.y1, w.x2, w.y2, y ? this.textCollisionBox : this.iconCollisionBox, w.anchorPoint, d);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new $_(ja, O1.members, ha), this.iconCollisionBox = new $_(ja, O1.members, ha);
          for (let o = 0; o < this.symbolInstances.length; o++) {
            const u = this.symbolInstances.get(o);
            this.addDebugCollisionBoxes(u.textBoxStartIndex, u.textBoxEndIndex, u, !0), this.addDebugCollisionBoxes(u.verticalTextBoxStartIndex, u.verticalTextBoxEndIndex, u, !0), this.addDebugCollisionBoxes(u.iconBoxStartIndex, u.iconBoxEndIndex, u, !1), this.addDebugCollisionBoxes(u.verticalIconBoxStartIndex, u.verticalIconBoxEndIndex, u, !1);
          }
        }
        _deserializeCollisionBoxesForSymbol(o, u, d, y, x, w, C, I, R) {
          const N = {};
          for (let z = u; z < d; z++) {
            const V = o.get(z);
            N.textBox = { x1: V.x1, y1: V.y1, x2: V.x2, y2: V.y2, anchorPointX: V.anchorPointX, anchorPointY: V.anchorPointY }, N.textFeatureIndex = V.featureIndex;
            break;
          }
          for (let z = y; z < x; z++) {
            const V = o.get(z);
            N.verticalTextBox = { x1: V.x1, y1: V.y1, x2: V.x2, y2: V.y2, anchorPointX: V.anchorPointX, anchorPointY: V.anchorPointY }, N.verticalTextFeatureIndex = V.featureIndex;
            break;
          }
          for (let z = w; z < C; z++) {
            const V = o.get(z);
            N.iconBox = { x1: V.x1, y1: V.y1, x2: V.x2, y2: V.y2, anchorPointX: V.anchorPointX, anchorPointY: V.anchorPointY }, N.iconFeatureIndex = V.featureIndex;
            break;
          }
          for (let z = I; z < R; z++) {
            const V = o.get(z);
            N.verticalIconBox = { x1: V.x1, y1: V.y1, x2: V.x2, y2: V.y2, anchorPointX: V.anchorPointX, anchorPointY: V.anchorPointY }, N.verticalIconFeatureIndex = V.featureIndex;
            break;
          }
          return N;
        }
        deserializeCollisionBoxes(o) {
          this.collisionArrays = [];
          for (let u = 0; u < this.symbolInstances.length; u++) {
            const d = this.symbolInstances.get(u);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(o, d.textBoxStartIndex, d.textBoxEndIndex, d.verticalTextBoxStartIndex, d.verticalTextBoxEndIndex, d.iconBoxStartIndex, d.iconBoxEndIndex, d.verticalIconBoxStartIndex, d.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(o, u) {
          const d = o.placedSymbolArray.get(u), y = d.vertexStartIndex + 4 * d.numGlyphs;
          for (let x = d.vertexStartIndex; x < y; x += 4)
            o.indexArray.emplaceBack(x, x + 1, x + 2), o.indexArray.emplaceBack(x + 1, x + 2, x + 3);
        }
        getSortedSymbolIndexes(o) {
          if (this.sortedAngle === o && this.symbolInstanceIndexes !== void 0)
            return this.symbolInstanceIndexes;
          const u = Math.sin(o), d = Math.cos(o), y = [], x = [], w = [];
          for (let C = 0; C < this.symbolInstances.length; ++C) {
            w.push(C);
            const I = this.symbolInstances.get(C);
            y.push(0 | Math.round(u * I.anchorX + d * I.anchorY)), x.push(I.featureIndex);
          }
          return w.sort((C, I) => y[C] - y[I] || x[I] - x[C]), w;
        }
        addToSortKeyRanges(o, u) {
          const d = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          d && d.sortKey === u ? d.symbolInstanceEnd = o + 1 : this.sortKeyRanges.push({ sortKey: u, symbolInstanceStart: o, symbolInstanceEnd: o + 1 });
        }
        sortFeatures(o) {
          if (this.sortFeaturesByY && this.sortedAngle !== o && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(o), this.sortedAngle = o, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const u of this.symbolInstanceIndexes) {
              const d = this.symbolInstances.get(u);
              this.featureSortOrder.push(d.featureIndex), [d.rightJustifiedTextSymbolIndex, d.centerJustifiedTextSymbolIndex, d.leftJustifiedTextSymbolIndex].forEach((y, x, w) => {
                y >= 0 && w.indexOf(y) === x && this.addIndicesForPlacedSymbol(this.text, y);
              }), d.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, d.verticalPlacedTextSymbolIndex), d.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, d.placedIconSymbolIndex), d.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, d.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      Ct("SymbolBucket", Xu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Xu.MAX_GLYPHS = 65535, Xu.addDynamicAttributes = B_;
      const hP = new pi({ "symbol-placement": new Dt(Ce.layout_symbol["symbol-placement"]), "symbol-spacing": new Dt(Ce.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Dt(Ce.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new jt(Ce.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Dt(Ce.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Dt(Ce.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Dt(Ce.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Dt(Ce.layout_symbol["icon-ignore-placement"]), "icon-optional": new Dt(Ce.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Dt(Ce.layout_symbol["icon-rotation-alignment"]), "icon-size": new jt(Ce.layout_symbol["icon-size"]), "icon-text-fit": new Dt(Ce.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Dt(Ce.layout_symbol["icon-text-fit-padding"]), "icon-image": new jt(Ce.layout_symbol["icon-image"]), "icon-rotate": new jt(Ce.layout_symbol["icon-rotate"]), "icon-padding": new jt(Ce.layout_symbol["icon-padding"]), "icon-keep-upright": new Dt(Ce.layout_symbol["icon-keep-upright"]), "icon-offset": new jt(Ce.layout_symbol["icon-offset"]), "icon-anchor": new jt(Ce.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Dt(Ce.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Dt(Ce.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Dt(Ce.layout_symbol["text-rotation-alignment"]), "text-field": new jt(Ce.layout_symbol["text-field"]), "text-font": new jt(Ce.layout_symbol["text-font"]), "text-size": new jt(Ce.layout_symbol["text-size"]), "text-max-width": new jt(Ce.layout_symbol["text-max-width"]), "text-line-height": new Dt(Ce.layout_symbol["text-line-height"]), "text-letter-spacing": new jt(Ce.layout_symbol["text-letter-spacing"]), "text-justify": new jt(Ce.layout_symbol["text-justify"]), "text-radial-offset": new jt(Ce.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Dt(Ce.layout_symbol["text-variable-anchor"]), "text-anchor": new jt(Ce.layout_symbol["text-anchor"]), "text-max-angle": new Dt(Ce.layout_symbol["text-max-angle"]), "text-writing-mode": new Dt(Ce.layout_symbol["text-writing-mode"]), "text-rotate": new jt(Ce.layout_symbol["text-rotate"]), "text-padding": new Dt(Ce.layout_symbol["text-padding"]), "text-keep-upright": new Dt(Ce.layout_symbol["text-keep-upright"]), "text-transform": new jt(Ce.layout_symbol["text-transform"]), "text-offset": new jt(Ce.layout_symbol["text-offset"]), "text-allow-overlap": new Dt(Ce.layout_symbol["text-allow-overlap"]), "text-overlap": new Dt(Ce.layout_symbol["text-overlap"]), "text-ignore-placement": new Dt(Ce.layout_symbol["text-ignore-placement"]), "text-optional": new Dt(Ce.layout_symbol["text-optional"]) });
      var V_ = { paint: new pi({ "icon-opacity": new jt(Ce.paint_symbol["icon-opacity"]), "icon-color": new jt(Ce.paint_symbol["icon-color"]), "icon-halo-color": new jt(Ce.paint_symbol["icon-halo-color"]), "icon-halo-width": new jt(Ce.paint_symbol["icon-halo-width"]), "icon-halo-blur": new jt(Ce.paint_symbol["icon-halo-blur"]), "icon-translate": new Dt(Ce.paint_symbol["icon-translate"]), "icon-translate-anchor": new Dt(Ce.paint_symbol["icon-translate-anchor"]), "text-opacity": new jt(Ce.paint_symbol["text-opacity"]), "text-color": new jt(Ce.paint_symbol["text-color"], { runtimeType: Kn, getOverride: (c) => c.textColor, hasOverride: (c) => !!c.textColor }), "text-halo-color": new jt(Ce.paint_symbol["text-halo-color"]), "text-halo-width": new jt(Ce.paint_symbol["text-halo-width"]), "text-halo-blur": new jt(Ce.paint_symbol["text-halo-blur"]), "text-translate": new Dt(Ce.paint_symbol["text-translate"]), "text-translate-anchor": new Dt(Ce.paint_symbol["text-translate-anchor"]) }), layout: hP };
      class nb {
        constructor(o) {
          if (o.property.overrides === void 0)
            throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = o.property.overrides ? o.property.overrides.runtimeType : Yr, this.defaultValue = o;
        }
        evaluate(o) {
          if (o.formattedSection) {
            const u = this.defaultValue.property.overrides;
            if (u && u.hasOverride(o.formattedSection))
              return u.getOverride(o.formattedSection);
          }
          return o.feature && o.featureState ? this.defaultValue.evaluate(o.feature, o.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(o) {
          this.defaultValue.isConstant() || o(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      Ct("FormatSectionOverride", nb, { omit: ["defaultValue"] });
      class mm extends Xo {
        constructor(o) {
          super(o, V_);
        }
        recalculate(o, u) {
          if (super.recalculate(o, u), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const d = this.layout.get("text-writing-mode");
            if (d) {
              const y = [];
              for (const x of d)
                y.indexOf(x) < 0 && y.push(x);
              this.layout._values["text-writing-mode"] = y;
            } else
              this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(o, u, d, y) {
          const x = this.layout.get(o).evaluate(u, {}, d, y), w = this._unevaluatedLayout._values[o];
          return w.isDataDriven() || sc(w.value) || !x ? x : function(C, I) {
            return I.replace(/{([^{}]+)}/g, (R, N) => N in C ? String(C[N]) : "");
          }(u.properties, x);
        }
        createBucket(o) {
          return new Xu(o);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const o of V_.paint.overridableProperties) {
            if (!mm.hasPaintOverride(this.layout, o))
              continue;
            const u = this.paint.get(o), d = new nb(u), y = new Pu(d, u.property.specification);
            let x = null;
            x = u.value.kind === "constant" || u.value.kind === "source" ? new cc("source", y) : new df("composite", y, u.value.zoomStops), this.paint._values[o] = new Wo(u.property, x, u.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(o, u, d) {
          return !(!this.layout || u.isDataDriven() || d.isDataDriven()) && mm.hasPaintOverride(this.layout, o);
        }
        static hasPaintOverride(o, u) {
          const d = o.get("text-field"), y = V_.paint.properties[u];
          let x = !1;
          const w = (C) => {
            for (const I of C)
              if (y.overrides && y.overrides.hasOverride(I))
                return void (x = !0);
          };
          if (d.value.kind === "constant" && d.value.value instanceof fe)
            w(d.value.value.sections);
          else if (d.value.kind === "source") {
            const C = (R) => {
              x || (R instanceof ot && ue(R.value) === Vn ? w(R.value.sections) : R instanceof Cu ? w(R.sections) : R.eachChild(C));
            }, I = d.value;
            I._styleExpression && C(I._styleExpression.expression);
          }
          return x;
        }
      }
      function j_(c, o, u) {
        let d = "never";
        const y = c.get(o);
        return y ? d = y : c.get(u) && (d = "always"), d;
      }
      var fP = { paint: new pi({ "background-color": new Dt(Ce.paint_background["background-color"]), "background-pattern": new Sf(Ce.paint_background["background-pattern"]), "background-opacity": new Dt(Ce.paint_background["background-opacity"]) }) }, dP = { paint: new pi({ "raster-opacity": new Dt(Ce.paint_raster["raster-opacity"]), "raster-hue-rotate": new Dt(Ce.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Dt(Ce.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Dt(Ce.paint_raster["raster-brightness-max"]), "raster-saturation": new Dt(Ce.paint_raster["raster-saturation"]), "raster-contrast": new Dt(Ce.paint_raster["raster-contrast"]), "raster-resampling": new Dt(Ce.paint_raster["raster-resampling"]), "raster-fade-duration": new Dt(Ce.paint_raster["raster-fade-duration"]) }) };
      class pP extends Xo {
        constructor(o) {
          super(o, {}), this.onAdd = (u) => {
            this.implementation.onAdd && this.implementation.onAdd(u, u.painter.context.gl);
          }, this.onRemove = (u) => {
            this.implementation.onRemove && this.implementation.onRemove(u, u.painter.context.gl);
          }, this.implementation = o;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      const mP = { circle: class extends Xo {
        constructor(c) {
          super(c, WC);
        }
        createBucket(c) {
          return new g_(c);
        }
        queryRadius(c) {
          const o = c;
          return Af("circle-radius", this, o) + Af("circle-stroke-width", this, o) + Jp(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(c, o, u, d, y, x, w, C) {
          const I = Qp(c, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), x.angle, w), R = this.paint.get("circle-radius").evaluate(o, u) + this.paint.get("circle-stroke-width").evaluate(o, u), N = this.paint.get("circle-pitch-alignment") === "map", z = N ? I : function(W, X) {
            return W.map((se) => p1(se, X));
          }(I, C), V = N ? R * w : R;
          for (const W of d)
            for (const X of W) {
              const se = N ? X : p1(X, C);
              let ae = V;
              const Ee = em([], [X.x, X.y, 0, 1], C);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? ae *= Ee[3] / x.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (ae *= x.cameraToCenterDistance / Ee[3]), $C(z, se, ae))
                return !0;
            }
          return !1;
        }
      }, heatmap: class extends Xo {
        constructor(c) {
          super(c, ZC), this._updateColorRamp();
        }
        createBucket(c) {
          return new m1(c);
        }
        _handleSpecialPaintPropertyUpdate(c) {
          c === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = y1({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }, hillshade: class extends Xo {
        constructor(c) {
          super(c, HC);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }, fill: class extends Xo {
        constructor(c) {
          super(c, hI);
        }
        recalculate(c, o) {
          super.recalculate(c, o);
          const u = this.paint._values["fill-outline-color"];
          u.value.kind === "constant" && u.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(c) {
          return new I_(c);
        }
        queryRadius() {
          return Jp(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(c, o, u, d, y, x, w) {
          return a1(Qp(c, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), x.angle, w), d);
        }
        isTileClipped() {
          return !0;
        }
      }, "fill-extrusion": class extends Xo {
        constructor(c) {
          super(c, SI);
        }
        createBucket(c) {
          return new A_(c);
        }
        queryRadius() {
          return Jp(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature(c, o, u, d, y, x, w, C) {
          const I = Qp(c, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), x.angle, w), R = this.paint.get("fill-extrusion-height").evaluate(o, u), N = this.paint.get("fill-extrusion-base").evaluate(o, u), z = function(W, X, se, ae) {
            const Ee = [];
            for (const De of W) {
              const we = [De.x, De.y, 0, 1];
              em(we, we, X), Ee.push(new Pe(we[0] / we[3], we[1] / we[3]));
            }
            return Ee;
          }(I, C), V = function(W, X, se, ae) {
            const Ee = [], De = [], we = ae[8] * X, Ae = ae[9] * X, qe = ae[10] * X, je = ae[11] * X, Et = ae[8] * se, Ot = ae[9] * se, yt = ae[10] * se, ft = ae[11] * se;
            for (const ut of W) {
              const _t = [], pt = [];
              for (const et of ut) {
                const Bt = et.x, Nt = et.y, lr = ae[0] * Bt + ae[4] * Nt + ae[12], fn = ae[1] * Bt + ae[5] * Nt + ae[13], wn = ae[2] * Bt + ae[6] * Nt + ae[14], Qn = ae[3] * Bt + ae[7] * Nt + ae[15], No = wn + qe, wi = Qn + je, Gn = lr + Et, li = fn + Ot, Ei = wn + yt, Li = Qn + ft, ro = new Pe((lr + we) / wi, (fn + Ae) / wi);
                ro.z = No / wi, _t.push(ro);
                const qn = new Pe(Gn / Li, li / Li);
                qn.z = Ei / Li, pt.push(qn);
              }
              Ee.push(_t), De.push(pt);
            }
            return [Ee, De];
          }(d, N, R, C);
          return function(W, X, se) {
            let ae = 1 / 0;
            a1(se, X) && (ae = M1(se, X[0]));
            for (let Ee = 0; Ee < X.length; Ee++) {
              const De = X[Ee], we = W[Ee];
              for (let Ae = 0; Ae < De.length - 1; Ae++) {
                const qe = De[Ae], je = [qe, De[Ae + 1], we[Ae + 1], we[Ae], qe];
                o1(se, je) && (ae = Math.min(ae, M1(se, je)));
              }
            }
            return ae !== 1 / 0 && ae;
          }(V[0], V[1], z);
        }
      }, line: class extends Xo {
        constructor(c) {
          super(c, I1), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(c) {
          c === "line-gradient" && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof rc, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(c, o) {
          super.recalculate(c, o), this.paint._values["line-floorwidth"] = P1.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, c);
        }
        createBucket(c) {
          return new O_(c);
        }
        queryRadius(c) {
          const o = c, u = A1(Af("line-width", this, o), Af("line-gap-width", this, o)), d = Af("line-offset", this, o);
          return u / 2 + Math.abs(d) + Jp(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(c, o, u, d, y, x, w) {
          const C = Qp(c, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), x.angle, w), I = w / 2 * A1(this.paint.get("line-width").evaluate(o, u), this.paint.get("line-gap-width").evaluate(o, u)), R = this.paint.get("line-offset").evaluate(o, u);
          return R && (d = function(N, z) {
            const V = [];
            for (let W = 0; W < N.length; W++) {
              const X = N[W], se = [];
              for (let ae = 0; ae < X.length; ae++) {
                const Ee = X[ae - 1], De = X[ae], we = X[ae + 1], Ae = ae === 0 ? new Pe(0, 0) : De.sub(Ee)._unit()._perp(), qe = ae === X.length - 1 ? new Pe(0, 0) : we.sub(De)._unit()._perp(), je = Ae._add(qe)._unit(), Et = je.x * qe.x + je.y * qe.y;
                Et !== 0 && je._mult(1 / Et), se.push(je._mult(z)._add(De));
              }
              V.push(se);
            }
            return V;
          }(d, R * w)), function(N, z, V) {
            for (let W = 0; W < z.length; W++) {
              const X = z[W];
              if (N.length >= 3) {
                for (let se = 0; se < X.length; se++)
                  if (Uu(N, X[se]))
                    return !0;
              }
              if (VC(N, X, V))
                return !0;
            }
            return !1;
          }(C, d, I);
        }
        isTileClipped() {
          return !0;
        }
      }, symbol: mm, background: class extends Xo {
        constructor(c) {
          super(c, fP);
        }
      }, raster: class extends Xo {
        constructor(c) {
          super(c, dP);
        }
      } };
      class gP {
        constructor(o) {
          this._callback = o, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._callback();
          }, 0));
        }
        remove() {
          delete this._channel, this._callback = () => {
          };
        }
      }
      const ib = 63710088e-1;
      class Ln {
        constructor(o, u) {
          if (isNaN(o) || isNaN(u))
            throw new Error(`Invalid LngLat object: (${o}, ${u})`);
          if (this.lng = +o, this.lat = +u, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Ln(A(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(o) {
          const u = Math.PI / 180, d = this.lat * u, y = o.lat * u, x = Math.sin(d) * Math.sin(y) + Math.cos(d) * Math.cos(y) * Math.cos((o.lng - this.lng) * u);
          return ib * Math.acos(Math.min(x, 1));
        }
        toBounds(o = 0) {
          const u = 360 * o / 40075017, d = u / Math.cos(Math.PI / 180 * this.lat);
          return new Cc(new Ln(this.lng - d, this.lat - u), new Ln(this.lng + d, this.lat + u));
        }
        static convert(o) {
          if (o instanceof Ln)
            return o;
          if (Array.isArray(o) && (o.length === 2 || o.length === 3))
            return new Ln(Number(o[0]), Number(o[1]));
          if (!Array.isArray(o) && typeof o == "object" && o !== null)
            return new Ln(Number("lng" in o ? o.lng : o.lon), Number(o.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      class Cc {
        constructor(o, u) {
          o && (u ? this.setSouthWest(o).setNorthEast(u) : o.length === 4 ? this.setSouthWest([o[0], o[1]]).setNorthEast([o[2], o[3]]) : this.setSouthWest(o[0]).setNorthEast(o[1]));
        }
        setNorthEast(o) {
          return this._ne = o instanceof Ln ? new Ln(o.lng, o.lat) : Ln.convert(o), this;
        }
        setSouthWest(o) {
          return this._sw = o instanceof Ln ? new Ln(o.lng, o.lat) : Ln.convert(o), this;
        }
        extend(o) {
          const u = this._sw, d = this._ne;
          let y, x;
          if (o instanceof Ln)
            y = o, x = o;
          else {
            if (!(o instanceof Cc))
              return Array.isArray(o) ? o.length === 4 || o.every(Array.isArray) ? this.extend(Cc.convert(o)) : this.extend(Ln.convert(o)) : this;
            if (y = o._sw, x = o._ne, !y || !x)
              return this;
          }
          return u || d ? (u.lng = Math.min(y.lng, u.lng), u.lat = Math.min(y.lat, u.lat), d.lng = Math.max(x.lng, d.lng), d.lat = Math.max(x.lat, d.lat)) : (this._sw = new Ln(y.lng, y.lat), this._ne = new Ln(x.lng, x.lat)), this;
        }
        getCenter() {
          return new Ln((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new Ln(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new Ln(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(o) {
          const { lng: u, lat: d } = Ln.convert(o);
          let y = this._sw.lng <= u && u <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (y = this._sw.lng >= u && u >= this._ne.lng), this._sw.lat <= d && d <= this._ne.lat && y;
        }
        static convert(o) {
          return o instanceof Cc ? o : o && new Cc(o);
        }
      }
      const ob = 2 * Math.PI * ib;
      function ab(c) {
        return ob * Math.cos(c * Math.PI / 180);
      }
      function sb(c) {
        return (180 + c) / 360;
      }
      function lb(c) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + c * Math.PI / 360))) / 360;
      }
      function cb(c, o) {
        return c / ab(o);
      }
      function G_(c) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * c) * Math.PI / 180)) - 90;
      }
      class gm {
        constructor(o, u, d = 0) {
          this.x = +o, this.y = +u, this.z = +d;
        }
        static fromLngLat(o, u = 0) {
          const d = Ln.convert(o);
          return new gm(sb(d.lng), lb(d.lat), cb(u, d.lat));
        }
        toLngLat() {
          return new Ln(360 * this.x - 180, G_(this.y));
        }
        toAltitude() {
          return this.z * ab(G_(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / ob * (o = G_(this.y), 1 / Math.cos(o * Math.PI / 180));
          var o;
        }
      }
      function ub(c, o, u) {
        var d = 2 * Math.PI * 6378137 / 256 / Math.pow(2, u);
        return [c * d - 2 * Math.PI * 6378137 / 2, o * d - 2 * Math.PI * 6378137 / 2];
      }
      class q_ {
        constructor(o, u, d) {
          if (o < 0 || o > 25 || d < 0 || d >= Math.pow(2, o) || u < 0 || u >= Math.pow(2, o))
            throw new Error(`x=${u}, y=${d}, z=${o} outside of bounds. 0<=x<${Math.pow(2, o)}, 0<=y<${Math.pow(2, o)} 0<=z<=25 `);
          this.z = o, this.x = u, this.y = d, this.key = $f(0, o, o, u, d);
        }
        equals(o) {
          return this.z === o.z && this.x === o.x && this.y === o.y;
        }
        url(o, u, d) {
          const y = (w = this.y, C = this.z, I = ub(256 * (x = this.x), 256 * (w = Math.pow(2, C) - w - 1), C), R = ub(256 * (x + 1), 256 * (w + 1), C), I[0] + "," + I[1] + "," + R[0] + "," + R[1]);
          var x, w, C, I, R;
          const N = function(z, V, W) {
            let X, se = "";
            for (let ae = z; ae > 0; ae--)
              X = 1 << ae - 1, se += (V & X ? 1 : 0) + (W & X ? 2 : 0);
            return se;
          }(this.z, this.x, this.y);
          return o[(this.x + this.y) % o.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(d === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, u > 1 ? "@2x" : "").replace(/{quadkey}/g, N).replace(/{bbox-epsg-3857}/g, y);
        }
        isChildOf(o) {
          const u = this.z - o.z;
          return u > 0 && o.x === this.x >> u && o.y === this.y >> u;
        }
        getTilePoint(o) {
          const u = Math.pow(2, this.z);
          return new Pe((o.x * u - this.x) * Jn, (o.y * u - this.y) * Jn);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class hb {
        constructor(o, u) {
          this.wrap = o, this.canonical = u, this.key = $f(o, u.z, u.z, u.x, u.y);
        }
      }
      class ko {
        constructor(o, u, d, y, x) {
          if (o < d)
            throw new Error(`overscaledZ should be >= z; overscaledZ = ${o}; z = ${d}`);
          this.overscaledZ = o, this.wrap = u, this.canonical = new q_(d, +y, +x), this.key = $f(u, o, d, y, x);
        }
        clone() {
          return new ko(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(o) {
          return this.overscaledZ === o.overscaledZ && this.wrap === o.wrap && this.canonical.equals(o.canonical);
        }
        scaledTo(o) {
          if (o > this.overscaledZ)
            throw new Error(`targetZ > this.overscaledZ; targetZ = ${o}; overscaledZ = ${this.overscaledZ}`);
          const u = this.canonical.z - o;
          return o > this.canonical.z ? new ko(o, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ko(o, this.wrap, o, this.canonical.x >> u, this.canonical.y >> u);
        }
        calculateScaledKey(o, u) {
          if (o > this.overscaledZ)
            throw new Error(`targetZ > this.overscaledZ; targetZ = ${o}; overscaledZ = ${this.overscaledZ}`);
          const d = this.canonical.z - o;
          return o > this.canonical.z ? $f(this.wrap * +u, o, this.canonical.z, this.canonical.x, this.canonical.y) : $f(this.wrap * +u, o, o, this.canonical.x >> d, this.canonical.y >> d);
        }
        isChildOf(o) {
          if (o.wrap !== this.wrap)
            return !1;
          const u = this.canonical.z - o.canonical.z;
          return o.overscaledZ === 0 || o.overscaledZ < this.overscaledZ && o.canonical.x === this.canonical.x >> u && o.canonical.y === this.canonical.y >> u;
        }
        children(o) {
          if (this.overscaledZ >= o)
            return [new ko(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const u = this.canonical.z + 1, d = 2 * this.canonical.x, y = 2 * this.canonical.y;
          return [new ko(u, this.wrap, u, d, y), new ko(u, this.wrap, u, d + 1, y), new ko(u, this.wrap, u, d, y + 1), new ko(u, this.wrap, u, d + 1, y + 1)];
        }
        isLessThan(o) {
          return this.wrap < o.wrap || !(this.wrap > o.wrap) && (this.overscaledZ < o.overscaledZ || !(this.overscaledZ > o.overscaledZ) && (this.canonical.x < o.canonical.x || !(this.canonical.x > o.canonical.x) && this.canonical.y < o.canonical.y));
        }
        wrapped() {
          return new ko(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(o) {
          return new ko(this.overscaledZ, o, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new hb(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(o) {
          return this.canonical.getTilePoint(new gm(o.x - this.wrap, o.y));
        }
      }
      function $f(c, o, u, d, y) {
        (c *= 2) < 0 && (c = -1 * c - 1);
        const x = 1 << u;
        return (x * x * c + x * y + d).toString(36) + u.toString(36) + o.toString(36);
      }
      Ct("CanonicalTileID", q_), Ct("OverscaledTileID", ko, { omit: ["posMatrix"] });
      class fb {
        constructor(o, u, d) {
          if (this.uid = o, u.height !== u.width)
            throw new RangeError("DEM tiles must be square");
          if (d && d !== "mapbox" && d !== "terrarium")
            return void he(`"${d}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = u.height;
          const y = this.dim = u.height - 2;
          this.data = new Uint32Array(u.data.buffer), this.encoding = d || "mapbox";
          for (let x = 0; x < y; x++)
            this.data[this._idx(-1, x)] = this.data[this._idx(0, x)], this.data[this._idx(y, x)] = this.data[this._idx(y - 1, x)], this.data[this._idx(x, -1)] = this.data[this._idx(x, 0)], this.data[this._idx(x, y)] = this.data[this._idx(x, y - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(y, -1)] = this.data[this._idx(y - 1, 0)], this.data[this._idx(-1, y)] = this.data[this._idx(0, y - 1)], this.data[this._idx(y, y)] = this.data[this._idx(y - 1, y - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let x = 0; x < y; x++)
            for (let w = 0; w < y; w++) {
              const C = this.get(x, w);
              C > this.max && (this.max = C), C < this.min && (this.min = C);
            }
        }
        get(o, u) {
          const d = new Uint8Array(this.data.buffer), y = 4 * this._idx(o, u);
          return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(d[y], d[y + 1], d[y + 2]);
        }
        getUnpackVector() {
          return this.encoding === "terrarium" ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
        }
        _idx(o, u) {
          if (o < -1 || o >= this.dim + 1 || u < -1 || u >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (u + 1) * this.stride + (o + 1);
        }
        _unpackMapbox(o, u, d) {
          return (256 * o * 256 + 256 * u + d) / 10 - 1e4;
        }
        _unpackTerrarium(o, u, d) {
          return 256 * o + u + d / 256 - 32768;
        }
        getPixels() {
          return new Do({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(o, u, d) {
          if (this.dim !== o.dim)
            throw new Error("dem dimension mismatch");
          let y = u * this.dim, x = u * this.dim + this.dim, w = d * this.dim, C = d * this.dim + this.dim;
          switch (u) {
            case -1:
              y = x - 1;
              break;
            case 1:
              x = y + 1;
          }
          switch (d) {
            case -1:
              w = C - 1;
              break;
            case 1:
              C = w + 1;
          }
          const I = -u * this.dim, R = -d * this.dim;
          for (let N = w; N < C; N++)
            for (let z = y; z < x; z++)
              this.data[this._idx(z, N)] = o.data[this._idx(z + I, N + R)];
        }
      }
      Ct("DEMData", fb);
      class db {
        constructor(o) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let u = 0; u < o.length; u++) {
            const d = o[u];
            this._stringToNumber[d] = u, this._numberToString[u] = d;
          }
        }
        encode(o) {
          return this._stringToNumber[o];
        }
        decode(o) {
          if (o >= this._numberToString.length)
            throw new Error(`Out of bounds. Index requested n=${o} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[o];
        }
      }
      class pb {
        constructor(o, u, d, y, x) {
          this.type = "Feature", this._vectorTileFeature = o, o._z = u, o._x = d, o._y = y, this.properties = o.properties, this.id = x;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(o) {
          this._geometry = o;
        }
        toJSON() {
          const o = { geometry: this.geometry };
          for (const u in this)
            u !== "_geometry" && u !== "_vectorTileFeature" && (o[u] = this[u]);
          return o;
        }
      }
      class mb {
        constructor(o, u) {
          this.tileID = o, this.x = o.canonical.x, this.y = o.canonical.y, this.z = o.canonical.z, this.grid = new vc(Jn, 16, 0), this.grid3D = new vc(Jn, 16, 0), this.featureIndexArray = new sr(), this.promoteId = u;
        }
        insert(o, u, d, y, x, w) {
          const C = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(d, y, x);
          const I = w ? this.grid3D : this.grid;
          for (let R = 0; R < u.length; R++) {
            const N = u[R], z = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let V = 0; V < N.length; V++) {
              const W = N[V];
              z[0] = Math.min(z[0], W.x), z[1] = Math.min(z[1], W.y), z[2] = Math.max(z[2], W.x), z[3] = Math.max(z[3], W.y);
            }
            z[0] < Jn && z[1] < Jn && z[2] >= 0 && z[3] >= 0 && I.insert(C, z[0], z[1], z[2], z[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new ul.VectorTile(new R_(this.rawTileData)).layers, this.sourceLayerCoder = new db(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(o, u, d, y) {
          this.loadVTLayers();
          const x = o.params || {}, w = Jn / o.tileSize / o.scale, C = Ru(x.filter), I = o.queryGeometry, R = o.queryPadding * w, N = yb(I), z = this.grid.query(N.minX - R, N.minY - R, N.maxX + R, N.maxY + R), V = yb(o.cameraQueryGeometry), W = this.grid3D.query(V.minX - R, V.minY - R, V.maxX + R, V.maxY + R, (ae, Ee, De, we) => function(Ae, qe, je, Et, Ot) {
            for (const ft of Ae)
              if (qe <= ft.x && je <= ft.y && Et >= ft.x && Ot >= ft.y)
                return !0;
            const yt = [new Pe(qe, je), new Pe(qe, Ot), new Pe(Et, Ot), new Pe(Et, je)];
            if (Ae.length > 2) {
              for (const ft of yt)
                if (Uu(Ae, ft))
                  return !0;
            }
            for (let ft = 0; ft < Ae.length - 1; ft++)
              if (GC(Ae[ft], Ae[ft + 1], yt))
                return !0;
            return !1;
          }(o.cameraQueryGeometry, ae - R, Ee - R, De + R, we + R));
          for (const ae of W)
            z.push(ae);
          z.sort(yP);
          const X = {};
          let se;
          for (let ae = 0; ae < z.length; ae++) {
            const Ee = z[ae];
            if (Ee === se)
              continue;
            se = Ee;
            const De = this.featureIndexArray.get(Ee);
            let we = null;
            this.loadMatchingFeature(X, De.bucketIndex, De.sourceLayerIndex, De.featureIndex, C, x.layers, x.availableImages, u, d, y, (Ae, qe, je) => (we || (we = Tc(Ae)), qe.queryIntersectsFeature(I, Ae, je, we, this.z, o.transform, w, o.pixelPosMatrix)));
          }
          return X;
        }
        loadMatchingFeature(o, u, d, y, x, w, C, I, R, N, z) {
          const V = this.bucketLayerIDs[u];
          if (w && !function(ae, Ee) {
            for (let De = 0; De < ae.length; De++)
              if (Ee.indexOf(ae[De]) >= 0)
                return !0;
            return !1;
          }(w, V))
            return;
          const W = this.sourceLayerCoder.decode(d), X = this.vtLayers[W].feature(y);
          if (x.needGeometry) {
            const ae = Sc(X, !0);
            if (!x.filter(new xn(this.tileID.overscaledZ), ae, this.tileID.canonical))
              return;
          } else if (!x.filter(new xn(this.tileID.overscaledZ), X))
            return;
          const se = this.getId(X, W);
          for (let ae = 0; ae < V.length; ae++) {
            const Ee = V[ae];
            if (w && w.indexOf(Ee) < 0)
              continue;
            const De = I[Ee];
            if (!De)
              continue;
            let we = {};
            se && N && (we = N.getState(De.sourceLayer || "_geojsonTileLayer", se));
            const Ae = L({}, R[Ee]);
            Ae.paint = gb(Ae.paint, De.paint, X, we, C), Ae.layout = gb(Ae.layout, De.layout, X, we, C);
            const qe = !z || z(X, De, we);
            if (!qe)
              continue;
            const je = new pb(X, this.z, this.x, this.y, se);
            je.layer = Ae;
            let Et = o[Ee];
            Et === void 0 && (Et = o[Ee] = []), Et.push({ featureIndex: y, feature: je, intersectionZ: qe });
          }
        }
        lookupSymbolFeatures(o, u, d, y, x, w, C, I) {
          const R = {};
          this.loadVTLayers();
          const N = Ru(x);
          for (const z of o)
            this.loadMatchingFeature(R, d, y, z, N, w, C, I, u);
          return R;
        }
        hasLayer(o) {
          for (const u of this.bucketLayerIDs)
            for (const d of u)
              if (o === d)
                return !0;
          return !1;
        }
        getId(o, u) {
          let d = o.id;
          return this.promoteId && (d = o.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[u]], typeof d == "boolean" && (d = Number(d))), d;
        }
      }
      function gb(c, o, u, d, y) {
        return q(c, (x, w) => {
          const C = o instanceof wc ? o.get(w) : null;
          return C && C.evaluate ? C.evaluate(u, d, y) : C;
        });
      }
      function yb(c) {
        let o = 1 / 0, u = 1 / 0, d = -1 / 0, y = -1 / 0;
        for (const x of c)
          o = Math.min(o, x.x), u = Math.min(u, x.y), d = Math.max(d, x.x), y = Math.max(y, x.y);
        return { minX: o, minY: u, maxX: d, maxY: y };
      }
      function yP(c, o) {
        return o - c;
      }
      var W_;
      Ct("FeatureIndex", mb, { omit: ["rawTileData", "sourceLayerCoder"] }), s.PerformanceMarkers = void 0, (W_ = s.PerformanceMarkers || (s.PerformanceMarkers = {})).create = "create", W_.load = "load", W_.fullLoad = "fullLoad";
      let ym = null, Vf = [];
      const X_ = 1e3 / 30, _P = { mark(c) {
        performance.mark(c);
      }, frame(c) {
        const o = c;
        ym != null && Vf.push(o - ym), ym = o;
      }, clearMetrics() {
        ym = null, Vf = [], performance.clearMeasures("loadTime"), performance.clearMeasures("fullLoadTime");
        for (const c in s.PerformanceMarkers)
          performance.clearMarks(s.PerformanceMarkers[c]);
      }, getPerformanceMetrics() {
        performance.measure("loadTime", s.PerformanceMarkers.create, s.PerformanceMarkers.load), performance.measure("fullLoadTime", s.PerformanceMarkers.create, s.PerformanceMarkers.fullLoad);
        const c = performance.getEntriesByName("loadTime")[0].duration, o = performance.getEntriesByName("fullLoadTime")[0].duration, u = Vf.length, d = 1 / (Vf.reduce((x, w) => x + w, 0) / u / 1e3), y = Vf.filter((x) => x > X_).reduce((x, w) => x + (w - X_) / X_, 0);
        return { loadTime: c, fullLoadTime: o, fps: d, percentDroppedFrames: y / (u + y) * 100 };
      } };
      s.AJAXError = re, s.ARRAY_TYPE = Gi, s.Actor = class {
        constructor(c, o, u) {
          this.target = c, this.parent = o, this.mapId = u, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, j(["receive", "process"], this), this.invoker = new gP(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = Oe() ? c : window;
        }
        send(c, o, u, d, y = !1) {
          const x = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          u && (this.callbacks[x] = u);
          const w = dt(this.globalScope) ? void 0 : [];
          return this.target.postMessage({ id: x, type: c, hasCallback: !!u, targetMapId: d, mustQueue: y, sourceMapId: this.mapId, data: ys(o, w) }, w), { cancel: () => {
            u && delete this.callbacks[x], this.target.postMessage({ id: x, type: "<cancel>", targetMapId: d, sourceMapId: this.mapId });
          } };
        }
        receive(c) {
          const o = c.data, u = o.id;
          if (u && (!o.targetMapId || this.mapId === o.targetMapId))
            if (o.type === "<cancel>") {
              delete this.tasks[u];
              const d = this.cancelCallbacks[u];
              delete this.cancelCallbacks[u], d && d();
            } else
              Oe() || o.mustQueue ? (this.tasks[u] = o, this.taskQueue.push(u), this.invoker.trigger()) : this.processTask(u, o);
        }
        process() {
          if (!this.taskQueue.length)
            return;
          const c = this.taskQueue.shift(), o = this.tasks[c];
          delete this.tasks[c], this.taskQueue.length && this.invoker.trigger(), o && this.processTask(c, o);
        }
        processTask(c, o) {
          if (o.type === "<response>") {
            const u = this.callbacks[c];
            delete this.callbacks[c], u && (o.error ? u(za(o.error)) : u(null, za(o.data)));
          } else {
            let u = !1;
            const d = dt(this.globalScope) ? void 0 : [], y = o.hasCallback ? (C, I) => {
              u = !0, delete this.cancelCallbacks[c], this.target.postMessage({ id: c, type: "<response>", sourceMapId: this.mapId, error: C ? ys(C) : null, data: ys(I, d) }, d);
            } : (C) => {
              u = !0;
            };
            let x = null;
            const w = za(o.data);
            if (this.parent[o.type])
              x = this.parent[o.type](o.sourceMapId, w, y);
            else if (this.parent.getWorkerSource) {
              const C = o.type.split(".");
              x = this.parent.getWorkerSource(o.sourceMapId, C[0], w.source)[C[1]](w, y);
            } else
              y(new Error(`Could not find function ${o.type}`));
            !u && x && x.cancel && (this.cancelCallbacks[c] = x.cancel);
          }
        }
        remove() {
          this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);
        }
      }, s.AlphaImage = Rf, s.CanonicalTileID = q_, s.CollisionBoxArray = Be, s.CollisionCircleLayoutArray = class extends F {
      }, s.Color = K, s.DEMData = fb, s.DataConstantProperty = Dt, s.DictionaryCoder = db, s.EXTENT = Jn, s.ErrorEvent = Ut, s.EvaluationParameters = xn, s.Event = St, s.Evented = Wt, s.FeatureIndex = mb, s.FillBucket = I_, s.FillExtrusionBucket = A_, s.GeoJSONFeature = pb, s.ImageAtlas = B1, s.ImagePosition = D_, s.LineBucket = O_, s.LineStripIndexArray = class extends oe {
      }, s.LngLat = Ln, s.LngLatBounds = Cc, s.MercatorCoordinate = gm, s.ONE_EM = mi, s.OverscaledTileID = ko, s.PerformanceUtils = _P, s.PosArray = zt, s.Properties = pi, s.QuadTriangleArray = class extends G {
      }, s.RGBAImage = Do, s.RasterBoundsArray = class extends g {
      }, s.RequestPerformance = class {
        constructor(c) {
          this._marks = { start: [c.url, "start"].join("#"), end: [c.url, "end"].join("#"), measure: c.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let c = performance.getEntriesByName(this._marks.measure);
          return c.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), c = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), c;
        }
      }, s.ResourceType = qr, s.SegmentVector = hr, s.SymbolBucket = Xu, s.Transitionable = Wp, s.TriangleIndexArray = Vi, s.Uniform1f = bs, s.Uniform1i = class extends xs {
        constructor(c, o) {
          super(c, o), this.current = 0;
        }
        set(c) {
          this.current !== c && (this.current = c, this.gl.uniform1i(this.location, c));
        }
      }, s.Uniform2f = class extends xs {
        constructor(c, o) {
          super(c, o), this.current = [0, 0];
        }
        set(c) {
          c[0] === this.current[0] && c[1] === this.current[1] || (this.current = c, this.gl.uniform2f(this.location, c[0], c[1]));
        }
      }, s.Uniform3f = class extends xs {
        constructor(c, o) {
          super(c, o), this.current = [0, 0, 0];
        }
        set(c) {
          c[0] === this.current[0] && c[1] === this.current[1] && c[2] === this.current[2] || (this.current = c, this.gl.uniform3f(this.location, c[0], c[1], c[2]));
        }
      }, s.Uniform4f = zu, s.UniformColor = t1, s.UniformMatrix4f = class extends xs {
        constructor(c, o) {
          super(c, o), this.current = BC;
        }
        set(c) {
          if (c[12] !== this.current[12] || c[0] !== this.current[0])
            return this.current = c, void this.gl.uniformMatrix4fv(this.location, !1, c);
          for (let o = 1; o < 16; o++)
            if (c[o] !== this.current[o]) {
              this.current = c, this.gl.uniformMatrix4fv(this.location, !1, c);
              break;
            }
        }
      }, s.UnwrappedTileID = hb, s.ValidationError = We, s.ZoomHistory = yf, s.add = function(c, o, u) {
        return c[0] = o[0] + u[0], c[1] = o[1] + u[1], c[2] = o[2] + u[2], c;
      }, s.addDynamicAttributes = B_, s.asyncAll = function(c, o, u) {
        if (!c.length)
          return u(null, []);
        let d = c.length;
        const y = new Array(c.length);
        let x = null;
        c.forEach((w, C) => {
          o(w, (I, R) => {
            I && (x = I), y[C] = R, --d == 0 && u(x, y);
          });
        });
      }, s.bezier = E, s.bindAll = j, s.cacheEntryPossiblyAdded = function(c) {
        Jt++, Jt > on && (c.getActor().send("enforceCacheSizeLimit", Yt), Jt = 0);
      }, s.clamp = S, s.clearTileCache = function(c) {
        const o = caches.delete(kt);
        c && o.catch(c).then(() => c());
      }, s.clipLine = Y1, s.clone = function(c) {
        var o = new Gi(16);
        return o[0] = c[0], o[1] = c[1], o[2] = c[2], o[3] = c[3], o[4] = c[4], o[5] = c[5], o[6] = c[6], o[7] = c[7], o[8] = c[8], o[9] = c[9], o[10] = c[10], o[11] = c[11], o[12] = c[12], o[13] = c[13], o[14] = c[14], o[15] = c[15], o;
      }, s.clone$1 = ne, s.clone$2 = function(c) {
        var o = new Gi(3);
        return o[0] = c[0], o[1] = c[1], o[2] = c[2], o;
      }, s.collisionCircleLayout = NI, s.config = it, s.copy = function(c, o) {
        return c[0] = o[0], c[1] = o[1], c[2] = o[2], c[3] = o[3], c[4] = o[4], c[5] = o[5], c[6] = o[6], c[7] = o[7], c[8] = o[8], c[9] = o[9], c[10] = o[10], c[11] = o[11], c[12] = o[12], c[13] = o[13], c[14] = o[14], c[15] = o[15], c;
      }, s.create = function() {
        var c = new Gi(16);
        return Gi != Float32Array && (c[1] = 0, c[2] = 0, c[3] = 0, c[4] = 0, c[6] = 0, c[7] = 0, c[8] = 0, c[9] = 0, c[11] = 0, c[12] = 0, c[13] = 0, c[14] = 0), c[0] = 1, c[5] = 1, c[10] = 1, c[15] = 1, c;
      }, s.create$1 = c1, s.createExpression = lc, s.createFilter = Ru, s.createLayout = jn, s.createStyleLayer = function(c) {
        return c.type === "custom" ? new pP(c) : new mP[c.type](c);
      }, s.cross = function(c, o, u) {
        var d = o[0], y = o[1], x = o[2], w = u[0], C = u[1], I = u[2];
        return c[0] = y * I - x * C, c[1] = x * w - d * I, c[2] = d * C - y * w, c;
      }, s.dot = function(c, o) {
        return c[0] * o[0] + c[1] * o[1] + c[2] * o[2];
      }, s.dot$1 = function(c, o) {
        return c[0] * o[0] + c[1] * o[1] + c[2] * o[2] + c[3] * o[3];
      }, s.ease = T, s.emitValidationErrors = Du, s.enforceCacheSizeLimit = function(c) {
        or(), Er && Er.then((o) => {
          o.keys().then((u) => {
            for (let d = 0; d < u.length - c; d++)
              o.delete(u[d]);
          });
        });
      }, s.equals = function(c, o) {
        var u = c[0], d = c[1], y = c[2], x = c[3], w = c[4], C = c[5], I = c[6], R = c[7], N = c[8], z = c[9], V = c[10], W = c[11], X = c[12], se = c[13], ae = c[14], Ee = c[15], De = o[0], we = o[1], Ae = o[2], qe = o[3], je = o[4], Et = o[5], Ot = o[6], yt = o[7], ft = o[8], ut = o[9], _t = o[10], pt = o[11], et = o[12], Bt = o[13], Nt = o[14], lr = o[15];
        return Math.abs(u - De) <= ji * Math.max(1, Math.abs(u), Math.abs(De)) && Math.abs(d - we) <= ji * Math.max(1, Math.abs(d), Math.abs(we)) && Math.abs(y - Ae) <= ji * Math.max(1, Math.abs(y), Math.abs(Ae)) && Math.abs(x - qe) <= ji * Math.max(1, Math.abs(x), Math.abs(qe)) && Math.abs(w - je) <= ji * Math.max(1, Math.abs(w), Math.abs(je)) && Math.abs(C - Et) <= ji * Math.max(1, Math.abs(C), Math.abs(Et)) && Math.abs(I - Ot) <= ji * Math.max(1, Math.abs(I), Math.abs(Ot)) && Math.abs(R - yt) <= ji * Math.max(1, Math.abs(R), Math.abs(yt)) && Math.abs(N - ft) <= ji * Math.max(1, Math.abs(N), Math.abs(ft)) && Math.abs(z - ut) <= ji * Math.max(1, Math.abs(z), Math.abs(ut)) && Math.abs(V - _t) <= ji * Math.max(1, Math.abs(V), Math.abs(_t)) && Math.abs(W - pt) <= ji * Math.max(1, Math.abs(W), Math.abs(pt)) && Math.abs(X - et) <= ji * Math.max(1, Math.abs(X), Math.abs(et)) && Math.abs(se - Bt) <= ji * Math.max(1, Math.abs(se), Math.abs(Bt)) && Math.abs(ae - Nt) <= ji * Math.max(1, Math.abs(ae), Math.abs(Nt)) && Math.abs(Ee - lr) <= ji * Math.max(1, Math.abs(Ee), Math.abs(lr));
      }, s.evaluateSizeForFeature = function(c, { uSize: o, uSizeT: u }, { lowerSize: d, upperSize: y }) {
        return c.kind === "source" ? d / Ts : c.kind === "composite" ? _n(d / Ts, y / Ts, u) : o;
      }, s.evaluateSizeForZoom = function(c, o) {
        let u = 0, d = 0;
        if (c.kind === "constant")
          d = c.layoutSize;
        else if (c.kind !== "source") {
          const { interpolationType: y, minZoom: x, maxZoom: w } = c, C = y ? S(Qi.interpolationFactor(y, o, x, w), 0, 1) : 0;
          c.kind === "camera" ? d = _n(c.minSize, c.maxSize, C) : u = C;
        }
        return { uSizeT: u, uSize: d };
      }, s.evaluateVariableOffset = eb, s.evented = Tf, s.exported = ze, s.exported$1 = Ht, s.extend = L, s.filterObject = H, s.fromRotation = function(c, o) {
        var u = Math.sin(o), d = Math.cos(o);
        return c[0] = d, c[1] = u, c[2] = 0, c[3] = -u, c[4] = d, c[5] = 0, c[6] = 0, c[7] = 0, c[8] = 1, c;
      }, s.fromScaling = function(c, o) {
        return c[0] = o[0], c[1] = 0, c[2] = 0, c[3] = 0, c[4] = 0, c[5] = o[1], c[6] = 0, c[7] = 0, c[8] = 0, c[9] = 0, c[10] = o[2], c[11] = 0, c[12] = 0, c[13] = 0, c[14] = 0, c[15] = 1, c;
      }, s.getAnchorAlignment = N_, s.getAnchorJustification = z_, s.getArrayBuffer = Ge, s.getImage = Ke, s.getJSON = function(c, o) {
        return Ze(L(c, { type: "json" }), o);
      }, s.getOverlapMode = j_, s.getRTLTextPluginStatus = xc, s.getReferrer = pe, s.getVideo = function(c, o) {
        const u = window.document.createElement("video");
        u.muted = !0, u.onloadstart = function() {
          o(null, u);
        };
        for (let d = 0; d < c.length; d++) {
          const y = window.document.createElement("source");
          rt(c[d]) || (u.crossOrigin = "Anonymous"), y.src = c[d], u.appendChild(y);
        }
        return { cancel: () => {
        } };
      }, s.identity = v_, s.invert = function(c, o) {
        var u = o[0], d = o[1], y = o[2], x = o[3], w = o[4], C = o[5], I = o[6], R = o[7], N = o[8], z = o[9], V = o[10], W = o[11], X = o[12], se = o[13], ae = o[14], Ee = o[15], De = u * C - d * w, we = u * I - y * w, Ae = u * R - x * w, qe = d * I - y * C, je = d * R - x * C, Et = y * R - x * I, Ot = N * se - z * X, yt = N * ae - V * X, ft = N * Ee - W * X, ut = z * ae - V * se, _t = z * Ee - W * se, pt = V * Ee - W * ae, et = De * pt - we * _t + Ae * ut + qe * ft - je * yt + Et * Ot;
        return et ? (c[0] = (C * pt - I * _t + R * ut) * (et = 1 / et), c[1] = (y * _t - d * pt - x * ut) * et, c[2] = (se * Et - ae * je + Ee * qe) * et, c[3] = (V * je - z * Et - W * qe) * et, c[4] = (I * ft - w * pt - R * yt) * et, c[5] = (u * pt - y * ft + x * yt) * et, c[6] = (ae * Ae - X * Et - Ee * we) * et, c[7] = (N * Et - V * Ae + W * we) * et, c[8] = (w * _t - C * ft + R * Ot) * et, c[9] = (d * ft - u * _t - x * Ot) * et, c[10] = (X * je - se * Ae + Ee * De) * et, c[11] = (z * Ae - N * je - W * De) * et, c[12] = (C * yt - w * ut - I * Ot) * et, c[13] = (u * ut - d * yt + y * Ot) * et, c[14] = (se * we - X * qe - ae * De) * et, c[15] = (N * qe - z * we + V * De) * et, c) : null;
      }, s.isImageBitmap = xe, s.isSafari = dt, s.isWorker = Oe, s.keysDifference = function(c, o) {
        const u = [];
        for (const d in c)
          d in o || u.push(d);
        return u;
      }, s.lazyLoadRTLTextPlugin = function() {
        yo.isLoading() || yo.isLoaded() || xc() !== "deferred" || qp();
      }, s.makeRequest = Ze, s.mapObject = q, s.mercatorXfromLng = sb, s.mercatorYfromLat = lb, s.mercatorZfromAltitude = cb, s.mul = XC, s.mul$1 = function(c, o, u) {
        return c[0] = o[0] * u[0], c[1] = o[1] * u[1], c[2] = o[2] * u[2], c[3] = o[3] * u[3], c;
      }, s.multiply = u1, s.nextPowerOfTwo = function(c) {
        return c <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(c) / Math.LN2));
      }, s.normalize = function(c, o) {
        var u = o[0], d = o[1], y = o[2], x = u * u + d * d + y * y;
        return x > 0 && (x = 1 / Math.sqrt(x)), c[0] = o[0] * x, c[1] = o[1] * x, c[2] = o[2] * x, c;
      }, s.number = _n, s.ortho = function(c, o, u, d, y, x, w) {
        var C = 1 / (o - u), I = 1 / (d - y), R = 1 / (x - w);
        return c[0] = -2 * C, c[1] = 0, c[2] = 0, c[3] = 0, c[4] = 0, c[5] = -2 * I, c[6] = 0, c[7] = 0, c[8] = 0, c[9] = 0, c[10] = 2 * R, c[11] = 0, c[12] = (o + u) * C, c[13] = (y + d) * I, c[14] = (w + x) * R, c[15] = 1, c;
      }, s.parseCacheControl = Me, s.parseGlyphPbf = function(c) {
        return new R_(c).readFields(XI, []);
      }, s.pbf = R_, s.performSymbolLayout = function(c) {
        c.bucket.createArrays(), c.bucket.tilePixelRatio = Jn / (512 * c.bucket.overscaling), c.bucket.compareText = {}, c.bucket.iconsNeedLinear = !1;
        const o = c.bucket.layers[0].layout, u = c.bucket.layers[0]._unevaluatedLayout._values, d = { layoutIconSize: u["icon-size"].possiblyEvaluate(new xn(c.bucket.zoom + 1), c.canonical), layoutTextSize: u["text-size"].possiblyEvaluate(new xn(c.bucket.zoom + 1), c.canonical), textMaxSize: u["text-size"].possiblyEvaluate(new xn(18)) };
        if (c.bucket.textSizeData.kind === "composite") {
          const { minZoom: I, maxZoom: R } = c.bucket.textSizeData;
          d.compositeTextSizes = [u["text-size"].possiblyEvaluate(new xn(I), c.canonical), u["text-size"].possiblyEvaluate(new xn(R), c.canonical)];
        }
        if (c.bucket.iconSizeData.kind === "composite") {
          const { minZoom: I, maxZoom: R } = c.bucket.iconSizeData;
          d.compositeIconSizes = [u["icon-size"].possiblyEvaluate(new xn(I), c.canonical), u["icon-size"].possiblyEvaluate(new xn(R), c.canonical)];
        }
        const y = o.get("text-line-height") * mi, x = o.get("text-rotation-alignment") !== "viewport" && o.get("symbol-placement") !== "point", w = o.get("text-keep-upright"), C = o.get("text-size");
        for (const I of c.bucket.features) {
          const R = o.get("text-font").evaluate(I, {}, c.canonical).join(","), N = C.evaluate(I, {}, c.canonical), z = d.layoutTextSize.evaluate(I, {}, c.canonical), V = d.layoutIconSize.evaluate(I, {}, c.canonical), W = { horizontal: {}, vertical: void 0 }, X = I.text;
          let se, ae = [0, 0];
          if (X) {
            const we = X.toString(), Ae = o.get("text-letter-spacing").evaluate(I, {}, c.canonical) * mi, qe = h_(we) ? Ae : 0, je = o.get("text-anchor").evaluate(I, {}, c.canonical), Et = o.get("text-variable-anchor");
            if (!Et) {
              const _t = o.get("text-radial-offset").evaluate(I, {}, c.canonical);
              ae = _t ? eb(je, [_t * mi, F_]) : o.get("text-offset").evaluate(I, {}, c.canonical).map((pt) => pt * mi);
            }
            let Ot = x ? "center" : o.get("text-justify").evaluate(I, {}, c.canonical);
            const yt = o.get("symbol-placement"), ft = yt === "point" ? o.get("text-max-width").evaluate(I, {}, c.canonical) * mi : 0, ut = () => {
              c.bucket.allowVerticalPlacement && ku(we) && (W.vertical = lm(X, c.glyphMap, c.glyphPositions, c.imagePositions, R, ft, y, je, "left", qe, ae, s.WritingMode.vertical, !0, yt, z, N));
            };
            if (!x && Et) {
              const _t = Ot === "auto" ? Et.map((et) => z_(et)) : [Ot];
              let pt = !1;
              for (let et = 0; et < _t.length; et++) {
                const Bt = _t[et];
                if (!W.horizontal[Bt])
                  if (pt)
                    W.horizontal[Bt] = W.horizontal[0];
                  else {
                    const Nt = lm(X, c.glyphMap, c.glyphPositions, c.imagePositions, R, ft, y, "center", Bt, qe, ae, s.WritingMode.horizontal, !1, yt, z, N);
                    Nt && (W.horizontal[Bt] = Nt, pt = Nt.positionedLines.length === 1);
                  }
              }
              ut();
            } else {
              Ot === "auto" && (Ot = z_(je));
              const _t = lm(X, c.glyphMap, c.glyphPositions, c.imagePositions, R, ft, y, je, Ot, qe, ae, s.WritingMode.horizontal, !1, yt, z, N);
              _t && (W.horizontal[Ot] = _t), ut(), ku(we) && x && w && (W.vertical = lm(X, c.glyphMap, c.glyphPositions, c.imagePositions, R, ft, y, je, Ot, qe, ae, s.WritingMode.vertical, !1, yt, z, N));
            }
          }
          let Ee = !1;
          if (I.icon && I.icon.name) {
            const we = c.imageMap[I.icon.name];
            we && (se = QI(c.imagePositions[I.icon.name], o.get("icon-offset").evaluate(I, {}, c.canonical), o.get("icon-anchor").evaluate(I, {}, c.canonical)), Ee = !!we.sdf, c.bucket.sdfIcons === void 0 ? c.bucket.sdfIcons = Ee : c.bucket.sdfIcons !== Ee && he("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (we.pixelRatio !== c.bucket.pixelRatio || o.get("icon-rotate").constantOr(1) !== 0) && (c.bucket.iconsNeedLinear = !0));
          }
          const De = rb(W.horizontal) || W.vertical;
          c.bucket.iconsInText = !!De && De.iconsInText, (De || se) && aP(c.bucket, I, W, se, c.imageMap, d, z, V, ae, Ee, c.canonical);
        }
        c.showCollisionBoxes && c.bucket.generateCollisionDebugBuffers();
      }, s.perspective = function(c, o, u, d, y) {
        var x, w = 1 / Math.tan(o / 2);
        return c[0] = w / u, c[1] = 0, c[2] = 0, c[3] = 0, c[4] = 0, c[5] = w, c[6] = 0, c[7] = 0, c[8] = 0, c[9] = 0, c[11] = -1, c[12] = 0, c[13] = 0, c[15] = 0, y != null && y !== 1 / 0 ? (c[10] = (y + d) * (x = 1 / (d - y)), c[14] = 2 * y * d * x) : (c[10] = -1, c[14] = -2 * d), c;
      }, s.pick = function(c, o) {
        const u = {};
        for (let d = 0; d < o.length; d++) {
          const y = o[d];
          y in c && (u[y] = c[y]);
        }
        return u;
      }, s.plugin = yo, s.pointGeometry = Pe, s.polygonIntersectsPolygon = o1, s.potpack = z1, s.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], s.register = Ct, s.registerForPluginStateChange = function(c) {
        return c({ pluginStatus: $i, pluginURL: Ba }), Tf.on("pluginStateChange", c), c;
      }, s.renderColorRamp = y1, s.rotateX = function(c, o, u) {
        var d = Math.sin(u), y = Math.cos(u), x = o[4], w = o[5], C = o[6], I = o[7], R = o[8], N = o[9], z = o[10], V = o[11];
        return o !== c && (c[0] = o[0], c[1] = o[1], c[2] = o[2], c[3] = o[3], c[12] = o[12], c[13] = o[13], c[14] = o[14], c[15] = o[15]), c[4] = x * y + R * d, c[5] = w * y + N * d, c[6] = C * y + z * d, c[7] = I * y + V * d, c[8] = R * y - x * d, c[9] = N * y - w * d, c[10] = z * y - C * d, c[11] = V * y - I * d, c;
      }, s.rotateZ = function(c, o, u) {
        var d = Math.sin(u), y = Math.cos(u), x = o[0], w = o[1], C = o[2], I = o[3], R = o[4], N = o[5], z = o[6], V = o[7];
        return o !== c && (c[8] = o[8], c[9] = o[9], c[10] = o[10], c[11] = o[11], c[12] = o[12], c[13] = o[13], c[14] = o[14], c[15] = o[15]), c[0] = x * y + R * d, c[1] = w * y + N * d, c[2] = C * y + z * d, c[3] = I * y + V * d, c[4] = R * y - x * d, c[5] = N * y - w * d, c[6] = z * y - C * d, c[7] = V * y - I * d, c;
      }, s.scale = function(c, o, u) {
        var d = u[0], y = u[1], x = u[2];
        return c[0] = o[0] * d, c[1] = o[1] * d, c[2] = o[2] * d, c[3] = o[3] * d, c[4] = o[4] * y, c[5] = o[5] * y, c[6] = o[6] * y, c[7] = o[7] * y, c[8] = o[8] * x, c[9] = o[9] * x, c[10] = o[10] * x, c[11] = o[11] * x, c[12] = o[12], c[13] = o[13], c[14] = o[14], c[15] = o[15], c;
      }, s.scale$1 = function(c, o, u) {
        return c[0] = o[0] * u, c[1] = o[1] * u, c[2] = o[2] * u, c;
      }, s.setCacheLimits = function(c, o) {
        Yt = c, on = o;
      }, s.setRTLTextPlugin = function(c, o, u = !1) {
        if ($i === xf || $i === bf || $i === wf)
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        Ba = ze.resolveURL(c), $i = xf, Ef = o, al(), u || qp();
      }, s.spec = Ce, s.sphericalToCartesian = function([c, o, u]) {
        return o += 90, o *= Math.PI / 180, u *= Math.PI / 180, { x: c * Math.cos(o) * Math.sin(u), y: c * Math.sin(o) * Math.sin(u), z: c * Math.cos(u) };
      }, s.sqrLen = function(c) {
        var o = c[0], u = c[1];
        return o * o + u * u;
      }, s.sub = function(c, o, u) {
        return c[0] = o[0] - u[0], c[1] = o[1] - u[1], c[2] = o[2] - u[2], c;
      }, s.toEvaluationFeature = Sc, s.transformMat3 = function(c, o, u) {
        var d = o[0], y = o[1], x = o[2];
        return c[0] = d * u[0] + y * u[3] + x * u[6], c[1] = d * u[1] + y * u[4] + x * u[7], c[2] = d * u[2] + y * u[5] + x * u[8], c;
      }, s.transformMat4 = em, s.transformMat4$1 = function(c, o, u) {
        var d = o[0], y = o[1];
        return c[0] = u[0] * d + u[4] * y + u[12], c[1] = u[1] * d + u[5] * y + u[13], c;
      }, s.translate = function(c, o, u) {
        var d, y, x, w, C, I, R, N, z, V, W, X, se = u[0], ae = u[1], Ee = u[2];
        return o === c ? (c[12] = o[0] * se + o[4] * ae + o[8] * Ee + o[12], c[13] = o[1] * se + o[5] * ae + o[9] * Ee + o[13], c[14] = o[2] * se + o[6] * ae + o[10] * Ee + o[14], c[15] = o[3] * se + o[7] * ae + o[11] * Ee + o[15]) : (y = o[1], x = o[2], w = o[3], C = o[4], I = o[5], R = o[6], N = o[7], z = o[8], V = o[9], W = o[10], X = o[11], c[0] = d = o[0], c[1] = y, c[2] = x, c[3] = w, c[4] = C, c[5] = I, c[6] = R, c[7] = N, c[8] = z, c[9] = V, c[10] = W, c[11] = X, c[12] = d * se + C * ae + z * Ee + o[12], c[13] = y * se + I * ae + V * Ee + o[13], c[14] = x * se + R * ae + W * Ee + o[14], c[15] = w * se + N * ae + X * Ee + o[15]), c;
      }, s.triggerPluginCompletionEvent = Gp, s.unicodeBlockLookup = gt, s.uniqueId = function() {
        return B++;
      }, s.validateCustomStyleLayer = function(c) {
        const o = [], u = c.id;
        return u === void 0 && o.push({ message: `layers.${u}: missing required property "id"` }), c.render === void 0 && o.push({ message: `layers.${u}: missing required method "render"` }), c.renderingMode && c.renderingMode !== "2d" && c.renderingMode !== "3d" && o.push({ message: `layers.${u}: property "renderingMode" must be either "2d" or "3d"` }), o;
      }, s.validateLight = gf, s.validateStyle = _c, s.vectorTile = ul, s.warnOnce = he, s.wrap = A;
    }), l(["./shared"], function(s) {
      function m(Y) {
        const k = typeof Y;
        if (k === "number" || k === "boolean" || k === "string" || Y == null)
          return JSON.stringify(Y);
        if (Array.isArray(Y)) {
          let K = "[";
          for (const le of Y)
            K += `${m(le)},`;
          return `${K}]`;
        }
        const U = Object.keys(Y).sort();
        let Z = "{";
        for (let K = 0; K < U.length; K++)
          Z += `${JSON.stringify(U[K])}:${m(Y[U[K]])},`;
        return `${Z}}`;
      }
      function v(Y) {
        let k = "";
        for (const U of s.refProperties)
          k += `/${m(Y[U])}`;
        return k;
      }
      class E {
        constructor(k) {
          this.keyCache = {}, k && this.replace(k);
        }
        replace(k) {
          this._layerConfigs = {}, this._layers = {}, this.update(k, []);
        }
        update(k, U) {
          for (const K of k) {
            this._layerConfigs[K.id] = K;
            const le = this._layers[K.id] = s.createStyleLayer(K);
            le._featureFilter = s.createFilter(le.filter), this.keyCache[K.id] && delete this.keyCache[K.id];
          }
          for (const K of U)
            delete this.keyCache[K], delete this._layerConfigs[K], delete this._layers[K];
          this.familiesBySource = {};
          const Z = function(K, le) {
            const me = {};
            for (let ce = 0; ce < K.length; ce++) {
              const ge = le && le[K[ce].id] || v(K[ce]);
              le && (le[K[ce].id] = ge);
              let ye = me[ge];
              ye || (ye = me[ge] = []), ye.push(K[ce]);
            }
            const fe = [];
            for (const ce in me)
              fe.push(me[ce]);
            return fe;
          }(Object.values(this._layerConfigs), this.keyCache);
          for (const K of Z) {
            const le = K.map((J) => this._layers[J.id]), me = le[0];
            if (me.visibility === "none")
              continue;
            const fe = me.source || "";
            let ce = this.familiesBySource[fe];
            ce || (ce = this.familiesBySource[fe] = {});
            const ge = me.sourceLayer || "_geojsonTileLayer";
            let ye = ce[ge];
            ye || (ye = ce[ge] = []), ye.push(le);
          }
        }
      }
      class T {
        constructor(k) {
          const U = {}, Z = [];
          for (const fe in k) {
            const ce = k[fe], ge = U[fe] = {};
            for (const ye in ce) {
              const J = ce[+ye];
              if (!J || J.bitmap.width === 0 || J.bitmap.height === 0)
                continue;
              const ue = { x: 0, y: 0, w: J.bitmap.width + 2, h: J.bitmap.height + 2 };
              Z.push(ue), ge[ye] = { rect: ue, metrics: J.metrics };
            }
          }
          const { w: K, h: le } = s.potpack(Z), me = new s.AlphaImage({ width: K || 1, height: le || 1 });
          for (const fe in k) {
            const ce = k[fe];
            for (const ge in ce) {
              const ye = ce[+ge];
              if (!ye || ye.bitmap.width === 0 || ye.bitmap.height === 0)
                continue;
              const J = U[fe][ge].rect;
              s.AlphaImage.copy(ye.bitmap, me, { x: 0, y: 0 }, { x: J.x + 1, y: J.y + 1 }, ye.bitmap);
            }
          }
          this.image = me, this.positions = U;
        }
      }
      s.register("GlyphAtlas", T);
      class S {
        constructor(k) {
          this.tileID = new s.OverscaledTileID(k.tileID.overscaledZ, k.tileID.wrap, k.tileID.canonical.z, k.tileID.canonical.x, k.tileID.canonical.y), this.uid = k.uid, this.zoom = k.zoom, this.pixelRatio = k.pixelRatio, this.tileSize = k.tileSize, this.source = k.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = k.showCollisionBoxes, this.collectResourceTiming = !!k.collectResourceTiming, this.returnDependencies = !!k.returnDependencies, this.promoteId = k.promoteId;
        }
        parse(k, U, Z, K, le) {
          this.status = "parsing", this.data = k, this.collisionBoxArray = new s.CollisionBoxArray();
          const me = new s.DictionaryCoder(Object.keys(k.layers).sort()), fe = new s.FeatureIndex(this.tileID, this.promoteId);
          fe.bucketLayerIDs = [];
          const ce = {}, ge = { featureIndex: fe, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: Z }, ye = U.familiesBySource[this.source];
          for (const Rt in ye) {
            const Qt = k.layers[Rt];
            if (!Qt)
              continue;
            Qt.version === 1 && s.warnOnce(`Vector tile source "${this.source}" layer "${Rt}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const gr = me.encode(Rt), jr = [];
            for (let ii = 0; ii < Qt.length; ii++) {
              const yn = Qt.feature(ii), bi = fe.getId(yn, Rt);
              jr.push({ feature: yn, id: bi, index: ii, sourceLayerIndex: gr });
            }
            for (const ii of ye[Rt]) {
              const yn = ii[0];
              yn.source !== this.source && s.warnOnce(`layer.source = ${yn.source} does not equal this.source = ${this.source}`), yn.minzoom && this.zoom < Math.floor(yn.minzoom) || yn.maxzoom && this.zoom >= yn.maxzoom || yn.visibility !== "none" && (A(ii, this.zoom, Z), (ce[yn.id] = yn.createBucket({ index: fe.bucketLayerIDs.length, layers: ii, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: gr, sourceID: this.source })).populate(jr, ge, this.tileID.canonical), fe.bucketLayerIDs.push(ii.map((bi) => bi.id)));
            }
          }
          let J, ue, Ne, ot;
          const lt = s.mapObject(ge.glyphDependencies, (Rt) => Object.keys(Rt).map(Number));
          Object.keys(lt).length ? K.send("getGlyphs", { uid: this.uid, stacks: lt }, (Rt, Qt) => {
            J || (J = Rt, ue = Qt, ur.call(this));
          }) : ue = {};
          const Mt = Object.keys(ge.iconDependencies);
          Mt.length ? K.send("getImages", { icons: Mt, source: this.source, tileID: this.tileID, type: "icons" }, (Rt, Qt) => {
            J || (J = Rt, Ne = Qt, ur.call(this));
          }) : Ne = {};
          const Pt = Object.keys(ge.patternDependencies);
          function ur() {
            if (J)
              return le(J);
            if (ue && Ne && ot) {
              const Rt = new T(ue), Qt = new s.ImageAtlas(Ne, ot);
              for (const gr in ce) {
                const jr = ce[gr];
                jr instanceof s.SymbolBucket ? (A(jr.layers, this.zoom, Z), s.performSymbolLayout({ bucket: jr, glyphMap: ue, glyphPositions: Rt.positions, imageMap: Ne, imagePositions: Qt.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : jr.hasPattern && (jr instanceof s.LineBucket || jr instanceof s.FillBucket || jr instanceof s.FillExtrusionBucket) && (A(jr.layers, this.zoom, Z), jr.addFeatures(ge, this.tileID.canonical, Qt.patternPositions));
              }
              this.status = "done", le(null, { buckets: Object.values(ce).filter((gr) => !gr.isEmpty()), featureIndex: fe, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Rt.image, imageAtlas: Qt, glyphMap: this.returnDependencies ? ue : null, iconMap: this.returnDependencies ? Ne : null, glyphPositions: this.returnDependencies ? Rt.positions : null });
            }
          }
          Pt.length ? K.send("getImages", { icons: Pt, source: this.source, tileID: this.tileID, type: "patterns" }, (Rt, Qt) => {
            J || (J = Rt, ot = Qt, ur.call(this));
          }) : ot = {}, ur.call(this);
        }
      }
      function A(Y, k, U) {
        const Z = new s.EvaluationParameters(k);
        for (const K of Y)
          K.recalculate(Z, U);
      }
      function L(Y, k) {
        const U = s.getArrayBuffer(Y.request, (Z, K, le, me) => {
          Z ? k(Z) : K && k(null, { vectorTile: new s.vectorTile.VectorTile(new s.pbf(K)), rawData: K, cacheControl: le, expires: me });
        });
        return () => {
          U.cancel(), k();
        };
      }
      class B {
        constructor(k, U, Z, K) {
          this.actor = k, this.layerIndex = U, this.availableImages = Z, this.loadVectorData = K || L, this.loading = {}, this.loaded = {};
        }
        loadTile(k, U) {
          const Z = k.uid;
          this.loading || (this.loading = {});
          const K = !!(k && k.request && k.request.collectResourceTiming) && new s.RequestPerformance(k.request), le = this.loading[Z] = new S(k);
          le.abort = this.loadVectorData(k, (me, fe) => {
            if (delete this.loading[Z], me || !fe)
              return le.status = "done", this.loaded[Z] = le, U(me);
            const ce = fe.rawData, ge = {};
            fe.expires && (ge.expires = fe.expires), fe.cacheControl && (ge.cacheControl = fe.cacheControl);
            const ye = {};
            if (K) {
              const J = K.finish();
              J && (ye.resourceTiming = JSON.parse(JSON.stringify(J)));
            }
            le.vectorTile = fe.vectorTile, le.parse(fe.vectorTile, this.layerIndex, this.availableImages, this.actor, (J, ue) => {
              if (J || !ue)
                return U(J);
              U(null, s.extend({ rawTileData: ce.slice(0) }, ue, ge, ye));
            }), this.loaded = this.loaded || {}, this.loaded[Z] = le;
          });
        }
        reloadTile(k, U) {
          const Z = this.loaded, K = k.uid, le = this;
          if (Z && Z[K]) {
            const me = Z[K];
            me.showCollisionBoxes = k.showCollisionBoxes;
            const fe = (ce, ge) => {
              const ye = me.reloadCallback;
              ye && (delete me.reloadCallback, me.parse(me.vectorTile, le.layerIndex, this.availableImages, le.actor, ye)), U(ce, ge);
            };
            me.status === "parsing" ? me.reloadCallback = fe : me.status === "done" && (me.vectorTile ? me.parse(me.vectorTile, this.layerIndex, this.availableImages, this.actor, fe) : fe());
          }
        }
        abortTile(k, U) {
          const Z = this.loading, K = k.uid;
          Z && Z[K] && Z[K].abort && (Z[K].abort(), delete Z[K]), U();
        }
        removeTile(k, U) {
          const Z = this.loaded, K = k.uid;
          Z && Z[K] && delete Z[K], U();
        }
      }
      class j {
        constructor() {
          this.loaded = {};
        }
        loadTile(k, U) {
          const { uid: Z, encoding: K, rawImageData: le } = k, me = s.isImageBitmap(le) ? this.getImageData(le) : le, fe = new s.DEMData(Z, me, K);
          this.loaded = this.loaded || {}, this.loaded[Z] = fe, U(null, fe);
        }
        getImageData(k) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(k.width, k.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = k.width, this.offscreenCanvas.height = k.height, this.offscreenCanvasContext.drawImage(k, 0, 0, k.width, k.height);
          const U = this.offscreenCanvasContext.getImageData(-1, -1, k.width + 2, k.height + 2);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new s.RGBAImage({ width: U.width, height: U.height }, U.data);
        }
        removeTile(k) {
          const U = this.loaded, Z = k.uid;
          U && U[Z] && delete U[Z];
        }
      }
      var q = function Y(k, U) {
        var Z, K = k && k.type;
        if (K === "FeatureCollection")
          for (Z = 0; Z < k.features.length; Z++)
            Y(k.features[Z], U);
        else if (K === "GeometryCollection")
          for (Z = 0; Z < k.geometries.length; Z++)
            Y(k.geometries[Z], U);
        else if (K === "Feature")
          Y(k.geometry, U);
        else if (K === "Polygon")
          H(k.coordinates, U);
        else if (K === "MultiPolygon")
          for (Z = 0; Z < k.coordinates.length; Z++)
            H(k.coordinates[Z], U);
        return k;
      };
      function H(Y, k) {
        if (Y.length !== 0) {
          ne(Y[0], k);
          for (var U = 1; U < Y.length; U++)
            ne(Y[U], !k);
        }
      }
      function ne(Y, k) {
        for (var U = 0, Z = 0, K = 0, le = Y.length, me = le - 1; K < le; me = K++) {
          var fe = (Y[K][0] - Y[me][0]) * (Y[me][1] + Y[K][1]), ce = U + fe;
          Z += Math.abs(U) >= Math.abs(fe) ? U - ce + fe : fe - ce + U, U = ce;
        }
        U + Z >= 0 != !!k && Y.reverse();
      }
      const ee = s.vectorTile.VectorTileFeature.prototype.toGeoJSON;
      class he {
        constructor(k) {
          this._feature = k, this.extent = s.EXTENT, this.type = k.type, this.properties = k.tags, "id" in k && !isNaN(k.id) && (this.id = parseInt(k.id, 10));
        }
        loadGeometry() {
          if (this._feature.type === 1) {
            const k = [];
            for (const U of this._feature.geometry)
              k.push([new s.pointGeometry(U[0], U[1])]);
            return k;
          }
          {
            const k = [];
            for (const U of this._feature.geometry) {
              const Z = [];
              for (const K of U)
                Z.push(new s.pointGeometry(K[0], K[1]));
              k.push(Z);
            }
            return k;
          }
        }
        toGeoJSON(k, U, Z) {
          return ee.call(this, k, U, Z);
        }
      }
      class Te {
        constructor(k) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = s.EXTENT, this.length = k.length, this._features = k;
        }
        feature(k) {
          return new he(this._features[k]);
        }
      }
      var ve = { exports: {} }, Oe = s.pointGeometry, Me = s.vectorTile.VectorTileFeature, Re = He;
      function He(Y, k) {
        this.options = k || {}, this.features = Y, this.length = Y.length;
      }
      function Ve(Y, k) {
        this.id = typeof Y.id == "number" ? Y.id : void 0, this.type = Y.type, this.rawGeometry = Y.type === 1 ? [Y.geometry] : Y.geometry, this.properties = Y.tags, this.extent = k || 4096;
      }
      He.prototype.feature = function(Y) {
        return new Ve(this.features[Y], this.options.extent);
      }, Ve.prototype.loadGeometry = function() {
        var Y = this.rawGeometry;
        this.geometry = [];
        for (var k = 0; k < Y.length; k++) {
          for (var U = Y[k], Z = [], K = 0; K < U.length; K++)
            Z.push(new Oe(U[K][0], U[K][1]));
          this.geometry.push(Z);
        }
        return this.geometry;
      }, Ve.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var Y = this.geometry, k = 1 / 0, U = -1 / 0, Z = 1 / 0, K = -1 / 0, le = 0; le < Y.length; le++)
          for (var me = Y[le], fe = 0; fe < me.length; fe++) {
            var ce = me[fe];
            k = Math.min(k, ce.x), U = Math.max(U, ce.x), Z = Math.min(Z, ce.y), K = Math.max(K, ce.y);
          }
        return [k, Z, U, K];
      }, Ve.prototype.toGeoJSON = Me.prototype.toGeoJSON;
      var dt = s.pbf, xe = Re;
      function ze(Y) {
        var k = new dt();
        return function(U, Z) {
          for (var K in U.layers)
            Z.writeMessage(3, Pe, U.layers[K]);
        }(Y, k), k.finish();
      }
      function Pe(Y, k) {
        var U;
        k.writeVarintField(15, Y.version || 1), k.writeStringField(1, Y.name || ""), k.writeVarintField(5, Y.extent || 4096);
        var Z = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (U = 0; U < Y.length; U++)
          Z.feature = Y.feature(U), k.writeMessage(2, Ye, Z);
        var K = Z.keys;
        for (U = 0; U < K.length; U++)
          k.writeStringField(3, K[U]);
        var le = Z.values;
        for (U = 0; U < le.length; U++)
          k.writeMessage(4, Yt, le[U]);
      }
      function Ye(Y, k) {
        var U = Y.feature;
        U.id !== void 0 && k.writeVarintField(1, U.id), k.writeMessage(2, it, Y), k.writeVarintField(3, U.type), k.writeMessage(4, mr, U);
      }
      function it(Y, k) {
        var U = Y.feature, Z = Y.keys, K = Y.values, le = Y.keycache, me = Y.valuecache;
        for (var fe in U.properties) {
          var ce = U.properties[fe], ge = le[fe];
          if (ce !== null) {
            ge === void 0 && (Z.push(fe), le[fe] = ge = Z.length - 1), k.writeVarint(ge);
            var ye = typeof ce;
            ye !== "string" && ye !== "boolean" && ye !== "number" && (ce = JSON.stringify(ce));
            var J = ye + ":" + ce, ue = me[J];
            ue === void 0 && (K.push(ce), me[J] = ue = K.length - 1), k.writeVarint(ue);
          }
        }
      }
      function kt(Y, k) {
        return (k << 3) + (7 & Y);
      }
      function Er(Y) {
        return Y << 1 ^ Y >> 31;
      }
      function mr(Y, k) {
        for (var U = Y.loadGeometry(), Z = Y.type, K = 0, le = 0, me = U.length, fe = 0; fe < me; fe++) {
          var ce = U[fe], ge = 1;
          Z === 1 && (ge = ce.length), k.writeVarint(kt(1, ge));
          for (var ye = Z === 3 ? ce.length - 1 : ce.length, J = 0; J < ye; J++) {
            J === 1 && Z !== 1 && k.writeVarint(kt(2, ye - 1));
            var ue = ce[J].x - K, Ne = ce[J].y - le;
            k.writeVarint(Er(ue)), k.writeVarint(Er(Ne)), K += ue, le += Ne;
          }
          Z === 3 && k.writeVarint(kt(7, 1));
        }
      }
      function Yt(Y, k) {
        var U = typeof Y;
        U === "string" ? k.writeStringField(1, Y) : U === "boolean" ? k.writeBooleanField(7, Y) : U === "number" && (Y % 1 != 0 ? k.writeDoubleField(3, Y) : Y < 0 ? k.writeSVarintField(6, Y) : k.writeVarintField(5, Y));
      }
      function on(Y, k, U, Z, K, le) {
        if (K - Z <= U)
          return;
        const me = Z + K >> 1;
        or(Y, k, me, Z, K, le % 2), on(Y, k, U, Z, me - 1, le + 1), on(Y, k, U, me + 1, K, le + 1);
      }
      function or(Y, k, U, Z, K, le) {
        for (; K > Z; ) {
          if (K - Z > 600) {
            const ge = K - Z + 1, ye = U - Z + 1, J = Math.log(ge), ue = 0.5 * Math.exp(2 * J / 3), Ne = 0.5 * Math.sqrt(J * ue * (ge - ue) / ge) * (ye - ge / 2 < 0 ? -1 : 1);
            or(Y, k, U, Math.max(Z, Math.floor(U - ye * ue / ge + Ne)), Math.min(K, Math.floor(U + (ge - ye) * ue / ge + Ne)), le);
          }
          const me = k[2 * U + le];
          let fe = Z, ce = K;
          for (Jt(Y, k, Z, U), k[2 * K + le] > me && Jt(Y, k, Z, K); fe < ce; ) {
            for (Jt(Y, k, fe, ce), fe++, ce--; k[2 * fe + le] < me; )
              fe++;
            for (; k[2 * ce + le] > me; )
              ce--;
          }
          k[2 * Z + le] === me ? Jt(Y, k, Z, ce) : (ce++, Jt(Y, k, ce, K)), ce <= U && (Z = ce + 1), U <= ce && (K = ce - 1);
        }
      }
      function Jt(Y, k, U, Z) {
        Ht(Y, U, Z), Ht(k, 2 * U, 2 * Z), Ht(k, 2 * U + 1, 2 * Z + 1);
      }
      function Ht(Y, k, U) {
        const Z = Y[k];
        Y[k] = Y[U], Y[U] = Z;
      }
      function xr(Y, k, U, Z) {
        const K = Y - U, le = k - Z;
        return K * K + le * le;
      }
      ve.exports = ze, ve.exports.fromVectorTileJs = ze, ve.exports.fromGeojsonVt = function(Y, k) {
        k = k || {};
        var U = {};
        for (var Z in Y)
          U[Z] = new xe(Y[Z].features, k), U[Z].name = Z, U[Z].version = k.version, U[Z].extent = k.extent;
        return ze({ layers: U });
      }, ve.exports.GeoJSONWrapper = xe;
      const Cr = (Y) => Y[0], an = (Y) => Y[1];
      class kr {
        constructor(k, U = Cr, Z = an, K = 64, le = Float64Array) {
          this.nodeSize = K, this.points = k;
          const me = k.length < 65536 ? Uint16Array : Uint32Array, fe = this.ids = new me(k.length), ce = this.coords = new le(2 * k.length);
          for (let ge = 0; ge < k.length; ge++)
            fe[ge] = ge, ce[2 * ge] = U(k[ge]), ce[2 * ge + 1] = Z(k[ge]);
          on(fe, ce, K, 0, fe.length - 1, 0);
        }
        range(k, U, Z, K) {
          return function(le, me, fe, ce, ge, ye, J) {
            const ue = [0, le.length - 1, 0], Ne = [];
            let ot, lt;
            for (; ue.length; ) {
              const Mt = ue.pop(), Pt = ue.pop(), ur = ue.pop();
              if (Pt - ur <= J) {
                for (let gr = ur; gr <= Pt; gr++)
                  ot = me[2 * gr], lt = me[2 * gr + 1], ot >= fe && ot <= ge && lt >= ce && lt <= ye && Ne.push(le[gr]);
                continue;
              }
              const Rt = Math.floor((ur + Pt) / 2);
              ot = me[2 * Rt], lt = me[2 * Rt + 1], ot >= fe && ot <= ge && lt >= ce && lt <= ye && Ne.push(le[Rt]);
              const Qt = (Mt + 1) % 2;
              (Mt === 0 ? fe <= ot : ce <= lt) && (ue.push(ur), ue.push(Rt - 1), ue.push(Qt)), (Mt === 0 ? ge >= ot : ye >= lt) && (ue.push(Rt + 1), ue.push(Pt), ue.push(Qt));
            }
            return Ne;
          }(this.ids, this.coords, k, U, Z, K, this.nodeSize);
        }
        within(k, U, Z) {
          return function(K, le, me, fe, ce, ge) {
            const ye = [0, K.length - 1, 0], J = [], ue = ce * ce;
            for (; ye.length; ) {
              const Ne = ye.pop(), ot = ye.pop(), lt = ye.pop();
              if (ot - lt <= ge) {
                for (let Qt = lt; Qt <= ot; Qt++)
                  xr(le[2 * Qt], le[2 * Qt + 1], me, fe) <= ue && J.push(K[Qt]);
                continue;
              }
              const Mt = Math.floor((lt + ot) / 2), Pt = le[2 * Mt], ur = le[2 * Mt + 1];
              xr(Pt, ur, me, fe) <= ue && J.push(K[Mt]);
              const Rt = (Ne + 1) % 2;
              (Ne === 0 ? me - ce <= Pt : fe - ce <= ur) && (ye.push(lt), ye.push(Mt - 1), ye.push(Rt)), (Ne === 0 ? me + ce >= Pt : fe + ce >= ur) && (ye.push(Mt + 1), ye.push(ot), ye.push(Rt));
            }
            return J;
          }(this.ids, this.coords, k, U, Z, this.nodeSize);
        }
      }
      const Pn = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (Y) => Y }, qr = Math.fround || (re = new Float32Array(1), (Y) => (re[0] = +Y, re[0]));
      var re;
      class pe {
        constructor(k) {
          this.options = Ke(Object.create(Pn), k), this.trees = new Array(this.options.maxZoom + 1);
        }
        load(k) {
          const { log: U, minZoom: Z, maxZoom: K, nodeSize: le } = this.options;
          U && console.time("total time");
          const me = `prepare ${k.length} points`;
          U && console.time(me), this.points = k;
          let fe = [];
          for (let ce = 0; ce < k.length; ce++)
            k[ce].geometry && fe.push(Ze(k[ce], ce));
          this.trees[K + 1] = new kr(fe, At, mt, le, Float32Array), U && console.timeEnd(me);
          for (let ce = K; ce >= Z; ce--) {
            const ge = +Date.now();
            fe = this._cluster(fe, ce), this.trees[ce] = new kr(fe, At, mt, le, Float32Array), U && console.log("z%d: %d clusters in %dms", ce, fe.length, +Date.now() - ge);
          }
          return U && console.timeEnd("total time"), this;
        }
        getClusters(k, U) {
          let Z = ((k[0] + 180) % 360 + 360) % 360 - 180;
          const K = Math.max(-90, Math.min(90, k[1]));
          let le = k[2] === 180 ? 180 : ((k[2] + 180) % 360 + 360) % 360 - 180;
          const me = Math.max(-90, Math.min(90, k[3]));
          if (k[2] - k[0] >= 360)
            Z = -180, le = 180;
          else if (Z > le) {
            const ye = this.getClusters([Z, K, 180, me], U), J = this.getClusters([-180, K, le, me], U);
            return ye.concat(J);
          }
          const fe = this.trees[this._limitZoom(U)], ce = fe.range(Xe(Z), Je(me), Xe(le), Je(K)), ge = [];
          for (const ye of ce) {
            const J = fe.points[ye];
            ge.push(J.numPoints ? Ge(J) : this.points[J.index]);
          }
          return ge;
        }
        getChildren(k) {
          const U = this._getOriginId(k), Z = this._getOriginZoom(k), K = "No cluster with the specified id.", le = this.trees[Z];
          if (!le)
            throw new Error(K);
          const me = le.points[U];
          if (!me)
            throw new Error(K);
          const fe = this.options.radius / (this.options.extent * Math.pow(2, Z - 1)), ce = le.within(me.x, me.y, fe), ge = [];
          for (const ye of ce) {
            const J = le.points[ye];
            J.parentId === k && ge.push(J.numPoints ? Ge(J) : this.points[J.index]);
          }
          if (ge.length === 0)
            throw new Error(K);
          return ge;
        }
        getLeaves(k, U, Z) {
          const K = [];
          return this._appendLeaves(K, k, U = U || 10, Z = Z || 0, 0), K;
        }
        getTile(k, U, Z) {
          const K = this.trees[this._limitZoom(k)], le = Math.pow(2, k), { extent: me, radius: fe } = this.options, ce = fe / me, ge = (Z - ce) / le, ye = (Z + 1 + ce) / le, J = { features: [] };
          return this._addTileFeatures(K.range((U - ce) / le, ge, (U + 1 + ce) / le, ye), K.points, U, Z, le, J), U === 0 && this._addTileFeatures(K.range(1 - ce / le, ge, 1, ye), K.points, le, Z, le, J), U === le - 1 && this._addTileFeatures(K.range(0, ge, ce / le, ye), K.points, -1, Z, le, J), J.features.length ? J : null;
        }
        getClusterExpansionZoom(k) {
          let U = this._getOriginZoom(k) - 1;
          for (; U <= this.options.maxZoom; ) {
            const Z = this.getChildren(k);
            if (U++, Z.length !== 1)
              break;
            k = Z[0].properties.cluster_id;
          }
          return U;
        }
        _appendLeaves(k, U, Z, K, le) {
          const me = this.getChildren(U);
          for (const fe of me) {
            const ce = fe.properties;
            if (ce && ce.cluster ? le + ce.point_count <= K ? le += ce.point_count : le = this._appendLeaves(k, ce.cluster_id, Z, K, le) : le < K ? le++ : k.push(fe), k.length === Z)
              break;
          }
          return le;
        }
        _addTileFeatures(k, U, Z, K, le, me) {
          for (const fe of k) {
            const ce = U[fe], ge = ce.numPoints;
            let ye, J, ue;
            if (ge)
              ye = rt(ce), J = ce.x, ue = ce.y;
            else {
              const lt = this.points[ce.index];
              ye = lt.properties, J = Xe(lt.geometry.coordinates[0]), ue = Je(lt.geometry.coordinates[1]);
            }
            const Ne = { type: 1, geometry: [[Math.round(this.options.extent * (J * le - Z)), Math.round(this.options.extent * (ue * le - K))]], tags: ye };
            let ot;
            ge ? ot = ce.id : this.options.generateId ? ot = ce.index : this.points[ce.index].id && (ot = this.points[ce.index].id), ot !== void 0 && (Ne.id = ot), me.features.push(Ne);
          }
        }
        _limitZoom(k) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+k), this.options.maxZoom + 1));
        }
        _cluster(k, U) {
          const Z = [], { radius: K, extent: le, reduce: me, minPoints: fe } = this.options, ce = K / (le * Math.pow(2, U));
          for (let ge = 0; ge < k.length; ge++) {
            const ye = k[ge];
            if (ye.zoom <= U)
              continue;
            ye.zoom = U;
            const J = this.trees[U + 1], ue = J.within(ye.x, ye.y, ce), Ne = ye.numPoints || 1;
            let ot = Ne;
            for (const lt of ue) {
              const Mt = J.points[lt];
              Mt.zoom > U && (ot += Mt.numPoints || 1);
            }
            if (ot > Ne && ot >= fe) {
              let lt = ye.x * Ne, Mt = ye.y * Ne, Pt = me && Ne > 1 ? this._map(ye, !0) : null;
              const ur = (ge << 5) + (U + 1) + this.points.length;
              for (const Rt of ue) {
                const Qt = J.points[Rt];
                if (Qt.zoom <= U)
                  continue;
                Qt.zoom = U;
                const gr = Qt.numPoints || 1;
                lt += Qt.x * gr, Mt += Qt.y * gr, Qt.parentId = ur, me && (Pt || (Pt = this._map(ye, !0)), me(Pt, this._map(Qt)));
              }
              ye.parentId = ur, Z.push(ke(lt / ot, Mt / ot, ur, ot, Pt));
            } else if (Z.push(ye), ot > 1)
              for (const lt of ue) {
                const Mt = J.points[lt];
                Mt.zoom <= U || (Mt.zoom = U, Z.push(Mt));
              }
          }
          return Z;
        }
        _getOriginId(k) {
          return k - this.points.length >> 5;
        }
        _getOriginZoom(k) {
          return (k - this.points.length) % 32;
        }
        _map(k, U) {
          if (k.numPoints)
            return U ? Ke({}, k.properties) : k.properties;
          const Z = this.points[k.index].properties, K = this.options.map(Z);
          return U && K === Z ? Ke({}, K) : K;
        }
      }
      function ke(Y, k, U, Z, K) {
        return { x: qr(Y), y: qr(k), zoom: 1 / 0, id: U, parentId: -1, numPoints: Z, properties: K };
      }
      function Ze(Y, k) {
        const [U, Z] = Y.geometry.coordinates;
        return { x: qr(Xe(U)), y: qr(Je(Z)), zoom: 1 / 0, index: k, parentId: -1 };
      }
      function Ge(Y) {
        return { type: "Feature", id: Y.id, properties: rt(Y), geometry: { type: "Point", coordinates: [(k = Y.x, 360 * (k - 0.5)), at(Y.y)] } };
        var k;
      }
      function rt(Y) {
        const k = Y.numPoints, U = k >= 1e4 ? `${Math.round(k / 1e3)}k` : k >= 1e3 ? Math.round(k / 100) / 10 + "k" : k;
        return Ke(Ke({}, Y.properties), { cluster: !0, cluster_id: Y.id, point_count: k, point_count_abbreviated: U });
      }
      function Xe(Y) {
        return Y / 360 + 0.5;
      }
      function Je(Y) {
        const k = Math.sin(Y * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + k) / (1 - k)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function at(Y) {
        const k = (180 - 360 * Y) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(k)) / Math.PI - 90;
      }
      function Ke(Y, k) {
        for (const U in k)
          Y[U] = k[U];
        return Y;
      }
      function At(Y) {
        return Y.x;
      }
      function mt(Y) {
        return Y.y;
      }
      function St(Y, k, U, Z) {
        for (var K, le = Z, me = U - k >> 1, fe = U - k, ce = Y[k], ge = Y[k + 1], ye = Y[U], J = Y[U + 1], ue = k + 3; ue < U; ue += 3) {
          var Ne = Ut(Y[ue], Y[ue + 1], ce, ge, ye, J);
          if (Ne > le)
            K = ue, le = Ne;
          else if (Ne === le) {
            var ot = Math.abs(ue - me);
            ot < fe && (K = ue, fe = ot);
          }
        }
        le > Z && (K - k > 3 && St(Y, k, K, Z), Y[K + 2] = le, U - K > 3 && St(Y, K, U, Z));
      }
      function Ut(Y, k, U, Z, K, le) {
        var me = K - U, fe = le - Z;
        if (me !== 0 || fe !== 0) {
          var ce = ((Y - U) * me + (k - Z) * fe) / (me * me + fe * fe);
          ce > 1 ? (U = K, Z = le) : ce > 0 && (U += me * ce, Z += fe * ce);
        }
        return (me = Y - U) * me + (fe = k - Z) * fe;
      }
      function Wt(Y, k, U, Z) {
        var K = { id: Y === void 0 ? null : Y, type: k, geometry: U, tags: Z, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(le) {
          var me = le.geometry, fe = le.type;
          if (fe === "Point" || fe === "MultiPoint" || fe === "LineString")
            Ce(le, me);
          else if (fe === "Polygon" || fe === "MultiLineString")
            for (var ce = 0; ce < me.length; ce++)
              Ce(le, me[ce]);
          else if (fe === "MultiPolygon")
            for (ce = 0; ce < me.length; ce++)
              for (var ge = 0; ge < me[ce].length; ge++)
                Ce(le, me[ce][ge]);
        }(K), K;
      }
      function Ce(Y, k) {
        for (var U = 0; U < k.length; U += 3)
          Y.minX = Math.min(Y.minX, k[U]), Y.minY = Math.min(Y.minY, k[U + 1]), Y.maxX = Math.max(Y.maxX, k[U]), Y.maxY = Math.max(Y.maxY, k[U + 1]);
      }
      function We(Y, k, U, Z) {
        if (k.geometry) {
          var K = k.geometry.coordinates, le = k.geometry.type, me = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2), fe = [], ce = k.id;
          if (U.promoteId ? ce = k.properties[U.promoteId] : U.generateId && (ce = Z || 0), le === "Point")
            br(K, fe);
          else if (le === "MultiPoint")
            for (var ge = 0; ge < K.length; ge++)
              br(K[ge], fe);
          else if (le === "LineString")
            Wr(K, fe, me, !1);
          else if (le === "MultiLineString") {
            if (U.lineMetrics) {
              for (ge = 0; ge < K.length; ge++)
                Wr(K[ge], fe = [], me, !1), Y.push(Wt(ce, "LineString", fe, k.properties));
              return;
            }
            Xt(K, fe, me, !1);
          } else if (le === "Polygon")
            Xt(K, fe, me, !0);
          else {
            if (le !== "MultiPolygon") {
              if (le === "GeometryCollection") {
                for (ge = 0; ge < k.geometry.geometries.length; ge++)
                  We(Y, { id: ce, geometry: k.geometry.geometries[ge], properties: k.properties }, U, Z);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (ge = 0; ge < K.length; ge++) {
              var ye = [];
              Xt(K[ge], ye, me, !0), fe.push(ye);
            }
          }
          Y.push(Wt(ce, le, fe, k.properties));
        }
      }
      function br(Y, k) {
        k.push(gn(Y[0])), k.push(Br(Y[1])), k.push(0);
      }
      function Wr(Y, k, U, Z) {
        for (var K, le, me = 0, fe = 0; fe < Y.length; fe++) {
          var ce = gn(Y[fe][0]), ge = Br(Y[fe][1]);
          k.push(ce), k.push(ge), k.push(0), fe > 0 && (me += Z ? (K * ge - ce * le) / 2 : Math.sqrt(Math.pow(ce - K, 2) + Math.pow(ge - le, 2))), K = ce, le = ge;
        }
        var ye = k.length - 3;
        k[2] = 1, St(k, 0, ye, U), k[ye + 2] = 1, k.size = Math.abs(me), k.start = 0, k.end = k.size;
      }
      function Xt(Y, k, U, Z) {
        for (var K = 0; K < Y.length; K++) {
          var le = [];
          Wr(Y[K], le, U, Z), k.push(le);
        }
      }
      function gn(Y) {
        return Y / 360 + 0.5;
      }
      function Br(Y) {
        var k = Math.sin(Y * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + k) / (1 - k)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function Ir(Y, k, U, Z, K, le, me, fe) {
        if (Z /= k, le >= (U /= k) && me < Z)
          return Y;
        if (me < U || le >= Z)
          return null;
        for (var ce = [], ge = 0; ge < Y.length; ge++) {
          var ye = Y[ge], J = ye.geometry, ue = ye.type, Ne = K === 0 ? ye.minX : ye.minY, ot = K === 0 ? ye.maxX : ye.maxY;
          if (Ne >= U && ot < Z)
            ce.push(ye);
          else if (!(ot < U || Ne >= Z)) {
            var lt = [];
            if (ue === "Point" || ue === "MultiPoint")
              Yr(J, lt, U, Z, K);
            else if (ue === "LineString")
              nt(J, lt, U, Z, K, !1, fe.lineMetrics);
            else if (ue === "MultiLineString")
              Gt(J, lt, U, Z, K, !1);
            else if (ue === "Polygon")
              Gt(J, lt, U, Z, K, !0);
            else if (ue === "MultiPolygon")
              for (var Mt = 0; Mt < J.length; Mt++) {
                var Pt = [];
                Gt(J[Mt], Pt, U, Z, K, !0), Pt.length && lt.push(Pt);
              }
            if (lt.length) {
              if (fe.lineMetrics && ue === "LineString") {
                for (Mt = 0; Mt < lt.length; Mt++)
                  ce.push(Wt(ye.id, ue, lt[Mt], ye.tags));
                continue;
              }
              ue !== "LineString" && ue !== "MultiLineString" || (lt.length === 1 ? (ue = "LineString", lt = lt[0]) : ue = "MultiLineString"), ue !== "Point" && ue !== "MultiPoint" || (ue = lt.length === 3 ? "Point" : "MultiPoint"), ce.push(Wt(ye.id, ue, lt, ye.tags));
            }
          }
        }
        return ce.length ? ce : null;
      }
      function Yr(Y, k, U, Z, K) {
        for (var le = 0; le < Y.length; le += 3) {
          var me = Y[le + K];
          me >= U && me <= Z && (k.push(Y[le]), k.push(Y[le + 1]), k.push(Y[le + 2]));
        }
      }
      function nt(Y, k, U, Z, K, le, me) {
        for (var fe, ce, ge = Kt(Y), ye = K === 0 ? qo : Lt, J = Y.start, ue = 0; ue < Y.length - 3; ue += 3) {
          var Ne = Y[ue], ot = Y[ue + 1], lt = Y[ue + 2], Mt = Y[ue + 3], Pt = Y[ue + 4], ur = K === 0 ? Ne : ot, Rt = K === 0 ? Mt : Pt, Qt = !1;
          me && (fe = Math.sqrt(Math.pow(Ne - Mt, 2) + Math.pow(ot - Pt, 2))), ur < U ? Rt > U && (ce = ye(ge, Ne, ot, Mt, Pt, U), me && (ge.start = J + fe * ce)) : ur > Z ? Rt < Z && (ce = ye(ge, Ne, ot, Mt, Pt, Z), me && (ge.start = J + fe * ce)) : Kn(ge, Ne, ot, lt), Rt < U && ur >= U && (ce = ye(ge, Ne, ot, Mt, Pt, U), Qt = !0), Rt > Z && ur <= Z && (ce = ye(ge, Ne, ot, Mt, Pt, Z), Qt = !0), !le && Qt && (me && (ge.end = J + fe * ce), k.push(ge), ge = Kt(Y)), me && (J += fe);
        }
        var gr = Y.length - 3;
        Ne = Y[gr], ot = Y[gr + 1], lt = Y[gr + 2], (ur = K === 0 ? Ne : ot) >= U && ur <= Z && Kn(ge, Ne, ot, lt), gr = ge.length - 3, le && gr >= 3 && (ge[gr] !== ge[0] || ge[gr + 1] !== ge[1]) && Kn(ge, ge[0], ge[1], ge[2]), ge.length && k.push(ge);
      }
      function Kt(Y) {
        var k = [];
        return k.size = Y.size, k.start = Y.start, k.end = Y.end, k;
      }
      function Gt(Y, k, U, Z, K, le) {
        for (var me = 0; me < Y.length; me++)
          nt(Y[me], k, U, Z, K, le, !1);
      }
      function Kn(Y, k, U, Z) {
        Y.push(k), Y.push(U), Y.push(Z);
      }
      function qo(Y, k, U, Z, K, le) {
        var me = (le - k) / (Z - k);
        return Y.push(le), Y.push(U + (K - U) * me), Y.push(1), me;
      }
      function Lt(Y, k, U, Z, K, le) {
        var me = (le - U) / (K - U);
        return Y.push(k + (Z - k) * me), Y.push(le), Y.push(1), me;
      }
      function vi(Y, k) {
        for (var U = [], Z = 0; Z < Y.length; Z++) {
          var K, le = Y[Z], me = le.type;
          if (me === "Point" || me === "MultiPoint" || me === "LineString")
            K = Vn(le.geometry, k);
          else if (me === "MultiLineString" || me === "Polygon") {
            K = [];
            for (var fe = 0; fe < le.geometry.length; fe++)
              K.push(Vn(le.geometry[fe], k));
          } else if (me === "MultiPolygon")
            for (K = [], fe = 0; fe < le.geometry.length; fe++) {
              for (var ce = [], ge = 0; ge < le.geometry[fe].length; ge++)
                ce.push(Vn(le.geometry[fe][ge], k));
              K.push(ce);
            }
          U.push(Wt(le.id, me, K, le.tags));
        }
        return U;
      }
      function Vn(Y, k) {
        var U = [];
        U.size = Y.size, Y.start !== void 0 && (U.start = Y.start, U.end = Y.end);
        for (var Z = 0; Z < Y.length; Z += 3)
          U.push(Y[Z] + k, Y[Z + 1], Y[Z + 2]);
        return U;
      }
      function sa(Y, k) {
        if (Y.transformed)
          return Y;
        var U, Z, K, le = 1 << Y.z, me = Y.x, fe = Y.y;
        for (U = 0; U < Y.features.length; U++) {
          var ce = Y.features[U], ge = ce.geometry, ye = ce.type;
          if (ce.geometry = [], ye === 1)
            for (Z = 0; Z < ge.length; Z += 2)
              ce.geometry.push(Tn(ge[Z], ge[Z + 1], k, le, me, fe));
          else
            for (Z = 0; Z < ge.length; Z++) {
              var J = [];
              for (K = 0; K < ge[Z].length; K += 2)
                J.push(Tn(ge[Z][K], ge[Z][K + 1], k, le, me, fe));
              ce.geometry.push(J);
            }
        }
        return Y.transformed = !0, Y;
      }
      function Tn(Y, k, U, Z, K, le) {
        return [Math.round(U * (Y * Z - K)), Math.round(U * (k * Z - le))];
      }
      function ni(Y, k, U, Z, K) {
        for (var le = k === K.maxZoom ? 0 : K.tolerance / ((1 << k) * K.extent), me = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: U, y: Z, z: k, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, fe = 0; fe < Y.length; fe++) {
          me.numFeatures++, Rr(me, Y[fe], le, K);
          var ce = Y[fe].minX, ge = Y[fe].minY, ye = Y[fe].maxX, J = Y[fe].maxY;
          ce < me.minX && (me.minX = ce), ge < me.minY && (me.minY = ge), ye > me.maxX && (me.maxX = ye), J > me.maxY && (me.maxY = J);
        }
        return me;
      }
      function Rr(Y, k, U, Z) {
        var K = k.geometry, le = k.type, me = [];
        if (le === "Point" || le === "MultiPoint")
          for (var fe = 0; fe < K.length; fe += 3)
            me.push(K[fe]), me.push(K[fe + 1]), Y.numPoints++, Y.numSimplified++;
        else if (le === "LineString")
          Na(me, K, Y, U, !1, !1);
        else if (le === "MultiLineString" || le === "Polygon")
          for (fe = 0; fe < K.length; fe++)
            Na(me, K[fe], Y, U, le === "Polygon", fe === 0);
        else if (le === "MultiPolygon")
          for (var ce = 0; ce < K.length; ce++) {
            var ge = K[ce];
            for (fe = 0; fe < ge.length; fe++)
              Na(me, ge[fe], Y, U, !0, fe === 0);
          }
        if (me.length) {
          var ye = k.tags || null;
          if (le === "LineString" && Z.lineMetrics) {
            for (var J in ye = {}, k.tags)
              ye[J] = k.tags[J];
            ye.mapbox_clip_start = K.start / K.size, ye.mapbox_clip_end = K.end / K.size;
          }
          var ue = { geometry: me, type: le === "Polygon" || le === "MultiPolygon" ? 3 : le === "LineString" || le === "MultiLineString" ? 2 : 1, tags: ye };
          k.id !== null && (ue.id = k.id), Y.features.push(ue);
        }
      }
      function Na(Y, k, U, Z, K, le) {
        var me = Z * Z;
        if (Z > 0 && k.size < (K ? me : Z))
          U.numPoints += k.length / 3;
        else {
          for (var fe = [], ce = 0; ce < k.length; ce += 3)
            (Z === 0 || k[ce + 2] > me) && (U.numSimplified++, fe.push(k[ce]), fe.push(k[ce + 1])), U.numPoints++;
          K && function(ge, ye) {
            for (var J = 0, ue = 0, Ne = ge.length, ot = Ne - 2; ue < Ne; ot = ue, ue += 2)
              J += (ge[ue] - ge[ot]) * (ge[ue + 1] + ge[ot + 1]);
            if (J > 0 === ye)
              for (ue = 0, Ne = ge.length; ue < Ne / 2; ue += 2) {
                var lt = ge[ue], Mt = ge[ue + 1];
                ge[ue] = ge[Ne - 2 - ue], ge[ue + 1] = ge[Ne - 1 - ue], ge[Ne - 2 - ue] = lt, ge[Ne - 1 - ue] = Mt;
              }
          }(fe, le), Y.push(fe);
        }
      }
      function Ri(Y, k) {
        var U = (k = this.options = function(K, le) {
          for (var me in le)
            K[me] = le[me];
          return K;
        }(Object.create(this.options), k)).debug;
        if (U && console.time("preprocess data"), k.maxZoom < 0 || k.maxZoom > 24)
          throw new Error("maxZoom should be in the 0-24 range");
        if (k.promoteId && k.generateId)
          throw new Error("promoteId and generateId cannot be used together.");
        var Z = function(K, le) {
          var me = [];
          if (K.type === "FeatureCollection")
            for (var fe = 0; fe < K.features.length; fe++)
              We(me, K.features[fe], le, fe);
          else
            We(me, K.type === "Feature" ? K : { geometry: K }, le);
          return me;
        }(Y, k);
        this.tiles = {}, this.tileCoords = [], U && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", k.indexMaxZoom, k.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), Z = function(K, le) {
          var me = le.buffer / le.extent, fe = K, ce = Ir(K, 1, -1 - me, me, 0, -1, 2, le), ge = Ir(K, 1, 1 - me, 2 + me, 0, -1, 2, le);
          return (ce || ge) && (fe = Ir(K, 1, -me, 1 + me, 0, -1, 2, le) || [], ce && (fe = vi(ce, 1).concat(fe)), ge && (fe = fe.concat(vi(ge, -1)))), fe;
        }(Z, k), Z.length && this.splitTile(Z, 0, 0, 0), U && (Z.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function Ao(Y, k, U) {
        return 32 * ((1 << Y) * U + k) + Y;
      }
      function la(Y, k) {
        const U = Y.tileID.canonical;
        if (!this._geoJSONIndex)
          return k(null, null);
        const Z = this._geoJSONIndex.getTile(U.z, U.x, U.y);
        if (!Z)
          return k(null, null);
        const K = new Te(Z.features);
        let le = ve.exports(K);
        le.byteOffset === 0 && le.byteLength === le.buffer.byteLength || (le = new Uint8Array(le)), k(null, { vectorTile: K, rawData: le.buffer });
      }
      Ri.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, Ri.prototype.splitTile = function(Y, k, U, Z, K, le, me) {
        for (var fe = [Y, k, U, Z], ce = this.options, ge = ce.debug; fe.length; ) {
          Z = fe.pop(), U = fe.pop(), k = fe.pop(), Y = fe.pop();
          var ye = 1 << k, J = Ao(k, U, Z), ue = this.tiles[J];
          if (!ue && (ge > 1 && console.time("creation"), ue = this.tiles[J] = ni(Y, k, U, Z, ce), this.tileCoords.push({ z: k, x: U, y: Z }), ge)) {
            ge > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", k, U, Z, ue.numFeatures, ue.numPoints, ue.numSimplified), console.timeEnd("creation"));
            var Ne = "z" + k;
            this.stats[Ne] = (this.stats[Ne] || 0) + 1, this.total++;
          }
          if (ue.source = Y, K) {
            if (k === ce.maxZoom || k === K)
              continue;
            var ot = 1 << K - k;
            if (U !== Math.floor(le / ot) || Z !== Math.floor(me / ot))
              continue;
          } else if (k === ce.indexMaxZoom || ue.numPoints <= ce.indexMaxPoints)
            continue;
          if (ue.source = null, Y.length !== 0) {
            ge > 1 && console.time("clipping");
            var lt, Mt, Pt, ur, Rt, Qt, gr = 0.5 * ce.buffer / ce.extent, jr = 0.5 - gr, ii = 0.5 + gr, yn = 1 + gr;
            lt = Mt = Pt = ur = null, Rt = Ir(Y, ye, U - gr, U + ii, 0, ue.minX, ue.maxX, ce), Qt = Ir(Y, ye, U + jr, U + yn, 0, ue.minX, ue.maxX, ce), Y = null, Rt && (lt = Ir(Rt, ye, Z - gr, Z + ii, 1, ue.minY, ue.maxY, ce), Mt = Ir(Rt, ye, Z + jr, Z + yn, 1, ue.minY, ue.maxY, ce), Rt = null), Qt && (Pt = Ir(Qt, ye, Z - gr, Z + ii, 1, ue.minY, ue.maxY, ce), ur = Ir(Qt, ye, Z + jr, Z + yn, 1, ue.minY, ue.maxY, ce), Qt = null), ge > 1 && console.timeEnd("clipping"), fe.push(lt || [], k + 1, 2 * U, 2 * Z), fe.push(Mt || [], k + 1, 2 * U, 2 * Z + 1), fe.push(Pt || [], k + 1, 2 * U + 1, 2 * Z), fe.push(ur || [], k + 1, 2 * U + 1, 2 * Z + 1);
          }
        }
      }, Ri.prototype.getTile = function(Y, k, U) {
        var Z = this.options, K = Z.extent, le = Z.debug;
        if (Y < 0 || Y > 24)
          return null;
        var me = 1 << Y, fe = Ao(Y, k = (k % me + me) % me, U);
        if (this.tiles[fe])
          return sa(this.tiles[fe], K);
        le > 1 && console.log("drilling down to z%d-%d-%d", Y, k, U);
        for (var ce, ge = Y, ye = k, J = U; !ce && ge > 0; )
          ge--, ye = Math.floor(ye / 2), J = Math.floor(J / 2), ce = this.tiles[Ao(ge, ye, J)];
        return ce && ce.source ? (le > 1 && console.log("found parent tile z%d-%d-%d", ge, ye, J), le > 1 && console.time("drilling down"), this.splitTile(ce.source, ge, ye, J, Y, k, U), le > 1 && console.timeEnd("drilling down"), this.tiles[fe] ? sa(this.tiles[fe], K) : null) : null;
      };
      class xi extends B {
        constructor(k, U, Z, K) {
          super(k, U, Z, la), K && (this.loadGeoJSON = K);
        }
        loadData(k, U) {
          var Z;
          (Z = this._pendingRequest) === null || Z === void 0 || Z.cancel(), this._pendingCallback && this._pendingCallback(null, { abandoned: !0 });
          const K = !!(k && k.request && k.request.collectResourceTiming) && new s.RequestPerformance(k.request);
          this._pendingCallback = U, this._pendingRequest = this.loadGeoJSON(k, (le, me) => {
            if (delete this._pendingCallback, delete this._pendingRequest, le || !me)
              return U(le);
            if (typeof me != "object")
              return U(new Error(`Input data given to '${k.source}' is not a valid GeoJSON object.`));
            {
              q(me, !0);
              try {
                if (k.filter) {
                  const ce = s.createExpression(k.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                  if (ce.result === "error")
                    throw new Error(ce.value.map((ye) => `${ye.key}: ${ye.message}`).join(", "));
                  me = { type: "FeatureCollection", features: me.features.filter((ye) => ce.value.evaluate({ zoom: 0 }, ye)) };
                }
                this._geoJSONIndex = k.cluster ? new pe(function({ superclusterOptions: ce, clusterProperties: ge }) {
                  if (!ge || !ce)
                    return ce;
                  const ye = {}, J = {}, ue = { accumulated: null, zoom: 0 }, Ne = { properties: null }, ot = Object.keys(ge);
                  for (const lt of ot) {
                    const [Mt, Pt] = ge[lt], ur = s.createExpression(Pt), Rt = s.createExpression(typeof Mt == "string" ? [Mt, ["accumulated"], ["get", lt]] : Mt);
                    ye[lt] = ur.value, J[lt] = Rt.value;
                  }
                  return ce.map = (lt) => {
                    Ne.properties = lt;
                    const Mt = {};
                    for (const Pt of ot)
                      Mt[Pt] = ye[Pt].evaluate(ue, Ne);
                    return Mt;
                  }, ce.reduce = (lt, Mt) => {
                    Ne.properties = Mt;
                    for (const Pt of ot)
                      ue.accumulated = lt[Pt], lt[Pt] = J[Pt].evaluate(ue, Ne);
                  }, ce;
                }(k)).load(me.features) : function(ce, ge) {
                  return new Ri(ce, ge);
                }(me, k.geojsonVtOptions);
              } catch (ce) {
                return U(ce);
              }
              this.loaded = {};
              const fe = {};
              if (K) {
                const ce = K.finish();
                ce && (fe.resourceTiming = {}, fe.resourceTiming[k.source] = JSON.parse(JSON.stringify(ce)));
              }
              U(null, fe);
            }
          });
        }
        reloadTile(k, U) {
          const Z = this.loaded;
          return Z && Z[k.uid] ? super.reloadTile(k, U) : this.loadTile(k, U);
        }
        loadGeoJSON(k, U) {
          if (k.request)
            return s.getJSON(k.request, U);
          if (typeof k.data == "string")
            try {
              U(null, JSON.parse(k.data));
            } catch {
              U(new Error(`Input data given to '${k.source}' is not a valid GeoJSON object.`));
            }
          else
            U(new Error(`Input data given to '${k.source}' is not a valid GeoJSON object.`));
          return { cancel: () => {
          } };
        }
        removeSource(k, U) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), U();
        }
        getClusterExpansionZoom(k, U) {
          try {
            U(null, this._geoJSONIndex.getClusterExpansionZoom(k.clusterId));
          } catch (Z) {
            U(Z);
          }
        }
        getClusterChildren(k, U) {
          try {
            U(null, this._geoJSONIndex.getChildren(k.clusterId));
          } catch (Z) {
            U(Z);
          }
        }
        getClusterLeaves(k, U) {
          try {
            U(null, this._geoJSONIndex.getLeaves(k.clusterId, k.limit, k.offset));
          } catch (Z) {
            U(Z);
          }
        }
      }
      class Oo {
        constructor(k) {
          this.self = k, this.actor = new s.Actor(k, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: B, geojson: xi }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (U, Z) => {
            if (this.workerSourceTypes[U])
              throw new Error(`Worker source with name "${U}" already registered.`);
            this.workerSourceTypes[U] = Z;
          }, this.self.registerRTLTextPlugin = (U) => {
            if (s.plugin.isParsed())
              throw new Error("RTL text plugin already registered.");
            s.plugin.applyArabicShaping = U.applyArabicShaping, s.plugin.processBidirectionalText = U.processBidirectionalText, s.plugin.processStyledBidirectionalText = U.processStyledBidirectionalText;
          };
        }
        setReferrer(k, U) {
          this.referrer = U;
        }
        setImages(k, U, Z) {
          this.availableImages[k] = U;
          for (const K in this.workerSources[k]) {
            const le = this.workerSources[k][K];
            for (const me in le)
              le[me].availableImages = U;
          }
          Z();
        }
        setLayers(k, U, Z) {
          this.getLayerIndex(k).replace(U), Z();
        }
        updateLayers(k, U, Z) {
          this.getLayerIndex(k).update(U.layers, U.removedIds), Z();
        }
        loadTile(k, U, Z) {
          this.getWorkerSource(k, U.type, U.source).loadTile(U, Z);
        }
        loadDEMTile(k, U, Z) {
          this.getDEMWorkerSource(k, U.source).loadTile(U, Z);
        }
        reloadTile(k, U, Z) {
          this.getWorkerSource(k, U.type, U.source).reloadTile(U, Z);
        }
        abortTile(k, U, Z) {
          this.getWorkerSource(k, U.type, U.source).abortTile(U, Z);
        }
        removeTile(k, U, Z) {
          this.getWorkerSource(k, U.type, U.source).removeTile(U, Z);
        }
        removeDEMTile(k, U) {
          this.getDEMWorkerSource(k, U.source).removeTile(U);
        }
        removeSource(k, U, Z) {
          if (!this.workerSources[k] || !this.workerSources[k][U.type] || !this.workerSources[k][U.type][U.source])
            return;
          const K = this.workerSources[k][U.type][U.source];
          delete this.workerSources[k][U.type][U.source], K.removeSource !== void 0 ? K.removeSource(U, Z) : Z();
        }
        loadWorkerSource(k, U, Z) {
          try {
            this.self.importScripts(U.url), Z();
          } catch (K) {
            Z(K.toString());
          }
        }
        syncRTLPluginState(k, U, Z) {
          try {
            s.plugin.setState(U);
            const K = s.plugin.getPluginURL();
            if (s.plugin.isLoaded() && !s.plugin.isParsed() && K != null) {
              this.self.importScripts(K);
              const le = s.plugin.isParsed();
              Z(le ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${K}`), le);
            }
          } catch (K) {
            Z(K.toString());
          }
        }
        getAvailableImages(k) {
          let U = this.availableImages[k];
          return U || (U = []), U;
        }
        getLayerIndex(k) {
          let U = this.layerIndexes[k];
          return U || (U = this.layerIndexes[k] = new E()), U;
        }
        getWorkerSource(k, U, Z) {
          if (this.workerSources[k] || (this.workerSources[k] = {}), this.workerSources[k][U] || (this.workerSources[k][U] = {}), !this.workerSources[k][U][Z]) {
            const K = { send: (le, me, fe) => {
              this.actor.send(le, me, fe, k);
            } };
            this.workerSources[k][U][Z] = new this.workerSourceTypes[U](K, this.getLayerIndex(k), this.getAvailableImages(k));
          }
          return this.workerSources[k][U][Z];
        }
        getDEMWorkerSource(k, U) {
          return this.demWorkerSources[k] || (this.demWorkerSources[k] = {}), this.demWorkerSources[k][U] || (this.demWorkerSources[k][U] = new j()), this.demWorkerSources[k][U];
        }
        enforceCacheSizeLimit(k, U) {
          s.enforceCacheSizeLimit(U);
        }
      }
      return s.isWorker() && (self.worker = new Oo(self)), Oo;
    }), l(["./shared"], function(s) {
      var m = v;
      function v(g) {
        return !function(a) {
          return typeof window > "u" || typeof document > "u" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return !1;
            var p, _, b = new Blob([""], { type: "text/javascript" }), M = URL.createObjectURL(b);
            try {
              _ = new Worker(M), p = !0;
            } catch {
              p = !1;
            }
            return _ && _.terminate(), URL.revokeObjectURL(M), p;
          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
            var p = document.createElement("canvas");
            p.width = p.height = 1;
            var _ = p.getContext("2d");
            if (!_)
              return !1;
            var b = _.getImageData(0, 0, 1, 1);
            return b && b.width === p.width;
          }() ? (E[f = a && a.failIfMajorPerformanceCaveat] === void 0 && (E[f] = function(p) {
            var _, b = function(M) {
              var P = document.createElement("canvas"), O = Object.create(v.webGLContextAttributes);
              return O.failIfMajorPerformanceCaveat = M, P.getContext("webgl", O) || P.getContext("experimental-webgl", O);
            }(p);
            if (!b)
              return !1;
            try {
              _ = b.createShader(b.VERTEX_SHADER);
            } catch {
              return !1;
            }
            return !(!_ || b.isContextLost()) && (b.shaderSource(_, "void main() {}"), b.compileShader(_), b.getShaderParameter(_, b.COMPILE_STATUS) === !0);
          }(f)), E[f] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          var f;
        }(g);
      }
      var E = {};
      function T(g, a) {
        if (Array.isArray(g)) {
          if (!Array.isArray(a) || g.length !== a.length)
            return !1;
          for (let f = 0; f < g.length; f++)
            if (!T(g[f], a[f]))
              return !1;
          return !0;
        }
        if (typeof g == "object" && g !== null && a !== null) {
          if (typeof a != "object" || Object.keys(g).length !== Object.keys(a).length)
            return !1;
          for (const f in g)
            if (!T(g[f], a[f]))
              return !1;
          return !0;
        }
        return g === a;
      }
      v.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };
      class S {
        static testProp(a) {
          if (!S.docStyle)
            return a[0];
          for (let f = 0; f < a.length; f++)
            if (a[f] in S.docStyle)
              return a[f];
          return a[0];
        }
        static create(a, f, p) {
          const _ = window.document.createElement(a);
          return f !== void 0 && (_.className = f), p && p.appendChild(_), _;
        }
        static createNS(a, f) {
          return window.document.createElementNS(a, f);
        }
        static disableDrag() {
          S.docStyle && S.selectProp && (S.userSelect = S.docStyle[S.selectProp], S.docStyle[S.selectProp] = "none");
        }
        static enableDrag() {
          S.docStyle && S.selectProp && (S.docStyle[S.selectProp] = S.userSelect);
        }
        static setTransform(a, f) {
          a.style[S.transformProp] = f;
        }
        static addEventListener(a, f, p, _ = {}) {
          a.addEventListener(f, p, "passive" in _ ? _ : _.capture);
        }
        static removeEventListener(a, f, p, _ = {}) {
          a.removeEventListener(f, p, "passive" in _ ? _ : _.capture);
        }
        static suppressClickInternal(a) {
          a.preventDefault(), a.stopPropagation(), window.removeEventListener("click", S.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener("click", S.suppressClickInternal, !0), window.setTimeout(() => {
            window.removeEventListener("click", S.suppressClickInternal, !0);
          }, 0);
        }
        static mousePos(a, f) {
          const p = a.getBoundingClientRect();
          return new s.pointGeometry(f.clientX - p.left - a.clientLeft, f.clientY - p.top - a.clientTop);
        }
        static touchPos(a, f) {
          const p = a.getBoundingClientRect(), _ = [];
          for (let b = 0; b < f.length; b++)
            _.push(new s.pointGeometry(f[b].clientX - p.left - a.clientLeft, f[b].clientY - p.top - a.clientTop));
          return _;
        }
        static mouseButton(a) {
          return a.button;
        }
        static remove(a) {
          a.parentNode && a.parentNode.removeChild(a);
        }
      }
      S.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, S.selectProp = S.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), S.transformProp = S.testProp(["transform", "WebkitTransform"]);
      class A {
        constructor(a) {
          this._transformRequestFn = a;
        }
        transformRequest(a, f) {
          return this._transformRequestFn && this._transformRequestFn(a, f) || { url: a };
        }
        normalizeSpriteURL(a, f, p) {
          const _ = function(b) {
            const M = b.match(L);
            if (!M)
              throw new Error(`Unable to parse URL "${b}"`);
            return { protocol: M[1], authority: M[2], path: M[3] || "/", params: M[4] ? M[4].split("&") : [] };
          }(a);
          return _.path += `${f}${p}`, function(b) {
            const M = b.params.length ? `?${b.params.join("&")}` : "";
            return `${b.protocol}://${b.authority}${b.path}${M}`;
          }(_);
        }
        setTransformRequest(a) {
          this._transformRequestFn = a;
        }
      }
      const L = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      class B {
        constructor(a, f, p, _) {
          this.context = a, this.format = p, this.texture = a.gl.createTexture(), this.update(f, _);
        }
        update(a, f, p) {
          const { width: _, height: b } = a, M = !(this.size && this.size[0] === _ && this.size[1] === b || p), { context: P } = this, { gl: O } = P;
          if (this.useMipmap = Boolean(f && f.useMipmap), O.bindTexture(O.TEXTURE_2D, this.texture), P.pixelStoreUnpackFlipY.set(!1), P.pixelStoreUnpack.set(1), P.pixelStoreUnpackPremultiplyAlpha.set(this.format === O.RGBA && (!f || f.premultiply !== !1)), M)
            this.size = [_, b], a instanceof HTMLImageElement || a instanceof HTMLCanvasElement || a instanceof HTMLVideoElement || a instanceof ImageData || s.isImageBitmap(a) ? O.texImage2D(O.TEXTURE_2D, 0, this.format, this.format, O.UNSIGNED_BYTE, a) : O.texImage2D(O.TEXTURE_2D, 0, this.format, _, b, 0, this.format, O.UNSIGNED_BYTE, a.data);
          else {
            const { x: D, y: F } = p || { x: 0, y: 0 };
            a instanceof HTMLImageElement || a instanceof HTMLCanvasElement || a instanceof HTMLVideoElement || a instanceof ImageData || s.isImageBitmap(a) ? O.texSubImage2D(O.TEXTURE_2D, 0, D, F, O.RGBA, O.UNSIGNED_BYTE, a) : O.texSubImage2D(O.TEXTURE_2D, 0, D, F, _, b, O.RGBA, O.UNSIGNED_BYTE, a.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && O.generateMipmap(O.TEXTURE_2D);
        }
        bind(a, f, p) {
          const { context: _ } = this, { gl: b } = _;
          b.bindTexture(b.TEXTURE_2D, this.texture), p !== b.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (p = b.LINEAR), a !== this.filter && (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, a), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, p || a), this.filter = a), f !== this.wrap && (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, f), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, f), this.wrap = f);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: a } = this.context;
          a.deleteTexture(this.texture), this.texture = null;
        }
      }
      function j(g) {
        const { userImage: a } = g;
        return !!(a && a.render && a.render()) && (g.data.replace(new Uint8Array(a.data.buffer)), !0);
      }
      class q extends s.Evented {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new s.RGBAImage({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(a) {
          if (this.loaded !== a && (this.loaded = a, a)) {
            for (const { ids: f, callback: p } of this.requestors)
              this._notify(f, p);
            this.requestors = [];
          }
        }
        getImage(a) {
          return this.images[a];
        }
        addImage(a, f) {
          if (this.images[a])
            throw new Error(`Image id ${a} already exist, use updateImage instead`);
          this._validate(a, f) && (this.images[a] = f);
        }
        _validate(a, f) {
          let p = !0;
          return this._validateStretch(f.stretchX, f.data && f.data.width) || (this.fire(new s.ErrorEvent(new Error(`Image "${a}" has invalid "stretchX" value`))), p = !1), this._validateStretch(f.stretchY, f.data && f.data.height) || (this.fire(new s.ErrorEvent(new Error(`Image "${a}" has invalid "stretchY" value`))), p = !1), this._validateContent(f.content, f) || (this.fire(new s.ErrorEvent(new Error(`Image "${a}" has invalid "content" value`))), p = !1), p;
        }
        _validateStretch(a, f) {
          if (!a)
            return !0;
          let p = 0;
          for (const _ of a) {
            if (_[0] < p || _[1] < _[0] || f < _[1])
              return !1;
            p = _[1];
          }
          return !0;
        }
        _validateContent(a, f) {
          return !(a && (a.length !== 4 || a[0] < 0 || f.data.width < a[0] || a[1] < 0 || f.data.height < a[1] || a[2] < 0 || f.data.width < a[2] || a[3] < 0 || f.data.height < a[3] || a[2] < a[0] || a[3] < a[1]));
        }
        updateImage(a, f) {
          const p = this.images[a];
          if (p.data.width !== f.data.width || p.data.height !== f.data.height)
            throw new Error(`size mismatch between old image (${p.data.width}x${p.data.height}) and new image (${f.data.width}x${f.data.height}).`);
          f.version = p.version + 1, this.images[a] = f, this.updatedImages[a] = !0;
        }
        removeImage(a) {
          const f = this.images[a];
          delete this.images[a], delete this.patterns[a], f.userImage && f.userImage.onRemove && f.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(a, f) {
          let p = !0;
          if (!this.isLoaded())
            for (const _ of a)
              this.images[_] || (p = !1);
          this.isLoaded() || p ? this._notify(a, f) : this.requestors.push({ ids: a, callback: f });
        }
        _notify(a, f) {
          const p = {};
          for (const _ of a) {
            this.images[_] || this.fire(new s.Event("styleimagemissing", { id: _ }));
            const b = this.images[_];
            b ? p[_] = { data: b.data.clone(), pixelRatio: b.pixelRatio, sdf: b.sdf, version: b.version, stretchX: b.stretchX, stretchY: b.stretchY, content: b.content, hasRenderCallback: Boolean(b.userImage && b.userImage.render) } : s.warnOnce(`Image "${_}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          f(null, p);
        }
        getPixelSize() {
          const { width: a, height: f } = this.atlasImage;
          return { width: a, height: f };
        }
        getPattern(a) {
          const f = this.patterns[a], p = this.getImage(a);
          if (!p)
            return null;
          if (f && f.position.version === p.version)
            return f.position;
          if (f)
            f.position.version = p.version;
          else {
            const _ = { w: p.data.width + 2, h: p.data.height + 2, x: 0, y: 0 }, b = new s.ImagePosition(_, p);
            this.patterns[a] = { bin: _, position: b };
          }
          return this._updatePatternAtlas(), this.patterns[a].position;
        }
        bind(a) {
          const f = a.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new B(a, this.atlasImage, f.RGBA), this.atlasTexture.bind(f.LINEAR, f.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const a = [];
          for (const b in this.patterns)
            a.push(this.patterns[b].bin);
          const { w: f, h: p } = s.potpack(a), _ = this.atlasImage;
          _.resize({ width: f || 1, height: p || 1 });
          for (const b in this.patterns) {
            const { bin: M } = this.patterns[b], P = M.x + 1, O = M.y + 1, D = this.images[b].data, F = D.width, $ = D.height;
            s.RGBAImage.copy(D, _, { x: 0, y: 0 }, { x: P, y: O }, { width: F, height: $ }), s.RGBAImage.copy(D, _, { x: 0, y: $ - 1 }, { x: P, y: O - 1 }, { width: F, height: 1 }), s.RGBAImage.copy(D, _, { x: 0, y: 0 }, { x: P, y: O + $ }, { width: F, height: 1 }), s.RGBAImage.copy(D, _, { x: F - 1, y: 0 }, { x: P - 1, y: O }, { width: 1, height: $ }), s.RGBAImage.copy(D, _, { x: 0, y: 0 }, { x: P + F, y: O }, { width: 1, height: $ });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(a) {
          for (const f of a) {
            if (this.callbackDispatchedThisFrame[f])
              continue;
            this.callbackDispatchedThisFrame[f] = !0;
            const p = this.images[f];
            p || s.warnOnce(`Image with ID: "${f}" was not found`), j(p) && this.updateImage(f, p);
          }
        }
      }
      const H = 1e20;
      function ne(g, a, f, p, _, b, M, P, O) {
        for (let D = a; D < a + p; D++)
          ee(g, f * b + D, b, _, M, P, O);
        for (let D = f; D < f + _; D++)
          ee(g, D * b + a, 1, p, M, P, O);
      }
      function ee(g, a, f, p, _, b, M) {
        b[0] = 0, M[0] = -H, M[1] = H, _[0] = g[a];
        for (let P = 1, O = 0, D = 0; P < p; P++) {
          _[P] = g[a + P * f];
          const F = P * P;
          do {
            const $ = b[O];
            D = (_[P] - _[$] + F - $ * $) / (P - $) / 2;
          } while (D <= M[O] && --O > -1);
          O++, b[O] = P, M[O] = D, M[O + 1] = H;
        }
        for (let P = 0, O = 0; P < p; P++) {
          for (; M[O + 1] < P; )
            O++;
          const D = b[O], F = P - D;
          g[a + P * f] = _[D] + F * F;
        }
      }
      class he {
        constructor(a, f) {
          this.requestManager = a, this.localIdeographFontFamily = f, this.entries = {};
        }
        setURL(a) {
          this.url = a;
        }
        getGlyphs(a, f) {
          const p = [];
          for (const _ in a)
            for (const b of a[_])
              p.push({ stack: _, id: b });
          s.asyncAll(p, ({ stack: _, id: b }, M) => {
            let P = this.entries[_];
            P || (P = this.entries[_] = { glyphs: {}, requests: {}, ranges: {} });
            let O = P.glyphs[b];
            if (O !== void 0)
              return void M(null, { stack: _, id: b, glyph: O });
            if (O = this._tinySDF(P, _, b), O)
              return P.glyphs[b] = O, void M(null, { stack: _, id: b, glyph: O });
            const D = Math.floor(b / 256);
            if (256 * D > 65535)
              return void M(new Error("glyphs > 65535 not supported"));
            if (P.ranges[D])
              return void M(null, { stack: _, id: b, glyph: O });
            let F = P.requests[D];
            F || (F = P.requests[D] = [], he.loadGlyphRange(_, D, this.url, this.requestManager, ($, G) => {
              if (G) {
                for (const ie in G)
                  this._doesCharSupportLocalGlyph(+ie) || (P.glyphs[+ie] = G[+ie]);
                P.ranges[D] = !0;
              }
              for (const ie of F)
                ie($, G);
              delete P.requests[D];
            })), F.push(($, G) => {
              $ ? M($) : G && M(null, { stack: _, id: b, glyph: G[b] || null });
            });
          }, (_, b) => {
            if (_)
              f(_);
            else if (b) {
              const M = {};
              for (const { stack: P, id: O, glyph: D } of b)
                (M[P] || (M[P] = {}))[O] = D && { id: D.id, bitmap: D.bitmap.clone(), metrics: D.metrics };
              f(null, M);
            }
          });
        }
        _doesCharSupportLocalGlyph(a) {
          return !!this.localIdeographFontFamily && (s.unicodeBlockLookup["CJK Unified Ideographs"](a) || s.unicodeBlockLookup["Hangul Syllables"](a) || s.unicodeBlockLookup.Hiragana(a) || s.unicodeBlockLookup.Katakana(a));
        }
        _tinySDF(a, f, p) {
          const _ = this.localIdeographFontFamily;
          if (!_ || !this._doesCharSupportLocalGlyph(p))
            return;
          let b = a.tinySDF;
          if (!b) {
            let P = "400";
            /bold/i.test(f) ? P = "900" : /medium/i.test(f) ? P = "500" : /light/i.test(f) && (P = "200"), b = a.tinySDF = new he.TinySDF({ fontSize: 24, buffer: 3, radius: 8, cutoff: 0.25, fontFamily: _, fontWeight: P });
          }
          const M = b.draw(String.fromCharCode(p));
          return { id: p, bitmap: new s.AlphaImage({ width: M.width || 30, height: M.height || 30 }, M.data), metrics: { width: M.glyphWidth || 24, height: M.glyphHeight || 24, left: M.glyphLeft || 0, top: M.glyphTop - 27 || -8, advance: M.glyphAdvance || 24 } };
        }
      }
      he.loadGlyphRange = function(g, a, f, p, _) {
        const b = 256 * a, M = b + 255, P = p.transformRequest(f.replace("{fontstack}", g).replace("{range}", `${b}-${M}`), s.ResourceType.Glyphs);
        s.getArrayBuffer(P, (O, D) => {
          if (O)
            _(O);
          else if (D) {
            const F = {};
            for (const $ of s.parseGlyphPbf(D))
              F[$.id] = $;
            _(null, F);
          }
        });
      }, he.TinySDF = class {
        constructor({ fontSize: g = 24, buffer: a = 3, radius: f = 8, cutoff: p = 0.25, fontFamily: _ = "sans-serif", fontWeight: b = "normal", fontStyle: M = "normal" } = {}) {
          this.buffer = a, this.cutoff = p, this.radius = f;
          const P = this.size = g + 4 * a, O = this._createCanvas(P), D = this.ctx = O.getContext("2d", { willReadFrequently: !0 });
          D.font = `${M} ${b} ${g}px ${_}`, D.textBaseline = "alphabetic", D.textAlign = "left", D.fillStyle = "black", this.gridOuter = new Float64Array(P * P), this.gridInner = new Float64Array(P * P), this.f = new Float64Array(P), this.z = new Float64Array(P + 1), this.v = new Uint16Array(P);
        }
        _createCanvas(g) {
          const a = document.createElement("canvas");
          return a.width = a.height = g, a;
        }
        draw(g) {
          const { width: a, actualBoundingBoxAscent: f, actualBoundingBoxDescent: p, actualBoundingBoxLeft: _, actualBoundingBoxRight: b } = this.ctx.measureText(g), M = Math.ceil(f), P = Math.min(this.size - this.buffer, Math.ceil(b - _)), O = Math.min(this.size - this.buffer, M + Math.ceil(p)), D = P + 2 * this.buffer, F = O + 2 * this.buffer, $ = Math.max(D * F, 0), G = new Uint8ClampedArray($), ie = { data: G, width: D, height: F, glyphWidth: P, glyphHeight: O, glyphTop: M, glyphLeft: 0, glyphAdvance: a };
          if (P === 0 || O === 0)
            return ie;
          const { ctx: Q, buffer: te, gridInner: de, gridOuter: be } = this;
          Q.clearRect(te, te, P, O), Q.fillText(g, te, te + M);
          const Se = Q.getImageData(te, te, P, O);
          be.fill(H, 0, $), de.fill(0, 0, $);
          for (let oe = 0; oe < O; oe++)
            for (let Le = 0; Le < P; Le++) {
              const Ie = Se.data[4 * (oe * P + Le) + 3] / 255;
              if (Ie === 0)
                continue;
              const Be = (oe + te) * D + Le + te;
              if (Ie === 1)
                be[Be] = 0, de[Be] = H;
              else {
                const Ue = 0.5 - Ie;
                be[Be] = Ue > 0 ? Ue * Ue : 0, de[Be] = Ue < 0 ? Ue * Ue : 0;
              }
            }
          ne(be, 0, 0, D, F, D, this.f, this.v, this.z), ne(de, te, te, P, O, D, this.f, this.v, this.z);
          for (let oe = 0; oe < $; oe++) {
            const Le = Math.sqrt(be[oe]) - Math.sqrt(de[oe]);
            G[oe] = Math.round(255 - 255 * (Le / this.radius + this.cutoff));
          }
          return ie;
        }
      };
      const Te = new s.Properties({ anchor: new s.DataConstantProperty(s.spec.light.anchor), position: new class {
        constructor() {
          this.specification = s.spec.light.position;
        }
        possiblyEvaluate(g, a) {
          return s.sphericalToCartesian(g.expression.evaluate(a));
        }
        interpolate(g, a, f) {
          return { x: s.number(g.x, a.x, f), y: s.number(g.y, a.y, f), z: s.number(g.z, a.z, f) };
        }
      }(), color: new s.DataConstantProperty(s.spec.light.color), intensity: new s.DataConstantProperty(s.spec.light.intensity) }), ve = "-transition";
      class Oe extends s.Evented {
        constructor(a) {
          super(), this._transitionable = new s.Transitionable(Te), this.setLight(a), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(a, f = {}) {
          if (!this._validate(s.validateLight, a, f))
            for (const p in a) {
              const _ = a[p];
              p.endsWith(ve) ? this._transitionable.setTransition(p.slice(0, -ve.length), _) : this._transitionable.setValue(p, _);
            }
        }
        updateTransitions(a) {
          this._transitioning = this._transitionable.transitioned(a, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(a) {
          this.properties = this._transitioning.possiblyEvaluate(a);
        }
        _validate(a, f, p) {
          return (!p || p.validate !== !1) && s.emitValidationErrors(this, a.call(s.validateStyle, s.extend({ value: f, style: { glyphs: !0, sprite: !0 }, styleSpec: s.spec })));
        }
      }
      class Me {
        constructor(a, f) {
          this.width = a, this.height = f, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(a, f) {
          const p = a.join(",") + String(f);
          return this.dashEntry[p] || (this.dashEntry[p] = this.addDash(a, f)), this.dashEntry[p];
        }
        getDashRanges(a, f, p) {
          const _ = [];
          let b = a.length % 2 == 1 ? -a[a.length - 1] * p : 0, M = a[0] * p, P = !0;
          _.push({ left: b, right: M, isDash: P, zeroLength: a[0] === 0 });
          let O = a[0];
          for (let D = 1; D < a.length; D++) {
            P = !P;
            const F = a[D];
            b = O * p, O += F, M = O * p, _.push({ left: b, right: M, isDash: P, zeroLength: F === 0 });
          }
          return _;
        }
        addRoundDash(a, f, p) {
          const _ = f / 2;
          for (let b = -p; b <= p; b++) {
            const M = this.width * (this.nextRow + p + b);
            let P = 0, O = a[P];
            for (let D = 0; D < this.width; D++) {
              D / O.right > 1 && (O = a[++P]);
              const F = Math.abs(D - O.left), $ = Math.abs(D - O.right), G = Math.min(F, $);
              let ie;
              const Q = b / p * (_ + 1);
              if (O.isDash) {
                const te = _ - Math.abs(Q);
                ie = Math.sqrt(G * G + te * te);
              } else
                ie = _ - Math.sqrt(G * G + Q * Q);
              this.data[M + D] = Math.max(0, Math.min(255, ie + 128));
            }
          }
        }
        addRegularDash(a) {
          for (let P = a.length - 1; P >= 0; --P) {
            const O = a[P], D = a[P + 1];
            O.zeroLength ? a.splice(P, 1) : D && D.isDash === O.isDash && (D.left = O.left, a.splice(P, 1));
          }
          const f = a[0], p = a[a.length - 1];
          f.isDash === p.isDash && (f.left = p.left - this.width, p.right = f.right + this.width);
          const _ = this.width * this.nextRow;
          let b = 0, M = a[b];
          for (let P = 0; P < this.width; P++) {
            P / M.right > 1 && (M = a[++b]);
            const O = Math.abs(P - M.left), D = Math.abs(P - M.right), F = Math.min(O, D);
            this.data[_ + P] = Math.max(0, Math.min(255, (M.isDash ? F : -F) + 128));
          }
        }
        addDash(a, f) {
          const p = f ? 7 : 0, _ = 2 * p + 1;
          if (this.nextRow + _ > this.height)
            return s.warnOnce("LineAtlas out of space"), null;
          let b = 0;
          for (let P = 0; P < a.length; P++)
            b += a[P];
          if (b !== 0) {
            const P = this.width / b, O = this.getDashRanges(a, this.width, P);
            f ? this.addRoundDash(O, P, p) : this.addRegularDash(O);
          }
          const M = { y: (this.nextRow + p + 0.5) / this.height, height: 2 * p / this.height, width: b };
          return this.nextRow += _, this.dirty = !0, M;
        }
        bind(a) {
          const f = a.gl;
          this.texture ? (f.bindTexture(f.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, f.texSubImage2D(f.TEXTURE_2D, 0, 0, 0, this.width, this.height, f.ALPHA, f.UNSIGNED_BYTE, this.data))) : (this.texture = f.createTexture(), f.bindTexture(f.TEXTURE_2D, this.texture), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.REPEAT), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.REPEAT), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.LINEAR), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR), f.texImage2D(f.TEXTURE_2D, 0, f.ALPHA, this.width, this.height, 0, f.ALPHA, f.UNSIGNED_BYTE, this.data));
        }
      }
      class Re {
        constructor(a, f) {
          this.workerPool = a, this.actors = [], this.currentActor = 0, this.id = s.uniqueId();
          const p = this.workerPool.acquire(this.id);
          for (let _ = 0; _ < p.length; _++) {
            const b = new Re.Actor(p[_], f, this.id);
            b.name = `Worker ${_}`, this.actors.push(b);
          }
          if (!this.actors.length)
            throw new Error("No actors found");
        }
        broadcast(a, f, p) {
          s.asyncAll(this.actors, (_, b) => {
            _.send(a, f, b);
          }, p = p || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((a) => {
            a.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      function He(g, a, f) {
        const p = function(_, b) {
          if (_)
            return f(_);
          if (b) {
            const M = s.pick(s.extend(b, g), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            b.vector_layers && (M.vectorLayers = b.vector_layers, M.vectorLayerIds = M.vectorLayers.map((P) => P.id)), f(null, M);
          }
        };
        return g.url ? s.getJSON(a.transformRequest(g.url, s.ResourceType.Source), p) : s.exported.frame(() => p(null, g));
      }
      Re.Actor = s.Actor;
      class Ve {
        constructor(a, f, p) {
          this.bounds = s.LngLatBounds.convert(this.validateBounds(a)), this.minzoom = f || 0, this.maxzoom = p || 24;
        }
        validateBounds(a) {
          return Array.isArray(a) && a.length === 4 ? [Math.max(-180, a[0]), Math.max(-90, a[1]), Math.min(180, a[2]), Math.min(90, a[3])] : [-180, -90, 180, 90];
        }
        contains(a) {
          const f = Math.pow(2, a.z), p = Math.floor(s.mercatorXfromLng(this.bounds.getWest()) * f), _ = Math.floor(s.mercatorYfromLat(this.bounds.getNorth()) * f), b = Math.ceil(s.mercatorXfromLng(this.bounds.getEast()) * f), M = Math.ceil(s.mercatorYfromLat(this.bounds.getSouth()) * f);
          return a.x >= p && a.x < b && a.y >= _ && a.y < M;
        }
      }
      class dt extends s.Evented {
        constructor(a, f, p, _) {
          if (super(), this.id = a, this.dispatcher = p, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, s.extend(this, s.pick(f, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.extend({ type: "vector" }, f), this._collectResourceTiming = f.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(_);
        }
        load() {
          this._loaded = !1, this.fire(new s.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = He(this._options, this.map._requestManager, (a, f) => {
            this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), a ? this.fire(new s.ErrorEvent(a)) : f && (s.extend(this, f), f.bounds && (this.tileBounds = new Ve(f.bounds, this.minzoom, this.maxzoom)), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(a) {
          return !this.tileBounds || this.tileBounds.contains(a.canonical);
        }
        onAdd(a) {
          this.map = a, this.load();
        }
        setSourceProperty(a) {
          this._tileJSONRequest && this._tileJSONRequest.cancel(), a(), this.load();
        }
        setTiles(a) {
          return this.setSourceProperty(() => {
            this._options.tiles = a;
          }), this;
        }
        setUrl(a) {
          return this.setSourceProperty(() => {
            this.url = a, this._options.url = a;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
        serialize() {
          return s.extend({}, this._options);
        }
        loadTile(a, f) {
          const p = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), _ = { request: this.map._requestManager.transformRequest(p, s.ResourceType.Tile), uid: a.uid, tileID: a.tileID, zoom: a.tileID.overscaledZ, tileSize: this.tileSize * a.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
          function b(M, P) {
            return delete a.request, a.aborted ? f(null) : M && M.status !== 404 ? f(M) : (P && P.resourceTiming && (a.resourceTiming = P.resourceTiming), this.map._refreshExpiredTiles && P && a.setExpiryData(P), a.loadVectorData(P, this.map.painter), s.cacheEntryPossiblyAdded(this.dispatcher), f(null), void (a.reloadCallback && (this.loadTile(a, a.reloadCallback), a.reloadCallback = null)));
          }
          _.request.collectResourceTiming = this._collectResourceTiming, a.actor && a.state !== "expired" ? a.state === "loading" ? a.reloadCallback = f : a.request = a.actor.send("reloadTile", _, b.bind(this)) : (a.actor = this.dispatcher.getActor(), a.request = a.actor.send("loadTile", _, b.bind(this)));
        }
        abortTile(a) {
          a.request && (a.request.cancel(), delete a.request), a.actor && a.actor.send("abortTile", { uid: a.uid, type: this.type, source: this.id }, void 0);
        }
        unloadTile(a) {
          a.unloadVectorData(), a.actor && a.actor.send("removeTile", { uid: a.uid, type: this.type, source: this.id }, void 0);
        }
        hasTransition() {
          return !1;
        }
      }
      class xe extends s.Evented {
        constructor(a, f, p, _) {
          super(), this.id = a, this.dispatcher = p, this.setEventedParent(_), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = s.extend({ type: "raster" }, f), s.extend(this, s.pick(f, ["url", "scheme", "tileSize"]));
        }
        load() {
          this._loaded = !1, this.fire(new s.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = He(this._options, this.map._requestManager, (a, f) => {
            this._tileJSONRequest = null, this._loaded = !0, a ? this.fire(new s.ErrorEvent(a)) : f && (s.extend(this, f), f.bounds && (this.tileBounds = new Ve(f.bounds, this.minzoom, this.maxzoom)), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(a) {
          this.map = a, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
        serialize() {
          return s.extend({}, this._options);
        }
        hasTile(a) {
          return !this.tileBounds || this.tileBounds.contains(a.canonical);
        }
        loadTile(a, f) {
          const p = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
          a.request = s.getImage(this.map._requestManager.transformRequest(p, s.ResourceType.Tile), (_, b, M) => {
            if (delete a.request, a.aborted)
              a.state = "unloaded", f(null);
            else if (_)
              a.state = "errored", f(_);
            else if (b) {
              this.map._refreshExpiredTiles && a.setExpiryData(M);
              const P = this.map.painter.context, O = P.gl;
              a.texture = this.map.painter.getTileTexture(b.width), a.texture ? a.texture.update(b, { useMipmap: !0 }) : (a.texture = new B(P, b, O.RGBA, { useMipmap: !0 }), a.texture.bind(O.LINEAR, O.CLAMP_TO_EDGE, O.LINEAR_MIPMAP_NEAREST), P.extTextureFilterAnisotropic && O.texParameterf(O.TEXTURE_2D, P.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, P.extTextureFilterAnisotropicMax)), a.state = "loaded", s.cacheEntryPossiblyAdded(this.dispatcher), f(null);
            }
          });
        }
        abortTile(a, f) {
          a.request && (a.request.cancel(), delete a.request), f();
        }
        unloadTile(a, f) {
          a.texture && this.map.painter.saveTileTexture(a.texture), f();
        }
        hasTransition() {
          return !1;
        }
      }
      let ze;
      class Pe extends xe {
        constructor(a, f, p, _) {
          super(a, f, p, _), this.type = "raster-dem", this.maxzoom = 22, this._options = s.extend({ type: "raster-dem" }, f), this.encoding = f.encoding || "mapbox";
        }
        serialize() {
          return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
        }
        loadTile(a, f) {
          const p = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
          function _(b, M) {
            b && (a.state = "errored", f(b)), M && (a.dem = M, a.needsHillshadePrepare = !0, a.needsTerrainPrepare = !0, a.state = "loaded", f(null));
          }
          a.request = s.getImage(this.map._requestManager.transformRequest(p, s.ResourceType.Tile), function(b, M) {
            if (delete a.request, a.aborted)
              a.state = "unloaded", f(null);
            else if (b)
              a.state = "errored", f(b);
            else if (M) {
              this.map._refreshExpiredTiles && a.setExpiryData(M), delete M.cacheControl, delete M.expires;
              const P = s.isImageBitmap(M) && (ze == null && (ze = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), ze) ? M : s.exported.getImageData(M, 1), O = { uid: a.uid, coord: a.tileID, source: this.id, rawImageData: P, encoding: this.encoding };
              a.actor && a.state !== "expired" || (a.actor = this.dispatcher.getActor(), a.actor.send("loadDEMTile", O, _.bind(this)));
            }
          }.bind(this)), a.neighboringTiles = this._getNeighboringTiles(a.tileID);
        }
        _getNeighboringTiles(a) {
          const f = a.canonical, p = Math.pow(2, f.z), _ = (f.x - 1 + p) % p, b = f.x === 0 ? a.wrap - 1 : a.wrap, M = (f.x + 1 + p) % p, P = f.x + 1 === p ? a.wrap + 1 : a.wrap, O = {};
          return O[new s.OverscaledTileID(a.overscaledZ, b, f.z, _, f.y).key] = { backfilled: !1 }, O[new s.OverscaledTileID(a.overscaledZ, P, f.z, M, f.y).key] = { backfilled: !1 }, f.y > 0 && (O[new s.OverscaledTileID(a.overscaledZ, b, f.z, _, f.y - 1).key] = { backfilled: !1 }, O[new s.OverscaledTileID(a.overscaledZ, a.wrap, f.z, f.x, f.y - 1).key] = { backfilled: !1 }, O[new s.OverscaledTileID(a.overscaledZ, P, f.z, M, f.y - 1).key] = { backfilled: !1 }), f.y + 1 < p && (O[new s.OverscaledTileID(a.overscaledZ, b, f.z, _, f.y + 1).key] = { backfilled: !1 }, O[new s.OverscaledTileID(a.overscaledZ, a.wrap, f.z, f.x, f.y + 1).key] = { backfilled: !1 }, O[new s.OverscaledTileID(a.overscaledZ, P, f.z, M, f.y + 1).key] = { backfilled: !1 }), O;
        }
        unloadTile(a) {
          a.demTexture && this.map.painter.saveTileTexture(a.demTexture), a.fbo && (a.fbo.destroy(), delete a.fbo), a.dem && delete a.dem, delete a.neighboringTiles, a.state = "unloaded", a.actor && a.actor.send("removeDEMTile", { uid: a.uid, source: this.id });
        }
      }
      class Ye extends s.Evented {
        constructor(a, f, p, _) {
          super(), this.id = a, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = p.getActor(), this.setEventedParent(_), this._data = f.data, this._options = s.extend({}, f), this._collectResourceTiming = f.collectResourceTiming, f.maxzoom !== void 0 && (this.maxzoom = f.maxzoom), f.type && (this.type = f.type), f.attribution && (this.attribution = f.attribution), this.promoteId = f.promoteId;
          const b = s.EXTENT / this.tileSize;
          this.workerOptions = s.extend({ source: this.id, cluster: f.cluster || !1, geojsonVtOptions: { buffer: (f.buffer !== void 0 ? f.buffer : 128) * b, tolerance: (f.tolerance !== void 0 ? f.tolerance : 0.375) * b, extent: s.EXTENT, maxZoom: this.maxzoom, lineMetrics: f.lineMetrics || !1, generateId: f.generateId || !1 }, superclusterOptions: { maxZoom: f.clusterMaxZoom !== void 0 ? f.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, f.clusterMinPoints || 2), extent: s.EXTENT, radius: (f.clusterRadius || 50) * b, log: !1, generateId: f.generateId || !1 }, clusterProperties: f.clusterProperties, filter: f.filter }, f.workerOptions);
        }
        load() {
          this._updateWorkerData("metadata");
        }
        onAdd(a) {
          this.map = a, this.load();
        }
        setData(a) {
          return this._data = a, this._updateWorkerData("content"), this;
        }
        getClusterExpansionZoom(a, f) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: a, source: this.id }, f), this;
        }
        getClusterChildren(a, f) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: a, source: this.id }, f), this;
        }
        getClusterLeaves(a, f, p, _) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: a, limit: f, offset: p }, _), this;
        }
        _updateWorkerData(a) {
          const f = s.extend({}, this.workerOptions), p = this._data;
          typeof p == "string" ? (f.request = this.map._requestManager.transformRequest(s.exported.resolveURL(p), s.ResourceType.Source), f.request.collectResourceTiming = this._collectResourceTiming) : f.data = JSON.stringify(p), this._pendingLoads++, this.fire(new s.Event("dataloading", { dataType: "source" })), this.actor.send(`${this.type}.loadData`, f, (_, b) => {
            if (this._pendingLoads--, this._removed || b && b.abandoned)
              return void this.fire(new s.Event("dataabort", { dataType: "source", sourceDataType: a }));
            let M = null;
            if (b && b.resourceTiming && b.resourceTiming[this.id] && (M = b.resourceTiming[this.id].slice(0)), _)
              return void this.fire(new s.ErrorEvent(_));
            const P = { dataType: "source", sourceDataType: a };
            this._collectResourceTiming && M && M.length > 0 && s.extend(P, { resourceTiming: M }), this.fire(new s.Event("data", P));
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(a, f) {
          const p = a.actor ? "reloadTile" : "loadTile";
          a.actor = this.actor;
          const _ = { type: this.type, uid: a.uid, tileID: a.tileID, zoom: a.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
          a.request = this.actor.send(p, _, (b, M) => (delete a.request, a.unloadVectorData(), a.aborted ? f(null) : b ? f(b) : (a.loadVectorData(M, this.map.painter, p === "reloadTile"), f(null))));
        }
        abortTile(a) {
          a.request && (a.request.cancel(), delete a.request), a.aborted = !0;
        }
        unloadTile(a) {
          a.unloadVectorData(), this.actor.send("removeTile", { uid: a.uid, type: this.type, source: this.id });
        }
        onRemove() {
          this._removed = !0, this.actor.send("removeSource", { type: this.type, source: this.id });
        }
        serialize() {
          return s.extend({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      var it = s.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class kt extends s.Evented {
        constructor(a, f, p, _) {
          super(), this.id = a, this.dispatcher = p, this.coordinates = f.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(_), this.options = f;
        }
        load(a, f) {
          this._loaded = !1, this.fire(new s.Event("dataloading", { dataType: "source" })), this.url = this.options.url, s.getImage(this.map._requestManager.transformRequest(this.url, s.ResourceType.Image), (p, _) => {
            this._loaded = !0, p ? this.fire(new s.ErrorEvent(p)) : _ && (this.image = _, a && (this.coordinates = a), f && f(), this._finishLoading());
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(a) {
          return this.image && a.url ? (this.options.url = a.url, this.load(a.coordinates, () => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(a) {
          this.map = a, this.load();
        }
        setCoordinates(a) {
          this.coordinates = a;
          const f = a.map(s.MercatorCoordinate.fromLngLat);
          this.tileID = function(_) {
            let b = 1 / 0, M = 1 / 0, P = -1 / 0, O = -1 / 0;
            for (const G of _)
              b = Math.min(b, G.x), M = Math.min(M, G.y), P = Math.max(P, G.x), O = Math.max(O, G.y);
            const D = Math.max(P - b, O - M), F = Math.max(0, Math.floor(-Math.log(D) / Math.LN2)), $ = Math.pow(2, F);
            return new s.CanonicalTileID(F, Math.floor((b + P) / 2 * $), Math.floor((M + O) / 2 * $));
          }(f), this.minzoom = this.maxzoom = this.tileID.z;
          const p = f.map((_) => this.tileID.getTilePoint(_)._round());
          return this._boundsArray = new s.RasterBoundsArray(), this._boundsArray.emplaceBack(p[0].x, p[0].y, 0, 0), this._boundsArray.emplaceBack(p[1].x, p[1].y, s.EXTENT, 0), this._boundsArray.emplaceBack(p[3].x, p[3].y, 0, s.EXTENT), this._boundsArray.emplaceBack(p[2].x, p[2].y, s.EXTENT, s.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new s.Event("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image)
            return;
          const a = this.map.painter.context, f = a.gl;
          this.boundsBuffer || (this.boundsBuffer = a.createVertexBuffer(this._boundsArray, it.members)), this.boundsSegments || (this.boundsSegments = s.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new B(a, this.image, f.RGBA), this.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE));
          for (const p in this.tiles) {
            const _ = this.tiles[p];
            _.state !== "loaded" && (_.state = "loaded", _.texture = this.texture);
          }
        }
        loadTile(a, f) {
          this.tileID && this.tileID.equals(a.tileID.canonical) ? (this.tiles[String(a.tileID.wrap)] = a, a.buckets = {}, f(null)) : (a.state = "errored", f(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class Er extends kt {
        constructor(a, f, p, _) {
          super(a, f, p, _), this.roundZoom = !0, this.type = "video", this.options = f;
        }
        load() {
          this._loaded = !1;
          const a = this.options;
          this.urls = [];
          for (const f of a.urls)
            this.urls.push(this.map._requestManager.transformRequest(f, s.ResourceType.Source).url);
          s.getVideo(this.urls, (f, p) => {
            this._loaded = !0, f ? this.fire(new s.ErrorEvent(f)) : p && (this.video = p, this.video.loop = !0, this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(a) {
          if (this.video) {
            const f = this.video.seekable;
            a < f.start(0) || a > f.end(0) ? this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${f.start(0)} and ${f.end(0)}-second mark.`))) : this.video.currentTime = a;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(a) {
          this.map || (this.map = a, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
            return;
          const a = this.map.painter.context, f = a.gl;
          this.boundsBuffer || (this.boundsBuffer = a.createVertexBuffer(this._boundsArray, it.members)), this.boundsSegments || (this.boundsSegments = s.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE), f.texSubImage2D(f.TEXTURE_2D, 0, 0, 0, f.RGBA, f.UNSIGNED_BYTE, this.video)) : (this.texture = new B(a, this.video, f.RGBA), this.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE));
          for (const p in this.tiles) {
            const _ = this.tiles[p];
            _.state !== "loaded" && (_.state = "loaded", _.texture = this.texture);
          }
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class mr extends kt {
        constructor(a, f, p, _) {
          super(a, f, p, _), f.coordinates ? Array.isArray(f.coordinates) && f.coordinates.length === 4 && !f.coordinates.some((b) => !Array.isArray(b) || b.length !== 2 || b.some((M) => typeof M != "number")) || this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${a}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${a}`, null, 'missing required property "coordinates"'))), f.animate && typeof f.animate != "boolean" && this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${a}`, null, 'optional "animate" property must be a boolean value'))), f.canvas ? typeof f.canvas == "string" || f.canvas instanceof HTMLCanvasElement || this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${a}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.ErrorEvent(new s.ValidationError(`sources.${a}`, null, 'missing required property "canvas"'))), this.options = f, this.animate = f.animate === void 0 || f.animate;
        }
        load() {
          this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = !0, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = !1);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(a) {
          this.map = a, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let a = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, a = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, a = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)
            return;
          const f = this.map.painter.context, p = f.gl;
          this.boundsBuffer || (this.boundsBuffer = f.createVertexBuffer(this._boundsArray, it.members)), this.boundsSegments || (this.boundsSegments = s.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (a || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new B(f, this.canvas, p.RGBA, { premultiply: !0 });
          for (const _ in this.tiles) {
            const b = this.tiles[_];
            b.state !== "loaded" && (b.state = "loaded", b.texture = this.texture);
          }
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const a of [this.canvas.width, this.canvas.height])
            if (isNaN(a) || a <= 0)
              return !0;
          return !1;
        }
      }
      const Yt = { vector: dt, raster: xe, "raster-dem": Pe, geojson: Ye, video: Er, image: kt, canvas: mr };
      function on(g, a) {
        const f = s.create();
        return s.translate(f, f, [1, 1, 0]), s.scale(f, f, [0.5 * g.width, 0.5 * g.height, 1]), s.multiply(f, f, g.calculatePosMatrix(a.toUnwrapped()));
      }
      function or(g, a, f, p, _, b) {
        const M = function($, G, ie) {
          if ($)
            for (const Q of $) {
              const te = G[Q];
              if (te && te.source === ie && te.type === "fill-extrusion")
                return !0;
            }
          else
            for (const Q in G) {
              const te = G[Q];
              if (te.source === ie && te.type === "fill-extrusion")
                return !0;
            }
          return !1;
        }(_ && _.layers, a, g.id), P = b.maxPitchScaleFactor(), O = g.tilesIn(p, P, M);
        O.sort(Jt);
        const D = [];
        for (const $ of O)
          D.push({ wrappedTileID: $.tileID.wrapped().key, queryResults: $.tile.queryRenderedFeatures(a, f, g._state, $.queryGeometry, $.cameraQueryGeometry, $.scale, _, b, P, on(g.transform, $.tileID)) });
        const F = function($) {
          const G = {}, ie = {};
          for (const Q of $) {
            const te = Q.queryResults, de = Q.wrappedTileID, be = ie[de] = ie[de] || {};
            for (const Se in te) {
              const oe = te[Se], Le = be[Se] = be[Se] || {}, Ie = G[Se] = G[Se] || [];
              for (const Be of oe)
                Le[Be.featureIndex] || (Le[Be.featureIndex] = !0, Ie.push(Be));
            }
          }
          return G;
        }(D);
        for (const $ in F)
          F[$].forEach((G) => {
            const ie = G.feature, Q = g.getFeatureState(ie.layer["source-layer"], ie.id);
            ie.source = ie.layer.source, ie.layer["source-layer"] && (ie.sourceLayer = ie.layer["source-layer"]), ie.state = Q;
          });
        return F;
      }
      function Jt(g, a) {
        const f = g.tileID, p = a.tileID;
        return f.overscaledZ - p.overscaledZ || f.canonical.y - p.canonical.y || f.wrap - p.wrap || f.canonical.x - p.canonical.x;
      }
      class Ht {
        constructor(a, f) {
          this.tileID = a, this.uid = s.uniqueId(), this.uses = 0, this.tileSize = f, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.textures = [], this.textureCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(a) {
          const f = a + this.timeAdded;
          f < s.exported.now() || this.fadeEndTime && f < this.fadeEndTime || (this.fadeEndTime = f);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(a) {
          this.demTexture && a.saveTileTexture(this.demTexture), this.textures.forEach((f) => a.saveTileTexture(f)), this.demTexture = null, this.textures = [], this.textureCoords = {};
        }
        loadVectorData(a, f, p) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", a) {
            a.featureIndex && (this.latestFeatureIndex = a.featureIndex, a.rawTileData ? (this.latestRawTileData = a.rawTileData, this.latestFeatureIndex.rawTileData = a.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = a.collisionBoxArray, this.buckets = function(_, b) {
              const M = {};
              if (!b)
                return M;
              for (const P of _) {
                const O = P.layerIds.map((D) => b.getLayer(D)).filter(Boolean);
                if (O.length !== 0) {
                  P.layers = O, P.stateDependentLayerIds && (P.stateDependentLayers = P.stateDependentLayerIds.map((D) => O.filter((F) => F.id === D)[0]));
                  for (const D of O)
                    M[D.id] = P;
                }
              }
              return M;
            }(a.buckets, f.style), this.hasSymbolBuckets = !1;
            for (const _ in this.buckets) {
              const b = this.buckets[_];
              if (b instanceof s.SymbolBucket) {
                if (this.hasSymbolBuckets = !0, !p)
                  break;
                b.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets)
              for (const _ in this.buckets) {
                const b = this.buckets[_];
                if (b instanceof s.SymbolBucket && b.hasRTLText) {
                  this.hasRTLText = !0, s.lazyLoadRTLTextPlugin();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const _ in this.buckets) {
              const b = this.buckets[_];
              this.queryPadding = Math.max(this.queryPadding, f.style.getLayer(_).queryRadius(b));
            }
            a.imageAtlas && (this.imageAtlas = a.imageAtlas), a.glyphAtlasImage && (this.glyphAtlasImage = a.glyphAtlasImage);
          } else
            this.collisionBoxArray = new s.CollisionBoxArray();
        }
        unloadVectorData() {
          for (const a in this.buckets)
            this.buckets[a].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(a) {
          return this.buckets[a.id];
        }
        upload(a) {
          for (const p in this.buckets) {
            const _ = this.buckets[p];
            _.uploadPending() && _.upload(a);
          }
          const f = a.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new B(a, this.imageAtlas.image, f.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new B(a, this.glyphAtlasImage, f.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(a) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(a, this.imageAtlasTexture);
        }
        queryRenderedFeatures(a, f, p, _, b, M, P, O, D, F) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: _, cameraQueryGeometry: b, scale: M, tileSize: this.tileSize, pixelPosMatrix: F, transform: O, params: P, queryPadding: this.queryPadding * D }, a, f, p) : {};
        }
        querySourceFeatures(a, f) {
          const p = this.latestFeatureIndex;
          if (!p || !p.rawTileData)
            return;
          const _ = p.loadVTLayers(), b = f ? f.sourceLayer : "", M = _._geojsonTileLayer || _[b];
          if (!M)
            return;
          const P = s.createFilter(f && f.filter), { z: O, x: D, y: F } = this.tileID.canonical, $ = { z: O, x: D, y: F };
          for (let G = 0; G < M.length; G++) {
            const ie = M.feature(G);
            if (P.needGeometry) {
              const de = s.toEvaluationFeature(ie, !0);
              if (!P.filter(new s.EvaluationParameters(this.tileID.overscaledZ), de, this.tileID.canonical))
                continue;
            } else if (!P.filter(new s.EvaluationParameters(this.tileID.overscaledZ), ie))
              continue;
            const Q = p.getId(ie, b), te = new s.GeoJSONFeature(ie, O, D, F, Q);
            te.tile = $, a.push(te);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(a) {
          const f = this.expirationTime;
          if (a.cacheControl) {
            const p = s.parseCacheControl(a.cacheControl);
            p["max-age"] && (this.expirationTime = Date.now() + 1e3 * p["max-age"]);
          } else
            a.expires && (this.expirationTime = new Date(a.expires).getTime());
          if (this.expirationTime) {
            const p = Date.now();
            let _ = !1;
            if (this.expirationTime > p)
              _ = !1;
            else if (f)
              if (this.expirationTime < f)
                _ = !0;
              else {
                const b = this.expirationTime - f;
                b ? this.expirationTime = p + Math.max(b, 3e4) : _ = !0;
              }
            else
              _ = !0;
            _ ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(a, f) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(a).length === 0)
            return;
          const p = this.latestFeatureIndex.loadVTLayers();
          for (const _ in this.buckets) {
            if (!f.style.hasLayer(_))
              continue;
            const b = this.buckets[_], M = b.layers[0].sourceLayer || "_geojsonTileLayer", P = p[M], O = a[M];
            if (!P || !O || Object.keys(O).length === 0)
              continue;
            b.update(O, P, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const D = f && f.style && f.style.getLayer(_);
            D && (this.queryPadding = Math.max(this.queryPadding, D.queryRadius(b)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < s.exported.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(a) {
          this.symbolFadeHoldUntil = s.exported.now() + a;
        }
        setDependencies(a, f) {
          const p = {};
          for (const _ of f)
            p[_] = !0;
          this.dependencies[a] = p;
        }
        hasDependency(a, f) {
          for (const p of a) {
            const _ = this.dependencies[p];
            if (_) {
              for (const b of f)
                if (_[b])
                  return !0;
            }
          }
          return !1;
        }
      }
      class xr {
        constructor(a, f) {
          this.max = a, this.onRemove = f, this.reset();
        }
        reset() {
          for (const a in this.data)
            for (const f of this.data[a])
              f.timeout && clearTimeout(f.timeout), this.onRemove(f.value);
          return this.data = {}, this.order = [], this;
        }
        add(a, f, p) {
          const _ = a.wrapped().key;
          this.data[_] === void 0 && (this.data[_] = []);
          const b = { value: f, timeout: void 0 };
          if (p !== void 0 && (b.timeout = setTimeout(() => {
            this.remove(a, b);
          }, p)), this.data[_].push(b), this.order.push(_), this.order.length > this.max) {
            const M = this._getAndRemoveByKey(this.order[0]);
            M && this.onRemove(M);
          }
          return this;
        }
        has(a) {
          return a.wrapped().key in this.data;
        }
        getAndRemove(a) {
          return this.has(a) ? this._getAndRemoveByKey(a.wrapped().key) : null;
        }
        _getAndRemoveByKey(a) {
          const f = this.data[a].shift();
          return f.timeout && clearTimeout(f.timeout), this.data[a].length === 0 && delete this.data[a], this.order.splice(this.order.indexOf(a), 1), f.value;
        }
        getByKey(a) {
          const f = this.data[a];
          return f ? f[0].value : null;
        }
        get(a) {
          return this.has(a) ? this.data[a.wrapped().key][0].value : null;
        }
        remove(a, f) {
          if (!this.has(a))
            return this;
          const p = a.wrapped().key, _ = f === void 0 ? 0 : this.data[p].indexOf(f), b = this.data[p][_];
          return this.data[p].splice(_, 1), b.timeout && clearTimeout(b.timeout), this.data[p].length === 0 && delete this.data[p], this.onRemove(b.value), this.order.splice(this.order.indexOf(p), 1), this;
        }
        setMaxSize(a) {
          for (this.max = a; this.order.length > this.max; ) {
            const f = this._getAndRemoveByKey(this.order[0]);
            f && this.onRemove(f);
          }
          return this;
        }
        filter(a) {
          const f = [];
          for (const p in this.data)
            for (const _ of this.data[p])
              a(_.value) || f.push(_);
          for (const p of f)
            this.remove(p.value.tileID, p);
        }
      }
      class Cr {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(a, f, p) {
          const _ = String(f);
          if (this.stateChanges[a] = this.stateChanges[a] || {}, this.stateChanges[a][_] = this.stateChanges[a][_] || {}, s.extend(this.stateChanges[a][_], p), this.deletedStates[a] === null) {
            this.deletedStates[a] = {};
            for (const b in this.state[a])
              b !== _ && (this.deletedStates[a][b] = null);
          } else if (this.deletedStates[a] && this.deletedStates[a][_] === null) {
            this.deletedStates[a][_] = {};
            for (const b in this.state[a][_])
              p[b] || (this.deletedStates[a][_][b] = null);
          } else
            for (const b in p)
              this.deletedStates[a] && this.deletedStates[a][_] && this.deletedStates[a][_][b] === null && delete this.deletedStates[a][_][b];
        }
        removeFeatureState(a, f, p) {
          if (this.deletedStates[a] === null)
            return;
          const _ = String(f);
          if (this.deletedStates[a] = this.deletedStates[a] || {}, p && f !== void 0)
            this.deletedStates[a][_] !== null && (this.deletedStates[a][_] = this.deletedStates[a][_] || {}, this.deletedStates[a][_][p] = null);
          else if (f !== void 0)
            if (this.stateChanges[a] && this.stateChanges[a][_])
              for (p in this.deletedStates[a][_] = {}, this.stateChanges[a][_])
                this.deletedStates[a][_][p] = null;
            else
              this.deletedStates[a][_] = null;
          else
            this.deletedStates[a] = null;
        }
        getState(a, f) {
          const p = String(f), _ = s.extend({}, (this.state[a] || {})[p], (this.stateChanges[a] || {})[p]);
          if (this.deletedStates[a] === null)
            return {};
          if (this.deletedStates[a]) {
            const b = this.deletedStates[a][f];
            if (b === null)
              return {};
            for (const M in b)
              delete _[M];
          }
          return _;
        }
        initializeTileState(a, f) {
          a.setFeatureState(this.state, f);
        }
        coalesceChanges(a, f) {
          const p = {};
          for (const _ in this.stateChanges) {
            this.state[_] = this.state[_] || {};
            const b = {};
            for (const M in this.stateChanges[_])
              this.state[_][M] || (this.state[_][M] = {}), s.extend(this.state[_][M], this.stateChanges[_][M]), b[M] = this.state[_][M];
            p[_] = b;
          }
          for (const _ in this.deletedStates) {
            this.state[_] = this.state[_] || {};
            const b = {};
            if (this.deletedStates[_] === null)
              for (const M in this.state[_])
                b[M] = {}, this.state[_][M] = {};
            else
              for (const M in this.deletedStates[_]) {
                if (this.deletedStates[_][M] === null)
                  this.state[_][M] = {};
                else
                  for (const P of Object.keys(this.deletedStates[_][M]))
                    delete this.state[_][M][P];
                b[M] = this.state[_][M];
              }
            p[_] = p[_] || {}, s.extend(p[_], b);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(p).length !== 0)
            for (const _ in a)
              a[_].setFeatureState(p, f);
        }
      }
      class an extends s.Evented {
        constructor(a, f, p) {
          super(), this.id = a, this.dispatcher = p, this.on("data", (_) => {
            _.dataType === "source" && _.sourceDataType === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && _.dataType === "source" && _.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain));
          }), this.on("dataloading", () => {
            this._sourceErrored = !1;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = function(_, b, M, P) {
            const O = new Yt[b.type](_, b, M, P);
            if (O.id !== _)
              throw new Error(`Expected Source id to be ${_} instead of ${O.id}`);
            return s.bindAll(["load", "abort", "unload", "serialize", "prepare"], O), O;
          }(a, f, p, this), this._tiles = {}, this._cache = new xr(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Cr();
        }
        onAdd(a) {
          this.map = a, this._maxTileCacheSize = a ? a._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(a);
        }
        onRemove(a) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(a);
        }
        loaded() {
          if (this._sourceErrored)
            return !0;
          if (!this._sourceLoaded || !this._source.loaded())
            return !1;
          for (const a in this._tiles) {
            const f = this._tiles[a];
            if (f.state !== "loaded" && f.state !== "errored")
              return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused)
            return;
          const a = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, a && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(a, f) {
          return this._source.loadTile(a, f);
        }
        _unloadTile(a) {
          if (this._source.unloadTile)
            return this._source.unloadTile(a, () => {
            });
        }
        _abortTile(a) {
          this._source.abortTile && this._source.abortTile(a, () => {
          }), this._source.fire(new s.Event("dataabort", { tile: a, coord: a.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(a) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const f in this._tiles) {
            const p = this._tiles[f];
            p.upload(a), p.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((a) => a.tileID).sort(kr).map((a) => a.key);
        }
        getRenderableIds(a) {
          const f = [];
          for (const p in this._tiles)
            this._isIdRenderable(p, a) && f.push(this._tiles[p]);
          return a ? f.sort((p, _) => {
            const b = p.tileID, M = _.tileID, P = new s.pointGeometry(b.canonical.x, b.canonical.y)._rotate(this.transform.angle), O = new s.pointGeometry(M.canonical.x, M.canonical.y)._rotate(this.transform.angle);
            return b.overscaledZ - M.overscaledZ || O.y - P.y || O.x - P.x;
          }).map((p) => p.tileID.key) : f.map((p) => p.tileID).sort(kr).map((p) => p.key);
        }
        hasRenderableParent(a) {
          const f = this.findLoadedParent(a, 0);
          return !!f && this._isIdRenderable(f.tileID.key);
        }
        _isIdRenderable(a, f) {
          return this._tiles[a] && this._tiles[a].hasData() && !this._coveredTiles[a] && (f || !this._tiles[a].holdingForFade());
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const a in this._tiles)
              this._tiles[a].state !== "errored" && this._reloadTile(a, "reloading");
          }
        }
        _reloadTile(a, f) {
          const p = this._tiles[a];
          p && (p.state !== "loading" && (p.state = f), this._loadTile(p, this._tileLoaded.bind(this, p, a, f)));
        }
        _tileLoaded(a, f, p, _) {
          if (_)
            return a.state = "errored", void (_.status !== 404 ? this._source.fire(new s.ErrorEvent(_, { tile: a })) : this.update(this.transform, this.terrain));
          a.timeAdded = s.exported.now(), p === "expired" && (a.refreshedUponExpiration = !0), this._setTileReloadTimer(f, a), this.getSource().type === "raster-dem" && a.dem && this._backfillDEM(a), this._state.initializeTileState(a, this.map ? this.map.painter : null), a.aborted || this._source.fire(new s.Event("data", { dataType: "source", tile: a, coord: a.tileID }));
        }
        _backfillDEM(a) {
          const f = this.getRenderableIds();
          for (let _ = 0; _ < f.length; _++) {
            const b = f[_];
            if (a.neighboringTiles && a.neighboringTiles[b]) {
              const M = this.getTileByID(b);
              p(a, M), p(M, a);
            }
          }
          function p(_, b) {
            _.needsHillshadePrepare = !0, _.needsTerrainPrepare = !0;
            let M = b.tileID.canonical.x - _.tileID.canonical.x;
            const P = b.tileID.canonical.y - _.tileID.canonical.y, O = Math.pow(2, _.tileID.canonical.z), D = b.tileID.key;
            M === 0 && P === 0 || Math.abs(P) > 1 || (Math.abs(M) > 1 && (Math.abs(M + O) === 1 ? M += O : Math.abs(M - O) === 1 && (M -= O)), b.dem && _.dem && (_.dem.backfillBorder(b.dem, M, P), _.neighboringTiles && _.neighboringTiles[D] && (_.neighboringTiles[D].backfilled = !0)));
          }
        }
        getTile(a) {
          return this.getTileByID(a.key);
        }
        getTileByID(a) {
          return this._tiles[a];
        }
        _retainLoadedChildren(a, f, p, _) {
          for (const b in this._tiles) {
            let M = this._tiles[b];
            if (_[b] || !M.hasData() || M.tileID.overscaledZ <= f || M.tileID.overscaledZ > p)
              continue;
            let P = M.tileID;
            for (; M && M.tileID.overscaledZ > f + 1; ) {
              const D = M.tileID.scaledTo(M.tileID.overscaledZ - 1);
              M = this._tiles[D.key], M && M.hasData() && (P = D);
            }
            let O = P;
            for (; O.overscaledZ > f; )
              if (O = O.scaledTo(O.overscaledZ - 1), a[O.key]) {
                _[P.key] = P;
                break;
              }
          }
        }
        findLoadedParent(a, f) {
          if (a.key in this._loadedParentTiles) {
            const p = this._loadedParentTiles[a.key];
            return p && p.tileID.overscaledZ >= f ? p : null;
          }
          for (let p = a.overscaledZ - 1; p >= f; p--) {
            const _ = a.scaledTo(p), b = this._getLoadedTile(_);
            if (b)
              return b;
          }
        }
        _getLoadedTile(a) {
          const f = this._tiles[a.key];
          return f && f.hasData() ? f : this._cache.getByKey(a.wrapped().key);
        }
        updateCacheSize(a) {
          const f = Math.ceil(a.width / this._source.tileSize) + 1, p = Math.ceil(a.height / this._source.tileSize) + 1, _ = Math.floor(f * p * 5), b = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, _) : _;
          this._cache.setMaxSize(b);
        }
        handleWrapJump(a) {
          const f = Math.round((a - (this._prevLng === void 0 ? a : this._prevLng)) / 360);
          if (this._prevLng = a, f) {
            const p = {};
            for (const _ in this._tiles) {
              const b = this._tiles[_];
              b.tileID = b.tileID.unwrapTo(b.tileID.wrap + f), p[b.tileID.key] = b;
            }
            this._tiles = p;
            for (const _ in this._timers)
              clearTimeout(this._timers[_]), delete this._timers[_];
            for (const _ in this._tiles)
              this._setTileReloadTimer(_, this._tiles[_]);
          }
        }
        update(a, f) {
          if (this.transform = a, this.terrain = f, !this._sourceLoaded || this._paused)
            return;
          let p;
          this.updateCacheSize(a), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? p = a.getVisibleUnwrappedCoordinates(this._source.tileID).map((D) => new s.OverscaledTileID(D.canonical.z, D.wrap, D.canonical.z, D.canonical.x, D.canonical.y)) : (p = a.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: f }), this._source.hasTile && (p = p.filter((D) => this._source.hasTile(D)))) : p = [];
          const _ = a.coveringZoomLevel(this._source), b = Math.max(_ - an.maxOverzooming, this._source.minzoom), M = Math.max(_ + an.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const D = {};
            for (const F of p)
              if (F.canonical.z > this._source.minzoom) {
                const $ = F.scaledTo(F.canonical.z - 1);
                D[$.key] = $;
                const G = F.scaledTo(Math.max(this._source.minzoom, Math.min(F.canonical.z, 5)));
                D[G.key] = G;
              }
            p = p.concat(Object.values(D));
          }
          const P = this._updateRetainedTiles(p, _);
          if (Pn(this._source.type)) {
            const D = {}, F = {}, $ = Object.keys(P);
            for (const G of $) {
              const ie = P[G], Q = this._tiles[G];
              if (!Q || Q.fadeEndTime && Q.fadeEndTime <= s.exported.now())
                continue;
              const te = this.findLoadedParent(ie, b);
              te && (this._addTile(te.tileID), D[te.tileID.key] = te.tileID), F[G] = ie;
            }
            this._retainLoadedChildren(F, _, M, P);
            for (const G in D)
              P[G] || (this._coveredTiles[G] = !0, P[G] = D[G]);
            if (f) {
              const G = {}, ie = {};
              for (const Q of p)
                this._tiles[Q.key].hasData() ? G[Q.key] = Q : ie[Q.key] = Q;
              for (const Q in ie) {
                const te = ie[Q].children(this._source.maxzoom);
                this._tiles[te[0].key] && this._tiles[te[1].key] && this._tiles[te[2].key] && this._tiles[te[3].key] && (G[te[0].key] = P[te[0].key] = te[0], G[te[1].key] = P[te[1].key] = te[1], G[te[2].key] = P[te[2].key] = te[2], G[te[3].key] = P[te[3].key] = te[3], delete ie[Q]);
              }
              for (const Q in ie) {
                const te = this.findLoadedParent(ie[Q], this._source.minzoom);
                if (te) {
                  G[te.tileID.key] = P[te.tileID.key] = te.tileID;
                  for (const de in G)
                    G[de].isChildOf(te.tileID) && delete G[de];
                }
              }
              for (const Q in this._tiles)
                G[Q] || (this._coveredTiles[Q] = !0);
            }
          }
          for (const D in P)
            this._tiles[D].clearFadeHold();
          const O = s.keysDifference(this._tiles, P);
          for (const D of O) {
            const F = this._tiles[D];
            F.hasSymbolBuckets && !F.holdingForFade() ? F.setHoldDuration(this.map._fadeDuration) : F.hasSymbolBuckets && !F.symbolFadeFinished() || this._removeTile(D);
          }
          this._updateLoadedParentTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const a in this._tiles)
            this._tiles[a].holdingForFade() && this._removeTile(a);
        }
        _updateRetainedTiles(a, f) {
          const p = {}, _ = {}, b = Math.max(f - an.maxOverzooming, this._source.minzoom), M = Math.max(f + an.maxUnderzooming, this._source.minzoom), P = {};
          for (const O of a) {
            const D = this._addTile(O);
            p[O.key] = O, D.hasData() || f < this._source.maxzoom && (P[O.key] = O);
          }
          this._retainLoadedChildren(P, f, M, p);
          for (const O of a) {
            let D = this._tiles[O.key];
            if (D.hasData())
              continue;
            if (f + 1 > this._source.maxzoom) {
              const $ = O.children(this._source.maxzoom)[0], G = this.getTile($);
              if (G && G.hasData()) {
                p[$.key] = $;
                continue;
              }
            } else {
              const $ = O.children(this._source.maxzoom);
              if (p[$[0].key] && p[$[1].key] && p[$[2].key] && p[$[3].key])
                continue;
            }
            let F = D.wasRequested();
            for (let $ = O.overscaledZ - 1; $ >= b; --$) {
              const G = O.scaledTo($);
              if (_[G.key] || (_[G.key] = !0, D = this.getTile(G), !D && F && (D = this._addTile(G)), D && (p[G.key] = G, F = D.wasRequested(), D.hasData())))
                break;
            }
          }
          return p;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const a in this._tiles) {
            const f = [];
            let p, _ = this._tiles[a].tileID;
            for (; _.overscaledZ > 0; ) {
              if (_.key in this._loadedParentTiles) {
                p = this._loadedParentTiles[_.key];
                break;
              }
              f.push(_.key);
              const b = _.scaledTo(_.overscaledZ - 1);
              if (p = this._getLoadedTile(b), p)
                break;
              _ = b;
            }
            for (const b of f)
              this._loadedParentTiles[b] = p;
          }
        }
        _addTile(a) {
          let f = this._tiles[a.key];
          if (f)
            return f;
          f = this._cache.getAndRemove(a), f && (this._setTileReloadTimer(a.key, f), f.tileID = a, this._state.initializeTileState(f, this.map ? this.map.painter : null), this._cacheTimers[a.key] && (clearTimeout(this._cacheTimers[a.key]), delete this._cacheTimers[a.key], this._setTileReloadTimer(a.key, f)));
          const p = f;
          return f || (f = new Ht(a, this._source.tileSize * a.overscaleFactor()), this._loadTile(f, this._tileLoaded.bind(this, f, a.key, f.state))), f.uses++, this._tiles[a.key] = f, p || this._source.fire(new s.Event("dataloading", { tile: f, coord: f.tileID, dataType: "source" })), f;
        }
        _setTileReloadTimer(a, f) {
          a in this._timers && (clearTimeout(this._timers[a]), delete this._timers[a]);
          const p = f.getExpiryTimeout();
          p && (this._timers[a] = setTimeout(() => {
            this._reloadTile(a, "expired"), delete this._timers[a];
          }, p));
        }
        _removeTile(a) {
          const f = this._tiles[a];
          f && (f.uses--, delete this._tiles[a], this._timers[a] && (clearTimeout(this._timers[a]), delete this._timers[a]), f.uses > 0 || (f.hasData() && f.state !== "reloading" ? this._cache.add(f.tileID, f, f.getExpiryTimeout()) : (f.aborted = !0, this._abortTile(f), this._unloadTile(f))));
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const a in this._tiles)
            this._removeTile(a);
          this._cache.reset();
        }
        tilesIn(a, f, p) {
          const _ = [], b = this.transform;
          if (!b)
            return _;
          const M = p ? b.getCameraQueryGeometry(a) : a, P = a.map((Q) => b.pointCoordinate(Q, this.terrain)), O = M.map((Q) => b.pointCoordinate(Q, this.terrain)), D = this.getIds();
          let F = 1 / 0, $ = 1 / 0, G = -1 / 0, ie = -1 / 0;
          for (const Q of O)
            F = Math.min(F, Q.x), $ = Math.min($, Q.y), G = Math.max(G, Q.x), ie = Math.max(ie, Q.y);
          for (let Q = 0; Q < D.length; Q++) {
            const te = this._tiles[D[Q]];
            if (te.holdingForFade())
              continue;
            const de = te.tileID, be = Math.pow(2, b.zoom - te.tileID.overscaledZ), Se = f * te.queryPadding * s.EXTENT / te.tileSize / be, oe = [de.getTilePoint(new s.MercatorCoordinate(F, $)), de.getTilePoint(new s.MercatorCoordinate(G, ie))];
            if (oe[0].x - Se < s.EXTENT && oe[0].y - Se < s.EXTENT && oe[1].x + Se >= 0 && oe[1].y + Se >= 0) {
              const Le = P.map((Be) => de.getTilePoint(Be)), Ie = O.map((Be) => de.getTilePoint(Be));
              _.push({ tile: te, tileID: de, queryGeometry: Le, cameraQueryGeometry: Ie, scale: be });
            }
          }
          return _;
        }
        getVisibleCoordinates(a) {
          const f = this.getRenderableIds(a).map((p) => this._tiles[p].tileID);
          for (const p of f)
            p.posMatrix = this.transform.calculatePosMatrix(p.toUnwrapped());
          return f;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return !0;
          if (Pn(this._source.type))
            for (const a in this._tiles) {
              const f = this._tiles[a];
              if (f.fadeEndTime !== void 0 && f.fadeEndTime >= s.exported.now())
                return !0;
            }
          return !1;
        }
        setFeatureState(a, f, p) {
          this._state.updateState(a = a || "_geojsonTileLayer", f, p);
        }
        removeFeatureState(a, f, p) {
          this._state.removeFeatureState(a = a || "_geojsonTileLayer", f, p);
        }
        getFeatureState(a, f) {
          return this._state.getState(a = a || "_geojsonTileLayer", f);
        }
        setDependencies(a, f, p) {
          const _ = this._tiles[a];
          _ && _.setDependencies(f, p);
        }
        reloadTilesForDependencies(a, f) {
          for (const p in this._tiles)
            this._tiles[p].hasDependency(a, f) && this._reloadTile(p, "reloading");
          this._cache.filter((p) => !p.hasDependency(a, f));
        }
      }
      function kr(g, a) {
        const f = Math.abs(2 * g.wrap) - +(g.wrap < 0), p = Math.abs(2 * a.wrap) - +(a.wrap < 0);
        return g.overscaledZ - a.overscaledZ || p - f || a.canonical.y - g.canonical.y || a.canonical.x - g.canonical.x;
      }
      function Pn(g) {
        return g === "raster" || g === "image" || g === "video";
      }
      an.maxOverzooming = 10, an.maxUnderzooming = 3;
      const qr = "mapboxgl_preloaded_worker_pool";
      class re {
        constructor() {
          this.active = {};
        }
        acquire(a) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < re.workerCount; )
              this.workers.push(new Worker(_s.workerUrl));
          return this.active[a] = !0, this.workers.slice();
        }
        release(a) {
          delete this.active[a], this.numActive() === 0 && (this.workers.forEach((f) => {
            f.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[qr];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const pe = Math.floor(s.exported.hardwareConcurrency / 2);
      let ke;
      function Ze() {
        return ke || (ke = new re()), ke;
      }
      function Ge(g, a) {
        const f = {};
        for (const p in g)
          p !== "ref" && (f[p] = g[p]);
        return s.refProperties.forEach((p) => {
          p in a && (f[p] = a[p]);
        }), f;
      }
      function rt(g) {
        g = g.slice();
        const a = /* @__PURE__ */ Object.create(null);
        for (let f = 0; f < g.length; f++)
          a[g[f].id] = g[f];
        for (let f = 0; f < g.length; f++)
          "ref" in g[f] && (g[f] = Ge(g[f], a[g[f].ref]));
        return g;
      }
      re.workerCount = Math.max(Math.min(pe, 6), 1);
      const Xe = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
      function Je(g, a, f) {
        f.push({ command: Xe.addSource, args: [g, a[g]] });
      }
      function at(g, a, f) {
        a.push({ command: Xe.removeSource, args: [g] }), f[g] = !0;
      }
      function Ke(g, a, f, p) {
        at(g, f, p), Je(g, a, f);
      }
      function At(g, a, f) {
        let p;
        for (p in g[f])
          if (Object.prototype.hasOwnProperty.call(g[f], p) && p !== "data" && !T(g[f][p], a[f][p]))
            return !1;
        for (p in a[f])
          if (Object.prototype.hasOwnProperty.call(a[f], p) && p !== "data" && !T(g[f][p], a[f][p]))
            return !1;
        return !0;
      }
      function mt(g, a, f, p, _, b) {
        let M;
        for (M in a = a || {}, g = g || {})
          Object.prototype.hasOwnProperty.call(g, M) && (T(g[M], a[M]) || f.push({ command: b, args: [p, M, a[M], _] }));
        for (M in a)
          Object.prototype.hasOwnProperty.call(a, M) && !Object.prototype.hasOwnProperty.call(g, M) && (T(g[M], a[M]) || f.push({ command: b, args: [p, M, a[M], _] }));
      }
      function St(g) {
        return g.id;
      }
      function Ut(g, a) {
        return g[a.id] = a, g;
      }
      class Wt {
        constructor(a, f) {
          this.reset(a, f);
        }
        reset(a, f) {
          this.points = a || [], this._distances = [0];
          for (let p = 1; p < this.points.length; p++)
            this._distances[p] = this._distances[p - 1] + this.points[p].dist(this.points[p - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(f || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(a) {
          if (this.points.length === 1)
            return this.points[0];
          a = s.clamp(a, 0, 1);
          let f = 1, p = this._distances[f];
          const _ = a * this.paddedLength + this.padding;
          for (; p < _ && f < this._distances.length; )
            p = this._distances[++f];
          const b = f - 1, M = this._distances[b], P = p - M, O = P > 0 ? (_ - M) / P : 0;
          return this.points[b].mult(1 - O).add(this.points[f].mult(O));
        }
      }
      function Ce(g, a) {
        let f = !0;
        return g === "always" || g !== "never" && a !== "never" || (f = !1), f;
      }
      class We {
        constructor(a, f, p) {
          const _ = this.boxCells = [], b = this.circleCells = [];
          this.xCellCount = Math.ceil(a / p), this.yCellCount = Math.ceil(f / p);
          for (let M = 0; M < this.xCellCount * this.yCellCount; M++)
            _.push([]), b.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = a, this.height = f, this.xScale = this.xCellCount / a, this.yScale = this.yCellCount / f, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(a, f, p, _, b) {
          this._forEachCell(f, p, _, b, this._insertBoxCell, this.boxUid++), this.boxKeys.push(a), this.bboxes.push(f), this.bboxes.push(p), this.bboxes.push(_), this.bboxes.push(b);
        }
        insertCircle(a, f, p, _) {
          this._forEachCell(f - _, p - _, f + _, p + _, this._insertCircleCell, this.circleUid++), this.circleKeys.push(a), this.circles.push(f), this.circles.push(p), this.circles.push(_);
        }
        _insertBoxCell(a, f, p, _, b, M) {
          this.boxCells[b].push(M);
        }
        _insertCircleCell(a, f, p, _, b, M) {
          this.circleCells[b].push(M);
        }
        _query(a, f, p, _, b, M, P) {
          if (p < 0 || a > this.width || _ < 0 || f > this.height)
            return [];
          const O = [];
          if (a <= 0 && f <= 0 && this.width <= p && this.height <= _) {
            if (b)
              return [{ key: null, x1: a, y1: f, x2: p, y2: _ }];
            for (let D = 0; D < this.boxKeys.length; D++)
              O.push({ key: this.boxKeys[D], x1: this.bboxes[4 * D], y1: this.bboxes[4 * D + 1], x2: this.bboxes[4 * D + 2], y2: this.bboxes[4 * D + 3] });
            for (let D = 0; D < this.circleKeys.length; D++) {
              const F = this.circles[3 * D], $ = this.circles[3 * D + 1], G = this.circles[3 * D + 2];
              O.push({ key: this.circleKeys[D], x1: F - G, y1: $ - G, x2: F + G, y2: $ + G });
            }
          } else
            this._forEachCell(a, f, p, _, this._queryCell, O, { hitTest: b, overlapMode: M, seenUids: { box: {}, circle: {} } }, P);
          return O;
        }
        query(a, f, p, _) {
          return this._query(a, f, p, _, !1, null);
        }
        hitTest(a, f, p, _, b, M) {
          return this._query(a, f, p, _, !0, b, M).length > 0;
        }
        hitTestCircle(a, f, p, _, b) {
          const M = a - p, P = a + p, O = f - p, D = f + p;
          if (P < 0 || M > this.width || D < 0 || O > this.height)
            return !1;
          const F = [];
          return this._forEachCell(M, O, P, D, this._queryCellCircle, F, { hitTest: !0, overlapMode: _, circle: { x: a, y: f, radius: p }, seenUids: { box: {}, circle: {} } }, b), F.length > 0;
        }
        _queryCell(a, f, p, _, b, M, P, O) {
          const { seenUids: D, hitTest: F, overlapMode: $ } = P, G = this.boxCells[b];
          if (G !== null) {
            const Q = this.bboxes;
            for (const te of G)
              if (!D.box[te]) {
                D.box[te] = !0;
                const de = 4 * te, be = this.boxKeys[te];
                if (a <= Q[de + 2] && f <= Q[de + 3] && p >= Q[de + 0] && _ >= Q[de + 1] && (!O || O(be)) && (!F || !Ce($, be.overlapMode)) && (M.push({ key: be, x1: Q[de], y1: Q[de + 1], x2: Q[de + 2], y2: Q[de + 3] }), F))
                  return !0;
              }
          }
          const ie = this.circleCells[b];
          if (ie !== null) {
            const Q = this.circles;
            for (const te of ie)
              if (!D.circle[te]) {
                D.circle[te] = !0;
                const de = 3 * te, be = this.circleKeys[te];
                if (this._circleAndRectCollide(Q[de], Q[de + 1], Q[de + 2], a, f, p, _) && (!O || O(be)) && (!F || !Ce($, be.overlapMode))) {
                  const Se = Q[de], oe = Q[de + 1], Le = Q[de + 2];
                  if (M.push({ key: be, x1: Se - Le, y1: oe - Le, x2: Se + Le, y2: oe + Le }), F)
                    return !0;
                }
              }
          }
          return !1;
        }
        _queryCellCircle(a, f, p, _, b, M, P, O) {
          const { circle: D, seenUids: F, overlapMode: $ } = P, G = this.boxCells[b];
          if (G !== null) {
            const Q = this.bboxes;
            for (const te of G)
              if (!F.box[te]) {
                F.box[te] = !0;
                const de = 4 * te, be = this.boxKeys[te];
                if (this._circleAndRectCollide(D.x, D.y, D.radius, Q[de + 0], Q[de + 1], Q[de + 2], Q[de + 3]) && (!O || O(be)) && !Ce($, be.overlapMode))
                  return M.push(!0), !0;
              }
          }
          const ie = this.circleCells[b];
          if (ie !== null) {
            const Q = this.circles;
            for (const te of ie)
              if (!F.circle[te]) {
                F.circle[te] = !0;
                const de = 3 * te, be = this.circleKeys[te];
                if (this._circlesCollide(Q[de], Q[de + 1], Q[de + 2], D.x, D.y, D.radius) && (!O || O(be)) && !Ce($, be.overlapMode))
                  return M.push(!0), !0;
              }
          }
        }
        _forEachCell(a, f, p, _, b, M, P, O) {
          const D = this._convertToXCellCoord(a), F = this._convertToYCellCoord(f), $ = this._convertToXCellCoord(p), G = this._convertToYCellCoord(_);
          for (let ie = D; ie <= $; ie++)
            for (let Q = F; Q <= G; Q++)
              if (b.call(this, a, f, p, _, this.xCellCount * Q + ie, M, P, O))
                return;
        }
        _convertToXCellCoord(a) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(a * this.xScale)));
        }
        _convertToYCellCoord(a) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(a * this.yScale)));
        }
        _circlesCollide(a, f, p, _, b, M) {
          const P = _ - a, O = b - f, D = p + M;
          return D * D > P * P + O * O;
        }
        _circleAndRectCollide(a, f, p, _, b, M, P) {
          const O = (M - _) / 2, D = Math.abs(a - (_ + O));
          if (D > O + p)
            return !1;
          const F = (P - b) / 2, $ = Math.abs(f - (b + F));
          if ($ > F + p)
            return !1;
          if (D <= O || $ <= F)
            return !0;
          const G = D - O, ie = $ - F;
          return G * G + ie * ie <= p * p;
        }
      }
      function br(g, a, f, p, _) {
        const b = s.create();
        return a ? (s.scale(b, b, [1 / _, 1 / _, 1]), f || s.rotateZ(b, b, p.angle)) : s.multiply(b, p.labelPlaneMatrix, g), b;
      }
      function Wr(g, a, f, p, _) {
        if (a) {
          const b = s.clone(g);
          return s.scale(b, b, [_, _, 1]), f || s.rotateZ(b, b, -p.angle), b;
        }
        return p.glCoordMatrix;
      }
      function Xt(g, a, f) {
        let p;
        f ? (p = [g.x, g.y, f(g.x, g.y), 1], s.transformMat4(p, p, a)) : (p = [g.x, g.y, 0, 1], vi(p, p, a));
        const _ = p[3];
        return { point: new s.pointGeometry(p[0] / _, p[1] / _), signedDistanceFromCamera: _ };
      }
      function gn(g, a) {
        return 0.5 + g / a * 0.5;
      }
      function Br(g, a) {
        const f = g[0] / g[3], p = g[1] / g[3];
        return f >= -a[0] && f <= a[0] && p >= -a[1] && p <= a[1];
      }
      function Ir(g, a, f, p, _, b, M, P, O, D) {
        const F = p ? g.textSizeData : g.iconSizeData, $ = s.evaluateSizeForZoom(F, f.transform.zoom), G = [256 / f.width * 2 + 1, 256 / f.height * 2 + 1], ie = p ? g.text.dynamicLayoutVertexArray : g.icon.dynamicLayoutVertexArray;
        ie.clear();
        const Q = g.lineVertexArray, te = p ? g.text.placedSymbolArray : g.icon.placedSymbolArray, de = f.transform.width / f.transform.height;
        let be = !1;
        for (let Se = 0; Se < te.length; Se++) {
          const oe = te.get(Se);
          if (oe.hidden || oe.writingMode === s.WritingMode.vertical && !be) {
            Lt(oe.numGlyphs, ie);
            continue;
          }
          let Le;
          if (be = !1, D ? (Le = [oe.anchorX, oe.anchorY, D(oe.anchorX, oe.anchorY), 1], s.transformMat4(Le, Le, a)) : (Le = [oe.anchorX, oe.anchorY, 0, 1], vi(Le, Le, a)), !Br(Le, G)) {
            Lt(oe.numGlyphs, ie);
            continue;
          }
          const Ie = gn(f.transform.cameraToCenterDistance, Le[3]), Be = s.evaluateSizeForFeature(F, $, oe), Ue = M ? Be / Ie : Be * Ie, Qe = new s.pointGeometry(oe.anchorX, oe.anchorY), Fe = Xt(Qe, _, D).point, bt = {}, ht = Kt(oe, Ue, !1, P, a, _, b, g.glyphOffsetArray, Q, ie, Fe, Qe, bt, de, O, D);
          be = ht.useVertical, (ht.notEnoughRoom || be || ht.needsFlipping && Kt(oe, Ue, !0, P, a, _, b, g.glyphOffsetArray, Q, ie, Fe, Qe, bt, de, O, D).notEnoughRoom) && Lt(oe.numGlyphs, ie);
        }
        p ? g.text.dynamicLayoutVertexBuffer.updateData(ie) : g.icon.dynamicLayoutVertexBuffer.updateData(ie);
      }
      function Yr(g, a, f, p, _, b, M, P, O, D, F, $, G) {
        const ie = P.glyphStartIndex + P.numGlyphs, Q = P.lineStartIndex, te = P.lineStartIndex + P.lineLength, de = a.getoffsetX(P.glyphStartIndex), be = a.getoffsetX(ie - 1), Se = Kn(g * de, f, p, _, b, M, P.segment, Q, te, O, D, F, $, G);
        if (!Se)
          return null;
        const oe = Kn(g * be, f, p, _, b, M, P.segment, Q, te, O, D, F, $, G);
        return oe ? { first: Se, last: oe } : null;
      }
      function nt(g, a, f, p) {
        return g === s.WritingMode.horizontal && Math.abs(f.y - a.y) > Math.abs(f.x - a.x) * p ? { useVertical: !0 } : (g === s.WritingMode.vertical ? a.y < f.y : a.x > f.x) ? { needsFlipping: !0 } : null;
      }
      function Kt(g, a, f, p, _, b, M, P, O, D, F, $, G, ie, Q, te) {
        const de = a / 24, be = g.lineOffsetX * de, Se = g.lineOffsetY * de;
        let oe;
        if (g.numGlyphs > 1) {
          const Le = g.glyphStartIndex + g.numGlyphs, Ie = g.lineStartIndex, Be = g.lineStartIndex + g.lineLength, Ue = Yr(de, P, be, Se, f, F, $, g, O, b, G, Q, te);
          if (!Ue)
            return { notEnoughRoom: !0 };
          const Qe = Xt(Ue.first.point, M, te).point, Fe = Xt(Ue.last.point, M, te).point;
          if (p && !f) {
            const bt = nt(g.writingMode, Qe, Fe, ie);
            if (bt)
              return bt;
          }
          oe = [Ue.first];
          for (let bt = g.glyphStartIndex + 1; bt < Le - 1; bt++)
            oe.push(Kn(de * P.getoffsetX(bt), be, Se, f, F, $, g.segment, Ie, Be, O, b, G, Q, te));
          oe.push(Ue.last);
        } else {
          if (p && !f) {
            const Ie = Xt($, _, te).point, Be = g.lineStartIndex + g.segment + 1, Ue = new s.pointGeometry(O.getx(Be), O.gety(Be)), Qe = Xt(Ue, _, te), Fe = Qe.signedDistanceFromCamera > 0 ? Qe.point : Gt($, Ue, Ie, 1, _, te), bt = nt(g.writingMode, Ie, Fe, ie);
            if (bt)
              return bt;
          }
          const Le = Kn(de * P.getoffsetX(g.glyphStartIndex), be, Se, f, F, $, g.segment, g.lineStartIndex, g.lineStartIndex + g.lineLength, O, b, G, Q, te);
          if (!Le)
            return { notEnoughRoom: !0 };
          oe = [Le];
        }
        for (const Le of oe)
          s.addDynamicAttributes(D, Le.point, Le.angle);
        return {};
      }
      function Gt(g, a, f, p, _, b) {
        const M = Xt(g.add(g.sub(a)._unit()), _, b).point, P = f.sub(M);
        return f.add(P._mult(p / P.mag()));
      }
      function Kn(g, a, f, p, _, b, M, P, O, D, F, $, G, ie) {
        const Q = p ? g - a : g + a;
        let te = Q > 0 ? 1 : -1, de = 0;
        p && (te *= -1, de = Math.PI), te < 0 && (de += Math.PI);
        let be = te > 0 ? P + M : P + M + 1, Se = _, oe = _, Le = 0, Ie = 0;
        const Be = Math.abs(Q), Ue = [];
        for (; Le + Ie <= Be; ) {
          if (be += te, be < P || be >= O)
            return null;
          if (oe = Se, Ue.push(Se), Se = $[be], Se === void 0) {
            const wt = new s.pointGeometry(D.getx(be), D.gety(be)), er = Xt(wt, F, ie);
            if (er.signedDistanceFromCamera > 0)
              Se = $[be] = er.point;
            else {
              const sr = be - te;
              Se = Gt(Le === 0 ? b : new s.pointGeometry(D.getx(sr), D.gety(sr)), wt, oe, Be - Le + 1, F, ie);
            }
          }
          Le += Ie, Ie = oe.dist(Se);
        }
        const Qe = (Be - Le) / Ie, Fe = Se.sub(oe), bt = Fe.mult(Qe)._add(oe);
        bt._add(Fe._unit()._perp()._mult(f * te));
        const ht = de + Math.atan2(Se.y - oe.y, Se.x - oe.x);
        return Ue.push(bt), { point: bt, angle: G ? ht : 0, path: Ue };
      }
      const qo = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function Lt(g, a) {
        for (let f = 0; f < g; f++) {
          const p = a.length;
          a.resize(p + 4), a.float32.set(qo, 3 * p);
        }
      }
      function vi(g, a, f) {
        const p = a[0], _ = a[1];
        return g[0] = f[0] * p + f[4] * _ + f[12], g[1] = f[1] * p + f[5] * _ + f[13], g[3] = f[3] * p + f[7] * _ + f[15], g;
      }
      const Vn = 100;
      class sa {
        constructor(a, f = new We(a.width + 200, a.height + 200, 25), p = new We(a.width + 200, a.height + 200, 25)) {
          this.transform = a, this.grid = f, this.ignoredGrid = p, this.pitchfactor = Math.cos(a._pitch) * a.cameraToCenterDistance, this.screenRightBoundary = a.width + Vn, this.screenBottomBoundary = a.height + Vn, this.gridRightBoundary = a.width + 200, this.gridBottomBoundary = a.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(a, f, p, _, b, M) {
          const P = this.projectAndGetPerspectiveRatio(_, a.anchorPointX, a.anchorPointY, M), O = p * P.perspectiveRatio, D = a.x1 * O + P.point.x, F = a.y1 * O + P.point.y, $ = a.x2 * O + P.point.x, G = a.y2 * O + P.point.y;
          return !this.isInsideGrid(D, F, $, G) || f !== "always" && this.grid.hitTest(D, F, $, G, f, b) || P.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: !1 } : { box: [D, F, $, G], offscreen: this.isOffscreen(D, F, $, G) };
        }
        placeCollisionCircles(a, f, p, _, b, M, P, O, D, F, $, G, ie, Q) {
          const te = [], de = new s.pointGeometry(f.anchorX, f.anchorY), be = Xt(de, M, Q), Se = gn(this.transform.cameraToCenterDistance, be.signedDistanceFromCamera), oe = (F ? b / Se : b * Se) / s.ONE_EM, Le = Xt(de, P, Q).point, Ie = Yr(oe, _, f.lineOffsetX * oe, f.lineOffsetY * oe, !1, Le, de, f, p, P, {}, !1, Q);
          let Be = !1, Ue = !1, Qe = !0;
          if (Ie) {
            const Fe = 0.5 * G * Se + ie, bt = new s.pointGeometry(-100, -100), ht = new s.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), wt = new Wt(), er = Ie.first, sr = Ie.last;
            let zt = [];
            for (let Tr = er.path.length - 1; Tr >= 1; Tr--)
              zt.push(er.path[Tr]);
            for (let Tr = 1; Tr < sr.path.length; Tr++)
              zt.push(sr.path[Tr]);
            const Ur = 2.5 * Fe;
            if (O) {
              const Tr = zt.map((Pr) => Xt(Pr, O, Q));
              zt = Tr.some((Pr) => Pr.signedDistanceFromCamera <= 0) ? [] : Tr.map((Pr) => Pr.point);
            }
            let $r = [];
            if (zt.length > 0) {
              const Tr = zt[0].clone(), Pr = zt[0].clone();
              for (let Gr = 1; Gr < zt.length; Gr++)
                Tr.x = Math.min(Tr.x, zt[Gr].x), Tr.y = Math.min(Tr.y, zt[Gr].y), Pr.x = Math.max(Pr.x, zt[Gr].x), Pr.y = Math.max(Pr.y, zt[Gr].y);
              $r = Tr.x >= bt.x && Pr.x <= ht.x && Tr.y >= bt.y && Pr.y <= ht.y ? [zt] : Pr.x < bt.x || Tr.x > ht.x || Pr.y < bt.y || Tr.y > ht.y ? [] : s.clipLine([zt], bt.x, bt.y, ht.x, ht.y);
            }
            for (const Tr of $r) {
              wt.reset(Tr, 0.25 * Fe);
              let Pr = 0;
              Pr = wt.length <= 0.5 * Fe ? 1 : Math.ceil(wt.paddedLength / Ur) + 1;
              for (let Gr = 0; Gr < Pr; Gr++) {
                const oi = Gr / Math.max(Pr - 1, 1), Zo = wt.lerp(oi), Lo = Zo.x + Vn, Ho = Zo.y + Vn;
                te.push(Lo, Ho, Fe, 0);
                const ja = Lo - Fe, _o = Ho - Fe, Vi = Lo + Fe, ha = Ho + Fe;
                if (Qe = Qe && this.isOffscreen(ja, _o, Vi, ha), Ue = Ue || this.isInsideGrid(ja, _o, Vi, ha), a !== "always" && this.grid.hitTestCircle(Lo, Ho, Fe, a, $) && (Be = !0, !D))
                  return { circles: [], offscreen: !1, collisionDetected: Be };
              }
            }
          }
          return { circles: !D && Be || !Ue || Se < this.perspectiveRatioCutoff ? [] : te, offscreen: Qe, collisionDetected: Be };
        }
        queryRenderedSymbols(a) {
          if (a.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
            return {};
          const f = [];
          let p = 1 / 0, _ = 1 / 0, b = -1 / 0, M = -1 / 0;
          for (const F of a) {
            const $ = new s.pointGeometry(F.x + Vn, F.y + Vn);
            p = Math.min(p, $.x), _ = Math.min(_, $.y), b = Math.max(b, $.x), M = Math.max(M, $.y), f.push($);
          }
          const P = this.grid.query(p, _, b, M).concat(this.ignoredGrid.query(p, _, b, M)), O = {}, D = {};
          for (const F of P) {
            const $ = F.key;
            if (O[$.bucketInstanceId] === void 0 && (O[$.bucketInstanceId] = {}), O[$.bucketInstanceId][$.featureIndex])
              continue;
            const G = [new s.pointGeometry(F.x1, F.y1), new s.pointGeometry(F.x2, F.y1), new s.pointGeometry(F.x2, F.y2), new s.pointGeometry(F.x1, F.y2)];
            s.polygonIntersectsPolygon(f, G) && (O[$.bucketInstanceId][$.featureIndex] = !0, D[$.bucketInstanceId] === void 0 && (D[$.bucketInstanceId] = []), D[$.bucketInstanceId].push($.featureIndex));
          }
          return D;
        }
        insertCollisionBox(a, f, p, _, b, M) {
          (p ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: _, featureIndex: b, collisionGroupID: M, overlapMode: f }, a[0], a[1], a[2], a[3]);
        }
        insertCollisionCircles(a, f, p, _, b, M) {
          const P = p ? this.ignoredGrid : this.grid, O = { bucketInstanceId: _, featureIndex: b, collisionGroupID: M, overlapMode: f };
          for (let D = 0; D < a.length; D += 4)
            P.insertCircle(O, a[D], a[D + 1], a[D + 2]);
        }
        projectAndGetPerspectiveRatio(a, f, p, _) {
          let b;
          return _ ? (b = [f, p, _(f, p), 1], s.transformMat4(b, b, a)) : (b = [f, p, 0, 1], vi(b, b, a)), { point: new s.pointGeometry((b[0] / b[3] + 1) / 2 * this.transform.width + Vn, (-b[1] / b[3] + 1) / 2 * this.transform.height + Vn), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / b[3] * 0.5 };
        }
        isOffscreen(a, f, p, _) {
          return p < Vn || a >= this.screenRightBoundary || _ < Vn || f > this.screenBottomBoundary;
        }
        isInsideGrid(a, f, p, _) {
          return p >= 0 && a < this.gridRightBoundary && _ >= 0 && f < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const a = s.identity([]);
          return s.translate(a, a, [-100, -100, 0]), a;
        }
      }
      function Tn(g, a, f) {
        return a * (s.EXTENT / (g.tileSize * Math.pow(2, f - g.tileID.overscaledZ)));
      }
      class ni {
        constructor(a, f, p, _) {
          this.opacity = a ? Math.max(0, Math.min(1, a.opacity + (a.placed ? f : -f))) : _ && p ? 1 : 0, this.placed = p;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Rr {
        constructor(a, f, p, _, b) {
          this.text = new ni(a ? a.text : null, f, p, b), this.icon = new ni(a ? a.icon : null, f, _, b);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class Na {
        constructor(a, f, p) {
          this.text = a, this.icon = f, this.skipFade = p;
        }
      }
      class Ri {
        constructor() {
          this.invProjMatrix = s.create(), this.viewportMatrix = s.create(), this.circles = [];
        }
      }
      class Ao {
        constructor(a, f, p, _, b) {
          this.bucketInstanceId = a, this.featureIndex = f, this.sourceLayerIndex = p, this.bucketIndex = _, this.tileID = b;
        }
      }
      class la {
        constructor(a) {
          this.crossSourceCollisions = a, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(a) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[a]) {
            const f = ++this.maxGroupID;
            this.collisionGroups[a] = { ID: f, predicate: (p) => p.collisionGroupID === f };
          }
          return this.collisionGroups[a];
        }
      }
      function xi(g, a, f, p, _) {
        const { horizontalAlign: b, verticalAlign: M } = s.getAnchorAlignment(g), P = -(b - 0.5) * a, O = -(M - 0.5) * f, D = s.evaluateVariableOffset(g, p);
        return new s.pointGeometry(P + D[0] * _, O + D[1] * _);
      }
      function Oo(g, a, f, p, _, b) {
        const { x1: M, x2: P, y1: O, y2: D, anchorPointX: F, anchorPointY: $ } = g, G = new s.pointGeometry(a, f);
        return p && G._rotate(_ ? b : -b), { x1: M + G.x, y1: O + G.y, x2: P + G.x, y2: D + G.y, anchorPointX: F, anchorPointY: $ };
      }
      class Y {
        constructor(a, f, p, _, b) {
          this.transform = a.clone(), this.terrain = f, this.collisionIndex = new sa(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = p, this.retainedQueryData = {}, this.collisionGroups = new la(_), this.collisionCircleArrays = {}, this.prevPlacement = b, b && (b.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(a, f, p, _) {
          const b = p.getBucket(f), M = p.latestFeatureIndex;
          if (!b || !M || f.id !== b.layerIds[0])
            return;
          const P = p.collisionBoxArray, O = b.layers[0].layout, D = Math.pow(2, this.transform.zoom - p.tileID.overscaledZ), F = p.tileSize / s.EXTENT, $ = this.transform.calculatePosMatrix(p.tileID.toUnwrapped()), G = O.get("text-pitch-alignment") === "map", ie = O.get("text-rotation-alignment") === "map", Q = Tn(p, 1, this.transform.zoom), te = br($, G, ie, this.transform, Q);
          let de = null;
          if (G) {
            const Se = Wr($, G, ie, this.transform, Q);
            de = s.multiply([], this.transform.labelPlaneMatrix, Se);
          }
          this.retainedQueryData[b.bucketInstanceId] = new Ao(b.bucketInstanceId, M, b.sourceLayerIndex, b.index, p.tileID);
          const be = { bucket: b, layout: O, posMatrix: $, textLabelPlaneMatrix: te, labelToScreenMatrix: de, scale: D, textPixelRatio: F, holdingForFade: p.holdingForFade(), collisionBoxArray: P, partiallyEvaluatedTextSize: s.evaluateSizeForZoom(b.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(b.sourceID) };
          if (_)
            for (const Se of b.sortKeyRanges) {
              const { sortKey: oe, symbolInstanceStart: Le, symbolInstanceEnd: Ie } = Se;
              a.push({ sortKey: oe, symbolInstanceStart: Le, symbolInstanceEnd: Ie, parameters: be });
            }
          else
            a.push({ symbolInstanceStart: 0, symbolInstanceEnd: b.symbolInstances.length, parameters: be });
        }
        attemptAnchorPlacement(a, f, p, _, b, M, P, O, D, F, $, G, ie, Q, te, de) {
          const be = [G.textOffset0, G.textOffset1], Se = xi(a, p, _, be, b), oe = this.collisionIndex.placeCollisionBox(Oo(f, Se.x, Se.y, M, P, this.transform.angle), $, O, D, F.predicate, de);
          if ((!te || this.collisionIndex.placeCollisionBox(Oo(te, Se.x, Se.y, M, P, this.transform.angle), $, O, D, F.predicate, de).box.length !== 0) && oe.box.length > 0) {
            let Le;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[G.crossTileID] && this.prevPlacement.placements[G.crossTileID] && this.prevPlacement.placements[G.crossTileID].text && (Le = this.prevPlacement.variableOffsets[G.crossTileID].anchor), G.crossTileID === 0)
              throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[G.crossTileID] = { textOffset: be, width: p, height: _, anchor: a, textBoxScale: b, prevAnchor: Le }, this.markUsedJustification(ie, a, G, Q), ie.allowVerticalPlacement && (this.markUsedOrientation(ie, Q, G), this.placedOrientations[G.crossTileID] = Q), { shift: Se, placedGlyphBoxes: oe };
          }
        }
        placeLayerBucketPart(a, f, p) {
          const { bucket: _, layout: b, posMatrix: M, textLabelPlaneMatrix: P, labelToScreenMatrix: O, textPixelRatio: D, holdingForFade: F, collisionBoxArray: $, partiallyEvaluatedTextSize: G, collisionGroup: ie } = a.parameters, Q = b.get("text-optional"), te = b.get("icon-optional"), de = s.getOverlapMode(b, "text-overlap", "text-allow-overlap"), be = de === "always", Se = s.getOverlapMode(b, "icon-overlap", "icon-allow-overlap"), oe = Se === "always", Le = b.get("text-rotation-alignment") === "map", Ie = b.get("text-pitch-alignment") === "map", Be = b.get("icon-text-fit") !== "none", Ue = b.get("symbol-z-order") === "viewport-y", Qe = be && (oe || !_.hasIconData() || te), Fe = oe && (be || !_.hasTextData() || Q);
          !_.collisionArrays && $ && _.deserializeCollisionBoxes($);
          const bt = (ht, wt) => {
            if (f[ht.crossTileID])
              return;
            if (F)
              return void (this.placements[ht.crossTileID] = new Na(!1, !1, !1));
            let er = !1, sr = !1, zt = !0, Ur = null, $r = { box: null, offscreen: null }, Tr = { box: null, offscreen: null }, Pr = null, Gr = null, oi = null, Zo = 0, Lo = 0, Ho = 0;
            wt.textFeatureIndex ? Zo = wt.textFeatureIndex : ht.useRuntimeCollisionCircles && (Zo = ht.featureIndex), wt.verticalTextFeatureIndex && (Lo = wt.verticalTextFeatureIndex);
            const ja = this.retainedQueryData[_.bucketInstanceId].tileID, _o = this.terrain ? (Yn, hr) => this.terrain.getElevation(ja, Yn, hr) : null;
            for (const Yn of ["textBox", "verticalTextBox", "iconBox", "verticalIconBox"]) {
              const hr = wt[Yn];
              hr && (hr.elevation = _o ? _o(hr.anchorPointX, hr.anchorPointY) : 0);
            }
            const Vi = wt.textBox;
            if (Vi) {
              const Yn = (Nr) => {
                let ai = s.WritingMode.horizontal;
                if (_.allowVerticalPlacement && !Nr && this.prevPlacement) {
                  const si = this.prevPlacement.placedOrientations[ht.crossTileID];
                  si && (this.placedOrientations[ht.crossTileID] = si, ai = si, this.markUsedOrientation(_, ai, ht));
                }
                return ai;
              }, hr = (Nr, ai) => {
                if (_.allowVerticalPlacement && ht.numVerticalGlyphVertices > 0 && wt.verticalTextBox) {
                  for (const si of _.writingModes)
                    if (si === s.WritingMode.vertical ? ($r = ai(), Tr = $r) : $r = Nr(), $r && $r.box && $r.box.length)
                      break;
                } else
                  $r = Nr();
              };
              if (b.get("text-variable-anchor")) {
                let Nr = b.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[ht.crossTileID]) {
                  const bn = this.prevPlacement.variableOffsets[ht.crossTileID];
                  Nr.indexOf(bn.anchor) > 0 && (Nr = Nr.filter((vo) => vo !== bn.anchor), Nr.unshift(bn.anchor));
                }
                const ai = (bn, vo, vs) => {
                  const Cf = bn.x2 - bn.x1, ll = bn.y2 - bn.y1, Kp = ht.textBoxScale, If = Be && Se === "never" ? vo : null;
                  let Ga = { box: [], offscreen: !1 };
                  const xs = de !== "never" ? 2 * Nr.length : Nr.length;
                  for (let bs = 0; bs < xs; ++bs) {
                    const zu = this.attemptAnchorPlacement(Nr[bs % Nr.length], bn, Cf, ll, Kp, Le, Ie, D, M, ie, bs >= Nr.length ? de : "never", ht, _, vs, If, _o);
                    if (zu && (Ga = zu.placedGlyphBoxes, Ga && Ga.box && Ga.box.length)) {
                      er = !0, Ur = zu.shift;
                      break;
                    }
                  }
                  return Ga;
                };
                hr(() => ai(Vi, wt.iconBox, s.WritingMode.horizontal), () => {
                  const bn = wt.verticalTextBox;
                  return _.allowVerticalPlacement && !($r && $r.box && $r.box.length) && ht.numVerticalGlyphVertices > 0 && bn ? ai(bn, wt.verticalIconBox, s.WritingMode.vertical) : { box: null, offscreen: null };
                }), $r && (er = $r.box, zt = $r.offscreen);
                const si = Yn($r && $r.box);
                if (!er && this.prevPlacement) {
                  const bn = this.prevPlacement.variableOffsets[ht.crossTileID];
                  bn && (this.variableOffsets[ht.crossTileID] = bn, this.markUsedJustification(_, bn.anchor, ht, si));
                }
              } else {
                const Nr = (ai, si) => {
                  const bn = this.collisionIndex.placeCollisionBox(ai, de, D, M, ie.predicate, _o);
                  return bn && bn.box && bn.box.length && (this.markUsedOrientation(_, si, ht), this.placedOrientations[ht.crossTileID] = si), bn;
                };
                hr(() => Nr(Vi, s.WritingMode.horizontal), () => {
                  const ai = wt.verticalTextBox;
                  return _.allowVerticalPlacement && ht.numVerticalGlyphVertices > 0 && ai ? Nr(ai, s.WritingMode.vertical) : { box: null, offscreen: null };
                }), Yn($r && $r.box && $r.box.length);
              }
            }
            if (Pr = $r, er = Pr && Pr.box && Pr.box.length > 0, zt = Pr && Pr.offscreen, ht.useRuntimeCollisionCircles) {
              const Yn = _.text.placedSymbolArray.get(ht.centerJustifiedTextSymbolIndex), hr = s.evaluateSizeForFeature(_.textSizeData, G, Yn), Nr = b.get("text-padding");
              Gr = this.collisionIndex.placeCollisionCircles(de, Yn, _.lineVertexArray, _.glyphOffsetArray, hr, M, P, O, p, Ie, ie.predicate, ht.collisionCircleDiameter, Nr, _o), Gr.circles.length && Gr.collisionDetected && !p && s.warnOnce("Collisions detected, but collision boxes are not shown"), er = be || Gr.circles.length > 0 && !Gr.collisionDetected, zt = zt && Gr.offscreen;
            }
            if (wt.iconFeatureIndex && (Ho = wt.iconFeatureIndex), wt.iconBox) {
              const Yn = (hr) => {
                const Nr = Be && Ur ? Oo(hr, Ur.x, Ur.y, Le, Ie, this.transform.angle) : hr;
                return this.collisionIndex.placeCollisionBox(Nr, Se, D, M, ie.predicate, _o);
              };
              Tr && Tr.box && Tr.box.length && wt.verticalIconBox ? (oi = Yn(wt.verticalIconBox), sr = oi.box.length > 0) : (oi = Yn(wt.iconBox), sr = oi.box.length > 0), zt = zt && oi.offscreen;
            }
            const ha = Q || ht.numHorizontalGlyphVertices === 0 && ht.numVerticalGlyphVertices === 0, Fu = te || ht.numIconVertices === 0;
            if (ha || Fu ? Fu ? ha || (sr = sr && er) : er = sr && er : sr = er = sr && er, er && Pr && Pr.box && this.collisionIndex.insertCollisionBox(Pr.box, de, b.get("text-ignore-placement"), _.bucketInstanceId, Tr && Tr.box && Lo ? Lo : Zo, ie.ID), sr && oi && this.collisionIndex.insertCollisionBox(oi.box, Se, b.get("icon-ignore-placement"), _.bucketInstanceId, Ho, ie.ID), Gr && (er && this.collisionIndex.insertCollisionCircles(Gr.circles, de, b.get("text-ignore-placement"), _.bucketInstanceId, Zo, ie.ID), p)) {
              const Yn = _.bucketInstanceId;
              let hr = this.collisionCircleArrays[Yn];
              hr === void 0 && (hr = this.collisionCircleArrays[Yn] = new Ri());
              for (let Nr = 0; Nr < Gr.circles.length; Nr += 4)
                hr.circles.push(Gr.circles[Nr + 0]), hr.circles.push(Gr.circles[Nr + 1]), hr.circles.push(Gr.circles[Nr + 2]), hr.circles.push(Gr.collisionDetected ? 1 : 0);
            }
            if (ht.crossTileID === 0)
              throw new Error("symbolInstance.crossTileID can't be 0");
            if (_.bucketInstanceId === 0)
              throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[ht.crossTileID] = new Na(er || Qe, sr || Fe, zt || _.justReloaded), f[ht.crossTileID] = !0;
          };
          if (Ue) {
            if (a.symbolInstanceStart !== 0)
              throw new Error("bucket.bucketInstanceId should be 0");
            const ht = _.getSortedSymbolIndexes(this.transform.angle);
            for (let wt = ht.length - 1; wt >= 0; --wt) {
              const er = ht[wt];
              bt(_.symbolInstances.get(er), _.collisionArrays[er]);
            }
          } else
            for (let ht = a.symbolInstanceStart; ht < a.symbolInstanceEnd; ht++)
              bt(_.symbolInstances.get(ht), _.collisionArrays[ht]);
          if (p && _.bucketInstanceId in this.collisionCircleArrays) {
            const ht = this.collisionCircleArrays[_.bucketInstanceId];
            s.invert(ht.invProjMatrix, M), ht.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          _.justReloaded = !1;
        }
        markUsedJustification(a, f, p, _) {
          let b;
          b = _ === s.WritingMode.vertical ? p.verticalPlacedTextSymbolIndex : { left: p.leftJustifiedTextSymbolIndex, center: p.centerJustifiedTextSymbolIndex, right: p.rightJustifiedTextSymbolIndex }[s.getAnchorJustification(f)];
          const M = [p.leftJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.rightJustifiedTextSymbolIndex, p.verticalPlacedTextSymbolIndex];
          for (const P of M)
            P >= 0 && (a.text.placedSymbolArray.get(P).crossTileID = b >= 0 && P !== b ? 0 : p.crossTileID);
        }
        markUsedOrientation(a, f, p) {
          const _ = f === s.WritingMode.horizontal || f === s.WritingMode.horizontalOnly ? f : 0, b = f === s.WritingMode.vertical ? f : 0, M = [p.leftJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.rightJustifiedTextSymbolIndex];
          for (const P of M)
            a.text.placedSymbolArray.get(P).placedOrientation = _;
          p.verticalPlacedTextSymbolIndex && (a.text.placedSymbolArray.get(p.verticalPlacedTextSymbolIndex).placedOrientation = b);
        }
        commit(a) {
          this.commitTime = a, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const f = this.prevPlacement;
          let p = !1;
          this.prevZoomAdjustment = f ? f.zoomAdjustment(this.transform.zoom) : 0;
          const _ = f ? f.symbolFadeChange(a) : 1, b = f ? f.opacities : {}, M = f ? f.variableOffsets : {}, P = f ? f.placedOrientations : {};
          for (const O in this.placements) {
            const D = this.placements[O], F = b[O];
            F ? (this.opacities[O] = new Rr(F, _, D.text, D.icon), p = p || D.text !== F.text.placed || D.icon !== F.icon.placed) : (this.opacities[O] = new Rr(null, _, D.text, D.icon, D.skipFade), p = p || D.text || D.icon);
          }
          for (const O in b) {
            const D = b[O];
            if (!this.opacities[O]) {
              const F = new Rr(D, _, !1, !1);
              F.isHidden() || (this.opacities[O] = F, p = p || D.text.placed || D.icon.placed);
            }
          }
          for (const O in M)
            this.variableOffsets[O] || !this.opacities[O] || this.opacities[O].isHidden() || (this.variableOffsets[O] = M[O]);
          for (const O in P)
            this.placedOrientations[O] || !this.opacities[O] || this.opacities[O].isHidden() || (this.placedOrientations[O] = P[O]);
          if (f && f.lastPlacementChangeTime === void 0)
            throw new Error("Last placement time for previous placement is not defined");
          p ? this.lastPlacementChangeTime = a : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = f ? f.lastPlacementChangeTime : a);
        }
        updateLayerOpacities(a, f) {
          const p = {};
          for (const _ of f) {
            const b = _.getBucket(a);
            b && _.latestFeatureIndex && a.id === b.layerIds[0] && this.updateBucketOpacities(b, p, _.collisionBoxArray);
          }
        }
        updateBucketOpacities(a, f, p) {
          a.hasTextData() && a.text.opacityVertexArray.clear(), a.hasIconData() && a.icon.opacityVertexArray.clear(), a.hasIconCollisionBoxData() && a.iconCollisionBox.collisionVertexArray.clear(), a.hasTextCollisionBoxData() && a.textCollisionBox.collisionVertexArray.clear();
          const _ = a.layers[0].layout, b = new Rr(null, 0, !1, !1, !0), M = _.get("text-allow-overlap"), P = _.get("icon-allow-overlap"), O = _.get("text-variable-anchor"), D = _.get("text-rotation-alignment") === "map", F = _.get("text-pitch-alignment") === "map", $ = _.get("icon-text-fit") !== "none", G = new Rr(null, 0, M && (P || !a.hasIconData() || _.get("icon-optional")), P && (M || !a.hasTextData() || _.get("text-optional")), !0);
          !a.collisionArrays && p && (a.hasIconCollisionBoxData() || a.hasTextCollisionBoxData()) && a.deserializeCollisionBoxes(p);
          const ie = (Q, te, de) => {
            for (let be = 0; be < te / 4; be++)
              Q.opacityVertexArray.emplaceBack(de);
          };
          for (let Q = 0; Q < a.symbolInstances.length; Q++) {
            const te = a.symbolInstances.get(Q), { numHorizontalGlyphVertices: de, numVerticalGlyphVertices: be, crossTileID: Se } = te;
            let oe = this.opacities[Se];
            f[Se] ? oe = b : oe || (oe = G, this.opacities[Se] = oe), f[Se] = !0;
            const Le = te.numIconVertices > 0, Ie = this.placedOrientations[te.crossTileID], Be = Ie === s.WritingMode.vertical, Ue = Ie === s.WritingMode.horizontal || Ie === s.WritingMode.horizontalOnly;
            if (de > 0 || be > 0) {
              const Qe = ge(oe.text);
              ie(a.text, de, Be ? ye : Qe), ie(a.text, be, Ue ? ye : Qe);
              const Fe = oe.text.isHidden();
              [te.rightJustifiedTextSymbolIndex, te.centerJustifiedTextSymbolIndex, te.leftJustifiedTextSymbolIndex].forEach((wt) => {
                wt >= 0 && (a.text.placedSymbolArray.get(wt).hidden = Fe || Be ? 1 : 0);
              }), te.verticalPlacedTextSymbolIndex >= 0 && (a.text.placedSymbolArray.get(te.verticalPlacedTextSymbolIndex).hidden = Fe || Ue ? 1 : 0);
              const bt = this.variableOffsets[te.crossTileID];
              bt && this.markUsedJustification(a, bt.anchor, te, Ie);
              const ht = this.placedOrientations[te.crossTileID];
              ht && (this.markUsedJustification(a, "left", te, ht), this.markUsedOrientation(a, ht, te));
            }
            if (Le) {
              const Qe = ge(oe.icon), Fe = !($ && te.verticalPlacedIconSymbolIndex && Be);
              te.placedIconSymbolIndex >= 0 && (ie(a.icon, te.numIconVertices, Fe ? Qe : ye), a.icon.placedSymbolArray.get(te.placedIconSymbolIndex).hidden = oe.icon.isHidden()), te.verticalPlacedIconSymbolIndex >= 0 && (ie(a.icon, te.numVerticalIconVertices, Fe ? ye : Qe), a.icon.placedSymbolArray.get(te.verticalPlacedIconSymbolIndex).hidden = oe.icon.isHidden());
            }
            if (a.hasIconCollisionBoxData() || a.hasTextCollisionBoxData()) {
              const Qe = a.collisionArrays[Q];
              if (Qe) {
                let Fe = new s.pointGeometry(0, 0);
                if (Qe.textBox || Qe.verticalTextBox) {
                  let ht = !0;
                  if (O) {
                    const wt = this.variableOffsets[Se];
                    wt ? (Fe = xi(wt.anchor, wt.width, wt.height, wt.textOffset, wt.textBoxScale), D && Fe._rotate(F ? this.transform.angle : -this.transform.angle)) : ht = !1;
                  }
                  Qe.textBox && k(a.textCollisionBox.collisionVertexArray, oe.text.placed, !ht || Be, Fe.x, Fe.y), Qe.verticalTextBox && k(a.textCollisionBox.collisionVertexArray, oe.text.placed, !ht || Ue, Fe.x, Fe.y);
                }
                const bt = Boolean(!Ue && Qe.verticalIconBox);
                Qe.iconBox && k(a.iconCollisionBox.collisionVertexArray, oe.icon.placed, bt, $ ? Fe.x : 0, $ ? Fe.y : 0), Qe.verticalIconBox && k(a.iconCollisionBox.collisionVertexArray, oe.icon.placed, !bt, $ ? Fe.x : 0, $ ? Fe.y : 0);
              }
            }
          }
          if (a.sortFeatures(this.transform.angle), this.retainedQueryData[a.bucketInstanceId] && (this.retainedQueryData[a.bucketInstanceId].featureSortOrder = a.featureSortOrder), a.hasTextData() && a.text.opacityVertexBuffer && a.text.opacityVertexBuffer.updateData(a.text.opacityVertexArray), a.hasIconData() && a.icon.opacityVertexBuffer && a.icon.opacityVertexBuffer.updateData(a.icon.opacityVertexArray), a.hasIconCollisionBoxData() && a.iconCollisionBox.collisionVertexBuffer && a.iconCollisionBox.collisionVertexBuffer.updateData(a.iconCollisionBox.collisionVertexArray), a.hasTextCollisionBoxData() && a.textCollisionBox.collisionVertexBuffer && a.textCollisionBox.collisionVertexBuffer.updateData(a.textCollisionBox.collisionVertexArray), a.text.opacityVertexArray.length !== a.text.layoutVertexArray.length / 4)
            throw new Error(`bucket.text.opacityVertexArray.length (= ${a.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${a.text.layoutVertexArray.length}) / 4`);
          if (a.icon.opacityVertexArray.length !== a.icon.layoutVertexArray.length / 4)
            throw new Error(`bucket.icon.opacityVertexArray.length (= ${a.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${a.icon.layoutVertexArray.length}) / 4`);
          if (a.bucketInstanceId in this.collisionCircleArrays) {
            const Q = this.collisionCircleArrays[a.bucketInstanceId];
            a.placementInvProjMatrix = Q.invProjMatrix, a.placementViewportMatrix = Q.viewportMatrix, a.collisionCircleArray = Q.circles, delete this.collisionCircleArrays[a.bucketInstanceId];
          }
        }
        symbolFadeChange(a) {
          return this.fadeDuration === 0 ? 1 : (a - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(a) {
          return Math.max(0, (this.transform.zoom - a) / 1.5);
        }
        hasTransitions(a) {
          return this.stale || a - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(a, f) {
          const p = this.zoomAtLastRecencyCheck === f ? 1 - this.zoomAdjustment(f) : 1;
          return this.zoomAtLastRecencyCheck = f, this.commitTime + this.fadeDuration * p > a;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function k(g, a, f, p, _) {
        g.emplaceBack(a ? 1 : 0, f ? 1 : 0, p || 0, _ || 0), g.emplaceBack(a ? 1 : 0, f ? 1 : 0, p || 0, _ || 0), g.emplaceBack(a ? 1 : 0, f ? 1 : 0, p || 0, _ || 0), g.emplaceBack(a ? 1 : 0, f ? 1 : 0, p || 0, _ || 0);
      }
      const U = Math.pow(2, 25), Z = Math.pow(2, 24), K = Math.pow(2, 17), le = Math.pow(2, 16), me = Math.pow(2, 9), fe = Math.pow(2, 8), ce = Math.pow(2, 1);
      function ge(g) {
        if (g.opacity === 0 && !g.placed)
          return 0;
        if (g.opacity === 1 && g.placed)
          return 4294967295;
        const a = g.placed ? 1 : 0, f = Math.floor(127 * g.opacity);
        return f * U + a * Z + f * K + a * le + f * me + a * fe + f * ce + a;
      }
      const ye = 0;
      class J {
        constructor(a) {
          this._sortAcrossTiles = a.layout.get("symbol-z-order") !== "viewport-y" && !a.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(a, f, p, _, b) {
          const M = this._bucketParts;
          for (; this._currentTileIndex < a.length; )
            if (f.getBucketParts(M, _, a[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, b())
              return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, M.sort((P, O) => P.sortKey - O.sortKey)); this._currentPartIndex < M.length; )
            if (f.placeLayerBucketPart(M[this._currentPartIndex], this._seenCrossTileIDs, p), this._currentPartIndex++, b())
              return !0;
          return !1;
        }
      }
      class ue {
        constructor(a, f, p, _, b, M, P, O) {
          this.placement = new Y(a, f, M, P, O), this._currentPlacementIndex = p.length - 1, this._forceFullPlacement = _, this._showCollisionBoxes = b, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(a, f, p) {
          const _ = s.exported.now(), b = () => {
            const M = s.exported.now() - _;
            return !this._forceFullPlacement && M > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const M = f[a[this._currentPlacementIndex]], P = this.placement.collisionIndex.transform.zoom;
            if (M.type === "symbol" && (!M.minzoom || M.minzoom <= P) && (!M.maxzoom || M.maxzoom > P)) {
              if (this._inProgressLayer || (this._inProgressLayer = new J(M)), this._inProgressLayer.continuePlacement(p[M.source], this.placement, this._showCollisionBoxes, M, b))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(a) {
          return this.placement.commit(a), this.placement;
        }
      }
      const Ne = 512 / s.EXTENT / 2;
      class ot {
        constructor(a, f, p) {
          this.tileID = a, this.indexedSymbolInstances = {}, this.bucketInstanceId = p;
          for (let _ = 0; _ < f.length; _++) {
            const b = f.get(_), M = b.key;
            this.indexedSymbolInstances[M] || (this.indexedSymbolInstances[M] = []), this.indexedSymbolInstances[M].push({ crossTileID: b.crossTileID, coord: this.getScaledCoordinates(b, a) });
          }
        }
        getScaledCoordinates(a, f) {
          const p = Ne / Math.pow(2, f.canonical.z - this.tileID.canonical.z);
          return { x: Math.floor((f.canonical.x * s.EXTENT + a.anchorX) * p), y: Math.floor((f.canonical.y * s.EXTENT + a.anchorY) * p) };
        }
        findMatches(a, f, p) {
          const _ = this.tileID.canonical.z < f.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - f.canonical.z);
          for (let b = 0; b < a.length; b++) {
            const M = a.get(b);
            if (M.crossTileID)
              continue;
            const P = this.indexedSymbolInstances[M.key];
            if (!P)
              continue;
            const O = this.getScaledCoordinates(M, f);
            for (const D of P)
              if (Math.abs(D.coord.x - O.x) <= _ && Math.abs(D.coord.y - O.y) <= _ && !p[D.crossTileID]) {
                p[D.crossTileID] = !0, M.crossTileID = D.crossTileID;
                break;
              }
          }
        }
      }
      class lt {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Mt {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(a) {
          const f = Math.round((a - this.lng) / 360);
          if (f !== 0)
            for (const p in this.indexes) {
              const _ = this.indexes[p], b = {};
              for (const M in _) {
                const P = _[M];
                P.tileID = P.tileID.unwrapTo(P.tileID.wrap + f), b[P.tileID.key] = P;
              }
              this.indexes[p] = b;
            }
          this.lng = a;
        }
        addBucket(a, f, p) {
          if (this.indexes[a.overscaledZ] && this.indexes[a.overscaledZ][a.key]) {
            if (this.indexes[a.overscaledZ][a.key].bucketInstanceId === f.bucketInstanceId)
              return !1;
            this.removeBucketCrossTileIDs(a.overscaledZ, this.indexes[a.overscaledZ][a.key]);
          }
          for (let b = 0; b < f.symbolInstances.length; b++)
            f.symbolInstances.get(b).crossTileID = 0;
          this.usedCrossTileIDs[a.overscaledZ] || (this.usedCrossTileIDs[a.overscaledZ] = {});
          const _ = this.usedCrossTileIDs[a.overscaledZ];
          for (const b in this.indexes) {
            const M = this.indexes[b];
            if (Number(b) > a.overscaledZ)
              for (const P in M) {
                const O = M[P];
                O.tileID.isChildOf(a) && O.findMatches(f.symbolInstances, a, _);
              }
            else {
              const P = M[a.scaledTo(Number(b)).key];
              P && P.findMatches(f.symbolInstances, a, _);
            }
          }
          for (let b = 0; b < f.symbolInstances.length; b++) {
            const M = f.symbolInstances.get(b);
            M.crossTileID || (M.crossTileID = p.generate(), _[M.crossTileID] = !0);
          }
          return this.indexes[a.overscaledZ] === void 0 && (this.indexes[a.overscaledZ] = {}), this.indexes[a.overscaledZ][a.key] = new ot(a, f.symbolInstances, f.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(a, f) {
          for (const p in f.indexedSymbolInstances)
            for (const _ of f.indexedSymbolInstances[p])
              delete this.usedCrossTileIDs[a][_.crossTileID];
        }
        removeStaleBuckets(a) {
          let f = !1;
          for (const p in this.indexes) {
            const _ = this.indexes[p];
            for (const b in _)
              a[_[b].bucketInstanceId] || (this.removeBucketCrossTileIDs(p, _[b]), delete _[b], f = !0);
          }
          return f;
        }
      }
      class Pt {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new lt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(a, f, p) {
          let _ = this.layerIndexes[a.id];
          _ === void 0 && (_ = this.layerIndexes[a.id] = new Mt());
          let b = !1;
          const M = {};
          _.handleWrapJump(p);
          for (const P of f) {
            const O = P.getBucket(a);
            O && a.id === O.layerIds[0] && (O.bucketInstanceId || (O.bucketInstanceId = ++this.maxBucketInstanceId), _.addBucket(P.tileID, O, this.crossTileIDs) && (b = !0), M[O.bucketInstanceId] = !0);
          }
          return _.removeStaleBuckets(M) && (b = !0), b;
        }
        pruneUnusedLayers(a) {
          const f = {};
          a.forEach((p) => {
            f[p] = !0;
          });
          for (const p in this.layerIndexes)
            f[p] || delete this.layerIndexes[p];
        }
      }
      var ur = s.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]);
      class Rt extends s.Evented {
        constructor(a) {
          super(), this.sourceCache = a, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.renderHistory = [], this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, this.renderHistorySize = a._cache.max, a.usedForTerrain = !0, a.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
          for (const a in this._tiles) {
            const f = this._tiles[a];
            f.textures.forEach((p) => p.destroy()), f.textures = [];
          }
        }
        update(a, f) {
          this.sourceCache.update(a, f), this._renderableTilesKeys = [];
          for (const p of a.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: f }))
            this._renderableTilesKeys.push(p.key), this._tiles[p.key] || (p.posMatrix = new Float64Array(16), s.ortho(p.posMatrix, 0, s.EXTENT, 0, s.EXTENT, 0, 1), this._tiles[p.key] = new Ht(p, this.tileSize));
        }
        removeOutdated(a) {
          const f = {};
          this.renderHistory = this.renderHistory.filter((p, _) => this.renderHistory.indexOf(p) === _).slice(0, this.renderHistorySize);
          for (const p of this._renderableTilesKeys)
            f[p] = !0;
          for (const p of this.renderHistory)
            f[p] = !0;
          for (const p in this._tiles)
            f[p] || (this._tiles[p].clearTextures(a), delete this._tiles[p]);
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((a) => this.getTileByID(a));
        }
        getTileByID(a) {
          return this._tiles[a];
        }
        getTerrainCoords(a) {
          const f = {};
          for (const p of this._renderableTilesKeys) {
            const _ = this._tiles[p].tileID;
            if (_.canonical.equals(a.canonical)) {
              const b = a.clone();
              b.posMatrix = new Float64Array(16), s.ortho(b.posMatrix, 0, s.EXTENT, 0, s.EXTENT, 0, 1), f[p] = b;
            } else if (_.canonical.isChildOf(a.canonical)) {
              const b = a.clone();
              b.posMatrix = new Float64Array(16);
              const M = _.canonical.z - a.canonical.z, P = _.canonical.x - (_.canonical.x >> M << M), O = _.canonical.y - (_.canonical.y >> M << M), D = s.EXTENT >> M;
              s.ortho(b.posMatrix, 0, D, 0, D, 0, 1), s.translate(b.posMatrix, b.posMatrix, [-P * D, -O * D, 0]), f[p] = b;
            } else if (a.canonical.isChildOf(_.canonical)) {
              const b = a.clone();
              b.posMatrix = new Float64Array(16);
              const M = a.canonical.z - _.canonical.z, P = a.canonical.x - (a.canonical.x >> M << M), O = a.canonical.y - (a.canonical.y >> M << M), D = s.EXTENT >> M;
              s.ortho(b.posMatrix, 0, s.EXTENT, 0, s.EXTENT, 0, 1), s.translate(b.posMatrix, b.posMatrix, [P * D, O * D, 0]), s.scale(b.posMatrix, b.posMatrix, [1 / 2 ** M, 1 / 2 ** M, 0]), f[p] = b;
            }
          }
          return f;
        }
        getSourceTile(a, f) {
          const p = this.sourceCache._source;
          let _ = a.overscaledZ - this.deltaZoom;
          if (_ > p.maxzoom && (_ = p.maxzoom), _ < p.minzoom)
            return null;
          this._sourceTileCache[a.key] || (this._sourceTileCache[a.key] = a.scaledTo(_).key);
          let b = this.sourceCache.getTileByID(this._sourceTileCache[a.key]);
          if ((!b || !b.dem) && f)
            for (; _ >= p.minzoom && (!b || !b.dem); )
              b = this.sourceCache.getTileByID(a.scaledTo(_--).key);
          return b;
        }
        tilesAfterTime(a = Date.now()) {
          return Object.values(this._tiles).filter((f) => f.timeLoaded >= a);
        }
      }
      class Qt {
        constructor(a, f, p) {
          this.style = a, this.sourceCache = new Rt(f), this.options = p, this.exaggeration = typeof p.exaggeration == "number" ? p.exaggeration : 1, this.elevationOffset = typeof p.elevationOffset == "number" ? p.elevationOffset : 450, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024, this.clearRerenderCache();
        }
        getDEMElevation(a, f, p, _ = s.EXTENT) {
          if (!(f >= 0 && f < _ && p >= 0 && p < _))
            return this.elevationOffset;
          let b = 0;
          const M = this.getTerrainData(a);
          if (M.tile && M.tile.dem) {
            const P = s.transformMat4$1([], [f / _ * s.EXTENT, p / _ * s.EXTENT], M.u_terrain_matrix), O = [P[0] * M.tile.dem.dim, P[1] * M.tile.dem.dim], D = [Math.floor(O[0]), Math.floor(O[1])], F = M.tile.dem.get(D[0], D[1]), $ = M.tile.dem.get(D[0], D[1] + 1), G = M.tile.dem.get(D[0] + 1, D[1]), ie = M.tile.dem.get(D[0] + 1, D[1] + 1);
            b = s.number(s.number(F, $, O[0] - D[0]), s.number(G, ie, O[0] - D[0]), O[1] - D[1]);
          }
          return b;
        }
        rememberForRerender(a, f) {
          for (const p in this.sourceCache._tiles) {
            const _ = this.sourceCache._tiles[p];
            (_.tileID.equals(f) || _.tileID.isChildOf(f)) && (a === this.sourceCache.sourceCache.id && (_.timeLoaded = Date.now()), this._rerender[a] = this._rerender[a] || {}, this._rerender[a][_.tileID.key] = !0);
          }
        }
        needsRerender(a, f) {
          return this._rerender[a] && this._rerender[a][f.key];
        }
        clearRerenderCache() {
          this._rerender = {};
        }
        getElevation(a, f, p, _ = s.EXTENT) {
          return (this.getDEMElevation(a, f, p, _) + this.elevationOffset) * this.exaggeration;
        }
        getTerrainData(a) {
          if (!this._emptyDemTexture) {
            const _ = this.style.map.painter.context, b = new s.RGBAImage({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new B(_, b, _.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new B(_, new s.RGBAImage({ width: 1, height: 1 }), _.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(_.gl.NEAREST, _.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.identity([]);
          }
          const f = this.sourceCache.getSourceTile(a, !0);
          if (f && f.dem && (!f.demTexture || f.needsTerrainPrepare)) {
            const _ = this.style.map.painter.context;
            f.demTexture = this.style.map.painter.getTileTexture(f.dem.stride), f.demTexture ? f.demTexture.update(f.dem.getPixels(), { premultiply: !1 }) : f.demTexture = new B(_, f.dem.getPixels(), _.gl.RGBA, { premultiply: !1 }), f.demTexture.bind(_.gl.NEAREST, _.gl.CLAMP_TO_EDGE), f.needsTerrainPrepare = !1;
          }
          const p = f && f + f.tileID.key + a.key;
          if (p && !this._demMatrixCache[p]) {
            const _ = this.sourceCache.sourceCache._source.maxzoom;
            let b = a.canonical.z - f.tileID.canonical.z;
            a.overscaledZ > a.canonical.z && (a.canonical.z >= _ ? b = a.canonical.z - _ : s.warnOnce("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const M = a.canonical.x - (a.canonical.x >> b << b), P = a.canonical.y - (a.canonical.y >> b << b), O = s.fromScaling(new Float64Array(16), [1 / (s.EXTENT << b), 1 / (s.EXTENT << b), 0]);
            s.translate(O, O, [M * s.EXTENT, P * s.EXTENT, 0]), this._demMatrixCache[a.key] = { matrix: O, coord: a };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: f && f.dem && f.dem.dim || 1, u_terrain_matrix: p ? this._demMatrixCache[a.key].matrix : this._emptyDemMatrix, u_terrain_unpack: f && f.dem && f.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_offset: this.elevationOffset, u_terrain_exaggeration: this.exaggeration, texture: (f && f.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: f };
        }
        getRTTFramebuffer() {
          const a = this.style.map.painter;
          if (!this._rttFramebuffer) {
            const f = this.sourceCache.tileSize * this.qualityFactor;
            this._rttFramebuffer = a.context.createFramebuffer(f, f, !0), this._rttFramebuffer.depthAttachment.set(a.context.createRenderbuffer(a.context.gl.DEPTH_COMPONENT16, f, f));
          }
          return this._rttFramebuffer;
        }
        getFramebuffer(a) {
          const f = this.style.map.painter, p = f.width / devicePixelRatio, _ = f.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === p && this._fbo.height === _ || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new B(f.context, { width: p, height: _, data: null }, f.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(f.context.gl.NEAREST, f.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new B(f.context, { width: p, height: _, data: null }, f.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(f.context.gl.NEAREST, f.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = f.context.createFramebuffer(p, _, !0), this._fbo.depthAttachment.set(f.context.createRenderbuffer(f.context.gl.DEPTH_COMPONENT16, p, _))), this._fbo.colorAttachment.set(a === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const a = this.style.map.painter.context;
          if (this._coordsTexture)
            return this._coordsTexture;
          const f = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let b = 0, M = 0; b < this._coordsTextureSize; b++)
            for (let P = 0; P < this._coordsTextureSize; P++, M += 4)
              f[M + 0] = 255 & P, f[M + 1] = 255 & b, f[M + 2] = P >> 8 << 4 | b >> 8, f[M + 3] = 0;
          const p = new s.RGBAImage({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(f.buffer)), _ = new B(a, p, a.gl.RGBA, { premultiply: !1 });
          return _.bind(a.gl.NEAREST, a.gl.CLAMP_TO_EDGE), this._coordsTexture = _, _;
        }
        pointCoordinate(a) {
          const f = new Uint8Array(4), p = this.style.map.painter, _ = p.context, b = _.gl;
          _.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), b.readPixels(a.x, p.height / devicePixelRatio - a.y - 1, 1, 1, b.RGBA, b.UNSIGNED_BYTE, f), _.bindFramebuffer.set(null);
          const M = f[0] + (f[2] >> 4 << 8), P = f[1] + ((15 & f[2]) << 8), O = this.coordsIndex[255 - f[3]], D = O && this.sourceCache.getTileByID(O);
          if (!D)
            return null;
          const F = this._coordsTextureSize, $ = (1 << D.tileID.canonical.z) * F;
          return new s.MercatorCoordinate((D.tileID.canonical.x * F + M) / $, (D.tileID.canonical.y * F + P) / $, this.getElevation(D.tileID, M, P, F));
        }
        getTerrainMesh() {
          if (this._mesh)
            return this._mesh;
          const a = this.style.map.painter.context, f = new s.PosArray(), p = new s.TriangleIndexArray(), _ = this.meshSize, b = s.EXTENT / _, M = _ * _;
          for (let P = 0; P <= _; P++)
            for (let O = 0; O <= _; O++)
              f.emplaceBack(O * b, P * b);
          for (let P = 0; P < M; P += _ + 1)
            for (let O = 0; O < _; O++)
              p.emplaceBack(O + P, _ + O + P + 1, _ + O + P + 2), p.emplaceBack(O + P, _ + O + P + 2, O + P + 1);
          return this._mesh = { indexBuffer: a.createIndexBuffer(p), vertexBuffer: a.createVertexBuffer(f, ur.members), segments: s.SegmentVector.simpleSegment(0, 0, f.length, p.length) }, this._mesh;
        }
        getMinMaxElevation(a) {
          const f = this.getTerrainData(a).tile, p = { minElevation: null, maxElevation: null };
          return f && f.dem && (p.minElevation = (f.dem.min + this.elevationOffset) * this.exaggeration, p.maxElevation = (f.dem.max + this.elevationOffset) * this.exaggeration), p;
        }
      }
      const gr = (g, a) => s.emitValidationErrors(g, a && a.filter((f) => f.identifier !== "source.canvas")), jr = s.pick(Xe, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), ii = s.pick(Xe, ["setCenter", "setZoom", "setBearing", "setPitch"]), yn = function() {
        const g = {}, a = s.spec.$version;
        for (const f in s.spec.$root) {
          const p = s.spec.$root[f];
          if (p.required) {
            let _ = null;
            _ = f === "version" ? a : p.type === "array" ? [] : {}, _ != null && (g[f] = _);
          }
        }
        return g;
      }();
      class bi extends s.Evented {
        constructor(a, f = {}) {
          super(), this.map = a, this.dispatcher = new Re(Ze(), this), this.imageManager = new q(), this.imageManager.setEventedParent(this), this.glyphManager = new he(a._requestManager, f.localIdeographFontFamily), this.lineAtlas = new Me(256, 512), this.crossTileSymbolIndex = new Pt(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new s.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", s.getReferrer());
          const p = this;
          this._rtlTextPluginCallback = bi.registerForPluginStateChange((_) => {
            p.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: _.pluginStatus, pluginURL: _.pluginURL }, (b, M) => {
              if (s.triggerPluginCompletionEvent(b), M && M.every((P) => P))
                for (const P in p.sourceCaches)
                  p.sourceCaches[P].reload();
            });
          }), this.on("data", (_) => {
            if (_.dataType !== "source" || _.sourceDataType !== "metadata")
              return;
            const b = this.sourceCaches[_.sourceId];
            if (!b)
              return;
            const M = b.getSource();
            if (M && M.vectorLayerIds)
              for (const P in this._layers) {
                const O = this._layers[P];
                O.source === M.id && this._validateLayer(O);
              }
          });
        }
        loadURL(a, f = {}) {
          this.fire(new s.Event("dataloading", { dataType: "style" }));
          const p = typeof f.validate != "boolean" || f.validate, _ = this.map._requestManager.transformRequest(a, s.ResourceType.Style);
          this._request = s.getJSON(_, (b, M) => {
            this._request = null, b ? this.fire(new s.ErrorEvent(b)) : M && this._load(M, p);
          });
        }
        loadJSON(a, f = {}) {
          this.fire(new s.Event("dataloading", { dataType: "style" })), this._request = s.exported.frame(() => {
            this._request = null, this._load(a, f.validate !== !1);
          });
        }
        loadEmpty() {
          this.fire(new s.Event("dataloading", { dataType: "style" })), this._load(yn, !1);
        }
        _load(a, f) {
          if (f && gr(this, s.validateStyle(a)))
            return;
          this._loaded = !0, this.stylesheet = a;
          for (const _ in a.sources)
            this.addSource(_, a.sources[_], { validate: !1 });
          a.sprite ? this._loadSprite(a.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(a.glyphs);
          const p = rt(this.stylesheet.layers);
          this._order = p.map((_) => _.id), this._layers = {}, this._serializedLayers = {};
          for (let _ of p)
            _ = s.createStyleLayer(_), _.setEventedParent(this, { layer: { id: _.id } }), this._layers[_.id] = _, this._serializedLayers[_.id] = _.serialize();
          this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new Oe(this.stylesheet.light), this.setTerrain(this.stylesheet.terrain), this.fire(new s.Event("data", { dataType: "style" })), this.fire(new s.Event("style.load"));
        }
        _loadSprite(a) {
          this._spriteRequest = function(f, p, _, b) {
            let M, P, O;
            const D = _ > 1 ? "@2x" : "";
            let F = s.getJSON(p.transformRequest(p.normalizeSpriteURL(f, D, ".json"), s.ResourceType.SpriteJSON), (ie, Q) => {
              F = null, O || (O = ie, M = Q, G());
            }), $ = s.getImage(p.transformRequest(p.normalizeSpriteURL(f, D, ".png"), s.ResourceType.SpriteImage), (ie, Q) => {
              $ = null, O || (O = ie, P = Q, G());
            });
            function G() {
              if (O)
                b(O);
              else if (M && P) {
                const ie = s.exported.getImageData(P), Q = {};
                for (const te in M) {
                  const { width: de, height: be, x: Se, y: oe, sdf: Le, pixelRatio: Ie, stretchX: Be, stretchY: Ue, content: Qe } = M[te], Fe = new s.RGBAImage({ width: de, height: be });
                  s.RGBAImage.copy(ie, Fe, { x: Se, y: oe }, { x: 0, y: 0 }, { width: de, height: be }), Q[te] = { data: Fe, pixelRatio: Ie, sdf: Le, stretchX: Be, stretchY: Ue, content: Qe };
                }
                b(null, Q);
              }
            }
            return { cancel() {
              F && (F.cancel(), F = null), $ && ($.cancel(), $ = null);
            } };
          }(a, this.map._requestManager, this.map.getPixelRatio(), (f, p) => {
            if (this._spriteRequest = null, f)
              this.fire(new s.ErrorEvent(f));
            else if (p)
              for (const _ in p)
                this.imageManager.addImage(_, p[_]);
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new s.Event("data", { dataType: "style" }));
          });
        }
        _validateLayer(a) {
          const f = this.sourceCaches[a.source];
          if (!f)
            return;
          const p = a.sourceLayer;
          if (!p)
            return;
          const _ = f.getSource();
          (_.type === "geojson" || _.vectorLayerIds && _.vectorLayerIds.indexOf(p) === -1) && this.fire(new s.ErrorEvent(new Error(`Source layer "${p}" does not exist on source "${_.id}" as specified by style layer "${a.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length)
            return !1;
          for (const a in this.sourceCaches)
            if (!this.sourceCaches[a].loaded())
              return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeLayers(a) {
          const f = [];
          for (const p of a) {
            const _ = this._layers[p];
            _.type !== "custom" && f.push(_.serialize());
          }
          return f;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition())
            return !0;
          for (const a in this.sourceCaches)
            if (this.sourceCaches[a].hasTransition())
              return !0;
          for (const a in this._layers)
            if (this._layers[a].hasTransition())
              return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading.");
        }
        update(a) {
          if (!this._loaded)
            return;
          const f = this._changed;
          if (this._changed) {
            const _ = Object.keys(this._updatedLayers), b = Object.keys(this._removedLayers);
            (_.length || b.length) && this._updateWorkerLayers(_, b);
            for (const M in this._updatedSources) {
              const P = this._updatedSources[M];
              if (P === "reload")
                this._reloadSource(M);
              else {
                if (P !== "clear")
                  throw new Error(`Invalid action ${P}`);
                this._clearSource(M);
              }
            }
            this._updateTilesForChangedImages();
            for (const M in this._updatedPaintProps)
              this._layers[M].updateTransitions(a);
            this.light.updateTransitions(a), this._resetUpdates();
          }
          const p = {};
          for (const _ in this.sourceCaches) {
            const b = this.sourceCaches[_];
            p[_] = b.used, b.used = !1;
          }
          for (const _ of this._order) {
            const b = this._layers[_];
            b.recalculate(a, this._availableImages), !b.isHidden(a.zoom) && b.source && (this.sourceCaches[b.source].used = !0);
          }
          for (const _ in p) {
            const b = this.sourceCaches[_];
            p[_] !== b.used && b.fire(new s.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: _ }));
          }
          this.light.recalculate(a), this.z = a.zoom, f && this.fire(new s.Event("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const a = Object.keys(this._changedImages);
          if (a.length) {
            for (const f in this.sourceCaches)
              this.sourceCaches[f].reloadTilesForDependencies(["icons", "patterns"], a);
            this._changedImages = {};
          }
        }
        _updateWorkerLayers(a, f) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(a), removedIds: f });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
        }
        setTerrain(a) {
          if (this._checkLoaded(), this._terrainDataCallback && this.off("data", this._terrainDataCallback), this._terrainfreezeElevationCallback && this.map.off("freezeElevation", this._terrainfreezeElevationCallback), a) {
            const f = this.sourceCaches[a.source];
            if (!f)
              throw new Error(`cannot load terrain, because there exists no source with ID: ${a.source}`);
            this.terrain = new Qt(this, f, a), this.map.transform.updateElevation(this.terrain), this._terrainfreezeElevationCallback = (p) => {
              p.freeze ? this.map.transform.freezeElevation = !0 : (this.map.transform.freezeElevation = !1, this.map.transform.recalculateZoom(this.terrain));
            }, this._terrainDataCallback = (p) => {
              p.tile && (p.sourceId === a.source ? (this.map.transform.updateElevation(this.terrain), this.terrain.rememberForRerender(p.sourceId, p.tile.tileID)) : p.source.type === "geojson" && this.terrain.rememberForRerender(p.sourceId, p.tile.tileID));
            }, this.on("data", this._terrainDataCallback), this.map.on("freezeElevation", this._terrainfreezeElevationCallback);
          } else
            this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.map.transform.updateElevation(this.terrain);
          this.map.fire(new s.Event("terrain", { terrain: a }));
        }
        setState(a) {
          if (this._checkLoaded(), gr(this, s.validateStyle(a)))
            return !1;
          (a = s.clone$1(a)).layers = rt(a.layers);
          const f = function(_, b) {
            if (!_)
              return [{ command: Xe.setStyle, args: [b] }];
            let M = [];
            try {
              if (!T(_.version, b.version))
                return [{ command: Xe.setStyle, args: [b] }];
              T(_.center, b.center) || M.push({ command: Xe.setCenter, args: [b.center] }), T(_.zoom, b.zoom) || M.push({ command: Xe.setZoom, args: [b.zoom] }), T(_.bearing, b.bearing) || M.push({ command: Xe.setBearing, args: [b.bearing] }), T(_.pitch, b.pitch) || M.push({ command: Xe.setPitch, args: [b.pitch] }), T(_.sprite, b.sprite) || M.push({ command: Xe.setSprite, args: [b.sprite] }), T(_.glyphs, b.glyphs) || M.push({ command: Xe.setGlyphs, args: [b.glyphs] }), T(_.transition, b.transition) || M.push({ command: Xe.setTransition, args: [b.transition] }), T(_.light, b.light) || M.push({ command: Xe.setLight, args: [b.light] });
              const P = {}, O = [];
              (function(F, $, G, ie) {
                let Q;
                for (Q in $ = $ || {}, F = F || {})
                  Object.prototype.hasOwnProperty.call(F, Q) && (Object.prototype.hasOwnProperty.call($, Q) || at(Q, G, ie));
                for (Q in $)
                  Object.prototype.hasOwnProperty.call($, Q) && (Object.prototype.hasOwnProperty.call(F, Q) ? T(F[Q], $[Q]) || (F[Q].type === "geojson" && $[Q].type === "geojson" && At(F, $, Q) ? G.push({ command: Xe.setGeoJSONSourceData, args: [Q, $[Q].data] }) : Ke(Q, $, G, ie)) : Je(Q, $, G));
              })(_.sources, b.sources, O, P);
              const D = [];
              _.layers && _.layers.forEach((F) => {
                P[F.source] ? M.push({ command: Xe.removeLayer, args: [F.id] }) : D.push(F);
              }), M = M.concat(O), function(F, $, G) {
                $ = $ || [];
                const ie = (F = F || []).map(St), Q = $.map(St), te = F.reduce(Ut, {}), de = $.reduce(Ut, {}), be = ie.slice(), Se = /* @__PURE__ */ Object.create(null);
                let oe, Le, Ie, Be, Ue, Qe, Fe;
                for (oe = 0, Le = 0; oe < ie.length; oe++)
                  Ie = ie[oe], Object.prototype.hasOwnProperty.call(de, Ie) ? Le++ : (G.push({ command: Xe.removeLayer, args: [Ie] }), be.splice(be.indexOf(Ie, Le), 1));
                for (oe = 0, Le = 0; oe < Q.length; oe++)
                  Ie = Q[Q.length - 1 - oe], be[be.length - 1 - oe] !== Ie && (Object.prototype.hasOwnProperty.call(te, Ie) ? (G.push({ command: Xe.removeLayer, args: [Ie] }), be.splice(be.lastIndexOf(Ie, be.length - Le), 1)) : Le++, Qe = be[be.length - oe], G.push({ command: Xe.addLayer, args: [de[Ie], Qe] }), be.splice(be.length - oe, 0, Ie), Se[Ie] = !0);
                for (oe = 0; oe < Q.length; oe++)
                  if (Ie = Q[oe], Be = te[Ie], Ue = de[Ie], !Se[Ie] && !T(Be, Ue))
                    if (T(Be.source, Ue.source) && T(Be["source-layer"], Ue["source-layer"]) && T(Be.type, Ue.type)) {
                      for (Fe in mt(Be.layout, Ue.layout, G, Ie, null, Xe.setLayoutProperty), mt(Be.paint, Ue.paint, G, Ie, null, Xe.setPaintProperty), T(Be.filter, Ue.filter) || G.push({ command: Xe.setFilter, args: [Ie, Ue.filter] }), T(Be.minzoom, Ue.minzoom) && T(Be.maxzoom, Ue.maxzoom) || G.push({ command: Xe.setLayerZoomRange, args: [Ie, Ue.minzoom, Ue.maxzoom] }), Be)
                        Object.prototype.hasOwnProperty.call(Be, Fe) && Fe !== "layout" && Fe !== "paint" && Fe !== "filter" && Fe !== "metadata" && Fe !== "minzoom" && Fe !== "maxzoom" && (Fe.indexOf("paint.") === 0 ? mt(Be[Fe], Ue[Fe], G, Ie, Fe.slice(6), Xe.setPaintProperty) : T(Be[Fe], Ue[Fe]) || G.push({ command: Xe.setLayerProperty, args: [Ie, Fe, Ue[Fe]] }));
                      for (Fe in Ue)
                        Object.prototype.hasOwnProperty.call(Ue, Fe) && !Object.prototype.hasOwnProperty.call(Be, Fe) && Fe !== "layout" && Fe !== "paint" && Fe !== "filter" && Fe !== "metadata" && Fe !== "minzoom" && Fe !== "maxzoom" && (Fe.indexOf("paint.") === 0 ? mt(Be[Fe], Ue[Fe], G, Ie, Fe.slice(6), Xe.setPaintProperty) : T(Be[Fe], Ue[Fe]) || G.push({ command: Xe.setLayerProperty, args: [Ie, Fe, Ue[Fe]] }));
                    } else
                      G.push({ command: Xe.removeLayer, args: [Ie] }), Qe = be[be.lastIndexOf(Ie) + 1], G.push({ command: Xe.addLayer, args: [Ue, Qe] });
              }(D, b.layers, M);
            } catch (P) {
              console.warn("Unable to compute style diff:", P), M = [{ command: Xe.setStyle, args: [b] }];
            }
            return M;
          }(this.serialize(), a).filter((_) => !(_.command in ii));
          if (f.length === 0)
            return !1;
          const p = f.filter((_) => !(_.command in jr));
          if (p.length > 0)
            throw new Error(`Unimplemented: ${p.map((_) => _.command).join(", ")}.`);
          return f.forEach((_) => {
            _.command !== "setTransition" && this[_.command].apply(this, _.args);
          }), this.stylesheet = a, !0;
        }
        addImage(a, f) {
          if (this.getImage(a))
            return this.fire(new s.ErrorEvent(new Error(`An image named "${a}" already exists.`)));
          this.imageManager.addImage(a, f), this._afterImageUpdated(a);
        }
        updateImage(a, f) {
          this.imageManager.updateImage(a, f);
        }
        getImage(a) {
          return this.imageManager.getImage(a);
        }
        removeImage(a) {
          if (!this.getImage(a))
            return this.fire(new s.ErrorEvent(new Error(`An image named "${a}" does not exist.`)));
          this.imageManager.removeImage(a), this._afterImageUpdated(a);
        }
        _afterImageUpdated(a) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[a] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new s.Event("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(a, f, p = {}) {
          if (this._checkLoaded(), this.sourceCaches[a] !== void 0)
            throw new Error(`Source "${a}" already exists.`);
          if (!f.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(f).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(f.type) >= 0 && this._validate(s.validateStyle.source, `sources.${a}`, f, null, p))
            return;
          this.map && this.map._collectResourceTiming && (f.collectResourceTiming = !0);
          const _ = this.sourceCaches[a] = new an(a, f, this.dispatcher);
          _.style = this, _.setEventedParent(this, () => ({ isSourceLoaded: this.loaded(), source: _.serialize(), sourceId: a })), _.onAdd(this.map), this._changed = !0;
        }
        removeSource(a) {
          if (this._checkLoaded(), this.sourceCaches[a] === void 0)
            throw new Error("There is no source with this ID");
          for (const p in this._layers)
            if (this._layers[p].source === a)
              return this.fire(new s.ErrorEvent(new Error(`Source "${a}" cannot be removed while layer "${p}" is using it.`)));
          const f = this.sourceCaches[a];
          delete this.sourceCaches[a], delete this._updatedSources[a], f.fire(new s.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: a })), f.setEventedParent(null), f.onRemove(this.map), this._changed = !0;
        }
        setGeoJSONSourceData(a, f) {
          if (this._checkLoaded(), this.sourceCaches[a] === void 0)
            throw new Error(`There is no source with this ID=${a}`);
          const p = this.sourceCaches[a].getSource();
          if (p.type !== "geojson")
            throw new Error(`geojsonSource.type is ${p.type}, which is !== 'geojson`);
          p.setData(f), this._changed = !0;
        }
        getSource(a) {
          return this.sourceCaches[a] && this.sourceCaches[a].getSource();
        }
        addLayer(a, f, p = {}) {
          this._checkLoaded();
          const _ = a.id;
          if (this.getLayer(_))
            return void this.fire(new s.ErrorEvent(new Error(`Layer "${_}" already exists on this map.`)));
          let b;
          if (a.type === "custom") {
            if (gr(this, s.validateCustomStyleLayer(a)))
              return;
            b = s.createStyleLayer(a);
          } else {
            if (typeof a.source == "object" && (this.addSource(_, a.source), a = s.clone$1(a), a = s.extend(a, { source: _ })), this._validate(s.validateStyle.layer, `layers.${_}`, a, { arrayIndex: -1 }, p))
              return;
            b = s.createStyleLayer(a), this._validateLayer(b), b.setEventedParent(this, { layer: { id: _ } }), this._serializedLayers[b.id] = b.serialize();
          }
          const M = f ? this._order.indexOf(f) : this._order.length;
          if (f && M === -1)
            this.fire(new s.ErrorEvent(new Error(`Cannot add layer "${_}" before non-existing layer "${f}".`)));
          else {
            if (this._order.splice(M, 0, _), this._layerOrderChanged = !0, this._layers[_] = b, this._removedLayers[_] && b.source && b.type !== "custom") {
              const P = this._removedLayers[_];
              delete this._removedLayers[_], P.type !== b.type ? this._updatedSources[b.source] = "clear" : (this._updatedSources[b.source] = "reload", this.sourceCaches[b.source].pause());
            }
            this._updateLayer(b), b.onAdd && b.onAdd(this.map);
          }
        }
        moveLayer(a, f) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[a])
            return void this.fire(new s.ErrorEvent(new Error(`The layer '${a}' does not exist in the map's style and cannot be moved.`)));
          if (a === f)
            return;
          const p = this._order.indexOf(a);
          this._order.splice(p, 1);
          const _ = f ? this._order.indexOf(f) : this._order.length;
          f && _ === -1 ? this.fire(new s.ErrorEvent(new Error(`Cannot move layer "${a}" before non-existing layer "${f}".`))) : (this._order.splice(_, 0, a), this._layerOrderChanged = !0);
        }
        removeLayer(a) {
          this._checkLoaded();
          const f = this._layers[a];
          if (!f)
            return void this.fire(new s.ErrorEvent(new Error(`Cannot remove non-existing layer "${a}".`)));
          f.setEventedParent(null);
          const p = this._order.indexOf(a);
          this._order.splice(p, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[a] = f, delete this._layers[a], delete this._serializedLayers[a], delete this._updatedLayers[a], delete this._updatedPaintProps[a], f.onRemove && f.onRemove(this.map);
        }
        getLayer(a) {
          return this._layers[a];
        }
        hasLayer(a) {
          return a in this._layers;
        }
        setLayerZoomRange(a, f, p) {
          this._checkLoaded();
          const _ = this.getLayer(a);
          _ ? _.minzoom === f && _.maxzoom === p || (f != null && (_.minzoom = f), p != null && (_.maxzoom = p), this._updateLayer(_)) : this.fire(new s.ErrorEvent(new Error(`Cannot set the zoom range of non-existing layer "${a}".`)));
        }
        setFilter(a, f, p = {}) {
          this._checkLoaded();
          const _ = this.getLayer(a);
          if (_) {
            if (!T(_.filter, f))
              return f == null ? (_.filter = void 0, void this._updateLayer(_)) : void (this._validate(s.validateStyle.filter, `layers.${_.id}.filter`, f, null, p) || (_.filter = s.clone$1(f), this._updateLayer(_)));
          } else
            this.fire(new s.ErrorEvent(new Error(`Cannot filter non-existing layer "${a}".`)));
        }
        getFilter(a) {
          return s.clone$1(this.getLayer(a).filter);
        }
        setLayoutProperty(a, f, p, _ = {}) {
          this._checkLoaded();
          const b = this.getLayer(a);
          b ? T(b.getLayoutProperty(f), p) || (b.setLayoutProperty(f, p, _), this._updateLayer(b)) : this.fire(new s.ErrorEvent(new Error(`Cannot style non-existing layer "${a}".`)));
        }
        getLayoutProperty(a, f) {
          const p = this.getLayer(a);
          if (p)
            return p.getLayoutProperty(f);
          this.fire(new s.ErrorEvent(new Error(`Cannot get style of non-existing layer "${a}".`)));
        }
        setPaintProperty(a, f, p, _ = {}) {
          this._checkLoaded();
          const b = this.getLayer(a);
          b ? T(b.getPaintProperty(f), p) || (b.setPaintProperty(f, p, _) && this._updateLayer(b), this._changed = !0, this._updatedPaintProps[a] = !0) : this.fire(new s.ErrorEvent(new Error(`Cannot style non-existing layer "${a}".`)));
        }
        getPaintProperty(a, f) {
          return this.getLayer(a).getPaintProperty(f);
        }
        setFeatureState(a, f) {
          this._checkLoaded();
          const p = a.source, _ = a.sourceLayer, b = this.sourceCaches[p];
          if (b === void 0)
            return void this.fire(new s.ErrorEvent(new Error(`The source '${p}' does not exist in the map's style.`)));
          const M = b.getSource().type;
          M === "geojson" && _ ? this.fire(new s.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : M !== "vector" || _ ? (a.id === void 0 && this.fire(new s.ErrorEvent(new Error("The feature id parameter must be provided."))), b.setFeatureState(_, a.id, f)) : this.fire(new s.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(a, f) {
          this._checkLoaded();
          const p = a.source, _ = this.sourceCaches[p];
          if (_ === void 0)
            return void this.fire(new s.ErrorEvent(new Error(`The source '${p}' does not exist in the map's style.`)));
          const b = _.getSource().type, M = b === "vector" ? a.sourceLayer : void 0;
          b !== "vector" || M ? f && typeof a.id != "string" && typeof a.id != "number" ? this.fire(new s.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : _.removeFeatureState(M, a.id, f) : this.fire(new s.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(a) {
          this._checkLoaded();
          const f = a.source, p = a.sourceLayer, _ = this.sourceCaches[f];
          if (_ !== void 0)
            return _.getSource().type !== "vector" || p ? (a.id === void 0 && this.fire(new s.ErrorEvent(new Error("The feature id parameter must be provided."))), _.getFeatureState(p, a.id)) : void this.fire(new s.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new s.ErrorEvent(new Error(`The source '${f}' does not exist in the map's style.`)));
        }
        getTransition() {
          return s.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          return s.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: s.mapObject(this.sourceCaches, (a) => a.serialize()), layers: this._serializeLayers(this._order) }, (a) => a !== void 0);
        }
        _updateLayer(a) {
          this._updatedLayers[a.id] = !0, a.source && !this._updatedSources[a.source] && this.sourceCaches[a.source].getSource().type !== "raster" && (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause()), this._changed = !0;
        }
        _flattenAndSortRenderedFeatures(a) {
          const f = (M) => this._layers[M].type === "fill-extrusion", p = {}, _ = [];
          for (let M = this._order.length - 1; M >= 0; M--) {
            const P = this._order[M];
            if (f(P)) {
              p[P] = M;
              for (const O of a) {
                const D = O[P];
                if (D)
                  for (const F of D)
                    _.push(F);
              }
            }
          }
          _.sort((M, P) => P.intersectionZ - M.intersectionZ);
          const b = [];
          for (let M = this._order.length - 1; M >= 0; M--) {
            const P = this._order[M];
            if (f(P))
              for (let O = _.length - 1; O >= 0; O--) {
                const D = _[O].feature;
                if (p[D.layer.id] < M)
                  break;
                b.push(D), _.pop();
              }
            else
              for (const O of a) {
                const D = O[P];
                if (D)
                  for (const F of D)
                    b.push(F.feature);
              }
          }
          return b;
        }
        queryRenderedFeatures(a, f, p) {
          f && f.filter && this._validate(s.validateStyle.filter, "queryRenderedFeatures.filter", f.filter, null, f);
          const _ = {};
          if (f && f.layers) {
            if (!Array.isArray(f.layers))
              return this.fire(new s.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
            for (const M of f.layers) {
              const P = this._layers[M];
              if (!P)
                return this.fire(new s.ErrorEvent(new Error(`The layer '${M}' does not exist in the map's style and cannot be queried for features.`))), [];
              _[P.source] = !0;
            }
          }
          const b = [];
          f.availableImages = this._availableImages;
          for (const M in this.sourceCaches)
            f.layers && !_[M] || b.push(or(this.sourceCaches[M], this._layers, this._serializedLayers, a, f, p));
          return this.placement && b.push(function(M, P, O, D, F, $, G) {
            const ie = {}, Q = $.queryRenderedSymbols(D), te = [];
            for (const de of Object.keys(Q).map(Number))
              te.push(G[de]);
            te.sort(Jt);
            for (const de of te) {
              const be = de.featureIndex.lookupSymbolFeatures(Q[de.bucketInstanceId], P, de.bucketIndex, de.sourceLayerIndex, F.filter, F.layers, F.availableImages, M);
              for (const Se in be) {
                const oe = ie[Se] = ie[Se] || [], Le = be[Se];
                Le.sort((Ie, Be) => {
                  const Ue = de.featureSortOrder;
                  if (Ue) {
                    const Qe = Ue.indexOf(Ie.featureIndex);
                    return Ue.indexOf(Be.featureIndex) - Qe;
                  }
                  return Be.featureIndex - Ie.featureIndex;
                });
                for (const Ie of Le)
                  oe.push(Ie);
              }
            }
            for (const de in ie)
              ie[de].forEach((be) => {
                const Se = be.feature, oe = O[M[de].source].getFeatureState(Se.layer["source-layer"], Se.id);
                Se.source = Se.layer.source, Se.layer["source-layer"] && (Se.sourceLayer = Se.layer["source-layer"]), Se.state = oe;
              });
            return ie;
          }(this._layers, this._serializedLayers, this.sourceCaches, a, f, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(b);
        }
        querySourceFeatures(a, f) {
          f && f.filter && this._validate(s.validateStyle.filter, "querySourceFeatures.filter", f.filter, null, f);
          const p = this.sourceCaches[a];
          return p ? function(_, b) {
            const M = _.getRenderableIds().map((D) => _.getTileByID(D)), P = [], O = {};
            for (let D = 0; D < M.length; D++) {
              const F = M[D], $ = F.tileID.canonical.key;
              O[$] || (O[$] = !0, F.querySourceFeatures(P, b));
            }
            return P;
          }(p, f) : [];
        }
        addSourceType(a, f, p) {
          return bi.getSourceType(a) ? p(new Error(`A source type called "${a}" already exists.`)) : (bi.setSourceType(a, f), f.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: a, url: f.workerSourceURL }, p) : p(null, null));
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(a, f = {}) {
          this._checkLoaded();
          const p = this.light.getLight();
          let _ = !1;
          for (const M in a)
            if (!T(a[M], p[M])) {
              _ = !0;
              break;
            }
          if (!_)
            return;
          const b = { now: s.exported.now(), transition: s.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(a, f), this.light.updateTransitions(b);
        }
        _validate(a, f, p, _, b = {}) {
          return (!b || b.validate !== !1) && gr(this, a.call(s.validateStyle, s.extend({ key: f, style: this.serialize(), value: p, styleSpec: s.spec }, _)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), s.evented.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const a in this._layers)
            this._layers[a].setEventedParent(null);
          for (const a in this.sourceCaches) {
            const f = this.sourceCaches[a];
            f.setEventedParent(null), f.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
        }
        _clearSource(a) {
          this.sourceCaches[a].clearTiles();
        }
        _reloadSource(a) {
          this.sourceCaches[a].resume(), this.sourceCaches[a].reload();
        }
        _updateSources(a) {
          for (const f in this.sourceCaches)
            this.sourceCaches[f].update(a, this.terrain);
        }
        _generateCollisionBoxes() {
          for (const a in this.sourceCaches)
            this._reloadSource(a);
        }
        _updatePlacement(a, f, p, _, b = !1) {
          let M = !1, P = !1;
          const O = {};
          for (const D of this._order) {
            const F = this._layers[D];
            if (F.type !== "symbol")
              continue;
            if (!O[F.source]) {
              const G = this.sourceCaches[F.source];
              O[F.source] = G.getRenderableIds(!0).map((ie) => G.getTileByID(ie)).sort((ie, Q) => Q.tileID.overscaledZ - ie.tileID.overscaledZ || (ie.tileID.isLessThan(Q.tileID) ? -1 : 1));
            }
            const $ = this.crossTileSymbolIndex.addLayer(F, O[F.source], a.center.lng);
            M = M || $;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((b = b || this._layerOrderChanged || p === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(s.exported.now(), a.zoom)) && (this.pauseablePlacement = new ue(a, this.terrain, this._order, b, f, p, _, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, O), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(s.exported.now()), P = !0), M && this.pauseablePlacement.placement.setStale()), P || M)
            for (const D of this._order) {
              const F = this._layers[D];
              F.type === "symbol" && this.placement.updateLayerOpacities(F, O[F.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(s.exported.now());
        }
        _releaseSymbolFadeTiles() {
          for (const a in this.sourceCaches)
            this.sourceCaches[a].releaseSymbolFadeTiles();
        }
        getImages(a, f, p) {
          this.imageManager.getImages(f.icons, p), this._updateTilesForChangedImages();
          const _ = this.sourceCaches[f.source];
          _ && _.setDependencies(f.tileID.key, f.type, f.icons);
        }
        getGlyphs(a, f, p) {
          this.glyphManager.getGlyphs(f.stacks, p);
        }
        getResource(a, f, p) {
          return s.makeRequest(f, p);
        }
      }
      bi.getSourceType = function(g) {
        return Yt[g];
      }, bi.setSourceType = function(g, a) {
        Yt[g] = a;
      }, bi.registerForPluginStateChange = s.registerForPluginStateChange;
      var Ks = "attribute vec2 a_pos;uniform mat4 u_matrix;varying vec2 v_texture_pos;varying float v_depth;void main() {v_texture_pos=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);v_depth=gl_Position.z/gl_Position.w;}";
      const ec = { prelude: Xr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_offset;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return (elevation+u_terrain_offset)*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: Xr(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: Xr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Xr(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Xr("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Xr(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`), heatmapTexture: Xr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Xr("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Xr("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Xr("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: Xr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: Xr(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: Xr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: Xr(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Xr(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float baseDelta=10.0;float ele=get_elevation(a_centroid);
#else
float baseDelta=0.0;float ele=0.0;
#endif
base=max(0.0,ele+base-baseDelta);height=max(0.0,ele+height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Xr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float baseDelta=10.0;float ele=get_elevation(a_centroid);
#else
float baseDelta=0.0;float ele=0.0;
#endif
base=max(0.0,ele+base-baseDelta);height=max(0.0,ele+height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Xr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Xr(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: Xr(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Xr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Xr(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Xr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Xr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: Xr(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Xr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Xr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Xr("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", Ks), terrainDepth: Xr("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", Ks), terrainCoords: Xr("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", Ks) };
      function Xr(g, a) {
        const f = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, p = a.match(/attribute ([\w]+) ([\w]+)/g), _ = g.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), b = a.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), M = b ? b.concat(_) : _, P = {};
        return { fragmentSource: g = g.replace(f, (O, D, F, $, G) => (P[G] = !0, D === "define" ? `
#ifndef HAS_UNIFORM_u_${G}
varying ${F} ${$} ${G};
#else
uniform ${F} ${$} u_${G};
#endif
` : `
#ifdef HAS_UNIFORM_u_${G}
    ${F} ${$} ${G} = u_${G};
#endif
`)), vertexSource: a = a.replace(f, (O, D, F, $, G) => {
          const ie = $ === "float" ? "vec2" : "vec4", Q = G.match(/color/) ? "color" : ie;
          return P[G] ? D === "define" ? `
#ifndef HAS_UNIFORM_u_${G}
uniform lowp float u_${G}_t;
attribute ${F} ${ie} a_${G};
varying ${F} ${$} ${G};
#else
uniform ${F} ${$} u_${G};
#endif
` : Q === "vec4" ? `
#ifndef HAS_UNIFORM_u_${G}
    ${G} = a_${G};
#else
    ${F} ${$} ${G} = u_${G};
#endif
` : `
#ifndef HAS_UNIFORM_u_${G}
    ${G} = unpack_mix_${Q}(a_${G}, u_${G}_t);
#else
    ${F} ${$} ${G} = u_${G};
#endif
` : D === "define" ? `
#ifndef HAS_UNIFORM_u_${G}
uniform lowp float u_${G}_t;
attribute ${F} ${ie} a_${G};
#else
uniform ${F} ${$} u_${G};
#endif
` : Q === "vec4" ? `
#ifndef HAS_UNIFORM_u_${G}
    ${F} ${$} ${G} = a_${G};
#else
    ${F} ${$} ${G} = u_${G};
#endif
` : `
#ifndef HAS_UNIFORM_u_${G}
    ${F} ${$} ${G} = unpack_mix_${Q}(a_${G}, u_${G}_t);
#else
    ${F} ${$} ${G} = u_${G};
#endif
`;
        }), staticAttributes: p, staticUniforms: M };
      }
      class Zh {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(a, f, p, _, b, M, P, O, D) {
          this.context = a;
          let F = this.boundPaintVertexBuffers.length !== _.length;
          for (let $ = 0; !F && $ < _.length; $++)
            this.boundPaintVertexBuffers[$] !== _[$] && (F = !0);
          a.extVertexArrayObject && this.vao && this.boundProgram === f && this.boundLayoutVertexBuffer === p && !F && this.boundIndexBuffer === b && this.boundVertexOffset === M && this.boundDynamicVertexBuffer === P && this.boundDynamicVertexBuffer2 === O && this.boundDynamicVertexBuffer3 === D ? (a.bindVertexArrayOES.set(this.vao), P && P.bind(), b && b.dynamicDraw && b.bind(), O && O.bind(), D && D.bind()) : this.freshBind(f, p, _, b, M, P, O, D);
        }
        freshBind(a, f, p, _, b, M, P, O) {
          let D;
          const F = a.numAttributes, $ = this.context, G = $.gl;
          if ($.extVertexArrayObject)
            this.vao && this.destroy(), this.vao = $.extVertexArrayObject.createVertexArrayOES(), $.bindVertexArrayOES.set(this.vao), D = 0, this.boundProgram = a, this.boundLayoutVertexBuffer = f, this.boundPaintVertexBuffers = p, this.boundIndexBuffer = _, this.boundVertexOffset = b, this.boundDynamicVertexBuffer = M, this.boundDynamicVertexBuffer2 = P, this.boundDynamicVertexBuffer3 = O;
          else {
            D = $.currentNumAttributes || 0;
            for (let ie = F; ie < D; ie++)
              G.disableVertexAttribArray(ie);
          }
          f.enableAttributes(G, a);
          for (const ie of p)
            ie.enableAttributes(G, a);
          M && M.enableAttributes(G, a), P && P.enableAttributes(G, a), O && O.enableAttributes(G, a), f.bind(), f.setVertexAttribPointers(G, a, b);
          for (const ie of p)
            ie.bind(), ie.setVertexAttribPointers(G, a, b);
          M && (M.bind(), M.setVertexAttribPointers(G, a, b)), _ && _.bind(), P && (P.bind(), P.setVertexAttribPointers(G, a, b)), O && (O.bind(), O.setVertexAttribPointers(G, a, b)), $.currentNumAttributes = F;
        }
        destroy() {
          this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
        }
      }
      function Hh(g) {
        const a = [];
        for (let f = 0; f < g.length; f++) {
          if (g[f] === null)
            continue;
          const p = g[f].split(" ");
          a.push(p.pop());
        }
        return a;
      }
      class fp {
        constructor(a, f, p, _, b, M, P) {
          const O = a.gl;
          this.program = O.createProgram();
          const D = Hh(p.staticAttributes), F = _ ? _.getBinderAttributes() : [], $ = D.concat(F), G = ec.prelude.staticUniforms ? Hh(ec.prelude.staticUniforms) : [], ie = p.staticUniforms ? Hh(p.staticUniforms) : [], Q = _ ? _.getBinderUniforms() : [], te = G.concat(ie).concat(Q), de = [];
          for (const Ue of te)
            de.indexOf(Ue) < 0 && de.push(Ue);
          const be = _ ? _.defines() : [];
          M && be.push("#define OVERDRAW_INSPECTOR;"), P && be.push("#define TERRAIN3D;");
          const Se = be.concat(ec.prelude.fragmentSource, p.fragmentSource).join(`
`), oe = be.concat(ec.prelude.vertexSource, p.vertexSource).join(`
`), Le = O.createShader(O.FRAGMENT_SHADER);
          if (O.isContextLost())
            return void (this.failedToCreate = !0);
          O.shaderSource(Le, Se), O.compileShader(Le), O.attachShader(this.program, Le);
          const Ie = O.createShader(O.VERTEX_SHADER);
          if (O.isContextLost())
            return void (this.failedToCreate = !0);
          O.shaderSource(Ie, oe), O.compileShader(Ie), O.attachShader(this.program, Ie), this.attributes = {};
          const Be = {};
          this.numAttributes = $.length;
          for (let Ue = 0; Ue < this.numAttributes; Ue++)
            $[Ue] && (O.bindAttribLocation(this.program, Ue, $[Ue]), this.attributes[$[Ue]] = Ue);
          O.linkProgram(this.program), O.deleteShader(Ie), O.deleteShader(Le);
          for (let Ue = 0; Ue < de.length; Ue++) {
            const Qe = de[Ue];
            if (Qe && !Be[Qe]) {
              const Fe = O.getUniformLocation(this.program, Qe);
              Fe && (Be[Qe] = Fe);
            }
          }
          this.fixedUniforms = b(a, Be), this.terrainUniforms = ((Ue, Qe) => ({ u_depth: new s.Uniform1i(Ue, Qe.u_depth), u_terrain: new s.Uniform1i(Ue, Qe.u_terrain), u_terrain_dim: new s.Uniform1f(Ue, Qe.u_terrain_dim), u_terrain_matrix: new s.UniformMatrix4f(Ue, Qe.u_terrain_matrix), u_terrain_unpack: new s.Uniform4f(Ue, Qe.u_terrain_unpack), u_terrain_offset: new s.Uniform1f(Ue, Qe.u_terrain_offset), u_terrain_exaggeration: new s.Uniform1f(Ue, Qe.u_terrain_exaggeration) }))(a, Be), this.binderUniforms = _ ? _.getUniforms(a, Be) : [];
        }
        draw(a, f, p, _, b, M, P, O, D, F, $, G, ie, Q, te, de, be, Se) {
          const oe = a.gl;
          if (this.failedToCreate)
            return;
          if (a.program.set(this.program), a.setDepthMode(p), a.setStencilMode(_), a.setColorMode(b), a.setCullFace(M), O) {
            a.activeTexture.set(oe.TEXTURE2), oe.bindTexture(oe.TEXTURE_2D, O.depthTexture), a.activeTexture.set(oe.TEXTURE3), oe.bindTexture(oe.TEXTURE_2D, O.texture);
            for (const Ie in this.terrainUniforms)
              this.terrainUniforms[Ie].set(O[Ie]);
          }
          for (const Ie in this.fixedUniforms)
            this.fixedUniforms[Ie].set(P[Ie]);
          te && te.setUniforms(a, this.binderUniforms, ie, { zoom: Q });
          let Le = 0;
          switch (f) {
            case oe.LINES:
              Le = 2;
              break;
            case oe.TRIANGLES:
              Le = 3;
              break;
            case oe.LINE_STRIP:
              Le = 1;
          }
          for (const Ie of G.get()) {
            const Be = Ie.vaos || (Ie.vaos = {});
            (Be[D] || (Be[D] = new Zh())).bind(a, this, F, te ? te.getPaintVertexBuffers() : [], $, Ie.vertexOffset, de, be, Se), oe.drawElements(f, Ie.primitiveLength * Le, oe.UNSIGNED_SHORT, Ie.primitiveOffset * Le * 2);
          }
        }
      }
      function dp(g, a, f) {
        const p = 1 / Tn(f, 1, a.transform.tileZoom), _ = Math.pow(2, f.tileID.overscaledZ), b = f.tileSize * Math.pow(2, a.transform.tileZoom) / _, M = b * (f.tileID.canonical.x + f.tileID.wrap * _), P = b * f.tileID.canonical.y;
        return { u_image: 0, u_texsize: f.imageAtlasTexture.size, u_scale: [p, g.fromScale, g.toScale], u_fade: g.t, u_pixel_coord_upper: [M >> 16, P >> 16], u_pixel_coord_lower: [65535 & M, 65535 & P] };
      }
      const Kh = (g, a, f, p) => {
        const _ = a.style.light, b = _.properties.get("position"), M = [b.x, b.y, b.z], P = s.create$1();
        _.properties.get("anchor") === "viewport" && s.fromRotation(P, -a.transform.angle), s.transformMat3(M, M, P);
        const O = _.properties.get("color");
        return { u_matrix: g, u_lightpos: M, u_lightintensity: _.properties.get("intensity"), u_lightcolor: [O.r, O.g, O.b], u_vertical_gradient: +f, u_opacity: p };
      }, Zy = (g, a, f, p, _, b, M) => s.extend(Kh(g, a, f, p), dp(b, a, M), { u_height_factor: -Math.pow(2, _.overscaledZ) / M.tileSize / 8 }), _u = (g) => ({ u_matrix: g }), Yh = (g, a, f, p) => s.extend(_u(g), dp(f, a, p)), pp = (g, a) => ({ u_matrix: g, u_world: a }), mp = (g, a, f, p, _) => s.extend(Yh(g, a, f, p), { u_world: _ }), gp = (g, a, f, p) => {
        const _ = g.transform;
        let b, M;
        if (p.paint.get("circle-pitch-alignment") === "map") {
          const P = Tn(f, 1, _.zoom);
          b = !0, M = [P, P];
        } else
          b = !1, M = _.pixelsToGLUnits;
        return { u_camera_to_center_distance: _.cameraToCenterDistance, u_scale_with_map: +(p.paint.get("circle-pitch-scale") === "map"), u_matrix: g.translatePosMatrix(a.posMatrix, f, p.paint.get("circle-translate"), p.paint.get("circle-translate-anchor")), u_pitch_with_map: +b, u_device_pixel_ratio: g.pixelRatio, u_extrude_scale: M };
      }, ps = (g, a, f) => {
        const p = Tn(f, 1, a.zoom), _ = Math.pow(2, a.zoom - f.tileID.overscaledZ), b = f.tileID.overscaleFactor();
        return { u_matrix: g, u_camera_to_center_distance: a.cameraToCenterDistance, u_pixels_to_tile_units: p, u_extrude_scale: [a.pixelsToGLUnits[0] / (p * _), a.pixelsToGLUnits[1] / (p * _)], u_overscale_factor: b };
      }, tc = (g, a, f = 1) => ({ u_matrix: g, u_color: a, u_overlay: 0, u_overlay_scale: f }), Ys = (g) => ({ u_matrix: g }), vu = (g, a, f, p) => ({ u_matrix: g, u_extrude_scale: Tn(a, 1, f), u_intensity: p });
      function xu(g, a) {
        const f = Math.pow(2, a.canonical.z), p = a.canonical.y;
        return [new s.MercatorCoordinate(0, p / f).toLngLat().lat, new s.MercatorCoordinate(0, (p + 1) / f).toLngLat().lat];
      }
      const Js = (g, a, f, p) => {
        const _ = g.transform;
        return { u_matrix: nc(g, a, f, p), u_ratio: 1 / Tn(a, 1, _.zoom), u_device_pixel_ratio: g.pixelRatio, u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]] };
      }, Jh = (g, a, f, p, _) => s.extend(Js(g, a, f, _), { u_image: 0, u_image_height: p }), bu = (g, a, f, p, _) => {
        const b = g.transform, M = _n(a, b);
        return { u_matrix: nc(g, a, f, _), u_texsize: a.imageAtlasTexture.size, u_ratio: 1 / Tn(a, 1, b.zoom), u_device_pixel_ratio: g.pixelRatio, u_image: 0, u_scale: [M, p.fromScale, p.toScale], u_fade: p.t, u_units_to_pixels: [1 / b.pixelsToGLUnits[0], 1 / b.pixelsToGLUnits[1]] };
      }, rc = (g, a, f, p, _, b) => {
        const M = g.lineAtlas, P = _n(a, g.transform), O = f.layout.get("line-cap") === "round", D = M.getDash(p.from, O), F = M.getDash(p.to, O), $ = D.width * _.fromScale, G = F.width * _.toScale;
        return s.extend(Js(g, a, f, b), { u_patternscale_a: [P / $, -D.height / 2], u_patternscale_b: [P / G, -F.height / 2], u_sdfgamma: M.width / (256 * Math.min($, G) * g.pixelRatio) / 2, u_image: 0, u_tex_y_a: D.y, u_tex_y_b: F.y, u_mix: _.t });
      };
      function _n(g, a) {
        return 1 / Tn(g, 1, a.tileZoom);
      }
      function nc(g, a, f, p) {
        return g.translatePosMatrix(p ? p.posMatrix : a.tileID.posMatrix, a, f.paint.get("line-translate"), f.paint.get("line-translate-anchor"));
      }
      const yp = (g, a, f, p, _) => {
        return { u_matrix: g, u_tl_parent: a, u_scale_parent: f, u_buffer_scale: 1, u_fade_t: p.mix, u_opacity: p.opacity * _.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: _.paint.get("raster-brightness-min"), u_brightness_high: _.paint.get("raster-brightness-max"), u_saturation_factor: (M = _.paint.get("raster-saturation"), M > 0 ? 1 - 1 / (1.001 - M) : -M), u_contrast_factor: (b = _.paint.get("raster-contrast"), b > 0 ? 1 / (1 - b) : 1 + b), u_spin_weights: _p(_.paint.get("raster-hue-rotate")) };
        var b, M;
      };
      function _p(g) {
        g *= Math.PI / 180;
        const a = Math.sin(g), f = Math.cos(g);
        return [(2 * f + 1) / 3, (-Math.sqrt(3) * a - f + 1) / 3, (Math.sqrt(3) * a - f + 1) / 3];
      }
      const Qh = (g, a, f, p, _, b, M, P, O, D) => {
        const F = _.transform;
        return { u_is_size_zoom_constant: +(g === "constant" || g === "source"), u_is_size_feature_constant: +(g === "constant" || g === "camera"), u_size_t: a ? a.uSizeT : 0, u_size: a ? a.uSize : 0, u_camera_to_center_distance: F.cameraToCenterDistance, u_pitch: F.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +f, u_aspect_ratio: F.width / F.height, u_fade_change: _.options.fadeDuration ? _.symbolFadeChange : 1, u_matrix: b, u_label_plane_matrix: M, u_coord_matrix: P, u_is_text: +O, u_pitch_with_map: +p, u_texsize: D, u_texture: 0 };
      }, wu = (g, a, f, p, _, b, M, P, O, D, F) => {
        const $ = _.transform;
        return s.extend(Qh(g, a, f, p, _, b, M, P, O, D), { u_gamma_scale: p ? Math.cos($._pitch) * $.cameraToCenterDistance : 1, u_device_pixel_ratio: _.pixelRatio, u_is_halo: +F });
      }, vp = (g, a, f, p, _, b, M, P, O, D) => s.extend(wu(g, a, f, p, _, b, M, P, !0, O, !0), { u_texsize_icon: D, u_texture_icon: 1 }), Hy = (g, a, f) => ({ u_matrix: g, u_opacity: a, u_color: f }), Ky = (g, a, f, p, _, b) => s.extend(function(M, P, O, D) {
        const F = O.imageManager.getPattern(M.from.toString()), $ = O.imageManager.getPattern(M.to.toString()), { width: G, height: ie } = O.imageManager.getPixelSize(), Q = Math.pow(2, D.tileID.overscaledZ), te = D.tileSize * Math.pow(2, O.transform.tileZoom) / Q, de = te * (D.tileID.canonical.x + D.tileID.wrap * Q), be = te * D.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: F.tl, u_pattern_br_a: F.br, u_pattern_tl_b: $.tl, u_pattern_br_b: $.br, u_texsize: [G, ie], u_mix: P.t, u_pattern_size_a: F.displaySize, u_pattern_size_b: $.displaySize, u_scale_a: P.fromScale, u_scale_b: P.toScale, u_tile_units_to_pixels: 1 / Tn(D, 1, O.transform.tileZoom), u_pixel_coord_upper: [de >> 16, be >> 16], u_pixel_coord_lower: [65535 & de, 65535 & be] };
      }(p, b, f, _), { u_matrix: g, u_opacity: a }), ef = { fillExtrusion: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_lightpos: new s.Uniform3f(g, a.u_lightpos), u_lightintensity: new s.Uniform1f(g, a.u_lightintensity), u_lightcolor: new s.Uniform3f(g, a.u_lightcolor), u_vertical_gradient: new s.Uniform1f(g, a.u_vertical_gradient), u_opacity: new s.Uniform1f(g, a.u_opacity) }), fillExtrusionPattern: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_lightpos: new s.Uniform3f(g, a.u_lightpos), u_lightintensity: new s.Uniform1f(g, a.u_lightintensity), u_lightcolor: new s.Uniform3f(g, a.u_lightcolor), u_vertical_gradient: new s.Uniform1f(g, a.u_vertical_gradient), u_height_factor: new s.Uniform1f(g, a.u_height_factor), u_image: new s.Uniform1i(g, a.u_image), u_texsize: new s.Uniform2f(g, a.u_texsize), u_pixel_coord_upper: new s.Uniform2f(g, a.u_pixel_coord_upper), u_pixel_coord_lower: new s.Uniform2f(g, a.u_pixel_coord_lower), u_scale: new s.Uniform3f(g, a.u_scale), u_fade: new s.Uniform1f(g, a.u_fade), u_opacity: new s.Uniform1f(g, a.u_opacity) }), fill: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix) }), fillPattern: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_image: new s.Uniform1i(g, a.u_image), u_texsize: new s.Uniform2f(g, a.u_texsize), u_pixel_coord_upper: new s.Uniform2f(g, a.u_pixel_coord_upper), u_pixel_coord_lower: new s.Uniform2f(g, a.u_pixel_coord_lower), u_scale: new s.Uniform3f(g, a.u_scale), u_fade: new s.Uniform1f(g, a.u_fade) }), fillOutline: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_world: new s.Uniform2f(g, a.u_world) }), fillOutlinePattern: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_world: new s.Uniform2f(g, a.u_world), u_image: new s.Uniform1i(g, a.u_image), u_texsize: new s.Uniform2f(g, a.u_texsize), u_pixel_coord_upper: new s.Uniform2f(g, a.u_pixel_coord_upper), u_pixel_coord_lower: new s.Uniform2f(g, a.u_pixel_coord_lower), u_scale: new s.Uniform3f(g, a.u_scale), u_fade: new s.Uniform1f(g, a.u_fade) }), circle: (g, a) => ({ u_camera_to_center_distance: new s.Uniform1f(g, a.u_camera_to_center_distance), u_scale_with_map: new s.Uniform1i(g, a.u_scale_with_map), u_pitch_with_map: new s.Uniform1i(g, a.u_pitch_with_map), u_extrude_scale: new s.Uniform2f(g, a.u_extrude_scale), u_device_pixel_ratio: new s.Uniform1f(g, a.u_device_pixel_ratio), u_matrix: new s.UniformMatrix4f(g, a.u_matrix) }), collisionBox: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_camera_to_center_distance: new s.Uniform1f(g, a.u_camera_to_center_distance), u_pixels_to_tile_units: new s.Uniform1f(g, a.u_pixels_to_tile_units), u_extrude_scale: new s.Uniform2f(g, a.u_extrude_scale), u_overscale_factor: new s.Uniform1f(g, a.u_overscale_factor) }), collisionCircle: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_inv_matrix: new s.UniformMatrix4f(g, a.u_inv_matrix), u_camera_to_center_distance: new s.Uniform1f(g, a.u_camera_to_center_distance), u_viewport_size: new s.Uniform2f(g, a.u_viewport_size) }), debug: (g, a) => ({ u_color: new s.UniformColor(g, a.u_color), u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_overlay: new s.Uniform1i(g, a.u_overlay), u_overlay_scale: new s.Uniform1f(g, a.u_overlay_scale) }), clippingMask: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix) }), heatmap: (g, a) => ({ u_extrude_scale: new s.Uniform1f(g, a.u_extrude_scale), u_intensity: new s.Uniform1f(g, a.u_intensity), u_matrix: new s.UniformMatrix4f(g, a.u_matrix) }), heatmapTexture: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_world: new s.Uniform2f(g, a.u_world), u_image: new s.Uniform1i(g, a.u_image), u_color_ramp: new s.Uniform1i(g, a.u_color_ramp), u_opacity: new s.Uniform1f(g, a.u_opacity) }), hillshade: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_image: new s.Uniform1i(g, a.u_image), u_latrange: new s.Uniform2f(g, a.u_latrange), u_light: new s.Uniform2f(g, a.u_light), u_shadow: new s.UniformColor(g, a.u_shadow), u_highlight: new s.UniformColor(g, a.u_highlight), u_accent: new s.UniformColor(g, a.u_accent) }), hillshadePrepare: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_image: new s.Uniform1i(g, a.u_image), u_dimension: new s.Uniform2f(g, a.u_dimension), u_zoom: new s.Uniform1f(g, a.u_zoom), u_unpack: new s.Uniform4f(g, a.u_unpack) }), line: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_ratio: new s.Uniform1f(g, a.u_ratio), u_device_pixel_ratio: new s.Uniform1f(g, a.u_device_pixel_ratio), u_units_to_pixels: new s.Uniform2f(g, a.u_units_to_pixels) }), lineGradient: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_ratio: new s.Uniform1f(g, a.u_ratio), u_device_pixel_ratio: new s.Uniform1f(g, a.u_device_pixel_ratio), u_units_to_pixels: new s.Uniform2f(g, a.u_units_to_pixels), u_image: new s.Uniform1i(g, a.u_image), u_image_height: new s.Uniform1f(g, a.u_image_height) }), linePattern: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_texsize: new s.Uniform2f(g, a.u_texsize), u_ratio: new s.Uniform1f(g, a.u_ratio), u_device_pixel_ratio: new s.Uniform1f(g, a.u_device_pixel_ratio), u_image: new s.Uniform1i(g, a.u_image), u_units_to_pixels: new s.Uniform2f(g, a.u_units_to_pixels), u_scale: new s.Uniform3f(g, a.u_scale), u_fade: new s.Uniform1f(g, a.u_fade) }), lineSDF: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_ratio: new s.Uniform1f(g, a.u_ratio), u_device_pixel_ratio: new s.Uniform1f(g, a.u_device_pixel_ratio), u_units_to_pixels: new s.Uniform2f(g, a.u_units_to_pixels), u_patternscale_a: new s.Uniform2f(g, a.u_patternscale_a), u_patternscale_b: new s.Uniform2f(g, a.u_patternscale_b), u_sdfgamma: new s.Uniform1f(g, a.u_sdfgamma), u_image: new s.Uniform1i(g, a.u_image), u_tex_y_a: new s.Uniform1f(g, a.u_tex_y_a), u_tex_y_b: new s.Uniform1f(g, a.u_tex_y_b), u_mix: new s.Uniform1f(g, a.u_mix) }), raster: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_tl_parent: new s.Uniform2f(g, a.u_tl_parent), u_scale_parent: new s.Uniform1f(g, a.u_scale_parent), u_buffer_scale: new s.Uniform1f(g, a.u_buffer_scale), u_fade_t: new s.Uniform1f(g, a.u_fade_t), u_opacity: new s.Uniform1f(g, a.u_opacity), u_image0: new s.Uniform1i(g, a.u_image0), u_image1: new s.Uniform1i(g, a.u_image1), u_brightness_low: new s.Uniform1f(g, a.u_brightness_low), u_brightness_high: new s.Uniform1f(g, a.u_brightness_high), u_saturation_factor: new s.Uniform1f(g, a.u_saturation_factor), u_contrast_factor: new s.Uniform1f(g, a.u_contrast_factor), u_spin_weights: new s.Uniform3f(g, a.u_spin_weights) }), symbolIcon: (g, a) => ({ u_is_size_zoom_constant: new s.Uniform1i(g, a.u_is_size_zoom_constant), u_is_size_feature_constant: new s.Uniform1i(g, a.u_is_size_feature_constant), u_size_t: new s.Uniform1f(g, a.u_size_t), u_size: new s.Uniform1f(g, a.u_size), u_camera_to_center_distance: new s.Uniform1f(g, a.u_camera_to_center_distance), u_pitch: new s.Uniform1f(g, a.u_pitch), u_rotate_symbol: new s.Uniform1i(g, a.u_rotate_symbol), u_aspect_ratio: new s.Uniform1f(g, a.u_aspect_ratio), u_fade_change: new s.Uniform1f(g, a.u_fade_change), u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_label_plane_matrix: new s.UniformMatrix4f(g, a.u_label_plane_matrix), u_coord_matrix: new s.UniformMatrix4f(g, a.u_coord_matrix), u_is_text: new s.Uniform1i(g, a.u_is_text), u_pitch_with_map: new s.Uniform1i(g, a.u_pitch_with_map), u_texsize: new s.Uniform2f(g, a.u_texsize), u_texture: new s.Uniform1i(g, a.u_texture) }), symbolSDF: (g, a) => ({ u_is_size_zoom_constant: new s.Uniform1i(g, a.u_is_size_zoom_constant), u_is_size_feature_constant: new s.Uniform1i(g, a.u_is_size_feature_constant), u_size_t: new s.Uniform1f(g, a.u_size_t), u_size: new s.Uniform1f(g, a.u_size), u_camera_to_center_distance: new s.Uniform1f(g, a.u_camera_to_center_distance), u_pitch: new s.Uniform1f(g, a.u_pitch), u_rotate_symbol: new s.Uniform1i(g, a.u_rotate_symbol), u_aspect_ratio: new s.Uniform1f(g, a.u_aspect_ratio), u_fade_change: new s.Uniform1f(g, a.u_fade_change), u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_label_plane_matrix: new s.UniformMatrix4f(g, a.u_label_plane_matrix), u_coord_matrix: new s.UniformMatrix4f(g, a.u_coord_matrix), u_is_text: new s.Uniform1i(g, a.u_is_text), u_pitch_with_map: new s.Uniform1i(g, a.u_pitch_with_map), u_texsize: new s.Uniform2f(g, a.u_texsize), u_texture: new s.Uniform1i(g, a.u_texture), u_gamma_scale: new s.Uniform1f(g, a.u_gamma_scale), u_device_pixel_ratio: new s.Uniform1f(g, a.u_device_pixel_ratio), u_is_halo: new s.Uniform1i(g, a.u_is_halo) }), symbolTextAndIcon: (g, a) => ({ u_is_size_zoom_constant: new s.Uniform1i(g, a.u_is_size_zoom_constant), u_is_size_feature_constant: new s.Uniform1i(g, a.u_is_size_feature_constant), u_size_t: new s.Uniform1f(g, a.u_size_t), u_size: new s.Uniform1f(g, a.u_size), u_camera_to_center_distance: new s.Uniform1f(g, a.u_camera_to_center_distance), u_pitch: new s.Uniform1f(g, a.u_pitch), u_rotate_symbol: new s.Uniform1i(g, a.u_rotate_symbol), u_aspect_ratio: new s.Uniform1f(g, a.u_aspect_ratio), u_fade_change: new s.Uniform1f(g, a.u_fade_change), u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_label_plane_matrix: new s.UniformMatrix4f(g, a.u_label_plane_matrix), u_coord_matrix: new s.UniformMatrix4f(g, a.u_coord_matrix), u_is_text: new s.Uniform1i(g, a.u_is_text), u_pitch_with_map: new s.Uniform1i(g, a.u_pitch_with_map), u_texsize: new s.Uniform2f(g, a.u_texsize), u_texsize_icon: new s.Uniform2f(g, a.u_texsize_icon), u_texture: new s.Uniform1i(g, a.u_texture), u_texture_icon: new s.Uniform1i(g, a.u_texture_icon), u_gamma_scale: new s.Uniform1f(g, a.u_gamma_scale), u_device_pixel_ratio: new s.Uniform1f(g, a.u_device_pixel_ratio), u_is_halo: new s.Uniform1i(g, a.u_is_halo) }), background: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_opacity: new s.Uniform1f(g, a.u_opacity), u_color: new s.UniformColor(g, a.u_color) }), backgroundPattern: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_opacity: new s.Uniform1f(g, a.u_opacity), u_image: new s.Uniform1i(g, a.u_image), u_pattern_tl_a: new s.Uniform2f(g, a.u_pattern_tl_a), u_pattern_br_a: new s.Uniform2f(g, a.u_pattern_br_a), u_pattern_tl_b: new s.Uniform2f(g, a.u_pattern_tl_b), u_pattern_br_b: new s.Uniform2f(g, a.u_pattern_br_b), u_texsize: new s.Uniform2f(g, a.u_texsize), u_mix: new s.Uniform1f(g, a.u_mix), u_pattern_size_a: new s.Uniform2f(g, a.u_pattern_size_a), u_pattern_size_b: new s.Uniform2f(g, a.u_pattern_size_b), u_scale_a: new s.Uniform1f(g, a.u_scale_a), u_scale_b: new s.Uniform1f(g, a.u_scale_b), u_pixel_coord_upper: new s.Uniform2f(g, a.u_pixel_coord_upper), u_pixel_coord_lower: new s.Uniform2f(g, a.u_pixel_coord_lower), u_tile_units_to_pixels: new s.Uniform1f(g, a.u_tile_units_to_pixels) }), terrain: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_texture: new s.Uniform1i(g, a.u_texture) }), terrainDepth: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix) }), terrainCoords: (g, a) => ({ u_matrix: new s.UniformMatrix4f(g, a.u_matrix), u_texture: new s.Uniform1i(g, a.u_texture), u_terrain_coords_id: new s.Uniform1f(g, a.u_terrain_coords_id) }) };
      class tf {
        constructor(a, f, p) {
          this.context = a;
          const _ = a.gl;
          this.buffer = _.createBuffer(), this.dynamicDraw = Boolean(p), this.context.unbindVAO(), a.bindElementBuffer.set(this.buffer), _.bufferData(_.ELEMENT_ARRAY_BUFFER, f.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete f.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(a) {
          const f = this.context.gl;
          if (!this.dynamicDraw)
            throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), f.bufferSubData(f.ELEMENT_ARRAY_BUFFER, 0, a.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const rf = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class nf {
        constructor(a, f, p, _) {
          this.length = f.length, this.attributes = p, this.itemSize = f.bytesPerElement, this.dynamicDraw = _, this.context = a;
          const b = a.gl;
          this.buffer = b.createBuffer(), a.bindVertexBuffer.set(this.buffer), b.bufferData(b.ARRAY_BUFFER, f.arrayBuffer, this.dynamicDraw ? b.DYNAMIC_DRAW : b.STATIC_DRAW), this.dynamicDraw || delete f.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(a) {
          if (a.length !== this.length)
            throw new Error(`Length of new data is ${a.length}, which doesn't match current length of ${this.length}`);
          const f = this.context.gl;
          this.bind(), f.bufferSubData(f.ARRAY_BUFFER, 0, a.arrayBuffer);
        }
        enableAttributes(a, f) {
          for (let p = 0; p < this.attributes.length; p++) {
            const _ = f.attributes[this.attributes[p].name];
            _ !== void 0 && a.enableVertexAttribArray(_);
          }
        }
        setVertexAttribPointers(a, f, p) {
          for (let _ = 0; _ < this.attributes.length; _++) {
            const b = this.attributes[_], M = f.attributes[b.name];
            M !== void 0 && a.vertexAttribPointer(M, b.components, a[rf[b.type]], !1, this.itemSize, b.offset + this.itemSize * (p || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class Lr {
        constructor(a) {
          this.gl = a.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(a) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class xp extends Lr {
        getDefault() {
          return s.Color.transparent;
        }
        set(a) {
          const f = this.current;
          (a.r !== f.r || a.g !== f.g || a.b !== f.b || a.a !== f.a || this.dirty) && (this.gl.clearColor(a.r, a.g, a.b, a.a), this.current = a, this.dirty = !1);
        }
      }
      class Yy extends Lr {
        getDefault() {
          return 1;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.clearDepth(a), this.current = a, this.dirty = !1);
        }
      }
      class ic extends Lr {
        getDefault() {
          return 0;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.clearStencil(a), this.current = a, this.dirty = !1);
        }
      }
      class oc extends Lr {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(a) {
          const f = this.current;
          (a[0] !== f[0] || a[1] !== f[1] || a[2] !== f[2] || a[3] !== f[3] || this.dirty) && (this.gl.colorMask(a[0], a[1], a[2], a[3]), this.current = a, this.dirty = !1);
        }
      }
      class bp extends Lr {
        getDefault() {
          return !0;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.depthMask(a), this.current = a, this.dirty = !1);
        }
      }
      class Qi extends Lr {
        getDefault() {
          return 255;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.stencilMask(a), this.current = a, this.dirty = !1);
        }
      }
      class of extends Lr {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(a) {
          const f = this.current;
          (a.func !== f.func || a.ref !== f.ref || a.mask !== f.mask || this.dirty) && (this.gl.stencilFunc(a.func, a.ref, a.mask), this.current = a, this.dirty = !1);
        }
      }
      class Eu extends Lr {
        getDefault() {
          const a = this.gl;
          return [a.KEEP, a.KEEP, a.KEEP];
        }
        set(a) {
          const f = this.current;
          (a[0] !== f[0] || a[1] !== f[1] || a[2] !== f[2] || this.dirty) && (this.gl.stencilOp(a[0], a[1], a[2]), this.current = a, this.dirty = !1);
        }
      }
      class Tu extends Lr {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          a ? f.enable(f.STENCIL_TEST) : f.disable(f.STENCIL_TEST), this.current = a, this.dirty = !1;
        }
      }
      class af extends Lr {
        getDefault() {
          return [0, 1];
        }
        set(a) {
          const f = this.current;
          (a[0] !== f[0] || a[1] !== f[1] || this.dirty) && (this.gl.depthRange(a[0], a[1]), this.current = a, this.dirty = !1);
        }
      }
      class sf extends Lr {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          a ? f.enable(f.DEPTH_TEST) : f.disable(f.DEPTH_TEST), this.current = a, this.dirty = !1;
        }
      }
      class Su extends Lr {
        getDefault() {
          return this.gl.LESS;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.depthFunc(a), this.current = a, this.dirty = !1);
        }
      }
      class lf extends Lr {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          a ? f.enable(f.BLEND) : f.disable(f.BLEND), this.current = a, this.dirty = !1;
        }
      }
      class cf extends Lr {
        getDefault() {
          const a = this.gl;
          return [a.ONE, a.ZERO];
        }
        set(a) {
          const f = this.current;
          (a[0] !== f[0] || a[1] !== f[1] || this.dirty) && (this.gl.blendFunc(a[0], a[1]), this.current = a, this.dirty = !1);
        }
      }
      class Mu extends Lr {
        getDefault() {
          return s.Color.transparent;
        }
        set(a) {
          const f = this.current;
          (a.r !== f.r || a.g !== f.g || a.b !== f.b || a.a !== f.a || this.dirty) && (this.gl.blendColor(a.r, a.g, a.b, a.a), this.current = a, this.dirty = !1);
        }
      }
      class wp extends Lr {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.blendEquation(a), this.current = a, this.dirty = !1);
        }
      }
      class Ep extends Lr {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          a ? f.enable(f.CULL_FACE) : f.disable(f.CULL_FACE), this.current = a, this.dirty = !1;
        }
      }
      class Qs extends Lr {
        getDefault() {
          return this.gl.BACK;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.cullFace(a), this.current = a, this.dirty = !1);
        }
      }
      class Jy extends Lr {
        getDefault() {
          return this.gl.CCW;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.frontFace(a), this.current = a, this.dirty = !1);
        }
      }
      class Qy extends Lr {
        getDefault() {
          return null;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.useProgram(a), this.current = a, this.dirty = !1);
        }
      }
      class e_ extends Lr {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.activeTexture(a), this.current = a, this.dirty = !1);
        }
      }
      class t_ extends Lr {
        getDefault() {
          const a = this.gl;
          return [0, 0, a.drawingBufferWidth, a.drawingBufferHeight];
        }
        set(a) {
          const f = this.current;
          (a[0] !== f[0] || a[1] !== f[1] || a[2] !== f[2] || a[3] !== f[3] || this.dirty) && (this.gl.viewport(a[0], a[1], a[2], a[3]), this.current = a, this.dirty = !1);
        }
      }
      class r_ extends Lr {
        getDefault() {
          return null;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.bindFramebuffer(f.FRAMEBUFFER, a), this.current = a, this.dirty = !1;
        }
      }
      class n_ extends Lr {
        getDefault() {
          return null;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.bindRenderbuffer(f.RENDERBUFFER, a), this.current = a, this.dirty = !1;
        }
      }
      class uf extends Lr {
        getDefault() {
          return null;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.bindTexture(f.TEXTURE_2D, a), this.current = a, this.dirty = !1;
        }
      }
      class Cu extends Lr {
        getDefault() {
          return null;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.bindBuffer(f.ARRAY_BUFFER, a), this.current = a, this.dirty = !1;
        }
      }
      class hf extends Lr {
        getDefault() {
          return null;
        }
        set(a) {
          const f = this.gl;
          f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, a), this.current = a, this.dirty = !1;
        }
      }
      class ff extends Lr {
        constructor(a) {
          super(a), this.vao = a.extVertexArrayObject;
        }
        getDefault() {
          return null;
        }
        set(a) {
          this.vao && (a !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(a), this.current = a, this.dirty = !1);
        }
      }
      class el extends Lr {
        getDefault() {
          return 4;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.pixelStorei(f.UNPACK_ALIGNMENT, a), this.current = a, this.dirty = !1;
        }
      }
      class Tp extends Lr {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a), this.current = a, this.dirty = !1;
        }
      }
      class Sp extends Lr {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL, a), this.current = a, this.dirty = !1;
        }
      }
      class Iu extends Lr {
        constructor(a, f) {
          super(a), this.context = a, this.parent = f;
        }
        getDefault() {
          return null;
        }
      }
      class ms extends Iu {
        setDirty() {
          this.dirty = !0;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const f = this.gl;
          f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, a, 0), this.current = a, this.dirty = !1;
        }
      }
      class Mp extends Iu {
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const f = this.gl;
          f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_ATTACHMENT, f.RENDERBUFFER, a), this.current = a, this.dirty = !1;
        }
      }
      class tl {
        constructor(a, f, p, _) {
          this.context = a, this.width = f, this.height = p;
          const b = a.gl, M = this.framebuffer = b.createFramebuffer();
          if (this.colorAttachment = new ms(a, M), _ && (this.depthAttachment = new Mp(a, M)), b.checkFramebufferStatus(b.FRAMEBUFFER) !== b.FRAMEBUFFER_COMPLETE)
            throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const a = this.context.gl, f = this.colorAttachment.get();
          if (f && a.deleteTexture(f), this.depthAttachment) {
            const p = this.depthAttachment.get();
            p && a.deleteRenderbuffer(p);
          }
          a.deleteFramebuffer(this.framebuffer);
        }
      }
      class hn {
        constructor(a, f, p) {
          this.blendFunction = a, this.blendColor = f, this.mask = p;
        }
      }
      hn.Replace = [1, 0], hn.disabled = new hn(hn.Replace, s.Color.transparent, [!1, !1, !1, !1]), hn.unblended = new hn(hn.Replace, s.Color.transparent, [!0, !0, !0, !0]), hn.alphaBlended = new hn([1, 771], s.Color.transparent, [!0, !0, !0, !0]);
      class Cp {
        constructor(a) {
          this.gl = a, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new xp(this), this.clearDepth = new Yy(this), this.clearStencil = new ic(this), this.colorMask = new oc(this), this.depthMask = new bp(this), this.stencilMask = new Qi(this), this.stencilFunc = new of(this), this.stencilOp = new Eu(this), this.stencilTest = new Tu(this), this.depthRange = new af(this), this.depthTest = new sf(this), this.depthFunc = new Su(this), this.blend = new lf(this), this.blendFunc = new cf(this), this.blendColor = new Mu(this), this.blendEquation = new wp(this), this.cullFace = new Ep(this), this.cullFaceSide = new Qs(this), this.frontFace = new Jy(this), this.program = new Qy(this), this.activeTexture = new e_(this), this.viewport = new t_(this), this.bindFramebuffer = new r_(this), this.bindRenderbuffer = new n_(this), this.bindTexture = new uf(this), this.bindVertexBuffer = new Cu(this), this.bindElementBuffer = new hf(this), this.bindVertexArrayOES = this.extVertexArrayObject && new ff(this), this.pixelStoreUnpack = new el(this), this.pixelStoreUnpackPremultiplyAlpha = new Tp(this), this.pixelStoreUnpackFlipY = new Sp(this), this.extTextureFilterAnisotropic = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = a.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = a.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (a.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = a.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = a.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(a, f) {
          return new tf(this, a, f);
        }
        createVertexBuffer(a, f, p) {
          return new nf(this, a, f, p);
        }
        createRenderbuffer(a, f, p) {
          const _ = this.gl, b = _.createRenderbuffer();
          return this.bindRenderbuffer.set(b), _.renderbufferStorage(_.RENDERBUFFER, a, f, p), this.bindRenderbuffer.set(null), b;
        }
        createFramebuffer(a, f, p) {
          return new tl(this, a, f, p);
        }
        clear({ color: a, depth: f }) {
          const p = this.gl;
          let _ = 0;
          a && (_ |= p.COLOR_BUFFER_BIT, this.clearColor.set(a), this.colorMask.set([!0, !0, !0, !0])), f !== void 0 && (_ |= p.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(f), this.depthMask.set(!0)), p.clear(_);
        }
        setCullFace(a) {
          a.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(a.mode), this.frontFace.set(a.frontFace));
        }
        setDepthMode(a) {
          a.func !== this.gl.ALWAYS || a.mask ? (this.depthTest.set(!0), this.depthFunc.set(a.func), this.depthMask.set(a.mask), this.depthRange.set(a.range)) : this.depthTest.set(!1);
        }
        setStencilMode(a) {
          a.test.func !== this.gl.ALWAYS || a.mask ? (this.stencilTest.set(!0), this.stencilMask.set(a.mask), this.stencilOp.set([a.fail, a.depthFail, a.pass]), this.stencilFunc.set({ func: a.test.func, ref: a.ref, mask: a.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(a) {
          T(a.blendFunction, hn.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(a.blendFunction), this.blendColor.set(a.blendColor)), this.colorMask.set(a.mask);
        }
        unbindVAO() {
          this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
        }
      }
      class yr {
        constructor(a, f, p) {
          this.func = a, this.mask = f, this.range = p;
        }
      }
      yr.ReadOnly = !1, yr.ReadWrite = !0, yr.disabled = new yr(519, yr.ReadOnly, [0, 1]);
      const Dr = 7680;
      class sn {
        constructor(a, f, p, _, b, M) {
          this.test = a, this.ref = f, this.mask = p, this.fail = _, this.depthFail = b, this.pass = M;
        }
      }
      sn.disabled = new sn({ func: 519, mask: 0 }, 0, 0, Dr, Dr, Dr);
      class vn {
        constructor(a, f, p) {
          this.enable = a, this.mode = f, this.frontFace = p;
        }
      }
      let ac;
      function rl(g, a, f, p, _, b, M) {
        const P = g.context, O = P.gl, D = g.useProgram("collisionBox"), F = [];
        let $ = 0, G = 0;
        for (let oe = 0; oe < p.length; oe++) {
          const Le = p[oe], Ie = a.getTile(Le), Be = Ie.getBucket(f);
          if (!Be)
            continue;
          let Ue = Le.posMatrix;
          _[0] === 0 && _[1] === 0 || (Ue = g.translatePosMatrix(Le.posMatrix, Ie, _, b));
          const Qe = M ? Be.textCollisionBox : Be.iconCollisionBox, Fe = Be.collisionCircleArray;
          if (Fe.length > 0) {
            const bt = s.create(), ht = Ue;
            s.mul(bt, Be.placementInvProjMatrix, g.transform.glCoordMatrix), s.mul(bt, bt, Be.placementViewportMatrix), F.push({ circleArray: Fe, circleOffset: G, transform: ht, invTransform: bt, coord: Le }), $ += Fe.length / 4, G = $;
          }
          Qe && D.draw(P, O.LINES, yr.disabled, sn.disabled, g.colorModeForRenderPass(), vn.disabled, ps(Ue, g.transform, Ie), g.style.terrain && g.style.terrain.getTerrainData(Le), f.id, Qe.layoutVertexBuffer, Qe.indexBuffer, Qe.segments, null, g.transform.zoom, null, null, Qe.collisionVertexBuffer);
        }
        if (!M || !F.length)
          return;
        const ie = g.useProgram("collisionCircle"), Q = new s.CollisionCircleLayoutArray();
        Q.resize(4 * $), Q._trim();
        let te = 0;
        for (const oe of F)
          for (let Le = 0; Le < oe.circleArray.length / 4; Le++) {
            const Ie = 4 * Le, Be = oe.circleArray[Ie + 0], Ue = oe.circleArray[Ie + 1], Qe = oe.circleArray[Ie + 2], Fe = oe.circleArray[Ie + 3];
            Q.emplace(te++, Be, Ue, Qe, Fe, 0), Q.emplace(te++, Be, Ue, Qe, Fe, 1), Q.emplace(te++, Be, Ue, Qe, Fe, 2), Q.emplace(te++, Be, Ue, Qe, Fe, 3);
          }
        (!ac || ac.length < 2 * $) && (ac = function(oe) {
          const Le = 2 * oe, Ie = new s.QuadTriangleArray();
          Ie.resize(Le), Ie._trim();
          for (let Be = 0; Be < Le; Be++) {
            const Ue = 6 * Be;
            Ie.uint16[Ue + 0] = 4 * Be + 0, Ie.uint16[Ue + 1] = 4 * Be + 1, Ie.uint16[Ue + 2] = 4 * Be + 2, Ie.uint16[Ue + 3] = 4 * Be + 2, Ie.uint16[Ue + 4] = 4 * Be + 3, Ie.uint16[Ue + 5] = 4 * Be + 0;
          }
          return Ie;
        }($));
        const de = P.createIndexBuffer(ac, !0), be = P.createVertexBuffer(Q, s.collisionCircleLayout.members, !0);
        for (const oe of F) {
          const Le = { u_matrix: oe.transform, u_inv_matrix: oe.invTransform, u_camera_to_center_distance: (Se = g.transform).cameraToCenterDistance, u_viewport_size: [Se.width, Se.height] };
          ie.draw(P, O.TRIANGLES, yr.disabled, sn.disabled, g.colorModeForRenderPass(), vn.disabled, Le, g.style.terrain && g.style.terrain.getTerrainData(oe.coord), f.id, be, de, s.SegmentVector.simpleSegment(0, 2 * oe.circleOffset, oe.circleArray.length, oe.circleArray.length / 2), null, g.transform.zoom, null, null, null);
        }
        var Se;
        be.destroy(), de.destroy();
      }
      vn.disabled = new vn(!1, 1029, 2305), vn.backCCW = new vn(!0, 1029, 2305);
      const i_ = s.identity(new Float32Array(16));
      function o_(g, a, f, p, _, b) {
        const { horizontalAlign: M, verticalAlign: P } = s.getAnchorAlignment(g), O = -(M - 0.5) * a, D = -(P - 0.5) * f, F = s.evaluateVariableOffset(g, p);
        return new s.pointGeometry((O / _ + F[0]) * b, (D / _ + F[1]) * b);
      }
      function Ip(g, a, f, p, _, b, M, P, O, D, F) {
        const $ = g.text.placedSymbolArray, G = g.text.dynamicLayoutVertexArray, ie = g.icon.dynamicLayoutVertexArray, Q = {};
        G.clear();
        for (let te = 0; te < $.length; te++) {
          const de = $.get(te), be = g.allowVerticalPlacement && !de.placedOrientation, Se = de.hidden || !de.crossTileID || be ? null : p[de.crossTileID];
          if (Se) {
            const oe = new s.pointGeometry(de.anchorX, de.anchorY), Le = Xt(oe, f ? M : b, F), Ie = gn(_.cameraToCenterDistance, Le.signedDistanceFromCamera);
            let Be = s.evaluateSizeForFeature(g.textSizeData, O, de) * Ie / s.ONE_EM;
            f && (Be *= g.tilePixelRatio / P);
            const { width: Ue, height: Qe, anchor: Fe, textOffset: bt, textBoxScale: ht } = Se, wt = o_(Fe, Ue, Qe, bt, ht, Be), er = f ? Xt(oe.add(wt), b, F).point : Le.point.add(a ? wt.rotate(-_.angle) : wt), sr = g.allowVerticalPlacement && de.placedOrientation === s.WritingMode.vertical ? Math.PI / 2 : 0;
            for (let zt = 0; zt < de.numGlyphs; zt++)
              s.addDynamicAttributes(G, er, sr);
            D && de.associatedIconIndex >= 0 && (Q[de.associatedIconIndex] = { shiftedAnchor: er, angle: sr });
          } else
            Lt(de.numGlyphs, G);
        }
        if (D) {
          ie.clear();
          const te = g.icon.placedSymbolArray;
          for (let de = 0; de < te.length; de++) {
            const be = te.get(de);
            if (be.hidden)
              Lt(be.numGlyphs, ie);
            else {
              const Se = Q[de];
              if (Se)
                for (let oe = 0; oe < be.numGlyphs; oe++)
                  s.addDynamicAttributes(ie, Se.shiftedAnchor, Se.angle);
              else
                Lt(be.numGlyphs, ie);
            }
          }
          g.icon.dynamicLayoutVertexBuffer.updateData(ie);
        }
        g.text.dynamicLayoutVertexBuffer.updateData(G);
      }
      function a_(g, a, f) {
        return f.iconsInText && a ? "symbolTextAndIcon" : g ? "symbolSDF" : "symbolIcon";
      }
      function Pu(g, a, f, p, _, b, M, P, O, D, F, $) {
        const G = g.context, ie = G.gl, Q = g.transform, te = P === "map", de = O === "map", be = P !== "viewport" && f.layout.get("symbol-placement") !== "point", Se = te && !de && !be, oe = !f.layout.get("symbol-sort-key").isConstant();
        let Le = !1;
        const Ie = g.depthModeForSublayer(0, yr.ReadOnly), Be = f.layout.get("text-variable-anchor"), Ue = [];
        for (const Qe of p) {
          const Fe = a.getTile(Qe), bt = Fe.getBucket(f);
          if (!bt)
            continue;
          const ht = _ ? bt.text : bt.icon;
          if (!ht || !ht.segments.get().length)
            continue;
          const wt = ht.programConfigurations.get(f.id), er = _ || bt.sdfIcons, sr = _ ? bt.textSizeData : bt.iconSizeData, zt = de || Q.pitch !== 0, Ur = g.useProgram(a_(er, _, bt), wt), $r = s.evaluateSizeForZoom(sr, Q.zoom), Tr = g.style.terrain && g.style.terrain.getTerrainData(Qe);
          let Pr, Gr, oi, Zo, Lo = [0, 0], Ho = null;
          if (_) {
            if (Gr = Fe.glyphAtlasTexture, oi = ie.LINEAR, Pr = Fe.glyphAtlasTexture.size, bt.iconsInText) {
              Lo = Fe.imageAtlasTexture.size, Ho = Fe.imageAtlasTexture;
              const vo = sr.kind === "composite" || sr.kind === "camera";
              Zo = zt || g.options.rotating || g.options.zooming || vo ? ie.LINEAR : ie.NEAREST;
            }
          } else {
            const vo = f.layout.get("icon-size").constantOr(0) !== 1 || bt.iconsNeedLinear;
            Gr = Fe.imageAtlasTexture, oi = er || g.options.rotating || g.options.zooming || vo || zt ? ie.LINEAR : ie.NEAREST, Pr = Fe.imageAtlasTexture.size;
          }
          const ja = Tn(Fe, 1, g.transform.zoom), _o = br(Qe.posMatrix, de, te, g.transform, ja), Vi = Wr(Qe.posMatrix, de, te, g.transform, ja), ha = Be && bt.hasTextData(), Fu = f.layout.get("icon-text-fit") !== "none" && ha && bt.hasIconData();
          if (be) {
            const vo = g.style.terrain ? (Cf, ll) => g.style.terrain.getElevation(Qe, Cf, ll) : null, vs = f.layout.get("text-rotation-alignment") === "map";
            Ir(bt, Qe.posMatrix, g, _, _o, Vi, de, D, vs, vo);
          }
          const Yn = g.translatePosMatrix(Qe.posMatrix, Fe, b, M), hr = be || _ && Be || Fu ? i_ : _o, Nr = g.translatePosMatrix(Vi, Fe, b, M, !0), ai = er && f.paint.get(_ ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let si;
          si = er ? bt.iconsInText ? vp(sr.kind, $r, Se, de, g, Yn, hr, Nr, Pr, Lo) : wu(sr.kind, $r, Se, de, g, Yn, hr, Nr, _, Pr, !0) : Qh(sr.kind, $r, Se, de, g, Yn, hr, Nr, _, Pr);
          const bn = { program: Ur, buffers: ht, uniformValues: si, atlasTexture: Gr, atlasTextureIcon: Ho, atlasInterpolation: oi, atlasInterpolationIcon: Zo, isSDF: er, hasHalo: ai };
          if (oe && bt.canOverlap) {
            Le = !0;
            const vo = ht.segments.get();
            for (const vs of vo)
              Ue.push({ segments: new s.SegmentVector([vs]), sortKey: vs.sortKey, state: bn, terrainData: Tr });
          } else
            Ue.push({ segments: ht.segments, sortKey: 0, state: bn, terrainData: Tr });
        }
        Le && Ue.sort((Qe, Fe) => Qe.sortKey - Fe.sortKey);
        for (const Qe of Ue) {
          const Fe = Qe.state;
          if (G.activeTexture.set(ie.TEXTURE0), Fe.atlasTexture.bind(Fe.atlasInterpolation, ie.CLAMP_TO_EDGE), Fe.atlasTextureIcon && (G.activeTexture.set(ie.TEXTURE1), Fe.atlasTextureIcon && Fe.atlasTextureIcon.bind(Fe.atlasInterpolationIcon, ie.CLAMP_TO_EDGE)), Fe.isSDF) {
            const bt = Fe.uniformValues;
            Fe.hasHalo && (bt.u_is_halo = 1, sc(Fe.buffers, Qe.segments, f, g, Fe.program, Ie, F, $, bt, Qe.terrainData)), bt.u_is_halo = 0;
          }
          sc(Fe.buffers, Qe.segments, f, g, Fe.program, Ie, F, $, Fe.uniformValues, Qe.terrainData);
        }
      }
      function sc(g, a, f, p, _, b, M, P, O, D) {
        const F = p.context;
        _.draw(F, F.gl.TRIANGLES, b, M, P, vn.disabled, O, D, f.id, g.layoutVertexBuffer, g.indexBuffer, a, f.paint, p.transform.zoom, g.programConfigurations.get(f.id), g.dynamicLayoutVertexBuffer, g.opacityVertexBuffer);
      }
      function lc(g, a, f, p, _, b, M) {
        const P = g.context.gl, O = f.paint.get("fill-pattern"), D = O && O.constantOr(1), F = f.getCrossfadeParameters();
        let $, G, ie, Q, te;
        M ? (G = D && !f.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", $ = P.LINES) : (G = D ? "fillPattern" : "fill", $ = P.TRIANGLES);
        for (const de of p) {
          const be = a.getTile(de);
          if (D && !be.patternsLoaded())
            continue;
          const Se = be.getBucket(f);
          if (!Se)
            continue;
          const oe = Se.programConfigurations.get(f.id), Le = g.useProgram(G, oe), Ie = g.style.terrain && g.style.terrain.getTerrainData(de);
          D && (g.context.activeTexture.set(P.TEXTURE0), be.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), oe.updatePaintBuffers(F));
          const Be = O.constantOr(null);
          if (Be && be.imageAtlas) {
            const Fe = be.imageAtlas, bt = Fe.patternPositions[Be.to.toString()], ht = Fe.patternPositions[Be.from.toString()];
            bt && ht && oe.setConstantPatternPositions(bt, ht);
          }
          const Ue = Ie ? de : null, Qe = g.translatePosMatrix(Ue ? Ue.posMatrix : de.posMatrix, be, f.paint.get("fill-translate"), f.paint.get("fill-translate-anchor"));
          if (M) {
            Q = Se.indexBuffer2, te = Se.segments2;
            const Fe = [P.drawingBufferWidth, P.drawingBufferHeight];
            ie = G === "fillOutlinePattern" && D ? mp(Qe, g, F, be, Fe) : pp(Qe, Fe);
          } else
            Q = Se.indexBuffer, te = Se.segments, ie = D ? Yh(Qe, g, F, be) : _u(Qe);
          Le.draw(g.context, $, _, g.stencilModeForClipping(de), b, vn.disabled, ie, Ie, f.id, Se.layoutVertexBuffer, Q, te, f.paint, g.transform.zoom, oe);
        }
      }
      function cc(g, a, f, p, _, b, M) {
        const P = g.context, O = P.gl, D = f.paint.get("fill-extrusion-pattern"), F = D.constantOr(1), $ = f.getCrossfadeParameters(), G = f.paint.get("fill-extrusion-opacity");
        for (const ie of p) {
          const Q = a.getTile(ie), te = Q.getBucket(f);
          if (!te)
            continue;
          const de = g.style.terrain && g.style.terrain.getTerrainData(ie), be = te.programConfigurations.get(f.id), Se = g.useProgram(F ? "fillExtrusionPattern" : "fillExtrusion", be);
          F && (g.context.activeTexture.set(O.TEXTURE0), Q.imageAtlasTexture.bind(O.LINEAR, O.CLAMP_TO_EDGE), be.updatePaintBuffers($));
          const oe = D.constantOr(null);
          if (oe && Q.imageAtlas) {
            const Ue = Q.imageAtlas, Qe = Ue.patternPositions[oe.to.toString()], Fe = Ue.patternPositions[oe.from.toString()];
            Qe && Fe && be.setConstantPatternPositions(Qe, Fe);
          }
          const Le = g.translatePosMatrix(ie.posMatrix, Q, f.paint.get("fill-extrusion-translate"), f.paint.get("fill-extrusion-translate-anchor")), Ie = f.paint.get("fill-extrusion-vertical-gradient"), Be = F ? Zy(Le, g, Ie, G, ie, $, Q) : Kh(Le, g, Ie, G);
          Se.draw(P, P.gl.TRIANGLES, _, b, M, vn.backCCW, Be, de, f.id, te.layoutVertexBuffer, te.indexBuffer, te.segments, f.paint, g.transform.zoom, be, g.style.terrain && te.centroidVertexBuffer);
        }
      }
      function df(g, a, f, p, _, b, M) {
        const P = g.context, O = P.gl, D = f.fbo;
        if (!D)
          return;
        const F = g.useProgram("hillshade"), $ = g.style.terrain && g.style.terrain.getTerrainData(a);
        P.activeTexture.set(O.TEXTURE0), O.bindTexture(O.TEXTURE_2D, D.colorAttachment.get()), F.draw(P, O.TRIANGLES, _, b, M, vn.disabled, ((G, ie, Q, te) => {
          const de = Q.paint.get("hillshade-shadow-color"), be = Q.paint.get("hillshade-highlight-color"), Se = Q.paint.get("hillshade-accent-color");
          let oe = Q.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          Q.paint.get("hillshade-illumination-anchor") === "viewport" && (oe -= G.transform.angle);
          const Le = !G.options.moving;
          return { u_matrix: te ? te.posMatrix : G.transform.calculatePosMatrix(ie.tileID.toUnwrapped(), Le), u_image: 0, u_latrange: xu(0, ie.tileID), u_light: [Q.paint.get("hillshade-exaggeration"), oe], u_shadow: de, u_highlight: be, u_accent: Se };
        })(g, f, p, $ ? a : null), $, p.id, g.rasterBoundsBuffer, g.quadTriangleIndexBuffer, g.rasterBoundsSegments);
      }
      function Pp(g, a, f, p, _, b) {
        const M = g.context, P = M.gl, O = a.dem;
        if (O && O.data) {
          const D = O.dim, F = O.stride, $ = O.getPixels();
          if (M.activeTexture.set(P.TEXTURE1), M.pixelStoreUnpackPremultiplyAlpha.set(!1), a.demTexture = a.demTexture || g.getTileTexture(F), a.demTexture) {
            const ie = a.demTexture;
            ie.update($, { premultiply: !1 }), ie.bind(P.NEAREST, P.CLAMP_TO_EDGE);
          } else
            a.demTexture = new B(M, $, P.RGBA, { premultiply: !1 }), a.demTexture.bind(P.NEAREST, P.CLAMP_TO_EDGE);
          M.activeTexture.set(P.TEXTURE0);
          let G = a.fbo;
          if (!G) {
            const ie = new B(M, { width: D, height: D, data: null }, P.RGBA);
            ie.bind(P.LINEAR, P.CLAMP_TO_EDGE), G = a.fbo = M.createFramebuffer(D, D, !0), G.colorAttachment.set(ie.texture);
          }
          M.bindFramebuffer.set(G.framebuffer), M.viewport.set([0, 0, D, D]), g.useProgram("hillshadePrepare").draw(M, P.TRIANGLES, p, _, b, vn.disabled, ((ie, Q) => {
            const te = Q.stride, de = s.create();
            return s.ortho(de, 0, s.EXTENT, -s.EXTENT, 0, 0, 1), s.translate(de, de, [0, -s.EXTENT, 0]), { u_matrix: de, u_image: 1, u_dimension: [te, te], u_zoom: ie.overscaledZ, u_unpack: Q.getUnpackVector() };
          })(a.tileID, O), null, f.id, g.rasterBoundsBuffer, g.quadTriangleIndexBuffer, g.rasterBoundsSegments), a.needsHillshadePrepare = !1;
        }
      }
      function Au(g, a, f, p, _, b) {
        const M = p.paint.get("raster-fade-duration");
        if (!b && M > 0) {
          const P = s.exported.now(), O = (P - g.timeAdded) / M, D = a ? (P - a.timeAdded) / M : -1, F = f.getSource(), $ = _.coveringZoomLevel({ tileSize: F.tileSize, roundZoom: F.roundZoom }), G = !a || Math.abs(a.tileID.overscaledZ - $) > Math.abs(g.tileID.overscaledZ - $), ie = G && g.refreshedUponExpiration ? 1 : s.clamp(G ? O : 1 - D, 0, 1);
          return g.refreshedUponExpiration && O >= 1 && (g.refreshedUponExpiration = !1), a ? { opacity: 1, mix: 1 - ie } : { opacity: ie, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const Ou = new s.Color(1, 0, 0, 1), Ro = new s.Color(0, 1, 0, 1), Ap = new s.Color(0, 0, 1, 1), pf = new s.Color(1, 0, 1, 1), Op = new s.Color(0, 1, 1, 1);
      function gs(g, a, f, p) {
        nl(g, 0, a + f / 2, g.transform.width, f, p);
      }
      function uc(g, a, f, p) {
        nl(g, a - f / 2, 0, f, g.transform.height, p);
      }
      function nl(g, a, f, p, _, b) {
        const M = g.context, P = M.gl;
        P.enable(P.SCISSOR_TEST), P.scissor(a * g.pixelRatio, f * g.pixelRatio, p * g.pixelRatio, _ * g.pixelRatio), M.clear({ color: b }), P.disable(P.SCISSOR_TEST);
      }
      function s_(g, a, f) {
        const p = g.context, _ = p.gl, b = f.posMatrix, M = g.useProgram("debug"), P = yr.disabled, O = sn.disabled, D = g.colorModeForRenderPass(), F = "$debug", $ = g.style.terrain && g.style.terrain.getTerrainData(f);
        p.activeTexture.set(_.TEXTURE0), g.emptyTexture.bind(_.LINEAR, _.CLAMP_TO_EDGE);
        const G = a.getTileByID(f.key).latestRawTileData, ie = Math.floor((G && G.byteLength || 0) / 1024), Q = a.getTile(f).tileSize, te = 512 / Math.min(Q, 512) * (f.overscaledZ / g.transform.zoom) * 0.5;
        let de = f.canonical.toString();
        f.overscaledZ !== f.canonical.z && (de += ` => ${f.overscaledZ}`), function(be, Se) {
          be.initDebugOverlayCanvas();
          const oe = be.debugOverlayCanvas, Le = be.context.gl, Ie = be.debugOverlayCanvas.getContext("2d");
          Ie.clearRect(0, 0, oe.width, oe.height), Ie.shadowColor = "white", Ie.shadowBlur = 2, Ie.lineWidth = 1.5, Ie.strokeStyle = "white", Ie.textBaseline = "top", Ie.font = "bold 36px Open Sans, sans-serif", Ie.fillText(Se, 5, 5), Ie.strokeText(Se, 5, 5), be.debugOverlayTexture.update(oe), be.debugOverlayTexture.bind(Le.LINEAR, Le.CLAMP_TO_EDGE);
        }(g, `${de} ${ie}kB`), M.draw(p, _.TRIANGLES, P, O, hn.alphaBlended, vn.disabled, tc(b, s.Color.transparent, te), null, F, g.debugBuffer, g.quadTriangleIndexBuffer, g.debugSegments), M.draw(p, _.LINE_STRIP, P, O, D, vn.disabled, tc(b, s.Color.red), $, F, g.debugBuffer, g.tileBorderIndexBuffer, g.debugSegments);
      }
      function Ru(g, a, f) {
        const p = g.context, _ = p.gl, b = g.colorModeForRenderPass(), M = new yr(_.LEQUAL, yr.ReadWrite, g.depthRangeFor3D), P = g.useProgram("terrain"), O = a.getTerrainMesh(), D = a.getTerrainData(f.tileID);
        p.bindFramebuffer.set(null), p.viewport.set([0, 0, g.width, g.height]), p.activeTexture.set(_.TEXTURE0), _.bindTexture(_.TEXTURE_2D, a.getRTTFramebuffer().colorAttachment.get());
        const F = g.transform.calculatePosMatrix(f.tileID.toUnwrapped());
        P.draw(p, _.TRIANGLES, M, sn.disabled, b, vn.backCCW, { u_matrix: F, u_texture: 0 }, D, "terrain", O.vertexBuffer, O.indexBuffer, O.segments);
      }
      function Rp(g, a, f, p) {
        const _ = g.context, b = f.tileSize * a.qualityFactor;
        f.textures[p] || (f.textures[p] = g.getTileTexture(b) || new B(_, { width: b, height: b, data: null }, _.gl.RGBA), f.textures[p].bind(_.gl.LINEAR, _.gl.CLAMP_TO_EDGE), p === 0 && a.sourceCache.renderHistory.unshift(f.tileID.key));
        const M = a.getRTTFramebuffer();
        M.colorAttachment.set(f.textures[p].texture), _.bindFramebuffer.set(M.framebuffer), _.viewport.set([0, 0, b, b]);
      }
      class Lp {
        constructor(a) {
          this._coordsDescendingInv = {}, this._coordsDescendingInvStr = {}, this.painter = a, this._renderToTexture = { background: !0, fill: !0, line: !0, raster: !0 }, this._coordsDescendingInv = {}, this._coordsDescendingInvStr = {}, this._stacks = [], this._prevType = null, this._rerender = {}, this._renderableTiles = a.style.terrain.sourceCache.getRenderableTiles(), this._init();
        }
        _init() {
          const a = this.painter.style, f = a.terrain;
          for (const p in a.sourceCaches) {
            this._coordsDescendingInv[p] = {};
            const _ = a.sourceCaches[p].getVisibleCoordinates();
            for (const b of _) {
              const M = f.sourceCache.getTerrainCoords(b);
              for (const P in M)
                this._coordsDescendingInv[p][P] || (this._coordsDescendingInv[p][P] = []), this._coordsDescendingInv[p][P].push(M[P]);
            }
          }
          for (const p of a._order) {
            const _ = a._layers[p], b = _.source;
            if (this._renderToTexture[_.type] && !this._coordsDescendingInvStr[b]) {
              this._coordsDescendingInvStr[b] = {};
              for (const M in this._coordsDescendingInv[b])
                this._coordsDescendingInvStr[b][M] = this._coordsDescendingInv[b][M].map((P) => P.key).sort().join();
            }
          }
          return this._renderableTiles.forEach((p) => {
            for (const _ in this._coordsDescendingInvStr) {
              const b = this._coordsDescendingInvStr[_][p.tileID.key];
              b && b !== p.textureCoords[_] && p.clearTextures(this.painter), f.needsRerender(_, p.tileID) && p.clearTextures(this.painter);
            }
            this._rerender[p.tileID.key] = !p.textures.length;
          }), f.clearRerenderCache(), f.sourceCache.removeOutdated(this.painter), this;
        }
        renderLayer(a) {
          const f = a.type, p = this.painter, _ = p.style._order, b = p.currentLayer, M = b + 1 === _.length;
          if (this._renderToTexture[f] && (this._prevType && this._renderToTexture[this._prevType] || this._stacks.push([]), this._prevType = f, this._stacks[this._stacks.length - 1].push(_[b]), !M))
            return !0;
          if (this._renderToTexture[this._prevType] || f === "hillshade" || this._renderToTexture[f] && M) {
            this._prevType = f;
            const P = this._stacks.length - 1, O = this._stacks[P] || [];
            for (const D of this._renderableTiles) {
              if (Rp(p, p.style.terrain, D, P), this._rerender[D.tileID.key]) {
                p.context.clear({ color: s.Color.transparent });
                for (let F = 0; F < O.length; F++) {
                  const $ = p.style._layers[O[F]], G = $.source ? this._coordsDescendingInv[$.source][D.tileID.key] : [D.tileID];
                  p._renderTileClippingMasks($, G), p.renderLayer(p, p.style.sourceCaches[$.source], $, G), $.source && (D.textureCoords[$.source] = this._coordsDescendingInvStr[$.source][D.tileID.key]);
                }
              }
              Ru(p, p.style.terrain, D);
            }
            if (f === "hillshade") {
              this._stacks.push([_[b]]);
              for (const D of this._renderableTiles) {
                const F = this._coordsDescendingInv[a.source][D.tileID.key];
                Rp(p, p.style.terrain, D, this._stacks.length - 1), p.context.clear({ color: s.Color.transparent }), p._renderTileClippingMasks(a, F), p.renderLayer(p, p.style.sourceCaches[a.source], a, F), Ru(p, p.style.terrain, D);
              }
              return !0;
            }
            return this._renderToTexture[f];
          }
          return !1;
        }
      }
      const hc = { symbol: function(g, a, f, p, _) {
        if (g.renderPass !== "translucent")
          return;
        const b = sn.disabled, M = g.colorModeForRenderPass();
        f.layout.get("text-variable-anchor") && function(P, O, D, F, $, G, ie) {
          const Q = O.transform, te = $ === "map", de = G === "map";
          for (const be of P) {
            const Se = F.getTile(be), oe = Se.getBucket(D);
            if (!oe || !oe.text || !oe.text.segments.get().length)
              continue;
            const Le = s.evaluateSizeForZoom(oe.textSizeData, Q.zoom), Ie = Tn(Se, 1, O.transform.zoom), Be = br(be.posMatrix, de, te, O.transform, Ie), Ue = D.layout.get("icon-text-fit") !== "none" && oe.hasIconData();
            if (Le) {
              const Qe = Math.pow(2, Q.zoom - Se.tileID.overscaledZ);
              Ip(oe, te, de, ie, Q, Be, be.posMatrix, Qe, Le, Ue, O.style.terrain ? (Fe, bt) => O.style.terrain.getElevation(be, Fe, bt) : null);
            }
          }
        }(p, g, f, a, f.layout.get("text-rotation-alignment"), f.layout.get("text-pitch-alignment"), _), f.paint.get("icon-opacity").constantOr(1) !== 0 && Pu(g, a, f, p, !1, f.paint.get("icon-translate"), f.paint.get("icon-translate-anchor"), f.layout.get("icon-rotation-alignment"), f.layout.get("icon-pitch-alignment"), f.layout.get("icon-keep-upright"), b, M), f.paint.get("text-opacity").constantOr(1) !== 0 && Pu(g, a, f, p, !0, f.paint.get("text-translate"), f.paint.get("text-translate-anchor"), f.layout.get("text-rotation-alignment"), f.layout.get("text-pitch-alignment"), f.layout.get("text-keep-upright"), b, M), a.map.showCollisionBoxes && (rl(g, a, f, p, f.paint.get("text-translate"), f.paint.get("text-translate-anchor"), !0), rl(g, a, f, p, f.paint.get("icon-translate"), f.paint.get("icon-translate-anchor"), !1));
      }, circle: function(g, a, f, p) {
        if (g.renderPass !== "translucent")
          return;
        const _ = f.paint.get("circle-opacity"), b = f.paint.get("circle-stroke-width"), M = f.paint.get("circle-stroke-opacity"), P = !f.layout.get("circle-sort-key").isConstant();
        if (_.constantOr(1) === 0 && (b.constantOr(1) === 0 || M.constantOr(1) === 0))
          return;
        const O = g.context, D = O.gl, F = g.depthModeForSublayer(0, yr.ReadOnly), $ = sn.disabled, G = g.colorModeForRenderPass(), ie = [];
        for (let Q = 0; Q < p.length; Q++) {
          const te = p[Q], de = a.getTile(te), be = de.getBucket(f);
          if (!be)
            continue;
          const Se = be.programConfigurations.get(f.id), oe = g.useProgram("circle", Se), Le = be.layoutVertexBuffer, Ie = be.indexBuffer, Be = g.style.terrain && g.style.terrain.getTerrainData(te), Ue = { programConfiguration: Se, program: oe, layoutVertexBuffer: Le, indexBuffer: Ie, uniformValues: gp(g, te, de, f), terrainData: Be };
          if (P) {
            const Qe = be.segments.get();
            for (const Fe of Qe)
              ie.push({ segments: new s.SegmentVector([Fe]), sortKey: Fe.sortKey, state: Ue });
          } else
            ie.push({ segments: be.segments, sortKey: 0, state: Ue });
        }
        P && ie.sort((Q, te) => Q.sortKey - te.sortKey);
        for (const Q of ie) {
          const { programConfiguration: te, program: de, layoutVertexBuffer: be, indexBuffer: Se, uniformValues: oe, terrainData: Le } = Q.state;
          de.draw(O, D.TRIANGLES, F, $, G, vn.disabled, oe, Le, f.id, be, Se, Q.segments, f.paint, g.transform.zoom, te);
        }
      }, heatmap: function(g, a, f, p) {
        if (f.paint.get("heatmap-opacity") !== 0)
          if (g.renderPass === "offscreen") {
            const _ = g.context, b = _.gl, M = sn.disabled, P = new hn([b.ONE, b.ONE], s.Color.transparent, [!0, !0, !0, !0]);
            (function(O, D, F) {
              const $ = O.gl;
              O.activeTexture.set($.TEXTURE1), O.viewport.set([0, 0, D.width / 4, D.height / 4]);
              let G = F.heatmapFbo;
              if (G)
                $.bindTexture($.TEXTURE_2D, G.colorAttachment.get()), O.bindFramebuffer.set(G.framebuffer);
              else {
                const ie = $.createTexture();
                $.bindTexture($.TEXTURE_2D, ie), $.texParameteri($.TEXTURE_2D, $.TEXTURE_WRAP_S, $.CLAMP_TO_EDGE), $.texParameteri($.TEXTURE_2D, $.TEXTURE_WRAP_T, $.CLAMP_TO_EDGE), $.texParameteri($.TEXTURE_2D, $.TEXTURE_MIN_FILTER, $.LINEAR), $.texParameteri($.TEXTURE_2D, $.TEXTURE_MAG_FILTER, $.LINEAR), G = F.heatmapFbo = O.createFramebuffer(D.width / 4, D.height / 4, !1), function(Q, te, de, be) {
                  const Se = Q.gl;
                  Se.texImage2D(Se.TEXTURE_2D, 0, Se.RGBA, te.width / 4, te.height / 4, 0, Se.RGBA, Q.extRenderToTextureHalfFloat ? Q.extTextureHalfFloat.HALF_FLOAT_OES : Se.UNSIGNED_BYTE, null), be.colorAttachment.set(de);
                }(O, D, ie, G);
              }
            })(_, g, f), _.clear({ color: s.Color.transparent });
            for (let O = 0; O < p.length; O++) {
              const D = p[O];
              if (a.hasRenderableParent(D))
                continue;
              const F = a.getTile(D), $ = F.getBucket(f);
              if (!$)
                continue;
              const G = $.programConfigurations.get(f.id), ie = g.useProgram("heatmap", G), { zoom: Q } = g.transform;
              ie.draw(_, b.TRIANGLES, yr.disabled, M, P, vn.disabled, vu(D.posMatrix, F, Q, f.paint.get("heatmap-intensity")), null, f.id, $.layoutVertexBuffer, $.indexBuffer, $.segments, f.paint, g.transform.zoom, G);
            }
            _.viewport.set([0, 0, g.width, g.height]);
          } else
            g.renderPass === "translucent" && (g.context.setColorMode(g.colorModeForRenderPass()), function(_, b) {
              const M = _.context, P = M.gl, O = b.heatmapFbo;
              if (!O)
                return;
              M.activeTexture.set(P.TEXTURE0), P.bindTexture(P.TEXTURE_2D, O.colorAttachment.get()), M.activeTexture.set(P.TEXTURE1);
              let D = b.colorRampTexture;
              D || (D = b.colorRampTexture = new B(M, b.colorRamp, P.RGBA)), D.bind(P.LINEAR, P.CLAMP_TO_EDGE), _.useProgram("heatmapTexture").draw(M, P.TRIANGLES, yr.disabled, sn.disabled, _.colorModeForRenderPass(), vn.disabled, ((F, $, G, ie) => {
                const Q = s.create();
                s.ortho(Q, 0, F.width, F.height, 0, 0, 1);
                const te = F.context.gl;
                return { u_matrix: Q, u_world: [te.drawingBufferWidth, te.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: $.paint.get("heatmap-opacity") };
              })(_, b), null, b.id, _.viewportBuffer, _.quadTriangleIndexBuffer, _.viewportSegments, b.paint, _.transform.zoom);
            }(g, f));
      }, line: function(g, a, f, p) {
        if (g.renderPass !== "translucent")
          return;
        const _ = f.paint.get("line-opacity"), b = f.paint.get("line-width");
        if (_.constantOr(1) === 0 || b.constantOr(1) === 0)
          return;
        const M = g.depthModeForSublayer(0, yr.ReadOnly), P = g.colorModeForRenderPass(), O = f.paint.get("line-dasharray"), D = f.paint.get("line-pattern"), F = D.constantOr(1), $ = f.paint.get("line-gradient"), G = f.getCrossfadeParameters(), ie = F ? "linePattern" : O ? "lineSDF" : $ ? "lineGradient" : "line", Q = g.context, te = Q.gl;
        let de = !0;
        for (const be of p) {
          const Se = a.getTile(be);
          if (F && !Se.patternsLoaded())
            continue;
          const oe = Se.getBucket(f);
          if (!oe)
            continue;
          const Le = oe.programConfigurations.get(f.id), Ie = g.context.program.get(), Be = g.useProgram(ie, Le), Ue = de || Be.program !== Ie, Qe = g.style.terrain && g.style.terrain.getTerrainData(be), Fe = D.constantOr(null);
          if (Fe && Se.imageAtlas) {
            const wt = Se.imageAtlas, er = wt.patternPositions[Fe.to.toString()], sr = wt.patternPositions[Fe.from.toString()];
            er && sr && Le.setConstantPatternPositions(er, sr);
          }
          const bt = Qe ? be : null, ht = F ? bu(g, Se, f, G, bt) : O ? rc(g, Se, f, O, G, bt) : $ ? Jh(g, Se, f, oe.lineClipsArray.length, bt) : Js(g, Se, f, bt);
          if (F)
            Q.activeTexture.set(te.TEXTURE0), Se.imageAtlasTexture.bind(te.LINEAR, te.CLAMP_TO_EDGE), Le.updatePaintBuffers(G);
          else if (O && (Ue || g.lineAtlas.dirty))
            Q.activeTexture.set(te.TEXTURE0), g.lineAtlas.bind(Q);
          else if ($) {
            const wt = oe.gradients[f.id];
            let er = wt.texture;
            if (f.gradientVersion !== wt.version) {
              let sr = 256;
              if (f.stepInterpolant) {
                const zt = a.getSource().maxzoom, Ur = be.canonical.z === zt ? Math.ceil(1 << g.transform.maxZoom - be.canonical.z) : 1;
                sr = s.clamp(s.nextPowerOfTwo(oe.maxLineLength / s.EXTENT * 1024 * Ur), 256, Q.maxTextureSize);
              }
              wt.gradient = s.renderColorRamp({ expression: f.gradientExpression(), evaluationKey: "lineProgress", resolution: sr, image: wt.gradient || void 0, clips: oe.lineClipsArray }), wt.texture ? wt.texture.update(wt.gradient) : wt.texture = new B(Q, wt.gradient, te.RGBA), wt.version = f.gradientVersion, er = wt.texture;
            }
            Q.activeTexture.set(te.TEXTURE0), er.bind(f.stepInterpolant ? te.NEAREST : te.LINEAR, te.CLAMP_TO_EDGE);
          }
          Be.draw(Q, te.TRIANGLES, M, g.stencilModeForClipping(be), P, vn.disabled, ht, Qe, f.id, oe.layoutVertexBuffer, oe.indexBuffer, oe.segments, f.paint, g.transform.zoom, Le, oe.layoutVertexBuffer2), de = !1;
        }
      }, fill: function(g, a, f, p) {
        const _ = f.paint.get("fill-color"), b = f.paint.get("fill-opacity");
        if (b.constantOr(1) === 0)
          return;
        const M = g.colorModeForRenderPass(), P = f.paint.get("fill-pattern"), O = g.opaquePassEnabledForLayer() && !P.constantOr(1) && _.constantOr(s.Color.transparent).a === 1 && b.constantOr(0) === 1 ? "opaque" : "translucent";
        if (g.renderPass === O) {
          const D = g.depthModeForSublayer(1, g.renderPass === "opaque" ? yr.ReadWrite : yr.ReadOnly);
          lc(g, a, f, p, D, M, !1);
        }
        if (g.renderPass === "translucent" && f.paint.get("fill-antialias")) {
          const D = g.depthModeForSublayer(f.getPaintProperty("fill-outline-color") ? 2 : 0, yr.ReadOnly);
          lc(g, a, f, p, D, M, !0);
        }
      }, "fill-extrusion": function(g, a, f, p) {
        const _ = f.paint.get("fill-extrusion-opacity");
        if (_ !== 0 && g.renderPass === "translucent") {
          const b = new yr(g.context.gl.LEQUAL, yr.ReadWrite, g.depthRangeFor3D);
          if (_ !== 1 || f.paint.get("fill-extrusion-pattern").constantOr(1))
            cc(g, a, f, p, b, sn.disabled, hn.disabled), cc(g, a, f, p, b, g.stencilModeFor3D(), g.colorModeForRenderPass());
          else {
            const M = g.colorModeForRenderPass();
            cc(g, a, f, p, b, sn.disabled, M);
          }
        }
      }, hillshade: function(g, a, f, p) {
        if (g.renderPass !== "offscreen" && g.renderPass !== "translucent")
          return;
        const _ = g.context, b = g.depthModeForSublayer(0, yr.ReadOnly), M = g.colorModeForRenderPass(), [P, O] = g.renderPass === "translucent" ? g.stencilConfigForOverlap(p) : [{}, p];
        for (const D of O) {
          const F = a.getTile(D);
          F.needsHillshadePrepare !== void 0 && F.needsHillshadePrepare && g.renderPass === "offscreen" ? Pp(g, F, f, b, sn.disabled, M) : g.renderPass === "translucent" && df(g, D, F, f, b, P[D.overscaledZ], M);
        }
        _.viewport.set([0, 0, g.width, g.height]);
      }, raster: function(g, a, f, p) {
        if (g.renderPass !== "translucent" || f.paint.get("raster-opacity") === 0 || !p.length)
          return;
        const _ = g.context, b = _.gl, M = a.getSource(), P = g.useProgram("raster"), O = g.colorModeForRenderPass(), [D, F] = M instanceof kt ? [{}, p] : g.stencilConfigForOverlap(p), $ = F[F.length - 1].overscaledZ, G = !g.options.moving;
        for (const ie of F) {
          const Q = g.depthModeForSublayer(ie.overscaledZ - $, f.paint.get("raster-opacity") === 1 ? yr.ReadWrite : yr.ReadOnly, b.LESS), te = a.getTile(ie);
          te.registerFadeDuration(f.paint.get("raster-fade-duration"));
          const de = a.findLoadedParent(ie, 0), be = Au(te, de, a, f, g.transform, g.style.terrain);
          let Se, oe;
          const Le = f.paint.get("raster-resampling") === "nearest" ? b.NEAREST : b.LINEAR;
          _.activeTexture.set(b.TEXTURE0), te.texture.bind(Le, b.CLAMP_TO_EDGE, b.LINEAR_MIPMAP_NEAREST), _.activeTexture.set(b.TEXTURE1), de ? (de.texture.bind(Le, b.CLAMP_TO_EDGE, b.LINEAR_MIPMAP_NEAREST), Se = Math.pow(2, de.tileID.overscaledZ - te.tileID.overscaledZ), oe = [te.tileID.canonical.x * Se % 1, te.tileID.canonical.y * Se % 1]) : te.texture.bind(Le, b.CLAMP_TO_EDGE, b.LINEAR_MIPMAP_NEAREST);
          const Ie = g.style.terrain && g.style.terrain.getTerrainData(ie), Be = Ie ? ie : null, Ue = Be ? Be.posMatrix : g.transform.calculatePosMatrix(ie.toUnwrapped(), G), Qe = yp(Ue, oe || [0, 0], Se || 1, be, f);
          M instanceof kt ? P.draw(_, b.TRIANGLES, Q, sn.disabled, O, vn.disabled, Qe, Ie, f.id, M.boundsBuffer, g.quadTriangleIndexBuffer, M.boundsSegments) : P.draw(_, b.TRIANGLES, Q, D[ie.overscaledZ], O, vn.disabled, Qe, Ie, f.id, g.rasterBoundsBuffer, g.quadTriangleIndexBuffer, g.rasterBoundsSegments);
        }
      }, background: function(g, a, f, p) {
        const _ = f.paint.get("background-color"), b = f.paint.get("background-opacity");
        if (b === 0)
          return;
        const M = g.context, P = M.gl, O = g.transform, D = O.tileSize, F = f.paint.get("background-pattern");
        if (g.isPatternMissing(F))
          return;
        const $ = !F && _.a === 1 && b === 1 && g.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (g.renderPass !== $)
          return;
        const G = sn.disabled, ie = g.depthModeForSublayer(0, $ === "opaque" ? yr.ReadWrite : yr.ReadOnly), Q = g.colorModeForRenderPass(), te = g.useProgram(F ? "backgroundPattern" : "background"), de = p || O.coveringTiles({ tileSize: D, terrain: g.style.terrain });
        F && (M.activeTexture.set(P.TEXTURE0), g.imageManager.bind(g.context));
        const be = f.getCrossfadeParameters();
        for (const Se of de) {
          const oe = p ? Se.posMatrix : g.transform.calculatePosMatrix(Se.toUnwrapped()), Le = F ? Ky(oe, b, g, F, { tileID: Se, tileSize: D }, be) : Hy(oe, b, _), Ie = g.style.terrain && g.style.terrain.getTerrainData(Se);
          te.draw(M, P.TRIANGLES, ie, G, Q, vn.disabled, Le, Ie, f.id, g.tileExtentBuffer, g.quadTriangleIndexBuffer, g.tileExtentSegments);
        }
      }, debug: function(g, a, f) {
        for (let p = 0; p < f.length; p++)
          s_(g, a, f[p]);
      }, custom: function(g, a, f) {
        const p = g.context, _ = f.implementation;
        if (g.renderPass === "offscreen") {
          const b = _.prerender;
          b && (g.setCustomLayerDefaults(), p.setColorMode(g.colorModeForRenderPass()), b.call(_, p.gl, g.transform.customLayerMatrix()), p.setDirty(), g.setBaseState());
        } else if (g.renderPass === "translucent") {
          g.setCustomLayerDefaults(), p.setColorMode(g.colorModeForRenderPass()), p.setStencilMode(sn.disabled);
          const b = _.renderingMode === "3d" ? new yr(g.context.gl.LEQUAL, yr.ReadWrite, g.depthRangeFor3D) : g.depthModeForSublayer(0, yr.ReadOnly);
          p.setDepthMode(b), _.render(p.gl, g.transform.customLayerMatrix()), p.setDirty(), g.setBaseState(), p.bindFramebuffer.set(null);
        }
      } };
      class mf {
        constructor(a, f) {
          this.context = new Cp(a), this.transform = f, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: s.create(), renderTime: 0 }, this.setup(), this.numSublayers = an.maxUnderzooming + an.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Pt(), this.gpuTimers = {};
        }
        resize(a, f, p) {
          if (this.width = a * p, this.height = f * p, this.pixelRatio = p, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const _ of this.style._order)
              this.style._layers[_].resize();
        }
        setup() {
          const a = this.context, f = new s.PosArray();
          f.emplaceBack(0, 0), f.emplaceBack(s.EXTENT, 0), f.emplaceBack(0, s.EXTENT), f.emplaceBack(s.EXTENT, s.EXTENT), this.tileExtentBuffer = a.createVertexBuffer(f, ur.members), this.tileExtentSegments = s.SegmentVector.simpleSegment(0, 0, 4, 2);
          const p = new s.PosArray();
          p.emplaceBack(0, 0), p.emplaceBack(s.EXTENT, 0), p.emplaceBack(0, s.EXTENT), p.emplaceBack(s.EXTENT, s.EXTENT), this.debugBuffer = a.createVertexBuffer(p, ur.members), this.debugSegments = s.SegmentVector.simpleSegment(0, 0, 4, 5);
          const _ = new s.RasterBoundsArray();
          _.emplaceBack(0, 0, 0, 0), _.emplaceBack(s.EXTENT, 0, s.EXTENT, 0), _.emplaceBack(0, s.EXTENT, 0, s.EXTENT), _.emplaceBack(s.EXTENT, s.EXTENT, s.EXTENT, s.EXTENT), this.rasterBoundsBuffer = a.createVertexBuffer(_, it.members), this.rasterBoundsSegments = s.SegmentVector.simpleSegment(0, 0, 4, 2);
          const b = new s.PosArray();
          b.emplaceBack(0, 0), b.emplaceBack(1, 0), b.emplaceBack(0, 1), b.emplaceBack(1, 1), this.viewportBuffer = a.createVertexBuffer(b, ur.members), this.viewportSegments = s.SegmentVector.simpleSegment(0, 0, 4, 2);
          const M = new s.LineStripIndexArray();
          M.emplaceBack(0), M.emplaceBack(1), M.emplaceBack(3), M.emplaceBack(2), M.emplaceBack(0), this.tileBorderIndexBuffer = a.createIndexBuffer(M);
          const P = new s.TriangleIndexArray();
          P.emplaceBack(0, 1, 2), P.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = a.createIndexBuffer(P), this.emptyTexture = new B(a, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, a.gl.RGBA);
          const O = this.context.gl;
          this.stencilClearMode = new sn({ func: O.ALWAYS, mask: 0 }, 0, 255, O.ZERO, O.ZERO, O.ZERO);
        }
        clearStencil() {
          const a = this.context, f = a.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const p = s.create();
          s.ortho(p, 0, this.width, this.height, 0, 0, 1), s.scale(p, p, [f.drawingBufferWidth, f.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(a, f.TRIANGLES, yr.disabled, this.stencilClearMode, hn.disabled, vn.disabled, Ys(p), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(a, f) {
          if (this.currentStencilSource === a.source || !a.isTileClipped() || !f || !f.length)
            return;
          this.currentStencilSource = a.source;
          const p = this.context, _ = p.gl;
          this.nextStencilID + f.length > 256 && this.clearStencil(), p.setColorMode(hn.disabled), p.setDepthMode(yr.disabled);
          const b = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const M of f) {
            const P = this._tileClippingMaskIDs[M.key] = this.nextStencilID++, O = this.style.terrain && this.style.terrain.getTerrainData(M);
            b.draw(p, _.TRIANGLES, yr.disabled, new sn({ func: _.ALWAYS, mask: 0 }, P, 255, _.KEEP, _.KEEP, _.REPLACE), hn.disabled, vn.disabled, Ys(M.posMatrix), O, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const a = this.nextStencilID++, f = this.context.gl;
          return new sn({ func: f.NOTEQUAL, mask: 255 }, a, 255, f.KEEP, f.KEEP, f.REPLACE);
        }
        stencilModeForClipping(a) {
          const f = this.context.gl;
          return new sn({ func: f.EQUAL, mask: 255 }, this._tileClippingMaskIDs[a.key], 0, f.KEEP, f.KEEP, f.REPLACE);
        }
        stencilConfigForOverlap(a) {
          const f = this.context.gl, p = a.sort((M, P) => P.overscaledZ - M.overscaledZ), _ = p[p.length - 1].overscaledZ, b = p[0].overscaledZ - _ + 1;
          if (b > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + b > 256 && this.clearStencil();
            const M = {};
            for (let P = 0; P < b; P++)
              M[P + _] = new sn({ func: f.GEQUAL, mask: 255 }, P + this.nextStencilID, 255, f.KEEP, f.KEEP, f.REPLACE);
            return this.nextStencilID += b, [M, p];
          }
          return [{ [_]: sn.disabled }, p];
        }
        colorModeForRenderPass() {
          const a = this.context.gl;
          return this._showOverdrawInspector ? new hn([a.CONSTANT_COLOR, a.ONE], new s.Color(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? hn.unblended : hn.alphaBlended;
        }
        depthModeForSublayer(a, f, p) {
          if (!this.opaquePassEnabledForLayer())
            return yr.disabled;
          const _ = 1 - ((1 + this.currentLayer) * this.numSublayers + a) * this.depthEpsilon;
          return new yr(p || this.context.gl.LEQUAL, f, [_, _]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(a, f) {
          this.style = a, this.options = f, this.lineAtlas = a.lineAtlas, this.imageManager = a.imageManager, this.glyphManager = a.glyphManager, this.symbolFadeChange = a.placement.symbolFadeChange(s.exported.now()), this.imageManager.beginFrame();
          const p = this.style._order, _ = this.style.sourceCaches, b = this.style.terrain && new Lp(this);
          for (const D in _) {
            const F = _[D];
            F.used && F.prepare(this.context);
          }
          const M = {}, P = {}, O = {};
          for (const D in _) {
            const F = _[D];
            M[D] = F.getVisibleCoordinates(), P[D] = M[D].slice().reverse(), O[D] = F.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let D = 0; D < p.length; D++)
            if (this.style._layers[p[D]].is3D()) {
              this.opaquePassCutoff = D;
              break;
            }
          if (b) {
            this.opaquePassCutoff = 0;
            const D = this.style.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
            (this.terrainFacilitator.dirty || !s.equals(this.terrainFacilitator.matrix, this.transform.projMatrix) || D.length) && (s.copy(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(F, $) {
              const G = F.context, ie = G.gl, Q = hn.unblended, te = new yr(ie.LEQUAL, yr.ReadWrite, [0, 1]), de = $.getTerrainMesh(), be = $.sourceCache.getRenderableTiles(), Se = F.useProgram("terrainDepth");
              G.bindFramebuffer.set($.getFramebuffer("depth").framebuffer), G.viewport.set([0, 0, F.width / devicePixelRatio, F.height / devicePixelRatio]), G.clear({ color: s.Color.transparent, depth: 1 });
              for (const oe of be) {
                const Le = $.getTerrainData(oe.tileID), Ie = F.transform.calculatePosMatrix(oe.tileID.toUnwrapped());
                Se.draw(G, ie.TRIANGLES, te, sn.disabled, Q, vn.backCCW, { u_matrix: Ie }, Le, "terrain", de.vertexBuffer, de.indexBuffer, de.segments);
              }
              G.bindFramebuffer.set(null), G.viewport.set([0, 0, F.width, F.height]);
            }(this, this.style.terrain), function(F, $) {
              const G = F.context, ie = G.gl, Q = hn.unblended, te = new yr(ie.LEQUAL, yr.ReadWrite, [0, 1]), de = $.getTerrainMesh(), be = $.getCoordsTexture(), Se = $.sourceCache.getRenderableTiles(), oe = F.useProgram("terrainCoords");
              G.bindFramebuffer.set($.getFramebuffer("coords").framebuffer), G.viewport.set([0, 0, F.width / devicePixelRatio, F.height / devicePixelRatio]), G.clear({ color: s.Color.transparent, depth: 1 }), $.coordsIndex = [];
              for (const Le of Se) {
                const Ie = $.getTerrainData(Le.tileID);
                G.activeTexture.set(ie.TEXTURE0), ie.bindTexture(ie.TEXTURE_2D, be.texture);
                const Be = F.transform.calculatePosMatrix(Le.tileID.toUnwrapped());
                oe.draw(G, ie.TRIANGLES, te, sn.disabled, Q, vn.backCCW, { u_matrix: Be, u_terrain_coords_id: (255 - $.coordsIndex.length) / 255, u_texture: 0 }, Ie, "terrain", de.vertexBuffer, de.indexBuffer, de.segments), $.coordsIndex.push(Le.tileID.key);
              }
              G.bindFramebuffer.set(null), G.viewport.set([0, 0, F.width, F.height]);
            }(this, this.style.terrain));
          }
          this.renderPass = "offscreen";
          for (const D of p) {
            const F = this.style._layers[D];
            if (!F.hasOffscreenPass() || F.isHidden(this.transform.zoom))
              continue;
            const $ = P[F.source];
            (F.type === "custom" || $.length) && this.renderLayer(this, _[F.source], F, $);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: f.showOverdrawInspector ? s.Color.black : s.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = f.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (a._order.length + 2) * this.numSublayers * this.depthEpsilon], !b)
            for (this.renderPass = "opaque", this.currentLayer = p.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const D = this.style._layers[p[this.currentLayer]], F = _[D.source], $ = M[D.source];
              this._renderTileClippingMasks(D, $), this.renderLayer(this, F, D, $);
            }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < p.length; this.currentLayer++) {
            const D = this.style._layers[p[this.currentLayer]], F = _[D.source];
            if (b && b.renderLayer(D))
              continue;
            const $ = (D.type === "symbol" ? O : P)[D.source];
            this._renderTileClippingMasks(D, M[D.source]), this.renderLayer(this, F, D, $);
          }
          if (this.options.showTileBoundaries) {
            let D, F;
            Object.values(this.style._layers).forEach(($) => {
              $.source && !$.isHidden(this.transform.zoom) && ($.source !== (F && F.id) && (F = this.style.sourceCaches[$.source]), (!D || D.getSource().maxzoom < F.getSource().maxzoom) && (D = F));
            }), D && hc.debug(this, D, D.getVisibleCoordinates());
          }
          this.options.showPadding && function(D) {
            const F = D.transform.padding;
            gs(D, D.transform.height - (F.top || 0), 3, Ou), gs(D, F.bottom || 0, 3, Ro), uc(D, F.left || 0, 3, Ap), uc(D, D.transform.width - (F.right || 0), 3, pf);
            const $ = D.transform.centerPoint;
            (function(G, ie, Q, te) {
              nl(G, ie - 1, Q - 10, 2, 20, te), nl(G, ie - 10, Q - 1, 20, 2, te);
            })(D, $.x, D.transform.height - $.y, Op);
          }(this), this.context.setDefault();
        }
        renderLayer(a, f, p, _) {
          p.isHidden(this.transform.zoom) || (p.type === "background" || p.type === "custom" || (_ || []).length) && (this.id = p.id, this.gpuTimingStart(p), hc[p.type](a, f, p, _, this.style.placement.variableOffsets), this.gpuTimingEnd());
        }
        gpuTimingStart(a) {
          if (!this.options.gpuTiming)
            return;
          const f = this.context.extTimerQuery;
          let p = this.gpuTimers[a.id];
          p || (p = this.gpuTimers[a.id] = { calls: 0, cpuTime: 0, query: f.createQueryEXT() }), p.calls++, f.beginQueryEXT(f.TIME_ELAPSED_EXT, p.query);
        }
        gpuTimingEnd() {
          if (!this.options.gpuTiming)
            return;
          const a = this.context.extTimerQuery;
          a.endQueryEXT(a.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const a = this.gpuTimers;
          return this.gpuTimers = {}, a;
        }
        queryGpuTimers(a) {
          const f = {};
          for (const p in a) {
            const _ = a[p], b = this.context.extTimerQuery, M = b.getQueryObjectEXT(_.query, b.QUERY_RESULT_EXT) / 1e6;
            b.deleteQueryEXT(_.query), f[p] = M;
          }
          return f;
        }
        translatePosMatrix(a, f, p, _, b) {
          if (!p[0] && !p[1])
            return a;
          const M = b ? _ === "map" ? this.transform.angle : 0 : _ === "viewport" ? -this.transform.angle : 0;
          if (M) {
            const D = Math.sin(M), F = Math.cos(M);
            p = [p[0] * F - p[1] * D, p[0] * D + p[1] * F];
          }
          const P = [b ? p[0] : Tn(f, p[0], this.transform.zoom), b ? p[1] : Tn(f, p[1], this.transform.zoom), 0], O = new Float32Array(16);
          return s.translate(O, a, P), O;
        }
        saveTileTexture(a) {
          const f = this._tileTextures[a.size[0]];
          f ? f.push(a) : this._tileTextures[a.size[0]] = [a];
        }
        getTileTexture(a) {
          const f = this._tileTextures[a];
          return f && f.length > 0 ? f.pop() : null;
        }
        isPatternMissing(a) {
          if (!a)
            return !1;
          if (!a.from || !a.to)
            return !0;
          const f = this.imageManager.getPattern(a.from.toString()), p = this.imageManager.getPattern(a.to.toString());
          return !f || !p;
        }
        useProgram(a, f) {
          this.cache = this.cache || {};
          const p = a + (f ? f.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.terrain ? "/terrain" : "");
          return this.cache[p] || (this.cache[p] = new fp(this.context, a, ec[a], f, ef[a], this._showOverdrawInspector, this.style.terrain)), this.cache[p];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const a = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(a.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new B(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
      }
      class Lu {
        constructor(a, f) {
          this.points = a, this.planes = f;
        }
        static fromInvProjectionMatrix(a, f, p) {
          const _ = Math.pow(2, p), b = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((P) => {
            const O = 1 / (P = s.transformMat4([], P, a))[3] / f * _;
            return s.mul$1(P, P, [O, O, 1 / P[3], O]);
          }), M = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((P) => {
            const O = s.sub([], b[P[0]], b[P[1]]), D = s.sub([], b[P[2]], b[P[1]]), F = s.normalize([], s.cross([], O, D)), $ = -s.dot(F, b[P[1]]);
            return F.concat($);
          });
          return new Lu(b, M);
        }
      }
      class fc {
        constructor(a, f) {
          this.min = a, this.max = f, this.center = s.scale$1([], s.add([], this.min, this.max), 0.5);
        }
        quadrant(a) {
          const f = [a % 2 == 0, a < 2], p = s.clone$2(this.min), _ = s.clone$2(this.max);
          for (let b = 0; b < f.length; b++)
            p[b] = f[b] ? this.min[b] : this.center[b], _[b] = f[b] ? this.center[b] : this.max[b];
          return _[2] = this.max[2], new fc(p, _);
        }
        distanceX(a) {
          return Math.max(Math.min(this.max[0], a[0]), this.min[0]) - a[0];
        }
        distanceY(a) {
          return Math.max(Math.min(this.max[1], a[1]), this.min[1]) - a[1];
        }
        intersects(a) {
          const f = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let p = !0;
          for (let _ = 0; _ < a.planes.length; _++) {
            const b = a.planes[_];
            let M = 0;
            for (let P = 0; P < f.length; P++)
              s.dot$1(b, f[P]) >= 0 && M++;
            if (M === 0)
              return 0;
            M !== f.length && (p = !1);
          }
          if (p)
            return 2;
          for (let _ = 0; _ < 3; _++) {
            let b = Number.MAX_VALUE, M = -Number.MAX_VALUE;
            for (let P = 0; P < a.points.length; P++) {
              const O = a.points[P][_] - this.min[_];
              b = Math.min(b, O), M = Math.max(M, O);
            }
            if (M < 0 || b > this.max[_] - this.min[_])
              return 0;
          }
          return 1;
        }
      }
      class il {
        constructor(a = 0, f = 0, p = 0, _ = 0) {
          if (isNaN(a) || a < 0 || isNaN(f) || f < 0 || isNaN(p) || p < 0 || isNaN(_) || _ < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = a, this.bottom = f, this.left = p, this.right = _;
        }
        interpolate(a, f, p) {
          return f.top != null && a.top != null && (this.top = s.number(a.top, f.top, p)), f.bottom != null && a.bottom != null && (this.bottom = s.number(a.bottom, f.bottom, p)), f.left != null && a.left != null && (this.left = s.number(a.left, f.left, p)), f.right != null && a.right != null && (this.right = s.number(a.right, f.right, p)), this;
        }
        getCenter(a, f) {
          const p = s.clamp((this.left + a - this.right) / 2, 0, a), _ = s.clamp((this.top + f - this.bottom) / 2, 0, f);
          return new s.pointGeometry(p, _);
        }
        equals(a) {
          return this.top === a.top && this.bottom === a.bottom && this.left === a.left && this.right === a.right;
        }
        clone() {
          return new il(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      class dc {
        constructor(a, f, p, _, b) {
          this.tileSize = 512, this.maxValidLatitude = 85.051129, this.freezeElevation = !1, this._renderWorldCopies = b === void 0 || !!b, this._minZoom = a || 0, this._maxZoom = f || 22, this._minPitch = p == null ? 0 : p, this._maxPitch = _ == null ? 60 : _, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new s.LngLat(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new il(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }
        clone() {
          const a = new dc(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return a.tileSize = this.tileSize, a.latRange = this.latRange, a.width = this.width, a.height = this.height, a._center = this._center, a._elevation = this._elevation, a.zoom = this.zoom, a.angle = this.angle, a._fov = this._fov, a._pitch = this._pitch, a._unmodified = this._unmodified, a._edgeInsets = this._edgeInsets.clone(), a._calcMatrices(), a;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(a) {
          this._minZoom !== a && (this._minZoom = a, this.zoom = Math.max(this.zoom, a));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(a) {
          this._maxZoom !== a && (this._maxZoom = a, this.zoom = Math.min(this.zoom, a));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(a) {
          this._minPitch !== a && (this._minPitch = a, this.pitch = Math.max(this.pitch, a));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(a) {
          this._maxPitch !== a && (this._maxPitch = a, this.pitch = Math.min(this.pitch, a));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(a) {
          a === void 0 ? a = !0 : a === null && (a = !1), this._renderWorldCopies = a;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new s.pointGeometry(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(a) {
          const f = -s.wrap(a, -180, 180) * Math.PI / 180;
          var p;
          this.angle !== f && (this._unmodified = !1, this.angle = f, this._calcMatrices(), this.rotationMatrix = (p = new s.ARRAY_TYPE(4), s.ARRAY_TYPE != Float32Array && (p[1] = 0, p[2] = 0), p[0] = 1, p[3] = 1, p), function(_, b, M) {
            var P = b[0], O = b[1], D = b[2], F = b[3], $ = Math.sin(M), G = Math.cos(M);
            _[0] = P * G + D * $, _[1] = O * G + F * $, _[2] = P * -$ + D * G, _[3] = O * -$ + F * G;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(a) {
          const f = s.clamp(a, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== f && (this._unmodified = !1, this._pitch = f, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(a) {
          a = Math.max(0.01, Math.min(60, a)), this._fov !== a && (this._unmodified = !1, this._fov = a / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(a) {
          const f = Math.min(Math.max(a, this.minZoom), this.maxZoom);
          this._zoom !== f && (this._unmodified = !1, this._zoom = f, this.scale = this.zoomScale(f), this.tileZoom = Math.floor(f), this.zoomFraction = f - this.tileZoom, this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(a) {
          a.lat === this._center.lat && a.lng === this._center.lng || (this._unmodified = !1, this._center = a, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(a) {
          a !== this._elevation && (this._elevation = a, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(a) {
          this._edgeInsets.equals(a) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, a, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(a) {
          return this._edgeInsets.equals(a);
        }
        interpolatePadding(a, f, p) {
          this._unmodified = !1, this._edgeInsets.interpolate(a, f, p), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(a) {
          const f = (a.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / a.tileSize));
          return Math.max(0, f);
        }
        getVisibleUnwrappedCoordinates(a) {
          const f = [new s.UnwrappedTileID(0, a)];
          if (this._renderWorldCopies) {
            const p = this.pointCoordinate(new s.pointGeometry(0, 0)), _ = this.pointCoordinate(new s.pointGeometry(this.width, 0)), b = this.pointCoordinate(new s.pointGeometry(this.width, this.height)), M = this.pointCoordinate(new s.pointGeometry(0, this.height)), P = Math.floor(Math.min(p.x, _.x, b.x, M.x)), O = Math.floor(Math.max(p.x, _.x, b.x, M.x)), D = 1;
            for (let F = P - D; F <= O + D; F++)
              F !== 0 && f.push(new s.UnwrappedTileID(F, a));
          }
          return f;
        }
        coveringTiles(a) {
          var f, p;
          let _ = this.coveringZoomLevel(a);
          const b = _;
          if (a.minzoom !== void 0 && _ < a.minzoom)
            return [];
          a.maxzoom !== void 0 && _ > a.maxzoom && (_ = a.maxzoom);
          const M = this.pointCoordinate(this.getCameraPoint()), P = s.MercatorCoordinate.fromLngLat(this.center), O = Math.pow(2, _), D = [O * M.x, O * M.y, 0], F = [O * P.x, O * P.y, 0], $ = Lu.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, _);
          let G = a.minzoom || 0;
          !a.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (G = _);
          const ie = a.terrain ? 2 / Math.min(this.tileSize, a.tileSize) * this.tileSize : 3, Q = (oe) => ({ aabb: new fc([oe * O, 0, 0], [(oe + 1) * O, O, 0]), zoom: 0, x: 0, y: 0, wrap: oe, fullyVisible: !1 }), te = [], de = [], be = _, Se = a.reparseOverscaled ? b : _;
          if (this._renderWorldCopies)
            for (let oe = 1; oe <= 3; oe++)
              te.push(Q(-oe)), te.push(Q(oe));
          for (te.push(Q(0)); te.length > 0; ) {
            const oe = te.pop(), Le = oe.x, Ie = oe.y;
            let Be = oe.fullyVisible;
            if (!Be) {
              const wt = oe.aabb.intersects($);
              if (wt === 0)
                continue;
              Be = wt === 2;
            }
            const Ue = a.terrain ? D : F, Qe = oe.aabb.distanceX(Ue), Fe = oe.aabb.distanceY(Ue), bt = Math.max(Math.abs(Qe), Math.abs(Fe)), ht = ie + (1 << be - oe.zoom) - 2;
            if (oe.zoom === be || bt > ht && oe.zoom >= G) {
              const wt = be - oe.zoom, er = D[0] - 0.5 - (Le << wt), sr = D[1] - 0.5 - (Ie << wt);
              de.push({ tileID: new s.OverscaledTileID(oe.zoom === be ? Se : oe.zoom, oe.wrap, oe.zoom, Le, Ie), distanceSq: s.sqrLen([F[0] - 0.5 - Le, F[1] - 0.5 - Ie]), tileDistanceToCamera: Math.sqrt(er * er + sr * sr) });
            } else
              for (let wt = 0; wt < 4; wt++) {
                const er = (Le << 1) + wt % 2, sr = (Ie << 1) + (wt >> 1), zt = oe.zoom + 1;
                let Ur = oe.aabb.quadrant(wt);
                if (a.terrain) {
                  const $r = new s.OverscaledTileID(zt, oe.wrap, zt, er, sr), Tr = a.terrain.getMinMaxElevation($r), Pr = (f = Tr.minElevation) !== null && f !== void 0 ? f : this.elevation, Gr = (p = Tr.maxElevation) !== null && p !== void 0 ? p : this.elevation;
                  Ur = new fc([Ur.min[0], Ur.min[1], Pr], [Ur.max[0], Ur.max[1], Gr]);
                }
                te.push({ aabb: Ur, zoom: zt, x: er, y: sr, wrap: oe.wrap, fullyVisible: Be });
              }
          }
          return de.sort((oe, Le) => oe.distanceSq - Le.distanceSq).map((oe) => oe.tileID);
        }
        resize(a, f) {
          this.width = a, this.height = f, this.pixelsToGLUnits = [2 / a, -2 / f], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(a) {
          return Math.pow(2, a);
        }
        scaleZoom(a) {
          return Math.log(a) / Math.LN2;
        }
        project(a) {
          const f = s.clamp(a.lat, -this.maxValidLatitude, this.maxValidLatitude);
          return new s.pointGeometry(s.mercatorXfromLng(a.lng) * this.worldSize, s.mercatorYfromLat(f) * this.worldSize);
        }
        unproject(a) {
          return new s.MercatorCoordinate(a.x / this.worldSize, a.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        updateElevation(a) {
          this.freezeElevation || (this.elevation = a ? this.getElevation(this._center, a) : 0);
        }
        getElevation(a, f) {
          const p = s.MercatorCoordinate.fromLngLat(a), _ = (1 << this.tileZoom) * s.EXTENT, b = p.x * _, M = p.y * _, P = Math.floor(b / s.EXTENT), O = Math.floor(M / s.EXTENT), D = new s.OverscaledTileID(this.tileZoom, 0, this.tileZoom, P, O);
          return f.getElevation(D, b % s.EXTENT, M % s.EXTENT, s.EXTENT);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(a) {
          const f = this.pointLocation(this.centerPoint, a), p = this.getElevation(f, a);
          if (!(this.elevation - p))
            return;
          const _ = this.getCameraPosition(), b = s.MercatorCoordinate.fromLngLat(_.lngLat, _.altitude), M = s.MercatorCoordinate.fromLngLat(f, p), P = b.x - M.x, O = b.y - M.y, D = b.z - M.z, F = Math.sqrt(P * P + O * O + D * D), $ = this.scaleZoom(this.cameraToCenterDistance / F / this.tileSize);
          this._elevation = p, this._center = f, this.zoom = $;
        }
        setLocationAtPoint(a, f) {
          const p = this.pointCoordinate(f), _ = this.pointCoordinate(this.centerPoint), b = this.locationCoordinate(a), M = new s.MercatorCoordinate(b.x - (p.x - _.x), b.y - (p.y - _.y));
          this.center = this.coordinateLocation(M), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(a, f) {
          return f ? this.coordinatePoint(this.locationCoordinate(a), this.getElevation(a, f), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(a));
        }
        pointLocation(a, f) {
          return this.coordinateLocation(this.pointCoordinate(a, f));
        }
        locationCoordinate(a) {
          return s.MercatorCoordinate.fromLngLat(a);
        }
        coordinateLocation(a) {
          return a && a.toLngLat();
        }
        pointCoordinate(a, f) {
          if (f) {
            const G = f.pointCoordinate(a);
            if (G != null)
              return G;
          }
          const p = [a.x, a.y, 0, 1], _ = [a.x, a.y, 1, 1];
          s.transformMat4(p, p, this.pixelMatrixInverse), s.transformMat4(_, _, this.pixelMatrixInverse);
          const b = p[3], M = _[3], P = p[1] / b, O = _[1] / M, D = p[2] / b, F = _[2] / M, $ = D === F ? 0 : (0 - D) / (F - D);
          return new s.MercatorCoordinate(s.number(p[0] / b, _[0] / M, $) / this.worldSize, s.number(P, O, $) / this.worldSize);
        }
        coordinatePoint(a, f = 0, p = this.pixelMatrix) {
          const _ = [a.x * this.worldSize, a.y * this.worldSize, f, 1];
          return s.transformMat4(_, _, p), new s.pointGeometry(_[0] / _[3], _[1] / _[3]);
        }
        getBounds() {
          const a = Math.max(0, this.height / 2 - this.getHorizon());
          return new s.LngLatBounds().extend(this.pointLocation(new s.pointGeometry(0, a))).extend(this.pointLocation(new s.pointGeometry(this.width, a))).extend(this.pointLocation(new s.pointGeometry(this.width, this.height))).extend(this.pointLocation(new s.pointGeometry(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new s.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(a) {
          a ? (this.lngRange = [a.getWest(), a.getEast()], this.latRange = [a.getSouth(), a.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
        }
        calculatePosMatrix(a, f = !1) {
          const p = a.key, _ = f ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (_[p])
            return _[p];
          const b = a.canonical, M = this.worldSize / this.zoomScale(b.z), P = b.x + Math.pow(2, b.z) * a.wrap, O = s.identity(new Float64Array(16));
          return s.translate(O, O, [P * M, b.y * M, 0]), s.scale(O, O, [M / s.EXTENT, M / s.EXTENT, 1]), s.multiply(O, f ? this.alignedProjMatrix : this.projMatrix, O), _[p] = new Float32Array(O), _[p];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = !0;
          let a, f, p, _, b = -90, M = 90, P = -180, O = 180;
          const D = this.size, F = this._unmodified;
          if (this.latRange) {
            const ie = this.latRange;
            b = s.mercatorYfromLat(ie[1]) * this.worldSize, M = s.mercatorYfromLat(ie[0]) * this.worldSize, a = M - b < D.y ? D.y / (M - b) : 0;
          }
          if (this.lngRange) {
            const ie = this.lngRange;
            P = s.wrap(s.mercatorXfromLng(ie[0]) * this.worldSize, 0, this.worldSize), O = s.wrap(s.mercatorXfromLng(ie[1]) * this.worldSize, 0, this.worldSize), O < P && (O += this.worldSize), f = O - P < D.x ? D.x / (O - P) : 0;
          }
          const $ = this.point, G = Math.max(f || 0, a || 0);
          if (G)
            return this.center = this.unproject(new s.pointGeometry(f ? (O + P) / 2 : $.x, a ? (M + b) / 2 : $.y)), this.zoom += this.scaleZoom(G), this._unmodified = F, void (this._constraining = !1);
          if (this.latRange) {
            const ie = $.y, Q = D.y / 2;
            ie - Q < b && (_ = b + Q), ie + Q > M && (_ = M - Q);
          }
          if (this.lngRange) {
            const ie = (P + O) / 2, Q = s.wrap($.x, ie - this.worldSize / 2, ie + this.worldSize / 2), te = D.x / 2;
            Q - te < P && (p = P + te), Q + te > O && (p = O - te);
          }
          p === void 0 && _ === void 0 || (this.center = this.unproject(new s.pointGeometry(p !== void 0 ? p : $.x, _ !== void 0 ? _ : $.y)).wrap()), this._unmodified = F, this._constraining = !1;
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const a = this.centerOffset, f = this.point.x, p = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = s.mercatorZfromAltitude(1, this.center.lat) * this.worldSize;
          let _ = s.identity(new Float64Array(16));
          s.scale(_, _, [this.width / 2, -this.height / 2, 1]), s.translate(_, _, [1, -1, 0]), this.labelPlaneMatrix = _, _ = s.identity(new Float64Array(16)), s.scale(_, _, [1, -1, 1]), s.translate(_, _, [-1, -1, 0]), s.scale(_, _, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = _, this.cameraToSeaLevelDistance = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch);
          const b = Math.PI / 2 + this._pitch, M = this._fov * (0.5 + a.y / this.height), P = Math.sin(M) * this.cameraToSeaLevelDistance / Math.sin(s.clamp(Math.PI - b - M, 0.01, Math.PI - 0.01)), O = this.getHorizon(), D = 2 * Math.atan(O / this.cameraToCenterDistance) * (0.5 + a.y / (2 * O)), F = Math.sin(D) * this.cameraToSeaLevelDistance / Math.sin(s.clamp(Math.PI - b - D, 0.01, Math.PI - 0.01)), $ = Math.cos(Math.PI / 2 - this._pitch) * P + this.cameraToSeaLevelDistance, G = Math.cos(Math.PI / 2 - this._pitch) * F + this.cameraToSeaLevelDistance, ie = 1.01 * Math.min($, G), Q = this.height / 50;
          _ = new Float64Array(16), s.perspective(_, this._fov, this.width / this.height, Q, ie), _[8] = 2 * -a.x / this.width, _[9] = 2 * a.y / this.height, s.scale(_, _, [1, -1, 1]), s.translate(_, _, [0, 0, -this.cameraToCenterDistance]), s.rotateX(_, _, this._pitch), s.rotateZ(_, _, this.angle), s.translate(_, _, [-f, -p, 0]), this.mercatorMatrix = s.scale([], _, [this.worldSize, this.worldSize, this.worldSize]), s.scale(_, _, [1, 1, this._pixelPerMeter]), this.pixelMatrix = s.multiply(new Float64Array(16), this.labelPlaneMatrix, _), s.translate(_, _, [0, 0, -this.elevation]), this.projMatrix = _, this.invProjMatrix = s.invert([], _), this.pixelMatrix3D = s.multiply(new Float64Array(16), this.labelPlaneMatrix, _);
          const te = this.width % 2 / 2, de = this.height % 2 / 2, be = Math.cos(this.angle), Se = Math.sin(this.angle), oe = f - Math.round(f) + be * te + Se * de, Le = p - Math.round(p) + be * de + Se * te, Ie = new Float64Array(_);
          if (s.translate(Ie, Ie, [oe > 0.5 ? oe - 1 : oe, Le > 0.5 ? Le - 1 : Le, 0]), this.alignedProjMatrix = Ie, _ = s.invert(new Float64Array(16), this.pixelMatrix), !_)
            throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = _, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse)
            return 1;
          const a = this.pointCoordinate(new s.pointGeometry(0, 0)), f = [a.x * this.worldSize, a.y * this.worldSize, 0, 1];
          return s.transformMat4(f, f, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const a = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new s.pointGeometry(0, a));
        }
        getCameraQueryGeometry(a) {
          const f = this.getCameraPoint();
          if (a.length === 1)
            return [a[0], f];
          {
            let p = f.x, _ = f.y, b = f.x, M = f.y;
            for (const P of a)
              p = Math.min(p, P.x), _ = Math.min(_, P.y), b = Math.max(b, P.x), M = Math.max(M, P.y);
            return [new s.pointGeometry(p, _), new s.pointGeometry(b, _), new s.pointGeometry(b, M), new s.pointGeometry(p, M), new s.pointGeometry(p, _)];
          }
        }
      }
      class Dp {
        constructor(a) {
          this._hashName = a && encodeURIComponent(a), s.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = function(f, p) {
            let _ = !1, b = null;
            const M = () => {
              b = null, _ && (f(), b = setTimeout(M, 300), _ = !1);
            };
            return () => (_ = !0, b || M(), b);
          }(this._updateHashUnthrottled.bind(this));
        }
        addTo(a) {
          return this._map = a, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
        }
        getHashString(a) {
          const f = this._map.getCenter(), p = Math.round(100 * this._map.getZoom()) / 100, _ = Math.ceil((p * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), b = Math.pow(10, _), M = Math.round(f.lng * b) / b, P = Math.round(f.lat * b) / b, O = this._map.getBearing(), D = this._map.getPitch();
          let F = "";
          if (F += a ? `/${M}/${P}/${p}` : `${p}/${P}/${M}`, (O || D) && (F += "/" + Math.round(10 * O) / 10), D && (F += `/${Math.round(D)}`), this._hashName) {
            const $ = this._hashName;
            let G = !1;
            const ie = window.location.hash.slice(1).split("&").map((Q) => {
              const te = Q.split("=")[0];
              return te === $ ? (G = !0, `${te}=${F}`) : Q;
            }).filter((Q) => Q);
            return G || ie.push(`${$}=${F}`), `#${ie.join("&")}`;
          }
          return `#${F}`;
        }
        _getCurrentHash() {
          const a = window.location.hash.replace("#", "");
          if (this._hashName) {
            let f;
            return a.split("&").map((p) => p.split("=")).forEach((p) => {
              p[0] === this._hashName && (f = p);
            }), (f && f[1] || "").split("/");
          }
          return a.split("/");
        }
        _onHashChange() {
          const a = this._getCurrentHash();
          if (a.length >= 3 && !a.some((f) => isNaN(f))) {
            const f = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(a[3] || 0) : this._map.getBearing();
            return this._map.jumpTo({ center: [+a[2], +a[1]], zoom: +a[0], bearing: f, pitch: +(a[4] || 0) }), !0;
          }
          return !1;
        }
        _updateHashUnthrottled() {
          const a = window.location.href.replace(/(#.+)?$/, this.getHashString());
          try {
            window.history.replaceState(window.history.state, null, a);
          } catch {
          }
        }
      }
      const pc = { linearity: 0.3, easing: s.bezier(0, 0, 0.3, 1) }, kp = s.extend({ deceleration: 2500, maxSpeed: 1400 }, pc), Np = s.extend({ deceleration: 20, maxSpeed: 1400 }, pc), Fp = s.extend({ deceleration: 1e3, maxSpeed: 360 }, pc), ol = s.extend({ deceleration: 1e3, maxSpeed: 90 }, pc);
      class zp {
        constructor(a) {
          this._map = a, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(a) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: s.exported.now(), settings: a });
        }
        _drainInertiaBuffer() {
          const a = this._inertiaBuffer, f = s.exported.now();
          for (; a.length > 0 && f - a[0].time > 160; )
            a.shift();
        }
        _onMoveEnd(a) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const f = { zoom: 0, bearing: 0, pitch: 0, pan: new s.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: b } of this._inertiaBuffer)
            f.zoom += b.zoomDelta || 0, f.bearing += b.bearingDelta || 0, f.pitch += b.pitchDelta || 0, b.panDelta && f.pan._add(b.panDelta), b.around && (f.around = b.around), b.pinchAround && (f.pinchAround = b.pinchAround);
          const p = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, _ = {};
          if (f.pan.mag()) {
            const b = gc(f.pan.mag(), p, s.extend({}, kp, a || {}));
            _.offset = f.pan.mult(b.amount / f.pan.mag()), _.center = this._map.transform.center, mc(_, b);
          }
          if (f.zoom) {
            const b = gc(f.zoom, p, Np);
            _.zoom = this._map.transform.zoom + b.amount, mc(_, b);
          }
          if (f.bearing) {
            const b = gc(f.bearing, p, Fp);
            _.bearing = this._map.transform.bearing + s.clamp(b.amount, -179, 179), mc(_, b);
          }
          if (f.pitch) {
            const b = gc(f.pitch, p, ol);
            _.pitch = this._map.transform.pitch + b.amount, mc(_, b);
          }
          if (_.zoom || _.bearing) {
            const b = f.pinchAround === void 0 ? f.around : f.pinchAround;
            _.around = b ? this._map.unproject(b) : this._map.getCenter();
          }
          return this.clear(), s.extend(_, { noMoveStart: !0 });
        }
      }
      function mc(g, a) {
        (!g.duration || g.duration < a.duration) && (g.duration = a.duration, g.easing = a.easing);
      }
      function gc(g, a, f) {
        const { maxSpeed: p, linearity: _, deceleration: b } = f, M = s.clamp(g * _ / (a / 1e3), -p, p), P = Math.abs(M) / (b * _);
        return { easing: f.easing, duration: 1e3 * P, amount: M * (P / 2) };
      }
      class eo extends s.Event {
        constructor(a, f, p, _ = {}) {
          const b = S.mousePos(f.getCanvasContainer(), p), M = f.unproject(b);
          super(a, s.extend({ point: b, lngLat: M, originalEvent: p }, _)), this._defaultPrevented = !1, this.target = f;
        }
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
      }
      class yc extends s.Event {
        constructor(a, f, p) {
          const _ = a === "touchend" ? p.changedTouches : p.touches, b = S.touchPos(f.getCanvasContainer(), _), M = b.map((O) => f.unproject(O)), P = b.reduce((O, D, F, $) => O.add(D.div($.length)), new s.pointGeometry(0, 0));
          super(a, { points: b, point: P, lngLats: M, lngLat: f.unproject(P), originalEvent: p }), this._defaultPrevented = !1;
        }
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
      }
      class to extends s.Event {
        constructor(a, f, p) {
          super(a, { originalEvent: p }), this._defaultPrevented = !1;
        }
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
      }
      class l_ {
        constructor(a, f) {
          this._map = a, this._clickTolerance = f.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(a) {
          return this._firePreventable(new to(a.type, this._map, a));
        }
        mousedown(a, f) {
          return this._mousedownPos = f, this._firePreventable(new eo(a.type, this._map, a));
        }
        mouseup(a) {
          this._map.fire(new eo(a.type, this._map, a));
        }
        click(a, f) {
          this._mousedownPos && this._mousedownPos.dist(f) >= this._clickTolerance || this._map.fire(new eo(a.type, this._map, a));
        }
        dblclick(a) {
          return this._firePreventable(new eo(a.type, this._map, a));
        }
        mouseover(a) {
          this._map.fire(new eo(a.type, this._map, a));
        }
        mouseout(a) {
          this._map.fire(new eo(a.type, this._map, a));
        }
        touchstart(a) {
          return this._firePreventable(new yc(a.type, this._map, a));
        }
        touchmove(a) {
          this._map.fire(new yc(a.type, this._map, a));
        }
        touchend(a) {
          this._map.fire(new yc(a.type, this._map, a));
        }
        touchcancel(a) {
          this._map.fire(new yc(a.type, this._map, a));
        }
        _firePreventable(a) {
          if (this._map.fire(a), a.defaultPrevented)
            return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Fa {
        constructor(a) {
          this._map = a;
        }
        reset() {
          this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
        }
        mousemove(a) {
          this._map.fire(new eo(a.type, this._map, a));
        }
        mousedown() {
          this._delayContextMenu = !0, this._ignoreContextMenu = !1;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new eo("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(a) {
          this._delayContextMenu ? this._contextMenuEvent = a : this._ignoreContextMenu || this._map.fire(new eo(a.type, this._map, a)), this._map.listens("contextmenu") && a.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Bp {
        constructor(a, f) {
          this._map = a, this._el = a.getCanvasContainer(), this._container = a.getContainer(), this._clickTolerance = f.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(a, f) {
          this.isEnabled() && a.shiftKey && a.button === 0 && (S.disableDrag(), this._startPos = this._lastPos = f, this._active = !0);
        }
        mousemoveWindow(a, f) {
          if (!this._active)
            return;
          const p = f;
          if (this._lastPos.equals(p) || !this._box && p.dist(this._startPos) < this._clickTolerance)
            return;
          const _ = this._startPos;
          this._lastPos = p, this._box || (this._box = S.create("div", "maplibregl-boxzoom mapboxgl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair", "mapboxgl-crosshair"), this._fireEvent("boxzoomstart", a));
          const b = Math.min(_.x, p.x), M = Math.max(_.x, p.x), P = Math.min(_.y, p.y), O = Math.max(_.y, p.y);
          S.setTransform(this._box, `translate(${b}px,${P}px)`), this._box.style.width = M - b + "px", this._box.style.height = O - P + "px";
        }
        mouseupWindow(a, f) {
          if (!this._active || a.button !== 0)
            return;
          const p = this._startPos, _ = f;
          if (this.reset(), S.suppressClick(), p.x !== _.x || p.y !== _.y)
            return this._map.fire(new s.Event("boxzoomend", { originalEvent: a })), { cameraAnimation: (b) => b.fitScreenCoordinates(p, _, this._map.getBearing(), { linear: !0 }) };
          this._fireEvent("boxzoomcancel", a);
        }
        keydown(a) {
          this._active && a.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", a));
        }
        reset() {
          this._active = !1, this._container.classList.remove("maplibregl-crosshair", "mapboxgl-crosshair"), this._box && (S.remove(this._box), this._box = null), S.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(a, f) {
          return this._map.fire(new s.Event(a, { originalEvent: f }));
        }
      }
      function ca(g, a) {
        if (g.length !== a.length)
          throw new Error(`The number of touches and points are not equal - touches ${g.length}, points ${a.length}`);
        const f = {};
        for (let p = 0; p < g.length; p++)
          f[g[p].identifier] = a[p];
        return f;
      }
      class _c {
        constructor(a) {
          this.reset(), this.numTouches = a.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }
        touchstart(a, f, p) {
          (this.centroid || p.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = a.timeStamp), p.length === this.numTouches && (this.centroid = function(_) {
            const b = new s.pointGeometry(0, 0);
            for (const M of _)
              b._add(M);
            return b.div(_.length);
          }(f), this.touches = ca(p, f)));
        }
        touchmove(a, f, p) {
          if (this.aborted || !this.centroid)
            return;
          const _ = ca(p, f);
          for (const b in this.touches) {
            const M = this.touches[b], P = _[b];
            (!P || P.dist(M) > 30) && (this.aborted = !0);
          }
        }
        touchend(a, f, p) {
          if ((!this.centroid || a.timeStamp - this.startTime > 500) && (this.aborted = !0), p.length === 0) {
            const _ = !this.aborted && this.centroid;
            if (this.reset(), _)
              return _;
          }
        }
      }
      class gf {
        constructor(a) {
          this.singleTap = new _c(a), this.numTaps = a.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(a, f, p) {
          this.singleTap.touchstart(a, f, p);
        }
        touchmove(a, f, p) {
          this.singleTap.touchmove(a, f, p);
        }
        touchend(a, f, p) {
          const _ = this.singleTap.touchend(a, f, p);
          if (_) {
            const b = a.timeStamp - this.lastTime < 500, M = !this.lastTap || this.lastTap.dist(_) < 30;
            if (b && M || this.reset(), this.count++, this.lastTime = a.timeStamp, this.lastTap = _, this.count === this.numTaps)
              return this.reset(), _;
          }
        }
      }
      class c_ {
        constructor() {
          this._zoomIn = new gf({ numTouches: 1, numTaps: 2 }), this._zoomOut = new gf({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(a, f, p) {
          this._zoomIn.touchstart(a, f, p), this._zoomOut.touchstart(a, f, p);
        }
        touchmove(a, f, p) {
          this._zoomIn.touchmove(a, f, p), this._zoomOut.touchmove(a, f, p);
        }
        touchend(a, f, p) {
          const _ = this._zoomIn.touchend(a, f, p), b = this._zoomOut.touchend(a, f, p);
          return _ ? (this._active = !0, a.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (M) => M.easeTo({ duration: 300, zoom: M.getZoom() + 1, around: M.unproject(_) }, { originalEvent: a }) }) : b ? (this._active = !0, a.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (M) => M.easeTo({ duration: 300, zoom: M.getZoom() - 1, around: M.unproject(b) }, { originalEvent: a }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const u_ = { 0: 1, 2: 2 };
      class Du {
        constructor(a) {
          this.reset(), this._clickTolerance = a.clickTolerance || 1;
        }
        reset() {
          this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;
        }
        _correctButton(a, f) {
          return !1;
        }
        _move(a, f) {
          return {};
        }
        mousedown(a, f) {
          if (this._lastPoint)
            return;
          const p = S.mouseButton(a);
          this._correctButton(a, p) && (this._lastPoint = f, this._eventButton = p);
        }
        mousemoveWindow(a, f) {
          const p = this._lastPoint;
          if (p) {
            if (a.preventDefault(), function(_, b) {
              const M = u_[b];
              return _.buttons === void 0 || (_.buttons & M) !== M;
            }(a, this._eventButton))
              this.reset();
            else if (this._moved || !(f.dist(p) < this._clickTolerance))
              return this._moved = !0, this._lastPoint = f, this._move(p, f);
          }
        }
        mouseupWindow(a) {
          this._lastPoint && S.mouseButton(a) === this._eventButton && (this._moved && S.suppressClick(), this.reset());
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class vc extends Du {
        mousedown(a, f) {
          super.mousedown(a, f), this._lastPoint && (this._active = !0);
        }
        _correctButton(a, f) {
          return f === 0 && !a.ctrlKey;
        }
        _move(a, f) {
          return { around: f, panDelta: f.sub(a) };
        }
      }
      class ua extends Du {
        _correctButton(a, f) {
          return f === 0 && a.ctrlKey || f === 2;
        }
        _move(a, f) {
          const p = 0.8 * (f.x - a.x);
          if (p)
            return this._active = !0, { bearingDelta: p };
        }
        contextmenu(a) {
          a.preventDefault();
        }
      }
      class Ct extends Du {
        _correctButton(a, f) {
          return f === 0 && a.ctrlKey || f === 2;
        }
        _move(a, f) {
          const p = -0.5 * (f.y - a.y);
          if (p)
            return this._active = !0, { pitchDelta: p };
        }
        contextmenu(a) {
          a.preventDefault();
        }
      }
      class Up {
        constructor(a, f) {
          this._minTouches = a.cooperativeGestures ? 2 : 1, this._clickTolerance = a.clickTolerance || 1, this._map = f, this.reset();
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new s.pointGeometry(0, 0), setTimeout(() => {
            this._cancelCooperativeMessage = !1;
          }, 200);
        }
        touchstart(a, f, p) {
          return this._calculateTransform(a, f, p);
        }
        touchmove(a, f, p) {
          if (this._map._cooperativeGestures && (this._minTouches === 2 && p.length < 2 && !this._cancelCooperativeMessage ? this._map._onCooperativeGesture(a, !1, p.length) : this._cancelCooperativeMessage || (this._cancelCooperativeMessage = !0)), this._active && !(p.length < this._minTouches))
            return a.preventDefault(), this._calculateTransform(a, f, p);
        }
        touchend(a, f, p) {
          this._calculateTransform(a, f, p), this._active && p.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(a, f, p) {
          p.length > 0 && (this._active = !0);
          const _ = ca(p, f), b = new s.pointGeometry(0, 0), M = new s.pointGeometry(0, 0);
          let P = 0;
          for (const D in _) {
            const F = _[D], $ = this._touches[D];
            $ && (b._add(F), M._add(F.sub($)), P++, _[D] = F);
          }
          if (this._touches = _, P < this._minTouches || !M.mag())
            return;
          const O = M.div(P);
          return this._sum._add(O), this._sum.mag() < this._clickTolerance ? void 0 : { around: b.div(P), panDelta: O };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ys {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, delete this._firstTwoTouches;
        }
        _start(a) {
        }
        _move(a, f, p) {
          return {};
        }
        touchstart(a, f, p) {
          this._firstTwoTouches || p.length < 2 || (this._firstTwoTouches = [p[0].identifier, p[1].identifier], this._start([f[0], f[1]]));
        }
        touchmove(a, f, p) {
          if (!this._firstTwoTouches)
            return;
          a.preventDefault();
          const [_, b] = this._firstTwoTouches, M = za(p, f, _), P = za(p, f, b);
          if (!M || !P)
            return;
          const O = this._aroundCenter ? null : M.add(P).div(2);
          return this._move([M, P], O, a);
        }
        touchend(a, f, p) {
          if (!this._firstTwoTouches)
            return;
          const [_, b] = this._firstTwoTouches, M = za(p, f, _), P = za(p, f, b);
          M && P || (this._active && S.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(a) {
          this._enabled = !0, this._aroundCenter = !!a && a.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function za(g, a, f) {
        for (let p = 0; p < g.length; p++)
          if (g[p].identifier === f)
            return a[p];
      }
      function yf(g, a) {
        return Math.log(g / a) / Math.LN2;
      }
      class gt extends ys {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(a) {
          this._startDistance = this._distance = a[0].dist(a[1]);
        }
        _move(a, f) {
          const p = this._distance;
          if (this._distance = a[0].dist(a[1]), this._active || !(Math.abs(yf(this._distance, this._startDistance)) < 0.1))
            return this._active = !0, { zoomDelta: yf(this._distance, p), pinchAround: f };
        }
      }
      function ku(g, a) {
        return 180 * g.angleWith(a) / Math.PI;
      }
      class h_ extends ys {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(a) {
          this._startVector = this._vector = a[0].sub(a[1]), this._minDiameter = a[0].dist(a[1]);
        }
        _move(a, f) {
          const p = this._vector;
          if (this._vector = a[0].sub(a[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = !0, { bearingDelta: ku(this._vector, p), pinchAround: f };
        }
        _isBelowThreshold(a) {
          this._minDiameter = Math.min(this._minDiameter, a.mag());
          const f = 25 / (Math.PI * this._minDiameter) * 360, p = ku(a, this._startVector);
          return Math.abs(p) < f;
        }
      }
      function _f(g) {
        return Math.abs(g.y) > Math.abs(g.x);
      }
      class vf extends ys {
        constructor(a) {
          super(), this._map = a;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(a, f, p) {
          super.touchstart(a, f, p), this._currentTouchCount = p.length;
        }
        _start(a) {
          this._lastPoints = a, _f(a[0].sub(a[1])) && (this._valid = !1);
        }
        _move(a, f, p) {
          if (this._map._cooperativeGestures && this._currentTouchCount < 3)
            return;
          const _ = a[0].sub(this._lastPoints[0]), b = a[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(_, b, p.timeStamp), this._valid ? (this._lastPoints = a, this._active = !0, { pitchDelta: (_.y + b.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(a, f, p) {
          if (this._valid !== void 0)
            return this._valid;
          const _ = a.mag() >= 2, b = f.mag() >= 2;
          if (!_ && !b)
            return;
          if (!_ || !b)
            return this._firstMove === void 0 && (this._firstMove = p), p - this._firstMove < 100 && void 0;
          const M = a.y > 0 == f.y > 0;
          return _f(a) && _f(f) && M;
        }
      }
      const $p = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Vp {
        constructor() {
          const a = $p;
          this._panStep = a.panStep, this._bearingStep = a.bearingStep, this._pitchStep = a.pitchStep, this._rotationDisabled = !1;
        }
        reset() {
          this._active = !1;
        }
        keydown(a) {
          if (a.altKey || a.ctrlKey || a.metaKey)
            return;
          let f = 0, p = 0, _ = 0, b = 0, M = 0;
          switch (a.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              f = 1;
              break;
            case 189:
            case 109:
            case 173:
              f = -1;
              break;
            case 37:
              a.shiftKey ? p = -1 : (a.preventDefault(), b = -1);
              break;
            case 39:
              a.shiftKey ? p = 1 : (a.preventDefault(), b = 1);
              break;
            case 38:
              a.shiftKey ? _ = 1 : (a.preventDefault(), M = -1);
              break;
            case 40:
              a.shiftKey ? _ = -1 : (a.preventDefault(), M = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (p = 0, _ = 0), { cameraAnimation: (P) => {
            const O = P.getZoom();
            P.easeTo({ duration: 300, easeId: "keyboardHandler", easing: f_, zoom: f ? Math.round(O) + f * (a.shiftKey ? 2 : 1) : O, bearing: P.getBearing() + p * this._bearingStep, pitch: P.getPitch() + _ * this._pitchStep, offset: [-b * this._panStep, -M * this._panStep], center: P.getCenter() }, { originalEvent: a });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function f_(g) {
        return g * (2 - g);
      }
      const jp = 4.000244140625;
      class xf {
        constructor(a, f) {
          this._map = a, this._el = a.getCanvasContainer(), this._handler = f, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, s.bindAll(["_onTimeout"], this);
        }
        setZoomRate(a) {
          this._defaultZoomRate = a;
        }
        setWheelZoomRate(a) {
          this._wheelZoomRate = a;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(a) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = a && a.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        wheel(a) {
          if (!this.isEnabled())
            return;
          if (this._map._cooperativeGestures) {
            if (!this._map._metaPress)
              return;
            a.preventDefault();
          }
          let f = a.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * a.deltaY : a.deltaY;
          const p = s.exported.now(), _ = p - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = p, f !== 0 && f % jp == 0 ? this._type = "wheel" : f !== 0 && Math.abs(f) < 4 ? this._type = "trackpad" : _ > 400 ? (this._type = null, this._lastValue = f, this._timeout = setTimeout(this._onTimeout, 40, a)) : this._type || (this._type = Math.abs(_ * f) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, f += this._lastValue)), a.shiftKey && f && (f /= 4), this._type && (this._lastWheelEvent = a, this._delta -= f, this._active || this._start(a)), a.preventDefault();
        }
        _onTimeout(a) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(a);
        }
        _start(a) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const f = S.mousePos(this._el, a);
          this._around = s.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(f)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive()))
            return;
          const a = this._map.transform;
          if (this._delta !== 0) {
            const P = this._type === "wheel" && Math.abs(this._delta) > jp ? this._wheelZoomRate : this._defaultZoomRate;
            let O = 2 / (1 + Math.exp(-Math.abs(this._delta * P)));
            this._delta < 0 && O !== 0 && (O = 1 / O);
            const D = typeof this._targetZoom == "number" ? a.zoomScale(this._targetZoom) : a.scale;
            this._targetZoom = Math.min(a.maxZoom, Math.max(a.minZoom, a.scaleZoom(D * O))), this._type === "wheel" && (this._startZoom = a.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const f = typeof this._targetZoom == "number" ? this._targetZoom : a.zoom, p = this._startZoom, _ = this._easing;
          let b, M = !1;
          if (this._type === "wheel" && p && _) {
            const P = Math.min((s.exported.now() - this._lastWheelEventTime) / 200, 1), O = _(P);
            b = s.number(p, f, O), P < 1 ? this._frameId || (this._frameId = !0) : M = !0;
          } else
            b = f, M = !0;
          return this._active = !0, M && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !M, zoomDelta: b - a.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(a) {
          let f = s.ease;
          if (this._prevEase) {
            const p = this._prevEase, _ = (s.exported.now() - p.start) / p.duration, b = p.easing(_ + 0.01) - p.easing(_), M = 0.27 / Math.sqrt(b * b + 1e-4) * 0.01, P = Math.sqrt(0.0729 - M * M);
            f = s.bezier(M, P, 0.25, 1);
          }
          return this._prevEase = { start: s.exported.now(), duration: a, easing: f }, f;
        }
        reset() {
          this._active = !1;
        }
      }
      class bf {
        constructor(a, f) {
          this._clickZoom = a, this._tapZoom = f;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class wf {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(a, f) {
          return a.preventDefault(), { cameraAnimation: (p) => {
            p.easeTo({ duration: 300, zoom: p.getZoom() + (a.shiftKey ? -1 : 1), around: p.unproject(f) }, { originalEvent: a });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ef {
        constructor() {
          this._tap = new gf({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
        }
        touchstart(a, f, p) {
          this._swipePoint || (this._tapTime && a.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? p.length > 0 && (this._swipePoint = f[0], this._swipeTouch = p[0].identifier) : this._tap.touchstart(a, f, p));
        }
        touchmove(a, f, p) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (p[0].identifier !== this._swipeTouch)
                return;
              const _ = f[0], b = _.y - this._swipePoint.y;
              return this._swipePoint = _, a.preventDefault(), this._active = !0, { zoomDelta: b / 128 };
            }
          } else
            this._tap.touchmove(a, f, p);
        }
        touchend(a, f, p) {
          this._tapTime ? this._swipePoint && p.length === 0 && this.reset() : this._tap.touchend(a, f, p) && (this._tapTime = a.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class $i {
        constructor(a, f, p) {
          this._el = a, this._mousePan = f, this._touchPan = p;
        }
        enable(a) {
          this._inertiaOptions = a || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class Ba {
        constructor(a, f, p) {
          this._pitchWithRotate = a.pitchWithRotate, this._mouseRotate = f, this._mousePitch = p;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class Gp {
        constructor(a, f, p, _) {
          this._el = a, this._touchZoom = f, this._touchRotate = p, this._tapDragZoom = _, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(a) {
          this._touchZoom.enable(a), this._rotationDisabled || this._touchRotate.enable(a), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const al = (g) => g.zoom || g.drag || g.pitch || g.rotate;
      class Tf extends s.Event {
      }
      function xc(g) {
        return g.panDelta && g.panDelta.mag() || g.zoomDelta || g.bearingDelta || g.pitchDelta;
      }
      class qp {
        constructor(a, f) {
          this._map = a, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new zp(a), this._bearingSnap = f.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(f), s.bindAll(["handleEvent", "handleWindowEvent"], this);
          const p = this._el;
          this._listeners = [[p, "touchstart", { passive: !0 }], [p, "touchmove", { passive: !1 }], [p, "touchend", void 0], [p, "touchcancel", void 0], [p, "mousedown", void 0], [p, "mousemove", void 0], [p, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [p, "mouseover", void 0], [p, "mouseout", void 0], [p, "dblclick", void 0], [p, "click", void 0], [p, "keydown", { capture: !1 }], [p, "keyup", void 0], [p, "wheel", { passive: !1 }], [p, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [_, b, M] of this._listeners)
            S.addEventListener(_, b, _ === document ? this.handleWindowEvent : this.handleEvent, M);
        }
        destroy() {
          for (const [a, f, p] of this._listeners)
            S.removeEventListener(a, f, a === document ? this.handleWindowEvent : this.handleEvent, p);
        }
        _addDefaultHandlers(a) {
          const f = this._map, p = f.getCanvasContainer();
          this._add("mapEvent", new l_(f, a));
          const _ = f.boxZoom = new Bp(f, a);
          this._add("boxZoom", _);
          const b = new c_(), M = new wf();
          f.doubleClickZoom = new bf(M, b), this._add("tapZoom", b), this._add("clickZoom", M);
          const P = new Ef();
          this._add("tapDragZoom", P);
          const O = f.touchPitch = new vf(f);
          this._add("touchPitch", O);
          const D = new ua(a), F = new Ct(a);
          f.dragRotate = new Ba(a, D, F), this._add("mouseRotate", D, ["mousePitch"]), this._add("mousePitch", F, ["mouseRotate"]);
          const $ = new vc(a), G = new Up(a, f);
          f.dragPan = new $i(p, $, G), this._add("mousePan", $), this._add("touchPan", G, ["touchZoom", "touchRotate"]);
          const ie = new h_(), Q = new gt();
          f.touchZoomRotate = new Gp(p, Q, ie, P), this._add("touchRotate", ie, ["touchPan", "touchZoom"]), this._add("touchZoom", Q, ["touchPan", "touchRotate"]);
          const te = f.scrollZoom = new xf(f, this);
          this._add("scrollZoom", te, ["mousePan"]);
          const de = f.keyboard = new Vp();
          this._add("keyboard", de), this._add("blockableMapEvent", new Fa(f));
          for (const be of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
            a.interactive && a[be] && f[be].enable(a[be]);
        }
        _add(a, f, p) {
          this._handlers.push({ handlerName: a, handler: f, allowed: p }), this._handlersById[a] = f;
        }
        stop(a) {
          if (!this._updatingCamera) {
            for (const { handler: f } of this._handlers)
              f.reset();
            this._inertia.clear(), this._fireEvents({}, {}, a), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: a } of this._handlers)
            if (a.isActive())
              return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return Boolean(al(this._eventsInProgress)) || this.isZooming();
        }
        _blockedByActive(a, f, p) {
          for (const _ in a)
            if (_ !== p && (!f || f.indexOf(_) < 0))
              return !0;
          return !1;
        }
        handleWindowEvent(a) {
          this.handleEvent(a, `${a.type}Window`);
        }
        _getMapTouches(a) {
          const f = [];
          for (const p of a)
            this._el.contains(p.target) && f.push(p);
          return f;
        }
        handleEvent(a, f) {
          if (a.type === "blur")
            return void this.stop(!0);
          this._updatingCamera = !0;
          const p = a.type === "renderFrame" ? void 0 : a, _ = { needsRenderFrame: !1 }, b = {}, M = {}, P = a.touches, O = P ? this._getMapTouches(P) : void 0, D = O ? S.touchPos(this._el, O) : S.mousePos(this._el, a);
          for (const { handlerName: G, handler: ie, allowed: Q } of this._handlers) {
            if (!ie.isEnabled())
              continue;
            let te;
            this._blockedByActive(M, Q, G) ? ie.reset() : ie[f || a.type] && (te = ie[f || a.type](a, D, O), this.mergeHandlerResult(_, b, te, G, p), te && te.needsRenderFrame && this._triggerRenderFrame()), (te || ie.isActive()) && (M[G] = ie);
          }
          const F = {};
          for (const G in this._previousActiveHandlers)
            M[G] || (F[G] = p);
          this._previousActiveHandlers = M, (Object.keys(F).length || xc(_)) && (this._changes.push([_, b, F]), this._triggerRenderFrame()), (Object.keys(M).length || xc(_)) && this._map._stop(!0), this._updatingCamera = !1;
          const { cameraAnimation: $ } = _;
          $ && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], $(this._map));
        }
        mergeHandlerResult(a, f, p, _, b) {
          if (!p)
            return;
          s.extend(a, p);
          const M = { handlerName: _, originalEvent: p.originalEvent || b };
          p.zoomDelta !== void 0 && (f.zoom = M), p.panDelta !== void 0 && (f.drag = M), p.pitchDelta !== void 0 && (f.pitch = M), p.bearingDelta !== void 0 && (f.rotate = M);
        }
        _applyChanges() {
          const a = {}, f = {}, p = {};
          for (const [_, b, M] of this._changes)
            _.panDelta && (a.panDelta = (a.panDelta || new s.pointGeometry(0, 0))._add(_.panDelta)), _.zoomDelta && (a.zoomDelta = (a.zoomDelta || 0) + _.zoomDelta), _.bearingDelta && (a.bearingDelta = (a.bearingDelta || 0) + _.bearingDelta), _.pitchDelta && (a.pitchDelta = (a.pitchDelta || 0) + _.pitchDelta), _.around !== void 0 && (a.around = _.around), _.pinchAround !== void 0 && (a.pinchAround = _.pinchAround), _.noInertia && (a.noInertia = _.noInertia), s.extend(f, b), s.extend(p, M);
          this._updateMapTransform(a, f, p), this._changes = [];
        }
        _updateMapTransform(a, f, p) {
          const _ = this._map, b = _.transform, M = _.style && _.style.terrain;
          if (!(xc(a) || M && this._drag))
            return this._fireEvents(f, p, !0);
          let { panDelta: P, zoomDelta: O, bearingDelta: D, pitchDelta: F, around: $, pinchAround: G } = a;
          G !== void 0 && ($ = G), _._stop(!0), $ = $ || _.transform.centerPoint;
          const ie = b.pointLocation(P ? $.sub(P) : $);
          D && (b.bearing += D), F && (b.pitch += F), O && (b.zoom += O), M ? f.drag && !this._drag ? (this._drag = { center: b.centerPoint, lngLat: b.pointLocation($), point: $, handlerName: f.drag.handlerName }, _.fire(new s.Event("freezeElevation", { freeze: !0 }))) : this._drag && p[this._drag.handlerName] ? (_.fire(new s.Event("freezeElevation", { freeze: !1 })), this._drag = null) : f.drag && this._drag && (b.center = b.pointLocation(b.centerPoint.sub(P))) : b.setLocationAtPoint(ie, $), this._map._update(), a.noInertia || this._inertia.record(a), this._fireEvents(f, p, !0);
        }
        _fireEvents(a, f, p) {
          const _ = al(this._eventsInProgress), b = al(a), M = {};
          for (const F in a) {
            const { originalEvent: $ } = a[F];
            this._eventsInProgress[F] || (M[`${F}start`] = $), this._eventsInProgress[F] = a[F];
          }
          !_ && b && this._fireEvent("movestart", b.originalEvent);
          for (const F in M)
            this._fireEvent(F, M[F]);
          b && this._fireEvent("move", b.originalEvent);
          for (const F in a) {
            const { originalEvent: $ } = a[F];
            this._fireEvent(F, $);
          }
          const P = {};
          let O;
          for (const F in this._eventsInProgress) {
            const { handlerName: $, originalEvent: G } = this._eventsInProgress[F];
            this._handlersById[$].isActive() || (delete this._eventsInProgress[F], O = f[$] || G, P[`${F}end`] = O);
          }
          for (const F in P)
            this._fireEvent(F, P[F]);
          const D = al(this._eventsInProgress);
          if (p && (_ || b) && !D) {
            this._updatingCamera = !0;
            const F = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), $ = (G) => G !== 0 && -this._bearingSnap < G && G < this._bearingSnap;
            F ? ($(F.bearing || this._map.getBearing()) && (F.bearing = 0), this._map.easeTo(F, { originalEvent: O })) : (this._map.fire(new s.Event("moveend", { originalEvent: O })), $(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
          }
        }
        _fireEvent(a, f) {
          this._map.fire(new s.Event(a, f ? { originalEvent: f } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((a) => {
            delete this._frameId, this.handleEvent(new Tf("renderFrame", { timeStamp: a })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      const yo = { extend: (g, ...a) => s.extend(g, ...a), run(g) {
        g();
      }, logToElement(g, a = !1, f = "log") {
        const p = window.document.getElementById(f);
        p && (a && (p.innerHTML = ""), p.innerHTML += `<br>${g}`);
      } };
      class xn extends s.Evented {
        constructor(a, f) {
          super(), this._moving = !1, this._zooming = !1, this.transform = a, this._bearingSnap = f.bearingSnap, s.bindAll(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new s.LngLat(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(a, f) {
          return this.jumpTo({ center: a }, f);
        }
        panBy(a, f, p) {
          return a = s.pointGeometry.convert(a).mult(-1), this.panTo(this.transform.center, s.extend({ offset: a }, f), p);
        }
        panTo(a, f, p) {
          return this.easeTo(s.extend({ center: a }, f), p);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(a, f) {
          return this.jumpTo({ zoom: a }, f), this;
        }
        zoomTo(a, f, p) {
          return this.easeTo(s.extend({ zoom: a }, f), p);
        }
        zoomIn(a, f) {
          return this.zoomTo(this.getZoom() + 1, a, f), this;
        }
        zoomOut(a, f) {
          return this.zoomTo(this.getZoom() - 1, a, f), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(a, f) {
          return this.jumpTo({ bearing: a }, f), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(a, f) {
          return this.jumpTo({ padding: a }, f), this;
        }
        rotateTo(a, f, p) {
          return this.easeTo(s.extend({ bearing: a }, f), p);
        }
        resetNorth(a, f) {
          return this.rotateTo(0, s.extend({ duration: 1e3 }, a), f), this;
        }
        resetNorthPitch(a, f) {
          return this.easeTo(s.extend({ bearing: 0, pitch: 0, duration: 1e3 }, a), f), this;
        }
        snapToNorth(a, f) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(a, f) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(a, f) {
          return this.jumpTo({ pitch: a }, f), this;
        }
        cameraForBounds(a, f) {
          a = s.LngLatBounds.convert(a);
          const p = f && f.bearing || 0;
          return this._cameraForBoxAndBearing(a.getNorthWest(), a.getSouthEast(), p, f);
        }
        _cameraForBoxAndBearing(a, f, p, _) {
          const b = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (_ = s.extend({ padding: b, offset: [0, 0], maxZoom: this.transform.maxZoom }, _)).padding == "number") {
            const Ie = _.padding;
            _.padding = { top: Ie, bottom: Ie, right: Ie, left: Ie };
          }
          _.padding = s.extend(b, _.padding);
          const M = this.transform, P = M.padding, O = M.project(s.LngLat.convert(a)), D = M.project(s.LngLat.convert(f)), F = O.rotate(-p * Math.PI / 180), $ = D.rotate(-p * Math.PI / 180), G = new s.pointGeometry(Math.max(F.x, $.x), Math.max(F.y, $.y)), ie = new s.pointGeometry(Math.min(F.x, $.x), Math.min(F.y, $.y)), Q = G.sub(ie), te = (M.width - (P.left + P.right + _.padding.left + _.padding.right)) / Q.x, de = (M.height - (P.top + P.bottom + _.padding.top + _.padding.bottom)) / Q.y;
          if (de < 0 || te < 0)
            return void s.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const be = Math.min(M.scaleZoom(M.scale * Math.min(te, de)), _.maxZoom), Se = s.pointGeometry.convert(_.offset), oe = new s.pointGeometry((_.padding.left - _.padding.right) / 2, (_.padding.top - _.padding.bottom) / 2).rotate(p * Math.PI / 180), Le = Se.add(oe).mult(M.scale / M.zoomScale(be));
          return { center: M.unproject(O.add(D).div(2).sub(Le)), zoom: be, bearing: p };
        }
        fitBounds(a, f, p) {
          return this._fitInternal(this.cameraForBounds(a, f), f, p);
        }
        fitScreenCoordinates(a, f, p, _, b) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(s.pointGeometry.convert(a)), this.transform.pointLocation(s.pointGeometry.convert(f)), p, _), _, b);
        }
        _fitInternal(a, f, p) {
          return a ? (delete (f = s.extend(a, f)).padding, f.linear ? this.easeTo(f, p) : this.flyTo(f, p)) : this;
        }
        jumpTo(a, f) {
          this.stop();
          const p = this.transform;
          let _ = !1, b = !1, M = !1;
          return "zoom" in a && p.zoom !== +a.zoom && (_ = !0, p.zoom = +a.zoom), a.center !== void 0 && (p.center = s.LngLat.convert(a.center)), "bearing" in a && p.bearing !== +a.bearing && (b = !0, p.bearing = +a.bearing), "pitch" in a && p.pitch !== +a.pitch && (M = !0, p.pitch = +a.pitch), a.padding == null || p.isPaddingEqual(a.padding) || (p.padding = a.padding), this.fire(new s.Event("movestart", f)).fire(new s.Event("move", f)), _ && this.fire(new s.Event("zoomstart", f)).fire(new s.Event("zoom", f)).fire(new s.Event("zoomend", f)), b && this.fire(new s.Event("rotatestart", f)).fire(new s.Event("rotate", f)).fire(new s.Event("rotateend", f)), M && this.fire(new s.Event("pitchstart", f)).fire(new s.Event("pitch", f)).fire(new s.Event("pitchend", f)), this.fire(new s.Event("moveend", f));
        }
        calculateCameraOptionsFromTo(a, f, p, _ = 0) {
          const b = s.MercatorCoordinate.fromLngLat(a, f), M = s.MercatorCoordinate.fromLngLat(p, _), P = M.x - b.x, O = M.y - b.y, D = M.z - b.z, F = Math.hypot(P, O, D);
          if (F === 0)
            throw new Error("Can't calculate camera options with same From and To");
          const $ = Math.hypot(P, O), G = this.transform.scaleZoom(this.transform.cameraToCenterDistance / F / this.transform.tileSize), ie = 180 * Math.atan2(P, -O) / Math.PI;
          let Q = 180 * Math.acos($ / F) / Math.PI;
          return Q = D < 0 ? 90 - Q : 90 + Q, { center: M.toLngLat(), zoom: G, pitch: Q, bearing: ie };
        }
        easeTo(a, f) {
          this._stop(!1, a.easeId), ((a = s.extend({ offset: [0, 0], duration: 500, easing: s.ease }, a)).animate === !1 || !a.essential && s.exported.prefersReducedMotion) && (a.duration = 0);
          const p = this.transform, _ = this.getZoom(), b = this.getBearing(), M = this.getPitch(), P = this.getPadding(), O = "zoom" in a ? +a.zoom : _, D = "bearing" in a ? this._normalizeBearing(a.bearing, b) : b, F = "pitch" in a ? +a.pitch : M, $ = "padding" in a ? a.padding : p.padding, G = s.pointGeometry.convert(a.offset);
          let ie = p.centerPoint.add(G);
          const Q = p.pointLocation(ie), te = s.LngLat.convert(a.center || Q);
          this._normalizeCenter(te);
          const de = p.project(Q), be = p.project(te).sub(de), Se = p.zoomScale(O - _);
          let oe, Le;
          a.around && (oe = s.LngLat.convert(a.around), Le = p.locationPoint(oe));
          const Ie = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || O !== _, this._rotating = this._rotating || b !== D, this._pitching = this._pitching || F !== M, this._padding = !p.isPaddingEqual($), this._easeId = a.easeId, this._prepareEase(f, a.noMoveStart, Ie), this._ease((Be) => {
            if (this._zooming && (p.zoom = s.number(_, O, Be)), this._rotating && (p.bearing = s.number(b, D, Be)), this._pitching && (p.pitch = s.number(M, F, Be)), this._padding && (p.interpolatePadding(P, $, Be), ie = p.centerPoint.add(G)), oe)
              p.setLocationAtPoint(oe, Le);
            else {
              const Ue = p.zoomScale(p.zoom - _), Qe = O > _ ? Math.min(2, Se) : Math.max(0.5, Se), Fe = Math.pow(Qe, 1 - Be), bt = p.unproject(de.add(be.mult(Be * Fe)).mult(Ue));
              p.setLocationAtPoint(p.renderWorldCopies ? bt.wrap() : bt, ie);
            }
            this._fireMoveEvents(f);
          }, (Be) => {
            this._afterEase(f, Be);
          }, a), this;
        }
        _prepareEase(a, f, p = {}) {
          this._moving = !0, this.fire(new s.Event("freezeElevation", { freeze: !0 })), f || p.moving || this.fire(new s.Event("movestart", a)), this._zooming && !p.zooming && this.fire(new s.Event("zoomstart", a)), this._rotating && !p.rotating && this.fire(new s.Event("rotatestart", a)), this._pitching && !p.pitching && this.fire(new s.Event("pitchstart", a));
        }
        _fireMoveEvents(a) {
          this.fire(new s.Event("move", a)), this._zooming && this.fire(new s.Event("zoom", a)), this._rotating && this.fire(new s.Event("rotate", a)), this._pitching && this.fire(new s.Event("pitch", a));
        }
        _afterEase(a, f) {
          if (this._easeId && f && this._easeId === f)
            return;
          delete this._easeId, this.fire(new s.Event("freezeElevation", { freeze: !1 }));
          const p = this._zooming, _ = this._rotating, b = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, p && this.fire(new s.Event("zoomend", a)), _ && this.fire(new s.Event("rotateend", a)), b && this.fire(new s.Event("pitchend", a)), this.fire(new s.Event("moveend", a));
        }
        flyTo(a, f) {
          if (!a.essential && s.exported.prefersReducedMotion) {
            const zt = s.pick(a, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(zt, f);
          }
          this.stop(), a = s.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: s.ease }, a);
          const p = this.transform, _ = this.getZoom(), b = this.getBearing(), M = this.getPitch(), P = this.getPadding(), O = "zoom" in a ? s.clamp(+a.zoom, p.minZoom, p.maxZoom) : _, D = "bearing" in a ? this._normalizeBearing(a.bearing, b) : b, F = "pitch" in a ? +a.pitch : M, $ = "padding" in a ? a.padding : p.padding, G = p.zoomScale(O - _), ie = s.pointGeometry.convert(a.offset);
          let Q = p.centerPoint.add(ie);
          const te = p.pointLocation(Q), de = s.LngLat.convert(a.center || te);
          this._normalizeCenter(de);
          const be = p.project(te), Se = p.project(de).sub(be);
          let oe = a.curve;
          const Le = Math.max(p.width, p.height), Ie = Le / G, Be = Se.mag();
          if ("minZoom" in a) {
            const zt = s.clamp(Math.min(a.minZoom, _, O), p.minZoom, p.maxZoom), Ur = Le / p.zoomScale(zt - _);
            oe = Math.sqrt(Ur / Be * 2);
          }
          const Ue = oe * oe;
          function Qe(zt) {
            const Ur = (Ie * Ie - Le * Le + (zt ? -1 : 1) * Ue * Ue * Be * Be) / (2 * (zt ? Ie : Le) * Ue * Be);
            return Math.log(Math.sqrt(Ur * Ur + 1) - Ur);
          }
          function Fe(zt) {
            return (Math.exp(zt) - Math.exp(-zt)) / 2;
          }
          function bt(zt) {
            return (Math.exp(zt) + Math.exp(-zt)) / 2;
          }
          const ht = Qe(0);
          let wt = function(zt) {
            return bt(ht) / bt(ht + oe * zt);
          }, er = function(zt) {
            return Le * ((bt(ht) * (Fe(Ur = ht + oe * zt) / bt(Ur)) - Fe(ht)) / Ue) / Be;
            var Ur;
          }, sr = (Qe(1) - ht) / oe;
          if (Math.abs(Be) < 1e-6 || !isFinite(sr)) {
            if (Math.abs(Le - Ie) < 1e-6)
              return this.easeTo(a, f);
            const zt = Ie < Le ? -1 : 1;
            sr = Math.abs(Math.log(Ie / Le)) / oe, er = function() {
              return 0;
            }, wt = function(Ur) {
              return Math.exp(zt * oe * Ur);
            };
          }
          return a.duration = "duration" in a ? +a.duration : 1e3 * sr / ("screenSpeed" in a ? +a.screenSpeed / oe : +a.speed), a.maxDuration && a.duration > a.maxDuration && (a.duration = 0), this._zooming = !0, this._rotating = b !== D, this._pitching = F !== M, this._padding = !p.isPaddingEqual($), this._prepareEase(f, !1), this._ease((zt) => {
            const Ur = zt * sr, $r = 1 / wt(Ur);
            p.zoom = zt === 1 ? O : _ + p.scaleZoom($r), this._rotating && (p.bearing = s.number(b, D, zt)), this._pitching && (p.pitch = s.number(M, F, zt)), this._padding && (p.interpolatePadding(P, $, zt), Q = p.centerPoint.add(ie));
            const Tr = zt === 1 ? de : p.unproject(be.add(Se.mult(er(Ur))).mult($r));
            p.setLocationAtPoint(p.renderWorldCopies ? Tr.wrap() : Tr, Q), this._fireMoveEvents(f);
          }, () => this._afterEase(f), a), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(a, f) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const p = this._onEaseEnd;
            delete this._onEaseEnd, p.call(this, f);
          }
          if (!a) {
            const p = this.handlers;
            p && p.stop(!1);
          }
          return this;
        }
        _ease(a, f, p) {
          p.animate === !1 || p.duration === 0 ? (a(1), f()) : (this._easeStart = s.exported.now(), this._easeOptions = p, this._onEaseFrame = a, this._onEaseEnd = f, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const a = Math.min((s.exported.now() - this._easeStart) / this._easeOptions.duration, 1);
          this._onEaseFrame(this._easeOptions.easing(a)), a < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(a, f) {
          a = s.wrap(a, -180, 180);
          const p = Math.abs(a - f);
          return Math.abs(a - 360 - f) < p && (a -= 360), Math.abs(a + 360 - f) < p && (a += 360), a;
        }
        _normalizeCenter(a) {
          const f = this.transform;
          if (!f.renderWorldCopies || f.lngRange)
            return;
          const p = a.lng - f.center.lng;
          a.lng += p > 180 ? -360 : p < -180 ? 360 : 0;
        }
      }
      class bc {
        constructor(a = {}) {
          this.options = a, s.bindAll(["_toggleAttribution", "_updateData", "_updateCompact", "_updateCompactMinimize"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(a) {
          return this._map = a, this._compact = this.options && this.options.compact, this._container = S.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = S.create("summary", "maplibregl-ctrl-attrib-button mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = S.create("div", "maplibregl-ctrl-attrib-inner mapboxgl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          S.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(a, f) {
          const p = this._map._getUIString(`AttributionControl.${f}`);
          a.title = p, a.setAttribute("aria-label", p);
        }
        _toggleAttribution() {
          this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.classList.add("maplibregl-compact-show", "mapboxgl-compact-show"), this._container.removeAttribute("open")));
        }
        _updateData(a) {
          !a || a.sourceDataType !== "metadata" && a.sourceDataType !== "visibility" && a.dataType !== "style" && a.type !== "terrain" || this._updateAttributions();
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let a = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? a = a.concat(this.options.customAttribution.map((_) => typeof _ != "string" ? "" : _)) : typeof this.options.customAttribution == "string" && a.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const _ = this._map.style.stylesheet;
            this.styleOwner = _.owner, this.styleId = _.id;
          }
          const f = this._map.style.sourceCaches;
          for (const _ in f) {
            const b = f[_];
            if (b.used || b.usedForTerrain) {
              const M = b.getSource();
              M.attribution && a.indexOf(M.attribution) < 0 && a.push(M.attribution);
            }
          }
          a = a.filter((_) => String(_).trim()), a.sort((_, b) => _.length - b.length), a = a.filter((_, b) => {
            for (let M = b + 1; M < a.length; M++)
              if (a[M].indexOf(_) >= 0)
                return !1;
            return !0;
          });
          const p = a.join(" | ");
          p !== this._attribHTML && (this._attribHTML = p, a.length ? (this._innerContainer.innerHTML = p, this._container.classList.remove("maplibregl-attrib-empty", "mapboxgl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty", "mapboxgl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "mapboxgl-compact", "maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show", "mapboxgl-compact", "mapboxgl-compact-show"));
        }
        _updateCompactMinimize() {
          this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show");
        }
      }
      class Nu {
        constructor(a = {}) {
          this.options = a, s.bindAll(["_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(a) {
          this._map = a, this._compact = this.options && this.options.compact, this._container = S.create("div", "maplibregl-ctrl mapboxgl-ctrl");
          const f = S.create("a", "maplibregl-ctrl-logo mapboxgl-ctrl-logo");
          return f.target = "_blank", f.rel = "noopener nofollow", f.href = "https://maplibre.org/", f.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), f.setAttribute("rel", "noopener nofollow"), this._container.appendChild(f), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          S.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
        _updateCompact() {
          const a = this._container.children;
          if (a.length) {
            const f = a[0];
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && f.classList.add("maplibregl-compact", "mapboxgl-compact") : f.classList.remove("maplibregl-compact", "mapboxgl-compact");
          }
        }
      }
      class Wp {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(a) {
          const f = ++this._id;
          return this._queue.push({ callback: a, id: f, cancelled: !1 }), f;
        }
        remove(a) {
          const f = this._currentlyRunning, p = f ? this._queue.concat(f) : this._queue;
          for (const _ of p)
            if (_.id === a)
              return void (_.cancelled = !0);
        }
        run(a = 0) {
          if (this._currentlyRunning)
            throw new Error("Attempting to run(), but is already running.");
          const f = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const p of f)
            if (!p.cancelled && (p.callback(a), this._cleared))
              break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      const Xp = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.enableTerrain": "Enable terrain", "TerrainControl.disableTerrain": "Disable terrain" }, Zp = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: void 0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, maplibreLogo: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, fadeDuration: 300, crossSourceCollisions: !0 }, d_ = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class Wo {
        constructor(a, f, p = !1) {
          this._clickTolerance = 10, this.element = f, this.mouseRotate = new ua({ clickTolerance: a.dragRotate._mouseRotate._clickTolerance }), this.map = a, p && (this.mousePitch = new Ct({ clickTolerance: a.dragRotate._mousePitch._clickTolerance })), s.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), S.addEventListener(f, "mousedown", this.mousedown), S.addEventListener(f, "touchstart", this.touchstart, { passive: !1 }), S.addEventListener(f, "touchmove", this.touchmove), S.addEventListener(f, "touchend", this.touchend), S.addEventListener(f, "touchcancel", this.reset);
        }
        down(a, f) {
          this.mouseRotate.mousedown(a, f), this.mousePitch && this.mousePitch.mousedown(a, f), S.disableDrag();
        }
        move(a, f) {
          const p = this.map, _ = this.mouseRotate.mousemoveWindow(a, f);
          if (_ && _.bearingDelta && p.setBearing(p.getBearing() + _.bearingDelta), this.mousePitch) {
            const b = this.mousePitch.mousemoveWindow(a, f);
            b && b.pitchDelta && p.setPitch(p.getPitch() + b.pitchDelta);
          }
        }
        off() {
          const a = this.element;
          S.removeEventListener(a, "mousedown", this.mousedown), S.removeEventListener(a, "touchstart", this.touchstart, { passive: !1 }), S.removeEventListener(a, "touchmove", this.touchmove), S.removeEventListener(a, "touchend", this.touchend), S.removeEventListener(a, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          S.enableDrag(), S.removeEventListener(window, "mousemove", this.mousemove), S.removeEventListener(window, "mouseup", this.mouseup);
        }
        mousedown(a) {
          this.down(s.extend({}, a, { ctrlKey: !0, preventDefault: () => a.preventDefault() }), S.mousePos(this.element, a)), S.addEventListener(window, "mousemove", this.mousemove), S.addEventListener(window, "mouseup", this.mouseup);
        }
        mousemove(a) {
          this.move(a, S.mousePos(this.element, a));
        }
        mouseup(a) {
          this.mouseRotate.mouseupWindow(a), this.mousePitch && this.mousePitch.mouseupWindow(a), this.offTemp();
        }
        touchstart(a) {
          a.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = S.touchPos(this.element, a.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: () => a.preventDefault() }, this._startPos));
        }
        touchmove(a) {
          a.targetTouches.length !== 1 ? this.reset() : (this._lastPos = S.touchPos(this.element, a.targetTouches)[0], this.move({ preventDefault: () => a.preventDefault() }, this._lastPos));
        }
        touchend(a) {
          a.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      function wc(g, a, f) {
        if (g = new s.LngLat(g.lng, g.lat), a) {
          const p = new s.LngLat(g.lng - 360, g.lat), _ = new s.LngLat(g.lng + 360, g.lat), b = f.locationPoint(g).distSqr(a);
          f.locationPoint(p).distSqr(a) < b ? g = p : f.locationPoint(_).distSqr(a) < b && (g = _);
        }
        for (; Math.abs(g.lng - f.center.lng) > 180; ) {
          const p = f.locationPoint(g);
          if (p.x >= 0 && p.y >= 0 && p.x <= f.width && p.y <= f.height)
            break;
          g.lng > f.center.lng ? g.lng -= 360 : g.lng += 360;
        }
        return g;
      }
      const Dt = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function jt(g, a, f) {
        const p = g.classList;
        for (const _ in Dt)
          p.remove(`maplibregl-${f}-anchor-${_}`, `mapboxgl-${f}-anchor-${_}`);
        p.add(`maplibregl-${f}-anchor-${a}`, `mapboxgl-${f}-anchor-${a}`);
      }
      class sl extends s.Evented {
        constructor(a, f) {
          if (super(), (a instanceof HTMLElement || f) && (a = s.extend({ element: a }, f)), s.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = a && a.anchor || "center", this._color = a && a.color || "#3FB1CE", this._scale = a && a.scale || 1, this._draggable = a && a.draggable || !1, this._clickTolerance = a && a.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = a && a.rotation || 0, this._rotationAlignment = a && a.rotationAlignment || "auto", this._pitchAlignment = a && a.pitchAlignment && a.pitchAlignment !== "auto" ? a.pitchAlignment : this._rotationAlignment, a && a.element)
            this._element = a.element, this._offset = s.pointGeometry.convert(a && a.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = S.create("div"), this._element.setAttribute("aria-label", "Map marker");
            const p = S.createNS("http://www.w3.org/2000/svg", "svg"), _ = 41, b = 27;
            p.setAttributeNS(null, "display", "block"), p.setAttributeNS(null, "height", `${_}px`), p.setAttributeNS(null, "width", `${b}px`), p.setAttributeNS(null, "viewBox", `0 0 ${b} ${_}`);
            const M = S.createNS("http://www.w3.org/2000/svg", "g");
            M.setAttributeNS(null, "stroke", "none"), M.setAttributeNS(null, "stroke-width", "1"), M.setAttributeNS(null, "fill", "none"), M.setAttributeNS(null, "fill-rule", "evenodd");
            const P = S.createNS("http://www.w3.org/2000/svg", "g");
            P.setAttributeNS(null, "fill-rule", "nonzero");
            const O = S.createNS("http://www.w3.org/2000/svg", "g");
            O.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), O.setAttributeNS(null, "fill", "#000000");
            const D = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const Se of D) {
              const oe = S.createNS("http://www.w3.org/2000/svg", "ellipse");
              oe.setAttributeNS(null, "opacity", "0.04"), oe.setAttributeNS(null, "cx", "10.5"), oe.setAttributeNS(null, "cy", "5.80029008"), oe.setAttributeNS(null, "rx", Se.rx), oe.setAttributeNS(null, "ry", Se.ry), O.appendChild(oe);
            }
            const F = S.createNS("http://www.w3.org/2000/svg", "g");
            F.setAttributeNS(null, "fill", this._color);
            const $ = S.createNS("http://www.w3.org/2000/svg", "path");
            $.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), F.appendChild($);
            const G = S.createNS("http://www.w3.org/2000/svg", "g");
            G.setAttributeNS(null, "opacity", "0.25"), G.setAttributeNS(null, "fill", "#000000");
            const ie = S.createNS("http://www.w3.org/2000/svg", "path");
            ie.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), G.appendChild(ie);
            const Q = S.createNS("http://www.w3.org/2000/svg", "g");
            Q.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), Q.setAttributeNS(null, "fill", "#FFFFFF");
            const te = S.createNS("http://www.w3.org/2000/svg", "g");
            te.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const de = S.createNS("http://www.w3.org/2000/svg", "circle");
            de.setAttributeNS(null, "fill", "#000000"), de.setAttributeNS(null, "opacity", "0.25"), de.setAttributeNS(null, "cx", "5.5"), de.setAttributeNS(null, "cy", "5.5"), de.setAttributeNS(null, "r", "5.4999962");
            const be = S.createNS("http://www.w3.org/2000/svg", "circle");
            be.setAttributeNS(null, "fill", "#FFFFFF"), be.setAttributeNS(null, "cx", "5.5"), be.setAttributeNS(null, "cy", "5.5"), be.setAttributeNS(null, "r", "5.4999962"), te.appendChild(de), te.appendChild(be), P.appendChild(O), P.appendChild(F), P.appendChild(G), P.appendChild(Q), P.appendChild(te), p.appendChild(P), p.setAttributeNS(null, "height", _ * this._scale + "px"), p.setAttributeNS(null, "width", b * this._scale + "px"), this._element.appendChild(p), this._offset = s.pointGeometry.convert(a && a.offset || [0, -14]);
          }
          this._element.classList.add("maplibregl-marker", "mapboxgl-marker"), this._element.addEventListener("dragstart", (p) => {
            p.preventDefault();
          }), this._element.addEventListener("mousedown", (p) => {
            p.preventDefault();
          }), jt(this._element, this._anchor, "marker"), this._popup = null;
        }
        addTo(a) {
          return this.remove(), this._map = a, a.getCanvasContainer().appendChild(this._element), a.on("move", this._update), a.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), S.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(a) {
          return this._lngLat = s.LngLat.convert(a), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(a) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), a) {
            if (!("offset" in a.options)) {
              const _ = Math.sqrt(Math.pow(13.5, 2) / 2);
              a.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [_, -1 * (38.1 - 13.5 + _)], "bottom-right": [-_, -1 * (38.1 - 13.5 + _)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = a, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        _onKeyPress(a) {
          const f = a.code, p = a.charCode || a.keyCode;
          f !== "Space" && f !== "Enter" && p !== 32 && p !== 13 || this.togglePopup();
        }
        _onMapClick(a) {
          const f = a.originalEvent.target, p = this._element;
          this._popup && (f === p || p.contains(f)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const a = this._popup;
          return a ? (a.isOpen() ? a.remove() : a.addTo(this._map), this) : this;
        }
        _update(a) {
          if (!this._map)
            return;
          this._map.transform.renderWorldCopies && (this._lngLat = wc(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
          let f = "";
          this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? f = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (f = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
          let p = "";
          this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? p = "rotateX(0deg)" : this._pitchAlignment === "map" && (p = `rotateX(${this._map.getPitch()}deg)`), a && a.type !== "moveend" || (this._pos = this._pos.round()), S.setTransform(this._element, `${Dt[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${p} ${f}`), this._map.style && this._map.style.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(() => {
            const _ = this._map.unproject(this._pos), b = 40075016686e-3 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
            this._element.style.opacity = _.distanceTo(this._lngLat) > 20 * b ? "0.2" : "1.0", this._opacityTimeout = null;
          }, 100));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(a) {
          return this._offset = s.pointGeometry.convert(a), this._update(), this;
        }
        _onMove(a) {
          if (!this._isDragging) {
            const f = this._clickTolerance || this._map._clickTolerance;
            this._isDragging = a.point.dist(this._pointerdownPos) >= f;
          }
          this._isDragging && (this._pos = a.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.Event("dragstart"))), this.fire(new s.Event("drag")));
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.Event("dragend")), this._state = "inactive";
        }
        _addDragHandler(a) {
          this._element.contains(a.originalEvent.target) && (a.preventDefault(), this._positionDelta = a.point.sub(this._pos).add(this._offset), this._pointerdownPos = a.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
        }
        setDraggable(a) {
          return this._draggable = !!a, this._map && (a ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(a) {
          return this._rotation = a || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(a) {
          return this._rotationAlignment = a || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(a) {
          return this._pitchAlignment = a && a !== "auto" ? a : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
      }
      const Sf = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
      let Ua, pi = 0, $a = !1;
      const Xo = { maxWidth: 100, unit: "metric" };
      function Hp(g, a, f) {
        const p = f && f.maxWidth || 100, _ = g._container.clientHeight / 2, b = g.unproject([0, _]), M = g.unproject([p, _]), P = b.distanceTo(M);
        if (f && f.unit === "imperial") {
          const O = 3.2808 * P;
          O > 5280 ? Va(a, p, O / 5280, g._getUIString("ScaleControl.Miles")) : Va(a, p, O, g._getUIString("ScaleControl.Feet"));
        } else
          f && f.unit === "nautical" ? Va(a, p, P / 1852, g._getUIString("ScaleControl.NauticalMiles")) : P >= 1e3 ? Va(a, p, P / 1e3, g._getUIString("ScaleControl.Kilometers")) : Va(a, p, P, g._getUIString("ScaleControl.Meters"));
      }
      function Va(g, a, f, p) {
        const _ = function(b) {
          const M = Math.pow(10, `${Math.floor(b)}`.length - 1);
          let P = b / M;
          return P = P >= 10 ? 10 : P >= 5 ? 5 : P >= 3 ? 3 : P >= 2 ? 2 : P >= 1 ? 1 : function(O) {
            const D = Math.pow(10, Math.ceil(-Math.log(O) / Math.LN10));
            return Math.round(O * D) / D;
          }(P), M * P;
        }(f);
        g.style.width = a * (_ / f) + "px", g.innerHTML = `${_}&nbsp;${p}`;
      }
      const Rn = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, jn = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function Mf(g) {
        if (g) {
          if (typeof g == "number") {
            const a = Math.round(Math.sqrt(0.5 * Math.pow(g, 2)));
            return { center: new s.pointGeometry(0, 0), top: new s.pointGeometry(0, g), "top-left": new s.pointGeometry(a, a), "top-right": new s.pointGeometry(-a, a), bottom: new s.pointGeometry(0, -g), "bottom-left": new s.pointGeometry(a, -a), "bottom-right": new s.pointGeometry(-a, -a), left: new s.pointGeometry(g, 0), right: new s.pointGeometry(-g, 0) };
          }
          if (g instanceof s.pointGeometry || Array.isArray(g)) {
            const a = s.pointGeometry.convert(g);
            return { center: a, top: a, "top-left": a, "top-right": a, bottom: a, "bottom-left": a, "bottom-right": a, left: a, right: a };
          }
          return { center: s.pointGeometry.convert(g.center || [0, 0]), top: s.pointGeometry.convert(g.top || [0, 0]), "top-left": s.pointGeometry.convert(g["top-left"] || [0, 0]), "top-right": s.pointGeometry.convert(g["top-right"] || [0, 0]), bottom: s.pointGeometry.convert(g.bottom || [0, 0]), "bottom-left": s.pointGeometry.convert(g["bottom-left"] || [0, 0]), "bottom-right": s.pointGeometry.convert(g["bottom-right"] || [0, 0]), left: s.pointGeometry.convert(g.left || [0, 0]), right: s.pointGeometry.convert(g.right || [0, 0]) };
        }
        return Mf(new s.pointGeometry(0, 0));
      }
      const _s = { supported: m, setRTLTextPlugin: s.setRTLTextPlugin, getRTLTextPluginStatus: s.getRTLTextPluginStatus, Map: class extends xn {
        constructor(g) {
          var a;
          if (s.PerformanceUtils.mark(s.PerformanceMarkers.create), (g = s.extend({}, Zp, g)).minZoom != null && g.maxZoom != null && g.minZoom > g.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (g.minPitch != null && g.maxPitch != null && g.minPitch > g.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (g.minPitch != null && g.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (g.maxPitch != null && g.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (super(new dc(g.minZoom, g.maxZoom, g.minPitch, g.maxPitch, g.renderWorldCopies), { bearingSnap: g.bearingSnap }), this._interactive = g.interactive, this._cooperativeGestures = g.cooperativeGestures, this._maxTileCacheSize = g.maxTileCacheSize, this._failIfMajorPerformanceCaveat = g.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = g.preserveDrawingBuffer, this._antialias = g.antialias, this._trackResize = g.trackResize, this._bearingSnap = g.bearingSnap, this._refreshExpiredTiles = g.refreshExpiredTiles, this._fadeDuration = g.fadeDuration, this._crossSourceCollisions = g.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = g.collectResourceTiming, this._renderTaskQueue = new Wp(), this._controls = [], this._mapId = s.uniqueId(), this._locale = s.extend({}, Xp, g.locale), this._clickTolerance = g.clickTolerance, this._pixelRatio = (a = g.pixelRatio) !== null && a !== void 0 ? a : devicePixelRatio, this._requestManager = new A(g.transformRequest), typeof g.container == "string") {
            if (this._container = document.getElementById(g.container), !this._container)
              throw new Error(`Container '${g.container}' not found.`);
          } else {
            if (!(g.container instanceof HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = g.container;
          }
          if (g.maxBounds && this.setMaxBounds(g.maxBounds), s.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)
            throw new Error("Failed to initialize WebGL.");
          this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => {
            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
          }), typeof window < "u" && (addEventListener("online", this._onWindowOnline, !1), addEventListener("resize", this._onWindowResize, !1), addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new qp(this, g), this._cooperativeGestures && this._setupCooperativeGestures(), this._hash = g.hash && new Dp(typeof g.hash == "string" && g.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: g.center, zoom: g.zoom, bearing: g.bearing, pitch: g.pitch }), g.bounds && (this.resize(), this.fitBounds(g.bounds, s.extend({}, g.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = g.localIdeographFontFamily, g.style && this.setStyle(g.style, { localIdeographFontFamily: g.localIdeographFontFamily }), g.attributionControl && this.addControl(new bc({ customAttribution: g.customAttribution })), g.maplibreLogo && this.addControl(new Nu(), g.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (f) => {
            this._update(f.dataType === "style"), this.fire(new s.Event(`${f.dataType}data`, f));
          }), this.on("dataloading", (f) => {
            this.fire(new s.Event(`${f.dataType}dataloading`, f));
          }), this.on("dataabort", (f) => {
            this.fire(new s.Event("sourcedataabort", f));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(g, a) {
          if (a === void 0 && (a = g.getDefaultPosition ? g.getDefaultPosition() : "top-right"), !g || !g.onAdd)
            return this.fire(new s.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const f = g.onAdd(this);
          this._controls.push(g);
          const p = this._controlPositions[a];
          return a.indexOf("bottom") !== -1 ? p.insertBefore(f, p.firstChild) : p.appendChild(f), this;
        }
        removeControl(g) {
          if (!g || !g.onRemove)
            return this.fire(new s.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const a = this._controls.indexOf(g);
          return a > -1 && this._controls.splice(a, 1), g.onRemove(this), this;
        }
        hasControl(g) {
          return this._controls.indexOf(g) > -1;
        }
        calculateCameraOptionsFromTo(g, a, f, p) {
          return p == null && this.style.terrain && (p = this.transform.getElevation(f, this.style.terrain)), super.calculateCameraOptionsFromTo(g, a, f, p);
        }
        resize(g) {
          const a = this._containerDimensions(), f = a[0], p = a[1];
          this._resizeCanvas(f, p, this.getPixelRatio()), this.transform.resize(f, p), this.painter.resize(f, p, this.getPixelRatio());
          const _ = !this._moving;
          return _ && (this.stop(), this.fire(new s.Event("movestart", g)).fire(new s.Event("move", g))), this.fire(new s.Event("resize", g)), _ && this.fire(new s.Event("moveend", g)), this;
        }
        getPixelRatio() {
          return this._pixelRatio;
        }
        setPixelRatio(g) {
          const [a, f] = this._containerDimensions();
          this._pixelRatio = g, this._resizeCanvas(a, f, g), this.painter.resize(a, f, g);
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(g) {
          return this.transform.setMaxBounds(s.LngLatBounds.convert(g)), this._update();
        }
        setMinZoom(g) {
          if ((g = g == null ? -2 : g) >= -2 && g <= this.transform.maxZoom)
            return this.transform.minZoom = g, this._update(), this.getZoom() < g && this.setZoom(g), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(g) {
          if ((g = g == null ? 22 : g) >= this.transform.minZoom)
            return this.transform.maxZoom = g, this._update(), this.getZoom() > g && this.setZoom(g), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(g) {
          if ((g = g == null ? 0 : g) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (g >= 0 && g <= this.transform.maxPitch)
            return this.transform.minPitch = g, this._update(), this.getPitch() < g && this.setPitch(g), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(g) {
          if ((g = g == null ? 60 : g) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (g >= this.transform.minPitch)
            return this.transform.maxPitch = g, this._update(), this.getPitch() > g && this.setPitch(g), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(g) {
          return this.transform.renderWorldCopies = g, this._update();
        }
        project(g) {
          return this.transform.locationPoint(s.LngLat.convert(g), this.style && this.style.terrain);
        }
        unproject(g) {
          return this.transform.pointLocation(s.pointGeometry.convert(g), this.style && this.style.terrain);
        }
        isMoving() {
          return this._moving || this.handlers.isMoving();
        }
        isZooming() {
          return this._zooming || this.handlers.isZooming();
        }
        isRotating() {
          return this._rotating || this.handlers.isRotating();
        }
        _createDelegatedListener(g, a, f) {
          if (g === "mouseenter" || g === "mouseover") {
            let p = !1;
            return { layer: a, listener: f, delegates: { mousemove: (b) => {
              const M = this.getLayer(a) ? this.queryRenderedFeatures(b.point, { layers: [a] }) : [];
              M.length ? p || (p = !0, f.call(this, new eo(g, this, b.originalEvent, { features: M }))) : p = !1;
            }, mouseout: () => {
              p = !1;
            } } };
          }
          if (g === "mouseleave" || g === "mouseout") {
            let p = !1;
            return { layer: a, listener: f, delegates: { mousemove: (M) => {
              (this.getLayer(a) ? this.queryRenderedFeatures(M.point, { layers: [a] }) : []).length ? p = !0 : p && (p = !1, f.call(this, new eo(g, this, M.originalEvent)));
            }, mouseout: (M) => {
              p && (p = !1, f.call(this, new eo(g, this, M.originalEvent)));
            } } };
          }
          {
            const p = (_) => {
              const b = this.getLayer(a) ? this.queryRenderedFeatures(_.point, { layers: [a] }) : [];
              b.length && (_.features = b, f.call(this, _), delete _.features);
            };
            return { layer: a, listener: f, delegates: { [g]: p } };
          }
        }
        on(g, a, f) {
          if (f === void 0)
            return super.on(g, a);
          const p = this._createDelegatedListener(g, a, f);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[g] = this._delegatedListeners[g] || [], this._delegatedListeners[g].push(p);
          for (const _ in p.delegates)
            this.on(_, p.delegates[_]);
          return this;
        }
        once(g, a, f) {
          if (f === void 0)
            return super.once(g, a);
          const p = this._createDelegatedListener(g, a, f);
          for (const _ in p.delegates)
            this.once(_, p.delegates[_]);
          return this;
        }
        off(g, a, f) {
          return f === void 0 ? super.off(g, a) : (this._delegatedListeners && this._delegatedListeners[g] && ((p) => {
            const _ = this._delegatedListeners[g];
            for (let b = 0; b < _.length; b++) {
              const M = _[b];
              if (M.layer === a && M.listener === f) {
                for (const P in M.delegates)
                  this.off(P, M.delegates[P]);
                return _.splice(b, 1), this;
              }
            }
          })(), this);
        }
        queryRenderedFeatures(g, a) {
          if (!this.style)
            return [];
          let f;
          if (a !== void 0 || g === void 0 || g instanceof s.pointGeometry || Array.isArray(g) || (a = g, g = void 0), a = a || {}, (g = g || [[0, 0], [this.transform.width, this.transform.height]]) instanceof s.pointGeometry || typeof g[0] == "number")
            f = [s.pointGeometry.convert(g)];
          else {
            const p = s.pointGeometry.convert(g[0]), _ = s.pointGeometry.convert(g[1]);
            f = [p, new s.pointGeometry(_.x, p.y), _, new s.pointGeometry(p.x, _.y), p];
          }
          return this.style.queryRenderedFeatures(f, a, this.transform);
        }
        querySourceFeatures(g, a) {
          return this.style.querySourceFeatures(g, a);
        }
        setStyle(g, a) {
          return (a = s.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, a)).diff !== !1 && a.localIdeographFontFamily === this._localIdeographFontFamily && this.style && g ? (this._diffStyle(g, a), this) : (this._localIdeographFontFamily = a.localIdeographFontFamily, this._updateStyle(g, a));
        }
        setTransformRequest(g) {
          return this._requestManager.setTransformRequest(g), this;
        }
        _getUIString(g) {
          const a = this._locale[g];
          if (a == null)
            throw new Error(`Missing UI string '${g}'`);
          return a;
        }
        _updateStyle(g, a) {
          return this.style && (this.style.setEventedParent(null), this.style._remove()), g ? (this.style = new bi(this, a || {}), this.style.setEventedParent(this, { style: this.style }), typeof g == "string" ? this.style.loadURL(g) : this.style.loadJSON(g), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new bi(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(g, a) {
          if (typeof g == "string") {
            const f = this._requestManager.transformRequest(g, s.ResourceType.Style);
            s.getJSON(f, (p, _) => {
              p ? this.fire(new s.ErrorEvent(p)) : _ && this._updateDiff(_, a);
            });
          } else
            typeof g == "object" && this._updateDiff(g, a);
        }
        _updateDiff(g, a) {
          try {
            this.style.setState(g) && this._update(!0);
          } catch (f) {
            s.warnOnce(`Unable to perform style diff: ${f.message || f.error || f}.  Rebuilding the style from scratch.`), this._updateStyle(g, a);
          }
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : s.warnOnce("There is no style added to the map.");
        }
        addSource(g, a) {
          return this._lazyInitEmptyStyle(), this.style.addSource(g, a), this._update(!0);
        }
        isSourceLoaded(g) {
          const a = this.style && this.style.sourceCaches[g];
          if (a !== void 0)
            return a.loaded();
          this.fire(new s.ErrorEvent(new Error(`There is no source with ID '${g}'`)));
        }
        setTerrain(g) {
          return this.style.setTerrain(g), this;
        }
        getTerrain() {
          return this.style.terrain && this.style.terrain.options;
        }
        areTilesLoaded() {
          const g = this.style && this.style.sourceCaches;
          for (const a in g) {
            const f = g[a]._tiles;
            for (const p in f) {
              const _ = f[p];
              if (_.state !== "loaded" && _.state !== "errored")
                return !1;
            }
          }
          return !0;
        }
        addSourceType(g, a, f) {
          return this._lazyInitEmptyStyle(), this.style.addSourceType(g, a, f);
        }
        removeSource(g) {
          return this.style.removeSource(g), this._update(!0);
        }
        getSource(g) {
          return this.style.getSource(g);
        }
        addImage(g, a, { pixelRatio: f = 1, sdf: p = !1, stretchX: _, stretchY: b, content: M } = {}) {
          if (this._lazyInitEmptyStyle(), a instanceof HTMLImageElement || s.isImageBitmap(a)) {
            const { width: P, height: O, data: D } = s.exported.getImageData(a);
            this.style.addImage(g, { data: new s.RGBAImage({ width: P, height: O }, D), pixelRatio: f, stretchX: _, stretchY: b, content: M, sdf: p, version: 0 });
          } else {
            if (a.width === void 0 || a.height === void 0)
              return this.fire(new s.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: P, height: O, data: D } = a, F = a;
              this.style.addImage(g, { data: new s.RGBAImage({ width: P, height: O }, new Uint8Array(D)), pixelRatio: f, stretchX: _, stretchY: b, content: M, sdf: p, version: 0, userImage: F }), F.onAdd && F.onAdd(this, g);
            }
          }
        }
        updateImage(g, a) {
          const f = this.style.getImage(g);
          if (!f)
            return this.fire(new s.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const p = a instanceof HTMLImageElement || s.isImageBitmap(a) ? s.exported.getImageData(a) : a, { width: _, height: b, data: M } = p;
          if (_ === void 0 || b === void 0)
            return this.fire(new s.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (_ !== f.data.width || b !== f.data.height)
            return this.fire(new s.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const P = !(a instanceof HTMLImageElement || s.isImageBitmap(a));
          f.data.replace(M, P), this.style.updateImage(g, f);
        }
        hasImage(g) {
          return g ? !!this.style.getImage(g) : (this.fire(new s.ErrorEvent(new Error("Missing required image id"))), !1);
        }
        removeImage(g) {
          this.style.removeImage(g);
        }
        loadImage(g, a) {
          s.getImage(this._requestManager.transformRequest(g, s.ResourceType.Image), a);
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(g, a) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(g, a), this._update(!0);
        }
        moveLayer(g, a) {
          return this.style.moveLayer(g, a), this._update(!0);
        }
        removeLayer(g) {
          return this.style.removeLayer(g), this._update(!0);
        }
        getLayer(g) {
          return this.style.getLayer(g);
        }
        setLayerZoomRange(g, a, f) {
          return this.style.setLayerZoomRange(g, a, f), this._update(!0);
        }
        setFilter(g, a, f = {}) {
          return this.style.setFilter(g, a, f), this._update(!0);
        }
        getFilter(g) {
          return this.style.getFilter(g);
        }
        setPaintProperty(g, a, f, p = {}) {
          return this.style.setPaintProperty(g, a, f, p), this._update(!0);
        }
        getPaintProperty(g, a) {
          return this.style.getPaintProperty(g, a);
        }
        setLayoutProperty(g, a, f, p = {}) {
          return this.style.setLayoutProperty(g, a, f, p), this._update(!0);
        }
        getLayoutProperty(g, a) {
          return this.style.getLayoutProperty(g, a);
        }
        setLight(g, a = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(g, a), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setFeatureState(g, a) {
          return this.style.setFeatureState(g, a), this._update();
        }
        removeFeatureState(g, a) {
          return this.style.removeFeatureState(g, a), this._update();
        }
        getFeatureState(g) {
          return this.style.getFeatureState(g);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let g = 0, a = 0;
          return this._container && (g = this._container.clientWidth || 400, a = this._container.clientHeight || 300), [g, a];
        }
        _setupContainer() {
          const g = this._container;
          g.classList.add("maplibregl-map", "mapboxgl-map");
          const a = this._canvasContainer = S.create("div", "maplibregl-canvas-container mapboxgl-canvas-container", g);
          this._interactive && a.classList.add("maplibregl-interactive", "mapboxgl-interactive"), this._canvas = S.create("canvas", "maplibregl-canvas mapboxgl-canvas", a), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
          const f = this._containerDimensions();
          this._resizeCanvas(f[0], f[1], this.getPixelRatio());
          const p = this._controlContainer = S.create("div", "maplibregl-control-container mapboxgl-control-container", g), _ = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((b) => {
            _[b] = S.create("div", `maplibregl-ctrl-${b} mapboxgl-ctrl-${b}`, p);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _setupCooperativeGestures() {
          const g = this._container;
          this._metaPress = !1, this._cooperativeGesturesScreen = S.create("div", "maplibregl-cooperative-gesture-screen", g);
          let a = "Control", f = typeof this._cooperativeGestures != "boolean" && this._cooperativeGestures.windowsHelpText ? this._cooperativeGestures.windowsHelpText : "Use Ctrl + scroll to zoom the map";
          navigator.platform.indexOf("Mac") === 0 && (f = typeof this._cooperativeGestures != "boolean" && this._cooperativeGestures.macHelpText ? this._cooperativeGestures.macHelpText : "Use \u2318 + scroll to zoom the map", a = "Meta"), this._cooperativeGesturesScreen.innerHTML = `
            <div class="maplibregl-desktop-message">${f}</div>
            <div class="maplibregl-mobile-message">${typeof this._cooperativeGestures != "boolean" && this._cooperativeGestures.mobileHelpText ? this._cooperativeGestures.mobileHelpText : "Use two fingers to move the map"}</div>
        `, document.addEventListener("keydown", (p) => {
            p.key === a && (this._metaPress = !0);
          }), document.addEventListener("keyup", (p) => {
            p.key === a && (this._metaPress = !1);
          }), this._canvasContainer.addEventListener("wheel", (p) => {
            this._onCooperativeGesture(p, this._metaPress, 1);
          }, !1), this._canvasContainer.classList.remove("mapboxgl-touch-drag-pan", "maplibregl-touch-drag-pan");
        }
        _resizeCanvas(g, a, f) {
          this._canvas.width = f * g, this._canvas.height = f * a, this._canvas.style.width = `${g}px`, this._canvas.style.height = `${a}px`;
        }
        _setupPainter() {
          const g = s.extend({}, m.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), a = this._canvas.getContext("webgl", g) || this._canvas.getContext("experimental-webgl", g);
          a ? (this.painter = new mf(a, this.transform), s.exported$1.testSupport(a)) : this.fire(new s.ErrorEvent(new Error("Failed to initialize WebGL")));
        }
        _contextLost(g) {
          g.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new s.Event("webglcontextlost", { originalEvent: g }));
        }
        _contextRestored(g) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new s.Event("webglcontextrestored", { originalEvent: g }));
        }
        _onMapScroll(g) {
          if (g.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
        }
        _onCooperativeGesture(g, a, f) {
          return !a && f < 2 && (this._cooperativeGesturesScreen.classList.add("maplibregl-show"), setTimeout(() => {
            this._cooperativeGesturesScreen.classList.remove("maplibregl-show");
          }, 100)), !1;
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(g) {
          return this.style ? (this._styleDirty = this._styleDirty || g, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(g) {
          return this._update(), this._renderTaskQueue.add(g);
        }
        _cancelRenderFrame(g) {
          this._renderTaskQueue.remove(g);
        }
        _render(g) {
          let a, f = 0;
          const p = this.painter.context.extTimerQuery;
          if (this.listens("gpu-timing-frame") && (a = p.createQueryEXT(), p.beginQueryEXT(p.TIME_ELAPSED_EXT, a), f = s.exported.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(g), this._removed)
            return;
          let _ = !1;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const M = this.transform.zoom, P = s.exported.now();
            this.style.zoomHistory.update(M, P);
            const O = new s.EvaluationParameters(M, { now: P, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), D = O.crossFadingFactor();
            D === 1 && D === this._crossFadingFactor || (_ = !0, this._crossFadingFactor = D), this.style.update(O);
          }
          if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.style.terrain && this.style.terrain.sourceCache.update(this.transform, this.style.terrain), this.transform.updateElevation(this.style.terrain), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new s.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, s.PerformanceUtils.mark(s.PerformanceMarkers.load), this.fire(new s.Event("load"))), this.style && (this.style.hasTransitions() || _) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
            const M = s.exported.now() - f;
            p.endQueryEXT(p.TIME_ELAPSED_EXT, a), setTimeout(() => {
              const P = p.getQueryObjectEXT(a, p.QUERY_RESULT_EXT) / 1e6;
              p.deleteQueryEXT(a), this.fire(new s.Event("gpu-timing-frame", { cpuTime: M, gpuTime: P }));
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const M = this.painter.collectGpuTimers();
            setTimeout(() => {
              const P = this.painter.queryGpuTimers(M);
              this.fire(new s.Event("gpu-timing-layer", { layerTimes: P }));
            }, 50);
          }
          const b = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return b || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.Event("idle")), !this._loaded || this._fullyLoaded || b || (this._fullyLoaded = !0, s.PerformanceUtils.mark(s.PerformanceMarkers.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const a of this._controls)
            a.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && (removeEventListener("resize", this._onWindowResize, !1), removeEventListener("orientationchange", this._onWindowResize, !1), removeEventListener("online", this._onWindowOnline, !1));
          const g = this.painter.context.gl.getExtension("WEBGL_lose_context");
          g && g.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), S.remove(this._canvasContainer), S.remove(this._controlContainer), this._cooperativeGestures && S.remove(this._cooperativeGesturesScreen), this._container.classList.remove("maplibregl-map", "mapboxgl-map"), s.PerformanceUtils.clearMetrics(), this._removed = !0, this.fire(new s.Event("remove"));
        }
        triggerRepaint() {
          this.style && !this._frame && (this._frame = s.exported.frame((g) => {
            s.PerformanceUtils.frame(g), this._frame = null, this._render(g);
          }));
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(g) {
          this._trackResize && this.resize({ originalEvent: g })._update();
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(g) {
          this._showTileBoundaries !== g && (this._showTileBoundaries = g, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(g) {
          this._showPadding !== g && (this._showPadding = g, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(g) {
          this._showCollisionBoxes !== g && (this._showCollisionBoxes = g, g ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(g) {
          this._showOverdrawInspector !== g && (this._showOverdrawInspector = g, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(g) {
          this._repaint !== g && (this._repaint = g, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(g) {
          this._vertices = g, this._update();
        }
        _setCacheLimits(g, a) {
          s.setCacheLimits(g, a);
        }
        get version() {
          return "2.4.0";
        }
      }, NavigationControl: class {
        constructor(g) {
          this.options = s.extend({}, d_, g), this._container = S.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (a) => a.preventDefault()), this.options.showZoom && (s.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in mapboxgl-ctrl-zoom-in", (a) => this._map.zoomIn({}, { originalEvent: a })), S.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out mapboxgl-ctrl-zoom-out", (a) => this._map.zoomOut({}, { originalEvent: a })), S.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (s.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("maplibregl-ctrl-compass mapboxgl-ctrl-compass", (a) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: a }) : this._map.resetNorth({}, { originalEvent: a });
          }), this._compassIcon = S.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const g = this._map.getZoom(), a = g === this._map.getMaxZoom(), f = g === this._map.getMinZoom();
          this._zoomInButton.disabled = a, this._zoomOutButton.disabled = f, this._zoomInButton.setAttribute("aria-disabled", a.toString()), this._zoomOutButton.setAttribute("aria-disabled", f.toString());
        }
        _rotateCompassArrow() {
          const g = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
          this._compassIcon.style.transform = g;
        }
        onAdd(g) {
          return this._map = g, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Wo(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          S.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(g, a) {
          const f = S.create("button", g, this._container);
          return f.type = "button", f.addEventListener("click", a), f;
        }
        _setButtonTitle(g, a) {
          const f = this._map._getUIString(`NavigationControl.${a}`);
          g.title = f, g.setAttribute("aria-label", f);
        }
      }, GeolocateControl: class extends s.Evented {
        constructor(g) {
          super(), this.options = s.extend({}, Sf, g), s.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
        }
        onAdd(g) {
          var a;
          return this._map = g, this._container = S.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), a = this._setupUI, Ua !== void 0 ? a(Ua) : window.navigator.permissions !== void 0 ? window.navigator.permissions.query({ name: "geolocation" }).then((f) => {
            Ua = f.state !== "denied", a(Ua);
          }) : (Ua = !!window.navigator.geolocation, a(Ua)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), S.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, pi = 0, $a = !1;
        }
        _isOutOfMapMaxBounds(g) {
          const a = this._map.getMaxBounds(), f = g.coords;
          return a && (f.longitude < a.getWest() || f.longitude > a.getEast() || f.latitude < a.getSouth() || f.latitude > a.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _onSuccess(g) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(g))
              return this._setErrorState(), this.fire(new s.Event("outofmaxbounds", g)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = g, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background");
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(g), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(g), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new s.Event("geolocate", g)), this._finish();
          }
        }
        _updateCamera(g) {
          const a = new s.LngLat(g.coords.longitude, g.coords.latitude), f = g.coords.accuracy, p = this._map.getBearing(), _ = s.extend({ bearing: p }, this.options.fitBoundsOptions);
          this._map.fitBounds(a.toBounds(f), _, { geolocateSource: !0 });
        }
        _updateMarker(g) {
          if (g) {
            const a = new s.LngLat(g.coords.longitude, g.coords.latitude);
            this._accuracyCircleMarker.setLngLat(a).addTo(this._map), this._userLocationDotMarker.setLngLat(a).addTo(this._map), this._accuracy = g.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const g = this._map._container.clientHeight / 2, a = this._map.unproject([0, g]), f = this._map.unproject([1, g]), p = a.distanceTo(f), _ = Math.ceil(2 * this._accuracy / p);
          this._circleElement.style.width = `${_}px`, this._circleElement.style.height = `${_}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _onError(g) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (g.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (g.code === 3 && $a)
                  return;
                this._setErrorState();
              }
            this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new s.Event("error", g)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(g) {
          if (this._container.addEventListener("contextmenu", (a) => a.preventDefault()), this._geolocateButton = S.create("button", "maplibregl-ctrl-geolocate mapboxgl-ctrl-geolocate", this._container), S.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", g === !1) {
            s.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
            const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
            this._geolocateButton.disabled = !0, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
          } else {
            const a = this._map._getUIString("GeolocateControl.FindMyLocation");
            this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
          }
          this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = S.create("div", "maplibregl-user-location-dot mapboxgl-user-location-dot"), this._userLocationDotMarker = new sl(this._dotElement), this._circleElement = S.create("div", "maplibregl-user-location-accuracy-circle mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new sl({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (a) => {
            a.geolocateSource || this._watchState !== "ACTIVE_LOCK" || a.originalEvent && a.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this.fire(new s.Event("trackuserlocationend")));
          });
        }
        trigger() {
          if (!this._setup)
            return s.warnOnce("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new s.Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                pi--, $a = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this.fire(new s.Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.Event("trackuserlocationstart"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
              this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let g;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), pi++, pi > 1 ? (g = { maximumAge: 6e5, timeout: 0 }, $a = !0) : (g = this.options.positionOptions, $a = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, g);
            }
          } else
            window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl: bc, LogoControl: Nu, ScaleControl: class {
        constructor(g) {
          this.options = s.extend({}, Xo, g), s.bindAll(["_onMove", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _onMove() {
          Hp(this._map, this._container, this.options);
        }
        onAdd(g) {
          return this._map = g, this._container = S.create("div", "maplibregl-ctrl maplibregl-ctrl-scale mapboxgl-ctrl mapboxgl-ctrl-scale", g.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          S.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
        setUnit(g) {
          this.options.unit = g, Hp(this._map, this._container, this.options);
        }
      }, FullscreenControl: class {
        constructor(g) {
          this._fullscreen = !1, g && g.container && (g.container instanceof HTMLElement ? this._container = g.container : s.warnOnce("Full screen control 'container' must be a DOM element.")), s.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(g) {
          return this._map = g, this._container || (this._container = this._map.getContainer()), this._controlContainer = S.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", s.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          S.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !!(document.fullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled || document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const g = this._fullscreenButton = S.create("button", "maplibregl-ctrl-fullscreen mapboxgl-ctrl-fullscreen", this._controlContainer);
          S.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", g).setAttribute("aria-hidden", "true"), g.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const g = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", g), this._fullscreenButton.title = g;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen && window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, TerrainControl: class {
        constructor(g) {
          this.options = g, s.bindAll(["_toggleTerrain", "_updateTerrainIcon"], this);
        }
        onAdd(g) {
          return this._map = g, this._container = S.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._terrainButton = S.create("button", "maplibregl-ctrl-terrain mapboxgl-ctrl-terrain", this._container), S.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          S.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
        _toggleTerrain() {
          this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
        }
        _updateTerrainIcon() {
          this._terrainButton.classList.remove("maplibregl-ctrl-terrain", "mapboxgl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled", "mapboxgl-ctrl-terrain-enabled"), this._map.style.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled", "mapboxgl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain", "mapboxgl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
        }
      }, Popup: class extends s.Evented {
        constructor(g) {
          super(), this.options = s.extend(Object.create(Rn), g), s.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
        }
        addTo(g) {
          return this._map && this.remove(), this._map = g, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.Event("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          return this._content && S.remove(this._content), this._container && (S.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new s.Event("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(g) {
          return this._lngLat = s.LngLat.convert(g), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(g) {
          return this.setDOMContent(document.createTextNode(g));
        }
        setHTML(g) {
          const a = document.createDocumentFragment(), f = document.createElement("body");
          let p;
          for (f.innerHTML = g; p = f.firstChild, p; )
            a.appendChild(p);
          return this.setDOMContent(a);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(g) {
          return this.options.maxWidth = g, this._update(), this;
        }
        setDOMContent(g) {
          if (this._content)
            for (; this._content.hasChildNodes(); )
              this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else
            this._content = S.create("div", "maplibregl-popup-content mapboxgl-popup-content", this._container);
          return this._content.appendChild(g), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(g) {
          this._container && this._container.classList.add(g);
        }
        removeClassName(g) {
          this._container && this._container.classList.remove(g);
        }
        setOffset(g) {
          return this.options.offset = g, this._update(), this;
        }
        toggleClassName(g) {
          if (this._container)
            return this._container.classList.toggle(g);
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = S.create("button", "maplibregl-popup-close-button mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _onMouseUp(g) {
          this._update(g.point);
        }
        _onMouseMove(g) {
          this._update(g.point);
        }
        _onDrag(g) {
          this._update(g.point);
        }
        _update(g) {
          if (!this._map || !this._lngLat && !this._trackPointer || !this._content || (this._container || (this._container = S.create("div", "maplibregl-popup mapboxgl-popup", this._map.getContainer()), this._tip = S.create("div", "maplibregl-popup-tip mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach((b) => this._container.classList.add(b)), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = wc(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !g))
            return;
          const a = this._pos = this._trackPointer && g ? g : this._map.project(this._lngLat);
          let f = this.options.anchor;
          const p = Mf(this.options.offset);
          if (!f) {
            const b = this._container.offsetWidth, M = this._container.offsetHeight;
            let P;
            P = a.y + p.bottom.y < M ? ["top"] : a.y > this._map.transform.height - M ? ["bottom"] : [], a.x < b / 2 ? P.push("left") : a.x > this._map.transform.width - b / 2 && P.push("right"), f = P.length === 0 ? "bottom" : P.join("-");
          }
          const _ = a.add(p[f]).round();
          S.setTransform(this._container, `${Dt[f]} translate(${_.x}px,${_.y}px)`), jt(this._container, f, "popup");
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const g = this._container.querySelector(jn);
          g && g.focus();
        }
        _onClose() {
          this.remove();
        }
      }, Marker: sl, Style: bi, LngLat: s.LngLat, LngLatBounds: s.LngLatBounds, Point: s.pointGeometry, MercatorCoordinate: s.MercatorCoordinate, Evented: s.Evented, AJAXError: s.AJAXError, config: s.config, CanvasSource: mr, GeoJSONSource: Ye, ImageSource: kt, RasterDEMTileSource: Pe, RasterTileSource: xe, VectorTileSource: dt, VideoSource: Er, prewarm: function() {
        Ze().acquire(qr);
      }, clearPrewarmedResources: function() {
        const g = ke;
        g && (g.isPreloaded() && g.numActive() === 1 ? (g.release(qr), ke = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get version() {
        return "2.4.0";
      }, get workerCount() {
        return re.workerCount;
      }, set workerCount(g) {
        re.workerCount = g;
      }, get maxParallelImageRequests() {
        return s.config.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(g) {
        s.config.MAX_PARALLEL_IMAGE_REQUESTS = g;
      }, clearStorage(g) {
        s.clearTileCache(g);
      }, workerUrl: "", addProtocol(g, a) {
        s.config.REGISTERED_PROTOCOLS[g] = a;
      }, removeProtocol(g) {
        delete s.config.REGISTERED_PROTOCOLS[g];
      } };
      return yo.extend(_s, { isSafari: s.isSafari, getPerformanceMetrics: s.PerformanceUtils.getPerformanceMetrics }), _s;
    });
    var h = i;
    return h;
  });
})(DM);
const M8 = DM.exports;
class NM extends rp {
  constructor(e) {
    const r = Object.assign({}, e);
    delete r.maplibreOptions, super(r);
    const n = document.createElement("div");
    n.style.position = "absolute", n.style.width = "100%", n.style.height = "100%", this.maplibreMap = new M8.Map(
      Object.assign({}, e.maplibreOptions, {
        container: n,
        attributionControl: !1,
        interactive: !1,
        trackResize: !1
      })
    ), this.applyOpacity_();
  }
  setOpacity(e) {
    super.setOpacity(e), this.applyOpacity_();
  }
  applyOpacity_() {
    const e = this.maplibreMap.getCanvas(), r = this.getOpacity().toString();
    r !== e.style.opacity && (e.style.opacity = r);
  }
  render(e) {
    const r = e.viewState;
    this.maplibreMap.jumpTo({
      center: FD(r.center),
      zoom: r.zoom - 1,
      bearing: eD(-r.rotation),
      animate: !1
    });
    const n = this.maplibreMap.getCanvas();
    return n.isConnected ? C8(n, e) || this.maplibreMap.resize() : this.getMapInternal().render(), this.maplibreMap.redraw(), this.maplibreMap.getContainer();
  }
}
function C8(t, e) {
  return t.width === Math.floor(e.size[0] * e.pixelRatio) || t.height === Math.floor(e.size[1] * e.pixelRatio);
}
const zm = /* @__PURE__ */ new Map();
class I8 {
  styleSerialToStyle(e) {
    return e ? JSON.parse(decodeURIComponent(e)) || [] : [];
  }
  styleLocalStorageToStyle(e) {
    return e ? JSON.parse(e).medium || [] : [];
  }
  styleToSerial(e) {
    return e && e.length > 0 ? JSON.stringify(e) : "";
  }
  styleToLocalStorage(e) {
    return e && e.length > 0 ? JSON.stringify({ medium: e }) : "";
  }
}
const Bm = new I8();
function wE(t, e) {
  let r;
  return (...n) => {
    clearTimeout(r), r = setTimeout(() => {
      t.apply(n);
    }, e);
  };
}
function Ph(t) {
  return (t == null ? void 0 : t.trim()) && !isNaN(Number(t)) ? Number(t) : void 0;
}
function P8(t, e) {
  return (t == null ? void 0 : t.split(e).map(
    (r) => r !== null && !isNaN(Number(r)) ? parseFloat(r) : void 0
  )) || [];
}
function A8(t, e) {
  return (t == null ? void 0 : t.split(e).map(Ux)) || [];
}
function Ux(t) {
  return (t == null ? void 0 : t.trim()) === "true" ? !0 : (t == null ? void 0 : t.trim()) === "false" ? !1 : void 0;
}
function FM() {
  return window.matchMedia(
    "(-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2), (min-resolution: 192dpi)"
  ).matches;
}
const op = "ipv6", ap = "applogin", sp = "localforage", Ah = "debug", Zg = "fid", Bl = "lang", Hg = "layersOpen", Kg = "address", k0 = "version", O8 = "map_id", EE = "layers", TE = "bgLayer", SE = "opacities", Fd = "theme", ME = "zoom", R8 = "SRS", CE = "X", IE = "Y", Yg = "serial", zM = [
  "basemap_2015_global",
  "topogr_global",
  "topo_bw_jpeg"
], N0 = "lc", F0 = "sliderRatio", BM = "bgOpacity", L8 = "layers_indices", PE = "layers_opacity", AE = "layers_visibility";
var Bi = /* @__PURE__ */ ((t) => (t[t.localStorage = 0] = "localStorage", t[t.permalink = 1] = "permalink", t[t.permalinkAsPath = 2] = "permalinkAsPath", t[t.permalinkAndLocalStorage = 3] = "permalinkAndLocalStorage", t))(Bi || {});
class UM {
}
class Jg extends UM {
  static processRules(e) {
    return Jg.ruleUseLocalStorage(e) ? Bi.localStorage : Bi.permalink;
  }
  static processRulesForKey(e, r) {
    if (e === Fd && {}.VITE_DEPLOY_GHPAGES !== "true")
      return Bi.permalinkAsPath;
    if (zM.includes(e))
      return Bi.localStorage;
    if (e === Yg)
      return Bi.permalink;
    if (e === Hg)
      return Bi.localStorage;
  }
  static ruleUseLocalStorage(e) {
    return [D8, k8, N8].reduce(
      (r, n) => r || n(e),
      !1
    );
  }
}
const D8 = (t) => Object.keys(t).length === 0, k8 = (t) => Object.keys(t).length === 1 && (t.hasOwnProperty(op) || t.hasOwnProperty(ap) || t.hasOwnProperty(sp)), N8 = (t) => Object.keys(t).length === 3 && t.hasOwnProperty(op) && t.hasOwnProperty(ap) && t.hasOwnProperty(sp);
class Qg extends UM {
  static processRules() {
    return Bi.permalinkAndLocalStorage;
  }
  static processRulesForKey(e, r) {
    if (Qg.ruleUsePermalink(e))
      return Bi.permalink;
    if (e === Hg || zM.includes(e))
      return Bi.localStorage;
    if (e === Yg)
      return Bi.permalink;
    if (e === Fd)
      return Bi.permalinkAsPath;
  }
  static ruleUsePermalink(e) {
    return [
      F8,
      z8,
      B8
    ].reduce(
      (r, n) => r || n(e),
      !1
    );
  }
}
const F8 = (t) => t === N0 || t === F0, z8 = (t) => t === k0, B8 = (t) => t === Fd && {}.VITE_DEPLOY_GHPAGES === "true";
class $M {
  constructor() {
    ei(this, "snappedUrl");
    this.snappedUrl = new URL(window.location.toString());
  }
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(e) {
    throw new Error("Method key() not implemented. " + e);
  }
  getSnappedUrl() {
    return this.snappedUrl;
  }
  getSnappedParamsAsObj() {
    return this.getSnappedParams().reduce(
      (e, r) => {
        const [n, i] = r.split("=");
        return { ...e, [n]: i };
      },
      {}
    );
  }
  getSnappedParams() {
    return this.getSnappedUrl().search.replace("?", "").split("&").filter((e) => e.split("=")[1]);
  }
  setItem(e, r) {
    const n = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    n.set(encodeURIComponent(e), encodeURIComponent(r));
    try {
      window.history.replaceState(null, "", "?" + n.toString());
    } catch {
    }
  }
  getItem(e) {
    return this.getSnappedUrl().searchParams.get(e);
  }
  removeItem(e) {
    const r = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    r.delete(e);
    try {
      window.history.replaceState(null, "", "?" + r.toString());
    } catch {
    }
  }
  encodeQueryParam(e, r) {
    return `${encodeURIComponent(e)}=${encodeURIComponent(r)}`;
  }
}
const Mv = new $M();
class U8 extends $M {
  getItem(e) {
    const r = this.getSnappedUrl().pathname.split("/"), n = r.findIndex((i) => i === e);
    return r[n + 1];
  }
  setItem(e, r) {
    const n = new URL(window.location.toString()).search, i = `/${e}/${r}${n}`;
    try {
      window.history.replaceState(null, "", i);
    } catch {
    }
  }
}
const $8 = new U8();
class V8 {
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(e) {
    throw new Error("Method key() not implemented. " + e);
  }
  removeItem(e) {
    const r = this.getWriteStorages(e);
    r == null || r.map(
      (n) => n.removeItem(e)
    );
  }
  setItem(e, r) {
    this.setValue(e, r);
  }
  getItem(e) {
    return this.getValue(e);
  }
  get paramKeys() {
    return Mv.getSnappedParamsAsObj();
  }
  getValue(e) {
    var i;
    const r = (i = this.correspondingStorages(
      Jg.processRules(this.paramKeys)
    )) == null ? void 0 : i.pop(), n = this.storageForKey(e, Jg, r);
    return n ? n.getItem(e) : null;
  }
  setValue(e, r) {
    const n = this.getWriteStorages(e);
    n == null || n.map(
      (i) => i.setItem(e, r)
    );
  }
  getWriteStorages(e) {
    const r = this.correspondingStorages(
      Qg.processRules()
    ), n = this.storageForKey(e, Qg);
    return n ? [n] : r;
  }
  storageForKey(e, r, n) {
    var l;
    const i = (l = this.correspondingStorages(
      r.processRulesForKey(e, this.paramKeys)
    )) == null ? void 0 : l.pop();
    return i != null ? i : n;
  }
  correspondingStorages(e) {
    if (e === Bi.permalinkAndLocalStorage)
      return [Mv, localStorage];
    if (e === Bi.localStorage)
      return [localStorage];
    if (e === Bi.permalink)
      return [Mv];
    if (e === Bi.permalinkAsPath)
      return [$8];
  }
}
const Um = new V8();
function j8(t) {
  return G8(t) || q8(t) || W8(t) || X8(t);
}
const G8 = (t) => Object.keys(t).length === 0, q8 = (t) => {
  const e = Object.keys(t);
  return Object.keys(t).length === 1 && [
    op,
    ap,
    sp,
    Zg,
    Bl,
    Kg,
    Ah
  ].some((r) => e.indexOf(r) !== -1);
}, W8 = (t) => {
  const e = Object.keys(t), r = (i) => e.indexOf(i) !== -1, n = [
    [ap, sp],
    [Ah, Zg],
    [Bl, Zg],
    [Ah, Bl],
    [Ah, Kg],
    [Bl, Kg]
  ];
  return Object.keys(t).length === 2 && n.reduce(
    (i, l) => i || l.every(r),
    !1
  );
}, X8 = (t) => {
  const e = Object.keys(t), r = (h) => e.indexOf(h) !== -1, n = [op, ap, sp].every(
    r
  ), i = [Ah, Zg, Bl].every(r), l = [Ah, Kg, Bl].every(r);
  return Object.keys(t).length === 3 && (n || i || l);
};
class Z8 {
  constructor() {
    ei(this, "intialVersion");
    const e = Um.paramKeys, r = this.getValue(k0, Ph);
    this.intialVersion = r ? Math.max(2, Math.min(r, 3)) : j8(e) ? 3 : 2, this.setValue(k0, 3);
  }
  getInitialVersion() {
    return this.intialVersion;
  }
  mapToEntity(e, r) {
    return r ? r(e) : e;
  }
  mapToStorage(e, r) {
    return r ? r(e) : String(e);
  }
  getValue(e, r) {
    return this.mapToEntity(Um.getValue(e), r);
  }
  setValue(e, r, n) {
    Um.setValue(e, this.mapToStorage(r, n));
  }
  removeItem(e) {
    Um.removeItem(e);
  }
}
const Sr = new Z8(), H8 = [
  "line",
  "fill",
  "symbol",
  "fill-extrusion",
  "background",
  "hillshade"
], Pa = () => ({
  bg_layers: [
    {
      icon_id: "route",
      vector_id: "roadmap",
      simple_style_class: "road",
      medium_style_class: "road",
      expert_style_class: "maputnik",
      id: 556,
      is_default: !0
    },
    {
      icon_id: "topo",
      vector_id: "topomap",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 529
    },
    {
      icon_id: "topo_bw",
      vector_id: "topomap_gray",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 502
    },
    {
      icon_id: "ortho",
      id: 530
    },
    {
      icon_id: "hybrid",
      id: 501
    },
    {
      icon_id: "blank",
      id: 0
    }
  ],
  bg_layer_theme_defaults: {
    tourisme: 502
  },
  simple_styles: {
    road: [
      {
        unlocalized_label: "Light grey",
        hillshade: !1,
        colors: [
          "#ffffff",
          "#ffffff",
          "#d6e0d7",
          "#e1e1e1",
          "#cccccc",
          "#f2f2f2"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Dark grey",
        hillshade: !1,
        colors: [
          "#808080",
          "#808080",
          "#494b4a",
          "#505052",
          "#232426",
          "#454545"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Dark sand",
        hillshade: !1,
        colors: [
          "#9e9375",
          "#9e9375",
          "#6b6249",
          "#403928",
          "#b8aa84",
          "#1a1814"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Kids",
        hillshade: !1,
        colors: [
          "#f9c50d",
          "#ffffff",
          "#839836",
          "#d6d3ce",
          "#2a5ba8",
          "#eeeeee"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Light mauve",
        hillshade: !1,
        colors: [
          "#f3edf5",
          "#f3edf5",
          "#9d7da8",
          "#caa9d1",
          "#613b5c",
          "#e5d3e6"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Light Blue",
        hillshade: !1,
        colors: [
          "#dceaf5",
          "#dceaf5",
          "#5598cf",
          "#81b7e3",
          "#3b576e",
          "#b6cde0"
        ],
        selected: !1
      }
    ]
  },
  medium_default_styles: {
    road: [
      {
        label: "Roads primary",
        color: "#f7f7f7",
        lines: [
          "lu_road_trunk_primary",
          "lu_bridge_major",
          "lu_tunnel_major",
          "lu_road_major_motorway"
        ],
        visible: !0
      },
      {
        label: "Roads secondary",
        color: "#f7f7f7",
        lines: [
          "lu_road_minor",
          "lu_road_secondary_tertiary",
          "lu_bridge_minor",
          "lu_road_path",
          "lu_bridge_path",
          "lu_bridge_railway case",
          "lu_bridge_path case"
        ],
        visible: !0
      },
      {
        label: "Vegetation",
        color: "#B8D293",
        opacity: "1",
        fills: [
          "lu_landcover_wood",
          "lu_landcover_grass",
          "lu_landuse_stadium",
          "lu_landuse_cemetery"
        ],
        visible: !0
      },
      {
        label: "Buildings",
        color: "#D6AA85",
        opacity: "1",
        fillExtrusions: ["lu_building-3d_public", "lu_building-3d"],
        fills: ["lu_building", "lu_building_public"],
        lines: ["lu_bridge_railway", "lu_railway", "lu_tunnel_railway"],
        visible: !0
      },
      {
        label: "Water",
        color: "#94c1e1",
        lines: [
          "lu_waterway",
          "lu_waterway_tunnel",
          "lu_waterway_intermittent"
        ],
        fills: ["lu_water"],
        visible: !0
      },
      {
        label: "Background",
        color: "#e7e7e7",
        backgrounds: ["background"],
        visible: !0
      },
      {
        label: "Hillshade",
        hillshades: ["hillshade"],
        visible: !0
      }
    ],
    topo: [
      {
        label: "Primary Names",
        symbols: [
          "lu_place-label_other",
          "lu_place-label_city",
          "lu_place-label_canton",
          "lu_country-label-other",
          "lu_country-label",
          "place_label_other",
          "place_label_city",
          "country_label-other",
          "country_label"
        ],
        visible: !0
      },
      {
        label: "Secondary Names",
        symbols: [
          "lu_place-label_isolated",
          "lu_place-label_locality_forest",
          "lu_place-label_locality_lieudit"
        ],
        visible: !0
      },
      {
        label: "Transport",
        lines: [
          "lu_tunnel_track-casing",
          "lu_tunnel_major_motorway-casing",
          "lu_tunnel_railway_transit",
          "lu_tunnel_railway",
          "lu_tunnel_railway-hatching",
          "lu_tunnel_path",
          "lu_tunnel_track",
          "lu_tunnel_minor",
          "lu_tunnel_major_motorway",
          "lu_tunnel_secondary_tertiary",
          "lu_tunnel_trunk_primary",
          "lu_road_track-casing",
          "lu_road_minor-casing",
          "lu_road_major_motorway-casing",
          "lu_road_secondary_tertiary-casing",
          "lu_road_trunk_primary-casing",
          "lu_road_pier",
          "lu_road_path",
          "lu_road_track",
          "lu_road_minor",
          "lu_road_major_motorway",
          "lu_road_secondary_tertiary",
          "lu_road_trunk_primary",
          "lu_tram",
          "lu_tram-hatching",
          "lu_railway_transit",
          "lu_railway",
          "lu_railway-hatching",
          "lu_bridge_railway-casing",
          "lu_bridge_track-casing",
          "lu_bridge_path-casing",
          "lu_bridge_minor-casing",
          "lu_bridge_major_motorway-casing",
          "lu_bridge_secondary_tertiary-casing",
          "lu_bridge_trunk_primary-casing",
          "lu_bridge_railway",
          "lu_bridge_path",
          "lu_bridge_track",
          "lu_bridge_minor",
          "lu_bridge_major_motorway",
          "lu_bridge_secondary_tertiary",
          "lu_bridge_trunk_primary",
          "tunnel_track-casing",
          "tunnel_major_motorway-casing",
          "tunnel_railway_transit",
          "tunnel_railway_transit-hatching",
          "tunnel_railway",
          "tunnel_railway-hatching",
          "tunnel_path",
          "tunnel_track",
          "tunnel_minor",
          "tunnel_major_motorway",
          "tunnel_secondary_tertiary",
          "tunnel_trunk_primary",
          "road_track-casing",
          "road_minor-casing",
          "road_major_motorway-casing",
          "road_secondary_tertiary-casing",
          "road_trunk_primary-casing",
          "road_pier",
          "road_path",
          "road_track",
          "road_minor",
          "road_major_motorway",
          "road_secondary_tertiary",
          "road_trunk_primary",
          "railway-transit",
          "railway-transit-hatching",
          "railway",
          "railway-hatching",
          "bridge_railway-casing",
          "bridge_path-casing",
          "bridge_track_casing",
          "bridge_minor-casing",
          "bridge_major_motorway-casing",
          "bridge_secondary_tertiary-casing",
          "bridge_trunk_primary-casing",
          "bridge_railway",
          "bridge_path",
          "bridge_track",
          "bridge_minor",
          "bridge_major_motorway",
          "bridge_secondary_tertiary",
          "bridge_trunk_primary"
        ],
        symbols: [
          "lu_road_major-label",
          "lu_motorway-shield",
          "lu_road-shield"
        ],
        visible: !0
      },
      {
        label: "Vegetation",
        fills: [
          "lu_landuse_stadium",
          "lu_landuse_cemetery",
          "lu_landuse_gras",
          "lu_landuse_park",
          "lu_landuse_park-outline",
          "lu_landuse_vineyard",
          "lu_landuse_orchard",
          "lu_landuse_wood",
          "landcover_grass",
          "landcover_wood"
        ],
        visible: !0
      },
      {
        label: "Electricity",
        fills: ["lu_power_station", "lu_power_pylone"],
        lines: ["lu_power_line", "lu_power_station-outline"],
        symbols: ["lu_power_station-label", "lu_eolienne"],
        visible: !0
      },
      {
        label: "Contours and Height Points",
        lines: [
          "lu_contour-100",
          "lu_contour-50",
          "lu_contour-20",
          "lu_contour-10",
          "lu_contour"
        ],
        symbols: [
          "lu_contour-label-100",
          "lu_contour-label-20",
          "lu_apex-label"
        ],
        visible: !0
      },
      {
        label: "Hillshade",
        hillshades: ["lu_hillshade"],
        visible: !0
      }
    ]
  },
  http_bg_server: "wmts{1-2}",
  https_bg_server: "wmts{3-4}",
  bg_wmts_server_path: "mapproxy_4_v3/wmts/{Layer}",
  bg_wmts_tile_template: "{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}",
  bg_layer_projection: "EPSG:3857",
  olcs_extent: [5.31, 49.38, 6.64, 50.21],
  olcs_extent_projection: "EPSG:3857",
  bg_layer_resolutions: [
    156543.033928,
    78271.516964,
    39135.758482,
    19567.879241,
    9783.9396205,
    4891.96981025,
    2445.98490513,
    1222.99245256,
    611.496226281,
    305.748113141,
    152.87405657,
    76.4370282852,
    38.2185141426,
    19.1092570713,
    9.55462853565,
    4.77731426782,
    2.38865713391,
    1.19432856696,
    0.597164283478,
    0.298582141739,
    0.1492910708695,
    0.07464553543475
  ],
  bg_matrix_ids: [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "20",
    "21"
  ]
});
function Wh() {
  function t(j) {
    const q = new URLSearchParams(document.location.search), H = q.get("embeddedserver"), ne = q.get("embeddedserverprotocol") || "http";
    return (H ? `${ne}://${H}` : "https://vectortiles.geoportail.lu") + `/styles/${j}/style.json`;
  }
  function e(j) {
    return `https://vectortiles.geoportail.lu/styles/${j}/{z}/{x}/{y}.png`;
  }
  function r(j) {
    return /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/gi.test(j);
  }
  function n(j, q, H = !1) {
    const ne = "", ee = t(q), he = e(q), Te = {
      label: j,
      defaultMapBoxStyle: ee,
      defaultMapBoxStyleXYZ: he,
      xyz: he,
      xyz_custom: ne,
      style: ee
    }, ve = new URLSearchParams(window.location.search).get("serial"), Oe = new URLSearchParams(window.location.search).get(
      "serialLayer"
    );
    if (ve)
      r(ve) && console.log(Oe);
    else if (!H)
      return Promise.resolve(Te);
    return Promise.resolve(Te);
  }
  function i(j) {
    const q = Pa().medium_default_styles.road;
    if (j) {
      j.colors.forEach((ne, ee) => {
        q[ee].color = ne;
      });
      const H = q.findIndex(
        (ne) => ne.label === "Hillshade"
      );
      q[H].visible = j.hillshade;
    }
    return q;
  }
  function l(j, q, H) {
    if (!j || !q.get(j.id))
      return;
    const ne = JSON.parse(
      JSON.stringify(q.get(j.id))
    );
    if (!!ne && !(!ne || !ne.layers))
      return H && H.forEach((ee) => {
        ne == null || ne.layers.forEach((he, Te) => {
          for (const ve of H8)
            if ((ee[`${ve}s`] || []).includes(he.id)) {
              const Me = Object.assign(
                {},
                ne.layers[Te].paint
              );
              ee.color && (Me[`${ve}-color`] = ee.color, Me[`${ve}-opacity`] = 1, ne.layers[Te].paint = Me), ne.layers[Te].layout = Object.assign(
                {},
                ne.layers[Te].layout,
                { visibility: ee.visible ? "visible" : "none" }
              );
            }
        });
      }), ne;
  }
  const h = "/getvtstyle", s = "/uploadvtstyle", m = "/deletevtstyle";
  function v(j) {
    if (j === null)
      return Promise.resolve();
    {
      const q = `${m}?id=${j}`;
      return fetch(q).catch(() => "");
    }
  }
  function E(j, q) {
    return v(q).then(() => {
      const H = new FormData(), ne = JSON.stringify(j), ee = new Blob([ne], { type: "application/json" });
      return H.append("style", ee, "style.json"), fetch(s, {
        method: "POST",
        body: H
      }).then((Te) => Te.json()).then((Te) => Te.id);
    });
  }
  function T(j, q) {
    if (!q)
      return;
    const H = j.maplibreMap;
    !H || (H.loaded() ? H.setStyle(q) : new Promise((ne) => H.once("data", ne)).then(
      () => H.setStyle(q)
    ));
  }
  function S(j) {
    const q = Pa().bg_layers.find(
      (H) => H.id == (j == null ? void 0 : j.id)
    );
    return q == null ? void 0 : q.vector_id;
  }
  function A(j) {
    const q = Pa().bg_layers.find(
      (H) => H.id == (j == null ? void 0 : j.id)
    );
    return (q == null ? void 0 : q.vector_id) !== void 0;
  }
  function L(j) {
    const q = Pa().bg_layers.find(
      (H) => H.id == (j == null ? void 0 : j.id)
    );
    return {
      isEditable: (q == null ? void 0 : q.vector_id) !== void 0,
      hasSimpleStyle: (q == null ? void 0 : q.simple_style_class) !== void 0,
      hasAdvancedStyle: (q == null ? void 0 : q.medium_style_class) !== void 0,
      hasExpertStyle: (q == null ? void 0 : q.expert_style_class) !== void 0
    };
  }
  function B(j, q) {
    return q.map(
      (H) => Object.assign(H, {
        selected: H.colors.every(
          (ne, ee) => {
            var he;
            return ((he = j[ee]) == null ? void 0 : he.color) === ne;
          }
        )
      })
    );
  }
  return {
    getDefaultMapBoxStyleUrl: t,
    setConfigForLayer: n,
    getRoadStyleFromSimpleStyle: i,
    applyDefaultStyle: l,
    applyConsolidatedStyle: T,
    getVectorId: S,
    unregisterStyle: v,
    registerStyle: E,
    checkSelection: B,
    isLayerStyleEditable: A,
    getStyleCapabilitiesFromLayer: L,
    getvtstyleUrl_: h
  };
}
const Bs = du(
  "style",
  () => {
    const t = Wh(), e = yi(), r = yi(/* @__PURE__ */ new Map()), n = yi(
      /* @__PURE__ */ new Map()
    ), i = yi(!1), l = yi(null), h = yi(), s = [];
    Pa().bg_layers.forEach((L) => {
      if (L.vector_id) {
        const B = t.setConfigForLayer(
          L.icon_id,
          L.vector_id
        );
        s.push(
          B.then((j) => ({ id: L.id, config: j }))
        );
      }
    }), Promise.all(s).then((L) => {
      const B = /* @__PURE__ */ new Map();
      L.forEach((j) => B.set(j.id, j.config)), r.value = B;
    });
    function m(L) {
      const B = /* @__PURE__ */ new Map();
      n.value.forEach((j, q) => {
        q !== L && B.set(q, j);
      }), n.value = B;
    }
    function v(L, B) {
      const j = /* @__PURE__ */ new Map();
      n.value.forEach(
        (q, H) => j.set(H, q)
      ), j.set(L, B), n.value = j;
    }
    function E(L) {
      e.value = t.getRoadStyleFromSimpleStyle(L), S();
    }
    function T(L) {
      e.value = L, S();
    }
    function S() {
      i.value = !1;
    }
    function A() {
      i.value = !0;
    }
    return {
      bgStyle: e,
      bgVectorSources: r,
      bgVectorBaseStyles: n,
      isExpertStyleActive: i,
      appliedStyle: h,
      removeBaseStyle: m,
      setBaseStyle: v,
      setSimpleStyle: E,
      setStyle: T,
      disableExpertStyle: S,
      enableExpertStyle: A,
      styleId: l
    };
  },
  {}
), Ai = du("map", () => {
  const t = Kr({}), e = yi([]), r = Kr(void 0);
  function n(v) {
    r.value = v;
  }
  function i(...v) {
    e.value = [.../* @__PURE__ */ new Set([...e.value, ...v])];
  }
  function l(...v) {
    e.value = e.value.filter(
      (E) => v.indexOf(E.id) === -1
    );
  }
  function h(v) {
    var E;
    return !!((E = e.value) != null && E.find((T) => T.id === v));
  }
  function s(v) {
    var E;
    e.value = [
      ...((E = e.value) == null ? void 0 : E.sort(
        (T, S) => v.indexOf(T.id) - v.indexOf(S.id)
      )) || []
    ];
  }
  function m(v, E) {
    e.value = e.value.map((T) => T.id === v ? { ...T, opacity: E, previousOpacity: T.opacity } : T);
  }
  return {
    map: t,
    layers: e,
    bgLayer: r,
    addLayers: i,
    removeLayers: l,
    reorderLayers: s,
    setLayerOpacity: m,
    setBgLayer: n,
    hasLayer: h
  };
});
class K8 {
  constructor() {
    ei(this, "styleWatcher");
  }
  bootstrapStyle() {
    const e = Bs();
    let r, n = !1;
    r = Da(() => {
      e.bgVectorSources && (this.restoreStyle(!1), n && this.persistStyle(), n = !0, r && r());
    });
  }
  persistStyle() {
    const e = Bs(), { bgStyle: r } = mn(e);
    this.styleWatcher || (this.styleWatcher = An(
      r,
      (n, i) => {
        if (i !== n) {
          const l = Ai();
          l.bgLayer && (Sr.setValue(
            l.bgLayer.name,
            n || [],
            Bm.styleToLocalStorage
          ), Sr.setValue(
            Yg,
            n || [],
            Bm.styleToSerial
          ));
        }
      },
      { immediate: !0 }
    ));
  }
  restoreStyle(e) {
    const r = Bs();
    r.setStyle(null);
    const i = Ai().bgLayer;
    if (i) {
      let l = [];
      e || (l = Sr.getValue(
        Yg,
        Bm.styleSerialToStyle
      )), l.length === 0 && (l = Sr.getValue(
        i.name,
        Bm.styleLocalStorageToStyle
      )), l && l.length > 0 && r.setStyle(l);
    }
  }
}
const VM = new K8(), Y8 = [
  156543.033928,
  78271.516964,
  39135.758482,
  19567.879241,
  9783.9396205,
  4891.96981025,
  2445.98490513,
  1222.99245256,
  611.496226281,
  305.748113141,
  152.87405657,
  76.4370282852,
  38.2185141426,
  19.1092570713,
  9.55462853565,
  4.77731426782,
  2.38865713391,
  1.19432856696,
  0.597164283478,
  0.298582141739,
  0.1492910708695,
  0.07464553543475
], J8 = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "20",
  "21"
], $m = -200, Q8 = "https://map.geoportail.lu/ogcproxywms", jM = "https://map.geoportail.lu/httpsproxy";
function GM() {
  return zD(
    [5.31, 49.38, 6.64, 50.21],
    mM,
    yd
  );
}
function eU(t) {
  const { name: e, layers: r, imageType: n, url: i, id: l } = t;
  return new _B({
    properties: {
      "olcs.extent": GM(),
      label: e,
      id: l
    },
    source: new v8({
      url: i || Q8,
      hidpi: FM(),
      serverType: "mapserver",
      params: {
        FORMAT: n,
        LAYERS: r
      },
      ...i != null || jM ? { crossOrigin: "anonymous" } : {}
    })
  });
}
function tU(t) {
  const { name: e, imageType: r, id: n } = t, i = qM(t), l = fi(yd), h = l.getExtent();
  return new zB({
    source: new S8({
      url: nU(t),
      tilePixelRatio: i ? 2 : 1,
      layer: e,
      matrixSet: `GLOBAL_WEBMERCATOR_4_V3${i ? "_HD" : ""}`,
      format: r,
      requestEncoding: "REST",
      projection: l,
      tileGrid: new w8({
        origin: Kl(h),
        extent: h,
        resolutions: Y8,
        matrixIds: J8
      }),
      style: "default",
      crossOrigin: "anonymous"
    }),
    properties: {
      "olcs.extent": GM(),
      label: e,
      id: n
    }
  });
}
function rU(t, e) {
  const r = zs(), n = t.get(e.id);
  if (!n)
    return;
  const i = Object.assign(
    {
      container: r.getOlMap().getTarget()
    },
    n
  ), l = new NM({
    maplibreOptions: i,
    label: e.name,
    id: e.id,
    queryable_id: e.id,
    metadata: e.metadata
  }), h = Bs();
  return l != null && l.maplibreMap.loaded() ? h.setBaseStyle(e.id, l.getStyle()) : new Promise(
    (s) => l == null ? void 0 : l.maplibreMap.once("data", s)
  ).then(
    () => h.setBaseStyle(
      e.id,
      l == null ? void 0 : l.maplibreMap.getStyle()
    )
  ), l;
}
function nU(t, e = "https") {
  const r = t.imageType.split("/")[1], n = Sr.getValue(op, Ux) ? "app.geoportail.lu" : "geoportail.lu";
  return `${e === "https" ? "//wmts{3-4}." : "//wmts{1-2}."}${n}/mapproxy_4_v3/wmts/{Layer}${qM(t) ? "_hd" : ""}/{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}.${r}`;
}
function qM(t) {
  var e;
  return !!((e = t == null ? void 0 : t.metadata) != null && e.hasRetina) && FM();
}
function WM() {
  function t(S) {
    var L;
    let A;
    switch (S.type) {
      case "WMS": {
        A = eU(S);
        break;
      }
      case "WMTS":
      case "BG WMTS": {
        A = tU(S);
        break;
      }
      default:
        throw new Error(`Unrecognized layer type: ${S.type}`);
    }
    if (A.set("metadata", S.metadata), A.set("queryable_id", S.id), A.setOpacity(S.opacity), (L = S.metadata) != null && L.hasOwnProperty("attribution")) {
      const B = A.getSource();
      B == null || B.setAttributions(S.metadata.attribution);
    }
    return A;
  }
  function e(S, A) {
    const L = v(A);
    S.addLayer(L);
  }
  function r(S, A) {
    return S.getLayers().getArray().find((L) => L.get("id") === A);
  }
  function n(S, A) {
    const L = r(S, A);
    L && S.removeLayer(L);
  }
  function i(S, A) {
    const L = S.getLayers().getArray();
    A.forEach((B, j) => {
      const q = L.find(
        (H) => H.get("id") === B.id
      );
      q == null || q.setZIndex(j + 1);
    });
  }
  function l(S, A, L) {
    const B = S.getLayers().getArray().find((j) => j.get("id") === A);
    B && B.setOpacity(L);
  }
  function h(S) {
    zm.delete(S);
  }
  function s(S) {
    return zm.has(S.id);
  }
  function m(S, A) {
    zm.set(S, A);
  }
  function v(S) {
    const A = S.id, L = zm.get(A);
    if (L)
      return L;
    {
      const B = t(S);
      return m(A, B), B;
    }
  }
  function E(S, A) {
    const B = S.getLayers().getArray().find((j) => j.getZIndex() === $m);
    B && A(B);
  }
  function T(S, A, L) {
    const B = S.getLayers(), j = B.getArray().findIndex((H) => H.getZIndex() === $m);
    let q;
    A && (s(A) ? q = v(A) : (L && (q = rU(L, A)), q = q || t(A), m(A.id, q))), j >= 0 ? q ? (q.setZIndex($m), B.setAt(j, q)) : B.removeAt(j) : q && (q.setZIndex($m), S.addLayer(q)), VM.restoreStyle(!0);
  }
  return {
    createLayer: t,
    addLayer: e,
    findLayer: r,
    removeLayer: n,
    removeFromCache: h,
    reorderLayers: i,
    setLayerOpacity: l,
    getLayerFromCache: v,
    setBgLayer: T,
    applyOnBgLayer: E
  };
}
class iU {
  constructor(e) {
    ei(this, "previousLayers");
    ei(this, "previousVectorSources");
    const r = Ai(), n = Bs(), i = zs(), l = Wh(), h = WM(), { appliedStyle: s } = mn(n);
    An(
      () => r.layers,
      (m) => {
        const v = {
          layers: this.previousLayers
        }, E = {
          layers: m
        }, T = i.getRemovedLayers(
          E,
          v
        ), S = i.getAddedLayers(
          E,
          v
        ), A = i.getMutatedLayers(
          E,
          v
        );
        T.forEach((L) => h.removeLayer(e, L.id)), S.forEach(
          (L) => h.addLayer(e, L.layer)
        ), A.forEach((L) => {
          h.setLayerOpacity(e, L.id, L.opacity);
        }), E.layers && h.reorderLayers(e, E.layers), this.previousLayers = m;
      }
    ), An(
      () => r.bgLayer,
      (m) => m !== void 0 && h.setBgLayer(e, m, n.bgVectorSources)
    ), Da(() => {
      n.isExpertStyleActive || (s.value = l.applyDefaultStyle(
        r.bgLayer,
        n.bgVectorBaseStyles,
        n.bgStyle
      ));
    }), An(s, (m) => {
      n.bgStyle === null && !n.isExpertStyleActive ? l.unregisterStyle(n.styleId).then(n.styleId = null) : l.registerStyle(m, n.styleId).then((v) => n.styleId = v), h.applyOnBgLayer(
        e,
        (v) => l.applyConsolidatedStyle(v, m)
      );
    }), An(
      () => n.bgVectorSources,
      (m) => {
        var v;
        for (const E of m.keys())
          (!this.previousVectorSources || this.previousVectorSources.get(E) !== m.get(E)) && (h.removeFromCache(E), E === ((v = r == null ? void 0 : r.bgLayer) == null ? void 0 : v.id) && h.setBgLayer(e, r == null ? void 0 : r.bgLayer, m));
        this.previousVectorSources = m;
      }
    );
  }
}
const oU = {
  0: 8,
  1: 9,
  2: 9,
  3: 10,
  4: 11,
  5: 12,
  6: 13,
  7: 14,
  8: 16,
  9: 17,
  10: 18,
  11: 19,
  12: 20,
  13: 21
};
class aU {
  bootstrap() {
    this.restore(), this.persist();
  }
  persistZoom() {
    const e = zs().getOlMap().getView(), r = () => {
      const n = e.getZoom();
      Sr.setValue(ME, n ? Math.ceil(n) : null);
    };
    r(), Fr(
      e,
      "change:resolution",
      wE(r, 300)
    );
  }
  persistXY() {
    const e = zs().getOlMap().getView(), r = () => {
      const n = e.getCenter();
      Sr.setValue(CE, n ? Math.round(n[0]) : null), Sr.setValue(IE, n ? Math.round(n[1]) : null);
    };
    r(), Fr(
      e,
      zh.PROPERTYCHANGE,
      wE(r, 300)
    );
  }
  persist() {
    this.persistXY(), this.persistZoom();
  }
  restore() {
    const e = zs().getOlMap().getView(), r = Sr.getValue(ME, Ph), n = Sr.getInitialVersion(), i = Sr.getValue(CE, Ph), l = Sr.getValue(IE, Ph), h = Sr.getValue(R8), s = kh(
      cB,
      yd
    );
    let m, v;
    r !== void 0 ? v = n === 3 ? Number(r) : oU[r] : v = 8, i != null && l != null ? n === 3 && h != null ? m = Rd([i, l], h, yd) : m = n === 3 ? [i, l] : s([l, i], void 0, 2) : m = Rd(
      [6, 49.7],
      mM,
      yd
    ), e.setCenter(m), e.setZoom(v);
  }
}
const sU = new aU();
function lp(t, e) {
  const r = new t(e), n = zs(), i = bh("olMap");
  return aa(() => {
    i.addControl(r), i.changed();
  }), fu(() => {
    const l = n.getOlMap();
    l.removeControl(r), l.changed();
  }), {
    control: r
  };
}
const lU = /* @__PURE__ */ vr({
  __name: "attribution-control",
  props: {
    className: { type: String, required: !1, default: "geoportailv3-attribution" },
    collapsed: { type: Boolean, required: !1, default: !1 },
    collapsible: { type: Boolean, required: !1, default: !1 }
  },
  setup(t) {
    return lp(nM, t), (r, n) => Tt("v-if", !0);
  }
}), cU = /* @__PURE__ */ Mr(lU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/attribution-control.vue"]]);
function uU(t, {
  i18next: e,
  rerenderOn: r = ["languageChanged", "loaded", "added", "removed"]
}) {
  const n = e.t.bind(e), i = Kr(new Date()), l = () => i.value = new Date(), h = () => i.value;
  r.forEach((E) => {
    var T;
    switch (E) {
      case "added":
      case "removed":
        (T = e.store) == null || T.on(E, l);
        break;
      default:
        e.on(E, l);
        break;
    }
  }), t.component("i18next", hU), t.mixin({
    beforeCreate() {
      var E, T;
      const S = this.$options;
      if (!S.__i18n && !S.i18nOptions) {
        this.__translate = void 0;
        return;
      }
      const A = this.$options.name, L = (Math.random() * 10 ** 8 | 0).toString(), B = [A, L].filter((he) => !!he).join("-");
      this.__bundles = [];
      const j = (he) => {
        Object.entries(he).forEach(([Te, ve]) => {
          e.addResourceBundle(Te, B, ve, !0, !1), this.__bundles.push([Te, B]);
        });
      };
      (E = S.__i18n) == null || E.forEach((he) => {
        j(JSON.parse(he));
      });
      let { lng: q, ns: H, keyPrefix: ne } = v(S, j);
      (T = this.__bundles) != null && T.length && (H = [B].concat(H != null ? H : []));
      const ee = s(q, H);
      this.__translate = (he, Te) => !ne || m(he) ? ee(he, Te) : ee(ne + "." + he, Te);
    },
    unmounted() {
      var E;
      (E = this.__bundles) == null || E.forEach(([T, S]) => e.removeResourceBundle(T, S));
    }
  }), t.config.globalProperties.$t = function(E, T) {
    var S;
    return h(), e.isInitialized ? ((S = this == null ? void 0 : this.__translate) != null ? S : n)(E, T) : E;
  }, t.config.globalProperties.$i18next = new Proxy(e, {
    get(E, T) {
      return h(), Reflect.get(E, T);
    }
  });
  function s(E, T) {
    return E ? e.getFixedT(E, T) : T ? e.getFixedT(null, T) : n;
  }
  function m(E) {
    const T = e.options.nsSeparator;
    return typeof T == "string" && E.includes(T);
  }
  function v(E, T) {
    let S, A, L;
    if (E.i18nOptions) {
      let B, j;
      ({
        lng: S,
        namespaces: j = e.options.defaultNS,
        keyPrefix: L,
        messages: B
      } = E.i18nOptions), B && T(B), A = typeof j == "string" ? [j] : j, A && e.loadNamespaces(A);
    }
    return { lng: S, ns: A, keyPrefix: L };
  }
}
function Hn() {
  const t = My();
  if (!t)
    throw new Error("i18next-vue: No Vue instance in context. Make sure to register the i18next-vue plugin using app.use(...).");
  const e = t.appContext.config.globalProperties;
  return {
    i18next: e.$i18next,
    t: e.$t.bind(t.proxy)
  };
}
var OE = new RegExp("{\\s*([a-z0-9\\-]+)\\s*}", "gi"), hU = vr({
  props: {
    translation: {
      type: String,
      required: !0
    }
  },
  setup(t, { slots: e }) {
    return () => {
      const r = t.translation, n = [];
      let i, l = 0;
      for (; (i = OE.exec(r)) !== null; ) {
        n.push(r.substring(l, i.index));
        const h = e[i[1]];
        h ? n.push(...h()) : n.push(i[0]), l = OE.lastIndex;
      }
      return n.push(r.substring(l)), n;
    };
  }
});
const fU = ["title"], dU = /* @__PURE__ */ vr({
  __name: "location-control",
  props: {
    className: { type: String, required: !1, default: "location-button" },
    label: { type: String, required: !1, default: "\uE800" },
    tipLabel: { type: String, required: !1, default: "Location" }
  },
  setup(t) {
    const e = t, { t: r } = Hn(), n = Kr(null);
    function i() {
    }
    return aa(
      () => lp(qh, { ...e, target: n })
    ), (l, h) => (tt(), vt("div", {
      ref_key: "controlElement",
      ref: n,
      class: Or(`tracker-off ${e.className} ${_e(mu)} ${_e(jh)}`)
    }, [
      $e("button", {
        title: _e(r)(e.tipLabel),
        onClick: i
      }, Vt(e.label), 9, fU)
    ], 2));
  }
}), pU = /* @__PURE__ */ Mr(dU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/location-control.vue"]]), mU = /* @__PURE__ */ vr({
  __name: "fullscreen-control",
  props: {
    className: { type: String, required: !1 },
    label: { type: String, required: !1, default: "\uE01C" },
    labelActive: { type: String, required: !1, default: "\uE02C" }
  },
  setup(t) {
    return lp(Y4, t), (r, n) => Tt("v-if", !0);
  }
}), gU = /* @__PURE__ */ Mr(mU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/fullscreen-control.vue"]]), yU = /* @__PURE__ */ vr({
  __name: "zoom-control",
  props: {
    className: { type: String, required: !1 },
    zoomInLabel: { type: String, required: !1, default: "\uE032" },
    zoomOutLabel: { type: String, required: !1, default: "\uE033" }
  },
  setup(t) {
    return lp(iM, t), (r, n) => Tt("v-if", !0);
  }
}), _U = /* @__PURE__ */ Mr(yU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/zoom-control.vue"]]);
class vU extends e6 {
  constructor(r) {
    super(r);
    ei(this, "ol3dm");
  }
  handleZoomToExtent() {
    this.ol3dm && this.ol3dm.luxCameraExtentInRadians && this.ol3dm.is3dEnabled() || super.handleZoomToExtent();
  }
}
const xU = /* @__PURE__ */ vr({
  __name: "zoom-to-extent-control",
  props: {
    className: { type: String, required: !1 },
    label: { type: String, required: !1, default: "\uE01B" },
    tipLabel: { type: String, required: !1 },
    extent: { type: null, required: !0 }
  },
  setup(t) {
    return lp(vU, t), (r, n) => Tt("v-if", !0);
  }
}), bU = /* @__PURE__ */ Mr(xU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/zoom-to-extent-control.vue"]]), wU = /* @__PURE__ */ vr({
  __name: "map-container",
  setup(t) {
    const e = zs(), r = Kr(null), n = e.createMap(), i = [
      425152.9429259216,
      632446599999133e-8,
      914349.9239510496,
      6507914867875754e-9
    ];
    return aa(() => {
      r.value && (new iU(n), sU.bootstrap(), n.setTarget(r.value), window.olMap = n);
    }), aS("olMap", n), (l, h) => (tt(), vt("div", {
      id: "map-container",
      ref_key: "mapContainer",
      ref: r,
      class: "h-full w-full bg-white absolute"
    }, [
      $t(_U),
      $t(bU, { extent: i }),
      $t(gU),
      $t(cU),
      $t(pU)
    ], 512));
  }
}), EU = /* @__PURE__ */ Mr(wU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map/map-container.vue"]]);
function Ra(t) {
  return Ra = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Ra(t);
}
function hs(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function TU(t, e) {
  if (Ra(t) !== "object" || t === null)
    return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e || "default");
    if (Ra(n) !== "object")
      return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function XM(t) {
  var e = TU(t, "string");
  return Ra(e) === "symbol" ? e : String(e);
}
function RE(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, XM(n.key), n);
  }
}
function fs(t, e, r) {
  return e && RE(t.prototype, e), r && RE(t, r), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function Ul(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function z0(t, e) {
  return z0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, z0(t, e);
}
function jy(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && z0(t, e);
}
function cp(t, e) {
  if (e && (Ra(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Ul(t);
}
function cs(t) {
  return cs = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, cs(t);
}
function Yl(t, e, r) {
  return e = XM(e), e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function SU(t) {
  if (Array.isArray(t))
    return t;
}
function MU(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function LE(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = new Array(e); r < e; r++)
    n[r] = t[r];
  return n;
}
function CU(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return LE(t, e);
    var r = Object.prototype.toString.call(t).slice(8, -1);
    if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set")
      return Array.from(t);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return LE(t, e);
  }
}
function IU() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function PU(t) {
  return SU(t) || MU(t) || CU(t) || IU();
}
function DE(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function kE(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? DE(Object(r), !0).forEach(function(n) {
      Yl(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : DE(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
var AU = {
  type: "logger",
  log: function(e) {
    this.output("log", e);
  },
  warn: function(e) {
    this.output("warn", e);
  },
  error: function(e) {
    this.output("error", e);
  },
  output: function(e, r) {
    console && console[e] && console[e].apply(console, r);
  }
}, OU = function() {
  function t(e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    hs(this, t), this.init(e, r);
  }
  return fs(t, [{
    key: "init",
    value: function(r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = n.prefix || "i18next:", this.logger = r || AU, this.options = n, this.debug = n.debug;
    }
  }, {
    key: "setDebug",
    value: function(r) {
      this.debug = r;
    }
  }, {
    key: "log",
    value: function() {
      for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
        n[i] = arguments[i];
      return this.forward(n, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
        n[i] = arguments[i];
      return this.forward(n, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
        n[i] = arguments[i];
      return this.forward(n, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
        n[i] = arguments[i];
      return this.forward(n, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(r, n, i, l) {
      return l && !this.debug ? null : (typeof r[0] == "string" && (r[0] = "".concat(i).concat(this.prefix, " ").concat(r[0])), this.logger[n](r));
    }
  }, {
    key: "create",
    value: function(r) {
      return new t(this.logger, kE(kE({}, {
        prefix: "".concat(this.prefix, ":").concat(r, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function(r) {
      return r = r || this.options, r.prefix = r.prefix || this.prefix, new t(this.logger, r);
    }
  }]), t;
}(), es = new OU(), Xl = function() {
  function t() {
    hs(this, t), this.observers = {};
  }
  return fs(t, [{
    key: "on",
    value: function(r, n) {
      var i = this;
      return r.split(" ").forEach(function(l) {
        i.observers[l] = i.observers[l] || [], i.observers[l].push(n);
      }), this;
    }
  }, {
    key: "off",
    value: function(r, n) {
      if (!!this.observers[r]) {
        if (!n) {
          delete this.observers[r];
          return;
        }
        this.observers[r] = this.observers[r].filter(function(i) {
          return i !== n;
        });
      }
    }
  }, {
    key: "emit",
    value: function(r) {
      for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), l = 1; l < n; l++)
        i[l - 1] = arguments[l];
      if (this.observers[r]) {
        var h = [].concat(this.observers[r]);
        h.forEach(function(m) {
          m.apply(void 0, i);
        });
      }
      if (this.observers["*"]) {
        var s = [].concat(this.observers["*"]);
        s.forEach(function(m) {
          m.apply(m, [r].concat(i));
        });
      }
    }
  }]), t;
}();
function Yf() {
  var t, e, r = new Promise(function(n, i) {
    t = n, e = i;
  });
  return r.resolve = t, r.reject = e, r;
}
function NE(t) {
  return t == null ? "" : "" + t;
}
function RU(t, e, r) {
  t.forEach(function(n) {
    e[n] && (r[n] = e[n]);
  });
}
function $x(t, e, r) {
  function n(s) {
    return s && s.indexOf("###") > -1 ? s.replace(/###/g, ".") : s;
  }
  function i() {
    return !t || typeof t == "string";
  }
  for (var l = typeof e != "string" ? [].concat(e) : e.split("."); l.length > 1; ) {
    if (i())
      return {};
    var h = n(l.shift());
    !t[h] && r && (t[h] = new r()), Object.prototype.hasOwnProperty.call(t, h) ? t = t[h] : t = {};
  }
  return i() ? {} : {
    obj: t,
    k: n(l.shift())
  };
}
function FE(t, e, r) {
  var n = $x(t, e, Object), i = n.obj, l = n.k;
  i[l] = r;
}
function LU(t, e, r, n) {
  var i = $x(t, e, Object), l = i.obj, h = i.k;
  l[h] = l[h] || [], n && (l[h] = l[h].concat(r)), n || l[h].push(r);
}
function ey(t, e) {
  var r = $x(t, e), n = r.obj, i = r.k;
  if (!!n)
    return n[i];
}
function zE(t, e, r) {
  var n = ey(t, r);
  return n !== void 0 ? n : ey(e, r);
}
function ZM(t, e, r) {
  for (var n in e)
    n !== "__proto__" && n !== "constructor" && (n in t ? typeof t[n] == "string" || t[n] instanceof String || typeof e[n] == "string" || e[n] instanceof String ? r && (t[n] = e[n]) : ZM(t[n], e[n], r) : t[n] = e[n]);
  return t;
}
function Qu(t) {
  return t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var DU = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function kU(t) {
  return typeof t == "string" ? t.replace(/[&<>"'\/]/g, function(e) {
    return DU[e];
  }) : t;
}
var Gy = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, NU = [" ", ",", "?", "!", ";"];
function FU(t, e, r) {
  e = e || "", r = r || "";
  var n = NU.filter(function(s) {
    return e.indexOf(s) < 0 && r.indexOf(s) < 0;
  });
  if (n.length === 0)
    return !0;
  var i = new RegExp("(".concat(n.map(function(s) {
    return s === "?" ? "\\?" : s;
  }).join("|"), ")")), l = !i.test(t);
  if (!l) {
    var h = t.indexOf(r);
    h > 0 && !i.test(t.substring(0, h)) && (l = !0);
  }
  return l;
}
function BE(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Vm(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? BE(Object(r), !0).forEach(function(n) {
      Yl(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : BE(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function zU(t) {
  var e = BU();
  return function() {
    var n = cs(t), i;
    if (e) {
      var l = cs(this).constructor;
      i = Reflect.construct(n, arguments, l);
    } else
      i = n.apply(this, arguments);
    return cp(this, i);
  };
}
function BU() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function HM(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!!t) {
    if (t[e])
      return t[e];
    for (var n = e.split(r), i = t, l = 0; l < n.length; ++l) {
      if (!i || typeof i[n[l]] == "string" && l + 1 < n.length)
        return;
      if (i[n[l]] === void 0) {
        for (var h = 2, s = n.slice(l, l + h).join(r), m = i[s]; m === void 0 && n.length > l + h; )
          h++, s = n.slice(l, l + h).join(r), m = i[s];
        if (m === void 0)
          return;
        if (m === null)
          return null;
        if (e.endsWith(s)) {
          if (typeof m == "string")
            return m;
          if (s && typeof m[s] == "string")
            return m[s];
        }
        var v = n.slice(l + h).join(r);
        return v ? HM(m, v, r) : void 0;
      }
      i = i[n[l]];
    }
    return i;
  }
}
var UU = function(t) {
  jy(r, t);
  var e = zU(r);
  function r(n) {
    var i, l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return hs(this, r), i = e.call(this), Gy && Xl.call(Ul(i)), i.data = n || {}, i.options = l, i.options.keySeparator === void 0 && (i.options.keySeparator = "."), i.options.ignoreJSONStructure === void 0 && (i.options.ignoreJSONStructure = !0), i;
  }
  return fs(r, [{
    key: "addNamespaces",
    value: function(i) {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }
  }, {
    key: "removeNamespaces",
    value: function(i) {
      var l = this.options.ns.indexOf(i);
      l > -1 && this.options.ns.splice(l, 1);
    }
  }, {
    key: "getResource",
    value: function(i, l, h) {
      var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, m = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator, v = s.ignoreJSONStructure !== void 0 ? s.ignoreJSONStructure : this.options.ignoreJSONStructure, E = [i, l];
      h && typeof h != "string" && (E = E.concat(h)), h && typeof h == "string" && (E = E.concat(m ? h.split(m) : h)), i.indexOf(".") > -1 && (E = i.split("."));
      var T = ey(this.data, E);
      return T || !v || typeof h != "string" ? T : HM(this.data && this.data[i] && this.data[i][l], h, m);
    }
  }, {
    key: "addResource",
    value: function(i, l, h, s) {
      var m = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, v = this.options.keySeparator;
      v === void 0 && (v = ".");
      var E = [i, l];
      h && (E = E.concat(v ? h.split(v) : h)), i.indexOf(".") > -1 && (E = i.split("."), s = l, l = E[1]), this.addNamespaces(l), FE(this.data, E, s), m.silent || this.emit("added", i, l, h, s);
    }
  }, {
    key: "addResources",
    value: function(i, l, h) {
      var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var m in h)
        (typeof h[m] == "string" || Object.prototype.toString.apply(h[m]) === "[object Array]") && this.addResource(i, l, m, h[m], {
          silent: !0
        });
      s.silent || this.emit("added", i, l, h);
    }
  }, {
    key: "addResourceBundle",
    value: function(i, l, h, s, m) {
      var v = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, E = [i, l];
      i.indexOf(".") > -1 && (E = i.split("."), s = h, h = l, l = E[1]), this.addNamespaces(l);
      var T = ey(this.data, E) || {};
      s ? ZM(T, h, m) : T = Vm(Vm({}, T), h), FE(this.data, E, T), v.silent || this.emit("added", i, l, h);
    }
  }, {
    key: "removeResourceBundle",
    value: function(i, l) {
      this.hasResourceBundle(i, l) && delete this.data[i][l], this.removeNamespaces(l), this.emit("removed", i, l);
    }
  }, {
    key: "hasResourceBundle",
    value: function(i, l) {
      return this.getResource(i, l) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(i, l) {
      return l || (l = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? Vm(Vm({}, {}), this.getResource(i, l)) : this.getResource(i, l);
    }
  }, {
    key: "getDataByLanguage",
    value: function(i) {
      return this.data[i];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function(i) {
      var l = this.getDataByLanguage(i), h = l && Object.keys(l) || [];
      return !!h.find(function(s) {
        return l[s] && Object.keys(l[s]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), r;
}(Xl), KM = {
  processors: {},
  addPostProcessor: function(e) {
    this.processors[e.name] = e;
  },
  handle: function(e, r, n, i, l) {
    var h = this;
    return e.forEach(function(s) {
      h.processors[s] && (r = h.processors[s].process(r, n, i, l));
    }), r;
  }
};
function UE(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function lo(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? UE(Object(r), !0).forEach(function(n) {
      Yl(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : UE(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function $U(t) {
  var e = VU();
  return function() {
    var n = cs(t), i;
    if (e) {
      var l = cs(this).constructor;
      i = Reflect.construct(n, arguments, l);
    } else
      i = n.apply(this, arguments);
    return cp(this, i);
  };
}
function VU() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var $E = {}, VE = function(t) {
  jy(r, t);
  var e = $U(r);
  function r(n) {
    var i, l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return hs(this, r), i = e.call(this), Gy && Xl.call(Ul(i)), RU(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], n, Ul(i)), i.options = l, i.options.keySeparator === void 0 && (i.options.keySeparator = "."), i.logger = es.create("translator"), i;
  }
  return fs(r, [{
    key: "changeLanguage",
    value: function(i) {
      i && (this.language = i);
    }
  }, {
    key: "exists",
    value: function(i) {
      var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (i == null)
        return !1;
      var h = this.resolve(i, l);
      return h && h.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(i, l) {
      var h = l.nsSeparator !== void 0 ? l.nsSeparator : this.options.nsSeparator;
      h === void 0 && (h = ":");
      var s = l.keySeparator !== void 0 ? l.keySeparator : this.options.keySeparator, m = l.ns || this.options.defaultNS || [], v = h && i.indexOf(h) > -1, E = !this.options.userDefinedKeySeparator && !l.keySeparator && !this.options.userDefinedNsSeparator && !l.nsSeparator && !FU(i, h, s);
      if (v && !E) {
        var T = i.match(this.interpolator.nestingRegexp);
        if (T && T.length > 0)
          return {
            key: i,
            namespaces: m
          };
        var S = i.split(h);
        (h !== s || h === s && this.options.ns.indexOf(S[0]) > -1) && (m = S.shift()), i = S.join(s);
      }
      return typeof m == "string" && (m = [m]), {
        key: i,
        namespaces: m
      };
    }
  }, {
    key: "translate",
    value: function(i, l, h) {
      var s = this;
      if (Ra(l) !== "object" && this.options.overloadTranslationOptionHandler && (l = this.options.overloadTranslationOptionHandler(arguments)), l || (l = {}), i == null)
        return "";
      Array.isArray(i) || (i = [String(i)]);
      var m = l.returnDetails !== void 0 ? l.returnDetails : this.options.returnDetails, v = l.keySeparator !== void 0 ? l.keySeparator : this.options.keySeparator, E = this.extractFromKey(i[i.length - 1], l), T = E.key, S = E.namespaces, A = S[S.length - 1], L = l.lng || this.language, B = l.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (L && L.toLowerCase() === "cimode") {
        if (B) {
          var j = l.nsSeparator || this.options.nsSeparator;
          return m ? {
            res: "".concat(A).concat(j).concat(T),
            usedKey: T,
            exactUsedKey: T,
            usedLng: L,
            usedNS: A
          } : "".concat(A).concat(j).concat(T);
        }
        return m ? {
          res: T,
          usedKey: T,
          exactUsedKey: T,
          usedLng: L,
          usedNS: A
        } : T;
      }
      var q = this.resolve(i, l), H = q && q.res, ne = q && q.usedKey || T, ee = q && q.exactUsedKey || T, he = Object.prototype.toString.apply(H), Te = ["[object Number]", "[object Function]", "[object RegExp]"], ve = l.joinArrays !== void 0 ? l.joinArrays : this.options.joinArrays, Oe = !this.i18nFormat || this.i18nFormat.handleAsObject, Me = typeof H != "string" && typeof H != "boolean" && typeof H != "number";
      if (Oe && H && Me && Te.indexOf(he) < 0 && !(typeof ve == "string" && he === "[object Array]")) {
        if (!l.returnObjects && !this.options.returnObjects) {
          this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          var Re = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(ne, H, lo(lo({}, l), {}, {
            ns: S
          })) : "key '".concat(T, " (").concat(this.language, ")' returned an object instead of string.");
          return m ? (q.res = Re, q) : Re;
        }
        if (v) {
          var He = he === "[object Array]", Ve = He ? [] : {}, dt = He ? ee : ne;
          for (var xe in H)
            if (Object.prototype.hasOwnProperty.call(H, xe)) {
              var ze = "".concat(dt).concat(v).concat(xe);
              Ve[xe] = this.translate(ze, lo(lo({}, l), {
                joinArrays: !1,
                ns: S
              })), Ve[xe] === ze && (Ve[xe] = H[xe]);
            }
          H = Ve;
        }
      } else if (Oe && typeof ve == "string" && he === "[object Array]")
        H = H.join(ve), H && (H = this.extendTranslation(H, i, l, h));
      else {
        var Pe = !1, Ye = !1, it = l.count !== void 0 && typeof l.count != "string", kt = r.hasDefaultValue(l), Er = it ? this.pluralResolver.getSuffix(L, l.count, l) : "", mr = l["defaultValue".concat(Er)] || l.defaultValue;
        !this.isValidLookup(H) && kt && (Pe = !0, H = mr), this.isValidLookup(H) || (Ye = !0, H = T);
        var Yt = l.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, on = Yt && Ye ? void 0 : H, or = kt && mr !== H && this.options.updateMissing;
        if (Ye || Pe || or) {
          if (this.logger.log(or ? "updateKey" : "missingKey", L, A, T, or ? mr : H), v) {
            var Jt = this.resolve(T, lo(lo({}, l), {}, {
              keySeparator: !1
            }));
            Jt && Jt.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var Ht = [], xr = this.languageUtils.getFallbackCodes(this.options.fallbackLng, l.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && xr && xr[0])
            for (var Cr = 0; Cr < xr.length; Cr++)
              Ht.push(xr[Cr]);
          else
            this.options.saveMissingTo === "all" ? Ht = this.languageUtils.toResolveHierarchy(l.lng || this.language) : Ht.push(l.lng || this.language);
          var an = function(Pn, qr, re) {
            var pe = kt && re !== H ? re : on;
            s.options.missingKeyHandler ? s.options.missingKeyHandler(Pn, A, qr, pe, or, l) : s.backendConnector && s.backendConnector.saveMissing && s.backendConnector.saveMissing(Pn, A, qr, pe, or, l), s.emit("missingKey", Pn, A, qr, H);
          };
          this.options.saveMissing && (this.options.saveMissingPlurals && it ? Ht.forEach(function(kr) {
            s.pluralResolver.getSuffixes(kr, l).forEach(function(Pn) {
              an([kr], T + Pn, l["defaultValue".concat(Pn)] || mr);
            });
          }) : an(Ht, T, mr));
        }
        H = this.extendTranslation(H, i, l, q, h), Ye && H === T && this.options.appendNamespaceToMissingKey && (H = "".concat(A, ":").concat(T)), (Ye || Pe) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? H = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(A, ":").concat(T) : T, Pe ? H : void 0) : H = this.options.parseMissingKeyHandler(H));
      }
      return m ? (q.res = H, q) : H;
    }
  }, {
    key: "extendTranslation",
    value: function(i, l, h, s, m) {
      var v = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        i = this.i18nFormat.parse(i, lo(lo({}, this.options.interpolation.defaultVariables), h), s.usedLng, s.usedNS, s.usedKey, {
          resolved: s
        });
      else if (!h.skipInterpolation) {
        h.interpolation && this.interpolator.init(lo(lo({}, h), {
          interpolation: lo(lo({}, this.options.interpolation), h.interpolation)
        }));
        var E = typeof i == "string" && (h && h.interpolation && h.interpolation.skipOnVariables !== void 0 ? h.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), T;
        if (E) {
          var S = i.match(this.interpolator.nestingRegexp);
          T = S && S.length;
        }
        var A = h.replace && typeof h.replace != "string" ? h.replace : h;
        if (this.options.interpolation.defaultVariables && (A = lo(lo({}, this.options.interpolation.defaultVariables), A)), i = this.interpolator.interpolate(i, A, h.lng || this.language, h), E) {
          var L = i.match(this.interpolator.nestingRegexp), B = L && L.length;
          T < B && (h.nest = !1);
        }
        h.nest !== !1 && (i = this.interpolator.nest(i, function() {
          for (var H = arguments.length, ne = new Array(H), ee = 0; ee < H; ee++)
            ne[ee] = arguments[ee];
          return m && m[0] === ne[0] && !h.context ? (v.logger.warn("It seems you are nesting recursively key: ".concat(ne[0], " in key: ").concat(l[0])), null) : v.translate.apply(v, ne.concat([l]));
        }, h)), h.interpolation && this.interpolator.reset();
      }
      var j = h.postProcess || this.options.postProcess, q = typeof j == "string" ? [j] : j;
      return i != null && q && q.length && h.applyPostProcessor !== !1 && (i = KM.handle(q, i, l, this.options && this.options.postProcessPassResolved ? lo({
        i18nResolved: s
      }, h) : h, this)), i;
    }
  }, {
    key: "resolve",
    value: function(i) {
      var l = this, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s, m, v, E, T;
      return typeof i == "string" && (i = [i]), i.forEach(function(S) {
        if (!l.isValidLookup(s)) {
          var A = l.extractFromKey(S, h), L = A.key;
          m = L;
          var B = A.namespaces;
          l.options.fallbackNS && (B = B.concat(l.options.fallbackNS));
          var j = h.count !== void 0 && typeof h.count != "string", q = j && !h.ordinal && h.count === 0 && l.pluralResolver.shouldUseIntlApi(), H = h.context !== void 0 && (typeof h.context == "string" || typeof h.context == "number") && h.context !== "", ne = h.lngs ? h.lngs : l.languageUtils.toResolveHierarchy(h.lng || l.language, h.fallbackLng);
          B.forEach(function(ee) {
            l.isValidLookup(s) || (T = ee, !$E["".concat(ne[0], "-").concat(ee)] && l.utils && l.utils.hasLoadedNamespace && !l.utils.hasLoadedNamespace(T) && ($E["".concat(ne[0], "-").concat(ee)] = !0, l.logger.warn('key "'.concat(m, '" for languages "').concat(ne.join(", "), `" won't get resolved as namespace "`).concat(T, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), ne.forEach(function(he) {
              if (!l.isValidLookup(s)) {
                E = he;
                var Te = [L];
                if (l.i18nFormat && l.i18nFormat.addLookupKeys)
                  l.i18nFormat.addLookupKeys(Te, L, he, ee, h);
                else {
                  var ve;
                  j && (ve = l.pluralResolver.getSuffix(he, h.count, h));
                  var Oe = "".concat(l.options.pluralSeparator, "zero");
                  if (j && (Te.push(L + ve), q && Te.push(L + Oe)), H) {
                    var Me = "".concat(L).concat(l.options.contextSeparator).concat(h.context);
                    Te.push(Me), j && (Te.push(Me + ve), q && Te.push(Me + Oe));
                  }
                }
                for (var Re; Re = Te.pop(); )
                  l.isValidLookup(s) || (v = Re, s = l.getResource(he, ee, Re, h));
              }
            }));
          });
        }
      }), {
        res: s,
        usedKey: m,
        exactUsedKey: v,
        usedLng: E,
        usedNS: T
      };
    }
  }, {
    key: "isValidLookup",
    value: function(i) {
      return i !== void 0 && !(!this.options.returnNull && i === null) && !(!this.options.returnEmptyString && i === "");
    }
  }, {
    key: "getResource",
    value: function(i, l, h) {
      var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(i, l, h, s) : this.resourceStore.getResource(i, l, h, s);
    }
  }], [{
    key: "hasDefaultValue",
    value: function(i) {
      var l = "defaultValue";
      for (var h in i)
        if (Object.prototype.hasOwnProperty.call(i, h) && l === h.substring(0, l.length) && i[h] !== void 0)
          return !0;
      return !1;
    }
  }]), r;
}(Xl);
function Cv(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
var jE = function() {
  function t(e) {
    hs(this, t), this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = es.create("languageUtils");
  }
  return fs(t, [{
    key: "getScriptPartFromCode",
    value: function(r) {
      if (!r || r.indexOf("-") < 0)
        return null;
      var n = r.split("-");
      return n.length === 2 || (n.pop(), n[n.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(n.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(r) {
      if (!r || r.indexOf("-") < 0)
        return r;
      var n = r.split("-");
      return this.formatLanguageCode(n[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(r) {
      if (typeof r == "string" && r.indexOf("-") > -1) {
        var n = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], i = r.split("-");
        return this.options.lowerCaseLng ? i = i.map(function(l) {
          return l.toLowerCase();
        }) : i.length === 2 ? (i[0] = i[0].toLowerCase(), i[1] = i[1].toUpperCase(), n.indexOf(i[1].toLowerCase()) > -1 && (i[1] = Cv(i[1].toLowerCase()))) : i.length === 3 && (i[0] = i[0].toLowerCase(), i[1].length === 2 && (i[1] = i[1].toUpperCase()), i[0] !== "sgn" && i[2].length === 2 && (i[2] = i[2].toUpperCase()), n.indexOf(i[1].toLowerCase()) > -1 && (i[1] = Cv(i[1].toLowerCase())), n.indexOf(i[2].toLowerCase()) > -1 && (i[2] = Cv(i[2].toLowerCase()))), i.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? r.toLowerCase() : r;
    }
  }, {
    key: "isSupportedCode",
    value: function(r) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (r = this.getLanguagePartFromCode(r)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(r) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function(r) {
      var n = this;
      if (!r)
        return null;
      var i;
      return r.forEach(function(l) {
        if (!i) {
          var h = n.formatLanguageCode(l);
          (!n.options.supportedLngs || n.isSupportedCode(h)) && (i = h);
        }
      }), !i && this.options.supportedLngs && r.forEach(function(l) {
        if (!i) {
          var h = n.getLanguagePartFromCode(l);
          if (n.isSupportedCode(h))
            return i = h;
          i = n.options.supportedLngs.find(function(s) {
            if (s.indexOf(h) === 0)
              return s;
          });
        }
      }), i || (i = this.getFallbackCodes(this.options.fallbackLng)[0]), i;
    }
  }, {
    key: "getFallbackCodes",
    value: function(r, n) {
      if (!r)
        return [];
      if (typeof r == "function" && (r = r(n)), typeof r == "string" && (r = [r]), Object.prototype.toString.apply(r) === "[object Array]")
        return r;
      if (!n)
        return r.default || [];
      var i = r[n];
      return i || (i = r[this.getScriptPartFromCode(n)]), i || (i = r[this.formatLanguageCode(n)]), i || (i = r[this.getLanguagePartFromCode(n)]), i || (i = r.default), i || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(r, n) {
      var i = this, l = this.getFallbackCodes(n || this.options.fallbackLng || [], r), h = [], s = function(v) {
        !v || (i.isSupportedCode(v) ? h.push(v) : i.logger.warn("rejecting language code not found in supportedLngs: ".concat(v)));
      };
      return typeof r == "string" && r.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && s(this.formatLanguageCode(r)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && s(this.getScriptPartFromCode(r)), this.options.load !== "currentOnly" && s(this.getLanguagePartFromCode(r))) : typeof r == "string" && s(this.formatLanguageCode(r)), l.forEach(function(m) {
        h.indexOf(m) < 0 && s(i.formatLanguageCode(m));
      }), h;
    }
  }]), t;
}(), jU = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], GU = {
  1: function(e) {
    return Number(e > 1);
  },
  2: function(e) {
    return Number(e != 1);
  },
  3: function(e) {
    return 0;
  },
  4: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  5: function(e) {
    return Number(e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5);
  },
  6: function(e) {
    return Number(e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2);
  },
  7: function(e) {
    return Number(e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  8: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3);
  },
  9: function(e) {
    return Number(e >= 2);
  },
  10: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4);
  },
  11: function(e) {
    return Number(e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3);
  },
  12: function(e) {
    return Number(e % 10 != 1 || e % 100 == 11);
  },
  13: function(e) {
    return Number(e !== 0);
  },
  14: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3);
  },
  15: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  16: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2);
  },
  17: function(e) {
    return Number(e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1);
  },
  18: function(e) {
    return Number(e == 0 ? 0 : e == 1 ? 1 : 2);
  },
  19: function(e) {
    return Number(e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3);
  },
  20: function(e) {
    return Number(e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2);
  },
  21: function(e) {
    return Number(e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0);
  },
  22: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3);
  }
}, qU = ["v1", "v2", "v3"], GE = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function WU() {
  var t = {};
  return jU.forEach(function(e) {
    e.lngs.forEach(function(r) {
      t[r] = {
        numbers: e.nr,
        plurals: GU[e.fc]
      };
    });
  }), t;
}
var XU = function() {
  function t(e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    hs(this, t), this.languageUtils = e, this.options = r, this.logger = es.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = WU();
  }
  return fs(t, [{
    key: "addRule",
    value: function(r, n) {
      this.rules[r] = n;
    }
  }, {
    key: "getRule",
    value: function(r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
        try {
          return new Intl.PluralRules(r, {
            type: n.ordinal ? "ordinal" : "cardinal"
          });
        } catch {
          return;
        }
      return this.rules[r] || this.rules[this.languageUtils.getLanguagePartFromCode(r)];
    }
  }, {
    key: "needsPlural",
    value: function(r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = this.getRule(r, n);
      return this.shouldUseIntlApi() ? i && i.resolvedOptions().pluralCategories.length > 1 : i && i.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(r, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(r, i).map(function(l) {
        return "".concat(n).concat(l);
      });
    }
  }, {
    key: "getSuffixes",
    value: function(r) {
      var n = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = this.getRule(r, i);
      return l ? this.shouldUseIntlApi() ? l.resolvedOptions().pluralCategories.sort(function(h, s) {
        return GE[h] - GE[s];
      }).map(function(h) {
        return "".concat(n.options.prepend).concat(h);
      }) : l.numbers.map(function(h) {
        return n.getSuffix(r, h, i);
      }) : [];
    }
  }, {
    key: "getSuffix",
    value: function(r, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = this.getRule(r, i);
      return l ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(l.select(n)) : this.getSuffixRetroCompatible(l, n) : (this.logger.warn("no plural rule found for: ".concat(r)), "");
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function(r, n) {
      var i = this, l = r.noAbs ? r.plurals(n) : r.plurals(Math.abs(n)), h = r.numbers[l];
      this.options.simplifyPluralSuffix && r.numbers.length === 2 && r.numbers[0] === 1 && (h === 2 ? h = "plural" : h === 1 && (h = ""));
      var s = function() {
        return i.options.prepend && h.toString() ? i.options.prepend + h.toString() : h.toString();
      };
      return this.options.compatibilityJSON === "v1" ? h === 1 ? "" : typeof h == "number" ? "_plural_".concat(h.toString()) : s() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && r.numbers.length === 2 && r.numbers[0] === 1 ? s() : this.options.prepend && l.toString() ? this.options.prepend + l.toString() : l.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function() {
      return !qU.includes(this.options.compatibilityJSON);
    }
  }]), t;
}();
function qE(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function _a(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? qE(Object(r), !0).forEach(function(n) {
      Yl(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : qE(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
var ZU = function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    hs(this, t), this.logger = es.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || function(r) {
      return r;
    }, this.init(e);
  }
  return fs(t, [{
    key: "init",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      r.interpolation || (r.interpolation = {
        escapeValue: !0
      });
      var n = r.interpolation;
      this.escape = n.escape !== void 0 ? n.escape : kU, this.escapeValue = n.escapeValue !== void 0 ? n.escapeValue : !0, this.useRawValueToEscape = n.useRawValueToEscape !== void 0 ? n.useRawValueToEscape : !1, this.prefix = n.prefix ? Qu(n.prefix) : n.prefixEscaped || "{{", this.suffix = n.suffix ? Qu(n.suffix) : n.suffixEscaped || "}}", this.formatSeparator = n.formatSeparator ? n.formatSeparator : n.formatSeparator || ",", this.unescapePrefix = n.unescapeSuffix ? "" : n.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : n.unescapeSuffix || "", this.nestingPrefix = n.nestingPrefix ? Qu(n.nestingPrefix) : n.nestingPrefixEscaped || Qu("$t("), this.nestingSuffix = n.nestingSuffix ? Qu(n.nestingSuffix) : n.nestingSuffixEscaped || Qu(")"), this.nestingOptionsSeparator = n.nestingOptionsSeparator ? n.nestingOptionsSeparator : n.nestingOptionsSeparator || ",", this.maxReplaces = n.maxReplaces ? n.maxReplaces : 1e3, this.alwaysFormat = n.alwaysFormat !== void 0 ? n.alwaysFormat : !1, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var r = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(r, "g");
      var n = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(n, "g");
      var i = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(i, "g");
    }
  }, {
    key: "interpolate",
    value: function(r, n, i, l) {
      var h = this, s, m, v, E = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function T(j) {
        return j.replace(/\$/g, "$$$$");
      }
      var S = function(q) {
        if (q.indexOf(h.formatSeparator) < 0) {
          var H = zE(n, E, q);
          return h.alwaysFormat ? h.format(H, void 0, i, _a(_a(_a({}, l), n), {}, {
            interpolationkey: q
          })) : H;
        }
        var ne = q.split(h.formatSeparator), ee = ne.shift().trim(), he = ne.join(h.formatSeparator).trim();
        return h.format(zE(n, E, ee), he, i, _a(_a(_a({}, l), n), {}, {
          interpolationkey: ee
        }));
      };
      this.resetRegExp();
      var A = l && l.missingInterpolationHandler || this.options.missingInterpolationHandler, L = l && l.interpolation && l.interpolation.skipOnVariables !== void 0 ? l.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, B = [{
        regex: this.regexpUnescape,
        safeValue: function(q) {
          return T(q);
        }
      }, {
        regex: this.regexp,
        safeValue: function(q) {
          return h.escapeValue ? T(h.escape(q)) : T(q);
        }
      }];
      return B.forEach(function(j) {
        for (v = 0; s = j.regex.exec(r); ) {
          var q = s[1].trim();
          if (m = S(q), m === void 0)
            if (typeof A == "function") {
              var H = A(r, s, l);
              m = typeof H == "string" ? H : "";
            } else if (l && Object.prototype.hasOwnProperty.call(l, q))
              m = "";
            else if (L) {
              m = s[0];
              continue;
            } else
              h.logger.warn("missed to pass in variable ".concat(q, " for interpolating ").concat(r)), m = "";
          else
            typeof m != "string" && !h.useRawValueToEscape && (m = NE(m));
          var ne = j.safeValue(m);
          if (r = r.replace(s[0], ne), L ? (j.regex.lastIndex += m.length, j.regex.lastIndex -= s[0].length) : j.regex.lastIndex = 0, v++, v >= h.maxReplaces)
            break;
        }
      }), r;
    }
  }, {
    key: "nest",
    value: function(r, n) {
      var i = this, l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h, s, m;
      function v(A, L) {
        var B = this.nestingOptionsSeparator;
        if (A.indexOf(B) < 0)
          return A;
        var j = A.split(new RegExp("".concat(B, "[ ]*{"))), q = "{".concat(j[1]);
        A = j[0], q = this.interpolate(q, m);
        var H = q.match(/'/g), ne = q.match(/"/g);
        (H && H.length % 2 === 0 && !ne || ne.length % 2 !== 0) && (q = q.replace(/'/g, '"'));
        try {
          m = JSON.parse(q), L && (m = _a(_a({}, L), m));
        } catch (ee) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(A), ee), "".concat(A).concat(B).concat(q);
        }
        return delete m.defaultValue, A;
      }
      for (; h = this.nestingRegexp.exec(r); ) {
        var E = [];
        m = _a({}, l), m = m.replace && typeof m.replace != "string" ? m.replace : m, m.applyPostProcessor = !1, delete m.defaultValue;
        var T = !1;
        if (h[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(h[1])) {
          var S = h[1].split(this.formatSeparator).map(function(A) {
            return A.trim();
          });
          h[1] = S.shift(), E = S, T = !0;
        }
        if (s = n(v.call(this, h[1].trim(), m), m), s && h[0] === r && typeof s != "string")
          return s;
        typeof s != "string" && (s = NE(s)), s || (this.logger.warn("missed to resolve ".concat(h[1], " for nesting ").concat(r)), s = ""), T && (s = E.reduce(function(A, L) {
          return i.format(A, L, l.lng, _a(_a({}, l), {}, {
            interpolationkey: h[1].trim()
          }));
        }, s.trim())), r = r.replace(h[0], s), this.regexp.lastIndex = 0;
      }
      return r;
    }
  }]), t;
}();
function WE(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function As(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? WE(Object(r), !0).forEach(function(n) {
      Yl(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : WE(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function HU(t) {
  var e = t.toLowerCase().trim(), r = {};
  if (t.indexOf("(") > -1) {
    var n = t.split("(");
    e = n[0].toLowerCase().trim();
    var i = n[1].substring(0, n[1].length - 1);
    if (e === "currency" && i.indexOf(":") < 0)
      r.currency || (r.currency = i.trim());
    else if (e === "relativetime" && i.indexOf(":") < 0)
      r.range || (r.range = i.trim());
    else {
      var l = i.split(";");
      l.forEach(function(h) {
        if (!!h) {
          var s = h.split(":"), m = PU(s), v = m[0], E = m.slice(1), T = E.join(":").trim().replace(/^'+|'+$/g, "");
          r[v.trim()] || (r[v.trim()] = T), T === "false" && (r[v.trim()] = !1), T === "true" && (r[v.trim()] = !0), isNaN(T) || (r[v.trim()] = parseInt(T, 10));
        }
      });
    }
  }
  return {
    formatName: e,
    formatOptions: r
  };
}
function eh(t) {
  var e = {};
  return function(n, i, l) {
    var h = i + JSON.stringify(l), s = e[h];
    return s || (s = t(i, l), e[h] = s), s(n);
  };
}
var KU = function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    hs(this, t), this.logger = es.create("formatter"), this.options = e, this.formats = {
      number: eh(function(r, n) {
        var i = new Intl.NumberFormat(r, As({}, n));
        return function(l) {
          return i.format(l);
        };
      }),
      currency: eh(function(r, n) {
        var i = new Intl.NumberFormat(r, As(As({}, n), {}, {
          style: "currency"
        }));
        return function(l) {
          return i.format(l);
        };
      }),
      datetime: eh(function(r, n) {
        var i = new Intl.DateTimeFormat(r, As({}, n));
        return function(l) {
          return i.format(l);
        };
      }),
      relativetime: eh(function(r, n) {
        var i = new Intl.RelativeTimeFormat(r, As({}, n));
        return function(l) {
          return i.format(l, n.range || "day");
        };
      }),
      list: eh(function(r, n) {
        var i = new Intl.ListFormat(r, As({}, n));
        return function(l) {
          return i.format(l);
        };
      })
    }, this.init(e);
  }
  return fs(t, [{
    key: "init",
    value: function(r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, i = n.interpolation;
      this.formatSeparator = i.formatSeparator ? i.formatSeparator : i.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function(r, n) {
      this.formats[r.toLowerCase().trim()] = n;
    }
  }, {
    key: "addCached",
    value: function(r, n) {
      this.formats[r.toLowerCase().trim()] = eh(n);
    }
  }, {
    key: "format",
    value: function(r, n, i) {
      var l = this, h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, s = n.split(this.formatSeparator), m = s.reduce(function(v, E) {
        var T = HU(E), S = T.formatName, A = T.formatOptions;
        if (l.formats[S]) {
          var L = v;
          try {
            var B = h && h.formatParams && h.formatParams[h.interpolationkey] || {}, j = B.locale || B.lng || h.locale || h.lng || i;
            L = l.formats[S](v, j, As(As(As({}, A), h), B));
          } catch (q) {
            l.logger.warn(q);
          }
          return L;
        } else
          l.logger.warn("there was no format function for ".concat(S));
        return v;
      }, r);
      return m;
    }
  }]), t;
}();
function XE(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function ZE(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? XE(Object(r), !0).forEach(function(n) {
      Yl(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : XE(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function YU(t) {
  var e = JU();
  return function() {
    var n = cs(t), i;
    if (e) {
      var l = cs(this).constructor;
      i = Reflect.construct(n, arguments, l);
    } else
      i = n.apply(this, arguments);
    return cp(this, i);
  };
}
function JU() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function QU(t, e) {
  t.pending[e] !== void 0 && (delete t.pending[e], t.pendingCount--);
}
var e$ = function(t) {
  jy(r, t);
  var e = YU(r);
  function r(n, i, l) {
    var h, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return hs(this, r), h = e.call(this), Gy && Xl.call(Ul(h)), h.backend = n, h.store = i, h.services = l, h.languageUtils = l.languageUtils, h.options = s, h.logger = es.create("backendConnector"), h.waitingReads = [], h.maxParallelReads = s.maxParallelReads || 10, h.readingCalls = 0, h.maxRetries = s.maxRetries >= 0 ? s.maxRetries : 5, h.retryTimeout = s.retryTimeout >= 1 ? s.retryTimeout : 350, h.state = {}, h.queue = [], h.backend && h.backend.init && h.backend.init(l, s.backend, s), h;
  }
  return fs(r, [{
    key: "queueLoad",
    value: function(i, l, h, s) {
      var m = this, v = {}, E = {}, T = {}, S = {};
      return i.forEach(function(A) {
        var L = !0;
        l.forEach(function(B) {
          var j = "".concat(A, "|").concat(B);
          !h.reload && m.store.hasResourceBundle(A, B) ? m.state[j] = 2 : m.state[j] < 0 || (m.state[j] === 1 ? E[j] === void 0 && (E[j] = !0) : (m.state[j] = 1, L = !1, E[j] === void 0 && (E[j] = !0), v[j] === void 0 && (v[j] = !0), S[B] === void 0 && (S[B] = !0)));
        }), L || (T[A] = !0);
      }), (Object.keys(v).length || Object.keys(E).length) && this.queue.push({
        pending: E,
        pendingCount: Object.keys(E).length,
        loaded: {},
        errors: [],
        callback: s
      }), {
        toLoad: Object.keys(v),
        pending: Object.keys(E),
        toLoadLanguages: Object.keys(T),
        toLoadNamespaces: Object.keys(S)
      };
    }
  }, {
    key: "loaded",
    value: function(i, l, h) {
      var s = i.split("|"), m = s[0], v = s[1];
      l && this.emit("failedLoading", m, v, l), h && this.store.addResourceBundle(m, v, h), this.state[i] = l ? -1 : 2;
      var E = {};
      this.queue.forEach(function(T) {
        LU(T.loaded, [m], v), QU(T, i), l && T.errors.push(l), T.pendingCount === 0 && !T.done && (Object.keys(T.loaded).forEach(function(S) {
          E[S] || (E[S] = {});
          var A = T.loaded[S];
          A.length && A.forEach(function(L) {
            E[S][L] === void 0 && (E[S][L] = !0);
          });
        }), T.done = !0, T.errors.length ? T.callback(T.errors) : T.callback());
      }), this.emit("loaded", E), this.queue = this.queue.filter(function(T) {
        return !T.done;
      });
    }
  }, {
    key: "read",
    value: function(i, l, h) {
      var s = this, m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, v = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, E = arguments.length > 5 ? arguments[5] : void 0;
      if (!i.length)
        return E(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: i,
          ns: l,
          fcName: h,
          tried: m,
          wait: v,
          callback: E
        });
        return;
      }
      this.readingCalls++;
      var T = function(B, j) {
        if (s.readingCalls--, s.waitingReads.length > 0) {
          var q = s.waitingReads.shift();
          s.read(q.lng, q.ns, q.fcName, q.tried, q.wait, q.callback);
        }
        if (B && j && m < s.maxRetries) {
          setTimeout(function() {
            s.read.call(s, i, l, h, m + 1, v * 2, E);
          }, v);
          return;
        }
        E(B, j);
      }, S = this.backend[h].bind(this.backend);
      if (S.length === 2) {
        try {
          var A = S(i, l);
          A && typeof A.then == "function" ? A.then(function(L) {
            return T(null, L);
          }).catch(T) : T(null, A);
        } catch (L) {
          T(L);
        }
        return;
      }
      return S(i, l, T);
    }
  }, {
    key: "prepareLoading",
    value: function(i, l) {
      var h = this, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, m = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), m && m();
      typeof i == "string" && (i = this.languageUtils.toResolveHierarchy(i)), typeof l == "string" && (l = [l]);
      var v = this.queueLoad(i, l, s, m);
      if (!v.toLoad.length)
        return v.pending.length || m(), null;
      v.toLoad.forEach(function(E) {
        h.loadOne(E);
      });
    }
  }, {
    key: "load",
    value: function(i, l, h) {
      this.prepareLoading(i, l, {}, h);
    }
  }, {
    key: "reload",
    value: function(i, l, h) {
      this.prepareLoading(i, l, {
        reload: !0
      }, h);
    }
  }, {
    key: "loadOne",
    value: function(i) {
      var l = this, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", s = i.split("|"), m = s[0], v = s[1];
      this.read(m, v, "read", void 0, void 0, function(E, T) {
        E && l.logger.warn("".concat(h, "loading namespace ").concat(v, " for language ").concat(m, " failed"), E), !E && T && l.logger.log("".concat(h, "loaded namespace ").concat(v, " for language ").concat(m), T), l.loaded(i, E, T);
      });
    }
  }, {
    key: "saveMissing",
    value: function(i, l, h, s, m) {
      var v = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, E = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function() {
      };
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(l)) {
        this.logger.warn('did not save key "'.concat(h, '" as the namespace "').concat(l, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (!(h == null || h === "")) {
        if (this.backend && this.backend.create) {
          var T = ZE(ZE({}, v), {}, {
            isUpdate: m
          }), S = this.backend.create.bind(this.backend);
          if (S.length < 6)
            try {
              var A;
              S.length === 5 ? A = S(i, l, h, s, T) : A = S(i, l, h, s), A && typeof A.then == "function" ? A.then(function(L) {
                return E(null, L);
              }).catch(E) : E(null, A);
            } catch (L) {
              E(L);
            }
          else
            S(i, l, h, s, E, T);
        }
        !i || !i[0] || this.store.addResource(i[0], l, h, s);
      }
    }
  }]), r;
}(Xl);
function HE() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      var r = {};
      if (Ra(e[1]) === "object" && (r = e[1]), typeof e[1] == "string" && (r.defaultValue = e[1]), typeof e[2] == "string" && (r.tDescription = e[2]), Ra(e[2]) === "object" || Ra(e[3]) === "object") {
        var n = e[3] || e[2];
        Object.keys(n).forEach(function(i) {
          r[i] = n[i];
        });
      }
      return r;
    },
    interpolation: {
      escapeValue: !0,
      format: function(e, r, n, i) {
        return e;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function KE(t) {
  return typeof t.ns == "string" && (t.ns = [t.ns]), typeof t.fallbackLng == "string" && (t.fallbackLng = [t.fallbackLng]), typeof t.fallbackNS == "string" && (t.fallbackNS = [t.fallbackNS]), t.supportedLngs && t.supportedLngs.indexOf("cimode") < 0 && (t.supportedLngs = t.supportedLngs.concat(["cimode"])), t;
}
function YE(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Xa(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? YE(Object(r), !0).forEach(function(n) {
      Yl(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : YE(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function t$(t) {
  var e = r$();
  return function() {
    var n = cs(t), i;
    if (e) {
      var l = cs(this).constructor;
      i = Reflect.construct(n, arguments, l);
    } else
      i = n.apply(this, arguments);
    return cp(this, i);
  };
}
function r$() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function jm() {
}
function n$(t) {
  var e = Object.getOwnPropertyNames(Object.getPrototypeOf(t));
  e.forEach(function(r) {
    typeof t[r] == "function" && (t[r] = t[r].bind(t));
  });
}
var ty = function(t) {
  jy(r, t);
  var e = t$(r);
  function r() {
    var n, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, l = arguments.length > 1 ? arguments[1] : void 0;
    if (hs(this, r), n = e.call(this), Gy && Xl.call(Ul(n)), n.options = KE(i), n.services = {}, n.logger = es, n.modules = {
      external: []
    }, n$(Ul(n)), l && !n.isInitialized && !i.isClone) {
      if (!n.options.initImmediate)
        return n.init(i, l), cp(n, Ul(n));
      setTimeout(function() {
        n.init(i, l);
      }, 0);
    }
    return n;
  }
  return fs(r, [{
    key: "init",
    value: function() {
      var i = this, l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 ? arguments[1] : void 0;
      typeof l == "function" && (h = l, l = {}), !l.defaultNS && l.defaultNS !== !1 && l.ns && (typeof l.ns == "string" ? l.defaultNS = l.ns : l.ns.indexOf("translation") < 0 && (l.defaultNS = l.ns[0]));
      var s = HE();
      this.options = Xa(Xa(Xa({}, s), this.options), KE(l)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = Xa(Xa({}, s.interpolation), this.options.interpolation)), l.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = l.keySeparator), l.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = l.nsSeparator);
      function m(q) {
        return q ? typeof q == "function" ? new q() : q : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? es.init(m(this.modules.logger), this.options) : es.init(null, this.options);
        var v;
        this.modules.formatter ? v = this.modules.formatter : typeof Intl < "u" && (v = KU);
        var E = new jE(this.options);
        this.store = new UU(this.options.resources, this.options);
        var T = this.services;
        T.logger = es, T.resourceStore = this.store, T.languageUtils = E, T.pluralResolver = new XU(E, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), v && (!this.options.interpolation.format || this.options.interpolation.format === s.interpolation.format) && (T.formatter = m(v), T.formatter.init(T, this.options), this.options.interpolation.format = T.formatter.format.bind(T.formatter)), T.interpolator = new ZU(this.options), T.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, T.backendConnector = new e$(m(this.modules.backend), T.resourceStore, T, this.options), T.backendConnector.on("*", function(q) {
          for (var H = arguments.length, ne = new Array(H > 1 ? H - 1 : 0), ee = 1; ee < H; ee++)
            ne[ee - 1] = arguments[ee];
          i.emit.apply(i, [q].concat(ne));
        }), this.modules.languageDetector && (T.languageDetector = m(this.modules.languageDetector), T.languageDetector.init && T.languageDetector.init(T, this.options.detection, this.options)), this.modules.i18nFormat && (T.i18nFormat = m(this.modules.i18nFormat), T.i18nFormat.init && T.i18nFormat.init(this)), this.translator = new VE(this.services, this.options), this.translator.on("*", function(q) {
          for (var H = arguments.length, ne = new Array(H > 1 ? H - 1 : 0), ee = 1; ee < H; ee++)
            ne[ee - 1] = arguments[ee];
          i.emit.apply(i, [q].concat(ne));
        }), this.modules.external.forEach(function(q) {
          q.init && q.init(i);
        });
      }
      if (this.format = this.options.interpolation.format, h || (h = jm), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var S = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        S.length > 0 && S[0] !== "dev" && (this.options.lng = S[0]);
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var A = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      A.forEach(function(q) {
        i[q] = function() {
          var H;
          return (H = i.store)[q].apply(H, arguments);
        };
      });
      var L = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      L.forEach(function(q) {
        i[q] = function() {
          var H;
          return (H = i.store)[q].apply(H, arguments), i;
        };
      });
      var B = Yf(), j = function() {
        var H = function(ee, he) {
          i.isInitialized && !i.initializedStoreOnce && i.logger.warn("init: i18next is already initialized. You should call init just once!"), i.isInitialized = !0, i.options.isClone || i.logger.log("initialized", i.options), i.emit("initialized", i.options), B.resolve(he), h(ee, he);
        };
        if (i.languages && i.options.compatibilityAPI !== "v1" && !i.isInitialized)
          return H(null, i.t.bind(i));
        i.changeLanguage(i.options.lng, H);
      };
      return this.options.resources || !this.options.initImmediate ? j() : setTimeout(j, 0), B;
    }
  }, {
    key: "loadResources",
    value: function(i) {
      var l = this, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : jm, s = h, m = typeof i == "string" ? i : this.language;
      if (typeof i == "function" && (s = i), !this.options.resources || this.options.partialBundledLanguages) {
        if (m && m.toLowerCase() === "cimode")
          return s();
        var v = [], E = function(A) {
          if (!!A) {
            var L = l.services.languageUtils.toResolveHierarchy(A);
            L.forEach(function(B) {
              v.indexOf(B) < 0 && v.push(B);
            });
          }
        };
        if (m)
          E(m);
        else {
          var T = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          T.forEach(function(S) {
            return E(S);
          });
        }
        this.options.preload && this.options.preload.forEach(function(S) {
          return E(S);
        }), this.services.backendConnector.load(v, this.options.ns, function(S) {
          !S && !l.resolvedLanguage && l.language && l.setResolvedLanguage(l.language), s(S);
        });
      } else
        s(null);
    }
  }, {
    key: "reloadResources",
    value: function(i, l, h) {
      var s = Yf();
      return i || (i = this.languages), l || (l = this.options.ns), h || (h = jm), this.services.backendConnector.reload(i, l, function(m) {
        s.resolve(), h(m);
      }), s;
    }
  }, {
    key: "use",
    value: function(i) {
      if (!i)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!i.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return i.type === "backend" && (this.modules.backend = i), (i.type === "logger" || i.log && i.warn && i.error) && (this.modules.logger = i), i.type === "languageDetector" && (this.modules.languageDetector = i), i.type === "i18nFormat" && (this.modules.i18nFormat = i), i.type === "postProcessor" && KM.addPostProcessor(i), i.type === "formatter" && (this.modules.formatter = i), i.type === "3rdParty" && this.modules.external.push(i), this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function(i) {
      if (!(!i || !this.languages) && !(["cimode", "dev"].indexOf(i) > -1))
        for (var l = 0; l < this.languages.length; l++) {
          var h = this.languages[l];
          if (!(["cimode", "dev"].indexOf(h) > -1) && this.store.hasLanguageSomeTranslations(h)) {
            this.resolvedLanguage = h;
            break;
          }
        }
    }
  }, {
    key: "changeLanguage",
    value: function(i, l) {
      var h = this;
      this.isLanguageChangingTo = i;
      var s = Yf();
      this.emit("languageChanging", i);
      var m = function(S) {
        h.language = S, h.languages = h.services.languageUtils.toResolveHierarchy(S), h.resolvedLanguage = void 0, h.setResolvedLanguage(S);
      }, v = function(S, A) {
        A ? (m(A), h.translator.changeLanguage(A), h.isLanguageChangingTo = void 0, h.emit("languageChanged", A), h.logger.log("languageChanged", A)) : h.isLanguageChangingTo = void 0, s.resolve(function() {
          return h.t.apply(h, arguments);
        }), l && l(S, function() {
          return h.t.apply(h, arguments);
        });
      }, E = function(S) {
        !i && !S && h.services.languageDetector && (S = []);
        var A = typeof S == "string" ? S : h.services.languageUtils.getBestMatchFromCodes(S);
        A && (h.language || m(A), h.translator.language || h.translator.changeLanguage(A), h.services.languageDetector && h.services.languageDetector.cacheUserLanguage && h.services.languageDetector.cacheUserLanguage(A)), h.loadResources(A, function(L) {
          v(L, A);
        });
      };
      return !i && this.services.languageDetector && !this.services.languageDetector.async ? E(this.services.languageDetector.detect()) : !i && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(E) : this.services.languageDetector.detect(E) : E(i), s;
    }
  }, {
    key: "getFixedT",
    value: function(i, l, h) {
      var s = this, m = function v(E, T) {
        var S;
        if (Ra(T) !== "object") {
          for (var A = arguments.length, L = new Array(A > 2 ? A - 2 : 0), B = 2; B < A; B++)
            L[B - 2] = arguments[B];
          S = s.options.overloadTranslationOptionHandler([E, T].concat(L));
        } else
          S = Xa({}, T);
        S.lng = S.lng || v.lng, S.lngs = S.lngs || v.lngs, S.ns = S.ns || v.ns, S.keyPrefix = S.keyPrefix || h || v.keyPrefix;
        var j = s.options.keySeparator || ".", q;
        return S.keyPrefix && Array.isArray(E) ? q = E.map(function(H) {
          return "".concat(S.keyPrefix).concat(j).concat(H);
        }) : q = S.keyPrefix ? "".concat(S.keyPrefix).concat(j).concat(E) : E, s.t(q, S);
      };
      return typeof i == "string" ? m.lng = i : m.lngs = i, m.ns = l, m.keyPrefix = h, m;
    }
  }, {
    key: "t",
    value: function() {
      var i;
      return this.translator && (i = this.translator).translate.apply(i, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var i;
      return this.translator && (i = this.translator).exists.apply(i, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(i) {
      this.options.defaultNS = i;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(i) {
      var l = this, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var s = this.resolvedLanguage || this.languages[0], m = this.options ? this.options.fallbackLng : !1, v = this.languages[this.languages.length - 1];
      if (s.toLowerCase() === "cimode")
        return !0;
      var E = function(A, L) {
        var B = l.services.backendConnector.state["".concat(A, "|").concat(L)];
        return B === -1 || B === 2;
      };
      if (h.precheck) {
        var T = h.precheck(this, E);
        if (T !== void 0)
          return T;
      }
      return !!(this.hasResourceBundle(s, i) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || E(s, i) && (!m || E(v, i)));
    }
  }, {
    key: "loadNamespaces",
    value: function(i, l) {
      var h = this, s = Yf();
      return this.options.ns ? (typeof i == "string" && (i = [i]), i.forEach(function(m) {
        h.options.ns.indexOf(m) < 0 && h.options.ns.push(m);
      }), this.loadResources(function(m) {
        s.resolve(), l && l(m);
      }), s) : (l && l(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(i, l) {
      var h = Yf();
      typeof i == "string" && (i = [i]);
      var s = this.options.preload || [], m = i.filter(function(v) {
        return s.indexOf(v) < 0;
      });
      return m.length ? (this.options.preload = s.concat(m), this.loadResources(function(v) {
        h.resolve(), l && l(v);
      }), h) : (l && l(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(i) {
      if (i || (i = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !i)
        return "rtl";
      var l = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], h = this.services && this.services.languageUtils || new jE(HE());
      return l.indexOf(h.getLanguagePartFromCode(i)) > -1 || i.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var i = this, l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : jm, s = Xa(Xa(Xa({}, this.options), l), {
        isClone: !0
      }), m = new r(s);
      (l.debug !== void 0 || l.prefix !== void 0) && (m.logger = m.logger.clone(l));
      var v = ["store", "services", "language"];
      return v.forEach(function(E) {
        m[E] = i[E];
      }), m.services = Xa({}, this.services), m.services.utils = {
        hasLoadedNamespace: m.hasLoadedNamespace.bind(m)
      }, m.translator = new VE(m.services, m.options), m.translator.on("*", function(E) {
        for (var T = arguments.length, S = new Array(T > 1 ? T - 1 : 0), A = 1; A < T; A++)
          S[A - 1] = arguments[A];
        m.emit.apply(m, [E].concat(S));
      }), m.init(s, h), m.translator.options = m.options, m.translator.backendConnector.services.utils = {
        hasLoadedNamespace: m.hasLoadedNamespace.bind(m)
      }, m;
    }
  }, {
    key: "toJSON",
    value: function() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]), r;
}(Xl);
Yl(ty, "createInstance", function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0;
  return new ty(t, e);
});
var ri = ty.createInstance();
ri.createInstance = ty.createInstance;
ri.createInstance;
ri.dir;
ri.init;
ri.loadResources;
ri.reloadResources;
ri.use;
ri.changeLanguage;
ri.getFixedT;
ri.t;
ri.exists;
ri.setDefaultNamespace;
ri.hasLoadedNamespace;
ri.loadNamespaces;
ri.loadLanguages;
const Co = du(
  "config",
  () => {
    const t = yi(), e = Kr("main"), r = un(() => {
      var s;
      return (s = t.value) == null ? void 0 : s.themes;
    }), n = un(
      () => {
        var s;
        return (s = r.value) == null ? void 0 : s.find((m) => m.name === e.value);
      }
    ), i = un(() => {
      var s;
      return ((s = t.value) == null ? void 0 : s.background_layers) || [];
    });
    function l(s) {
      t.value = s;
    }
    function h(s) {
      e.value = s;
    }
    return {
      config: t,
      themes: r,
      themeName: e,
      theme: n,
      bgLayers: i,
      setTheme: h,
      setThemes: l
    };
  },
  {}
);
function $l() {
  function t(h, s) {
    return r(h, void 0, s);
  }
  function e(h, s) {
    return r(void 0, h, s);
  }
  function r(h, s, m) {
    const { theme: v } = Co();
    if (m = m || v, h && (m == null ? void 0 : m.id) === h || s && (m == null ? void 0 : m.name) === s)
      return m;
    if (m != null && m.children)
      for (const E of m.children) {
        const T = r(h, s, E);
        if (T)
          return T;
      }
  }
  function n(h) {
    const { bgLayers: s } = Co();
    return s.find((m) => m.id === h);
  }
  function i(h) {
    const { bgLayers: s } = Co();
    return s.find((m) => m.name === h);
  }
  function l(h) {
    const { setTheme: s } = Co();
    s(h);
  }
  return {
    findById: t,
    findByName: e,
    findBgLayerById: n,
    findBgLayerByName: i,
    setTheme: l
  };
}
const JE = $l();
function zd() {
  function t(i, l) {
    try {
      return JSON.parse(i).concat(JSON.parse(l)).sort((s, m) => s - m).some(
        (s, m, v) => m && s === v[m - 1]
      );
    } catch {
      return !1;
    }
  }
  function e(i) {
    var l, h;
    return i.opacity = i.previousOpacity = (h = (l = i.metadata) == null ? void 0 : l.start_opacity) != null ? h : 1, i;
  }
  function r(i) {
    var s;
    if (!((s = i.metadata) != null && s.exclusion))
      return;
    const l = Ai(), h = l.layers.filter(
      (m) => {
        var v, E;
        return t(
          (v = i == null ? void 0 : i.metadata) == null ? void 0 : v.exclusion,
          (E = m == null ? void 0 : m.metadata) == null ? void 0 : E.exclusion
        );
      }
    );
    h.length > 0 && (l.removeLayers(...h.map((m) => m.id)), alert(
      ri.t(
        "The layer <b>{{layersToRemove}}</b> has been removed because it cannot be displayed while the layer <b>{{layer}}</b> is displayed",
        {
          count: h.length,
          layersToRemove: h.map((m) => ri.t(m.name, { ns: "client" })).join(", "),
          layer: ri.t(i.name, { ns: "client" }),
          ns: "client"
        }
      )
    ));
  }
  function n(i, l = !0) {
    var v;
    const h = Co(), s = Ai(), m = JE.findById(i, h.theme);
    if (m) {
      const E = ((v = m.metadata) == null ? void 0 : v.linked_layers) || [];
      l === !1 ? s.removeLayers(m.id, ...E) : (r(m), s.addLayers(
        e(m),
        ...E.map(
          (T) => e(
            JE.findById(parseInt(T, 10))
          )
        )
      ));
    }
  }
  return {
    initLayer: e,
    handleExclusionLayers: r,
    toggleLayer: n
  };
}
const i$ = "fr", o$ = !0, a$ = !1, s$ = !1, di = du(
  "app",
  () => {
    const t = Kr(i$), e = Kr(o$), r = Kr(a$), n = Kr(s$), i = Kr(), l = Kr(), h = Kr(!1);
    function s(B) {
      t.value = B;
    }
    function m(B) {
      e.value = B, B || (n.value = !1, r.value = !1);
    }
    function v(B) {
      r.value = B, B && (n.value = !1);
    }
    function E(B) {
      n.value = B;
    }
    function T(B) {
      l.value = B;
    }
    function S(B) {
      i.value = B;
    }
    function A() {
      h.value = !0;
    }
    function L() {
      h.value = !1;
    }
    return {
      lang: t,
      layersOpen: e,
      myLayersTabOpen: r,
      themeGridOpen: n,
      mapId: i,
      styleEditorOpen: h,
      remoteLayersOpen: l,
      setLang: s,
      setLayersOpen: m,
      setMyLayersTabOpen: v,
      setThemeGridOpen: E,
      setRemoteLayersOpen: T,
      setMapId: S,
      openStyleEditorPanel: A,
      closeStyleEditorPanel: L
    };
  },
  {}
), ry = {
  name: "blank",
  id: 0
};
function YM() {
  const t = di(), { mapId: e } = mn(t), r = $l(), n = Ai(), i = zd(), l = un(() => {
    var T;
    if (!e.value) {
      const S = (T = Co().theme) == null ? void 0 : T.name;
      if (S)
        return Pa().bg_layer_theme_defaults[S] || m();
    }
    return m();
  });
  function h(T) {
    const S = r.findBgLayerById(T);
    s(S || null);
  }
  function s(T) {
    if (T) {
      if (T.type === "WMTS" || T.type === "BG WMTS")
        T.type = "BG WMTS";
      else if (T.type === "BG MVT")
        console.log(`passed through MVT layer ${T.name}`);
      else
        throw new Error(
          `Only WMTS and MVT BG layers are currently implemented (not ${T.type} for ${T.name})`
        );
      i.handleExclusionLayers(T), n.setBgLayer(i.initLayer(T));
    } else
      n.setBgLayer(null);
  }
  function m() {
    var T;
    return ((T = E().find((S) => S.is_default)) == null ? void 0 : T.id) || ry.id;
  }
  function v() {
    return ry.id;
  }
  function E() {
    return Pa().bg_layers;
  }
  return {
    setBgLayer: h,
    setMapBackground: s,
    getBgLayersFromConfig: E,
    getNullId: v,
    getDefaultSelectedId: m,
    defaultSelectedBgId: l
  };
}
const l$ = ["title"], c$ = /* @__PURE__ */ vr({
  __name: "background-selector-item",
  props: {
    bgTitle: {
      type: String,
      default: ""
    },
    bgName: {
      type: String,
      default: ""
    }
  },
  setup(t) {
    const e = t, { t: r } = Hn(), n = un(() => {
      const l = r(e.bgTitle), h = e.bgTitle.length > 0, s = `${r("Background layer:")} ${r(e.bgName)}`;
      return `${l}${h ? " - " : ""}${s}`;
    }), i = un(
      () => `h-full w-full rounded-sm lux-bg-sel-icon
        lux-bg-sel-${e.bgName}
        bg-${e.bgName}_sm
        md:bg-${e.bgName}
        hd:bg-${e.bgName}_sm_hi
        hd_md:bg-${e.bgName}_hi`
    );
    return (l, h) => (tt(), vt("button", {
      title: _e(n),
      class: Or(_e(i))
    }, null, 10, l$));
  }
}), QE = /* @__PURE__ */ Mr(c$, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/background-selector/background-selector-item.vue"]]), u$ = { class: "flex flex-row-reverse" }, h$ = /* @__PURE__ */ vr({
  __name: "background-selector",
  props: {
    isOpen: {
      type: Boolean,
      default: !1
    }
  },
  setup(t) {
    const e = t, { t: r } = Hn(), n = YM(), i = Ai(), l = Co(), { bgLayer: h } = mn(i), s = Kr(e.isOpen), m = Kr([]), v = un(
      () => {
        var A, L;
        return (L = (A = h.value) == null ? void 0 : A.id) != null ? L : n.getNullId();
      }
    ), E = un(
      () => {
        var A, L;
        return (L = (A = m.value) == null ? void 0 : A.find((B) => B.id === v.value)) == null ? void 0 : L.name;
      }
    );
    An(
      () => l.bgLayers,
      (A) => {
        m.value = Pa().bg_layers.map(
          (L) => Object.assign(
            {
              id: L.id
            },
            A.find((B) => L.id === B.id),
            {
              name: L.icon_id
            }
          )
        );
      },
      { immediate: !0 }
    ), An(
      () => i.bgLayer,
      (A, L) => {
        const B = i.layers;
        L === void 0 && A === null && (B == null ? void 0 : B.length) === 0 && (n.setBgLayer(n.defaultSelectedBgId.value), A === null && O2().addNotification(
          r(
            "Aucune couche n'\xE9tant d\xE9finie pour cette carte, une couche de fond a automatiquement \xE9t\xE9 ajout\xE9e.",
            { ns: "client" }
          )
        ));
      }
    );
    function T(A) {
      n.setBgLayer(A.id), s.value = !1;
    }
    function S() {
      s.value = !s.value;
    }
    return (A, L) => (tt(), vt("div", u$, [
      $e("div", {
        class: Or(["lux-bg-sel border border-black", s.value === !0 ? "hidden" : "block"])
      }, [
        $t(QE, {
          "aria-expanded": s.value,
          "bg-title": "Select BG layer",
          "bg-name": _e(E),
          onClick: S
        }, null, 8, ["aria-expanded", "bg-name"])
      ], 2),
      $e("div", {
        class: Or(s.value === !0 ? "flex flex-col md:flex-row" : "hidden")
      }, [
        (tt(!0), vt(pn, null, ka(m.value, (B) => (tt(), vt("div", {
          key: B.id,
          class: Or([
            "lux-bg-sel hover:bg-cyan-600",
            B.id === _e(v) ? "border-red-500 border-2" : "border-black border"
          ])
        }, [
          $t(QE, {
            "bg-name": B.name,
            onClick: (j) => T(B)
          }, null, 8, ["bg-name", "onClick"])
        ], 2))), 128))
      ], 2)
    ]));
  }
}), f$ = /* @__PURE__ */ Mr(h$, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/background-selector/background-selector.vue"]]), d$ = /* @__PURE__ */ $e("div", { class: "fixed inset-0 bg-gray-900 opacity-40 z-[1050]" }, null, -1), p$ = { class: "bg-white shadow-modal rounded-lg overflow-hidden w-[700px]" }, m$ = { class: "relative flex flex-row justify-center p-4 border-b-[1px]" }, g$ = { class: "text-xl" }, y$ = /* @__PURE__ */ $e("span", { "aria-hidden": "true" }, "\xD7", -1), _$ = [
  y$
], v$ = {
  key: 0,
  class: "p-[15px] border-t-[1px]"
}, x$ = { class: "flex flex-row justify-end" }, b$ = /* @__PURE__ */ vr({
  __name: "modal-dialog",
  props: {
    footer: {
      type: Boolean,
      default: !0
    },
    maxHeight: {
      type: Boolean,
      default: !1
    },
    title: String
  },
  emits: ["close"],
  setup(t) {
    const { t: e } = Hn(), r = Kr();
    aa(() => {
      r.value.focus();
    });
    const n = yi(!0);
    function i() {
      n.value = !1;
    }
    return (l, h) => (tt(), Un(SS, { to: "body" }, [
      Tt(" backdrop "),
      d$,
      Tt(" modal "),
      $t(Py, {
        appear: "",
        "enter-active-class": "duration-200 ease-out",
        "enter-from-class": "transform opacity-0 -translate-y-60",
        "enter-to-class": "opacity-100 translate-y-0",
        "leave-active-class": "duration-200 ease-in",
        "leave-from-class": "opacity-100 translate-y-0",
        "leave-to-class": "transform opacity-0 -translate-y-60",
        onAfterLeave: h[3] || (h[3] = (s) => l.$emit("close"))
      }, {
        default: jd(() => [
          _e(n) ? (tt(), vt("div", {
            key: 0,
            role: "dialog",
            ref_key: "modal",
            ref: r,
            tabindex: "0",
            onKeydown: h[2] || (h[2] = ih((s) => i(), ["esc"])),
            class: "fixed inset-x-0 inset-y-8 flex items-start justify-center z-[1100] outline-none"
          }, [
            $e("div", p$, [
              Tt(" header (title)"),
              $e("div", m$, [
                $e("h4", g$, Vt(t.title), 1),
                $e("button", {
                  type: "button",
                  class: "absolute right-2 top-1 text-slate-400 text-[24px]",
                  "data-dismiss": "modal",
                  "aria-label": "Close",
                  onClick: h[0] || (h[0] = (s) => i())
                }, _$)
              ]),
              Tt(" content slot "),
              $e("div", {
                class: Or(["p-[15px] overflow-y-auto", t.maxHeight ? "max-h-96" : "max-h-full"])
              }, [
                bO(l.$slots, "content")
              ], 2),
              Tt(" footer (optional)"),
              t.footer ? (tt(), vt("div", v$, [
                $e("div", x$, [
                  $e("button", {
                    type: "button",
                    class: "lux-btn",
                    "data-dismiss": "modal",
                    onClick: h[1] || (h[1] = (s) => i())
                  }, Vt(_e(e)("Close", { ns: "client" })), 1)
                ])
              ])) : Tt("v-if", !0)
            ])
          ], 544)) : Tt("v-if", !0)
        ]),
        _: 3
      })
    ]));
  }
}), JM = /* @__PURE__ */ Mr(b$, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/modal-dialog.vue"]]), Vx = du(
  "metadata",
  () => {
    const t = Kr();
    function e(n) {
      t.value = n;
    }
    function r() {
      t.value = void 0;
    }
    return {
      metadataId: t,
      setMetadataId: e,
      clearMetadataId: r
    };
  },
  {}
), w$ = {
  class: "mb-px",
  key: "node.id"
}, E$ = ["aria-expanded", "data-cy"], T$ = { class: "leading-6" }, S$ = ["aria-expanded", "data-cy"], M$ = { class: "grow" }, C$ = { class: "leading-6" }, I$ = {
  key: 1,
  class: "flex text-tertiary pr-2"
}, P$ = ["data-cy"], A$ = { class: "ml-1 hover:underline" }, O$ = /* @__PURE__ */ vr({
  __name: "layer-tree-node",
  props: {
    node: { type: null, required: !0 }
  },
  emits: ["toggleLayer", "toggleParent"],
  setup(t, { emit: e }) {
    const r = t, { t: n } = Hn(), { setMetadataId: i } = Vx(), l = !!r.node.children, h = r.node.depth === 0, s = r.node.depth >= 10, m = un(() => n(r.node.name, { ns: "client" }));
    function v(T) {
      e("toggleLayer", T);
    }
    function E(T) {
      e("toggleParent", T);
    }
    return (T, S) => {
      const A = _O("layer-tree-node", !0);
      return l ? (tt(), vt("div", w$, [
        Tt("    First level parents"),
        t.node.depth === 1 ? (tt(), vt("button", {
          key: 0,
          class: "group node-1 w-full text-left flex px-2 py-1.5 uppercase bg-tertiary",
          "aria-expanded": t.node.expanded,
          onClick: S[0] || (S[0] = (L) => E(t.node)),
          "data-cy": `parentLayerLabel-${t.node.id}`
        }, [
          $e("div", {
            class: Or(["grow", t.node.expanded ? "text-white" : "text-secondary"])
          }, Vt(_e(m)), 3),
          $e("div", T$, [
            $e("div", {
              class: Or(["fa fa-sharp fa-solid group-hover:text-white text-primary", t.node.expanded ? "fa-caret-up" : "fa-caret-down"])
            }, null, 2)
          ])
        ], 8, E$)) : t.node.depth > 1 && !s ? (tt(), vt(pn, { key: 1 }, [
          Tt("    Other parents"),
          $e("button", {
            class: Or(["w-full text-left flex px-2 py-1.5 pl-2", t.node.expanded ? "text-tertiary" : "bg-white text-primary"]),
            "aria-expanded": t.node.expanded,
            onClick: S[1] || (S[1] = (L) => E(t.node)),
            "data-cy": `parentLayerLabel-${t.node.id}`
          }, [
            $e("div", M$, Vt(_e(m)), 1),
            $e("div", C$, [
              $e("div", {
                class: Or(["fa-sharp fa-solid", t.node.expanded ? "fa-minus" : "fa-plus"])
              }, null, 2)
            ])
          ], 10, S$)
        ], 2112)) : Tt("v-if", !0),
        Tt("    Children"),
        s ? Tt("v-if", !0) : (tt(), vt("div", {
          key: 2,
          class: Or(["bg-secondary", [
            { "pl-2": t.node.depth > 1 },
            { "lux-collapse": !h },
            { expanded: !h && t.node.expanded }
          ]])
        }, [
          (tt(!0), vt(pn, null, ka(t.node.children, (L) => (tt(), Un(A, {
            key: L.id,
            node: L,
            onToggleParent: S[2] || (S[2] = (B) => E(B)),
            onToggleLayer: S[3] || (S[3] = (B) => v(B))
          }, null, 8, ["node"]))), 128))
        ], 2))
      ])) : (tt(), vt("div", I$, [
        $e("button", {
          class: "self-start before:text-[.85rem] before:transform before:translate-y-[.1rem] before:inline-block before:content-['\\f129'] fa-solid fa-fw fa-fh fa-info",
          onClick: S[4] || (S[4] = (L) => _e(i)(t.node.id))
        }),
        $e("button", {
          class: Or(["w-full text-left", { "font-bold": t.node.checked }]),
          onClick: S[5] || (S[5] = (L) => v(t.node)),
          "data-cy": `layerLabel-${t.node.id}`
        }, [
          $e("i", {
            class: Or(["fa-solid", t.node.checked ? "fa-check-square" : "fa-square"])
          }, null, 2),
          $e("span", A$, Vt(_e(m)), 1)
        ], 10, P$)
      ]));
    };
  }
}), QM = /* @__PURE__ */ Mr(O$, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-tree/layer-tree-node.vue"]]);
class R$ {
  toggleNode(e, r, n) {
    var i;
    return (r == null ? void 0 : r.id) === e ? {
      ...r,
      [n]: !r[n]
    } : {
      ...r,
      children: (i = r.children) == null ? void 0 : i.map(
        (l) => this.toggleNode(e, l, n)
      )
    };
  }
  updateLayers(e, r) {
    const { id: n } = e;
    if (e.children)
      return {
        ...e,
        children: e.children.map((i) => this.updateLayers(i, r))
      };
    {
      const i = !!(r != null && r.find((l) => l.id === n));
      return {
        ...e,
        checked: i
      };
    }
  }
}
const _d = new R$();
var eC = /* @__PURE__ */ ((t) => (t.PNG = "image/png", t.JPG = "image/jpeg", t))(eC || {}), ia = /* @__PURE__ */ ((t) => (t.WMS = "WMS", t.WMTS = "WMTS", t))(ia || {});
class Iv {
  constructor(e, r = 0, n = !1) {
    this.message = e, this.httpStatus = r, this.isCrossOriginRelated = n;
  }
}
let L$ = 0;
function D$() {
  return L$++;
}
function k$(t, e, r) {
  return new Promise((n, i) => {
    const l = D$(), h = {
      requestId: l,
      taskName: t,
      params: r
    };
    e === null ? window.dispatchEvent(
      new CustomEvent("ogc-client.request", {
        detail: h
      })
    ) : e.postMessage(h);
    const s = ({ detail: m, data: v }) => {
      const E = m || v;
      E.requestId === l && (e === null ? window.removeEventListener("message", s) : e.removeEventListener("message", s), "error" in E ? i(E.error) : n(E.response));
    };
    e === null ? window.addEventListener("ogc-client.response", s) : e.addEventListener("message", s);
  });
}
function jx(t, e, r) {
  const n = typeof WorkerGlobalScope < "u", i = async ({ detail: l, data: h }) => {
    const s = l || h;
    if (s.taskName === t) {
      let m, v;
      try {
        m = await r(s.params);
      } catch (T) {
        v = T;
      }
      const E = {
        taskName: t,
        requestId: s.requestId,
        ...m && { response: m },
        ...v && { error: v }
      };
      n ? e.postMessage(E) : e.dispatchEvent(
        new CustomEvent("ogc-client.response", {
          detail: E
        })
      );
    }
  };
  n ? e.addEventListener("message", i) : e.addEventListener("ogc-client.request", i);
}
let Pv;
function N$() {
  return Pv || (Pv = new Worker(URL.createObjectURL(new Blob([`function t(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function e(t,e,r,n,o,i,a){try{var c=t[i](a),u=c.value}catch(t){return void r(t)}c.done?e(u):Promise.resolve(u).then(n,o)}function r(t){return function(){var r=this,n=arguments;return new Promise((function(o,i){var a=t.apply(r,n);function c(t){e(a,o,i,c,u,"next",t)}function u(t){e(a,o,i,c,u,"throw",t)}c(void 0)}))}}function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}var o={exports:{}};!function(t){var e=function(t){var e,r=Object.prototype,o=r.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function s(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{s({},"")}catch(t){s=function(t,e,r){return t[e]=r}}function f(t,e,r,n){var o=e&&e.prototype instanceof m?e:m,i=Object.create(o.prototype),a=new j(n||[]);return i._invoke=function(t,e,r){var n=h;return function(o,i){if(n===v)throw new Error("Generator is already running");if(n===d){if("throw"===o)throw i;return G()}for(r.method=o,r.arg=i;;){var a=r.delegate;if(a){var c=k(a,r);if(c){if(c===y)continue;return c}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===h)throw n=d,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=v;var u=l(t,e,r);if("normal"===u.type){if(n=r.done?d:p,u.arg===y)continue;return{value:u.arg,done:r.done}}"throw"===u.type&&(n=d,r.method="throw",r.arg=u.arg)}}}(t,r,a),i}function l(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=f;var h="suspendedStart",p="suspendedYield",v="executing",d="completed",y={};function m(){}function g(){}function b(){}var S={};S[a]=function(){return this};var E=Object.getPrototypeOf,w=E&&E(E(C([])));w&&w!==r&&o.call(w,a)&&(S=w);var O=b.prototype=m.prototype=Object.create(S);function x(t){["next","throw","return"].forEach((function(e){s(t,e,(function(t){return this._invoke(e,t)}))}))}function P(t,e){function r(i,a,c,u){var s=l(t[i],t,a);if("throw"!==s.type){var f=s.arg,h=f.value;return h&&"object"===n(h)&&o.call(h,"__await")?e.resolve(h.__await).then((function(t){r("next",t,c,u)}),(function(t){r("throw",t,c,u)})):e.resolve(h).then((function(t){f.value=t,c(f)}),(function(t){return r("throw",t,c,u)}))}u(s.arg)}var i;this._invoke=function(t,n){function o(){return new e((function(e,o){r(t,n,e,o)}))}return i=i?i.then(o,o):o()}}function k(t,r){var n=t.iterator[r.method];if(n===e){if(r.delegate=null,"throw"===r.method){if(t.iterator.return&&(r.method="return",r.arg=e,k(t,r),"throw"===r.method))return y;r.method="throw",r.arg=new TypeError("The iterator does not provide a 'throw' method")}return y}var o=l(n,t.iterator,r.arg);if("throw"===o.type)return r.method="throw",r.arg=o.arg,r.delegate=null,y;var i=o.arg;return i?i.done?(r[t.resultName]=i.value,r.next=t.nextLoc,"return"!==r.method&&(r.method="next",r.arg=e),r.delegate=null,y):i:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function R(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function T(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function j(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(R,this),this.reset(!0)}function C(t){if(t){var r=t[a];if(r)return r.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,i=function r(){for(;++n<t.length;)if(o.call(t,n))return r.value=t[n],r.done=!1,r;return r.value=e,r.done=!0,r};return i.next=i}}return{next:G}}function G(){return{value:e,done:!0}}return g.prototype=O.constructor=b,b.constructor=g,g.displayName=s(b,u,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===g||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,b):(t.__proto__=b,s(t,u,"GeneratorFunction")),t.prototype=Object.create(O),t},t.awrap=function(t){return{__await:t}},x(P.prototype),P.prototype[c]=function(){return this},t.AsyncIterator=P,t.async=function(e,r,n,o,i){void 0===i&&(i=Promise);var a=new P(f(e,r,n,o),i);return t.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},x(O),s(O,u,"Generator"),O[a]=function(){return this},O.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=C,j.prototype={constructor:j,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(T),!t)for(var r in this)"t"===r.charAt(0)&&o.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=e)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var r=this;function n(n,o){return c.type="throw",c.arg=t,r.next=n,o&&(r.method="next",r.arg=e),!!o}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],c=a.completion;if("root"===a.tryLoc)return n("end");if(a.tryLoc<=this.prev){var u=o.call(a,"catchLoc"),s=o.call(a,"finallyLoc");if(u&&s){if(this.prev<a.catchLoc)return n(a.catchLoc,!0);if(this.prev<a.finallyLoc)return n(a.finallyLoc)}else if(u){if(this.prev<a.catchLoc)return n(a.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return n(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&o.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var i=n;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),T(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;T(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,r,n){return this.delegate={iterator:C(t),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=e),y}},t}(t.exports);try{regeneratorRuntime=e}catch(t){Function("r","regeneratorRuntime = r")(e)}}(o);var i=o.exports;function a(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?a(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(t,e,n){var o="undefined"!=typeof WorkerGlobalScope,a=function(){var a=r(i.mark((function r(a){var u,s,f,l,h,p;return i.wrap((function(r){for(;;)switch(r.prev=r.next){case 0:if(u=a.detail,s=a.data,(f=u||s).taskName!==t){r.next=14;break}return r.prev=3,r.next=6,n(f.params);case 6:l=r.sent,r.next=12;break;case 9:r.prev=9,r.t0=r.catch(3),h=r.t0;case 12:p=c(c({taskName:t,requestId:f.requestId},l&&{response:l}),h&&{error:h}),o?e.postMessage(p):e.dispatchEvent(new CustomEvent("ogc-client.response",{detail:p}));case 14:case"end":return r.stop()}}),r,null,[[3,9]])})));return function(t){return a.apply(this,arguments)}}();o?e.addEventListener("message",a):e.addEventListener("ogc-client.request",a)}function s(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function f(t){return function(t){if(Array.isArray(t))return s(t)}(t)||function(t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||function(t,e){if(t){if("string"==typeof t)return s(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?s(t,e):void 0}}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function l(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function h(t,e){return h=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},h(t,e)}function p(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&h(t,e)}function v(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function d(t){return d=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},d(t)}function y(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function m(t,e,r){return m=y()?Reflect.construct:function(t,e,r){var n=[null];n.push.apply(n,e);var o=new(Function.bind.apply(t,n));return r&&h(o,r.prototype),o},m.apply(null,arguments)}function g(t){var e="function"==typeof Map?new Map:void 0;return g=function(t){if(null===t||(r=t,-1===Function.toString.call(r).indexOf("[native code]")))return t;var r;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,n)}function n(){return m(t,arguments,d(this).constructor)}return n.prototype=Object.create(t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),h(n,t)},g(t)}function b(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function S(t,e,r){return e&&b(t.prototype,e),r&&b(t,r),t}var E=function(){function t(e){l(this,t),this.chars=f(e),this.charCount=this.chars.length,this.charIndex=0,this.charsToBytes=new Array(this.charCount),this.multiByteMode=!1,this.string=e;var r=this.chars,n=this.charCount,o=this.charsToBytes;if(n===e.length)for(var i=0;i<n;++i)o[i]=i;else{for(var a=0,c=0;c<n;++c)o[c]=a,a+=r[c].length;this.multiByteMode=!0}}return S(t,[{key:"isEnd",get:function(){return this.charIndex>=this.charCount}},{key:"_charLength",value:function(t){var e=t.length;return e<2||!this.multiByteMode?e:t.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,"_").length}},{key:"advance",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.charIndex=Math.min(this.charCount,this.charIndex+t)}},{key:"consume",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=this.peek(t);return this.advance(t),e}},{key:"consumeMatch",value:function(t){if(!t.sticky)throw new Error('\`regex\` must have a sticky flag ("y")');t.lastIndex=this.charsToBytes[this.charIndex];var e=t.exec(this.string);if(null===e)return"";var r=e[0];return this.advance(this._charLength(r)),r}},{key:"consumeMatchFn",value:function(t){for(var e=this.charIndex;!this.isEnd&&t(this.peek());)this.advance();return this.charIndex>e?this.string.slice(this.charsToBytes[e],this.charsToBytes[this.charIndex]):""}},{key:"consumeString",value:function(t){if(this.consumeStringFast(t))return t;if(!this.multiByteMode)return"";var e=t.length,r=this._charLength(t);return r!==e&&t===this.peek(r)?(this.advance(r),t):""}},{key:"consumeStringFast",value:function(t){if(this.peek()===t[0]){var e=t.length;if(1===e)return this.advance(),t;if(this.peek(e)===t)return this.advance(e),t}return""}},{key:"consumeUntilMatch",value:function(t){if(!t.global)throw new Error('\`regex\` must have a global flag ("g")');var e=this.charsToBytes[this.charIndex];t.lastIndex=e;var r=t.exec(this.string);if(null===r||r.index===e)return"";var n=this.string.slice(e,r.index);return this.advance(this._charLength(n)),n}},{key:"consumeUntilString",value:function(t){var e=this.charIndex,r=this.charsToBytes,n=this.string,o=r[e],i=n.indexOf(t,o);if(i<=0)return"";var a=n.slice(o,i);return this.advance(this._charLength(a)),a}},{key:"peek",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;if(this.charIndex>=this.charCount)return"";if(1===t)return this.chars[this.charIndex];var e=this.charsToBytes,r=this.charIndex;return this.string.slice(e[r],e[r+t])}},{key:"reset",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;this.charIndex=t>=0?Math.min(this.charCount,t):Math.max(0,this.charIndex+t)}}]),t}(),w=E,O={},x=Object.freeze(Object.assign(Object.create(null),{amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}));function P(t){if(k(t))return!0;var e=T(t);return 45===e||46===e||e>=48&&e<=57||183===e||e>=768&&e<=879||e>=8255&&e<=8256}function k(t){var e=T(t);return 58===e||95===e||e>=65&&e<=90||e>=97&&e<=122||e>=192&&e<=214||e>=216&&e<=246||e>=248&&e<=767||e>=880&&e<=893||e>=895&&e<=8191||e>=8204&&e<=8205||e>=8304&&e<=8591||e>=11264&&e<=12271||e>=12289&&e<=55295||e>=63744&&e<=64975||e>=65008&&e<=65533||e>=65536&&e<=983039}function R(t){var e=T(t);return 9===e||10===e||13===e||e>=32&&e<=55295||e>=57344&&e<=65533||e>=65536&&e<=1114111}function T(t){return t.codePointAt(0)||-1}O.predefinedEntities=x,O.isNameChar=P,O.isNameStartChar=k,O.isNotXmlChar=function(t){return!R(t)},O.isReferenceChar=function(t){return"#"===t||P(t)},O.isWhitespace=function(t){var e=T(t);return 32===e||9===e||10===e||13===e},O.isXmlChar=R;var j=function(){function t(){l(this,t),this.parent=null}return S(t,[{key:"document",get:function(){return this.parent?this.parent.document:null}},{key:"isRootNode",get:function(){return!!this.parent&&this.parent===this.document}},{key:"preserveWhitespace",get:function(){return Boolean(this.parent&&this.parent.preserveWhitespace)}},{key:"type",get:function(){return""}},{key:"toJSON",value:function(){var t={type:this.type};return this.isRootNode&&(t.isRootNode=!0),this.preserveWhitespace&&(t.preserveWhitespace=!0),t}}]),t}();j.TYPE_CDATA="cdata",j.TYPE_COMMENT="comment",j.TYPE_DOCUMENT="document",j.TYPE_ELEMENT="element",j.TYPE_PROCESSING_INSTRUCTION="pi",j.TYPE_TEXT="text";var C=j;function G(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var N=C,A=function(t){p(r,N);var e=G(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).text=n,t}return S(r,[{key:"type",get:function(){return N.TYPE_TEXT}},{key:"toJSON",value:function(){return Object.assign(N.prototype.toJSON.call(this),{text:this.text})}}]),r}(),F=A;function I(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var L=C,M=F,B=function(t){p(r,M);var e=I(r);function r(){return l(this,r),e.apply(this,arguments)}return S(r,[{key:"type",get:function(){return L.TYPE_CDATA}}]),r}(),_=B;function U(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var D=C,W=function(t){p(r,D);var e=U(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).content=n,t}return S(r,[{key:"type",get:function(){return D.TYPE_COMMENT}},{key:"toJSON",value:function(){return Object.assign(D.prototype.toJSON.call(this),{content:this.content})}}]),r}(),X=W;function Y(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var q=C,J=function(t){p(r,q);var e=Y(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Object.create(null),i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return l(this,r),(n=e.call(this)).name=t,n.attributes=o,n.children=i,n}return S(r,[{key:"isEmpty",get:function(){return 0===this.children.length}},{key:"preserveWhitespace",get:function(){for(var t=this;t instanceof r;){if("xml:space"in t.attributes)return"preserve"===t.attributes["xml:space"];t=t.parent}return!1}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return q.TYPE_ELEMENT}},{key:"toJSON",value:function(){return Object.assign(q.prototype.toJSON.call(this),{name:this.name,attributes:this.attributes,children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),V=J;function $(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var K=V,z=C,H=function(t){p(r,z);var e=$(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return l(this,r),(t=e.call(this)).children=n,t}return S(r,[{key:"document",get:function(){return this}},{key:"root",get:function(){return this.children.find((function(t){return t instanceof K}))||null}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return z.TYPE_DOCUMENT}},{key:"toJSON",value:function(){return Object.assign(z.prototype.toJSON.call(this),{children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),Q=H;function Z(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var tt=C,et=function(t){p(r,tt);var e=Z(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return l(this,r),(n=e.call(this)).name=t,n.content=o,n}return S(r,[{key:"type",get:function(){return tt.TYPE_PROCESSING_INSTRUCTION}},{key:"toJSON",value:function(){return Object.assign(tt.prototype.toJSON.call(this),{name:this.name,content:this.content})}}]),r}(),rt=et;function nt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return ot(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return ot(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function ot(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var it=w,at=O,ct=_,ut=X,st=Q,ft=V,lt=rt,ht=F,pt=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(l(this,t),this.document=new st,this.currentNode=this.document,this.options=r,this.scanner=new it(vt(e)),this.consumeProlog(),this.consumeElement()||this.error("Root element is missing or invalid");this.consumeMisc(););this.scanner.isEnd||this.error("Extra content at the end of the document")}return S(t,[{key:"addNode",value:function(t){t.parent=this.currentNode,this.currentNode.children.push(t)}},{key:"addText",value:function(t){var e=this.currentNode.children;if(e.length>0){var r=e[e.length-1];if(r instanceof ht)return void(r.text+=t)}this.addNode(new ht(t))}},{key:"consumeAttributeValue",value:function(){var t,e=this.scanner,r=e.peek();if('"'!==r&&"'"!==r)return!1;e.advance();var n=!1,o="",i='"'===r?new RegExp('[^"&<]+',"y"):new RegExp("[^'&<]+","y");t:for(;!e.isEnd;){switch((t=e.consumeMatch(i))&&(this.validateChars(t),o+=t.replace(/[\\t\\r\\n]/g," ")),e.peek()){case r:n=!0;break t;case"&":o+=this.consumeReference();continue;case"<":this.error("Unescaped \`<\` is not allowed in an attribute value");break;case"":this.error("Unclosed attribute")}}return n||this.error("Unclosed attribute"),e.advance(),o}},{key:"consumeCdataSection",value:function(){var t=this.scanner;if(!t.consumeStringFast("<![CDATA["))return!1;var e=t.consumeUntilString("]]>");return this.validateChars(e),t.consumeStringFast("]]>")||this.error("Unclosed CDATA section"),this.options.preserveCdata?this.addNode(new ct(e)):this.addText(e),!0}},{key:"consumeCharData",value:function(){var t=this.scanner,e=t.consumeUntilMatch(/<|&|]]>/g);return!!e&&(this.validateChars(e),"]"===t.peek()&&"]]>"===t.peek(3)&&this.error("Element content may not contain the CDATA section close delimiter \`]]>\`"),this.addText(e),!0)}},{key:"consumeComment",value:function(){var t=this.scanner;if(!t.consumeStringFast("\\x3c!--"))return!1;var e=t.consumeUntilString("--");return this.validateChars(e),t.consumeStringFast("--\\x3e")||("--"===t.peek(2)?this.error("The string \`--\` isn't allowed inside a comment"):this.error("Unclosed comment")),this.options.preserveComments&&this.addNode(new ut(e.trim())),!0}},{key:"consumeContentReference",value:function(){var t=this.consumeReference();return!!t&&(this.addText(t),!0)}},{key:"consumeDoctypeDeclaration",value:function(){var t=this.scanner;return!(!t.consumeStringFast("<!DOCTYPE")||!this.consumeWhitespace())&&(t.consumeMatch(new RegExp("[^[>]+","y")),t.consumeMatch(new RegExp("\\\\[[\\\\s\\\\S]+?\\\\][\\\\x20\\\\t\\\\r\\\\n]*>","y"))||t.consumeStringFast(">")||this.error("Unclosed doctype declaration"),!0)}},{key:"consumeElement",value:function(){var t=this.scanner,e=t.charIndex;if("<"!==t.peek())return!1;t.advance();var r=this.consumeName();if(!r)return t.reset(e),!1;for(var n=Object.create(null);this.consumeWhitespace();){var o=this.consumeName();if(o){var i=this.consumeEqual()&&this.consumeAttributeValue();!1===i&&this.error("Attribute value expected"),o in n&&this.error("Duplicate attribute: ".concat(o)),"xml:space"===o&&"default"!==i&&"preserve"!==i&&this.error('Value of the \`xml:space\` attribute must be "default" or "preserve"'),n[o]=i}}if(this.options.sortAttributes){for(var a=Object.keys(n).sort(),c=Object.create(null),u=0;u<a.length;++u){var s=a[u];c[s]=n[s]}n=c}var f=Boolean(t.consumeStringFast("/>")),l=new ft(r,n);if(l.parent=this.currentNode,!f){for(t.consumeStringFast(">")||this.error("Unclosed start tag for element \`".concat(r,"\`")),this.currentNode=l,this.consumeCharData();this.consumeElement()||this.consumeContentReference()||this.consumeCdataSection()||this.consumeProcessingInstruction()||this.consumeComment();)this.consumeCharData();var h,p=t.charIndex;t.consumeStringFast("</")&&(h=this.consumeName())&&h===r||(t.reset(p),this.error("Missing end tag for element ".concat(r))),this.consumeWhitespace(),t.consumeStringFast(">")||this.error("Unclosed end tag for element ".concat(r)),this.currentNode=l.parent}return this.addNode(l),!0}},{key:"consumeEqual",value:function(){return this.consumeWhitespace(),!!this.scanner.consumeStringFast("=")&&(this.consumeWhitespace(),!0)}},{key:"consumeMisc",value:function(){return this.consumeComment()||this.consumeProcessingInstruction()||this.consumeWhitespace()}},{key:"consumeName",value:function(){return at.isNameStartChar(this.scanner.peek())?this.scanner.consumeMatchFn(at.isNameChar):""}},{key:"consumeProcessingInstruction",value:function(){var t=this.scanner,e=t.charIndex;if(!t.consumeStringFast("<?"))return!1;var r=this.consumeName();if(r?"xml"===r.toLowerCase()&&(t.reset(e),this.error("XML declaration isn't allowed here")):this.error("Invalid processing instruction"),!this.consumeWhitespace()){if(t.consumeStringFast("?>"))return this.addNode(new lt(r)),!0;this.error("Whitespace is required after a processing instruction name")}var n=t.consumeUntilString("?>");return this.validateChars(n),t.consumeStringFast("?>")||this.error("Unterminated processing instruction"),this.addNode(new lt(r,n)),!0}},{key:"consumeProlog",value:function(){var t=this.scanner,e=t.charIndex;for(this.consumeXmlDeclaration();this.consumeMisc(););if(this.consumeDoctypeDeclaration())for(;this.consumeMisc(););return e<t.charIndex}},{key:"consumeReference",value:function(){var t=this.scanner;if("&"!==t.peek())return!1;t.advance();var e,r=t.consumeMatchFn(at.isReferenceChar);if(";"!==t.consume()&&this.error("Unterminated reference (a reference must end with \`;\`)"),"#"===r[0]){var o="x"===r[1]?parseInt(r.slice(2),16):parseInt(r.slice(1),10);isNaN(o)&&this.error("Invalid character reference"),e=String.fromCodePoint(o),at.isXmlChar(e)||this.error("Character reference resolves to an invalid character")}else if(void 0===(e=at.predefinedEntities[r])){var i=this.options,a=i.ignoreUndefinedEntities,c=i.resolveUndefinedEntity,u="&".concat(r,";");if(c){var s=c(u);if(null!=s){var f=n(s);if("string"!==f)throw new TypeError("\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ".concat(f));return s}}if(a)return u;t.reset(-u.length),this.error("Named entity isn't defined: ".concat(u))}return e}},{key:"consumeSystemLiteral",value:function(){var t=this.scanner,e=t.consumeStringFast('"')||t.consumeStringFast("'");if(!e)return!1;var r=t.consumeUntilString(e);return this.validateChars(r),t.consumeStringFast(e)||this.error("Missing end quote"),r}},{key:"consumeWhitespace",value:function(){return Boolean(this.scanner.consumeMatchFn(at.isWhitespace))}},{key:"consumeXmlDeclaration",value:function(){var t=this.scanner;if(!t.consumeStringFast("<?xml"))return!1;this.consumeWhitespace()||this.error("Invalid XML declaration");var e=Boolean(t.consumeStringFast("version"))&&this.consumeEqual()&&this.consumeSystemLiteral();if(!1===e?this.error("XML version is missing or invalid"):/^1\\.[0-9]+$/.test(e)||this.error("Invalid character in version number"),this.consumeWhitespace()){Boolean(t.consumeStringFast("encoding"))&&this.consumeEqual()&&this.consumeSystemLiteral()&&this.consumeWhitespace();var r=Boolean(t.consumeStringFast("standalone"))&&this.consumeEqual()&&this.consumeSystemLiteral();r&&("yes"!==r&&"no"!==r&&this.error('Only "yes" and "no" are permitted as values of \`standalone\`'),this.consumeWhitespace())}return t.consumeStringFast("?>")||this.error("Invalid or unclosed XML declaration"),!0}},{key:"error",value:function(t){for(var e=this.scanner,r=e.charIndex,n=e.string,o=1,i="",a=1,c=0;c<r;++c){var u=n[c];"\\n"===u?(o=1,i="",a+=1):(o+=1,i+=u)}var s=n.indexOf("\\n",r),f=0;(i+=-1===s?n.slice(r):n.slice(r,s)).length>50&&(o<40?i=i.slice(0,50):(f=o-20,i=i.slice(f,o+30)));var l=new Error("".concat(t," (line ").concat(a,", column ").concat(o,")\\n")+"  ".concat(i,"\\n")+" ".repeat(o-f+1)+"^\\n");throw Object.assign(l,{column:o,excerpt:i,line:a,pos:r}),l}},{key:"validateChars",value:function(t){var e,r=0,n=nt(t);try{for(n.s();!(e=n.n()).done;){var o=e.value;at.isNotXmlChar(o)&&(this.scanner.reset(-(f(t).length-r)),this.error("Invalid character")),r+=1}}catch(t){n.e(t)}finally{n.f()}}}]),t}();function vt(t){return"\\ufeff"===t[0]&&(t=t.slice(1)),t.replace(/\\r\\n?/g,"\\n")}var dt=pt,yt=_,mt=X,gt=Q,bt=V,St=C,Et=rt,wt=F;function Ot(t,e){return new dt(t,e).document}Ot.XmlCdata=yt,Ot.XmlComment=mt,Ot.XmlDocument=gt,Ot.XmlElement=bt,Ot.XmlNode=St,Ot.XmlProcessingInstruction=Et,Ot.XmlText=wt;var xt=Ot;function Pt(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var kt=function(t){p(r,g(Error));var e=Pt(r);function r(t){return l(this,r),e.call(this,t)}return r}();function Rt(t){return t.children[0]}function Tt(t){var e=t.indexOf(":");return e>-1?t.substr(e+1):t}function jt(t){return t.name||""}function Ct(t,e,r){var n=Tt(e);return t&&Array.isArray(t.children)?t.children.reduce((function t(e,o){return Tt(jt(o))===n&&e.push(o),r&&Array.isArray(o.children)?[].concat(f(e),f(o.children.reduce(t,[]))):e}),[]):[]}function Gt(t,e,r){return Ct(t,e,r)[0]||null}function Nt(t){return t&&Array.isArray(t.children)?f(t.children.filter((function(t){return"XmlElement"===t.constructor.name}))):[]}function At(t){var e=t&&Array.isArray(t.children)?t.children.find((function(t){return"text"===t.type})):null;return e?e.text:""}function Ft(t,e){return t&&t.attributes[e]||""}var It=function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];l(this,t),this.message=e,this.httpStatus=r,this.isCrossOriginRelated=n};function Lt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Mt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Mt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Mt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Bt=["utf-8","utf-16","iso-8859-1"];function _t(t,e){var r,n=e?function(t){var e=/charset=([^;]+)/.exec(t);return e?e[1]:null}(e):null,o=Lt(n?[n].concat(Bt):Bt);try{for(o.s();!(r=o.n()).done;){var i=r.value;try{return new TextDecoder(i,{fatal:!0}).decode(t)}catch(t){}}}catch(t){o.e(t)}finally{o.f()}return console.warn("XML document encoding could not be determined, falling back to ".concat("utf-8",".")),new TextDecoder("utf-8").decode(t)}function Ut(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Dt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Dt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Dt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Wt=new Map;function Xt(t){return function(t){if(Wt.has(t))return Wt.get(t);var e=fetch(t);return e.finally((function(){return Wt.delete(t)})),Wt.set(t,e),e}(t).catch((function(){return fetch(t,{method:"HEAD",mode:"no-cors"}).catch((function(t){throw new It("Fetching the document failed either due to network errors or unreachable host, error is: ".concat(t.message),0,!1)})).then((function(){throw new It("The document could not be fetched due to CORS limitations",0,!0)}))})).then(function(){var t=r(i.mark((function t(e){var r,n,o;return i.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(e.ok){t.next=5;break}return t.next=3,e.text();case 3:throw r=t.sent,new It("Received an error with code ".concat(e.status,": ").concat(r),e.status,!1);case 5:return t.next=7,e.arrayBuffer();case 7:return n=t.sent,o=e.headers.get("Content-Type"),t.abrupt("return",_t(n,o));case 10:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}()).then((function(t){return function(t){var e=null;try{e=xt(t)}catch(t){throw new kt(t.message)}return e}(t)}))}function Yt(t,e){var r=t.match(/(https?%3A%2F%2F[^/]+)$/);if(r){var n=r[1],o=Yt(decodeURIComponent(n),e);return t.replace(n,encodeURIComponent(o))}var i,a=new URL(t),c=Object.keys(e),u=c.map((function(t){return t.toLowerCase()})),s=[],f=Ut(a.searchParams.keys());try{for(f.s();!(i=f.n()).done;){var l=i.value;u.indexOf(l.toLowerCase())>-1&&s.push(l)}}catch(t){f.e(t)}finally{f.f()}return s.map((function(t){return a.searchParams.delete(t)})),c.forEach((function(t){return a.searchParams.set(t,!0===e[t]?"":e[t])})),a.toString()}var qt=["EPSG:4046","EPSG:4075","EPSG:4120","EPSG:4122","EPSG:4124","EPSG:4126","EPSG:4149","EPSG:4151","EPSG:4153","EPSG:4155","EPSG:4157","EPSG:4159","EPSG:4161","EPSG:4163","EPSG:4165","EPSG:4167","EPSG:4169","EPSG:4171","EPSG:4173","EPSG:4175","EPSG:4178","EPSG:4180","EPSG:4182","EPSG:4184","EPSG:4188","EPSG:4190","EPSG:4191","EPSG:4196","EPSG:4198","EPSG:4202","EPSG:4210","EPSG:4211","EPSG:4214","EPSG:4226","EPSG:4229","EPSG:4231","EPSG:4233","EPSG:4236","EPSG:4238","EPSG:4240","EPSG:4242","EPSG:4244","EPSG:4246","EPSG:4248","EPSG:4250","EPSG:4252","EPSG:4255","EPSG:4258","EPSG:4261","EPSG:4264","EPSG:4267","EPSG:4270","EPSG:4273","EPSG:4276","EPSG:4279","EPSG:4281","EPSG:4284","EPSG:4286","EPSG:4288","EPSG:4292","EPSG:4295","EPSG:4297","EPSG:4299","EPSG:4302","EPSG:4324","EPSG:4326"];function Jt(t){return qt.indexOf(Vt(t))>-1}function Vt(t){if(/^urn:(?:x-)?ogc:def:crs:epsg:/.test(t.toLowerCase())){var e=/([0-9]+)$/.exec(t)[1];return"EPSG:".concat(e)}return t}function $t(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function Kt(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?$t(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):$t(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function zt(t){return Rt(t).attributes.version}function Ht(t){var e=zt(t);return Ct(Gt(Rt(t),"Capability"),"Layer").map((function(t){return Qt(t,e)}))}function Qt(e,r){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a="1.3.0"===r?"CRS":"SRS",c=Ct(e,a).map(At),u=c.length>0?c:n,s=Ct(e,"Style").map(Zt),f=s.length>0?s:o;function l(t){return(Jt(Ft(t,a))&&"1.3.0"===r?["miny","minx","maxy","maxx"]:["minx","miny","maxx","maxy"]).map((function(e){return Ft(t,e)}))}var h=Gt(e,"Attribution"),p=null!==h?te(h):i,v=Ct(e,"Layer").map((function(t){return Qt(t,r,u,f,p)}));return Kt({name:At(Gt(e,"Name")),title:At(Gt(e,"Title")),abstract:At(Gt(e,"Abstract")),availableCrs:u,styles:f,attribution:p,boundingBoxes:Ct(e,"BoundingBox").reduce((function(e,r){return Kt(Kt({},e),{},t({},Ft(r,a),l(r)))}),{})},v.length&&{children:v})}function Zt(t){var e=Ft(Gt(Gt(t,"LegendURL"),"OnlineResource"),"xlink:href");return Kt({name:At(Gt(t,"Name")),title:At(Gt(t,"Title"))},e&&{legendUrl:e})}function te(t){var e=Ft(Gt(Gt(t,"LogoURL"),"OnlineResource"),"xlink:href"),r=Ft(Gt(t,"OnlineResource"),"xlink:href"),n=At(Gt(t,"Title"));return Kt(Kt(Kt({},n&&{title:n}),r&&{url:r}),e&&{logoUrl:e})}function ee(t){return Rt(t).attributes.version}function re(t){var e;if(ee(t).startsWith("1.0")){var r=Gt(Gt(Gt(Rt(t),"Capability"),"Request"),"GetFeature");e=Nt(Gt(r,"ResultFormat")).map(jt)}else{var n=Ct(Gt(Rt(t),"OperationsMetadata"),"Operation").find((function(t){return"GetFeature"===Ft(t,"name")})),o=Ct(n,"Parameter").find((function(t){return"outputFormat"===Ft(t,"name")}));e=Ct(o,"Value",!0).map(At)}return e}function ne(t){var e=ee(t),r=re(t);return Ct(Gt(Rt(t),"FeatureTypeList"),"FeatureType").map((function(t){return function(t,e,r){var n=e.startsWith("2.")?"CRS":"SRS",o=e.startsWith("1.0")?"SRS":"Default".concat(n);function i(){var e=Gt(t,"LatLongBoundingBox");return["minx","miny","maxx","maxy"].map((function(t){return Ft(e,t)})).map(parseFloat)}function a(){var e=Gt(t,"WGS84BoundingBox");return["LowerCorner","UpperCorner"].map((function(t){return Gt(e,t)})).map((function(t){return At(t).split(" ")})).reduce((function(t,e){return[].concat(f(t),f(e))})).map(parseFloat)}var c=e.startsWith("1.0")?[]:Ct(t,"Other".concat(n)).map(At).map(Vt),u=e.startsWith("1.0")?[]:Ct(Gt(t,"OutputFormats"),"Format").map(At);return{name:At(Gt(t,"Name")),title:At(Gt(t,"Title")),abstract:At(Gt(t,"Abstract")),defaultCrs:Vt(At(Gt(t,o))),otherCrs:c,outputFormats:u.length>0?u:r,latLonBoundingBox:e.startsWith("1.0")?i():a()}}(t,e,r)}))}function oe(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function ie(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?oe(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):oe(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ae(e,r,n){var o,i=Rt(e);if(n.startsWith("2.0"))o=Ct(i,"member").map((function(t){return Nt(t)[0]}));else{var a=Gt(i,"featureMembers");o=a?Nt(a):Ct(i,"featureMember").map((function(t){return Nt(t)[0]}))}var c="1.0.0"===n?"fid":"gml:id";function u(e){return Nt(e).filter((function(t){return Tt(jt(t))in r.properties})).reduce((function(e,n){var o=Tt(jt(n));return ie(ie({},e),{},t({},o,function(t,e){switch(r.properties[t]){case"integer":return parseInt(e);case"float":return parseFloat(e);case"boolean":return"true"===e;default:return e}}(o,At(n))))}),{})}return o.map((function(t){return{id:Ft(t,c),properties:u(t)}}))}function ce(e,r,n,o,i,a,c,u,s,f){var l="2.0.0"===r?"COUNT":"MAXFEATURES",h=t({SERVICE:"WFS",REQUEST:"GetFeature",VERSION:r},"2.0.0"===r?"TYPENAMES":"TYPENAME",n);if(void 0!==o&&(h.OUTPUTFORMAT=o),void 0!==a&&(h.PROPERTYNAME=a.join(",")),c?(h.RESULTTYPE="hits",h[l]="1"):void 0!==i&&(h[l]=i.toString(10)),u&&(h.SRSNAME=u),s){var p=s.join(",");h.BBOX=f?"".concat(p,",").concat(f):p}return Yt(e,h)}u("parseWmsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,r=Gt(Rt(e),"Service"),n=Ct(Gt(r,"KeywordList"),"Keyword").map(At).filter((function(t,e,r){return r.indexOf(t)===e})),{title:At(Gt(r,"Title")),name:At(Gt(r,"Name")),abstract:At(Gt(r,"Abstract")),fees:At(Gt(r,"Fees")),constraints:At(Gt(r,"AccessConstraints")),keywords:n}),layers:Ht(t),version:zt(t)};var e,r,n}))})),u("parseWfsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,n=ee(e),o=n.startsWith("1.0")?"Service":"ServiceIdentification",i=n.startsWith("1.0")?"Name":"ServiceType",a=Gt(Rt(e),o),r=n.startsWith("1.0")?At(Gt(a,"Keywords")).split(",").map((function(t){return t.trim()})):Ct(Gt(a,"Keywords"),"Keyword").map(At),{title:At(Gt(a,"Title")),name:At(Gt(a,i)),abstract:At(Gt(a,"Abstract")),fees:At(Gt(a,"Fees")),constraints:At(Gt(a,"AccessConstraints")),keywords:r,outputFormats:re(e)}),featureTypes:ne(t),version:ee(t)};var e,r,n,o,i,a}))})),u("queryWfsFeatureTypeDetails",self,(function(t){var e=t.url,r=t.serviceVersion,n=t.featureTypeFull;return Xt(ce(e,r,n.name,void 0,void 0,Object.keys(n.properties))).then((function(t){return{props:(e=ae(t,n,r),e.reduce((function(t,e){var r=function(r){var n=e.properties[r];r in t||(t[r]={uniqueValues:[]});var o=t[r].uniqueValues.find((function(t){return t.value===n}));o?o.count++:t[r].uniqueValues.push({value:n,count:1})};for(var n in e.properties)r(n);return t}),{}))};var e}))}));
`], { type: "application/javascript" })), {
    type: "module"
  })), Pv;
}
function F$(t) {
  return k$("parseWmsCapabilities", N$(), {
    url: t
  });
}
const vl = "";
class z$ {
  constructor(e) {
    this.chars = [...e], this.charCount = this.chars.length, this.charIndex = 0, this.charsToBytes = new Array(this.charCount), this.multiByteMode = !1, this.string = e;
    let { chars: r, charCount: n, charsToBytes: i } = this;
    if (n === e.length)
      for (let l = 0; l < n; ++l)
        i[l] = l;
    else {
      for (let l = 0, h = 0; h < n; ++h)
        i[h] = l, l += r[h].length;
      this.multiByteMode = !0;
    }
  }
  get isEnd() {
    return this.charIndex >= this.charCount;
  }
  _charLength(e) {
    let { length: r } = e;
    return r < 2 || !this.multiByteMode ? r : e.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length;
  }
  advance(e = 1) {
    this.charIndex = Math.min(this.charCount, this.charIndex + e);
  }
  consume(e = 1) {
    let r = this.peek(e);
    return this.advance(e), r;
  }
  consumeMatch(e) {
    if (!e.sticky)
      throw new Error('`regex` must have a sticky flag ("y")');
    e.lastIndex = this.charsToBytes[this.charIndex];
    let r = e.exec(this.string);
    if (r === null)
      return vl;
    let n = r[0];
    return this.advance(this._charLength(n)), n;
  }
  consumeMatchFn(e) {
    let r = this.charIndex;
    for (; !this.isEnd && e(this.peek()); )
      this.advance();
    return this.charIndex > r ? this.string.slice(this.charsToBytes[r], this.charsToBytes[this.charIndex]) : vl;
  }
  consumeString(e) {
    if (this.consumeStringFast(e))
      return e;
    if (!this.multiByteMode)
      return vl;
    let { length: r } = e, n = this._charLength(e);
    return n !== r && e === this.peek(n) ? (this.advance(n), e) : vl;
  }
  consumeStringFast(e) {
    if (this.peek() === e[0]) {
      let { length: r } = e;
      if (r === 1)
        return this.advance(), e;
      if (this.peek(r) === e)
        return this.advance(r), e;
    }
    return vl;
  }
  consumeUntilMatch(e) {
    if (!e.global)
      throw new Error('`regex` must have a global flag ("g")');
    let r = this.charsToBytes[this.charIndex];
    e.lastIndex = r;
    let n = e.exec(this.string);
    if (n === null || n.index === r)
      return vl;
    let i = this.string.slice(r, n.index);
    return this.advance(this._charLength(i)), i;
  }
  consumeUntilString(e) {
    let { charIndex: r, charsToBytes: n, string: i } = this, l = n[r], h = i.indexOf(e, l);
    if (h <= 0)
      return vl;
    let s = i.slice(l, h);
    return this.advance(this._charLength(s)), s;
  }
  peek(e = 1) {
    if (this.charIndex >= this.charCount)
      return vl;
    if (e === 1)
      return this.chars[this.charIndex];
    let { charsToBytes: r, charIndex: n } = this;
    return this.string.slice(r[n], r[n + e]);
  }
  reset(e = 0) {
    this.charIndex = e >= 0 ? Math.min(this.charCount, e) : Math.max(0, this.charIndex + e);
  }
}
var B$ = z$, Jl = {};
const U$ = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
  amp: "&",
  apos: "'",
  gt: ">",
  lt: "<",
  quot: '"'
}));
Jl.predefinedEntities = U$;
function tC(t) {
  if (rC(t))
    return !0;
  let e = qy(t);
  return e === 45 || e === 46 || e >= 48 && e <= 57 || e === 183 || e >= 768 && e <= 879 || e >= 8255 && e <= 8256;
}
Jl.isNameChar = tC;
function rC(t) {
  let e = qy(t);
  return e === 58 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 192 && e <= 214 || e >= 216 && e <= 246 || e >= 248 && e <= 767 || e >= 880 && e <= 893 || e >= 895 && e <= 8191 || e >= 8204 && e <= 8205 || e >= 8304 && e <= 8591 || e >= 11264 && e <= 12271 || e >= 12289 && e <= 55295 || e >= 63744 && e <= 64975 || e >= 65008 && e <= 65533 || e >= 65536 && e <= 983039;
}
Jl.isNameStartChar = rC;
function $$(t) {
  return !nC(t);
}
Jl.isNotXmlChar = $$;
function V$(t) {
  return t === "#" || tC(t);
}
Jl.isReferenceChar = V$;
function j$(t) {
  let e = qy(t);
  return e === 32 || e === 9 || e === 10 || e === 13;
}
Jl.isWhitespace = j$;
function nC(t) {
  let e = qy(t);
  return e === 9 || e === 10 || e === 13 || e >= 32 && e <= 55295 || e >= 57344 && e <= 65533 || e >= 65536 && e <= 1114111;
}
Jl.isXmlChar = nC;
function qy(t) {
  return t.codePointAt(0) || -1;
}
class gu {
  constructor() {
    this.parent = null;
  }
  get document() {
    return this.parent ? this.parent.document : null;
  }
  get isRootNode() {
    return this.parent ? this.parent === this.document : !1;
  }
  get preserveWhitespace() {
    return Boolean(this.parent && this.parent.preserveWhitespace);
  }
  get type() {
    return "";
  }
  toJSON() {
    let e = {
      type: this.type
    };
    return this.isRootNode && (e.isRootNode = !0), this.preserveWhitespace && (e.preserveWhitespace = !0), e;
  }
}
gu.TYPE_CDATA = "cdata";
gu.TYPE_COMMENT = "comment";
gu.TYPE_DOCUMENT = "document";
gu.TYPE_ELEMENT = "element";
gu.TYPE_PROCESSING_INSTRUCTION = "pi";
gu.TYPE_TEXT = "text";
var yu = gu;
const Av = yu;
class G$ extends Av {
  constructor(e = "") {
    super(), this.text = e;
  }
  get type() {
    return Av.TYPE_TEXT;
  }
  toJSON() {
    return Object.assign(Av.prototype.toJSON.call(this), {
      text: this.text
    });
  }
}
var Gx = G$;
const q$ = yu, W$ = Gx;
class X$ extends W$ {
  get type() {
    return q$.TYPE_CDATA;
  }
}
var iC = X$;
const Ov = yu;
class Z$ extends Ov {
  constructor(e = "") {
    super(), this.content = e;
  }
  get type() {
    return Ov.TYPE_COMMENT;
  }
  toJSON() {
    return Object.assign(Ov.prototype.toJSON.call(this), {
      content: this.content
    });
  }
}
var oC = Z$;
const Rv = yu;
class qx extends Rv {
  constructor(e, r = /* @__PURE__ */ Object.create(null), n = []) {
    super(), this.name = e, this.attributes = r, this.children = n;
  }
  get isEmpty() {
    return this.children.length === 0;
  }
  get preserveWhitespace() {
    let e = this;
    for (; e instanceof qx; ) {
      if ("xml:space" in e.attributes)
        return e.attributes["xml:space"] === "preserve";
      e = e.parent;
    }
    return !1;
  }
  get text() {
    return this.children.map((e) => "text" in e ? e.text : "").join("");
  }
  get type() {
    return Rv.TYPE_ELEMENT;
  }
  toJSON() {
    return Object.assign(Rv.prototype.toJSON.call(this), {
      name: this.name,
      attributes: this.attributes,
      children: this.children.map((e) => e.toJSON())
    });
  }
}
var Wx = qx;
const H$ = Wx, Lv = yu;
class K$ extends Lv {
  constructor(e = []) {
    super(), this.children = e;
  }
  get document() {
    return this;
  }
  get root() {
    return this.children.find((e) => e instanceof H$) || null;
  }
  get text() {
    return this.children.map((e) => "text" in e ? e.text : "").join("");
  }
  get type() {
    return Lv.TYPE_DOCUMENT;
  }
  toJSON() {
    return Object.assign(Lv.prototype.toJSON.call(this), {
      children: this.children.map((e) => e.toJSON())
    });
  }
}
var aC = K$;
const Dv = yu;
class Y$ extends Dv {
  constructor(e, r = "") {
    super(), this.name = e, this.content = r;
  }
  get type() {
    return Dv.TYPE_PROCESSING_INSTRUCTION;
  }
  toJSON() {
    return Object.assign(Dv.prototype.toJSON.call(this), {
      name: this.name,
      content: this.content
    });
  }
}
var sC = Y$;
const J$ = B$, Nc = Jl, Q$ = iC, eV = oC, tV = aC, rV = Wx, eT = sC, tT = Gx, kv = "";
class nV {
  constructor(e, r = {}) {
    for (this.document = new tV(), this.currentNode = this.document, this.options = r, this.scanner = new J$(oV(e)), this.consumeProlog(), this.consumeElement() || this.error("Root element is missing or invalid"); this.consumeMisc(); )
      ;
    this.scanner.isEnd || this.error("Extra content at the end of the document");
  }
  addNode(e) {
    e.parent = this.currentNode, this.currentNode.children.push(e);
  }
  addText(e) {
    let { children: r } = this.currentNode;
    if (r.length > 0) {
      let n = r[r.length - 1];
      if (n instanceof tT) {
        n.text += e;
        return;
      }
    }
    this.addNode(new tT(e));
  }
  consumeAttributeValue() {
    let { scanner: e } = this, r = e.peek();
    if (r !== '"' && r !== "'")
      return !1;
    e.advance();
    let n, i = !1, l = kv, h = r === '"' ? /[^"&<]+/y : /[^'&<]+/y;
    e:
      for (; !e.isEnd; )
        switch (n = e.consumeMatch(h), n && (this.validateChars(n), l += n.replace(/[\t\r\n]/g, " ")), e.peek()) {
          case r:
            i = !0;
            break e;
          case "&":
            l += this.consumeReference();
            continue;
          case "<":
            this.error("Unescaped `<` is not allowed in an attribute value");
            break;
          case kv:
            this.error("Unclosed attribute");
            break;
        }
    return i || this.error("Unclosed attribute"), e.advance(), l;
  }
  consumeCdataSection() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<![CDATA["))
      return !1;
    let r = e.consumeUntilString("]]>");
    return this.validateChars(r), e.consumeStringFast("]]>") || this.error("Unclosed CDATA section"), this.options.preserveCdata ? this.addNode(new Q$(r)) : this.addText(r), !0;
  }
  consumeCharData() {
    let { scanner: e } = this, r = e.consumeUntilMatch(/<|&|]]>/g);
    return r ? (this.validateChars(r), e.peek() === "]" && e.peek(3) === "]]>" && this.error("Element content may not contain the CDATA section close delimiter `]]>`"), this.addText(r), !0) : !1;
  }
  consumeComment() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<!--"))
      return !1;
    let r = e.consumeUntilString("--");
    return this.validateChars(r), e.consumeStringFast("-->") || (e.peek(2) === "--" ? this.error("The string `--` isn't allowed inside a comment") : this.error("Unclosed comment")), this.options.preserveComments && this.addNode(new eV(r.trim())), !0;
  }
  consumeContentReference() {
    let e = this.consumeReference();
    return e ? (this.addText(e), !0) : !1;
  }
  consumeDoctypeDeclaration() {
    let { scanner: e } = this;
    return !e.consumeStringFast("<!DOCTYPE") || !this.consumeWhitespace() ? !1 : (e.consumeMatch(/[^[>]+/y), e.consumeMatch(/\[[\s\S]+?\][\x20\t\r\n]*>/y) || e.consumeStringFast(">") || this.error("Unclosed doctype declaration"), !0);
  }
  consumeElement() {
    let { scanner: e } = this, r = e.charIndex;
    if (e.peek() !== "<")
      return !1;
    e.advance();
    let n = this.consumeName();
    if (!n)
      return e.reset(r), !1;
    let i = /* @__PURE__ */ Object.create(null);
    for (; this.consumeWhitespace(); ) {
      let s = this.consumeName();
      if (!s)
        continue;
      let m = this.consumeEqual() && this.consumeAttributeValue();
      m === !1 && this.error("Attribute value expected"), s in i && this.error(`Duplicate attribute: ${s}`), s === "xml:space" && m !== "default" && m !== "preserve" && this.error('Value of the `xml:space` attribute must be "default" or "preserve"'), i[s] = m;
    }
    if (this.options.sortAttributes) {
      let s = Object.keys(i).sort(), m = /* @__PURE__ */ Object.create(null);
      for (let v = 0; v < s.length; ++v) {
        let E = s[v];
        m[E] = i[E];
      }
      i = m;
    }
    let l = Boolean(e.consumeStringFast("/>")), h = new rV(n, i);
    if (h.parent = this.currentNode, !l) {
      for (e.consumeStringFast(">") || this.error(`Unclosed start tag for element \`${n}\``), this.currentNode = h, this.consumeCharData(); this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment(); )
        this.consumeCharData();
      let s = e.charIndex, m;
      (!e.consumeStringFast("</") || !(m = this.consumeName()) || m !== n) && (e.reset(s), this.error(`Missing end tag for element ${n}`)), this.consumeWhitespace(), e.consumeStringFast(">") || this.error(`Unclosed end tag for element ${n}`), this.currentNode = h.parent;
    }
    return this.addNode(h), !0;
  }
  consumeEqual() {
    return this.consumeWhitespace(), this.scanner.consumeStringFast("=") ? (this.consumeWhitespace(), !0) : !1;
  }
  consumeMisc() {
    return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();
  }
  consumeName() {
    return Nc.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(Nc.isNameChar) : kv;
  }
  consumeProcessingInstruction() {
    let { scanner: e } = this, r = e.charIndex;
    if (!e.consumeStringFast("<?"))
      return !1;
    let n = this.consumeName();
    if (n ? n.toLowerCase() === "xml" && (e.reset(r), this.error("XML declaration isn't allowed here")) : this.error("Invalid processing instruction"), !this.consumeWhitespace()) {
      if (e.consumeStringFast("?>"))
        return this.addNode(new eT(n)), !0;
      this.error("Whitespace is required after a processing instruction name");
    }
    let i = e.consumeUntilString("?>");
    return this.validateChars(i), e.consumeStringFast("?>") || this.error("Unterminated processing instruction"), this.addNode(new eT(n, i)), !0;
  }
  consumeProlog() {
    let { scanner: e } = this, r = e.charIndex;
    for (this.consumeXmlDeclaration(); this.consumeMisc(); )
      ;
    if (this.consumeDoctypeDeclaration())
      for (; this.consumeMisc(); )
        ;
    return r < e.charIndex;
  }
  consumeReference() {
    let { scanner: e } = this;
    if (e.peek() !== "&")
      return !1;
    e.advance();
    let r = e.consumeMatchFn(Nc.isReferenceChar);
    e.consume() !== ";" && this.error("Unterminated reference (a reference must end with `;`)");
    let n;
    if (r[0] === "#") {
      let i = r[1] === "x" ? parseInt(r.slice(2), 16) : parseInt(r.slice(1), 10);
      isNaN(i) && this.error("Invalid character reference"), n = String.fromCodePoint(i), Nc.isXmlChar(n) || this.error("Character reference resolves to an invalid character");
    } else if (n = Nc.predefinedEntities[r], n === void 0) {
      let {
        ignoreUndefinedEntities: i,
        resolveUndefinedEntity: l
      } = this.options, h = `&${r};`;
      if (l) {
        let s = l(h);
        if (s != null) {
          let m = typeof s;
          if (m !== "string")
            throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${m}`);
          return s;
        }
      }
      if (i)
        return h;
      e.reset(-h.length), this.error(`Named entity isn't defined: ${h}`);
    }
    return n;
  }
  consumeSystemLiteral() {
    let { scanner: e } = this, r = e.consumeStringFast('"') || e.consumeStringFast("'");
    if (!r)
      return !1;
    let n = e.consumeUntilString(r);
    return this.validateChars(n), e.consumeStringFast(r) || this.error("Missing end quote"), n;
  }
  consumeWhitespace() {
    return Boolean(this.scanner.consumeMatchFn(Nc.isWhitespace));
  }
  consumeXmlDeclaration() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<?xml"))
      return !1;
    this.consumeWhitespace() || this.error("Invalid XML declaration");
    let r = Boolean(e.consumeStringFast("version")) && this.consumeEqual() && this.consumeSystemLiteral();
    if (r === !1 ? this.error("XML version is missing or invalid") : /^1\.[0-9]+$/.test(r) || this.error("Invalid character in version number"), this.consumeWhitespace()) {
      Boolean(e.consumeStringFast("encoding")) && this.consumeEqual() && this.consumeSystemLiteral() && this.consumeWhitespace();
      let i = Boolean(e.consumeStringFast("standalone")) && this.consumeEqual() && this.consumeSystemLiteral();
      i && (i !== "yes" && i !== "no" && this.error('Only "yes" and "no" are permitted as values of `standalone`'), this.consumeWhitespace());
    }
    return e.consumeStringFast("?>") || this.error("Invalid or unclosed XML declaration"), !0;
  }
  error(e) {
    let { charIndex: r, string: n } = this.scanner, i = 1, l = "", h = 1;
    for (let E = 0; E < r; ++E) {
      let T = n[E];
      T === `
` ? (i = 1, l = "", h += 1) : (i += 1, l += T);
    }
    let s = n.indexOf(`
`, r);
    l += s === -1 ? n.slice(r) : n.slice(r, s);
    let m = 0;
    l.length > 50 && (i < 40 ? l = l.slice(0, 50) : (m = i - 20, l = l.slice(m, i + 30)));
    let v = new Error(
      `${e} (line ${h}, column ${i})
  ${l}
` + " ".repeat(i - m + 1) + `^
`
    );
    throw Object.assign(v, {
      column: i,
      excerpt: l,
      line: h,
      pos: r
    }), v;
  }
  validateChars(e) {
    let r = 0;
    for (let n of e)
      Nc.isNotXmlChar(n) && (this.scanner.reset(-([...e].length - r)), this.error("Invalid character")), r += 1;
  }
}
var iV = nV;
function oV(t) {
  return t[0] === "\uFEFF" && (t = t.slice(1)), t.replace(/\r\n?/g, `
`);
}
const aV = iV, sV = iC, lV = oC, cV = aC, uV = Wx, hV = yu, fV = sC, dV = Gx;
function Ql(t, e) {
  return new aV(t, e).document;
}
Ql.XmlCdata = sV;
Ql.XmlComment = lV;
Ql.XmlDocument = cV;
Ql.XmlElement = uV;
Ql.XmlNode = hV;
Ql.XmlProcessingInstruction = fV;
Ql.XmlText = dV;
var pV = Ql;
class mV extends Error {
  constructor(e) {
    super(e);
  }
}
function gV(t) {
  let e = null;
  try {
    e = pV(t);
  } catch (r) {
    throw new mV(r.message);
  }
  return e;
}
function js(t) {
  return t.children[0];
}
function ny(t) {
  const e = t.indexOf(":");
  return e > -1 ? t.substr(e + 1) : t;
}
function iy(t) {
  return t.name || "";
}
function Ji(t, e, r) {
  const n = ny(e);
  function i(l, h) {
    return ny(iy(h)) === n && l.push(h), r && Array.isArray(h.children) ? [...l, ...h.children.reduce(i, [])] : l;
  }
  return t && Array.isArray(t.children) ? t.children.reduce(i, []) : [];
}
function fr(t, e, r) {
  return Ji(t, e, r)[0] || null;
}
function od(t) {
  return t && Array.isArray(t.children) ? [...t.children.filter((e) => e.constructor.name === "XmlElement")] : [];
}
function cn(t) {
  const e = t && Array.isArray(t.children) ? t.children.find((r) => r.type === "text") : null;
  return e ? e.text : "";
}
function is(t, e) {
  return t && t.attributes[e] || "";
}
const rT = ["utf-8", "utf-16", "iso-8859-1"], nT = "utf-8";
function yV(t) {
  const e = /charset=([^;]+)/.exec(t);
  return e ? e[1] : null;
}
function _V(t, e) {
  const r = e ? yV(e) : null, n = r ? [r, ...rT] : rT;
  for (const i of n)
    try {
      return new TextDecoder(i, { fatal: !0 }).decode(t);
    } catch {
    }
  return console.warn(
    `XML document encoding could not be determined, falling back to ${nT}.`
  ), new TextDecoder(nT).decode(t);
}
const Gm = /* @__PURE__ */ new Map();
function vV(t) {
  if (Gm.has(t))
    return Gm.get(t);
  const e = fetch(t);
  return e.finally(() => Gm.delete(t)), Gm.set(t, e), e;
}
function Xx(t) {
  return vV(t).catch(
    () => fetch(t, { method: "HEAD", mode: "no-cors" }).catch((e) => {
      throw new Iv(
        `Fetching the document failed either due to network errors or unreachable host, error is: ${e.message}`,
        0,
        !1
      );
    }).then(() => {
      throw new Iv(
        "The document could not be fetched due to CORS limitations",
        0,
        !0
      );
    })
  ).then(async (e) => {
    if (!e.ok) {
      const i = await e.text();
      throw new Iv(
        `Received an error with code ${e.status}: ${i}`,
        e.status,
        !1
      );
    }
    const r = await e.arrayBuffer(), n = e.headers.get("Content-Type");
    return _V(r, n);
  }).then((e) => gV(e));
}
function Zx(t, e) {
  const r = t.match(/(https?%3A%2F%2F[^/]+)$/);
  if (r) {
    const s = r[1], m = Zx(decodeURIComponent(s), e);
    return t.replace(s, encodeURIComponent(m));
  }
  const n = new URL(t), i = Object.keys(e), l = i.map((s) => s.toLowerCase()), h = [];
  for (const s of n.searchParams.keys())
    l.indexOf(s.toLowerCase()) > -1 && h.push(s);
  return h.map((s) => n.searchParams.delete(s)), i.forEach(
    (s) => n.searchParams.set(s, e[s] === !0 ? "" : e[s])
  ), n.toString();
}
let xV = 1e3 * 60 * 60;
function bV() {
  return xV;
}
const Zl = "caches" in self ? caches.open("ogc-client") : null;
async function wV(t, ...e) {
  if (!Zl)
    return;
  const r = "https://cache/" + e.join("/");
  await (await Zl).put(
    r,
    new Response(JSON.stringify(t), {
      headers: {
        "x-expiry": (Date.now() + bV()).toString(10)
      }
    })
  );
}
async function EV(...t) {
  if (!Zl)
    return !1;
  const e = "https://cache/" + t.join("/");
  return (await Zl).match(e).then((n) => !!n && parseInt(n.headers.get("x-expiry")) > Date.now());
}
async function TV(...t) {
  if (!Zl)
    return null;
  const e = "https://cache/" + t.join("/"), n = await (await Zl).match(e);
  return n ? n.clone().json() : null;
}
const qm = /* @__PURE__ */ new Map();
async function SV(t, ...e) {
  if (await MV(), await EV(...e))
    return TV(...e);
  const r = e.join("#");
  if (qm.has(r))
    return qm.get(r);
  const n = t();
  n instanceof Promise && (n.then(() => qm.delete(r)), qm.set(r, n));
  const i = await n;
  return await wV(i, ...e), i;
}
async function MV() {
  if (!Zl)
    return;
  const t = await Zl, e = await t.keys();
  for (let r of e) {
    const n = await t.match(r);
    parseInt(n.headers.get("x-expiry")) <= Date.now() && await t.delete(r);
  }
}
function CV(t, e, r, n, i, l, h, s, m, v) {
  const E = e === "2.0.0" ? "TYPENAMES" : "TYPENAME", T = e === "2.0.0" ? "COUNT" : "MAXFEATURES", S = {
    SERVICE: "WFS",
    REQUEST: "GetFeature",
    VERSION: e,
    [E]: r
  };
  if (n !== void 0 && (S.OUTPUTFORMAT = n), l !== void 0 && (S.PROPERTYNAME = l.join(",")), h ? (S.RESULTTYPE = "hits", S[T] = "1") : i !== void 0 && (S[T] = i.toString(10)), s && (S.SRSNAME = s), m) {
    const A = m.join(",");
    S.BBOX = v ? `${A},${v}` : A;
  }
  return Zx(t, S);
}
class IV {
  constructor(e) {
    const r = Zx(e, {
      SERVICE: "WMS",
      REQUEST: "GetCapabilities"
    });
    this._capabilitiesPromise = SV(
      () => F$(r),
      "WMS",
      "CAPABILITIES",
      r
    ).then(({ info: n, layers: i, version: l }) => {
      this._info = n, this._layers = i, this._version = l;
    }), this._info = null, this._layers = null, this._version = null;
  }
  isReady() {
    return this._capabilitiesPromise.then(() => this);
  }
  getServiceInfo() {
    return this._info;
  }
  getLayers() {
    function e(r) {
      return {
        title: r.title,
        name: r.name,
        abstract: r.abstract,
        ..."children" in r && {
          children: r.children.map(e)
        }
      };
    }
    return this._layers.map(e);
  }
  getLayerByName(e) {
    let r = null;
    function n(i) {
      if (r === null) {
        if (i.name === e) {
          r = i;
          return;
        }
        "children" in i && i.children.map(n);
      }
    }
    return this._layers.map(n), r;
  }
  getVersion() {
    return this._version;
  }
}
const PV = [
  "EPSG:4046",
  "EPSG:4075",
  "EPSG:4120",
  "EPSG:4122",
  "EPSG:4124",
  "EPSG:4126",
  "EPSG:4149",
  "EPSG:4151",
  "EPSG:4153",
  "EPSG:4155",
  "EPSG:4157",
  "EPSG:4159",
  "EPSG:4161",
  "EPSG:4163",
  "EPSG:4165",
  "EPSG:4167",
  "EPSG:4169",
  "EPSG:4171",
  "EPSG:4173",
  "EPSG:4175",
  "EPSG:4178",
  "EPSG:4180",
  "EPSG:4182",
  "EPSG:4184",
  "EPSG:4188",
  "EPSG:4190",
  "EPSG:4191",
  "EPSG:4196",
  "EPSG:4198",
  "EPSG:4202",
  "EPSG:4210",
  "EPSG:4211",
  "EPSG:4214",
  "EPSG:4226",
  "EPSG:4229",
  "EPSG:4231",
  "EPSG:4233",
  "EPSG:4236",
  "EPSG:4238",
  "EPSG:4240",
  "EPSG:4242",
  "EPSG:4244",
  "EPSG:4246",
  "EPSG:4248",
  "EPSG:4250",
  "EPSG:4252",
  "EPSG:4255",
  "EPSG:4258",
  "EPSG:4261",
  "EPSG:4264",
  "EPSG:4267",
  "EPSG:4270",
  "EPSG:4273",
  "EPSG:4276",
  "EPSG:4279",
  "EPSG:4281",
  "EPSG:4284",
  "EPSG:4286",
  "EPSG:4288",
  "EPSG:4292",
  "EPSG:4295",
  "EPSG:4297",
  "EPSG:4299",
  "EPSG:4302",
  "EPSG:4324",
  "EPSG:4326"
];
function AV(t) {
  return PV.indexOf(B0(t)) > -1;
}
function B0(t) {
  return /^urn:(?:x-)?ogc:def:crs:epsg:/.test(t.toLowerCase()) ? `EPSG:${/([0-9]+)$/.exec(t)[1]}` : t;
}
function lC(t) {
  return js(t).attributes.version;
}
function OV(t) {
  const e = lC(t), r = fr(
    js(t),
    "Capability"
  );
  return Ji(r, "Layer").map(
    (n) => cC(n, e)
  );
}
function RV(t) {
  const e = fr(js(t), "Service"), r = Ji(
    fr(e, "KeywordList"),
    "Keyword"
  ).map(cn).filter((n, i, l) => l.indexOf(n) === i);
  return {
    title: cn(fr(e, "Title")),
    name: cn(fr(e, "Name")),
    abstract: cn(fr(e, "Abstract")),
    fees: cn(fr(e, "Fees")),
    constraints: cn(fr(e, "AccessConstraints")),
    keywords: r
  };
}
function cC(t, e, r = [], n = [], i = null) {
  const l = e === "1.3.0" ? "CRS" : "SRS", h = Ji(t, l).map(cn), s = h.length > 0 ? h : r, m = Ji(t, "Style").map(
    LV
  ), v = m.length > 0 ? m : n;
  function E(L) {
    const B = is(L, l);
    return (AV(B) && e === "1.3.0" ? ["miny", "minx", "maxy", "maxx"] : ["minx", "miny", "maxx", "maxy"]).map((q) => is(L, q));
  }
  const T = fr(t, "Attribution"), S = T !== null ? DV(T) : i, A = Ji(t, "Layer").map(
    (L) => cC(L, e, s, v, S)
  );
  return {
    name: cn(fr(t, "Name")),
    title: cn(fr(t, "Title")),
    abstract: cn(fr(t, "Abstract")),
    availableCrs: s,
    styles: v,
    attribution: S,
    boundingBoxes: Ji(t, "BoundingBox").reduce(
      (L, B) => ({
        ...L,
        [is(B, l)]: E(B)
      }),
      {}
    ),
    ...A.length && { children: A }
  };
}
function LV(t) {
  const e = is(
    fr(fr(t, "LegendURL"), "OnlineResource"),
    "xlink:href"
  );
  return {
    name: cn(fr(t, "Name")),
    title: cn(fr(t, "Title")),
    ...e && { legendUrl: e }
  };
}
function DV(t) {
  const e = is(
    fr(
      fr(t, "LogoURL"),
      "OnlineResource"
    ),
    "xlink:href"
  ), r = is(
    fr(t, "OnlineResource"),
    "xlink:href"
  ), n = cn(fr(t, "Title"));
  return {
    ...n && { title: n },
    ...r && { url: r },
    ...e && { logoUrl: e }
  };
}
function Wy(t) {
  return js(t).attributes.version;
}
function uC(t) {
  const e = Wy(t);
  let r;
  if (e.startsWith("1.0")) {
    const n = fr(
      fr(
        fr(js(t), "Capability"),
        "Request"
      ),
      "GetFeature"
    );
    r = od(
      fr(n, "ResultFormat")
    ).map(iy);
  } else {
    const n = fr(
      js(t),
      "OperationsMetadata"
    ), i = Ji(n, "Operation").find(
      (h) => is(h, "name") === "GetFeature"
    ), l = Ji(i, "Parameter").find(
      (h) => is(h, "name") === "outputFormat"
    );
    r = Ji(l, "Value", !0).map(
      cn
    );
  }
  return r;
}
function kV(t) {
  const e = Wy(t), r = e.startsWith("1.0") ? "Service" : "ServiceIdentification", n = e.startsWith("1.0") ? "Name" : "ServiceType", i = fr(js(t), r);
  let l;
  return e.startsWith("1.0") ? l = cn(fr(i, "Keywords")).split(",").map((h) => h.trim()) : l = Ji(
    fr(i, "Keywords"),
    "Keyword"
  ).map(cn), {
    title: cn(fr(i, "Title")),
    name: cn(fr(i, n)),
    abstract: cn(fr(i, "Abstract")),
    fees: cn(fr(i, "Fees")),
    constraints: cn(fr(i, "AccessConstraints")),
    keywords: l,
    outputFormats: uC(t)
  };
}
function NV(t) {
  const e = Wy(t), r = uC(t), n = fr(
    js(t),
    "FeatureTypeList"
  );
  return Ji(n, "FeatureType").map(
    (i) => FV(i, e, r)
  );
}
function FV(t, e, r) {
  const n = e.startsWith("2.") ? "CRS" : "SRS", i = e.startsWith("1.0") ? "SRS" : `Default${n}`;
  function l() {
    const v = fr(t, "LatLongBoundingBox");
    return ["minx", "miny", "maxx", "maxy"].map((E) => is(v, E)).map(parseFloat);
  }
  function h() {
    const v = fr(t, "WGS84BoundingBox");
    return ["LowerCorner", "UpperCorner"].map((E) => fr(v, E)).map((E) => cn(E).split(" ")).reduce((E, T) => [...E, ...T]).map(parseFloat);
  }
  const s = e.startsWith("1.0") ? [] : Ji(t, `Other${n}`).map(cn).map(B0), m = e.startsWith("1.0") ? [] : Ji(
    fr(t, "OutputFormats"),
    "Format"
  ).map(cn);
  return {
    name: cn(fr(t, "Name")),
    title: cn(fr(t, "Title")),
    abstract: cn(fr(t, "Abstract")),
    defaultCrs: B0(
      cn(fr(t, i))
    ),
    otherCrs: s,
    outputFormats: m.length > 0 ? m : r,
    latLonBoundingBox: e.startsWith("1.0") ? l() : h()
  };
}
function zV(t, e, r) {
  const n = js(t);
  let i;
  if (r.startsWith("2.0"))
    i = Ji(n, "member").map(
      (v) => od(v)[0]
    );
  else {
    const v = fr(n, "featureMembers");
    i = v ? od(v) : Ji(n, "featureMember").map(
      (E) => od(E)[0]
    );
  }
  const l = r === "1.0.0" ? "fid" : "gml:id";
  function h(v) {
    return v in e.properties;
  }
  function s(v, E) {
    switch (e.properties[v]) {
      case "integer":
        return parseInt(E);
      case "float":
        return parseFloat(E);
      case "boolean":
        return E === "true";
      default:
        return E;
    }
  }
  function m(v) {
    return od(v).filter((E) => h(ny(iy(E)))).reduce((E, T) => {
      const S = ny(iy(T));
      return {
        ...E,
        [S]: s(S, cn(T))
      };
    }, {});
  }
  return i.map((v) => ({
    id: is(v, l),
    properties: m(v)
  }));
}
function BV(t) {
  return t.reduce((e, r) => {
    for (const n in r.properties) {
      const i = r.properties[n];
      n in e || (e[n] = { uniqueValues: [] });
      const l = e[n].uniqueValues.find(
        (h) => h.value === i
      );
      l ? l.count++ : e[n].uniqueValues.push({ value: i, count: 1 });
    }
    return e;
  }, {});
}
jx(
  "parseWmsCapabilities",
  self,
  ({ url: t }) => Xx(t).then((e) => ({
    info: RV(e),
    layers: OV(e),
    version: lC(e)
  }))
);
jx(
  "parseWfsCapabilities",
  self,
  ({ url: t }) => Xx(t).then((e) => ({
    info: kV(e),
    featureTypes: NV(e),
    version: Wy(e)
  }))
);
jx(
  "queryWfsFeatureTypeDetails",
  self,
  ({ url: t, serviceVersion: e, featureTypeFull: r }) => {
    const n = CV(
      t,
      e,
      r.name,
      void 0,
      void 0,
      Object.keys(r.properties)
    );
    return Xx(n).then((i) => ({
      props: BV(
        zV(i, r, e)
      )
    }));
  }
);
const UV = () => [
  {
    url: "http://wmts1.geoportail.lu/opendata/service",
    label: "Open Data Webservices WMS"
  },
  {
    url: "http://ows.terrestris.de/osm-gray/service",
    label: "OpenStreetMap by Terrestris (Grey)"
  },
  {
    url: "http://ows.terrestris.de/osm/service",
    label: "OpenStreetMap by Terrestris (Color)"
  }
];
function Hx(t, e) {
  return hC(t, e, []).join("");
}
function hC(t, e, r) {
  if (t.nodeType == Node.CDATA_SECTION_NODE || t.nodeType == Node.TEXT_NODE)
    e ? r.push(String(t.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : r.push(t.nodeValue);
  else {
    var n = void 0;
    for (n = t.firstChild; n; n = n.nextSibling)
      hC(n, e, r);
  }
  return r;
}
function $V(t) {
  return "documentElement" in t;
}
function VV(t) {
  return new DOMParser().parseFromString(t, "application/xml");
}
function U0(t, e) {
  return function(r, n) {
    var i = t.call(e !== void 0 ? e : this, r, n);
    if (i !== void 0) {
      var l = n[n.length - 1];
      l.push(i);
    }
  };
}
function $o(t, e, r) {
  return function(n, i) {
    var l = t.call(r !== void 0 ? r : this, n, i);
    if (l !== void 0) {
      var h = i[i.length - 1], s = e !== void 0 ? e : n.localName, m = void 0;
      s in h ? m = h[s] : (m = [], h[s] = m), m.push(l);
    }
  };
}
function qt(t, e, r) {
  return function(n, i) {
    var l = t.call(r !== void 0 ? r : this, n, i);
    if (l !== void 0) {
      var h = i[i.length - 1], s = e !== void 0 ? e : n.localName;
      h[s] = l;
    }
  };
}
function nn(t, e, r) {
  var n = r !== void 0 ? r : {}, i, l;
  for (i = 0, l = t.length; i < l; ++i)
    n[t[i]] = e;
  return n;
}
function jV(t, e, r, n) {
  var i;
  for (i = e.firstElementChild; i; i = i.nextElementSibling) {
    var l = t[i.namespaceURI];
    if (l !== void 0) {
      var h = l[i.localName];
      h !== void 0 && h.call(n, i, r);
    }
  }
}
function On(t, e, r, n, i) {
  return n.push(t), jV(e, r, n, i), n.pop();
}
var GV = function() {
  function t() {
  }
  return t.prototype.read = function(e) {
    if (e)
      if (typeof e == "string") {
        var r = VV(e);
        return this.readFromDocument(r);
      } else
        return $V(e) ? this.readFromDocument(e) : this.readFromNode(e);
    else
      return null;
  }, t.prototype.readFromDocument = function(e) {
    for (var r = e.firstChild; r; r = r.nextSibling)
      if (r.nodeType == Node.ELEMENT_NODE)
        return this.readFromNode(r);
    return null;
  }, t.prototype.readFromNode = function(e) {
  }, t;
}();
const fC = GV;
var qV = "http://www.w3.org/1999/xlink";
function Kx(t) {
  return t.getAttributeNS(qV, "href");
}
function WV(t) {
  var e = Hx(t, !1);
  return XV(e);
}
function XV(t) {
  var e = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(t);
  if (e)
    return parseFloat(e[1]);
}
function Dl(t) {
  var e = Hx(t, !1);
  return ZV(e);
}
function ZV(t) {
  var e = /^\s*(\d+)\s*$/.exec(t);
  if (e)
    return parseInt(e[1], 10);
}
function zr(t) {
  return Hx(t, !1).trim();
}
var HV = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Po = [null, "http://www.opengis.net/ows/1.1"], KV = nn(Po, {
  ServiceIdentification: qt(bj),
  ServiceProvider: qt(Ej),
  OperationsMetadata: qt(vj)
}), YV = function(t) {
  HV(e, t);
  function e() {
    return t.call(this) || this;
  }
  return e.prototype.readFromNode = function(r) {
    var n = On({}, KV, r, []);
    return n || null;
  }, e;
}(fC), JV = nn(Po, {
  DeliveryPoint: qt(zr),
  City: qt(zr),
  AdministrativeArea: qt(zr),
  PostalCode: qt(zr),
  Country: qt(zr),
  ElectronicMailAddress: qt(zr)
}), QV = nn(Po, {
  Value: $o(Tj)
}), ej = nn(Po, {
  AllowedValues: qt(fj)
}), tj = nn(Po, {
  Phone: qt(xj),
  Address: qt(hj)
}), rj = nn(Po, {
  HTTP: qt(yj)
}), nj = nn(Po, {
  Get: $o(gj),
  Post: void 0
}), ij = nn(Po, {
  DCP: qt(mj)
}), oj = nn(Po, {
  Operation: _j
}), aj = nn(Po, {
  Voice: qt(zr),
  Facsimile: qt(zr)
}), sj = nn(Po, {
  Constraint: $o(dj)
}), lj = nn(Po, {
  IndividualName: qt(zr),
  PositionName: qt(zr),
  ContactInfo: qt(pj)
}), cj = nn(Po, {
  Abstract: qt(zr),
  AccessConstraints: qt(zr),
  Fees: qt(zr),
  Title: qt(zr),
  ServiceTypeVersion: qt(zr),
  ServiceType: qt(zr)
}), uj = nn(Po, {
  ProviderName: qt(zr),
  ProviderSite: qt(Kx),
  ServiceContact: qt(wj)
});
function hj(t, e) {
  return On({}, JV, t, e);
}
function fj(t, e) {
  return On({}, QV, t, e);
}
function dj(t, e) {
  var r = t.getAttribute("name");
  if (!!r)
    return On({ name: r }, ej, t, e);
}
function pj(t, e) {
  return On({}, tj, t, e);
}
function mj(t, e) {
  return On({}, rj, t, e);
}
function gj(t, e) {
  var r = Kx(t);
  if (!!r)
    return On({ href: r }, sj, t, e);
}
function yj(t, e) {
  return On({}, nj, t, e);
}
function _j(t, e) {
  var r = t.getAttribute("name"), n = On({}, ij, t, e);
  if (!!n) {
    var i = e[e.length - 1];
    i[r] = n;
  }
}
function vj(t, e) {
  return On({}, oj, t, e);
}
function xj(t, e) {
  return On({}, aj, t, e);
}
function bj(t, e) {
  return On({}, cj, t, e);
}
function wj(t, e) {
  return On({}, lj, t, e);
}
function Ej(t, e) {
  return On({}, uj, t, e);
}
function Tj(t, e) {
  return zr(t);
}
const Sj = YV;
var Mj = globalThis && globalThis.__extends || function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var l in i)
        Object.prototype.hasOwnProperty.call(i, l) && (n[l] = i[l]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), ds = [null, "http://www.opengis.net/wmts/1.0"], Xh = [null, "http://www.opengis.net/ows/1.1"], Cj = nn(ds, {
  Contents: qt(Bj)
}), Ij = function(t) {
  Mj(e, t);
  function e() {
    var r = t.call(this) || this;
    return r.owsParser_ = new Sj(), r;
  }
  return e.prototype.readFromNode = function(r) {
    var n = r.getAttribute("version");
    n && (n = n.trim());
    var i = this.owsParser_.readFromNode(r);
    return i ? (i.version = n, i = On(i, Cj, r, []), i || null) : null;
  }, e;
}(fC), Pj = nn(ds, {
  Layer: $o(Uj),
  TileMatrixSet: $o($j)
}), Aj = nn(ds, {
  Style: $o(Vj),
  Format: $o(zr),
  TileMatrixSetLink: $o(jj),
  Dimension: $o(Gj),
  ResourceURL: $o(qj)
}, nn(Xh, {
  Title: qt(zr),
  Abstract: qt(zr),
  WGS84BoundingBox: qt(dC),
  Identifier: qt(zr)
})), Oj = nn(ds, {
  LegendURL: $o(Wj)
}, nn(Xh, {
  Title: qt(zr),
  Identifier: qt(zr)
})), Rj = nn(ds, {
  TileMatrixSet: qt(zr),
  TileMatrixSetLimits: qt(Zj)
}), Lj = nn(ds, {
  TileMatrixLimits: U0(Hj)
}), Dj = nn(ds, {
  TileMatrix: qt(zr),
  MinTileRow: qt(Dl),
  MaxTileRow: qt(Dl),
  MinTileCol: qt(Dl),
  MaxTileCol: qt(Dl)
}), kj = nn(ds, {
  Default: qt(zr),
  Value: $o(zr)
}, nn(Xh, {
  Identifier: qt(zr)
})), Nj = nn(Xh, {
  LowerCorner: U0($0),
  UpperCorner: U0($0)
}), Fj = nn(ds, {
  WellKnownScaleSet: qt(zr),
  TileMatrix: $o(Xj)
}, nn(Xh, {
  SupportedCRS: qt(zr),
  Identifier: qt(zr),
  BoundingBox: qt(dC)
})), zj = nn(ds, {
  TopLeftCorner: qt($0),
  ScaleDenominator: qt(WV),
  TileWidth: qt(Dl),
  TileHeight: qt(Dl),
  MatrixWidth: qt(Dl),
  MatrixHeight: qt(Dl)
}, nn(Xh, {
  Identifier: qt(zr)
}));
function Bj(t, e) {
  return On({}, Pj, t, e);
}
function Uj(t, e) {
  return On({}, Aj, t, e);
}
function $j(t, e) {
  return On({}, Fj, t, e);
}
function Vj(t, e) {
  var r = On({}, Oj, t, e);
  if (!!r) {
    var n = t.getAttribute("isDefault") === "true";
    return r.isDefault = n, r;
  }
}
function jj(t, e) {
  return On({}, Rj, t, e);
}
function Gj(t, e) {
  return On({}, kj, t, e);
}
function qj(t, e) {
  var r = t.getAttribute("format"), n = t.getAttribute("template"), i = t.getAttribute("resourceType"), l = {};
  return r && (l.format = r), n && (l.template = n), i && (l.resourceType = i), l;
}
function dC(t, e) {
  var r = On([], Nj, t, e);
  if (r.length == 2)
    return x0(r);
}
function Wj(t, e) {
  var r = {};
  return r.format = t.getAttribute("format"), r.href = Kx(t), r;
}
function $0(t, e) {
  var r = zr(t).split(/\s+/);
  if (!(!r || r.length != 2)) {
    var n = +r[0], i = +r[1];
    if (!(isNaN(n) || isNaN(i)))
      return [n, i];
  }
}
function Xj(t, e) {
  return On({}, zj, t, e);
}
function Zj(t, e) {
  return On([], Lj, t, e);
}
function Hj(t, e) {
  return On({}, Dj, t, e);
}
const Kj = Ij;
class Yj {
  constructor(e) {
    ei(this, "capabilitiesPromise");
    ei(this, "serviceInfo");
    ei(this, "layers");
    const r = new Kj();
    let n = "&";
    e.indexOf("?") === -1 && (n = "?"), e.indexOf("Capabilities") === -1 && (e = e + n + "SERVICE=WMTS&REQUEST=GetCapabilities"), this.capabilitiesPromise = fetch(e).then((i) => i.text()).then((i) => {
      var h;
      const l = r.read(i);
      this.serviceInfo = this.mapServiceInfo(l.ServiceIdentification), this.layers = this.mapToRemoteLayers((h = l.Contents) == null ? void 0 : h.Layer);
    });
  }
  mapToRemoteLayers(e) {
    return [
      {
        type: ia.WMTS,
        children: e.map(
          (r) => ({
            type: ia.WMTS,
            abstract: r.Abstract,
            format: r.Format,
            name: r.Identifier,
            title: r.Title,
            tileMatrixSetLink: r.TileMatrixSetLink,
            wgs84BoundingBox: r.WGS84BoundingBox
          })
        )
      }
    ];
  }
  mapServiceInfo(e) {
    return {
      type: ia.WMTS,
      title: e.Title,
      abstract: e.Abstract,
      fees: e.Fees,
      constraints: e.AccessConstraints,
      serviceTypeVersion: e.ServiceTypeVersion
    };
  }
  isReady() {
    return this.capabilitiesPromise.then(() => this);
  }
  getLayerByName(e) {
    return this.layers[0].children.filter((r) => r.name === e)[0];
  }
  getLayers() {
    return this.layers;
  }
  getServiceInfo() {
    return this.serviceInfo;
  }
}
class Jj {
  async getRemoteEndpoint(e) {
    let r;
    return await this.getWmsEndpoint(e).isReady().catch(async () => {
      r = await this.getWmtsEndpoint(e).isReady();
    }) || r;
  }
  getWmsEndpoint(e) {
    return new IV(this.getProxyfiedUrl(e));
  }
  getWmtsEndpoint(e) {
    return new Yj(this.getProxyfiedUrl(e));
  }
  getProxyfiedUrl(e) {
    return e.indexOf("httpsproxy") > 0 ? e : jM + "?url=" + encodeURIComponent(e);
  }
  async fetchRemoteWmsEndpoint() {
    return new Promise((e) => e(UV()));
  }
  isRemoteLayer(e) {
    return typeof e == "string" && (e.indexOf(ia.WMS) === 0 || e.indexOf(ia.WMTS) === 0);
  }
}
const tu = new Jj();
function Qj(t, e) {
  var r, n;
  return t.children && !e.children || ((r = e.children) == null ? void 0 : r.length) === 0 ? 1 : e.children && !t.children || ((n = t.children) == null ? void 0 : n.length) === 0 ? -1 : 0;
}
function pC(t, e, r = 0) {
  const { name: n = "", type: i = ia.WMS, children: l } = t, h = `${i}||${e}||${n}`.split("-").join("%2D"), s = Ai();
  return {
    id: h,
    name: n,
    depth: r,
    children: l == null ? void 0 : l.sort(Qj).map((m) => pC(m, e, r + 1)),
    checked: s.hasLayer(h),
    expanded: !1
  };
}
function eG(t) {
  const e = decodeURIComponent(t), [r, n, i] = e.split("||");
  return mC({
    id: e,
    url: tu.getProxyfiedUrl(n),
    remoteLayer: { name: i, type: r }
  });
}
function mC({
  id: t,
  url: e,
  remoteLayer: r
}) {
  const { name: n = "", type: i = ia.WMS } = r;
  return {
    id: t,
    name: n,
    layers: n,
    url: e,
    type: i,
    imageType: eC.PNG
  };
}
const tG = { class: "relative text-center" }, rG = ["placeholder", "value"], nG = {
  key: 0,
  class: "text-center"
}, iG = { class: "lux-label" }, oG = {
  key: 1,
  class: "text-center"
}, aG = { class: "lux-label" }, sG = {
  key: 2,
  class: "text-center"
}, lG = /* @__PURE__ */ $e("div", { class: "fa fa-refresh fa-spin" }, null, -1), cG = {
  key: 3,
  class: "overflow-auto max-h-[calc(400px-36px)]"
}, uG = /* @__PURE__ */ vr({
  __name: "remote-layers",
  setup(t) {
    const { t: e } = Hn(), r = Ai(), n = zd(), i = yi([]), l = yi(), { remoteLayersOpen: h } = mn(di()), { setRemoteLayersOpen: s } = di();
    let m = !1, v, E, T;
    Da(S);
    function S() {
      l.value = l.value ? _d.updateLayers(
        l.value,
        r.layers
      ) : void 0;
    }
    tu.fetchRemoteWmsEndpoint().then((ee) => {
      i.value = ee.map(({ url: he, label: Te }) => ({
        label: Te,
        value: he
      }));
    });
    async function A(ee) {
      m = !0, T = await tu.getRemoteEndpoint(ee).catch(() => alert(e("Impossible de contacter ce WMS", { ns: "client" }))), E = ee, m = !1;
    }
    async function L() {
      const ee = T, he = ee == null ? void 0 : ee.getLayers();
      if (he && he[0]) {
        const Te = pC(
          he[0],
          E
        );
        l.value = _d.updateLayers(Te, r.layers);
      }
    }
    async function B(ee) {
      E = v = ee, await A(E), L();
    }
    function j(ee) {
      v = ee.target.value;
    }
    async function q() {
      await A(v), L();
    }
    function H(ee) {
      l.value = _d.toggleNode(
        ee.id,
        l.value,
        "expanded"
      );
    }
    function ne(ee) {
      const { id: he, name: Te } = ee, ve = T;
      if (ee.checked === !0)
        r.removeLayers(he);
      else {
        const Oe = ve == null ? void 0 : ve.getLayerByName(Te);
        if (Oe) {
          const Me = n.initLayer(
            mC({
              id: he,
              url: tu.getProxyfiedUrl(E),
              remoteLayer: Oe
            })
          );
          r.addLayers(Me);
        }
      }
    }
    return (ee, he) => _e(h) ? (tt(), Un(JM, {
      key: 0,
      title: _e(e)("Add external data", { ns: "client" }),
      onClose: he[0] || (he[0] = (Te) => _e(s)(!1))
    }, {
      content: jd(() => {
        var Te, ve;
        return [
          $e("div", tG, [
            $t(R2, {
              class: "lux-remote-services-dropdown",
              options: _e(i),
              placeholder: _e(e)("Predefined wms", { ns: "client" }),
              onChange: B
            }, null, 8, ["options", "placeholder"]),
            $e("input", {
              class: "lux-input w-[300px]",
              type: "url",
              placeholder: _e(e)("Choose or write a WMS url", {
                ns: "client"
              }),
              value: _e(E) || "",
              onChange: j
            }, null, 40, rG),
            $e("button", {
              type: "button",
              class: "lux-btn",
              onClick: q
            }, Vt(_e(e)("Get the layers", { ns: "client" })), 1)
          ]),
          !_e(m) && _e(T) ? (tt(), vt("div", nG, [
            $e("span", iG, Vt(_e(e)("Description du service :", {
              ns: "client"
            })), 1),
            Ag(" " + Vt((Te = _e(T).getServiceInfo()) == null ? void 0 : Te.abstract), 1)
          ])) : Tt("v-if", !0),
          !_e(m) && _e(T) ? (tt(), vt("div", oG, [
            $e("span", aG, Vt(_e(e)("Access constraints :", {
              ns: "client"
            })), 1),
            Ag(" " + Vt((ve = _e(T).getServiceInfo()) == null ? void 0 : ve.constraints), 1)
          ])) : Tt("v-if", !0),
          _e(m) ? (tt(), vt("div", sG, [
            lG,
            $e("span", null, Vt(_e(e)("Chargement des informations", {
              ns: "client"
            })), 1)
          ])) : Tt("v-if", !0),
          _e(m) ? Tt("v-if", !0) : (tt(), vt("div", cG, [
            _e(l) ? (tt(), Un(QM, {
              key: 0,
              class: "block p-[10px] mb-[11px]",
              node: _e(l),
              onToggleParent: H,
              onToggleLayer: ne
            }, null, 8, ["node"])) : Tt("v-if", !0)
          ]))
        ];
      }),
      _: 1
    }, 8, ["title"])) : Tt("v-if", !0);
  }
}), hG = /* @__PURE__ */ Mr(uG, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/remote-layers/remote-layers.vue"]]);
function fG(t, e = "fr-FR") {
  const r = new Date(t);
  return new Intl.DateTimeFormat(e).format(r);
}
const dG = { class: "font-bold" }, pG = { class: "col-span-2" }, mG = /* @__PURE__ */ vr({
  __name: "layer-metadata-item",
  props: {
    label: { type: String, required: !0 },
    value: { type: String, required: !0 }
  },
  setup(t) {
    const e = t;
    return (r, n) => (tt(), vt(pn, null, [
      $e("span", dG, Vt(e.label), 1),
      $e("span", pG, Vt(e.value), 1)
    ], 64));
  }
}), Jf = /* @__PURE__ */ Mr(mG, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-metadata/layer-metadata-item.vue"]]);
function gG(t) {
  return {
    fr: "fre",
    en: "eng",
    de: "ger",
    lb: "ltz"
  }[t.toLowerCase()];
}
function yG(t) {
  return new DOMParser().parseFromString(t, "text/html").body;
}
function _G(t) {
  const e = [];
  function r(n) {
    const i = n.split("|");
    i[3] === "WWW:LINK-1.0-http--link" && e.indexOf(i[2]) === -1 && e.push(i[2]);
  }
  return Array.isArray(t) ? t.forEach(r, t) : r(t), e;
}
function vG(t) {
  const r = (Array.isArray(t) ? t : [t]).filter((n) => n.split("|")[1] === "metadata");
  return {
    organisaton: r[0].split("|")[2],
    name: r[0].split("|")[5],
    unknown: r[0].split("|")[6],
    address: r[0].split("|")[7],
    email: r[0].split("|")[4]
  };
}
class gC {
}
class xG extends gC {
  async getMetadata(e, r, n) {
    console.assert(e === ia.WMS);
    const i = tu.getWmsEndpoint(r);
    await i.isReady();
    const l = i == null ? void 0 : i.getServiceInfo(), h = i == null ? void 0 : i.getLayerByName(n);
    return {
      title: h.title,
      description: h.abstract,
      keywords: l.keywords,
      accessConstraints: l.constraints,
      serviceDescription: l.abstract
    };
  }
}
const bG = new xG();
class wG extends gC {
  async getMetadata(e, r, n) {
    console.assert(e === ia.WMTS);
    const i = tu.getWmtsEndpoint(r);
    await i.isReady();
    const l = i == null ? void 0 : i.getServiceInfo(), h = i == null ? void 0 : i.getLayerByName(n);
    return {
      title: h.title,
      description: h.abstract,
      accessConstraints: l.constraints,
      serviceDescription: l.abstract
    };
  }
}
const EG = new wG();
class TG {
  async getMetadata(e, r, n) {
    if (e === ia.WMS)
      return bG.getMetadata(e, r, n);
    if (e === ia.WMTS)
      return EG.getMetadata(e, r, n);
    throw new Error(`Unsupported service type: ${e}`);
  }
}
const SG = new TG();
class MG {
  constructor() {
    ei(this, "geonetworkBaseUrl", "https://geocatalogue.geoportail.lu/geonetwork/srv");
    ei(this, "legendBaseUrl", "https://map.geoportail.lu/legends/get_html");
    ei(this, "localMetadataBaseUrl", "https://map.geoportail.lu/getMetadata");
  }
  async getLayerMetadata(e, r) {
    const n = $l().findBgLayerById(+e) || $l().findById(+e);
    if (n) {
      const i = n.metadata, l = i == null ? void 0 : i.metadata_id, h = l && await this.getLocalMetadata(
        this.localMetadataBaseUrl,
        l,
        r
      ), s = n.name, m = (i == null ? void 0 : i.legend_name) || "", v = n == null ? void 0 : n.id, E = m && await this.getLegendHtml(
        this.legendBaseUrl,
        m,
        v,
        r
      );
      return {
        ...h,
        title: s,
        hasLegend: !!E,
        ...E && { legendHtml: E }
      };
    } else {
      const [i, l, h] = String(e).split("%2D").join("-").split("||");
      return SG.getMetadata(
        i,
        l,
        h
      );
    }
  }
  getLocalMetadata(e, r, n) {
    return fetch(`${e}?lang=${n}&uid=${r}`).then(async (i) => {
      const l = (await i.json()).metadata;
      return {
        name: l.title,
        serviceDescription: l.serviceDescription,
        description: l.abstract,
        legalConstraints: l.legalConstraints,
        link: _G(l.link),
        revisionDate: l.revisionDate,
        keyword: l.keyword,
        responsibleParty: l.responsibleParty ? vG(l.responsibleParty) : void 0,
        metadataLink: `${this.geonetworkBaseUrl}/${gG(
          n
        )}/catalog.search#/metadata/${r}`,
        isError: !1
      };
    }).catch(() => ({ isError: !0 }));
  }
  getLegendHtml(e, r, n, i) {
    const l = {
      lang: i,
      ...r && { name: r },
      ...n && { id: n.toString() }
    };
    if (l.name && l.lang) {
      window.devicePixelRatio > 1 && (l.dpi = (window.devicePixelRatio * 96).toString());
      const h = `${e}?${new URLSearchParams(
        l
      ).toString()}`;
      return fetch(h).then(async (s) => {
        if (s.status >= 400 && s.status < 600)
          throw new Error("Server responded with error code");
        const m = await s.text();
        return m ? yG(m) : void 0;
      }).catch(() => {
      });
    }
  }
}
const iT = new MG(), CG = { class: "grid gap-2 grid-cols-3 pt-3 text-[13px] font-arial break-words" }, IG = {
  key: 2,
  class: "col-span-3 grid gap-2 grid-cols-3"
}, PG = { class: "font-bold" }, AG = { class: "col-span-2" }, OG = ["title"], RG = ["title"], LG = {
  key: 4,
  class: "col-span-3"
}, DG = { class: "font-bold" }, kG = { class: "col-span-2" }, NG = ["href"], FG = {
  key: 7,
  class: "col-span-3 grid gap-2 grid-cols-3"
}, zG = { class: "font-bold" }, BG = { class: "col-span-2" }, UG = { key: 0 }, $G = { key: 1 }, VG = { key: 2 }, jG = { key: 3 }, GG = { key: 4 }, qG = ["href"], WG = {
  key: 8,
  class: "grid gap-2 grid-cols-3 col-span-3"
}, XG = { class: "font-bold" }, ZG = { class: "col-span-2" }, HG = ["href"], KG = {
  key: 9,
  class: "col-span-3"
}, YG = { key: 10 }, JG = { class: "text-xl" }, QG = {
  key: 11,
  class: "col-span-3"
}, e7 = /* @__PURE__ */ vr({
  __name: "layer-metadata",
  setup(t) {
    const e = Vx(), { metadataId: r } = mn(e), { t: n, i18next: i } = Hn(), l = Kr(), h = Kr(!0), s = 220;
    An(r, async (S) => {
      var A, L;
      l.value = S ? await iT.getLayerMetadata(S, i.language) : void 0, h.value = (((L = (A = l.value) == null ? void 0 : A.description) == null ? void 0 : L.length) || 0) < s;
    }), aa(() => {
      i.on("languageChanged", async () => {
        r.value && (l.value = await iT.getLayerMetadata(
          r.value,
          i.language
        ));
      });
    });
    const m = un(
      () => {
        var S, A, L;
        return h.value ? (S = l.value) == null ? void 0 : S.description : (L = (A = l.value) == null ? void 0 : A.description) == null ? void 0 : L.slice(0, s);
      }
    );
    function v() {
      h.value = !0;
    }
    function E() {
      h.value = !1;
    }
    function T() {
      e.clearMetadataId();
    }
    return (S, A) => {
      const L = xO("dompurify-html");
      return l.value ? (tt(), Un(JM, {
        key: 0,
        footer: !1,
        "max-height": !0,
        title: _e(n)(`${l.value.title}`, { ns: "client" }),
        onClose: T
      }, {
        content: jd(() => {
          var B, j, q, H, ne, ee, he, Te, ve, Oe, Me, Re, He, Ve, dt;
          return [
            $e("div", CG, [
              l.value.name ? (tt(), Un(Jf, {
                key: 0,
                label: _e(n)("Name"),
                value: l.value.name
              }, null, 8, ["label", "value"])) : Tt("v-if", !0),
              l.value.serviceDescription ? (tt(), Un(Jf, {
                key: 1,
                label: _e(n)("Description du Service"),
                value: l.value.serviceDescription
              }, null, 8, ["label", "value"])) : Tt("v-if", !0),
              l.value.description ? (tt(), vt("div", IG, [
                $e("span", PG, Vt(_e(n)("Description")), 1),
                $e("span", AG, [
                  Fb($e("span", null, null, 512), [
                    [L, _e(m)]
                  ]),
                  h.value ? Tt("v-if", !0) : (tt(), vt("button", {
                    key: 0,
                    title: _e(n)("Display full description", {
                      ns: "client"
                    }),
                    onClick: v,
                    class: "text-secondary hover:underline"
                  }, " ... ", 8, OG)),
                  h.value && (((B = _e(m)) == null ? void 0 : B.length) || 0) > s ? (tt(), vt("button", {
                    key: 1,
                    title: _e(n)("Hide full description", {
                      ns: "client"
                    }),
                    onClick: E,
                    class: "text-secondary hover:underline"
                  }, " - ", 8, RG)) : Tt("v-if", !0)
                ])
              ])) : Tt("v-if", !0),
              l.value.legalConstraints ? (tt(), Un(Jf, {
                key: 3,
                label: _e(n)("Contrainte d'utilisation"),
                value: l.value.legalConstraints
              }, null, 8, ["label", "value"])) : Tt("v-if", !0),
              ((j = l.value.link) == null ? void 0 : j.length) !== 0 ? (tt(), vt("div", LG, [
                (tt(!0), vt(pn, null, ka(l.value.link, (xe) => (tt(), vt("div", {
                  class: "grid gap-2 grid-cols-3",
                  key: xe
                }, [
                  $e("span", DG, Vt(_e(n)("Url vers la resource")), 1),
                  $e("span", kG, [
                    $e("a", {
                      class: "text-secondary hover:underline",
                      target: "_blank",
                      href: xe
                    }, Vt(xe), 9, NG)
                  ])
                ]))), 128))
              ])) : Tt("v-if", !0),
              l.value.revisionDate ? (tt(), Un(Jf, {
                key: 5,
                label: _e(n)("Revision date"),
                value: _e(fG)(l.value.revisionDate, _e(i).language)
              }, null, 8, ["label", "value"])) : Tt("v-if", !0),
              l.value.keyword ? (tt(), Un(Jf, {
                key: 6,
                label: _e(n)("Keywords"),
                value: (q = l.value.keyword) == null ? void 0 : q.join(",")
              }, null, 8, ["label", "value"])) : Tt("v-if", !0),
              l.value.responsibleParty ? (tt(), vt("div", FG, [
                $e("div", zG, Vt(_e(n)("Contact")), 1),
                $e("div", BG, [
                  (H = l.value.responsibleParty) != null && H.organisaton ? (tt(), vt("p", UG, Vt((ne = l.value.responsibleParty) == null ? void 0 : ne.organisaton), 1)) : Tt("v-if", !0),
                  (ee = l.value.responsibleParty) != null && ee.name ? (tt(), vt("p", $G, Vt((he = l.value.responsibleParty) == null ? void 0 : he.name), 1)) : Tt("v-if", !0),
                  (Te = l.value.responsibleParty) != null && Te.unknown ? (tt(), vt("p", VG, Vt((ve = l.value.responsibleParty) == null ? void 0 : ve.unknown), 1)) : Tt("v-if", !0),
                  (Oe = l.value.responsibleParty) != null && Oe.address ? (tt(), vt("p", jG, Vt((Me = l.value.responsibleParty) == null ? void 0 : Me.address), 1)) : Tt("v-if", !0),
                  (Re = l.value.responsibleParty) != null && Re.email ? (tt(), vt("p", GG, [
                    $e("a", {
                      class: "text-secondary hover:underline",
                      href: "mailto:" + ((He = l.value.responsibleParty) == null ? void 0 : He.email)
                    }, Vt((Ve = l.value.responsibleParty) == null ? void 0 : Ve.email), 9, qG)
                  ])) : Tt("v-if", !0)
                ])
              ])) : Tt("v-if", !0),
              l.value.metadataLink ? (tt(), vt("div", WG, [
                $e("span", XG, Vt(_e(n)("Link to the metadata")), 1),
                $e("span", ZG, [
                  $e("a", {
                    class: "text-secondary hover:underline",
                    target: "_blank",
                    href: l.value.metadataLink
                  }, Vt(_e(n)("link")), 9, HG)
                ])
              ])) : Tt("v-if", !0),
              l.value.isError ? (tt(), vt("div", KG, Vt(_e(n)("The metadata is right now not available")), 1)) : Tt("v-if", !0),
              l.value.legendHtml ? (tt(), vt("div", YG, [
                $e("h4", JG, Vt(_e(n)("Legend")), 1),
                Fb($e("span", null, null, 512), [
                  [L, (dt = l.value.legendHtml) == null ? void 0 : dt.innerHTML]
                ])
              ])) : Tt("v-if", !0),
              l.value.hasLegend ? Tt("v-if", !0) : (tt(), vt("div", QG, Vt(_e(n)("The legend is not available for this layer")), 1))
            ])
          ];
        }),
        _: 1
      }, 8, ["title"])) : Tt("v-if", !0);
    };
  }
}), t7 = /* @__PURE__ */ Mr(e7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-metadata/layer-metadata.vue"]]), r7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM0AAAAoCAMAAABq645qAAACPVBMVEUAAABaW13////tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy5DjxTaAAAAvXRSTlMAAAABAgMEBQYHCAkKCwwNDg8QERESFBUWFxkaGx0eHyAhIiInKSosMTIzNTY5Ojs8PUFCQ0RERkpMTk9QU1RVVldaXmFjZWZmamtwcXJzdXd3eHl7fX+AgYKDhIaHiIiKi4yOj5CTlJWWl5iZmZqcnZ+goaKjpKanqKqqq6ywsbK0tbW4u7u8vb6/wMHExcbHysvMzM7P0NDS1NXa29zd3t/g4eTl5ujp6uvs7e7u8PLz9PX29/j5+vv8/f5cALqzAAAEcklEQVRo3u3Z+ZPUVBAH8O63LsLKijoIgotHFI+HgiKNeGC8MCqgUUFAJYjgAQ6HKMgGEQQiqChIPFh1iciiwPIEhvv49t/mD5lBORa2tHbLTO2rmqnUTCrJZ3r65ZuEjDHGGLrMWGcKMah7mh/7NP8PzXBqbqgfzdtPb7i/fjQPvq8r5jUVXNNIY4moYeL6+XNfn9Ov6LUZ2/Z7Pxo3YaZWTp/uLPw/reXYbqLRPz/38g+qJ/oTEV396IzmgmquXHZoIRHd/sTs31T1DqIBcyqHZjQWtTbf6nQiokHLVVWn7ju4euXGjsX9LtTAGgPAGGMzOPZSOGFYtmAXsO8skFkgZovQgi2QcZKyIGAAjJQtIgAB/5vRTc2IvbqSqOWNJQdUVdfe+/zitmsu2jeQ/GWMC43HacRhxhAWcJRyEgmYBSVYgROwgJkzeGVEDGEGotqnPaih1Xp63KSvVFVVtz0wt23AvMVda5AZY2FM7OWO/N2DwBMgESBiQZyABUgYSYQkYSBjhAh7QXN3Zfey7YdyzXh6aQpdu2fIpWsD30CykKOU4XPgmBPEnNcmC1jgIT9uCx9ZkOW1kQi9oBm6aMvO3KIVomUPES19/KIaoNo34uA8cUgtB4DzmQXCFoCFhbXgMtgC8DNGKMj7xnIKtj2toeGf55X5c9+ZRpo1lWjyq5c/33Avj+5obpz25miiwd+p6q4/2jfvIrqtrYlemF5MzZObTuhHCw6cUd2y/91ftj5DRJOn0JKniqm56jPtUNXDx44u6NywvaPzPqL+G5v3jCimhhqaX/vyi6VTxtzyYkVV9dSsRvrmnVXUI5oo7GkNEV2RH/igaRVV1Y8fOdE+tEc0tlzqBU1tND+7U1W18t51F8/QAFJrkUccL4VjABFb+MwoMyznszWzBZxfDT2SIbZgm0/TzBbIpLqcr8GwScJxfF4UiliAgGEZ1gKx8VK4bmuafmpdrqr6cFdXBJBSORPkp9A0ZI8hAi4jYQY8CEN8MDML2K/FBBdwKU80kOp3eSBirq7BkJJLstK5UShw+eYhDBGUYNPQeN3WTND2rd+r6oquNUZQ00A49gCEJQg8RhJD8j0DQX6IEBZYMLMAAANZrpHa8lkNBwjOi0Ion90KRIDIQEzsdVfzlurhT1X11F2XqE3qwfNQMiYLGYIYNgAQMcTltXHV3z9w1dAD/8LapH/XJt9eycWudG4U8lGrjYeSIAtMFlaD1SU1NxAR0cA9qrpqr6ruaOmybxLPREBojLEOzoMNkAXsO4YNYRnIpNo3WS30+EByXt+kttY3AEdAyGmZ4/TcKORCDgDhEAg5D0wO7vK1mbmwhajxA9XWkXTTh8dVj6wZX9gr6ZFL9eTm1nbVhUREdOs2Vb25sJqmRTuOq+r+rwfmgGEHVYcU+H7a8KNrdP6kYTXBJ6qPFVjT2DxwzD/msbWqE+vnrvqvevSeutGMUm0dXC+ahk3asb5unt+8cvLIqOvr52nU7Dv7nq31afo0/0mzrhiavwAx1n2SsZnMdgAAAABJRU5ErkJggg==";
class n7 {
  bootstrap() {
    this.restore();
    let e;
    e = Da(() => {
      this.persist(), e && e();
    });
  }
  persist() {
    const e = di(), { lang: r } = mn(e);
    An(
      r,
      (n, i) => {
        i !== n && (Sr.setValue(Bl, n), document.documentElement.setAttribute("lang", n));
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Sr.getValue(Bl);
    if (e) {
      const { setLang: r } = di(), { i18next: n } = Hn();
      n.changeLanguage(e), r(e);
    }
  }
}
const i7 = new n7(), o7 = /* @__PURE__ */ vr({
  __name: "language-selector",
  setup(t) {
    const { i18next: e, t: r } = Hn(), { setLang: n } = di(), { lang: i } = mn(di()), l = un(
      () => ["en", "de", "fr", "lb"].map((m) => ({
        label: r(m),
        value: m,
        ariaLabel: r("Changer de langue : {{lang}}", { lang: m })
      }))
    ), h = r("Changer de langue");
    i7.bootstrap();
    function s(m) {
      e.changeLanguage(m), n(m);
    }
    return (m, v) => (tt(), vt("div", null, [
      $t(R2, {
        class: "lux-navbar-dropdown lux-dropdown-inline text-white h-full",
        options: _e(l),
        placeholder: _e(h),
        modelValue: _e(i),
        "onUpdate:modelValue": v[0] || (v[0] = (E) => tn(i) ? i.value = E : null),
        onChange: s
      }, null, 8, ["options", "placeholder", "modelValue"])
    ]));
  }
}), a7 = /* @__PURE__ */ Mr(o7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/nav-bars/language-selector.vue"]]);
class s7 {
  setCurrentThemeColors(e) {
    const r = document.querySelector(":root");
    ["primary", "secondary", "tertiary"].forEach((i) => {
      const l = getComputedStyle(r).getPropertyValue(
        `--${e}-${i}`
      );
      r.style.setProperty(`--color-${i}`, l);
    });
  }
}
const l7 = new s7(), c7 = { class: "w-full h-14 flex bg-white shadow-header z-10 shrink-0" }, u7 = /* @__PURE__ */ $e("div", { class: "flex-2 p-[5px]" }, [
  /* @__PURE__ */ $e("img", { src: r7 })
], -1), h7 = /* @__PURE__ */ $e("div", { class: "grow text-center" }, "search", -1), f7 = { class: "h-full flex" }, d7 = { class: "hidden lg:inline-block" }, p7 = { class: "border-l-[1px] border-stone-300 h-full" }, m7 = /* @__PURE__ */ vr({
  __name: "header-bar",
  setup(t) {
    const { t: e } = Hn(), r = di(), { layersOpen: n, myLayersTabOpen: i, themeGridOpen: l } = mn(r), { setLayersOpen: h, setMyLayersTabOpen: s, setThemeGridOpen: m } = r, v = Co(), { theme: E } = mn(v);
    An(
      E,
      (S) => {
        S && l7.setCurrentThemeColors(S.name);
      },
      { immediate: !0 }
    );
    function T() {
      n.value ? n.value && (l.value ? h(!1) : (i.value && s(!1), m(!0))) : (h(!0), i.value && s(!1), m(!0));
    }
    return (S, A) => {
      var L, B;
      return tt(), vt("header", c7, [
        u7,
        h7,
        $e("div", null, [
          $e("ul", f7, [
            $e("li", null, [
              $e("button", {
                class: Or(["flex items-center before:font-icons before:text-3xl before:w-16 text-primary uppercase h-full mr-3", `before:content-${(L = _e(E)) == null ? void 0 : L.name}`]),
                onClick: T
              }, [
                $e("span", d7, Vt(_e(e)(`${(B = _e(E)) == null ? void 0 : B.name}`)), 1)
              ], 2)
            ]),
            $e("li", p7, [
              $t(a7, { class: "flex-none h-full" })
            ])
          ])
        ])
      ]);
    };
  }
}), g7 = /* @__PURE__ */ Mr(m7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/header/header-bar.vue"]]), y7 = { class: "block text-[13px] sm:text-base uppercase" }, _7 = /* @__PURE__ */ vr({
  __name: "button-icon",
  props: {
    label: { type: String, required: !0 },
    icon: { type: String, required: !0 },
    active: { type: Boolean, required: !1 }
  },
  setup(t) {
    const e = t;
    return (r, n) => (tt(), vt("button", {
      class: Or(["h-[42px] w-full sm:h-full sm:w-16 hover:text-white hover:bg-primary", e.active ? "bg-primary text-white" : ""])
    }, [
      $e("span", {
        class: Or(["block text-[1.7rem] sm:text-[2rem] -mt-1.5 -mb-3 after:font-icons", e.active ? "lux-close-cross" : `after:content-${e.icon}`])
      }, null, 2),
      $e("span", y7, Vt(e.label), 1)
    ], 2));
  }
}), Os = /* @__PURE__ */ Mr(_7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/footer/button-icon.vue"]]), v7 = ["href"], x7 = /* @__PURE__ */ vr({
  __name: "button-link",
  props: {
    label: { type: String, required: !0 },
    link: { type: String, required: !0 }
  },
  setup(t) {
    const e = t;
    return (r, n) => (tt(), vt("a", {
      class: "h-full flex flex-col justify-center px-[7px] uppercase hover:text-white hover:bg-primary",
      href: `${e.link}`,
      target: "_blank"
    }, Vt(r.$props.label), 9, v7));
  }
}), xl = /* @__PURE__ */ Mr(x7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/footer/button-link.vue"]]), b7 = { class: "flex flex-col w-12 justify-between bg-white z-5 shrink-0 sm:flex-row sm:w-full sm:h-14 sm:shadow-footer" }, w7 = { class: "flex flex-col w-full sm:w-80 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" }, E7 = { class: "flex flex-col w-12 sm:w-64 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" }, T7 = { class: "w-[466px] hidden sm:flex flex-row justify-end text-gray-500 whitespace-nowrap" }, S7 = /* @__PURE__ */ vr({
  __name: "footer-bar",
  setup(t) {
    const { t: e, i18next: r } = Hn(), { setLayersOpen: n } = di(), { layersOpen: i } = mn(di());
    return (l, h) => (tt(), vt("footer", b7, [
      Tt(" left buttons "),
      $e("ul", w7, [
        $e("li", null, [
          $t(Os, {
            label: _e(e)("Layers", { ns: "client" }),
            icon: "layers",
            active: _e(i),
            onClick: h[0] || (h[0] = () => _e(n)(!_e(i)))
          }, null, 8, ["label", "active"])
        ]),
        Tt(`TODOs in each button when implemented
        - remove class="text-gray-300"
        - add click handler that calls setLayersOpen(true) and opens tool (also via app store)
      `),
        $e("li", null, [
          $t(Os, {
            class: "text-gray-300",
            label: _e(e)("My Maps", { ns: "client" }),
            icon: "mymaps"
          }, null, 8, ["label"])
        ]),
        $e("li", null, [
          $t(Os, {
            class: "text-gray-300",
            label: _e(e)("Infos", { ns: "client" }),
            icon: "infos"
          }, null, 8, ["label"])
        ]),
        $e("li", null, [
          $t(Os, {
            class: "text-gray-300",
            label: _e(e)("Legends", { ns: "client" }),
            icon: "legends"
          }, null, 8, ["label"])
        ]),
        $e("li", null, [
          $t(Os, {
            class: "text-gray-300",
            label: _e(e)("Routing", { ns: "client" }),
            icon: "routing"
          }, null, 8, ["label"])
        ])
      ]),
      Tt(" center buttons "),
      $e("div", E7, [
        $t(Os, {
          class: "text-gray-300",
          label: _e(e)("Dessin", { ns: "client" }),
          icon: "draw"
        }, null, 8, ["label"]),
        $t(Os, {
          class: "text-gray-300 hidden sm:block",
          label: _e(e)("Mesurer", { ns: "client" }),
          icon: "measure"
        }, null, 8, ["label"]),
        $t(Os, {
          class: "text-gray-300 hidden sm:block",
          label: _e(e)("Imprimer", { ns: "client" }),
          icon: "print"
        }, null, 8, ["label"]),
        $t(Os, {
          class: "text-gray-300",
          label: _e(e)("Partager", { ns: "client" }),
          icon: "share"
        }, null, 8, ["label"])
      ]),
      Tt(" right buttons "),
      $e("div", T7, [
        $t(xl, {
          class: "hidden lg:flex",
          label: _e(e)("What's new", { ns: "client" }),
          link: `https://geoportail.lu/${_e(r).language}/questions/whats-new/`
        }, null, 8, ["label", "link"]),
        Tt("TODO get geonetworkBaseUrl from config"),
        $t(xl, {
          class: "hidden lg:flex",
          label: _e(e)("Geocatalogue", { ns: "client" }),
          link: ""
        }, null, 8, ["label"]),
        Tt("TODO handle feedback links (for different portals?)"),
        $t(xl, {
          class: "hidden lg:flex",
          label: _e(e)("Feedback", { ns: "client" }),
          link: ""
        }, null, 8, ["label"]),
        $t(xl, {
          class: "hidden lg:flex",
          label: _e(e)("A Propos", { ns: "client" }),
          link: `https://www.geoportail.lu/${_e(r).language}/propos/`
        }, null, 8, ["label", "link"]),
        $t(xl, {
          class: "hidden lg:flex",
          label: _e(e)("Aide", { ns: "client" }),
          link: `https://www.geoportail.lu/${_e(r).language}/documentation/`
        }, null, 8, ["label", "link"]),
        $t(xl, {
          class: "hidden lg:flex",
          label: _e(e)("Contact", { ns: "client" }),
          link: `https://www.geoportail.lu/${_e(r).language}/propos/contactez-nous/`
        }, null, 8, ["label", "link"]),
        $t(xl, {
          label: _e(e)("Legalites", { ns: "client" }),
          link: `https://www.geoportail.lu/${_e(r).language}/propos/mentions-legales/`
        }, null, 8, ["label", "link"]),
        $t(xl, {
          label: _e(e)("ACT", { ns: "client" }),
          link: "http://www.act.public.lu/"
        }, null, 8, ["label", "link"])
      ])
    ]));
  }
}), M7 = /* @__PURE__ */ Mr(S7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/footer/footer-bar.vue"]]), C7 = { class: "flex flex-row flex-wrap pl-2.5" }, I7 = ["onClick"], P7 = { class: "text-2xl absolute top-5" }, A7 = /* @__PURE__ */ vr({
  __name: "theme-grid",
  props: {
    themes: { type: Array, required: !0 }
  },
  setup(t) {
    const e = t, { t: r } = Hn();
    return (n, i) => (tt(), vt("div", C7, [
      (tt(!0), vt(pn, null, ka(e.themes, (l) => (tt(), vt("button", {
        class: Or(["relative shrink-0 h-[150px] w-1/2 px-2.5 text-start text-gray-100/40 uppercase hover:bg-[#ccc]", `bg-${l.name}-primary hover:text-${l.name}-primary`]),
        key: l.id,
        onClick: (h) => n.$emit("setTheme", l.name)
      }, [
        $e("div", P7, Vt(_e(r)(`${l.name}`)), 1),
        $e("div", {
          class: Or(["text-6xl absolute bottom-1 after:font-icons", `after:content-${l.name}`])
        }, null, 2)
      ], 10, I7))), 128))
    ]));
  }
}), O7 = /* @__PURE__ */ Mr(A7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/theme-selector/theme-grid.vue"]]), R7 = ["aria-expanded"], L7 = { class: "py-0.5" }, D7 = { class: "px-1 py-0.5 shrink-0 flex flex-row text-[12px] bg-secondary text-white" }, k7 = { class: "py-[3px]" }, N7 = { class: "flex flex-row flex-wrap ml-1 w-12" }, F7 = /* @__PURE__ */ vr({
  __name: "theme-selector-button",
  props: {
    themes: { type: Array, required: !0 },
    currentTheme: { type: null, required: !1 },
    isOpen: { type: Boolean, required: !1 }
  },
  setup(t) {
    const e = t, { t: r } = Hn(), n = un(() => {
      var i;
      return ((i = e.themes) == null ? void 0 : i.slice(0, 8)) || [];
    });
    return (i, l) => {
      var h;
      return tt(), vt("button", {
        class: "w-full flex flex-row justify-between bg-tertiary text-white px-2 py-1.5 uppercase cursor-pointer hover:bg-white hover:text-primary",
        "aria-expanded": e.isOpen
      }, [
        $e("span", L7, Vt(_e(r)("Theme")) + ": " + Vt(_e(r)(`${(h = e.currentTheme) == null ? void 0 : h.name}`)), 1),
        $e("span", D7, [
          $e("span", k7, Vt(_e(r)("Changer")), 1),
          $e("span", N7, [
            (tt(!0), vt(pn, null, ka(_e(n), (s) => (tt(), vt("div", {
              class: Or(`h-2.5 w-2.5 m-px bg-${s.name}-primary`),
              key: s.id
            }, null, 2))), 128))
          ])
        ])
      ], 8, R7);
    };
  }
}), z7 = /* @__PURE__ */ Mr(F7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/theme-selector/theme-selector-button.vue"]]), B7 = {
  key: 0,
  class: "absolute inset-x-0 top-14 bottom-0 mt-1 bg-primary overflow-y-auto overflow-x-hidden"
}, U7 = /* @__PURE__ */ vr({
  __name: "theme-selector",
  setup(t) {
    const e = di(), { setThemeGridOpen: r } = e, { themeGridOpen: n } = mn(e), i = Co(), l = $l(), { theme: h, themes: s } = mn(i), m = un(
      () => {
        var T;
        return ((T = s.value) == null ? void 0 : T.filter(
          (S) => {
            var A;
            return ((A = S.metadata) == null ? void 0 : A.display_in_switcher) === !0;
          }
        )) || [];
      }
    );
    function v() {
      r(!n.value);
    }
    function E(T) {
      l.setTheme(T), v();
    }
    return (T, S) => (tt(), vt(pn, null, [
      $t(z7, {
        onClick: v,
        themes: _e(m),
        currentTheme: _e(h),
        isOpen: _e(n)
      }, null, 8, ["themes", "currentTheme", "isOpen"]),
      _e(n) ? (tt(), vt("div", B7, [
        $t(O7, {
          onSetTheme: E,
          themes: _e(m)
        }, null, 8, ["themes"])
      ])) : Tt("v-if", !0)
    ], 64));
  }
}), $7 = /* @__PURE__ */ Mr(U7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/theme-selector/theme-selector.vue"]]);
function yC(t, e = 0) {
  const { name: r, id: n, children: i, metadata: l } = t;
  return {
    name: r,
    id: n,
    depth: e,
    children: i == null ? void 0 : i.map((h) => yC(h, e + 1)),
    checked: !1,
    expanded: (l == null ? void 0 : l.is_expanded) || !1
  };
}
const V7 = /* @__PURE__ */ vr({
  __name: "catalog-tree",
  setup(t) {
    const e = Ai(), r = Co(), n = zd(), i = yi();
    Da(l);
    function l() {
      var m;
      if (r.theme && e.layers) {
        const v = i.value && i.value.id === ((m = r.theme) == null ? void 0 : m.id) ? i.value : yC(r.theme);
        i.value = _d.updateLayers(
          v,
          e.layers
        );
      }
    }
    function h(m) {
      i.value = _d.toggleNode(
        m.id,
        i.value,
        "expanded"
      );
    }
    function s(m) {
      n.toggleLayer(+m.id, !m.checked);
    }
    return (m, v) => _e(i) ? (tt(), Un(QM, {
      node: _e(i),
      key: _e(i).id,
      onToggleParent: h,
      onToggleLayer: s
    }, null, 8, ["node"])) : Tt("v-if", !0);
  }
}), j7 = /* @__PURE__ */ Mr(V7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/catalog/catalog-tree.vue"]]), G7 = /* @__PURE__ */ vr({
  __name: "catalog-tab",
  setup(t) {
    const { themeGridOpen: e } = mn(di());
    return (r, n) => (tt(), vt(pn, null, [
      $t($7),
      _e(e) === !1 ? (tt(), Un(j7, {
        key: 0,
        class: "pt-5 absolute inset-x-2.5 bg-primary overflow-y-auto overflow-x-hidden"
      })) : Tt("v-if", !0)
    ], 64));
  }
}), q7 = /* @__PURE__ */ Mr(G7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/catalog/catalog-tab.vue"]]);
/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function oT(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function us(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? oT(Object(r), !0).forEach(function(n) {
      W7(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : oT(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function pg(t) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? pg = function(e) {
    return typeof e;
  } : pg = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, pg(t);
}
function W7(t, e, r) {
  return e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function Gs() {
  return Gs = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, Gs.apply(this, arguments);
}
function X7(t, e) {
  if (t == null)
    return {};
  var r = {}, n = Object.keys(t), i, l;
  for (l = 0; l < n.length; l++)
    i = n[l], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
  return r;
}
function Z7(t, e) {
  if (t == null)
    return {};
  var r = X7(t, e), n, i;
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(t);
    for (i = 0; i < l.length; i++)
      n = l[i], !(e.indexOf(n) >= 0) && (!Object.prototype.propertyIsEnumerable.call(t, n) || (r[n] = t[n]));
  }
  return r;
}
var H7 = "1.15.0";
function Us(t) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(t);
}
var Hs = Us(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), up = Us(/Edge/i), aT = Us(/firefox/i), vd = Us(/safari/i) && !Us(/chrome/i) && !Us(/android/i), _C = Us(/iP(ad|od|hone)/i), vC = Us(/chrome/i) && Us(/android/i), xC = {
  capture: !1,
  passive: !1
};
function Hr(t, e, r) {
  t.addEventListener(e, r, !Hs && xC);
}
function Vr(t, e, r) {
  t.removeEventListener(e, r, !Hs && xC);
}
function oy(t, e) {
  if (!!e) {
    if (e[0] === ">" && (e = e.substring(1)), t)
      try {
        if (t.matches)
          return t.matches(e);
        if (t.msMatchesSelector)
          return t.msMatchesSelector(e);
        if (t.webkitMatchesSelector)
          return t.webkitMatchesSelector(e);
      } catch {
        return !1;
      }
    return !1;
  }
}
function K7(t) {
  return t.host && t !== document && t.host.nodeType ? t.host : t.parentNode;
}
function Ha(t, e, r, n) {
  if (t) {
    r = r || document;
    do {
      if (e != null && (e[0] === ">" ? t.parentNode === r && oy(t, e) : oy(t, e)) || n && t === r)
        return t;
      if (t === r)
        break;
    } while (t = K7(t));
  }
  return null;
}
var sT = /\s+/g;
function zo(t, e, r) {
  if (t && e)
    if (t.classList)
      t.classList[r ? "add" : "remove"](e);
    else {
      var n = (" " + t.className + " ").replace(sT, " ").replace(" " + e + " ", " ");
      t.className = (n + (r ? " " + e : "")).replace(sT, " ");
    }
}
function rr(t, e, r) {
  var n = t && t.style;
  if (n) {
    if (r === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? r = document.defaultView.getComputedStyle(t, "") : t.currentStyle && (r = t.currentStyle), e === void 0 ? r : r[e];
    !(e in n) && e.indexOf("webkit") === -1 && (e = "-webkit-" + e), n[e] = r + (typeof r == "string" ? "" : "px");
  }
}
function Oh(t, e) {
  var r = "";
  if (typeof t == "string")
    r = t;
  else
    do {
      var n = rr(t, "transform");
      n && n !== "none" && (r = n + " " + r);
    } while (!e && (t = t.parentNode));
  var i = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return i && new i(r);
}
function bC(t, e, r) {
  if (t) {
    var n = t.getElementsByTagName(e), i = 0, l = n.length;
    if (r)
      for (; i < l; i++)
        r(n[i], i);
    return n;
  }
  return [];
}
function os() {
  var t = document.scrollingElement;
  return t || document.documentElement;
}
function gi(t, e, r, n, i) {
  if (!(!t.getBoundingClientRect && t !== window)) {
    var l, h, s, m, v, E, T;
    if (t !== window && t.parentNode && t !== os() ? (l = t.getBoundingClientRect(), h = l.top, s = l.left, m = l.bottom, v = l.right, E = l.height, T = l.width) : (h = 0, s = 0, m = window.innerHeight, v = window.innerWidth, E = window.innerHeight, T = window.innerWidth), (e || r) && t !== window && (i = i || t.parentNode, !Hs))
      do
        if (i && i.getBoundingClientRect && (rr(i, "transform") !== "none" || r && rr(i, "position") !== "static")) {
          var S = i.getBoundingClientRect();
          h -= S.top + parseInt(rr(i, "border-top-width")), s -= S.left + parseInt(rr(i, "border-left-width")), m = h + l.height, v = s + l.width;
          break;
        }
      while (i = i.parentNode);
    if (n && t !== window) {
      var A = Oh(i || t), L = A && A.a, B = A && A.d;
      A && (h /= B, s /= L, T /= L, E /= B, m = h + E, v = s + T);
    }
    return {
      top: h,
      left: s,
      bottom: m,
      right: v,
      width: T,
      height: E
    };
  }
}
function lT(t, e, r) {
  for (var n = kl(t, !0), i = gi(t)[e]; n; ) {
    var l = gi(n)[r], h = void 0;
    if (r === "top" || r === "left" ? h = i >= l : h = i <= l, !h)
      return n;
    if (n === os())
      break;
    n = kl(n, !1);
  }
  return !1;
}
function Bh(t, e, r, n) {
  for (var i = 0, l = 0, h = t.children; l < h.length; ) {
    if (h[l].style.display !== "none" && h[l] !== nr.ghost && (n || h[l] !== nr.dragged) && Ha(h[l], r.draggable, t, !1)) {
      if (i === e)
        return h[l];
      i++;
    }
    l++;
  }
  return null;
}
function Yx(t, e) {
  for (var r = t.lastElementChild; r && (r === nr.ghost || rr(r, "display") === "none" || e && !oy(r, e)); )
    r = r.previousElementSibling;
  return r || null;
}
function ta(t, e) {
  var r = 0;
  if (!t || !t.parentNode)
    return -1;
  for (; t = t.previousElementSibling; )
    t.nodeName.toUpperCase() !== "TEMPLATE" && t !== nr.clone && (!e || oy(t, e)) && r++;
  return r;
}
function cT(t) {
  var e = 0, r = 0, n = os();
  if (t)
    do {
      var i = Oh(t), l = i.a, h = i.d;
      e += t.scrollLeft * l, r += t.scrollTop * h;
    } while (t !== n && (t = t.parentNode));
  return [e, r];
}
function Y7(t, e) {
  for (var r in t)
    if (!!t.hasOwnProperty(r)) {
      for (var n in e)
        if (e.hasOwnProperty(n) && e[n] === t[r][n])
          return Number(r);
    }
  return -1;
}
function kl(t, e) {
  if (!t || !t.getBoundingClientRect)
    return os();
  var r = t, n = !1;
  do
    if (r.clientWidth < r.scrollWidth || r.clientHeight < r.scrollHeight) {
      var i = rr(r);
      if (r.clientWidth < r.scrollWidth && (i.overflowX == "auto" || i.overflowX == "scroll") || r.clientHeight < r.scrollHeight && (i.overflowY == "auto" || i.overflowY == "scroll")) {
        if (!r.getBoundingClientRect || r === document.body)
          return os();
        if (n || e)
          return r;
        n = !0;
      }
    }
  while (r = r.parentNode);
  return os();
}
function J7(t, e) {
  if (t && e)
    for (var r in e)
      e.hasOwnProperty(r) && (t[r] = e[r]);
  return t;
}
function Nv(t, e) {
  return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width);
}
var xd;
function wC(t, e) {
  return function() {
    if (!xd) {
      var r = arguments, n = this;
      r.length === 1 ? t.call(n, r[0]) : t.apply(n, r), xd = setTimeout(function() {
        xd = void 0;
      }, e);
    }
  };
}
function Q7() {
  clearTimeout(xd), xd = void 0;
}
function EC(t, e, r) {
  t.scrollLeft += e, t.scrollTop += r;
}
function TC(t) {
  var e = window.Polymer, r = window.jQuery || window.Zepto;
  return e && e.dom ? e.dom(t).cloneNode(!0) : r ? r(t).clone(!0)[0] : t.cloneNode(!0);
}
var Vo = "Sortable" + new Date().getTime();
function e9() {
  var t = [], e;
  return {
    captureAnimationState: function() {
      if (t = [], !!this.options.animation) {
        var n = [].slice.call(this.el.children);
        n.forEach(function(i) {
          if (!(rr(i, "display") === "none" || i === nr.ghost)) {
            t.push({
              target: i,
              rect: gi(i)
            });
            var l = us({}, t[t.length - 1].rect);
            if (i.thisAnimationDuration) {
              var h = Oh(i, !0);
              h && (l.top -= h.f, l.left -= h.e);
            }
            i.fromRect = l;
          }
        });
      }
    },
    addAnimationState: function(n) {
      t.push(n);
    },
    removeAnimationState: function(n) {
      t.splice(Y7(t, {
        target: n
      }), 1);
    },
    animateAll: function(n) {
      var i = this;
      if (!this.options.animation) {
        clearTimeout(e), typeof n == "function" && n();
        return;
      }
      var l = !1, h = 0;
      t.forEach(function(s) {
        var m = 0, v = s.target, E = v.fromRect, T = gi(v), S = v.prevFromRect, A = v.prevToRect, L = s.rect, B = Oh(v, !0);
        B && (T.top -= B.f, T.left -= B.e), v.toRect = T, v.thisAnimationDuration && Nv(S, T) && !Nv(E, T) && (L.top - T.top) / (L.left - T.left) === (E.top - T.top) / (E.left - T.left) && (m = r9(L, S, A, i.options)), Nv(T, E) || (v.prevFromRect = E, v.prevToRect = T, m || (m = i.options.animation), i.animate(v, L, T, m)), m && (l = !0, h = Math.max(h, m), clearTimeout(v.animationResetTimer), v.animationResetTimer = setTimeout(function() {
          v.animationTime = 0, v.prevFromRect = null, v.fromRect = null, v.prevToRect = null, v.thisAnimationDuration = null;
        }, m), v.thisAnimationDuration = m);
      }), clearTimeout(e), l ? e = setTimeout(function() {
        typeof n == "function" && n();
      }, h) : typeof n == "function" && n(), t = [];
    },
    animate: function(n, i, l, h) {
      if (h) {
        rr(n, "transition", ""), rr(n, "transform", "");
        var s = Oh(this.el), m = s && s.a, v = s && s.d, E = (i.left - l.left) / (m || 1), T = (i.top - l.top) / (v || 1);
        n.animatingX = !!E, n.animatingY = !!T, rr(n, "transform", "translate3d(" + E + "px," + T + "px,0)"), this.forRepaintDummy = t9(n), rr(n, "transition", "transform " + h + "ms" + (this.options.easing ? " " + this.options.easing : "")), rr(n, "transform", "translate3d(0,0,0)"), typeof n.animated == "number" && clearTimeout(n.animated), n.animated = setTimeout(function() {
          rr(n, "transition", ""), rr(n, "transform", ""), n.animated = !1, n.animatingX = !1, n.animatingY = !1;
        }, h);
      }
    }
  };
}
function t9(t) {
  return t.offsetWidth;
}
function r9(t, e, r, n) {
  return Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) / Math.sqrt(Math.pow(e.top - r.top, 2) + Math.pow(e.left - r.left, 2)) * n.animation;
}
var th = [], Fv = {
  initializeByDefault: !0
}, hp = {
  mount: function(e) {
    for (var r in Fv)
      Fv.hasOwnProperty(r) && !(r in e) && (e[r] = Fv[r]);
    th.forEach(function(n) {
      if (n.pluginName === e.pluginName)
        throw "Sortable: Cannot mount plugin ".concat(e.pluginName, " more than once");
    }), th.push(e);
  },
  pluginEvent: function(e, r, n) {
    var i = this;
    this.eventCanceled = !1, n.cancel = function() {
      i.eventCanceled = !0;
    };
    var l = e + "Global";
    th.forEach(function(h) {
      !r[h.pluginName] || (r[h.pluginName][l] && r[h.pluginName][l](us({
        sortable: r
      }, n)), r.options[h.pluginName] && r[h.pluginName][e] && r[h.pluginName][e](us({
        sortable: r
      }, n)));
    });
  },
  initializePlugins: function(e, r, n, i) {
    th.forEach(function(s) {
      var m = s.pluginName;
      if (!(!e.options[m] && !s.initializeByDefault)) {
        var v = new s(e, r, e.options);
        v.sortable = e, v.options = e.options, e[m] = v, Gs(n, v.defaults);
      }
    });
    for (var l in e.options)
      if (!!e.options.hasOwnProperty(l)) {
        var h = this.modifyOption(e, l, e.options[l]);
        typeof h < "u" && (e.options[l] = h);
      }
  },
  getEventProperties: function(e, r) {
    var n = {};
    return th.forEach(function(i) {
      typeof i.eventProperties == "function" && Gs(n, i.eventProperties.call(r[i.pluginName], e));
    }), n;
  },
  modifyOption: function(e, r, n) {
    var i;
    return th.forEach(function(l) {
      !e[l.pluginName] || l.optionListeners && typeof l.optionListeners[r] == "function" && (i = l.optionListeners[r].call(e[l.pluginName], n));
    }), i;
  }
};
function n9(t) {
  var e = t.sortable, r = t.rootEl, n = t.name, i = t.targetEl, l = t.cloneEl, h = t.toEl, s = t.fromEl, m = t.oldIndex, v = t.newIndex, E = t.oldDraggableIndex, T = t.newDraggableIndex, S = t.originalEvent, A = t.putSortable, L = t.extraEventProperties;
  if (e = e || r && r[Vo], !!e) {
    var B, j = e.options, q = "on" + n.charAt(0).toUpperCase() + n.substr(1);
    window.CustomEvent && !Hs && !up ? B = new CustomEvent(n, {
      bubbles: !0,
      cancelable: !0
    }) : (B = document.createEvent("Event"), B.initEvent(n, !0, !0)), B.to = h || r, B.from = s || r, B.item = i || r, B.clone = l, B.oldIndex = m, B.newIndex = v, B.oldDraggableIndex = E, B.newDraggableIndex = T, B.originalEvent = S, B.pullMode = A ? A.lastPutMode : void 0;
    var H = us(us({}, L), hp.getEventProperties(n, e));
    for (var ne in H)
      B[ne] = H[ne];
    r && r.dispatchEvent(B), j[q] && j[q].call(e, B);
  }
}
var i9 = ["evt"], bo = function(e, r) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = n.evt, l = Z7(n, i9);
  hp.pluginEvent.bind(nr)(e, r, us({
    dragEl: xt,
    parentEl: Wn,
    ghostEl: pr,
    rootEl: Dn,
    nextEl: Vc,
    lastDownEl: mg,
    cloneEl: zn,
    cloneHidden: Ol,
    dragStarted: ad,
    putSortable: Ni,
    activeSortable: nr.active,
    originalEvent: i,
    oldIndex: _h,
    oldDraggableIndex: bd,
    newIndex: Bo,
    newDraggableIndex: Ml,
    hideGhostForTarget: IC,
    unhideGhostForTarget: PC,
    cloneNowHidden: function() {
      Ol = !0;
    },
    cloneNowShown: function() {
      Ol = !1;
    },
    dispatchSortableEvent: function(s) {
      uo({
        sortable: r,
        name: s,
        originalEvent: i
      });
    }
  }, l));
};
function uo(t) {
  n9(us({
    putSortable: Ni,
    cloneEl: zn,
    targetEl: xt,
    rootEl: Dn,
    oldIndex: _h,
    oldDraggableIndex: bd,
    newIndex: Bo,
    newDraggableIndex: Ml
  }, t));
}
var xt, Wn, pr, Dn, Vc, mg, zn, Ol, _h, Bo, bd, Ml, Wm, Ni, lh = !1, ay = !1, sy = [], Fc, va, zv, Bv, uT, hT, ad, rh, wd, Ed = !1, Xm = !1, gg, Wi, Uv = [], V0 = !1, ly = [], Xy = typeof document < "u", Zm = _C, fT = up || Hs ? "cssFloat" : "float", o9 = Xy && !vC && !_C && "draggable" in document.createElement("div"), SC = function() {
  if (!!Xy) {
    if (Hs)
      return !1;
    var t = document.createElement("x");
    return t.style.cssText = "pointer-events:auto", t.style.pointerEvents === "auto";
  }
}(), MC = function(e, r) {
  var n = rr(e), i = parseInt(n.width) - parseInt(n.paddingLeft) - parseInt(n.paddingRight) - parseInt(n.borderLeftWidth) - parseInt(n.borderRightWidth), l = Bh(e, 0, r), h = Bh(e, 1, r), s = l && rr(l), m = h && rr(h), v = s && parseInt(s.marginLeft) + parseInt(s.marginRight) + gi(l).width, E = m && parseInt(m.marginLeft) + parseInt(m.marginRight) + gi(h).width;
  if (n.display === "flex")
    return n.flexDirection === "column" || n.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (n.display === "grid")
    return n.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (l && s.float && s.float !== "none") {
    var T = s.float === "left" ? "left" : "right";
    return h && (m.clear === "both" || m.clear === T) ? "vertical" : "horizontal";
  }
  return l && (s.display === "block" || s.display === "flex" || s.display === "table" || s.display === "grid" || v >= i && n[fT] === "none" || h && n[fT] === "none" && v + E > i) ? "vertical" : "horizontal";
}, a9 = function(e, r, n) {
  var i = n ? e.left : e.top, l = n ? e.right : e.bottom, h = n ? e.width : e.height, s = n ? r.left : r.top, m = n ? r.right : r.bottom, v = n ? r.width : r.height;
  return i === s || l === m || i + h / 2 === s + v / 2;
}, s9 = function(e, r) {
  var n;
  return sy.some(function(i) {
    var l = i[Vo].options.emptyInsertThreshold;
    if (!(!l || Yx(i))) {
      var h = gi(i), s = e >= h.left - l && e <= h.right + l, m = r >= h.top - l && r <= h.bottom + l;
      if (s && m)
        return n = i;
    }
  }), n;
}, CC = function(e) {
  function r(l, h) {
    return function(s, m, v, E) {
      var T = s.options.group.name && m.options.group.name && s.options.group.name === m.options.group.name;
      if (l == null && (h || T))
        return !0;
      if (l == null || l === !1)
        return !1;
      if (h && l === "clone")
        return l;
      if (typeof l == "function")
        return r(l(s, m, v, E), h)(s, m, v, E);
      var S = (h ? s : m).options.group.name;
      return l === !0 || typeof l == "string" && l === S || l.join && l.indexOf(S) > -1;
    };
  }
  var n = {}, i = e.group;
  (!i || pg(i) != "object") && (i = {
    name: i
  }), n.name = i.name, n.checkPull = r(i.pull, !0), n.checkPut = r(i.put), n.revertClone = i.revertClone, e.group = n;
}, IC = function() {
  !SC && pr && rr(pr, "display", "none");
}, PC = function() {
  !SC && pr && rr(pr, "display", "");
};
Xy && !vC && document.addEventListener("click", function(t) {
  if (ay)
    return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), ay = !1, !1;
}, !0);
var zc = function(e) {
  if (xt) {
    e = e.touches ? e.touches[0] : e;
    var r = s9(e.clientX, e.clientY);
    if (r) {
      var n = {};
      for (var i in e)
        e.hasOwnProperty(i) && (n[i] = e[i]);
      n.target = n.rootEl = r, n.preventDefault = void 0, n.stopPropagation = void 0, r[Vo]._onDragOver(n);
    }
  }
}, l9 = function(e) {
  xt && xt.parentNode[Vo]._isOutsideThisEl(e.target);
};
function nr(t, e) {
  if (!(t && t.nodeType && t.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t));
  this.el = t, this.options = e = Gs({}, e), t[Vo] = this;
  var r = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(t.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: !1,
    invertedSwapThreshold: null,
    removeCloneOnHide: !0,
    direction: function() {
      return MC(t, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(h, s) {
      h.setData("Text", s.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: nr.supportPointer !== !1 && "PointerEvent" in window && !vd,
    emptyInsertThreshold: 5
  };
  hp.initializePlugins(this, t, r);
  for (var n in r)
    !(n in e) && (e[n] = r[n]);
  CC(e);
  for (var i in this)
    i.charAt(0) === "_" && typeof this[i] == "function" && (this[i] = this[i].bind(this));
  this.nativeDraggable = e.forceFallback ? !1 : o9, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? Hr(t, "pointerdown", this._onTapStart) : (Hr(t, "mousedown", this._onTapStart), Hr(t, "touchstart", this._onTapStart)), this.nativeDraggable && (Hr(t, "dragover", this), Hr(t, "dragenter", this)), sy.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), Gs(this, e9());
}
nr.prototype = {
  constructor: nr,
  _isOutsideThisEl: function(e) {
    !this.el.contains(e) && e !== this.el && (rh = null);
  },
  _getDirection: function(e, r) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, e, r, xt) : this.options.direction;
  },
  _onTapStart: function(e) {
    if (!!e.cancelable) {
      var r = this, n = this.el, i = this.options, l = i.preventOnFilter, h = e.type, s = e.touches && e.touches[0] || e.pointerType && e.pointerType === "touch" && e, m = (s || e).target, v = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || m, E = i.filter;
      if (g9(n), !xt && !(/mousedown|pointerdown/.test(h) && e.button !== 0 || i.disabled) && !v.isContentEditable && !(!this.nativeDraggable && vd && m && m.tagName.toUpperCase() === "SELECT") && (m = Ha(m, i.draggable, n, !1), !(m && m.animated) && mg !== m)) {
        if (_h = ta(m), bd = ta(m, i.draggable), typeof E == "function") {
          if (E.call(this, e, m, this)) {
            uo({
              sortable: r,
              rootEl: v,
              name: "filter",
              targetEl: m,
              toEl: n,
              fromEl: n
            }), bo("filter", r, {
              evt: e
            }), l && e.cancelable && e.preventDefault();
            return;
          }
        } else if (E && (E = E.split(",").some(function(T) {
          if (T = Ha(v, T.trim(), n, !1), T)
            return uo({
              sortable: r,
              rootEl: T,
              name: "filter",
              targetEl: m,
              fromEl: n,
              toEl: n
            }), bo("filter", r, {
              evt: e
            }), !0;
        }), E)) {
          l && e.cancelable && e.preventDefault();
          return;
        }
        i.handle && !Ha(v, i.handle, n, !1) || this._prepareDragStart(e, s, m);
      }
    }
  },
  _prepareDragStart: function(e, r, n) {
    var i = this, l = i.el, h = i.options, s = l.ownerDocument, m;
    if (n && !xt && n.parentNode === l) {
      var v = gi(n);
      if (Dn = l, xt = n, Wn = xt.parentNode, Vc = xt.nextSibling, mg = n, Wm = h.group, nr.dragged = xt, Fc = {
        target: xt,
        clientX: (r || e).clientX,
        clientY: (r || e).clientY
      }, uT = Fc.clientX - v.left, hT = Fc.clientY - v.top, this._lastX = (r || e).clientX, this._lastY = (r || e).clientY, xt.style["will-change"] = "all", m = function() {
        if (bo("delayEnded", i, {
          evt: e
        }), nr.eventCanceled) {
          i._onDrop();
          return;
        }
        i._disableDelayedDragEvents(), !aT && i.nativeDraggable && (xt.draggable = !0), i._triggerDragStart(e, r), uo({
          sortable: i,
          name: "choose",
          originalEvent: e
        }), zo(xt, h.chosenClass, !0);
      }, h.ignore.split(",").forEach(function(E) {
        bC(xt, E.trim(), $v);
      }), Hr(s, "dragover", zc), Hr(s, "mousemove", zc), Hr(s, "touchmove", zc), Hr(s, "mouseup", i._onDrop), Hr(s, "touchend", i._onDrop), Hr(s, "touchcancel", i._onDrop), aT && this.nativeDraggable && (this.options.touchStartThreshold = 4, xt.draggable = !0), bo("delayStart", this, {
        evt: e
      }), h.delay && (!h.delayOnTouchOnly || r) && (!this.nativeDraggable || !(up || Hs))) {
        if (nr.eventCanceled) {
          this._onDrop();
          return;
        }
        Hr(s, "mouseup", i._disableDelayedDrag), Hr(s, "touchend", i._disableDelayedDrag), Hr(s, "touchcancel", i._disableDelayedDrag), Hr(s, "mousemove", i._delayedDragTouchMoveHandler), Hr(s, "touchmove", i._delayedDragTouchMoveHandler), h.supportPointer && Hr(s, "pointermove", i._delayedDragTouchMoveHandler), i._dragStartTimer = setTimeout(m, h.delay);
      } else
        m();
    }
  },
  _delayedDragTouchMoveHandler: function(e) {
    var r = e.touches ? e.touches[0] : e;
    Math.max(Math.abs(r.clientX - this._lastX), Math.abs(r.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    xt && $v(xt), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var e = this.el.ownerDocument;
    Vr(e, "mouseup", this._disableDelayedDrag), Vr(e, "touchend", this._disableDelayedDrag), Vr(e, "touchcancel", this._disableDelayedDrag), Vr(e, "mousemove", this._delayedDragTouchMoveHandler), Vr(e, "touchmove", this._delayedDragTouchMoveHandler), Vr(e, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(e, r) {
    r = r || e.pointerType == "touch" && e, !this.nativeDraggable || r ? this.options.supportPointer ? Hr(document, "pointermove", this._onTouchMove) : r ? Hr(document, "touchmove", this._onTouchMove) : Hr(document, "mousemove", this._onTouchMove) : (Hr(xt, "dragend", this), Hr(Dn, "dragstart", this._onDragStart));
    try {
      document.selection ? yg(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(e, r) {
    if (lh = !1, Dn && xt) {
      bo("dragStarted", this, {
        evt: r
      }), this.nativeDraggable && Hr(document, "dragover", l9);
      var n = this.options;
      !e && zo(xt, n.dragClass, !1), zo(xt, n.ghostClass, !0), nr.active = this, e && this._appendGhost(), uo({
        sortable: this,
        name: "start",
        originalEvent: r
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (va) {
      this._lastX = va.clientX, this._lastY = va.clientY, IC();
      for (var e = document.elementFromPoint(va.clientX, va.clientY), r = e; e && e.shadowRoot && (e = e.shadowRoot.elementFromPoint(va.clientX, va.clientY), e !== r); )
        r = e;
      if (xt.parentNode[Vo]._isOutsideThisEl(e), r)
        do {
          if (r[Vo]) {
            var n = void 0;
            if (n = r[Vo]._onDragOver({
              clientX: va.clientX,
              clientY: va.clientY,
              target: e,
              rootEl: r
            }), n && !this.options.dragoverBubble)
              break;
          }
          e = r;
        } while (r = r.parentNode);
      PC();
    }
  },
  _onTouchMove: function(e) {
    if (Fc) {
      var r = this.options, n = r.fallbackTolerance, i = r.fallbackOffset, l = e.touches ? e.touches[0] : e, h = pr && Oh(pr, !0), s = pr && h && h.a, m = pr && h && h.d, v = Zm && Wi && cT(Wi), E = (l.clientX - Fc.clientX + i.x) / (s || 1) + (v ? v[0] - Uv[0] : 0) / (s || 1), T = (l.clientY - Fc.clientY + i.y) / (m || 1) + (v ? v[1] - Uv[1] : 0) / (m || 1);
      if (!nr.active && !lh) {
        if (n && Math.max(Math.abs(l.clientX - this._lastX), Math.abs(l.clientY - this._lastY)) < n)
          return;
        this._onDragStart(e, !0);
      }
      if (pr) {
        h ? (h.e += E - (zv || 0), h.f += T - (Bv || 0)) : h = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: E,
          f: T
        };
        var S = "matrix(".concat(h.a, ",").concat(h.b, ",").concat(h.c, ",").concat(h.d, ",").concat(h.e, ",").concat(h.f, ")");
        rr(pr, "webkitTransform", S), rr(pr, "mozTransform", S), rr(pr, "msTransform", S), rr(pr, "transform", S), zv = E, Bv = T, va = l;
      }
      e.cancelable && e.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!pr) {
      var e = this.options.fallbackOnBody ? document.body : Dn, r = gi(xt, !0, Zm, !0, e), n = this.options;
      if (Zm) {
        for (Wi = e; rr(Wi, "position") === "static" && rr(Wi, "transform") === "none" && Wi !== document; )
          Wi = Wi.parentNode;
        Wi !== document.body && Wi !== document.documentElement ? (Wi === document && (Wi = os()), r.top += Wi.scrollTop, r.left += Wi.scrollLeft) : Wi = os(), Uv = cT(Wi);
      }
      pr = xt.cloneNode(!0), zo(pr, n.ghostClass, !1), zo(pr, n.fallbackClass, !0), zo(pr, n.dragClass, !0), rr(pr, "transition", ""), rr(pr, "transform", ""), rr(pr, "box-sizing", "border-box"), rr(pr, "margin", 0), rr(pr, "top", r.top), rr(pr, "left", r.left), rr(pr, "width", r.width), rr(pr, "height", r.height), rr(pr, "opacity", "0.8"), rr(pr, "position", Zm ? "absolute" : "fixed"), rr(pr, "zIndex", "100000"), rr(pr, "pointerEvents", "none"), nr.ghost = pr, e.appendChild(pr), rr(pr, "transform-origin", uT / parseInt(pr.style.width) * 100 + "% " + hT / parseInt(pr.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(e, r) {
    var n = this, i = e.dataTransfer, l = n.options;
    if (bo("dragStart", this, {
      evt: e
    }), nr.eventCanceled) {
      this._onDrop();
      return;
    }
    bo("setupClone", this), nr.eventCanceled || (zn = TC(xt), zn.removeAttribute("id"), zn.draggable = !1, zn.style["will-change"] = "", this._hideClone(), zo(zn, this.options.chosenClass, !1), nr.clone = zn), n.cloneId = yg(function() {
      bo("clone", n), !nr.eventCanceled && (n.options.removeCloneOnHide || Dn.insertBefore(zn, xt), n._hideClone(), uo({
        sortable: n,
        name: "clone"
      }));
    }), !r && zo(xt, l.dragClass, !0), r ? (ay = !0, n._loopId = setInterval(n._emulateDragOver, 50)) : (Vr(document, "mouseup", n._onDrop), Vr(document, "touchend", n._onDrop), Vr(document, "touchcancel", n._onDrop), i && (i.effectAllowed = "move", l.setData && l.setData.call(n, i, xt)), Hr(document, "drop", n), rr(xt, "transform", "translateZ(0)")), lh = !0, n._dragStartId = yg(n._dragStarted.bind(n, r, e)), Hr(document, "selectstart", n), ad = !0, vd && rr(document.body, "user-select", "none");
  },
  _onDragOver: function(e) {
    var r = this.el, n = e.target, i, l, h, s = this.options, m = s.group, v = nr.active, E = Wm === m, T = s.sort, S = Ni || v, A, L = this, B = !1;
    if (V0)
      return;
    function j(it, kt) {
      bo(it, L, us({
        evt: e,
        isOwner: E,
        axis: A ? "vertical" : "horizontal",
        revert: h,
        dragRect: i,
        targetRect: l,
        canSort: T,
        fromSortable: S,
        target: n,
        completed: H,
        onMove: function(mr, Yt) {
          return Hm(Dn, r, xt, i, mr, gi(mr), e, Yt);
        },
        changed: ne
      }, kt));
    }
    function q() {
      j("dragOverAnimationCapture"), L.captureAnimationState(), L !== S && S.captureAnimationState();
    }
    function H(it) {
      return j("dragOverCompleted", {
        insertion: it
      }), it && (E ? v._hideClone() : v._showClone(L), L !== S && (zo(xt, Ni ? Ni.options.ghostClass : v.options.ghostClass, !1), zo(xt, s.ghostClass, !0)), Ni !== L && L !== nr.active ? Ni = L : L === nr.active && Ni && (Ni = null), S === L && (L._ignoreWhileAnimating = n), L.animateAll(function() {
        j("dragOverAnimationComplete"), L._ignoreWhileAnimating = null;
      }), L !== S && (S.animateAll(), S._ignoreWhileAnimating = null)), (n === xt && !xt.animated || n === r && !n.animated) && (rh = null), !s.dragoverBubble && !e.rootEl && n !== document && (xt.parentNode[Vo]._isOutsideThisEl(e.target), !it && zc(e)), !s.dragoverBubble && e.stopPropagation && e.stopPropagation(), B = !0;
    }
    function ne() {
      Bo = ta(xt), Ml = ta(xt, s.draggable), uo({
        sortable: L,
        name: "change",
        toEl: r,
        newIndex: Bo,
        newDraggableIndex: Ml,
        originalEvent: e
      });
    }
    if (e.preventDefault !== void 0 && e.cancelable && e.preventDefault(), n = Ha(n, s.draggable, r, !0), j("dragOver"), nr.eventCanceled)
      return B;
    if (xt.contains(e.target) || n.animated && n.animatingX && n.animatingY || L._ignoreWhileAnimating === n)
      return H(!1);
    if (ay = !1, v && !s.disabled && (E ? T || (h = Wn !== Dn) : Ni === this || (this.lastPutMode = Wm.checkPull(this, v, xt, e)) && m.checkPut(this, v, xt, e))) {
      if (A = this._getDirection(e, n) === "vertical", i = gi(xt), j("dragOverValid"), nr.eventCanceled)
        return B;
      if (h)
        return Wn = Dn, q(), this._hideClone(), j("revert"), nr.eventCanceled || (Vc ? Dn.insertBefore(xt, Vc) : Dn.appendChild(xt)), H(!0);
      var ee = Yx(r, s.draggable);
      if (!ee || f9(e, A, this) && !ee.animated) {
        if (ee === xt)
          return H(!1);
        if (ee && r === e.target && (n = ee), n && (l = gi(n)), Hm(Dn, r, xt, i, n, l, e, !!n) !== !1)
          return q(), ee && ee.nextSibling ? r.insertBefore(xt, ee.nextSibling) : r.appendChild(xt), Wn = r, ne(), H(!0);
      } else if (ee && h9(e, A, this)) {
        var he = Bh(r, 0, s, !0);
        if (he === xt)
          return H(!1);
        if (n = he, l = gi(n), Hm(Dn, r, xt, i, n, l, e, !1) !== !1)
          return q(), r.insertBefore(xt, he), Wn = r, ne(), H(!0);
      } else if (n.parentNode === r) {
        l = gi(n);
        var Te = 0, ve, Oe = xt.parentNode !== r, Me = !a9(xt.animated && xt.toRect || i, n.animated && n.toRect || l, A), Re = A ? "top" : "left", He = lT(n, "top", "top") || lT(xt, "top", "top"), Ve = He ? He.scrollTop : void 0;
        rh !== n && (ve = l[Re], Ed = !1, Xm = !Me && s.invertSwap || Oe), Te = d9(e, n, l, A, Me ? 1 : s.swapThreshold, s.invertedSwapThreshold == null ? s.swapThreshold : s.invertedSwapThreshold, Xm, rh === n);
        var dt;
        if (Te !== 0) {
          var xe = ta(xt);
          do
            xe -= Te, dt = Wn.children[xe];
          while (dt && (rr(dt, "display") === "none" || dt === pr));
        }
        if (Te === 0 || dt === n)
          return H(!1);
        rh = n, wd = Te;
        var ze = n.nextElementSibling, Pe = !1;
        Pe = Te === 1;
        var Ye = Hm(Dn, r, xt, i, n, l, e, Pe);
        if (Ye !== !1)
          return (Ye === 1 || Ye === -1) && (Pe = Ye === 1), V0 = !0, setTimeout(u9, 30), q(), Pe && !ze ? r.appendChild(xt) : n.parentNode.insertBefore(xt, Pe ? ze : n), He && EC(He, 0, Ve - He.scrollTop), Wn = xt.parentNode, ve !== void 0 && !Xm && (gg = Math.abs(ve - gi(n)[Re])), ne(), H(!0);
      }
      if (r.contains(xt))
        return H(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    Vr(document, "mousemove", this._onTouchMove), Vr(document, "touchmove", this._onTouchMove), Vr(document, "pointermove", this._onTouchMove), Vr(document, "dragover", zc), Vr(document, "mousemove", zc), Vr(document, "touchmove", zc);
  },
  _offUpEvents: function() {
    var e = this.el.ownerDocument;
    Vr(e, "mouseup", this._onDrop), Vr(e, "touchend", this._onDrop), Vr(e, "pointerup", this._onDrop), Vr(e, "touchcancel", this._onDrop), Vr(document, "selectstart", this);
  },
  _onDrop: function(e) {
    var r = this.el, n = this.options;
    if (Bo = ta(xt), Ml = ta(xt, n.draggable), bo("drop", this, {
      evt: e
    }), Wn = xt && xt.parentNode, Bo = ta(xt), Ml = ta(xt, n.draggable), nr.eventCanceled) {
      this._nulling();
      return;
    }
    lh = !1, Xm = !1, Ed = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), j0(this.cloneId), j0(this._dragStartId), this.nativeDraggable && (Vr(document, "drop", this), Vr(r, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), vd && rr(document.body, "user-select", ""), rr(xt, "transform", ""), e && (ad && (e.cancelable && e.preventDefault(), !n.dropBubble && e.stopPropagation()), pr && pr.parentNode && pr.parentNode.removeChild(pr), (Dn === Wn || Ni && Ni.lastPutMode !== "clone") && zn && zn.parentNode && zn.parentNode.removeChild(zn), xt && (this.nativeDraggable && Vr(xt, "dragend", this), $v(xt), xt.style["will-change"] = "", ad && !lh && zo(xt, Ni ? Ni.options.ghostClass : this.options.ghostClass, !1), zo(xt, this.options.chosenClass, !1), uo({
      sortable: this,
      name: "unchoose",
      toEl: Wn,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: e
    }), Dn !== Wn ? (Bo >= 0 && (uo({
      rootEl: Wn,
      name: "add",
      toEl: Wn,
      fromEl: Dn,
      originalEvent: e
    }), uo({
      sortable: this,
      name: "remove",
      toEl: Wn,
      originalEvent: e
    }), uo({
      rootEl: Wn,
      name: "sort",
      toEl: Wn,
      fromEl: Dn,
      originalEvent: e
    }), uo({
      sortable: this,
      name: "sort",
      toEl: Wn,
      originalEvent: e
    })), Ni && Ni.save()) : Bo !== _h && Bo >= 0 && (uo({
      sortable: this,
      name: "update",
      toEl: Wn,
      originalEvent: e
    }), uo({
      sortable: this,
      name: "sort",
      toEl: Wn,
      originalEvent: e
    })), nr.active && ((Bo == null || Bo === -1) && (Bo = _h, Ml = bd), uo({
      sortable: this,
      name: "end",
      toEl: Wn,
      originalEvent: e
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    bo("nulling", this), Dn = xt = Wn = pr = Vc = zn = mg = Ol = Fc = va = ad = Bo = Ml = _h = bd = rh = wd = Ni = Wm = nr.dragged = nr.ghost = nr.clone = nr.active = null, ly.forEach(function(e) {
      e.checked = !0;
    }), ly.length = zv = Bv = 0;
  },
  handleEvent: function(e) {
    switch (e.type) {
      case "drop":
      case "dragend":
        this._onDrop(e);
        break;
      case "dragenter":
      case "dragover":
        xt && (this._onDragOver(e), c9(e));
        break;
      case "selectstart":
        e.preventDefault();
        break;
    }
  },
  toArray: function() {
    for (var e = [], r, n = this.el.children, i = 0, l = n.length, h = this.options; i < l; i++)
      r = n[i], Ha(r, h.draggable, this.el, !1) && e.push(r.getAttribute(h.dataIdAttr) || m9(r));
    return e;
  },
  sort: function(e, r) {
    var n = {}, i = this.el;
    this.toArray().forEach(function(l, h) {
      var s = i.children[h];
      Ha(s, this.options.draggable, i, !1) && (n[l] = s);
    }, this), r && this.captureAnimationState(), e.forEach(function(l) {
      n[l] && (i.removeChild(n[l]), i.appendChild(n[l]));
    }), r && this.animateAll();
  },
  save: function() {
    var e = this.options.store;
    e && e.set && e.set(this);
  },
  closest: function(e, r) {
    return Ha(e, r || this.options.draggable, this.el, !1);
  },
  option: function(e, r) {
    var n = this.options;
    if (r === void 0)
      return n[e];
    var i = hp.modifyOption(this, e, r);
    typeof i < "u" ? n[e] = i : n[e] = r, e === "group" && CC(n);
  },
  destroy: function() {
    bo("destroy", this);
    var e = this.el;
    e[Vo] = null, Vr(e, "mousedown", this._onTapStart), Vr(e, "touchstart", this._onTapStart), Vr(e, "pointerdown", this._onTapStart), this.nativeDraggable && (Vr(e, "dragover", this), Vr(e, "dragenter", this)), Array.prototype.forEach.call(e.querySelectorAll("[draggable]"), function(r) {
      r.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), sy.splice(sy.indexOf(this.el), 1), this.el = e = null;
  },
  _hideClone: function() {
    if (!Ol) {
      if (bo("hideClone", this), nr.eventCanceled)
        return;
      rr(zn, "display", "none"), this.options.removeCloneOnHide && zn.parentNode && zn.parentNode.removeChild(zn), Ol = !0;
    }
  },
  _showClone: function(e) {
    if (e.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (Ol) {
      if (bo("showClone", this), nr.eventCanceled)
        return;
      xt.parentNode == Dn && !this.options.group.revertClone ? Dn.insertBefore(zn, xt) : Vc ? Dn.insertBefore(zn, Vc) : Dn.appendChild(zn), this.options.group.revertClone && this.animate(xt, zn), rr(zn, "display", ""), Ol = !1;
    }
  }
};
function c9(t) {
  t.dataTransfer && (t.dataTransfer.dropEffect = "move"), t.cancelable && t.preventDefault();
}
function Hm(t, e, r, n, i, l, h, s) {
  var m, v = t[Vo], E = v.options.onMove, T;
  return window.CustomEvent && !Hs && !up ? m = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (m = document.createEvent("Event"), m.initEvent("move", !0, !0)), m.to = e, m.from = t, m.dragged = r, m.draggedRect = n, m.related = i || e, m.relatedRect = l || gi(e), m.willInsertAfter = s, m.originalEvent = h, t.dispatchEvent(m), E && (T = E.call(v, m, h)), T;
}
function $v(t) {
  t.draggable = !1;
}
function u9() {
  V0 = !1;
}
function h9(t, e, r) {
  var n = gi(Bh(r.el, 0, r.options, !0)), i = 10;
  return e ? t.clientX < n.left - i || t.clientY < n.top && t.clientX < n.right : t.clientY < n.top - i || t.clientY < n.bottom && t.clientX < n.left;
}
function f9(t, e, r) {
  var n = gi(Yx(r.el, r.options.draggable)), i = 10;
  return e ? t.clientX > n.right + i || t.clientX <= n.right && t.clientY > n.bottom && t.clientX >= n.left : t.clientX > n.right && t.clientY > n.top || t.clientX <= n.right && t.clientY > n.bottom + i;
}
function d9(t, e, r, n, i, l, h, s) {
  var m = n ? t.clientY : t.clientX, v = n ? r.height : r.width, E = n ? r.top : r.left, T = n ? r.bottom : r.right, S = !1;
  if (!h) {
    if (s && gg < v * i) {
      if (!Ed && (wd === 1 ? m > E + v * l / 2 : m < T - v * l / 2) && (Ed = !0), Ed)
        S = !0;
      else if (wd === 1 ? m < E + gg : m > T - gg)
        return -wd;
    } else if (m > E + v * (1 - i) / 2 && m < T - v * (1 - i) / 2)
      return p9(e);
  }
  return S = S || h, S && (m < E + v * l / 2 || m > T - v * l / 2) ? m > E + v / 2 ? 1 : -1 : 0;
}
function p9(t) {
  return ta(xt) < ta(t) ? 1 : -1;
}
function m9(t) {
  for (var e = t.tagName + t.className + t.src + t.href + t.textContent, r = e.length, n = 0; r--; )
    n += e.charCodeAt(r);
  return n.toString(36);
}
function g9(t) {
  ly.length = 0;
  for (var e = t.getElementsByTagName("input"), r = e.length; r--; ) {
    var n = e[r];
    n.checked && ly.push(n);
  }
}
function yg(t) {
  return setTimeout(t, 0);
}
function j0(t) {
  return clearTimeout(t);
}
Xy && Hr(document, "touchmove", function(t) {
  (nr.active || lh) && t.cancelable && t.preventDefault();
});
nr.utils = {
  on: Hr,
  off: Vr,
  css: rr,
  find: bC,
  is: function(e, r) {
    return !!Ha(e, r, e, !1);
  },
  extend: J7,
  throttle: wC,
  closest: Ha,
  toggleClass: zo,
  clone: TC,
  index: ta,
  nextTick: yg,
  cancelNextTick: j0,
  detectDirection: MC,
  getChild: Bh
};
nr.get = function(t) {
  return t[Vo];
};
nr.mount = function() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  e[0].constructor === Array && (e = e[0]), e.forEach(function(n) {
    if (!n.prototype || !n.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(n));
    n.utils && (nr.utils = us(us({}, nr.utils), n.utils)), hp.mount(n);
  });
};
nr.create = function(t, e) {
  return new nr(t, e);
};
nr.version = H7;
var ui = [], sd, G0, q0 = !1, Vv, jv, cy, ld;
function y9() {
  function t() {
    this.defaults = {
      scroll: !0,
      forceAutoScrollFallback: !1,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var e in this)
      e.charAt(0) === "_" && typeof this[e] == "function" && (this[e] = this[e].bind(this));
  }
  return t.prototype = {
    dragStarted: function(r) {
      var n = r.originalEvent;
      this.sortable.nativeDraggable ? Hr(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? Hr(document, "pointermove", this._handleFallbackAutoScroll) : n.touches ? Hr(document, "touchmove", this._handleFallbackAutoScroll) : Hr(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(r) {
      var n = r.originalEvent;
      !this.options.dragOverBubble && !n.rootEl && this._handleAutoScroll(n);
    },
    drop: function() {
      this.sortable.nativeDraggable ? Vr(document, "dragover", this._handleAutoScroll) : (Vr(document, "pointermove", this._handleFallbackAutoScroll), Vr(document, "touchmove", this._handleFallbackAutoScroll), Vr(document, "mousemove", this._handleFallbackAutoScroll)), dT(), _g(), Q7();
    },
    nulling: function() {
      cy = G0 = sd = q0 = ld = Vv = jv = null, ui.length = 0;
    },
    _handleFallbackAutoScroll: function(r) {
      this._handleAutoScroll(r, !0);
    },
    _handleAutoScroll: function(r, n) {
      var i = this, l = (r.touches ? r.touches[0] : r).clientX, h = (r.touches ? r.touches[0] : r).clientY, s = document.elementFromPoint(l, h);
      if (cy = r, n || this.options.forceAutoScrollFallback || up || Hs || vd) {
        Gv(r, this.options, s, n);
        var m = kl(s, !0);
        q0 && (!ld || l !== Vv || h !== jv) && (ld && dT(), ld = setInterval(function() {
          var v = kl(document.elementFromPoint(l, h), !0);
          v !== m && (m = v, _g()), Gv(r, i.options, v, n);
        }, 10), Vv = l, jv = h);
      } else {
        if (!this.options.bubbleScroll || kl(s, !0) === os()) {
          _g();
          return;
        }
        Gv(r, this.options, kl(s, !1), !1);
      }
    }
  }, Gs(t, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function _g() {
  ui.forEach(function(t) {
    clearInterval(t.pid);
  }), ui = [];
}
function dT() {
  clearInterval(ld);
}
var Gv = wC(function(t, e, r, n) {
  if (!!e.scroll) {
    var i = (t.touches ? t.touches[0] : t).clientX, l = (t.touches ? t.touches[0] : t).clientY, h = e.scrollSensitivity, s = e.scrollSpeed, m = os(), v = !1, E;
    G0 !== r && (G0 = r, _g(), sd = e.scroll, E = e.scrollFn, sd === !0 && (sd = kl(r, !0)));
    var T = 0, S = sd;
    do {
      var A = S, L = gi(A), B = L.top, j = L.bottom, q = L.left, H = L.right, ne = L.width, ee = L.height, he = void 0, Te = void 0, ve = A.scrollWidth, Oe = A.scrollHeight, Me = rr(A), Re = A.scrollLeft, He = A.scrollTop;
      A === m ? (he = ne < ve && (Me.overflowX === "auto" || Me.overflowX === "scroll" || Me.overflowX === "visible"), Te = ee < Oe && (Me.overflowY === "auto" || Me.overflowY === "scroll" || Me.overflowY === "visible")) : (he = ne < ve && (Me.overflowX === "auto" || Me.overflowX === "scroll"), Te = ee < Oe && (Me.overflowY === "auto" || Me.overflowY === "scroll"));
      var Ve = he && (Math.abs(H - i) <= h && Re + ne < ve) - (Math.abs(q - i) <= h && !!Re), dt = Te && (Math.abs(j - l) <= h && He + ee < Oe) - (Math.abs(B - l) <= h && !!He);
      if (!ui[T])
        for (var xe = 0; xe <= T; xe++)
          ui[xe] || (ui[xe] = {});
      (ui[T].vx != Ve || ui[T].vy != dt || ui[T].el !== A) && (ui[T].el = A, ui[T].vx = Ve, ui[T].vy = dt, clearInterval(ui[T].pid), (Ve != 0 || dt != 0) && (v = !0, ui[T].pid = setInterval(function() {
        n && this.layer === 0 && nr.active._onTouchMove(cy);
        var ze = ui[this.layer].vy ? ui[this.layer].vy * s : 0, Pe = ui[this.layer].vx ? ui[this.layer].vx * s : 0;
        typeof E == "function" && E.call(nr.dragged.parentNode[Vo], Pe, ze, t, cy, ui[this.layer].el) !== "continue" || EC(ui[this.layer].el, Pe, ze);
      }.bind({
        layer: T
      }), 24))), T++;
    } while (e.bubbleScroll && S !== m && (S = kl(S, !1)));
    q0 = v;
  }
}, 30), AC = function(e) {
  var r = e.originalEvent, n = e.putSortable, i = e.dragEl, l = e.activeSortable, h = e.dispatchSortableEvent, s = e.hideGhostForTarget, m = e.unhideGhostForTarget;
  if (!!r) {
    var v = n || l;
    s();
    var E = r.changedTouches && r.changedTouches.length ? r.changedTouches[0] : r, T = document.elementFromPoint(E.clientX, E.clientY);
    m(), v && !v.el.contains(T) && (h("spill"), this.onSpill({
      dragEl: i,
      putSortable: n
    }));
  }
};
function Jx() {
}
Jx.prototype = {
  startIndex: null,
  dragStart: function(e) {
    var r = e.oldDraggableIndex;
    this.startIndex = r;
  },
  onSpill: function(e) {
    var r = e.dragEl, n = e.putSortable;
    this.sortable.captureAnimationState(), n && n.captureAnimationState();
    var i = Bh(this.sortable.el, this.startIndex, this.options);
    i ? this.sortable.el.insertBefore(r, i) : this.sortable.el.appendChild(r), this.sortable.animateAll(), n && n.animateAll();
  },
  drop: AC
};
Gs(Jx, {
  pluginName: "revertOnSpill"
});
function Qx() {
}
Qx.prototype = {
  onSpill: function(e) {
    var r = e.dragEl, n = e.putSortable, i = n || this.sortable;
    i.captureAnimationState(), r.parentNode && r.parentNode.removeChild(r), i.animateAll();
  },
  drop: AC
};
Gs(Qx, {
  pluginName: "removeOnSpill"
});
nr.mount(new y9());
nr.mount(Qx, Jx);
const OC = 0.5, _9 = !1, uy = du(
  "slider",
  () => {
    const t = Ai(), e = Kr(OC), r = Kr(_9), n = un(
      () => [...t.layers].reverse()[0]
    );
    function i(h) {
      let s = h;
      h < 0.1 ? s = 0.1 : h > 0.9 && (s = 0.9), e.value = s;
    }
    function l(h) {
      r.value = h != null ? h : !r.value;
    }
    return {
      sliderActive: r,
      sliderRatio: e,
      sliderTopLayer: n,
      setRatio: i,
      toggleSlider: l
    };
  },
  {}
);
function RC(t, e) {
  const { t: r } = Hn();
  function n() {
    return r(t.name, { ns: "client" });
  }
  function i() {
    e == null || e.emit("clickInfo", t);
  }
  return {
    t: r,
    getLabel: n,
    onClickInfo: i
  };
}
const v9 = { class: "lux-layer-manager-item mt-2.5" }, x9 = ["title"], b9 = { class: "flex-1 text-left cursor-default" }, w9 = ["title"], E9 = /* @__PURE__ */ vr({
  __name: "layer-item-background",
  props: {
    showEditButton: { type: Boolean, required: !0 },
    layer: { type: null, required: !0 }
  },
  emits: ["clickEdit", "clickInfo"],
  setup(t, { emit: e }) {
    const r = t, { t: n, onClickInfo: i } = RC(r.layer, { emit: e }), l = un(
      () => n('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: h()
      })
    );
    function h() {
      return n(r.layer.name, { ns: "client" });
    }
    return (s, m) => (tt(), vt("div", v9, [
      $e("button", {
        class: "fa fa-info w-3",
        title: _e(l),
        onClick: m[0] || (m[0] = (...v) => _e(i) && _e(i)(...v))
      }, null, 8, x9),
      $e("span", b9, Vt(h()), 1),
      t.showEditButton ? (tt(), vt("button", {
        key: 0,
        class: "fa fa-pencil",
        title: _e(n)("Open editor panel", { ns: "client" }),
        onClick: m[1] || (m[1] = (v) => s.$emit("clickEdit"))
      }, null, 8, w9)) : Tt("v-if", !0)
    ]));
  }
}), T9 = /* @__PURE__ */ Mr(E9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item-background.vue"]]), S9 = { class: "lux-layer-manager-item relative" }, M9 = { class: "w-full flex flex-nowrap items-start gap-x-2" }, C9 = ["title"], I9 = ["title"], P9 = ["aria-expanded", "aria-controls", "data-cy"], A9 = ["aria-expanded", "aria-controls"], O9 = ["title"], R9 = ["id"], L9 = ["title"], D9 = ["id", "value", "aria-label"], k9 = ["aria-label"], N9 = /* @__PURE__ */ vr({
  __name: "layer-item",
  props: {
    layer: { type: null, required: !0 },
    draggableClassName: { type: String, required: !0 },
    isOpen: { type: Boolean, required: !0 },
    isLayerComparatorOpen: { type: Boolean, required: !0 },
    displayLayerComparatorOpen: { type: Boolean, required: !0 }
  },
  emits: [
    "clickInfo",
    "clickEdit",
    "changeOpacity",
    "clickToggle",
    "clickToggleLayerComparator",
    "clickRemove"
  ],
  setup(t, { emit: e }) {
    var q, H, ne, ee;
    const r = t, { t: n, getLabel: i, onClickInfo: l } = RC(r.layer, { emit: e }), h = yi(
      ((H = (q = r.layer) == null ? void 0 : q.opacity) != null ? H : 1) * 100
    ), s = yi(
      ((ee = (ne = r.layer) == null ? void 0 : ne.previousOpacity) != null ? ee : h.value) * 100
    ), m = un(
      () => n('Sort "{{layerName}}" in the list', {
        ns: "client",
        layerName: i()
      })
    ), v = un(
      () => n('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: i()
      })
    ), E = un(
      () => n('Remove layer "{{layerName}}"', {
        ns: "client",
        layerName: i()
      })
    );
    function T() {
      e("clickToggle", r.layer);
    }
    function S() {
      h.value === 0 ? h.value = s.value : (s.value = h.value, h.value = 0), j();
    }
    function A() {
      e("clickRemove", r.layer);
    }
    function L(he) {
      he.target && (h.value = parseInt(he.target.value), j());
    }
    function B() {
      e("clickToggleLayerComparator", r.layer);
    }
    function j() {
      e("changeOpacity", r.layer, h.value);
    }
    return (he, Te) => (tt(), vt("div", S9, [
      $e("div", M9, [
        $e("button", {
          class: Or(["fa-solid fa-bars cursor-move mt-1", t.draggableClassName]),
          title: _e(m)
        }, null, 10, C9),
        $e("button", {
          class: "fa-solid fa-info mt-1",
          title: _e(v),
          onClick: Te[0] || (Te[0] = (...ve) => _e(l) && _e(l)(...ve))
        }, null, 8, I9),
        $e("button", {
          "aria-expanded": r.isOpen,
          "aria-controls": `layer-manager-item-content-${r.layer.id}`,
          "data-cy": `myLayerItemLabel-${r.layer.id}`,
          class: "cursor-pointer grow text-left break-words w-[70%]",
          onClick: T
        }, Vt(_e(i)()), 9, P9),
        $e("button", {
          class: Or(["mt-1 w-3.5 fa-solid", r.isOpen ? "fa-xmark" : "fa-ellipsis"]),
          onClick: T,
          "aria-expanded": r.isOpen,
          "aria-controls": `layer-manager-item-content-${r.layer.id}`
        }, null, 10, A9),
        $e("button", {
          class: "mt-1 fa-solid fa-trash",
          title: _e(E),
          onClick: A
        }, null, 8, O9)
      ]),
      $e("div", {
        class: Or(["lux-layer-manager-item-content", r.isOpen ? "h-6" : "h-0"]),
        id: `layer-manager-item-content-${r.layer.id}`
      }, [
        $e("button", {
          title: _e(n)("Toggle layer opacity for {{layerName}}", {
            layerName: _e(n)(r.layer.name)
          }),
          class: Or(["w-5 fa-solid", _e(h) === 0 ? "fa-eye-slash" : "fa-eye"]),
          onClick: S
        }, null, 10, L9),
        $e("input", {
          id: `${r.layer.id}-steps-range`,
          type: "range",
          min: "0",
          max: "100",
          value: _e(h),
          step: "25",
          onChange: L,
          class: "m-2.5 w-16 h-[5px] rounded-lg appearance-none cursor-pointer",
          "aria-label": _e(n)("Change opacity for {{ layerName }}", { layerName: _e(i)() })
        }, null, 40, D9),
        t.displayLayerComparatorOpen ? (tt(), vt("button", {
          key: 0,
          class: Or(["fa ml-auto text-sm cursor-pointer", r.isLayerComparatorOpen ? "fa-adjust" : "fa-circle"]),
          "aria-label": _e(n)("Toggle layer comparator for {{ layerName }}", {
            layerName: _e(i)()
          }),
          onClick: B
        }, null, 10, k9)) : Tt("v-if", !0)
      ], 10, R9)
    ]));
  }
}), F9 = /* @__PURE__ */ Mr(N9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item.vue"]]), z9 = { id: "sortable-layers" }, B9 = ["id"], U9 = { class: "flex flex-row justify-center space-x-1 my-2" }, $9 = /* @__PURE__ */ vr({
  __name: "layer-manager",
  emits: ["displayCatalog"],
  setup(t, { emit: e }) {
    const { t: r } = Hn(), { setMetadataId: n } = Vx(), i = Ai(), l = di(), h = Wh(), s = uy(), { bgLayer: m } = mn(i), { sliderActive: v } = mn(s), E = un(() => [...i.layers].reverse()), T = yi(), S = "drag-handle", A = un(
      () => h.isLayerStyleEditable(m.value)
    ), { setRemoteLayersOpen: L } = di();
    aa(() => {
      const he = document.getElementById("sortable-layers");
      he && nr.create(he, {
        dataIdAttr: "data-id",
        dragClass: "lux-sortable-drag",
        ghostClass: "lux-sortable-ghost",
        sort: !0,
        handle: `.${S}`,
        onSort: B
      });
    });
    function B(he) {
      const Te = he.to.children;
      i.reorderLayers([...Te].map((ve) => Number(ve.id)).reverse());
    }
    function j(he, Te) {
      i.setLayerOpacity(he.id, Te / 100);
    }
    function q(he) {
      i.removeLayers(he.id);
    }
    function H(he) {
      T.value = T.value !== he.id ? he.id : void 0;
    }
    function ne() {
      l.openStyleEditorPanel();
    }
    function ee() {
      s.toggleSlider();
    }
    return (he, Te) => (tt(), vt("ul", z9, [
      (tt(!0), vt(pn, null, ka(_e(E), (ve, Oe) => (tt(), vt("li", {
        key: ve.id,
        id: ve.id
      }, [
        $t(F9, {
          draggableClassName: S,
          layer: ve,
          isOpen: _e(T) === ve.id,
          isLayerComparatorOpen: _e(v),
          displayLayerComparatorOpen: Oe === 0,
          onClickRemove: q,
          onClickToggle: H,
          onClickToggleLayerComparator: ee,
          onClickInfo: (Me) => _e(n)(ve.id),
          onChangeOpacity: j
        }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen", "onClickInfo"])
      ], 8, B9))), 128)),
      $e("li", null, [
        $t(T9, {
          layer: _e(m) || _e(ry),
          showEditButton: _e(A),
          onClickInfo: Te[0] || (Te[0] = () => _e(m) && _e(n)(_e(m).id)),
          onClickEdit: ne
        }, null, 8, ["layer", "showEditButton"]),
        $e("div", U9, [
          $e("button", {
            class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
            onClick: Te[1] || (Te[1] = (ve) => e("displayCatalog"))
          }, Vt(_e(r)("+ Add layers", { ns: "client" })), 1),
          $e("button", {
            class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
            onClick: Te[2] || (Te[2] = (ve) => _e(L)(!0))
          }, Vt(_e(r)("+ Add external Wms", { ns: "client" })), 1)
        ])
      ])
    ]));
  }
}), V9 = /* @__PURE__ */ Mr($9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-manager.vue"]]), j9 = { class: "flex flex-col h-full pt-1.5" }, G9 = { class: "h-16 shrink-0 flex justify-between lux-panel-title" }, q9 = ["aria-label"], W9 = { class: "flex flex-row gap-2 h-10 text-2xl" }, X9 = ["aria-expanded"], Z9 = { key: 0 }, H9 = ["aria-expanded"], K9 = { class: "relative grow p-2.5 bg-primary overflow-auto" }, Y9 = /* @__PURE__ */ vr({
  __name: "layer-panel",
  setup(t) {
    const { t: e } = Hn(), r = di(), { setLayersOpen: n } = r, { myLayersTabOpen: i } = mn(r), { layers: l } = mn(Ai());
    function h() {
      r.setMyLayersTabOpen(!0);
    }
    function s() {
      r.setMyLayersTabOpen(!1);
    }
    return (m, v) => (tt(), vt("div", j9, [
      Tt(" Panel title and close button "),
      $e("div", G9, [
        $e("h1", null, Vt(_e(e)("layers", { ns: "client" })), 1),
        $e("span", null, [
          $e("button", {
            onClick: v[0] || (v[0] = () => _e(n)(!1)),
            "aria-label": _e(e)("Close", { ns: "client" }),
            class: "fa-sharp fa-solid fa-close"
          }, null, 8, q9)
        ])
      ]),
      Tt(" My Layers and Catalog tab labels "),
      $e("div", W9, [
        $e("button", {
          onClick: h,
          class: Or(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", _e(i) ? "bg-primary" : "bg-tertiary"]),
          "aria-expanded": _e(i)
        }, [
          Ag(Vt(_e(e)("my_layers", { ns: "client" })) + " ", 1),
          _e(l).length ? (tt(), vt("span", Z9, "(" + Vt(_e(l).length) + ")", 1)) : Tt("v-if", !0)
        ], 10, X9),
        $e("button", {
          onClick: s,
          class: Or(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", _e(i) ? "bg-tertiary" : "bg-primary"]),
          "aria-expanded": !_e(i)
        }, Vt(_e(e)("Catalog", { ns: "client" })), 11, H9)
      ]),
      Tt(" Panel content (MyLayers and Catalog) "),
      $e("div", K9, [
        _e(i) ? (tt(), Un(V9, {
          key: 0,
          onDisplayCatalog: s
        })) : Tt("v-if", !0),
        _e(i) ? Tt("v-if", !0) : (tt(), Un(q7, { key: 1 }))
      ])
    ]));
  }
}), J9 = /* @__PURE__ */ Mr(Y9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-panel/layer-panel.vue"]]);
function Km(t, e) {
  return Xi(t.inversePixelTransform, e.slice(0));
}
class Q9 {
  bootstrap() {
    let e;
    e = Da(() => {
      this.restore(), this.persist(), e && e();
    });
  }
  persist() {
    const e = uy();
    An(
      [() => e.sliderActive, () => e.sliderRatio],
      ([r, n], [i]) => {
        r !== i && Sr.setValue(N0, r), Sr.setValue(
          F0,
          n
        );
      }
    );
  }
  restore() {
    const e = Sr.getValue(N0, Ux), r = Sr.getValue(F0, Ph), { toggleSlider: n, setRatio: i } = uy();
    typeof e < "u" && e !== null && (n(e), typeof r !== void 0 && r !== null && i(r != null ? r : OC));
  }
}
const eq = new Q9(), tq = ["onKeydown"], rq = /* @__PURE__ */ $e("span", { class: "lux-slider-line" }, null, -1), nq = /* @__PURE__ */ $e("span", { class: "lux-slider-arrows" }, [
  /* @__PURE__ */ $e("span"),
  /* @__PURE__ */ $e("span")
], -1), iq = {
  key: 0,
  class: "lux-slider-layer-label"
}, oq = /* @__PURE__ */ $e("i", { class: "fa fa-arrow-left mr-2" }, null, -1), aq = /* @__PURE__ */ vr({
  __name: "splitter-element",
  props: {
    sliderActive: { type: Boolean, required: !0 },
    sliderRatio: { type: Number, required: !0 },
    sliderTopLayer: { type: null, required: !0 },
    sliderOffset: { type: Number, required: !0 },
    containerOffset: { type: Number, required: !0 }
  },
  emits: ["moveSplitBar", "escSplitBar"],
  setup(t, { expose: e, emit: r }) {
    const n = t, i = 30, { t: l } = Hn(), h = Kr(null), s = un(() => ({ left: `${n.sliderOffset}px` }));
    let m = !1;
    e({
      sliderElement: h
    });
    function v(j) {
      r("moveSplitBar", j + h.value.offsetWidth / 2);
    }
    function E() {
      m = !0, document.addEventListener("mousemove", T), document.addEventListener("mouseup", S);
    }
    function T(j) {
      !m || v(j.clientX - n.containerOffset);
    }
    function S() {
      m = !1, document.removeEventListener("mousemove", T), document.removeEventListener("mouseup", S);
    }
    function A() {
      v(h.value.offsetLeft + i);
    }
    function L() {
      v(h.value.offsetLeft - i);
    }
    function B() {
      r("escSplitBar");
    }
    return aa(() => {
      var j;
      (j = h.value) == null || j.focus({ focusVisible: !0 });
    }), fu(() => {
      document.removeEventListener("mousemove", T), document.removeEventListener("mouseup", S);
    }), (j, q) => (tt(), vt("button", {
      ref_key: "sliderElement",
      ref: h,
      onMousedown: E,
      onMousemove: T,
      onMouseup: S,
      onKeydown: [
        ih(A, ["space"]),
        ih(A, ["right"]),
        ih(L, ["left"]),
        ih(L, ["delete"]),
        ih(B, ["esc"])
      ],
      class: "left-[20px] absolute h-full w-[32px] block",
      style: Uh(_e(s)),
      role: "seperator",
      "aria-controls": "map-container"
    }, [
      rq,
      nq,
      t.sliderTopLayer ? (tt(), vt("span", iq, [
        oq,
        $e("span", null, Vt(_e(l)(t.sliderTopLayer.name)), 1)
      ])) : Tt("v-if", !0)
    ], 44, tq));
  }
}), sq = /* @__PURE__ */ Mr(aq, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/slider/splitter-element.vue"]]), lq = /* @__PURE__ */ vr({
  __name: "slider-comparator",
  setup(t) {
    const e = uy(), r = WM(), n = zs().olMap, i = Kr(null), { sliderActive: l, sliderRatio: h, sliderTopLayer: s } = mn(e), m = un(
      () => {
        var q, H;
        return ((H = (q = i.value) == null ? void 0 : q.sliderElement) == null ? void 0 : H.offsetWidth) || 0;
      }
    ), v = un(
      () => {
        var q, H;
        return n.value && i.value ? h.value * n.value.getSize()[0] - ((H = (q = i.value) == null ? void 0 : q.sliderElement) == null ? void 0 : H.offsetWidth) / 2 + n.value.getViewport().offsetLeft : 0;
      }
    );
    let E, T, S;
    eq.bootstrap(), An([s, l], ([q, H], [ne]) => {
      var ee;
      q && H ? (q !== ne && L(), A()) : L(), (ee = n.value) == null || ee.render();
    }), An(v, () => {
      var q;
      (q = n.value) == null || q.render();
    });
    function A() {
      const q = r.getLayerFromCache(s.value);
      E = q.on(
        ns.PRERENDER,
        function(H) {
          var Re;
          const ne = H.context, ee = (Re = n.value) == null ? void 0 : Re.getSize(), he = v.value + m.value / 2, Te = Km(H, [0, 0]), ve = Km(H, [he, 0]), Oe = Km(H, [0, ee[1]]), Me = Km(H, [he, ee[0]]);
          ne.save(), ne.beginPath(), ne.moveTo(Te[0], Te[1]), ne.lineTo(Oe[0], Oe[1]), ne.lineTo(Me[0], Me[1]), ne.lineTo(ve[0], ve[1]), ne.closePath(), ne.clip();
        }
      ), T = q.on(
        ns.POSTRENDER,
        function(H) {
          H.context.restore();
        }
      );
    }
    function L() {
      z2([E, T]);
    }
    function B(q) {
      var ee;
      const H = (ee = n.value) == null ? void 0 : ee.getSize(), ne = q / H[0];
      e.setRatio(ne);
    }
    function j() {
      e.toggleSlider();
    }
    return aa(() => {
      var q, H;
      S = (H = (q = n.value) == null ? void 0 : q.getTargetElement()) == null ? void 0 : H.closest(".map-wrapper");
    }), fu(() => {
      L();
    }), (q, H) => {
      var ne;
      return _e(s) && _e(l) ? (tt(), Un(sq, {
        key: 0,
        ref_key: "splitterElement",
        ref: i,
        sliderActive: _e(l),
        sliderRatio: _e(h),
        sliderTopLayer: _e(s),
        sliderOffset: _e(v),
        containerOffset: ((ne = _e(S)) == null ? void 0 : ne.offsetLeft) || 0,
        onMoveSplitBar: B,
        onEscSplitBar: j
      }, null, 8, ["sliderActive", "sliderRatio", "sliderTopLayer", "sliderOffset", "containerOffset"])) : Tt("v-if", !0);
    };
  }
}), cq = /* @__PURE__ */ Mr(lq, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/slider/slider-comparator.vue"]]), Ym = "-", qv = ",";
class uq {
  constructor() {
    ei(this, "layersOpacitiesToNumbersV2", (e) => this.layersOpacitiesToNumbers(e, qv));
  }
  layerIdsToLayers(e) {
    const r = $l(), n = zd();
    return (e ? e.split(Ym) : []).map((l) => {
      const h = tu.isRemoteLayer(l) ? eG(l) : r.findById(parseInt(l, 10));
      return h ? n.initLayer(h) : void 0;
    });
  }
  layerNamesToLayersV2(e) {
    const r = $l(), n = zd();
    return (e ? e.split(qv) : []).map((l) => {
      const h = r.findByName(l);
      return h ? n.initLayer(h) : void 0;
    });
  }
  layersOpacitiesToNumbers(e, r = Ym) {
    return P8(e, r);
  }
  layersVisibilitiesToBooleansV2(e) {
    return A8(e, qv);
  }
  layersToLayerIds(e) {
    return (e == null ? void 0 : e.map((r) => r.id).join(Ym)) || "";
  }
  layersToLayerOpacities(e) {
    return (e == null ? void 0 : e.map((r) => {
      var n;
      return (n = r.opacity) != null ? n : 1;
    }).join(Ym)) || "";
  }
  bgLayerNameToBgLayer(e) {
    const r = $l();
    return e ? r.findBgLayerByName(e) : null;
  }
  bgLayerToBgLayerName(e) {
    return (e == null ? void 0 : e.name) || ry.name;
  }
}
const Ea = new uq(), hq = "basemap_2015_global", fq = "orthogr_2013_global", dq = {
  webbasemap: "basemap_2015_global",
  "pixelmaps-color": "topogr_global",
  "pixelmaps-gray": "topo_bw_jpeg",
  streets: "streets_jpeg",
  voidlayer: "blank"
};
class pq {
  bootstrap() {
    const e = Co();
    let r;
    r = Da(() => {
      e.bgLayers.length > 0 && (this.restore(), this.persist(), r && r());
    });
  }
  persist() {
    const e = Ai(), { bgLayer: r } = mn(e);
    An(
      r,
      (n, i) => {
        i !== n && Sr.setValue(
          TE,
          n,
          Ea.bgLayerToBgLayerName
        );
      },
      { immediate: !0 }
    );
  }
  restore() {
    const { setMapBackground: e } = YM(), r = this.getBgLayerFromStorage();
    e(r);
  }
  getBgLayerFromStorage() {
    const e = Sr.getInitialVersion(), r = Sr.getValue(TE);
    return r ? e === 2 ? this.getBgLayerFromStorageV2(r) : Ea.bgLayerNameToBgLayer(r) : Ea.bgLayerNameToBgLayer(hq);
  }
  getBgLayerFromStorageV2(e) {
    const r = Sr.getValue(
      BM,
      Ph
    );
    let n = "";
    return e ? n = dq[e] : r === 0 && (n = fq), Ea.bgLayerNameToBgLayer(n);
  }
}
const mq = new pq();
class gq {
  bootstrap() {
    const e = Co();
    let r;
    r = Da(() => {
      e.themes && (this.restore(), this.persist(), r && r());
    });
  }
  persist() {
    const e = Ai(), { layers: r } = mn(e);
    An(
      r,
      (n, i) => {
        i !== n && (Sr.setValue(
          EE,
          n,
          Ea.layersToLayerIds
        ), Sr.setValue(
          SE,
          n,
          Ea.layersToLayerOpacities
        ));
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Sr.getInitialVersion(), r = Ai(), n = Sr.getValue(
      EE,
      e === 2 ? Ea.layerNamesToLayersV2 : Ea.layerIdsToLayers
    ), i = e === 2 ? this.getOpacitiesFromStorageV2() : this.getOpacitiesFromStorage();
    i && (n == null || n.forEach((l, h) => {
      var s;
      l && (l.opacity = (s = i[h]) != null ? s : 1);
    })), e === 2 && (Sr.removeItem(BM), Sr.removeItem(L8), Sr.removeItem(PE), Sr.removeItem(AE)), r.addLayers(...(n == null ? void 0 : n.filter((l) => l)) || []);
  }
  getOpacitiesFromStorage() {
    return Sr.getValue(
      SE,
      Ea.layersOpacitiesToNumbers
    );
  }
  getOpacitiesFromStorageV2() {
    const e = Sr.getValue(
      PE,
      Ea.layersOpacitiesToNumbersV2
    ), r = Sr.getValue(
      AE,
      Ea.layersVisibilitiesToBooleansV2
    );
    return e.map((n, i) => r[i] ? n : 0);
  }
}
const yq = new gq();
class _q {
  themeToThemeName(e) {
    return (e == null ? void 0 : e.name) || "";
  }
}
const vq = new _q();
class xq {
  bootstrap() {
    this.restore();
    let e;
    e = Da(() => {
      this.persist(), e && e();
    });
  }
  persist() {
    const e = Co();
    An(
      () => e.theme,
      (r, n) => {
        n !== r && r && Sr.setValue(
          Fd,
          r,
          vq.themeToThemeName
        );
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Sr.getValue(Fd);
    if (e) {
      const { setTheme: r } = Co();
      r(e);
    }
  }
}
const bq = new xq();
class wq {
  bootstrapLayersOpen() {
    this.restoreLayersOpen();
    let e;
    e = Da(() => {
      this.persistLayersOpen(), e && e();
    });
  }
  persistLayersOpen() {
    const e = di(), { layersOpen: r } = mn(e);
    An(
      r,
      (n, i) => {
        i !== n && Sr.setValue(Hg, n);
      },
      { immediate: !0 }
    );
  }
  restoreLayersOpen() {
    const e = Sr.getValue(Hg) !== "false", { setLayersOpen: r } = di();
    r(e);
  }
}
const Eq = new wq();
class Tq {
  bootstrap() {
    this.restore();
    let e;
    e = Da(() => {
      this.persist(), e && e();
    });
  }
  persist() {
  }
  restore() {
    const e = Sr.getValue(O8);
    di().setMapId(e);
  }
}
const Sq = new Tq();
function W0(t) {
  return W0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, W0(t);
}
var LC = [], Mq = LC.forEach, Cq = LC.slice;
function X0(t) {
  return Mq.call(Cq.call(arguments, 1), function(e) {
    if (e)
      for (var r in e)
        t[r] === void 0 && (t[r] = e[r]);
  }), t;
}
function DC() {
  return typeof XMLHttpRequest == "function" || (typeof XMLHttpRequest > "u" ? "undefined" : W0(XMLHttpRequest)) === "object";
}
function Iq(t) {
  return !!t && typeof t.then == "function";
}
function Pq(t) {
  return Iq(t) ? t : Promise.resolve(t);
}
function Aq(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var hy = { exports: {} }, Jm = { exports: {} }, pT;
function Oq() {
  return pT || (pT = 1, function(t, e) {
    var r = typeof self < "u" ? self : Ja, n = function() {
      function l() {
        this.fetch = !1, this.DOMException = r.DOMException;
      }
      return l.prototype = r, new l();
    }();
    (function(l) {
      (function(h) {
        var s = {
          searchParams: "URLSearchParams" in l,
          iterable: "Symbol" in l && "iterator" in Symbol,
          blob: "FileReader" in l && "Blob" in l && function() {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          }(),
          formData: "FormData" in l,
          arrayBuffer: "ArrayBuffer" in l
        };
        function m(xe) {
          return xe && DataView.prototype.isPrototypeOf(xe);
        }
        if (s.arrayBuffer)
          var v = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ], E = ArrayBuffer.isView || function(xe) {
            return xe && v.indexOf(Object.prototype.toString.call(xe)) > -1;
          };
        function T(xe) {
          if (typeof xe != "string" && (xe = String(xe)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(xe))
            throw new TypeError("Invalid character in header field name");
          return xe.toLowerCase();
        }
        function S(xe) {
          return typeof xe != "string" && (xe = String(xe)), xe;
        }
        function A(xe) {
          var ze = {
            next: function() {
              var Pe = xe.shift();
              return { done: Pe === void 0, value: Pe };
            }
          };
          return s.iterable && (ze[Symbol.iterator] = function() {
            return ze;
          }), ze;
        }
        function L(xe) {
          this.map = {}, xe instanceof L ? xe.forEach(function(ze, Pe) {
            this.append(Pe, ze);
          }, this) : Array.isArray(xe) ? xe.forEach(function(ze) {
            this.append(ze[0], ze[1]);
          }, this) : xe && Object.getOwnPropertyNames(xe).forEach(function(ze) {
            this.append(ze, xe[ze]);
          }, this);
        }
        L.prototype.append = function(xe, ze) {
          xe = T(xe), ze = S(ze);
          var Pe = this.map[xe];
          this.map[xe] = Pe ? Pe + ", " + ze : ze;
        }, L.prototype.delete = function(xe) {
          delete this.map[T(xe)];
        }, L.prototype.get = function(xe) {
          return xe = T(xe), this.has(xe) ? this.map[xe] : null;
        }, L.prototype.has = function(xe) {
          return this.map.hasOwnProperty(T(xe));
        }, L.prototype.set = function(xe, ze) {
          this.map[T(xe)] = S(ze);
        }, L.prototype.forEach = function(xe, ze) {
          for (var Pe in this.map)
            this.map.hasOwnProperty(Pe) && xe.call(ze, this.map[Pe], Pe, this);
        }, L.prototype.keys = function() {
          var xe = [];
          return this.forEach(function(ze, Pe) {
            xe.push(Pe);
          }), A(xe);
        }, L.prototype.values = function() {
          var xe = [];
          return this.forEach(function(ze) {
            xe.push(ze);
          }), A(xe);
        }, L.prototype.entries = function() {
          var xe = [];
          return this.forEach(function(ze, Pe) {
            xe.push([Pe, ze]);
          }), A(xe);
        }, s.iterable && (L.prototype[Symbol.iterator] = L.prototype.entries);
        function B(xe) {
          if (xe.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
          xe.bodyUsed = !0;
        }
        function j(xe) {
          return new Promise(function(ze, Pe) {
            xe.onload = function() {
              ze(xe.result);
            }, xe.onerror = function() {
              Pe(xe.error);
            };
          });
        }
        function q(xe) {
          var ze = new FileReader(), Pe = j(ze);
          return ze.readAsArrayBuffer(xe), Pe;
        }
        function H(xe) {
          var ze = new FileReader(), Pe = j(ze);
          return ze.readAsText(xe), Pe;
        }
        function ne(xe) {
          for (var ze = new Uint8Array(xe), Pe = new Array(ze.length), Ye = 0; Ye < ze.length; Ye++)
            Pe[Ye] = String.fromCharCode(ze[Ye]);
          return Pe.join("");
        }
        function ee(xe) {
          if (xe.slice)
            return xe.slice(0);
          var ze = new Uint8Array(xe.byteLength);
          return ze.set(new Uint8Array(xe)), ze.buffer;
        }
        function he() {
          return this.bodyUsed = !1, this._initBody = function(xe) {
            this._bodyInit = xe, xe ? typeof xe == "string" ? this._bodyText = xe : s.blob && Blob.prototype.isPrototypeOf(xe) ? this._bodyBlob = xe : s.formData && FormData.prototype.isPrototypeOf(xe) ? this._bodyFormData = xe : s.searchParams && URLSearchParams.prototype.isPrototypeOf(xe) ? this._bodyText = xe.toString() : s.arrayBuffer && s.blob && m(xe) ? (this._bodyArrayBuffer = ee(xe.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : s.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(xe) || E(xe)) ? this._bodyArrayBuffer = ee(xe) : this._bodyText = xe = Object.prototype.toString.call(xe) : this._bodyText = "", this.headers.get("content-type") || (typeof xe == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : s.searchParams && URLSearchParams.prototype.isPrototypeOf(xe) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
          }, s.blob && (this.blob = function() {
            var xe = B(this);
            if (xe)
              return xe;
            if (this._bodyBlob)
              return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]));
          }, this.arrayBuffer = function() {
            return this._bodyArrayBuffer ? B(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(q);
          }), this.text = function() {
            var xe = B(this);
            if (xe)
              return xe;
            if (this._bodyBlob)
              return H(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(ne(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }, s.formData && (this.formData = function() {
            return this.text().then(Me);
          }), this.json = function() {
            return this.text().then(JSON.parse);
          }, this;
        }
        var Te = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function ve(xe) {
          var ze = xe.toUpperCase();
          return Te.indexOf(ze) > -1 ? ze : xe;
        }
        function Oe(xe, ze) {
          ze = ze || {};
          var Pe = ze.body;
          if (xe instanceof Oe) {
            if (xe.bodyUsed)
              throw new TypeError("Already read");
            this.url = xe.url, this.credentials = xe.credentials, ze.headers || (this.headers = new L(xe.headers)), this.method = xe.method, this.mode = xe.mode, this.signal = xe.signal, !Pe && xe._bodyInit != null && (Pe = xe._bodyInit, xe.bodyUsed = !0);
          } else
            this.url = String(xe);
          if (this.credentials = ze.credentials || this.credentials || "same-origin", (ze.headers || !this.headers) && (this.headers = new L(ze.headers)), this.method = ve(ze.method || this.method || "GET"), this.mode = ze.mode || this.mode || null, this.signal = ze.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && Pe)
            throw new TypeError("Body not allowed for GET or HEAD requests");
          this._initBody(Pe);
        }
        Oe.prototype.clone = function() {
          return new Oe(this, { body: this._bodyInit });
        };
        function Me(xe) {
          var ze = new FormData();
          return xe.trim().split("&").forEach(function(Pe) {
            if (Pe) {
              var Ye = Pe.split("="), it = Ye.shift().replace(/\+/g, " "), kt = Ye.join("=").replace(/\+/g, " ");
              ze.append(decodeURIComponent(it), decodeURIComponent(kt));
            }
          }), ze;
        }
        function Re(xe) {
          var ze = new L(), Pe = xe.replace(/\r?\n[\t ]+/g, " ");
          return Pe.split(/\r?\n/).forEach(function(Ye) {
            var it = Ye.split(":"), kt = it.shift().trim();
            if (kt) {
              var Er = it.join(":").trim();
              ze.append(kt, Er);
            }
          }), ze;
        }
        he.call(Oe.prototype);
        function He(xe, ze) {
          ze || (ze = {}), this.type = "default", this.status = ze.status === void 0 ? 200 : ze.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in ze ? ze.statusText : "OK", this.headers = new L(ze.headers), this.url = ze.url || "", this._initBody(xe);
        }
        he.call(He.prototype), He.prototype.clone = function() {
          return new He(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new L(this.headers),
            url: this.url
          });
        }, He.error = function() {
          var xe = new He(null, { status: 0, statusText: "" });
          return xe.type = "error", xe;
        };
        var Ve = [301, 302, 303, 307, 308];
        He.redirect = function(xe, ze) {
          if (Ve.indexOf(ze) === -1)
            throw new RangeError("Invalid status code");
          return new He(null, { status: ze, headers: { location: xe } });
        }, h.DOMException = l.DOMException;
        try {
          new h.DOMException();
        } catch {
          h.DOMException = function(ze, Pe) {
            this.message = ze, this.name = Pe;
            var Ye = Error(ze);
            this.stack = Ye.stack;
          }, h.DOMException.prototype = Object.create(Error.prototype), h.DOMException.prototype.constructor = h.DOMException;
        }
        function dt(xe, ze) {
          return new Promise(function(Pe, Ye) {
            var it = new Oe(xe, ze);
            if (it.signal && it.signal.aborted)
              return Ye(new h.DOMException("Aborted", "AbortError"));
            var kt = new XMLHttpRequest();
            function Er() {
              kt.abort();
            }
            kt.onload = function() {
              var mr = {
                status: kt.status,
                statusText: kt.statusText,
                headers: Re(kt.getAllResponseHeaders() || "")
              };
              mr.url = "responseURL" in kt ? kt.responseURL : mr.headers.get("X-Request-URL");
              var Yt = "response" in kt ? kt.response : kt.responseText;
              Pe(new He(Yt, mr));
            }, kt.onerror = function() {
              Ye(new TypeError("Network request failed"));
            }, kt.ontimeout = function() {
              Ye(new TypeError("Network request failed"));
            }, kt.onabort = function() {
              Ye(new h.DOMException("Aborted", "AbortError"));
            }, kt.open(it.method, it.url, !0), it.credentials === "include" ? kt.withCredentials = !0 : it.credentials === "omit" && (kt.withCredentials = !1), "responseType" in kt && s.blob && (kt.responseType = "blob"), it.headers.forEach(function(mr, Yt) {
              kt.setRequestHeader(Yt, mr);
            }), it.signal && (it.signal.addEventListener("abort", Er), kt.onreadystatechange = function() {
              kt.readyState === 4 && it.signal.removeEventListener("abort", Er);
            }), kt.send(typeof it._bodyInit > "u" ? null : it._bodyInit);
          });
        }
        return dt.polyfill = !0, l.fetch || (l.fetch = dt, l.Headers = L, l.Request = Oe, l.Response = He), h.Headers = L, h.Request = Oe, h.Response = He, h.fetch = dt, Object.defineProperty(h, "__esModule", { value: !0 }), h;
      })({});
    })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
    var i = n;
    e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, t.exports = e;
  }(Jm, Jm.exports)), Jm.exports;
}
(function(t, e) {
  var r;
  if (typeof fetch == "function" && (typeof Ja < "u" && Ja.fetch ? r = Ja.fetch : typeof window < "u" && window.fetch ? r = window.fetch : r = fetch), typeof Aq < "u" && (typeof window > "u" || typeof window.document > "u")) {
    var n = r || Oq();
    n.default && (n = n.default), e.default = n, t.exports = e.default;
  }
})(hy, hy.exports);
const kC = hy.exports, mT = /* @__PURE__ */ PP({
  __proto__: null,
  default: kC
}, [hy.exports]);
function fy(t) {
  return fy = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, fy(t);
}
var $s;
typeof fetch == "function" && (typeof global < "u" && global.fetch ? $s = global.fetch : typeof window < "u" && window.fetch ? $s = window.fetch : $s = fetch);
var Bd;
DC() && (typeof global < "u" && global.XMLHttpRequest ? Bd = global.XMLHttpRequest : typeof window < "u" && window.XMLHttpRequest && (Bd = window.XMLHttpRequest));
var dy;
typeof ActiveXObject == "function" && (typeof global < "u" && global.ActiveXObject ? dy = global.ActiveXObject : typeof window < "u" && window.ActiveXObject && (dy = window.ActiveXObject));
!$s && mT && !Bd && !dy && ($s = kC || mT);
typeof $s != "function" && ($s = void 0);
var Z0 = function(e, r) {
  if (r && fy(r) === "object") {
    var n = "";
    for (var i in r)
      n += "&" + encodeURIComponent(i) + "=" + encodeURIComponent(r[i]);
    if (!n)
      return e;
    e = e + (e.indexOf("?") !== -1 ? "&" : "?") + n.slice(1);
  }
  return e;
}, gT = function(e, r, n) {
  $s(e, r).then(function(i) {
    if (!i.ok)
      return n(i.statusText || "Error", {
        status: i.status
      });
    i.text().then(function(l) {
      n(null, {
        status: i.status,
        data: l
      });
    }).catch(n);
  }).catch(n);
}, yT = !1, Rq = function(e, r, n, i) {
  e.queryStringParams && (r = Z0(r, e.queryStringParams));
  var l = X0({}, typeof e.customHeaders == "function" ? e.customHeaders() : e.customHeaders);
  n && (l["Content-Type"] = "application/json");
  var h = typeof e.requestOptions == "function" ? e.requestOptions(n) : e.requestOptions, s = X0({
    method: n ? "POST" : "GET",
    body: n ? e.stringify(n) : void 0,
    headers: l
  }, yT ? {} : h);
  try {
    gT(r, s, i);
  } catch (m) {
    if (!h || Object.keys(h).length === 0 || !m.message || m.message.indexOf("not implemented") < 0)
      return i(m);
    try {
      Object.keys(h).forEach(function(v) {
        delete s[v];
      }), gT(r, s, i), yT = !0;
    } catch (v) {
      i(v);
    }
  }
}, Lq = function(e, r, n, i) {
  n && fy(n) === "object" && (n = Z0("", n).slice(1)), e.queryStringParams && (r = Z0(r, e.queryStringParams));
  try {
    var l;
    Bd ? l = new Bd() : l = new dy("MSXML2.XMLHTTP.3.0"), l.open(n ? "POST" : "GET", r, 1), e.crossDomain || l.setRequestHeader("X-Requested-With", "XMLHttpRequest"), l.withCredentials = !!e.withCredentials, n && l.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), l.overrideMimeType && l.overrideMimeType("application/json");
    var h = e.customHeaders;
    if (h = typeof h == "function" ? h() : h, h)
      for (var s in h)
        l.setRequestHeader(s, h[s]);
    l.onreadystatechange = function() {
      l.readyState > 3 && i(l.status >= 400 ? l.statusText : null, {
        status: l.status,
        data: l.responseText
      });
    }, l.send(n);
  } catch (m) {
    console && console.log(m);
  }
}, Dq = function(e, r, n, i) {
  if (typeof n == "function" && (i = n, n = void 0), i = i || function() {
  }, $s && r.indexOf("file:") !== 0)
    return Rq(e, r, n, i);
  if (DC() || typeof ActiveXObject == "function")
    return Lq(e, r, n, i);
  i(new Error("No fetch and no xhr implementation found!"));
};
function Ud(t) {
  return Ud = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Ud(t);
}
function kq(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _T(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, NC(n.key), n);
  }
}
function Nq(t, e, r) {
  return e && _T(t.prototype, e), r && _T(t, r), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function Fq(t, e, r) {
  return e = NC(e), e in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
}
function NC(t) {
  var e = zq(t, "string");
  return Ud(e) === "symbol" ? e : String(e);
}
function zq(t, e) {
  if (Ud(t) !== "object" || t === null)
    return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e || "default");
    if (Ud(n) !== "object")
      return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var Bq = function() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    allowMultiLoading: !1,
    parse: function(r) {
      return JSON.parse(r);
    },
    stringify: JSON.stringify,
    parsePayload: function(r, n, i) {
      return Fq({}, n, i || "");
    },
    request: Dq,
    reloadInterval: typeof window < "u" ? !1 : 60 * 60 * 1e3,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: !1,
    withCredentials: !1,
    overrideMimeType: !1,
    requestOptions: {
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
}, FC = function() {
  function t(e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    kq(this, t), this.services = e, this.options = r, this.allOptions = n, this.type = "backend", this.init(e, r, n);
  }
  return Nq(t, [{
    key: "init",
    value: function(r) {
      var n = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = r, this.options = X0(i, this.options || {}, Bq()), this.allOptions = l, this.services && this.options.reloadInterval && setInterval(function() {
        return n.reload();
      }, this.options.reloadInterval);
    }
  }, {
    key: "readMulti",
    value: function(r, n, i) {
      this._readAny(r, r, n, n, i);
    }
  }, {
    key: "read",
    value: function(r, n, i) {
      this._readAny([r], r, [n], n, i);
    }
  }, {
    key: "_readAny",
    value: function(r, n, i, l, h) {
      var s = this, m = this.options.loadPath;
      typeof this.options.loadPath == "function" && (m = this.options.loadPath(r, i)), m = Pq(m), m.then(function(v) {
        if (!v)
          return h(null, {});
        var E = s.services.interpolator.interpolate(v, {
          lng: r.join("+"),
          ns: i.join("+")
        });
        s.loadUrl(E, h, n, l);
      });
    }
  }, {
    key: "loadUrl",
    value: function(r, n, i, l) {
      var h = this;
      this.options.request(this.options, r, void 0, function(s, m) {
        if (m && (m.status >= 500 && m.status < 600 || !m.status))
          return n("failed loading " + r + "; status code: " + m.status, !0);
        if (m && m.status >= 400 && m.status < 500)
          return n("failed loading " + r + "; status code: " + m.status, !1);
        if (!m && s && s.message && s.message.indexOf("Failed to fetch") > -1)
          return n("failed loading " + r + ": " + s.message, !0);
        if (s)
          return n(s, !1);
        var v, E;
        try {
          typeof m.data == "string" ? v = h.options.parse(m.data, i, l) : v = m.data;
        } catch {
          E = "failed parsing " + r + " to json";
        }
        if (E)
          return n(E, !1);
        n(null, v);
      });
    }
  }, {
    key: "create",
    value: function(r, n, i, l, h) {
      var s = this;
      if (!!this.options.addPath) {
        typeof r == "string" && (r = [r]);
        var m = this.options.parsePayload(n, i, l), v = 0, E = [], T = [];
        r.forEach(function(S) {
          var A = s.options.addPath;
          typeof s.options.addPath == "function" && (A = s.options.addPath(S, n));
          var L = s.services.interpolator.interpolate(A, {
            lng: S,
            ns: n
          });
          s.options.request(s.options, L, m, function(B, j) {
            v += 1, E.push(B), T.push(j), v === r.length && typeof h == "function" && h(E, T);
          });
        });
      }
    }
  }, {
    key: "reload",
    value: function() {
      var r = this, n = this.services, i = n.backendConnector, l = n.languageUtils, h = n.logger, s = i.language;
      if (!(s && s.toLowerCase() === "cimode")) {
        var m = [], v = function(T) {
          var S = l.toResolveHierarchy(T);
          S.forEach(function(A) {
            m.indexOf(A) < 0 && m.push(A);
          });
        };
        v(s), this.allOptions.preload && this.allOptions.preload.forEach(function(E) {
          return v(E);
        }), m.forEach(function(E) {
          r.allOptions.ns.forEach(function(T) {
            i.read(E, T, "read", null, null, function(S, A) {
              S && h.warn("loading namespace ".concat(T, " for language ").concat(E, " failed"), S), !S && A && h.log("loaded namespace ".concat(T, " for language ").concat(E), A), i.loaded("".concat(E, "|").concat(T), S, A);
            });
          });
        });
      }
    }
  }]), t;
}();
FC.type = "backend";
const Uq = /* @__PURE__ */ vr({
  __name: "simple-style-item",
  props: {
    styleName: { type: String, required: !0 },
    colors: { type: Array, required: !0 }
  },
  setup(t) {
    const e = t;
    return (r, n) => (tt(!0), vt(pn, null, ka(e.colors, (i, l) => (tt(), vt("span", {
      key: `${t.styleName}-${l}`,
      class: "grow m-px",
      style: Uh(`background-color: ${i}`)
    }, " \xA0 ", 4))), 128));
  }
}), $q = /* @__PURE__ */ Mr(Uq, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/simple-style-item.vue"]]), Vq = { class: "text-white border-2 p-[10px] m-[10px]" }, jq = { class: "text-center mb-3" }, Gq = ["title"], qq = { class: "text-white" }, Wq = ["title", "onClick"], Xq = { class: "flex" }, Zq = /* @__PURE__ */ vr({
  __name: "simple-style-selector",
  setup(t) {
    const { t: e } = Hn(), r = Bs(), n = Wh(), { bgStyle: i } = mn(r), l = Pa().simple_styles.road, h = Kr(l);
    An(
      i,
      (m) => h.value = n.checkSelection(
        m || [],
        l
      ),
      { immediate: !0 }
    );
    function s(m) {
      r.setSimpleStyle(m);
    }
    return (m, v) => (tt(), vt("div", Vq, [
      Tt(" TODO: create clean container for simple and advanced style editors "),
      $e("h5", jq, Vt(_e(e)("Select a style", { ns: "client" })), 1),
      (tt(!0), vt(pn, null, ka(h.value, (E) => (tt(), vt("div", {
        key: E.unlocalized_label,
        title: _e(e)(E.unlocalized_label, { ns: "client" }),
        class: Or(`${E.selected ? "border-dotted" : "border-hidden"} border-2 p-px`)
      }, [
        $e("span", qq, Vt(_e(e)(E.unlocalized_label, { ns: "client" })) + " : ", 1),
        $e("button", {
          title: _e(e)("Select style: {{styleName}}", {
            styleName: _e(e)(E.unlocalized_label)
          }),
          onClick: (T) => s(E),
          class: "w-full"
        }, [
          $e("span", Xq, [
            $t($q, {
              colors: E.colors,
              "style-name": E.unlocalized_label
            }, null, 8, ["colors", "style-name"])
          ])
        ], 8, Wq)
      ], 10, Gq))), 128))
    ]));
  }
}), Hq = /* @__PURE__ */ Mr(Zq, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/simple-style-selector.vue"]]);
function Kq(t) {
  const e = Yq(t);
  return !e || !e.medium_style_class ? [] : Pa().medium_default_styles[e.medium_style_class];
}
function Yq(t) {
  return Pa().bg_layers.find((e) => e.id == (t == null ? void 0 : t.id));
}
const Jq = { class: "flex w-full items-center" }, Qq = {
  for: "colorId",
  class: "w-40"
}, eW = { class: "grow" }, tW = ["value"], rW = ["checked", "aria-label"], nW = /* @__PURE__ */ vr({
  __name: "medium-style-item",
  props: {
    style: { type: null, required: !0 },
    colorEditable: { type: Boolean, required: !0 }
  },
  emits: ["changeStyle"],
  setup(t, { emit: e }) {
    const r = t, { t: n } = Hn();
    function i(h) {
      if (h.target) {
        const s = {
          ...r.style,
          color: h.target.value
        };
        e("changeStyle", s);
      }
    }
    function l(h) {
      if (h) {
        const s = {
          ...r.style,
          visible: h.target.checked
        };
        e("changeStyle", s);
      }
    }
    return (h, s) => (tt(), vt("div", Jq, [
      $e("label", Qq, Vt(_e(n)(t.style.label)), 1),
      $e("div", eW, [
        t.colorEditable && r.style.color ? (tt(), vt("input", {
          key: 0,
          id: "colorId",
          type: "color",
          class: "w-11 h-5 py-[1px] px-[2px]",
          value: r.style.color,
          onInput: i
        }, null, 40, tW)) : Tt("v-if", !0)
      ]),
      $e("input", {
        type: "checkbox",
        class: "flex-none mr-3",
        checked: r.style.visible,
        onChange: l,
        "aria-label": _e(n)("Show or hide {{ thematicName }}", {
          thematicName: r.style.label
        })
      }, null, 40, rW)
    ]));
  }
}), iW = /* @__PURE__ */ Mr(nW, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/medium-style-item.vue"]]), oW = { class: "text-white border-2 p-[10px] m-[10px]" }, aW = { class: "text-center mb-3" }, sW = /* @__PURE__ */ vr({
  __name: "medium-style-selector",
  props: {
    layer: { type: null, required: !0 }
  },
  setup(t) {
    const e = t, r = ["basemap_2015_global"], n = Bs(), { bgStyle: i } = mn(n), { t: l } = Hn(), h = un(
      () => r.includes(e.layer.name)
    ), s = un(
      () => i.value || Kq(e.layer)
    );
    function m(v, E) {
      i.value = s.value.map(
        (T, S) => S === v ? E : T
      ), n.disableExpertStyle();
    }
    return (v, E) => (tt(), vt("div", oW, [
      $e("h5", aW, Vt(_e(h) ? _e(l)("Select a colour for every theme") : _e(l)("Activate categories")), 1),
      (tt(!0), vt(pn, null, ka(_e(s), (T, S) => (tt(), Un(iW, {
        key: T.label,
        style: Uh(T),
        onChangeStyle: (A) => m(S, A),
        colorEditable: _e(h)
      }, null, 8, ["style", "onChangeStyle", "colorEditable"]))), 128))
    ]));
  }
}), lW = /* @__PURE__ */ Mr(sW, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/medium-style-selector.vue"]]);
var zC = { exports: {} };
(function(t, e) {
  (function(r, n) {
    n();
  })(Ja, function() {
    function r(v, E) {
      return typeof E > "u" ? E = { autoBom: !1 } : typeof E != "object" && (console.warn("Deprecated: Expected third argument to be a object"), E = { autoBom: !E }), E.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(v.type) ? new Blob(["\uFEFF", v], { type: v.type }) : v;
    }
    function n(v, E, T) {
      var S = new XMLHttpRequest();
      S.open("GET", v), S.responseType = "blob", S.onload = function() {
        m(S.response, E, T);
      }, S.onerror = function() {
        console.error("could not download file");
      }, S.send();
    }
    function i(v) {
      var E = new XMLHttpRequest();
      E.open("HEAD", v, !1);
      try {
        E.send();
      } catch {
      }
      return 200 <= E.status && 299 >= E.status;
    }
    function l(v) {
      try {
        v.dispatchEvent(new MouseEvent("click"));
      } catch {
        var E = document.createEvent("MouseEvents");
        E.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), v.dispatchEvent(E);
      }
    }
    var h = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof Ja == "object" && Ja.global === Ja ? Ja : void 0, s = h.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), m = h.saveAs || (typeof window != "object" || window !== h ? function() {
    } : "download" in HTMLAnchorElement.prototype && !s ? function(v, E, T) {
      var S = h.URL || h.webkitURL, A = document.createElement("a");
      E = E || v.name || "download", A.download = E, A.rel = "noopener", typeof v == "string" ? (A.href = v, A.origin === location.origin ? l(A) : i(A.href) ? n(v, E, T) : l(A, A.target = "_blank")) : (A.href = S.createObjectURL(v), setTimeout(function() {
        S.revokeObjectURL(A.href);
      }, 4e4), setTimeout(function() {
        l(A);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(v, E, T) {
      if (E = E || v.name || "download", typeof v != "string")
        navigator.msSaveOrOpenBlob(r(v, T), E);
      else if (i(v))
        n(v, E, T);
      else {
        var S = document.createElement("a");
        S.href = v, S.target = "_blank", setTimeout(function() {
          l(S);
        });
      }
    } : function(v, E, T, S) {
      if (S = S || open("", "_blank"), S && (S.document.title = S.document.body.innerText = "downloading..."), typeof v == "string")
        return n(v, E, T);
      var A = v.type === "application/octet-stream", L = /constructor/i.test(h.HTMLElement) || h.safari, B = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((B || A && L || s) && typeof FileReader < "u") {
        var j = new FileReader();
        j.onloadend = function() {
          var ne = j.result;
          ne = B ? ne : ne.replace(/^data:[^;]*;/, "data:attachment/file;"), S ? S.location.href = ne : location = ne, S = null;
        }, j.readAsDataURL(v);
      } else {
        var q = h.URL || h.webkitURL, H = q.createObjectURL(v);
        S ? S.location = H : location.href = H, S = null, setTimeout(function() {
          q.revokeObjectURL(H);
        }, 4e4);
      }
    });
    h.saveAs = m.saveAs = m, t.exports = m;
  });
})(zC);
const cW = { class: "text-white border-2 p-[10px] m-[10px] flex flex-col" }, uW = { class: "text-center mb-3" }, hW = { class: "flex flex-row justify-center" }, fW = { class: "absolute top-[70px] w-full text-center text-base" }, dW = { class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] text-sm" }, pW = {
  class: "'block z-[5] w-full h-full cursor-pointer after:absolute after:py-[15px] after:px-[15px] after:w-full after:text-center after:content-upload",
  for: "uploadMvtStyle"
}, mW = { class: "absolute top-[70px] w-full text-center text-base" }, gW = ["href"], yW = /* @__PURE__ */ vr({
  __name: "expert-style-selector",
  setup(t) {
    const e = Ai(), r = Bs(), n = Wh(), { appliedStyle: i } = mn(r), { t: l } = Hn();
    function h() {
      const v = i.value, E = JSON.stringify(v), T = new Blob([E], { type: "text/plain;charset=utf-8" }), S = "styles.json";
      zC.exports.saveAs(T, S);
    }
    function s(v) {
      const E = v.target.files;
      if ((E == null ? void 0 : E.length) !== 1)
        return;
      const T = E[0];
      new File([], "./text.txt").text().then((A) => console.log(A)), T.type === "application/json" && (T.text().then((A) => {
        r.enableExpertStyle(), i.value = JSON.parse(A);
      }), v.target.value = "");
    }
    function m() {
      return r.styleId === null ? n.getDefaultMapBoxStyleUrl(
        n.getVectorId(e.bgLayer)
      ) : `${n.getvtstyleUrl_}?id=${r.styleId}`;
    }
    return (v, E) => (tt(), vt("div", cW, [
      $e("h5", uW, Vt(_e(l)("Lancer \xE9diteur externe ou importer json")), 1),
      $e("div", hW, [
        $e("a", {
          href: "#",
          class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] z-5 text-sm after:absolute after:left-[20px] after:top-[10px] after:z-4 after:w-[3.6em] after:text-center after:content-download",
          onClick: E[0] || (E[0] = (T) => h())
        }, [
          $e("span", fW, Vt(_e(l)("Download style")), 1)
        ]),
        $e("div", dW, [
          $e("label", pW, [
            $e("span", mW, Vt(_e(l)("Upload style")), 1)
          ]),
          $e("input", {
            class: "invisible",
            type: "file",
            name: "uploadMvtStyle",
            id: "uploadMvtStyle",
            onChange: s
          }, null, 32)
        ])
      ]),
      $e("a", {
        href: `https://maputnik.github.io/editor/?style=${m()}`,
        target: "_blank",
        class: "lux-btn text-center"
      }, Vt(_e(l)("Open Maputnik editor")), 9, gW)
    ]));
  }
}), _W = /* @__PURE__ */ Mr(yW, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/expert-style-selector.vue"]]), vW = { key: 0 }, xW = { class: "h-20 shrink-0 flex justify-between lux-panel-title" }, bW = { key: 0 }, wW = { key: 1 }, EW = { key: 2 }, TW = /* @__PURE__ */ vr({
  __name: "style-selector",
  setup(t) {
    const { t: e } = Hn(), r = Ai(), n = di(), i = Bs(), { bgLayer: l } = mn(r), h = Wh(), s = un(
      () => h.getStyleCapabilitiesFromLayer(l.value)
    );
    An(l, (S) => {
      h.isLayerStyleEditable(S) || n.closeStyleEditorPanel();
    });
    let m = Kr(!1), v = Kr(!1), E = Kr(!1);
    function T() {
      i.setStyle(null);
    }
    return (S, A) => _e(s).isEditable ? (tt(), vt("div", vW, [
      $e("button", {
        onClick: A[0] || (A[0] = () => _e(n).closeStyleEditorPanel())
      }, "X close"),
      $e("h2", xW, Vt(_e(e)("Style editor")), 1),
      _e(s).hasSimpleStyle ? (tt(), vt("div", bW, [
        $e("button", {
          onClick: A[1] || (A[1] = () => tn(m) ? m.value = !_e(m) : m = !_e(m))
        }, Vt(_e(e)("Choose a predefined style")), 1),
        $t(Hq, {
          class: Or(_e(m) ? "" : "hidden")
        }, null, 8, ["class"])
      ])) : Tt("v-if", !0),
      _e(s).hasAdvancedStyle ? (tt(), vt("div", wW, [
        $e("button", {
          onClick: A[2] || (A[2] = () => tn(v) ? v.value = !_e(v) : v = !_e(v))
        }, Vt(_e(e)("Change main colours")), 1),
        _e(l) ? (tt(), Un(lW, {
          key: 0,
          class: Or(_e(v) ? "" : "hidden"),
          layer: _e(l)
        }, null, 8, ["class", "layer"])) : Tt("v-if", !0)
      ])) : Tt("v-if", !0),
      _e(s).hasExpertStyle ? (tt(), vt("div", EW, [
        $e("button", {
          onClick: A[3] || (A[3] = () => tn(E) ? E.value = !_e(E) : E = !_e(E))
        }, Vt(_e(e)("Advanced settings")), 1),
        _e(l) ? (tt(), Un(_W, {
          key: 0,
          class: Or(_e(E) ? "" : "hidden"),
          layer: _e(l)
        }, null, 8, ["class", "layer"])) : Tt("v-if", !0)
      ])) : Tt("v-if", !0),
      $e("button", {
        onClick: T,
        class: "lux-btn"
      }, Vt(_e(e)("Reset style", { ns: "client" })), 1)
    ])) : Tt("v-if", !0);
  }
}), SW = /* @__PURE__ */ Mr(TW, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/style-selector.vue"]]), MW = { class: "h-screen flex flex-col overflow-hidden" }, CW = { class: "flex grow" }, IW = {
  key: 0,
  class: "w-full sm:w-80 bg-secondary z-10"
}, PW = {
  key: 1,
  class: "w-80 bg-primary"
}, AW = { class: "map-wrapper grow bg-blue-100 relative" }, OW = { class: "absolute right-1 top-16" }, RW = /* @__PURE__ */ vr({
  __name: "App",
  setup(t) {
    Sq.bootstrap(), yq.bootstrap(), bq.bootstrap(), Eq.bootstrapLayersOpen(), VM.bootstrapStyle(), mq.bootstrap();
    const { layersOpen: e, styleEditorOpen: r } = mn(di());
    An(
      e,
      () => setTimeout(() => {
        n();
      }, 50)
    ), aa(() => window.addEventListener("resize", n)), fu(() => window.removeEventListener("resize", n));
    function n() {
      const i = zs().getOlMap();
      i.updateSize(), i.getAllLayers().forEach((l) => {
        l instanceof NM && l.maplibreMap.resize();
      });
    }
    return (i, l) => (tt(), vt("div", MW, [
      $t(g7),
      $e("main", CW, [
        Tt(" Layer panel "),
        _e(e) ? (tt(), vt("div", IW, [
          $t(J9)
        ])) : Tt("v-if", !0),
        Tt(" Style editor "),
        _e(r) ? (tt(), vt("div", PW, [
          $t(SW)
        ])) : Tt("v-if", !0),
        Tt(" Map container and slider comparator "),
        $e("div", AW, [
          $t(EU),
          $t(cq),
          $t(hG),
          $t(t7)
        ]),
        Tt(" Background selector "),
        $e("div", OW, [
          $t(f$)
        ])
      ]),
      $t(M7, { class: "fixed bottom-5 sm:static z-20" }),
      $t(R5)
    ]));
  }
}), LW = /* @__PURE__ */ Mr(RW, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/App.vue"]]);
w5();
ri.use(FC);
ri.init({
  lng: "fr",
  debug: !1,
  defaultNS: "client",
  supportedLngs: ["de", "en", "fr", "lb"],
  ns: ["client", "legends", "server", "tooltips"],
  fallbackLng: "fr",
  backend: {
    loadPath: "/static-ngeo/web-components/assets/locales/{{ns}}.{{lng}}.json"
  }
});
const e1 = BR(LW);
e1.use(WL());
e1.use(uU, { i18next: ri });
e1.use(bL);
const kW = (t = {}, e = null) => E5(
  {
    setup: () => {
      const r = My();
      Object.assign(r.appContext, e._context), Object.assign(r.provides, e._context.provides);
    },
    render: () => DS(t)
  },
  { shadowRoot: !1 }
);
export {
  R5 as AlertNotifications,
  LW as App,
  f$ as BackgroundSelector,
  R2 as DropdownList,
  M7 as FooterBar,
  g7 as HeaderBar,
  uU as I18NextVue,
  t7 as LayerMetadata,
  J9 as LayerPanel,
  EU as MapContainer,
  hG as RemoteLayers,
  cq as SliderComparator,
  bL as VueDOMPurifyHTML,
  e1 as app,
  FC as backend,
  kW as createElementInstance,
  WL as createPinia,
  E5 as defineCustomElement,
  ri as i18next,
  mq as statePersistorBgLayerService,
  Eq as statePersistorLayersOpenService,
  yq as statePersistorLayersService,
  Sq as statePersistorMyMapService,
  VM as statePersistorStyleService,
  bq as statePersistorThemeService,
  mn as storeToRefs,
  l7 as themeSelectorService,
  di as useAppStore,
  zs as useMap,
  Ai as useMapStore,
  Co as useThemeStore,
  An as watch
};
