var xC = Object.defineProperty;
var bC = (t, e, n) => e in t ? xC(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var bi = (t, e, n) => (bC(t, typeof e != "symbol" ? e + "" : e, n), n);
import { get as Xy, transformExtent as wC, getTransform as EC, transform as kb } from "ol/proj";
import { register as SC } from "ol/proj/proj4";
import TC from "ol/Map";
import MC from "ol/View";
import IC from "ol/layer/Image";
import OE from "ol/source/ImageWMS";
import OC from "ol/layer/Tile";
import CE from "ol/source/WMTS";
import CC from "ol/tilegrid/WMTS";
import { getTopLeft as AC } from "ol/extent";
import PC from "ol/layer/Layer";
import { toDegrees as kC } from "ol/math";
import { toLonLat as LC } from "ol/proj.js";
import * as Lb from "ol/events";
import DC from "ol/ObjectEventType";
import { CLASS_UNSELECTABLE as AE, CLASS_CONTROL as PE } from "ol/css";
import kE from "ol/control/Control";
import NC from "ol/control/FullScreen";
import RC from "ol/control/Zoom";
import zC from "ol/control/ZoomToExtent";
import FC from "ol/format/WMTSCapabilities.js";
import { getRenderPixel as yy } from "ol/render";
import { unByKey as BC } from "ol/Observable";
import Db from "ol/render/EventType";
import VC from "ol/layer/Group.js";
function UC(t, e) {
  for (var n = 0; n < e.length; n++) {
    const o = e[n];
    if (typeof o != "string" && !Array.isArray(o)) {
      for (const s in o)
        if (s !== "default" && !(s in t)) {
          const h = Object.getOwnPropertyDescriptor(o, s);
          h && Object.defineProperty(t, s, h.get ? h : {
            enumerable: !0,
            get: () => o[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
function Uu(t, e) {
  const n = /* @__PURE__ */ Object.create(null), o = t.split(",");
  for (let s = 0; s < o.length; s++)
    n[o[s]] = !0;
  return e ? (s) => !!n[s.toLowerCase()] : (s) => !!n[s];
}
function ju(t) {
  if (er(t)) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const o = t[n], s = Hn(o) ? qC(o) : ju(o);
      if (s)
        for (const h in s)
          e[h] = s[h];
    }
    return e;
  } else {
    if (Hn(t))
      return t;
    if (fn(t))
      return t;
  }
}
const jC = /;(?![^(]*\))/g, GC = /:([^]+)/, $C = /\/\*.*?\*\//gs;
function qC(t) {
  const e = {};
  return t.replace($C, "").split(jC).forEach((n) => {
    if (n) {
      const o = n.split(GC);
      o.length > 1 && (e[o[0].trim()] = o[1].trim());
    }
  }), e;
}
function Pr(t) {
  let e = "";
  if (Hn(t))
    e = t;
  else if (er(t))
    for (let n = 0; n < t.length; n++) {
      const o = Pr(t[n]);
      o && (e += o + " ");
    }
  else if (fn(t))
    for (const n in t)
      t[n] && (e += n + " ");
  return e.trim();
}
const WC = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", HC = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", ZC = /* @__PURE__ */ Uu(WC), XC = /* @__PURE__ */ Uu(HC), KC = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", YC = /* @__PURE__ */ Uu(KC);
function LE(t) {
  return !!t || t === "";
}
const Gt = (t) => Hn(t) ? t : t == null ? "" : er(t) || fn(t) && (t.toString === zE || !yr(t.toString)) ? JSON.stringify(t, DE, 2) : String(t), DE = (t, e) => e && e.__v_isRef ? DE(t, e.value) : Gc(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce((n, [o, s]) => (n[`${o} =>`] = s, n), {})
} : RE(e) ? {
  [`Set(${e.size})`]: [...e.values()]
} : fn(e) && !er(e) && !FE(e) ? String(e) : e, wn = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, wf = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], ao = () => {
}, NE = () => !1, JC = /^on[^a-z]/, Bd = (t) => JC.test(t), gg = (t) => t.startsWith("onUpdate:"), Wn = Object.assign, x1 = (t, e) => {
  const n = t.indexOf(e);
  n > -1 && t.splice(n, 1);
}, QC = Object.prototype.hasOwnProperty, jr = (t, e) => QC.call(t, e), er = Array.isArray, Gc = (t) => lv(t) === "[object Map]", RE = (t) => lv(t) === "[object Set]", yr = (t) => typeof t == "function", Hn = (t) => typeof t == "string", b1 = (t) => typeof t == "symbol", fn = (t) => t !== null && typeof t == "object", w1 = (t) => fn(t) && yr(t.then) && yr(t.catch), zE = Object.prototype.toString, lv = (t) => zE.call(t), E1 = (t) => lv(t).slice(8, -1), FE = (t) => lv(t) === "[object Object]", S1 = (t) => Hn(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Ky = /* @__PURE__ */ Uu(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), eA = /* @__PURE__ */ Uu("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), uv = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = t(n));
}, tA = /-(\w)/g, ya = uv((t) => t.replace(tA, (e, n) => n ? n.toUpperCase() : "")), rA = /\B([A-Z])/g, ta = uv((t) => t.replace(rA, "-$1").toLowerCase()), Yc = uv((t) => t.charAt(0).toUpperCase() + t.slice(1)), Dc = uv((t) => t ? `on${Yc(t)}` : ""), Sd = (t, e) => !Object.is(t, e), Up = (t, e) => {
  for (let n = 0; n < t.length; n++)
    t[n](e);
}, vg = (t, e, n) => {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !1,
    value: n
  });
}, nA = (t) => {
  const e = parseFloat(t);
  return isNaN(e) ? t : e;
}, b0 = (t) => {
  const e = Hn(t) ? Number(t) : NaN;
  return isNaN(e) ? t : e;
};
let Nb;
const BE = () => Nb || (Nb = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function _g(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
let pa;
class VE {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = pa, !e && pa && (this.index = (pa.scopes || (pa.scopes = [])).push(this) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const n = pa;
      try {
        return pa = this, e();
      } finally {
        pa = n;
      }
    } else
      process.env.NODE_ENV !== "production" && _g("cannot run an inactive effect scope.");
  }
  on() {
    pa = this;
  }
  off() {
    pa = this.parent;
  }
  stop(e) {
    if (this._active) {
      let n, o;
      for (n = 0, o = this.effects.length; n < o; n++)
        this.effects[n].stop();
      for (n = 0, o = this.cleanups.length; n < o; n++)
        this.cleanups[n]();
      if (this.scopes)
        for (n = 0, o = this.scopes.length; n < o; n++)
          this.scopes[n].stop(!0);
      if (!this.detached && this.parent && !e) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function UE(t) {
  return new VE(t);
}
function iA(t, e = pa) {
  e && e.active && e.effects.push(t);
}
function jE() {
  return pa;
}
function oA(t) {
  pa ? pa.cleanups.push(t) : process.env.NODE_ENV !== "production" && _g("onScopeDispose() is called when there is no active effect scope to be associated with.");
}
const Td = (t) => {
  const e = new Set(t);
  return e.w = 0, e.n = 0, e;
}, GE = (t) => (t.w & Nu) > 0, $E = (t) => (t.n & Nu) > 0, aA = ({ deps: t }) => {
  if (t.length)
    for (let e = 0; e < t.length; e++)
      t[e].w |= Nu;
}, sA = (t) => {
  const { deps: e } = t;
  if (e.length) {
    let n = 0;
    for (let o = 0; o < e.length; o++) {
      const s = e[o];
      GE(s) && !$E(s) ? s.delete(t) : e[n++] = s, s.w &= ~Nu, s.n &= ~Nu;
    }
    e.length = n;
  }
}, xg = /* @__PURE__ */ new WeakMap();
let Yp = 0, Nu = 1;
const w0 = 30;
let No;
const $c = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : ""), E0 = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class T1 {
  constructor(e, n = null, o) {
    this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, iA(this, o);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = No, n = Au;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = No, No = this, Au = !0, Nu = 1 << ++Yp, Yp <= w0 ? aA(this) : Rb(this), this.fn();
    } finally {
      Yp <= w0 && sA(this), Nu = 1 << --Yp, No = this.parent, Au = n, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    No === this ? this.deferStop = !0 : this.active && (Rb(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function Rb(t) {
  const { deps: e } = t;
  if (e.length) {
    for (let n = 0; n < e.length; n++)
      e[n].delete(t);
    e.length = 0;
  }
}
let Au = !0;
const qE = [];
function rh() {
  qE.push(Au), Au = !1;
}
function nh() {
  const t = qE.pop();
  Au = t === void 0 ? !0 : t;
}
function Bo(t, e, n) {
  if (Au && No) {
    let o = xg.get(t);
    o || xg.set(t, o = /* @__PURE__ */ new Map());
    let s = o.get(n);
    s || o.set(n, s = Td());
    const h = process.env.NODE_ENV !== "production" ? { effect: No, target: t, type: e, key: n } : void 0;
    S0(s, h);
  }
}
function S0(t, e) {
  let n = !1;
  Yp <= w0 ? $E(t) || (t.n |= Nu, n = !GE(t)) : n = !t.has(No), n && (t.add(No), No.deps.push(t), process.env.NODE_ENV !== "production" && No.onTrack && No.onTrack(Object.assign({ effect: No }, e)));
}
function Gl(t, e, n, o, s, h) {
  const a = xg.get(t);
  if (!a)
    return;
  let m = [];
  if (e === "clear")
    m = [...a.values()];
  else if (n === "length" && er(t)) {
    const b = Number(o);
    a.forEach((T, M) => {
      (M === "length" || M >= b) && m.push(T);
    });
  } else
    switch (n !== void 0 && m.push(a.get(n)), e) {
      case "add":
        er(t) ? S1(n) && m.push(a.get("length")) : (m.push(a.get($c)), Gc(t) && m.push(a.get(E0)));
        break;
      case "delete":
        er(t) || (m.push(a.get($c)), Gc(t) && m.push(a.get(E0)));
        break;
      case "set":
        Gc(t) && m.push(a.get($c));
        break;
    }
  const g = process.env.NODE_ENV !== "production" ? { target: t, type: e, key: n, newValue: o, oldValue: s, oldTarget: h } : void 0;
  if (m.length === 1)
    m[0] && (process.env.NODE_ENV !== "production" ? df(m[0], g) : df(m[0]));
  else {
    const b = [];
    for (const T of m)
      T && b.push(...T);
    process.env.NODE_ENV !== "production" ? df(Td(b), g) : df(Td(b));
  }
}
function df(t, e) {
  const n = er(t) ? t : [...t];
  for (const o of n)
    o.computed && zb(o, e);
  for (const o of n)
    o.computed || zb(o, e);
}
function zb(t, e) {
  (t !== No || t.allowRecurse) && (process.env.NODE_ENV !== "production" && t.onTrigger && t.onTrigger(Wn({ effect: t }, e)), t.scheduler ? t.scheduler() : t.run());
}
function lA(t, e) {
  var n;
  return (n = xg.get(t)) === null || n === void 0 ? void 0 : n.get(e);
}
const uA = /* @__PURE__ */ Uu("__proto__,__v_isRef,__isVue"), WE = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(b1)
), cA = /* @__PURE__ */ cv(), hA = /* @__PURE__ */ cv(!1, !0), fA = /* @__PURE__ */ cv(!0), pA = /* @__PURE__ */ cv(!0, !0), Fb = /* @__PURE__ */ dA();
function dA() {
  const t = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    t[e] = function(...n) {
      const o = hr(this);
      for (let h = 0, a = this.length; h < a; h++)
        Bo(o, "get", h + "");
      const s = o[e](...n);
      return s === -1 || s === !1 ? o[e](...n.map(hr)) : s;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    t[e] = function(...n) {
      rh();
      const o = hr(this)[e].apply(this, n);
      return nh(), o;
    };
  }), t;
}
function mA(t) {
  const e = hr(this);
  return Bo(e, "has", t), e.hasOwnProperty(t);
}
function cv(t = !1, e = !1) {
  return function(o, s, h) {
    if (s === "__v_isReactive")
      return !t;
    if (s === "__v_isReadonly")
      return t;
    if (s === "__v_isShallow")
      return e;
    if (s === "__v_raw" && h === (t ? e ? eS : QE : e ? JE : YE).get(o))
      return o;
    const a = er(o);
    if (!t) {
      if (a && jr(Fb, s))
        return Reflect.get(Fb, s, h);
      if (s === "hasOwnProperty")
        return mA;
    }
    const m = Reflect.get(o, s, h);
    return (b1(s) ? WE.has(s) : uA(s)) || (t || Bo(o, "get", s), e) ? m : hn(m) ? a && S1(s) ? m : m.value : fn(m) ? t ? tS(m) : pv(m) : m;
  };
}
const yA = /* @__PURE__ */ HE(), gA = /* @__PURE__ */ HE(!0);
function HE(t = !1) {
  return function(n, o, s, h) {
    let a = n[o];
    if (Ru(a) && hn(a) && !hn(s))
      return !1;
    if (!t && (!bg(s) && !Ru(s) && (a = hr(a), s = hr(s)), !er(n) && hn(a) && !hn(s)))
      return a.value = s, !0;
    const m = er(n) && S1(o) ? Number(o) < n.length : jr(n, o), g = Reflect.set(n, o, s, h);
    return n === hr(h) && (m ? Sd(s, a) && Gl(n, "set", o, s, a) : Gl(n, "add", o, s)), g;
  };
}
function vA(t, e) {
  const n = jr(t, e), o = t[e], s = Reflect.deleteProperty(t, e);
  return s && n && Gl(t, "delete", e, void 0, o), s;
}
function _A(t, e) {
  const n = Reflect.has(t, e);
  return (!b1(e) || !WE.has(e)) && Bo(t, "has", e), n;
}
function xA(t) {
  return Bo(t, "iterate", er(t) ? "length" : $c), Reflect.ownKeys(t);
}
const ZE = {
  get: cA,
  set: yA,
  deleteProperty: vA,
  has: _A,
  ownKeys: xA
}, XE = {
  get: fA,
  set(t, e) {
    return process.env.NODE_ENV !== "production" && _g(`Set operation on key "${String(e)}" failed: target is readonly.`, t), !0;
  },
  deleteProperty(t, e) {
    return process.env.NODE_ENV !== "production" && _g(`Delete operation on key "${String(e)}" failed: target is readonly.`, t), !0;
  }
}, bA = /* @__PURE__ */ Wn({}, ZE, {
  get: hA,
  set: gA
}), wA = /* @__PURE__ */ Wn({}, XE, {
  get: pA
}), M1 = (t) => t, hv = (t) => Reflect.getPrototypeOf(t);
function gy(t, e, n = !1, o = !1) {
  t = t.__v_raw;
  const s = hr(t), h = hr(e);
  n || (e !== h && Bo(s, "get", e), Bo(s, "get", h));
  const { has: a } = hv(s), m = o ? M1 : n ? I1 : Md;
  if (a.call(s, e))
    return m(t.get(e));
  if (a.call(s, h))
    return m(t.get(h));
  t !== s && t.get(e);
}
function vy(t, e = !1) {
  const n = this.__v_raw, o = hr(n), s = hr(t);
  return e || (t !== s && Bo(o, "has", t), Bo(o, "has", s)), t === s ? n.has(t) : n.has(t) || n.has(s);
}
function _y(t, e = !1) {
  return t = t.__v_raw, !e && Bo(hr(t), "iterate", $c), Reflect.get(t, "size", t);
}
function Bb(t) {
  t = hr(t);
  const e = hr(this);
  return hv(e).has.call(e, t) || (e.add(t), Gl(e, "add", t, t)), this;
}
function Vb(t, e) {
  e = hr(e);
  const n = hr(this), { has: o, get: s } = hv(n);
  let h = o.call(n, t);
  h ? process.env.NODE_ENV !== "production" && KE(n, o, t) : (t = hr(t), h = o.call(n, t));
  const a = s.call(n, t);
  return n.set(t, e), h ? Sd(e, a) && Gl(n, "set", t, e, a) : Gl(n, "add", t, e), this;
}
function Ub(t) {
  const e = hr(this), { has: n, get: o } = hv(e);
  let s = n.call(e, t);
  s ? process.env.NODE_ENV !== "production" && KE(e, n, t) : (t = hr(t), s = n.call(e, t));
  const h = o ? o.call(e, t) : void 0, a = e.delete(t);
  return s && Gl(e, "delete", t, void 0, h), a;
}
function jb() {
  const t = hr(this), e = t.size !== 0, n = process.env.NODE_ENV !== "production" ? Gc(t) ? new Map(t) : new Set(t) : void 0, o = t.clear();
  return e && Gl(t, "clear", void 0, void 0, n), o;
}
function xy(t, e) {
  return function(o, s) {
    const h = this, a = h.__v_raw, m = hr(a), g = e ? M1 : t ? I1 : Md;
    return !t && Bo(m, "iterate", $c), a.forEach((b, T) => o.call(s, g(b), g(T), h));
  };
}
function by(t, e, n) {
  return function(...o) {
    const s = this.__v_raw, h = hr(s), a = Gc(h), m = t === "entries" || t === Symbol.iterator && a, g = t === "keys" && a, b = s[t](...o), T = n ? M1 : e ? I1 : Md;
    return !e && Bo(h, "iterate", g ? E0 : $c), {
      next() {
        const { value: M, done: I } = b.next();
        return I ? { value: M, done: I } : {
          value: m ? [T(M[0]), T(M[1])] : T(M),
          done: I
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function du(t) {
  return function(...e) {
    if (process.env.NODE_ENV !== "production") {
      const n = e[0] ? `on key "${e[0]}" ` : "";
      console.warn(`${Yc(t)} operation ${n}failed: target is readonly.`, hr(this));
    }
    return t === "delete" ? !1 : this;
  };
}
function EA() {
  const t = {
    get(h) {
      return gy(this, h);
    },
    get size() {
      return _y(this);
    },
    has: vy,
    add: Bb,
    set: Vb,
    delete: Ub,
    clear: jb,
    forEach: xy(!1, !1)
  }, e = {
    get(h) {
      return gy(this, h, !1, !0);
    },
    get size() {
      return _y(this);
    },
    has: vy,
    add: Bb,
    set: Vb,
    delete: Ub,
    clear: jb,
    forEach: xy(!1, !0)
  }, n = {
    get(h) {
      return gy(this, h, !0);
    },
    get size() {
      return _y(this, !0);
    },
    has(h) {
      return vy.call(this, h, !0);
    },
    add: du("add"),
    set: du("set"),
    delete: du("delete"),
    clear: du("clear"),
    forEach: xy(!0, !1)
  }, o = {
    get(h) {
      return gy(this, h, !0, !0);
    },
    get size() {
      return _y(this, !0);
    },
    has(h) {
      return vy.call(this, h, !0);
    },
    add: du("add"),
    set: du("set"),
    delete: du("delete"),
    clear: du("clear"),
    forEach: xy(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((h) => {
    t[h] = by(h, !1, !1), n[h] = by(h, !0, !1), e[h] = by(h, !1, !0), o[h] = by(h, !0, !0);
  }), [
    t,
    n,
    e,
    o
  ];
}
const [SA, TA, MA, IA] = /* @__PURE__ */ EA();
function fv(t, e) {
  const n = e ? t ? IA : MA : t ? TA : SA;
  return (o, s, h) => s === "__v_isReactive" ? !t : s === "__v_isReadonly" ? t : s === "__v_raw" ? o : Reflect.get(jr(n, s) && s in o ? n : o, s, h);
}
const OA = {
  get: /* @__PURE__ */ fv(!1, !1)
}, CA = {
  get: /* @__PURE__ */ fv(!1, !0)
}, AA = {
  get: /* @__PURE__ */ fv(!0, !1)
}, PA = {
  get: /* @__PURE__ */ fv(!0, !0)
};
function KE(t, e, n) {
  const o = hr(n);
  if (o !== n && e.call(t, o)) {
    const s = E1(t);
    console.warn(`Reactive ${s} contains both the raw and reactive versions of the same object${s === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const YE = /* @__PURE__ */ new WeakMap(), JE = /* @__PURE__ */ new WeakMap(), QE = /* @__PURE__ */ new WeakMap(), eS = /* @__PURE__ */ new WeakMap();
function kA(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function LA(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : kA(E1(t));
}
function pv(t) {
  return Ru(t) ? t : dv(t, !1, ZE, OA, YE);
}
function DA(t) {
  return dv(t, !1, bA, CA, JE);
}
function tS(t) {
  return dv(t, !0, XE, AA, QE);
}
function mf(t) {
  return dv(t, !0, wA, PA, eS);
}
function dv(t, e, n, o, s) {
  if (!fn(t))
    return process.env.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(t)}`), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  const h = s.get(t);
  if (h)
    return h;
  const a = LA(t);
  if (a === 0)
    return t;
  const m = new Proxy(t, a === 2 ? o : n);
  return s.set(t, m), m;
}
function ls(t) {
  return Ru(t) ? ls(t.__v_raw) : !!(t && t.__v_isReactive);
}
function Ru(t) {
  return !!(t && t.__v_isReadonly);
}
function bg(t) {
  return !!(t && t.__v_isShallow);
}
function wg(t) {
  return ls(t) || Ru(t);
}
function hr(t) {
  const e = t && t.__v_raw;
  return e ? hr(e) : t;
}
function rs(t) {
  return vg(t, "__v_skip", !0), t;
}
const Md = (t) => fn(t) ? pv(t) : t, I1 = (t) => fn(t) ? tS(t) : t;
function rS(t) {
  Au && No && (t = hr(t), process.env.NODE_ENV !== "production" ? S0(t.dep || (t.dep = Td()), {
    target: t,
    type: "get",
    key: "value"
  }) : S0(t.dep || (t.dep = Td())));
}
function nS(t, e) {
  t = hr(t);
  const n = t.dep;
  n && (process.env.NODE_ENV !== "production" ? df(n, {
    target: t,
    type: "set",
    key: "value",
    newValue: e
  }) : df(n));
}
function hn(t) {
  return !!(t && t.__v_isRef === !0);
}
function _r(t) {
  return iS(t, !1);
}
function Bn(t) {
  return iS(t, !0);
}
function iS(t, e) {
  return hn(t) ? t : new NA(t, e);
}
class NA {
  constructor(e, n) {
    this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : hr(e), this._value = n ? e : Md(e);
  }
  get value() {
    return rS(this), this._value;
  }
  set value(e) {
    const n = this.__v_isShallow || bg(e) || Ru(e);
    e = n ? e : hr(e), Sd(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : Md(e), nS(this, e));
  }
}
function se(t) {
  return hn(t) ? t.value : t;
}
const RA = {
  get: (t, e, n) => se(Reflect.get(t, e, n)),
  set: (t, e, n, o) => {
    const s = t[e];
    return hn(s) && !hn(n) ? (s.value = n, !0) : Reflect.set(t, e, n, o);
  }
};
function oS(t) {
  return ls(t) ? t : new Proxy(t, RA);
}
function Gb(t) {
  process.env.NODE_ENV !== "production" && !wg(t) && console.warn("toRefs() expects a reactive object but received a plain one.");
  const e = er(t) ? new Array(t.length) : {};
  for (const n in t)
    e[n] = ud(t, n);
  return e;
}
class zA {
  constructor(e, n, o) {
    this._object = e, this._key = n, this._defaultValue = o, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return lA(hr(this._object), this._key);
  }
}
function ud(t, e, n) {
  const o = t[e];
  return hn(o) ? o : new zA(t, e, n);
}
var aS;
class FA {
  constructor(e, n, o, s) {
    this._setter = n, this.dep = void 0, this.__v_isRef = !0, this[aS] = !1, this._dirty = !0, this.effect = new T1(e, () => {
      this._dirty || (this._dirty = !0, nS(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = o;
  }
  get value() {
    const e = hr(this);
    return rS(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
aS = "__v_isReadonly";
function BA(t, e, n = !1) {
  let o, s;
  const h = yr(t);
  h ? (o = t, s = process.env.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : ao) : (o = t.get, s = t.set);
  const a = new FA(o, s, h || !s, n);
  return process.env.NODE_ENV !== "production" && e && !n && (a.effect.onTrack = e.onTrack, a.effect.onTrigger = e.onTrigger), a;
}
const qc = [];
function Yy(t) {
  qc.push(t);
}
function Jy() {
  qc.pop();
}
function lt(t, ...e) {
  if (process.env.NODE_ENV === "production")
    return;
  rh();
  const n = qc.length ? qc[qc.length - 1].component : null, o = n && n.appContext.config.warnHandler, s = VA();
  if (o)
    Bl(o, n, 11, [
      t + e.join(""),
      n && n.proxy,
      s.map(({ vnode: h }) => `at <${wv(n, h.type)}>`).join(`
`),
      s
    ]);
  else {
    const h = [`[Vue warn]: ${t}`, ...e];
    s.length && h.push(`
`, ...UA(s)), console.warn(...h);
  }
  nh();
}
function VA() {
  let t = qc[qc.length - 1];
  if (!t)
    return [];
  const e = [];
  for (; t; ) {
    const n = e[0];
    n && n.vnode === t ? n.recurseCount++ : e.push({
      vnode: t,
      recurseCount: 0
    });
    const o = t.component && t.component.parent;
    t = o && o.vnode;
  }
  return e;
}
function UA(t) {
  const e = [];
  return t.forEach((n, o) => {
    e.push(...o === 0 ? [] : [`
`], ...jA(n));
  }), e;
}
function jA({ vnode: t, recurseCount: e }) {
  const n = e > 0 ? `... (${e} recursive calls)` : "", o = t.component ? t.component.parent == null : !1, s = ` at <${wv(t.component, t.type, o)}`, h = ">" + n;
  return t.props ? [s, ...GA(t.props), h] : [s + h];
}
function GA(t) {
  const e = [], n = Object.keys(t);
  return n.slice(0, 3).forEach((o) => {
    e.push(...sS(o, t[o]));
  }), n.length > 3 && e.push(" ..."), e;
}
function sS(t, e, n) {
  return Hn(e) ? (e = JSON.stringify(e), n ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? n ? e : [`${t}=${e}`] : hn(e) ? (e = sS(t, hr(e.value), !0), n ? e : [`${t}=Ref<`, e, ">"]) : yr(e) ? [`${t}=fn${e.name ? `<${e.name}>` : ""}`] : (e = hr(e), n ? e : [`${t}=`, e]);
}
function $A(t, e) {
  process.env.NODE_ENV !== "production" && t !== void 0 && (typeof t != "number" ? lt(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && lt(`${e} is NaN - the duration expression might be incorrect.`));
}
const O1 = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function Bl(t, e, n, o) {
  let s;
  try {
    s = o ? t(...o) : t();
  } catch (h) {
    mv(h, e, n);
  }
  return s;
}
function Da(t, e, n, o) {
  if (yr(t)) {
    const h = Bl(t, e, n, o);
    return h && w1(h) && h.catch((a) => {
      mv(a, e, n);
    }), h;
  }
  const s = [];
  for (let h = 0; h < t.length; h++)
    s.push(Da(t[h], e, n, o));
  return s;
}
function mv(t, e, n, o = !0) {
  const s = e ? e.vnode : null;
  if (e) {
    let h = e.parent;
    const a = e.proxy, m = process.env.NODE_ENV !== "production" ? O1[n] : n;
    for (; h; ) {
      const b = h.ec;
      if (b) {
        for (let T = 0; T < b.length; T++)
          if (b[T](t, a, m) === !1)
            return;
      }
      h = h.parent;
    }
    const g = e.appContext.config.errorHandler;
    if (g) {
      Bl(g, null, 10, [t, a, m]);
      return;
    }
  }
  qA(t, n, s, o);
}
function qA(t, e, n, o = !0) {
  if (process.env.NODE_ENV !== "production") {
    const s = O1[e];
    if (n && Yy(n), lt(`Unhandled error${s ? ` during execution of ${s}` : ""}`), n && Jy(), o)
      throw t;
    console.error(t);
  } else
    console.error(t);
}
let Id = !1, T0 = !1;
const xo = [];
let Vs = 0;
const Ef = [];
let Bs = null, bu = 0;
const lS = /* @__PURE__ */ Promise.resolve();
let C1 = null;
const WA = 100;
function Eg(t) {
  const e = C1 || lS;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function HA(t) {
  let e = Vs + 1, n = xo.length;
  for (; e < n; ) {
    const o = e + n >>> 1;
    Od(xo[o]) < t ? e = o + 1 : n = o;
  }
  return e;
}
function yv(t) {
  (!xo.length || !xo.includes(t, Id && t.allowRecurse ? Vs + 1 : Vs)) && (t.id == null ? xo.push(t) : xo.splice(HA(t.id), 0, t), uS());
}
function uS() {
  !Id && !T0 && (T0 = !0, C1 = lS.then(fS));
}
function ZA(t) {
  const e = xo.indexOf(t);
  e > Vs && xo.splice(e, 1);
}
function cS(t) {
  er(t) ? Ef.push(...t) : (!Bs || !Bs.includes(t, t.allowRecurse ? bu + 1 : bu)) && Ef.push(t), uS();
}
function $b(t, e = Id ? Vs + 1 : 0) {
  for (process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()); e < xo.length; e++) {
    const n = xo[e];
    if (n && n.pre) {
      if (process.env.NODE_ENV !== "production" && A1(t, n))
        continue;
      xo.splice(e, 1), e--, n();
    }
  }
}
function hS(t) {
  if (Ef.length) {
    const e = [...new Set(Ef)];
    if (Ef.length = 0, Bs) {
      Bs.push(...e);
      return;
    }
    for (Bs = e, process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), Bs.sort((n, o) => Od(n) - Od(o)), bu = 0; bu < Bs.length; bu++)
      process.env.NODE_ENV !== "production" && A1(t, Bs[bu]) || Bs[bu]();
    Bs = null, bu = 0;
  }
}
const Od = (t) => t.id == null ? 1 / 0 : t.id, XA = (t, e) => {
  const n = Od(t) - Od(e);
  if (n === 0) {
    if (t.pre && !e.pre)
      return -1;
    if (e.pre && !t.pre)
      return 1;
  }
  return n;
};
function fS(t) {
  T0 = !1, Id = !0, process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), xo.sort(XA);
  const e = process.env.NODE_ENV !== "production" ? (n) => A1(t, n) : ao;
  try {
    for (Vs = 0; Vs < xo.length; Vs++) {
      const n = xo[Vs];
      if (n && n.active !== !1) {
        if (process.env.NODE_ENV !== "production" && e(n))
          continue;
        Bl(n, null, 14);
      }
    }
  } finally {
    Vs = 0, xo.length = 0, hS(t), Id = !1, C1 = null, (xo.length || Ef.length) && fS(t);
  }
}
function A1(t, e) {
  if (!t.has(e))
    t.set(e, 1);
  else {
    const n = t.get(e);
    if (n > WA) {
      const o = e.ownerInstance, s = o && F1(o.type);
      return lt(`Maximum recursive updates exceeded${s ? ` in component <${s}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`), !0;
    } else
      t.set(e, n + 1);
  }
}
let Pu = !1;
const hf = /* @__PURE__ */ new Set();
process.env.NODE_ENV !== "production" && (BE().__VUE_HMR_RUNTIME__ = {
  createRecord: C_(pS),
  rerender: C_(JA),
  reload: C_(QA)
});
const Jc = /* @__PURE__ */ new Map();
function KA(t) {
  const e = t.type.__hmrId;
  let n = Jc.get(e);
  n || (pS(e, t.type), n = Jc.get(e)), n.instances.add(t);
}
function YA(t) {
  Jc.get(t.type.__hmrId).instances.delete(t);
}
function pS(t, e) {
  return Jc.has(t) ? !1 : (Jc.set(t, {
    initialDef: cd(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function cd(t) {
  return HS(t) ? t.__vccOpts : t;
}
function JA(t, e) {
  const n = Jc.get(t);
  !n || (n.initialDef.render = e, [...n.instances].forEach((o) => {
    e && (o.render = e, cd(o.type).render = e), o.renderCache = [], Pu = !0, o.update(), Pu = !1;
  }));
}
function QA(t, e) {
  const n = Jc.get(t);
  if (!n)
    return;
  e = cd(e), qb(n.initialDef, e);
  const o = [...n.instances];
  for (const s of o) {
    const h = cd(s.type);
    hf.has(h) || (h !== n.initialDef && qb(h, e), hf.add(h)), s.appContext.optionsCache.delete(s.type), s.ceReload ? (hf.add(h), s.ceReload(e.styles), hf.delete(h)) : s.parent ? yv(s.parent.update) : s.appContext.reload ? s.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
  }
  cS(() => {
    for (const s of o)
      hf.delete(cd(s.type));
  });
}
function qb(t, e) {
  Wn(t, e);
  for (const n in t)
    n !== "__file" && !(n in e) && delete t[n];
}
function C_(t) {
  return (e, n) => {
    try {
      return t(e, n);
    } catch (o) {
      console.error(o), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.");
    }
  };
}
let Us, Jp = [], M0 = !1;
function Vd(t, ...e) {
  Us ? Us.emit(t, ...e) : M0 || Jp.push({ event: t, args: e });
}
function dS(t, e) {
  var n, o;
  Us = t, Us ? (Us.enabled = !0, Jp.forEach(({ event: s, args: h }) => Us.emit(s, ...h)), Jp = []) : typeof window < "u" && window.HTMLElement && !(!((o = (n = window.navigator) === null || n === void 0 ? void 0 : n.userAgent) === null || o === void 0) && o.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((h) => {
    dS(h, e);
  }), setTimeout(() => {
    Us || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, M0 = !0, Jp = []);
  }, 3e3)) : (M0 = !0, Jp = []);
}
function eP(t, e) {
  Vd("app:init", t, e, {
    Fragment: cn,
    Text: Gd,
    Comment: Xi,
    Static: Qy
  });
}
function tP(t) {
  Vd("app:unmount", t);
}
const rP = /* @__PURE__ */ P1("component:added"), mS = /* @__PURE__ */ P1("component:updated"), nP = /* @__PURE__ */ P1("component:removed"), iP = (t) => {
  Us && typeof Us.cleanupBuffer == "function" && !Us.cleanupBuffer(t) && nP(t);
};
function P1(t) {
  return (e) => {
    Vd(t, e.appContext.app, e.uid, e.parent ? e.parent.uid : void 0, e);
  };
}
const oP = /* @__PURE__ */ yS("perf:start"), aP = /* @__PURE__ */ yS("perf:end");
function yS(t) {
  return (e, n, o) => {
    Vd(t, e.appContext.app, e.uid, e, n, o);
  };
}
function sP(t, e, n) {
  Vd("component:emit", t.appContext.app, t, e, n);
}
function lP(t, e, ...n) {
  if (t.isUnmounted)
    return;
  const o = t.vnode.props || wn;
  if (process.env.NODE_ENV !== "production") {
    const { emitsOptions: T, propsOptions: [M] } = t;
    if (T)
      if (!(e in T))
        (!M || !(Dc(e) in M)) && lt(`Component emitted event "${e}" but it is neither declared in the emits option nor as an "${Dc(e)}" prop.`);
      else {
        const I = T[e];
        yr(I) && (I(...n) || lt(`Invalid event arguments: event validation failed for event "${e}".`));
      }
  }
  let s = n;
  const h = e.startsWith("update:"), a = h && e.slice(7);
  if (a && a in o) {
    const T = `${a === "modelValue" ? "model" : a}Modifiers`, { number: M, trim: I } = o[T] || wn;
    I && (s = n.map((P) => Hn(P) ? P.trim() : P)), M && (s = n.map(nA));
  }
  if (process.env.NODE_ENV !== "production" && sP(t, e, s), process.env.NODE_ENV !== "production") {
    const T = e.toLowerCase();
    T !== e && o[Dc(T)] && lt(`Event "${T}" is emitted in component ${wv(t, t.type)} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${ta(e)}" instead of "${e}".`);
  }
  let m, g = o[m = Dc(e)] || o[m = Dc(ya(e))];
  !g && h && (g = o[m = Dc(ta(e))]), g && Da(g, t, 6, s);
  const b = o[m + "Once"];
  if (b) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[m])
      return;
    t.emitted[m] = !0, Da(b, t, 6, s);
  }
}
function gS(t, e, n = !1) {
  const o = e.emitsCache, s = o.get(t);
  if (s !== void 0)
    return s;
  const h = t.emits;
  let a = {}, m = !1;
  if (!yr(t)) {
    const g = (b) => {
      const T = gS(b, e, !0);
      T && (m = !0, Wn(a, T));
    };
    !n && e.mixins.length && e.mixins.forEach(g), t.extends && g(t.extends), t.mixins && t.mixins.forEach(g);
  }
  return !h && !m ? (fn(t) && o.set(t, null), null) : (er(h) ? h.forEach((g) => a[g] = null) : Wn(a, h), fn(t) && o.set(t, a), a);
}
function gv(t, e) {
  return !t || !Bd(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), jr(t, e[0].toLowerCase() + e.slice(1)) || jr(t, ta(e)) || jr(t, e));
}
let zi = null, vS = null;
function Sg(t) {
  const e = zi;
  return zi = t, vS = t && t.type.__scopeId || null, e;
}
function Ud(t, e = zi, n) {
  if (!e || t._n)
    return t;
  const o = (...s) => {
    o._d && iw(-1);
    const h = Sg(e);
    let a;
    try {
      a = t(...s);
    } finally {
      Sg(h), o._d && iw(1);
    }
    return process.env.NODE_ENV !== "production" && mS(e), a;
  };
  return o._n = !0, o._c = !0, o._d = !0, o;
}
let I0 = !1;
function Tg() {
  I0 = !0;
}
function A_(t) {
  const { type: e, vnode: n, proxy: o, withProxy: s, props: h, propsOptions: [a], slots: m, attrs: g, emit: b, render: T, renderCache: M, data: I, setupState: P, ctx: z, inheritAttrs: V } = t;
  let q, re;
  const X = Sg(t);
  process.env.NODE_ENV !== "production" && (I0 = !1);
  try {
    if (n.shapeFlag & 4) {
      const ve = s || o;
      q = ns(T.call(ve, ve, M, h, P, I, z)), re = g;
    } else {
      const ve = e;
      process.env.NODE_ENV !== "production" && g === h && Tg(), q = ns(ve.length > 1 ? ve(h, process.env.NODE_ENV !== "production" ? {
        get attrs() {
          return Tg(), g;
        },
        slots: m,
        emit: b
      } : { attrs: g, slots: m, emit: b }) : ve(h, null)), re = e.props ? g : cP(g);
    }
  } catch (ve) {
    pd.length = 0, mv(ve, t, 1), q = Ft(Xi);
  }
  let ae = q, ce;
  if (process.env.NODE_ENV !== "production" && q.patchFlag > 0 && q.patchFlag & 2048 && ([ae, ce] = uP(q)), re && V !== !1) {
    const ve = Object.keys(re), { shapeFlag: Re } = ae;
    if (ve.length) {
      if (Re & 7)
        a && ve.some(gg) && (re = hP(re, a)), ae = Qs(ae, re);
      else if (process.env.NODE_ENV !== "production" && !I0 && ae.type !== Xi) {
        const Fe = Object.keys(g), Pe = [], Se = [];
        for (let Ie = 0, Xe = Fe.length; Ie < Xe; Ie++) {
          const $e = Fe[Ie];
          Bd($e) ? gg($e) || Pe.push($e[2].toLowerCase() + $e.slice(3)) : Se.push($e);
        }
        Se.length && lt(`Extraneous non-props attributes (${Se.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`), Pe.length && lt(`Extraneous non-emits event listeners (${Pe.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
      }
    }
  }
  return n.dirs && (process.env.NODE_ENV !== "production" && !Wb(ae) && lt("Runtime directive used on component with non-element root node. The directives will not function as intended."), ae = Qs(ae), ae.dirs = ae.dirs ? ae.dirs.concat(n.dirs) : n.dirs), n.transition && (process.env.NODE_ENV !== "production" && !Wb(ae) && lt("Component inside <Transition> renders non-element root node that cannot be animated."), ae.transition = n.transition), process.env.NODE_ENV !== "production" && ce ? ce(ae) : q = ae, Sg(X), q;
}
const uP = (t) => {
  const e = t.children, n = t.dynamicChildren, o = _S(e);
  if (!o)
    return [t, void 0];
  const s = e.indexOf(o), h = n ? n.indexOf(o) : -1, a = (m) => {
    e[s] = m, n && (h > -1 ? n[h] = m : m.patchFlag > 0 && (t.dynamicChildren = [...n, m]));
  };
  return [ns(o), a];
};
function _S(t) {
  let e;
  for (let n = 0; n < t.length; n++) {
    const o = t[n];
    if (Lf(o)) {
      if (o.type !== Xi || o.children === "v-if") {
        if (e)
          return;
        e = o;
      }
    } else
      return;
  }
  return e;
}
const cP = (t) => {
  let e;
  for (const n in t)
    (n === "class" || n === "style" || Bd(n)) && ((e || (e = {}))[n] = t[n]);
  return e;
}, hP = (t, e) => {
  const n = {};
  for (const o in t)
    (!gg(o) || !(o.slice(9) in e)) && (n[o] = t[o]);
  return n;
}, Wb = (t) => t.shapeFlag & 7 || t.type === Xi;
function fP(t, e, n) {
  const { props: o, children: s, component: h } = t, { props: a, children: m, patchFlag: g } = e, b = h.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (s || m) && Pu || e.dirs || e.transition)
    return !0;
  if (n && g >= 0) {
    if (g & 1024)
      return !0;
    if (g & 16)
      return o ? Hb(o, a, b) : !!a;
    if (g & 8) {
      const T = e.dynamicProps;
      for (let M = 0; M < T.length; M++) {
        const I = T[M];
        if (a[I] !== o[I] && !gv(b, I))
          return !0;
      }
    }
  } else
    return (s || m) && (!m || !m.$stable) ? !0 : o === a ? !1 : o ? a ? Hb(o, a, b) : !0 : !!a;
  return !1;
}
function Hb(t, e, n) {
  const o = Object.keys(e);
  if (o.length !== Object.keys(t).length)
    return !0;
  for (let s = 0; s < o.length; s++) {
    const h = o[s];
    if (e[h] !== t[h] && !gv(n, h))
      return !0;
  }
  return !1;
}
function pP({ vnode: t, parent: e }, n) {
  for (; e && e.subTree === t; )
    (t = e.vnode).el = n, e = e.parent;
}
const dP = (t) => t.__isSuspense;
function mP(t, e) {
  e && e.pendingBranch ? er(t) ? e.effects.push(...t) : e.effects.push(t) : cS(t);
}
function xS(t, e) {
  if (!pi)
    process.env.NODE_ENV !== "production" && lt("provide() can only be used inside setup().");
  else {
    let n = pi.provides;
    const o = pi.parent && pi.parent.provides;
    o === n && (n = pi.provides = Object.create(o)), n[t] = e;
  }
}
function Sf(t, e, n = !1) {
  const o = pi || zi;
  if (o) {
    const s = o.parent == null ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides;
    if (s && t in s)
      return s[t];
    if (arguments.length > 1)
      return n && yr(e) ? e.call(o.proxy) : e;
    process.env.NODE_ENV !== "production" && lt(`injection "${String(t)}" not found.`);
  } else
    process.env.NODE_ENV !== "production" && lt("inject() can only be used inside setup() or functional components.");
}
function va(t, e) {
  return k1(t, null, e);
}
const wy = {};
function Pn(t, e, n) {
  return process.env.NODE_ENV !== "production" && !yr(e) && lt("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), k1(t, e, n);
}
function k1(t, e, { immediate: n, deep: o, flush: s, onTrack: h, onTrigger: a } = wn) {
  process.env.NODE_ENV !== "production" && !e && (n !== void 0 && lt('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), o !== void 0 && lt('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));
  const m = (ce) => {
    lt("Invalid watch source: ", ce, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.");
  }, g = jE() === (pi == null ? void 0 : pi.scope) ? pi : null;
  let b, T = !1, M = !1;
  if (hn(t) ? (b = () => t.value, T = bg(t)) : ls(t) ? (b = () => t, o = !0) : er(t) ? (M = !0, T = t.some((ce) => ls(ce) || bg(ce)), b = () => t.map((ce) => {
    if (hn(ce))
      return ce.value;
    if (ls(ce))
      return jc(ce);
    if (yr(ce))
      return Bl(ce, g, 2);
    process.env.NODE_ENV !== "production" && m(ce);
  })) : yr(t) ? e ? b = () => Bl(t, g, 2) : b = () => {
    if (!(g && g.isUnmounted))
      return I && I(), Da(t, g, 3, [P]);
  } : (b = ao, process.env.NODE_ENV !== "production" && m(t)), e && o) {
    const ce = b;
    b = () => jc(ce());
  }
  let I, P = (ce) => {
    I = X.onStop = () => {
      Bl(ce, g, 4);
    };
  }, z;
  if (Ad)
    if (P = ao, e ? n && Da(e, g, 3, [
      b(),
      M ? [] : void 0,
      P
    ]) : b(), s === "sync") {
      const ce = Ek();
      z = ce.__watcherHandles || (ce.__watcherHandles = []);
    } else
      return ao;
  let V = M ? new Array(t.length).fill(wy) : wy;
  const q = () => {
    if (!!X.active)
      if (e) {
        const ce = X.run();
        (o || T || (M ? ce.some((ve, Re) => Sd(ve, V[Re])) : Sd(ce, V))) && (I && I(), Da(e, g, 3, [
          ce,
          V === wy ? void 0 : M && V[0] === wy ? [] : V,
          P
        ]), V = ce);
      } else
        X.run();
  };
  q.allowRecurse = !!e;
  let re;
  s === "sync" ? re = q : s === "post" ? re = () => ea(q, g && g.suspense) : (q.pre = !0, g && (q.id = g.uid), re = () => yv(q));
  const X = new T1(b, re);
  process.env.NODE_ENV !== "production" && (X.onTrack = h, X.onTrigger = a), e ? n ? q() : V = X.run() : s === "post" ? ea(X.run.bind(X), g && g.suspense) : X.run();
  const ae = () => {
    X.stop(), g && g.scope && x1(g.scope.effects, X);
  };
  return z && z.push(ae), ae;
}
function yP(t, e, n) {
  const o = this.proxy, s = Hn(t) ? t.includes(".") ? bS(o, t) : () => o[t] : t.bind(o, o);
  let h;
  yr(e) ? h = e : (h = e.handler, n = e);
  const a = pi;
  Df(this);
  const m = k1(s, h.bind(o), n);
  return a ? Df(a) : Hc(), m;
}
function bS(t, e) {
  const n = e.split(".");
  return () => {
    let o = t;
    for (let s = 0; s < n.length && o; s++)
      o = o[n[s]];
    return o;
  };
}
function jc(t, e) {
  if (!fn(t) || t.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(t)))
    return t;
  if (e.add(t), hn(t))
    jc(t.value, e);
  else if (er(t))
    for (let n = 0; n < t.length; n++)
      jc(t[n], e);
  else if (RE(t) || Gc(t))
    t.forEach((n) => {
      jc(n, e);
    });
  else if (FE(t))
    for (const n in t)
      jc(t[n], e);
  return t;
}
function gP() {
  const t = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return _a(() => {
    t.isMounted = !0;
  }), MS(() => {
    t.isUnmounting = !0;
  }), t;
}
const Ia = [Function, Array], vP = {
  name: "BaseTransition",
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Ia,
    onEnter: Ia,
    onAfterEnter: Ia,
    onEnterCancelled: Ia,
    onBeforeLeave: Ia,
    onLeave: Ia,
    onAfterLeave: Ia,
    onLeaveCancelled: Ia,
    onBeforeAppear: Ia,
    onAppear: Ia,
    onAfterAppear: Ia,
    onAppearCancelled: Ia
  },
  setup(t, { slots: e }) {
    const n = xv(), o = gP();
    let s;
    return () => {
      const h = e.default && SS(e.default(), !0);
      if (!h || !h.length)
        return;
      let a = h[0];
      if (h.length > 1) {
        let V = !1;
        for (const q of h)
          if (q.type !== Xi) {
            if (process.env.NODE_ENV !== "production" && V) {
              lt("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
              break;
            }
            if (a = q, V = !0, process.env.NODE_ENV === "production")
              break;
          }
      }
      const m = hr(t), { mode: g } = m;
      if (process.env.NODE_ENV !== "production" && g && g !== "in-out" && g !== "out-in" && g !== "default" && lt(`invalid <transition> mode: ${g}`), o.isLeaving)
        return P_(a);
      const b = Zb(a);
      if (!b)
        return P_(a);
      const T = O0(b, m, o, n);
      C0(b, T);
      const M = n.subTree, I = M && Zb(M);
      let P = !1;
      const { getTransitionKey: z } = b.type;
      if (z) {
        const V = z();
        s === void 0 ? s = V : V !== s && (s = V, P = !0);
      }
      if (I && I.type !== Xi && (!Bc(b, I) || P)) {
        const V = O0(I, m, o, n);
        if (C0(I, V), g === "out-in")
          return o.isLeaving = !0, V.afterLeave = () => {
            o.isLeaving = !1, n.update.active !== !1 && n.update();
          }, P_(a);
        g === "in-out" && b.type !== Xi && (V.delayLeave = (q, re, X) => {
          const ae = ES(o, I);
          ae[String(I.key)] = I, q._leaveCb = () => {
            re(), q._leaveCb = void 0, delete T.delayedLeave;
          }, T.delayedLeave = X;
        });
      }
      return a;
    };
  }
}, wS = vP;
function ES(t, e) {
  const { leavingVNodes: n } = t;
  let o = n.get(e.type);
  return o || (o = /* @__PURE__ */ Object.create(null), n.set(e.type, o)), o;
}
function O0(t, e, n, o) {
  const { appear: s, mode: h, persisted: a = !1, onBeforeEnter: m, onEnter: g, onAfterEnter: b, onEnterCancelled: T, onBeforeLeave: M, onLeave: I, onAfterLeave: P, onLeaveCancelled: z, onBeforeAppear: V, onAppear: q, onAfterAppear: re, onAppearCancelled: X } = e, ae = String(t.key), ce = ES(n, t), ve = (Pe, Se) => {
    Pe && Da(Pe, o, 9, Se);
  }, Re = (Pe, Se) => {
    const Ie = Se[1];
    ve(Pe, Se), er(Pe) ? Pe.every((Xe) => Xe.length <= 1) && Ie() : Pe.length <= 1 && Ie();
  }, Fe = {
    mode: h,
    persisted: a,
    beforeEnter(Pe) {
      let Se = m;
      if (!n.isMounted)
        if (s)
          Se = V || m;
        else
          return;
      Pe._leaveCb && Pe._leaveCb(!0);
      const Ie = ce[ae];
      Ie && Bc(t, Ie) && Ie.el._leaveCb && Ie.el._leaveCb(), ve(Se, [Pe]);
    },
    enter(Pe) {
      let Se = g, Ie = b, Xe = T;
      if (!n.isMounted)
        if (s)
          Se = q || g, Ie = re || b, Xe = X || T;
        else
          return;
      let $e = !1;
      const at = Pe._enterCb = (be) => {
        $e || ($e = !0, be ? ve(Xe, [Pe]) : ve(Ie, [Pe]), Fe.delayedLeave && Fe.delayedLeave(), Pe._enterCb = void 0);
      };
      Se ? Re(Se, [Pe, at]) : at();
    },
    leave(Pe, Se) {
      const Ie = String(t.key);
      if (Pe._enterCb && Pe._enterCb(!0), n.isUnmounting)
        return Se();
      ve(M, [Pe]);
      let Xe = !1;
      const $e = Pe._leaveCb = (at) => {
        Xe || (Xe = !0, Se(), at ? ve(z, [Pe]) : ve(P, [Pe]), Pe._leaveCb = void 0, ce[Ie] === t && delete ce[Ie]);
      };
      ce[Ie] = t, I ? Re(I, [Pe, $e]) : $e();
    },
    clone(Pe) {
      return O0(Pe, e, n, o);
    }
  };
  return Fe;
}
function P_(t) {
  if (jd(t))
    return t = Qs(t), t.children = null, t;
}
function Zb(t) {
  return jd(t) ? t.children ? t.children[0] : void 0 : t;
}
function C0(t, e) {
  t.shapeFlag & 6 && t.component ? C0(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
}
function SS(t, e = !1, n) {
  let o = [], s = 0;
  for (let h = 0; h < t.length; h++) {
    let a = t[h];
    const m = n == null ? a.key : String(n) + String(a.key != null ? a.key : h);
    a.type === cn ? (a.patchFlag & 128 && s++, o = o.concat(SS(a.children, e, m))) : (e || a.type !== Xi) && o.push(m != null ? Qs(a, { key: m }) : a);
  }
  if (s > 1)
    for (let h = 0; h < o.length; h++)
      o[h].patchFlag = -2;
  return o;
}
function ar(t) {
  return yr(t) ? { setup: t, name: t.name } : t;
}
const hd = (t) => !!t.type.__asyncLoader, jd = (t) => t.type.__isKeepAlive;
function _P(t, e) {
  TS(t, "a", e);
}
function xP(t, e) {
  TS(t, "da", e);
}
function TS(t, e, n = pi) {
  const o = t.__wdc || (t.__wdc = () => {
    let s = n;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return t();
  });
  if (vv(e, o, n), n) {
    let s = n.parent;
    for (; s && s.parent; )
      jd(s.parent.vnode) && bP(o, e, n, s), s = s.parent;
  }
}
function bP(t, e, n, o) {
  const s = vv(e, t, o, !0);
  Gu(() => {
    x1(o[e], s);
  }, n);
}
function vv(t, e, n = pi, o = !1) {
  if (n) {
    const s = n[t] || (n[t] = []), h = e.__weh || (e.__weh = (...a) => {
      if (n.isUnmounted)
        return;
      rh(), Df(n);
      const m = Da(e, n, t, a);
      return Hc(), nh(), m;
    });
    return o ? s.unshift(h) : s.push(h), h;
  } else if (process.env.NODE_ENV !== "production") {
    const s = Dc(O1[t].replace(/ hook$/, ""));
    lt(`${s} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const Hl = (t) => (e, n = pi) => (!Ad || t === "sp") && vv(t, (...o) => e(...o), n), wP = Hl("bm"), _a = Hl("m"), EP = Hl("bu"), SP = Hl("u"), MS = Hl("bum"), Gu = Hl("um"), TP = Hl("sp"), MP = Hl("rtg"), IP = Hl("rtc");
function OP(t, e = pi) {
  vv("ec", t, e);
}
function IS(t) {
  eA(t) && lt("Do not use built-in directive ids as custom directive id: " + t);
}
function Mg(t, e) {
  const n = zi;
  if (n === null)
    return process.env.NODE_ENV !== "production" && lt("withDirectives can only be used inside render functions."), t;
  const o = bv(n) || n.proxy, s = t.dirs || (t.dirs = []);
  for (let h = 0; h < e.length; h++) {
    let [a, m, g, b = wn] = e[h];
    a && (yr(a) && (a = {
      mounted: a,
      updated: a
    }), a.deep && jc(m), s.push({
      dir: a,
      instance: o,
      value: m,
      oldValue: void 0,
      arg: g,
      modifiers: b
    }));
  }
  return t;
}
function Sc(t, e, n, o) {
  const s = t.dirs, h = e && e.dirs;
  for (let a = 0; a < s.length; a++) {
    const m = s[a];
    h && (m.oldValue = h[a].value);
    let g = m.dir[o];
    g && (rh(), Da(g, n, 8, [
      t.el,
      m,
      t,
      e
    ]), nh());
  }
}
const A0 = "components", CP = "directives";
function AP(t, e) {
  return OS(A0, t, !0, e) || t;
}
const PP = Symbol();
function L1(t) {
  return OS(CP, t);
}
function OS(t, e, n = !0, o = !1) {
  const s = zi || pi;
  if (s) {
    const h = s.type;
    if (t === A0) {
      const m = F1(h, !1);
      if (m && (m === e || m === ya(e) || m === Yc(ya(e))))
        return h;
    }
    const a = Xb(s[t] || h[t], e) || Xb(s.appContext[t], e);
    if (!a && o)
      return h;
    if (process.env.NODE_ENV !== "production" && n && !a) {
      const m = t === A0 ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      lt(`Failed to resolve ${t.slice(0, -1)}: ${e}${m}`);
    }
    return a;
  } else
    process.env.NODE_ENV !== "production" && lt(`resolve${Yc(t.slice(0, -1))} can only be used in render() or setup().`);
}
function Xb(t, e) {
  return t && (t[e] || t[ya(e)] || t[Yc(ya(e))]);
}
function Ra(t, e, n, o) {
  let s;
  const h = n && n[o];
  if (er(t) || Hn(t)) {
    s = new Array(t.length);
    for (let a = 0, m = t.length; a < m; a++)
      s[a] = e(t[a], a, void 0, h && h[a]);
  } else if (typeof t == "number") {
    process.env.NODE_ENV !== "production" && !Number.isInteger(t) && lt(`The v-for range expect an integer value but got ${t}.`), s = new Array(t);
    for (let a = 0; a < t; a++)
      s[a] = e(a + 1, a, void 0, h && h[a]);
  } else if (fn(t))
    if (t[Symbol.iterator])
      s = Array.from(t, (a, m) => e(a, m, void 0, h && h[m]));
    else {
      const a = Object.keys(t);
      s = new Array(a.length);
      for (let m = 0, g = a.length; m < g; m++) {
        const b = a[m];
        s[m] = e(t[b], b, m, h && h[m]);
      }
    }
  else
    s = [];
  return n && (n[o] = s), s;
}
function kP(t, e, n = {}, o, s) {
  if (zi.isCE || zi.parent && hd(zi.parent) && zi.parent.isCE)
    return e !== "default" && (n.name = e), Ft("slot", n, o && o());
  let h = t[e];
  process.env.NODE_ENV !== "production" && h && h.length > 1 && (lt("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."), h = () => []), h && h._c && (h._d = !1), Ve();
  const a = h && CS(h(n)), m = on(cn, {
    key: n.key || a && a.key || `_${e}`
  }, a || (o ? o() : []), a && t._ === 1 ? 64 : -2);
  return !s && m.scopeId && (m.slotScopeIds = [m.scopeId + "-s"]), h && h._c && (h._d = !0), m;
}
function CS(t) {
  return t.some((e) => Lf(e) ? !(e.type === Xi || e.type === cn && !CS(e.children)) : !0) ? t : null;
}
const P0 = (t) => t ? qS(t) ? bv(t) || t.proxy : P0(t.parent) : null, Wc = /* @__PURE__ */ Wn(/* @__PURE__ */ Object.create(null), {
  $: (t) => t,
  $el: (t) => t.vnode.el,
  $data: (t) => t.data,
  $props: (t) => process.env.NODE_ENV !== "production" ? mf(t.props) : t.props,
  $attrs: (t) => process.env.NODE_ENV !== "production" ? mf(t.attrs) : t.attrs,
  $slots: (t) => process.env.NODE_ENV !== "production" ? mf(t.slots) : t.slots,
  $refs: (t) => process.env.NODE_ENV !== "production" ? mf(t.refs) : t.refs,
  $parent: (t) => P0(t.parent),
  $root: (t) => P0(t.root),
  $emit: (t) => t.emit,
  $options: (t) => N1(t),
  $forceUpdate: (t) => t.f || (t.f = () => yv(t.update)),
  $nextTick: (t) => t.n || (t.n = Eg.bind(t.proxy)),
  $watch: (t) => yP.bind(t)
}), D1 = (t) => t === "_" || t === "$", k_ = (t, e) => t !== wn && !t.__isScriptSetup && jr(t, e), AS = {
  get({ _: t }, e) {
    const { ctx: n, setupState: o, data: s, props: h, accessCache: a, type: m, appContext: g } = t;
    if (process.env.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let b;
    if (e[0] !== "$") {
      const P = a[e];
      if (P !== void 0)
        switch (P) {
          case 1:
            return o[e];
          case 2:
            return s[e];
          case 4:
            return n[e];
          case 3:
            return h[e];
        }
      else {
        if (k_(o, e))
          return a[e] = 1, o[e];
        if (s !== wn && jr(s, e))
          return a[e] = 2, s[e];
        if ((b = t.propsOptions[0]) && jr(b, e))
          return a[e] = 3, h[e];
        if (n !== wn && jr(n, e))
          return a[e] = 4, n[e];
        k0 && (a[e] = 0);
      }
    }
    const T = Wc[e];
    let M, I;
    if (T)
      return e === "$attrs" && (Bo(t, "get", e), process.env.NODE_ENV !== "production" && Tg()), T(t);
    if ((M = m.__cssModules) && (M = M[e]))
      return M;
    if (n !== wn && jr(n, e))
      return a[e] = 4, n[e];
    if (I = g.config.globalProperties, jr(I, e))
      return I[e];
    process.env.NODE_ENV !== "production" && zi && (!Hn(e) || e.indexOf("__v") !== 0) && (s !== wn && D1(e[0]) && jr(s, e) ? lt(`Property ${JSON.stringify(e)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`) : t === zi && lt(`Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`));
  },
  set({ _: t }, e, n) {
    const { data: o, setupState: s, ctx: h } = t;
    return k_(s, e) ? (s[e] = n, !0) : process.env.NODE_ENV !== "production" && s.__isScriptSetup && jr(s, e) ? (lt(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : o !== wn && jr(o, e) ? (o[e] = n, !0) : jr(t.props, e) ? (process.env.NODE_ENV !== "production" && lt(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (process.env.NODE_ENV !== "production" && lt(`Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`), !1) : (process.env.NODE_ENV !== "production" && e in t.appContext.config.globalProperties ? Object.defineProperty(h, e, {
      enumerable: !0,
      configurable: !0,
      value: n
    }) : h[e] = n, !0);
  },
  has({ _: { data: t, setupState: e, accessCache: n, ctx: o, appContext: s, propsOptions: h } }, a) {
    let m;
    return !!n[a] || t !== wn && jr(t, a) || k_(e, a) || (m = h[0]) && jr(m, a) || jr(o, a) || jr(Wc, a) || jr(s.config.globalProperties, a);
  },
  defineProperty(t, e, n) {
    return n.get != null ? t._.accessCache[e] = 0 : jr(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n);
  }
};
process.env.NODE_ENV !== "production" && (AS.ownKeys = (t) => (lt("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."), Reflect.ownKeys(t)));
function LP(t) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => t
  }), Object.keys(Wc).forEach((n) => {
    Object.defineProperty(e, n, {
      configurable: !0,
      enumerable: !1,
      get: () => Wc[n](t),
      set: ao
    });
  }), e;
}
function DP(t) {
  const { ctx: e, propsOptions: [n] } = t;
  n && Object.keys(n).forEach((o) => {
    Object.defineProperty(e, o, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[o],
      set: ao
    });
  });
}
function NP(t) {
  const { ctx: e, setupState: n } = t;
  Object.keys(hr(n)).forEach((o) => {
    if (!n.__isScriptSetup) {
      if (D1(o[0])) {
        lt(`setup() return property ${JSON.stringify(o)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(e, o, {
        enumerable: !0,
        configurable: !0,
        get: () => n[o],
        set: ao
      });
    }
  });
}
function RP() {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, n) => {
    t[n] ? lt(`${e} property "${n}" is already defined in ${t[n]}.`) : t[n] = e;
  };
}
let k0 = !0;
function zP(t) {
  const e = N1(t), n = t.proxy, o = t.ctx;
  k0 = !1, e.beforeCreate && Kb(e.beforeCreate, t, "bc");
  const {
    data: s,
    computed: h,
    methods: a,
    watch: m,
    provide: g,
    inject: b,
    created: T,
    beforeMount: M,
    mounted: I,
    beforeUpdate: P,
    updated: z,
    activated: V,
    deactivated: q,
    beforeDestroy: re,
    beforeUnmount: X,
    destroyed: ae,
    unmounted: ce,
    render: ve,
    renderTracked: Re,
    renderTriggered: Fe,
    errorCaptured: Pe,
    serverPrefetch: Se,
    expose: Ie,
    inheritAttrs: Xe,
    components: $e,
    directives: at,
    filters: be
  } = e, Ye = process.env.NODE_ENV !== "production" ? RP() : null;
  if (process.env.NODE_ENV !== "production") {
    const [vt] = t.propsOptions;
    if (vt)
      for (const Pt in vt)
        Ye("Props", Pt);
  }
  if (b && FP(b, o, Ye, t.appContext.config.unwrapInjectedRef), a)
    for (const vt in a) {
      const Pt = a[vt];
      yr(Pt) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(o, vt, {
        value: Pt.bind(n),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : o[vt] = Pt.bind(n), process.env.NODE_ENV !== "production" && Ye("Methods", vt)) : process.env.NODE_ENV !== "production" && lt(`Method "${vt}" has type "${typeof Pt}" in the component definition. Did you reference the function correctly?`);
    }
  if (s) {
    process.env.NODE_ENV !== "production" && !yr(s) && lt("The data option must be a function. Plain object usage is no longer supported.");
    const vt = s.call(n, n);
    if (process.env.NODE_ENV !== "production" && w1(vt) && lt("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."), !fn(vt))
      process.env.NODE_ENV !== "production" && lt("data() should return an object.");
    else if (t.data = pv(vt), process.env.NODE_ENV !== "production")
      for (const Pt in vt)
        Ye("Data", Pt), D1(Pt[0]) || Object.defineProperty(o, Pt, {
          configurable: !0,
          enumerable: !0,
          get: () => vt[Pt],
          set: ao
        });
  }
  if (k0 = !0, h)
    for (const vt in h) {
      const Pt = h[vt], tr = yr(Pt) ? Pt.bind(n, n) : yr(Pt.get) ? Pt.get.bind(n, n) : ao;
      process.env.NODE_ENV !== "production" && tr === ao && lt(`Computed property "${vt}" has no getter.`);
      const kn = !yr(Pt) && yr(Pt.set) ? Pt.set.bind(n) : process.env.NODE_ENV !== "production" ? () => {
        lt(`Write operation failed: computed property "${vt}" is readonly.`);
      } : ao, Rr = or({
        get: tr,
        set: kn
      });
      Object.defineProperty(o, vt, {
        enumerable: !0,
        configurable: !0,
        get: () => Rr.value,
        set: (pr) => Rr.value = pr
      }), process.env.NODE_ENV !== "production" && Ye("Computed", vt);
    }
  if (m)
    for (const vt in m)
      PS(m[vt], o, n, vt);
  if (g) {
    const vt = yr(g) ? g.call(n) : g;
    Reflect.ownKeys(vt).forEach((Pt) => {
      xS(Pt, vt[Pt]);
    });
  }
  T && Kb(T, t, "c");
  function ht(vt, Pt) {
    er(Pt) ? Pt.forEach((tr) => vt(tr.bind(n))) : Pt && vt(Pt.bind(n));
  }
  if (ht(wP, M), ht(_a, I), ht(EP, P), ht(SP, z), ht(_P, V), ht(xP, q), ht(OP, Pe), ht(IP, Re), ht(MP, Fe), ht(MS, X), ht(Gu, ce), ht(TP, Se), er(Ie))
    if (Ie.length) {
      const vt = t.exposed || (t.exposed = {});
      Ie.forEach((Pt) => {
        Object.defineProperty(vt, Pt, {
          get: () => n[Pt],
          set: (tr) => n[Pt] = tr
        });
      });
    } else
      t.exposed || (t.exposed = {});
  ve && t.render === ao && (t.render = ve), Xe != null && (t.inheritAttrs = Xe), $e && (t.components = $e), at && (t.directives = at);
}
function FP(t, e, n = ao, o = !1) {
  er(t) && (t = L0(t));
  for (const s in t) {
    const h = t[s];
    let a;
    fn(h) ? "default" in h ? a = Sf(h.from || s, h.default, !0) : a = Sf(h.from || s) : a = Sf(h), hn(a) ? o ? Object.defineProperty(e, s, {
      enumerable: !0,
      configurable: !0,
      get: () => a.value,
      set: (m) => a.value = m
    }) : (process.env.NODE_ENV !== "production" && lt(`injected property "${s}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`), e[s] = a) : e[s] = a, process.env.NODE_ENV !== "production" && n("Inject", s);
  }
}
function Kb(t, e, n) {
  Da(er(t) ? t.map((o) => o.bind(e.proxy)) : t.bind(e.proxy), e, n);
}
function PS(t, e, n, o) {
  const s = o.includes(".") ? bS(n, o) : () => n[o];
  if (Hn(t)) {
    const h = e[t];
    yr(h) ? Pn(s, h) : process.env.NODE_ENV !== "production" && lt(`Invalid watch handler specified by key "${t}"`, h);
  } else if (yr(t))
    Pn(s, t.bind(n));
  else if (fn(t))
    if (er(t))
      t.forEach((h) => PS(h, e, n, o));
    else {
      const h = yr(t.handler) ? t.handler.bind(n) : e[t.handler];
      yr(h) ? Pn(s, h, t) : process.env.NODE_ENV !== "production" && lt(`Invalid watch handler specified by key "${t.handler}"`, h);
    }
  else
    process.env.NODE_ENV !== "production" && lt(`Invalid watch option: "${o}"`, t);
}
function N1(t) {
  const e = t.type, { mixins: n, extends: o } = e, { mixins: s, optionsCache: h, config: { optionMergeStrategies: a } } = t.appContext, m = h.get(e);
  let g;
  return m ? g = m : !s.length && !n && !o ? g = e : (g = {}, s.length && s.forEach((b) => Ig(g, b, a, !0)), Ig(g, e, a)), fn(e) && h.set(e, g), g;
}
function Ig(t, e, n, o = !1) {
  const { mixins: s, extends: h } = e;
  h && Ig(t, h, n, !0), s && s.forEach((a) => Ig(t, a, n, !0));
  for (const a in e)
    if (o && a === "expose")
      process.env.NODE_ENV !== "production" && lt('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');
    else {
      const m = BP[a] || n && n[a];
      t[a] = m ? m(t[a], e[a]) : e[a];
    }
  return t;
}
const BP = {
  data: Yb,
  props: Nc,
  emits: Nc,
  methods: Nc,
  computed: Nc,
  beforeCreate: ko,
  created: ko,
  beforeMount: ko,
  mounted: ko,
  beforeUpdate: ko,
  updated: ko,
  beforeDestroy: ko,
  beforeUnmount: ko,
  destroyed: ko,
  unmounted: ko,
  activated: ko,
  deactivated: ko,
  errorCaptured: ko,
  serverPrefetch: ko,
  components: Nc,
  directives: Nc,
  watch: UP,
  provide: Yb,
  inject: VP
};
function Yb(t, e) {
  return e ? t ? function() {
    return Wn(yr(t) ? t.call(this, this) : t, yr(e) ? e.call(this, this) : e);
  } : e : t;
}
function VP(t, e) {
  return Nc(L0(t), L0(e));
}
function L0(t) {
  if (er(t)) {
    const e = {};
    for (let n = 0; n < t.length; n++)
      e[t[n]] = t[n];
    return e;
  }
  return t;
}
function ko(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function Nc(t, e) {
  return t ? Wn(Wn(/* @__PURE__ */ Object.create(null), t), e) : e;
}
function UP(t, e) {
  if (!t)
    return e;
  if (!e)
    return t;
  const n = Wn(/* @__PURE__ */ Object.create(null), t);
  for (const o in e)
    n[o] = ko(t[o], e[o]);
  return n;
}
function jP(t, e, n, o = !1) {
  const s = {}, h = {};
  vg(h, _v, 1), t.propsDefaults = /* @__PURE__ */ Object.create(null), kS(t, e, s, h);
  for (const a in t.propsOptions[0])
    a in s || (s[a] = void 0);
  process.env.NODE_ENV !== "production" && DS(e || {}, s, t), n ? t.props = o ? s : DA(s) : t.type.props ? t.props = s : t.props = h, t.attrs = h;
}
function GP(t) {
  for (; t; ) {
    if (t.type.__hmrId)
      return !0;
    t = t.parent;
  }
}
function $P(t, e, n, o) {
  const { props: s, attrs: h, vnode: { patchFlag: a } } = t, m = hr(s), [g] = t.propsOptions;
  let b = !1;
  if (!(process.env.NODE_ENV !== "production" && GP(t)) && (o || a > 0) && !(a & 16)) {
    if (a & 8) {
      const T = t.vnode.dynamicProps;
      for (let M = 0; M < T.length; M++) {
        let I = T[M];
        if (gv(t.emitsOptions, I))
          continue;
        const P = e[I];
        if (g)
          if (jr(h, I))
            P !== h[I] && (h[I] = P, b = !0);
          else {
            const z = ya(I);
            s[z] = D0(g, m, z, P, t, !1);
          }
        else
          P !== h[I] && (h[I] = P, b = !0);
      }
    }
  } else {
    kS(t, e, s, h) && (b = !0);
    let T;
    for (const M in m)
      (!e || !jr(e, M) && ((T = ta(M)) === M || !jr(e, T))) && (g ? n && (n[M] !== void 0 || n[T] !== void 0) && (s[M] = D0(g, m, M, void 0, t, !0)) : delete s[M]);
    if (h !== m)
      for (const M in h)
        (!e || !jr(e, M) && !0) && (delete h[M], b = !0);
  }
  b && Gl(t, "set", "$attrs"), process.env.NODE_ENV !== "production" && DS(e || {}, s, t);
}
function kS(t, e, n, o) {
  const [s, h] = t.propsOptions;
  let a = !1, m;
  if (e)
    for (let g in e) {
      if (Ky(g))
        continue;
      const b = e[g];
      let T;
      s && jr(s, T = ya(g)) ? !h || !h.includes(T) ? n[T] = b : (m || (m = {}))[T] = b : gv(t.emitsOptions, g) || (!(g in o) || b !== o[g]) && (o[g] = b, a = !0);
    }
  if (h) {
    const g = hr(n), b = m || wn;
    for (let T = 0; T < h.length; T++) {
      const M = h[T];
      n[M] = D0(s, g, M, b[M], t, !jr(b, M));
    }
  }
  return a;
}
function D0(t, e, n, o, s, h) {
  const a = t[n];
  if (a != null) {
    const m = jr(a, "default");
    if (m && o === void 0) {
      const g = a.default;
      if (a.type !== Function && yr(g)) {
        const { propsDefaults: b } = s;
        n in b ? o = b[n] : (Df(s), o = b[n] = g.call(null, e), Hc());
      } else
        o = g;
    }
    a[0] && (h && !m ? o = !1 : a[1] && (o === "" || o === ta(n)) && (o = !0));
  }
  return o;
}
function LS(t, e, n = !1) {
  const o = e.propsCache, s = o.get(t);
  if (s)
    return s;
  const h = t.props, a = {}, m = [];
  let g = !1;
  if (!yr(t)) {
    const T = (M) => {
      g = !0;
      const [I, P] = LS(M, e, !0);
      Wn(a, I), P && m.push(...P);
    };
    !n && e.mixins.length && e.mixins.forEach(T), t.extends && T(t.extends), t.mixins && t.mixins.forEach(T);
  }
  if (!h && !g)
    return fn(t) && o.set(t, wf), wf;
  if (er(h))
    for (let T = 0; T < h.length; T++) {
      process.env.NODE_ENV !== "production" && !Hn(h[T]) && lt("props must be strings when using array syntax.", h[T]);
      const M = ya(h[T]);
      Jb(M) && (a[M] = wn);
    }
  else if (h) {
    process.env.NODE_ENV !== "production" && !fn(h) && lt("invalid props options", h);
    for (const T in h) {
      const M = ya(T);
      if (Jb(M)) {
        const I = h[T], P = a[M] = er(I) || yr(I) ? { type: I } : Object.assign({}, I);
        if (P) {
          const z = ew(Boolean, P.type), V = ew(String, P.type);
          P[0] = z > -1, P[1] = V < 0 || z < V, (z > -1 || jr(P, "default")) && m.push(M);
        }
      }
    }
  }
  const b = [a, m];
  return fn(t) && o.set(t, b), b;
}
function Jb(t) {
  return t[0] !== "$" ? !0 : (process.env.NODE_ENV !== "production" && lt(`Invalid prop name: "${t}" is a reserved property.`), !1);
}
function N0(t) {
  const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : t === null ? "null" : "";
}
function Qb(t, e) {
  return N0(t) === N0(e);
}
function ew(t, e) {
  return er(e) ? e.findIndex((n) => Qb(n, t)) : yr(e) && Qb(e, t) ? 0 : -1;
}
function DS(t, e, n) {
  const o = hr(e), s = n.propsOptions[0];
  for (const h in s) {
    let a = s[h];
    a != null && qP(h, o[h], a, !jr(t, h) && !jr(t, ta(h)));
  }
}
function qP(t, e, n, o) {
  const { type: s, required: h, validator: a } = n;
  if (h && o) {
    lt('Missing required prop: "' + t + '"');
    return;
  }
  if (!(e == null && !n.required)) {
    if (s != null && s !== !0) {
      let m = !1;
      const g = er(s) ? s : [s], b = [];
      for (let T = 0; T < g.length && !m; T++) {
        const { valid: M, expectedType: I } = HP(e, g[T]);
        b.push(I || ""), m = M;
      }
      if (!m) {
        lt(ZP(t, e, b));
        return;
      }
    }
    a && !a(e) && lt('Invalid prop: custom validator check failed for prop "' + t + '".');
  }
}
const WP = /* @__PURE__ */ Uu("String,Number,Boolean,Function,Symbol,BigInt");
function HP(t, e) {
  let n;
  const o = N0(e);
  if (WP(o)) {
    const s = typeof t;
    n = s === o.toLowerCase(), !n && s === "object" && (n = t instanceof e);
  } else
    o === "Object" ? n = fn(t) : o === "Array" ? n = er(t) : o === "null" ? n = t === null : n = t instanceof e;
  return {
    valid: n,
    expectedType: o
  };
}
function ZP(t, e, n) {
  let o = `Invalid prop: type check failed for prop "${t}". Expected ${n.map(Yc).join(" | ")}`;
  const s = n[0], h = E1(e), a = tw(e, s), m = tw(e, h);
  return n.length === 1 && rw(s) && !XP(s, h) && (o += ` with value ${a}`), o += `, got ${h} `, rw(h) && (o += `with value ${m}.`), o;
}
function tw(t, e) {
  return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`;
}
function rw(t) {
  return ["string", "number", "boolean"].some((n) => t.toLowerCase() === n);
}
function XP(...t) {
  return t.some((e) => e.toLowerCase() === "boolean");
}
const NS = (t) => t[0] === "_" || t === "$stable", R1 = (t) => er(t) ? t.map(ns) : [ns(t)], KP = (t, e, n) => {
  if (e._n)
    return e;
  const o = Ud((...s) => (process.env.NODE_ENV !== "production" && pi && lt(`Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`), R1(e(...s))), n);
  return o._c = !1, o;
}, RS = (t, e, n) => {
  const o = t._ctx;
  for (const s in t) {
    if (NS(s))
      continue;
    const h = t[s];
    if (yr(h))
      e[s] = KP(s, h, o);
    else if (h != null) {
      process.env.NODE_ENV !== "production" && lt(`Non-function value encountered for slot "${s}". Prefer function slots for better performance.`);
      const a = R1(h);
      e[s] = () => a;
    }
  }
}, zS = (t, e) => {
  process.env.NODE_ENV !== "production" && !jd(t.vnode) && lt("Non-function value encountered for default slot. Prefer function slots for better performance.");
  const n = R1(e);
  t.slots.default = () => n;
}, YP = (t, e) => {
  if (t.vnode.shapeFlag & 32) {
    const n = e._;
    n ? (t.slots = hr(e), vg(e, "_", n)) : RS(e, t.slots = {});
  } else
    t.slots = {}, e && zS(t, e);
  vg(t.slots, _v, 1);
}, JP = (t, e, n) => {
  const { vnode: o, slots: s } = t;
  let h = !0, a = wn;
  if (o.shapeFlag & 32) {
    const m = e._;
    m ? process.env.NODE_ENV !== "production" && Pu ? Wn(s, e) : n && m === 1 ? h = !1 : (Wn(s, e), !n && m === 1 && delete s._) : (h = !e.$stable, RS(e, s)), a = e;
  } else
    e && (zS(t, e), a = { default: 1 });
  if (h)
    for (const m in s)
      !NS(m) && !(m in a) && delete s[m];
};
function FS() {
  return {
    app: null,
    config: {
      isNativeTag: NE,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let QP = 0;
function ek(t, e) {
  return function(o, s = null) {
    yr(o) || (o = Object.assign({}, o)), s != null && !fn(s) && (process.env.NODE_ENV !== "production" && lt("root props passed to app.mount() must be an object."), s = null);
    const h = FS(), a = /* @__PURE__ */ new Set();
    let m = !1;
    const g = h.app = {
      _uid: QP++,
      _component: o,
      _props: s,
      _container: null,
      _context: h,
      _instance: null,
      version: sw,
      get config() {
        return h.config;
      },
      set config(b) {
        process.env.NODE_ENV !== "production" && lt("app.config cannot be replaced. Modify individual options instead.");
      },
      use(b, ...T) {
        return a.has(b) ? process.env.NODE_ENV !== "production" && lt("Plugin has already been applied to target app.") : b && yr(b.install) ? (a.add(b), b.install(g, ...T)) : yr(b) ? (a.add(b), b(g, ...T)) : process.env.NODE_ENV !== "production" && lt('A plugin must either be a function or an object with an "install" function.'), g;
      },
      mixin(b) {
        return h.mixins.includes(b) ? process.env.NODE_ENV !== "production" && lt("Mixin has already been applied to target app" + (b.name ? `: ${b.name}` : "")) : h.mixins.push(b), g;
      },
      component(b, T) {
        return process.env.NODE_ENV !== "production" && F0(b, h.config), T ? (process.env.NODE_ENV !== "production" && h.components[b] && lt(`Component "${b}" has already been registered in target app.`), h.components[b] = T, g) : h.components[b];
      },
      directive(b, T) {
        return process.env.NODE_ENV !== "production" && IS(b), T ? (process.env.NODE_ENV !== "production" && h.directives[b] && lt(`Directive "${b}" has already been registered in target app.`), h.directives[b] = T, g) : h.directives[b];
      },
      mount(b, T, M) {
        if (m)
          process.env.NODE_ENV !== "production" && lt("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
        else {
          process.env.NODE_ENV !== "production" && b.__vue_app__ && lt("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");
          const I = Ft(o, s);
          return I.appContext = h, process.env.NODE_ENV !== "production" && (h.reload = () => {
            t(Qs(I), b, M);
          }), T && e ? e(I, b) : t(I, b, M), m = !0, g._container = b, b.__vue_app__ = g, process.env.NODE_ENV !== "production" && (g._instance = I.component, eP(g, sw)), bv(I.component) || I.component.proxy;
        }
      },
      unmount() {
        m ? (t(null, g._container), process.env.NODE_ENV !== "production" && (g._instance = null, tP(g)), delete g._container.__vue_app__) : process.env.NODE_ENV !== "production" && lt("Cannot unmount an app that is not mounted.");
      },
      provide(b, T) {
        return process.env.NODE_ENV !== "production" && b in h.provides && lt(`App already provides property with key "${String(b)}". It will be overwritten with the new value.`), h.provides[b] = T, g;
      }
    };
    return g;
  };
}
function R0(t, e, n, o, s = !1) {
  if (er(t)) {
    t.forEach((I, P) => R0(I, e && (er(e) ? e[P] : e), n, o, s));
    return;
  }
  if (hd(o) && !s)
    return;
  const h = o.shapeFlag & 4 ? bv(o.component) || o.component.proxy : o.el, a = s ? null : h, { i: m, r: g } = t;
  if (process.env.NODE_ENV !== "production" && !m) {
    lt("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");
    return;
  }
  const b = e && e.r, T = m.refs === wn ? m.refs = {} : m.refs, M = m.setupState;
  if (b != null && b !== g && (Hn(b) ? (T[b] = null, jr(M, b) && (M[b] = null)) : hn(b) && (b.value = null)), yr(g))
    Bl(g, m, 12, [a, T]);
  else {
    const I = Hn(g), P = hn(g);
    if (I || P) {
      const z = () => {
        if (t.f) {
          const V = I ? jr(M, g) ? M[g] : T[g] : g.value;
          s ? er(V) && x1(V, h) : er(V) ? V.includes(h) || V.push(h) : I ? (T[g] = [h], jr(M, g) && (M[g] = T[g])) : (g.value = [h], t.k && (T[t.k] = g.value));
        } else
          I ? (T[g] = a, jr(M, g) && (M[g] = a)) : P ? (g.value = a, t.k && (T[t.k] = a)) : process.env.NODE_ENV !== "production" && lt("Invalid template ref type:", g, `(${typeof g})`);
      };
      a ? (z.id = -1, ea(z, n)) : z();
    } else
      process.env.NODE_ENV !== "production" && lt("Invalid template ref type:", g, `(${typeof g})`);
  }
}
let jp, Tu;
function Nl(t, e) {
  t.appContext.config.performance && Og() && Tu.mark(`vue-${e}-${t.uid}`), process.env.NODE_ENV !== "production" && oP(t, e, Og() ? Tu.now() : Date.now());
}
function Rl(t, e) {
  if (t.appContext.config.performance && Og()) {
    const n = `vue-${e}-${t.uid}`, o = n + ":end";
    Tu.mark(o), Tu.measure(`<${wv(t, t.type)}> ${e}`, n, o), Tu.clearMarks(n), Tu.clearMarks(o);
  }
  process.env.NODE_ENV !== "production" && aP(t, e, Og() ? Tu.now() : Date.now());
}
function Og() {
  return jp !== void 0 || (typeof window < "u" && window.performance ? (jp = !0, Tu = window.performance) : jp = !1), jp;
}
function tk() {
  const t = [];
  if (process.env.NODE_ENV !== "production" && t.length) {
    const e = t.length > 1;
    console.warn(`Feature flag${e ? "s" : ""} ${t.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const ea = mP;
function rk(t) {
  return nk(t);
}
function nk(t, e) {
  tk();
  const n = BE();
  n.__VUE__ = !0, process.env.NODE_ENV !== "production" && dS(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
  const { insert: o, remove: s, patchProp: h, createElement: a, createText: m, createComment: g, setText: b, setElementText: T, parentNode: M, nextSibling: I, setScopeId: P = ao, insertStaticContent: z } = t, V = (K, ye, Ne, qe = null, We = null, rt = null, mt = !1, et = null, ut = process.env.NODE_ENV !== "production" && Pu ? !1 : !!ye.dynamicChildren) => {
    if (K === ye)
      return;
    K && !Bc(K, ye) && (qe = Vn(K), Zn(K, We, rt, !0), K = null), ye.patchFlag === -2 && (ut = !1, ye.dynamicChildren = null);
    const { type: Qe, ref: It, shapeFlag: bt } = ye;
    switch (Qe) {
      case Gd:
        q(K, ye, Ne, qe);
        break;
      case Xi:
        re(K, ye, Ne, qe);
        break;
      case Qy:
        K == null ? X(ye, Ne, qe, mt) : process.env.NODE_ENV !== "production" && ae(K, ye, Ne, mt);
        break;
      case cn:
        at(K, ye, Ne, qe, We, rt, mt, et, ut);
        break;
      default:
        bt & 1 ? Re(K, ye, Ne, qe, We, rt, mt, et, ut) : bt & 6 ? be(K, ye, Ne, qe, We, rt, mt, et, ut) : bt & 64 || bt & 128 ? Qe.process(K, ye, Ne, qe, We, rt, mt, et, ut, Sn) : process.env.NODE_ENV !== "production" && lt("Invalid VNode type:", Qe, `(${typeof Qe})`);
    }
    It != null && We && R0(It, K && K.ref, rt, ye || K, !ye);
  }, q = (K, ye, Ne, qe) => {
    if (K == null)
      o(ye.el = m(ye.children), Ne, qe);
    else {
      const We = ye.el = K.el;
      ye.children !== K.children && b(We, ye.children);
    }
  }, re = (K, ye, Ne, qe) => {
    K == null ? o(ye.el = g(ye.children || ""), Ne, qe) : ye.el = K.el;
  }, X = (K, ye, Ne, qe) => {
    [K.el, K.anchor] = z(K.children, ye, Ne, qe, K.el, K.anchor);
  }, ae = (K, ye, Ne, qe) => {
    if (ye.children !== K.children) {
      const We = I(K.anchor);
      ve(K), [ye.el, ye.anchor] = z(ye.children, Ne, We, qe);
    } else
      ye.el = K.el, ye.anchor = K.anchor;
  }, ce = ({ el: K, anchor: ye }, Ne, qe) => {
    let We;
    for (; K && K !== ye; )
      We = I(K), o(K, Ne, qe), K = We;
    o(ye, Ne, qe);
  }, ve = ({ el: K, anchor: ye }) => {
    let Ne;
    for (; K && K !== ye; )
      Ne = I(K), s(K), K = Ne;
    s(ye);
  }, Re = (K, ye, Ne, qe, We, rt, mt, et, ut) => {
    mt = mt || ye.type === "svg", K == null ? Fe(ye, Ne, qe, We, rt, mt, et, ut) : Ie(K, ye, We, rt, mt, et, ut);
  }, Fe = (K, ye, Ne, qe, We, rt, mt, et) => {
    let ut, Qe;
    const { type: It, props: bt, shapeFlag: kt, transition: Ut, dirs: dr } = K;
    if (ut = K.el = a(K.type, rt, bt && bt.is, bt), kt & 8 ? T(ut, K.children) : kt & 16 && Se(K.children, ut, null, qe, We, rt && It !== "foreignObject", mt, et), dr && Sc(K, null, qe, "created"), Pe(ut, K, K.scopeId, mt, qe), bt) {
      for (const Lr in bt)
        Lr !== "value" && !Ky(Lr) && h(ut, Lr, null, bt[Lr], rt, K.children, qe, We, kr);
      "value" in bt && h(ut, "value", null, bt.value), (Qe = bt.onVnodeBeforeMount) && zs(Qe, qe, K);
    }
    process.env.NODE_ENV !== "production" && (Object.defineProperty(ut, "__vnode", {
      value: K,
      enumerable: !1
    }), Object.defineProperty(ut, "__vueParentComponent", {
      value: qe,
      enumerable: !1
    })), dr && Sc(K, null, qe, "beforeMount");
    const Vr = (!We || We && !We.pendingBranch) && Ut && !Ut.persisted;
    Vr && Ut.beforeEnter(ut), o(ut, ye, Ne), ((Qe = bt && bt.onVnodeMounted) || Vr || dr) && ea(() => {
      Qe && zs(Qe, qe, K), Vr && Ut.enter(ut), dr && Sc(K, null, qe, "mounted");
    }, We);
  }, Pe = (K, ye, Ne, qe, We) => {
    if (Ne && P(K, Ne), qe)
      for (let rt = 0; rt < qe.length; rt++)
        P(K, qe[rt]);
    if (We) {
      let rt = We.subTree;
      if (process.env.NODE_ENV !== "production" && rt.patchFlag > 0 && rt.patchFlag & 2048 && (rt = _S(rt.children) || rt), ye === rt) {
        const mt = We.vnode;
        Pe(K, mt, mt.scopeId, mt.slotScopeIds, We.parent);
      }
    }
  }, Se = (K, ye, Ne, qe, We, rt, mt, et, ut = 0) => {
    for (let Qe = ut; Qe < K.length; Qe++) {
      const It = K[Qe] = et ? wu(K[Qe]) : ns(K[Qe]);
      V(null, It, ye, Ne, qe, We, rt, mt, et);
    }
  }, Ie = (K, ye, Ne, qe, We, rt, mt) => {
    const et = ye.el = K.el;
    let { patchFlag: ut, dynamicChildren: Qe, dirs: It } = ye;
    ut |= K.patchFlag & 16;
    const bt = K.props || wn, kt = ye.props || wn;
    let Ut;
    Ne && Tc(Ne, !1), (Ut = kt.onVnodeBeforeUpdate) && zs(Ut, Ne, ye, K), It && Sc(ye, K, Ne, "beforeUpdate"), Ne && Tc(Ne, !0), process.env.NODE_ENV !== "production" && Pu && (ut = 0, mt = !1, Qe = null);
    const dr = We && ye.type !== "foreignObject";
    if (Qe ? (Xe(K.dynamicChildren, Qe, et, Ne, qe, dr, rt), process.env.NODE_ENV !== "production" && Ne && Ne.type.__hmrId && fd(K, ye)) : mt || tr(K, ye, et, null, Ne, qe, dr, rt, !1), ut > 0) {
      if (ut & 16)
        $e(et, ye, bt, kt, Ne, qe, We);
      else if (ut & 2 && bt.class !== kt.class && h(et, "class", null, kt.class, We), ut & 4 && h(et, "style", bt.style, kt.style, We), ut & 8) {
        const Vr = ye.dynamicProps;
        for (let Lr = 0; Lr < Vr.length; Lr++) {
          const Jr = Vr[Lr], Xn = bt[Jr], Bi = kt[Jr];
          (Bi !== Xn || Jr === "value") && h(et, Jr, Xn, Bi, We, K.children, Ne, qe, kr);
        }
      }
      ut & 1 && K.children !== ye.children && T(et, ye.children);
    } else
      !mt && Qe == null && $e(et, ye, bt, kt, Ne, qe, We);
    ((Ut = kt.onVnodeUpdated) || It) && ea(() => {
      Ut && zs(Ut, Ne, ye, K), It && Sc(ye, K, Ne, "updated");
    }, qe);
  }, Xe = (K, ye, Ne, qe, We, rt, mt) => {
    for (let et = 0; et < ye.length; et++) {
      const ut = K[et], Qe = ye[et], It = ut.el && (ut.type === cn || !Bc(ut, Qe) || ut.shapeFlag & 70) ? M(ut.el) : Ne;
      V(ut, Qe, It, null, qe, We, rt, mt, !0);
    }
  }, $e = (K, ye, Ne, qe, We, rt, mt) => {
    if (Ne !== qe) {
      if (Ne !== wn)
        for (const et in Ne)
          !Ky(et) && !(et in qe) && h(K, et, Ne[et], null, mt, ye.children, We, rt, kr);
      for (const et in qe) {
        if (Ky(et))
          continue;
        const ut = qe[et], Qe = Ne[et];
        ut !== Qe && et !== "value" && h(K, et, Qe, ut, mt, ye.children, We, rt, kr);
      }
      "value" in qe && h(K, "value", Ne.value, qe.value);
    }
  }, at = (K, ye, Ne, qe, We, rt, mt, et, ut) => {
    const Qe = ye.el = K ? K.el : m(""), It = ye.anchor = K ? K.anchor : m("");
    let { patchFlag: bt, dynamicChildren: kt, slotScopeIds: Ut } = ye;
    process.env.NODE_ENV !== "production" && (Pu || bt & 2048) && (bt = 0, ut = !1, kt = null), Ut && (et = et ? et.concat(Ut) : Ut), K == null ? (o(Qe, Ne, qe), o(It, Ne, qe), Se(ye.children, Ne, It, We, rt, mt, et, ut)) : bt > 0 && bt & 64 && kt && K.dynamicChildren ? (Xe(K.dynamicChildren, kt, Ne, We, rt, mt, et), process.env.NODE_ENV !== "production" && We && We.type.__hmrId ? fd(K, ye) : (ye.key != null || We && ye === We.subTree) && fd(K, ye, !0)) : tr(K, ye, Ne, It, We, rt, mt, et, ut);
  }, be = (K, ye, Ne, qe, We, rt, mt, et, ut) => {
    ye.slotScopeIds = et, K == null ? ye.shapeFlag & 512 ? We.ctx.activate(ye, Ne, qe, mt, ut) : Ye(ye, Ne, qe, We, rt, mt, ut) : ht(K, ye, ut);
  }, Ye = (K, ye, Ne, qe, We, rt, mt) => {
    const et = K.component = dk(K, qe, We);
    if (process.env.NODE_ENV !== "production" && et.type.__hmrId && KA(et), process.env.NODE_ENV !== "production" && (Yy(K), Nl(et, "mount")), jd(K) && (et.ctx.renderer = Sn), process.env.NODE_ENV !== "production" && Nl(et, "init"), yk(et), process.env.NODE_ENV !== "production" && Rl(et, "init"), et.asyncDep) {
      if (We && We.registerDep(et, vt), !K.el) {
        const ut = et.subTree = Ft(Xi);
        re(null, ut, ye, Ne);
      }
      return;
    }
    vt(et, K, ye, Ne, We, rt, mt), process.env.NODE_ENV !== "production" && (Jy(), Rl(et, "mount"));
  }, ht = (K, ye, Ne) => {
    const qe = ye.component = K.component;
    if (fP(K, ye, Ne))
      if (qe.asyncDep && !qe.asyncResolved) {
        process.env.NODE_ENV !== "production" && Yy(ye), Pt(qe, ye, Ne), process.env.NODE_ENV !== "production" && Jy();
        return;
      } else
        qe.next = ye, ZA(qe.update), qe.update();
    else
      ye.el = K.el, qe.vnode = ye;
  }, vt = (K, ye, Ne, qe, We, rt, mt) => {
    const et = () => {
      if (K.isMounted) {
        let { next: It, bu: bt, u: kt, parent: Ut, vnode: dr } = K, Vr = It, Lr;
        process.env.NODE_ENV !== "production" && Yy(It || K.vnode), Tc(K, !1), It ? (It.el = dr.el, Pt(K, It, mt)) : It = dr, bt && Up(bt), (Lr = It.props && It.props.onVnodeBeforeUpdate) && zs(Lr, Ut, It, dr), Tc(K, !0), process.env.NODE_ENV !== "production" && Nl(K, "render");
        const Jr = A_(K);
        process.env.NODE_ENV !== "production" && Rl(K, "render");
        const Xn = K.subTree;
        K.subTree = Jr, process.env.NODE_ENV !== "production" && Nl(K, "patch"), V(
          Xn,
          Jr,
          M(Xn.el),
          Vn(Xn),
          K,
          We,
          rt
        ), process.env.NODE_ENV !== "production" && Rl(K, "patch"), It.el = Jr.el, Vr === null && pP(K, Jr.el), kt && ea(kt, We), (Lr = It.props && It.props.onVnodeUpdated) && ea(() => zs(Lr, Ut, It, dr), We), process.env.NODE_ENV !== "production" && mS(K), process.env.NODE_ENV !== "production" && Jy();
      } else {
        let It;
        const { el: bt, props: kt } = ye, { bm: Ut, m: dr, parent: Vr } = K, Lr = hd(ye);
        if (Tc(K, !1), Ut && Up(Ut), !Lr && (It = kt && kt.onVnodeBeforeMount) && zs(It, Vr, ye), Tc(K, !0), bt && Un) {
          const Jr = () => {
            process.env.NODE_ENV !== "production" && Nl(K, "render"), K.subTree = A_(K), process.env.NODE_ENV !== "production" && Rl(K, "render"), process.env.NODE_ENV !== "production" && Nl(K, "hydrate"), Un(bt, K.subTree, K, We, null), process.env.NODE_ENV !== "production" && Rl(K, "hydrate");
          };
          Lr ? ye.type.__asyncLoader().then(
            () => !K.isUnmounted && Jr()
          ) : Jr();
        } else {
          process.env.NODE_ENV !== "production" && Nl(K, "render");
          const Jr = K.subTree = A_(K);
          process.env.NODE_ENV !== "production" && Rl(K, "render"), process.env.NODE_ENV !== "production" && Nl(K, "patch"), V(null, Jr, Ne, qe, K, We, rt), process.env.NODE_ENV !== "production" && Rl(K, "patch"), ye.el = Jr.el;
        }
        if (dr && ea(dr, We), !Lr && (It = kt && kt.onVnodeMounted)) {
          const Jr = ye;
          ea(() => zs(It, Vr, Jr), We);
        }
        (ye.shapeFlag & 256 || Vr && hd(Vr.vnode) && Vr.vnode.shapeFlag & 256) && K.a && ea(K.a, We), K.isMounted = !0, process.env.NODE_ENV !== "production" && rP(K), ye = Ne = qe = null;
      }
    }, ut = K.effect = new T1(
      et,
      () => yv(Qe),
      K.scope
    ), Qe = K.update = () => ut.run();
    Qe.id = K.uid, Tc(K, !0), process.env.NODE_ENV !== "production" && (ut.onTrack = K.rtc ? (It) => Up(K.rtc, It) : void 0, ut.onTrigger = K.rtg ? (It) => Up(K.rtg, It) : void 0, Qe.ownerInstance = K), Qe();
  }, Pt = (K, ye, Ne) => {
    ye.component = K;
    const qe = K.vnode.props;
    K.vnode = ye, K.next = null, $P(K, ye.props, qe, Ne), JP(K, ye.children, Ne), rh(), $b(), nh();
  }, tr = (K, ye, Ne, qe, We, rt, mt, et, ut = !1) => {
    const Qe = K && K.children, It = K ? K.shapeFlag : 0, bt = ye.children, { patchFlag: kt, shapeFlag: Ut } = ye;
    if (kt > 0) {
      if (kt & 128) {
        Rr(Qe, bt, Ne, qe, We, rt, mt, et, ut);
        return;
      } else if (kt & 256) {
        kn(Qe, bt, Ne, qe, We, rt, mt, et, ut);
        return;
      }
    }
    Ut & 8 ? (It & 16 && kr(Qe, We, rt), bt !== Qe && T(Ne, bt)) : It & 16 ? Ut & 16 ? Rr(Qe, bt, Ne, qe, We, rt, mt, et, ut) : kr(Qe, We, rt, !0) : (It & 8 && T(Ne, ""), Ut & 16 && Se(bt, Ne, qe, We, rt, mt, et, ut));
  }, kn = (K, ye, Ne, qe, We, rt, mt, et, ut) => {
    K = K || wf, ye = ye || wf;
    const Qe = K.length, It = ye.length, bt = Math.min(Qe, It);
    let kt;
    for (kt = 0; kt < bt; kt++) {
      const Ut = ye[kt] = ut ? wu(ye[kt]) : ns(ye[kt]);
      V(K[kt], Ut, Ne, null, We, rt, mt, et, ut);
    }
    Qe > It ? kr(K, We, rt, !0, !1, bt) : Se(ye, Ne, qe, We, rt, mt, et, ut, bt);
  }, Rr = (K, ye, Ne, qe, We, rt, mt, et, ut) => {
    let Qe = 0;
    const It = ye.length;
    let bt = K.length - 1, kt = It - 1;
    for (; Qe <= bt && Qe <= kt; ) {
      const Ut = K[Qe], dr = ye[Qe] = ut ? wu(ye[Qe]) : ns(ye[Qe]);
      if (Bc(Ut, dr))
        V(Ut, dr, Ne, null, We, rt, mt, et, ut);
      else
        break;
      Qe++;
    }
    for (; Qe <= bt && Qe <= kt; ) {
      const Ut = K[bt], dr = ye[kt] = ut ? wu(ye[kt]) : ns(ye[kt]);
      if (Bc(Ut, dr))
        V(Ut, dr, Ne, null, We, rt, mt, et, ut);
      else
        break;
      bt--, kt--;
    }
    if (Qe > bt) {
      if (Qe <= kt) {
        const Ut = kt + 1, dr = Ut < It ? ye[Ut].el : qe;
        for (; Qe <= kt; )
          V(null, ye[Qe] = ut ? wu(ye[Qe]) : ns(ye[Qe]), Ne, dr, We, rt, mt, et, ut), Qe++;
      }
    } else if (Qe > kt)
      for (; Qe <= bt; )
        Zn(K[Qe], We, rt, !0), Qe++;
    else {
      const Ut = Qe, dr = Qe, Vr = /* @__PURE__ */ new Map();
      for (Qe = dr; Qe <= kt; Qe++) {
        const Tn = ye[Qe] = ut ? wu(ye[Qe]) : ns(ye[Qe]);
        Tn.key != null && (process.env.NODE_ENV !== "production" && Vr.has(Tn.key) && lt("Duplicate keys found during update:", JSON.stringify(Tn.key), "Make sure keys are unique."), Vr.set(Tn.key, Qe));
      }
      let Lr, Jr = 0;
      const Xn = kt - dr + 1;
      let Bi = !1, so = 0;
      const Kn = new Array(Xn);
      for (Qe = 0; Qe < Xn; Qe++)
        Kn[Qe] = 0;
      for (Qe = Ut; Qe <= bt; Qe++) {
        const Tn = K[Qe];
        if (Jr >= Xn) {
          Zn(Tn, We, rt, !0);
          continue;
        }
        let ai;
        if (Tn.key != null)
          ai = Vr.get(Tn.key);
        else
          for (Lr = dr; Lr <= kt; Lr++)
            if (Kn[Lr - dr] === 0 && Bc(Tn, ye[Lr])) {
              ai = Lr;
              break;
            }
        ai === void 0 ? Zn(Tn, We, rt, !0) : (Kn[ai - dr] = Qe + 1, ai >= so ? so = ai : Bi = !0, V(Tn, ye[ai], Ne, null, We, rt, mt, et, ut), Jr++);
      }
      const Li = Bi ? ik(Kn) : wf;
      for (Lr = Li.length - 1, Qe = Xn - 1; Qe >= 0; Qe--) {
        const Tn = dr + Qe, ai = ye[Tn], Fa = Tn + 1 < It ? ye[Tn + 1].el : qe;
        Kn[Qe] === 0 ? V(null, ai, Ne, Fa, We, rt, mt, et, ut) : Bi && (Lr < 0 || Qe !== Li[Lr] ? pr(ai, Ne, Fa, 2) : Lr--);
      }
    }
  }, pr = (K, ye, Ne, qe, We = null) => {
    const { el: rt, type: mt, transition: et, children: ut, shapeFlag: Qe } = K;
    if (Qe & 6) {
      pr(K.component.subTree, ye, Ne, qe);
      return;
    }
    if (Qe & 128) {
      K.suspense.move(ye, Ne, qe);
      return;
    }
    if (Qe & 64) {
      mt.move(K, ye, Ne, Sn);
      return;
    }
    if (mt === cn) {
      o(rt, ye, Ne);
      for (let bt = 0; bt < ut.length; bt++)
        pr(ut[bt], ye, Ne, qe);
      o(K.anchor, ye, Ne);
      return;
    }
    if (mt === Qy) {
      ce(K, ye, Ne);
      return;
    }
    if (qe !== 2 && Qe & 1 && et)
      if (qe === 0)
        et.beforeEnter(rt), o(rt, ye, Ne), ea(() => et.enter(rt), We);
      else {
        const { leave: bt, delayLeave: kt, afterLeave: Ut } = et, dr = () => o(rt, ye, Ne), Vr = () => {
          bt(rt, () => {
            dr(), Ut && Ut();
          });
        };
        kt ? kt(rt, dr, Vr) : Vr();
      }
    else
      o(rt, ye, Ne);
  }, Zn = (K, ye, Ne, qe = !1, We = !1) => {
    const { type: rt, props: mt, ref: et, children: ut, dynamicChildren: Qe, shapeFlag: It, patchFlag: bt, dirs: kt } = K;
    if (et != null && R0(et, null, Ne, K, !0), It & 256) {
      ye.ctx.deactivate(K);
      return;
    }
    const Ut = It & 1 && kt, dr = !hd(K);
    let Vr;
    if (dr && (Vr = mt && mt.onVnodeBeforeUnmount) && zs(Vr, ye, K), It & 6)
      $r(K.component, Ne, qe);
    else {
      if (It & 128) {
        K.suspense.unmount(Ne, qe);
        return;
      }
      Ut && Sc(K, null, ye, "beforeUnmount"), It & 64 ? K.type.remove(K, ye, Ne, We, Sn, qe) : Qe && (rt !== cn || bt > 0 && bt & 64) ? kr(Qe, ye, Ne, !1, !0) : (rt === cn && bt & 384 || !We && It & 16) && kr(ut, ye, Ne), qe && zr(K);
    }
    (dr && (Vr = mt && mt.onVnodeUnmounted) || Ut) && ea(() => {
      Vr && zs(Vr, ye, K), Ut && Sc(K, null, ye, "unmounted");
    }, Ne);
  }, zr = (K) => {
    const { type: ye, el: Ne, anchor: qe, transition: We } = K;
    if (ye === cn) {
      process.env.NODE_ENV !== "production" && K.patchFlag > 0 && K.patchFlag & 2048 && We && !We.persisted ? K.children.forEach((mt) => {
        mt.type === Xi ? s(mt.el) : zr(mt);
      }) : Fi(Ne, qe);
      return;
    }
    if (ye === Qy) {
      ve(K);
      return;
    }
    const rt = () => {
      s(Ne), We && !We.persisted && We.afterLeave && We.afterLeave();
    };
    if (K.shapeFlag & 1 && We && !We.persisted) {
      const { leave: mt, delayLeave: et } = We, ut = () => mt(Ne, rt);
      et ? et(K.el, rt, ut) : ut();
    } else
      rt();
  }, Fi = (K, ye) => {
    let Ne;
    for (; K !== ye; )
      Ne = I(K), s(K), K = Ne;
    s(ye);
  }, $r = (K, ye, Ne) => {
    process.env.NODE_ENV !== "production" && K.type.__hmrId && YA(K);
    const { bum: qe, scope: We, update: rt, subTree: mt, um: et } = K;
    qe && Up(qe), We.stop(), rt && (rt.active = !1, Zn(mt, K, ye, Ne)), et && ea(et, ye), ea(() => {
      K.isUnmounted = !0;
    }, ye), ye && ye.pendingBranch && !ye.isUnmounted && K.asyncDep && !K.asyncResolved && K.suspenseId === ye.pendingId && (ye.deps--, ye.deps === 0 && ye.resolve()), process.env.NODE_ENV !== "production" && iP(K);
  }, kr = (K, ye, Ne, qe = !1, We = !1, rt = 0) => {
    for (let mt = rt; mt < K.length; mt++)
      Zn(K[mt], ye, Ne, qe, We);
  }, Vn = (K) => K.shapeFlag & 6 ? Vn(K.component.subTree) : K.shapeFlag & 128 ? K.suspense.next() : I(K.anchor || K.el), Tr = (K, ye, Ne) => {
    K == null ? ye._vnode && Zn(ye._vnode, null, null, !0) : V(ye._vnode || null, K, ye, null, null, null, Ne), $b(), hS(), ye._vnode = K;
  }, Sn = {
    p: V,
    um: Zn,
    m: pr,
    r: zr,
    mt: Ye,
    mc: Se,
    pc: tr,
    pbc: Xe,
    n: Vn,
    o: t
  };
  let oi, Un;
  return e && ([oi, Un] = e(Sn)), {
    render: Tr,
    hydrate: oi,
    createApp: ek(Tr, oi)
  };
}
function Tc({ effect: t, update: e }, n) {
  t.allowRecurse = e.allowRecurse = n;
}
function fd(t, e, n = !1) {
  const o = t.children, s = e.children;
  if (er(o) && er(s))
    for (let h = 0; h < o.length; h++) {
      const a = o[h];
      let m = s[h];
      m.shapeFlag & 1 && !m.dynamicChildren && ((m.patchFlag <= 0 || m.patchFlag === 32) && (m = s[h] = wu(s[h]), m.el = a.el), n || fd(a, m)), m.type === Gd && (m.el = a.el), process.env.NODE_ENV !== "production" && m.type === Xi && !m.el && (m.el = a.el);
    }
}
function ik(t) {
  const e = t.slice(), n = [0];
  let o, s, h, a, m;
  const g = t.length;
  for (o = 0; o < g; o++) {
    const b = t[o];
    if (b !== 0) {
      if (s = n[n.length - 1], t[s] < b) {
        e[o] = s, n.push(o);
        continue;
      }
      for (h = 0, a = n.length - 1; h < a; )
        m = h + a >> 1, t[n[m]] < b ? h = m + 1 : a = m;
      b < t[n[h]] && (h > 0 && (e[o] = n[h - 1]), n[h] = o);
    }
  }
  for (h = n.length, a = n[h - 1]; h-- > 0; )
    n[h] = a, a = e[a];
  return n;
}
const ok = (t) => t.__isTeleport, Tf = (t) => t && (t.disabled || t.disabled === ""), nw = (t) => typeof SVGElement < "u" && t instanceof SVGElement, z0 = (t, e) => {
  const n = t && t.to;
  if (Hn(n))
    if (e) {
      const o = e(n);
      return o || process.env.NODE_ENV !== "production" && lt(`Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`), o;
    } else
      return process.env.NODE_ENV !== "production" && lt("Current renderer does not support string target for Teleports. (missing querySelector renderer option)"), null;
  else
    return process.env.NODE_ENV !== "production" && !n && !Tf(t) && lt(`Invalid Teleport target: ${n}`), n;
}, ak = {
  __isTeleport: !0,
  process(t, e, n, o, s, h, a, m, g, b) {
    const { mc: T, pc: M, pbc: I, o: { insert: P, querySelector: z, createText: V, createComment: q } } = b, re = Tf(e.props);
    let { shapeFlag: X, children: ae, dynamicChildren: ce } = e;
    if (process.env.NODE_ENV !== "production" && Pu && (g = !1, ce = null), t == null) {
      const ve = e.el = process.env.NODE_ENV !== "production" ? q("teleport start") : V(""), Re = e.anchor = process.env.NODE_ENV !== "production" ? q("teleport end") : V("");
      P(ve, n, o), P(Re, n, o);
      const Fe = e.target = z0(e.props, z), Pe = e.targetAnchor = V("");
      Fe ? (P(Pe, Fe), a = a || nw(Fe)) : process.env.NODE_ENV !== "production" && !re && lt("Invalid Teleport target on mount:", Fe, `(${typeof Fe})`);
      const Se = (Ie, Xe) => {
        X & 16 && T(ae, Ie, Xe, s, h, a, m, g);
      };
      re ? Se(n, Re) : Fe && Se(Fe, Pe);
    } else {
      e.el = t.el;
      const ve = e.anchor = t.anchor, Re = e.target = t.target, Fe = e.targetAnchor = t.targetAnchor, Pe = Tf(t.props), Se = Pe ? n : Re, Ie = Pe ? ve : Fe;
      if (a = a || nw(Re), ce ? (I(t.dynamicChildren, ce, Se, s, h, a, m), fd(t, e, !0)) : g || M(t, e, Se, Ie, s, h, a, m, !1), re)
        Pe || Ey(e, n, ve, b, 1);
      else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
        const Xe = e.target = z0(e.props, z);
        Xe ? Ey(e, Xe, null, b, 0) : process.env.NODE_ENV !== "production" && lt("Invalid Teleport target on update:", Re, `(${typeof Re})`);
      } else
        Pe && Ey(e, Re, Fe, b, 1);
    }
    VS(e);
  },
  remove(t, e, n, o, { um: s, o: { remove: h } }, a) {
    const { shapeFlag: m, children: g, anchor: b, targetAnchor: T, target: M, props: I } = t;
    if (M && h(T), (a || !Tf(I)) && (h(b), m & 16))
      for (let P = 0; P < g.length; P++) {
        const z = g[P];
        s(z, e, n, !0, !!z.dynamicChildren);
      }
  },
  move: Ey,
  hydrate: sk
};
function Ey(t, e, n, { o: { insert: o }, m: s }, h = 2) {
  h === 0 && o(t.targetAnchor, e, n);
  const { el: a, anchor: m, shapeFlag: g, children: b, props: T } = t, M = h === 2;
  if (M && o(a, e, n), (!M || Tf(T)) && g & 16)
    for (let I = 0; I < b.length; I++)
      s(b[I], e, n, 2);
  M && o(m, e, n);
}
function sk(t, e, n, o, s, h, { o: { nextSibling: a, parentNode: m, querySelector: g } }, b) {
  const T = e.target = z0(e.props, g);
  if (T) {
    const M = T._lpa || T.firstChild;
    if (e.shapeFlag & 16)
      if (Tf(e.props))
        e.anchor = b(a(t), e, m(t), n, o, s, h), e.targetAnchor = M;
      else {
        e.anchor = a(t);
        let I = M;
        for (; I; )
          if (I = a(I), I && I.nodeType === 8 && I.data === "teleport anchor") {
            e.targetAnchor = I, T._lpa = e.targetAnchor && a(e.targetAnchor);
            break;
          }
        b(M, e, T, n, o, s, h);
      }
    VS(e);
  }
  return e.anchor && a(e.anchor);
}
const BS = ak;
function VS(t) {
  const e = t.ctx;
  if (e && e.ut) {
    let n = t.children[0].el;
    for (; n !== t.targetAnchor; )
      n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid), n = n.nextSibling;
    e.ut();
  }
}
const cn = Symbol(process.env.NODE_ENV !== "production" ? "Fragment" : void 0), Gd = Symbol(process.env.NODE_ENV !== "production" ? "Text" : void 0), Xi = Symbol(process.env.NODE_ENV !== "production" ? "Comment" : void 0), Qy = Symbol(process.env.NODE_ENV !== "production" ? "Static" : void 0), pd = [];
let os = null;
function Ve(t = !1) {
  pd.push(os = t ? null : []);
}
function lk() {
  pd.pop(), os = pd[pd.length - 1] || null;
}
let Cd = 1;
function iw(t) {
  Cd += t;
}
function US(t) {
  return t.dynamicChildren = Cd > 0 ? os || wf : null, lk(), Cd > 0 && os && os.push(t), t;
}
function it(t, e, n, o, s, h) {
  return US(ze(t, e, n, o, s, h, !0));
}
function on(t, e, n, o, s) {
  return US(Ft(t, e, n, o, s, !0));
}
function Lf(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function Bc(t, e) {
  return process.env.NODE_ENV !== "production" && e.shapeFlag & 6 && hf.has(e.type) ? (t.shapeFlag &= -257, e.shapeFlag &= -513, !1) : t.type === e.type && t.key === e.key;
}
const uk = (...t) => GS(...t), _v = "__vInternal", jS = ({ key: t }) => t != null ? t : null, eg = ({ ref: t, ref_key: e, ref_for: n }) => t != null ? Hn(t) || hn(t) || yr(t) ? { i: zi, r: t, k: e, f: !!n } : t : null;
function ze(t, e = null, n = null, o = 0, s = null, h = t === cn ? 0 : 1, a = !1, m = !1) {
  const g = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && jS(e),
    ref: e && eg(e),
    scopeId: vS,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: h,
    patchFlag: o,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: zi
  };
  return m ? (z1(g, n), h & 128 && t.normalize(g)) : n && (g.shapeFlag |= Hn(n) ? 8 : 16), process.env.NODE_ENV !== "production" && g.key !== g.key && lt("VNode created with invalid key (NaN). VNode type:", g.type), Cd > 0 && !a && os && (g.patchFlag > 0 || h & 6) && g.patchFlag !== 32 && os.push(g), g;
}
const Ft = process.env.NODE_ENV !== "production" ? uk : GS;
function GS(t, e = null, n = null, o = 0, s = null, h = !1) {
  if ((!t || t === PP) && (process.env.NODE_ENV !== "production" && !t && lt(`Invalid vnode type when creating vnode: ${t}.`), t = Xi), Lf(t)) {
    const m = Qs(t, e, !0);
    return n && z1(m, n), Cd > 0 && !h && os && (m.shapeFlag & 6 ? os[os.indexOf(t)] = m : os.push(m)), m.patchFlag |= -2, m;
  }
  if (HS(t) && (t = t.__vccOpts), e) {
    e = ck(e);
    let { class: m, style: g } = e;
    m && !Hn(m) && (e.class = Pr(m)), fn(g) && (wg(g) && !er(g) && (g = Wn({}, g)), e.style = ju(g));
  }
  const a = Hn(t) ? 1 : dP(t) ? 128 : ok(t) ? 64 : fn(t) ? 4 : yr(t) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && a & 4 && wg(t) && (t = hr(t), lt("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `
Component that was made reactive: `, t)), ze(t, e, n, o, s, a, h, !0);
}
function ck(t) {
  return t ? wg(t) || _v in t ? Wn({}, t) : t : null;
}
function Qs(t, e, n = !1) {
  const { props: o, ref: s, patchFlag: h, children: a } = t, m = e ? hk(o || {}, e) : o;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: m,
    key: m && jS(m),
    ref: e && e.ref ? n && s ? er(s) ? s.concat(eg(e)) : [s, eg(e)] : eg(e) : s,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && h === -1 && er(a) ? a.map($S) : a,
    target: t.target,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    patchFlag: e && t.type !== cn ? h === -1 ? 16 : h | 16 : h,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: t.transition,
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && Qs(t.ssContent),
    ssFallback: t.ssFallback && Qs(t.ssFallback),
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
}
function $S(t) {
  const e = Qs(t);
  return er(t.children) && (e.children = t.children.map($S)), e;
}
function Cg(t = " ", e = 0) {
  return Ft(Gd, null, t, e);
}
function Je(t = "", e = !1) {
  return e ? (Ve(), on(Xi, null, t)) : Ft(Xi, null, t);
}
function ns(t) {
  return t == null || typeof t == "boolean" ? Ft(Xi) : er(t) ? Ft(
    cn,
    null,
    t.slice()
  ) : typeof t == "object" ? wu(t) : Ft(Gd, null, String(t));
}
function wu(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : Qs(t);
}
function z1(t, e) {
  let n = 0;
  const { shapeFlag: o } = t;
  if (e == null)
    e = null;
  else if (er(e))
    n = 16;
  else if (typeof e == "object")
    if (o & 65) {
      const s = e.default;
      s && (s._c && (s._d = !1), z1(t, s()), s._c && (s._d = !0));
      return;
    } else {
      n = 32;
      const s = e._;
      !s && !(_v in e) ? e._ctx = zi : s === 3 && zi && (zi.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
  else
    yr(e) ? (e = { default: e, _ctx: zi }, n = 32) : (e = String(e), o & 64 ? (n = 16, e = [Cg(e)]) : n = 8);
  t.children = e, t.shapeFlag |= n;
}
function hk(...t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const o = t[n];
    for (const s in o)
      if (s === "class")
        e.class !== o.class && (e.class = Pr([e.class, o.class]));
      else if (s === "style")
        e.style = ju([e.style, o.style]);
      else if (Bd(s)) {
        const h = e[s], a = o[s];
        a && h !== a && !(er(h) && h.includes(a)) && (e[s] = h ? [].concat(h, a) : a);
      } else
        s !== "" && (e[s] = o[s]);
  }
  return e;
}
function zs(t, e, n, o = null) {
  Da(t, e, 7, [
    n,
    o
  ]);
}
const fk = FS();
let pk = 0;
function dk(t, e, n) {
  const o = t.type, s = (e ? e.appContext : t.appContext) || fk, h = {
    uid: pk++,
    vnode: t,
    type: o,
    parent: e,
    appContext: s,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new VE(!0),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(s.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: LS(o, s),
    emitsOptions: gS(o, s),
    emit: null,
    emitted: null,
    propsDefaults: wn,
    inheritAttrs: o.inheritAttrs,
    ctx: wn,
    data: wn,
    props: wn,
    attrs: wn,
    slots: wn,
    refs: wn,
    setupState: wn,
    setupContext: null,
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return process.env.NODE_ENV !== "production" ? h.ctx = LP(h) : h.ctx = { _: h }, h.root = e ? e.root : h, h.emit = lP.bind(null, h), t.ce && t.ce(h), h;
}
let pi = null;
const xv = () => pi || zi, Df = (t) => {
  pi = t, t.scope.on();
}, Hc = () => {
  pi && pi.scope.off(), pi = null;
}, mk = /* @__PURE__ */ Uu("slot,component");
function F0(t, e) {
  const n = e.isNativeTag || NE;
  (mk(t) || n(t)) && lt("Do not use built-in or reserved HTML elements as component id: " + t);
}
function qS(t) {
  return t.vnode.shapeFlag & 4;
}
let Ad = !1;
function yk(t, e = !1) {
  Ad = e;
  const { props: n, children: o } = t.vnode, s = qS(t);
  jP(t, n, s, e), YP(t, o);
  const h = s ? gk(t, e) : void 0;
  return Ad = !1, h;
}
function gk(t, e) {
  var n;
  const o = t.type;
  if (process.env.NODE_ENV !== "production") {
    if (o.name && F0(o.name, t.appContext.config), o.components) {
      const h = Object.keys(o.components);
      for (let a = 0; a < h.length; a++)
        F0(h[a], t.appContext.config);
    }
    if (o.directives) {
      const h = Object.keys(o.directives);
      for (let a = 0; a < h.length; a++)
        IS(h[a]);
    }
    o.compilerOptions && vk() && lt('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.');
  }
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = rs(new Proxy(t.ctx, AS)), process.env.NODE_ENV !== "production" && DP(t);
  const { setup: s } = o;
  if (s) {
    const h = t.setupContext = s.length > 1 ? _k(t) : null;
    Df(t), rh();
    const a = Bl(s, t, 0, [process.env.NODE_ENV !== "production" ? mf(t.props) : t.props, h]);
    if (nh(), Hc(), w1(a)) {
      if (a.then(Hc, Hc), e)
        return a.then((m) => {
          ow(t, m, e);
        }).catch((m) => {
          mv(m, t, 0);
        });
      if (t.asyncDep = a, process.env.NODE_ENV !== "production" && !t.suspense) {
        const m = (n = o.name) !== null && n !== void 0 ? n : "Anonymous";
        lt(`Component <${m}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
      }
    } else
      ow(t, a, e);
  } else
    WS(t, e);
}
function ow(t, e, n) {
  yr(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : fn(e) ? (process.env.NODE_ENV !== "production" && Lf(e) && lt("setup() should not return VNodes directly - return a render function instead."), process.env.NODE_ENV !== "production" && (t.devtoolsRawSetupState = e), t.setupState = oS(e), process.env.NODE_ENV !== "production" && NP(t)) : process.env.NODE_ENV !== "production" && e !== void 0 && lt(`setup() should return an object. Received: ${e === null ? "null" : typeof e}`), WS(t, n);
}
let B0;
const vk = () => !B0;
function WS(t, e, n) {
  const o = t.type;
  if (!t.render) {
    if (!e && B0 && !o.render) {
      const s = o.template || N1(t).template;
      if (s) {
        process.env.NODE_ENV !== "production" && Nl(t, "compile");
        const { isCustomElement: h, compilerOptions: a } = t.appContext.config, { delimiters: m, compilerOptions: g } = o, b = Wn(Wn({
          isCustomElement: h,
          delimiters: m
        }, a), g);
        o.render = B0(s, b), process.env.NODE_ENV !== "production" && Rl(t, "compile");
      }
    }
    t.render = o.render || ao;
  }
  Df(t), rh(), zP(t), nh(), Hc(), process.env.NODE_ENV !== "production" && !o.render && t.render === ao && !e && (o.template ? lt('Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".') : lt("Component is missing template or render function."));
}
function aw(t) {
  return new Proxy(t.attrs, process.env.NODE_ENV !== "production" ? {
    get(e, n) {
      return Tg(), Bo(t, "get", "$attrs"), e[n];
    },
    set() {
      return lt("setupContext.attrs is readonly."), !1;
    },
    deleteProperty() {
      return lt("setupContext.attrs is readonly."), !1;
    }
  } : {
    get(e, n) {
      return Bo(t, "get", "$attrs"), e[n];
    }
  });
}
function _k(t) {
  const e = (o) => {
    if (process.env.NODE_ENV !== "production" && (t.exposed && lt("expose() should be called only once per setup()."), o != null)) {
      let s = typeof o;
      s === "object" && (er(o) ? s = "array" : hn(o) && (s = "ref")), s !== "object" && lt(`expose() should be passed a plain object, received ${s}.`);
    }
    t.exposed = o || {};
  };
  let n;
  return process.env.NODE_ENV !== "production" ? Object.freeze({
    get attrs() {
      return n || (n = aw(t));
    },
    get slots() {
      return mf(t.slots);
    },
    get emit() {
      return (o, ...s) => t.emit(o, ...s);
    },
    expose: e
  }) : {
    get attrs() {
      return n || (n = aw(t));
    },
    slots: t.slots,
    emit: t.emit,
    expose: e
  };
}
function bv(t) {
  if (t.exposed)
    return t.exposeProxy || (t.exposeProxy = new Proxy(oS(rs(t.exposed)), {
      get(e, n) {
        if (n in e)
          return e[n];
        if (n in Wc)
          return Wc[n](t);
      },
      has(e, n) {
        return n in e || n in Wc;
      }
    }));
}
const xk = /(?:^|[-_])(\w)/g, bk = (t) => t.replace(xk, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function F1(t, e = !0) {
  return yr(t) ? t.displayName || t.name : t.name || e && t.__name;
}
function wv(t, e, n = !1) {
  let o = F1(e);
  if (!o && e.__file) {
    const s = e.__file.match(/([^/\\]+)\.\w+$/);
    s && (o = s[1]);
  }
  if (!o && t && t.parent) {
    const s = (h) => {
      for (const a in h)
        if (h[a] === e)
          return a;
    };
    o = s(t.components || t.parent.type.components) || s(t.appContext.components);
  }
  return o ? bk(o) : n ? "App" : "Anonymous";
}
function HS(t) {
  return yr(t) && "__vccOpts" in t;
}
const or = (t, e) => BA(t, e, Ad);
function ZS(t, e, n) {
  const o = arguments.length;
  return o === 2 ? fn(e) && !er(e) ? Lf(e) ? Ft(t, null, [e]) : Ft(t, e) : Ft(t, null, e) : (o > 3 ? n = Array.prototype.slice.call(arguments, 2) : o === 3 && Lf(n) && (n = [n]), Ft(t, e, n));
}
const wk = Symbol(process.env.NODE_ENV !== "production" ? "ssrContext" : ""), Ek = () => {
  {
    const t = Sf(wk);
    return t || process.env.NODE_ENV !== "production" && lt("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), t;
  }
};
function L_(t) {
  return !!(t && t.__v_isShallow);
}
function Sk() {
  if (process.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const t = { style: "color:#3ba776" }, e = { style: "color:#0b1bc9" }, n = { style: "color:#b62e24" }, o = { style: "color:#9d288c" }, s = {
    header(M) {
      return fn(M) ? M.__isVue ? ["div", t, "VueInstance"] : hn(M) ? [
        "div",
        {},
        ["span", t, T(M)],
        "<",
        m(M.value),
        ">"
      ] : ls(M) ? [
        "div",
        {},
        ["span", t, L_(M) ? "ShallowReactive" : "Reactive"],
        "<",
        m(M),
        `>${Ru(M) ? " (readonly)" : ""}`
      ] : Ru(M) ? [
        "div",
        {},
        ["span", t, L_(M) ? "ShallowReadonly" : "Readonly"],
        "<",
        m(M),
        ">"
      ] : null : null;
    },
    hasBody(M) {
      return M && M.__isVue;
    },
    body(M) {
      if (M && M.__isVue)
        return [
          "div",
          {},
          ...h(M.$)
        ];
    }
  };
  function h(M) {
    const I = [];
    M.type.props && M.props && I.push(a("props", hr(M.props))), M.setupState !== wn && I.push(a("setup", M.setupState)), M.data !== wn && I.push(a("data", hr(M.data)));
    const P = g(M, "computed");
    P && I.push(a("computed", P));
    const z = g(M, "inject");
    return z && I.push(a("injected", z)), I.push([
      "div",
      {},
      [
        "span",
        {
          style: o.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: M }]
    ]), I;
  }
  function a(M, I) {
    return I = Wn({}, I), Object.keys(I).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        M
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(I).map((P) => [
          "div",
          {},
          ["span", o, P + ": "],
          m(I[P], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function m(M, I = !0) {
    return typeof M == "number" ? ["span", e, M] : typeof M == "string" ? ["span", n, JSON.stringify(M)] : typeof M == "boolean" ? ["span", o, M] : fn(M) ? ["object", { object: I ? hr(M) : M }] : ["span", n, String(M)];
  }
  function g(M, I) {
    const P = M.type;
    if (yr(P))
      return;
    const z = {};
    for (const V in M.ctx)
      b(P, V, I) && (z[V] = M.ctx[V]);
    return z;
  }
  function b(M, I, P) {
    const z = M[P];
    if (er(z) && z.includes(I) || fn(z) && I in z || M.extends && b(M.extends, I, P) || M.mixins && M.mixins.some((V) => b(V, I, P)))
      return !0;
  }
  function T(M) {
    return L_(M) ? "ShallowRef" : M.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(s) : window.devtoolsFormatters = [s];
}
const sw = "3.2.47", Tk = "http://www.w3.org/2000/svg", Vc = typeof document < "u" ? document : null, lw = Vc && /* @__PURE__ */ Vc.createElement("template"), Mk = {
  insert: (t, e, n) => {
    e.insertBefore(t, n || null);
  },
  remove: (t) => {
    const e = t.parentNode;
    e && e.removeChild(t);
  },
  createElement: (t, e, n, o) => {
    const s = e ? Vc.createElementNS(Tk, t) : Vc.createElement(t, n ? { is: n } : void 0);
    return t === "select" && o && o.multiple != null && s.setAttribute("multiple", o.multiple), s;
  },
  createText: (t) => Vc.createTextNode(t),
  createComment: (t) => Vc.createComment(t),
  setText: (t, e) => {
    t.nodeValue = e;
  },
  setElementText: (t, e) => {
    t.textContent = e;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => Vc.querySelector(t),
  setScopeId(t, e) {
    t.setAttribute(e, "");
  },
  insertStaticContent(t, e, n, o, s, h) {
    const a = n ? n.previousSibling : e.lastChild;
    if (s && (s === h || s.nextSibling))
      for (; e.insertBefore(s.cloneNode(!0), n), !(s === h || !(s = s.nextSibling)); )
        ;
    else {
      lw.innerHTML = o ? `<svg>${t}</svg>` : t;
      const m = lw.content;
      if (o) {
        const g = m.firstChild;
        for (; g.firstChild; )
          m.appendChild(g.firstChild);
        m.removeChild(g);
      }
      e.insertBefore(m, n);
    }
    return [
      a ? a.nextSibling : e.firstChild,
      n ? n.previousSibling : e.lastChild
    ];
  }
};
function Ik(t, e, n) {
  const o = t._vtc;
  o && (e = (e ? [e, ...o] : [...o]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e;
}
function Ok(t, e, n) {
  const o = t.style, s = Hn(n);
  if (n && !s) {
    if (e && !Hn(e))
      for (const h in e)
        n[h] == null && V0(o, h, "");
    for (const h in n)
      V0(o, h, n[h]);
  } else {
    const h = o.display;
    s ? e !== n && (o.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (o.display = h);
  }
}
const Ck = /[^\\];\s*$/, uw = /\s*!important$/;
function V0(t, e, n) {
  if (er(n))
    n.forEach((o) => V0(t, e, o));
  else if (n == null && (n = ""), process.env.NODE_ENV !== "production" && Ck.test(n) && lt(`Unexpected semicolon at the end of '${e}' style value: '${n}'`), e.startsWith("--"))
    t.setProperty(e, n);
  else {
    const o = Ak(t, e);
    uw.test(n) ? t.setProperty(ta(o), n.replace(uw, ""), "important") : t[o] = n;
  }
}
const cw = ["Webkit", "Moz", "ms"], D_ = {};
function Ak(t, e) {
  const n = D_[e];
  if (n)
    return n;
  let o = ya(e);
  if (o !== "filter" && o in t)
    return D_[e] = o;
  o = Yc(o);
  for (let s = 0; s < cw.length; s++) {
    const h = cw[s] + o;
    if (h in t)
      return D_[e] = h;
  }
  return e;
}
const hw = "http://www.w3.org/1999/xlink";
function Pk(t, e, n, o, s) {
  if (o && e.startsWith("xlink:"))
    n == null ? t.removeAttributeNS(hw, e.slice(6, e.length)) : t.setAttributeNS(hw, e, n);
  else {
    const h = YC(e);
    n == null || h && !LE(n) ? t.removeAttribute(e) : t.setAttribute(e, h ? "" : n);
  }
}
function kk(t, e, n, o, s, h, a) {
  if (e === "innerHTML" || e === "textContent") {
    o && a(o, s, h), t[e] = n == null ? "" : n;
    return;
  }
  if (e === "value" && t.tagName !== "PROGRESS" && !t.tagName.includes("-")) {
    t._value = n;
    const g = n == null ? "" : n;
    (t.value !== g || t.tagName === "OPTION") && (t.value = g), n == null && t.removeAttribute(e);
    return;
  }
  let m = !1;
  if (n === "" || n == null) {
    const g = typeof t[e];
    g === "boolean" ? n = LE(n) : n == null && g === "string" ? (n = "", m = !0) : g === "number" && (n = 0, m = !0);
  }
  try {
    t[e] = n;
  } catch (g) {
    process.env.NODE_ENV !== "production" && !m && lt(`Failed setting prop "${e}" on <${t.tagName.toLowerCase()}>: value ${n} is invalid.`, g);
  }
  m && t.removeAttribute(e);
}
function Lk(t, e, n, o) {
  t.addEventListener(e, n, o);
}
function Dk(t, e, n, o) {
  t.removeEventListener(e, n, o);
}
function Nk(t, e, n, o, s = null) {
  const h = t._vei || (t._vei = {}), a = h[e];
  if (o && a)
    a.value = o;
  else {
    const [m, g] = Rk(e);
    if (o) {
      const b = h[e] = Bk(o, s);
      Lk(t, m, b, g);
    } else
      a && (Dk(t, m, a, g), h[e] = void 0);
  }
}
const fw = /(?:Once|Passive|Capture)$/;
function Rk(t) {
  let e;
  if (fw.test(t)) {
    e = {};
    let o;
    for (; o = t.match(fw); )
      t = t.slice(0, t.length - o[0].length), e[o[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : ta(t.slice(2)), e];
}
let N_ = 0;
const zk = /* @__PURE__ */ Promise.resolve(), Fk = () => N_ || (zk.then(() => N_ = 0), N_ = Date.now());
function Bk(t, e) {
  const n = (o) => {
    if (!o._vts)
      o._vts = Date.now();
    else if (o._vts <= n.attached)
      return;
    Da(Vk(o, n.value), e, 5, [o]);
  };
  return n.value = t, n.attached = Fk(), n;
}
function Vk(t, e) {
  if (er(e)) {
    const n = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      n.call(t), t._stopped = !0;
    }, e.map((o) => (s) => !s._stopped && o && o(s));
  } else
    return e;
}
const pw = /^on[a-z]/, Uk = (t, e, n, o, s = !1, h, a, m, g) => {
  e === "class" ? Ik(t, o, s) : e === "style" ? Ok(t, n, o) : Bd(e) ? gg(e) || Nk(t, e, n, o, a) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : jk(t, e, o, s)) ? kk(t, e, o, h, a, m, g) : (e === "true-value" ? t._trueValue = o : e === "false-value" && (t._falseValue = o), Pk(t, e, o, s));
};
function jk(t, e, n, o) {
  return o ? !!(e === "innerHTML" || e === "textContent" || e in t && pw.test(e) && yr(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || pw.test(e) && Hn(n) ? !1 : e in t;
}
const mu = "transition", Gp = "animation", Ev = (t, { slots: e }) => ZS(wS, Gk(t), e);
Ev.displayName = "Transition";
const XS = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Ev.props = /* @__PURE__ */ Wn({}, wS.props, XS);
const Mc = (t, e = []) => {
  er(t) ? t.forEach((n) => n(...e)) : t && t(...e);
}, dw = (t) => t ? er(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;
function Gk(t) {
  const e = {};
  for (const $e in t)
    $e in XS || (e[$e] = t[$e]);
  if (t.css === !1)
    return e;
  const { name: n = "v", type: o, duration: s, enterFromClass: h = `${n}-enter-from`, enterActiveClass: a = `${n}-enter-active`, enterToClass: m = `${n}-enter-to`, appearFromClass: g = h, appearActiveClass: b = a, appearToClass: T = m, leaveFromClass: M = `${n}-leave-from`, leaveActiveClass: I = `${n}-leave-active`, leaveToClass: P = `${n}-leave-to` } = t, z = $k(s), V = z && z[0], q = z && z[1], { onBeforeEnter: re, onEnter: X, onEnterCancelled: ae, onLeave: ce, onLeaveCancelled: ve, onBeforeAppear: Re = re, onAppear: Fe = X, onAppearCancelled: Pe = ae } = e, Se = ($e, at, be) => {
    Ic($e, at ? T : m), Ic($e, at ? b : a), be && be();
  }, Ie = ($e, at) => {
    $e._isLeaving = !1, Ic($e, M), Ic($e, P), Ic($e, I), at && at();
  }, Xe = ($e) => (at, be) => {
    const Ye = $e ? Fe : X, ht = () => Se(at, $e, be);
    Mc(Ye, [at, ht]), mw(() => {
      Ic(at, $e ? g : h), yu(at, $e ? T : m), dw(Ye) || yw(at, o, V, ht);
    });
  };
  return Wn(e, {
    onBeforeEnter($e) {
      Mc(re, [$e]), yu($e, h), yu($e, a);
    },
    onBeforeAppear($e) {
      Mc(Re, [$e]), yu($e, g), yu($e, b);
    },
    onEnter: Xe(!1),
    onAppear: Xe(!0),
    onLeave($e, at) {
      $e._isLeaving = !0;
      const be = () => Ie($e, at);
      yu($e, M), Hk(), yu($e, I), mw(() => {
        !$e._isLeaving || (Ic($e, M), yu($e, P), dw(ce) || yw($e, o, q, be));
      }), Mc(ce, [$e, be]);
    },
    onEnterCancelled($e) {
      Se($e, !1), Mc(ae, [$e]);
    },
    onAppearCancelled($e) {
      Se($e, !0), Mc(Pe, [$e]);
    },
    onLeaveCancelled($e) {
      Ie($e), Mc(ve, [$e]);
    }
  });
}
function $k(t) {
  if (t == null)
    return null;
  if (fn(t))
    return [R_(t.enter), R_(t.leave)];
  {
    const e = R_(t);
    return [e, e];
  }
}
function R_(t) {
  const e = b0(t);
  return process.env.NODE_ENV !== "production" && $A(e, "<transition> explicit duration"), e;
}
function yu(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.add(n)), (t._vtc || (t._vtc = /* @__PURE__ */ new Set())).add(e);
}
function Ic(t, e) {
  e.split(/\s+/).forEach((o) => o && t.classList.remove(o));
  const { _vtc: n } = t;
  n && (n.delete(e), n.size || (t._vtc = void 0));
}
function mw(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let qk = 0;
function yw(t, e, n, o) {
  const s = t._endId = ++qk, h = () => {
    s === t._endId && o();
  };
  if (n)
    return setTimeout(h, n);
  const { type: a, timeout: m, propCount: g } = Wk(t, e);
  if (!a)
    return o();
  const b = a + "end";
  let T = 0;
  const M = () => {
    t.removeEventListener(b, I), h();
  }, I = (P) => {
    P.target === t && ++T >= g && M();
  };
  setTimeout(() => {
    T < g && M();
  }, m + 1), t.addEventListener(b, I);
}
function Wk(t, e) {
  const n = window.getComputedStyle(t), o = (z) => (n[z] || "").split(", "), s = o(`${mu}Delay`), h = o(`${mu}Duration`), a = gw(s, h), m = o(`${Gp}Delay`), g = o(`${Gp}Duration`), b = gw(m, g);
  let T = null, M = 0, I = 0;
  e === mu ? a > 0 && (T = mu, M = a, I = h.length) : e === Gp ? b > 0 && (T = Gp, M = b, I = g.length) : (M = Math.max(a, b), T = M > 0 ? a > b ? mu : Gp : null, I = T ? T === mu ? h.length : g.length : 0);
  const P = T === mu && /\b(transform|all)(,|$)/.test(o(`${mu}Property`).toString());
  return {
    type: T,
    timeout: M,
    propCount: I,
    hasTransform: P
  };
}
function gw(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((n, o) => vw(n) + vw(t[o])));
}
function vw(t) {
  return Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function Hk() {
  return document.body.offsetHeight;
}
const Zk = ["ctrl", "shift", "alt", "meta"], Xk = {
  stop: (t) => t.stopPropagation(),
  prevent: (t) => t.preventDefault(),
  self: (t) => t.target !== t.currentTarget,
  ctrl: (t) => !t.ctrlKey,
  shift: (t) => !t.shiftKey,
  alt: (t) => !t.altKey,
  meta: (t) => !t.metaKey,
  left: (t) => "button" in t && t.button !== 0,
  middle: (t) => "button" in t && t.button !== 1,
  right: (t) => "button" in t && t.button !== 2,
  exact: (t, e) => Zk.some((n) => t[`${n}Key`] && !e.includes(n))
}, js = (t, e) => (n, ...o) => {
  for (let s = 0; s < e.length; s++) {
    const h = Xk[e[s]];
    if (h && h(n, e))
      return;
  }
  return t(n, ...o);
}, Kk = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Gs = (t, e) => (n) => {
  if (!("key" in n))
    return;
  const o = ta(n.key);
  if (e.some((s) => s === o || Kk[s] === o))
    return t(n);
}, Yk = /* @__PURE__ */ Wn({ patchProp: Uk }, Mk);
let _w;
function KS() {
  return _w || (_w = rk(Yk));
}
const xw = (...t) => {
  KS().render(...t);
}, Jk = (...t) => {
  const e = KS().createApp(...t);
  process.env.NODE_ENV !== "production" && (Qk(e), eL(e));
  const { mount: n } = e;
  return e.mount = (o) => {
    const s = tL(o);
    if (!s)
      return;
    const h = e._component;
    !yr(h) && !h.render && !h.template && (h.template = s.innerHTML), s.innerHTML = "";
    const a = n(s, !1, s instanceof SVGElement);
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), a;
  }, e;
};
function Qk(t) {
  Object.defineProperty(t.config, "isNativeTag", {
    value: (e) => ZC(e) || XC(e),
    writable: !1
  });
}
function eL(t) {
  {
    const e = t.config.isCustomElement;
    Object.defineProperty(t.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        lt("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.");
      }
    });
    const n = t.config.compilerOptions, o = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom';
    Object.defineProperty(t.config, "compilerOptions", {
      get() {
        return lt(o), n;
      },
      set() {
        lt(o);
      }
    });
  }
}
function tL(t) {
  if (Hn(t)) {
    const e = document.querySelector(t);
    return process.env.NODE_ENV !== "production" && !e && lt(`Failed to mount app: mount target selector "${t}" returned null.`), e;
  }
  return process.env.NODE_ENV !== "production" && window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && lt('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'), t;
}
function rL() {
  Sk();
}
process.env.NODE_ENV !== "production" && rL();
/*! @license DOMPurify 2.4.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.5/LICENSE */
function Mu(t) {
  return Mu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Mu(t);
}
function U0(t, e) {
  return U0 = Object.setPrototypeOf || function(o, s) {
    return o.__proto__ = s, o;
  }, U0(t, e);
}
function nL() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function tg(t, e, n) {
  return nL() ? tg = Reflect.construct : tg = function(s, h, a) {
    var m = [null];
    m.push.apply(m, h);
    var g = Function.bind.apply(s, m), b = new g();
    return a && U0(b, a.prototype), b;
  }, tg.apply(null, arguments);
}
function Qa(t) {
  return iL(t) || oL(t) || aL(t) || sL();
}
function iL(t) {
  if (Array.isArray(t))
    return j0(t);
}
function oL(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function aL(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return j0(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set")
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return j0(t, e);
  }
}
function j0(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++)
    o[n] = t[n];
  return o;
}
function sL() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var lL = Object.hasOwnProperty, bw = Object.setPrototypeOf, uL = Object.isFrozen, cL = Object.getPrototypeOf, hL = Object.getOwnPropertyDescriptor, Vo = Object.freeze, fs = Object.seal, fL = Object.create, YS = typeof Reflect < "u" && Reflect, Ag = YS.apply, G0 = YS.construct;
Ag || (Ag = function(e, n, o) {
  return e.apply(n, o);
});
Vo || (Vo = function(e) {
  return e;
});
fs || (fs = function(e) {
  return e;
});
G0 || (G0 = function(e, n) {
  return tg(e, Qa(n));
});
var pL = za(Array.prototype.forEach), ww = za(Array.prototype.pop), $p = za(Array.prototype.push), rg = za(String.prototype.toLowerCase), z_ = za(String.prototype.toString), dL = za(String.prototype.match), Za = za(String.prototype.replace), mL = za(String.prototype.indexOf), yL = za(String.prototype.trim), Ao = za(RegExp.prototype.test), F_ = gL(TypeError);
function za(t) {
  return function(e) {
    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      o[s - 1] = arguments[s];
    return Ag(t, e, o);
  };
}
function gL(t) {
  return function() {
    for (var e = arguments.length, n = new Array(e), o = 0; o < e; o++)
      n[o] = arguments[o];
    return G0(t, n);
  };
}
function Ar(t, e, n) {
  n = n || rg, bw && bw(t, null);
  for (var o = e.length; o--; ) {
    var s = e[o];
    if (typeof s == "string") {
      var h = n(s);
      h !== s && (uL(e) || (e[o] = h), s = h);
    }
    t[s] = !0;
  }
  return t;
}
function Oc(t) {
  var e = fL(null), n;
  for (n in t)
    Ag(lL, t, [n]) === !0 && (e[n] = t[n]);
  return e;
}
function Sy(t, e) {
  for (; t !== null; ) {
    var n = hL(t, e);
    if (n) {
      if (n.get)
        return za(n.get);
      if (typeof n.value == "function")
        return za(n.value);
    }
    t = cL(t);
  }
  function o(s) {
    return console.warn("fallback value for", s), null;
  }
  return o;
}
var Ew = Vo(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), B_ = Vo(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), V_ = Vo(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), vL = Vo(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), U_ = Vo(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), _L = Vo(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Sw = Vo(["#text"]), Tw = Vo(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), j_ = Vo(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Mw = Vo(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Ty = Vo(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), xL = fs(/\{\{[\w\W]*|[\w\W]*\}\}/gm), bL = fs(/<%[\w\W]*|[\w\W]*%>/gm), wL = fs(/\${[\w\W]*}/gm), EL = fs(/^data-[\-\w.\u00B7-\uFFFF]/), SL = fs(/^aria-[\-\w]+$/), TL = fs(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
), ML = fs(/^(?:\w+script|data):/i), IL = fs(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
), OL = fs(/^html$/i), CL = function() {
  return typeof window > "u" ? null : window;
}, AL = function(e, n) {
  if (Mu(e) !== "object" || typeof e.createPolicy != "function")
    return null;
  var o = null, s = "data-tt-policy-suffix";
  n.currentScript && n.currentScript.hasAttribute(s) && (o = n.currentScript.getAttribute(s));
  var h = "dompurify" + (o ? "#" + o : "");
  try {
    return e.createPolicy(h, {
      createHTML: function(m) {
        return m;
      },
      createScriptURL: function(m) {
        return m;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + h + " could not be created."), null;
  }
};
function JS() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : CL(), e = function(fe) {
    return JS(fe);
  };
  if (e.version = "2.4.5", e.removed = [], !t || !t.document || t.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var n = t.document, o = t.document, s = t.DocumentFragment, h = t.HTMLTemplateElement, a = t.Node, m = t.Element, g = t.NodeFilter, b = t.NamedNodeMap, T = b === void 0 ? t.NamedNodeMap || t.MozNamedAttrMap : b, M = t.HTMLFormElement, I = t.DOMParser, P = t.trustedTypes, z = m.prototype, V = Sy(z, "cloneNode"), q = Sy(z, "nextSibling"), re = Sy(z, "childNodes"), X = Sy(z, "parentNode");
  if (typeof h == "function") {
    var ae = o.createElement("template");
    ae.content && ae.content.ownerDocument && (o = ae.content.ownerDocument);
  }
  var ce = AL(P, n), ve = ce ? ce.createHTML("") : "", Re = o, Fe = Re.implementation, Pe = Re.createNodeIterator, Se = Re.createDocumentFragment, Ie = Re.getElementsByTagName, Xe = n.importNode, $e = {};
  try {
    $e = Oc(o).documentMode ? o.documentMode : {};
  } catch {
  }
  var at = {};
  e.isSupported = typeof X == "function" && Fe && typeof Fe.createHTMLDocument < "u" && $e !== 9;
  var be = xL, Ye = bL, ht = wL, vt = EL, Pt = SL, tr = ML, kn = IL, Rr = TL, pr = null, Zn = Ar({}, [].concat(Qa(Ew), Qa(B_), Qa(V_), Qa(U_), Qa(Sw))), zr = null, Fi = Ar({}, [].concat(Qa(Tw), Qa(j_), Qa(Mw), Qa(Ty))), $r = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), kr = null, Vn = null, Tr = !0, Sn = !0, oi = !1, Un = !0, K = !1, ye = !1, Ne = !1, qe = !1, We = !1, rt = !1, mt = !1, et = !0, ut = !1, Qe = "user-content-", It = !0, bt = !1, kt = {}, Ut = null, dr = Ar({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Vr = null, Lr = Ar({}, ["audio", "video", "img", "source", "image", "track"]), Jr = null, Xn = Ar({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Bi = "http://www.w3.org/1998/Math/MathML", so = "http://www.w3.org/2000/svg", Kn = "http://www.w3.org/1999/xhtml", Li = Kn, Tn = !1, ai = null, Fa = Ar({}, [Bi, so, Kn], z_), Uo, Ba = ["application/xhtml+xml", "text/html"], na = "text/html", an, So = null, ol = o.createElement("form"), bn = function(fe) {
    return fe instanceof RegExp || fe instanceof Function;
  }, N = function(fe) {
    So && So === fe || ((!fe || Mu(fe) !== "object") && (fe = {}), fe = Oc(fe), Uo = Ba.indexOf(fe.PARSER_MEDIA_TYPE) === -1 ? Uo = na : Uo = fe.PARSER_MEDIA_TYPE, an = Uo === "application/xhtml+xml" ? z_ : rg, pr = "ALLOWED_TAGS" in fe ? Ar({}, fe.ALLOWED_TAGS, an) : Zn, zr = "ALLOWED_ATTR" in fe ? Ar({}, fe.ALLOWED_ATTR, an) : Fi, ai = "ALLOWED_NAMESPACES" in fe ? Ar({}, fe.ALLOWED_NAMESPACES, z_) : Fa, Jr = "ADD_URI_SAFE_ATTR" in fe ? Ar(
      Oc(Xn),
      fe.ADD_URI_SAFE_ATTR,
      an
    ) : Xn, Vr = "ADD_DATA_URI_TAGS" in fe ? Ar(
      Oc(Lr),
      fe.ADD_DATA_URI_TAGS,
      an
    ) : Lr, Ut = "FORBID_CONTENTS" in fe ? Ar({}, fe.FORBID_CONTENTS, an) : dr, kr = "FORBID_TAGS" in fe ? Ar({}, fe.FORBID_TAGS, an) : {}, Vn = "FORBID_ATTR" in fe ? Ar({}, fe.FORBID_ATTR, an) : {}, kt = "USE_PROFILES" in fe ? fe.USE_PROFILES : !1, Tr = fe.ALLOW_ARIA_ATTR !== !1, Sn = fe.ALLOW_DATA_ATTR !== !1, oi = fe.ALLOW_UNKNOWN_PROTOCOLS || !1, Un = fe.ALLOW_SELF_CLOSE_IN_ATTR !== !1, K = fe.SAFE_FOR_TEMPLATES || !1, ye = fe.WHOLE_DOCUMENT || !1, We = fe.RETURN_DOM || !1, rt = fe.RETURN_DOM_FRAGMENT || !1, mt = fe.RETURN_TRUSTED_TYPE || !1, qe = fe.FORCE_BODY || !1, et = fe.SANITIZE_DOM !== !1, ut = fe.SANITIZE_NAMED_PROPS || !1, It = fe.KEEP_CONTENT !== !1, bt = fe.IN_PLACE || !1, Rr = fe.ALLOWED_URI_REGEXP || Rr, Li = fe.NAMESPACE || Kn, $r = fe.CUSTOM_ELEMENT_HANDLING || {}, fe.CUSTOM_ELEMENT_HANDLING && bn(fe.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && ($r.tagNameCheck = fe.CUSTOM_ELEMENT_HANDLING.tagNameCheck), fe.CUSTOM_ELEMENT_HANDLING && bn(fe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && ($r.attributeNameCheck = fe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), fe.CUSTOM_ELEMENT_HANDLING && typeof fe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && ($r.allowCustomizedBuiltInElements = fe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), K && (Sn = !1), rt && (We = !0), kt && (pr = Ar({}, Qa(Sw)), zr = [], kt.html === !0 && (Ar(pr, Ew), Ar(zr, Tw)), kt.svg === !0 && (Ar(pr, B_), Ar(zr, j_), Ar(zr, Ty)), kt.svgFilters === !0 && (Ar(pr, V_), Ar(zr, j_), Ar(zr, Ty)), kt.mathMl === !0 && (Ar(pr, U_), Ar(zr, Mw), Ar(zr, Ty))), fe.ADD_TAGS && (pr === Zn && (pr = Oc(pr)), Ar(pr, fe.ADD_TAGS, an)), fe.ADD_ATTR && (zr === Fi && (zr = Oc(zr)), Ar(zr, fe.ADD_ATTR, an)), fe.ADD_URI_SAFE_ATTR && Ar(Jr, fe.ADD_URI_SAFE_ATTR, an), fe.FORBID_CONTENTS && (Ut === dr && (Ut = Oc(Ut)), Ar(Ut, fe.FORBID_CONTENTS, an)), It && (pr["#text"] = !0), ye && Ar(pr, ["html", "head", "body"]), pr.table && (Ar(pr, ["tbody"]), delete kr.tbody), Vo && Vo(fe), So = fe);
  }, F = Ar({}, ["mi", "mo", "mn", "ms", "mtext"]), U = Ar({}, ["foreignobject", "desc", "title", "annotation-xml"]), Z = Ar({}, ["title", "style", "font", "a", "script"]), Q = Ar({}, B_);
  Ar(Q, V_), Ar(Q, vL);
  var pe = Ar({}, U_);
  Ar(pe, _L);
  var de = function(fe) {
    var Ee = X(fe);
    (!Ee || !Ee.tagName) && (Ee = {
      namespaceURI: Li,
      tagName: "template"
    });
    var He = rg(fe.tagName), jt = rg(Ee.tagName);
    return ai[fe.namespaceURI] ? fe.namespaceURI === so ? Ee.namespaceURI === Kn ? He === "svg" : Ee.namespaceURI === Bi ? He === "svg" && (jt === "annotation-xml" || F[jt]) : Boolean(Q[He]) : fe.namespaceURI === Bi ? Ee.namespaceURI === Kn ? He === "math" : Ee.namespaceURI === so ? He === "math" && U[jt] : Boolean(pe[He]) : fe.namespaceURI === Kn ? Ee.namespaceURI === so && !U[jt] || Ee.namespaceURI === Bi && !F[jt] ? !1 : !pe[He] && (Z[He] || !Q[He]) : !!(Uo === "application/xhtml+xml" && ai[fe.namespaceURI]) : !1;
  }, G = function(fe) {
    $p(e.removed, {
      element: fe
    });
    try {
      fe.parentNode.removeChild(fe);
    } catch {
      try {
        fe.outerHTML = ve;
      } catch {
        fe.remove();
      }
    }
  }, ie = function(fe, Ee) {
    try {
      $p(e.removed, {
        attribute: Ee.getAttributeNode(fe),
        from: Ee
      });
    } catch {
      $p(e.removed, {
        attribute: null,
        from: Ee
      });
    }
    if (Ee.removeAttribute(fe), fe === "is" && !zr[fe])
      if (We || rt)
        try {
          G(Ee);
        } catch {
        }
      else
        try {
          Ee.setAttribute(fe, "");
        } catch {
        }
  }, _e = function(fe) {
    var Ee, He;
    if (qe)
      fe = "<remove></remove>" + fe;
    else {
      var jt = dL(fe, /^[\r\n\t ]+/);
      He = jt && jt[0];
    }
    Uo === "application/xhtml+xml" && Li === Kn && (fe = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + fe + "</body></html>");
    var Wt = ce ? ce.createHTML(fe) : fe;
    if (Li === Kn)
      try {
        Ee = new I().parseFromString(Wt, Uo);
      } catch {
      }
    if (!Ee || !Ee.documentElement) {
      Ee = Fe.createDocument(Li, "template", null);
      try {
        Ee.documentElement.innerHTML = Tn ? ve : Wt;
      } catch {
      }
    }
    var Jt = Ee.body || Ee.documentElement;
    return fe && He && Jt.insertBefore(o.createTextNode(He), Jt.childNodes[0] || null), Li === Kn ? Ie.call(Ee, ye ? "html" : "body")[0] : ye ? Ee.documentElement : Jt;
  }, Ge = function(fe) {
    return Pe.call(
      fe.ownerDocument || fe,
      fe,
      g.SHOW_ELEMENT | g.SHOW_COMMENT | g.SHOW_TEXT,
      null,
      !1
    );
  }, Ze = function(fe) {
    return fe instanceof M && (typeof fe.nodeName != "string" || typeof fe.textContent != "string" || typeof fe.removeChild != "function" || !(fe.attributes instanceof T) || typeof fe.removeAttribute != "function" || typeof fe.setAttribute != "function" || typeof fe.namespaceURI != "string" || typeof fe.insertBefore != "function" || typeof fe.hasChildNodes != "function");
  }, Ce = function(fe) {
    return Mu(a) === "object" ? fe instanceof a : fe && Mu(fe) === "object" && typeof fe.nodeType == "number" && typeof fe.nodeName == "string";
  }, Ue = function(fe, Ee, He) {
    !at[fe] || pL(at[fe], function(jt) {
      jt.call(e, Ee, He, So);
    });
  }, Et = function(fe) {
    var Ee;
    if (Ue("beforeSanitizeElements", fe, null), Ze(fe) || Ao(/[\u0080-\uFFFF]/, fe.nodeName))
      return G(fe), !0;
    var He = an(fe.nodeName);
    if (Ue("uponSanitizeElement", fe, {
      tagName: He,
      allowedTags: pr
    }), fe.hasChildNodes() && !Ce(fe.firstElementChild) && (!Ce(fe.content) || !Ce(fe.content.firstElementChild)) && Ao(/<[/\w]/g, fe.innerHTML) && Ao(/<[/\w]/g, fe.textContent) || He === "select" && Ao(/<template/i, fe.innerHTML))
      return G(fe), !0;
    if (!pr[He] || kr[He]) {
      if (!kr[He] && Le(He) && ($r.tagNameCheck instanceof RegExp && Ao($r.tagNameCheck, He) || $r.tagNameCheck instanceof Function && $r.tagNameCheck(He)))
        return !1;
      if (It && !Ut[He]) {
        var jt = X(fe) || fe.parentNode, Wt = re(fe) || fe.childNodes;
        if (Wt && jt)
          for (var Jt = Wt.length, Zt = Jt - 1; Zt >= 0; --Zt)
            jt.insertBefore(V(Wt[Zt], !0), q(fe));
      }
      return G(fe), !0;
    }
    return fe instanceof m && !de(fe) || (He === "noscript" || He === "noembed") && Ao(/<\/no(script|embed)/i, fe.innerHTML) ? (G(fe), !0) : (K && fe.nodeType === 3 && (Ee = fe.textContent, Ee = Za(Ee, be, " "), Ee = Za(Ee, Ye, " "), Ee = Za(Ee, ht, " "), fe.textContent !== Ee && ($p(e.removed, {
      element: fe.cloneNode()
    }), fe.textContent = Ee)), Ue("afterSanitizeElements", fe, null), !1);
  }, _t = function(fe, Ee, He) {
    if (et && (Ee === "id" || Ee === "name") && (He in o || He in ol))
      return !1;
    if (!(Sn && !Vn[Ee] && Ao(vt, Ee))) {
      if (!(Tr && Ao(Pt, Ee))) {
        if (!zr[Ee] || Vn[Ee]) {
          if (!(Le(fe) && ($r.tagNameCheck instanceof RegExp && Ao($r.tagNameCheck, fe) || $r.tagNameCheck instanceof Function && $r.tagNameCheck(fe)) && ($r.attributeNameCheck instanceof RegExp && Ao($r.attributeNameCheck, Ee) || $r.attributeNameCheck instanceof Function && $r.attributeNameCheck(Ee)) || Ee === "is" && $r.allowCustomizedBuiltInElements && ($r.tagNameCheck instanceof RegExp && Ao($r.tagNameCheck, He) || $r.tagNameCheck instanceof Function && $r.tagNameCheck(He))))
            return !1;
        } else if (!Jr[Ee]) {
          if (!Ao(Rr, Za(He, kn, ""))) {
            if (!((Ee === "src" || Ee === "xlink:href" || Ee === "href") && fe !== "script" && mL(He, "data:") === 0 && Vr[fe])) {
              if (!(oi && !Ao(tr, Za(He, kn, "")))) {
                if (He)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Le = function(fe) {
    return fe.indexOf("-") > 0;
  }, pt = function(fe) {
    var Ee, He, jt, Wt;
    Ue("beforeSanitizeAttributes", fe, null);
    var Jt = fe.attributes;
    if (!!Jt) {
      var Zt = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: zr
      };
      for (Wt = Jt.length; Wt--; ) {
        Ee = Jt[Wt];
        var Yn = Ee, Qt = Yn.name, pn = Yn.namespaceURI;
        if (He = Qt === "value" ? Ee.value : yL(Ee.value), jt = an(Qt), Zt.attrName = jt, Zt.attrValue = He, Zt.keepAttr = !0, Zt.forceKeepAttr = void 0, Ue("uponSanitizeAttribute", fe, Zt), He = Zt.attrValue, !Zt.forceKeepAttr && (ie(Qt, fe), !!Zt.keepAttr)) {
          if (!Un && Ao(/\/>/i, He)) {
            ie(Qt, fe);
            continue;
          }
          K && (He = Za(He, be, " "), He = Za(He, Ye, " "), He = Za(He, ht, " "));
          var Ur = an(fe.nodeName);
          if (!!_t(Ur, jt, He)) {
            if (ut && (jt === "id" || jt === "name") && (ie(Qt, fe), He = Qe + He), ce && Mu(P) === "object" && typeof P.getAttributeType == "function" && !pn)
              switch (P.getAttributeType(Ur, jt)) {
                case "TrustedHTML":
                  He = ce.createHTML(He);
                  break;
                case "TrustedScriptURL":
                  He = ce.createScriptURL(He);
                  break;
              }
            try {
              pn ? fe.setAttributeNS(pn, Qt, He) : fe.setAttribute(Qt, He), ww(e.removed);
            } catch {
            }
          }
        }
      }
      Ue("afterSanitizeAttributes", fe, null);
    }
  }, st = function De(fe) {
    var Ee, He = Ge(fe);
    for (Ue("beforeSanitizeShadowDOM", fe, null); Ee = He.nextNode(); )
      Ue("uponSanitizeShadowNode", Ee, null), !Et(Ee) && (Ee.content instanceof s && De(Ee.content), pt(Ee));
    Ue("afterSanitizeShadowDOM", fe, null);
  };
  return e.sanitize = function(De) {
    var fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Ee, He, jt, Wt, Jt;
    if (Tn = !De, Tn && (De = "<!-->"), typeof De != "string" && !Ce(De)) {
      if (typeof De.toString != "function")
        throw F_("toString is not a function");
      if (De = De.toString(), typeof De != "string")
        throw F_("dirty is not a string, aborting");
    }
    if (!e.isSupported) {
      if (Mu(t.toStaticHTML) === "object" || typeof t.toStaticHTML == "function") {
        if (typeof De == "string")
          return t.toStaticHTML(De);
        if (Ce(De))
          return t.toStaticHTML(De.outerHTML);
      }
      return De;
    }
    if (Ne || N(fe), e.removed = [], typeof De == "string" && (bt = !1), bt) {
      if (De.nodeName) {
        var Zt = an(De.nodeName);
        if (!pr[Zt] || kr[Zt])
          throw F_("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (De instanceof a)
      Ee = _e("<!---->"), He = Ee.ownerDocument.importNode(De, !0), He.nodeType === 1 && He.nodeName === "BODY" || He.nodeName === "HTML" ? Ee = He : Ee.appendChild(He);
    else {
      if (!We && !K && !ye && De.indexOf("<") === -1)
        return ce && mt ? ce.createHTML(De) : De;
      if (Ee = _e(De), !Ee)
        return We ? null : mt ? ve : "";
    }
    Ee && qe && G(Ee.firstChild);
    for (var Yn = Ge(bt ? De : Ee); jt = Yn.nextNode(); )
      jt.nodeType === 3 && jt === Wt || Et(jt) || (jt.content instanceof s && st(jt.content), pt(jt), Wt = jt);
    if (Wt = null, bt)
      return De;
    if (We) {
      if (rt)
        for (Jt = Se.call(Ee.ownerDocument); Ee.firstChild; )
          Jt.appendChild(Ee.firstChild);
      else
        Jt = Ee;
      return (zr.shadowroot || zr.shadowrootmod) && (Jt = Xe.call(n, Jt, !0)), Jt;
    }
    var Qt = ye ? Ee.outerHTML : Ee.innerHTML;
    return ye && pr["!doctype"] && Ee.ownerDocument && Ee.ownerDocument.doctype && Ee.ownerDocument.doctype.name && Ao(OL, Ee.ownerDocument.doctype.name) && (Qt = "<!DOCTYPE " + Ee.ownerDocument.doctype.name + `>
` + Qt), K && (Qt = Za(Qt, be, " "), Qt = Za(Qt, Ye, " "), Qt = Za(Qt, ht, " ")), ce && mt ? ce.createHTML(Qt) : Qt;
  }, e.setConfig = function(De) {
    N(De), Ne = !0;
  }, e.clearConfig = function() {
    So = null, Ne = !1;
  }, e.isValidAttribute = function(De, fe, Ee) {
    So || N({});
    var He = an(De), jt = an(fe);
    return _t(He, jt, Ee);
  }, e.addHook = function(De, fe) {
    typeof fe == "function" && (at[De] = at[De] || [], $p(at[De], fe));
  }, e.removeHook = function(De) {
    if (at[De])
      return ww(at[De]);
  }, e.removeHooks = function(De) {
    at[De] && (at[De] = []);
  }, e.removeAllHooks = function() {
    at = {};
  }, e;
}
var PL = JS(), QS = !1;
function My(t, e, n) {
  return Array.isArray(t) ? (t.length = Math.max(t.length, e), t.splice(e, 1, n), n) : (t[e] = n, n);
}
function G_(t, e) {
  if (Array.isArray(t)) {
    t.splice(e, 1);
    return;
  }
  delete t[e];
}
function kL(t, e) {
  var s;
  const n = (s = t.hooks) != null ? s : {};
  let o;
  for (o in n) {
    const h = n[o];
    h !== void 0 && e.addHook(o, h);
  }
}
function eT() {
  return PL();
}
function LL(t = {}, e = eT) {
  const n = e();
  kL(t, n);
  const o = function(s, h) {
    var M, I;
    const a = h.value;
    if (h.oldValue === a)
      return;
    const m = `${a}`, g = h.arg, b = t.namedConfigurations, T = (M = t.default) != null ? M : {};
    if (b && g !== void 0) {
      s.innerHTML = n.sanitize(
        m,
        (I = b[g]) != null ? I : T
      );
      return;
    }
    s.innerHTML = n.sanitize(
      m,
      T
    );
  };
  return {
    mounted: o,
    updated: o
  };
}
const DL = {
  install(t, e = {}, n = eT) {
    t.directive(
      "dompurify-html",
      LL(e, n)
    );
  }
};
function NL() {
  return tT().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function tT() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
}
const RL = typeof Proxy == "function", zL = "devtools-plugin:setup", FL = "plugin:settings:set";
let rf, $0;
function BL() {
  var t;
  return rf !== void 0 || (typeof window < "u" && window.performance ? (rf = !0, $0 = window.performance) : typeof global < "u" && ((t = global.perf_hooks) === null || t === void 0 ? void 0 : t.performance) ? (rf = !0, $0 = global.perf_hooks.performance) : rf = !1), rf;
}
function VL() {
  return BL() ? $0.now() : Date.now();
}
class UL {
  constructor(e, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e, this.hook = n;
    const o = {};
    if (e.settings)
      for (const a in e.settings) {
        const m = e.settings[a];
        o[a] = m.defaultValue;
      }
    const s = `__vue-devtools-plugin-settings__${e.id}`;
    let h = Object.assign({}, o);
    try {
      const a = localStorage.getItem(s), m = JSON.parse(a);
      Object.assign(h, m);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return h;
      },
      setSettings(a) {
        try {
          localStorage.setItem(s, JSON.stringify(a));
        } catch {
        }
        h = a;
      },
      now() {
        return VL();
      }
    }, n && n.on(FL, (a, m) => {
      a === this.plugin.id && this.fallbacks.setSettings(m);
    }), this.proxiedOn = new Proxy({}, {
      get: (a, m) => this.target ? this.target.on[m] : (...g) => {
        this.onQueue.push({
          method: m,
          args: g
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (a, m) => this.target ? this.target[m] : m === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(m) ? (...g) => (this.targetQueue.push({
        method: m,
        args: g,
        resolve: () => {
        }
      }), this.fallbacks[m](...g)) : (...g) => new Promise((b) => {
        this.targetQueue.push({
          method: m,
          args: g,
          resolve: b
        });
      })
    });
  }
  async setRealTarget(e) {
    this.target = e;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function rT(t, e) {
  const n = t, o = tT(), s = NL(), h = RL && n.enableEarlyProxy;
  if (s && (o.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !h))
    s.emit(zL, t, e);
  else {
    const a = h ? new UL(n, s) : null;
    (o.__VUE_DEVTOOLS_PLUGINS__ = o.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: e,
      proxy: a
    }), a && e(a.proxiedTarget);
  }
}
/*!
  * pinia v2.0.33
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
let Qp;
const Pd = (t) => Qp = t, nT = process.env.NODE_ENV !== "production" ? Symbol("pinia") : Symbol();
function Qc(t) {
  return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
}
var Hs;
(function(t) {
  t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
})(Hs || (Hs = {}));
const Sv = typeof window < "u", dd = (process.env.NODE_ENV !== "production" || !1) && process.env.NODE_ENV !== "test" && Sv, Iw = /* @__PURE__ */ (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : { HTMLElement: null })();
function jL(t, { autoBom: e = !1 } = {}) {
  return e && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], { type: t.type }) : t;
}
function B1(t, e, n) {
  const o = new XMLHttpRequest();
  o.open("GET", t), o.responseType = "blob", o.onload = function() {
    aT(o.response, e, n);
  }, o.onerror = function() {
    console.error("could not download file");
  }, o.send();
}
function iT(t) {
  const e = new XMLHttpRequest();
  e.open("HEAD", t, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function ng(t) {
  try {
    t.dispatchEvent(new MouseEvent("click"));
  } catch {
    const n = document.createEvent("MouseEvents");
    n.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), t.dispatchEvent(n);
  }
}
const ig = typeof navigator == "object" ? navigator : { userAgent: "" }, oT = /* @__PURE__ */ (() => /Macintosh/.test(ig.userAgent) && /AppleWebKit/.test(ig.userAgent) && !/Safari/.test(ig.userAgent))(), aT = Sv ? typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !oT ? GL : "msSaveOrOpenBlob" in ig ? $L : qL : () => {
};
function GL(t, e = "download", n) {
  const o = document.createElement("a");
  o.download = e, o.rel = "noopener", typeof t == "string" ? (o.href = t, o.origin !== location.origin ? iT(o.href) ? B1(t, e, n) : (o.target = "_blank", ng(o)) : ng(o)) : (o.href = URL.createObjectURL(t), setTimeout(function() {
    URL.revokeObjectURL(o.href);
  }, 4e4), setTimeout(function() {
    ng(o);
  }, 0));
}
function $L(t, e = "download", n) {
  if (typeof t == "string")
    if (iT(t))
      B1(t, e, n);
    else {
      const o = document.createElement("a");
      o.href = t, o.target = "_blank", setTimeout(function() {
        ng(o);
      });
    }
  else
    navigator.msSaveOrOpenBlob(jL(t, n), e);
}
function qL(t, e, n, o) {
  if (o = o || open("", "_blank"), o && (o.document.title = o.document.body.innerText = "downloading..."), typeof t == "string")
    return B1(t, e, n);
  const s = t.type === "application/octet-stream", h = /constructor/i.test(String(Iw.HTMLElement)) || "safari" in Iw, a = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((a || s && h || oT) && typeof FileReader < "u") {
    const m = new FileReader();
    m.onloadend = function() {
      let g = m.result;
      if (typeof g != "string")
        throw o = null, new Error("Wrong reader.result type");
      g = a ? g : g.replace(/^data:[^;]*;/, "data:attachment/file;"), o ? o.location.href = g : location.assign(g), o = null;
    }, m.readAsDataURL(t);
  } else {
    const m = URL.createObjectURL(t);
    o ? o.location.assign(m) : location.href = m, o = null, setTimeout(function() {
      URL.revokeObjectURL(m);
    }, 4e4);
  }
}
function Zi(t, e) {
  const n = "\u{1F34D} " + t;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(n, e) : e === "error" ? console.error(n) : e === "warn" ? console.warn(n) : console.log(n);
}
function V1(t) {
  return "_a" in t && "install" in t;
}
function sT() {
  if (!("clipboard" in navigator))
    return Zi("Your browser doesn't support the Clipboard API", "error"), !0;
}
function lT(t) {
  return t instanceof Error && t.message.toLowerCase().includes("document is not focused") ? (Zi('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) : !1;
}
async function WL(t) {
  if (!sT())
    try {
      await navigator.clipboard.writeText(JSON.stringify(t.state.value)), Zi("Global state copied to clipboard.");
    } catch (e) {
      if (lT(e))
        return;
      Zi("Failed to serialize the state. Check the console for more details.", "error"), console.error(e);
    }
}
async function HL(t) {
  if (!sT())
    try {
      t.state.value = JSON.parse(await navigator.clipboard.readText()), Zi("Global state pasted from clipboard.");
    } catch (e) {
      if (lT(e))
        return;
      Zi("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(e);
    }
}
async function ZL(t) {
  try {
    aT(new Blob([JSON.stringify(t.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (e) {
    Zi("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
let Pl;
function XL() {
  Pl || (Pl = document.createElement("input"), Pl.type = "file", Pl.accept = ".json");
  function t() {
    return new Promise((e, n) => {
      Pl.onchange = async () => {
        const o = Pl.files;
        if (!o)
          return e(null);
        const s = o.item(0);
        return e(s ? { text: await s.text(), file: s } : null);
      }, Pl.oncancel = () => e(null), Pl.onerror = n, Pl.click();
    });
  }
  return t;
}
async function KL(t) {
  try {
    const n = await (await XL())();
    if (!n)
      return;
    const { text: o, file: s } = n;
    t.state.value = JSON.parse(o), Zi(`Global state imported from "${s.name}".`);
  } catch (e) {
    Zi("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
function es(t) {
  return {
    _custom: {
      display: t
    }
  };
}
const uT = "\u{1F34D} Pinia (root)", q0 = "_root";
function YL(t) {
  return V1(t) ? {
    id: q0,
    label: uT
  } : {
    id: t.$id,
    label: t.$id
  };
}
function JL(t) {
  if (V1(t)) {
    const n = Array.from(t._s.keys()), o = t._s;
    return {
      state: n.map((h) => ({
        editable: !0,
        key: h,
        value: t.state.value[h]
      })),
      getters: n.filter((h) => o.get(h)._getters).map((h) => {
        const a = o.get(h);
        return {
          editable: !1,
          key: h,
          value: a._getters.reduce((m, g) => (m[g] = a[g], m), {})
        };
      })
    };
  }
  const e = {
    state: Object.keys(t.$state).map((n) => ({
      editable: !0,
      key: n,
      value: t.$state[n]
    }))
  };
  return t._getters && t._getters.length && (e.getters = t._getters.map((n) => ({
    editable: !1,
    key: n,
    value: t[n]
  }))), t._customProperties.size && (e.customProperties = Array.from(t._customProperties).map((n) => ({
    editable: !0,
    key: n,
    value: t[n]
  }))), e;
}
function QL(t) {
  return t ? Array.isArray(t) ? t.reduce((e, n) => (e.keys.push(n.key), e.operations.push(n.type), e.oldValue[n.key] = n.oldValue, e.newValue[n.key] = n.newValue, e), {
    oldValue: {},
    keys: [],
    operations: [],
    newValue: {}
  }) : {
    operation: es(t.type),
    key: es(t.key),
    oldValue: t.oldValue,
    newValue: t.newValue
  } : {};
}
function eD(t) {
  switch (t) {
    case Hs.direct:
      return "mutation";
    case Hs.patchFunction:
      return "$patch";
    case Hs.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let yf = !0;
const og = [], Rc = "pinia:mutations", vo = "pinia", { assign: tD } = Object, Pg = (t) => "\u{1F34D} " + t;
function rD(t, e) {
  rT({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: og,
    app: t
  }, (n) => {
    typeof n.now != "function" && Zi("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), n.addTimelineLayer({
      id: Rc,
      label: "Pinia \u{1F34D}",
      color: 15064968
    }), n.addInspector({
      id: vo,
      label: "Pinia \u{1F34D}",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            WL(e);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: async () => {
            await HL(e), n.sendInspectorTree(vo), n.sendInspectorState(vo);
          },
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            ZL(e);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: async () => {
            await KL(e), n.sendInspectorTree(vo), n.sendInspectorState(vo);
          },
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: "Reset the state (option store only)",
          action: (o) => {
            const s = e._s.get(o);
            s ? s._isOptionsAPI ? (s.$reset(), Zi(`Store "${o}" reset.`)) : Zi(`Cannot reset "${o}" store because it's a setup store.`, "warn") : Zi(`Cannot reset "${o}" store because it wasn't found.`, "warn");
          }
        }
      ]
    }), n.on.inspectComponent((o, s) => {
      const h = o.componentInstance && o.componentInstance.proxy;
      if (h && h._pStores) {
        const a = o.componentInstance.proxy._pStores;
        Object.values(a).forEach((m) => {
          o.instanceData.state.push({
            type: Pg(m.$id),
            key: "state",
            editable: !0,
            value: m._isOptionsAPI ? {
              _custom: {
                value: hr(m.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => m.$reset()
                  }
                ]
              }
            } : Object.keys(m.$state).reduce((g, b) => (g[b] = m.$state[b], g), {})
          }), m._getters && m._getters.length && o.instanceData.state.push({
            type: Pg(m.$id),
            key: "getters",
            editable: !1,
            value: m._getters.reduce((g, b) => {
              try {
                g[b] = m[b];
              } catch (T) {
                g[b] = T;
              }
              return g;
            }, {})
          });
        });
      }
    }), n.on.getInspectorTree((o) => {
      if (o.app === t && o.inspectorId === vo) {
        let s = [e];
        s = s.concat(Array.from(e._s.values())), o.rootNodes = (o.filter ? s.filter((h) => "$id" in h ? h.$id.toLowerCase().includes(o.filter.toLowerCase()) : uT.toLowerCase().includes(o.filter.toLowerCase())) : s).map(YL);
      }
    }), n.on.getInspectorState((o) => {
      if (o.app === t && o.inspectorId === vo) {
        const s = o.nodeId === q0 ? e : e._s.get(o.nodeId);
        if (!s)
          return;
        s && (o.state = JL(s));
      }
    }), n.on.editInspectorState((o, s) => {
      if (o.app === t && o.inspectorId === vo) {
        const h = o.nodeId === q0 ? e : e._s.get(o.nodeId);
        if (!h)
          return Zi(`store "${o.nodeId}" not found`, "error");
        const { path: a } = o;
        V1(h) ? a.unshift("state") : (a.length !== 1 || !h._customProperties.has(a[0]) || a[0] in h.$state) && a.unshift("$state"), yf = !1, o.set(h, a, o.state.value), yf = !0;
      }
    }), n.on.editComponentState((o) => {
      if (o.type.startsWith("\u{1F34D}")) {
        const s = o.type.replace(/^\s*/, ""), h = e._s.get(s);
        if (!h)
          return Zi(`store "${s}" not found`, "error");
        const { path: a } = o;
        if (a[0] !== "state")
          return Zi(`Invalid path for store "${s}":
${a}
Only state can be modified.`);
        a[0] = "$state", yf = !1, o.set(h, a, o.state.value), yf = !0;
      }
    });
  });
}
function nD(t, e) {
  og.includes(Pg(e.$id)) || og.push(Pg(e.$id)), rT({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: og,
    app: t,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: !0
      }
    }
  }, (n) => {
    const o = typeof n.now == "function" ? n.now.bind(n) : Date.now;
    e.$onAction(({ after: a, onError: m, name: g, args: b }) => {
      const T = cT++;
      n.addTimelineEvent({
        layerId: Rc,
        event: {
          time: o(),
          title: "\u{1F6EB} " + g,
          subtitle: "start",
          data: {
            store: es(e.$id),
            action: es(g),
            args: b
          },
          groupId: T
        }
      }), a((M) => {
        Uc = void 0, n.addTimelineEvent({
          layerId: Rc,
          event: {
            time: o(),
            title: "\u{1F6EC} " + g,
            subtitle: "end",
            data: {
              store: es(e.$id),
              action: es(g),
              args: b,
              result: M
            },
            groupId: T
          }
        });
      }), m((M) => {
        Uc = void 0, n.addTimelineEvent({
          layerId: Rc,
          event: {
            time: o(),
            logType: "error",
            title: "\u{1F4A5} " + g,
            subtitle: "end",
            data: {
              store: es(e.$id),
              action: es(g),
              args: b,
              error: M
            },
            groupId: T
          }
        });
      });
    }, !0), e._customProperties.forEach((a) => {
      Pn(() => se(e[a]), (m, g) => {
        n.notifyComponentUpdate(), n.sendInspectorState(vo), yf && n.addTimelineEvent({
          layerId: Rc,
          event: {
            time: o(),
            title: "Change",
            subtitle: a,
            data: {
              newValue: m,
              oldValue: g
            },
            groupId: Uc
          }
        });
      }, { deep: !0 });
    }), e.$subscribe(({ events: a, type: m }, g) => {
      if (n.notifyComponentUpdate(), n.sendInspectorState(vo), !yf)
        return;
      const b = {
        time: o(),
        title: eD(m),
        data: tD({ store: es(e.$id) }, QL(a)),
        groupId: Uc
      };
      Uc = void 0, m === Hs.patchFunction ? b.subtitle = "\u2935\uFE0F" : m === Hs.patchObject ? b.subtitle = "\u{1F9E9}" : a && !Array.isArray(a) && (b.subtitle = a.type), a && (b.data["rawEvent(s)"] = {
        _custom: {
          display: "DebuggerEvent",
          type: "object",
          tooltip: "raw DebuggerEvent[]",
          value: a
        }
      }), n.addTimelineEvent({
        layerId: Rc,
        event: b
      });
    }, { detached: !0, flush: "sync" });
    const s = e._hotUpdate;
    e._hotUpdate = rs((a) => {
      s(a), n.addTimelineEvent({
        layerId: Rc,
        event: {
          time: o(),
          title: "\u{1F525} " + e.$id,
          subtitle: "HMR update",
          data: {
            store: es(e.$id),
            info: es("HMR update")
          }
        }
      }), n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo);
    });
    const { $dispose: h } = e;
    e.$dispose = () => {
      h(), n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo), n.getSettings().logStoreChanges && Zi(`Disposed "${e.$id}" store \u{1F5D1}`);
    }, n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo), n.getSettings().logStoreChanges && Zi(`"${e.$id}" store installed \u{1F195}`);
  });
}
let cT = 0, Uc;
function Ow(t, e) {
  const n = e.reduce((o, s) => (o[s] = hr(t)[s], o), {});
  for (const o in n)
    t[o] = function() {
      const s = cT, h = new Proxy(t, {
        get(...a) {
          return Uc = s, Reflect.get(...a);
        },
        set(...a) {
          return Uc = s, Reflect.set(...a);
        }
      });
      return n[o].apply(h, arguments);
    };
}
function iD({ app: t, store: e, options: n }) {
  if (!e.$id.startsWith("__hot:")) {
    if (n.state && (e._isOptionsAPI = !0), typeof n.state == "function") {
      Ow(
        e,
        Object.keys(n.actions)
      );
      const o = e._hotUpdate;
      hr(e)._hotUpdate = function(s) {
        o.apply(this, arguments), Ow(e, Object.keys(s._hmrPayload.actions));
      };
    }
    nD(
      t,
      e
    );
  }
}
function oD() {
  const t = UE(!0), e = t.run(() => _r({}));
  let n = [], o = [];
  const s = rs({
    install(h) {
      Pd(s), s._a = h, h.provide(nT, s), h.config.globalProperties.$pinia = s, dd && rD(h, s), o.forEach((a) => n.push(a)), o = [];
    },
    use(h) {
      return !this._a && !QS ? o.push(h) : n.push(h), this;
    },
    _p: n,
    _a: null,
    _e: t,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return dd && typeof Proxy < "u" && s.use(iD), s;
}
function hT(t, e) {
  for (const n in e) {
    const o = e[n];
    if (!(n in t))
      continue;
    const s = t[n];
    Qc(s) && Qc(o) && !hn(o) && !ls(o) ? t[n] = hT(s, o) : t[n] = o;
  }
  return t;
}
const fT = () => {
};
function Cw(t, e, n, o = fT) {
  t.push(e);
  const s = () => {
    const h = t.indexOf(e);
    h > -1 && (t.splice(h, 1), o());
  };
  return !n && jE() && oA(s), s;
}
function nf(t, ...e) {
  t.slice().forEach((n) => {
    n(...e);
  });
}
function W0(t, e) {
  t instanceof Map && e instanceof Map && e.forEach((n, o) => t.set(o, n)), t instanceof Set && e instanceof Set && e.forEach(t.add, t);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const o = e[n], s = t[n];
    Qc(s) && Qc(o) && t.hasOwnProperty(n) && !hn(o) && !ls(o) ? t[n] = W0(s, o) : t[n] = o;
  }
  return t;
}
const aD = process.env.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : Symbol();
function sD(t) {
  return !Qc(t) || !t.hasOwnProperty(aD);
}
const { assign: Ca } = Object;
function Aw(t) {
  return !!(hn(t) && t.effect);
}
function Pw(t, e, n, o) {
  const { state: s, actions: h, getters: a } = e, m = n.state.value[t];
  let g;
  function b() {
    !m && (process.env.NODE_ENV === "production" || !o) && (n.state.value[t] = s ? s() : {});
    const T = process.env.NODE_ENV !== "production" && o ? Gb(_r(s ? s() : {}).value) : Gb(n.state.value[t]);
    return Ca(T, h, Object.keys(a || {}).reduce((M, I) => (process.env.NODE_ENV !== "production" && I in T && console.warn(`[\u{1F34D}]: A getter cannot have the same name as another state property. Rename one of them. Found with "${I}" in store "${t}".`), M[I] = rs(or(() => {
      Pd(n);
      const P = n._s.get(t);
      return a[I].call(P, P);
    })), M), {}));
  }
  return g = H0(t, b, e, n, o, !0), g;
}
function H0(t, e, n = {}, o, s, h) {
  let a;
  const m = Ca({ actions: {} }, n);
  if (process.env.NODE_ENV !== "production" && !o._e.active)
    throw new Error("Pinia destroyed");
  const g = {
    deep: !0
  };
  process.env.NODE_ENV !== "production" && !QS && (g.onTrigger = (Se) => {
    b ? P = Se : b == !1 && !Fe._hotUpdating && (Array.isArray(P) ? P.push(Se) : console.error("\u{1F34D} debuggerEvents should be an array. This is most likely an internal Pinia bug."));
  });
  let b, T, M = rs([]), I = rs([]), P;
  const z = o.state.value[t];
  !h && !z && (process.env.NODE_ENV === "production" || !s) && (o.state.value[t] = {});
  const V = _r({});
  let q;
  function re(Se) {
    let Ie;
    b = T = !1, process.env.NODE_ENV !== "production" && (P = []), typeof Se == "function" ? (Se(o.state.value[t]), Ie = {
      type: Hs.patchFunction,
      storeId: t,
      events: P
    }) : (W0(o.state.value[t], Se), Ie = {
      type: Hs.patchObject,
      payload: Se,
      storeId: t,
      events: P
    });
    const Xe = q = Symbol();
    Eg().then(() => {
      q === Xe && (b = !0);
    }), T = !0, nf(M, Ie, o.state.value[t]);
  }
  const X = h ? function() {
    const { state: Ie } = n, Xe = Ie ? Ie() : {};
    this.$patch(($e) => {
      Ca($e, Xe);
    });
  } : process.env.NODE_ENV !== "production" ? () => {
    throw new Error(`\u{1F34D}: Store "${t}" is built using the setup syntax and does not implement $reset().`);
  } : fT;
  function ae() {
    a.stop(), M = [], I = [], o._s.delete(t);
  }
  function ce(Se, Ie) {
    return function() {
      Pd(o);
      const Xe = Array.from(arguments), $e = [], at = [];
      function be(vt) {
        $e.push(vt);
      }
      function Ye(vt) {
        at.push(vt);
      }
      nf(I, {
        args: Xe,
        name: Se,
        store: Fe,
        after: be,
        onError: Ye
      });
      let ht;
      try {
        ht = Ie.apply(this && this.$id === t ? this : Fe, Xe);
      } catch (vt) {
        throw nf(at, vt), vt;
      }
      return ht instanceof Promise ? ht.then((vt) => (nf($e, vt), vt)).catch((vt) => (nf(at, vt), Promise.reject(vt))) : (nf($e, ht), ht);
    };
  }
  const ve = /* @__PURE__ */ rs({
    actions: {},
    getters: {},
    state: [],
    hotState: V
  }), Re = {
    _p: o,
    $id: t,
    $onAction: Cw.bind(null, I),
    $patch: re,
    $reset: X,
    $subscribe(Se, Ie = {}) {
      const Xe = Cw(M, Se, Ie.detached, () => $e()), $e = a.run(() => Pn(() => o.state.value[t], (at) => {
        (Ie.flush === "sync" ? T : b) && Se({
          storeId: t,
          type: Hs.direct,
          events: P
        }, at);
      }, Ca({}, g, Ie)));
      return Xe;
    },
    $dispose: ae
  }, Fe = pv(process.env.NODE_ENV !== "production" || dd ? Ca(
    {
      _hmrPayload: ve,
      _customProperties: rs(/* @__PURE__ */ new Set())
    },
    Re
  ) : Re);
  o._s.set(t, Fe);
  const Pe = o._e.run(() => (a = UE(), a.run(() => e())));
  for (const Se in Pe) {
    const Ie = Pe[Se];
    if (hn(Ie) && !Aw(Ie) || ls(Ie))
      process.env.NODE_ENV !== "production" && s ? My(V.value, Se, ud(Pe, Se)) : h || (z && sD(Ie) && (hn(Ie) ? Ie.value = z[Se] : W0(Ie, z[Se])), o.state.value[t][Se] = Ie), process.env.NODE_ENV !== "production" && ve.state.push(Se);
    else if (typeof Ie == "function") {
      const Xe = process.env.NODE_ENV !== "production" && s ? Ie : ce(Se, Ie);
      Pe[Se] = Xe, process.env.NODE_ENV !== "production" && (ve.actions[Se] = Ie), m.actions[Se] = Ie;
    } else
      process.env.NODE_ENV !== "production" && Aw(Ie) && (ve.getters[Se] = h ? n.getters[Se] : Ie, Sv && (Pe._getters || (Pe._getters = rs([]))).push(Se));
  }
  if (Ca(Fe, Pe), Ca(hr(Fe), Pe), Object.defineProperty(Fe, "$state", {
    get: () => process.env.NODE_ENV !== "production" && s ? V.value : o.state.value[t],
    set: (Se) => {
      if (process.env.NODE_ENV !== "production" && s)
        throw new Error("cannot set hotState");
      re((Ie) => {
        Ca(Ie, Se);
      });
    }
  }), process.env.NODE_ENV !== "production" && (Fe._hotUpdate = rs((Se) => {
    Fe._hotUpdating = !0, Se._hmrPayload.state.forEach((Ie) => {
      if (Ie in Fe.$state) {
        const Xe = Se.$state[Ie], $e = Fe.$state[Ie];
        typeof Xe == "object" && Qc(Xe) && Qc($e) ? hT(Xe, $e) : Se.$state[Ie] = $e;
      }
      My(Fe, Ie, ud(Se.$state, Ie));
    }), Object.keys(Fe.$state).forEach((Ie) => {
      Ie in Se.$state || G_(Fe, Ie);
    }), b = !1, T = !1, o.state.value[t] = ud(Se._hmrPayload, "hotState"), T = !0, Eg().then(() => {
      b = !0;
    });
    for (const Ie in Se._hmrPayload.actions) {
      const Xe = Se[Ie];
      My(Fe, Ie, ce(Ie, Xe));
    }
    for (const Ie in Se._hmrPayload.getters) {
      const Xe = Se._hmrPayload.getters[Ie], $e = h ? or(() => (Pd(o), Xe.call(Fe, Fe))) : Xe;
      My(Fe, Ie, $e);
    }
    Object.keys(Fe._hmrPayload.getters).forEach((Ie) => {
      Ie in Se._hmrPayload.getters || G_(Fe, Ie);
    }), Object.keys(Fe._hmrPayload.actions).forEach((Ie) => {
      Ie in Se._hmrPayload.actions || G_(Fe, Ie);
    }), Fe._hmrPayload = Se._hmrPayload, Fe._getters = Se._getters, Fe._hotUpdating = !1;
  })), dd) {
    const Se = {
      writable: !0,
      configurable: !0,
      enumerable: !1
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((Ie) => {
      Object.defineProperty(Fe, Ie, Ca({ value: Fe[Ie] }, Se));
    });
  }
  return o._p.forEach((Se) => {
    if (dd) {
      const Ie = a.run(() => Se({
        store: Fe,
        app: o._a,
        pinia: o,
        options: m
      }));
      Object.keys(Ie || {}).forEach((Xe) => Fe._customProperties.add(Xe)), Ca(Fe, Ie);
    } else
      Ca(Fe, a.run(() => Se({
        store: Fe,
        app: o._a,
        pinia: o,
        options: m
      })));
  }), process.env.NODE_ENV !== "production" && Fe.$state && typeof Fe.$state == "object" && typeof Fe.$state.constructor == "function" && !Fe.$state.constructor.toString().includes("[native code]") && console.warn(`[\u{1F34D}]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${Fe.$id}".`), z && h && n.hydrate && n.hydrate(Fe.$state, z), b = !0, T = !0, Fe;
}
function ih(t, e, n) {
  let o, s;
  const h = typeof e == "function";
  typeof t == "string" ? (o = t, s = h ? n : e) : (s = t, o = t.id);
  function a(m, g) {
    const b = xv();
    if (m = (process.env.NODE_ENV === "test" && Qp && Qp._testing ? null : m) || b && Sf(nT, null), m && Pd(m), process.env.NODE_ENV !== "production" && !Qp)
      throw new Error(`[\u{1F34D}]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);
    m = Qp, m._s.has(o) || (h ? H0(o, e, s, m) : Pw(o, s, m), process.env.NODE_ENV !== "production" && (a._pinia = m));
    const T = m._s.get(o);
    if (process.env.NODE_ENV !== "production" && g) {
      const M = "__hot:" + o, I = h ? H0(M, e, s, m, !0) : Pw(M, Ca({}, s), m, !0);
      g._hotUpdate(I), delete m.state.value[M], m._s.delete(M);
    }
    if (process.env.NODE_ENV !== "production" && Sv && b && b.proxy && !g) {
      const M = b.proxy, I = "_pStores" in M ? M._pStores : M._pStores = {};
      I[o] = T;
    }
    return T;
  }
  return a.$id = o, a;
}
function xn(t) {
  {
    t = hr(t);
    const e = {};
    for (const n in t) {
      const o = t[n];
      (hn(o) || ls(o)) && (e[n] = ud(t, n));
    }
    return e;
  }
}
function lD(t) {
  t("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), t.WGS84 = t["EPSG:4326"], t["EPSG:3785"] = t["EPSG:3857"], t.GOOGLE = t["EPSG:3857"], t["EPSG:900913"] = t["EPSG:3857"], t["EPSG:102113"] = t["EPSG:3857"];
}
var eh = 1, th = 2, Mf = 3, uD = 4, Z0 = 5, kw = 6378137, cD = 6356752314e-3, Lw = 0.0066943799901413165, md = 484813681109536e-20, ft = Math.PI / 2, hD = 0.16666666666666666, fD = 0.04722222222222222, pD = 0.022156084656084655, Ct = 1e-10, io = 0.017453292519943295, qs = 57.29577951308232, ln = Math.PI / 4, kd = Math.PI * 2, wi = 3.14159265359, ra = {};
ra.greenwich = 0;
ra.lisbon = -9.131906111111;
ra.paris = 2.337229166667;
ra.bogota = -74.080916666667;
ra.madrid = -3.687938888889;
ra.rome = 12.452333333333;
ra.bern = 7.439583333333;
ra.jakarta = 106.807719444444;
ra.ferro = -17.666666666667;
ra.brussels = 4.367975;
ra.stockholm = 18.058277777778;
ra.athens = 23.7163375;
ra.oslo = 10.722916666667;
const dD = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var Dw = /[\s_\-\/\(\)]/g;
function zu(t, e) {
  if (t[e])
    return t[e];
  for (var n = Object.keys(t), o = e.toLowerCase().replace(Dw, ""), s = -1, h, a; ++s < n.length; )
    if (h = n[s], a = h.toLowerCase().replace(Dw, ""), a === o)
      return t[h];
}
function X0(t) {
  var e = {}, n = t.split("+").map(function(m) {
    return m.trim();
  }).filter(function(m) {
    return m;
  }).reduce(function(m, g) {
    var b = g.split("=");
    return b.push(!0), m[b[0].toLowerCase()] = b[1], m;
  }, {}), o, s, h, a = {
    proj: "projName",
    datum: "datumCode",
    rf: function(m) {
      e.rf = parseFloat(m);
    },
    lat_0: function(m) {
      e.lat0 = m * io;
    },
    lat_1: function(m) {
      e.lat1 = m * io;
    },
    lat_2: function(m) {
      e.lat2 = m * io;
    },
    lat_ts: function(m) {
      e.lat_ts = m * io;
    },
    lon_0: function(m) {
      e.long0 = m * io;
    },
    lon_1: function(m) {
      e.long1 = m * io;
    },
    lon_2: function(m) {
      e.long2 = m * io;
    },
    alpha: function(m) {
      e.alpha = parseFloat(m) * io;
    },
    gamma: function(m) {
      e.rectified_grid_angle = parseFloat(m);
    },
    lonc: function(m) {
      e.longc = m * io;
    },
    x_0: function(m) {
      e.x0 = parseFloat(m);
    },
    y_0: function(m) {
      e.y0 = parseFloat(m);
    },
    k_0: function(m) {
      e.k0 = parseFloat(m);
    },
    k: function(m) {
      e.k0 = parseFloat(m);
    },
    a: function(m) {
      e.a = parseFloat(m);
    },
    b: function(m) {
      e.b = parseFloat(m);
    },
    r_a: function() {
      e.R_A = !0;
    },
    zone: function(m) {
      e.zone = parseInt(m, 10);
    },
    south: function() {
      e.utmSouth = !0;
    },
    towgs84: function(m) {
      e.datum_params = m.split(",").map(function(g) {
        return parseFloat(g);
      });
    },
    to_meter: function(m) {
      e.to_meter = parseFloat(m);
    },
    units: function(m) {
      e.units = m;
      var g = zu(dD, m);
      g && (e.to_meter = g.to_meter);
    },
    from_greenwich: function(m) {
      e.from_greenwich = m * io;
    },
    pm: function(m) {
      var g = zu(ra, m);
      e.from_greenwich = (g || parseFloat(m)) * io;
    },
    nadgrids: function(m) {
      m === "@null" ? e.datumCode = "none" : e.nadgrids = m;
    },
    axis: function(m) {
      var g = "ewnsud";
      m.length === 3 && g.indexOf(m.substr(0, 1)) !== -1 && g.indexOf(m.substr(1, 1)) !== -1 && g.indexOf(m.substr(2, 1)) !== -1 && (e.axis = m);
    },
    approx: function() {
      e.approx = !0;
    }
  };
  for (o in n)
    s = n[o], o in a ? (h = a[o], typeof h == "function" ? h(s) : e[h] = s) : e[o] = s;
  return typeof e.datumCode == "string" && e.datumCode !== "WGS84" && (e.datumCode = e.datumCode.toLowerCase()), e;
}
var Ld = 1, pT = 2, dT = 3, kg = 4, mT = 5, U1 = -1, mD = /\s/, yD = /[A-Za-z]/, gD = /[A-Za-z84_]/, Tv = /[,\]]/, yT = /[\d\.E\-\+]/;
function Zl(t) {
  if (typeof t != "string")
    throw new Error("not a string");
  this.text = t.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Ld;
}
Zl.prototype.readCharicter = function() {
  var t = this.text[this.place++];
  if (this.state !== kg)
    for (; mD.test(t); ) {
      if (this.place >= this.text.length)
        return;
      t = this.text[this.place++];
    }
  switch (this.state) {
    case Ld:
      return this.neutral(t);
    case pT:
      return this.keyword(t);
    case kg:
      return this.quoted(t);
    case mT:
      return this.afterquote(t);
    case dT:
      return this.number(t);
    case U1:
      return;
  }
};
Zl.prototype.afterquote = function(t) {
  if (t === '"') {
    this.word += '"', this.state = kg;
    return;
  }
  if (Tv.test(t)) {
    this.word = this.word.trim(), this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in afterquote yet, index ' + this.place);
};
Zl.prototype.afterItem = function(t) {
  if (t === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = Ld;
    return;
  }
  if (t === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Ld, this.currentObject = this.stack.pop(), this.currentObject || (this.state = U1);
    return;
  }
};
Zl.prototype.number = function(t) {
  if (yT.test(t)) {
    this.word += t;
    return;
  }
  if (Tv.test(t)) {
    this.word = parseFloat(this.word), this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in number yet, index ' + this.place);
};
Zl.prototype.quoted = function(t) {
  if (t === '"') {
    this.state = mT;
    return;
  }
  this.word += t;
};
Zl.prototype.keyword = function(t) {
  if (gD.test(t)) {
    this.word += t;
    return;
  }
  if (t === "[") {
    var e = [];
    e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, this.state = Ld;
    return;
  }
  if (Tv.test(t)) {
    this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in keyword yet, index ' + this.place);
};
Zl.prototype.neutral = function(t) {
  if (yD.test(t)) {
    this.word = t, this.state = pT;
    return;
  }
  if (t === '"') {
    this.word = "", this.state = kg;
    return;
  }
  if (yT.test(t)) {
    this.word = t, this.state = dT;
    return;
  }
  if (Tv.test(t)) {
    this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in neutral yet, index ' + this.place);
};
Zl.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === U1)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function vD(t) {
  var e = new Zl(t);
  return e.output();
}
function Nw(t, e, n) {
  Array.isArray(e) && (n.unshift(e), e = null);
  var o = e ? {} : t, s = n.reduce(function(h, a) {
    return gf(a, h), h;
  }, o);
  e && (t[e] = s);
}
function gf(t, e) {
  if (!Array.isArray(t)) {
    e[t] = !0;
    return;
  }
  var n = t.shift();
  if (n === "PARAMETER" && (n = t.shift()), t.length === 1) {
    if (Array.isArray(t[0])) {
      e[n] = {}, gf(t[0], e[n]);
      return;
    }
    e[n] = t[0];
    return;
  }
  if (!t.length) {
    e[n] = !0;
    return;
  }
  if (n === "TOWGS84") {
    e[n] = t;
    return;
  }
  if (n === "AXIS") {
    n in e || (e[n] = []), e[n].push(t);
    return;
  }
  Array.isArray(n) || (e[n] = {});
  var o;
  switch (n) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      e[n] = {
        name: t[0].toLowerCase(),
        convert: t[1]
      }, t.length === 3 && gf(t[2], e[n]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      e[n] = {
        name: t[0],
        a: t[1],
        rf: t[2]
      }, t.length === 4 && gf(t[3], e[n]);
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      t[0] = ["name", t[0]], Nw(e, n, t);
      return;
    default:
      for (o = -1; ++o < t.length; )
        if (!Array.isArray(t[o]))
          return gf(t, e[n]);
      return Nw(e, n, t);
  }
}
var _D = 0.017453292519943295;
function xD(t, e) {
  var n = e[0], o = e[1];
  !(n in t) && o in t && (t[n] = t[o], e.length === 3 && (t[n] = e[2](t[n])));
}
function kl(t) {
  return t * _D;
}
function bD(t) {
  if (t.type === "GEOGCS" ? t.projName = "longlat" : t.type === "LOCAL_CS" ? (t.projName = "identity", t.local = !0) : typeof t.PROJECTION == "object" ? t.projName = Object.keys(t.PROJECTION)[0] : t.projName = t.PROJECTION, t.AXIS) {
    for (var e = "", n = 0, o = t.AXIS.length; n < o; ++n) {
      var s = [t.AXIS[n][0].toLowerCase(), t.AXIS[n][1].toLowerCase()];
      s[0].indexOf("north") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "north" ? e += "n" : s[0].indexOf("south") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "south" ? e += "s" : s[0].indexOf("east") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "east" ? e += "e" : (s[0].indexOf("west") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "west") && (e += "w");
    }
    e.length === 2 && (e += "u"), e.length === 3 && (t.axis = e);
  }
  t.UNIT && (t.units = t.UNIT.name.toLowerCase(), t.units === "metre" && (t.units = "meter"), t.UNIT.convert && (t.type === "GEOGCS" ? t.DATUM && t.DATUM.SPHEROID && (t.to_meter = t.UNIT.convert * t.DATUM.SPHEROID.a) : t.to_meter = t.UNIT.convert));
  var h = t.GEOGCS;
  t.type === "GEOGCS" && (h = t), h && (h.DATUM ? t.datumCode = h.DATUM.name.toLowerCase() : t.datumCode = h.name.toLowerCase(), t.datumCode.slice(0, 2) === "d_" && (t.datumCode = t.datumCode.slice(2)), (t.datumCode === "new_zealand_geodetic_datum_1949" || t.datumCode === "new_zealand_1949") && (t.datumCode = "nzgd49"), (t.datumCode === "wgs_1984" || t.datumCode === "world_geodetic_system_1984") && (t.PROJECTION === "Mercator_Auxiliary_Sphere" && (t.sphere = !0), t.datumCode = "wgs84"), t.datumCode.slice(-6) === "_ferro" && (t.datumCode = t.datumCode.slice(0, -6)), t.datumCode.slice(-8) === "_jakarta" && (t.datumCode = t.datumCode.slice(0, -8)), ~t.datumCode.indexOf("belge") && (t.datumCode = "rnb72"), h.DATUM && h.DATUM.SPHEROID && (t.ellps = h.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), t.ellps.toLowerCase().slice(0, 13) === "international" && (t.ellps = "intl"), t.a = h.DATUM.SPHEROID.a, t.rf = parseFloat(h.DATUM.SPHEROID.rf, 10)), h.DATUM && h.DATUM.TOWGS84 && (t.datum_params = h.DATUM.TOWGS84), ~t.datumCode.indexOf("osgb_1936") && (t.datumCode = "osgb36"), ~t.datumCode.indexOf("osni_1952") && (t.datumCode = "osni52"), (~t.datumCode.indexOf("tm65") || ~t.datumCode.indexOf("geodetic_datum_of_1965")) && (t.datumCode = "ire65"), t.datumCode === "ch1903+" && (t.datumCode = "ch1903"), ~t.datumCode.indexOf("israel") && (t.datumCode = "isr93")), t.b && !isFinite(t.b) && (t.b = t.a);
  function a(b) {
    var T = t.to_meter || 1;
    return b * T;
  }
  var m = function(b) {
    return xD(t, b);
  }, g = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", kl],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", kl],
    ["x0", "false_easting", a],
    ["y0", "false_northing", a],
    ["long0", "central_meridian", kl],
    ["lat0", "latitude_of_origin", kl],
    ["lat0", "standard_parallel_1", kl],
    ["lat1", "standard_parallel_1", kl],
    ["lat2", "standard_parallel_2", kl],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", kl],
    ["srsCode", "name"]
  ];
  g.forEach(m), !t.long0 && t.longc && (t.projName === "Albers_Conic_Equal_Area" || t.projName === "Lambert_Azimuthal_Equal_Area") && (t.long0 = t.longc), !t.lat_ts && t.lat1 && (t.projName === "Stereographic_South_Pole" || t.projName === "Polar Stereographic (variant B)") && (t.lat0 = kl(t.lat1 > 0 ? 90 : -90), t.lat_ts = t.lat1);
}
function gT(t) {
  var e = vD(t), n = e.shift(), o = e.shift();
  e.unshift(["name", o]), e.unshift(["type", n]);
  var s = {};
  return gf(e, s), bD(s), s;
}
function Do(t) {
  var e = this;
  if (arguments.length === 2) {
    var n = arguments[1];
    typeof n == "string" ? n.charAt(0) === "+" ? Do[t] = X0(arguments[1]) : Do[t] = gT(arguments[1]) : Do[t] = n;
  } else if (arguments.length === 1) {
    if (Array.isArray(t))
      return t.map(function(o) {
        Array.isArray(o) ? Do.apply(e, o) : Do(o);
      });
    if (typeof t == "string") {
      if (t in Do)
        return Do[t];
    } else
      "EPSG" in t ? Do["EPSG:" + t.EPSG] = t : "ESRI" in t ? Do["ESRI:" + t.ESRI] = t : "IAU2000" in t ? Do["IAU2000:" + t.IAU2000] = t : console.log(t);
    return;
  }
}
lD(Do);
function wD(t) {
  return typeof t == "string";
}
function ED(t) {
  return t in Do;
}
var SD = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function TD(t) {
  return SD.some(function(e) {
    return t.indexOf(e) > -1;
  });
}
var MD = ["3857", "900913", "3785", "102113"];
function ID(t) {
  var e = zu(t, "authority");
  if (!!e) {
    var n = zu(e, "epsg");
    return n && MD.indexOf(n) > -1;
  }
}
function OD(t) {
  var e = zu(t, "extension");
  if (!!e)
    return zu(e, "proj4");
}
function CD(t) {
  return t[0] === "+";
}
function AD(t) {
  if (wD(t)) {
    if (ED(t))
      return Do[t];
    if (TD(t)) {
      var e = gT(t);
      if (ID(e))
        return Do["EPSG:3857"];
      var n = OD(e);
      return n ? X0(n) : e;
    }
    if (CD(t))
      return X0(t);
  } else
    return t;
}
function Rw(t, e) {
  t = t || {};
  var n, o;
  if (!e)
    return t;
  for (o in e)
    n = e[o], n !== void 0 && (t[o] = n);
  return t;
}
function el(t, e, n) {
  var o = t * e;
  return n / Math.sqrt(1 - o * o);
}
function $d(t) {
  return t < 0 ? -1 : 1;
}
function Vt(t) {
  return Math.abs(t) <= wi ? t : t - $d(t) * kd;
}
function us(t, e, n) {
  var o = t * n, s = 0.5 * t;
  return o = Math.pow((1 - o) / (1 + o), s), Math.tan(0.5 * (ft - e)) / o;
}
function Dd(t, e) {
  for (var n = 0.5 * t, o, s, h = ft - 2 * Math.atan(e), a = 0; a <= 15; a++)
    if (o = t * Math.sin(h), s = ft - 2 * Math.atan(e * Math.pow((1 - o) / (1 + o), n)) - h, h += s, Math.abs(s) <= 1e-10)
      return h;
  return -9999;
}
function PD() {
  var t = this.b / this.a;
  this.es = 1 - t * t, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = el(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function kD(t) {
  var e = t.x, n = t.y;
  if (n * qs > 90 && n * qs < -90 && e * qs > 180 && e * qs < -180)
    return null;
  var o, s;
  if (Math.abs(Math.abs(n) - ft) <= Ct)
    return null;
  if (this.sphere)
    o = this.x0 + this.a * this.k0 * Vt(e - this.long0), s = this.y0 + this.a * this.k0 * Math.log(Math.tan(ln + 0.5 * n));
  else {
    var h = Math.sin(n), a = us(this.e, n, h);
    o = this.x0 + this.a * this.k0 * Vt(e - this.long0), s = this.y0 - this.a * this.k0 * Math.log(a);
  }
  return t.x = o, t.y = s, t;
}
function LD(t) {
  var e = t.x - this.x0, n = t.y - this.y0, o, s;
  if (this.sphere)
    s = ft - 2 * Math.atan(Math.exp(-n / (this.a * this.k0)));
  else {
    var h = Math.exp(-n / (this.a * this.k0));
    if (s = Dd(this.e, h), s === -9999)
      return null;
  }
  return o = Vt(this.long0 + e / (this.a * this.k0)), t.x = o, t.y = s, t;
}
var DD = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const ND = {
  init: PD,
  forward: kD,
  inverse: LD,
  names: DD
};
function RD() {
}
function zw(t) {
  return t;
}
var zD = ["longlat", "identity"];
const FD = {
  init: RD,
  forward: zw,
  inverse: zw,
  names: zD
};
var BD = [ND, FD], ag = {}, Lg = [];
function vT(t, e) {
  var n = Lg.length;
  return t.names ? (Lg[n] = t, t.names.forEach(function(o) {
    ag[o.toLowerCase()] = n;
  }), this) : (console.log(e), !0);
}
function VD(t) {
  if (!t)
    return !1;
  var e = t.toLowerCase();
  if (typeof ag[e] < "u" && Lg[ag[e]])
    return Lg[ag[e]];
}
function UD() {
  BD.forEach(vT);
}
const jD = {
  start: UD,
  add: vT,
  get: VD
};
var br = {};
br.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
br.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
br.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
br.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
br.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
br.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
br.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
br.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
br.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
br.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
br.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
br.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
br.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
br.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
br.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
br.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
br.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
br.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
br.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
br.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
br.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
br.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
br.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
br.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
br.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
br.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
br.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
br.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
br.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
br.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
br.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
br.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
br.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
br.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
br.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
br.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
br.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
br.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
br.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
br.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
br.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var GD = br.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
br.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function $D(t, e, n, o) {
  var s = t * t, h = e * e, a = (s - h) / s, m = 0;
  o ? (t *= 1 - a * (hD + a * (fD + a * pD)), s = t * t, a = 0) : m = Math.sqrt(a);
  var g = (s - h) / h;
  return {
    es: a,
    e: m,
    ep2: g
  };
}
function qD(t, e, n, o, s) {
  if (!t) {
    var h = zu(br, o);
    h || (h = GD), t = h.a, e = h.b, n = h.rf;
  }
  return n && !e && (e = (1 - 1 / n) * t), (n === 0 || Math.abs(t - e) < Ct) && (s = !0, e = t), {
    a: t,
    b: e,
    rf: n,
    sphere: s
  };
}
var Ki = {};
Ki.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
Ki.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
Ki.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
Ki.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
Ki.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
Ki.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
Ki.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
Ki.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
Ki.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
Ki.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
Ki.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
Ki.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
Ki.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
Ki.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
Ki.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
Ki.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
Ki.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function WD(t, e, n, o, s, h, a) {
  var m = {};
  return t === void 0 || t === "none" ? m.datum_type = Z0 : m.datum_type = uD, e && (m.datum_params = e.map(parseFloat), (m.datum_params[0] !== 0 || m.datum_params[1] !== 0 || m.datum_params[2] !== 0) && (m.datum_type = eh), m.datum_params.length > 3 && (m.datum_params[3] !== 0 || m.datum_params[4] !== 0 || m.datum_params[5] !== 0 || m.datum_params[6] !== 0) && (m.datum_type = th, m.datum_params[3] *= md, m.datum_params[4] *= md, m.datum_params[5] *= md, m.datum_params[6] = m.datum_params[6] / 1e6 + 1)), a && (m.datum_type = Mf, m.grids = a), m.a = n, m.b = o, m.es = s, m.ep2 = h, m;
}
var _T = {};
function HD(t, e) {
  var n = new DataView(e), o = KD(n), s = YD(n, o);
  s.nSubgrids > 1 && console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
  var h = JD(n, s, o), a = { header: s, subgrids: h };
  return _T[t] = a, a;
}
function ZD(t) {
  if (t === void 0)
    return null;
  var e = t.split(",");
  return e.map(XD);
}
function XD(t) {
  if (t.length === 0)
    return null;
  var e = t[0] === "@";
  return e && (t = t.slice(1)), t === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : {
    name: t,
    mandatory: !e,
    grid: _T[t] || null,
    isNull: !1
  };
}
function vf(t) {
  return t / 3600 * Math.PI / 180;
}
function KD(t) {
  var e = t.getInt32(8, !1);
  return e === 11 ? !1 : (e = t.getInt32(8, !0), e !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function YD(t, e) {
  return {
    nFields: t.getInt32(8, e),
    nSubgridFields: t.getInt32(24, e),
    nSubgrids: t.getInt32(40, e),
    shiftType: K0(t, 56, 56 + 8).trim(),
    fromSemiMajorAxis: t.getFloat64(120, e),
    fromSemiMinorAxis: t.getFloat64(136, e),
    toSemiMajorAxis: t.getFloat64(152, e),
    toSemiMinorAxis: t.getFloat64(168, e)
  };
}
function K0(t, e, n) {
  return String.fromCharCode.apply(null, new Uint8Array(t.buffer.slice(e, n)));
}
function JD(t, e, n) {
  for (var o = 176, s = [], h = 0; h < e.nSubgrids; h++) {
    var a = eN(t, o, n), m = tN(t, o, a, n), g = Math.round(
      1 + (a.upperLongitude - a.lowerLongitude) / a.longitudeInterval
    ), b = Math.round(
      1 + (a.upperLatitude - a.lowerLatitude) / a.latitudeInterval
    );
    s.push({
      ll: [vf(a.lowerLongitude), vf(a.lowerLatitude)],
      del: [vf(a.longitudeInterval), vf(a.latitudeInterval)],
      lim: [g, b],
      count: a.gridNodeCount,
      cvs: QD(m)
    });
  }
  return s;
}
function QD(t) {
  return t.map(function(e) {
    return [vf(e.longitudeShift), vf(e.latitudeShift)];
  });
}
function eN(t, e, n) {
  return {
    name: K0(t, e + 8, e + 16).trim(),
    parent: K0(t, e + 24, e + 24 + 8).trim(),
    lowerLatitude: t.getFloat64(e + 72, n),
    upperLatitude: t.getFloat64(e + 88, n),
    lowerLongitude: t.getFloat64(e + 104, n),
    upperLongitude: t.getFloat64(e + 120, n),
    latitudeInterval: t.getFloat64(e + 136, n),
    longitudeInterval: t.getFloat64(e + 152, n),
    gridNodeCount: t.getInt32(e + 168, n)
  };
}
function tN(t, e, n, o) {
  for (var s = e + 176, h = 16, a = [], m = 0; m < n.gridNodeCount; m++) {
    var g = {
      latitudeShift: t.getFloat32(s + m * h, o),
      longitudeShift: t.getFloat32(s + m * h + 4, o),
      latitudeAccuracy: t.getFloat32(s + m * h + 8, o),
      longitudeAccuracy: t.getFloat32(s + m * h + 12, o)
    };
    a.push(g);
  }
  return a;
}
function Zs(t, e) {
  if (!(this instanceof Zs))
    return new Zs(t);
  e = e || function(b) {
    if (b)
      throw b;
  };
  var n = AD(t);
  if (typeof n != "object") {
    e(t);
    return;
  }
  var o = Zs.projections.get(n.projName);
  if (!o) {
    e(t);
    return;
  }
  if (n.datumCode && n.datumCode !== "none") {
    var s = zu(Ki, n.datumCode);
    s && (n.datum_params = n.datum_params || (s.towgs84 ? s.towgs84.split(",") : null), n.ellps = s.ellipse, n.datumName = s.datumName ? s.datumName : n.datumCode);
  }
  n.k0 = n.k0 || 1, n.axis = n.axis || "enu", n.ellps = n.ellps || "wgs84", n.lat1 = n.lat1 || n.lat0;
  var h = qD(n.a, n.b, n.rf, n.ellps, n.sphere), a = $D(h.a, h.b, h.rf, n.R_A), m = ZD(n.nadgrids), g = n.datum || WD(
    n.datumCode,
    n.datum_params,
    h.a,
    h.b,
    a.es,
    a.ep2,
    m
  );
  Rw(this, n), Rw(this, o), this.a = h.a, this.b = h.b, this.rf = h.rf, this.sphere = h.sphere, this.es = a.es, this.e = a.e, this.ep2 = a.ep2, this.datum = g, this.init(), e(null, this);
}
Zs.projections = jD;
Zs.projections.start();
function rN(t, e) {
  return t.datum_type !== e.datum_type || t.a !== e.a || Math.abs(t.es - e.es) > 5e-11 ? !1 : t.datum_type === eh ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] : t.datum_type === th ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] && t.datum_params[3] === e.datum_params[3] && t.datum_params[4] === e.datum_params[4] && t.datum_params[5] === e.datum_params[5] && t.datum_params[6] === e.datum_params[6] : !0;
}
function xT(t, e, n) {
  var o = t.x, s = t.y, h = t.z ? t.z : 0, a, m, g, b;
  if (s < -ft && s > -1.001 * ft)
    s = -ft;
  else if (s > ft && s < 1.001 * ft)
    s = ft;
  else {
    if (s < -ft)
      return { x: -1 / 0, y: -1 / 0, z: t.z };
    if (s > ft)
      return { x: 1 / 0, y: 1 / 0, z: t.z };
  }
  return o > Math.PI && (o -= 2 * Math.PI), m = Math.sin(s), b = Math.cos(s), g = m * m, a = n / Math.sqrt(1 - e * g), {
    x: (a + h) * b * Math.cos(o),
    y: (a + h) * b * Math.sin(o),
    z: (a * (1 - e) + h) * m
  };
}
function bT(t, e, n, o) {
  var s = 1e-12, h = s * s, a = 30, m, g, b, T, M, I, P, z, V, q, re, X, ae, ce = t.x, ve = t.y, Re = t.z ? t.z : 0, Fe, Pe, Se;
  if (m = Math.sqrt(ce * ce + ve * ve), g = Math.sqrt(ce * ce + ve * ve + Re * Re), m / n < s) {
    if (Fe = 0, g / n < s)
      return Pe = ft, Se = -o, {
        x: t.x,
        y: t.y,
        z: t.z
      };
  } else
    Fe = Math.atan2(ve, ce);
  b = Re / g, T = m / g, M = 1 / Math.sqrt(1 - e * (2 - e) * T * T), z = T * (1 - e) * M, V = b * M, ae = 0;
  do
    ae++, P = n / Math.sqrt(1 - e * V * V), Se = m * z + Re * V - P * (1 - e * V * V), I = e * P / (P + Se), M = 1 / Math.sqrt(1 - I * (2 - I) * T * T), q = T * (1 - I) * M, re = b * M, X = re * z - q * V, z = q, V = re;
  while (X * X > h && ae < a);
  return Pe = Math.atan(re / Math.abs(q)), {
    x: Fe,
    y: Pe,
    z: Se
  };
}
function nN(t, e, n) {
  if (e === eh)
    return {
      x: t.x + n[0],
      y: t.y + n[1],
      z: t.z + n[2]
    };
  if (e === th) {
    var o = n[0], s = n[1], h = n[2], a = n[3], m = n[4], g = n[5], b = n[6];
    return {
      x: b * (t.x - g * t.y + m * t.z) + o,
      y: b * (g * t.x + t.y - a * t.z) + s,
      z: b * (-m * t.x + a * t.y + t.z) + h
    };
  }
}
function iN(t, e, n) {
  if (e === eh)
    return {
      x: t.x - n[0],
      y: t.y - n[1],
      z: t.z - n[2]
    };
  if (e === th) {
    var o = n[0], s = n[1], h = n[2], a = n[3], m = n[4], g = n[5], b = n[6], T = (t.x - o) / b, M = (t.y - s) / b, I = (t.z - h) / b;
    return {
      x: T + g * M - m * I,
      y: -g * T + M + a * I,
      z: m * T - a * M + I
    };
  }
}
function Iy(t) {
  return t === eh || t === th;
}
function oN(t, e, n) {
  if (rN(t, e) || t.datum_type === Z0 || e.datum_type === Z0)
    return n;
  var o = t.a, s = t.es;
  if (t.datum_type === Mf) {
    var h = Fw(t, !1, n);
    if (h !== 0)
      return;
    o = kw, s = Lw;
  }
  var a = e.a, m = e.b, g = e.es;
  if (e.datum_type === Mf && (a = kw, m = cD, g = Lw), s === g && o === a && !Iy(t.datum_type) && !Iy(e.datum_type))
    return n;
  if (n = xT(n, s, o), Iy(t.datum_type) && (n = nN(n, t.datum_type, t.datum_params)), Iy(e.datum_type) && (n = iN(n, e.datum_type, e.datum_params)), n = bT(n, g, a, m), e.datum_type === Mf) {
    var b = Fw(e, !0, n);
    if (b !== 0)
      return;
  }
  return n;
}
function Fw(t, e, n) {
  if (t.grids === null || t.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  for (var o = { x: -n.x, y: n.y }, s = { x: Number.NaN, y: Number.NaN }, h = [], a = 0; a < t.grids.length; a++) {
    var m = t.grids[a];
    if (h.push(m.name), m.isNull) {
      s = o;
      break;
    }
    if (m.mandatory, m.grid === null) {
      if (m.mandatory)
        return console.log("Unable to find mandatory grid '" + m.name + "'"), -1;
      continue;
    }
    var g = m.grid.subgrids[0], b = (Math.abs(g.del[1]) + Math.abs(g.del[0])) / 1e4, T = g.ll[0] - b, M = g.ll[1] - b, I = g.ll[0] + (g.lim[0] - 1) * g.del[0] + b, P = g.ll[1] + (g.lim[1] - 1) * g.del[1] + b;
    if (!(M > o.y || T > o.x || P < o.y || I < o.x) && (s = aN(o, e, g), !isNaN(s.x)))
      break;
  }
  return isNaN(s.x) ? (console.log("Failed to find a grid shift table for location '" + -o.x * qs + " " + o.y * qs + " tried: '" + h + "'"), -1) : (n.x = -s.x, n.y = s.y, 0);
}
function aN(t, e, n) {
  var o = { x: Number.NaN, y: Number.NaN };
  if (isNaN(t.x))
    return o;
  var s = { x: t.x, y: t.y };
  s.x -= n.ll[0], s.y -= n.ll[1], s.x = Vt(s.x - Math.PI) + Math.PI;
  var h = Bw(s, n);
  if (e) {
    if (isNaN(h.x))
      return o;
    h.x = s.x - h.x, h.y = s.y - h.y;
    var a = 9, m = 1e-12, g, b;
    do {
      if (b = Bw(h, n), isNaN(b.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      g = { x: s.x - (b.x + h.x), y: s.y - (b.y + h.y) }, h.x += g.x, h.y += g.y;
    } while (a-- && Math.abs(g.x) > m && Math.abs(g.y) > m);
    if (a < 0)
      return console.log("Inverse grid shift iterator failed to converge."), o;
    o.x = Vt(h.x + n.ll[0]), o.y = h.y + n.ll[1];
  } else
    isNaN(h.x) || (o.x = t.x + h.x, o.y = t.y + h.y);
  return o;
}
function Bw(t, e) {
  var n = { x: t.x / e.del[0], y: t.y / e.del[1] }, o = { x: Math.floor(n.x), y: Math.floor(n.y) }, s = { x: n.x - 1 * o.x, y: n.y - 1 * o.y }, h = { x: Number.NaN, y: Number.NaN }, a;
  if (o.x < 0 || o.x >= e.lim[0] || o.y < 0 || o.y >= e.lim[1])
    return h;
  a = o.y * e.lim[0] + o.x;
  var m = { x: e.cvs[a][0], y: e.cvs[a][1] };
  a++;
  var g = { x: e.cvs[a][0], y: e.cvs[a][1] };
  a += e.lim[0];
  var b = { x: e.cvs[a][0], y: e.cvs[a][1] };
  a--;
  var T = { x: e.cvs[a][0], y: e.cvs[a][1] }, M = s.x * s.y, I = s.x * (1 - s.y), P = (1 - s.x) * (1 - s.y), z = (1 - s.x) * s.y;
  return h.x = P * m.x + I * g.x + z * T.x + M * b.x, h.y = P * m.y + I * g.y + z * T.y + M * b.y, h;
}
function Vw(t, e, n) {
  var o = n.x, s = n.y, h = n.z || 0, a, m, g, b = {};
  for (g = 0; g < 3; g++)
    if (!(e && g === 2 && n.z === void 0))
      switch (g === 0 ? (a = o, "ew".indexOf(t.axis[g]) !== -1 ? m = "x" : m = "y") : g === 1 ? (a = s, "ns".indexOf(t.axis[g]) !== -1 ? m = "y" : m = "x") : (a = h, m = "z"), t.axis[g]) {
        case "e":
          b[m] = a;
          break;
        case "w":
          b[m] = -a;
          break;
        case "n":
          b[m] = a;
          break;
        case "s":
          b[m] = -a;
          break;
        case "u":
          n[m] !== void 0 && (b.z = a);
          break;
        case "d":
          n[m] !== void 0 && (b.z = -a);
          break;
        default:
          return null;
      }
  return b;
}
function wT(t) {
  var e = {
    x: t[0],
    y: t[1]
  };
  return t.length > 2 && (e.z = t[2]), t.length > 3 && (e.m = t[3]), e;
}
function sN(t) {
  Uw(t.x), Uw(t.y);
}
function Uw(t) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(t))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof t != "number" || t !== t || !isFinite(t))
    throw new TypeError("coordinates must be finite numbers");
}
function lN(t, e) {
  return (t.datum.datum_type === eh || t.datum.datum_type === th || t.datum.datum_type === Mf) && e.datumCode !== "WGS84" || (e.datum.datum_type === eh || e.datum.datum_type === th || e.datum.datum_type === Mf) && t.datumCode !== "WGS84";
}
function Dg(t, e, n, o) {
  var s;
  Array.isArray(n) ? n = wT(n) : n = {
    x: n.x,
    y: n.y,
    z: n.z,
    m: n.m
  };
  var h = n.z !== void 0;
  if (sN(n), t.datum && e.datum && lN(t, e) && (s = new Zs("WGS84"), n = Dg(t, s, n, o), t = s), o && t.axis !== "enu" && (n = Vw(t, !1, n)), t.projName === "longlat")
    n = {
      x: n.x * io,
      y: n.y * io,
      z: n.z || 0
    };
  else if (t.to_meter && (n = {
    x: n.x * t.to_meter,
    y: n.y * t.to_meter,
    z: n.z || 0
  }), n = t.inverse(n), !n)
    return;
  if (t.from_greenwich && (n.x += t.from_greenwich), n = oN(t.datum, e.datum, n), !!n)
    return e.from_greenwich && (n = {
      x: n.x - e.from_greenwich,
      y: n.y,
      z: n.z || 0
    }), e.projName === "longlat" ? n = {
      x: n.x * qs,
      y: n.y * qs,
      z: n.z || 0
    } : (n = e.forward(n), e.to_meter && (n = {
      x: n.x / e.to_meter,
      y: n.y / e.to_meter,
      z: n.z || 0
    })), o && e.axis !== "enu" ? Vw(e, !0, n) : (h || delete n.z, n);
}
var jw = Zs("WGS84");
function $_(t, e, n, o) {
  var s, h, a;
  return Array.isArray(n) ? (s = Dg(t, e, n, o) || { x: NaN, y: NaN }, n.length > 2 ? typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent" ? typeof s.z == "number" ? [s.x, s.y, s.z].concat(n.splice(3)) : [s.x, s.y, n[2]].concat(n.splice(3)) : [s.x, s.y].concat(n.splice(2)) : [s.x, s.y]) : (h = Dg(t, e, n, o), a = Object.keys(n), a.length === 2 || a.forEach(function(m) {
    if (typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent") {
      if (m === "x" || m === "y" || m === "z")
        return;
    } else if (m === "x" || m === "y")
      return;
    h[m] = n[m];
  }), h);
}
function Gw(t) {
  return t instanceof Zs ? t : t.oProj ? t.oProj : Zs(t);
}
function wo(t, e, n) {
  t = Gw(t);
  var o = !1, s;
  return typeof e > "u" ? (e = t, t = jw, o = !0) : (typeof e.x < "u" || Array.isArray(e)) && (n = e, e = t, t = jw, o = !0), e = Gw(e), n ? $_(t, e, n) : (s = {
    forward: function(h, a) {
      return $_(t, e, h, a);
    },
    inverse: function(h, a) {
      return $_(e, t, h, a);
    }
  }, o && (s.oProj = e), s);
}
var $w = 6, ET = "AJSAJS", ST = "AFAFAF", _f = 65, Qo = 73, Aa = 79, ed = 86, td = 90;
const uN = {
  forward: TT,
  inverse: cN,
  toPoint: MT
};
function TT(t, e) {
  return e = e || 5, pN(hN({
    lat: t[1],
    lon: t[0]
  }), e);
}
function cN(t) {
  var e = j1(OT(t.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
}
function MT(t) {
  var e = j1(OT(t.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function q_(t) {
  return t * (Math.PI / 180);
}
function qw(t) {
  return 180 * (t / Math.PI);
}
function hN(t) {
  var e = t.lat, n = t.lon, o = 6378137, s = 669438e-8, h = 0.9996, a, m, g, b, T, M, I, P = q_(e), z = q_(n), V, q;
  q = Math.floor((n + 180) / 6) + 1, n === 180 && (q = 60), e >= 56 && e < 64 && n >= 3 && n < 12 && (q = 32), e >= 72 && e < 84 && (n >= 0 && n < 9 ? q = 31 : n >= 9 && n < 21 ? q = 33 : n >= 21 && n < 33 ? q = 35 : n >= 33 && n < 42 && (q = 37)), a = (q - 1) * 6 - 180 + 3, V = q_(a), m = s / (1 - s), g = o / Math.sqrt(1 - s * Math.sin(P) * Math.sin(P)), b = Math.tan(P) * Math.tan(P), T = m * Math.cos(P) * Math.cos(P), M = Math.cos(P) * (z - V), I = o * ((1 - s / 4 - 3 * s * s / 64 - 5 * s * s * s / 256) * P - (3 * s / 8 + 3 * s * s / 32 + 45 * s * s * s / 1024) * Math.sin(2 * P) + (15 * s * s / 256 + 45 * s * s * s / 1024) * Math.sin(4 * P) - 35 * s * s * s / 3072 * Math.sin(6 * P));
  var re = h * g * (M + (1 - b + T) * M * M * M / 6 + (5 - 18 * b + b * b + 72 * T - 58 * m) * M * M * M * M * M / 120) + 5e5, X = h * (I + g * Math.tan(P) * (M * M / 2 + (5 - b + 9 * T + 4 * T * T) * M * M * M * M / 24 + (61 - 58 * b + b * b + 600 * T - 330 * m) * M * M * M * M * M * M / 720));
  return e < 0 && (X += 1e7), {
    northing: Math.round(X),
    easting: Math.round(re),
    zoneNumber: q,
    zoneLetter: fN(e)
  };
}
function j1(t) {
  var e = t.northing, n = t.easting, o = t.zoneLetter, s = t.zoneNumber;
  if (s < 0 || s > 60)
    return null;
  var h = 0.9996, a = 6378137, m = 669438e-8, g, b = (1 - Math.sqrt(1 - m)) / (1 + Math.sqrt(1 - m)), T, M, I, P, z, V, q, re, X, ae = n - 5e5, ce = e;
  o < "N" && (ce -= 1e7), q = (s - 1) * 6 - 180 + 3, g = m / (1 - m), V = ce / h, re = V / (a * (1 - m / 4 - 3 * m * m / 64 - 5 * m * m * m / 256)), X = re + (3 * b / 2 - 27 * b * b * b / 32) * Math.sin(2 * re) + (21 * b * b / 16 - 55 * b * b * b * b / 32) * Math.sin(4 * re) + 151 * b * b * b / 96 * Math.sin(6 * re), T = a / Math.sqrt(1 - m * Math.sin(X) * Math.sin(X)), M = Math.tan(X) * Math.tan(X), I = g * Math.cos(X) * Math.cos(X), P = a * (1 - m) / Math.pow(1 - m * Math.sin(X) * Math.sin(X), 1.5), z = ae / (T * h);
  var ve = X - T * Math.tan(X) / P * (z * z / 2 - (5 + 3 * M + 10 * I - 4 * I * I - 9 * g) * z * z * z * z / 24 + (61 + 90 * M + 298 * I + 45 * M * M - 252 * g - 3 * I * I) * z * z * z * z * z * z / 720);
  ve = qw(ve);
  var Re = (z - (1 + 2 * M + I) * z * z * z / 6 + (5 - 2 * I + 28 * M - 3 * I * I + 8 * g + 24 * M * M) * z * z * z * z * z / 120) / Math.cos(X);
  Re = q + qw(Re);
  var Fe;
  if (t.accuracy) {
    var Pe = j1({
      northing: t.northing + t.accuracy,
      easting: t.easting + t.accuracy,
      zoneLetter: t.zoneLetter,
      zoneNumber: t.zoneNumber
    });
    Fe = {
      top: Pe.lat,
      right: Pe.lon,
      bottom: ve,
      left: Re
    };
  } else
    Fe = {
      lat: ve,
      lon: Re
    };
  return Fe;
}
function fN(t) {
  var e = "Z";
  return 84 >= t && t >= 72 ? e = "X" : 72 > t && t >= 64 ? e = "W" : 64 > t && t >= 56 ? e = "V" : 56 > t && t >= 48 ? e = "U" : 48 > t && t >= 40 ? e = "T" : 40 > t && t >= 32 ? e = "S" : 32 > t && t >= 24 ? e = "R" : 24 > t && t >= 16 ? e = "Q" : 16 > t && t >= 8 ? e = "P" : 8 > t && t >= 0 ? e = "N" : 0 > t && t >= -8 ? e = "M" : -8 > t && t >= -16 ? e = "L" : -16 > t && t >= -24 ? e = "K" : -24 > t && t >= -32 ? e = "J" : -32 > t && t >= -40 ? e = "H" : -40 > t && t >= -48 ? e = "G" : -48 > t && t >= -56 ? e = "F" : -56 > t && t >= -64 ? e = "E" : -64 > t && t >= -72 ? e = "D" : -72 > t && t >= -80 && (e = "C"), e;
}
function pN(t, e) {
  var n = "00000" + t.easting, o = "00000" + t.northing;
  return t.zoneNumber + t.zoneLetter + dN(t.easting, t.northing, t.zoneNumber) + n.substr(n.length - 5, e) + o.substr(o.length - 5, e);
}
function dN(t, e, n) {
  var o = IT(n), s = Math.floor(t / 1e5), h = Math.floor(e / 1e5) % 20;
  return mN(s, h, o);
}
function IT(t) {
  var e = t % $w;
  return e === 0 && (e = $w), e;
}
function mN(t, e, n) {
  var o = n - 1, s = ET.charCodeAt(o), h = ST.charCodeAt(o), a = s + t - 1, m = h + e, g = !1;
  a > td && (a = a - td + _f - 1, g = !0), (a === Qo || s < Qo && a > Qo || (a > Qo || s < Qo) && g) && a++, (a === Aa || s < Aa && a > Aa || (a > Aa || s < Aa) && g) && (a++, a === Qo && a++), a > td && (a = a - td + _f - 1), m > ed ? (m = m - ed + _f - 1, g = !0) : g = !1, (m === Qo || h < Qo && m > Qo || (m > Qo || h < Qo) && g) && m++, (m === Aa || h < Aa && m > Aa || (m > Aa || h < Aa) && g) && (m++, m === Qo && m++), m > ed && (m = m - ed + _f - 1);
  var b = String.fromCharCode(a) + String.fromCharCode(m);
  return b;
}
function OT(t) {
  if (t && t.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var e = t.length, n = null, o = "", s, h = 0; !/[A-Z]/.test(s = t.charAt(h)); ) {
    if (h >= 2)
      throw "MGRSPoint bad conversion from: " + t;
    o += s, h++;
  }
  var a = parseInt(o, 10);
  if (h === 0 || h + 3 > e)
    throw "MGRSPoint bad conversion from: " + t;
  var m = t.charAt(h++);
  if (m <= "A" || m === "B" || m === "Y" || m >= "Z" || m === "I" || m === "O")
    throw "MGRSPoint zone letter " + m + " not handled: " + t;
  n = t.substring(h, h += 2);
  for (var g = IT(a), b = yN(n.charAt(0), g), T = gN(n.charAt(1), g); T < vN(m); )
    T += 2e6;
  var M = e - h;
  if (M % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + t;
  var I = M / 2, P = 0, z = 0, V, q, re, X, ae;
  return I > 0 && (V = 1e5 / Math.pow(10, I), q = t.substring(h, h + I), P = parseFloat(q) * V, re = t.substring(h + I), z = parseFloat(re) * V), X = P + b, ae = z + T, {
    easting: X,
    northing: ae,
    zoneLetter: m,
    zoneNumber: a,
    accuracy: V
  };
}
function yN(t, e) {
  for (var n = ET.charCodeAt(e - 1), o = 1e5, s = !1; n !== t.charCodeAt(0); ) {
    if (n++, n === Qo && n++, n === Aa && n++, n > td) {
      if (s)
        throw "Bad character: " + t;
      n = _f, s = !0;
    }
    o += 1e5;
  }
  return o;
}
function gN(t, e) {
  if (t > "V")
    throw "MGRSPoint given invalid Northing " + t;
  for (var n = ST.charCodeAt(e - 1), o = 0, s = !1; n !== t.charCodeAt(0); ) {
    if (n++, n === Qo && n++, n === Aa && n++, n > ed) {
      if (s)
        throw "Bad character: " + t;
      n = _f, s = !0;
    }
    o += 1e5;
  }
  return o;
}
function vN(t) {
  var e;
  switch (t) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0)
    return e;
  throw "Invalid zone letter: " + t;
}
function Nf(t, e, n) {
  if (!(this instanceof Nf))
    return new Nf(t, e, n);
  if (Array.isArray(t))
    this.x = t[0], this.y = t[1], this.z = t[2] || 0;
  else if (typeof t == "object")
    this.x = t.x, this.y = t.y, this.z = t.z || 0;
  else if (typeof t == "string" && typeof e > "u") {
    var o = t.split(",");
    this.x = parseFloat(o[0], 10), this.y = parseFloat(o[1], 10), this.z = parseFloat(o[2], 10) || 0;
  } else
    this.x = t, this.y = e, this.z = n || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Nf.fromMGRS = function(t) {
  return new Nf(MT(t));
};
Nf.prototype.toMGRS = function(t) {
  return TT([this.x, this.y], t);
};
var _N = 1, xN = 0.25, Ww = 0.046875, Hw = 0.01953125, Zw = 0.01068115234375, bN = 0.75, wN = 0.46875, EN = 0.013020833333333334, SN = 0.007120768229166667, TN = 0.3645833333333333, MN = 0.005696614583333333, IN = 0.3076171875;
function CT(t) {
  var e = [];
  e[0] = _N - t * (xN + t * (Ww + t * (Hw + t * Zw))), e[1] = t * (bN - t * (Ww + t * (Hw + t * Zw)));
  var n = t * t;
  return e[2] = n * (wN - t * (EN + t * SN)), n *= t, e[3] = n * (TN - t * MN), e[4] = n * t * IN, e;
}
function Mv(t, e, n, o) {
  return n *= e, e *= e, o[0] * t - n * (o[1] + e * (o[2] + e * (o[3] + e * o[4])));
}
var ON = 20;
function AT(t, e, n) {
  for (var o = 1 / (1 - e), s = t, h = ON; h; --h) {
    var a = Math.sin(s), m = 1 - e * a * a;
    if (m = (Mv(s, a, Math.cos(s), n) - t) * (m * Math.sqrt(m)) * o, s -= m, Math.abs(m) < Ct)
      return s;
  }
  return s;
}
function CN() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = CT(this.es), this.ml0 = Mv(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function AN(t) {
  var e = t.x, n = t.y, o = Vt(e - this.long0), s, h, a, m = Math.sin(n), g = Math.cos(n);
  if (this.es) {
    var T = g * o, M = Math.pow(T, 2), I = this.ep2 * Math.pow(g, 2), P = Math.pow(I, 2), z = Math.abs(g) > Ct ? Math.tan(n) : 0, V = Math.pow(z, 2), q = Math.pow(V, 2);
    s = 1 - this.es * Math.pow(m, 2), T = T / Math.sqrt(s);
    var re = Mv(n, m, g, this.en);
    h = this.a * (this.k0 * T * (1 + M / 6 * (1 - V + I + M / 20 * (5 - 18 * V + q + 14 * I - 58 * V * I + M / 42 * (61 + 179 * q - q * V - 479 * V))))) + this.x0, a = this.a * (this.k0 * (re - this.ml0 + m * o * T / 2 * (1 + M / 12 * (5 - V + 9 * I + 4 * P + M / 30 * (61 + q - 58 * V + 270 * I - 330 * V * I + M / 56 * (1385 + 543 * q - q * V - 3111 * V)))))) + this.y0;
  } else {
    var b = g * Math.sin(o);
    if (Math.abs(Math.abs(b) - 1) < Ct)
      return 93;
    if (h = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0, a = g * Math.cos(o) / Math.sqrt(1 - Math.pow(b, 2)), b = Math.abs(a), b >= 1) {
      if (b - 1 > Ct)
        return 93;
      a = 0;
    } else
      a = Math.acos(a);
    n < 0 && (a = -a), a = this.a * this.k0 * (a - this.lat0) + this.y0;
  }
  return t.x = h, t.y = a, t;
}
function PN(t) {
  var e, n, o, s, h = (t.x - this.x0) * (1 / this.a), a = (t.y - this.y0) * (1 / this.a);
  if (this.es)
    if (e = this.ml0 + a / this.k0, n = AT(e, this.es, this.en), Math.abs(n) < ft) {
      var M = Math.sin(n), I = Math.cos(n), P = Math.abs(I) > Ct ? Math.tan(n) : 0, z = this.ep2 * Math.pow(I, 2), V = Math.pow(z, 2), q = Math.pow(P, 2), re = Math.pow(q, 2);
      e = 1 - this.es * Math.pow(M, 2);
      var X = h * Math.sqrt(e) / this.k0, ae = Math.pow(X, 2);
      e = e * P, o = n - e * ae / (1 - this.es) * 0.5 * (1 - ae / 12 * (5 + 3 * q - 9 * z * q + z - 4 * V - ae / 30 * (61 + 90 * q - 252 * z * q + 45 * re + 46 * z - ae / 56 * (1385 + 3633 * q + 4095 * re + 1574 * re * q)))), s = Vt(this.long0 + X * (1 - ae / 6 * (1 + 2 * q + z - ae / 20 * (5 + 28 * q + 24 * re + 8 * z * q + 6 * z - ae / 42 * (61 + 662 * q + 1320 * re + 720 * re * q)))) / I);
    } else
      o = ft * $d(a), s = 0;
  else {
    var m = Math.exp(h / this.k0), g = 0.5 * (m - 1 / m), b = this.lat0 + a / this.k0, T = Math.cos(b);
    e = Math.sqrt((1 - Math.pow(T, 2)) / (1 + Math.pow(g, 2))), o = Math.asin(e), a < 0 && (o = -o), g === 0 && T === 0 ? s = 0 : s = Vt(Math.atan2(g, T) + this.long0);
  }
  return t.x = s, t.y = o, t;
}
var kN = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const sg = {
  init: CN,
  forward: AN,
  inverse: PN,
  names: kN
};
function PT(t) {
  var e = Math.exp(t);
  return e = (e - 1 / e) / 2, e;
}
function is(t, e) {
  t = Math.abs(t), e = Math.abs(e);
  var n = Math.max(t, e), o = Math.min(t, e) / (n || 1);
  return n * Math.sqrt(1 + Math.pow(o, 2));
}
function LN(t) {
  var e = 1 + t, n = e - 1;
  return n === 0 ? t : t * Math.log(e) / n;
}
function DN(t) {
  var e = Math.abs(t);
  return e = LN(e * (1 + e / (is(1, e) + 1))), t < 0 ? -e : e;
}
function G1(t, e) {
  for (var n = 2 * Math.cos(2 * e), o = t.length - 1, s = t[o], h = 0, a; --o >= 0; )
    a = -h + n * s + t[o], h = s, s = a;
  return e + a * Math.sin(2 * e);
}
function NN(t, e) {
  for (var n = 2 * Math.cos(e), o = t.length - 1, s = t[o], h = 0, a; --o >= 0; )
    a = -h + n * s + t[o], h = s, s = a;
  return Math.sin(e) * a;
}
function RN(t) {
  var e = Math.exp(t);
  return e = (e + 1 / e) / 2, e;
}
function kT(t, e, n) {
  for (var o = Math.sin(e), s = Math.cos(e), h = PT(n), a = RN(n), m = 2 * s * a, g = -2 * o * h, b = t.length - 1, T = t[b], M = 0, I = 0, P = 0, z, V; --b >= 0; )
    z = I, V = M, I = T, M = P, T = -z + m * I - g * M + t[b], P = -V + g * I + m * M;
  return m = o * a, g = s * h, [m * T - g * P, m * P + g * T];
}
function zN() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (sg.init.apply(this), this.forward = sg.forward, this.inverse = sg.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var t = this.es / (1 + Math.sqrt(1 - this.es)), e = t / (2 - t), n = e;
  this.cgb[0] = e * (2 + e * (-2 / 3 + e * (-2 + e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675)))))), this.cbg[0] = e * (-2 + e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725)))))), n = n * e, this.cgb[1] = n * (7 / 3 + e * (-8 / 5 + e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))))), this.cbg[1] = n * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), n = n * e, this.cgb[2] = n * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = n * (-26 / 15 + e * (34 / 21 + e * (8 / 5 + e * (-12686 / 2835)))), n = n * e, this.cgb[3] = n * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = n * (1237 / 630 + e * (-12 / 5 + e * (-24832 / 14175))), n = n * e, this.cgb[4] = n * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = n * (-734 / 315 + e * (109598 / 31185)), n = n * e, this.cgb[5] = n * (601676 / 22275), this.cbg[5] = n * (444337 / 155925), n = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + n * (1 / 4 + n * (1 / 64 + n / 256))), this.utg[0] = e * (-0.5 + e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800)))))), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = n * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = n * (13 / 48 + e * (-3 / 5 + e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))))), n = n * e, this.utg[2] = n * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = n * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), n = n * e, this.utg[3] = n * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = n * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), n = n * e, this.utg[4] = n * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = n * (34729 / 80640 + e * (-3418889 / 1995840)), n = n * e, this.utg[5] = n * (-20648693 / 638668800), this.gtu[5] = n * (212378941 / 319334400);
  var o = G1(this.cbg, this.lat0);
  this.Zb = -this.Qn * (o + NN(this.gtu, 2 * o));
}
function FN(t) {
  var e = Vt(t.x - this.long0), n = t.y;
  n = G1(this.cbg, n);
  var o = Math.sin(n), s = Math.cos(n), h = Math.sin(e), a = Math.cos(e);
  n = Math.atan2(o, a * s), e = Math.atan2(h * s, is(o, s * a)), e = DN(Math.tan(e));
  var m = kT(this.gtu, 2 * n, 2 * e);
  n = n + m[0], e = e + m[1];
  var g, b;
  return Math.abs(e) <= 2.623395162778 ? (g = this.a * (this.Qn * e) + this.x0, b = this.a * (this.Qn * n + this.Zb) + this.y0) : (g = 1 / 0, b = 1 / 0), t.x = g, t.y = b, t;
}
function BN(t) {
  var e = (t.x - this.x0) * (1 / this.a), n = (t.y - this.y0) * (1 / this.a);
  n = (n - this.Zb) / this.Qn, e = e / this.Qn;
  var o, s;
  if (Math.abs(e) <= 2.623395162778) {
    var h = kT(this.utg, 2 * n, 2 * e);
    n = n + h[0], e = e + h[1], e = Math.atan(PT(e));
    var a = Math.sin(n), m = Math.cos(n), g = Math.sin(e), b = Math.cos(e);
    n = Math.atan2(a * b, is(g, b * m)), e = Math.atan2(g, b * m), o = Vt(e + this.long0), s = G1(this.cgb, n);
  } else
    o = 1 / 0, s = 1 / 0;
  return t.x = o, t.y = s, t;
}
var VN = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
const lg = {
  init: zN,
  forward: FN,
  inverse: BN,
  names: VN
};
function UN(t, e) {
  if (t === void 0) {
    if (t = Math.floor((Vt(e) + Math.PI) * 30 / Math.PI) + 1, t < 0)
      return 0;
    if (t > 60)
      return 60;
  }
  return t;
}
var jN = "etmerc";
function GN() {
  var t = UN(this.zone, this.long0);
  if (t === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(t) - 183) * io, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, lg.init.apply(this), this.forward = lg.forward, this.inverse = lg.inverse;
}
var $N = ["Universal Transverse Mercator System", "utm"];
const qN = {
  init: GN,
  names: $N,
  dependsOn: jN
};
function $1(t, e) {
  return Math.pow((1 - t) / (1 + t), e);
}
var WN = 20;
function HN() {
  var t = Math.sin(this.lat0), e = Math.cos(this.lat0);
  e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(t / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + ln) / (Math.pow(Math.tan(0.5 * this.lat0 + ln), this.C) * $1(this.e * t, this.ratexp));
}
function ZN(t) {
  var e = t.x, n = t.y;
  return t.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * n + ln), this.C) * $1(this.e * Math.sin(n), this.ratexp)) - ft, t.x = this.C * e, t;
}
function XN(t) {
  for (var e = 1e-14, n = t.x / this.C, o = t.y, s = Math.pow(Math.tan(0.5 * o + ln) / this.K, 1 / this.C), h = WN; h > 0 && (o = 2 * Math.atan(s * $1(this.e * Math.sin(t.y), -0.5 * this.e)) - ft, !(Math.abs(o - t.y) < e)); --h)
    t.y = o;
  return h ? (t.x = n, t.y = o, t) : null;
}
var KN = ["gauss"];
const q1 = {
  init: HN,
  forward: ZN,
  inverse: XN,
  names: KN
};
function YN() {
  q1.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function JN(t) {
  var e, n, o, s;
  return t.x = Vt(t.x - this.long0), q1.forward.apply(this, [t]), e = Math.sin(t.y), n = Math.cos(t.y), o = Math.cos(t.x), s = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * n * o), t.x = s * n * Math.sin(t.x), t.y = s * (this.cosc0 * e - this.sinc0 * n * o), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
}
function QN(t) {
  var e, n, o, s, h;
  if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, h = Math.sqrt(t.x * t.x + t.y * t.y)) {
    var a = 2 * Math.atan2(h, this.R2);
    e = Math.sin(a), n = Math.cos(a), s = Math.asin(n * this.sinc0 + t.y * e * this.cosc0 / h), o = Math.atan2(t.x * e, h * this.cosc0 * n - t.y * this.sinc0 * e);
  } else
    s = this.phic0, o = 0;
  return t.x = o, t.y = s, q1.inverse.apply(this, [t]), t.x = Vt(t.x + this.long0), t;
}
var e3 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const t3 = {
  init: YN,
  forward: JN,
  inverse: QN,
  names: e3
};
function r3(t, e, n) {
  return e *= n, Math.tan(0.5 * (ft + t)) * Math.pow((1 - e) / (1 + e), 0.5 * n);
}
function n3() {
  this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Ct && (this.k0 = 0.5 * (1 + $d(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= Ct && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Ct && (this.k0 = 0.5 * this.cons * el(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / us(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = el(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - ft, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function i3(t) {
  var e = t.x, n = t.y, o = Math.sin(n), s = Math.cos(n), h, a, m, g, b, T, M = Vt(e - this.long0);
  return Math.abs(Math.abs(e - this.long0) - Math.PI) <= Ct && Math.abs(n + this.lat0) <= Ct ? (t.x = NaN, t.y = NaN, t) : this.sphere ? (h = 2 * this.k0 / (1 + this.sinlat0 * o + this.coslat0 * s * Math.cos(M)), t.x = this.a * h * s * Math.sin(M) + this.x0, t.y = this.a * h * (this.coslat0 * o - this.sinlat0 * s * Math.cos(M)) + this.y0, t) : (a = 2 * Math.atan(this.ssfn_(n, o, this.e)) - ft, g = Math.cos(a), m = Math.sin(a), Math.abs(this.coslat0) <= Ct ? (b = us(this.e, n * this.con, this.con * o), T = 2 * this.a * this.k0 * b / this.cons, t.x = this.x0 + T * Math.sin(e - this.long0), t.y = this.y0 - this.con * T * Math.cos(e - this.long0), t) : (Math.abs(this.sinlat0) < Ct ? (h = 2 * this.a * this.k0 / (1 + g * Math.cos(M)), t.y = h * m) : (h = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * m + this.cosX0 * g * Math.cos(M))), t.y = h * (this.cosX0 * m - this.sinX0 * g * Math.cos(M)) + this.y0), t.x = h * g * Math.sin(M) + this.x0, t));
}
function o3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n, o, s, h, a = Math.sqrt(t.x * t.x + t.y * t.y);
  if (this.sphere) {
    var m = 2 * Math.atan(a / (2 * this.a * this.k0));
    return e = this.long0, n = this.lat0, a <= Ct ? (t.x = e, t.y = n, t) : (n = Math.asin(Math.cos(m) * this.sinlat0 + t.y * Math.sin(m) * this.coslat0 / a), Math.abs(this.coslat0) < Ct ? this.lat0 > 0 ? e = Vt(this.long0 + Math.atan2(t.x, -1 * t.y)) : e = Vt(this.long0 + Math.atan2(t.x, t.y)) : e = Vt(this.long0 + Math.atan2(t.x * Math.sin(m), a * this.coslat0 * Math.cos(m) - t.y * this.sinlat0 * Math.sin(m))), t.x = e, t.y = n, t);
  } else if (Math.abs(this.coslat0) <= Ct) {
    if (a <= Ct)
      return n = this.lat0, e = this.long0, t.x = e, t.y = n, t;
    t.x *= this.con, t.y *= this.con, o = a * this.cons / (2 * this.a * this.k0), n = this.con * Dd(this.e, o), e = this.con * Vt(this.con * this.long0 + Math.atan2(t.x, -1 * t.y));
  } else
    s = 2 * Math.atan(a * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, a <= Ct ? h = this.X0 : (h = Math.asin(Math.cos(s) * this.sinX0 + t.y * Math.sin(s) * this.cosX0 / a), e = Vt(this.long0 + Math.atan2(t.x * Math.sin(s), a * this.cosX0 * Math.cos(s) - t.y * this.sinX0 * Math.sin(s)))), n = -1 * Dd(this.e, Math.tan(0.5 * (ft + h)));
  return t.x = e, t.y = n, t;
}
var a3 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
const s3 = {
  init: n3,
  forward: i3,
  inverse: o3,
  names: a3,
  ssfn_: r3
};
function l3() {
  var t = this.lat0;
  this.lambda0 = this.long0;
  var e = Math.sin(t), n = this.a, o = this.rf, s = 1 / o, h = 2 * s - Math.pow(s, 2), a = this.e = Math.sqrt(h);
  this.R = this.k0 * n * Math.sqrt(1 - h) / (1 - h * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + h / (1 - h) * Math.pow(Math.cos(t), 4)), this.b0 = Math.asin(e / this.alpha);
  var m = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), g = Math.log(Math.tan(Math.PI / 4 + t / 2)), b = Math.log((1 + a * e) / (1 - a * e));
  this.K = m - this.alpha * g + this.alpha * a / 2 * b;
}
function u3(t) {
  var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)), n = this.e / 2 * Math.log((1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))), o = -this.alpha * (e + n) + this.K, s = 2 * (Math.atan(Math.exp(o)) - Math.PI / 4), h = this.alpha * (t.x - this.lambda0), a = Math.atan(Math.sin(h) / (Math.sin(this.b0) * Math.tan(s) + Math.cos(this.b0) * Math.cos(h))), m = Math.asin(Math.cos(this.b0) * Math.sin(s) - Math.sin(this.b0) * Math.cos(s) * Math.cos(h));
  return t.y = this.R / 2 * Math.log((1 + Math.sin(m)) / (1 - Math.sin(m))) + this.y0, t.x = this.R * a + this.x0, t;
}
function c3(t) {
  for (var e = t.x - this.x0, n = t.y - this.y0, o = e / this.R, s = 2 * (Math.atan(Math.exp(n / this.R)) - Math.PI / 4), h = Math.asin(Math.cos(this.b0) * Math.sin(s) + Math.sin(this.b0) * Math.cos(s) * Math.cos(o)), a = Math.atan(Math.sin(o) / (Math.cos(this.b0) * Math.cos(o) - Math.sin(this.b0) * Math.tan(s))), m = this.lambda0 + a / this.alpha, g = 0, b = h, T = -1e3, M = 0; Math.abs(b - T) > 1e-7; ) {
    if (++M > 20)
      return;
    g = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + h / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(b)) / 2)), T = b, b = 2 * Math.atan(Math.exp(g)) - Math.PI / 2;
  }
  return t.x = m, t.y = b, t;
}
var h3 = ["somerc"];
const f3 = {
  init: l3,
  forward: u3,
  inverse: c3,
  names: h3
};
var ff = 1e-7;
function p3(t) {
  var e = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], n = typeof t.PROJECTION == "object" ? Object.keys(t.PROJECTION)[0] : t.PROJECTION;
  return "no_uoff" in t || "no_off" in t || e.indexOf(n) !== -1;
}
function d3() {
  var t, e, n, o, s, h, a, m, g, b, T = 0, M, I = 0, P = 0, z = 0, V = 0, q = 0, re = 0;
  this.no_off = p3(this), this.no_rot = "no_rot" in this;
  var X = !1;
  "alpha" in this && (X = !0);
  var ae = !1;
  if ("rectified_grid_angle" in this && (ae = !0), X && (re = this.alpha), ae && (T = this.rectified_grid_angle * io), X || ae)
    I = this.longc;
  else if (P = this.long1, V = this.lat1, z = this.long2, q = this.lat2, Math.abs(V - q) <= ff || (t = Math.abs(V)) <= ff || Math.abs(t - ft) <= ff || Math.abs(Math.abs(this.lat0) - ft) <= ff || Math.abs(Math.abs(q) - ft) <= ff)
    throw new Error();
  var ce = 1 - this.es;
  e = Math.sqrt(ce), Math.abs(this.lat0) > Ct ? (m = Math.sin(this.lat0), n = Math.cos(this.lat0), t = 1 - this.es * m * m, this.B = n * n, this.B = Math.sqrt(1 + this.es * this.B * this.B / ce), this.A = this.B * this.k0 * e / t, o = this.B * e / (n * Math.sqrt(t)), s = o * o - 1, s <= 0 ? s = 0 : (s = Math.sqrt(s), this.lat0 < 0 && (s = -s)), this.E = s += o, this.E *= Math.pow(us(this.e, this.lat0, m), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = o = s = 1), X || ae ? (X ? (M = Math.asin(Math.sin(re) / o), ae || (T = re)) : (M = T, re = Math.asin(o * Math.sin(M))), this.lam0 = I - Math.asin(0.5 * (s - 1 / s) * Math.tan(M)) / this.B) : (h = Math.pow(us(this.e, V, Math.sin(V)), this.B), a = Math.pow(us(this.e, q, Math.sin(q)), this.B), s = this.E / h, g = (a - h) / (a + h), b = this.E * this.E, b = (b - a * h) / (b + a * h), t = P - z, t < -Math.pi ? z -= kd : t > Math.pi && (z += kd), this.lam0 = Vt(0.5 * (P + z) - Math.atan(b * Math.tan(0.5 * this.B * (P - z)) / g) / this.B), M = Math.atan(2 * Math.sin(this.B * Vt(P - this.lam0)) / (s - 1 / s)), T = re = Math.asin(o * Math.sin(M))), this.singam = Math.sin(M), this.cosgam = Math.cos(M), this.sinrot = Math.sin(T), this.cosrot = Math.cos(T), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(o * o - 1) / Math.cos(re))), this.lat0 < 0 && (this.u_0 = -this.u_0)), s = 0.5 * M, this.v_pole_n = this.ArB * Math.log(Math.tan(ln - s)), this.v_pole_s = this.ArB * Math.log(Math.tan(ln + s));
}
function m3(t) {
  var e = {}, n, o, s, h, a, m, g, b;
  if (t.x = t.x - this.lam0, Math.abs(Math.abs(t.y) - ft) > Ct) {
    if (a = this.E / Math.pow(us(this.e, t.y, Math.sin(t.y)), this.B), m = 1 / a, n = 0.5 * (a - m), o = 0.5 * (a + m), h = Math.sin(this.B * t.x), s = (n * this.singam - h * this.cosgam) / o, Math.abs(Math.abs(s) - 1) < Ct)
      throw new Error();
    b = 0.5 * this.ArB * Math.log((1 - s) / (1 + s)), m = Math.cos(this.B * t.x), Math.abs(m) < ff ? g = this.A * t.x : g = this.ArB * Math.atan2(n * this.cosgam + h * this.singam, m);
  } else
    b = t.y > 0 ? this.v_pole_n : this.v_pole_s, g = this.ArB * t.y;
  return this.no_rot ? (e.x = g, e.y = b) : (g -= this.u_0, e.x = b * this.cosrot + g * this.sinrot, e.y = g * this.cosrot - b * this.sinrot), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function y3(t) {
  var e, n, o, s, h, a, m, g = {};
  if (t.x = (t.x - this.x0) * (1 / this.a), t.y = (t.y - this.y0) * (1 / this.a), this.no_rot ? (n = t.y, e = t.x) : (n = t.x * this.cosrot - t.y * this.sinrot, e = t.y * this.cosrot + t.x * this.sinrot + this.u_0), o = Math.exp(-this.BrA * n), s = 0.5 * (o - 1 / o), h = 0.5 * (o + 1 / o), a = Math.sin(this.BrA * e), m = (a * this.cosgam + s * this.singam) / h, Math.abs(Math.abs(m) - 1) < Ct)
    g.x = 0, g.y = m < 0 ? -ft : ft;
  else {
    if (g.y = this.E / Math.sqrt((1 + m) / (1 - m)), g.y = Dd(this.e, Math.pow(g.y, 1 / this.B)), g.y === 1 / 0)
      throw new Error();
    g.x = -this.rB * Math.atan2(s * this.cosgam - a * this.singam, Math.cos(this.BrA * e));
  }
  return g.x += this.lam0, g;
}
var g3 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const v3 = {
  init: d3,
  forward: m3,
  inverse: y3,
  names: g3
};
function _3() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < Ct)) {
    var t = this.b / this.a;
    this.e = Math.sqrt(1 - t * t);
    var e = Math.sin(this.lat1), n = Math.cos(this.lat1), o = el(this.e, e, n), s = us(this.e, this.lat1, e), h = Math.sin(this.lat2), a = Math.cos(this.lat2), m = el(this.e, h, a), g = us(this.e, this.lat2, h), b = us(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > Ct ? this.ns = Math.log(o / m) / Math.log(s / g) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = o / (this.ns * Math.pow(s, this.ns)), this.rh = this.a * this.f0 * Math.pow(b, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function x3(t) {
  var e = t.x, n = t.y;
  Math.abs(2 * Math.abs(n) - Math.PI) <= Ct && (n = $d(n) * (ft - 2 * Ct));
  var o = Math.abs(Math.abs(n) - ft), s, h;
  if (o > Ct)
    s = us(this.e, n, Math.sin(n)), h = this.a * this.f0 * Math.pow(s, this.ns);
  else {
    if (o = n * this.ns, o <= 0)
      return null;
    h = 0;
  }
  var a = this.ns * Vt(e - this.long0);
  return t.x = this.k0 * (h * Math.sin(a)) + this.x0, t.y = this.k0 * (this.rh - h * Math.cos(a)) + this.y0, t;
}
function b3(t) {
  var e, n, o, s, h, a = (t.x - this.x0) / this.k0, m = this.rh - (t.y - this.y0) / this.k0;
  this.ns > 0 ? (e = Math.sqrt(a * a + m * m), n = 1) : (e = -Math.sqrt(a * a + m * m), n = -1);
  var g = 0;
  if (e !== 0 && (g = Math.atan2(n * a, n * m)), e !== 0 || this.ns > 0) {
    if (n = 1 / this.ns, o = Math.pow(e / (this.a * this.f0), n), s = Dd(this.e, o), s === -9999)
      return null;
  } else
    s = -ft;
  return h = Vt(g / this.ns + this.long0), t.x = h, t.y = s, t;
}
var w3 = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const E3 = {
  init: _3,
  forward: x3,
  inverse: b3,
  names: w3
};
function S3() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function T3(t) {
  var e, n, o, s, h, a, m, g = t.x, b = t.y, T = Vt(g - this.long0);
  return e = Math.pow((1 + this.e * Math.sin(b)) / (1 - this.e * Math.sin(b)), this.alfa * this.e / 2), n = 2 * (Math.atan(this.k * Math.pow(Math.tan(b / 2 + this.s45), this.alfa) / e) - this.s45), o = -T * this.alfa, s = Math.asin(Math.cos(this.ad) * Math.sin(n) + Math.sin(this.ad) * Math.cos(n) * Math.cos(o)), h = Math.asin(Math.cos(n) * Math.sin(o) / Math.cos(s)), a = this.n * h, m = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n), t.y = m * Math.cos(a) / 1, t.x = m * Math.sin(a) / 1, this.czech || (t.y *= -1, t.x *= -1), t;
}
function M3(t) {
  var e, n, o, s, h, a, m, g, b = t.x;
  t.x = t.y, t.y = b, this.czech || (t.y *= -1, t.x *= -1), a = Math.sqrt(t.x * t.x + t.y * t.y), h = Math.atan2(t.y, t.x), s = h / Math.sin(this.s0), o = 2 * (Math.atan(Math.pow(this.ro0 / a, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(o) - Math.sin(this.ad) * Math.cos(o) * Math.cos(s)), n = Math.asin(Math.cos(o) * Math.sin(s) / Math.cos(e)), t.x = this.long0 - n / this.alfa, m = e, g = 0;
  var T = 0;
  do
    t.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(m)) / (1 - this.e * Math.sin(m)), this.e / 2)) - this.s45), Math.abs(m - t.y) < 1e-10 && (g = 1), m = t.y, T += 1;
  while (g === 0 && T < 15);
  return T >= 15 ? null : t;
}
var I3 = ["Krovak", "krovak"];
const O3 = {
  init: S3,
  forward: T3,
  inverse: M3,
  names: I3
};
function zo(t, e, n, o, s) {
  return t * s - e * Math.sin(2 * s) + n * Math.sin(4 * s) - o * Math.sin(6 * s);
}
function qd(t) {
  return 1 - 0.25 * t * (1 + t / 16 * (3 + 1.25 * t));
}
function Wd(t) {
  return 0.375 * t * (1 + 0.25 * t * (1 + 0.46875 * t));
}
function Hd(t) {
  return 0.05859375 * t * t * (1 + 0.75 * t);
}
function Zd(t) {
  return t * t * t * (35 / 3072);
}
function Rf(t, e, n) {
  var o = e * n;
  return t / Math.sqrt(1 - o * o);
}
function Bf(t) {
  return Math.abs(t) < ft ? t : t - $d(t) * Math.PI;
}
function Ng(t, e, n, o, s) {
  var h, a;
  h = t / e;
  for (var m = 0; m < 15; m++)
    if (a = (t - (e * h - n * Math.sin(2 * h) + o * Math.sin(4 * h) - s * Math.sin(6 * h))) / (e - 2 * n * Math.cos(2 * h) + 4 * o * Math.cos(4 * h) - 6 * s * Math.cos(6 * h)), h += a, Math.abs(a) <= 1e-10)
      return h;
  return NaN;
}
function C3() {
  this.sphere || (this.e0 = qd(this.es), this.e1 = Wd(this.es), this.e2 = Hd(this.es), this.e3 = Zd(this.es), this.ml0 = this.a * zo(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function A3(t) {
  var e, n, o = t.x, s = t.y;
  if (o = Vt(o - this.long0), this.sphere)
    e = this.a * Math.asin(Math.cos(s) * Math.sin(o)), n = this.a * (Math.atan2(Math.tan(s), Math.cos(o)) - this.lat0);
  else {
    var h = Math.sin(s), a = Math.cos(s), m = Rf(this.a, this.e, h), g = Math.tan(s) * Math.tan(s), b = o * Math.cos(s), T = b * b, M = this.es * a * a / (1 - this.es), I = this.a * zo(this.e0, this.e1, this.e2, this.e3, s);
    e = m * b * (1 - T * g * (1 / 6 - (8 - g + 8 * M) * T / 120)), n = I - this.ml0 + m * h / a * T * (0.5 + (5 - g + 6 * M) * T / 24);
  }
  return t.x = e + this.x0, t.y = n + this.y0, t;
}
function P3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = t.x / this.a, n = t.y / this.a, o, s;
  if (this.sphere) {
    var h = n + this.lat0;
    o = Math.asin(Math.sin(h) * Math.cos(e)), s = Math.atan2(Math.tan(e), Math.cos(h));
  } else {
    var a = this.ml0 / this.a + n, m = Ng(a, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(m) - ft) <= Ct)
      return t.x = this.long0, t.y = ft, n < 0 && (t.y *= -1), t;
    var g = Rf(this.a, this.e, Math.sin(m)), b = g * g * g / this.a / this.a * (1 - this.es), T = Math.pow(Math.tan(m), 2), M = e * this.a / g, I = M * M;
    o = m - g * Math.tan(m) / b * M * M * (0.5 - (1 + 3 * T) * M * M / 24), s = M * (1 - I * (T / 3 + (1 + 3 * T) * T * I / 15)) / Math.cos(m);
  }
  return t.x = Vt(s + this.long0), t.y = Bf(o), t;
}
var k3 = ["Cassini", "Cassini_Soldner", "cass"];
const L3 = {
  init: C3,
  forward: A3,
  inverse: P3,
  names: k3
};
function ku(t, e) {
  var n;
  return t > 1e-7 ? (n = t * e, (1 - t * t) * (e / (1 - n * n) - 0.5 / t * Math.log((1 - n) / (1 + n)))) : 2 * e;
}
var D3 = 1, N3 = 2, R3 = 3, z3 = 4;
function F3() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - ft) < Ct ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(t) < Ct ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
    var e;
    switch (this.qp = ku(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = H3(this.es), this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = ku(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function B3(t) {
  var e, n, o, s, h, a, m, g, b, T, M = t.x, I = t.y;
  if (M = Vt(M - this.long0), this.sphere) {
    if (h = Math.sin(I), T = Math.cos(I), o = Math.cos(M), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (n = this.mode === this.EQUIT ? 1 + T * o : 1 + this.sinph0 * h + this.cosph0 * T * o, n <= Ct)
        return null;
      n = Math.sqrt(2 / n), e = n * T * Math.sin(M), n *= this.mode === this.EQUIT ? h : this.cosph0 * h - this.sinph0 * T * o;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (o = -o), Math.abs(I + this.lat0) < Ct)
        return null;
      n = ln - I * 0.5, n = 2 * (this.mode === this.S_POLE ? Math.cos(n) : Math.sin(n)), e = n * Math.sin(M), n *= o;
    }
  } else {
    switch (m = 0, g = 0, b = 0, o = Math.cos(M), s = Math.sin(M), h = Math.sin(I), a = ku(this.e, h), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (m = a / this.qp, g = Math.sqrt(1 - m * m)), this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * m + this.cosb1 * g * o;
        break;
      case this.EQUIT:
        b = 1 + g * o;
        break;
      case this.N_POLE:
        b = ft + I, a = this.qp - a;
        break;
      case this.S_POLE:
        b = I - ft, a = this.qp + a;
        break;
    }
    if (Math.abs(b) < Ct)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b), this.mode === this.OBLIQ ? n = this.ymf * b * (this.cosb1 * m - this.sinb1 * g * o) : n = (b = Math.sqrt(2 / (1 + g * o))) * m * this.ymf, e = this.xmf * b * g * s;
        break;
      case this.N_POLE:
      case this.S_POLE:
        a >= 0 ? (e = (b = Math.sqrt(a)) * s, n = o * (this.mode === this.S_POLE ? b : -b)) : e = n = 0;
        break;
    }
  }
  return t.x = this.a * e + this.x0, t.y = this.a * n + this.y0, t;
}
function V3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = t.x / this.a, n = t.y / this.a, o, s, h, a, m, g, b;
  if (this.sphere) {
    var T = 0, M, I = 0;
    if (M = Math.sqrt(e * e + n * n), s = M * 0.5, s > 1)
      return null;
    switch (s = 2 * Math.asin(s), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (I = Math.sin(s), T = Math.cos(s)), this.mode) {
      case this.EQUIT:
        s = Math.abs(M) <= Ct ? 0 : Math.asin(n * I / M), e *= I, n = T * M;
        break;
      case this.OBLIQ:
        s = Math.abs(M) <= Ct ? this.lat0 : Math.asin(T * this.sinph0 + n * I * this.cosph0 / M), e *= I * this.cosph0, n = (T - Math.sin(s) * this.sinph0) * M;
        break;
      case this.N_POLE:
        n = -n, s = ft - s;
        break;
      case this.S_POLE:
        s -= ft;
        break;
    }
    o = n === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(e, n);
  } else {
    if (b = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (e /= this.dd, n *= this.dd, g = Math.sqrt(e * e + n * n), g < Ct)
        return t.x = this.long0, t.y = this.lat0, t;
      a = 2 * Math.asin(0.5 * g / this.rq), h = Math.cos(a), e *= a = Math.sin(a), this.mode === this.OBLIQ ? (b = h * this.sinb1 + n * a * this.cosb1 / g, m = this.qp * b, n = g * this.cosb1 * h - n * this.sinb1 * a) : (b = n * a / g, m = this.qp * b, n = g * h);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), m = e * e + n * n, !m)
        return t.x = this.long0, t.y = this.lat0, t;
      b = 1 - m / this.qp, this.mode === this.S_POLE && (b = -b);
    }
    o = Math.atan2(e, n), s = Z3(Math.asin(b), this.apa);
  }
  return t.x = Vt(this.long0 + o), t.y = s, t;
}
var U3 = 0.3333333333333333, j3 = 0.17222222222222222, G3 = 0.10257936507936508, $3 = 0.06388888888888888, q3 = 0.0664021164021164, W3 = 0.016415012942191543;
function H3(t) {
  var e, n = [];
  return n[0] = t * U3, e = t * t, n[0] += e * j3, n[1] = e * $3, e *= t, n[0] += e * G3, n[1] += e * q3, n[2] = e * W3, n;
}
function Z3(t, e) {
  var n = t + t;
  return t + e[0] * Math.sin(n) + e[1] * Math.sin(n + n) + e[2] * Math.sin(n + n + n);
}
var X3 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const K3 = {
  init: F3,
  forward: B3,
  inverse: V3,
  names: X3,
  S_POLE: D3,
  N_POLE: N3,
  EQUIT: R3,
  OBLIQ: z3
};
function Fu(t) {
  return Math.abs(t) > 1 && (t = t > 1 ? 1 : -1), Math.asin(t);
}
function Y3() {
  Math.abs(this.lat1 + this.lat2) < Ct || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = el(this.e3, this.sin_po, this.cos_po), this.qs1 = ku(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = el(this.e3, this.sin_po, this.cos_po), this.qs2 = ku(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = ku(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > Ct ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function J3(t) {
  var e = t.x, n = t.y;
  this.sin_phi = Math.sin(n), this.cos_phi = Math.cos(n);
  var o = ku(this.e3, this.sin_phi), s = this.a * Math.sqrt(this.c - this.ns0 * o) / this.ns0, h = this.ns0 * Vt(e - this.long0), a = s * Math.sin(h) + this.x0, m = this.rh - s * Math.cos(h) + this.y0;
  return t.x = a, t.y = m, t;
}
function Q3(t) {
  var e, n, o, s, h, a;
  return t.x -= this.x0, t.y = this.rh - t.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(t.x * t.x + t.y * t.y), o = 1) : (e = -Math.sqrt(t.x * t.x + t.y * t.y), o = -1), s = 0, e !== 0 && (s = Math.atan2(o * t.x, o * t.y)), o = e * this.ns0 / this.a, this.sphere ? a = Math.asin((this.c - o * o) / (2 * this.ns0)) : (n = (this.c - o * o) / this.ns0, a = this.phi1z(this.e3, n)), h = Vt(s / this.ns0 + this.long0), t.x = h, t.y = a, t;
}
function eR(t, e) {
  var n, o, s, h, a, m = Fu(0.5 * e);
  if (t < Ct)
    return m;
  for (var g = t * t, b = 1; b <= 25; b++)
    if (n = Math.sin(m), o = Math.cos(m), s = t * n, h = 1 - s * s, a = 0.5 * h * h / o * (e / (1 - g) - n / h + 0.5 / t * Math.log((1 - s) / (1 + s))), m = m + a, Math.abs(a) <= 1e-7)
      return m;
  return null;
}
var tR = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const rR = {
  init: Y3,
  forward: J3,
  inverse: Q3,
  names: tR,
  phi1z: eR
};
function nR() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function iR(t) {
  var e, n, o, s, h, a, m, g, b = t.x, T = t.y;
  return o = Vt(b - this.long0), e = Math.sin(T), n = Math.cos(T), s = Math.cos(o), a = this.sin_p14 * e + this.cos_p14 * n * s, h = 1, a > 0 || Math.abs(a) <= Ct ? (m = this.x0 + this.a * h * n * Math.sin(o) / a, g = this.y0 + this.a * h * (this.cos_p14 * e - this.sin_p14 * n * s) / a) : (m = this.x0 + this.infinity_dist * n * Math.sin(o), g = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * n * s)), t.x = m, t.y = g, t;
}
function oR(t) {
  var e, n, o, s, h, a;
  return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, (e = Math.sqrt(t.x * t.x + t.y * t.y)) ? (s = Math.atan2(e, this.rc), n = Math.sin(s), o = Math.cos(s), a = Fu(o * this.sin_p14 + t.y * n * this.cos_p14 / e), h = Math.atan2(t.x * n, e * this.cos_p14 * o - t.y * this.sin_p14 * n), h = Vt(this.long0 + h)) : (a = this.phic0, h = 0), t.x = h, t.y = a, t;
}
var aR = ["gnom"];
const sR = {
  init: nR,
  forward: iR,
  inverse: oR,
  names: aR
};
function lR(t, e) {
  var n = 1 - (1 - t * t) / (2 * t) * Math.log((1 - t) / (1 + t));
  if (Math.abs(Math.abs(e) - n) < 1e-6)
    return e < 0 ? -1 * ft : ft;
  for (var o = Math.asin(0.5 * e), s, h, a, m, g = 0; g < 30; g++)
    if (h = Math.sin(o), a = Math.cos(o), m = t * h, s = Math.pow(1 - m * m, 2) / (2 * a) * (e / (1 - t * t) - h / (1 - m * m) + 0.5 / t * Math.log((1 - m) / (1 + m))), o += s, Math.abs(s) <= 1e-10)
      return o;
  return NaN;
}
function uR() {
  this.sphere || (this.k0 = el(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function cR(t) {
  var e = t.x, n = t.y, o, s, h = Vt(e - this.long0);
  if (this.sphere)
    o = this.x0 + this.a * h * Math.cos(this.lat_ts), s = this.y0 + this.a * Math.sin(n) / Math.cos(this.lat_ts);
  else {
    var a = ku(this.e, Math.sin(n));
    o = this.x0 + this.a * this.k0 * h, s = this.y0 + this.a * a * 0.5 / this.k0;
  }
  return t.x = o, t.y = s, t;
}
function hR(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n;
  return this.sphere ? (e = Vt(this.long0 + t.x / this.a / Math.cos(this.lat_ts)), n = Math.asin(t.y / this.a * Math.cos(this.lat_ts))) : (n = lR(this.e, 2 * t.y * this.k0 / this.a), e = Vt(this.long0 + t.x / (this.a * this.k0))), t.x = e, t.y = n, t;
}
var fR = ["cea"];
const pR = {
  init: uR,
  forward: cR,
  inverse: hR,
  names: fR
};
function dR() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function mR(t) {
  var e = t.x, n = t.y, o = Vt(e - this.long0), s = Bf(n - this.lat0);
  return t.x = this.x0 + this.a * o * this.rc, t.y = this.y0 + this.a * s, t;
}
function yR(t) {
  var e = t.x, n = t.y;
  return t.x = Vt(this.long0 + (e - this.x0) / (this.a * this.rc)), t.y = Bf(this.lat0 + (n - this.y0) / this.a), t;
}
var gR = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const vR = {
  init: dR,
  forward: mR,
  inverse: yR,
  names: gR
};
var Xw = 20;
function _R() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = qd(this.es), this.e1 = Wd(this.es), this.e2 = Hd(this.es), this.e3 = Zd(this.es), this.ml0 = this.a * zo(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function xR(t) {
  var e = t.x, n = t.y, o, s, h, a = Vt(e - this.long0);
  if (h = a * Math.sin(n), this.sphere)
    Math.abs(n) <= Ct ? (o = this.a * a, s = -1 * this.a * this.lat0) : (o = this.a * Math.sin(h) / Math.tan(n), s = this.a * (Bf(n - this.lat0) + (1 - Math.cos(h)) / Math.tan(n)));
  else if (Math.abs(n) <= Ct)
    o = this.a * a, s = -1 * this.ml0;
  else {
    var m = Rf(this.a, this.e, Math.sin(n)) / Math.tan(n);
    o = m * Math.sin(h), s = this.a * zo(this.e0, this.e1, this.e2, this.e3, n) - this.ml0 + m * (1 - Math.cos(h));
  }
  return t.x = o + this.x0, t.y = s + this.y0, t;
}
function bR(t) {
  var e, n, o, s, h, a, m, g, b;
  if (o = t.x - this.x0, s = t.y - this.y0, this.sphere)
    if (Math.abs(s + this.a * this.lat0) <= Ct)
      e = Vt(o / this.a + this.long0), n = 0;
    else {
      a = this.lat0 + s / this.a, m = o * o / this.a / this.a + a * a, g = a;
      var T;
      for (h = Xw; h; --h)
        if (T = Math.tan(g), b = -1 * (a * (g * T + 1) - g - 0.5 * (g * g + m) * T) / ((g - a) / T - 1), g += b, Math.abs(b) <= Ct) {
          n = g;
          break;
        }
      e = Vt(this.long0 + Math.asin(o * Math.tan(g) / this.a) / Math.sin(n));
    }
  else if (Math.abs(s + this.ml0) <= Ct)
    n = 0, e = Vt(this.long0 + o / this.a);
  else {
    a = (this.ml0 + s) / this.a, m = o * o / this.a / this.a + a * a, g = a;
    var M, I, P, z, V;
    for (h = Xw; h; --h)
      if (V = this.e * Math.sin(g), M = Math.sqrt(1 - V * V) * Math.tan(g), I = this.a * zo(this.e0, this.e1, this.e2, this.e3, g), P = this.e0 - 2 * this.e1 * Math.cos(2 * g) + 4 * this.e2 * Math.cos(4 * g) - 6 * this.e3 * Math.cos(6 * g), z = I / this.a, b = (a * (M * z + 1) - z - 0.5 * M * (z * z + m)) / (this.es * Math.sin(2 * g) * (z * z + m - 2 * a * z) / (4 * M) + (a - z) * (M * P - 2 / Math.sin(2 * g)) - P), g -= b, Math.abs(b) <= Ct) {
        n = g;
        break;
      }
    M = Math.sqrt(1 - this.es * Math.pow(Math.sin(n), 2)) * Math.tan(n), e = Vt(this.long0 + Math.asin(o * M / this.a) / Math.sin(n));
  }
  return t.x = e, t.y = n, t;
}
var wR = ["Polyconic", "poly"];
const ER = {
  init: _R,
  forward: xR,
  inverse: bR,
  names: wR
};
function SR() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function TR(t) {
  var e, n = t.x, o = t.y, s = o - this.lat0, h = n - this.long0, a = s / md * 1e-5, m = h, g = 1, b = 0;
  for (e = 1; e <= 10; e++)
    g = g * a, b = b + this.A[e] * g;
  var T = b, M = m, I = 1, P = 0, z, V, q = 0, re = 0;
  for (e = 1; e <= 6; e++)
    z = I * T - P * M, V = P * T + I * M, I = z, P = V, q = q + this.B_re[e] * I - this.B_im[e] * P, re = re + this.B_im[e] * I + this.B_re[e] * P;
  return t.x = re * this.a + this.x0, t.y = q * this.a + this.y0, t;
}
function MR(t) {
  var e, n = t.x, o = t.y, s = n - this.x0, h = o - this.y0, a = h / this.a, m = s / this.a, g = 1, b = 0, T, M, I = 0, P = 0;
  for (e = 1; e <= 6; e++)
    T = g * a - b * m, M = b * a + g * m, g = T, b = M, I = I + this.C_re[e] * g - this.C_im[e] * b, P = P + this.C_im[e] * g + this.C_re[e] * b;
  for (var z = 0; z < this.iterations; z++) {
    var V = I, q = P, re, X, ae = a, ce = m;
    for (e = 2; e <= 6; e++)
      re = V * I - q * P, X = q * I + V * P, V = re, q = X, ae = ae + (e - 1) * (this.B_re[e] * V - this.B_im[e] * q), ce = ce + (e - 1) * (this.B_im[e] * V + this.B_re[e] * q);
    V = 1, q = 0;
    var ve = this.B_re[1], Re = this.B_im[1];
    for (e = 2; e <= 6; e++)
      re = V * I - q * P, X = q * I + V * P, V = re, q = X, ve = ve + e * (this.B_re[e] * V - this.B_im[e] * q), Re = Re + e * (this.B_im[e] * V + this.B_re[e] * q);
    var Fe = ve * ve + Re * Re;
    I = (ae * ve + ce * Re) / Fe, P = (ce * ve - ae * Re) / Fe;
  }
  var Pe = I, Se = P, Ie = 1, Xe = 0;
  for (e = 1; e <= 9; e++)
    Ie = Ie * Pe, Xe = Xe + this.D[e] * Ie;
  var $e = this.lat0 + Xe * md * 1e5, at = this.long0 + Se;
  return t.x = at, t.y = $e, t;
}
var IR = ["New_Zealand_Map_Grid", "nzmg"];
const OR = {
  init: SR,
  forward: TR,
  inverse: MR,
  names: IR
};
function CR() {
}
function AR(t) {
  var e = t.x, n = t.y, o = Vt(e - this.long0), s = this.x0 + this.a * o, h = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + n / 2.5)) * 1.25;
  return t.x = s, t.y = h, t;
}
function PR(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = Vt(this.long0 + t.x / this.a), n = 2.5 * (Math.atan(Math.exp(0.8 * t.y / this.a)) - Math.PI / 4);
  return t.x = e, t.y = n, t;
}
var kR = ["Miller_Cylindrical", "mill"];
const LR = {
  init: CR,
  forward: AR,
  inverse: PR,
  names: kR
};
var DR = 20;
function NR() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = CT(this.es);
}
function RR(t) {
  var e, n, o = t.x, s = t.y;
  if (o = Vt(o - this.long0), this.sphere) {
    if (!this.m)
      s = this.n !== 1 ? Math.asin(this.n * Math.sin(s)) : s;
    else
      for (var h = this.n * Math.sin(s), a = DR; a; --a) {
        var m = (this.m * s + Math.sin(s) - h) / (this.m + Math.cos(s));
        if (s -= m, Math.abs(m) < Ct)
          break;
      }
    e = this.a * this.C_x * o * (this.m + Math.cos(s)), n = this.a * this.C_y * s;
  } else {
    var g = Math.sin(s), b = Math.cos(s);
    n = this.a * Mv(s, g, b, this.en), e = this.a * o * b / Math.sqrt(1 - this.es * g * g);
  }
  return t.x = e, t.y = n, t;
}
function zR(t) {
  var e, n, o, s;
  return t.x -= this.x0, o = t.x / this.a, t.y -= this.y0, e = t.y / this.a, this.sphere ? (e /= this.C_y, o = o / (this.C_x * (this.m + Math.cos(e))), this.m ? e = Fu((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = Fu(Math.sin(e) / this.n)), o = Vt(o + this.long0), e = Bf(e)) : (e = AT(t.y / this.a, this.es, this.en), s = Math.abs(e), s < ft ? (s = Math.sin(e), n = this.long0 + t.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(e)), o = Vt(n)) : s - Ct < ft && (o = this.long0)), t.x = o, t.y = e, t;
}
var FR = ["Sinusoidal", "sinu"];
const BR = {
  init: NR,
  forward: RR,
  inverse: zR,
  names: FR
};
function VR() {
}
function UR(t) {
  for (var e = t.x, n = t.y, o = Vt(e - this.long0), s = n, h = Math.PI * Math.sin(n); ; ) {
    var a = -(s + Math.sin(s) - h) / (1 + Math.cos(s));
    if (s += a, Math.abs(a) < Ct)
      break;
  }
  s /= 2, Math.PI / 2 - Math.abs(n) < Ct && (o = 0);
  var m = 0.900316316158 * this.a * o * Math.cos(s) + this.x0, g = 1.4142135623731 * this.a * Math.sin(s) + this.y0;
  return t.x = m, t.y = g, t;
}
function jR(t) {
  var e, n;
  t.x -= this.x0, t.y -= this.y0, n = t.y / (1.4142135623731 * this.a), Math.abs(n) > 0.999999999999 && (n = 0.999999999999), e = Math.asin(n);
  var o = Vt(this.long0 + t.x / (0.900316316158 * this.a * Math.cos(e)));
  o < -Math.PI && (o = -Math.PI), o > Math.PI && (o = Math.PI), n = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(n) > 1 && (n = 1);
  var s = Math.asin(n);
  return t.x = o, t.y = s, t;
}
var GR = ["Mollweide", "moll"];
const $R = {
  init: VR,
  forward: UR,
  inverse: jR,
  names: GR
};
function qR() {
  Math.abs(this.lat1 + this.lat2) < Ct || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = qd(this.es), this.e1 = Wd(this.es), this.e2 = Hd(this.es), this.e3 = Zd(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = el(this.e, this.sinphi, this.cosphi), this.ml1 = zo(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < Ct ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = el(this.e, this.sinphi, this.cosphi), this.ml2 = zo(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = zo(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function WR(t) {
  var e = t.x, n = t.y, o;
  if (this.sphere)
    o = this.a * (this.g - n);
  else {
    var s = zo(this.e0, this.e1, this.e2, this.e3, n);
    o = this.a * (this.g - s);
  }
  var h = this.ns * Vt(e - this.long0), a = this.x0 + o * Math.sin(h), m = this.y0 + this.rh - o * Math.cos(h);
  return t.x = a, t.y = m, t;
}
function HR(t) {
  t.x -= this.x0, t.y = this.rh - t.y + this.y0;
  var e, n, o, s;
  this.ns >= 0 ? (n = Math.sqrt(t.x * t.x + t.y * t.y), e = 1) : (n = -Math.sqrt(t.x * t.x + t.y * t.y), e = -1);
  var h = 0;
  if (n !== 0 && (h = Math.atan2(e * t.x, e * t.y)), this.sphere)
    return s = Vt(this.long0 + h / this.ns), o = Bf(this.g - n / this.a), t.x = s, t.y = o, t;
  var a = this.g - n / this.a;
  return o = Ng(a, this.e0, this.e1, this.e2, this.e3), s = Vt(this.long0 + h / this.ns), t.x = s, t.y = o, t;
}
var ZR = ["Equidistant_Conic", "eqdc"];
const XR = {
  init: qR,
  forward: WR,
  inverse: HR,
  names: ZR
};
function KR() {
  this.R = this.a;
}
function YR(t) {
  var e = t.x, n = t.y, o = Vt(e - this.long0), s, h;
  Math.abs(n) <= Ct && (s = this.x0 + this.R * o, h = this.y0);
  var a = Fu(2 * Math.abs(n / Math.PI));
  (Math.abs(o) <= Ct || Math.abs(Math.abs(n) - ft) <= Ct) && (s = this.x0, n >= 0 ? h = this.y0 + Math.PI * this.R * Math.tan(0.5 * a) : h = this.y0 + Math.PI * this.R * -Math.tan(0.5 * a));
  var m = 0.5 * Math.abs(Math.PI / o - o / Math.PI), g = m * m, b = Math.sin(a), T = Math.cos(a), M = T / (b + T - 1), I = M * M, P = M * (2 / b - 1), z = P * P, V = Math.PI * this.R * (m * (M - z) + Math.sqrt(g * (M - z) * (M - z) - (z + g) * (I - z))) / (z + g);
  o < 0 && (V = -V), s = this.x0 + V;
  var q = g + M;
  return V = Math.PI * this.R * (P * q - m * Math.sqrt((z + g) * (g + 1) - q * q)) / (z + g), n >= 0 ? h = this.y0 + V : h = this.y0 - V, t.x = s, t.y = h, t;
}
function JR(t) {
  var e, n, o, s, h, a, m, g, b, T, M, I, P;
  return t.x -= this.x0, t.y -= this.y0, M = Math.PI * this.R, o = t.x / M, s = t.y / M, h = o * o + s * s, a = -Math.abs(s) * (1 + h), m = a - 2 * s * s + o * o, g = -2 * a + 1 + 2 * s * s + h * h, P = s * s / g + (2 * m * m * m / g / g / g - 9 * a * m / g / g) / 27, b = (a - m * m / 3 / g) / g, T = 2 * Math.sqrt(-b / 3), M = 3 * P / b / T, Math.abs(M) > 1 && (M >= 0 ? M = 1 : M = -1), I = Math.acos(M) / 3, t.y >= 0 ? n = (-T * Math.cos(I + Math.PI / 3) - m / 3 / g) * Math.PI : n = -(-T * Math.cos(I + Math.PI / 3) - m / 3 / g) * Math.PI, Math.abs(o) < Ct ? e = this.long0 : e = Vt(this.long0 + Math.PI * (h - 1 + Math.sqrt(1 + 2 * (o * o - s * s) + h * h)) / 2 / o), t.x = e, t.y = n, t;
}
var QR = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const e4 = {
  init: KR,
  forward: YR,
  inverse: JR,
  names: QR
};
function t4() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}
function r4(t) {
  var e = t.x, n = t.y, o = Math.sin(t.y), s = Math.cos(t.y), h = Vt(e - this.long0), a, m, g, b, T, M, I, P, z, V, q, re, X, ae, ce, ve, Re, Fe, Pe, Se, Ie, Xe, $e;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= Ct ? (t.x = this.x0 + this.a * (ft - n) * Math.sin(h), t.y = this.y0 - this.a * (ft - n) * Math.cos(h), t) : Math.abs(this.sin_p12 + 1) <= Ct ? (t.x = this.x0 + this.a * (ft + n) * Math.sin(h), t.y = this.y0 + this.a * (ft + n) * Math.cos(h), t) : (Fe = this.sin_p12 * o + this.cos_p12 * s * Math.cos(h), ve = Math.acos(Fe), Re = ve ? ve / Math.sin(ve) : 1, t.x = this.x0 + this.a * Re * s * Math.sin(h), t.y = this.y0 + this.a * Re * (this.cos_p12 * o - this.sin_p12 * s * Math.cos(h)), t) : (a = qd(this.es), m = Wd(this.es), g = Hd(this.es), b = Zd(this.es), Math.abs(this.sin_p12 - 1) <= Ct ? (T = this.a * zo(a, m, g, b, ft), M = this.a * zo(a, m, g, b, n), t.x = this.x0 + (T - M) * Math.sin(h), t.y = this.y0 - (T - M) * Math.cos(h), t) : Math.abs(this.sin_p12 + 1) <= Ct ? (T = this.a * zo(a, m, g, b, ft), M = this.a * zo(a, m, g, b, n), t.x = this.x0 + (T + M) * Math.sin(h), t.y = this.y0 + (T + M) * Math.cos(h), t) : (I = o / s, P = Rf(this.a, this.e, this.sin_p12), z = Rf(this.a, this.e, o), V = Math.atan((1 - this.es) * I + this.es * P * this.sin_p12 / (z * s)), q = Math.atan2(Math.sin(h), this.cos_p12 * Math.tan(V) - this.sin_p12 * Math.cos(h)), q === 0 ? Pe = Math.asin(this.cos_p12 * Math.sin(V) - this.sin_p12 * Math.cos(V)) : Math.abs(Math.abs(q) - Math.PI) <= Ct ? Pe = -Math.asin(this.cos_p12 * Math.sin(V) - this.sin_p12 * Math.cos(V)) : Pe = Math.asin(Math.sin(h) * Math.cos(V) / Math.sin(q)), re = this.e * this.sin_p12 / Math.sqrt(1 - this.es), X = this.e * this.cos_p12 * Math.cos(q) / Math.sqrt(1 - this.es), ae = re * X, ce = X * X, Se = Pe * Pe, Ie = Se * Pe, Xe = Ie * Pe, $e = Xe * Pe, ve = P * Pe * (1 - Se * ce * (1 - ce) / 6 + Ie / 8 * ae * (1 - 2 * ce) + Xe / 120 * (ce * (4 - 7 * ce) - 3 * re * re * (1 - 7 * ce)) - $e / 48 * ae), t.x = this.x0 + ve * Math.sin(q), t.y = this.y0 + ve * Math.cos(q), t));
}
function n4(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n, o, s, h, a, m, g, b, T, M, I, P, z, V, q, re, X, ae, ce, ve, Re, Fe, Pe;
  return this.sphere ? (e = Math.sqrt(t.x * t.x + t.y * t.y), e > 2 * ft * this.a ? void 0 : (n = e / this.a, o = Math.sin(n), s = Math.cos(n), h = this.long0, Math.abs(e) <= Ct ? a = this.lat0 : (a = Fu(s * this.sin_p12 + t.y * o * this.cos_p12 / e), m = Math.abs(this.lat0) - ft, Math.abs(m) <= Ct ? this.lat0 >= 0 ? h = Vt(this.long0 + Math.atan2(t.x, -t.y)) : h = Vt(this.long0 - Math.atan2(-t.x, t.y)) : h = Vt(this.long0 + Math.atan2(t.x * o, e * this.cos_p12 * s - t.y * this.sin_p12 * o))), t.x = h, t.y = a, t)) : (g = qd(this.es), b = Wd(this.es), T = Hd(this.es), M = Zd(this.es), Math.abs(this.sin_p12 - 1) <= Ct ? (I = this.a * zo(g, b, T, M, ft), e = Math.sqrt(t.x * t.x + t.y * t.y), P = I - e, a = Ng(P / this.a, g, b, T, M), h = Vt(this.long0 + Math.atan2(t.x, -1 * t.y)), t.x = h, t.y = a, t) : Math.abs(this.sin_p12 + 1) <= Ct ? (I = this.a * zo(g, b, T, M, ft), e = Math.sqrt(t.x * t.x + t.y * t.y), P = e - I, a = Ng(P / this.a, g, b, T, M), h = Vt(this.long0 + Math.atan2(t.x, t.y)), t.x = h, t.y = a, t) : (e = Math.sqrt(t.x * t.x + t.y * t.y), q = Math.atan2(t.x, t.y), z = Rf(this.a, this.e, this.sin_p12), re = Math.cos(q), X = this.e * this.cos_p12 * re, ae = -X * X / (1 - this.es), ce = 3 * this.es * (1 - ae) * this.sin_p12 * this.cos_p12 * re / (1 - this.es), ve = e / z, Re = ve - ae * (1 + ae) * Math.pow(ve, 3) / 6 - ce * (1 + 3 * ae) * Math.pow(ve, 4) / 24, Fe = 1 - ae * Re * Re / 2 - ve * Re * Re * Re / 6, V = Math.asin(this.sin_p12 * Math.cos(Re) + this.cos_p12 * Math.sin(Re) * re), h = Vt(this.long0 + Math.asin(Math.sin(q) * Math.sin(Re) / Math.cos(V))), Pe = Math.sin(V), a = Math.atan2((Pe - this.es * Fe * this.sin_p12) * Math.tan(V), Pe * (1 - this.es)), t.x = h, t.y = a, t));
}
var i4 = ["Azimuthal_Equidistant", "aeqd"];
const o4 = {
  init: t4,
  forward: r4,
  inverse: n4,
  names: i4
};
function a4() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function s4(t) {
  var e, n, o, s, h, a, m, g, b = t.x, T = t.y;
  return o = Vt(b - this.long0), e = Math.sin(T), n = Math.cos(T), s = Math.cos(o), a = this.sin_p14 * e + this.cos_p14 * n * s, h = 1, (a > 0 || Math.abs(a) <= Ct) && (m = this.a * h * n * Math.sin(o), g = this.y0 + this.a * h * (this.cos_p14 * e - this.sin_p14 * n * s)), t.x = m, t.y = g, t;
}
function l4(t) {
  var e, n, o, s, h, a, m;
  return t.x -= this.x0, t.y -= this.y0, e = Math.sqrt(t.x * t.x + t.y * t.y), n = Fu(e / this.a), o = Math.sin(n), s = Math.cos(n), a = this.long0, Math.abs(e) <= Ct ? (m = this.lat0, t.x = a, t.y = m, t) : (m = Fu(s * this.sin_p14 + t.y * o * this.cos_p14 / e), h = Math.abs(this.lat0) - ft, Math.abs(h) <= Ct ? (this.lat0 >= 0 ? a = Vt(this.long0 + Math.atan2(t.x, -t.y)) : a = Vt(this.long0 - Math.atan2(-t.x, t.y)), t.x = a, t.y = m, t) : (a = Vt(this.long0 + Math.atan2(t.x * o, e * this.cos_p14 * s - t.y * this.sin_p14 * o)), t.x = a, t.y = m, t));
}
var u4 = ["ortho"];
const c4 = {
  init: a4,
  forward: s4,
  inverse: l4,
  names: u4
};
var ni = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, un = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function h4() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= ft - ln / 2 ? this.face = ni.TOP : this.lat0 <= -(ft - ln / 2) ? this.face = ni.BOTTOM : Math.abs(this.long0) <= ln ? this.face = ni.FRONT : Math.abs(this.long0) <= ft + ln ? this.face = this.long0 > 0 ? ni.RIGHT : ni.LEFT : this.face = ni.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function f4(t) {
  var e = { x: 0, y: 0 }, n, o, s, h, a, m, g = { value: 0 };
  if (t.x -= this.long0, this.es !== 0 ? n = Math.atan(this.one_minus_f_squared * Math.tan(t.y)) : n = t.y, o = t.x, this.face === ni.TOP)
    h = ft - n, o >= ln && o <= ft + ln ? (g.value = un.AREA_0, s = o - ft) : o > ft + ln || o <= -(ft + ln) ? (g.value = un.AREA_1, s = o > 0 ? o - wi : o + wi) : o > -(ft + ln) && o <= -ln ? (g.value = un.AREA_2, s = o + ft) : (g.value = un.AREA_3, s = o);
  else if (this.face === ni.BOTTOM)
    h = ft + n, o >= ln && o <= ft + ln ? (g.value = un.AREA_0, s = -o + ft) : o < ln && o >= -ln ? (g.value = un.AREA_1, s = -o) : o < -ln && o >= -(ft + ln) ? (g.value = un.AREA_2, s = -o - ft) : (g.value = un.AREA_3, s = o > 0 ? -o + wi : -o - wi);
  else {
    var b, T, M, I, P, z, V;
    this.face === ni.RIGHT ? o = If(o, +ft) : this.face === ni.BACK ? o = If(o, +wi) : this.face === ni.LEFT && (o = If(o, -ft)), I = Math.sin(n), P = Math.cos(n), z = Math.sin(o), V = Math.cos(o), b = P * V, T = P * z, M = I, this.face === ni.FRONT ? (h = Math.acos(b), s = Oy(h, M, T, g)) : this.face === ni.RIGHT ? (h = Math.acos(T), s = Oy(h, M, -b, g)) : this.face === ni.BACK ? (h = Math.acos(-b), s = Oy(h, M, -T, g)) : this.face === ni.LEFT ? (h = Math.acos(-T), s = Oy(h, M, b, g)) : (h = s = 0, g.value = un.AREA_0);
  }
  return m = Math.atan(12 / wi * (s + Math.acos(Math.sin(s) * Math.cos(ln)) - ft)), a = Math.sqrt((1 - Math.cos(h)) / (Math.cos(m) * Math.cos(m)) / (1 - Math.cos(Math.atan(1 / Math.cos(s))))), g.value === un.AREA_1 ? m += ft : g.value === un.AREA_2 ? m += wi : g.value === un.AREA_3 && (m += 1.5 * wi), e.x = a * Math.cos(m), e.y = a * Math.sin(m), e.x = e.x * this.a + this.x0, e.y = e.y * this.a + this.y0, t.x = e.x, t.y = e.y, t;
}
function p4(t) {
  var e = { lam: 0, phi: 0 }, n, o, s, h, a, m, g, b, T, M = { value: 0 };
  if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, o = Math.atan(Math.sqrt(t.x * t.x + t.y * t.y)), n = Math.atan2(t.y, t.x), t.x >= 0 && t.x >= Math.abs(t.y) ? M.value = un.AREA_0 : t.y >= 0 && t.y >= Math.abs(t.x) ? (M.value = un.AREA_1, n -= ft) : t.x < 0 && -t.x >= Math.abs(t.y) ? (M.value = un.AREA_2, n = n < 0 ? n + wi : n - wi) : (M.value = un.AREA_3, n += ft), T = wi / 12 * Math.tan(n), a = Math.sin(T) / (Math.cos(T) - 1 / Math.sqrt(2)), m = Math.atan(a), s = Math.cos(n), h = Math.tan(o), g = 1 - s * s * h * h * (1 - Math.cos(Math.atan(1 / Math.cos(m)))), g < -1 ? g = -1 : g > 1 && (g = 1), this.face === ni.TOP)
    b = Math.acos(g), e.phi = ft - b, M.value === un.AREA_0 ? e.lam = m + ft : M.value === un.AREA_1 ? e.lam = m < 0 ? m + wi : m - wi : M.value === un.AREA_2 ? e.lam = m - ft : e.lam = m;
  else if (this.face === ni.BOTTOM)
    b = Math.acos(g), e.phi = b - ft, M.value === un.AREA_0 ? e.lam = -m + ft : M.value === un.AREA_1 ? e.lam = -m : M.value === un.AREA_2 ? e.lam = -m - ft : e.lam = m < 0 ? -m - wi : -m + wi;
  else {
    var I, P, z;
    I = g, T = I * I, T >= 1 ? z = 0 : z = Math.sqrt(1 - T) * Math.sin(m), T += z * z, T >= 1 ? P = 0 : P = Math.sqrt(1 - T), M.value === un.AREA_1 ? (T = P, P = -z, z = T) : M.value === un.AREA_2 ? (P = -P, z = -z) : M.value === un.AREA_3 && (T = P, P = z, z = -T), this.face === ni.RIGHT ? (T = I, I = -P, P = T) : this.face === ni.BACK ? (I = -I, P = -P) : this.face === ni.LEFT && (T = I, I = P, P = -T), e.phi = Math.acos(-z) - ft, e.lam = Math.atan2(P, I), this.face === ni.RIGHT ? e.lam = If(e.lam, -ft) : this.face === ni.BACK ? e.lam = If(e.lam, -wi) : this.face === ni.LEFT && (e.lam = If(e.lam, +ft));
  }
  if (this.es !== 0) {
    var V, q, re;
    V = e.phi < 0 ? 1 : 0, q = Math.tan(e.phi), re = this.b / Math.sqrt(q * q + this.one_minus_f_squared), e.phi = Math.atan(Math.sqrt(this.a * this.a - re * re) / (this.one_minus_f * re)), V && (e.phi = -e.phi);
  }
  return e.lam += this.long0, t.x = e.lam, t.y = e.phi, t;
}
function Oy(t, e, n, o) {
  var s;
  return t < Ct ? (o.value = un.AREA_0, s = 0) : (s = Math.atan2(e, n), Math.abs(s) <= ln ? o.value = un.AREA_0 : s > ln && s <= ft + ln ? (o.value = un.AREA_1, s -= ft) : s > ft + ln || s <= -(ft + ln) ? (o.value = un.AREA_2, s = s >= 0 ? s - wi : s + wi) : (o.value = un.AREA_3, s += ft)), s;
}
function If(t, e) {
  var n = t + e;
  return n < -wi ? n += kd : n > +wi && (n -= kd), n;
}
var d4 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const m4 = {
  init: h4,
  forward: f4,
  inverse: p4,
  names: d4
};
var Y0 = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], rd = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], LT = 0.8487, DT = 1.3523, NT = qs / 5, y4 = 1 / NT, xf = 18, Rg = function(t, e) {
  return t[0] + e * (t[1] + e * (t[2] + e * t[3]));
}, g4 = function(t, e) {
  return t[1] + e * (2 * t[2] + e * 3 * t[3]);
};
function v4(t, e, n, o) {
  for (var s = e; o; --o) {
    var h = t(s);
    if (s -= h, Math.abs(h) < n)
      break;
  }
  return s;
}
function _4() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function x4(t) {
  var e = Vt(t.x - this.long0), n = Math.abs(t.y), o = Math.floor(n * NT);
  o < 0 ? o = 0 : o >= xf && (o = xf - 1), n = qs * (n - y4 * o);
  var s = {
    x: Rg(Y0[o], n) * e,
    y: Rg(rd[o], n)
  };
  return t.y < 0 && (s.y = -s.y), s.x = s.x * this.a * LT + this.x0, s.y = s.y * this.a * DT + this.y0, s;
}
function b4(t) {
  var e = {
    x: (t.x - this.x0) / (this.a * LT),
    y: Math.abs(t.y - this.y0) / (this.a * DT)
  };
  if (e.y >= 1)
    e.x /= Y0[xf][0], e.y = t.y < 0 ? -ft : ft;
  else {
    var n = Math.floor(e.y * xf);
    for (n < 0 ? n = 0 : n >= xf && (n = xf - 1); ; )
      if (rd[n][0] > e.y)
        --n;
      else if (rd[n + 1][0] <= e.y)
        ++n;
      else
        break;
    var o = rd[n], s = 5 * (e.y - o[0]) / (rd[n + 1][0] - o[0]);
    s = v4(function(h) {
      return (Rg(o, h) - e.y) / g4(o, h);
    }, s, Ct, 100), e.x /= Rg(Y0[n], s), e.y = (5 * n + s) * io, t.y < 0 && (e.y = -e.y);
  }
  return e.x = Vt(e.x + this.long0), e;
}
var w4 = ["Robinson", "robin"];
const E4 = {
  init: _4,
  forward: x4,
  inverse: b4,
  names: w4
};
function S4() {
  this.name = "geocent";
}
function T4(t) {
  var e = xT(t, this.es, this.a);
  return e;
}
function M4(t) {
  var e = bT(t, this.es, this.a, this.b);
  return e;
}
var I4 = ["Geocentric", "geocentric", "geocent", "Geocent"];
const O4 = {
  init: S4,
  forward: T4,
  inverse: M4,
  names: I4
};
var _o = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, qp = {
  h: { def: 1e5, num: !0 },
  azi: { def: 0, num: !0, degrees: !0 },
  tilt: { def: 0, num: !0, degrees: !0 },
  long0: { def: 0, num: !0 },
  lat0: { def: 0, num: !0 }
};
function C4() {
  if (Object.keys(qp).forEach(function(n) {
    if (typeof this[n] > "u")
      this[n] = qp[n].def;
    else {
      if (qp[n].num && isNaN(this[n]))
        throw new Error("Invalid parameter value, must be numeric " + n + " = " + this[n]);
      qp[n].num && (this[n] = parseFloat(this[n]));
    }
    qp[n].degrees && (this[n] = this[n] * io);
  }.bind(this)), Math.abs(Math.abs(this.lat0) - ft) < Ct ? this.mode = this.lat0 < 0 ? _o.S_POLE : _o.N_POLE : Math.abs(this.lat0) < Ct ? this.mode = _o.EQUIT : (this.mode = _o.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var t = this.tilt, e = this.azi;
  this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(t), this.sw = Math.sin(t);
}
function A4(t) {
  t.x -= this.long0;
  var e = Math.sin(t.y), n = Math.cos(t.y), o = Math.cos(t.x), s, h;
  switch (this.mode) {
    case _o.OBLIQ:
      h = this.sinph0 * e + this.cosph0 * n * o;
      break;
    case _o.EQUIT:
      h = n * o;
      break;
    case _o.S_POLE:
      h = -e;
      break;
    case _o.N_POLE:
      h = e;
      break;
  }
  switch (h = this.pn1 / (this.p - h), s = h * n * Math.sin(t.x), this.mode) {
    case _o.OBLIQ:
      h *= this.cosph0 * e - this.sinph0 * n * o;
      break;
    case _o.EQUIT:
      h *= e;
      break;
    case _o.N_POLE:
      h *= -(n * o);
      break;
    case _o.S_POLE:
      h *= n * o;
      break;
  }
  var a, m;
  return a = h * this.cg + s * this.sg, m = 1 / (a * this.sw * this.h1 + this.cw), s = (s * this.cg - h * this.sg) * this.cw * m, h = a * m, t.x = s * this.a, t.y = h * this.a, t;
}
function P4(t) {
  t.x /= this.a, t.y /= this.a;
  var e = { x: t.x, y: t.y }, n, o, s;
  s = 1 / (this.pn1 - t.y * this.sw), n = this.pn1 * t.x * s, o = this.pn1 * t.y * this.cw * s, t.x = n * this.cg + o * this.sg, t.y = o * this.cg - n * this.sg;
  var h = is(t.x, t.y);
  if (Math.abs(h) < Ct)
    e.x = 0, e.y = t.y;
  else {
    var a, m;
    switch (m = 1 - h * h * this.pfact, m = (this.p - Math.sqrt(m)) / (this.pn1 / h + h / this.pn1), a = Math.sqrt(1 - m * m), this.mode) {
      case _o.OBLIQ:
        e.y = Math.asin(a * this.sinph0 + t.y * m * this.cosph0 / h), t.y = (a - this.sinph0 * Math.sin(e.y)) * h, t.x *= m * this.cosph0;
        break;
      case _o.EQUIT:
        e.y = Math.asin(t.y * m / h), t.y = a * h, t.x *= m;
        break;
      case _o.N_POLE:
        e.y = Math.asin(a), t.y = -t.y;
        break;
      case _o.S_POLE:
        e.y = -Math.asin(a);
        break;
    }
    e.x = Math.atan2(t.x, t.y);
  }
  return t.x = e.x + this.long0, t.y = e.y, t;
}
var k4 = ["Tilted_Perspective", "tpers"];
const L4 = {
  init: C4,
  forward: A4,
  inverse: P4,
  names: k4
};
function D4() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var t = 1 - this.es, e = 1 / t;
    this.radius_p = Math.sqrt(t), this.radius_p2 = t, this.radius_p_inv2 = e, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function N4(t) {
  var e = t.x, n = t.y, o, s, h, a;
  if (e = e - this.long0, this.shape === "ellipse") {
    n = Math.atan(this.radius_p2 * Math.tan(n));
    var m = this.radius_p / is(this.radius_p * Math.cos(n), Math.sin(n));
    if (s = m * Math.cos(e) * Math.cos(n), h = m * Math.sin(e) * Math.cos(n), a = m * Math.sin(n), (this.radius_g - s) * s - h * h - a * a * this.radius_p_inv2 < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    o = this.radius_g - s, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(h / is(a, o)), t.y = this.radius_g_1 * Math.atan(a / o)) : (t.x = this.radius_g_1 * Math.atan(h / o), t.y = this.radius_g_1 * Math.atan(a / is(h, o)));
  } else
    this.shape === "sphere" && (o = Math.cos(n), s = Math.cos(e) * o, h = Math.sin(e) * o, a = Math.sin(n), o = this.radius_g - s, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(h / is(a, o)), t.y = this.radius_g_1 * Math.atan(a / o)) : (t.x = this.radius_g_1 * Math.atan(h / o), t.y = this.radius_g_1 * Math.atan(a / is(h, o))));
  return t.x = t.x * this.a, t.y = t.y * this.a, t;
}
function R4(t) {
  var e = -1, n = 0, o = 0, s, h, a, m;
  if (t.x = t.x / this.a, t.y = t.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (o = Math.tan(t.y / this.radius_g_1), n = Math.tan(t.x / this.radius_g_1) * is(1, o)) : (n = Math.tan(t.x / this.radius_g_1), o = Math.tan(t.y / this.radius_g_1) * is(1, n));
    var g = o / this.radius_p;
    if (s = n * n + g * g + e * e, h = 2 * this.radius_g * e, a = h * h - 4 * s * this.C, a < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    m = (-h - Math.sqrt(a)) / (2 * s), e = this.radius_g + m * e, n *= m, o *= m, t.x = Math.atan2(n, e), t.y = Math.atan(o * Math.cos(t.x) / e), t.y = Math.atan(this.radius_p_inv2 * Math.tan(t.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (o = Math.tan(t.y / this.radius_g_1), n = Math.tan(t.x / this.radius_g_1) * Math.sqrt(1 + o * o)) : (n = Math.tan(t.x / this.radius_g_1), o = Math.tan(t.y / this.radius_g_1) * Math.sqrt(1 + n * n)), s = n * n + o * o + e * e, h = 2 * this.radius_g * e, a = h * h - 4 * s * this.C, a < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    m = (-h - Math.sqrt(a)) / (2 * s), e = this.radius_g + m * e, n *= m, o *= m, t.x = Math.atan2(n, e), t.y = Math.atan(o * Math.cos(t.x) / e);
  }
  return t.x = t.x + this.long0, t;
}
var z4 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const F4 = {
  init: D4,
  forward: N4,
  inverse: R4,
  names: z4
};
function B4(t) {
  t.Proj.projections.add(sg), t.Proj.projections.add(lg), t.Proj.projections.add(qN), t.Proj.projections.add(t3), t.Proj.projections.add(s3), t.Proj.projections.add(f3), t.Proj.projections.add(v3), t.Proj.projections.add(E3), t.Proj.projections.add(O3), t.Proj.projections.add(L3), t.Proj.projections.add(K3), t.Proj.projections.add(rR), t.Proj.projections.add(sR), t.Proj.projections.add(pR), t.Proj.projections.add(vR), t.Proj.projections.add(ER), t.Proj.projections.add(OR), t.Proj.projections.add(LR), t.Proj.projections.add(BR), t.Proj.projections.add($R), t.Proj.projections.add(XR), t.Proj.projections.add(e4), t.Proj.projections.add(o4), t.Proj.projections.add(c4), t.Proj.projections.add(m4), t.Proj.projections.add(E4), t.Proj.projections.add(O4), t.Proj.projections.add(L4), t.Proj.projections.add(F4);
}
wo.defaultDatum = "WGS84";
wo.Proj = Zs;
wo.WGS84 = new wo.Proj("WGS84");
wo.Point = Nf;
wo.toPoint = wT;
wo.defs = Do;
wo.nadgrid = HD;
wo.transform = Dg;
wo.mgrs = uN;
wo.version = "__VERSION__";
B4(wo);
function V4() {
  var t, e, n;
  wo.defs("EPSG:32632", "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs"), wo.defs("EPSG:32631", "+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs"), wo.defs(
    "EPSG:2169",
    "+proj=tmerc +lat_0=49.83333333333334 +lon_0=6.166666666666667 +k=1 +x_0=80000 +y_0=100000 +ellps=intl +towgs84=-189.681,18.3463,-42.7695,-0.33746,-3.09264,2.53861,0.4598 +units=m +no_defs"
  ), SC(wo), (t = Xy("EPSG:32632")) == null || t.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]), (e = Xy("EPSG:32631")) == null || e.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]), (n = Xy("EPSG:2169")) == null || n.setExtent([
    48225.17,
    56225.6,
    105842.04,
    139616.4
  ]);
}
function U4(t, e, n) {
  const o = ar(t);
  class s extends W1 {
    constructor(a) {
      super(o, a, e, n);
    }
  }
  return bi(s, "def", o), s;
}
const j4 = typeof HTMLElement < "u" ? HTMLElement : class {
};
class W1 extends j4 {
  constructor(n, o = {}, s = {}, h) {
    super();
    bi(this, "_instance", null);
    bi(this, "_connected", !1);
    bi(this, "_resolved", !1);
    bi(this, "_numberProps", null);
    bi(this, "_styles");
    bi(this, "_slots");
    this._def = n, this._props = o, this._config = s, this._config = Wn(
      {
        shadowRoot: !0
      },
      this._config
    ), this._config.shadowRoot ? this.shadowRoot && h ? h(this._createVNode(), this.shadowRoot) : (this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def)) : h && h(this._createVNode(), this._root);
  }
  get _root() {
    return this._config.shadowRoot ? this.shadowRoot : this;
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, Eg(() => {
      this._connected || (xw(null, this._root), this._instance = null);
    });
  }
  _resolveDef() {
    this._resolved = !0;
    for (let s = 0; s < this.attributes.length; s++)
      this._setAttr(this.attributes[s].name);
    new MutationObserver((s) => {
      for (const h of s)
        this._setAttr(h.attributeName);
    }).observe(this, { attributes: !0 });
    const n = (s, h = !1) => {
      const { props: a, styles: m } = s;
      let g;
      if (a && !er(a))
        for (const b in a) {
          const T = a[b];
          (T === Number || T && T.type === Number) && (b in this._props && (this._props[b] = b0(this._props[b])), (g || (g = /* @__PURE__ */ Object.create(null)))[ya(b)] = !0);
        }
      this._numberProps = g, h && this._resolveProps(s), this._applyStyles(m), this._update();
    }, o = this._def.__asyncLoader;
    o ? o().then((s) => n(s, !0)) : n(this._def);
  }
  _resolveProps(n) {
    const { props: o } = n, s = er(o) ? o : Object.keys(o || {});
    for (const h of Object.keys(this))
      h[0] !== "_" && s.includes(h) && this._setProp(h, this[h], !0, !1);
    for (const h of s.map(ya))
      Object.defineProperty(this, h, {
        get() {
          return this._getProp(h);
        },
        set(a) {
          this._setProp(h, a);
        }
      });
  }
  _setAttr(n) {
    let o = this.getAttribute(n);
    const s = ya(n);
    this._numberProps && this._numberProps[s] && (o = b0(o)), this._setProp(s, o, !1);
  }
  _getProp(n) {
    return this._props[n];
  }
  _setProp(n, o, s = !0, h = !0) {
    o !== this._props[n] && (this._props[n] = o, h && this._instance && this._update(), s && (o === !0 ? this.setAttribute(ta(n), "") : typeof o == "string" || typeof o == "number" ? this.setAttribute(ta(n), o + "") : o || this.removeAttribute(ta(n))));
  }
  _update() {
    xw(this._createVNode(), this._root);
  }
  _createVNode() {
    const n = Ft(this._def, Wn({}, this._props));
    return this._instance || (n.ce = (o) => {
      this._instance = o, o.isCE = !0;
      const s = (a, m) => {
        this.dispatchEvent(
          new CustomEvent(a, {
            detail: m
          })
        );
      };
      o.emit = (a, ...m) => {
        s(a, m), ta(a) !== a && s(ta(a), m);
      };
      let h = this;
      for (; h = h && (h.parentNode || h.host); )
        if (h instanceof W1) {
          o.parent = h._instance, o.provides = h._instance.provides;
          break;
        }
    }), n;
  }
  _applyStyles(n) {
    n && n.forEach((o) => {
      const s = document.createElement("style");
      s.textContent = o, this._root.appendChild(s);
    });
  }
}
var Nd = /* @__PURE__ */ ((t) => (t.INFO = "alert-info", t.WARNING = "alert-warning", t.ERROR = "alert-danger", t))(Nd || {});
const G4 = Nd.INFO, $4 = 7e3, q4 = 4e3, zg = ih(
  "alert-notifications",
  () => {
    const t = _r([]);
    function e(o, s = G4, h) {
      const a = {
        message: o,
        type: s,
        duration: h != null ? h : s === Nd.WARNING ? q4 : $4
      };
      t.value.push(a);
    }
    function n(o) {
      t.value.splice(o, 1);
    }
    return {
      notifications: t,
      addNotification: e,
      removeNotification: n
    };
  },
  {}
), W4 = /* @__PURE__ */ ar({
  __name: "notification-item",
  props: {
    notification: { type: null, required: !0 }
  },
  emits: ["close"],
  setup(t) {
    const e = t, n = Bn(!0);
    function o(s, h) {
      setTimeout(() => {
        n.value = !1;
      }, e.notification.duration), h();
    }
    return (s, h) => {
      const a = L1("dompurify-html");
      return Ve(), on(Ev, {
        name: "fade-out",
        appear: "",
        "leave-active-class": "duration-200 ease-in",
        "leave-from-class": "opacity-100",
        "leave-to-class": "transform opacity-0",
        onEnter: o,
        onAfterLeave: h[0] || (h[0] = (m) => s.$emit("close"))
      }, {
        default: Ud(() => [
          se(n) ? Mg((Ve(), it("div", {
            key: 0,
            class: Pr(["lux-alert", `lux-${e.notification.type}`]),
            role: "alert"
          }, null, 2)), [
            [a, e.notification.message]
          ]) : Je("v-if", !0)
        ]),
        _: 1
      });
    };
  }
}), ur = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [o, s] of e)
    n[o] = s;
  return n;
}, H4 = /* @__PURE__ */ ur(W4, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/alert-notifications/notification-item.vue"]]), Z4 = {
  key: 0,
  class: "lux-notifications fixed w-[500px] top-10 left-1/2 ml-[-250px] z-50"
}, X4 = /* @__PURE__ */ ar({
  __name: "alert-notifications",
  setup(t) {
    const e = zg(), { notifications: n } = xn(e);
    function o(s) {
      e.removeNotification(s);
    }
    return (s, h) => (Ve(), on(BS, { to: "body" }, [
      se(n).length ? (Ve(), it("div", Z4, [
        (Ve(!0), it(cn, null, Ra(se(n), (a, m) => (Ve(), on(H4, {
          key: m,
          notification: a,
          onClose: () => o(m)
        }, null, 8, ["notification", "onClose"]))), 128))
      ])) : Je("v-if", !0)
    ]));
  }
}), K4 = /* @__PURE__ */ ur(X4, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/alert-notifications/alert-notifications.vue"]]), Y4 = { class: "lux-dropdown" }, J4 = { class: "h-full" }, Q4 = ["aria-expanded"], e5 = /* @__PURE__ */ ze("span", { class: "lux-caret" }, null, -1), t5 = { class: "lux-dropdown-wrapper" }, r5 = ["aria-label", "data-value"], n5 = /* @__PURE__ */ ar({
  __name: "dropdown-list",
  props: {
    placeholder: { type: String, required: !0 },
    options: { type: Array, required: !0, default: () => [{ label: "Default label", value: "Default value" }] },
    modelValue: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, o = Bn(!1), s = Bn();
    function h(b) {
      o.value = b === void 0 ? !o.value : b;
    }
    function a(b) {
      b.stopImmediatePropagation(), h();
    }
    function m(b) {
      s.value = b.target.dataset.value, e("change", s.value);
    }
    function g() {
      h(!1);
    }
    return _a(() => document.addEventListener("click", g)), Gu(() => document.removeEventListener("click", g)), (b, T) => {
      var M, I;
      return Ve(), it("div", Y4, [
        ze("div", J4, [
          ze("button", {
            type: "button",
            class: Pr(["lux-btn lux-dropdown-btn", se(o) ? "expanded" : ""]),
            "aria-expanded": se(o),
            "aria-haspopup": "true",
            onClick: a
          }, [
            ze("span", null, Gt((I = n.placeholder) != null ? I : (M = n.options[0]) == null ? void 0 : M.label), 1),
            e5
          ], 10, Q4)
        ]),
        ze("div", t5, [
          ze("ul", {
            class: Pr(["lux-dropdown-list", se(o) ? "" : "hidden"]),
            tabindex: "-1"
          }, [
            (Ve(!0), it(cn, null, Ra(n.options, (P) => (Ve(), it("li", {
              key: P.value,
              class: Pr(t.modelValue === P.value ? "selected" : "")
            }, [
              ze("button", {
                class: "lux-dropdown-list-item",
                "aria-label": P.ariaLabel,
                "data-value": P.value,
                onClick: m
              }, Gt(P.label), 9, r5)
            ], 2))), 128))
          ], 2)
        ])
      ]);
    };
  }
}), RT = /* @__PURE__ */ ur(n5, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/dropdown-list.vue"]]), yd = "EPSG:3857", zT = "EPSG:4326", i5 = "EPSG:2169";
let W_;
const Kw = Bn();
function Vl() {
  function t() {
    return W_;
  }
  function e() {
    return Kw.value = W_ = new TC({
      view: new MC({
        zoom: 10,
        center: [682439, 6379152],
        multiWorld: !0
      }),
      controls: [],
      keyboardEventTarget: document
    }), W_;
  }
  function n(T, M) {
    return T.id === M.id;
  }
  function o(T, M) {
    return T === M;
  }
  function s(T, M) {
    var I;
    return (I = T.layers) == null ? void 0 : I.some((P) => n(P, M));
  }
  function h(T, M) {
    var P;
    const I = (P = T == null ? void 0 : T.layers) == null ? void 0 : P.find((z) => n(z, M));
    return !o(I, M);
  }
  function a(T, M) {
    return !(M === null || !("layers" in T) || !("layers" in M) || typeof M.layers > "u" || typeof T.layers > "u" || T.layers === M.layers);
  }
  function m(T, M) {
    return !("layers" in T) || typeof T.layers > "u" ? [] : M === null || !("layers" in M) ? T.layers.map((I, P) => ({ layer: I, position: P })) : T.layers === M.layers ? [] : T.layers.reduce(
      (I, P, z) => s(M, P) ? I : [
        ...I,
        {
          layer: P,
          position: z
        }
      ],
      []
    );
  }
  function g(T, M) {
    return a(T, M) ? M.layers.reduce(
      (I, P) => s(T, P) ? I : [...I, P],
      []
    ) : [];
  }
  function b(T, M) {
    return a(T, M) ? T.layers.reduce(
      (I, P) => h(M, P) ? [...I, P] : I,
      []
    ) : [];
  }
  return {
    olMap: Kw,
    getOlMap: t,
    createMap: e,
    equalsLayer: n,
    hasLayer: s,
    layerHasChanged: h,
    contextHasChanged: a,
    getAddedLayers: m,
    getRemovedLayers: g,
    getMutatedLayers: b
  };
}
const Wp = /* @__PURE__ */ new Map();
function cs(t) {
  return cs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, cs(t);
}
function nl(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function o5(t, e) {
  if (cs(t) !== "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (cs(o) !== "object")
      return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function FT(t) {
  var e = o5(t, "string");
  return cs(e) === "symbol" ? e : String(e);
}
function Yw(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, FT(o.key), o);
  }
}
function il(t, e, n) {
  return e && Yw(t.prototype, e), n && Yw(t, n), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function Lu(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function J0(t, e) {
  return J0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, s) {
    return o.__proto__ = s, o;
  }, J0(t, e);
}
function Iv(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && J0(t, e);
}
function Xd(t, e) {
  if (e && (cs(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Lu(t);
}
function tl(t) {
  return tl = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, tl(t);
}
function $u(t, e, n) {
  return e = FT(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function a5(t) {
  if (Array.isArray(t))
    return t;
}
function s5(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function Jw(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++)
    o[n] = t[n];
  return o;
}
function l5(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return Jw(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set")
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Jw(t, e);
  }
}
function u5() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function c5(t) {
  return a5(t) || s5(t) || l5(t) || u5();
}
function Qw(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function e2(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Qw(Object(n), !0).forEach(function(o) {
      $u(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Qw(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
var h5 = {
  type: "logger",
  log: function(e) {
    this.output("log", e);
  },
  warn: function(e) {
    this.output("warn", e);
  },
  error: function(e) {
    this.output("error", e);
  },
  output: function(e, n) {
    console && console[e] && console[e].apply(console, n);
  }
}, f5 = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    nl(this, t), this.init(e, n);
  }
  return il(t, [{
    key: "init",
    value: function(n) {
      var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = o.prefix || "i18next:", this.logger = n || h5, this.options = o, this.debug = o.debug;
    }
  }, {
    key: "setDebug",
    value: function(n) {
      this.debug = n;
    }
  }, {
    key: "log",
    value: function() {
      for (var n = arguments.length, o = new Array(n), s = 0; s < n; s++)
        o[s] = arguments[s];
      return this.forward(o, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var n = arguments.length, o = new Array(n), s = 0; s < n; s++)
        o[s] = arguments[s];
      return this.forward(o, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var n = arguments.length, o = new Array(n), s = 0; s < n; s++)
        o[s] = arguments[s];
      return this.forward(o, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var n = arguments.length, o = new Array(n), s = 0; s < n; s++)
        o[s] = arguments[s];
      return this.forward(o, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(n, o, s, h) {
      return h && !this.debug ? null : (typeof n[0] == "string" && (n[0] = "".concat(s).concat(this.prefix, " ").concat(n[0])), this.logger[o](n));
    }
  }, {
    key: "create",
    value: function(n) {
      return new t(this.logger, e2(e2({}, {
        prefix: "".concat(this.prefix, ":").concat(n, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function(n) {
      return n = n || this.options, n.prefix = n.prefix || this.prefix, new t(this.logger, n);
    }
  }]), t;
}(), Ws = new f5(), Bu = function() {
  function t() {
    nl(this, t), this.observers = {};
  }
  return il(t, [{
    key: "on",
    value: function(n, o) {
      var s = this;
      return n.split(" ").forEach(function(h) {
        s.observers[h] = s.observers[h] || [], s.observers[h].push(o);
      }), this;
    }
  }, {
    key: "off",
    value: function(n, o) {
      if (!!this.observers[n]) {
        if (!o) {
          delete this.observers[n];
          return;
        }
        this.observers[n] = this.observers[n].filter(function(s) {
          return s !== o;
        });
      }
    }
  }, {
    key: "emit",
    value: function(n) {
      for (var o = arguments.length, s = new Array(o > 1 ? o - 1 : 0), h = 1; h < o; h++)
        s[h - 1] = arguments[h];
      if (this.observers[n]) {
        var a = [].concat(this.observers[n]);
        a.forEach(function(g) {
          g.apply(void 0, s);
        });
      }
      if (this.observers["*"]) {
        var m = [].concat(this.observers["*"]);
        m.forEach(function(g) {
          g.apply(g, [n].concat(s));
        });
      }
    }
  }]), t;
}();
function Hp() {
  var t, e, n = new Promise(function(o, s) {
    t = o, e = s;
  });
  return n.resolve = t, n.reject = e, n;
}
function t2(t) {
  return t == null ? "" : "" + t;
}
function p5(t, e, n) {
  t.forEach(function(o) {
    e[o] && (n[o] = e[o]);
  });
}
function H1(t, e, n) {
  function o(m) {
    return m && m.indexOf("###") > -1 ? m.replace(/###/g, ".") : m;
  }
  function s() {
    return !t || typeof t == "string";
  }
  for (var h = typeof e != "string" ? [].concat(e) : e.split("."); h.length > 1; ) {
    if (s())
      return {};
    var a = o(h.shift());
    !t[a] && n && (t[a] = new n()), Object.prototype.hasOwnProperty.call(t, a) ? t = t[a] : t = {};
  }
  return s() ? {} : {
    obj: t,
    k: o(h.shift())
  };
}
function r2(t, e, n) {
  var o = H1(t, e, Object), s = o.obj, h = o.k;
  s[h] = n;
}
function d5(t, e, n, o) {
  var s = H1(t, e, Object), h = s.obj, a = s.k;
  h[a] = h[a] || [], o && (h[a] = h[a].concat(n)), o || h[a].push(n);
}
function Fg(t, e) {
  var n = H1(t, e), o = n.obj, s = n.k;
  if (!!o)
    return o[s];
}
function n2(t, e, n) {
  var o = Fg(t, n);
  return o !== void 0 ? o : Fg(e, n);
}
function BT(t, e, n) {
  for (var o in e)
    o !== "__proto__" && o !== "constructor" && (o in t ? typeof t[o] == "string" || t[o] instanceof String || typeof e[o] == "string" || e[o] instanceof String ? n && (t[o] = e[o]) : BT(t[o], e[o], n) : t[o] = e[o]);
  return t;
}
function of(t) {
  return t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var m5 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function y5(t) {
  return typeof t == "string" ? t.replace(/[&<>"'\/]/g, function(e) {
    return m5[e];
  }) : t;
}
var Ov = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, g5 = [" ", ",", "?", "!", ";"];
function v5(t, e, n) {
  e = e || "", n = n || "";
  var o = g5.filter(function(m) {
    return e.indexOf(m) < 0 && n.indexOf(m) < 0;
  });
  if (o.length === 0)
    return !0;
  var s = new RegExp("(".concat(o.map(function(m) {
    return m === "?" ? "\\?" : m;
  }).join("|"), ")")), h = !s.test(t);
  if (!h) {
    var a = t.indexOf(n);
    a > 0 && !s.test(t.substring(0, a)) && (h = !0);
  }
  return h;
}
function i2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function Cy(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? i2(Object(n), !0).forEach(function(o) {
      $u(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : i2(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _5(t) {
  var e = x5();
  return function() {
    var o = tl(t), s;
    if (e) {
      var h = tl(this).constructor;
      s = Reflect.construct(o, arguments, h);
    } else
      s = o.apply(this, arguments);
    return Xd(this, s);
  };
}
function x5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function VT(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!!t) {
    if (t[e])
      return t[e];
    for (var o = e.split(n), s = t, h = 0; h < o.length; ++h) {
      if (!s || typeof s[o[h]] == "string" && h + 1 < o.length)
        return;
      if (s[o[h]] === void 0) {
        for (var a = 2, m = o.slice(h, h + a).join(n), g = s[m]; g === void 0 && o.length > h + a; )
          a++, m = o.slice(h, h + a).join(n), g = s[m];
        if (g === void 0)
          return;
        if (g === null)
          return null;
        if (e.endsWith(m)) {
          if (typeof g == "string")
            return g;
          if (m && typeof g[m] == "string")
            return g[m];
        }
        var b = o.slice(h + a).join(n);
        return b ? VT(g, b, n) : void 0;
      }
      s = s[o[h]];
    }
    return s;
  }
}
var b5 = function(t) {
  Iv(n, t);
  var e = _5(n);
  function n(o) {
    var s, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return nl(this, n), s = e.call(this), Ov && Bu.call(Lu(s)), s.data = o || {}, s.options = h, s.options.keySeparator === void 0 && (s.options.keySeparator = "."), s.options.ignoreJSONStructure === void 0 && (s.options.ignoreJSONStructure = !0), s;
  }
  return il(n, [{
    key: "addNamespaces",
    value: function(s) {
      this.options.ns.indexOf(s) < 0 && this.options.ns.push(s);
    }
  }, {
    key: "removeNamespaces",
    value: function(s) {
      var h = this.options.ns.indexOf(s);
      h > -1 && this.options.ns.splice(h, 1);
    }
  }, {
    key: "getResource",
    value: function(s, h, a) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, g = m.keySeparator !== void 0 ? m.keySeparator : this.options.keySeparator, b = m.ignoreJSONStructure !== void 0 ? m.ignoreJSONStructure : this.options.ignoreJSONStructure, T = [s, h];
      a && typeof a != "string" && (T = T.concat(a)), a && typeof a == "string" && (T = T.concat(g ? a.split(g) : a)), s.indexOf(".") > -1 && (T = s.split("."));
      var M = Fg(this.data, T);
      return M || !b || typeof a != "string" ? M : VT(this.data && this.data[s] && this.data[s][h], a, g);
    }
  }, {
    key: "addResource",
    value: function(s, h, a, m) {
      var g = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, b = this.options.keySeparator;
      b === void 0 && (b = ".");
      var T = [s, h];
      a && (T = T.concat(b ? a.split(b) : a)), s.indexOf(".") > -1 && (T = s.split("."), m = h, h = T[1]), this.addNamespaces(h), r2(this.data, T, m), g.silent || this.emit("added", s, h, a, m);
    }
  }, {
    key: "addResources",
    value: function(s, h, a) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var g in a)
        (typeof a[g] == "string" || Object.prototype.toString.apply(a[g]) === "[object Array]") && this.addResource(s, h, g, a[g], {
          silent: !0
        });
      m.silent || this.emit("added", s, h, a);
    }
  }, {
    key: "addResourceBundle",
    value: function(s, h, a, m, g) {
      var b = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, T = [s, h];
      s.indexOf(".") > -1 && (T = s.split("."), m = a, a = h, h = T[1]), this.addNamespaces(h);
      var M = Fg(this.data, T) || {};
      m ? BT(M, a, g) : M = Cy(Cy({}, M), a), r2(this.data, T, M), b.silent || this.emit("added", s, h, a);
    }
  }, {
    key: "removeResourceBundle",
    value: function(s, h) {
      this.hasResourceBundle(s, h) && delete this.data[s][h], this.removeNamespaces(h), this.emit("removed", s, h);
    }
  }, {
    key: "hasResourceBundle",
    value: function(s, h) {
      return this.getResource(s, h) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(s, h) {
      return h || (h = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? Cy(Cy({}, {}), this.getResource(s, h)) : this.getResource(s, h);
    }
  }, {
    key: "getDataByLanguage",
    value: function(s) {
      return this.data[s];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function(s) {
      var h = this.getDataByLanguage(s), a = h && Object.keys(h) || [];
      return !!a.find(function(m) {
        return h[m] && Object.keys(h[m]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), n;
}(Bu), UT = {
  processors: {},
  addPostProcessor: function(e) {
    this.processors[e.name] = e;
  },
  handle: function(e, n, o, s, h) {
    var a = this;
    return e.forEach(function(m) {
      a.processors[m] && (n = a.processors[m].process(n, o, s, h));
    }), n;
  }
};
function o2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function Po(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? o2(Object(n), !0).forEach(function(o) {
      $u(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : o2(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function w5(t) {
  var e = E5();
  return function() {
    var o = tl(t), s;
    if (e) {
      var h = tl(this).constructor;
      s = Reflect.construct(o, arguments, h);
    } else
      s = o.apply(this, arguments);
    return Xd(this, s);
  };
}
function E5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var a2 = {}, s2 = function(t) {
  Iv(n, t);
  var e = w5(n);
  function n(o) {
    var s, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return nl(this, n), s = e.call(this), Ov && Bu.call(Lu(s)), p5(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], o, Lu(s)), s.options = h, s.options.keySeparator === void 0 && (s.options.keySeparator = "."), s.logger = Ws.create("translator"), s;
  }
  return il(n, [{
    key: "changeLanguage",
    value: function(s) {
      s && (this.language = s);
    }
  }, {
    key: "exists",
    value: function(s) {
      var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (s == null)
        return !1;
      var a = this.resolve(s, h);
      return a && a.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(s, h) {
      var a = h.nsSeparator !== void 0 ? h.nsSeparator : this.options.nsSeparator;
      a === void 0 && (a = ":");
      var m = h.keySeparator !== void 0 ? h.keySeparator : this.options.keySeparator, g = h.ns || this.options.defaultNS || [], b = a && s.indexOf(a) > -1, T = !this.options.userDefinedKeySeparator && !h.keySeparator && !this.options.userDefinedNsSeparator && !h.nsSeparator && !v5(s, a, m);
      if (b && !T) {
        var M = s.match(this.interpolator.nestingRegexp);
        if (M && M.length > 0)
          return {
            key: s,
            namespaces: g
          };
        var I = s.split(a);
        (a !== m || a === m && this.options.ns.indexOf(I[0]) > -1) && (g = I.shift()), s = I.join(m);
      }
      return typeof g == "string" && (g = [g]), {
        key: s,
        namespaces: g
      };
    }
  }, {
    key: "translate",
    value: function(s, h, a) {
      var m = this;
      if (cs(h) !== "object" && this.options.overloadTranslationOptionHandler && (h = this.options.overloadTranslationOptionHandler(arguments)), h || (h = {}), s == null)
        return "";
      Array.isArray(s) || (s = [String(s)]);
      var g = h.returnDetails !== void 0 ? h.returnDetails : this.options.returnDetails, b = h.keySeparator !== void 0 ? h.keySeparator : this.options.keySeparator, T = this.extractFromKey(s[s.length - 1], h), M = T.key, I = T.namespaces, P = I[I.length - 1], z = h.lng || this.language, V = h.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (z && z.toLowerCase() === "cimode") {
        if (V) {
          var q = h.nsSeparator || this.options.nsSeparator;
          return g ? {
            res: "".concat(P).concat(q).concat(M),
            usedKey: M,
            exactUsedKey: M,
            usedLng: z,
            usedNS: P
          } : "".concat(P).concat(q).concat(M);
        }
        return g ? {
          res: M,
          usedKey: M,
          exactUsedKey: M,
          usedLng: z,
          usedNS: P
        } : M;
      }
      var re = this.resolve(s, h), X = re && re.res, ae = re && re.usedKey || M, ce = re && re.exactUsedKey || M, ve = Object.prototype.toString.apply(X), Re = ["[object Number]", "[object Function]", "[object RegExp]"], Fe = h.joinArrays !== void 0 ? h.joinArrays : this.options.joinArrays, Pe = !this.i18nFormat || this.i18nFormat.handleAsObject, Se = typeof X != "string" && typeof X != "boolean" && typeof X != "number";
      if (Pe && X && Se && Re.indexOf(ve) < 0 && !(typeof Fe == "string" && ve === "[object Array]")) {
        if (!h.returnObjects && !this.options.returnObjects) {
          this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          var Ie = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(ae, X, Po(Po({}, h), {}, {
            ns: I
          })) : "key '".concat(M, " (").concat(this.language, ")' returned an object instead of string.");
          return g ? (re.res = Ie, re) : Ie;
        }
        if (b) {
          var Xe = ve === "[object Array]", $e = Xe ? [] : {}, at = Xe ? ce : ae;
          for (var be in X)
            if (Object.prototype.hasOwnProperty.call(X, be)) {
              var Ye = "".concat(at).concat(b).concat(be);
              $e[be] = this.translate(Ye, Po(Po({}, h), {
                joinArrays: !1,
                ns: I
              })), $e[be] === Ye && ($e[be] = X[be]);
            }
          X = $e;
        }
      } else if (Pe && typeof Fe == "string" && ve === "[object Array]")
        X = X.join(Fe), X && (X = this.extendTranslation(X, s, h, a));
      else {
        var ht = !1, vt = !1, Pt = h.count !== void 0 && typeof h.count != "string", tr = n.hasDefaultValue(h), kn = Pt ? this.pluralResolver.getSuffix(z, h.count, h) : "", Rr = h["defaultValue".concat(kn)] || h.defaultValue;
        !this.isValidLookup(X) && tr && (ht = !0, X = Rr), this.isValidLookup(X) || (vt = !0, X = M);
        var pr = h.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, Zn = pr && vt ? void 0 : X, zr = tr && Rr !== X && this.options.updateMissing;
        if (vt || ht || zr) {
          if (this.logger.log(zr ? "updateKey" : "missingKey", z, P, M, zr ? Rr : X), b) {
            var Fi = this.resolve(M, Po(Po({}, h), {}, {
              keySeparator: !1
            }));
            Fi && Fi.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var $r = [], kr = this.languageUtils.getFallbackCodes(this.options.fallbackLng, h.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && kr && kr[0])
            for (var Vn = 0; Vn < kr.length; Vn++)
              $r.push(kr[Vn]);
          else
            this.options.saveMissingTo === "all" ? $r = this.languageUtils.toResolveHierarchy(h.lng || this.language) : $r.push(h.lng || this.language);
          var Tr = function(oi, Un, K) {
            var ye = tr && K !== X ? K : Zn;
            m.options.missingKeyHandler ? m.options.missingKeyHandler(oi, P, Un, ye, zr, h) : m.backendConnector && m.backendConnector.saveMissing && m.backendConnector.saveMissing(oi, P, Un, ye, zr, h), m.emit("missingKey", oi, P, Un, X);
          };
          this.options.saveMissing && (this.options.saveMissingPlurals && Pt ? $r.forEach(function(Sn) {
            m.pluralResolver.getSuffixes(Sn, h).forEach(function(oi) {
              Tr([Sn], M + oi, h["defaultValue".concat(oi)] || Rr);
            });
          }) : Tr($r, M, Rr));
        }
        X = this.extendTranslation(X, s, h, re, a), vt && X === M && this.options.appendNamespaceToMissingKey && (X = "".concat(P, ":").concat(M)), (vt || ht) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? X = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(P, ":").concat(M) : M, ht ? X : void 0) : X = this.options.parseMissingKeyHandler(X));
      }
      return g ? (re.res = X, re) : X;
    }
  }, {
    key: "extendTranslation",
    value: function(s, h, a, m, g) {
      var b = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        s = this.i18nFormat.parse(s, Po(Po({}, this.options.interpolation.defaultVariables), a), m.usedLng, m.usedNS, m.usedKey, {
          resolved: m
        });
      else if (!a.skipInterpolation) {
        a.interpolation && this.interpolator.init(Po(Po({}, a), {
          interpolation: Po(Po({}, this.options.interpolation), a.interpolation)
        }));
        var T = typeof s == "string" && (a && a.interpolation && a.interpolation.skipOnVariables !== void 0 ? a.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), M;
        if (T) {
          var I = s.match(this.interpolator.nestingRegexp);
          M = I && I.length;
        }
        var P = a.replace && typeof a.replace != "string" ? a.replace : a;
        if (this.options.interpolation.defaultVariables && (P = Po(Po({}, this.options.interpolation.defaultVariables), P)), s = this.interpolator.interpolate(s, P, a.lng || this.language, a), T) {
          var z = s.match(this.interpolator.nestingRegexp), V = z && z.length;
          M < V && (a.nest = !1);
        }
        a.nest !== !1 && (s = this.interpolator.nest(s, function() {
          for (var X = arguments.length, ae = new Array(X), ce = 0; ce < X; ce++)
            ae[ce] = arguments[ce];
          return g && g[0] === ae[0] && !a.context ? (b.logger.warn("It seems you are nesting recursively key: ".concat(ae[0], " in key: ").concat(h[0])), null) : b.translate.apply(b, ae.concat([h]));
        }, a)), a.interpolation && this.interpolator.reset();
      }
      var q = a.postProcess || this.options.postProcess, re = typeof q == "string" ? [q] : q;
      return s != null && re && re.length && a.applyPostProcessor !== !1 && (s = UT.handle(re, s, h, this.options && this.options.postProcessPassResolved ? Po({
        i18nResolved: m
      }, a) : a, this)), s;
    }
  }, {
    key: "resolve",
    value: function(s) {
      var h = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, m, g, b, T, M;
      return typeof s == "string" && (s = [s]), s.forEach(function(I) {
        if (!h.isValidLookup(m)) {
          var P = h.extractFromKey(I, a), z = P.key;
          g = z;
          var V = P.namespaces;
          h.options.fallbackNS && (V = V.concat(h.options.fallbackNS));
          var q = a.count !== void 0 && typeof a.count != "string", re = q && !a.ordinal && a.count === 0 && h.pluralResolver.shouldUseIntlApi(), X = a.context !== void 0 && (typeof a.context == "string" || typeof a.context == "number") && a.context !== "", ae = a.lngs ? a.lngs : h.languageUtils.toResolveHierarchy(a.lng || h.language, a.fallbackLng);
          V.forEach(function(ce) {
            h.isValidLookup(m) || (M = ce, !a2["".concat(ae[0], "-").concat(ce)] && h.utils && h.utils.hasLoadedNamespace && !h.utils.hasLoadedNamespace(M) && (a2["".concat(ae[0], "-").concat(ce)] = !0, h.logger.warn('key "'.concat(g, '" for languages "').concat(ae.join(", "), `" won't get resolved as namespace "`).concat(M, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), ae.forEach(function(ve) {
              if (!h.isValidLookup(m)) {
                T = ve;
                var Re = [z];
                if (h.i18nFormat && h.i18nFormat.addLookupKeys)
                  h.i18nFormat.addLookupKeys(Re, z, ve, ce, a);
                else {
                  var Fe;
                  q && (Fe = h.pluralResolver.getSuffix(ve, a.count, a));
                  var Pe = "".concat(h.options.pluralSeparator, "zero");
                  if (q && (Re.push(z + Fe), re && Re.push(z + Pe)), X) {
                    var Se = "".concat(z).concat(h.options.contextSeparator).concat(a.context);
                    Re.push(Se), q && (Re.push(Se + Fe), re && Re.push(Se + Pe));
                  }
                }
                for (var Ie; Ie = Re.pop(); )
                  h.isValidLookup(m) || (b = Ie, m = h.getResource(ve, ce, Ie, a));
              }
            }));
          });
        }
      }), {
        res: m,
        usedKey: g,
        exactUsedKey: b,
        usedLng: T,
        usedNS: M
      };
    }
  }, {
    key: "isValidLookup",
    value: function(s) {
      return s !== void 0 && !(!this.options.returnNull && s === null) && !(!this.options.returnEmptyString && s === "");
    }
  }, {
    key: "getResource",
    value: function(s, h, a) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(s, h, a, m) : this.resourceStore.getResource(s, h, a, m);
    }
  }], [{
    key: "hasDefaultValue",
    value: function(s) {
      var h = "defaultValue";
      for (var a in s)
        if (Object.prototype.hasOwnProperty.call(s, a) && h === a.substring(0, h.length) && s[a] !== void 0)
          return !0;
      return !1;
    }
  }]), n;
}(Bu);
function H_(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
var l2 = function() {
  function t(e) {
    nl(this, t), this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Ws.create("languageUtils");
  }
  return il(t, [{
    key: "getScriptPartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return null;
      var o = n.split("-");
      return o.length === 2 || (o.pop(), o[o.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(o.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return n;
      var o = n.split("-");
      return this.formatLanguageCode(o[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(n) {
      if (typeof n == "string" && n.indexOf("-") > -1) {
        var o = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], s = n.split("-");
        return this.options.lowerCaseLng ? s = s.map(function(h) {
          return h.toLowerCase();
        }) : s.length === 2 ? (s[0] = s[0].toLowerCase(), s[1] = s[1].toUpperCase(), o.indexOf(s[1].toLowerCase()) > -1 && (s[1] = H_(s[1].toLowerCase()))) : s.length === 3 && (s[0] = s[0].toLowerCase(), s[1].length === 2 && (s[1] = s[1].toUpperCase()), s[0] !== "sgn" && s[2].length === 2 && (s[2] = s[2].toUpperCase()), o.indexOf(s[1].toLowerCase()) > -1 && (s[1] = H_(s[1].toLowerCase())), o.indexOf(s[2].toLowerCase()) > -1 && (s[2] = H_(s[2].toLowerCase()))), s.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? n.toLowerCase() : n;
    }
  }, {
    key: "isSupportedCode",
    value: function(n) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (n = this.getLanguagePartFromCode(n)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(n) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function(n) {
      var o = this;
      if (!n)
        return null;
      var s;
      return n.forEach(function(h) {
        if (!s) {
          var a = o.formatLanguageCode(h);
          (!o.options.supportedLngs || o.isSupportedCode(a)) && (s = a);
        }
      }), !s && this.options.supportedLngs && n.forEach(function(h) {
        if (!s) {
          var a = o.getLanguagePartFromCode(h);
          if (o.isSupportedCode(a))
            return s = a;
          s = o.options.supportedLngs.find(function(m) {
            if (m.indexOf(a) === 0)
              return m;
          });
        }
      }), s || (s = this.getFallbackCodes(this.options.fallbackLng)[0]), s;
    }
  }, {
    key: "getFallbackCodes",
    value: function(n, o) {
      if (!n)
        return [];
      if (typeof n == "function" && (n = n(o)), typeof n == "string" && (n = [n]), Object.prototype.toString.apply(n) === "[object Array]")
        return n;
      if (!o)
        return n.default || [];
      var s = n[o];
      return s || (s = n[this.getScriptPartFromCode(o)]), s || (s = n[this.formatLanguageCode(o)]), s || (s = n[this.getLanguagePartFromCode(o)]), s || (s = n.default), s || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(n, o) {
      var s = this, h = this.getFallbackCodes(o || this.options.fallbackLng || [], n), a = [], m = function(b) {
        !b || (s.isSupportedCode(b) ? a.push(b) : s.logger.warn("rejecting language code not found in supportedLngs: ".concat(b)));
      };
      return typeof n == "string" && n.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && m(this.formatLanguageCode(n)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && m(this.getScriptPartFromCode(n)), this.options.load !== "currentOnly" && m(this.getLanguagePartFromCode(n))) : typeof n == "string" && m(this.formatLanguageCode(n)), h.forEach(function(g) {
        a.indexOf(g) < 0 && m(s.formatLanguageCode(g));
      }), a;
    }
  }]), t;
}(), S5 = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], T5 = {
  1: function(e) {
    return Number(e > 1);
  },
  2: function(e) {
    return Number(e != 1);
  },
  3: function(e) {
    return 0;
  },
  4: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  5: function(e) {
    return Number(e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5);
  },
  6: function(e) {
    return Number(e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2);
  },
  7: function(e) {
    return Number(e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  8: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3);
  },
  9: function(e) {
    return Number(e >= 2);
  },
  10: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4);
  },
  11: function(e) {
    return Number(e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3);
  },
  12: function(e) {
    return Number(e % 10 != 1 || e % 100 == 11);
  },
  13: function(e) {
    return Number(e !== 0);
  },
  14: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3);
  },
  15: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  16: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2);
  },
  17: function(e) {
    return Number(e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1);
  },
  18: function(e) {
    return Number(e == 0 ? 0 : e == 1 ? 1 : 2);
  },
  19: function(e) {
    return Number(e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3);
  },
  20: function(e) {
    return Number(e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2);
  },
  21: function(e) {
    return Number(e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0);
  },
  22: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3);
  }
}, M5 = ["v1", "v2", "v3"], u2 = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function I5() {
  var t = {};
  return S5.forEach(function(e) {
    e.lngs.forEach(function(n) {
      t[n] = {
        numbers: e.nr,
        plurals: T5[e.fc]
      };
    });
  }), t;
}
var O5 = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    nl(this, t), this.languageUtils = e, this.options = n, this.logger = Ws.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = I5();
  }
  return il(t, [{
    key: "addRule",
    value: function(n, o) {
      this.rules[n] = o;
    }
  }, {
    key: "getRule",
    value: function(n) {
      var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
        try {
          return new Intl.PluralRules(n, {
            type: o.ordinal ? "ordinal" : "cardinal"
          });
        } catch {
          return;
        }
      return this.rules[n] || this.rules[this.languageUtils.getLanguagePartFromCode(n)];
    }
  }, {
    key: "needsPlural",
    value: function(n) {
      var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = this.getRule(n, o);
      return this.shouldUseIntlApi() ? s && s.resolvedOptions().pluralCategories.length > 1 : s && s.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(n, o) {
      var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(n, s).map(function(h) {
        return "".concat(o).concat(h);
      });
    }
  }, {
    key: "getSuffixes",
    value: function(n) {
      var o = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, h = this.getRule(n, s);
      return h ? this.shouldUseIntlApi() ? h.resolvedOptions().pluralCategories.sort(function(a, m) {
        return u2[a] - u2[m];
      }).map(function(a) {
        return "".concat(o.options.prepend).concat(a);
      }) : h.numbers.map(function(a) {
        return o.getSuffix(n, a, s);
      }) : [];
    }
  }, {
    key: "getSuffix",
    value: function(n, o) {
      var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = this.getRule(n, s);
      return h ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(h.select(o)) : this.getSuffixRetroCompatible(h, o) : (this.logger.warn("no plural rule found for: ".concat(n)), "");
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function(n, o) {
      var s = this, h = n.noAbs ? n.plurals(o) : n.plurals(Math.abs(o)), a = n.numbers[h];
      this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 && (a === 2 ? a = "plural" : a === 1 && (a = ""));
      var m = function() {
        return s.options.prepend && a.toString() ? s.options.prepend + a.toString() : a.toString();
      };
      return this.options.compatibilityJSON === "v1" ? a === 1 ? "" : typeof a == "number" ? "_plural_".concat(a.toString()) : m() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 ? m() : this.options.prepend && h.toString() ? this.options.prepend + h.toString() : h.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function() {
      return !M5.includes(this.options.compatibilityJSON);
    }
  }]), t;
}();
function c2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function Xa(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? c2(Object(n), !0).forEach(function(o) {
      $u(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : c2(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
var C5 = function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    nl(this, t), this.logger = Ws.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || function(n) {
      return n;
    }, this.init(e);
  }
  return il(t, [{
    key: "init",
    value: function() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      n.interpolation || (n.interpolation = {
        escapeValue: !0
      });
      var o = n.interpolation;
      this.escape = o.escape !== void 0 ? o.escape : y5, this.escapeValue = o.escapeValue !== void 0 ? o.escapeValue : !0, this.useRawValueToEscape = o.useRawValueToEscape !== void 0 ? o.useRawValueToEscape : !1, this.prefix = o.prefix ? of(o.prefix) : o.prefixEscaped || "{{", this.suffix = o.suffix ? of(o.suffix) : o.suffixEscaped || "}}", this.formatSeparator = o.formatSeparator ? o.formatSeparator : o.formatSeparator || ",", this.unescapePrefix = o.unescapeSuffix ? "" : o.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : o.unescapeSuffix || "", this.nestingPrefix = o.nestingPrefix ? of(o.nestingPrefix) : o.nestingPrefixEscaped || of("$t("), this.nestingSuffix = o.nestingSuffix ? of(o.nestingSuffix) : o.nestingSuffixEscaped || of(")"), this.nestingOptionsSeparator = o.nestingOptionsSeparator ? o.nestingOptionsSeparator : o.nestingOptionsSeparator || ",", this.maxReplaces = o.maxReplaces ? o.maxReplaces : 1e3, this.alwaysFormat = o.alwaysFormat !== void 0 ? o.alwaysFormat : !1, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var n = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(n, "g");
      var o = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(o, "g");
      var s = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(s, "g");
    }
  }, {
    key: "interpolate",
    value: function(n, o, s, h) {
      var a = this, m, g, b, T = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function M(q) {
        return q.replace(/\$/g, "$$$$");
      }
      var I = function(re) {
        if (re.indexOf(a.formatSeparator) < 0) {
          var X = n2(o, T, re);
          return a.alwaysFormat ? a.format(X, void 0, s, Xa(Xa(Xa({}, h), o), {}, {
            interpolationkey: re
          })) : X;
        }
        var ae = re.split(a.formatSeparator), ce = ae.shift().trim(), ve = ae.join(a.formatSeparator).trim();
        return a.format(n2(o, T, ce), ve, s, Xa(Xa(Xa({}, h), o), {}, {
          interpolationkey: ce
        }));
      };
      this.resetRegExp();
      var P = h && h.missingInterpolationHandler || this.options.missingInterpolationHandler, z = h && h.interpolation && h.interpolation.skipOnVariables !== void 0 ? h.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, V = [{
        regex: this.regexpUnescape,
        safeValue: function(re) {
          return M(re);
        }
      }, {
        regex: this.regexp,
        safeValue: function(re) {
          return a.escapeValue ? M(a.escape(re)) : M(re);
        }
      }];
      return V.forEach(function(q) {
        for (b = 0; m = q.regex.exec(n); ) {
          var re = m[1].trim();
          if (g = I(re), g === void 0)
            if (typeof P == "function") {
              var X = P(n, m, h);
              g = typeof X == "string" ? X : "";
            } else if (h && Object.prototype.hasOwnProperty.call(h, re))
              g = "";
            else if (z) {
              g = m[0];
              continue;
            } else
              a.logger.warn("missed to pass in variable ".concat(re, " for interpolating ").concat(n)), g = "";
          else
            typeof g != "string" && !a.useRawValueToEscape && (g = t2(g));
          var ae = q.safeValue(g);
          if (n = n.replace(m[0], ae), z ? (q.regex.lastIndex += g.length, q.regex.lastIndex -= m[0].length) : q.regex.lastIndex = 0, b++, b >= a.maxReplaces)
            break;
        }
      }), n;
    }
  }, {
    key: "nest",
    value: function(n, o) {
      var s = this, h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a, m, g;
      function b(P, z) {
        var V = this.nestingOptionsSeparator;
        if (P.indexOf(V) < 0)
          return P;
        var q = P.split(new RegExp("".concat(V, "[ ]*{"))), re = "{".concat(q[1]);
        P = q[0], re = this.interpolate(re, g);
        var X = re.match(/'/g), ae = re.match(/"/g);
        (X && X.length % 2 === 0 && !ae || ae.length % 2 !== 0) && (re = re.replace(/'/g, '"'));
        try {
          g = JSON.parse(re), z && (g = Xa(Xa({}, z), g));
        } catch (ce) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(P), ce), "".concat(P).concat(V).concat(re);
        }
        return delete g.defaultValue, P;
      }
      for (; a = this.nestingRegexp.exec(n); ) {
        var T = [];
        g = Xa({}, h), g = g.replace && typeof g.replace != "string" ? g.replace : g, g.applyPostProcessor = !1, delete g.defaultValue;
        var M = !1;
        if (a[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(a[1])) {
          var I = a[1].split(this.formatSeparator).map(function(P) {
            return P.trim();
          });
          a[1] = I.shift(), T = I, M = !0;
        }
        if (m = o(b.call(this, a[1].trim(), g), g), m && a[0] === n && typeof m != "string")
          return m;
        typeof m != "string" && (m = t2(m)), m || (this.logger.warn("missed to resolve ".concat(a[1], " for nesting ").concat(n)), m = ""), M && (m = T.reduce(function(P, z) {
          return s.format(P, z, h.lng, Xa(Xa({}, h), {}, {
            interpolationkey: a[1].trim()
          }));
        }, m.trim())), n = n.replace(a[0], m), this.regexp.lastIndex = 0;
      }
      return n;
    }
  }]), t;
}();
function h2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function Ll(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? h2(Object(n), !0).forEach(function(o) {
      $u(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : h2(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function A5(t) {
  var e = t.toLowerCase().trim(), n = {};
  if (t.indexOf("(") > -1) {
    var o = t.split("(");
    e = o[0].toLowerCase().trim();
    var s = o[1].substring(0, o[1].length - 1);
    if (e === "currency" && s.indexOf(":") < 0)
      n.currency || (n.currency = s.trim());
    else if (e === "relativetime" && s.indexOf(":") < 0)
      n.range || (n.range = s.trim());
    else {
      var h = s.split(";");
      h.forEach(function(a) {
        if (!!a) {
          var m = a.split(":"), g = c5(m), b = g[0], T = g.slice(1), M = T.join(":").trim().replace(/^'+|'+$/g, "");
          n[b.trim()] || (n[b.trim()] = M), M === "false" && (n[b.trim()] = !1), M === "true" && (n[b.trim()] = !0), isNaN(M) || (n[b.trim()] = parseInt(M, 10));
        }
      });
    }
  }
  return {
    formatName: e,
    formatOptions: n
  };
}
function af(t) {
  var e = {};
  return function(o, s, h) {
    var a = s + JSON.stringify(h), m = e[a];
    return m || (m = t(s, h), e[a] = m), m(o);
  };
}
var P5 = function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    nl(this, t), this.logger = Ws.create("formatter"), this.options = e, this.formats = {
      number: af(function(n, o) {
        var s = new Intl.NumberFormat(n, Ll({}, o));
        return function(h) {
          return s.format(h);
        };
      }),
      currency: af(function(n, o) {
        var s = new Intl.NumberFormat(n, Ll(Ll({}, o), {}, {
          style: "currency"
        }));
        return function(h) {
          return s.format(h);
        };
      }),
      datetime: af(function(n, o) {
        var s = new Intl.DateTimeFormat(n, Ll({}, o));
        return function(h) {
          return s.format(h);
        };
      }),
      relativetime: af(function(n, o) {
        var s = new Intl.RelativeTimeFormat(n, Ll({}, o));
        return function(h) {
          return s.format(h, o.range || "day");
        };
      }),
      list: af(function(n, o) {
        var s = new Intl.ListFormat(n, Ll({}, o));
        return function(h) {
          return s.format(h);
        };
      })
    }, this.init(e);
  }
  return il(t, [{
    key: "init",
    value: function(n) {
      var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, s = o.interpolation;
      this.formatSeparator = s.formatSeparator ? s.formatSeparator : s.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function(n, o) {
      this.formats[n.toLowerCase().trim()] = o;
    }
  }, {
    key: "addCached",
    value: function(n, o) {
      this.formats[n.toLowerCase().trim()] = af(o);
    }
  }, {
    key: "format",
    value: function(n, o, s) {
      var h = this, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, m = o.split(this.formatSeparator), g = m.reduce(function(b, T) {
        var M = A5(T), I = M.formatName, P = M.formatOptions;
        if (h.formats[I]) {
          var z = b;
          try {
            var V = a && a.formatParams && a.formatParams[a.interpolationkey] || {}, q = V.locale || V.lng || a.locale || a.lng || s;
            z = h.formats[I](b, q, Ll(Ll(Ll({}, P), a), V));
          } catch (re) {
            h.logger.warn(re);
          }
          return z;
        } else
          h.logger.warn("there was no format function for ".concat(I));
        return b;
      }, n);
      return g;
    }
  }]), t;
}();
function f2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function p2(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? f2(Object(n), !0).forEach(function(o) {
      $u(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : f2(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function k5(t) {
  var e = L5();
  return function() {
    var o = tl(t), s;
    if (e) {
      var h = tl(this).constructor;
      s = Reflect.construct(o, arguments, h);
    } else
      s = o.apply(this, arguments);
    return Xd(this, s);
  };
}
function L5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function D5(t, e) {
  t.pending[e] !== void 0 && (delete t.pending[e], t.pendingCount--);
}
var N5 = function(t) {
  Iv(n, t);
  var e = k5(n);
  function n(o, s, h) {
    var a, m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return nl(this, n), a = e.call(this), Ov && Bu.call(Lu(a)), a.backend = o, a.store = s, a.services = h, a.languageUtils = h.languageUtils, a.options = m, a.logger = Ws.create("backendConnector"), a.waitingReads = [], a.maxParallelReads = m.maxParallelReads || 10, a.readingCalls = 0, a.maxRetries = m.maxRetries >= 0 ? m.maxRetries : 5, a.retryTimeout = m.retryTimeout >= 1 ? m.retryTimeout : 350, a.state = {}, a.queue = [], a.backend && a.backend.init && a.backend.init(h, m.backend, m), a;
  }
  return il(n, [{
    key: "queueLoad",
    value: function(s, h, a, m) {
      var g = this, b = {}, T = {}, M = {}, I = {};
      return s.forEach(function(P) {
        var z = !0;
        h.forEach(function(V) {
          var q = "".concat(P, "|").concat(V);
          !a.reload && g.store.hasResourceBundle(P, V) ? g.state[q] = 2 : g.state[q] < 0 || (g.state[q] === 1 ? T[q] === void 0 && (T[q] = !0) : (g.state[q] = 1, z = !1, T[q] === void 0 && (T[q] = !0), b[q] === void 0 && (b[q] = !0), I[V] === void 0 && (I[V] = !0)));
        }), z || (M[P] = !0);
      }), (Object.keys(b).length || Object.keys(T).length) && this.queue.push({
        pending: T,
        pendingCount: Object.keys(T).length,
        loaded: {},
        errors: [],
        callback: m
      }), {
        toLoad: Object.keys(b),
        pending: Object.keys(T),
        toLoadLanguages: Object.keys(M),
        toLoadNamespaces: Object.keys(I)
      };
    }
  }, {
    key: "loaded",
    value: function(s, h, a) {
      var m = s.split("|"), g = m[0], b = m[1];
      h && this.emit("failedLoading", g, b, h), a && this.store.addResourceBundle(g, b, a), this.state[s] = h ? -1 : 2;
      var T = {};
      this.queue.forEach(function(M) {
        d5(M.loaded, [g], b), D5(M, s), h && M.errors.push(h), M.pendingCount === 0 && !M.done && (Object.keys(M.loaded).forEach(function(I) {
          T[I] || (T[I] = {});
          var P = M.loaded[I];
          P.length && P.forEach(function(z) {
            T[I][z] === void 0 && (T[I][z] = !0);
          });
        }), M.done = !0, M.errors.length ? M.callback(M.errors) : M.callback());
      }), this.emit("loaded", T), this.queue = this.queue.filter(function(M) {
        return !M.done;
      });
    }
  }, {
    key: "read",
    value: function(s, h, a) {
      var m = this, g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, b = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, T = arguments.length > 5 ? arguments[5] : void 0;
      if (!s.length)
        return T(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: s,
          ns: h,
          fcName: a,
          tried: g,
          wait: b,
          callback: T
        });
        return;
      }
      this.readingCalls++;
      var M = function(V, q) {
        if (m.readingCalls--, m.waitingReads.length > 0) {
          var re = m.waitingReads.shift();
          m.read(re.lng, re.ns, re.fcName, re.tried, re.wait, re.callback);
        }
        if (V && q && g < m.maxRetries) {
          setTimeout(function() {
            m.read.call(m, s, h, a, g + 1, b * 2, T);
          }, b);
          return;
        }
        T(V, q);
      }, I = this.backend[a].bind(this.backend);
      if (I.length === 2) {
        try {
          var P = I(s, h);
          P && typeof P.then == "function" ? P.then(function(z) {
            return M(null, z);
          }).catch(M) : M(null, P);
        } catch (z) {
          M(z);
        }
        return;
      }
      return I(s, h, M);
    }
  }, {
    key: "prepareLoading",
    value: function(s, h) {
      var a = this, m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, g = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), g && g();
      typeof s == "string" && (s = this.languageUtils.toResolveHierarchy(s)), typeof h == "string" && (h = [h]);
      var b = this.queueLoad(s, h, m, g);
      if (!b.toLoad.length)
        return b.pending.length || g(), null;
      b.toLoad.forEach(function(T) {
        a.loadOne(T);
      });
    }
  }, {
    key: "load",
    value: function(s, h, a) {
      this.prepareLoading(s, h, {}, a);
    }
  }, {
    key: "reload",
    value: function(s, h, a) {
      this.prepareLoading(s, h, {
        reload: !0
      }, a);
    }
  }, {
    key: "loadOne",
    value: function(s) {
      var h = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", m = s.split("|"), g = m[0], b = m[1];
      this.read(g, b, "read", void 0, void 0, function(T, M) {
        T && h.logger.warn("".concat(a, "loading namespace ").concat(b, " for language ").concat(g, " failed"), T), !T && M && h.logger.log("".concat(a, "loaded namespace ").concat(b, " for language ").concat(g), M), h.loaded(s, T, M);
      });
    }
  }, {
    key: "saveMissing",
    value: function(s, h, a, m, g) {
      var b = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, T = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function() {
      };
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(h)) {
        this.logger.warn('did not save key "'.concat(a, '" as the namespace "').concat(h, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (!(a == null || a === "")) {
        if (this.backend && this.backend.create) {
          var M = p2(p2({}, b), {}, {
            isUpdate: g
          }), I = this.backend.create.bind(this.backend);
          if (I.length < 6)
            try {
              var P;
              I.length === 5 ? P = I(s, h, a, m, M) : P = I(s, h, a, m), P && typeof P.then == "function" ? P.then(function(z) {
                return T(null, z);
              }).catch(T) : T(null, P);
            } catch (z) {
              T(z);
            }
          else
            I(s, h, a, m, T, M);
        }
        !s || !s[0] || this.store.addResource(s[0], h, a, m);
      }
    }
  }]), n;
}(Bu);
function d2() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      var n = {};
      if (cs(e[1]) === "object" && (n = e[1]), typeof e[1] == "string" && (n.defaultValue = e[1]), typeof e[2] == "string" && (n.tDescription = e[2]), cs(e[2]) === "object" || cs(e[3]) === "object") {
        var o = e[3] || e[2];
        Object.keys(o).forEach(function(s) {
          n[s] = o[s];
        });
      }
      return n;
    },
    interpolation: {
      escapeValue: !0,
      format: function(e, n, o, s) {
        return e;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function m2(t) {
  return typeof t.ns == "string" && (t.ns = [t.ns]), typeof t.fallbackLng == "string" && (t.fallbackLng = [t.fallbackLng]), typeof t.fallbackNS == "string" && (t.fallbackNS = [t.fallbackNS]), t.supportedLngs && t.supportedLngs.indexOf("cimode") < 0 && (t.supportedLngs = t.supportedLngs.concat(["cimode"])), t;
}
function y2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function Fs(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? y2(Object(n), !0).forEach(function(o) {
      $u(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : y2(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function R5(t) {
  var e = z5();
  return function() {
    var o = tl(t), s;
    if (e) {
      var h = tl(this).constructor;
      s = Reflect.construct(o, arguments, h);
    } else
      s = o.apply(this, arguments);
    return Xd(this, s);
  };
}
function z5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ay() {
}
function F5(t) {
  var e = Object.getOwnPropertyNames(Object.getPrototypeOf(t));
  e.forEach(function(n) {
    typeof t[n] == "function" && (t[n] = t[n].bind(t));
  });
}
var Bg = function(t) {
  Iv(n, t);
  var e = R5(n);
  function n() {
    var o, s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 ? arguments[1] : void 0;
    if (nl(this, n), o = e.call(this), Ov && Bu.call(Lu(o)), o.options = m2(s), o.services = {}, o.logger = Ws, o.modules = {
      external: []
    }, F5(Lu(o)), h && !o.isInitialized && !s.isClone) {
      if (!o.options.initImmediate)
        return o.init(s, h), Xd(o, Lu(o));
      setTimeout(function() {
        o.init(s, h);
      }, 0);
    }
    return o;
  }
  return il(n, [{
    key: "init",
    value: function() {
      var s = this, h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = arguments.length > 1 ? arguments[1] : void 0;
      typeof h == "function" && (a = h, h = {}), !h.defaultNS && h.defaultNS !== !1 && h.ns && (typeof h.ns == "string" ? h.defaultNS = h.ns : h.ns.indexOf("translation") < 0 && (h.defaultNS = h.ns[0]));
      var m = d2();
      this.options = Fs(Fs(Fs({}, m), this.options), m2(h)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = Fs(Fs({}, m.interpolation), this.options.interpolation)), h.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = h.keySeparator), h.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = h.nsSeparator);
      function g(re) {
        return re ? typeof re == "function" ? new re() : re : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? Ws.init(g(this.modules.logger), this.options) : Ws.init(null, this.options);
        var b;
        this.modules.formatter ? b = this.modules.formatter : typeof Intl < "u" && (b = P5);
        var T = new l2(this.options);
        this.store = new b5(this.options.resources, this.options);
        var M = this.services;
        M.logger = Ws, M.resourceStore = this.store, M.languageUtils = T, M.pluralResolver = new O5(T, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), b && (!this.options.interpolation.format || this.options.interpolation.format === m.interpolation.format) && (M.formatter = g(b), M.formatter.init(M, this.options), this.options.interpolation.format = M.formatter.format.bind(M.formatter)), M.interpolator = new C5(this.options), M.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, M.backendConnector = new N5(g(this.modules.backend), M.resourceStore, M, this.options), M.backendConnector.on("*", function(re) {
          for (var X = arguments.length, ae = new Array(X > 1 ? X - 1 : 0), ce = 1; ce < X; ce++)
            ae[ce - 1] = arguments[ce];
          s.emit.apply(s, [re].concat(ae));
        }), this.modules.languageDetector && (M.languageDetector = g(this.modules.languageDetector), M.languageDetector.init && M.languageDetector.init(M, this.options.detection, this.options)), this.modules.i18nFormat && (M.i18nFormat = g(this.modules.i18nFormat), M.i18nFormat.init && M.i18nFormat.init(this)), this.translator = new s2(this.services, this.options), this.translator.on("*", function(re) {
          for (var X = arguments.length, ae = new Array(X > 1 ? X - 1 : 0), ce = 1; ce < X; ce++)
            ae[ce - 1] = arguments[ce];
          s.emit.apply(s, [re].concat(ae));
        }), this.modules.external.forEach(function(re) {
          re.init && re.init(s);
        });
      }
      if (this.format = this.options.interpolation.format, a || (a = Ay), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var I = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        I.length > 0 && I[0] !== "dev" && (this.options.lng = I[0]);
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var P = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      P.forEach(function(re) {
        s[re] = function() {
          var X;
          return (X = s.store)[re].apply(X, arguments);
        };
      });
      var z = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      z.forEach(function(re) {
        s[re] = function() {
          var X;
          return (X = s.store)[re].apply(X, arguments), s;
        };
      });
      var V = Hp(), q = function() {
        var X = function(ce, ve) {
          s.isInitialized && !s.initializedStoreOnce && s.logger.warn("init: i18next is already initialized. You should call init just once!"), s.isInitialized = !0, s.options.isClone || s.logger.log("initialized", s.options), s.emit("initialized", s.options), V.resolve(ve), a(ce, ve);
        };
        if (s.languages && s.options.compatibilityAPI !== "v1" && !s.isInitialized)
          return X(null, s.t.bind(s));
        s.changeLanguage(s.options.lng, X);
      };
      return this.options.resources || !this.options.initImmediate ? q() : setTimeout(q, 0), V;
    }
  }, {
    key: "loadResources",
    value: function(s) {
      var h = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ay, m = a, g = typeof s == "string" ? s : this.language;
      if (typeof s == "function" && (m = s), !this.options.resources || this.options.partialBundledLanguages) {
        if (g && g.toLowerCase() === "cimode")
          return m();
        var b = [], T = function(P) {
          if (!!P) {
            var z = h.services.languageUtils.toResolveHierarchy(P);
            z.forEach(function(V) {
              b.indexOf(V) < 0 && b.push(V);
            });
          }
        };
        if (g)
          T(g);
        else {
          var M = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          M.forEach(function(I) {
            return T(I);
          });
        }
        this.options.preload && this.options.preload.forEach(function(I) {
          return T(I);
        }), this.services.backendConnector.load(b, this.options.ns, function(I) {
          !I && !h.resolvedLanguage && h.language && h.setResolvedLanguage(h.language), m(I);
        });
      } else
        m(null);
    }
  }, {
    key: "reloadResources",
    value: function(s, h, a) {
      var m = Hp();
      return s || (s = this.languages), h || (h = this.options.ns), a || (a = Ay), this.services.backendConnector.reload(s, h, function(g) {
        m.resolve(), a(g);
      }), m;
    }
  }, {
    key: "use",
    value: function(s) {
      if (!s)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!s.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return s.type === "backend" && (this.modules.backend = s), (s.type === "logger" || s.log && s.warn && s.error) && (this.modules.logger = s), s.type === "languageDetector" && (this.modules.languageDetector = s), s.type === "i18nFormat" && (this.modules.i18nFormat = s), s.type === "postProcessor" && UT.addPostProcessor(s), s.type === "formatter" && (this.modules.formatter = s), s.type === "3rdParty" && this.modules.external.push(s), this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function(s) {
      if (!(!s || !this.languages) && !(["cimode", "dev"].indexOf(s) > -1))
        for (var h = 0; h < this.languages.length; h++) {
          var a = this.languages[h];
          if (!(["cimode", "dev"].indexOf(a) > -1) && this.store.hasLanguageSomeTranslations(a)) {
            this.resolvedLanguage = a;
            break;
          }
        }
    }
  }, {
    key: "changeLanguage",
    value: function(s, h) {
      var a = this;
      this.isLanguageChangingTo = s;
      var m = Hp();
      this.emit("languageChanging", s);
      var g = function(I) {
        a.language = I, a.languages = a.services.languageUtils.toResolveHierarchy(I), a.resolvedLanguage = void 0, a.setResolvedLanguage(I);
      }, b = function(I, P) {
        P ? (g(P), a.translator.changeLanguage(P), a.isLanguageChangingTo = void 0, a.emit("languageChanged", P), a.logger.log("languageChanged", P)) : a.isLanguageChangingTo = void 0, m.resolve(function() {
          return a.t.apply(a, arguments);
        }), h && h(I, function() {
          return a.t.apply(a, arguments);
        });
      }, T = function(I) {
        !s && !I && a.services.languageDetector && (I = []);
        var P = typeof I == "string" ? I : a.services.languageUtils.getBestMatchFromCodes(I);
        P && (a.language || g(P), a.translator.language || a.translator.changeLanguage(P), a.services.languageDetector && a.services.languageDetector.cacheUserLanguage && a.services.languageDetector.cacheUserLanguage(P)), a.loadResources(P, function(z) {
          b(z, P);
        });
      };
      return !s && this.services.languageDetector && !this.services.languageDetector.async ? T(this.services.languageDetector.detect()) : !s && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(T) : this.services.languageDetector.detect(T) : T(s), m;
    }
  }, {
    key: "getFixedT",
    value: function(s, h, a) {
      var m = this, g = function b(T, M) {
        var I;
        if (cs(M) !== "object") {
          for (var P = arguments.length, z = new Array(P > 2 ? P - 2 : 0), V = 2; V < P; V++)
            z[V - 2] = arguments[V];
          I = m.options.overloadTranslationOptionHandler([T, M].concat(z));
        } else
          I = Fs({}, M);
        I.lng = I.lng || b.lng, I.lngs = I.lngs || b.lngs, I.ns = I.ns || b.ns, I.keyPrefix = I.keyPrefix || a || b.keyPrefix;
        var q = m.options.keySeparator || ".", re;
        return I.keyPrefix && Array.isArray(T) ? re = T.map(function(X) {
          return "".concat(I.keyPrefix).concat(q).concat(X);
        }) : re = I.keyPrefix ? "".concat(I.keyPrefix).concat(q).concat(T) : T, m.t(re, I);
      };
      return typeof s == "string" ? g.lng = s : g.lngs = s, g.ns = h, g.keyPrefix = a, g;
    }
  }, {
    key: "t",
    value: function() {
      var s;
      return this.translator && (s = this.translator).translate.apply(s, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var s;
      return this.translator && (s = this.translator).exists.apply(s, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(s) {
      this.options.defaultNS = s;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(s) {
      var h = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var m = this.resolvedLanguage || this.languages[0], g = this.options ? this.options.fallbackLng : !1, b = this.languages[this.languages.length - 1];
      if (m.toLowerCase() === "cimode")
        return !0;
      var T = function(P, z) {
        var V = h.services.backendConnector.state["".concat(P, "|").concat(z)];
        return V === -1 || V === 2;
      };
      if (a.precheck) {
        var M = a.precheck(this, T);
        if (M !== void 0)
          return M;
      }
      return !!(this.hasResourceBundle(m, s) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || T(m, s) && (!g || T(b, s)));
    }
  }, {
    key: "loadNamespaces",
    value: function(s, h) {
      var a = this, m = Hp();
      return this.options.ns ? (typeof s == "string" && (s = [s]), s.forEach(function(g) {
        a.options.ns.indexOf(g) < 0 && a.options.ns.push(g);
      }), this.loadResources(function(g) {
        m.resolve(), h && h(g);
      }), m) : (h && h(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(s, h) {
      var a = Hp();
      typeof s == "string" && (s = [s]);
      var m = this.options.preload || [], g = s.filter(function(b) {
        return m.indexOf(b) < 0;
      });
      return g.length ? (this.options.preload = m.concat(g), this.loadResources(function(b) {
        a.resolve(), h && h(b);
      }), a) : (h && h(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(s) {
      if (s || (s = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !s)
        return "rtl";
      var h = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], a = this.services && this.services.languageUtils || new l2(d2());
      return h.indexOf(a.getLanguagePartFromCode(s)) > -1 || s.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var s = this, h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ay, m = Fs(Fs(Fs({}, this.options), h), {
        isClone: !0
      }), g = new n(m);
      (h.debug !== void 0 || h.prefix !== void 0) && (g.logger = g.logger.clone(h));
      var b = ["store", "services", "language"];
      return b.forEach(function(T) {
        g[T] = s[T];
      }), g.services = Fs({}, this.services), g.services.utils = {
        hasLoadedNamespace: g.hasLoadedNamespace.bind(g)
      }, g.translator = new s2(g.services, g.options), g.translator.on("*", function(T) {
        for (var M = arguments.length, I = new Array(M > 1 ? M - 1 : 0), P = 1; P < M; P++)
          I[P - 1] = arguments[P];
        g.emit.apply(g, [T].concat(I));
      }), g.init(m, a), g.translator.options = g.options, g.translator.backendConnector.services.utils = {
        hasLoadedNamespace: g.hasLoadedNamespace.bind(g)
      }, g;
    }
  }, {
    key: "toJSON",
    value: function() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]), n;
}(Bu);
$u(Bg, "createInstance", function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0;
  return new Bg(t, e);
});
var ii = Bg.createInstance();
ii.createInstance = Bg.createInstance;
ii.createInstance;
ii.dir;
ii.init;
ii.loadResources;
ii.reloadResources;
ii.use;
ii.changeLanguage;
ii.getFixedT;
ii.t;
ii.exists;
ii.setDefaultNamespace;
ii.hasLoadedNamespace;
ii.loadNamespaces;
ii.loadLanguages;
const B5 = "/";
var jT = /* @__PURE__ */ ((t) => (t.PNG = "image/png", t.JPG = "image/jpeg", t))(jT || {}), zl = /* @__PURE__ */ ((t) => (t.VALUE = "value", t.RANGE = "range", t))(zl || {}), ug = /* @__PURE__ */ ((t) => (t.DATEPICKER = "datepicker", t.SLIDER = "slider", t))(ug || {});
function V5(t, {
  i18next: e,
  rerenderOn: n = ["languageChanged", "loaded", "added", "removed"]
}) {
  const o = e.t.bind(e), s = _r(new Date()), h = () => s.value = new Date(), a = () => s.value;
  n.forEach((T) => {
    var M;
    switch (T) {
      case "added":
      case "removed":
        (M = e.store) == null || M.on(T, h);
        break;
      default:
        e.on(T, h);
        break;
    }
  }), t.component("i18next", U5), t.mixin({
    beforeCreate() {
      var T, M;
      const I = this.$options;
      if (!I.__i18n && !I.i18nOptions) {
        this.__translate = void 0;
        return;
      }
      const P = this.$options.name, z = (Math.random() * 10 ** 8 | 0).toString(), V = [P, z].filter((ve) => !!ve).join("-");
      this.__bundles = [];
      const q = (ve) => {
        Object.entries(ve).forEach(([Re, Fe]) => {
          e.addResourceBundle(Re, V, Fe, !0, !1), this.__bundles.push([Re, V]);
        });
      };
      (T = I.__i18n) == null || T.forEach((ve) => {
        q(JSON.parse(ve));
      });
      let { lng: re, ns: X, keyPrefix: ae } = b(I, q);
      (M = this.__bundles) != null && M.length && (X = [V].concat(X != null ? X : []));
      const ce = m(re, X);
      this.__translate = (ve, Re) => !ae || g(ve) ? ce(ve, Re) : ce(ae + "." + ve, Re);
    },
    unmounted() {
      var T;
      (T = this.__bundles) == null || T.forEach(([M, I]) => e.removeResourceBundle(M, I));
    }
  }), t.config.globalProperties.$t = function(T, M) {
    var I;
    return a(), e.isInitialized ? ((I = this == null ? void 0 : this.__translate) != null ? I : o)(T, M) : T;
  }, t.config.globalProperties.$i18next = new Proxy(e, {
    get(T, M) {
      return a(), Reflect.get(T, M);
    }
  });
  function m(T, M) {
    return T ? e.getFixedT(T, M) : M ? e.getFixedT(null, M) : o;
  }
  function g(T) {
    const M = e.options.nsSeparator;
    return typeof M == "string" && T.includes(M);
  }
  function b(T, M) {
    let I, P, z;
    if (T.i18nOptions) {
      let V, q;
      ({
        lng: I,
        namespaces: q = e.options.defaultNS,
        keyPrefix: z,
        messages: V
      } = T.i18nOptions), V && M(V), P = typeof q == "string" ? [q] : q, P && e.loadNamespaces(P);
    }
    return { lng: I, ns: P, keyPrefix: z };
  }
}
function En() {
  const t = xv();
  if (!t)
    throw new Error("i18next-vue: No Vue instance in context. Make sure to register the i18next-vue plugin using app.use(...).");
  const e = t.appContext.config.globalProperties;
  return {
    i18next: e.$i18next,
    t: e.$t.bind(t.proxy)
  };
}
var g2 = new RegExp("{\\s*([a-z0-9\\-]+)\\s*}", "gi"), U5 = ar({
  props: {
    translation: {
      type: String,
      required: !0
    }
  },
  setup(t, { slots: e }) {
    return () => {
      const n = t.translation, o = [];
      let s, h = 0;
      for (; (s = g2.exec(n)) !== null; ) {
        o.push(n.substring(h, s.index));
        const a = e[s[1]];
        a ? o.push(...a()) : o.push(s[0]), h = g2.lastIndex;
      }
      return o.push(n.substring(h)), o;
    };
  }
});
class oh extends Error {
}
class j5 extends oh {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class G5 extends oh {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class $5 extends oh {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class nd extends oh {
}
class GT extends oh {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class ka extends oh {
}
class gu extends oh {
  constructor() {
    super("Zone is an abstract class");
  }
}
const Ot = "numeric", ps = "short", ga = "long", Vg = {
  year: Ot,
  month: Ot,
  day: Ot
}, $T = {
  year: Ot,
  month: ps,
  day: Ot
}, q5 = {
  year: Ot,
  month: ps,
  day: Ot,
  weekday: ps
}, qT = {
  year: Ot,
  month: ga,
  day: Ot
}, WT = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga
}, HT = {
  hour: Ot,
  minute: Ot
}, ZT = {
  hour: Ot,
  minute: Ot,
  second: Ot
}, XT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: ps
}, KT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: ga
}, YT = {
  hour: Ot,
  minute: Ot,
  hourCycle: "h23"
}, JT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23"
}, QT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23",
  timeZoneName: ps
}, eM = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23",
  timeZoneName: ga
}, tM = {
  year: Ot,
  month: Ot,
  day: Ot,
  hour: Ot,
  minute: Ot
}, rM = {
  year: Ot,
  month: Ot,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot
}, nM = {
  year: Ot,
  month: ps,
  day: Ot,
  hour: Ot,
  minute: Ot
}, iM = {
  year: Ot,
  month: ps,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot
}, W5 = {
  year: Ot,
  month: ps,
  day: Ot,
  weekday: ps,
  hour: Ot,
  minute: Ot
}, oM = {
  year: Ot,
  month: ga,
  day: Ot,
  hour: Ot,
  minute: Ot,
  timeZoneName: ps
}, aM = {
  year: Ot,
  month: ga,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: ps
}, sM = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga,
  hour: Ot,
  minute: Ot,
  timeZoneName: ga
}, lM = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga,
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: ga
};
class Kd {
  get type() {
    throw new gu();
  }
  get name() {
    throw new gu();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new gu();
  }
  offsetName(e, n) {
    throw new gu();
  }
  formatOffset(e, n) {
    throw new gu();
  }
  offset(e) {
    throw new gu();
  }
  equals(e) {
    throw new gu();
  }
  get isValid() {
    throw new gu();
  }
}
let Z_ = null;
class Cv extends Kd {
  static get instance() {
    return Z_ === null && (Z_ = new Cv()), Z_;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: n, locale: o }) {
    return cM(e, n, o);
  }
  formatOffset(e, n) {
    return vd(this.offset(e), n);
  }
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  equals(e) {
    return e.type === "system";
  }
  get isValid() {
    return !0;
  }
}
let cg = {};
function H5(t) {
  return cg[t] || (cg[t] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: t,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), cg[t];
}
const Z5 = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function X5(t, e) {
  const n = t.format(e).replace(/\u200E/g, ""), o = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n), [, s, h, a, m, g, b, T] = o;
  return [a, s, h, m, g, b, T];
}
function K5(t, e) {
  const n = t.formatToParts(e), o = [];
  for (let s = 0; s < n.length; s++) {
    const { type: h, value: a } = n[s], m = Z5[h];
    h === "era" ? o[m] = a : Hr(m) || (o[m] = parseInt(a, 10));
  }
  return o;
}
let Py = {};
class $l extends Kd {
  static create(e) {
    return Py[e] || (Py[e] = new $l(e)), Py[e];
  }
  static resetCache() {
    Py = {}, cg = {};
  }
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  static isValidZone(e) {
    if (!e)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = $l.isValidZone(e);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: n, locale: o }) {
    return cM(e, n, o, this.name);
  }
  formatOffset(e, n) {
    return vd(this.offset(e), n);
  }
  offset(e) {
    const n = new Date(e);
    if (isNaN(n))
      return NaN;
    const o = H5(this.name);
    let [s, h, a, m, g, b, T] = o.formatToParts ? K5(o, n) : X5(o, n);
    m === "BC" && (s = -Math.abs(s) + 1);
    const I = Pv({
      year: s,
      month: h,
      day: a,
      hour: g === 24 ? 0 : g,
      minute: b,
      second: T,
      millisecond: 0
    });
    let P = +n;
    const z = P % 1e3;
    return P -= z >= 0 ? z : 1e3 + z, (I - P) / (60 * 1e3);
  }
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
}
let v2 = {};
function Y5(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let o = v2[n];
  return o || (o = new Intl.ListFormat(t, e), v2[n] = o), o;
}
let Q0 = {};
function e1(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let o = Q0[n];
  return o || (o = new Intl.DateTimeFormat(t, e), Q0[n] = o), o;
}
let t1 = {};
function J5(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let o = t1[n];
  return o || (o = new Intl.NumberFormat(t, e), t1[n] = o), o;
}
let r1 = {};
function Q5(t, e = {}) {
  const { base: n, ...o } = e, s = JSON.stringify([t, o]);
  let h = r1[s];
  return h || (h = new Intl.RelativeTimeFormat(t, e), r1[s] = h), h;
}
let id = null;
function ez() {
  return id || (id = new Intl.DateTimeFormat().resolvedOptions().locale, id);
}
function tz(t) {
  const e = t.indexOf("-x-");
  e !== -1 && (t = t.substring(0, e));
  const n = t.indexOf("-u-");
  if (n === -1)
    return [t];
  {
    let o, s;
    try {
      o = e1(t).resolvedOptions(), s = t;
    } catch {
      const g = t.substring(0, n);
      o = e1(g).resolvedOptions(), s = g;
    }
    const { numberingSystem: h, calendar: a } = o;
    return [s, h, a];
  }
}
function rz(t, e, n) {
  return (n || e) && (t.includes("-u-") || (t += "-u"), n && (t += `-ca-${n}`), e && (t += `-nu-${e}`)), t;
}
function nz(t) {
  const e = [];
  for (let n = 1; n <= 12; n++) {
    const o = Er.utc(2009, n, 1);
    e.push(t(o));
  }
  return e;
}
function iz(t) {
  const e = [];
  for (let n = 1; n <= 7; n++) {
    const o = Er.utc(2016, 11, 13 + n);
    e.push(t(o));
  }
  return e;
}
function ky(t, e, n, o) {
  const s = t.listingMode();
  return s === "error" ? null : s === "en" ? n(e) : o(e);
}
function oz(t) {
  return t.numberingSystem && t.numberingSystem !== "latn" ? !1 : t.numberingSystem === "latn" || !t.locale || t.locale.startsWith("en") || new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem === "latn";
}
class az {
  constructor(e, n, o) {
    this.padTo = o.padTo || 0, this.floor = o.floor || !1;
    const { padTo: s, floor: h, ...a } = o;
    if (!n || Object.keys(a).length > 0) {
      const m = { useGrouping: !1, ...o };
      o.padTo > 0 && (m.minimumIntegerDigits = o.padTo), this.inf = J5(e, m);
    }
  }
  format(e) {
    if (this.inf) {
      const n = this.floor ? Math.floor(e) : e;
      return this.inf.format(n);
    } else {
      const n = this.floor ? Math.floor(e) : X1(e, 3);
      return Ai(n, this.padTo);
    }
  }
}
class sz {
  constructor(e, n, o) {
    this.opts = o, this.originalZone = void 0;
    let s;
    if (this.opts.timeZone)
      this.dt = e;
    else if (e.zone.type === "fixed") {
      const a = -1 * (e.offset / 60), m = a >= 0 ? `Etc/GMT+${a}` : `Etc/GMT${a}`;
      e.offset !== 0 && $l.create(m).valid ? (s = m, this.dt = e) : (s = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    } else
      e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, s = e.zone.name) : (s = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    const h = { ...this.opts };
    h.timeZone = h.timeZone || s, this.dtf = e1(n, h);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? e.map((n) => {
      if (n.type === "timeZoneName") {
        const o = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...n,
          value: o
        };
      } else
        return n;
    }) : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class lz {
  constructor(e, n, o) {
    this.opts = { style: "long", ...o }, !n && uM() && (this.rtf = Q5(e, o));
  }
  format(e, n) {
    return this.rtf ? this.rtf.format(e, n) : Mz(n, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, n) {
    return this.rtf ? this.rtf.formatToParts(e, n) : [];
  }
}
class Fn {
  static fromOpts(e) {
    return Fn.create(e.locale, e.numberingSystem, e.outputCalendar, e.defaultToEN);
  }
  static create(e, n, o, s = !1) {
    const h = e || Ci.defaultLocale, a = h || (s ? "en-US" : ez()), m = n || Ci.defaultNumberingSystem, g = o || Ci.defaultOutputCalendar;
    return new Fn(a, m, g, h);
  }
  static resetCache() {
    id = null, Q0 = {}, t1 = {}, r1 = {};
  }
  static fromObject({ locale: e, numberingSystem: n, outputCalendar: o } = {}) {
    return Fn.create(e, n, o);
  }
  constructor(e, n, o, s) {
    const [h, a, m] = tz(e);
    this.locale = h, this.numberingSystem = n || a || null, this.outputCalendar = o || m || null, this.intl = rz(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = s, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = oz(this)), this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish(), n = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && n ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : Fn.create(
      e.locale || this.specifiedLocale,
      e.numberingSystem || this.numberingSystem,
      e.outputCalendar || this.outputCalendar,
      e.defaultToEN || !1
    );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, n = !1) {
    return ky(this, e, pM, () => {
      const o = n ? { month: e, day: "numeric" } : { month: e }, s = n ? "format" : "standalone";
      return this.monthsCache[s][e] || (this.monthsCache[s][e] = nz((h) => this.extract(h, o, "month"))), this.monthsCache[s][e];
    });
  }
  weekdays(e, n = !1) {
    return ky(this, e, yM, () => {
      const o = n ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, s = n ? "format" : "standalone";
      return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = iz(
        (h) => this.extract(h, o, "weekday")
      )), this.weekdaysCache[s][e];
    });
  }
  meridiems() {
    return ky(
      this,
      void 0,
      () => gM,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [Er.utc(2016, 11, 13, 9), Er.utc(2016, 11, 13, 19)].map(
            (n) => this.extract(n, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return ky(this, e, vM, () => {
      const n = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [Er.utc(-40, 1, 1), Er.utc(2017, 1, 1)].map(
        (o) => this.extract(o, n, "era")
      )), this.eraCache[e];
    });
  }
  extract(e, n, o) {
    const s = this.dtFormatter(e, n), h = s.formatToParts(), a = h.find((m) => m.type.toLowerCase() === o);
    return a ? a.value : null;
  }
  numberFormatter(e = {}) {
    return new az(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, n = {}) {
    return new sz(e, this.intl, n);
  }
  relFormatter(e = {}) {
    return new lz(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return Y5(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
}
let X_ = null;
class Fo extends Kd {
  static get utcInstance() {
    return X_ === null && (X_ = new Fo(0)), X_;
  }
  static instance(e) {
    return e === 0 ? Fo.utcInstance : new Fo(e);
  }
  static parseSpecifier(e) {
    if (e) {
      const n = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (n)
        return new Fo(kv(n[1], n[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${vd(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${vd(-this.fixed, "narrow")}`;
  }
  offsetName() {
    return this.name;
  }
  formatOffset(e, n) {
    return vd(this.fixed, n);
  }
  get isUniversal() {
    return !0;
  }
  offset() {
    return this.fixed;
  }
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  get isValid() {
    return !0;
  }
}
class uz extends Kd {
  constructor(e) {
    super(), this.zoneName = e;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return !1;
  }
  get isValid() {
    return !1;
  }
}
function Iu(t, e) {
  if (Hr(t) || t === null)
    return e;
  if (t instanceof Kd)
    return t;
  if (cz(t)) {
    const n = t.toLowerCase();
    return n === "default" ? e : n === "local" || n === "system" ? Cv.instance : n === "utc" || n === "gmt" ? Fo.utcInstance : Fo.parseSpecifier(n) || $l.create(t);
  } else
    return Zc(t) ? Fo.instance(t) : typeof t == "object" && "offset" in t && typeof t.offset == "function" ? t : new uz(t);
}
let _2 = () => Date.now(), x2 = "system", b2 = null, w2 = null, E2 = null, S2 = 60, T2;
class Ci {
  static get now() {
    return _2;
  }
  static set now(e) {
    _2 = e;
  }
  static set defaultZone(e) {
    x2 = e;
  }
  static get defaultZone() {
    return Iu(x2, Cv.instance);
  }
  static get defaultLocale() {
    return b2;
  }
  static set defaultLocale(e) {
    b2 = e;
  }
  static get defaultNumberingSystem() {
    return w2;
  }
  static set defaultNumberingSystem(e) {
    w2 = e;
  }
  static get defaultOutputCalendar() {
    return E2;
  }
  static set defaultOutputCalendar(e) {
    E2 = e;
  }
  static get twoDigitCutoffYear() {
    return S2;
  }
  static set twoDigitCutoffYear(e) {
    S2 = e % 100;
  }
  static get throwOnInvalid() {
    return T2;
  }
  static set throwOnInvalid(e) {
    T2 = e;
  }
  static resetCaches() {
    Fn.resetCache(), $l.resetCache();
  }
}
function Hr(t) {
  return typeof t > "u";
}
function Zc(t) {
  return typeof t == "number";
}
function Av(t) {
  return typeof t == "number" && t % 1 === 0;
}
function cz(t) {
  return typeof t == "string";
}
function hz(t) {
  return Object.prototype.toString.call(t) === "[object Date]";
}
function uM() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function fz(t) {
  return Array.isArray(t) ? t : [t];
}
function M2(t, e, n) {
  if (t.length !== 0)
    return t.reduce((o, s) => {
      const h = [e(s), s];
      return o && n(o[0], h[0]) === o[0] ? o : h;
    }, null)[1];
}
function pz(t, e) {
  return e.reduce((n, o) => (n[o] = t[o], n), {});
}
function zf(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function Fl(t, e, n) {
  return Av(t) && t >= e && t <= n;
}
function dz(t, e) {
  return t - e * Math.floor(t / e);
}
function Ai(t, e = 2) {
  const n = t < 0;
  let o;
  return n ? o = "-" + ("" + -t).padStart(e, "0") : o = ("" + t).padStart(e, "0"), o;
}
function Eu(t) {
  if (!(Hr(t) || t === null || t === ""))
    return parseInt(t, 10);
}
function Cc(t) {
  if (!(Hr(t) || t === null || t === ""))
    return parseFloat(t);
}
function Z1(t) {
  if (!(Hr(t) || t === null || t === "")) {
    const e = parseFloat("0." + t) * 1e3;
    return Math.floor(e);
  }
}
function mz(t) {
  return t > 0 ? Math.floor(t) : Math.ceil(t);
}
function X1(t, e, n = !1) {
  const o = 10 ** e;
  return (n ? Math.trunc : Math.round)(t * o) / o;
}
function Yd(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function gd(t) {
  return Yd(t) ? 366 : 365;
}
function Ug(t, e) {
  const n = dz(e - 1, 12) + 1, o = t + (e - n) / 12;
  return n === 2 ? Yd(o) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1];
}
function Pv(t) {
  let e = Date.UTC(
    t.year,
    t.month - 1,
    t.day,
    t.hour,
    t.minute,
    t.second,
    t.millisecond
  );
  return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(t.year, t.month - 1, t.day)), +e;
}
function jg(t) {
  const e = (t + Math.floor(t / 4) - Math.floor(t / 100) + Math.floor(t / 400)) % 7, n = t - 1, o = (n + Math.floor(n / 4) - Math.floor(n / 100) + Math.floor(n / 400)) % 7;
  return e === 4 || o === 3 ? 53 : 52;
}
function n1(t) {
  return t > 99 ? t : t > Ci.twoDigitCutoffYear ? 1900 + t : 2e3 + t;
}
function cM(t, e, n, o = null) {
  const s = new Date(t), h = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  o && (h.timeZone = o);
  const a = { timeZoneName: e, ...h }, m = new Intl.DateTimeFormat(n, a).formatToParts(s).find((g) => g.type.toLowerCase() === "timezonename");
  return m ? m.value : null;
}
function kv(t, e) {
  let n = parseInt(t, 10);
  Number.isNaN(n) && (n = 0);
  const o = parseInt(e, 10) || 0, s = n < 0 || Object.is(n, -0) ? -o : o;
  return n * 60 + s;
}
function hM(t) {
  const e = Number(t);
  if (typeof t == "boolean" || t === "" || Number.isNaN(e))
    throw new ka(`Invalid unit value ${t}`);
  return e;
}
function Gg(t, e) {
  const n = {};
  for (const o in t)
    if (zf(t, o)) {
      const s = t[o];
      if (s == null)
        continue;
      n[e(o)] = hM(s);
    }
  return n;
}
function vd(t, e) {
  const n = Math.trunc(Math.abs(t / 60)), o = Math.trunc(Math.abs(t % 60)), s = t >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${s}${Ai(n, 2)}:${Ai(o, 2)}`;
    case "narrow":
      return `${s}${n}${o > 0 ? `:${o}` : ""}`;
    case "techie":
      return `${s}${Ai(n, 2)}${Ai(o, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function Lv(t) {
  return pz(t, ["hour", "minute", "second", "millisecond"]);
}
const yz = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], fM = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], gz = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function pM(t) {
  switch (t) {
    case "narrow":
      return [...gz];
    case "short":
      return [...fM];
    case "long":
      return [...yz];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const dM = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], mM = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], vz = ["M", "T", "W", "T", "F", "S", "S"];
function yM(t) {
  switch (t) {
    case "narrow":
      return [...vz];
    case "short":
      return [...mM];
    case "long":
      return [...dM];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const gM = ["AM", "PM"], _z = ["Before Christ", "Anno Domini"], xz = ["BC", "AD"], bz = ["B", "A"];
function vM(t) {
  switch (t) {
    case "narrow":
      return [...bz];
    case "short":
      return [...xz];
    case "long":
      return [..._z];
    default:
      return null;
  }
}
function wz(t) {
  return gM[t.hour < 12 ? 0 : 1];
}
function Ez(t, e) {
  return yM(e)[t.weekday - 1];
}
function Sz(t, e) {
  return pM(e)[t.month - 1];
}
function Tz(t, e) {
  return vM(e)[t.year < 0 ? 0 : 1];
}
function Mz(t, e, n = "always", o = !1) {
  const s = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, h = ["hours", "minutes", "seconds"].indexOf(t) === -1;
  if (n === "auto" && h) {
    const M = t === "days";
    switch (e) {
      case 1:
        return M ? "tomorrow" : `next ${s[t][0]}`;
      case -1:
        return M ? "yesterday" : `last ${s[t][0]}`;
      case 0:
        return M ? "today" : `this ${s[t][0]}`;
    }
  }
  const a = Object.is(e, -0) || e < 0, m = Math.abs(e), g = m === 1, b = s[t], T = o ? g ? b[1] : b[2] || b[1] : g ? s[t][0] : t;
  return a ? `${m} ${T} ago` : `in ${m} ${T}`;
}
function I2(t, e) {
  let n = "";
  for (const o of t)
    o.literal ? n += o.val : n += e(o.val);
  return n;
}
const Iz = {
  D: Vg,
  DD: $T,
  DDD: qT,
  DDDD: WT,
  t: HT,
  tt: ZT,
  ttt: XT,
  tttt: KT,
  T: YT,
  TT: JT,
  TTT: QT,
  TTTT: eM,
  f: tM,
  ff: nM,
  fff: oM,
  ffff: sM,
  F: rM,
  FF: iM,
  FFF: aM,
  FFFF: lM
};
class bo {
  static create(e, n = {}) {
    return new bo(e, n);
  }
  static parseFormat(e) {
    let n = null, o = "", s = !1;
    const h = [];
    for (let a = 0; a < e.length; a++) {
      const m = e.charAt(a);
      m === "'" ? (o.length > 0 && h.push({ literal: s || /^\s+$/.test(o), val: o }), n = null, o = "", s = !s) : s || m === n ? o += m : (o.length > 0 && h.push({ literal: /^\s+$/.test(o), val: o }), o = m, n = m);
    }
    return o.length > 0 && h.push({ literal: s || /^\s+$/.test(o), val: o }), h;
  }
  static macroTokenToFormatOpts(e) {
    return Iz[e];
  }
  constructor(e, n) {
    this.opts = n, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, n) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...n }).format();
  }
  dtFormatter(e, n = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...n });
  }
  formatDateTime(e, n) {
    return this.dtFormatter(e, n).format();
  }
  formatDateTimeParts(e, n) {
    return this.dtFormatter(e, n).formatToParts();
  }
  formatInterval(e, n) {
    return this.dtFormatter(e.start, n).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, n) {
    return this.dtFormatter(e, n).resolvedOptions();
  }
  num(e, n = 0) {
    if (this.opts.forceSimple)
      return Ai(e, n);
    const o = { ...this.opts };
    return n > 0 && (o.padTo = n), this.loc.numberFormatter(o).format(e);
  }
  formatDateTimeFromString(e, n) {
    const o = this.loc.listingMode() === "en", s = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", h = (P, z) => this.loc.extract(e, P, z), a = (P) => e.isOffsetFixed && e.offset === 0 && P.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, P.format) : "", m = () => o ? wz(e) : h({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), g = (P, z) => o ? Sz(e, P) : h(z ? { month: P } : { month: P, day: "numeric" }, "month"), b = (P, z) => o ? Ez(e, P) : h(
      z ? { weekday: P } : { weekday: P, month: "long", day: "numeric" },
      "weekday"
    ), T = (P) => {
      const z = bo.macroTokenToFormatOpts(P);
      return z ? this.formatWithSystemDefault(e, z) : P;
    }, M = (P) => o ? Tz(e, P) : h({ era: P }, "era"), I = (P) => {
      switch (P) {
        case "S":
          return this.num(e.millisecond);
        case "u":
        case "SSS":
          return this.num(e.millisecond, 3);
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        case "Z":
          return a({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return a({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return a({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return e.zoneName;
        case "a":
          return m();
        case "d":
          return s ? h({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return s ? h({ day: "2-digit" }, "day") : this.num(e.day, 2);
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return b("short", !0);
        case "cccc":
          return b("long", !0);
        case "ccccc":
          return b("narrow", !0);
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return b("short", !1);
        case "EEEE":
          return b("long", !1);
        case "EEEEE":
          return b("narrow", !1);
        case "L":
          return s ? h({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return s ? h({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return g("short", !0);
        case "LLLL":
          return g("long", !0);
        case "LLLLL":
          return g("narrow", !0);
        case "M":
          return s ? h({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return s ? h({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return g("short", !1);
        case "MMMM":
          return g("long", !1);
        case "MMMMM":
          return g("narrow", !1);
        case "y":
          return s ? h({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return s ? h({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return s ? h({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return s ? h({ year: "numeric" }, "year") : this.num(e.year, 6);
        case "G":
          return M("short");
        case "GG":
          return M("long");
        case "GGGGG":
          return M("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return T(P);
      }
    };
    return I2(bo.parseFormat(n), I);
  }
  formatDurationFromString(e, n) {
    const o = (g) => {
      switch (g[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, s = (g) => (b) => {
      const T = o(b);
      return T ? this.num(g.get(T), b.length) : b;
    }, h = bo.parseFormat(n), a = h.reduce(
      (g, { literal: b, val: T }) => b ? g : g.concat(T),
      []
    ), m = e.shiftTo(...a.map(o).filter((g) => g));
    return I2(h, s(m));
  }
}
class as {
  constructor(e, n) {
    this.reason = e, this.explanation = n;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const _M = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function Vf(...t) {
  const e = t.reduce((n, o) => n + o.source, "");
  return RegExp(`^${e}$`);
}
function Uf(...t) {
  return (e) => t.reduce(
    ([n, o, s], h) => {
      const [a, m, g] = h(e, s);
      return [{ ...n, ...a }, m || o, g];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function jf(t, ...e) {
  if (t == null)
    return [null, null];
  for (const [n, o] of e) {
    const s = n.exec(t);
    if (s)
      return o(s);
  }
  return [null, null];
}
function xM(...t) {
  return (e, n) => {
    const o = {};
    let s;
    for (s = 0; s < t.length; s++)
      o[t[s]] = Eu(e[n + s]);
    return [o, null, n + s];
  };
}
const bM = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, Oz = `(?:${bM.source}?(?:\\[(${_M.source})\\])?)?`, K1 = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, wM = RegExp(`${K1.source}${Oz}`), Y1 = RegExp(`(?:T${wM.source})?`), Cz = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, Az = /(\d{4})-?W(\d\d)(?:-?(\d))?/, Pz = /(\d{4})-?(\d{3})/, kz = xM("weekYear", "weekNumber", "weekDay"), Lz = xM("year", "ordinal"), Dz = /(\d{4})-(\d\d)-(\d\d)/, EM = RegExp(
  `${K1.source} ?(?:${bM.source}|(${_M.source}))?`
), Nz = RegExp(`(?: ${EM.source})?`);
function Of(t, e, n) {
  const o = t[e];
  return Hr(o) ? n : Eu(o);
}
function Rz(t, e) {
  return [{
    year: Of(t, e),
    month: Of(t, e + 1, 1),
    day: Of(t, e + 2, 1)
  }, null, e + 3];
}
function Gf(t, e) {
  return [{
    hours: Of(t, e, 0),
    minutes: Of(t, e + 1, 0),
    seconds: Of(t, e + 2, 0),
    milliseconds: Z1(t[e + 3])
  }, null, e + 4];
}
function Jd(t, e) {
  const n = !t[e] && !t[e + 1], o = kv(t[e + 1], t[e + 2]), s = n ? null : Fo.instance(o);
  return [{}, s, e + 3];
}
function Qd(t, e) {
  const n = t[e] ? $l.create(t[e]) : null;
  return [{}, n, e + 1];
}
const zz = RegExp(`^T?${K1.source}$`), Fz = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function Bz(t) {
  const [e, n, o, s, h, a, m, g, b] = t, T = e[0] === "-", M = g && g[0] === "-", I = (P, z = !1) => P !== void 0 && (z || P && T) ? -P : P;
  return [
    {
      years: I(Cc(n)),
      months: I(Cc(o)),
      weeks: I(Cc(s)),
      days: I(Cc(h)),
      hours: I(Cc(a)),
      minutes: I(Cc(m)),
      seconds: I(Cc(g), g === "-0"),
      milliseconds: I(Z1(b), M)
    }
  ];
}
const Vz = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function J1(t, e, n, o, s, h, a) {
  const m = {
    year: e.length === 2 ? n1(Eu(e)) : Eu(e),
    month: fM.indexOf(n) + 1,
    day: Eu(o),
    hour: Eu(s),
    minute: Eu(h)
  };
  return a && (m.second = Eu(a)), t && (m.weekday = t.length > 3 ? dM.indexOf(t) + 1 : mM.indexOf(t) + 1), m;
}
const Uz = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function jz(t) {
  const [
    ,
    e,
    n,
    o,
    s,
    h,
    a,
    m,
    g,
    b,
    T,
    M
  ] = t, I = J1(e, s, o, n, h, a, m);
  let P;
  return g ? P = Vz[g] : b ? P = 0 : P = kv(T, M), [I, new Fo(P)];
}
function Gz(t) {
  return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const $z = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, qz = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Wz = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function O2(t) {
  const [, e, n, o, s, h, a, m] = t;
  return [J1(e, s, o, n, h, a, m), Fo.utcInstance];
}
function Hz(t) {
  const [, e, n, o, s, h, a, m] = t;
  return [J1(e, m, n, o, s, h, a), Fo.utcInstance];
}
const Zz = Vf(Cz, Y1), Xz = Vf(Az, Y1), Kz = Vf(Pz, Y1), Yz = Vf(wM), SM = Uf(
  Rz,
  Gf,
  Jd,
  Qd
), Jz = Uf(
  kz,
  Gf,
  Jd,
  Qd
), Qz = Uf(
  Lz,
  Gf,
  Jd,
  Qd
), e6 = Uf(
  Gf,
  Jd,
  Qd
);
function t6(t) {
  return jf(
    t,
    [Zz, SM],
    [Xz, Jz],
    [Kz, Qz],
    [Yz, e6]
  );
}
function r6(t) {
  return jf(Gz(t), [Uz, jz]);
}
function n6(t) {
  return jf(
    t,
    [$z, O2],
    [qz, O2],
    [Wz, Hz]
  );
}
function i6(t) {
  return jf(t, [Fz, Bz]);
}
const o6 = Uf(Gf);
function a6(t) {
  return jf(t, [zz, o6]);
}
const s6 = Vf(Dz, Nz), l6 = Vf(EM), u6 = Uf(
  Gf,
  Jd,
  Qd
);
function c6(t) {
  return jf(
    t,
    [s6, SM],
    [l6, u6]
  );
}
const C2 = "Invalid Duration", TM = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, h6 = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...TM
}, Oa = 146097 / 400, sf = 146097 / 4800, f6 = {
  years: {
    quarters: 4,
    months: 12,
    weeks: Oa / 7,
    days: Oa,
    hours: Oa * 24,
    minutes: Oa * 24 * 60,
    seconds: Oa * 24 * 60 * 60,
    milliseconds: Oa * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: Oa / 28,
    days: Oa / 4,
    hours: Oa * 24 / 4,
    minutes: Oa * 24 * 60 / 4,
    seconds: Oa * 24 * 60 * 60 / 4,
    milliseconds: Oa * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: sf / 7,
    days: sf,
    hours: sf * 24,
    minutes: sf * 24 * 60,
    seconds: sf * 24 * 60 * 60,
    milliseconds: sf * 24 * 60 * 60 * 1e3
  },
  ...TM
}, zc = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], MM = zc.slice(0).reverse();
function vu(t, e, n = !1) {
  const o = {
    values: n ? e.values : { ...t.values, ...e.values || {} },
    loc: t.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy,
    matrix: e.matrix || t.matrix
  };
  return new Yr(o);
}
function A2(t) {
  return Math.trunc(t * 1e3) / 1e3;
}
function IM(t, e, n, o, s) {
  const h = t[s][n], a = e[n] / h, m = mz(a);
  o[s] = A2(o[s] + m), e[n] = A2(e[n] - m * h);
}
function p6(t, e) {
  MM.reduce((n, o) => Hr(e[o]) ? n : (n && IM(t, e, n, e, o), o), null);
}
function d6(t) {
  const e = {};
  for (const [n, o] of Object.entries(t))
    o !== 0 && (e[n] = o);
  return e;
}
class Yr {
  constructor(e) {
    const n = e.conversionAccuracy === "longterm" || !1;
    let o = n ? f6 : h6;
    e.matrix && (o = e.matrix), this.values = e.values, this.loc = e.loc || Fn.create(), this.conversionAccuracy = n ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = o, this.isLuxonDuration = !0;
  }
  static fromMillis(e, n) {
    return Yr.fromObject({ milliseconds: e }, n);
  }
  static fromObject(e, n = {}) {
    if (e == null || typeof e != "object")
      throw new ka(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
      );
    return new Yr({
      values: Gg(e, Yr.normalizeUnit),
      loc: Fn.fromObject(n),
      conversionAccuracy: n.conversionAccuracy,
      matrix: n.matrix
    });
  }
  static fromDurationLike(e) {
    if (Zc(e))
      return Yr.fromMillis(e);
    if (Yr.isDuration(e))
      return e;
    if (typeof e == "object")
      return Yr.fromObject(e);
    throw new ka(
      `Unknown duration argument ${e} of type ${typeof e}`
    );
  }
  static fromISO(e, n) {
    const [o] = i6(e);
    return o ? Yr.fromObject(o, n) : Yr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static fromISOTime(e, n) {
    const [o] = a6(e);
    return o ? Yr.fromObject(o, n) : Yr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static invalid(e, n = null) {
    if (!e)
      throw new ka("need to specify a reason the Duration is invalid");
    const o = e instanceof as ? e : new as(e, n);
    if (Ci.throwOnInvalid)
      throw new $5(o);
    return new Yr({ invalid: o });
  }
  static normalizeUnit(e) {
    const n = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[e && e.toLowerCase()];
    if (!n)
      throw new GT(e);
    return n;
  }
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(e, n = {}) {
    const o = {
      ...n,
      floor: n.round !== !1 && n.floor !== !1
    };
    return this.isValid ? bo.create(this.loc, o).formatDurationFromString(this, e) : C2;
  }
  toHuman(e = {}) {
    if (!this.isValid)
      return C2;
    const n = zc.map((o) => {
      const s = this.values[o];
      return Hr(s) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: o.slice(0, -1) }).format(s);
    }).filter((o) => o);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(n);
  }
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  toISO() {
    if (!this.isValid)
      return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += X1(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  toISOTime(e = {}) {
    if (!this.isValid)
      return null;
    const n = this.toMillis();
    return n < 0 || n >= 864e5 ? null : (e = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...e,
      includeOffset: !1
    }, Er.fromMillis(n, { zone: "UTC" }).toISOTime(e));
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  toMillis() {
    var n;
    if (!this.isValid)
      return NaN;
    let e = (n = this.values.milliseconds) != null ? n : 0;
    for (let o of MM.slice(1))
      this.values[o] && (e += this.values[o] * this.matrix[o].milliseconds);
    return e;
  }
  valueOf() {
    return this.toMillis();
  }
  plus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e), o = {};
    for (const s of zc)
      (zf(n.values, s) || zf(this.values, s)) && (o[s] = n.get(s) + this.get(s));
    return vu(this, { values: o }, !0);
  }
  minus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e);
    return this.plus(n.negate());
  }
  mapUnits(e) {
    if (!this.isValid)
      return this;
    const n = {};
    for (const o of Object.keys(this.values))
      n[o] = hM(e(this.values[o], o));
    return vu(this, { values: n }, !0);
  }
  get(e) {
    return this[Yr.normalizeUnit(e)];
  }
  set(e) {
    if (!this.isValid)
      return this;
    const n = { ...this.values, ...Gg(e, Yr.normalizeUnit) };
    return vu(this, { values: n });
  }
  reconfigure({ locale: e, numberingSystem: n, conversionAccuracy: o, matrix: s } = {}) {
    const a = { loc: this.loc.clone({ locale: e, numberingSystem: n }), matrix: s, conversionAccuracy: o };
    return vu(this, a);
  }
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  normalize() {
    if (!this.isValid)
      return this;
    const e = this.toObject();
    return this.valueOf() >= 0 ? (p6(this.matrix, e), vu(this, { values: e }, !0)) : this.negate().normalize().negate();
  }
  rescale() {
    if (!this.isValid)
      return this;
    const e = d6(this.normalize().shiftToAll().toObject());
    return vu(this, { values: e }, !0);
  }
  shiftTo(...e) {
    if (!this.isValid)
      return this;
    if (e.length === 0)
      return this;
    e = e.map((a) => Yr.normalizeUnit(a));
    const n = {}, o = {}, s = this.toObject();
    let h;
    for (const a of zc)
      if (e.indexOf(a) >= 0) {
        h = a;
        let m = 0;
        for (const b in o)
          m += this.matrix[b][a] * o[b], o[b] = 0;
        Zc(s[a]) && (m += s[a]);
        const g = Math.trunc(m);
        n[a] = g, o[a] = (m * 1e3 - g * 1e3) / 1e3;
        for (const b in s)
          zc.indexOf(b) > zc.indexOf(a) && IM(this.matrix, s, b, n, a);
      } else
        Zc(s[a]) && (o[a] = s[a]);
    for (const a in o)
      o[a] !== 0 && (n[h] += a === h ? o[a] : o[a] / this.matrix[h][a]);
    return vu(this, { values: n }, !0).normalize();
  }
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  negate() {
    if (!this.isValid)
      return this;
    const e = {};
    for (const n of Object.keys(this.values))
      e[n] = this.values[n] === 0 ? 0 : -this.values[n];
    return vu(this, { values: e }, !0);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
      return !1;
    function n(o, s) {
      return o === void 0 || o === 0 ? s === void 0 || s === 0 : o === s;
    }
    for (const o of zc)
      if (!n(this.values[o], e.values[o]))
        return !1;
    return !0;
  }
}
const lf = "Invalid Interval";
function m6(t, e) {
  return !t || !t.isValid ? fi.invalid("missing or invalid start") : !e || !e.isValid ? fi.invalid("missing or invalid end") : e < t ? fi.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`
  ) : null;
}
class fi {
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  static invalid(e, n = null) {
    if (!e)
      throw new ka("need to specify a reason the Interval is invalid");
    const o = e instanceof as ? e : new as(e, n);
    if (Ci.throwOnInvalid)
      throw new G5(o);
    return new fi({ invalid: o });
  }
  static fromDateTimes(e, n) {
    const o = Xp(e), s = Xp(n), h = m6(o, s);
    return h == null ? new fi({
      start: o,
      end: s
    }) : h;
  }
  static after(e, n) {
    const o = Yr.fromDurationLike(n), s = Xp(e);
    return fi.fromDateTimes(s, s.plus(o));
  }
  static before(e, n) {
    const o = Yr.fromDurationLike(n), s = Xp(e);
    return fi.fromDateTimes(s.minus(o), s);
  }
  static fromISO(e, n) {
    const [o, s] = (e || "").split("/", 2);
    if (o && s) {
      let h, a;
      try {
        h = Er.fromISO(o, n), a = h.isValid;
      } catch {
        a = !1;
      }
      let m, g;
      try {
        m = Er.fromISO(s, n), g = m.isValid;
      } catch {
        g = !1;
      }
      if (a && g)
        return fi.fromDateTimes(h, m);
      if (a) {
        const b = Yr.fromISO(s, n);
        if (b.isValid)
          return fi.after(h, b);
      } else if (g) {
        const b = Yr.fromISO(o, n);
        if (b.isValid)
          return fi.before(m, b);
      }
    }
    return fi.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  count(e = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const n = this.start.startOf(e), o = this.end.startOf(e);
    return Math.floor(o.diff(n, e).get(e)) + (o.valueOf() !== this.end.valueOf());
  }
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  set({ start: e, end: n } = {}) {
    return this.isValid ? fi.fromDateTimes(e || this.s, n || this.e) : this;
  }
  splitAt(...e) {
    if (!this.isValid)
      return [];
    const n = e.map(Xp).filter((a) => this.contains(a)).sort(), o = [];
    let { s } = this, h = 0;
    for (; s < this.e; ) {
      const a = n[h] || this.e, m = +a > +this.e ? this.e : a;
      o.push(fi.fromDateTimes(s, m)), s = m, h += 1;
    }
    return o;
  }
  splitBy(e) {
    const n = Yr.fromDurationLike(e);
    if (!this.isValid || !n.isValid || n.as("milliseconds") === 0)
      return [];
    let { s: o } = this, s = 1, h;
    const a = [];
    for (; o < this.e; ) {
      const m = this.start.plus(n.mapUnits((g) => g * s));
      h = +m > +this.e ? this.e : m, a.push(fi.fromDateTimes(o, h)), o = h, s += 1;
    }
    return a;
  }
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  intersection(e) {
    if (!this.isValid)
      return this;
    const n = this.s > e.s ? this.s : e.s, o = this.e < e.e ? this.e : e.e;
    return n >= o ? null : fi.fromDateTimes(n, o);
  }
  union(e) {
    if (!this.isValid)
      return this;
    const n = this.s < e.s ? this.s : e.s, o = this.e > e.e ? this.e : e.e;
    return fi.fromDateTimes(n, o);
  }
  static merge(e) {
    const [n, o] = e.sort((s, h) => s.s - h.s).reduce(
      ([s, h], a) => h ? h.overlaps(a) || h.abutsStart(a) ? [s, h.union(a)] : [s.concat([h]), a] : [s, a],
      [[], null]
    );
    return o && n.push(o), n;
  }
  static xor(e) {
    let n = null, o = 0;
    const s = [], h = e.map((g) => [
      { time: g.s, type: "s" },
      { time: g.e, type: "e" }
    ]), a = Array.prototype.concat(...h), m = a.sort((g, b) => g.time - b.time);
    for (const g of m)
      o += g.type === "s" ? 1 : -1, o === 1 ? n = g.time : (n && +n != +g.time && s.push(fi.fromDateTimes(n, g.time)), n = null);
    return fi.merge(s);
  }
  difference(...e) {
    return fi.xor([this].concat(e)).map((n) => this.intersection(n)).filter((n) => n && !n.isEmpty());
  }
  toString() {
    return this.isValid ? `[${this.s.toISO()} \u2013 ${this.e.toISO()})` : lf;
  }
  toLocaleString(e = Vg, n = {}) {
    return this.isValid ? bo.create(this.s.loc.clone(n), e).formatInterval(this) : lf;
  }
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : lf;
  }
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : lf;
  }
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : lf;
  }
  toFormat(e, { separator: n = " \u2013 " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${n}${this.e.toFormat(e)}` : lf;
  }
  toDuration(e, n) {
    return this.isValid ? this.e.diff(this.s, e, n) : Yr.invalid(this.invalidReason);
  }
  mapEndpoints(e) {
    return fi.fromDateTimes(e(this.s), e(this.e));
  }
}
class Ly {
  static hasDST(e = Ci.defaultZone) {
    const n = Er.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && n.offset !== n.set({ month: 6 }).offset;
  }
  static isValidIANAZone(e) {
    return $l.isValidZone(e);
  }
  static normalizeZone(e) {
    return Iu(e, Ci.defaultZone);
  }
  static months(e = "long", { locale: n = null, numberingSystem: o = null, locObj: s = null, outputCalendar: h = "gregory" } = {}) {
    return (s || Fn.create(n, o, h)).months(e);
  }
  static monthsFormat(e = "long", { locale: n = null, numberingSystem: o = null, locObj: s = null, outputCalendar: h = "gregory" } = {}) {
    return (s || Fn.create(n, o, h)).months(e, !0);
  }
  static weekdays(e = "long", { locale: n = null, numberingSystem: o = null, locObj: s = null } = {}) {
    return (s || Fn.create(n, o, null)).weekdays(e);
  }
  static weekdaysFormat(e = "long", { locale: n = null, numberingSystem: o = null, locObj: s = null } = {}) {
    return (s || Fn.create(n, o, null)).weekdays(e, !0);
  }
  static meridiems({ locale: e = null } = {}) {
    return Fn.create(e).meridiems();
  }
  static eras(e = "short", { locale: n = null } = {}) {
    return Fn.create(n, null, "gregory").eras(e);
  }
  static features() {
    return { relative: uM() };
  }
}
function P2(t, e) {
  const n = (s) => s.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), o = n(e) - n(t);
  return Math.floor(Yr.fromMillis(o).as("days"));
}
function y6(t, e, n) {
  const o = [
    ["years", (g, b) => b.year - g.year],
    ["quarters", (g, b) => b.quarter - g.quarter + (b.year - g.year) * 4],
    ["months", (g, b) => b.month - g.month + (b.year - g.year) * 12],
    [
      "weeks",
      (g, b) => {
        const T = P2(g, b);
        return (T - T % 7) / 7;
      }
    ],
    ["days", P2]
  ], s = {}, h = t;
  let a, m;
  for (const [g, b] of o)
    n.indexOf(g) >= 0 && (a = g, s[g] = b(t, e), m = h.plus(s), m > e ? (s[g]--, t = h.plus(s), t > e && (m = t, s[g]--, t = h.plus(s))) : t = m);
  return [t, s, m, a];
}
function g6(t, e, n, o) {
  let [s, h, a, m] = y6(t, e, n);
  const g = e - s, b = n.filter(
    (M) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(M) >= 0
  );
  b.length === 0 && (a < e && (a = s.plus({ [m]: 1 })), a !== s && (h[m] = (h[m] || 0) + g / (a - s)));
  const T = Yr.fromObject(h, o);
  return b.length > 0 ? Yr.fromMillis(g, o).shiftTo(...b).plus(T) : T;
}
const Q1 = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
}, k2 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, v6 = Q1.hanidec.replace(/[\[|\]]/g, "").split("");
function _6(t) {
  let e = parseInt(t, 10);
  if (isNaN(e)) {
    e = "";
    for (let n = 0; n < t.length; n++) {
      const o = t.charCodeAt(n);
      if (t[n].search(Q1.hanidec) !== -1)
        e += v6.indexOf(t[n]);
      else
        for (const s in k2) {
          const [h, a] = k2[s];
          o >= h && o <= a && (e += o - h);
        }
    }
    return parseInt(e, 10);
  } else
    return e;
}
function Ka({ numberingSystem: t }, e = "") {
  return new RegExp(`${Q1[t || "latn"]}${e}`);
}
const x6 = "missing Intl.DateTimeFormat.formatToParts support";
function rn(t, e = (n) => n) {
  return { regex: t, deser: ([n]) => e(_6(n)) };
}
const b6 = String.fromCharCode(160), OM = `[ ${b6}]`, CM = new RegExp(OM, "g");
function w6(t) {
  return t.replace(/\./g, "\\.?").replace(CM, OM);
}
function L2(t) {
  return t.replace(/\./g, "").replace(CM, " ").toLowerCase();
}
function Ya(t, e) {
  return t === null ? null : {
    regex: RegExp(t.map(w6).join("|")),
    deser: ([n]) => t.findIndex((o) => L2(n) === L2(o)) + e
  };
}
function D2(t, e) {
  return { regex: t, deser: ([, n, o]) => kv(n, o), groups: e };
}
function Dy(t) {
  return { regex: t, deser: ([e]) => e };
}
function E6(t) {
  return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function S6(t, e) {
  const n = Ka(e), o = Ka(e, "{2}"), s = Ka(e, "{3}"), h = Ka(e, "{4}"), a = Ka(e, "{6}"), m = Ka(e, "{1,2}"), g = Ka(e, "{1,3}"), b = Ka(e, "{1,6}"), T = Ka(e, "{1,9}"), M = Ka(e, "{2,4}"), I = Ka(e, "{4,6}"), P = (q) => ({ regex: RegExp(E6(q.val)), deser: ([re]) => re, literal: !0 }), V = ((q) => {
    if (t.literal)
      return P(q);
    switch (q.val) {
      case "G":
        return Ya(e.eras("short"), 0);
      case "GG":
        return Ya(e.eras("long"), 0);
      case "y":
        return rn(b);
      case "yy":
        return rn(M, n1);
      case "yyyy":
        return rn(h);
      case "yyyyy":
        return rn(I);
      case "yyyyyy":
        return rn(a);
      case "M":
        return rn(m);
      case "MM":
        return rn(o);
      case "MMM":
        return Ya(e.months("short", !0), 1);
      case "MMMM":
        return Ya(e.months("long", !0), 1);
      case "L":
        return rn(m);
      case "LL":
        return rn(o);
      case "LLL":
        return Ya(e.months("short", !1), 1);
      case "LLLL":
        return Ya(e.months("long", !1), 1);
      case "d":
        return rn(m);
      case "dd":
        return rn(o);
      case "o":
        return rn(g);
      case "ooo":
        return rn(s);
      case "HH":
        return rn(o);
      case "H":
        return rn(m);
      case "hh":
        return rn(o);
      case "h":
        return rn(m);
      case "mm":
        return rn(o);
      case "m":
        return rn(m);
      case "q":
        return rn(m);
      case "qq":
        return rn(o);
      case "s":
        return rn(m);
      case "ss":
        return rn(o);
      case "S":
        return rn(g);
      case "SSS":
        return rn(s);
      case "u":
        return Dy(T);
      case "uu":
        return Dy(m);
      case "uuu":
        return rn(n);
      case "a":
        return Ya(e.meridiems(), 0);
      case "kkkk":
        return rn(h);
      case "kk":
        return rn(M, n1);
      case "W":
        return rn(m);
      case "WW":
        return rn(o);
      case "E":
      case "c":
        return rn(n);
      case "EEE":
        return Ya(e.weekdays("short", !1), 1);
      case "EEEE":
        return Ya(e.weekdays("long", !1), 1);
      case "ccc":
        return Ya(e.weekdays("short", !0), 1);
      case "cccc":
        return Ya(e.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return D2(new RegExp(`([+-]${m.source})(?::(${o.source}))?`), 2);
      case "ZZZ":
        return D2(new RegExp(`([+-]${m.source})(${o.source})?`), 2);
      case "z":
        return Dy(/[a-z_+-/]{1,256}?/i);
      case " ":
        return Dy(/[^\S\n\r]/);
      default:
        return P(q);
    }
  })(t) || {
    invalidReason: x6
  };
  return V.token = t, V;
}
const T6 = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function M6(t, e, n) {
  const { type: o, value: s } = t;
  if (o === "literal") {
    const g = /^\s+$/.test(s);
    return {
      literal: !g,
      val: g ? " " : s
    };
  }
  const h = e[o];
  let a = o;
  o === "hour" && (e.hour12 != null ? a = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? a = "hour12" : a = "hour24" : a = n.hour12 ? "hour12" : "hour24");
  let m = T6[a];
  if (typeof m == "object" && (m = m[h]), m)
    return {
      literal: !1,
      val: m
    };
}
function I6(t) {
  return [`^${t.map((n) => n.regex).reduce((n, o) => `${n}(${o.source})`, "")}$`, t];
}
function O6(t, e, n) {
  const o = t.match(e);
  if (o) {
    const s = {};
    let h = 1;
    for (const a in n)
      if (zf(n, a)) {
        const m = n[a], g = m.groups ? m.groups + 1 : 1;
        !m.literal && m.token && (s[m.token.val[0]] = m.deser(o.slice(h, h + g))), h += g;
      }
    return [o, s];
  } else
    return [o, {}];
}
function C6(t) {
  const e = (h) => {
    switch (h) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let n = null, o;
  return Hr(t.z) || (n = $l.create(t.z)), Hr(t.Z) || (n || (n = new Fo(t.Z)), o = t.Z), Hr(t.q) || (t.M = (t.q - 1) * 3 + 1), Hr(t.h) || (t.h < 12 && t.a === 1 ? t.h += 12 : t.h === 12 && t.a === 0 && (t.h = 0)), t.G === 0 && t.y && (t.y = -t.y), Hr(t.u) || (t.S = Z1(t.u)), [Object.keys(t).reduce((h, a) => {
    const m = e(a);
    return m && (h[m] = t[a]), h;
  }, {}), n, o];
}
let K_ = null;
function A6() {
  return K_ || (K_ = Er.fromMillis(1555555555555)), K_;
}
function P6(t, e) {
  if (t.literal)
    return t;
  const n = bo.macroTokenToFormatOpts(t.val), o = kM(n, e);
  return o == null || o.includes(void 0) ? t : o;
}
function AM(t, e) {
  return Array.prototype.concat(...t.map((n) => P6(n, e)));
}
function PM(t, e, n) {
  const o = AM(bo.parseFormat(n), t), s = o.map((a) => S6(a, t)), h = s.find((a) => a.invalidReason);
  if (h)
    return { input: e, tokens: o, invalidReason: h.invalidReason };
  {
    const [a, m] = I6(s), g = RegExp(a, "i"), [b, T] = O6(e, g, m), [M, I, P] = T ? C6(T) : [null, null, void 0];
    if (zf(T, "a") && zf(T, "H"))
      throw new nd(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: e, tokens: o, regex: g, rawMatches: b, matches: T, result: M, zone: I, specificOffset: P };
  }
}
function k6(t, e, n) {
  const { result: o, zone: s, specificOffset: h, invalidReason: a } = PM(t, e, n);
  return [o, s, h, a];
}
function kM(t, e) {
  if (!t)
    return null;
  const o = bo.create(e, t).dtFormatter(A6()), s = o.formatToParts(), h = o.resolvedOptions();
  return s.map((a) => M6(a, t, h));
}
const LM = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], DM = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function La(t, e) {
  return new as(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`
  );
}
function NM(t, e, n) {
  const o = new Date(Date.UTC(t, e - 1, n));
  t < 100 && t >= 0 && o.setUTCFullYear(o.getUTCFullYear() - 1900);
  const s = o.getUTCDay();
  return s === 0 ? 7 : s;
}
function RM(t, e, n) {
  return n + (Yd(t) ? DM : LM)[e - 1];
}
function zM(t, e) {
  const n = Yd(t) ? DM : LM, o = n.findIndex((h) => h < e), s = e - n[o];
  return { month: o + 1, day: s };
}
function i1(t) {
  const { year: e, month: n, day: o } = t, s = RM(e, n, o), h = NM(e, n, o);
  let a = Math.floor((s - h + 10) / 7), m;
  return a < 1 ? (m = e - 1, a = jg(m)) : a > jg(e) ? (m = e + 1, a = 1) : m = e, { weekYear: m, weekNumber: a, weekday: h, ...Lv(t) };
}
function N2(t) {
  const { weekYear: e, weekNumber: n, weekday: o } = t, s = NM(e, 1, 4), h = gd(e);
  let a = n * 7 + o - s - 3, m;
  a < 1 ? (m = e - 1, a += gd(m)) : a > h ? (m = e + 1, a -= gd(e)) : m = e;
  const { month: g, day: b } = zM(m, a);
  return { year: m, month: g, day: b, ...Lv(t) };
}
function Y_(t) {
  const { year: e, month: n, day: o } = t, s = RM(e, n, o);
  return { year: e, ordinal: s, ...Lv(t) };
}
function R2(t) {
  const { year: e, ordinal: n } = t, { month: o, day: s } = zM(e, n);
  return { year: e, month: o, day: s, ...Lv(t) };
}
function L6(t) {
  const e = Av(t.weekYear), n = Fl(t.weekNumber, 1, jg(t.weekYear)), o = Fl(t.weekday, 1, 7);
  return e ? n ? o ? !1 : La("weekday", t.weekday) : La("week", t.week) : La("weekYear", t.weekYear);
}
function D6(t) {
  const e = Av(t.year), n = Fl(t.ordinal, 1, gd(t.year));
  return e ? n ? !1 : La("ordinal", t.ordinal) : La("year", t.year);
}
function FM(t) {
  const e = Av(t.year), n = Fl(t.month, 1, 12), o = Fl(t.day, 1, Ug(t.year, t.month));
  return e ? n ? o ? !1 : La("day", t.day) : La("month", t.month) : La("year", t.year);
}
function BM(t) {
  const { hour: e, minute: n, second: o, millisecond: s } = t, h = Fl(e, 0, 23) || e === 24 && n === 0 && o === 0 && s === 0, a = Fl(n, 0, 59), m = Fl(o, 0, 59), g = Fl(s, 0, 999);
  return h ? a ? m ? g ? !1 : La("millisecond", s) : La("second", o) : La("minute", n) : La("hour", e);
}
const J_ = "Invalid DateTime", z2 = 864e13;
function Ny(t) {
  return new as("unsupported zone", `the zone "${t.name}" is not supported`);
}
function Q_(t) {
  return t.weekData === null && (t.weekData = i1(t.c)), t.weekData;
}
function Ac(t, e) {
  const n = {
    ts: t.ts,
    zone: t.zone,
    c: t.c,
    o: t.o,
    loc: t.loc,
    invalid: t.invalid
  };
  return new Er({ ...n, ...e, old: n });
}
function VM(t, e, n) {
  let o = t - e * 60 * 1e3;
  const s = n.offset(o);
  if (e === s)
    return [o, e];
  o -= (s - e) * 60 * 1e3;
  const h = n.offset(o);
  return s === h ? [o, s] : [t - Math.min(s, h) * 60 * 1e3, Math.max(s, h)];
}
function Ry(t, e) {
  t += e * 60 * 1e3;
  const n = new Date(t);
  return {
    year: n.getUTCFullYear(),
    month: n.getUTCMonth() + 1,
    day: n.getUTCDate(),
    hour: n.getUTCHours(),
    minute: n.getUTCMinutes(),
    second: n.getUTCSeconds(),
    millisecond: n.getUTCMilliseconds()
  };
}
function hg(t, e, n) {
  return VM(Pv(t), e, n);
}
function F2(t, e) {
  const n = t.o, o = t.c.year + Math.trunc(e.years), s = t.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, h = {
    ...t.c,
    year: o,
    month: s,
    day: Math.min(t.c.day, Ug(o, s)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
  }, a = Yr.fromObject({
    years: e.years - Math.trunc(e.years),
    quarters: e.quarters - Math.trunc(e.quarters),
    months: e.months - Math.trunc(e.months),
    weeks: e.weeks - Math.trunc(e.weeks),
    days: e.days - Math.trunc(e.days),
    hours: e.hours,
    minutes: e.minutes,
    seconds: e.seconds,
    milliseconds: e.milliseconds
  }).as("milliseconds"), m = Pv(h);
  let [g, b] = VM(m, n, t.zone);
  return a !== 0 && (g += a, b = t.zone.offset(g)), { ts: g, o: b };
}
function Zp(t, e, n, o, s, h) {
  const { setZone: a, zone: m } = n;
  if (t && Object.keys(t).length !== 0 || e) {
    const g = e || m, b = Er.fromObject(t, {
      ...n,
      zone: g,
      specificOffset: h
    });
    return a ? b : b.setZone(m);
  } else
    return Er.invalid(
      new as("unparsable", `the input "${s}" can't be parsed as ${o}`)
    );
}
function zy(t, e, n = !0) {
  return t.isValid ? bo.create(Fn.create("en-US"), {
    allowZ: n,
    forceSimple: !0
  }).formatDateTimeFromString(t, e) : null;
}
function e0(t, e) {
  const n = t.c.year > 9999 || t.c.year < 0;
  let o = "";
  return n && t.c.year >= 0 && (o += "+"), o += Ai(t.c.year, n ? 6 : 4), e ? (o += "-", o += Ai(t.c.month), o += "-", o += Ai(t.c.day)) : (o += Ai(t.c.month), o += Ai(t.c.day)), o;
}
function B2(t, e, n, o, s, h) {
  let a = Ai(t.c.hour);
  return e ? (a += ":", a += Ai(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (a += ":")) : a += Ai(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (a += Ai(t.c.second), (t.c.millisecond !== 0 || !o) && (a += ".", a += Ai(t.c.millisecond, 3))), s && (t.isOffsetFixed && t.offset === 0 && !h ? a += "Z" : t.o < 0 ? (a += "-", a += Ai(Math.trunc(-t.o / 60)), a += ":", a += Ai(Math.trunc(-t.o % 60))) : (a += "+", a += Ai(Math.trunc(t.o / 60)), a += ":", a += Ai(Math.trunc(t.o % 60)))), h && (a += "[" + t.zone.ianaName + "]"), a;
}
const UM = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, N6 = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, R6 = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, jM = ["year", "month", "day", "hour", "minute", "second", "millisecond"], z6 = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], F6 = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function V2(t) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[t.toLowerCase()];
  if (!e)
    throw new GT(t);
  return e;
}
function U2(t, e) {
  const n = Iu(e.zone, Ci.defaultZone), o = Fn.fromObject(e), s = Ci.now();
  let h, a;
  if (Hr(t.year))
    h = s;
  else {
    for (const b of jM)
      Hr(t[b]) && (t[b] = UM[b]);
    const m = FM(t) || BM(t);
    if (m)
      return Er.invalid(m);
    const g = n.offset(s);
    [h, a] = hg(t, g, n);
  }
  return new Er({ ts: h, zone: n, loc: o, o: a });
}
function j2(t, e, n) {
  const o = Hr(n.round) ? !0 : n.round, s = (a, m) => (a = X1(a, o || n.calendary ? 0 : 2, !0), e.loc.clone(n).relFormatter(n).format(a, m)), h = (a) => n.calendary ? e.hasSame(t, a) ? 0 : e.startOf(a).diff(t.startOf(a), a).get(a) : e.diff(t, a).get(a);
  if (n.unit)
    return s(h(n.unit), n.unit);
  for (const a of n.units) {
    const m = h(a);
    if (Math.abs(m) >= 1)
      return s(m, a);
  }
  return s(t > e ? -0 : 0, n.units[n.units.length - 1]);
}
function G2(t) {
  let e = {}, n;
  return t.length > 0 && typeof t[t.length - 1] == "object" ? (e = t[t.length - 1], n = Array.from(t).slice(0, t.length - 1)) : n = Array.from(t), [e, n];
}
class Er {
  constructor(e) {
    const n = e.zone || Ci.defaultZone;
    let o = e.invalid || (Number.isNaN(e.ts) ? new as("invalid input") : null) || (n.isValid ? null : Ny(n));
    this.ts = Hr(e.ts) ? Ci.now() : e.ts;
    let s = null, h = null;
    if (!o)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(n))
        [s, h] = [e.old.c, e.old.o];
      else {
        const m = n.offset(this.ts);
        s = Ry(this.ts, m), o = Number.isNaN(s.year) ? new as("invalid input") : null, s = o ? null : s, h = o ? null : m;
      }
    this._zone = n, this.loc = e.loc || Fn.create(), this.invalid = o, this.weekData = null, this.c = s, this.o = h, this.isLuxonDateTime = !0;
  }
  static now() {
    return new Er({});
  }
  static local() {
    const [e, n] = G2(arguments), [o, s, h, a, m, g, b] = n;
    return U2({ year: o, month: s, day: h, hour: a, minute: m, second: g, millisecond: b }, e);
  }
  static utc() {
    const [e, n] = G2(arguments), [o, s, h, a, m, g, b] = n;
    return e.zone = Fo.utcInstance, U2({ year: o, month: s, day: h, hour: a, minute: m, second: g, millisecond: b }, e);
  }
  static fromJSDate(e, n = {}) {
    const o = hz(e) ? e.valueOf() : NaN;
    if (Number.isNaN(o))
      return Er.invalid("invalid input");
    const s = Iu(n.zone, Ci.defaultZone);
    return s.isValid ? new Er({
      ts: o,
      zone: s,
      loc: Fn.fromObject(n)
    }) : Er.invalid(Ny(s));
  }
  static fromMillis(e, n = {}) {
    if (Zc(e))
      return e < -z2 || e > z2 ? Er.invalid("Timestamp out of range") : new Er({
        ts: e,
        zone: Iu(n.zone, Ci.defaultZone),
        loc: Fn.fromObject(n)
      });
    throw new ka(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
    );
  }
  static fromSeconds(e, n = {}) {
    if (Zc(e))
      return new Er({
        ts: e * 1e3,
        zone: Iu(n.zone, Ci.defaultZone),
        loc: Fn.fromObject(n)
      });
    throw new ka("fromSeconds requires a numerical input");
  }
  static fromObject(e, n = {}) {
    e = e || {};
    const o = Iu(n.zone, Ci.defaultZone);
    if (!o.isValid)
      return Er.invalid(Ny(o));
    const s = Ci.now(), h = Hr(n.specificOffset) ? o.offset(s) : n.specificOffset, a = Gg(e, V2), m = !Hr(a.ordinal), g = !Hr(a.year), b = !Hr(a.month) || !Hr(a.day), T = g || b, M = a.weekYear || a.weekNumber, I = Fn.fromObject(n);
    if ((T || m) && M)
      throw new nd(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (b && m)
      throw new nd("Can't mix ordinal dates with month/day");
    const P = M || a.weekday && !T;
    let z, V, q = Ry(s, h);
    P ? (z = z6, V = N6, q = i1(q)) : m ? (z = F6, V = R6, q = Y_(q)) : (z = jM, V = UM);
    let re = !1;
    for (const Pe of z) {
      const Se = a[Pe];
      Hr(Se) ? re ? a[Pe] = V[Pe] : a[Pe] = q[Pe] : re = !0;
    }
    const X = P ? L6(a) : m ? D6(a) : FM(a), ae = X || BM(a);
    if (ae)
      return Er.invalid(ae);
    const ce = P ? N2(a) : m ? R2(a) : a, [ve, Re] = hg(ce, h, o), Fe = new Er({
      ts: ve,
      zone: o,
      o: Re,
      loc: I
    });
    return a.weekday && T && e.weekday !== Fe.weekday ? Er.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${a.weekday} and a date of ${Fe.toISO()}`
    ) : Fe;
  }
  static fromISO(e, n = {}) {
    const [o, s] = t6(e);
    return Zp(o, s, n, "ISO 8601", e);
  }
  static fromRFC2822(e, n = {}) {
    const [o, s] = r6(e);
    return Zp(o, s, n, "RFC 2822", e);
  }
  static fromHTTP(e, n = {}) {
    const [o, s] = n6(e);
    return Zp(o, s, n, "HTTP", n);
  }
  static fromFormat(e, n, o = {}) {
    if (Hr(e) || Hr(n))
      throw new ka("fromFormat requires an input string and a format");
    const { locale: s = null, numberingSystem: h = null } = o, a = Fn.fromOpts({
      locale: s,
      numberingSystem: h,
      defaultToEN: !0
    }), [m, g, b, T] = k6(a, e, n);
    return T ? Er.invalid(T) : Zp(m, g, o, `format ${n}`, e, b);
  }
  static fromString(e, n, o = {}) {
    return Er.fromFormat(e, n, o);
  }
  static fromSQL(e, n = {}) {
    const [o, s] = c6(e);
    return Zp(o, s, n, "SQL", e);
  }
  static invalid(e, n = null) {
    if (!e)
      throw new ka("need to specify a reason the DateTime is invalid");
    const o = e instanceof as ? e : new as(e, n);
    if (Ci.throwOnInvalid)
      throw new j5(o);
    return new Er({ invalid: o });
  }
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  static parseFormatForOpts(e, n = {}) {
    const o = kM(e, Fn.fromObject(n));
    return o ? o.map((s) => s ? s.val : null).join("") : null;
  }
  static expandFormat(e, n = {}) {
    return AM(bo.parseFormat(e), Fn.fromObject(n)).map((s) => s.val).join("");
  }
  get(e) {
    return this[e];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? Q_(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? Q_(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? Q_(this).weekday : NaN;
  }
  get ordinal() {
    return this.isValid ? Y_(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? Ly.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? Ly.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? Ly.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? Ly.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const e = 864e5, n = 6e4, o = Pv(this.c), s = this.zone.offset(o - e), h = this.zone.offset(o + e), a = this.zone.offset(o - s * n), m = this.zone.offset(o - h * n);
    if (a === m)
      return [this];
    const g = o - a * n, b = o - m * n, T = Ry(g, a), M = Ry(b, m);
    return T.hour === M.hour && T.minute === M.minute && T.second === M.second && T.millisecond === M.millisecond ? [Ac(this, { ts: g }), Ac(this, { ts: b })] : [this];
  }
  get isInLeapYear() {
    return Yd(this.year);
  }
  get daysInMonth() {
    return Ug(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? gd(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? jg(this.weekYear) : NaN;
  }
  resolvedLocaleOptions(e = {}) {
    const { locale: n, numberingSystem: o, calendar: s } = bo.create(
      this.loc.clone(e),
      e
    ).resolvedOptions(this);
    return { locale: n, numberingSystem: o, outputCalendar: s };
  }
  toUTC(e = 0, n = {}) {
    return this.setZone(Fo.instance(e), n);
  }
  toLocal() {
    return this.setZone(Ci.defaultZone);
  }
  setZone(e, { keepLocalTime: n = !1, keepCalendarTime: o = !1 } = {}) {
    if (e = Iu(e, Ci.defaultZone), e.equals(this.zone))
      return this;
    if (e.isValid) {
      let s = this.ts;
      if (n || o) {
        const h = e.offset(this.ts), a = this.toObject();
        [s] = hg(a, h, e);
      }
      return Ac(this, { ts: s, zone: e });
    } else
      return Er.invalid(Ny(e));
  }
  reconfigure({ locale: e, numberingSystem: n, outputCalendar: o } = {}) {
    const s = this.loc.clone({ locale: e, numberingSystem: n, outputCalendar: o });
    return Ac(this, { loc: s });
  }
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  set(e) {
    if (!this.isValid)
      return this;
    const n = Gg(e, V2), o = !Hr(n.weekYear) || !Hr(n.weekNumber) || !Hr(n.weekday), s = !Hr(n.ordinal), h = !Hr(n.year), a = !Hr(n.month) || !Hr(n.day), m = h || a, g = n.weekYear || n.weekNumber;
    if ((m || s) && g)
      throw new nd(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (a && s)
      throw new nd("Can't mix ordinal dates with month/day");
    let b;
    o ? b = N2({ ...i1(this.c), ...n }) : Hr(n.ordinal) ? (b = { ...this.toObject(), ...n }, Hr(n.day) && (b.day = Math.min(Ug(b.year, b.month), b.day))) : b = R2({ ...Y_(this.c), ...n });
    const [T, M] = hg(b, this.o, this.zone);
    return Ac(this, { ts: T, o: M });
  }
  plus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e);
    return Ac(this, F2(this, n));
  }
  minus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e).negate();
    return Ac(this, F2(this, n));
  }
  startOf(e) {
    if (!this.isValid)
      return this;
    const n = {}, o = Yr.normalizeUnit(e);
    switch (o) {
      case "years":
        n.month = 1;
      case "quarters":
      case "months":
        n.day = 1;
      case "weeks":
      case "days":
        n.hour = 0;
      case "hours":
        n.minute = 0;
      case "minutes":
        n.second = 0;
      case "seconds":
        n.millisecond = 0;
        break;
    }
    if (o === "weeks" && (n.weekday = 1), o === "quarters") {
      const s = Math.ceil(this.month / 3);
      n.month = (s - 1) * 3 + 1;
    }
    return this.set(n);
  }
  endOf(e) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e).minus(1) : this;
  }
  toFormat(e, n = {}) {
    return this.isValid ? bo.create(this.loc.redefaultToEN(n)).formatDateTimeFromString(this, e) : J_;
  }
  toLocaleString(e = Vg, n = {}) {
    return this.isValid ? bo.create(this.loc.clone(n), e).formatDateTime(this) : J_;
  }
  toLocaleParts(e = {}) {
    return this.isValid ? bo.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  toISO({
    format: e = "extended",
    suppressSeconds: n = !1,
    suppressMilliseconds: o = !1,
    includeOffset: s = !0,
    extendedZone: h = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const a = e === "extended";
    let m = e0(this, a);
    return m += "T", m += B2(this, a, n, o, s, h), m;
  }
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? e0(this, e === "extended") : null;
  }
  toISOWeekDate() {
    return zy(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: n = !1,
    includeOffset: o = !0,
    includePrefix: s = !1,
    extendedZone: h = !1,
    format: a = "extended"
  } = {}) {
    return this.isValid ? (s ? "T" : "") + B2(
      this,
      a === "extended",
      n,
      e,
      o,
      h
    ) : null;
  }
  toRFC2822() {
    return zy(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  toHTTP() {
    return zy(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    return this.isValid ? e0(this, !0) : null;
  }
  toSQLTime({ includeOffset: e = !0, includeZone: n = !1, includeOffsetSpace: o = !0 } = {}) {
    let s = "HH:mm:ss.SSS";
    return (n || e) && (o && (s += " "), n ? s += "z" : e && (s += "ZZ")), zy(this, s, !0);
  }
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  toString() {
    return this.isValid ? this.toISO() : J_;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(e = {}) {
    if (!this.isValid)
      return {};
    const n = { ...this.c };
    return e.includeConfig && (n.outputCalendar = this.outputCalendar, n.numberingSystem = this.loc.numberingSystem, n.locale = this.loc.locale), n;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(e, n = "milliseconds", o = {}) {
    if (!this.isValid || !e.isValid)
      return Yr.invalid("created by diffing an invalid DateTime");
    const s = { locale: this.locale, numberingSystem: this.numberingSystem, ...o }, h = fz(n).map(Yr.normalizeUnit), a = e.valueOf() > this.valueOf(), m = a ? this : e, g = a ? e : this, b = g6(m, g, h, s);
    return a ? b.negate() : b;
  }
  diffNow(e = "milliseconds", n = {}) {
    return this.diff(Er.now(), e, n);
  }
  until(e) {
    return this.isValid ? fi.fromDateTimes(this, e) : this;
  }
  hasSame(e, n) {
    if (!this.isValid)
      return !1;
    const o = e.valueOf(), s = this.setZone(e.zone, { keepLocalTime: !0 });
    return s.startOf(n) <= o && o <= s.endOf(n);
  }
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  toRelative(e = {}) {
    if (!this.isValid)
      return null;
    const n = e.base || Er.fromObject({}, { zone: this.zone }), o = e.padding ? this < n ? -e.padding : e.padding : 0;
    let s = ["years", "months", "days", "hours", "minutes", "seconds"], h = e.unit;
    return Array.isArray(e.unit) && (s = e.unit, h = void 0), j2(n, this.plus(o), {
      ...e,
      numeric: "always",
      units: s,
      unit: h
    });
  }
  toRelativeCalendar(e = {}) {
    return this.isValid ? j2(e.base || Er.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  static min(...e) {
    if (!e.every(Er.isDateTime))
      throw new ka("min requires all arguments be DateTimes");
    return M2(e, (n) => n.valueOf(), Math.min);
  }
  static max(...e) {
    if (!e.every(Er.isDateTime))
      throw new ka("max requires all arguments be DateTimes");
    return M2(e, (n) => n.valueOf(), Math.max);
  }
  static fromFormatExplain(e, n, o = {}) {
    const { locale: s = null, numberingSystem: h = null } = o, a = Fn.fromOpts({
      locale: s,
      numberingSystem: h,
      defaultToEN: !0
    });
    return PM(a, e, n);
  }
  static fromStringExplain(e, n, o = {}) {
    return Er.fromFormatExplain(e, n, o);
  }
  static get DATE_SHORT() {
    return Vg;
  }
  static get DATE_MED() {
    return $T;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return q5;
  }
  static get DATE_FULL() {
    return qT;
  }
  static get DATE_HUGE() {
    return WT;
  }
  static get TIME_SIMPLE() {
    return HT;
  }
  static get TIME_WITH_SECONDS() {
    return ZT;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return XT;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return KT;
  }
  static get TIME_24_SIMPLE() {
    return YT;
  }
  static get TIME_24_WITH_SECONDS() {
    return JT;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return QT;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return eM;
  }
  static get DATETIME_SHORT() {
    return tM;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return rM;
  }
  static get DATETIME_MED() {
    return nM;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return iM;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return W5;
  }
  static get DATETIME_FULL() {
    return oM;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return aM;
  }
  static get DATETIME_HUGE() {
    return sM;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return lM;
  }
}
function Xp(t) {
  if (Er.isDateTime(t))
    return t;
  if (t && t.valueOf && Zc(t.valueOf()))
    return Er.fromJSDate(t);
  if (t && typeof t == "object")
    return Er.fromObject(t);
  throw new ka(
    `Unknown datetime argument: ${t}, of type ${typeof t}`
  );
}
const GM = [0, 1, 0, 0];
function $2(t, e = "second", n, o) {
  const { t: s } = En(), h = new Date(t).toISOString(), a = {
    year: s("yyyy"),
    month: s("M/yyyy"),
    day: s("M/d/yyyy"),
    second: s("M/d/yyyy HH:mm:ss")
  }, g = (n ? {
    year: "yyyy",
    month: "yyyy-MM",
    day: "yyyy-MM-dd",
    second: void 0
  } : a)[e];
  return g ? Er.fromISO(h).toFormat(
    `${o ? "UTC:" : ""}${g}`
  ) : h.replace(/\.\d{3}/, "");
}
function o1(t) {
  return new Date(t).toISOString().split(".")[0] + "Z";
}
function t0(t) {
  return Er.fromISO(t).toFormat("yyyy-MM-dd");
}
function B6(t, e) {
  return t <= e.minValue ? e.minValue : t >= e.maxValue ? e.maxValue : e.timeValueList ? V6(t, e) : U6(t, e);
}
function V6(t, e) {
  var g;
  const n = (g = e.timeValueList) != null ? g : [];
  let o, s = 0, h = n.length - 1;
  for (; h - s > 1; )
    o = Math.floor((s + h) / 2), n[o] >= t ? h = o : s = o;
  const a = Math.abs(n[s] - t), m = Math.abs(n[h] - t);
  return n[a < m ? s : h];
}
function U6(t, e) {
  var g;
  const n = (g = e.timeInterval) != null ? g : GM, o = new Date(t).getTime(), s = new Date(e.minValue), h = e.maxValue;
  let a = e.minValue, m = Math.abs(o - a);
  for (let b = 1; ; b++) {
    const T = new Date(s.getTime());
    if (T.setFullYear(s.getFullYear() + b * n[0]), T.setMonth(
      s.getMonth() + b * n[1],
      s.getDate() + b * n[2]
    ), T.setSeconds(s.getSeconds() + b * n[3]), T.getTime() > h)
      break;
    const M = Math.abs(o - T.getTime());
    if (M <= m)
      a = T.getTime(), m = M;
    else
      break;
  }
  return a;
}
const Ei = ih("map", () => {
  const t = hs(), e = _r({}), n = Bn([]), o = Bn([]), s = _r(!1), h = _r(!1), a = _r(void 0);
  function m(X) {
    a.value = X;
  }
  function g(...X) {
    n.value = [.../* @__PURE__ */ new Set([...n.value, ...X])];
  }
  function b(...X) {
    o.value = [.../* @__PURE__ */ new Set([...o.value, ...X])];
  }
  function T(...X) {
    n.value = n.value.filter(
      (ae) => X.indexOf(ae.id) === -1
    ), o.value = o.value.filter(
      (ae) => X.indexOf(ae.id) === -1
    );
  }
  function M() {
    n.value = [];
  }
  function I(X) {
    var ae;
    return !!((ae = n.value) != null && ae.find((ce) => ce.id === X));
  }
  function P(X, ae = !1) {
    var ve;
    const ce = ae ? o : n;
    ce.value = [
      ...((ve = ce.value) == null ? void 0 : ve.sort(
        (Re, Fe) => X.indexOf(Re.id) - X.indexOf(Fe.id)
      )) || []
    ];
  }
  function z(X, ae) {
    n.value = n.value.map((ce) => ce.id === X ? { ...ce, opacity: ae, previousOpacity: ce.opacity } : ce);
  }
  function V(X, ae, ce) {
    n.value = n.value.map((ve) => {
      if (ve.id === X) {
        const Re = {
          ...ve,
          currentTimeMinValue: ae ? o1(ae) : void 0,
          currentTimeMaxValue: ce ? o1(ce) : void 0
        };
        return Re.type === "WMTS" && (Re.name = t.getLayerCurrentLabel(Re)), Re;
      }
      return ve;
    });
  }
  function q(X) {
    s.value = X;
  }
  function re(X) {
    h.value = X;
  }
  return {
    map: e,
    layers: n,
    layers3d: o,
    is3dActive: s,
    is3dMesh: h,
    bgLayer: a,
    addLayers: g,
    add3dLayers: b,
    removeLayers: T,
    removeAllLayers: M,
    reorderLayers: P,
    setLayerOpacity: z,
    setLayerTime: V,
    setBgLayer: m,
    setIs3dActive: q,
    setIs3dMesh: re,
    hasLayer: I
  };
}), j6 = "root_3d", G6 = -222, Ro = ih(
  "config",
  () => {
    const t = Bn(), e = _r("main"), n = or(() => {
      var g;
      return (g = t.value) == null ? void 0 : g.themes;
    }), o = or(
      () => {
        var g;
        return (g = n.value) == null ? void 0 : g.find((b) => b.name === e.value);
      }
    ), s = or(() => {
      var g;
      return ((g = t.value) == null ? void 0 : g.background_layers) || [];
    }), h = or(() => {
      var b;
      const g = (b = n.value) == null ? void 0 : b.filter(
        (T) => {
          var M;
          return ((M = T.metadata) == null ? void 0 : M.ol3d_type) !== void 0;
        }
      );
      if (!!g)
        return {
          name: j6,
          id: G6,
          children: g.flatMap(
            (T) => T != null && T.children ? T.children : T
          ),
          metadata: {}
        };
    });
    function a(g) {
      t.value = g;
    }
    function m(g) {
      e.value = g;
    }
    return {
      config: t,
      themes: n,
      themeName: e,
      theme: o,
      bgLayers: s,
      layerTrees_3d: h,
      setTheme: m,
      setThemes: a
    };
  },
  {}
);
function Xc() {
  function t(m, g) {
    return n(m, void 0, g);
  }
  function e(m, g) {
    return n(void 0, m, g);
  }
  function n(m, g, b) {
    const { theme: T } = Ro();
    if (b = b || T, m && (b == null ? void 0 : b.id) === m || g && (b == null ? void 0 : b.name) === g)
      return b;
    if (b != null && b.children)
      for (const M of b.children) {
        const I = n(m, g, M);
        if (I)
          return I;
      }
  }
  function o(m) {
    const { layerTrees_3d: g } = Ro();
    return n(m, void 0, g);
  }
  function s(m) {
    const { bgLayers: g } = Ro();
    return g.find((b) => b.id === m);
  }
  function h(m) {
    const { bgLayers: g } = Ro();
    return g.find((b) => b.name === m);
  }
  function a(m) {
    const { setTheme: g } = Ro();
    g(m);
  }
  return {
    findById: t,
    findByName: e,
    find3dLayerById: o,
    findBgLayerById: s,
    findBgLayerByName: h,
    setTheme: a
  };
}
const q2 = Xc();
function hs() {
  function t(g, b) {
    try {
      const T = JSON.parse(g).concat(JSON.parse(b));
      return new Set(T).size < T.length;
    } catch {
      return !1;
    }
  }
  function e(g) {
    var b, T;
    return g.opacity = g.previousOpacity = (T = (b = g.metadata) == null ? void 0 : b.start_opacity) != null ? T : 1, n(g), g;
  }
  function n(g) {
    var T, M, I, P, z, V, q;
    g.currentTimeMinValue || (g.currentTimeMinValue = (I = (T = g.time) == null ? void 0 : T.minDefValue) != null ? I : (M = g.time) == null ? void 0 : M.minValue);
    const b = ((P = g.time) == null ? void 0 : P.mode) === zl.RANGE;
    !g.currentTimeMaxValue && b && (g.currentTimeMaxValue = (q = (z = g.time) == null ? void 0 : z.maxDefValue) != null ? q : (V = g.time) == null ? void 0 : V.maxValue);
  }
  function o(g) {
    var M, I, P;
    const b = s(g);
    let T = g.name;
    return b && (T = (P = (I = (M = g.metadata) == null ? void 0 : M.time_layers) == null ? void 0 : I[b]) != null ? P : T), T;
  }
  function s(g) {
    return [
      g.currentTimeMinValue,
      ...g.currentTimeMaxValue ? [g.currentTimeMaxValue] : []
    ].join(B5);
  }
  function h(g) {
    var I, P;
    const b = zg();
    if (!((I = g.metadata) != null && I.exclusion))
      return;
    const T = Ei(), M = T.layers.filter(
      (z) => {
        var V, q;
        return t(
          (V = g == null ? void 0 : g.metadata) == null ? void 0 : V.exclusion,
          (q = z == null ? void 0 : z.metadata) == null ? void 0 : q.exclusion
        );
      }
    );
    M.length > 0 && (T.removeLayers(...M.map((z) => z.id)), b.addNotification(
      ii.t(
        "The layer <b>{{layersToRemove}}</b> has been removed because it cannot be displayed while the layer <b>{{layer}}</b> is displayed",
        {
          count: M.length,
          layersToRemove: M.map((z) => ii.t(z.name, { ns: "client" })).join(", "),
          layer: ii.t(g.name, { ns: "client" }),
          ns: "client"
        }
      ),
      Nd.WARNING
    )), g.id !== ((P = T.bgLayer) == null ? void 0 : P.id) && a(g);
  }
  function a(g) {
    var M, I, P;
    const b = Ei(), T = zg();
    t(
      (M = g.metadata) == null ? void 0 : M.exclusion,
      (P = (I = b.bgLayer) == null ? void 0 : I.metadata) == null ? void 0 : P.exclusion
    ) && (b.setBgLayer(null), T.addNotification(
      ii.t(
        "Background has been deactivated because the layer {{layer}} cannot be displayed on top of it.",
        {
          layer: ii.t(g.name, { ns: "client" }),
          ns: "client"
        }
      ),
      Nd.WARNING
    ));
  }
  function m(g, b = !0, T) {
    var V;
    const M = Ro(), I = Ei(), P = T ? M.layerTrees_3d : M.theme, z = q2.findById(g, P);
    if (z) {
      const q = ((V = z.metadata) == null ? void 0 : V.linked_layers) || [];
      b === !1 ? I.removeLayers(z.id, ...q) : (h(z), (T ? I.add3dLayers : I.addLayers)(
        e(z),
        ...q.map(
          (X) => e(
            q2.findById(parseInt(X, 10))
          )
        )
      ));
    }
  }
  return {
    initLayer: e,
    getLayerCurrentLabel: o,
    getLayerCurrentTime: s,
    handleExclusionLayers: h,
    toggleLayer: m
  };
}
class $6 {
  styleSerialToStyle(e) {
    return e ? JSON.parse(decodeURIComponent(e)) || [] : [];
  }
  styleLocalStorageToStyle(e) {
    return e ? JSON.parse(e).medium || [] : [];
  }
  styleToSerial(e) {
    return e && e.length > 0 ? JSON.stringify(e) : "";
  }
  styleToLocalStorage(e) {
    return e && e.length > 0 ? JSON.stringify({ medium: e }) : "";
  }
}
const Fy = new $6();
function W2(t, e) {
  let n;
  return (...o) => {
    clearTimeout(n), n = setTimeout(() => {
      t.apply(o);
    }, e);
  };
}
function Cf(t) {
  return (t == null ? void 0 : t.trim()) && !isNaN(Number(t)) ? Number(t) : void 0;
}
function q6(t, e) {
  return (t == null ? void 0 : t.split(e).map(
    (n) => n !== null && !isNaN(Number(n)) ? parseFloat(n) : void 0
  )) || [];
}
function W6(t, e) {
  return (t == null ? void 0 : t.split(e).map(ex)) || [];
}
function ex(t) {
  return (t == null ? void 0 : t.trim()) === "true" ? !0 : (t == null ? void 0 : t.trim()) === "false" ? !1 : void 0;
}
function $M() {
  return window.matchMedia(
    "(-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2), (min-resolution: 192dpi)"
  ).matches;
}
function Xs(t) {
  return typeof window < "u" && window.navigator && t.test(navigator.userAgent);
}
const H6 = Xs(/firefox/i);
Xs(/safari/i) && !Xs(/chrome/i) && Xs(/android/i);
Xs(/iP(ad|od|hone)/i);
Xs(/chrome/i) && Xs(/android/i);
Xs(/chrome/i);
Xs(
  /(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i
);
Xs(/Edge/i);
const em = "ipv6", tm = "applogin", rm = "localforage", Af = "debug", $g = "fid", Du = "lang", qg = "layersOpen", Wg = "address", a1 = "version", Z6 = "map_id", H2 = "layers", Z2 = "bgLayer", X2 = "opacities", Rd = "theme", K2 = "time", Y2 = "zoom", X6 = "SRS", J2 = "X", Q2 = "Y", Hg = "serial", qM = [
  "basemap_2015_global",
  "topogr_global",
  "topo_bw_jpeg"
], s1 = "lc", l1 = "sliderRatio", WM = "bgOpacity", K6 = "layers_indices", eE = "layers_opacity", tE = "layers_visibility";
var oo = /* @__PURE__ */ ((t) => (t[t.localStorage = 0] = "localStorage", t[t.permalink = 1] = "permalink", t[t.permalinkAsPath = 2] = "permalinkAsPath", t[t.permalinkAndLocalStorage = 3] = "permalinkAndLocalStorage", t))(oo || {});
class HM {
}
class Zg extends HM {
  static processRules(e) {
    return Zg.ruleUseLocalStorage(e) ? oo.localStorage : oo.permalink;
  }
  static processRulesForKey(e, n) {
    if (e === Rd && {}.VITE_DEPLOY_GHPAGES !== "true")
      return oo.permalinkAsPath;
    if (qM.includes(e))
      return oo.localStorage;
    if (e === Hg)
      return oo.permalink;
    if (e === qg)
      return oo.localStorage;
  }
  static ruleUseLocalStorage(e) {
    return [Y6, J6, Q6].reduce(
      (n, o) => n || o(e),
      !1
    );
  }
}
const Y6 = (t) => Object.keys(t).length === 0, J6 = (t) => Object.keys(t).length === 1 && (t.hasOwnProperty(em) || t.hasOwnProperty(tm) || t.hasOwnProperty(rm)), Q6 = (t) => Object.keys(t).length === 3 && t.hasOwnProperty(em) && t.hasOwnProperty(tm) && t.hasOwnProperty(rm);
class Xg extends HM {
  static processRules() {
    return oo.permalinkAndLocalStorage;
  }
  static processRulesForKey(e, n) {
    if (Xg.ruleUsePermalink(e))
      return oo.permalink;
    if (e === qg || qM.includes(e))
      return oo.localStorage;
    if (e === Hg)
      return oo.permalink;
    if (e === Rd)
      return oo.permalinkAsPath;
  }
  static ruleUsePermalink(e) {
    return [
      eF,
      tF,
      rF
    ].reduce(
      (n, o) => n || o(e),
      !1
    );
  }
}
const eF = (t) => t === s1 || t === l1, tF = (t) => t === a1, rF = (t) => t === Rd && {}.VITE_DEPLOY_GHPAGES === "true";
class ZM {
  constructor() {
    bi(this, "snappedUrl");
    this.snappedUrl = new URL(window.location.toString());
  }
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(e) {
    throw new Error("Method key() not implemented. " + e);
  }
  getSnappedUrl() {
    return this.snappedUrl;
  }
  getSnappedParamsAsObj() {
    return this.getSnappedParams().reduce(
      (e, n) => {
        const [o, s] = n.split("=");
        return { ...e, [o]: s };
      },
      {}
    );
  }
  getSnappedParams() {
    return this.getSnappedUrl().search.replace("?", "").split("&").filter((e) => e.split("=")[1]);
  }
  setItem(e, n) {
    const o = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    o.set(encodeURIComponent(e), encodeURIComponent(n));
    try {
      window.history.replaceState(null, "", "?" + o.toString());
    } catch {
    }
  }
  getItem(e) {
    const n = this.getSnappedUrl().searchParams.get(e);
    return n !== null ? decodeURIComponent(n) : n;
  }
  removeItem(e) {
    const n = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    n.delete(e);
    try {
      window.history.replaceState(null, "", "?" + n.toString());
    } catch {
    }
  }
  encodeQueryParam(e, n) {
    return `${encodeURIComponent(e)}=${encodeURIComponent(n)}`;
  }
}
const r0 = new ZM();
class nF extends ZM {
  getItem(e) {
    const n = this.getSnappedUrl().pathname.split("/"), o = n.findIndex((s) => s === e);
    return n[o + 1];
  }
  setItem(e, n) {
    const o = new URL(window.location.toString()).search, s = `/${e}/${n}${o}`;
    try {
      window.history.replaceState(null, "", s);
    } catch {
    }
  }
}
const iF = new nF();
class oF {
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(e) {
    throw new Error("Method key() not implemented. " + e);
  }
  removeItem(e) {
    const n = this.getWriteStorages(e);
    n == null || n.map(
      (o) => o.removeItem(e)
    );
  }
  setItem(e, n) {
    this.setValue(e, n);
  }
  getItem(e) {
    return this.getValue(e);
  }
  get paramKeys() {
    return r0.getSnappedParamsAsObj();
  }
  getValue(e) {
    var s;
    const n = (s = this.correspondingStorages(
      Zg.processRules(this.paramKeys)
    )) == null ? void 0 : s.pop(), o = this.storageForKey(e, Zg, n);
    return o ? o.getItem(e) : null;
  }
  setValue(e, n) {
    const o = this.getWriteStorages(e);
    o == null || o.map(
      (s) => s.setItem(e, n)
    );
  }
  getWriteStorages(e) {
    const n = this.correspondingStorages(
      Xg.processRules()
    ), o = this.storageForKey(e, Xg);
    return o ? [o] : n;
  }
  storageForKey(e, n, o) {
    var h;
    const s = (h = this.correspondingStorages(
      n.processRulesForKey(e, this.paramKeys)
    )) == null ? void 0 : h.pop();
    return s != null ? s : o;
  }
  correspondingStorages(e) {
    if (e === oo.permalinkAndLocalStorage)
      return [r0, localStorage];
    if (e === oo.localStorage)
      return [localStorage];
    if (e === oo.permalink)
      return [r0];
    if (e === oo.permalinkAsPath)
      return [iF];
  }
}
const By = new oF();
function aF(t) {
  return sF(t) || lF(t) || uF(t) || cF(t);
}
const sF = (t) => Object.keys(t).length === 0, lF = (t) => {
  const e = Object.keys(t);
  return Object.keys(t).length === 1 && [
    em,
    tm,
    rm,
    $g,
    Du,
    Wg,
    Af
  ].some((n) => e.indexOf(n) !== -1);
}, uF = (t) => {
  const e = Object.keys(t), n = (s) => e.indexOf(s) !== -1, o = [
    [tm, rm],
    [Af, $g],
    [Du, $g],
    [Af, Du],
    [Af, Wg],
    [Du, Wg]
  ];
  return Object.keys(t).length === 2 && o.reduce(
    (s, h) => s || h.every(n),
    !1
  );
}, cF = (t) => {
  const e = Object.keys(t), n = (a) => e.indexOf(a) !== -1, o = [em, tm, rm].every(
    n
  ), s = [Af, $g, Du].every(n), h = [Af, Wg, Du].every(n);
  return Object.keys(t).length === 3 && (o || s || h);
};
class hF {
  constructor() {
    bi(this, "intialVersion");
    const e = By.paramKeys, n = this.getValue(a1, Cf);
    this.intialVersion = n ? Math.max(2, Math.min(n, 3)) : aF(e) ? 3 : 2, this.setValue(a1, 3);
  }
  getInitialVersion() {
    return this.intialVersion;
  }
  mapToEntity(e, n) {
    return n ? n(e) : e;
  }
  mapToStorage(e, n) {
    return n ? n(e) : String(e);
  }
  getValue(e, n) {
    return this.mapToEntity(By.getValue(e), n);
  }
  setValue(e, n, o) {
    By.setValue(e, this.mapToStorage(n, o));
  }
  removeItem(e) {
    By.removeItem(e);
  }
}
const Cr = new hF(), fF = [
  "line",
  "fill",
  "symbol",
  "fill-extrusion",
  "background",
  "hillshade"
], ss = () => ({
  bg_layers: [
    {
      icon_id: "route",
      vector_id: "roadmap",
      simple_style_class: "road",
      medium_style_class: "road",
      expert_style_class: "maputnik",
      id: 556,
      is_default: !0
    },
    {
      icon_id: "topo",
      vector_id: "topomap",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 529
    },
    {
      icon_id: "topo_bw",
      vector_id: "topomap_gray",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 502
    },
    {
      icon_id: "ortho",
      id: 530
    },
    {
      icon_id: "hybrid",
      id: 501
    },
    {
      icon_id: "blank",
      id: 0
    }
  ],
  bg_layer_theme_defaults: {
    tourisme: 502
  },
  simple_styles: {
    road: [
      {
        unlocalized_label: "Light grey",
        hillshade: !1,
        colors: [
          "#ffffff",
          "#ffffff",
          "#d6e0d7",
          "#e1e1e1",
          "#cccccc",
          "#f2f2f2"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Dark grey",
        hillshade: !1,
        colors: [
          "#808080",
          "#808080",
          "#494b4a",
          "#505052",
          "#232426",
          "#454545"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Dark sand",
        hillshade: !1,
        colors: [
          "#9e9375",
          "#9e9375",
          "#6b6249",
          "#403928",
          "#b8aa84",
          "#1a1814"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Kids",
        hillshade: !1,
        colors: [
          "#f9c50d",
          "#ffffff",
          "#839836",
          "#d6d3ce",
          "#2a5ba8",
          "#eeeeee"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Light mauve",
        hillshade: !1,
        colors: [
          "#f3edf5",
          "#f3edf5",
          "#9d7da8",
          "#caa9d1",
          "#613b5c",
          "#e5d3e6"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Light Blue",
        hillshade: !1,
        colors: [
          "#dceaf5",
          "#dceaf5",
          "#5598cf",
          "#81b7e3",
          "#3b576e",
          "#b6cde0"
        ],
        selected: !1
      }
    ]
  },
  medium_default_styles: {
    road: [
      {
        label: "Roads primary",
        color: "#f7f7f7",
        lines: [
          "lu_road_trunk_primary",
          "lu_bridge_major",
          "lu_tunnel_major",
          "lu_road_major_motorway"
        ],
        visible: !0
      },
      {
        label: "Roads secondary",
        color: "#f7f7f7",
        lines: [
          "lu_road_minor",
          "lu_road_secondary_tertiary",
          "lu_bridge_minor",
          "lu_road_path",
          "lu_bridge_path",
          "lu_bridge_railway case",
          "lu_bridge_path case"
        ],
        visible: !0
      },
      {
        label: "Vegetation",
        color: "#B8D293",
        opacity: "1",
        fills: [
          "lu_landcover_wood",
          "lu_landcover_grass",
          "lu_landuse_stadium",
          "lu_landuse_cemetery"
        ],
        visible: !0
      },
      {
        label: "Buildings",
        color: "#D6AA85",
        opacity: "1",
        fillExtrusions: ["lu_building-3d_public", "lu_building-3d"],
        fills: ["lu_building", "lu_building_public"],
        lines: ["lu_bridge_railway", "lu_railway", "lu_tunnel_railway"],
        visible: !0
      },
      {
        label: "Water",
        color: "#94c1e1",
        lines: [
          "lu_waterway",
          "lu_waterway_tunnel",
          "lu_waterway_intermittent"
        ],
        fills: ["lu_water"],
        visible: !0
      },
      {
        label: "Background",
        color: "#e7e7e7",
        backgrounds: ["background"],
        visible: !0
      },
      {
        label: "Hillshade",
        hillshades: ["hillshade"],
        visible: !0
      }
    ],
    topo: [
      {
        label: "Primary Names",
        symbols: [
          "lu_place-label_other",
          "lu_place-label_city",
          "lu_place-label_canton",
          "lu_country-label-other",
          "lu_country-label",
          "place_label_other",
          "place_label_city",
          "country_label-other",
          "country_label"
        ],
        visible: !0
      },
      {
        label: "Secondary Names",
        symbols: [
          "lu_place-label_isolated",
          "lu_place-label_locality_forest",
          "lu_place-label_locality_lieudit"
        ],
        visible: !0
      },
      {
        label: "Transport",
        lines: [
          "lu_tunnel_track-casing",
          "lu_tunnel_major_motorway-casing",
          "lu_tunnel_railway_transit",
          "lu_tunnel_railway",
          "lu_tunnel_railway-hatching",
          "lu_tunnel_path",
          "lu_tunnel_track",
          "lu_tunnel_minor",
          "lu_tunnel_major_motorway",
          "lu_tunnel_secondary_tertiary",
          "lu_tunnel_trunk_primary",
          "lu_road_track-casing",
          "lu_road_minor-casing",
          "lu_road_major_motorway-casing",
          "lu_road_secondary_tertiary-casing",
          "lu_road_trunk_primary-casing",
          "lu_road_pier",
          "lu_road_path",
          "lu_road_track",
          "lu_road_minor",
          "lu_road_major_motorway",
          "lu_road_secondary_tertiary",
          "lu_road_trunk_primary",
          "lu_tram",
          "lu_tram-hatching",
          "lu_railway_transit",
          "lu_railway",
          "lu_railway-hatching",
          "lu_bridge_railway-casing",
          "lu_bridge_track-casing",
          "lu_bridge_path-casing",
          "lu_bridge_minor-casing",
          "lu_bridge_major_motorway-casing",
          "lu_bridge_secondary_tertiary-casing",
          "lu_bridge_trunk_primary-casing",
          "lu_bridge_railway",
          "lu_bridge_path",
          "lu_bridge_track",
          "lu_bridge_minor",
          "lu_bridge_major_motorway",
          "lu_bridge_secondary_tertiary",
          "lu_bridge_trunk_primary",
          "tunnel_track-casing",
          "tunnel_major_motorway-casing",
          "tunnel_railway_transit",
          "tunnel_railway_transit-hatching",
          "tunnel_railway",
          "tunnel_railway-hatching",
          "tunnel_path",
          "tunnel_track",
          "tunnel_minor",
          "tunnel_major_motorway",
          "tunnel_secondary_tertiary",
          "tunnel_trunk_primary",
          "road_track-casing",
          "road_minor-casing",
          "road_major_motorway-casing",
          "road_secondary_tertiary-casing",
          "road_trunk_primary-casing",
          "road_pier",
          "road_path",
          "road_track",
          "road_minor",
          "road_major_motorway",
          "road_secondary_tertiary",
          "road_trunk_primary",
          "railway-transit",
          "railway-transit-hatching",
          "railway",
          "railway-hatching",
          "bridge_railway-casing",
          "bridge_path-casing",
          "bridge_track_casing",
          "bridge_minor-casing",
          "bridge_major_motorway-casing",
          "bridge_secondary_tertiary-casing",
          "bridge_trunk_primary-casing",
          "bridge_railway",
          "bridge_path",
          "bridge_track",
          "bridge_minor",
          "bridge_major_motorway",
          "bridge_secondary_tertiary",
          "bridge_trunk_primary"
        ],
        symbols: [
          "lu_road_major-label",
          "lu_motorway-shield",
          "lu_road-shield"
        ],
        visible: !0
      },
      {
        label: "Vegetation",
        fills: [
          "lu_landuse_stadium",
          "lu_landuse_cemetery",
          "lu_landuse_gras",
          "lu_landuse_park",
          "lu_landuse_park-outline",
          "lu_landuse_vineyard",
          "lu_landuse_orchard",
          "lu_landuse_wood",
          "landcover_grass",
          "landcover_wood"
        ],
        visible: !0
      },
      {
        label: "Electricity",
        fills: ["lu_power_station", "lu_power_pylone"],
        lines: ["lu_power_line", "lu_power_station-outline"],
        symbols: ["lu_power_station-label", "lu_eolienne"],
        visible: !0
      },
      {
        label: "Contours and Height Points",
        lines: [
          "lu_contour-100",
          "lu_contour-50",
          "lu_contour-20",
          "lu_contour-10",
          "lu_contour"
        ],
        symbols: [
          "lu_contour-label-100",
          "lu_contour-label-20",
          "lu_apex-label"
        ],
        visible: !0
      },
      {
        label: "Hillshade",
        hillshades: ["lu_hillshade"],
        visible: !0
      }
    ]
  },
  http_bg_server: "wmts{1-2}",
  https_bg_server: "wmts{3-4}",
  bg_wmts_server_path: "mapproxy_4_v3/wmts/{Layer}",
  bg_wmts_tile_template: "{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}",
  bg_layer_projection: "EPSG:3857",
  olcs_extent: [5.31, 49.38, 6.64, 50.21],
  olcs_extent_projection: "EPSG:3857",
  bg_layer_resolutions: [
    156543.033928,
    78271.516964,
    39135.758482,
    19567.879241,
    9783.9396205,
    4891.96981025,
    2445.98490513,
    1222.99245256,
    611.496226281,
    305.748113141,
    152.87405657,
    76.4370282852,
    38.2185141426,
    19.1092570713,
    9.55462853565,
    4.77731426782,
    2.38865713391,
    1.19432856696,
    0.597164283478,
    0.298582141739,
    0.1492910708695,
    0.07464553543475
  ],
  bg_matrix_ids: [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "20",
    "21"
  ]
});
function $f() {
  function t(V) {
    const q = new URLSearchParams(document.location.search), re = q.get("embeddedserver"), X = q.get("embeddedserverprotocol") || "http";
    return (re ? `${X}://${re}` : "https://vectortiles.geoportail.lu") + `/styles/${V}/style.json`;
  }
  function e(V) {
    return `https://vectortiles.geoportail.lu/styles/${V}/{z}/{x}/{y}.png`;
  }
  function n(V) {
    return /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/gi.test(V);
  }
  const o = Ks();
  function s(V, q) {
    if (V == null)
      return;
    const re = /* @__PURE__ */ new Map();
    o.bgVectorSources.forEach((X, ae) => {
      if (ae === V.id) {
        const ce = { ...X, xyz_custom: q };
        re.set(ae, ce);
      } else
        re.set(ae, X);
    }), o.setBgVectorSources(re);
  }
  function h(V, q, re = !1) {
    const X = "", ae = t(q), ce = e(q), ve = {
      label: V,
      defaultMapBoxStyle: ae,
      defaultMapBoxStyleXYZ: ce,
      xyz: ce,
      xyz_custom: X,
      style: ae
    }, Re = new URLSearchParams(window.location.search).get("serial"), Fe = new URLSearchParams(window.location.search).get(
      "serialLayer"
    );
    if (Re)
      n(Re) && console.log(Fe);
    else if (!re)
      return Promise.resolve(ve);
    return Promise.resolve(ve);
  }
  function a(V) {
    const q = ss().medium_default_styles.road;
    if (V) {
      V.colors.forEach((X, ae) => {
        q[ae].color = X;
      });
      const re = q.findIndex(
        (X) => X.label === "Hillshade"
      );
      q[re].visible = V.hillshade;
    }
    return q;
  }
  function m(V, q, re) {
    if (!V || !q.get(V.id))
      return;
    const X = JSON.parse(
      JSON.stringify(q.get(V.id))
    );
    if (!!X && !(!X || !X.layers))
      return re && re.forEach((ae) => {
        X == null || X.layers.forEach((ce, ve) => {
          for (const Re of fF)
            if ((ae[`${Re}s`] || []).includes(ce.id)) {
              const Pe = Object.assign(
                {},
                X.layers[ve].paint
              );
              ae.color && (Pe[`${Re}-color`] = ae.color, Pe[`${Re}-opacity`] = 1, X.layers[ve].paint = Pe), X.layers[ve].layout = Object.assign(
                {},
                X.layers[ve].layout,
                { visibility: ae.visible ? "visible" : "none" }
              );
            }
        });
      }), X;
  }
  function g(V, q) {
    if (V === null)
      return Promise.resolve();
    {
      const re = `${q.get("delete")}?id=${V}`;
      return fetch(re).catch(() => "");
    }
  }
  function b(V, q, re) {
    return g(q, re).then(() => {
      const X = new FormData(), ae = JSON.stringify(V), ce = new Blob([ae], { type: "application/json" });
      X.append("style", ce, "style.json");
      const ve = {
        method: "POST",
        body: X
      };
      return fetch(re.get("upload") || "", ve).then((Re) => Re.json()).then((Re) => Re.id);
    });
  }
  function T(V, q) {
    if (!q)
      return;
    const re = V.maplibreMap;
    !re || (re.loaded() ? re.setStyle(q) : new Promise((X) => re.once("data", X)).then(
      () => re.setStyle(q)
    ));
  }
  function M(V) {
    const q = ss().bg_layers.find(
      (re) => re.id == (V == null ? void 0 : V.id)
    );
    return q == null ? void 0 : q.vector_id;
  }
  function I(V) {
    const q = ss().bg_layers.find(
      (re) => re.id == (V == null ? void 0 : V.id)
    );
    return (q == null ? void 0 : q.vector_id) !== void 0;
  }
  function P(V) {
    const q = ss().bg_layers.find(
      (re) => re.id == (V == null ? void 0 : V.id)
    );
    return {
      isEditable: (q == null ? void 0 : q.vector_id) !== void 0,
      hasSimpleStyle: (q == null ? void 0 : q.simple_style_class) !== void 0,
      hasAdvancedStyle: (q == null ? void 0 : q.medium_style_class) !== void 0,
      hasExpertStyle: (q == null ? void 0 : q.expert_style_class) !== void 0
    };
  }
  function z(V, q) {
    return q.map(
      (re) => Object.assign(re, {
        selected: re.colors.every(
          (X, ae) => {
            var ce;
            return ((ce = V[ae]) == null ? void 0 : ce.color) === X;
          }
        )
      })
    );
  }
  return {
    getDefaultMapBoxStyleUrl: t,
    getDefaultMapBoxStyleXYZ: e,
    setConfigForLayer: h,
    getRoadStyleFromSimpleStyle: a,
    applyDefaultStyle: m,
    applyConsolidatedStyle: T,
    getVectorId: M,
    setCustomStyleSerial: s,
    unregisterStyle: g,
    registerStyle: b,
    checkSelection: z,
    isLayerStyleEditable: I,
    getStyleCapabilitiesFromLayer: P
  };
}
const Ks = ih(
  "style",
  () => {
    const t = $f(), e = Bn(), n = Bn(/* @__PURE__ */ new Map()), o = Bn(
      /* @__PURE__ */ new Map()
    ), s = Bn(!1), h = Bn(null), a = Bn(), m = Bn(
      /* @__PURE__ */ new Map([
        ["get", "/getvtstyle"],
        ["upload", "/uploadvtstyle"],
        ["delete", "/deletevtstyle"]
      ])
    ), g = [];
    ss().bg_layers.forEach((re) => {
      if (re.vector_id) {
        const X = t.setConfigForLayer(
          re.icon_id,
          re.vector_id
        );
        g.push(
          X.then((ae) => ({ id: re.id, config: ae }))
        );
      }
    }), Promise.all(g).then((re) => {
      const X = /* @__PURE__ */ new Map();
      re.forEach((ae) => X.set(ae.id, ae.config)), n.value = X;
    });
    function b(re, X) {
      m.value.set(re, X);
    }
    function T(re) {
      n.value = re;
    }
    function M(re) {
      const X = /* @__PURE__ */ new Map();
      o.value.forEach((ae, ce) => {
        ce !== re && X.set(ce, ae);
      }), o.value = X;
    }
    function I(re, X) {
      const ae = /* @__PURE__ */ new Map();
      o.value.forEach(
        (ce, ve) => ae.set(ve, ce)
      ), ae.set(re, X), o.value = ae;
    }
    function P(re) {
      e.value = t.getRoadStyleFromSimpleStyle(re), V();
    }
    function z(re) {
      e.value = re, V();
    }
    function V() {
      s.value = !1;
    }
    function q() {
      s.value = !0;
    }
    return {
      bgStyle: e,
      bgVectorSources: n,
      bgVectorBaseStyles: o,
      isExpertStyleActive: s,
      appliedStyle: a,
      removeBaseStyle: M,
      setBaseStyle: I,
      setBgVectorSources: T,
      setRegisterUrl: b,
      setSimpleStyle: P,
      setStyle: z,
      disableExpertStyle: V,
      enableExpertStyle: q,
      styleSerial: h,
      registerUrls: m
    };
  },
  {}
);
class pF {
  constructor() {
    bi(this, "styleWatcher");
  }
  bootstrapStyle() {
    const e = Ks();
    let n, o = !1;
    n = va(() => {
      e.bgVectorSources && (this.restoreStyle(!1), o && this.persistStyle(), o = !0, n && n());
    });
  }
  persistStyle() {
    const e = Ks(), { bgStyle: n } = xn(e);
    this.styleWatcher || (this.styleWatcher = Pn(
      n,
      (o, s) => {
        if (s !== o) {
          const h = Ei();
          h.bgLayer && (Cr.setValue(
            h.bgLayer.name,
            o || [],
            Fy.styleToLocalStorage
          ), Cr.setValue(
            Hg,
            o || [],
            Fy.styleToSerial
          ));
        }
      },
      { immediate: !0 }
    ));
  }
  restoreStyle(e) {
    const n = Ks();
    n.setStyle(null);
    const s = Ei().bgLayer;
    if (s) {
      let h = [];
      e || (h = Cr.getValue(
        Hg,
        Fy.styleSerialToStyle
      )), h.length === 0 && (h = Cr.getValue(
        s.name,
        Fy.styleLocalStorageToStyle
      )), h && h.length > 0 && n.setStyle(h);
    }
  }
}
const XM = new pF(), dF = "https://map.geoportail.lu/ogcproxywms", KM = "https://map.geoportail.lu/httpsproxy";
function YM() {
  return wC(
    [5.31, 49.38, 6.64, 50.21],
    zT,
    yd
  );
}
function JM(t) {
  var e;
  return !!((e = t == null ? void 0 : t.metadata) != null && e.hasRetina) && $M();
}
function mF(t, e = "https") {
  const n = t.imageType.split("/")[1], o = Cr.getValue(em, ex) ? "app.geoportail.lu" : "geoportail.lu";
  return `${e === "https" ? "//wmts{3-4}." : "//wmts{1-2}."}${o}/mapproxy_4_v3/wmts/{Layer}${JM(t) ? "_hd" : ""}/{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}.${n}`;
}
class yF {
  createOlLayer(e) {
    const { name: n, layers: o, imageType: s, url: h, id: a } = e, m = new OE({
      url: h || dF,
      hidpi: $M(),
      serverType: "mapserver",
      params: {
        FORMAT: s,
        LAYERS: o
      },
      ...h != null || KM ? { crossOrigin: "anonymous" } : {}
    });
    return new IC({
      properties: {
        "olcs.extent": YM(),
        label: n,
        id: a
      },
      source: m
    });
  }
  setLayerTime(e, n) {
    const o = e.getParams();
    o.TIME = n, e.updateParams(o);
  }
}
const QM = new yF(), gF = [
  156543.033928,
  78271.516964,
  39135.758482,
  19567.879241,
  9783.9396205,
  4891.96981025,
  2445.98490513,
  1222.99245256,
  611.496226281,
  305.748113141,
  152.87405657,
  76.4370282852,
  38.2185141426,
  19.1092570713,
  9.55462853565,
  4.77731426782,
  2.38865713391,
  1.19432856696,
  0.597164283478,
  0.298582141739,
  0.1492910708695,
  0.07464553543475
], vF = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "20",
  "21"
];
class _F {
  createOlLayer(e) {
    const { name: n, imageType: o, id: s } = e, h = JM(e), a = Xy(yd), m = a.getExtent(), g = new CE({
      url: mF(e),
      tilePixelRatio: h ? 2 : 1,
      layer: n,
      matrixSet: `GLOBAL_WEBMERCATOR_4_V3${h ? "_HD" : ""}`,
      format: o,
      requestEncoding: "REST",
      projection: a,
      tileGrid: new CC({
        origin: AC(m),
        extent: m,
        resolutions: gF,
        matrixIds: vF
      }),
      style: "default",
      crossOrigin: "anonymous"
    });
    return new OC({
      source: g,
      properties: {
        "olcs.extent": YM(),
        label: n,
        id: s
      }
    });
  }
  setLayerTime(e, n, o) {
    const s = e.get("metadata").time_layers[o], h = n.getUrls();
    if (h) {
      const a = this.transformUrls(h, s);
      n.setUrls(a), e.set("label", s), e.set("layer_name", s);
    }
  }
  transformUrls(e, n) {
    return e.map(
      (o) => o.replace(
        /[/][^/]*[/]{TileMatrixSet}/,
        `/${n}/{TileMatrixSet}`
      )
    );
  }
}
const eI = new _F();
var $s = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, tI = { exports: {} };
(function(t, e) {
  (function(n, o) {
    t.exports = o();
  })($s, function() {
    var n, o, s;
    function h(a, m) {
      if (!n)
        n = m;
      else if (!o)
        o = m;
      else {
        var g = "var sharedChunk = {}; (" + n + ")(sharedChunk); (" + o + ")(sharedChunk);", b = {};
        n(b), s = m(b), typeof window < "u" && (s.workerUrl = window.URL.createObjectURL(new Blob([g], { type: "text/javascript" })));
      }
    }
    return h(["exports"], function(a) {
      function m(r, i) {
        return r(i = { exports: {} }, i.exports), i.exports;
      }
      var g = b;
      function b(r, i, l, p) {
        this.cx = 3 * r, this.bx = 3 * (l - r) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (p - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r, this.p1y = p, this.p2x = l, this.p2y = p;
      }
      b.prototype.sampleCurveX = function(r) {
        return ((this.ax * r + this.bx) * r + this.cx) * r;
      }, b.prototype.sampleCurveY = function(r) {
        return ((this.ay * r + this.by) * r + this.cy) * r;
      }, b.prototype.sampleCurveDerivativeX = function(r) {
        return (3 * this.ax * r + 2 * this.bx) * r + this.cx;
      }, b.prototype.solveCurveX = function(r, i) {
        var l, p, y, v, x;
        for (i === void 0 && (i = 1e-6), y = r, x = 0; x < 8; x++) {
          if (v = this.sampleCurveX(y) - r, Math.abs(v) < i)
            return y;
          var S = this.sampleCurveDerivativeX(y);
          if (Math.abs(S) < 1e-6)
            break;
          y -= v / S;
        }
        if ((y = r) < (l = 0))
          return l;
        if (y > (p = 1))
          return p;
        for (; l < p; ) {
          if (v = this.sampleCurveX(y), Math.abs(v - r) < i)
            return y;
          r > v ? l = y : p = y, y = 0.5 * (p - l) + l;
        }
        return y;
      }, b.prototype.solve = function(r, i) {
        return this.sampleCurveY(this.solveCurveX(r, i));
      };
      var T = M;
      function M(r, i) {
        this.x = r, this.y = i;
      }
      M.prototype = { clone: function() {
        return new M(this.x, this.y);
      }, add: function(r) {
        return this.clone()._add(r);
      }, sub: function(r) {
        return this.clone()._sub(r);
      }, multByPoint: function(r) {
        return this.clone()._multByPoint(r);
      }, divByPoint: function(r) {
        return this.clone()._divByPoint(r);
      }, mult: function(r) {
        return this.clone()._mult(r);
      }, div: function(r) {
        return this.clone()._div(r);
      }, rotate: function(r) {
        return this.clone()._rotate(r);
      }, rotateAround: function(r, i) {
        return this.clone()._rotateAround(r, i);
      }, matMult: function(r) {
        return this.clone()._matMult(r);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(r) {
        return this.x === r.x && this.y === r.y;
      }, dist: function(r) {
        return Math.sqrt(this.distSqr(r));
      }, distSqr: function(r) {
        var i = r.x - this.x, l = r.y - this.y;
        return i * i + l * l;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(r) {
        return Math.atan2(this.y - r.y, this.x - r.x);
      }, angleWith: function(r) {
        return this.angleWithSep(r.x, r.y);
      }, angleWithSep: function(r, i) {
        return Math.atan2(this.x * i - this.y * r, this.x * r + this.y * i);
      }, _matMult: function(r) {
        var i = r[2] * this.x + r[3] * this.y;
        return this.x = r[0] * this.x + r[1] * this.y, this.y = i, this;
      }, _add: function(r) {
        return this.x += r.x, this.y += r.y, this;
      }, _sub: function(r) {
        return this.x -= r.x, this.y -= r.y, this;
      }, _mult: function(r) {
        return this.x *= r, this.y *= r, this;
      }, _div: function(r) {
        return this.x /= r, this.y /= r, this;
      }, _multByPoint: function(r) {
        return this.x *= r.x, this.y *= r.y, this;
      }, _divByPoint: function(r) {
        return this.x /= r.x, this.y /= r.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var r = this.y;
        return this.y = this.x, this.x = -r, this;
      }, _rotate: function(r) {
        var i = Math.cos(r), l = Math.sin(r), p = l * this.x + i * this.y;
        return this.x = i * this.x - l * this.y, this.y = p, this;
      }, _rotateAround: function(r, i) {
        var l = Math.cos(r), p = Math.sin(r), y = i.y + p * (this.x - i.x) + l * (this.y - i.y);
        return this.x = i.x + l * (this.x - i.x) - p * (this.y - i.y), this.y = y, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, M.convert = function(r) {
        return r instanceof M ? r : Array.isArray(r) ? new M(r[0], r[1]) : r;
      };
      var I = typeof self < "u" ? self : {}, P = Math.pow(2, 53) - 1;
      function z(r, i, l, p) {
        var y = new g(r, i, l, p);
        return function(v) {
          return y.solve(v);
        };
      }
      var V = z(0.25, 0.1, 0.25, 1);
      function q(r, i, l) {
        return Math.min(l, Math.max(i, r));
      }
      function re(r, i, l) {
        var p = l - i, y = ((r - i) % p + p) % p + i;
        return y === i ? l : y;
      }
      function X(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        for (var p = 0, y = i; p < y.length; p += 1) {
          var v = y[p];
          for (var x in v)
            r[x] = v[x];
        }
        return r;
      }
      var ae = 1;
      function ce() {
        return ae++;
      }
      function ve() {
        return function r(i) {
          return i ? (i ^ 16 * Math.random() >> i / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, r);
        }();
      }
      function Re(r) {
        return !!r && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(r);
      }
      function Fe(r, i) {
        r.forEach(function(l) {
          i[l] && (i[l] = i[l].bind(i));
        });
      }
      function Pe(r, i) {
        return r.indexOf(i, r.length - i.length) !== -1;
      }
      function Se(r, i, l) {
        var p = {};
        for (var y in r)
          p[y] = i.call(l || this, r[y], y, r);
        return p;
      }
      function Ie(r, i, l) {
        var p = {};
        for (var y in r)
          i.call(l || this, r[y], y, r) && (p[y] = r[y]);
        return p;
      }
      function Xe(r) {
        return Array.isArray(r) ? r.map(Xe) : typeof r == "object" && r ? Se(r, Xe) : r;
      }
      var $e = {};
      function at(r) {
        $e[r] || (typeof console < "u" && console.warn(r), $e[r] = !0);
      }
      function be(r, i, l) {
        return (l.y - r.y) * (i.x - r.x) > (i.y - r.y) * (l.x - r.x);
      }
      function Ye(r) {
        for (var i = 0, l = 0, p = r.length, y = p - 1, v = void 0, x = void 0; l < p; y = l++)
          i += ((x = r[y]).x - (v = r[l]).x) * (v.y + x.y);
        return i;
      }
      function ht() {
        return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
      }
      function vt(r) {
        var i = {};
        if (r.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, function(p, y, v, x) {
          var S = v || x;
          return i[y] = !S || S.toLowerCase(), "";
        }), i["max-age"]) {
          var l = parseInt(i["max-age"], 10);
          isNaN(l) ? delete i["max-age"] : i["max-age"] = l;
        }
        return i;
      }
      var Pt = null;
      function tr(r) {
        if (Pt == null) {
          var i = r.navigator ? r.navigator.userAgent : null;
          Pt = !!r.safari || !(!i || !(/\b(iPad|iPhone|iPod)\b/.test(i) || i.match("Safari") && !i.match("Chrome")));
        }
        return Pt;
      }
      function kn(r) {
        try {
          var i = I[r];
          return i.setItem("_mapbox_test_", 1), i.removeItem("_mapbox_test_"), !0;
        } catch {
          return !1;
        }
      }
      var Rr, pr, Zn, zr, Fi = I.performance && I.performance.now ? I.performance.now.bind(I.performance) : Date.now.bind(Date), $r = I.requestAnimationFrame || I.mozRequestAnimationFrame || I.webkitRequestAnimationFrame || I.msRequestAnimationFrame, kr = I.cancelAnimationFrame || I.mozCancelAnimationFrame || I.webkitCancelAnimationFrame || I.msCancelAnimationFrame, Vn = { now: Fi, frame: function(r) {
        var i = $r(r);
        return { cancel: function() {
          return kr(i);
        } };
      }, getImageData: function(r, i) {
        i === void 0 && (i = 0);
        var l = I.document.createElement("canvas"), p = l.getContext("2d");
        if (!p)
          throw new Error("failed to create canvas 2d context");
        return l.width = r.width, l.height = r.height, p.drawImage(r, 0, 0, r.width, r.height), p.getImageData(-i, -i, r.width + 2 * i, r.height + 2 * i);
      }, resolveURL: function(r) {
        return Rr || (Rr = I.document.createElement("a")), Rr.href = r, Rr.href;
      }, hardwareConcurrency: I.navigator && I.navigator.hardwareConcurrency || 4, get devicePixelRatio() {
        return I.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!I.matchMedia && (pr == null && (pr = I.matchMedia("(prefers-reduced-motion: reduce)")), pr.matches);
      } }, Tr = { API_URL: "https://api.mapbox.com", get EVENTS_URL() {
        return this.API_URL ? this.API_URL.indexOf("https://api.mapbox.cn") === 0 ? "https://events.mapbox.cn/events/v2" : this.API_URL.indexOf("https://api.mapbox.com") === 0 ? "https://events.mapbox.com/events/v2" : null : null;
      }, FEEDBACK_URL: "https://apps.mapbox.com/feedback", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, Sn = { supported: !1, testSupport: function(r) {
        !oi && zr && (Un ? K(r) : Zn = r);
      } }, oi = !1, Un = !1;
      function K(r) {
        var i = r.createTexture();
        r.bindTexture(r.TEXTURE_2D, i);
        try {
          if (r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, zr), r.isContextLost())
            return;
          Sn.supported = !0;
        } catch {
        }
        r.deleteTexture(i), oi = !0;
      }
      I.document && ((zr = I.document.createElement("img")).onload = function() {
        Zn && K(Zn), Zn = null, Un = !0;
      }, zr.onerror = function() {
        oi = !0, Zn = null;
      }, zr.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      var ye = "01", Ne = function(r, i) {
        this._transformRequestFn = r, this._customAccessToken = i, this._createSkuToken();
      };
      function qe(r) {
        return r.indexOf("mapbox:") === 0;
      }
      Ne.prototype._createSkuToken = function() {
        var r = function() {
          for (var i = "", l = 0; l < 10; l++)
            i += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
          return { token: ["1", ye, i].join(""), tokenExpiresAt: Date.now() + 432e5 };
        }();
        this._skuToken = r.token, this._skuTokenExpiresAt = r.tokenExpiresAt;
      }, Ne.prototype._isSkuTokenExpired = function() {
        return Date.now() > this._skuTokenExpiresAt;
      }, Ne.prototype.transformRequest = function(r, i) {
        return this._transformRequestFn && this._transformRequestFn(r, i) || { url: r };
      }, Ne.prototype.normalizeStyleURL = function(r, i) {
        if (!qe(r))
          return r;
        var l = et(r);
        return l.path = "/styles/v1" + l.path, this._makeAPIURL(l, this._customAccessToken || i);
      }, Ne.prototype.normalizeGlyphsURL = function(r, i) {
        if (!qe(r))
          return r;
        var l = et(r);
        return l.path = "/fonts/v1" + l.path, this._makeAPIURL(l, this._customAccessToken || i);
      }, Ne.prototype.normalizeSourceURL = function(r, i) {
        if (!qe(r))
          return r;
        var l = et(r);
        return l.path = "/v4/" + l.authority + ".json", l.params.push("secure"), this._makeAPIURL(l, this._customAccessToken || i);
      }, Ne.prototype.normalizeSpriteURL = function(r, i, l, p) {
        var y = et(r);
        return qe(r) ? (y.path = "/styles/v1" + y.path + "/sprite" + i + l, this._makeAPIURL(y, this._customAccessToken || p)) : (y.path += "" + i + l, ut(y));
      }, Ne.prototype.normalizeTileURL = function(r, i) {
        if (this._isSkuTokenExpired() && this._createSkuToken(), r && !qe(r))
          return r;
        var l = et(r);
        l.path = l.path.replace(/(\.(png|jpg)\d*)(?=$)/, (Vn.devicePixelRatio >= 2 || i === 512 ? "@2x" : "") + (Sn.supported ? ".webp" : "$1")), l.path = l.path.replace(/^.+\/v4\//, "/"), l.path = "/v4" + l.path;
        var p = this._customAccessToken || function(y) {
          for (var v = 0, x = y; v < x.length; v += 1) {
            var S = x[v].match(/^access_token=(.*)$/);
            if (S)
              return S[1];
          }
          return null;
        }(l.params) || Tr.ACCESS_TOKEN;
        return Tr.REQUIRE_ACCESS_TOKEN && p && this._skuToken && l.params.push("sku=" + this._skuToken), this._makeAPIURL(l, p);
      }, Ne.prototype.canonicalizeTileURL = function(r, i) {
        var l = et(r);
        if (!l.path.match(/(^\/v4\/)/) || !l.path.match(/\.[\w]+$/))
          return r;
        var p = "mapbox://tiles/";
        p += l.path.replace("/v4/", "");
        var y = l.params;
        return i && (y = y.filter(function(v) {
          return !v.match(/^access_token=/);
        })), y.length && (p += "?" + y.join("&")), p;
      }, Ne.prototype.canonicalizeTileset = function(r, i) {
        for (var l = !!i && qe(i), p = [], y = 0, v = r.tiles || []; y < v.length; y += 1) {
          var x = v[y];
          rt(x) ? p.push(this.canonicalizeTileURL(x, l)) : p.push(x);
        }
        return p;
      }, Ne.prototype._makeAPIURL = function(r, i) {
        var l = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", p = et(Tr.API_URL);
        if (r.protocol = p.protocol, r.authority = p.authority, r.protocol === "http") {
          var y = r.params.indexOf("secure");
          y >= 0 && r.params.splice(y, 1);
        }
        if (p.path !== "/" && (r.path = "" + p.path + r.path), !Tr.REQUIRE_ACCESS_TOKEN)
          return ut(r);
        if (!(i = i || Tr.ACCESS_TOKEN))
          throw new Error("An API access token is required to use Mapbox GL. " + l);
        if (i[0] === "s")
          throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + l);
        return r.params = r.params.filter(function(v) {
          return v.indexOf("access_token") === -1;
        }), r.params.push("access_token=" + i), ut(r);
      };
      var We = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
      function rt(r) {
        return We.test(r);
      }
      var mt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function et(r) {
        var i = r.match(mt);
        if (!i)
          throw new Error("Unable to parse URL object");
        return { protocol: i[1], authority: i[2], path: i[3] || "/", params: i[4] ? i[4].split("&") : [] };
      }
      function ut(r) {
        var i = r.params.length ? "?" + r.params.join("&") : "";
        return r.protocol + "://" + r.authority + r.path + i;
      }
      function Qe(r) {
        if (!r)
          return null;
        var i = r.split(".");
        if (!i || i.length !== 3)
          return null;
        try {
          return JSON.parse(decodeURIComponent(I.atob(i[1]).split("").map(function(l) {
            return "%" + ("00" + l.charCodeAt(0).toString(16)).slice(-2);
          }).join("")));
        } catch {
          return null;
        }
      }
      var It = function(r) {
        this.type = r, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
      };
      It.prototype.getStorageKey = function(r) {
        var i, l = Qe(Tr.ACCESS_TOKEN);
        return i = l && l.u ? I.btoa(encodeURIComponent(l.u).replace(/%([0-9A-F]{2})/g, function(p, y) {
          return String.fromCharCode(Number("0x" + y));
        })) : Tr.ACCESS_TOKEN || "", r ? "mapbox.eventData." + r + ":" + i : "mapbox.eventData:" + i;
      }, It.prototype.fetchEventData = function() {
        var r = kn("localStorage"), i = this.getStorageKey(), l = this.getStorageKey("uuid");
        if (r)
          try {
            var p = I.localStorage.getItem(i);
            p && (this.eventData = JSON.parse(p));
            var y = I.localStorage.getItem(l);
            y && (this.anonId = y);
          } catch {
            at("Unable to read from LocalStorage");
          }
      }, It.prototype.saveEventData = function() {
        var r = kn("localStorage"), i = this.getStorageKey(), l = this.getStorageKey("uuid");
        if (r)
          try {
            I.localStorage.setItem(l, this.anonId), Object.keys(this.eventData).length >= 1 && I.localStorage.setItem(i, JSON.stringify(this.eventData));
          } catch {
            at("Unable to write to LocalStorage");
          }
      }, It.prototype.processRequests = function(r) {
      }, It.prototype.postEvent = function(r, i, l, p) {
        var y = this;
        if (Tr.EVENTS_URL) {
          var v = et(Tr.EVENTS_URL);
          v.params.push("access_token=" + (p || Tr.ACCESS_TOKEN || ""));
          var x = { event: this.type, created: new Date(r).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: "1.13.3", skuId: ye, userId: this.anonId }, S = i ? X(x, i) : x, C = { url: ut(v), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([S]) };
          this.pendingRequest = bn(C, function(A) {
            y.pendingRequest = null, l(A), y.saveEventData(), y.processRequests(p);
          });
        }
      }, It.prototype.queueRequest = function(r, i) {
        this.queue.push(r), this.processRequests(i);
      };
      var bt, kt, Ut = function(r) {
        function i() {
          r.call(this, "map.load"), this.success = {}, this.skuToken = "";
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.postMapLoadEvent = function(l, p, y, v) {
          this.skuToken = y;
          var x = !(!v && !Tr.ACCESS_TOKEN), S = Array.isArray(l) && l.some(function(C) {
            return qe(C) || rt(C);
          });
          Tr.EVENTS_URL && x && S && this.queueRequest({ id: p, timestamp: Date.now() }, v);
        }, i.prototype.processRequests = function(l) {
          var p = this;
          if (!this.pendingRequest && this.queue.length !== 0) {
            var y = this.queue.shift(), v = y.id, x = y.timestamp;
            v && this.success[v] || (this.anonId || this.fetchEventData(), Re(this.anonId) || (this.anonId = ve()), this.postEvent(x, { skuToken: this.skuToken }, function(S) {
              S || v && (p.success[v] = !0);
            }, l));
          }
        }, i;
      }(It), dr = new (function(r) {
        function i(l) {
          r.call(this, "appUserTurnstile"), this._customAccessToken = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.postTurnstileEvent = function(l, p) {
          Tr.EVENTS_URL && Tr.ACCESS_TOKEN && Array.isArray(l) && l.some(function(y) {
            return qe(y) || rt(y);
          }) && this.queueRequest(Date.now(), p);
        }, i.prototype.processRequests = function(l) {
          var p = this;
          if (!this.pendingRequest && this.queue.length !== 0) {
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            var y = Qe(Tr.ACCESS_TOKEN), v = y ? y.u : Tr.ACCESS_TOKEN, x = v !== this.eventData.tokenU;
            Re(this.anonId) || (this.anonId = ve(), x = !0);
            var S = this.queue.shift();
            if (this.eventData.lastSuccess) {
              var C = new Date(this.eventData.lastSuccess), A = new Date(S), L = (S - this.eventData.lastSuccess) / 864e5;
              x = x || L >= 1 || L < -1 || C.getDate() !== A.getDate();
            } else
              x = !0;
            if (!x)
              return this.processRequests();
            this.postEvent(S, { "enabled.telemetry": !1 }, function(D) {
              D || (p.eventData.lastSuccess = S, p.eventData.tokenU = v);
            }, l);
          }
        }, i;
      }(It))(), Vr = dr.postTurnstileEvent.bind(dr), Lr = new Ut(), Jr = Lr.postMapLoadEvent.bind(Lr), Xn = 500, Bi = 50;
      function so() {
        I.caches && !bt && (bt = I.caches.open("mapbox-tiles"));
      }
      function Kn(r) {
        var i = r.indexOf("?");
        return i < 0 ? r : r.slice(0, i);
      }
      var Li, Tn = 1 / 0;
      function ai() {
        return Li == null && (Li = I.OffscreenCanvas && new I.OffscreenCanvas(1, 1).getContext("2d") && typeof I.createImageBitmap == "function"), Li;
      }
      var Fa = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
      typeof Object.freeze == "function" && Object.freeze(Fa);
      var Uo = function(r) {
        function i(l, p, y) {
          p === 401 && rt(y) && (l += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), r.call(this, l), this.status = p, this.url = y, this.name = this.constructor.name, this.message = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.toString = function() {
          return this.name + ": " + this.message + " (" + this.status + "): " + this.url;
        }, i;
      }(Error), Ba = ht() ? function() {
        return self.worker && self.worker.referrer;
      } : function() {
        return (I.location.protocol === "blob:" ? I.parent : I).location.href;
      }, na, an, So = function(r, i) {
        if (!(/^file:/.test(l = r.url) || /^file:/.test(Ba()) && !/^\w+:/.test(l))) {
          if (I.fetch && I.Request && I.AbortController && I.Request.prototype.hasOwnProperty("signal"))
            return function(p, y) {
              var v, x = new I.AbortController(), S = new I.Request(p.url, { method: p.method || "GET", body: p.body, credentials: p.credentials, headers: p.headers, referrer: Ba(), signal: x.signal }), C = !1, A = !1, L = (v = S.url).indexOf("sku=") > 0 && rt(v);
              p.type === "json" && S.headers.set("Accept", "application/json");
              var D = function(j, J, ee) {
                if (!A) {
                  if (j && j.message !== "SecurityError" && at(j), J && ee)
                    return B(J);
                  var he = Date.now();
                  I.fetch(S).then(function(oe) {
                    if (oe.ok) {
                      var ge = L ? oe.clone() : null;
                      return B(oe, ge, he);
                    }
                    return y(new Uo(oe.statusText, oe.status, p.url));
                  }).catch(function(oe) {
                    oe.code !== 20 && y(new Error(oe.message));
                  });
                }
              }, B = function(j, J, ee) {
                (p.type === "arrayBuffer" ? j.arrayBuffer() : p.type === "json" ? j.json() : j.text()).then(function(he) {
                  A || (J && ee && function(oe, ge, we) {
                    if (so(), bt) {
                      var Te = { status: ge.status, statusText: ge.statusText, headers: new I.Headers() };
                      ge.headers.forEach(function(Be, Ke) {
                        return Te.headers.set(Ke, Be);
                      });
                      var Oe = vt(ge.headers.get("Cache-Control") || "");
                      Oe["no-store"] || (Oe["max-age"] && Te.headers.set("Expires", new Date(we + 1e3 * Oe["max-age"]).toUTCString()), new Date(Te.headers.get("Expires")).getTime() - we < 42e4 || function(Be, Ke) {
                        if (kt === void 0)
                          try {
                            new Response(new ReadableStream()), kt = !0;
                          } catch {
                            kt = !1;
                          }
                        kt ? Ke(Be.body) : Be.blob().then(Ke);
                      }(ge, function(Be) {
                        var Ke = new I.Response(Be, Te);
                        so(), bt && bt.then(function(ot) {
                          return ot.put(Kn(oe.url), Ke);
                        }).catch(function(ot) {
                          return at(ot.message);
                        });
                      }));
                    }
                  }(S, J, ee), C = !0, y(null, he, j.headers.get("Cache-Control"), j.headers.get("Expires")));
                }).catch(function(he) {
                  A || y(new Error(he.message));
                });
              };
              return L ? function(j, J) {
                if (so(), !bt)
                  return J(null);
                var ee = Kn(j.url);
                bt.then(function(he) {
                  he.match(ee).then(function(oe) {
                    var ge = function(we) {
                      if (!we)
                        return !1;
                      var Te = new Date(we.headers.get("Expires") || 0), Oe = vt(we.headers.get("Cache-Control") || "");
                      return Te > Date.now() && !Oe["no-cache"];
                    }(oe);
                    he.delete(ee), ge && he.put(ee, oe.clone()), J(null, oe, ge);
                  }).catch(J);
                }).catch(J);
              }(S, D) : D(null, null), { cancel: function() {
                A = !0, C || x.abort();
              } };
            }(r, i);
          if (ht() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", r, i, void 0, !0);
        }
        var l;
        return function(p, y) {
          var v = new I.XMLHttpRequest();
          for (var x in v.open(p.method || "GET", p.url, !0), p.type === "arrayBuffer" && (v.responseType = "arraybuffer"), p.headers)
            v.setRequestHeader(x, p.headers[x]);
          return p.type === "json" && (v.responseType = "text", v.setRequestHeader("Accept", "application/json")), v.withCredentials = p.credentials === "include", v.onerror = function() {
            y(new Error(v.statusText));
          }, v.onload = function() {
            if ((v.status >= 200 && v.status < 300 || v.status === 0) && v.response !== null) {
              var S = v.response;
              if (p.type === "json")
                try {
                  S = JSON.parse(v.response);
                } catch (C) {
                  return y(C);
                }
              y(null, S, v.getResponseHeader("Cache-Control"), v.getResponseHeader("Expires"));
            } else
              y(new Uo(v.statusText, v.status, p.url));
          }, v.send(p.body), { cancel: function() {
            return v.abort();
          } };
        }(r, i);
      }, ol = function(r, i) {
        return So(X(r, { type: "arrayBuffer" }), i);
      }, bn = function(r, i) {
        return So(X(r, { method: "POST" }), i);
      }, N = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      na = [], an = 0;
      var F = function(r, i) {
        if (Sn.supported && (r.headers || (r.headers = {}), r.headers.accept = "image/webp,*/*"), an >= Tr.MAX_PARALLEL_IMAGE_REQUESTS) {
          var l = { requestParameters: r, callback: i, cancelled: !1, cancel: function() {
            this.cancelled = !0;
          } };
          return na.push(l), l;
        }
        an++;
        var p = !1, y = function() {
          if (!p)
            for (p = !0, an--; na.length && an < Tr.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              var x = na.shift();
              x.cancelled || (x.cancel = F(x.requestParameters, x.callback).cancel);
            }
        }, v = ol(r, function(x, S, C, A) {
          y(), x ? i(x) : S && (ai() ? function(L, D) {
            var B = new I.Blob([new Uint8Array(L)], { type: "image/png" });
            I.createImageBitmap(B).then(function(j) {
              D(null, j);
            }).catch(function(j) {
              D(new Error("Could not load image because of " + j.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            });
          }(S, i) : function(L, D, B, j) {
            var J = new I.Image(), ee = I.URL;
            J.onload = function() {
              D(null, J), ee.revokeObjectURL(J.src), J.onload = null, I.requestAnimationFrame(function() {
                J.src = N;
              });
            }, J.onerror = function() {
              return D(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            };
            var he = new I.Blob([new Uint8Array(L)], { type: "image/png" });
            J.cacheControl = B, J.expires = j, J.src = L.byteLength ? ee.createObjectURL(he) : N;
          }(S, i, C, A));
        });
        return { cancel: function() {
          v.cancel(), y();
        } };
      };
      function U(r, i, l) {
        l[r] && l[r].indexOf(i) !== -1 || (l[r] = l[r] || [], l[r].push(i));
      }
      function Z(r, i, l) {
        if (l && l[r]) {
          var p = l[r].indexOf(i);
          p !== -1 && l[r].splice(p, 1);
        }
      }
      var Q = function(r, i) {
        i === void 0 && (i = {}), X(this, i), this.type = r;
      }, pe = function(r) {
        function i(l, p) {
          p === void 0 && (p = {}), r.call(this, "error", X({ error: l }, p));
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(Q), de = function() {
      };
      de.prototype.on = function(r, i) {
        return this._listeners = this._listeners || {}, U(r, i, this._listeners), this;
      }, de.prototype.off = function(r, i) {
        return Z(r, i, this._listeners), Z(r, i, this._oneTimeListeners), this;
      }, de.prototype.once = function(r, i) {
        return this._oneTimeListeners = this._oneTimeListeners || {}, U(r, i, this._oneTimeListeners), this;
      }, de.prototype.fire = function(r, i) {
        typeof r == "string" && (r = new Q(r, i || {}));
        var l = r.type;
        if (this.listens(l)) {
          r.target = this;
          for (var p = 0, y = this._listeners && this._listeners[l] ? this._listeners[l].slice() : []; p < y.length; p += 1)
            y[p].call(this, r);
          for (var v = 0, x = this._oneTimeListeners && this._oneTimeListeners[l] ? this._oneTimeListeners[l].slice() : []; v < x.length; v += 1) {
            var S = x[v];
            Z(l, S, this._oneTimeListeners), S.call(this, r);
          }
          var C = this._eventedParent;
          C && (X(r, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), C.fire(r));
        } else
          r instanceof pe && console.error(r.error);
        return this;
      }, de.prototype.listens = function(r) {
        return this._listeners && this._listeners[r] && this._listeners[r].length > 0 || this._oneTimeListeners && this._oneTimeListeners[r] && this._oneTimeListeners[r].length > 0 || this._eventedParent && this._eventedParent.listens(r);
      }, de.prototype.setEventedParent = function(r, i) {
        return this._eventedParent = r, this._eventedParentData = i, this;
      };
      var G = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }, ie = function(r, i, l, p) {
        this.message = (r ? r + ": " : "") + l, p && (this.identifier = p), i != null && i.__line__ && (this.line = i.__line__);
      };
      function _e(r) {
        var i = r.value;
        return i ? [new ie(r.key, i, "constants have been deprecated as of v8")] : [];
      }
      function Ge(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        for (var p = 0, y = i; p < y.length; p += 1) {
          var v = y[p];
          for (var x in v)
            r[x] = v[x];
        }
        return r;
      }
      function Ze(r) {
        return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
      }
      function Ce(r) {
        if (Array.isArray(r))
          return r.map(Ce);
        if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
          var i = {};
          for (var l in r)
            i[l] = Ce(r[l]);
          return i;
        }
        return Ze(r);
      }
      var Ue = function(r) {
        function i(l, p) {
          r.call(this, p), this.message = p, this.key = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(Error), Et = function(r, i) {
        i === void 0 && (i = []), this.parent = r, this.bindings = {};
        for (var l = 0, p = i; l < p.length; l += 1) {
          var y = p[l];
          this.bindings[y[0]] = y[1];
        }
      };
      Et.prototype.concat = function(r) {
        return new Et(this, r);
      }, Et.prototype.get = function(r) {
        if (this.bindings[r])
          return this.bindings[r];
        if (this.parent)
          return this.parent.get(r);
        throw new Error(r + " not found in scope.");
      }, Et.prototype.has = function(r) {
        return !!this.bindings[r] || !!this.parent && this.parent.has(r);
      };
      var _t = { kind: "null" }, Le = { kind: "number" }, pt = { kind: "string" }, st = { kind: "boolean" }, De = { kind: "color" }, fe = { kind: "object" }, Ee = { kind: "value" }, He = { kind: "collator" }, jt = { kind: "formatted" }, Wt = { kind: "resolvedImage" };
      function Jt(r, i) {
        return { kind: "array", itemType: r, N: i };
      }
      function Zt(r) {
        if (r.kind === "array") {
          var i = Zt(r.itemType);
          return typeof r.N == "number" ? "array<" + i + ", " + r.N + ">" : r.itemType.kind === "value" ? "array" : "array<" + i + ">";
        }
        return r.kind;
      }
      var Yn = [_t, Le, pt, st, De, jt, fe, Jt(Ee), Wt];
      function Qt(r, i) {
        if (i.kind === "error")
          return null;
        if (r.kind === "array") {
          if (i.kind === "array" && (i.N === 0 && i.itemType.kind === "value" || !Qt(r.itemType, i.itemType)) && (typeof r.N != "number" || r.N === i.N))
            return null;
        } else {
          if (r.kind === i.kind)
            return null;
          if (r.kind === "value") {
            for (var l = 0, p = Yn; l < p.length; l += 1)
              if (!Qt(p[l], i))
                return null;
          }
        }
        return "Expected " + Zt(r) + " but found " + Zt(i) + " instead.";
      }
      function pn(r, i) {
        return i.some(function(l) {
          return l.kind === r.kind;
        });
      }
      function Ur(r, i) {
        return i.some(function(l) {
          return l === "null" ? r === null : l === "array" ? Array.isArray(r) : l === "object" ? r && !Array.isArray(r) && typeof r == "object" : l === typeof r;
        });
      }
      var gr = m(function(r, i) {
        var l = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function p(S) {
          return (S = Math.round(S)) < 0 ? 0 : S > 255 ? 255 : S;
        }
        function y(S) {
          return p(S[S.length - 1] === "%" ? parseFloat(S) / 100 * 255 : parseInt(S));
        }
        function v(S) {
          return (C = S[S.length - 1] === "%" ? parseFloat(S) / 100 : parseFloat(S)) < 0 ? 0 : C > 1 ? 1 : C;
          var C;
        }
        function x(S, C, A) {
          return A < 0 ? A += 1 : A > 1 && (A -= 1), 6 * A < 1 ? S + (C - S) * A * 6 : 2 * A < 1 ? C : 3 * A < 2 ? S + (C - S) * (2 / 3 - A) * 6 : S;
        }
        try {
          i.parseCSSColor = function(S) {
            var C, A = S.replace(/ /g, "").toLowerCase();
            if (A in l)
              return l[A].slice();
            if (A[0] === "#")
              return A.length === 4 ? (C = parseInt(A.substr(1), 16)) >= 0 && C <= 4095 ? [(3840 & C) >> 4 | (3840 & C) >> 8, 240 & C | (240 & C) >> 4, 15 & C | (15 & C) << 4, 1] : null : A.length === 7 && (C = parseInt(A.substr(1), 16)) >= 0 && C <= 16777215 ? [(16711680 & C) >> 16, (65280 & C) >> 8, 255 & C, 1] : null;
            var L = A.indexOf("("), D = A.indexOf(")");
            if (L !== -1 && D + 1 === A.length) {
              var B = A.substr(0, L), j = A.substr(L + 1, D - (L + 1)).split(","), J = 1;
              switch (B) {
                case "rgba":
                  if (j.length !== 4)
                    return null;
                  J = v(j.pop());
                case "rgb":
                  return j.length !== 3 ? null : [y(j[0]), y(j[1]), y(j[2]), J];
                case "hsla":
                  if (j.length !== 4)
                    return null;
                  J = v(j.pop());
                case "hsl":
                  if (j.length !== 3)
                    return null;
                  var ee = (parseFloat(j[0]) % 360 + 360) % 360 / 360, he = v(j[1]), oe = v(j[2]), ge = oe <= 0.5 ? oe * (he + 1) : oe + he - oe * he, we = 2 * oe - ge;
                  return [p(255 * x(we, ge, ee + 1 / 3)), p(255 * x(we, ge, ee)), p(255 * x(we, ge, ee - 1 / 3)), J];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch {
        }
      }).parseCSSColor, Fr = function(r, i, l, p) {
        p === void 0 && (p = 1), this.r = r, this.g = i, this.b = l, this.a = p;
      };
      Fr.parse = function(r) {
        if (r) {
          if (r instanceof Fr)
            return r;
          if (typeof r == "string") {
            var i = gr(r);
            if (i)
              return new Fr(i[0] / 255 * i[3], i[1] / 255 * i[3], i[2] / 255 * i[3], i[3]);
          }
        }
      }, Fr.prototype.toString = function() {
        var r = this.toArray(), i = r[1], l = r[2], p = r[3];
        return "rgba(" + Math.round(r[0]) + "," + Math.round(i) + "," + Math.round(l) + "," + p + ")";
      }, Fr.prototype.toArray = function() {
        var r = this.a;
        return r === 0 ? [0, 0, 0, 0] : [255 * this.r / r, 255 * this.g / r, 255 * this.b / r, r];
      }, Fr.black = new Fr(0, 0, 0, 1), Fr.white = new Fr(1, 1, 1, 1), Fr.transparent = new Fr(0, 0, 0, 0), Fr.red = new Fr(1, 0, 0, 1);
      var Yi = function(r, i, l) {
        this.sensitivity = r ? i ? "variant" : "case" : i ? "accent" : "base", this.locale = l, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
      };
      Yi.prototype.compare = function(r, i) {
        return this.collator.compare(r, i);
      }, Yi.prototype.resolvedLocale = function() {
        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
      };
      var Hu = function(r, i, l, p, y) {
        this.text = r, this.image = i, this.scale = l, this.fontStack = p, this.textColor = y;
      }, di = function(r) {
        this.sections = r;
      };
      di.fromString = function(r) {
        return new di([new Hu(r, null, null, null, null)]);
      }, di.prototype.isEmpty = function() {
        return this.sections.length === 0 || !this.sections.some(function(r) {
          return r.text.length !== 0 || r.image && r.image.name.length !== 0;
        });
      }, di.factory = function(r) {
        return r instanceof di ? r : di.fromString(r);
      }, di.prototype.toString = function() {
        return this.sections.length === 0 ? "" : this.sections.map(function(r) {
          return r.text;
        }).join("");
      }, di.prototype.serialize = function() {
        for (var r = ["format"], i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          if (p.image)
            r.push(["image", p.image.name]);
          else {
            r.push(p.text);
            var y = {};
            p.fontStack && (y["text-font"] = ["literal", p.fontStack.split(",")]), p.scale && (y["font-scale"] = p.scale), p.textColor && (y["text-color"] = ["rgba"].concat(p.textColor.toArray())), r.push(y);
          }
        }
        return r;
      };
      var Ji = function(r) {
        this.name = r.name, this.available = r.available;
      };
      function qf(r, i, l, p) {
        return typeof r == "number" && r >= 0 && r <= 255 && typeof i == "number" && i >= 0 && i <= 255 && typeof l == "number" && l >= 0 && l <= 255 ? p === void 0 || typeof p == "number" && p >= 0 && p <= 1 ? null : "Invalid rgba value [" + [r, i, l, p].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + (typeof p == "number" ? [r, i, l, p] : [r, i, l]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
      }
      function Zu(r) {
        if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof Fr || r instanceof Yi || r instanceof di || r instanceof Ji)
          return !0;
        if (Array.isArray(r)) {
          for (var i = 0, l = r; i < l.length; i += 1)
            if (!Zu(l[i]))
              return !1;
          return !0;
        }
        if (typeof r == "object") {
          for (var p in r)
            if (!Zu(r[p]))
              return !1;
          return !0;
        }
        return !1;
      }
      function Ln(r) {
        if (r === null)
          return _t;
        if (typeof r == "string")
          return pt;
        if (typeof r == "boolean")
          return st;
        if (typeof r == "number")
          return Le;
        if (r instanceof Fr)
          return De;
        if (r instanceof Yi)
          return He;
        if (r instanceof di)
          return jt;
        if (r instanceof Ji)
          return Wt;
        if (Array.isArray(r)) {
          for (var i, l = r.length, p = 0, y = r; p < y.length; p += 1) {
            var v = Ln(y[p]);
            if (i) {
              if (i === v)
                continue;
              i = Ee;
              break;
            }
            i = v;
          }
          return Jt(i || Ee, l);
        }
        return fe;
      }
      function Xu(r) {
        var i = typeof r;
        return r === null ? "" : i === "string" || i === "number" || i === "boolean" ? String(r) : r instanceof Fr || r instanceof di || r instanceof Ji ? r.toString() : JSON.stringify(r);
      }
      Ji.prototype.toString = function() {
        return this.name;
      }, Ji.fromString = function(r) {
        return r ? new Ji({ name: r, available: !1 }) : null;
      }, Ji.prototype.serialize = function() {
        return ["image", this.name];
      };
      var Vi = function(r, i) {
        this.type = r, this.value = i;
      };
      Vi.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("'literal' expression requires exactly one argument, but found " + (r.length - 1) + " instead.");
        if (!Zu(r[1]))
          return i.error("invalid value");
        var l = r[1], p = Ln(l), y = i.expectedType;
        return p.kind !== "array" || p.N !== 0 || !y || y.kind !== "array" || typeof y.N == "number" && y.N !== 0 || (p = y), new Vi(p, l);
      }, Vi.prototype.evaluate = function() {
        return this.value;
      }, Vi.prototype.eachChild = function() {
      }, Vi.prototype.outputDefined = function() {
        return !0;
      }, Vi.prototype.serialize = function() {
        return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof Fr ? ["rgba"].concat(this.value.toArray()) : this.value instanceof di ? this.value.serialize() : this.value;
      };
      var mi = function(r) {
        this.name = "ExpressionEvaluationError", this.message = r;
      };
      mi.prototype.toJSON = function() {
        return this.message;
      };
      var jo = { string: pt, number: Le, boolean: st, object: fe }, dn = function(r, i) {
        this.type = r, this.args = i;
      };
      dn.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l, p = 1, y = r[0];
        if (y === "array") {
          var v, x;
          if (r.length > 2) {
            var S = r[1];
            if (typeof S != "string" || !(S in jo) || S === "object")
              return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
            v = jo[S], p++;
          } else
            v = Ee;
          if (r.length > 3) {
            if (r[2] !== null && (typeof r[2] != "number" || r[2] < 0 || r[2] !== Math.floor(r[2])))
              return i.error('The length argument to "array" must be a positive integer literal', 2);
            x = r[2], p++;
          }
          l = Jt(v, x);
        } else
          l = jo[y];
        for (var C = []; p < r.length; p++) {
          var A = i.parse(r[p], p, Ee);
          if (!A)
            return null;
          C.push(A);
        }
        return new dn(l, C);
      }, dn.prototype.evaluate = function(r) {
        for (var i = 0; i < this.args.length; i++) {
          var l = this.args[i].evaluate(r);
          if (!Qt(this.type, Ln(l)))
            return l;
          if (i === this.args.length - 1)
            throw new mi("Expected value to be of type " + Zt(this.type) + ", but found " + Zt(Ln(l)) + " instead.");
        }
        return null;
      }, dn.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, dn.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, dn.prototype.serialize = function() {
        var r = this.type, i = [r.kind];
        if (r.kind === "array") {
          var l = r.itemType;
          if (l.kind === "string" || l.kind === "number" || l.kind === "boolean") {
            i.push(l.kind);
            var p = r.N;
            (typeof p == "number" || this.args.length > 1) && i.push(p);
          }
        }
        return i.concat(this.args.map(function(y) {
          return y.serialize();
        }));
      };
      var ia = function(r) {
        this.type = jt, this.sections = r;
      };
      ia.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l = r[1];
        if (!Array.isArray(l) && typeof l == "object")
          return i.error("First argument must be an image or text section.");
        for (var p = [], y = !1, v = 1; v <= r.length - 1; ++v) {
          var x = r[v];
          if (y && typeof x == "object" && !Array.isArray(x)) {
            y = !1;
            var S = null;
            if (x["font-scale"] && !(S = i.parse(x["font-scale"], 1, Le)))
              return null;
            var C = null;
            if (x["text-font"] && !(C = i.parse(x["text-font"], 1, Jt(pt))))
              return null;
            var A = null;
            if (x["text-color"] && !(A = i.parse(x["text-color"], 1, De)))
              return null;
            var L = p[p.length - 1];
            L.scale = S, L.font = C, L.textColor = A;
          } else {
            var D = i.parse(r[v], 1, Ee);
            if (!D)
              return null;
            var B = D.type.kind;
            if (B !== "string" && B !== "value" && B !== "null" && B !== "resolvedImage")
              return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
            y = !0, p.push({ content: D, scale: null, font: null, textColor: null });
          }
        }
        return new ia(p);
      }, ia.prototype.evaluate = function(r) {
        return new di(this.sections.map(function(i) {
          var l = i.content.evaluate(r);
          return Ln(l) === Wt ? new Hu("", l, null, null, null) : new Hu(Xu(l), null, i.scale ? i.scale.evaluate(r) : null, i.font ? i.font.evaluate(r).join(",") : null, i.textColor ? i.textColor.evaluate(r) : null);
        }));
      }, ia.prototype.eachChild = function(r) {
        for (var i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          r(p.content), p.scale && r(p.scale), p.font && r(p.font), p.textColor && r(p.textColor);
        }
      }, ia.prototype.outputDefined = function() {
        return !1;
      }, ia.prototype.serialize = function() {
        for (var r = ["format"], i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          r.push(p.content.serialize());
          var y = {};
          p.scale && (y["font-scale"] = p.scale.serialize()), p.font && (y["text-font"] = p.font.serialize()), p.textColor && (y["text-color"] = p.textColor.serialize()), r.push(y);
        }
        return r;
      };
      var To = function(r) {
        this.type = Wt, this.input = r;
      };
      To.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected two arguments.");
        var l = i.parse(r[1], 1, pt);
        return l ? new To(l) : i.error("No image name provided.");
      }, To.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r), l = Ji.fromString(i);
        return l && r.availableImages && (l.available = r.availableImages.indexOf(i) > -1), l;
      }, To.prototype.eachChild = function(r) {
        r(this.input);
      }, To.prototype.outputDefined = function() {
        return !1;
      }, To.prototype.serialize = function() {
        return ["image", this.input.serialize()];
      };
      var am = { "to-boolean": st, "to-color": De, "to-number": Le, "to-string": pt }, Go = function(r, i) {
        this.type = r, this.args = i;
      };
      Go.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l = r[0];
        if ((l === "to-boolean" || l === "to-string") && r.length !== 2)
          return i.error("Expected one argument.");
        for (var p = am[l], y = [], v = 1; v < r.length; v++) {
          var x = i.parse(r[v], v, Ee);
          if (!x)
            return null;
          y.push(x);
        }
        return new Go(p, y);
      }, Go.prototype.evaluate = function(r) {
        if (this.type.kind === "boolean")
          return Boolean(this.args[0].evaluate(r));
        if (this.type.kind === "color") {
          for (var i, l, p = 0, y = this.args; p < y.length; p += 1) {
            if (l = null, (i = y[p].evaluate(r)) instanceof Fr)
              return i;
            if (typeof i == "string") {
              var v = r.parseColor(i);
              if (v)
                return v;
            } else if (Array.isArray(i) && !(l = i.length < 3 || i.length > 4 ? "Invalid rbga value " + JSON.stringify(i) + ": expected an array containing either three or four numeric values." : qf(i[0], i[1], i[2], i[3])))
              return new Fr(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
          }
          throw new mi(l || "Could not parse color from value '" + (typeof i == "string" ? i : String(JSON.stringify(i))) + "'");
        }
        if (this.type.kind === "number") {
          for (var x = null, S = 0, C = this.args; S < C.length; S += 1) {
            if ((x = C[S].evaluate(r)) === null)
              return 0;
            var A = Number(x);
            if (!isNaN(A))
              return A;
          }
          throw new mi("Could not convert " + JSON.stringify(x) + " to number.");
        }
        return this.type.kind === "formatted" ? di.fromString(Xu(this.args[0].evaluate(r))) : this.type.kind === "resolvedImage" ? Ji.fromString(Xu(this.args[0].evaluate(r))) : Xu(this.args[0].evaluate(r));
      }, Go.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, Go.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, Go.prototype.serialize = function() {
        if (this.type.kind === "formatted")
          return new ia([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
        if (this.type.kind === "resolvedImage")
          return new To(this.args[0]).serialize();
        var r = ["to-" + this.type.kind];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var zv = ["Unknown", "Point", "LineString", "Polygon"], Va = function() {
        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
      };
      Va.prototype.id = function() {
        return this.feature && "id" in this.feature ? this.feature.id : null;
      }, Va.prototype.geometryType = function() {
        return this.feature ? typeof this.feature.type == "number" ? zv[this.feature.type] : this.feature.type : null;
      }, Va.prototype.geometry = function() {
        return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
      }, Va.prototype.canonicalID = function() {
        return this.canonical;
      }, Va.prototype.properties = function() {
        return this.feature && this.feature.properties || {};
      }, Va.prototype.parseColor = function(r) {
        var i = this._parseColorCache[r];
        return i || (i = this._parseColorCache[r] = Fr.parse(r)), i;
      };
      var Si = function(r, i, l, p) {
        this.name = r, this.type = i, this._evaluate = l, this.args = p;
      };
      Si.prototype.evaluate = function(r) {
        return this._evaluate(r, this.args);
      }, Si.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, Si.prototype.outputDefined = function() {
        return !1;
      }, Si.prototype.serialize = function() {
        return [this.name].concat(this.args.map(function(r) {
          return r.serialize();
        }));
      }, Si.parse = function(r, i) {
        var l, p = r[0], y = Si.definitions[p];
        if (!y)
          return i.error('Unknown expression "' + p + '". If you wanted a literal array, use ["literal", [...]].', 0);
        for (var v = Array.isArray(y) ? y[0] : y.type, x = Array.isArray(y) ? [[y[1], y[2]]] : y.overloads, S = x.filter(function(Nt) {
          var yt = Nt[0];
          return !Array.isArray(yt) || yt.length === r.length - 1;
        }), C = null, A = 0, L = S; A < L.length; A += 1) {
          var D = L[A], B = D[0], j = D[1];
          C = new gs(i.registry, i.path, null, i.scope);
          for (var J = [], ee = !1, he = 1; he < r.length; he++) {
            var oe = r[he], ge = Array.isArray(B) ? B[he - 1] : B.type, we = C.parse(oe, 1 + J.length, ge);
            if (!we) {
              ee = !0;
              break;
            }
            J.push(we);
          }
          if (!ee)
            if (Array.isArray(B) && B.length !== J.length)
              C.error("Expected " + B.length + " arguments, but found " + J.length + " instead.");
            else {
              for (var Te = 0; Te < J.length; Te++) {
                var Oe = Array.isArray(B) ? B[Te] : B.type, Be = J[Te];
                C.concat(Te + 1).checkSubtype(Oe, Be.type);
              }
              if (C.errors.length === 0)
                return new Si(p, v, j, J);
            }
        }
        if (S.length === 1)
          (l = i.errors).push.apply(l, C.errors);
        else {
          for (var Ke = (S.length ? S : x).map(function(Nt) {
            var yt;
            return yt = Nt[0], Array.isArray(yt) ? "(" + yt.map(Zt).join(", ") + ")" : "(" + Zt(yt.type) + "...)";
          }).join(" | "), ot = [], At = 1; At < r.length; At++) {
            var dt = i.parse(r[At], 1 + ot.length);
            if (!dt)
              return null;
            ot.push(Zt(dt.type));
          }
          i.error("Expected arguments of type " + Ke + ", but found (" + ot.join(", ") + ") instead.");
        }
        return null;
      }, Si.register = function(r, i) {
        for (var l in Si.definitions = i, i)
          r[l] = Si;
      };
      var xa = function(r, i, l) {
        this.type = He, this.locale = l, this.caseSensitive = r, this.diacriticSensitive = i;
      };
      function Ui(r, i) {
        r[0] = Math.min(r[0], i[0]), r[1] = Math.min(r[1], i[1]), r[2] = Math.max(r[2], i[0]), r[3] = Math.max(r[3], i[1]);
      }
      function al(r, i) {
        return !(r[0] <= i[0] || r[2] >= i[2] || r[1] <= i[1] || r[3] >= i[3]);
      }
      function Fv(r, i) {
        var l = (180 + r[0]) / 360, p = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r[1] * Math.PI / 360))) / 360, y = Math.pow(2, i.z);
        return [Math.round(l * y * 8192), Math.round(p * y * 8192)];
      }
      function Bv(r, i, l) {
        return i[1] > r[1] != l[1] > r[1] && r[0] < (l[0] - i[0]) * (r[1] - i[1]) / (l[1] - i[1]) + i[0];
      }
      function Wf(r, i) {
        for (var l, p, y, v, x, S, C, A = !1, L = 0, D = i.length; L < D; L++)
          for (var B = i[L], j = 0, J = B.length; j < J - 1; j++) {
            if ((v = (l = r)[0] - (p = B[j])[0]) * (C = l[1] - (y = B[j + 1])[1]) - (S = l[0] - y[0]) * (x = l[1] - p[1]) == 0 && v * S <= 0 && x * C <= 0)
              return !1;
            Bv(r, B[j], B[j + 1]) && (A = !A);
          }
        return A;
      }
      function Vv(r, i) {
        for (var l = 0; l < i.length; l++)
          if (Wf(r, i[l]))
            return !0;
        return !1;
      }
      function sm(r, i, l, p) {
        var y = p[0] - l[0], v = p[1] - l[1], x = (r[0] - l[0]) * v - y * (r[1] - l[1]), S = (i[0] - l[0]) * v - y * (i[1] - l[1]);
        return x > 0 && S < 0 || x < 0 && S > 0;
      }
      function Uv(r, i, l) {
        for (var p = 0, y = l; p < y.length; p += 1)
          for (var v = y[p], x = 0; x < v.length - 1; ++x)
            if ((D = [(L = v[x + 1])[0] - (A = v[x])[0], L[1] - A[1]])[0] * (B = [(C = i)[0] - (S = r)[0], C[1] - S[1]])[1] - D[1] * B[0] != 0 && sm(S, C, A, L) && sm(A, L, S, C))
              return !0;
        var S, C, A, L, D, B;
        return !1;
      }
      function lm(r, i) {
        for (var l = 0; l < r.length; ++l)
          if (!Wf(r[l], i))
            return !1;
        for (var p = 0; p < r.length - 1; ++p)
          if (Uv(r[p], r[p + 1], i))
            return !1;
        return !0;
      }
      function um(r, i) {
        for (var l = 0; l < i.length; l++)
          if (lm(r, i[l]))
            return !0;
        return !1;
      }
      function Kl(r, i, l) {
        for (var p = [], y = 0; y < r.length; y++) {
          for (var v = [], x = 0; x < r[y].length; x++) {
            var S = Fv(r[y][x], l);
            Ui(i, S), v.push(S);
          }
          p.push(v);
        }
        return p;
      }
      function Hf(r, i, l) {
        for (var p = [], y = 0; y < r.length; y++) {
          var v = Kl(r[y], i, l);
          p.push(v);
        }
        return p;
      }
      function Ku(r, i, l, p) {
        if (r[0] < l[0] || r[0] > l[2]) {
          var y = 0.5 * p, v = r[0] - l[0] > y ? -p : l[0] - r[0] > y ? p : 0;
          v === 0 && (v = r[0] - l[2] > y ? -p : l[2] - r[0] > y ? p : 0), r[0] += v;
        }
        Ui(i, r);
      }
      function cm(r, i, l, p) {
        for (var y = 8192 * Math.pow(2, p.z), v = [8192 * p.x, 8192 * p.y], x = [], S = 0, C = r; S < C.length; S += 1)
          for (var A = 0, L = C[S]; A < L.length; A += 1) {
            var D = L[A], B = [D.x + v[0], D.y + v[1]];
            Ku(B, i, l, y), x.push(B);
          }
        return x;
      }
      function lh(r, i, l, p) {
        for (var y, v = 8192 * Math.pow(2, p.z), x = [8192 * p.x, 8192 * p.y], S = [], C = 0, A = r; C < A.length; C += 1) {
          for (var L = [], D = 0, B = A[C]; D < B.length; D += 1) {
            var j = B[D], J = [j.x + x[0], j.y + x[1]];
            Ui(i, J), L.push(J);
          }
          S.push(L);
        }
        if (i[2] - i[0] <= v / 2) {
          (y = i)[0] = y[1] = 1 / 0, y[2] = y[3] = -1 / 0;
          for (var ee = 0, he = S; ee < he.length; ee += 1)
            for (var oe = 0, ge = he[ee]; oe < ge.length; oe += 1)
              Ku(ge[oe], i, l, v);
        }
        return S;
      }
      xa.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected one argument.");
        var l = r[1];
        if (typeof l != "object" || Array.isArray(l))
          return i.error("Collator options argument must be an object.");
        var p = i.parse(l["case-sensitive"] !== void 0 && l["case-sensitive"], 1, st);
        if (!p)
          return null;
        var y = i.parse(l["diacritic-sensitive"] !== void 0 && l["diacritic-sensitive"], 1, st);
        if (!y)
          return null;
        var v = null;
        return l.locale && !(v = i.parse(l.locale, 1, pt)) ? null : new xa(p, y, v);
      }, xa.prototype.evaluate = function(r) {
        return new Yi(this.caseSensitive.evaluate(r), this.diacriticSensitive.evaluate(r), this.locale ? this.locale.evaluate(r) : null);
      }, xa.prototype.eachChild = function(r) {
        r(this.caseSensitive), r(this.diacriticSensitive), this.locale && r(this.locale);
      }, xa.prototype.outputDefined = function() {
        return !1;
      }, xa.prototype.serialize = function() {
        var r = {};
        return r["case-sensitive"] = this.caseSensitive.serialize(), r["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (r.locale = this.locale.serialize()), ["collator", r];
      };
      var $o = function(r, i) {
        this.type = st, this.geojson = r, this.geometries = i;
      };
      function ds(r) {
        if (r instanceof Si && (r.name === "get" && r.args.length === 1 || r.name === "feature-state" || r.name === "has" && r.args.length === 1 || r.name === "properties" || r.name === "geometry-type" || r.name === "id" || /^filter-/.test(r.name)) || r instanceof $o)
          return !1;
        var i = !0;
        return r.eachChild(function(l) {
          i && !ds(l) && (i = !1);
        }), i;
      }
      function ms(r) {
        if (r instanceof Si && r.name === "feature-state")
          return !1;
        var i = !0;
        return r.eachChild(function(l) {
          i && !ms(l) && (i = !1);
        }), i;
      }
      function sl(r, i) {
        if (r instanceof Si && i.indexOf(r.name) >= 0)
          return !1;
        var l = !0;
        return r.eachChild(function(p) {
          l && !sl(p, i) && (l = !1);
        }), l;
      }
      $o.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("'within' expression requires exactly one argument, but found " + (r.length - 1) + " instead.");
        if (Zu(r[1])) {
          var l = r[1];
          if (l.type === "FeatureCollection")
            for (var p = 0; p < l.features.length; ++p) {
              var y = l.features[p].geometry.type;
              if (y === "Polygon" || y === "MultiPolygon")
                return new $o(l, l.features[p].geometry);
            }
          else if (l.type === "Feature") {
            var v = l.geometry.type;
            if (v === "Polygon" || v === "MultiPolygon")
              return new $o(l, l.geometry);
          } else if (l.type === "Polygon" || l.type === "MultiPolygon")
            return new $o(l, l);
        }
        return i.error("'within' expression requires valid geojson object that contains polygon geometry type.");
      }, $o.prototype.evaluate = function(r) {
        if (r.geometry() != null && r.canonicalID() != null) {
          if (r.geometryType() === "Point")
            return function(i, l) {
              var p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = i.canonicalID();
              if (l.type === "Polygon") {
                var x = Kl(l.coordinates, y, v), S = cm(i.geometry(), p, y, v);
                if (!al(p, y))
                  return !1;
                for (var C = 0, A = S; C < A.length; C += 1)
                  if (!Wf(A[C], x))
                    return !1;
              }
              if (l.type === "MultiPolygon") {
                var L = Hf(l.coordinates, y, v), D = cm(i.geometry(), p, y, v);
                if (!al(p, y))
                  return !1;
                for (var B = 0, j = D; B < j.length; B += 1)
                  if (!Vv(j[B], L))
                    return !1;
              }
              return !0;
            }(r, this.geometries);
          if (r.geometryType() === "LineString")
            return function(i, l) {
              var p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = i.canonicalID();
              if (l.type === "Polygon") {
                var x = Kl(l.coordinates, y, v), S = lh(i.geometry(), p, y, v);
                if (!al(p, y))
                  return !1;
                for (var C = 0, A = S; C < A.length; C += 1)
                  if (!lm(A[C], x))
                    return !1;
              }
              if (l.type === "MultiPolygon") {
                var L = Hf(l.coordinates, y, v), D = lh(i.geometry(), p, y, v);
                if (!al(p, y))
                  return !1;
                for (var B = 0, j = D; B < j.length; B += 1)
                  if (!um(j[B], L))
                    return !1;
              }
              return !0;
            }(r, this.geometries);
        }
        return !1;
      }, $o.prototype.eachChild = function() {
      }, $o.prototype.outputDefined = function() {
        return !0;
      }, $o.prototype.serialize = function() {
        return ["within", this.geojson];
      };
      var ys = function(r, i) {
        this.type = i.type, this.name = r, this.boundExpression = i;
      };
      ys.parse = function(r, i) {
        if (r.length !== 2 || typeof r[1] != "string")
          return i.error("'var' expression requires exactly one string literal argument.");
        var l = r[1];
        return i.scope.has(l) ? new ys(l, i.scope.get(l)) : i.error('Unknown variable "' + l + '". Make sure "' + l + '" has been bound in an enclosing "let" expression before using it.', 1);
      }, ys.prototype.evaluate = function(r) {
        return this.boundExpression.evaluate(r);
      }, ys.prototype.eachChild = function() {
      }, ys.prototype.outputDefined = function() {
        return !1;
      }, ys.prototype.serialize = function() {
        return ["var", this.name];
      };
      var gs = function(r, i, l, p, y) {
        i === void 0 && (i = []), p === void 0 && (p = new Et()), y === void 0 && (y = []), this.registry = r, this.path = i, this.key = i.map(function(v) {
          return "[" + v + "]";
        }).join(""), this.scope = p, this.errors = y, this.expectedType = l;
      };
      function uh(r, i) {
        for (var l, p = r.length - 1, y = 0, v = p, x = 0; y <= v; )
          if ((l = r[x = Math.floor((y + v) / 2)]) <= i) {
            if (x === p || i < r[x + 1])
              return x;
            y = x + 1;
          } else {
            if (!(l > i))
              throw new mi("Input is not a number.");
            v = x - 1;
          }
        return 0;
      }
      gs.prototype.parse = function(r, i, l, p, y) {
        return y === void 0 && (y = {}), i ? this.concat(i, l, p)._parse(r, y) : this._parse(r, y);
      }, gs.prototype._parse = function(r, i) {
        function l(A, L, D) {
          return D === "assert" ? new dn(L, [A]) : D === "coerce" ? new Go(L, [A]) : A;
        }
        if (r !== null && typeof r != "string" && typeof r != "boolean" && typeof r != "number" || (r = ["literal", r]), Array.isArray(r)) {
          if (r.length === 0)
            return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
          var p = r[0];
          if (typeof p != "string")
            return this.error("Expression name must be a string, but found " + typeof p + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null;
          var y = this.registry[p];
          if (y) {
            var v = y.parse(r, this);
            if (!v)
              return null;
            if (this.expectedType) {
              var x = this.expectedType, S = v.type;
              if (x.kind !== "string" && x.kind !== "number" && x.kind !== "boolean" && x.kind !== "object" && x.kind !== "array" || S.kind !== "value")
                if (x.kind !== "color" && x.kind !== "formatted" && x.kind !== "resolvedImage" || S.kind !== "value" && S.kind !== "string") {
                  if (this.checkSubtype(x, S))
                    return null;
                } else
                  v = l(v, x, i.typeAnnotation || "coerce");
              else
                v = l(v, x, i.typeAnnotation || "assert");
            }
            if (!(v instanceof Vi) && v.type.kind !== "resolvedImage" && function A(L) {
              if (L instanceof ys)
                return A(L.boundExpression);
              if (L instanceof Si && L.name === "error" || L instanceof xa || L instanceof $o)
                return !1;
              var D = L instanceof Go || L instanceof dn, B = !0;
              return L.eachChild(function(j) {
                B = D ? B && A(j) : B && j instanceof Vi;
              }), !!B && ds(L) && sl(L, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
            }(v)) {
              var C = new Va();
              try {
                v = new Vi(v.type, v.evaluate(C));
              } catch (A) {
                return this.error(A.message), null;
              }
            }
            return v;
          }
          return this.error('Unknown expression "' + p + '". If you wanted a literal array, use ["literal", [...]].', 0);
        }
        return this.error(r === void 0 ? "'undefined' value invalid. Use null instead." : typeof r == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found " + typeof r + " instead.");
      }, gs.prototype.concat = function(r, i, l) {
        var p = typeof r == "number" ? this.path.concat(r) : this.path, y = l ? this.scope.concat(l) : this.scope;
        return new gs(this.registry, p, i || null, y, this.errors);
      }, gs.prototype.error = function(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        var p = "" + this.key + i.map(function(y) {
          return "[" + y + "]";
        }).join("");
        this.errors.push(new Ue(p, r));
      }, gs.prototype.checkSubtype = function(r, i) {
        var l = Qt(r, i);
        return l && this.error(l), l;
      };
      var lo = function(r, i, l) {
        this.type = r, this.input = i, this.labels = [], this.outputs = [];
        for (var p = 0, y = l; p < y.length; p += 1) {
          var v = y[p], x = v[1];
          this.labels.push(v[0]), this.outputs.push(x);
        }
      };
      function jn(r, i, l) {
        return r * (1 - l) + i * l;
      }
      lo.parse = function(r, i) {
        if (r.length - 1 < 4)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if ((r.length - 1) % 2 != 0)
          return i.error("Expected an even number of arguments.");
        var l = i.parse(r[1], 1, Le);
        if (!l)
          return null;
        var p = [], y = null;
        i.expectedType && i.expectedType.kind !== "value" && (y = i.expectedType);
        for (var v = 1; v < r.length; v += 2) {
          var x = v === 1 ? -1 / 0 : r[v], S = r[v + 1], C = v, A = v + 1;
          if (typeof x != "number")
            return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', C);
          if (p.length && p[p.length - 1][0] >= x)
            return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', C);
          var L = i.parse(S, A, y);
          if (!L)
            return null;
          y = y || L.type, p.push([x, L]);
        }
        return new lo(y, l, p);
      }, lo.prototype.evaluate = function(r) {
        var i = this.labels, l = this.outputs;
        if (i.length === 1)
          return l[0].evaluate(r);
        var p = this.input.evaluate(r);
        if (p <= i[0])
          return l[0].evaluate(r);
        var y = i.length;
        return p >= i[y - 1] ? l[y - 1].evaluate(r) : l[uh(i, p)].evaluate(r);
      }, lo.prototype.eachChild = function(r) {
        r(this.input);
        for (var i = 0, l = this.outputs; i < l.length; i += 1)
          r(l[i]);
      }, lo.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        });
      }, lo.prototype.serialize = function() {
        for (var r = ["step", this.input.serialize()], i = 0; i < this.labels.length; i++)
          i > 0 && r.push(this.labels[i]), r.push(this.outputs[i].serialize());
        return r;
      };
      var Yl = Object.freeze({ __proto__: null, number: jn, color: function(r, i, l) {
        return new Fr(jn(r.r, i.r, l), jn(r.g, i.g, l), jn(r.b, i.b, l), jn(r.a, i.a, l));
      }, array: function(r, i, l) {
        return r.map(function(p, y) {
          return jn(p, i[y], l);
        });
      } }), hm = 6 / 29 * 3 * (6 / 29), jv = Math.PI / 180, Gv = 180 / Math.PI;
      function Zf(r) {
        return r > 0.008856451679035631 ? Math.pow(r, 1 / 3) : r / hm + 4 / 29;
      }
      function Xf(r) {
        return r > 6 / 29 ? r * r * r : hm * (r - 4 / 29);
      }
      function Kf(r) {
        return 255 * (r <= 31308e-7 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055);
      }
      function Yf(r) {
        return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      }
      function fm(r) {
        var i = Yf(r.r), l = Yf(r.g), p = Yf(r.b), y = Zf((0.4124564 * i + 0.3575761 * l + 0.1804375 * p) / 0.95047), v = Zf((0.2126729 * i + 0.7151522 * l + 0.072175 * p) / 1);
        return { l: 116 * v - 16, a: 500 * (y - v), b: 200 * (v - Zf((0.0193339 * i + 0.119192 * l + 0.9503041 * p) / 1.08883)), alpha: r.a };
      }
      function pm(r) {
        var i = (r.l + 16) / 116, l = isNaN(r.a) ? i : i + r.a / 500, p = isNaN(r.b) ? i : i - r.b / 200;
        return i = 1 * Xf(i), l = 0.95047 * Xf(l), p = 1.08883 * Xf(p), new Fr(Kf(3.2404542 * l - 1.5371385 * i - 0.4985314 * p), Kf(-0.969266 * l + 1.8760108 * i + 0.041556 * p), Kf(0.0556434 * l - 0.2040259 * i + 1.0572252 * p), r.alpha);
      }
      function $v(r, i, l) {
        var p = i - r;
        return r + l * (p > 180 || p < -180 ? p - 360 * Math.round(p / 360) : p);
      }
      var Yu = { forward: fm, reverse: pm, interpolate: function(r, i, l) {
        return { l: jn(r.l, i.l, l), a: jn(r.a, i.a, l), b: jn(r.b, i.b, l), alpha: jn(r.alpha, i.alpha, l) };
      } }, Ju = { forward: function(r) {
        var i = fm(r), l = i.l, p = i.a, y = i.b, v = Math.atan2(y, p) * Gv;
        return { h: v < 0 ? v + 360 : v, c: Math.sqrt(p * p + y * y), l, alpha: r.a };
      }, reverse: function(r) {
        var i = r.h * jv, l = r.c;
        return pm({ l: r.l, a: Math.cos(i) * l, b: Math.sin(i) * l, alpha: r.alpha });
      }, interpolate: function(r, i, l) {
        return { h: $v(r.h, i.h, l), c: jn(r.c, i.c, l), l: jn(r.l, i.l, l), alpha: jn(r.alpha, i.alpha, l) };
      } }, dm = Object.freeze({ __proto__: null, lab: Yu, hcl: Ju }), Ti = function(r, i, l, p, y) {
        this.type = r, this.operator = i, this.interpolation = l, this.input = p, this.labels = [], this.outputs = [];
        for (var v = 0, x = y; v < x.length; v += 1) {
          var S = x[v], C = S[1];
          this.labels.push(S[0]), this.outputs.push(C);
        }
      };
      function Jf(r, i, l, p) {
        var y = p - l, v = r - l;
        return y === 0 ? 0 : i === 1 ? v / y : (Math.pow(i, v) - 1) / (Math.pow(i, y) - 1);
      }
      Ti.interpolationFactor = function(r, i, l, p) {
        var y = 0;
        if (r.name === "exponential")
          y = Jf(i, r.base, l, p);
        else if (r.name === "linear")
          y = Jf(i, 1, l, p);
        else if (r.name === "cubic-bezier") {
          var v = r.controlPoints;
          y = new g(v[0], v[1], v[2], v[3]).solve(Jf(i, 1, l, p));
        }
        return y;
      }, Ti.parse = function(r, i) {
        var l = r[0], p = r[1], y = r[2], v = r.slice(3);
        if (!Array.isArray(p) || p.length === 0)
          return i.error("Expected an interpolation type expression.", 1);
        if (p[0] === "linear")
          p = { name: "linear" };
        else if (p[0] === "exponential") {
          var x = p[1];
          if (typeof x != "number")
            return i.error("Exponential interpolation requires a numeric base.", 1, 1);
          p = { name: "exponential", base: x };
        } else {
          if (p[0] !== "cubic-bezier")
            return i.error("Unknown interpolation type " + String(p[0]), 1, 0);
          var S = p.slice(1);
          if (S.length !== 4 || S.some(function(he) {
            return typeof he != "number" || he < 0 || he > 1;
          }))
            return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
          p = { name: "cubic-bezier", controlPoints: S };
        }
        if (r.length - 1 < 4)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if ((r.length - 1) % 2 != 0)
          return i.error("Expected an even number of arguments.");
        if (!(y = i.parse(y, 2, Le)))
          return null;
        var C = [], A = null;
        l === "interpolate-hcl" || l === "interpolate-lab" ? A = De : i.expectedType && i.expectedType.kind !== "value" && (A = i.expectedType);
        for (var L = 0; L < v.length; L += 2) {
          var D = v[L], B = v[L + 1], j = L + 3, J = L + 4;
          if (typeof D != "number")
            return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', j);
          if (C.length && C[C.length - 1][0] >= D)
            return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', j);
          var ee = i.parse(B, J, A);
          if (!ee)
            return null;
          A = A || ee.type, C.push([D, ee]);
        }
        return A.kind === "number" || A.kind === "color" || A.kind === "array" && A.itemType.kind === "number" && typeof A.N == "number" ? new Ti(A, l, p, y, C) : i.error("Type " + Zt(A) + " is not interpolatable.");
      }, Ti.prototype.evaluate = function(r) {
        var i = this.labels, l = this.outputs;
        if (i.length === 1)
          return l[0].evaluate(r);
        var p = this.input.evaluate(r);
        if (p <= i[0])
          return l[0].evaluate(r);
        var y = i.length;
        if (p >= i[y - 1])
          return l[y - 1].evaluate(r);
        var v = uh(i, p), x = Ti.interpolationFactor(this.interpolation, p, i[v], i[v + 1]), S = l[v].evaluate(r), C = l[v + 1].evaluate(r);
        return this.operator === "interpolate" ? Yl[this.type.kind.toLowerCase()](S, C, x) : this.operator === "interpolate-hcl" ? Ju.reverse(Ju.interpolate(Ju.forward(S), Ju.forward(C), x)) : Yu.reverse(Yu.interpolate(Yu.forward(S), Yu.forward(C), x));
      }, Ti.prototype.eachChild = function(r) {
        r(this.input);
        for (var i = 0, l = this.outputs; i < l.length; i += 1)
          r(l[i]);
      }, Ti.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        });
      }, Ti.prototype.serialize = function() {
        var r;
        r = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
        for (var i = [this.operator, r, this.input.serialize()], l = 0; l < this.labels.length; l++)
          i.push(this.labels[l], this.outputs[l].serialize());
        return i;
      };
      var vs = function(r, i) {
        this.type = r, this.args = i;
      };
      vs.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expectected at least one argument.");
        var l = null, p = i.expectedType;
        p && p.kind !== "value" && (l = p);
        for (var y = [], v = 0, x = r.slice(1); v < x.length; v += 1) {
          var S = i.parse(x[v], 1 + y.length, l, void 0, { typeAnnotation: "omit" });
          if (!S)
            return null;
          l = l || S.type, y.push(S);
        }
        var C = p && y.some(function(A) {
          return Qt(p, A.type);
        });
        return new vs(C ? Ee : l, y);
      }, vs.prototype.evaluate = function(r) {
        for (var i, l = null, p = 0, y = 0, v = this.args; y < v.length && (p++, (l = v[y].evaluate(r)) && l instanceof Ji && !l.available && (i || (i = l.name), l = null, p === this.args.length && (l = i)), l === null); y += 1)
          ;
        return l;
      }, vs.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, vs.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, vs.prototype.serialize = function() {
        var r = ["coalesce"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var _s = function(r, i) {
        this.type = i.type, this.bindings = [].concat(r), this.result = i;
      };
      _s.prototype.evaluate = function(r) {
        return this.result.evaluate(r);
      }, _s.prototype.eachChild = function(r) {
        for (var i = 0, l = this.bindings; i < l.length; i += 1)
          r(l[i][1]);
        r(this.result);
      }, _s.parse = function(r, i) {
        if (r.length < 4)
          return i.error("Expected at least 3 arguments, but found " + (r.length - 1) + " instead.");
        for (var l = [], p = 1; p < r.length - 1; p += 2) {
          var y = r[p];
          if (typeof y != "string")
            return i.error("Expected string, but found " + typeof y + " instead.", p);
          if (/[^a-zA-Z0-9_]/.test(y))
            return i.error("Variable names must contain only alphanumeric characters or '_'.", p);
          var v = i.parse(r[p + 1], p + 1);
          if (!v)
            return null;
          l.push([y, v]);
        }
        var x = i.parse(r[r.length - 1], r.length - 1, i.expectedType, l);
        return x ? new _s(l, x) : null;
      }, _s.prototype.outputDefined = function() {
        return this.result.outputDefined();
      }, _s.prototype.serialize = function() {
        for (var r = ["let"], i = 0, l = this.bindings; i < l.length; i += 1) {
          var p = l[i];
          r.push(p[0], p[1].serialize());
        }
        return r.push(this.result.serialize()), r;
      };
      var ll = function(r, i, l) {
        this.type = r, this.index = i, this.input = l;
      };
      ll.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected 2 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Le), p = i.parse(r[2], 2, Jt(i.expectedType || Ee));
        return l && p ? new ll(p.type.itemType, l, p) : null;
      }, ll.prototype.evaluate = function(r) {
        var i = this.index.evaluate(r), l = this.input.evaluate(r);
        if (i < 0)
          throw new mi("Array index out of bounds: " + i + " < 0.");
        if (i >= l.length)
          throw new mi("Array index out of bounds: " + i + " > " + (l.length - 1) + ".");
        if (i !== Math.floor(i))
          throw new mi("Array index must be an integer, but found " + i + " instead.");
        return l[i];
      }, ll.prototype.eachChild = function(r) {
        r(this.index), r(this.input);
      }, ll.prototype.outputDefined = function() {
        return !1;
      }, ll.prototype.serialize = function() {
        return ["at", this.index.serialize(), this.input.serialize()];
      };
      var ul = function(r, i) {
        this.type = st, this.needle = r, this.haystack = i;
      };
      ul.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected 2 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Ee), p = i.parse(r[2], 2, Ee);
        return l && p ? pn(l.type, [st, pt, Le, _t, Ee]) ? new ul(l, p) : i.error("Expected first argument to be of type boolean, string, number or null, but found " + Zt(l.type) + " instead") : null;
      }, ul.prototype.evaluate = function(r) {
        var i = this.needle.evaluate(r), l = this.haystack.evaluate(r);
        if (!l)
          return !1;
        if (!Ur(i, ["boolean", "string", "number", "null"]))
          throw new mi("Expected first argument to be of type boolean, string, number or null, but found " + Zt(Ln(i)) + " instead.");
        if (!Ur(l, ["string", "array"]))
          throw new mi("Expected second argument to be of type array or string, but found " + Zt(Ln(l)) + " instead.");
        return l.indexOf(i) >= 0;
      }, ul.prototype.eachChild = function(r) {
        r(this.needle), r(this.haystack);
      }, ul.prototype.outputDefined = function() {
        return !0;
      }, ul.prototype.serialize = function() {
        return ["in", this.needle.serialize(), this.haystack.serialize()];
      };
      var xs = function(r, i, l) {
        this.type = Le, this.needle = r, this.haystack = i, this.fromIndex = l;
      };
      xs.parse = function(r, i) {
        if (r.length <= 2 || r.length >= 5)
          return i.error("Expected 3 or 4 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Ee), p = i.parse(r[2], 2, Ee);
        if (!l || !p)
          return null;
        if (!pn(l.type, [st, pt, Le, _t, Ee]))
          return i.error("Expected first argument to be of type boolean, string, number or null, but found " + Zt(l.type) + " instead");
        if (r.length === 4) {
          var y = i.parse(r[3], 3, Le);
          return y ? new xs(l, p, y) : null;
        }
        return new xs(l, p);
      }, xs.prototype.evaluate = function(r) {
        var i = this.needle.evaluate(r), l = this.haystack.evaluate(r);
        if (!Ur(i, ["boolean", "string", "number", "null"]))
          throw new mi("Expected first argument to be of type boolean, string, number or null, but found " + Zt(Ln(i)) + " instead.");
        if (!Ur(l, ["string", "array"]))
          throw new mi("Expected second argument to be of type array or string, but found " + Zt(Ln(l)) + " instead.");
        if (this.fromIndex) {
          var p = this.fromIndex.evaluate(r);
          return l.indexOf(i, p);
        }
        return l.indexOf(i);
      }, xs.prototype.eachChild = function(r) {
        r(this.needle), r(this.haystack), this.fromIndex && r(this.fromIndex);
      }, xs.prototype.outputDefined = function() {
        return !1;
      }, xs.prototype.serialize = function() {
        if (this.fromIndex != null && this.fromIndex !== void 0) {
          var r = this.fromIndex.serialize();
          return ["index-of", this.needle.serialize(), this.haystack.serialize(), r];
        }
        return ["index-of", this.needle.serialize(), this.haystack.serialize()];
      };
      var cl = function(r, i, l, p, y, v) {
        this.inputType = r, this.type = i, this.input = l, this.cases = p, this.outputs = y, this.otherwise = v;
      };
      cl.parse = function(r, i) {
        if (r.length < 5)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if (r.length % 2 != 1)
          return i.error("Expected an even number of arguments.");
        var l, p;
        i.expectedType && i.expectedType.kind !== "value" && (p = i.expectedType);
        for (var y = {}, v = [], x = 2; x < r.length - 1; x += 2) {
          var S = r[x], C = r[x + 1];
          Array.isArray(S) || (S = [S]);
          var A = i.concat(x);
          if (S.length === 0)
            return A.error("Expected at least one branch label.");
          for (var L = 0, D = S; L < D.length; L += 1) {
            var B = D[L];
            if (typeof B != "number" && typeof B != "string")
              return A.error("Branch labels must be numbers or strings.");
            if (typeof B == "number" && Math.abs(B) > Number.MAX_SAFE_INTEGER)
              return A.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
            if (typeof B == "number" && Math.floor(B) !== B)
              return A.error("Numeric branch labels must be integer values.");
            if (l) {
              if (A.checkSubtype(l, Ln(B)))
                return null;
            } else
              l = Ln(B);
            if (y[String(B)] !== void 0)
              return A.error("Branch labels must be unique.");
            y[String(B)] = v.length;
          }
          var j = i.parse(C, x, p);
          if (!j)
            return null;
          p = p || j.type, v.push(j);
        }
        var J = i.parse(r[1], 1, Ee);
        if (!J)
          return null;
        var ee = i.parse(r[r.length - 1], r.length - 1, p);
        return ee ? J.type.kind !== "value" && i.concat(1).checkSubtype(l, J.type) ? null : new cl(l, p, J, y, v, ee) : null;
      }, cl.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r);
        return (Ln(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(r);
      }, cl.prototype.eachChild = function(r) {
        r(this.input), this.outputs.forEach(r), r(this.otherwise);
      }, cl.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        }) && this.otherwise.outputDefined();
      }, cl.prototype.serialize = function() {
        for (var r = this, i = ["match", this.input.serialize()], l = [], p = {}, y = 0, v = Object.keys(this.cases).sort(); y < v.length; y += 1) {
          var x = v[y];
          (D = p[this.cases[x]]) === void 0 ? (p[this.cases[x]] = l.length, l.push([this.cases[x], [x]])) : l[D][1].push(x);
        }
        for (var S = function(j) {
          return r.inputType.kind === "number" ? Number(j) : j;
        }, C = 0, A = l; C < A.length; C += 1) {
          var L = A[C], D = L[0], B = L[1];
          i.push(B.length === 1 ? S(B[0]) : B.map(S)), i.push(this.outputs[outputIndex$1].serialize());
        }
        return i.push(this.otherwise.serialize()), i;
      };
      var hl = function(r, i, l) {
        this.type = r, this.branches = i, this.otherwise = l;
      };
      hl.parse = function(r, i) {
        if (r.length < 4)
          return i.error("Expected at least 3 arguments, but found only " + (r.length - 1) + ".");
        if (r.length % 2 != 0)
          return i.error("Expected an odd number of arguments.");
        var l;
        i.expectedType && i.expectedType.kind !== "value" && (l = i.expectedType);
        for (var p = [], y = 1; y < r.length - 1; y += 2) {
          var v = i.parse(r[y], y, st);
          if (!v)
            return null;
          var x = i.parse(r[y + 1], y + 1, l);
          if (!x)
            return null;
          p.push([v, x]), l = l || x.type;
        }
        var S = i.parse(r[r.length - 1], r.length - 1, l);
        return S ? new hl(l, p, S) : null;
      }, hl.prototype.evaluate = function(r) {
        for (var i = 0, l = this.branches; i < l.length; i += 1) {
          var p = l[i], y = p[1];
          if (p[0].evaluate(r))
            return y.evaluate(r);
        }
        return this.otherwise.evaluate(r);
      }, hl.prototype.eachChild = function(r) {
        for (var i = 0, l = this.branches; i < l.length; i += 1) {
          var p = l[i], y = p[1];
          r(p[0]), r(y);
        }
        r(this.otherwise);
      }, hl.prototype.outputDefined = function() {
        return this.branches.every(function(r) {
          return r[1].outputDefined();
        }) && this.otherwise.outputDefined();
      }, hl.prototype.serialize = function() {
        var r = ["case"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var bs = function(r, i, l, p) {
        this.type = r, this.input = i, this.beginIndex = l, this.endIndex = p;
      };
      function mm(r, i) {
        return r === "==" || r === "!=" ? i.kind === "boolean" || i.kind === "string" || i.kind === "number" || i.kind === "null" || i.kind === "value" : i.kind === "string" || i.kind === "number" || i.kind === "value";
      }
      function ym(r, i, l, p) {
        return p.compare(i, l) === 0;
      }
      function Zr(r, i, l) {
        var p = r !== "==" && r !== "!=";
        return function() {
          function y(v, x, S) {
            this.type = st, this.lhs = v, this.rhs = x, this.collator = S, this.hasUntypedArgument = v.type.kind === "value" || x.type.kind === "value";
          }
          return y.parse = function(v, x) {
            if (v.length !== 3 && v.length !== 4)
              return x.error("Expected two or three arguments.");
            var S = v[0], C = x.parse(v[1], 1, Ee);
            if (!C)
              return null;
            if (!mm(S, C.type))
              return x.concat(1).error('"' + S + `" comparisons are not supported for type '` + Zt(C.type) + "'.");
            var A = x.parse(v[2], 2, Ee);
            if (!A)
              return null;
            if (!mm(S, A.type))
              return x.concat(2).error('"' + S + `" comparisons are not supported for type '` + Zt(A.type) + "'.");
            if (C.type.kind !== A.type.kind && C.type.kind !== "value" && A.type.kind !== "value")
              return x.error("Cannot compare types '" + Zt(C.type) + "' and '" + Zt(A.type) + "'.");
            p && (C.type.kind === "value" && A.type.kind !== "value" ? C = new dn(A.type, [C]) : C.type.kind !== "value" && A.type.kind === "value" && (A = new dn(C.type, [A])));
            var L = null;
            if (v.length === 4) {
              if (C.type.kind !== "string" && A.type.kind !== "string" && C.type.kind !== "value" && A.type.kind !== "value")
                return x.error("Cannot use collator to compare non-string types.");
              if (!(L = x.parse(v[3], 3, He)))
                return null;
            }
            return new y(C, A, L);
          }, y.prototype.evaluate = function(v) {
            var x = this.lhs.evaluate(v), S = this.rhs.evaluate(v);
            if (p && this.hasUntypedArgument) {
              var C = Ln(x), A = Ln(S);
              if (C.kind !== A.kind || C.kind !== "string" && C.kind !== "number")
                throw new mi('Expected arguments for "' + r + '" to be (string, string) or (number, number), but found (' + C.kind + ", " + A.kind + ") instead.");
            }
            if (this.collator && !p && this.hasUntypedArgument) {
              var L = Ln(x), D = Ln(S);
              if (L.kind !== "string" || D.kind !== "string")
                return i(v, x, S);
            }
            return this.collator ? l(v, x, S, this.collator.evaluate(v)) : i(v, x, S);
          }, y.prototype.eachChild = function(v) {
            v(this.lhs), v(this.rhs), this.collator && v(this.collator);
          }, y.prototype.outputDefined = function() {
            return !0;
          }, y.prototype.serialize = function() {
            var v = [r];
            return this.eachChild(function(x) {
              v.push(x.serialize());
            }), v;
          }, y;
        }();
      }
      bs.parse = function(r, i) {
        if (r.length <= 2 || r.length >= 5)
          return i.error("Expected 3 or 4 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Ee), p = i.parse(r[2], 2, Le);
        if (!l || !p)
          return null;
        if (!pn(l.type, [Jt(Ee), pt, Ee]))
          return i.error("Expected first argument to be of type array or string, but found " + Zt(l.type) + " instead");
        if (r.length === 4) {
          var y = i.parse(r[3], 3, Le);
          return y ? new bs(l.type, l, p, y) : null;
        }
        return new bs(l.type, l, p);
      }, bs.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r), l = this.beginIndex.evaluate(r);
        if (!Ur(i, ["string", "array"]))
          throw new mi("Expected first argument to be of type array or string, but found " + Zt(Ln(i)) + " instead.");
        if (this.endIndex) {
          var p = this.endIndex.evaluate(r);
          return i.slice(l, p);
        }
        return i.slice(l);
      }, bs.prototype.eachChild = function(r) {
        r(this.input), r(this.beginIndex), this.endIndex && r(this.endIndex);
      }, bs.prototype.outputDefined = function() {
        return !1;
      }, bs.prototype.serialize = function() {
        if (this.endIndex != null && this.endIndex !== void 0) {
          var r = this.endIndex.serialize();
          return ["slice", this.input.serialize(), this.beginIndex.serialize(), r];
        }
        return ["slice", this.input.serialize(), this.beginIndex.serialize()];
      };
      var qv = Zr("==", function(r, i, l) {
        return i === l;
      }, ym), ch = Zr("!=", function(r, i, l) {
        return i !== l;
      }, function(r, i, l, p) {
        return !ym(0, i, l, p);
      }), gm = Zr("<", function(r, i, l) {
        return i < l;
      }, function(r, i, l, p) {
        return p.compare(i, l) < 0;
      }), vm = Zr(">", function(r, i, l) {
        return i > l;
      }, function(r, i, l, p) {
        return p.compare(i, l) > 0;
      }), _m = Zr("<=", function(r, i, l) {
        return i <= l;
      }, function(r, i, l, p) {
        return p.compare(i, l) <= 0;
      }), xm = Zr(">=", function(r, i, l) {
        return i >= l;
      }, function(r, i, l, p) {
        return p.compare(i, l) >= 0;
      }), fl = function(r, i, l, p, y) {
        this.type = pt, this.number = r, this.locale = i, this.currency = l, this.minFractionDigits = p, this.maxFractionDigits = y;
      };
      fl.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected two arguments.");
        var l = i.parse(r[1], 1, Le);
        if (!l)
          return null;
        var p = r[2];
        if (typeof p != "object" || Array.isArray(p))
          return i.error("NumberFormat options argument must be an object.");
        var y = null;
        if (p.locale && !(y = i.parse(p.locale, 1, pt)))
          return null;
        var v = null;
        if (p.currency && !(v = i.parse(p.currency, 1, pt)))
          return null;
        var x = null;
        if (p["min-fraction-digits"] && !(x = i.parse(p["min-fraction-digits"], 1, Le)))
          return null;
        var S = null;
        return p["max-fraction-digits"] && !(S = i.parse(p["max-fraction-digits"], 1, Le)) ? null : new fl(l, y, v, x, S);
      }, fl.prototype.evaluate = function(r) {
        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(r) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(r) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(r) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(r) : void 0 }).format(this.number.evaluate(r));
      }, fl.prototype.eachChild = function(r) {
        r(this.number), this.locale && r(this.locale), this.currency && r(this.currency), this.minFractionDigits && r(this.minFractionDigits), this.maxFractionDigits && r(this.maxFractionDigits);
      }, fl.prototype.outputDefined = function() {
        return !1;
      }, fl.prototype.serialize = function() {
        var r = {};
        return this.locale && (r.locale = this.locale.serialize()), this.currency && (r.currency = this.currency.serialize()), this.minFractionDigits && (r["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (r["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), r];
      };
      var ws = function(r) {
        this.type = Le, this.input = r;
      };
      ws.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected 1 argument, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1);
        return l ? l.type.kind !== "array" && l.type.kind !== "string" && l.type.kind !== "value" ? i.error("Expected argument of type string or array, but found " + Zt(l.type) + " instead.") : new ws(l) : null;
      }, ws.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r);
        if (typeof i == "string" || Array.isArray(i))
          return i.length;
        throw new mi("Expected value to be of type string or array, but found " + Zt(Ln(i)) + " instead.");
      }, ws.prototype.eachChild = function(r) {
        r(this.input);
      }, ws.prototype.outputDefined = function() {
        return !1;
      }, ws.prototype.serialize = function() {
        var r = ["length"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var pl = { "==": qv, "!=": ch, ">": vm, "<": gm, ">=": xm, "<=": _m, array: dn, at: ll, boolean: dn, case: hl, coalesce: vs, collator: xa, format: ia, image: To, in: ul, "index-of": xs, interpolate: Ti, "interpolate-hcl": Ti, "interpolate-lab": Ti, length: ws, let: _s, literal: Vi, match: cl, number: dn, "number-format": fl, object: dn, slice: bs, step: lo, string: dn, "to-boolean": Go, "to-color": Go, "to-number": Go, "to-string": Go, var: ys, within: $o };
      function bm(r, i) {
        var l = i[0], p = i[1], y = i[2], v = i[3];
        l = l.evaluate(r), p = p.evaluate(r), y = y.evaluate(r);
        var x = v ? v.evaluate(r) : 1, S = qf(l, p, y, x);
        if (S)
          throw new mi(S);
        return new Fr(l / 255 * x, p / 255 * x, y / 255 * x, x);
      }
      function wm(r, i) {
        return r in i;
      }
      function Qf(r, i) {
        var l = i[r];
        return l === void 0 ? null : l;
      }
      function dl(r) {
        return { type: r };
      }
      function Em(r) {
        return { result: "success", value: r };
      }
      function ml(r) {
        return { result: "error", value: r };
      }
      function yl(r) {
        return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven";
      }
      function Sm(r) {
        return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
      }
      function Qu(r) {
        return !!r.expression && r.expression.interpolated;
      }
      function Qr(r) {
        return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
      }
      function hh(r) {
        return typeof r == "object" && r !== null && !Array.isArray(r);
      }
      function Wv(r) {
        return r;
      }
      function Jl(r, i, l) {
        return r !== void 0 ? r : i !== void 0 ? i : l !== void 0 ? l : void 0;
      }
      function Tm(r, i, l, p, y) {
        return Jl(typeof l === y ? p[l] : void 0, r.default, i.default);
      }
      function Hv(r, i, l) {
        if (Qr(l) !== "number")
          return Jl(r.default, i.default);
        var p = r.stops.length;
        if (p === 1 || l <= r.stops[0][0])
          return r.stops[0][1];
        if (l >= r.stops[p - 1][0])
          return r.stops[p - 1][1];
        var y = uh(r.stops.map(function(v) {
          return v[0];
        }), l);
        return r.stops[y][1];
      }
      function Mm(r, i, l) {
        var p = r.base !== void 0 ? r.base : 1;
        if (Qr(l) !== "number")
          return Jl(r.default, i.default);
        var y = r.stops.length;
        if (y === 1 || l <= r.stops[0][0])
          return r.stops[0][1];
        if (l >= r.stops[y - 1][0])
          return r.stops[y - 1][1];
        var v = uh(r.stops.map(function(D) {
          return D[0];
        }), l), x = function(D, B, j, J) {
          var ee = J - j, he = D - j;
          return ee === 0 ? 0 : B === 1 ? he / ee : (Math.pow(B, he) - 1) / (Math.pow(B, ee) - 1);
        }(l, p, r.stops[v][0], r.stops[v + 1][0]), S = r.stops[v][1], C = r.stops[v + 1][1], A = Yl[i.type] || Wv;
        if (r.colorSpace && r.colorSpace !== "rgb") {
          var L = dm[r.colorSpace];
          A = function(D, B) {
            return L.reverse(L.interpolate(L.forward(D), L.forward(B), x));
          };
        }
        return typeof S.evaluate == "function" ? { evaluate: function() {
          for (var D = [], B = arguments.length; B--; )
            D[B] = arguments[B];
          var j = S.evaluate.apply(void 0, D), J = C.evaluate.apply(void 0, D);
          if (j !== void 0 && J !== void 0)
            return A(j, J, x);
        } } : A(S, C, x);
      }
      function fh(r, i, l) {
        return i.type === "color" ? l = Fr.parse(l) : i.type === "formatted" ? l = di.fromString(l.toString()) : i.type === "resolvedImage" ? l = Ji.fromString(l.toString()) : Qr(l) === i.type || i.type === "enum" && i.values[l] || (l = void 0), Jl(l, r.default, i.default);
      }
      Si.register(pl, { error: [{ kind: "error" }, [pt], function(r, i) {
        throw new mi(i[0].evaluate(r));
      }], typeof: [pt, [Ee], function(r, i) {
        return Zt(Ln(i[0].evaluate(r)));
      }], "to-rgba": [Jt(Le, 4), [De], function(r, i) {
        return i[0].evaluate(r).toArray();
      }], rgb: [De, [Le, Le, Le], bm], rgba: [De, [Le, Le, Le, Le], bm], has: { type: st, overloads: [[[pt], function(r, i) {
        return wm(i[0].evaluate(r), r.properties());
      }], [[pt, fe], function(r, i) {
        var l = i[1];
        return wm(i[0].evaluate(r), l.evaluate(r));
      }]] }, get: { type: Ee, overloads: [[[pt], function(r, i) {
        return Qf(i[0].evaluate(r), r.properties());
      }], [[pt, fe], function(r, i) {
        var l = i[1];
        return Qf(i[0].evaluate(r), l.evaluate(r));
      }]] }, "feature-state": [Ee, [pt], function(r, i) {
        return Qf(i[0].evaluate(r), r.featureState || {});
      }], properties: [fe, [], function(r) {
        return r.properties();
      }], "geometry-type": [pt, [], function(r) {
        return r.geometryType();
      }], id: [Ee, [], function(r) {
        return r.id();
      }], zoom: [Le, [], function(r) {
        return r.globals.zoom;
      }], "heatmap-density": [Le, [], function(r) {
        return r.globals.heatmapDensity || 0;
      }], "line-progress": [Le, [], function(r) {
        return r.globals.lineProgress || 0;
      }], accumulated: [Ee, [], function(r) {
        return r.globals.accumulated === void 0 ? null : r.globals.accumulated;
      }], "+": [Le, dl(Le), function(r, i) {
        for (var l = 0, p = 0, y = i; p < y.length; p += 1)
          l += y[p].evaluate(r);
        return l;
      }], "*": [Le, dl(Le), function(r, i) {
        for (var l = 1, p = 0, y = i; p < y.length; p += 1)
          l *= y[p].evaluate(r);
        return l;
      }], "-": { type: Le, overloads: [[[Le, Le], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) - l.evaluate(r);
      }], [[Le], function(r, i) {
        return -i[0].evaluate(r);
      }]] }, "/": [Le, [Le, Le], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) / l.evaluate(r);
      }], "%": [Le, [Le, Le], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) % l.evaluate(r);
      }], ln2: [Le, [], function() {
        return Math.LN2;
      }], pi: [Le, [], function() {
        return Math.PI;
      }], e: [Le, [], function() {
        return Math.E;
      }], "^": [Le, [Le, Le], function(r, i) {
        var l = i[1];
        return Math.pow(i[0].evaluate(r), l.evaluate(r));
      }], sqrt: [Le, [Le], function(r, i) {
        return Math.sqrt(i[0].evaluate(r));
      }], log10: [Le, [Le], function(r, i) {
        return Math.log(i[0].evaluate(r)) / Math.LN10;
      }], ln: [Le, [Le], function(r, i) {
        return Math.log(i[0].evaluate(r));
      }], log2: [Le, [Le], function(r, i) {
        return Math.log(i[0].evaluate(r)) / Math.LN2;
      }], sin: [Le, [Le], function(r, i) {
        return Math.sin(i[0].evaluate(r));
      }], cos: [Le, [Le], function(r, i) {
        return Math.cos(i[0].evaluate(r));
      }], tan: [Le, [Le], function(r, i) {
        return Math.tan(i[0].evaluate(r));
      }], asin: [Le, [Le], function(r, i) {
        return Math.asin(i[0].evaluate(r));
      }], acos: [Le, [Le], function(r, i) {
        return Math.acos(i[0].evaluate(r));
      }], atan: [Le, [Le], function(r, i) {
        return Math.atan(i[0].evaluate(r));
      }], min: [Le, dl(Le), function(r, i) {
        return Math.min.apply(Math, i.map(function(l) {
          return l.evaluate(r);
        }));
      }], max: [Le, dl(Le), function(r, i) {
        return Math.max.apply(Math, i.map(function(l) {
          return l.evaluate(r);
        }));
      }], abs: [Le, [Le], function(r, i) {
        return Math.abs(i[0].evaluate(r));
      }], round: [Le, [Le], function(r, i) {
        var l = i[0].evaluate(r);
        return l < 0 ? -Math.round(-l) : Math.round(l);
      }], floor: [Le, [Le], function(r, i) {
        return Math.floor(i[0].evaluate(r));
      }], ceil: [Le, [Le], function(r, i) {
        return Math.ceil(i[0].evaluate(r));
      }], "filter-==": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1];
        return r.properties()[l.value] === p.value;
      }], "filter-id-==": [st, [Ee], function(r, i) {
        var l = i[0];
        return r.id() === l.value;
      }], "filter-type-==": [st, [pt], function(r, i) {
        var l = i[0];
        return r.geometryType() === l.value;
      }], "filter-<": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y < v;
      }], "filter-id-<": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p < y;
      }], "filter->": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y > v;
      }], "filter-id->": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p > y;
      }], "filter-<=": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y <= v;
      }], "filter-id-<=": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p <= y;
      }], "filter->=": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y >= v;
      }], "filter-id->=": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p >= y;
      }], "filter-has": [st, [Ee], function(r, i) {
        return i[0].value in r.properties();
      }], "filter-has-id": [st, [], function(r) {
        return r.id() !== null && r.id() !== void 0;
      }], "filter-type-in": [st, [Jt(pt)], function(r, i) {
        return i[0].value.indexOf(r.geometryType()) >= 0;
      }], "filter-id-in": [st, [Jt(Ee)], function(r, i) {
        return i[0].value.indexOf(r.id()) >= 0;
      }], "filter-in-small": [st, [pt, Jt(Ee)], function(r, i) {
        var l = i[0];
        return i[1].value.indexOf(r.properties()[l.value]) >= 0;
      }], "filter-in-large": [st, [pt, Jt(Ee)], function(r, i) {
        var l = i[0], p = i[1];
        return function(y, v, x, S) {
          for (; x <= S; ) {
            var C = x + S >> 1;
            if (v[C] === y)
              return !0;
            v[C] > y ? S = C - 1 : x = C + 1;
          }
          return !1;
        }(r.properties()[l.value], p.value, 0, p.value.length - 1);
      }], all: { type: st, overloads: [[[st, st], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) && l.evaluate(r);
      }], [dl(st), function(r, i) {
        for (var l = 0, p = i; l < p.length; l += 1)
          if (!p[l].evaluate(r))
            return !1;
        return !0;
      }]] }, any: { type: st, overloads: [[[st, st], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) || l.evaluate(r);
      }], [dl(st), function(r, i) {
        for (var l = 0, p = i; l < p.length; l += 1)
          if (p[l].evaluate(r))
            return !0;
        return !1;
      }]] }, "!": [st, [st], function(r, i) {
        return !i[0].evaluate(r);
      }], "is-supported-script": [st, [pt], function(r, i) {
        var l = r.globals && r.globals.isSupportedScript;
        return !l || l(i[0].evaluate(r));
      }], upcase: [pt, [pt], function(r, i) {
        return i[0].evaluate(r).toUpperCase();
      }], downcase: [pt, [pt], function(r, i) {
        return i[0].evaluate(r).toLowerCase();
      }], concat: [pt, dl(Ee), function(r, i) {
        return i.map(function(l) {
          return Xu(l.evaluate(r));
        }).join("");
      }], "resolved-locale": [pt, [He], function(r, i) {
        return i[0].evaluate(r).resolvedLocale();
      }] });
      var Ql = function(r, i) {
        this.expression = r, this._warningHistory = {}, this._evaluator = new Va(), this._defaultValue = i ? function(l) {
          return l.type === "color" && hh(l.default) ? new Fr(0, 0, 0, 0) : l.type === "color" ? Fr.parse(l.default) || null : l.default === void 0 ? null : l.default;
        }(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null;
      };
      function ec(r) {
        return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in pl;
      }
      function ph(r, i) {
        var l = new gs(pl, [], i ? function(y) {
          var v = { color: De, string: pt, number: Le, enum: pt, boolean: st, formatted: jt, resolvedImage: Wt };
          return y.type === "array" ? Jt(v[y.value] || Ee, y.length) : v[y.type];
        }(i) : void 0), p = l.parse(r, void 0, void 0, void 0, i && i.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return p ? Em(new Ql(p, i)) : ml(l.errors);
      }
      Ql.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._evaluator.globals = r, this._evaluator.feature = i, this._evaluator.featureState = l, this._evaluator.canonical = p, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = v, this.expression.evaluate(this._evaluator);
      }, Ql.prototype.evaluate = function(r, i, l, p, y, v) {
        this._evaluator.globals = r, this._evaluator.feature = i || null, this._evaluator.featureState = l || null, this._evaluator.canonical = p, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = v || null;
        try {
          var x = this.expression.evaluate(this._evaluator);
          if (x == null || typeof x == "number" && x != x)
            return this._defaultValue;
          if (this._enumValues && !(x in this._enumValues))
            throw new mi("Expected value to be one of " + Object.keys(this._enumValues).map(function(S) {
              return JSON.stringify(S);
            }).join(", ") + ", but found " + JSON.stringify(x) + " instead.");
          return x;
        } catch (S) {
          return this._warningHistory[S.message] || (this._warningHistory[S.message] = !0, typeof console < "u" && console.warn(S.message)), this._defaultValue;
        }
      };
      var tc = function(r, i) {
        this.kind = r, this._styleExpression = i, this.isStateDependent = r !== "constant" && !ms(i.expression);
      };
      tc.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluateWithoutErrorHandling(r, i, l, p, y, v);
      }, tc.prototype.evaluate = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluate(r, i, l, p, y, v);
      };
      var eu = function(r, i, l, p) {
        this.kind = r, this.zoomStops = l, this._styleExpression = i, this.isStateDependent = r !== "camera" && !ms(i.expression), this.interpolationType = p;
      };
      function Im(r, i) {
        if ((r = ph(r, i)).result === "error")
          return r;
        var l = r.value.expression, p = ds(l);
        if (!p && !yl(i))
          return ml([new Ue("", "data expressions not supported")]);
        var y = sl(l, ["zoom"]);
        if (!y && !Sm(i))
          return ml([new Ue("", "zoom expressions not supported")]);
        var v = function x(S) {
          var C = null;
          if (S instanceof _s)
            C = x(S.result);
          else if (S instanceof vs)
            for (var A = 0, L = S.args; A < L.length && !(C = x(L[A])); A += 1)
              ;
          else
            (S instanceof lo || S instanceof Ti) && S.input instanceof Si && S.input.name === "zoom" && (C = S);
          return C instanceof Ue || S.eachChild(function(D) {
            var B = x(D);
            B instanceof Ue ? C = B : !C && B ? C = new Ue("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : C && B && C !== B && (C = new Ue("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), C;
        }(l);
        return v || y ? v instanceof Ue ? ml([v]) : v instanceof Ti && !Qu(i) ? ml([new Ue("", '"interpolate" expressions cannot be used with this property')]) : Em(v ? new eu(p ? "camera" : "composite", r.value, v.labels, v instanceof Ti ? v.interpolation : void 0) : new tc(p ? "constant" : "source", r.value)) : ml([new Ue("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      eu.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluateWithoutErrorHandling(r, i, l, p, y, v);
      }, eu.prototype.evaluate = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluate(r, i, l, p, y, v);
      }, eu.prototype.interpolationFactor = function(r, i, l) {
        return this.interpolationType ? Ti.interpolationFactor(this.interpolationType, r, i, l) : 0;
      };
      var tu = function(r, i) {
        this._parameters = r, this._specification = i, Ge(this, function l(p, y) {
          var v, x, S, C = y.type === "color", A = p.stops && typeof p.stops[0][0] == "object", L = A || !(A || p.property !== void 0), D = p.type || (Qu(y) ? "exponential" : "interval");
          if (C && ((p = Ge({}, p)).stops && (p.stops = p.stops.map(function(dt) {
            return [dt[0], Fr.parse(dt[1])];
          })), p.default = Fr.parse(p.default ? p.default : y.default)), p.colorSpace && p.colorSpace !== "rgb" && !dm[p.colorSpace])
            throw new Error("Unknown color space: " + p.colorSpace);
          if (D === "exponential")
            v = Mm;
          else if (D === "interval")
            v = Hv;
          else if (D === "categorical") {
            v = Tm, x = /* @__PURE__ */ Object.create(null);
            for (var B = 0, j = p.stops; B < j.length; B += 1) {
              var J = j[B];
              x[J[0]] = J[1];
            }
            S = typeof p.stops[0][0];
          } else {
            if (D !== "identity")
              throw new Error('Unknown function type "' + D + '"');
            v = fh;
          }
          if (A) {
            for (var ee = {}, he = [], oe = 0; oe < p.stops.length; oe++) {
              var ge = p.stops[oe], we = ge[0].zoom;
              ee[we] === void 0 && (ee[we] = { zoom: we, type: p.type, property: p.property, default: p.default, stops: [] }, he.push(we)), ee[we].stops.push([ge[0].value, ge[1]]);
            }
            for (var Te = [], Oe = 0, Be = he; Oe < Be.length; Oe += 1) {
              var Ke = Be[Oe];
              Te.push([ee[Ke].zoom, l(ee[Ke], y)]);
            }
            var ot = { name: "linear" };
            return { kind: "composite", interpolationType: ot, interpolationFactor: Ti.interpolationFactor.bind(void 0, ot), zoomStops: Te.map(function(dt) {
              return dt[0];
            }), evaluate: function(dt, Nt) {
              var yt = dt.zoom;
              return Mm({ stops: Te, base: p.base }, y, yt).evaluate(yt, Nt);
            } };
          }
          if (L) {
            var At = D === "exponential" ? { name: "exponential", base: p.base !== void 0 ? p.base : 1 } : null;
            return { kind: "camera", interpolationType: At, interpolationFactor: Ti.interpolationFactor.bind(void 0, At), zoomStops: p.stops.map(function(dt) {
              return dt[0];
            }), evaluate: function(dt) {
              return v(p, y, dt.zoom, x, S);
            } };
          }
          return { kind: "source", evaluate: function(dt, Nt) {
            var yt = Nt && Nt.properties ? Nt.properties[p.property] : void 0;
            return yt === void 0 ? Jl(p.default, y.default) : v(p, y, yt, x, S);
          } };
        }(this._parameters, this._specification));
      };
      function oa(r) {
        var i = r.key, l = r.value, p = r.valueSpec || {}, y = r.objectElementValidators || {}, v = r.style, x = r.styleSpec, S = [], C = Qr(l);
        if (C !== "object")
          return [new ie(i, l, "object expected, " + C + " found")];
        for (var A in l) {
          var L = A.split(".")[0], D = p[L] || p["*"], B = void 0;
          if (y[L])
            B = y[L];
          else if (p[L])
            B = wr;
          else if (y["*"])
            B = y["*"];
          else {
            if (!p["*"]) {
              S.push(new ie(i, l[A], 'unknown property "' + A + '"'));
              continue;
            }
            B = wr;
          }
          S = S.concat(B({ key: (i && i + ".") + A, value: l[A], valueSpec: D, style: v, styleSpec: x, object: l, objectKey: A }, l));
        }
        for (var j in p)
          y[j] || p[j].required && p[j].default === void 0 && l[j] === void 0 && S.push(new ie(i, l, 'missing required property "' + j + '"'));
        return S;
      }
      function Om(r) {
        var i = r.value, l = r.valueSpec, p = r.style, y = r.styleSpec, v = r.key, x = r.arrayElementValidator || wr;
        if (Qr(i) !== "array")
          return [new ie(v, i, "array expected, " + Qr(i) + " found")];
        if (l.length && i.length !== l.length)
          return [new ie(v, i, "array length " + l.length + " expected, length " + i.length + " found")];
        if (l["min-length"] && i.length < l["min-length"])
          return [new ie(v, i, "array length at least " + l["min-length"] + " expected, length " + i.length + " found")];
        var S = { type: l.value, values: l.values };
        y.$version < 7 && (S.function = l.function), Qr(l.value) === "object" && (S = l.value);
        for (var C = [], A = 0; A < i.length; A++)
          C = C.concat(x({ array: i, arrayIndex: A, value: i[A], valueSpec: S, style: p, styleSpec: y, key: v + "[" + A + "]" }));
        return C;
      }
      function Cm(r) {
        var i = r.key, l = r.value, p = r.valueSpec, y = Qr(l);
        return y === "number" && l != l && (y = "NaN"), y !== "number" ? [new ie(i, l, "number expected, " + y + " found")] : "minimum" in p && l < p.minimum ? [new ie(i, l, l + " is less than the minimum value " + p.minimum)] : "maximum" in p && l > p.maximum ? [new ie(i, l, l + " is greater than the maximum value " + p.maximum)] : [];
      }
      function Am(r) {
        var i, l, p, y = r.valueSpec, v = Ze(r.value.type), x = {}, S = v !== "categorical" && r.value.property === void 0, C = !S, A = Qr(r.value.stops) === "array" && Qr(r.value.stops[0]) === "array" && Qr(r.value.stops[0][0]) === "object", L = oa({ key: r.key, value: r.value, valueSpec: r.styleSpec.function, style: r.style, styleSpec: r.styleSpec, objectElementValidators: { stops: function(j) {
          if (v === "identity")
            return [new ie(j.key, j.value, 'identity function may not have a "stops" property')];
          var J = [], ee = j.value;
          return J = J.concat(Om({ key: j.key, value: ee, valueSpec: j.valueSpec, style: j.style, styleSpec: j.styleSpec, arrayElementValidator: D })), Qr(ee) === "array" && ee.length === 0 && J.push(new ie(j.key, ee, "array must have at least one stop")), J;
        }, default: function(j) {
          return wr({ key: j.key, value: j.value, valueSpec: y, style: j.style, styleSpec: j.styleSpec });
        } } });
        return v === "identity" && S && L.push(new ie(r.key, r.value, 'missing required property "property"')), v === "identity" || r.value.stops || L.push(new ie(r.key, r.value, 'missing required property "stops"')), v === "exponential" && r.valueSpec.expression && !Qu(r.valueSpec) && L.push(new ie(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (C && !yl(r.valueSpec) ? L.push(new ie(r.key, r.value, "property functions not supported")) : S && !Sm(r.valueSpec) && L.push(new ie(r.key, r.value, "zoom functions not supported"))), v !== "categorical" && !A || r.value.property !== void 0 || L.push(new ie(r.key, r.value, '"property" property is required')), L;
        function D(j) {
          var J = [], ee = j.value, he = j.key;
          if (Qr(ee) !== "array")
            return [new ie(he, ee, "array expected, " + Qr(ee) + " found")];
          if (ee.length !== 2)
            return [new ie(he, ee, "array length 2 expected, length " + ee.length + " found")];
          if (A) {
            if (Qr(ee[0]) !== "object")
              return [new ie(he, ee, "object expected, " + Qr(ee[0]) + " found")];
            if (ee[0].zoom === void 0)
              return [new ie(he, ee, "object stop key must have zoom")];
            if (ee[0].value === void 0)
              return [new ie(he, ee, "object stop key must have value")];
            if (p && p > Ze(ee[0].zoom))
              return [new ie(he, ee[0].zoom, "stop zoom values must appear in ascending order")];
            Ze(ee[0].zoom) !== p && (p = Ze(ee[0].zoom), l = void 0, x = {}), J = J.concat(oa({ key: he + "[0]", value: ee[0], valueSpec: { zoom: {} }, style: j.style, styleSpec: j.styleSpec, objectElementValidators: { zoom: Cm, value: B } }));
          } else
            J = J.concat(B({ key: he + "[0]", value: ee[0], valueSpec: {}, style: j.style, styleSpec: j.styleSpec }, ee));
          return ec(Ce(ee[1])) ? J.concat([new ie(he + "[1]", ee[1], "expressions are not allowed in function stops.")]) : J.concat(wr({ key: he + "[1]", value: ee[1], valueSpec: y, style: j.style, styleSpec: j.styleSpec }));
        }
        function B(j, J) {
          var ee = Qr(j.value), he = Ze(j.value), oe = j.value !== null ? j.value : J;
          if (i) {
            if (ee !== i)
              return [new ie(j.key, oe, ee + " stop domain type must match previous stop domain type " + i)];
          } else
            i = ee;
          if (ee !== "number" && ee !== "string" && ee !== "boolean")
            return [new ie(j.key, oe, "stop domain value must be a number, string, or boolean")];
          if (ee !== "number" && v !== "categorical") {
            var ge = "number expected, " + ee + " found";
            return yl(y) && v === void 0 && (ge += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ie(j.key, oe, ge)];
          }
          return v !== "categorical" || ee !== "number" || isFinite(he) && Math.floor(he) === he ? v !== "categorical" && ee === "number" && l !== void 0 && he < l ? [new ie(j.key, oe, "stop domain values must appear in ascending order")] : (l = he, v === "categorical" && he in x ? [new ie(j.key, oe, "stop domain values must be unique")] : (x[he] = !0, [])) : [new ie(j.key, oe, "integer expected, found " + he)];
        }
      }
      function gl(r) {
        var i = (r.expressionContext === "property" ? Im : ph)(Ce(r.value), r.valueSpec);
        if (i.result === "error")
          return i.value.map(function(p) {
            return new ie("" + r.key + p.key, r.value, p.message);
          });
        var l = i.value.expression || i.value._styleExpression.expression;
        if (r.expressionContext === "property" && r.propertyKey === "text-font" && !l.outputDefined())
          return [new ie(r.key, r.value, 'Invalid data expression for "' + r.propertyKey + '". Output values must be contained as literals within the expression.')];
        if (r.expressionContext === "property" && r.propertyType === "layout" && !ms(l))
          return [new ie(r.key, r.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (r.expressionContext === "filter" && !ms(l))
          return [new ie(r.key, r.value, '"feature-state" data expressions are not supported with filters.')];
        if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
          if (!sl(l, ["zoom", "feature-state"]))
            return [new ie(r.key, r.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (r.expressionContext === "cluster-initial" && !ds(l))
            return [new ie(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function rc(r) {
        var i = r.key, l = r.value, p = r.valueSpec, y = [];
        return Array.isArray(p.values) ? p.values.indexOf(Ze(l)) === -1 && y.push(new ie(i, l, "expected one of [" + p.values.join(", ") + "], " + JSON.stringify(l) + " found")) : Object.keys(p.values).indexOf(Ze(l)) === -1 && y.push(new ie(i, l, "expected one of [" + Object.keys(p.values).join(", ") + "], " + JSON.stringify(l) + " found")), y;
      }
      function dh(r) {
        if (r === !0 || r === !1)
          return !0;
        if (!Array.isArray(r) || r.length === 0)
          return !1;
        switch (r[0]) {
          case "has":
            return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
          case "in":
            return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
          case "any":
          case "all":
            for (var i = 0, l = r.slice(1); i < l.length; i += 1) {
              var p = l[i];
              if (!dh(p) && typeof p != "boolean")
                return !1;
            }
            return !0;
          default:
            return !0;
        }
      }
      tu.deserialize = function(r) {
        return new tu(r._parameters, r._specification);
      }, tu.serialize = function(r) {
        return { _parameters: r._parameters, _specification: r._specification };
      };
      var ep = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function mh(r) {
        if (r == null)
          return { filter: function() {
            return !0;
          }, needGeometry: !1 };
        dh(r) || (r = yh(r));
        var i = ph(r, ep);
        if (i.result === "error")
          throw new Error(i.value.map(function(l) {
            return l.key + ": " + l.message;
          }).join(", "));
        return { filter: function(l, p, y) {
          return i.value.evaluate(l, p, {}, y);
        }, needGeometry: function l(p) {
          if (!Array.isArray(p))
            return !1;
          if (p[0] === "within")
            return !0;
          for (var y = 1; y < p.length; y++)
            if (l(p[y]))
              return !0;
          return !1;
        }(r) };
      }
      function Zv(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function yh(r) {
        if (!r)
          return !0;
        var i, l = r[0];
        return r.length <= 1 ? l !== "any" : l === "==" ? tp(r[1], r[2], "==") : l === "!=" ? gh(tp(r[1], r[2], "==")) : l === "<" || l === ">" || l === "<=" || l === ">=" ? tp(r[1], r[2], l) : l === "any" ? (i = r.slice(1), ["any"].concat(i.map(yh))) : l === "all" ? ["all"].concat(r.slice(1).map(yh)) : l === "none" ? ["all"].concat(r.slice(1).map(yh).map(gh)) : l === "in" ? Pm(r[1], r.slice(2)) : l === "!in" ? gh(Pm(r[1], r.slice(2))) : l === "has" ? km(r[1]) : l === "!has" ? gh(km(r[1])) : l !== "within" || r;
      }
      function tp(r, i, l) {
        switch (r) {
          case "$type":
            return ["filter-type-" + l, i];
          case "$id":
            return ["filter-id-" + l, i];
          default:
            return ["filter-" + l, r, i];
        }
      }
      function Pm(r, i) {
        if (i.length === 0)
          return !1;
        switch (r) {
          case "$type":
            return ["filter-type-in", ["literal", i]];
          case "$id":
            return ["filter-id-in", ["literal", i]];
          default:
            return i.length > 200 && !i.some(function(l) {
              return typeof l != typeof i[0];
            }) ? ["filter-in-large", r, ["literal", i.sort(Zv)]] : ["filter-in-small", r, ["literal", i]];
        }
      }
      function km(r) {
        switch (r) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", r];
        }
      }
      function gh(r) {
        return ["!", r];
      }
      function rp(r) {
        return dh(Ce(r.value)) ? gl(Ge({}, r, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : function i(l) {
          var p = l.value, y = l.key;
          if (Qr(p) !== "array")
            return [new ie(y, p, "array expected, " + Qr(p) + " found")];
          var v, x = l.styleSpec, S = [];
          if (p.length < 1)
            return [new ie(y, p, "filter array must have at least 1 element")];
          switch (S = S.concat(rc({ key: y + "[0]", value: p[0], valueSpec: x.filter_operator, style: l.style, styleSpec: l.styleSpec })), Ze(p[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              p.length >= 2 && Ze(p[1]) === "$type" && S.push(new ie(y, p, '"$type" cannot be use with operator "' + p[0] + '"'));
            case "==":
            case "!=":
              p.length !== 3 && S.push(new ie(y, p, 'filter array for operator "' + p[0] + '" must have 3 elements'));
            case "in":
            case "!in":
              p.length >= 2 && (v = Qr(p[1])) !== "string" && S.push(new ie(y + "[1]", p[1], "string expected, " + v + " found"));
              for (var C = 2; C < p.length; C++)
                v = Qr(p[C]), Ze(p[1]) === "$type" ? S = S.concat(rc({ key: y + "[" + C + "]", value: p[C], valueSpec: x.geometry_type, style: l.style, styleSpec: l.styleSpec })) : v !== "string" && v !== "number" && v !== "boolean" && S.push(new ie(y + "[" + C + "]", p[C], "string, number, or boolean expected, " + v + " found"));
              break;
            case "any":
            case "all":
            case "none":
              for (var A = 1; A < p.length; A++)
                S = S.concat(i({ key: y + "[" + A + "]", value: p[A], style: l.style, styleSpec: l.styleSpec }));
              break;
            case "has":
            case "!has":
              v = Qr(p[1]), p.length !== 2 ? S.push(new ie(y, p, 'filter array for "' + p[0] + '" operator must have 2 elements')) : v !== "string" && S.push(new ie(y + "[1]", p[1], "string expected, " + v + " found"));
              break;
            case "within":
              v = Qr(p[1]), p.length !== 2 ? S.push(new ie(y, p, 'filter array for "' + p[0] + '" operator must have 2 elements')) : v !== "object" && S.push(new ie(y + "[1]", p[1], "object expected, " + v + " found"));
          }
          return S;
        }(r);
      }
      function np(r, i) {
        var l = r.key, p = r.style, y = r.styleSpec, v = r.value, x = r.objectKey, S = y[i + "_" + r.layerType];
        if (!S)
          return [];
        var C = x.match(/^(.*)-transition$/);
        if (i === "paint" && C && S[C[1]] && S[C[1]].transition)
          return wr({ key: l, value: v, valueSpec: y.transition, style: p, styleSpec: y });
        var A, L = r.valueSpec || S[x];
        if (!L)
          return [new ie(l, v, 'unknown property "' + x + '"')];
        if (Qr(v) === "string" && yl(L) && !L.tokens && (A = /^{([^}]+)}$/.exec(v)))
          return [new ie(l, v, '"' + x + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(A[1]) + " }`.")];
        var D = [];
        return r.layerType === "symbol" && (x === "text-field" && p && !p.glyphs && D.push(new ie(l, v, 'use of "text-field" requires a style "glyphs" property')), x === "text-font" && hh(Ce(v)) && Ze(v.type) === "identity" && D.push(new ie(l, v, '"text-font" does not support identity functions'))), D.concat(wr({ key: r.key, value: v, valueSpec: L, style: p, styleSpec: y, expressionContext: "property", propertyType: i, propertyKey: x }));
      }
      function ip(r) {
        return np(r, "paint");
      }
      function nc(r) {
        return np(r, "layout");
      }
      function Lm(r) {
        var i = [], l = r.value, p = r.key, y = r.style, v = r.styleSpec;
        l.type || l.ref || i.push(new ie(p, l, 'either "type" or "ref" is required'));
        var x, S = Ze(l.type), C = Ze(l.ref);
        if (l.id)
          for (var A = Ze(l.id), L = 0; L < r.arrayIndex; L++) {
            var D = y.layers[L];
            Ze(D.id) === A && i.push(new ie(p, l.id, 'duplicate layer id "' + l.id + '", previously used at line ' + D.id.__line__));
          }
        if ("ref" in l)
          ["type", "source", "source-layer", "filter", "layout"].forEach(function(J) {
            J in l && i.push(new ie(p, l[J], '"' + J + '" is prohibited for ref layers'));
          }), y.layers.forEach(function(J) {
            Ze(J.id) === C && (x = J);
          }), x ? x.ref ? i.push(new ie(p, l.ref, "ref cannot reference another ref layer")) : S = Ze(x.type) : i.push(new ie(p, l.ref, 'ref layer "' + C + '" not found'));
        else if (S !== "background")
          if (l.source) {
            var B = y.sources && y.sources[l.source], j = B && Ze(B.type);
            B ? j === "vector" && S === "raster" ? i.push(new ie(p, l.source, 'layer "' + l.id + '" requires a raster source')) : j === "raster" && S !== "raster" ? i.push(new ie(p, l.source, 'layer "' + l.id + '" requires a vector source')) : j !== "vector" || l["source-layer"] ? j === "raster-dem" && S !== "hillshade" ? i.push(new ie(p, l.source, "raster-dem source can only be used with layer type 'hillshade'.")) : S !== "line" || !l.paint || !l.paint["line-gradient"] || j === "geojson" && B.lineMetrics || i.push(new ie(p, l, 'layer "' + l.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : i.push(new ie(p, l, 'layer "' + l.id + '" must specify a "source-layer"')) : i.push(new ie(p, l.source, 'source "' + l.source + '" not found'));
          } else
            i.push(new ie(p, l, 'missing required property "source"'));
        return i = i.concat(oa({ key: p, value: l, valueSpec: v.layer, style: r.style, styleSpec: r.styleSpec, objectElementValidators: { "*": function() {
          return [];
        }, type: function() {
          return wr({ key: p + ".type", value: l.type, valueSpec: v.layer.type, style: r.style, styleSpec: r.styleSpec, object: l, objectKey: "type" });
        }, filter: rp, layout: function(J) {
          return oa({ layer: l, key: J.key, value: J.value, style: J.style, styleSpec: J.styleSpec, objectElementValidators: { "*": function(ee) {
            return nc(Ge({ layerType: S }, ee));
          } } });
        }, paint: function(J) {
          return oa({ layer: l, key: J.key, value: J.value, style: J.style, styleSpec: J.styleSpec, objectElementValidators: { "*": function(ee) {
            return ip(Ge({ layerType: S }, ee));
          } } });
        } } }));
      }
      function vl(r) {
        var i = r.value, l = r.key, p = Qr(i);
        return p !== "string" ? [new ie(l, i, "string expected, " + p + " found")] : [];
      }
      var mn = { promoteId: function(r) {
        var i = r.key, l = r.value;
        if (Qr(l) === "string")
          return vl({ key: i, value: l });
        var p = [];
        for (var y in l)
          p.push.apply(p, vl({ key: i + "." + y, value: l[y] }));
        return p;
      } };
      function vh(r) {
        var i = r.value, l = r.key, p = r.styleSpec, y = r.style;
        if (!i.type)
          return [new ie(l, i, '"type" is required')];
        var v, x = Ze(i.type);
        switch (x) {
          case "vector":
          case "raster":
          case "raster-dem":
            return oa({ key: l, value: i, valueSpec: p["source_" + x.replace("-", "_")], style: r.style, styleSpec: p, objectElementValidators: mn });
          case "geojson":
            if (v = oa({ key: l, value: i, valueSpec: p.source_geojson, style: y, styleSpec: p, objectElementValidators: mn }), i.cluster)
              for (var S in i.clusterProperties) {
                var C = i.clusterProperties[S], A = C[0], L = typeof A == "string" ? [A, ["accumulated"], ["get", S]] : A;
                v.push.apply(v, gl({ key: l + "." + S + ".map", value: C[1], expressionContext: "cluster-map" })), v.push.apply(v, gl({ key: l + "." + S + ".reduce", value: L, expressionContext: "cluster-reduce" }));
              }
            return v;
          case "video":
            return oa({ key: l, value: i, valueSpec: p.source_video, style: y, styleSpec: p });
          case "image":
            return oa({ key: l, value: i, valueSpec: p.source_image, style: y, styleSpec: p });
          case "canvas":
            return [new ie(l, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return rc({ key: l + ".type", value: i.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: y, styleSpec: p });
        }
      }
      function _l(r) {
        var i = r.value, l = r.styleSpec, p = l.light, y = r.style, v = [], x = Qr(i);
        if (i === void 0)
          return v;
        if (x !== "object")
          return v.concat([new ie("light", i, "object expected, " + x + " found")]);
        for (var S in i) {
          var C = S.match(/^(.*)-transition$/);
          v = v.concat(C && p[C[1]] && p[C[1]].transition ? wr({ key: S, value: i[S], valueSpec: l.transition, style: y, styleSpec: l }) : p[S] ? wr({ key: S, value: i[S], valueSpec: p[S], style: y, styleSpec: l }) : [new ie(S, i[S], 'unknown property "' + S + '"')]);
        }
        return v;
      }
      var Es = { "*": function() {
        return [];
      }, array: Om, boolean: function(r) {
        var i = r.value, l = r.key, p = Qr(i);
        return p !== "boolean" ? [new ie(l, i, "boolean expected, " + p + " found")] : [];
      }, number: Cm, color: function(r) {
        var i = r.key, l = r.value, p = Qr(l);
        return p !== "string" ? [new ie(i, l, "color expected, " + p + " found")] : gr(l) === null ? [new ie(i, l, 'color expected, "' + l + '" found')] : [];
      }, constants: _e, enum: rc, filter: rp, function: Am, layer: Lm, object: oa, source: vh, light: _l, string: vl, formatted: function(r) {
        return vl(r).length === 0 ? [] : gl(r);
      }, resolvedImage: function(r) {
        return vl(r).length === 0 ? [] : gl(r);
      } };
      function wr(r) {
        var i = r.value, l = r.valueSpec, p = r.styleSpec;
        return l.expression && hh(Ze(i)) ? Am(r) : l.expression && ec(Ce(i)) ? gl(r) : l.type && Es[l.type] ? Es[l.type](r) : oa(Ge({}, r, { valueSpec: l.type ? p[l.type] : l }));
      }
      function en(r) {
        var i = r.value, l = r.key, p = vl(r);
        return p.length || (i.indexOf("{fontstack}") === -1 && p.push(new ie(l, i, '"glyphs" url must include a "{fontstack}" token')), i.indexOf("{range}") === -1 && p.push(new ie(l, i, '"glyphs" url must include a "{range}" token'))), p;
      }
      function Mo(r, i) {
        i === void 0 && (i = G);
        var l = [];
        return l = l.concat(wr({ key: "", value: r, valueSpec: i.$root, styleSpec: i, style: r, objectElementValidators: { glyphs: en, "*": function() {
          return [];
        } } })), r.constants && (l = l.concat(_e({ key: "constants", value: r.constants, style: r, styleSpec: i }))), ic(l);
      }
      function ic(r) {
        return [].concat(r).sort(function(i, l) {
          return i.line - l.line;
        });
      }
      function ru(r) {
        return function() {
          for (var i = [], l = arguments.length; l--; )
            i[l] = arguments[l];
          return ic(r.apply(this, i));
        };
      }
      Mo.source = ru(vh), Mo.light = ru(_l), Mo.layer = ru(Lm), Mo.filter = ru(rp), Mo.paintProperty = ru(ip), Mo.layoutProperty = ru(nc);
      var oc = Mo, Xv = oc.light, Kv = oc.paintProperty, ac = oc.layoutProperty;
      function sc(r, i) {
        var l = !1;
        if (i && i.length)
          for (var p = 0, y = i; p < y.length; p += 1)
            r.fire(new pe(new Error(y[p].message))), l = !0;
        return l;
      }
      var Ua = Jn;
      function Jn(r, i, l) {
        var p = this.cells = [];
        if (r instanceof ArrayBuffer) {
          this.arrayBuffer = r;
          var y = new Int32Array(this.arrayBuffer);
          r = y[0], this.d = (i = y[1]) + 2 * (l = y[2]);
          for (var v = 0; v < this.d * this.d; v++) {
            var x = y[3 + v], S = y[3 + v + 1];
            p.push(x === S ? null : y.subarray(x, S));
          }
          var C = y[3 + p.length + 1];
          this.keys = y.subarray(y[3 + p.length], C), this.bboxes = y.subarray(C), this.insert = this._insertReadonly;
        } else {
          this.d = i + 2 * l;
          for (var A = 0; A < this.d * this.d; A++)
            p.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = i, this.extent = r, this.padding = l, this.scale = i / r, this.uid = 0;
        var L = l / i * r;
        this.min = -L, this.max = r + L;
      }
      Jn.prototype.insert = function(r, i, l, p, y) {
        this._forEachCell(i, l, p, y, this._insertCell, this.uid++), this.keys.push(r), this.bboxes.push(i), this.bboxes.push(l), this.bboxes.push(p), this.bboxes.push(y);
      }, Jn.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, Jn.prototype._insertCell = function(r, i, l, p, y, v) {
        this.cells[y].push(v);
      }, Jn.prototype.query = function(r, i, l, p, y) {
        var v = this.min, x = this.max;
        if (r <= v && i <= v && x <= l && x <= p && !y)
          return Array.prototype.slice.call(this.keys);
        var S = [];
        return this._forEachCell(r, i, l, p, this._queryCell, S, {}, y), S;
      }, Jn.prototype._queryCell = function(r, i, l, p, y, v, x, S) {
        var C = this.cells[y];
        if (C !== null)
          for (var A = this.keys, L = this.bboxes, D = 0; D < C.length; D++) {
            var B = C[D];
            if (x[B] === void 0) {
              var j = 4 * B;
              (S ? S(L[j + 0], L[j + 1], L[j + 2], L[j + 3]) : r <= L[j + 2] && i <= L[j + 3] && l >= L[j + 0] && p >= L[j + 1]) ? (x[B] = !0, v.push(A[B])) : x[B] = !1;
            }
          }
      }, Jn.prototype._forEachCell = function(r, i, l, p, y, v, x, S) {
        for (var C = this._convertToCellCoord(r), A = this._convertToCellCoord(i), L = this._convertToCellCoord(l), D = this._convertToCellCoord(p), B = C; B <= L; B++)
          for (var j = A; j <= D; j++) {
            var J = this.d * j + B;
            if ((!S || S(this._convertFromCellCoord(B), this._convertFromCellCoord(j), this._convertFromCellCoord(B + 1), this._convertFromCellCoord(j + 1))) && y.call(this, r, i, l, p, J, v, x, S))
              return;
          }
      }, Jn.prototype._convertFromCellCoord = function(r) {
        return (r - this.padding) / this.scale;
      }, Jn.prototype._convertToCellCoord = function(r) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(r * this.scale) + this.padding));
      }, Jn.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer)
          return this.arrayBuffer;
        for (var r = this.cells, i = 3 + this.cells.length + 1 + 1, l = 0, p = 0; p < this.cells.length; p++)
          l += this.cells[p].length;
        var y = new Int32Array(i + l + this.keys.length + this.bboxes.length);
        y[0] = this.extent, y[1] = this.n, y[2] = this.padding;
        for (var v = i, x = 0; x < r.length; x++) {
          var S = r[x];
          y[3 + x] = v, y.set(S, v), v += S.length;
        }
        return y[3 + r.length] = v, y.set(this.keys, v), y[3 + r.length + 1] = v += this.keys.length, y.set(this.bboxes, v), v += this.bboxes.length, y.buffer;
      };
      var lc = I.ImageData, Dm = I.ImageBitmap, Gn = {};
      function wt(r, i, l) {
        l === void 0 && (l = {}), Object.defineProperty(i, "_classRegistryKey", { value: r, writeable: !1 }), Gn[r] = { klass: i, omit: l.omit || [], shallow: l.shallow || [] };
      }
      for (var uo in wt("Object", Object), Ua.serialize = function(r, i) {
        var l = r.toArrayBuffer();
        return i && i.push(l), { buffer: l };
      }, Ua.deserialize = function(r) {
        return new Ua(r.buffer);
      }, wt("Grid", Ua), wt("Color", Fr), wt("Error", Error), wt("ResolvedImage", Ji), wt("StylePropertyFunction", tu), wt("StyleExpression", Ql, { omit: ["_evaluator"] }), wt("ZoomDependentExpression", eu), wt("ZoomConstantExpression", tc), wt("CompoundExpression", Si, { omit: ["_evaluate"] }), pl)
        pl[uo]._classRegistryKey || wt("Expression_" + uo, pl[uo]);
      function _h(r) {
        return r && typeof ArrayBuffer < "u" && (r instanceof ArrayBuffer || r.constructor && r.constructor.name === "ArrayBuffer");
      }
      function nu(r) {
        return Dm && r instanceof Dm;
      }
      function aa(r, i) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp)
          return r;
        if (_h(r) || nu(r))
          return i && i.push(r), r;
        if (ArrayBuffer.isView(r)) {
          var l = r;
          return i && i.push(l.buffer), l;
        }
        if (r instanceof lc)
          return i && i.push(r.data.buffer), r;
        if (Array.isArray(r)) {
          for (var p = [], y = 0, v = r; y < v.length; y += 1)
            p.push(aa(v[y], i));
          return p;
        }
        if (typeof r == "object") {
          var x = r.constructor, S = x._classRegistryKey;
          if (!S)
            throw new Error("can't serialize object of unregistered class");
          var C = x.serialize ? x.serialize(r, i) : {};
          if (!x.serialize) {
            for (var A in r)
              if (r.hasOwnProperty(A) && !(Gn[S].omit.indexOf(A) >= 0)) {
                var L = r[A];
                C[A] = Gn[S].shallow.indexOf(A) >= 0 ? L : aa(L, i);
              }
            r instanceof Error && (C.message = r.message);
          }
          if (C.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return S !== "Object" && (C.$name = S), C;
        }
        throw new Error("can't serialize object of type " + typeof r);
      }
      function co(r) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp || _h(r) || nu(r) || ArrayBuffer.isView(r) || r instanceof lc)
          return r;
        if (Array.isArray(r))
          return r.map(co);
        if (typeof r == "object") {
          var i = r.$name || "Object", l = Gn[i].klass;
          if (!l)
            throw new Error("can't deserialize unregistered class " + i);
          if (l.deserialize)
            return l.deserialize(r);
          for (var p = Object.create(l.prototype), y = 0, v = Object.keys(r); y < v.length; y += 1) {
            var x = v[y];
            if (x !== "$name") {
              var S = r[x];
              p[x] = Gn[i].shallow.indexOf(x) >= 0 ? S : co(S);
            }
          }
          return p;
        }
        throw new Error("can't deserialize object of type " + typeof r);
      }
      var op = function() {
        this.first = !0;
      };
      op.prototype.update = function(r, i) {
        var l = Math.floor(r);
        return this.first ? (this.first = !1, this.lastIntegerZoom = l, this.lastIntegerZoomTime = 0, this.lastZoom = r, this.lastFloorZoom = l, !0) : (this.lastFloorZoom > l ? (this.lastIntegerZoom = l + 1, this.lastIntegerZoomTime = i) : this.lastFloorZoom < l && (this.lastIntegerZoom = l, this.lastIntegerZoomTime = i), r !== this.lastZoom && (this.lastZoom = r, this.lastFloorZoom = l, !0));
      };
      var ct = { "Latin-1 Supplement": function(r) {
        return r >= 128 && r <= 255;
      }, Arabic: function(r) {
        return r >= 1536 && r <= 1791;
      }, "Arabic Supplement": function(r) {
        return r >= 1872 && r <= 1919;
      }, "Arabic Extended-A": function(r) {
        return r >= 2208 && r <= 2303;
      }, "Hangul Jamo": function(r) {
        return r >= 4352 && r <= 4607;
      }, "Unified Canadian Aboriginal Syllabics": function(r) {
        return r >= 5120 && r <= 5759;
      }, Khmer: function(r) {
        return r >= 6016 && r <= 6143;
      }, "Unified Canadian Aboriginal Syllabics Extended": function(r) {
        return r >= 6320 && r <= 6399;
      }, "General Punctuation": function(r) {
        return r >= 8192 && r <= 8303;
      }, "Letterlike Symbols": function(r) {
        return r >= 8448 && r <= 8527;
      }, "Number Forms": function(r) {
        return r >= 8528 && r <= 8591;
      }, "Miscellaneous Technical": function(r) {
        return r >= 8960 && r <= 9215;
      }, "Control Pictures": function(r) {
        return r >= 9216 && r <= 9279;
      }, "Optical Character Recognition": function(r) {
        return r >= 9280 && r <= 9311;
      }, "Enclosed Alphanumerics": function(r) {
        return r >= 9312 && r <= 9471;
      }, "Geometric Shapes": function(r) {
        return r >= 9632 && r <= 9727;
      }, "Miscellaneous Symbols": function(r) {
        return r >= 9728 && r <= 9983;
      }, "Miscellaneous Symbols and Arrows": function(r) {
        return r >= 11008 && r <= 11263;
      }, "CJK Radicals Supplement": function(r) {
        return r >= 11904 && r <= 12031;
      }, "Kangxi Radicals": function(r) {
        return r >= 12032 && r <= 12255;
      }, "Ideographic Description Characters": function(r) {
        return r >= 12272 && r <= 12287;
      }, "CJK Symbols and Punctuation": function(r) {
        return r >= 12288 && r <= 12351;
      }, Hiragana: function(r) {
        return r >= 12352 && r <= 12447;
      }, Katakana: function(r) {
        return r >= 12448 && r <= 12543;
      }, Bopomofo: function(r) {
        return r >= 12544 && r <= 12591;
      }, "Hangul Compatibility Jamo": function(r) {
        return r >= 12592 && r <= 12687;
      }, Kanbun: function(r) {
        return r >= 12688 && r <= 12703;
      }, "Bopomofo Extended": function(r) {
        return r >= 12704 && r <= 12735;
      }, "CJK Strokes": function(r) {
        return r >= 12736 && r <= 12783;
      }, "Katakana Phonetic Extensions": function(r) {
        return r >= 12784 && r <= 12799;
      }, "Enclosed CJK Letters and Months": function(r) {
        return r >= 12800 && r <= 13055;
      }, "CJK Compatibility": function(r) {
        return r >= 13056 && r <= 13311;
      }, "CJK Unified Ideographs Extension A": function(r) {
        return r >= 13312 && r <= 19903;
      }, "Yijing Hexagram Symbols": function(r) {
        return r >= 19904 && r <= 19967;
      }, "CJK Unified Ideographs": function(r) {
        return r >= 19968 && r <= 40959;
      }, "Yi Syllables": function(r) {
        return r >= 40960 && r <= 42127;
      }, "Yi Radicals": function(r) {
        return r >= 42128 && r <= 42191;
      }, "Hangul Jamo Extended-A": function(r) {
        return r >= 43360 && r <= 43391;
      }, "Hangul Syllables": function(r) {
        return r >= 44032 && r <= 55215;
      }, "Hangul Jamo Extended-B": function(r) {
        return r >= 55216 && r <= 55295;
      }, "Private Use Area": function(r) {
        return r >= 57344 && r <= 63743;
      }, "CJK Compatibility Ideographs": function(r) {
        return r >= 63744 && r <= 64255;
      }, "Arabic Presentation Forms-A": function(r) {
        return r >= 64336 && r <= 65023;
      }, "Vertical Forms": function(r) {
        return r >= 65040 && r <= 65055;
      }, "CJK Compatibility Forms": function(r) {
        return r >= 65072 && r <= 65103;
      }, "Small Form Variants": function(r) {
        return r >= 65104 && r <= 65135;
      }, "Arabic Presentation Forms-B": function(r) {
        return r >= 65136 && r <= 65279;
      }, "Halfwidth and Fullwidth Forms": function(r) {
        return r >= 65280 && r <= 65519;
      } };
      function ap(r) {
        for (var i = 0, l = r; i < l.length; i += 1)
          if (xh(l[i].charCodeAt(0)))
            return !0;
        return !1;
      }
      function xh(r) {
        return !(r !== 746 && r !== 747 && (r < 4352 || !(ct["Bopomofo Extended"](r) || ct.Bopomofo(r) || ct["CJK Compatibility Forms"](r) && !(r >= 65097 && r <= 65103) || ct["CJK Compatibility Ideographs"](r) || ct["CJK Compatibility"](r) || ct["CJK Radicals Supplement"](r) || ct["CJK Strokes"](r) || !(!ct["CJK Symbols and Punctuation"](r) || r >= 12296 && r <= 12305 || r >= 12308 && r <= 12319 || r === 12336) || ct["CJK Unified Ideographs Extension A"](r) || ct["CJK Unified Ideographs"](r) || ct["Enclosed CJK Letters and Months"](r) || ct["Hangul Compatibility Jamo"](r) || ct["Hangul Jamo Extended-A"](r) || ct["Hangul Jamo Extended-B"](r) || ct["Hangul Jamo"](r) || ct["Hangul Syllables"](r) || ct.Hiragana(r) || ct["Ideographic Description Characters"](r) || ct.Kanbun(r) || ct["Kangxi Radicals"](r) || ct["Katakana Phonetic Extensions"](r) || ct.Katakana(r) && r !== 12540 || !(!ct["Halfwidth and Fullwidth Forms"](r) || r === 65288 || r === 65289 || r === 65293 || r >= 65306 && r <= 65310 || r === 65339 || r === 65341 || r === 65343 || r >= 65371 && r <= 65503 || r === 65507 || r >= 65512 && r <= 65519) || !(!ct["Small Form Variants"](r) || r >= 65112 && r <= 65118 || r >= 65123 && r <= 65126) || ct["Unified Canadian Aboriginal Syllabics"](r) || ct["Unified Canadian Aboriginal Syllabics Extended"](r) || ct["Vertical Forms"](r) || ct["Yijing Hexagram Symbols"](r) || ct["Yi Syllables"](r) || ct["Yi Radicals"](r))));
      }
      function sp(r) {
        return !(xh(r) || function(i) {
          return !!(ct["Latin-1 Supplement"](i) && (i === 167 || i === 169 || i === 174 || i === 177 || i === 188 || i === 189 || i === 190 || i === 215 || i === 247) || ct["General Punctuation"](i) && (i === 8214 || i === 8224 || i === 8225 || i === 8240 || i === 8241 || i === 8251 || i === 8252 || i === 8258 || i === 8263 || i === 8264 || i === 8265 || i === 8273) || ct["Letterlike Symbols"](i) || ct["Number Forms"](i) || ct["Miscellaneous Technical"](i) && (i >= 8960 && i <= 8967 || i >= 8972 && i <= 8991 || i >= 8996 && i <= 9e3 || i === 9003 || i >= 9085 && i <= 9114 || i >= 9150 && i <= 9165 || i === 9167 || i >= 9169 && i <= 9179 || i >= 9186 && i <= 9215) || ct["Control Pictures"](i) && i !== 9251 || ct["Optical Character Recognition"](i) || ct["Enclosed Alphanumerics"](i) || ct["Geometric Shapes"](i) || ct["Miscellaneous Symbols"](i) && !(i >= 9754 && i <= 9759) || ct["Miscellaneous Symbols and Arrows"](i) && (i >= 11026 && i <= 11055 || i >= 11088 && i <= 11097 || i >= 11192 && i <= 11243) || ct["CJK Symbols and Punctuation"](i) || ct.Katakana(i) || ct["Private Use Area"](i) || ct["CJK Compatibility Forms"](i) || ct["Small Form Variants"](i) || ct["Halfwidth and Fullwidth Forms"](i) || i === 8734 || i === 8756 || i === 8757 || i >= 9984 && i <= 10087 || i >= 10102 && i <= 10131 || i === 65532 || i === 65533);
        }(r));
      }
      function qo(r) {
        return r >= 1424 && r <= 2303 || ct["Arabic Presentation Forms-A"](r) || ct["Arabic Presentation Forms-B"](r);
      }
      function ho(r, i) {
        return !(!i && qo(r) || r >= 2304 && r <= 3583 || r >= 3840 && r <= 4255 || ct.Khmer(r));
      }
      function bh(r) {
        for (var i = 0, l = r; i < l.length; i += 1)
          if (qo(l[i].charCodeAt(0)))
            return !0;
        return !1;
      }
      var wh = null, fo = "unavailable", ja = null, Nm = function(r) {
        r && typeof r == "string" && r.indexOf("NetworkError") > -1 && (fo = "error"), wh && wh(r);
      };
      function uc() {
        lp.fire(new Q("pluginStateChange", { pluginStatus: fo, pluginURL: ja }));
      }
      var lp = new de(), up = function() {
        return fo;
      }, sa = function() {
        if (fo !== "deferred" || !ja)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        fo = "loading", uc(), ja && ol({ url: ja }, function(r) {
          r ? Nm(r) : (fo = "loaded", uc());
        });
      }, Io = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function() {
        return fo === "loaded" || Io.applyArabicShaping != null;
      }, isLoading: function() {
        return fo === "loading";
      }, setState: function(r) {
        fo = r.pluginStatus, ja = r.pluginURL;
      }, isParsed: function() {
        return Io.applyArabicShaping != null && Io.processBidirectionalText != null && Io.processStyledBidirectionalText != null;
      }, getPluginURL: function() {
        return ja;
      } }, mr = function(r, i) {
        this.zoom = r, i ? (this.now = i.now, this.fadeDuration = i.fadeDuration, this.zoomHistory = i.zoomHistory, this.transition = i.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new op(), this.transition = {});
      };
      mr.prototype.isSupportedScript = function(r) {
        return function(i, l) {
          for (var p = 0, y = i; p < y.length; p += 1)
            if (!ho(y[p].charCodeAt(0), l))
              return !1;
          return !0;
        }(r, Io.isLoaded());
      }, mr.prototype.crossFadingFactor = function() {
        return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
      }, mr.prototype.getCrossfadeParameters = function() {
        var r = this.zoom, i = r - Math.floor(r), l = this.crossFadingFactor();
        return r > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: i + (1 - i) * l } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - l) * i };
      };
      var ba = function(r, i) {
        this.property = r, this.value = i, this.expression = function(l, p) {
          if (hh(l))
            return new tu(l, p);
          if (ec(l)) {
            var y = Im(l, p);
            if (y.result === "error")
              throw new Error(y.value.map(function(x) {
                return x.key + ": " + x.message;
              }).join(", "));
            return y.value;
          }
          var v = l;
          return typeof l == "string" && p.type === "color" && (v = Fr.parse(l)), { kind: "constant", evaluate: function() {
            return v;
          } };
        }(i === void 0 ? r.specification.default : i, r.specification);
      };
      ba.prototype.isDataDriven = function() {
        return this.expression.kind === "source" || this.expression.kind === "composite";
      }, ba.prototype.possiblyEvaluate = function(r, i, l) {
        return this.property.possiblyEvaluate(this, r, i, l);
      };
      var Wo = function(r) {
        this.property = r, this.value = new ba(r, void 0);
      };
      Wo.prototype.transitioned = function(r, i) {
        return new xl(this.property, this.value, i, X({}, r.transition, this.transition), r.now);
      }, Wo.prototype.untransitioned = function() {
        return new xl(this.property, this.value, null, {}, 0);
      };
      var Mi = function(r) {
        this._properties = r, this._values = Object.create(r.defaultTransitionablePropertyValues);
      };
      Mi.prototype.getValue = function(r) {
        return Xe(this._values[r].value.value);
      }, Mi.prototype.setValue = function(r, i) {
        this._values.hasOwnProperty(r) || (this._values[r] = new Wo(this._values[r].property)), this._values[r].value = new ba(this._values[r].property, i === null ? void 0 : Xe(i));
      }, Mi.prototype.getTransition = function(r) {
        return Xe(this._values[r].transition);
      }, Mi.prototype.setTransition = function(r, i) {
        this._values.hasOwnProperty(r) || (this._values[r] = new Wo(this._values[r].property)), this._values[r].transition = Xe(i) || void 0;
      }, Mi.prototype.serialize = function() {
        for (var r = {}, i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i], y = this.getValue(p);
          y !== void 0 && (r[p] = y);
          var v = this.getTransition(p);
          v !== void 0 && (r[p + "-transition"] = v);
        }
        return r;
      }, Mi.prototype.transitioned = function(r, i) {
        for (var l = new Ss(this._properties), p = 0, y = Object.keys(this._values); p < y.length; p += 1) {
          var v = y[p];
          l._values[v] = this._values[v].transitioned(r, i._values[v]);
        }
        return l;
      }, Mi.prototype.untransitioned = function() {
        for (var r = new Ss(this._properties), i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i];
          r._values[p] = this._values[p].untransitioned();
        }
        return r;
      };
      var xl = function(r, i, l, p, y) {
        this.property = r, this.value = i, this.begin = y + p.delay || 0, this.end = this.begin + p.duration || 0, r.specification.transition && (p.delay || p.duration) && (this.prior = l);
      };
      xl.prototype.possiblyEvaluate = function(r, i, l) {
        var p = r.now || 0, y = this.value.possiblyEvaluate(r, i, l), v = this.prior;
        if (v) {
          if (p > this.end)
            return this.prior = null, y;
          if (this.value.isDataDriven())
            return this.prior = null, y;
          if (p < this.begin)
            return v.possiblyEvaluate(r, i, l);
          var x = (p - this.begin) / (this.end - this.begin);
          return this.property.interpolate(v.possiblyEvaluate(r, i, l), y, function(S) {
            if (S <= 0)
              return 0;
            if (S >= 1)
              return 1;
            var C = S * S, A = C * S;
            return 4 * (S < 0.5 ? A : 3 * (S - C) + A - 0.75);
          }(x));
        }
        return y;
      };
      var Ss = function(r) {
        this._properties = r, this._values = Object.create(r.defaultTransitioningPropertyValues);
      };
      Ss.prototype.possiblyEvaluate = function(r, i, l) {
        for (var p = new cc(this._properties), y = 0, v = Object.keys(this._values); y < v.length; y += 1) {
          var x = v[y];
          p._values[x] = this._values[x].possiblyEvaluate(r, i, l);
        }
        return p;
      }, Ss.prototype.hasTransition = function() {
        for (var r = 0, i = Object.keys(this._values); r < i.length; r += 1)
          if (this._values[i[r]].prior)
            return !0;
        return !1;
      };
      var la = function(r) {
        this._properties = r, this._values = Object.create(r.defaultPropertyValues);
      };
      la.prototype.getValue = function(r) {
        return Xe(this._values[r].value);
      }, la.prototype.setValue = function(r, i) {
        this._values[r] = new ba(this._values[r].property, i === null ? void 0 : Xe(i));
      }, la.prototype.serialize = function() {
        for (var r = {}, i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i], y = this.getValue(p);
          y !== void 0 && (r[p] = y);
        }
        return r;
      }, la.prototype.possiblyEvaluate = function(r, i, l) {
        for (var p = new cc(this._properties), y = 0, v = Object.keys(this._values); y < v.length; y += 1) {
          var x = v[y];
          p._values[x] = this._values[x].possiblyEvaluate(r, i, l);
        }
        return p;
      };
      var ji = function(r, i, l) {
        this.property = r, this.value = i, this.parameters = l;
      };
      ji.prototype.isConstant = function() {
        return this.value.kind === "constant";
      }, ji.prototype.constantOr = function(r) {
        return this.value.kind === "constant" ? this.value.value : r;
      }, ji.prototype.evaluate = function(r, i, l, p) {
        return this.property.evaluate(this.value, this.parameters, r, i, l, p);
      };
      var cc = function(r) {
        this._properties = r, this._values = Object.create(r.defaultPossiblyEvaluatedValues);
      };
      cc.prototype.get = function(r) {
        return this._values[r];
      };
      var Lt = function(r) {
        this.specification = r;
      };
      Lt.prototype.possiblyEvaluate = function(r, i) {
        return r.expression.evaluate(i);
      }, Lt.prototype.interpolate = function(r, i, l) {
        var p = Yl[this.specification.type];
        return p ? p(r, i, l) : r;
      };
      var Tt = function(r, i) {
        this.specification = r, this.overrides = i;
      };
      Tt.prototype.possiblyEvaluate = function(r, i, l, p) {
        return new ji(this, r.expression.kind === "constant" || r.expression.kind === "camera" ? { kind: "constant", value: r.expression.evaluate(i, null, {}, l, p) } : r.expression, i);
      }, Tt.prototype.interpolate = function(r, i, l) {
        if (r.value.kind !== "constant" || i.value.kind !== "constant")
          return r;
        if (r.value.value === void 0 || i.value.value === void 0)
          return new ji(this, { kind: "constant", value: void 0 }, r.parameters);
        var p = Yl[this.specification.type];
        return p ? new ji(this, { kind: "constant", value: p(r.value.value, i.value.value, l) }, r.parameters) : r;
      }, Tt.prototype.evaluate = function(r, i, l, p, y, v) {
        return r.kind === "constant" ? r.value : r.evaluate(i, l, p, y, v);
      };
      var Eh = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.possiblyEvaluate = function(l, p, y, v) {
          if (l.value === void 0)
            return new ji(this, { kind: "constant", value: void 0 }, p);
          if (l.expression.kind === "constant") {
            var x = l.expression.evaluate(p, null, {}, y, v), S = l.property.specification.type === "resolvedImage" && typeof x != "string" ? x.name : x, C = this._calculate(S, S, S, p);
            return new ji(this, { kind: "constant", value: C }, p);
          }
          if (l.expression.kind === "camera") {
            var A = this._calculate(l.expression.evaluate({ zoom: p.zoom - 1 }), l.expression.evaluate({ zoom: p.zoom }), l.expression.evaluate({ zoom: p.zoom + 1 }), p);
            return new ji(this, { kind: "constant", value: A }, p);
          }
          return new ji(this, l.expression, p);
        }, i.prototype.evaluate = function(l, p, y, v, x, S) {
          if (l.kind === "source") {
            var C = l.evaluate(p, y, v, x, S);
            return this._calculate(C, C, C, p);
          }
          return l.kind === "composite" ? this._calculate(l.evaluate({ zoom: Math.floor(p.zoom) - 1 }, y, v), l.evaluate({ zoom: Math.floor(p.zoom) }, y, v), l.evaluate({ zoom: Math.floor(p.zoom) + 1 }, y, v), p) : l.value;
        }, i.prototype._calculate = function(l, p, y, v) {
          return v.zoom > v.zoomHistory.lastIntegerZoom ? { from: l, to: p } : { from: y, to: p };
        }, i.prototype.interpolate = function(l) {
          return l;
        }, i;
      }(Tt), Gi = function(r) {
        this.specification = r;
      };
      Gi.prototype.possiblyEvaluate = function(r, i, l, p) {
        if (r.value !== void 0) {
          if (r.expression.kind === "constant") {
            var y = r.expression.evaluate(i, null, {}, l, p);
            return this._calculate(y, y, y, i);
          }
          return this._calculate(r.expression.evaluate(new mr(Math.floor(i.zoom - 1), i)), r.expression.evaluate(new mr(Math.floor(i.zoom), i)), r.expression.evaluate(new mr(Math.floor(i.zoom + 1), i)), i);
        }
      }, Gi.prototype._calculate = function(r, i, l, p) {
        return p.zoom > p.zoomHistory.lastIntegerZoom ? { from: r, to: i } : { from: l, to: i };
      }, Gi.prototype.interpolate = function(r) {
        return r;
      };
      var ua = function(r) {
        this.specification = r;
      };
      ua.prototype.possiblyEvaluate = function(r, i, l, p) {
        return !!r.expression.evaluate(i, null, {}, l, p);
      }, ua.prototype.interpolate = function() {
        return !1;
      };
      var Ii = function(r) {
        for (var i in this.properties = r, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], r) {
          var l = r[i];
          l.specification.overridable && this.overridableProperties.push(i);
          var p = this.defaultPropertyValues[i] = new ba(l, void 0), y = this.defaultTransitionablePropertyValues[i] = new Wo(l);
          this.defaultTransitioningPropertyValues[i] = y.untransitioned(), this.defaultPossiblyEvaluatedValues[i] = p.possiblyEvaluate({});
        }
      };
      wt("DataDrivenProperty", Tt), wt("DataConstantProperty", Lt), wt("CrossFadedDataDrivenProperty", Eh), wt("CrossFadedProperty", Gi), wt("ColorRampProperty", ua);
      var wa = function(r) {
        function i(l, p) {
          if (r.call(this), this.id = l.id, this.type = l.type, this._featureFilter = { filter: function() {
            return !0;
          }, needGeometry: !1 }, l.type !== "custom" && (this.metadata = (l = l).metadata, this.minzoom = l.minzoom, this.maxzoom = l.maxzoom, l.type !== "background" && (this.source = l.source, this.sourceLayer = l["source-layer"], this.filter = l.filter), p.layout && (this._unevaluatedLayout = new la(p.layout)), p.paint)) {
            for (var y in this._transitionablePaint = new Mi(p.paint), l.paint)
              this.setPaintProperty(y, l.paint[y], { validate: !1 });
            for (var v in l.layout)
              this.setLayoutProperty(v, l.layout[v], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new cc(p.paint);
          }
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getCrossfadeParameters = function() {
          return this._crossfadeParameters;
        }, i.prototype.getLayoutProperty = function(l) {
          return l === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(l);
        }, i.prototype.setLayoutProperty = function(l, p, y) {
          y === void 0 && (y = {}), p != null && this._validate(ac, "layers." + this.id + ".layout." + l, l, p, y) || (l !== "visibility" ? this._unevaluatedLayout.setValue(l, p) : this.visibility = p);
        }, i.prototype.getPaintProperty = function(l) {
          return Pe(l, "-transition") ? this._transitionablePaint.getTransition(l.slice(0, -11)) : this._transitionablePaint.getValue(l);
        }, i.prototype.setPaintProperty = function(l, p, y) {
          if (y === void 0 && (y = {}), p != null && this._validate(Kv, "layers." + this.id + ".paint." + l, l, p, y))
            return !1;
          if (Pe(l, "-transition"))
            return this._transitionablePaint.setTransition(l.slice(0, -11), p || void 0), !1;
          var v = this._transitionablePaint._values[l], x = v.property.specification["property-type"] === "cross-faded-data-driven", S = v.value.isDataDriven(), C = v.value;
          this._transitionablePaint.setValue(l, p), this._handleSpecialPaintPropertyUpdate(l);
          var A = this._transitionablePaint._values[l].value;
          return A.isDataDriven() || S || x || this._handleOverridablePaintPropertyUpdate(l, C, A);
        }, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
        }, i.prototype._handleOverridablePaintPropertyUpdate = function(l, p, y) {
          return !1;
        }, i.prototype.isHidden = function(l) {
          return !!(this.minzoom && l < this.minzoom) || !!(this.maxzoom && l >= this.maxzoom) || this.visibility === "none";
        }, i.prototype.updateTransitions = function(l) {
          this._transitioningPaint = this._transitionablePaint.transitioned(l, this._transitioningPaint);
        }, i.prototype.hasTransition = function() {
          return this._transitioningPaint.hasTransition();
        }, i.prototype.recalculate = function(l, p) {
          l.getCrossfadeParameters && (this._crossfadeParameters = l.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(l, void 0, p)), this.paint = this._transitioningPaint.possiblyEvaluate(l, void 0, p);
        }, i.prototype.serialize = function() {
          var l = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (l.layout = l.layout || {}, l.layout.visibility = this.visibility), Ie(l, function(p, y) {
            return !(p === void 0 || y === "layout" && !Object.keys(p).length || y === "paint" && !Object.keys(p).length);
          });
        }, i.prototype._validate = function(l, p, y, v, x) {
          return x === void 0 && (x = {}), (!x || x.validate !== !1) && sc(this, l.call(oc, { key: p, layerType: this.type, objectKey: y, value: v, styleSpec: G, style: { glyphs: !0, sprite: !0 } }));
        }, i.prototype.is3D = function() {
          return !1;
        }, i.prototype.isTileClipped = function() {
          return !1;
        }, i.prototype.hasOffscreenPass = function() {
          return !1;
        }, i.prototype.resize = function() {
        }, i.prototype.isStateDependent = function() {
          for (var l in this.paint._values) {
            var p = this.paint.get(l);
            if (p instanceof ji && yl(p.property.specification) && (p.value.kind === "source" || p.value.kind === "composite") && p.value.isStateDependent)
              return !0;
          }
          return !1;
        }, i;
      }(de), cp = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, Sh = function(r, i) {
        this._structArray = r, this._pos1 = i * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
      }, Gr = function() {
        this.isTransferred = !1, this.capacity = -1, this.resize(0);
      };
      function yi(r, i) {
        i === void 0 && (i = 1);
        var l = 0, p = 0;
        return { members: r.map(function(y) {
          var v = cp[y.type].BYTES_PER_ELEMENT, x = l = Rm(l, Math.max(i, v)), S = y.components || 1;
          return p = Math.max(p, v), l += v * S, { name: y.name, type: y.type, components: S, offset: x };
        }), size: Rm(l, Math.max(p, i)), alignment: i };
      }
      function Rm(r, i) {
        return Math.ceil(r / i) * i;
      }
      Gr.serialize = function(r, i) {
        return r._trim(), i && (r.isTransferred = !0, i.push(r.arrayBuffer)), { length: r.length, arrayBuffer: r.arrayBuffer };
      }, Gr.deserialize = function(r) {
        var i = Object.create(this.prototype);
        return i.arrayBuffer = r.arrayBuffer, i.length = r.length, i.capacity = r.arrayBuffer.byteLength / i.bytesPerElement, i._refreshViews(), i;
      }, Gr.prototype._trim = function() {
        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
      }, Gr.prototype.clear = function() {
        this.length = 0;
      }, Gr.prototype.resize = function(r) {
        this.reserve(r), this.length = r;
      }, Gr.prototype.reserve = function(r) {
        if (r > this.capacity) {
          this.capacity = Math.max(r, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
          var i = this.uint8;
          this._refreshViews(), i && this.uint8.set(i);
        }
      }, Gr.prototype._refreshViews = function() {
        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
      };
      var bl = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.int16[v + 0] = p, this.int16[v + 1] = y, l;
        }, i;
      }(Gr);
      bl.prototype.bytesPerElement = 4, wt("StructArrayLayout2i4", bl);
      var hp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 4 * l;
          return this.int16[S + 0] = p, this.int16[S + 1] = y, this.int16[S + 2] = v, this.int16[S + 3] = x, l;
        }, i;
      }(Gr);
      hp.prototype.bytesPerElement = 8, wt("StructArrayLayout4i8", hp);
      var Ga = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var A = 6 * l;
          return this.int16[A + 0] = p, this.int16[A + 1] = y, this.int16[A + 2] = v, this.int16[A + 3] = x, this.int16[A + 4] = S, this.int16[A + 5] = C, l;
        }, i;
      }(Gr);
      Ga.prototype.bytesPerElement = 12, wt("StructArrayLayout2i4i12", Ga);
      var po = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var A = 4 * l, L = 8 * l;
          return this.int16[A + 0] = p, this.int16[A + 1] = y, this.uint8[L + 4] = v, this.uint8[L + 5] = x, this.uint8[L + 6] = S, this.uint8[L + 7] = C, l;
        }, i;
      }(Gr);
      po.prototype.bytesPerElement = 8, wt("StructArrayLayout2i4ub8", po);
      var iu = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.float32[v + 0] = p, this.float32[v + 1] = y, l;
        }, i;
      }(Gr);
      iu.prototype.bytesPerElement = 8, wt("StructArrayLayout2f8", iu);
      var Ea = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, A, L, D) {
          var B = this.length;
          return this.resize(B + 1), this.emplace(B, l, p, y, v, x, S, C, A, L, D);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, A, L, D, B) {
          var j = 10 * l;
          return this.uint16[j + 0] = p, this.uint16[j + 1] = y, this.uint16[j + 2] = v, this.uint16[j + 3] = x, this.uint16[j + 4] = S, this.uint16[j + 5] = C, this.uint16[j + 6] = A, this.uint16[j + 7] = L, this.uint16[j + 8] = D, this.uint16[j + 9] = B, l;
        }, i;
      }(Gr);
      Ea.prototype.bytesPerElement = 20, wt("StructArrayLayout10ui20", Ea);
      var Th = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, A, L, D, B, j) {
          var J = this.length;
          return this.resize(J + 1), this.emplace(J, l, p, y, v, x, S, C, A, L, D, B, j);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, A, L, D, B, j, J) {
          var ee = 12 * l;
          return this.int16[ee + 0] = p, this.int16[ee + 1] = y, this.int16[ee + 2] = v, this.int16[ee + 3] = x, this.uint16[ee + 4] = S, this.uint16[ee + 5] = C, this.uint16[ee + 6] = A, this.uint16[ee + 7] = L, this.int16[ee + 8] = D, this.int16[ee + 9] = B, this.int16[ee + 10] = j, this.int16[ee + 11] = J, l;
        }, i;
      }(Gr);
      Th.prototype.bytesPerElement = 24, wt("StructArrayLayout4i4ui4i24", Th);
      var ou = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.float32[x + 0] = p, this.float32[x + 1] = y, this.float32[x + 2] = v, l;
        }, i;
      }(Gr);
      ou.prototype.bytesPerElement = 12, wt("StructArrayLayout3f12", ou);
      var hc = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.uint32[1 * l + 0] = p, l;
        }, i;
      }(Gr);
      hc.prototype.bytesPerElement = 4, wt("StructArrayLayout1ul4", hc);
      var fp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, A, L) {
          var D = this.length;
          return this.resize(D + 1), this.emplace(D, l, p, y, v, x, S, C, A, L);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, A, L, D) {
          var B = 10 * l, j = 5 * l;
          return this.int16[B + 0] = p, this.int16[B + 1] = y, this.int16[B + 2] = v, this.int16[B + 3] = x, this.int16[B + 4] = S, this.int16[B + 5] = C, this.uint32[j + 3] = A, this.uint16[B + 8] = L, this.uint16[B + 9] = D, l;
        }, i;
      }(Gr);
      fp.prototype.bytesPerElement = 20, wt("StructArrayLayout6i1ul2ui20", fp);
      var au = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var A = 6 * l;
          return this.int16[A + 0] = p, this.int16[A + 1] = y, this.int16[A + 2] = v, this.int16[A + 3] = x, this.int16[A + 4] = S, this.int16[A + 5] = C, l;
        }, i;
      }(Gr);
      au.prototype.bytesPerElement = 12, wt("StructArrayLayout2i2i2i12", au);
      var wl = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x) {
          var S = this.length;
          return this.resize(S + 1), this.emplace(S, l, p, y, v, x);
        }, i.prototype.emplace = function(l, p, y, v, x, S) {
          var C = 4 * l, A = 8 * l;
          return this.float32[C + 0] = p, this.float32[C + 1] = y, this.float32[C + 2] = v, this.int16[A + 6] = x, this.int16[A + 7] = S, l;
        }, i;
      }(Gr);
      wl.prototype.bytesPerElement = 16, wt("StructArrayLayout2f1f2i16", wl);
      var pp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 12 * l, C = 3 * l;
          return this.uint8[S + 0] = p, this.uint8[S + 1] = y, this.float32[C + 1] = v, this.float32[C + 2] = x, l;
        }, i;
      }(Gr);
      pp.prototype.bytesPerElement = 12, wt("StructArrayLayout2ub2f12", pp);
      var Ts = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.uint16[x + 0] = p, this.uint16[x + 1] = y, this.uint16[x + 2] = v, l;
        }, i;
      }(Gr);
      Ts.prototype.bytesPerElement = 6, wt("StructArrayLayout3ui6", Ts);
      var Ms = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, A, L, D, B, j, J, ee, he, oe, ge) {
          var we = this.length;
          return this.resize(we + 1), this.emplace(we, l, p, y, v, x, S, C, A, L, D, B, j, J, ee, he, oe, ge);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, A, L, D, B, j, J, ee, he, oe, ge, we) {
          var Te = 24 * l, Oe = 12 * l, Be = 48 * l;
          return this.int16[Te + 0] = p, this.int16[Te + 1] = y, this.uint16[Te + 2] = v, this.uint16[Te + 3] = x, this.uint32[Oe + 2] = S, this.uint32[Oe + 3] = C, this.uint32[Oe + 4] = A, this.uint16[Te + 10] = L, this.uint16[Te + 11] = D, this.uint16[Te + 12] = B, this.float32[Oe + 7] = j, this.float32[Oe + 8] = J, this.uint8[Be + 36] = ee, this.uint8[Be + 37] = he, this.uint8[Be + 38] = oe, this.uint32[Oe + 10] = ge, this.int16[Te + 22] = we, l;
        }, i;
      }(Gr);
      Ms.prototype.bytesPerElement = 48, wt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ms);
      var Mh = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, A, L, D, B, j, J, ee, he, oe, ge, we, Te, Oe, Be, Ke, ot, At, dt, Nt, yt, sr) {
          var qt = this.length;
          return this.resize(qt + 1), this.emplace(qt, l, p, y, v, x, S, C, A, L, D, B, j, J, ee, he, oe, ge, we, Te, Oe, Be, Ke, ot, At, dt, Nt, yt, sr);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, A, L, D, B, j, J, ee, he, oe, ge, we, Te, Oe, Be, Ke, ot, At, dt, Nt, yt, sr, qt) {
          var Mt = 34 * l, fr = 17 * l;
          return this.int16[Mt + 0] = p, this.int16[Mt + 1] = y, this.int16[Mt + 2] = v, this.int16[Mt + 3] = x, this.int16[Mt + 4] = S, this.int16[Mt + 5] = C, this.int16[Mt + 6] = A, this.int16[Mt + 7] = L, this.uint16[Mt + 8] = D, this.uint16[Mt + 9] = B, this.uint16[Mt + 10] = j, this.uint16[Mt + 11] = J, this.uint16[Mt + 12] = ee, this.uint16[Mt + 13] = he, this.uint16[Mt + 14] = oe, this.uint16[Mt + 15] = ge, this.uint16[Mt + 16] = we, this.uint16[Mt + 17] = Te, this.uint16[Mt + 18] = Oe, this.uint16[Mt + 19] = Be, this.uint16[Mt + 20] = Ke, this.uint16[Mt + 21] = ot, this.uint16[Mt + 22] = At, this.uint32[fr + 12] = dt, this.float32[fr + 13] = Nt, this.float32[fr + 14] = yt, this.float32[fr + 15] = sr, this.float32[fr + 16] = qt, l;
        }, i;
      }(Gr);
      Mh.prototype.bytesPerElement = 68, wt("StructArrayLayout8i15ui1ul4f68", Mh);
      var Is = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.float32[1 * l + 0] = p, l;
        }, i;
      }(Gr);
      Is.prototype.bytesPerElement = 4, wt("StructArrayLayout1f4", Is);
      var Ho = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.int16[x + 0] = p, this.int16[x + 1] = y, this.int16[x + 2] = v, l;
        }, i;
      }(Gr);
      Ho.prototype.bytesPerElement = 6, wt("StructArrayLayout3i6", Ho);
      var dp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 4 * l;
          return this.uint32[2 * l + 0] = p, this.uint16[x + 2] = y, this.uint16[x + 3] = v, l;
        }, i;
      }(Gr);
      dp.prototype.bytesPerElement = 8, wt("StructArrayLayout1ul2ui8", dp);
      var fc = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.uint16[v + 0] = p, this.uint16[v + 1] = y, l;
        }, i;
      }(Gr);
      fc.prototype.bytesPerElement = 4, wt("StructArrayLayout2ui4", fc);
      var mp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.uint16[1 * l + 0] = p, l;
        }, i;
      }(Gr);
      mp.prototype.bytesPerElement = 2, wt("StructArrayLayout1ui2", mp);
      var Ih = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 4 * l;
          return this.float32[S + 0] = p, this.float32[S + 1] = y, this.float32[S + 2] = v, this.float32[S + 3] = x, l;
        }, i;
      }(Gr);
      Ih.prototype.bytesPerElement = 16, wt("StructArrayLayout4f16", Ih);
      var u = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorPointX: { configurable: !0 }, anchorPointY: { configurable: !0 }, x1: { configurable: !0 }, y1: { configurable: !0 }, x2: { configurable: !0 }, y2: { configurable: !0 }, featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 }, anchorPoint: { configurable: !0 } };
        return l.anchorPointX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorPointY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.x1.get = function() {
          return this._structArray.int16[this._pos2 + 2];
        }, l.y1.get = function() {
          return this._structArray.int16[this._pos2 + 3];
        }, l.x2.get = function() {
          return this._structArray.int16[this._pos2 + 4];
        }, l.y2.get = function() {
          return this._structArray.int16[this._pos2 + 5];
        }, l.featureIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 3];
        }, l.sourceLayerIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 8];
        }, l.bucketIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 9];
        }, l.anchorPoint.get = function() {
          return new T(this.anchorPointX, this.anchorPointY);
        }, Object.defineProperties(i.prototype, l), i;
      }(Sh);
      u.prototype.size = 20;
      var f = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new u(this, l);
        }, i;
      }(fp);
      wt("CollisionBoxArray", f);
      var c = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, glyphStartIndex: { configurable: !0 }, numGlyphs: { configurable: !0 }, vertexStartIndex: { configurable: !0 }, lineStartIndex: { configurable: !0 }, lineLength: { configurable: !0 }, segment: { configurable: !0 }, lowerSize: { configurable: !0 }, upperSize: { configurable: !0 }, lineOffsetX: { configurable: !0 }, lineOffsetY: { configurable: !0 }, writingMode: { configurable: !0 }, placedOrientation: { configurable: !0 }, hidden: { configurable: !0 }, crossTileID: { configurable: !0 }, associatedIconIndex: { configurable: !0 } };
        return l.anchorX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.glyphStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 2];
        }, l.numGlyphs.get = function() {
          return this._structArray.uint16[this._pos2 + 3];
        }, l.vertexStartIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 2];
        }, l.lineStartIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 3];
        }, l.lineLength.get = function() {
          return this._structArray.uint32[this._pos4 + 4];
        }, l.segment.get = function() {
          return this._structArray.uint16[this._pos2 + 10];
        }, l.lowerSize.get = function() {
          return this._structArray.uint16[this._pos2 + 11];
        }, l.upperSize.get = function() {
          return this._structArray.uint16[this._pos2 + 12];
        }, l.lineOffsetX.get = function() {
          return this._structArray.float32[this._pos4 + 7];
        }, l.lineOffsetY.get = function() {
          return this._structArray.float32[this._pos4 + 8];
        }, l.writingMode.get = function() {
          return this._structArray.uint8[this._pos1 + 36];
        }, l.placedOrientation.get = function() {
          return this._structArray.uint8[this._pos1 + 37];
        }, l.placedOrientation.set = function(p) {
          this._structArray.uint8[this._pos1 + 37] = p;
        }, l.hidden.get = function() {
          return this._structArray.uint8[this._pos1 + 38];
        }, l.hidden.set = function(p) {
          this._structArray.uint8[this._pos1 + 38] = p;
        }, l.crossTileID.get = function() {
          return this._structArray.uint32[this._pos4 + 10];
        }, l.crossTileID.set = function(p) {
          this._structArray.uint32[this._pos4 + 10] = p;
        }, l.associatedIconIndex.get = function() {
          return this._structArray.int16[this._pos2 + 22];
        }, Object.defineProperties(i.prototype, l), i;
      }(Sh);
      c.prototype.size = 48;
      var d = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new c(this, l);
        }, i;
      }(Ms);
      wt("PlacedSymbolArray", d);
      var _ = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, rightJustifiedTextSymbolIndex: { configurable: !0 }, centerJustifiedTextSymbolIndex: { configurable: !0 }, leftJustifiedTextSymbolIndex: { configurable: !0 }, verticalPlacedTextSymbolIndex: { configurable: !0 }, placedIconSymbolIndex: { configurable: !0 }, verticalPlacedIconSymbolIndex: { configurable: !0 }, key: { configurable: !0 }, textBoxStartIndex: { configurable: !0 }, textBoxEndIndex: { configurable: !0 }, verticalTextBoxStartIndex: { configurable: !0 }, verticalTextBoxEndIndex: { configurable: !0 }, iconBoxStartIndex: { configurable: !0 }, iconBoxEndIndex: { configurable: !0 }, verticalIconBoxStartIndex: { configurable: !0 }, verticalIconBoxEndIndex: { configurable: !0 }, featureIndex: { configurable: !0 }, numHorizontalGlyphVertices: { configurable: !0 }, numVerticalGlyphVertices: { configurable: !0 }, numIconVertices: { configurable: !0 }, numVerticalIconVertices: { configurable: !0 }, useRuntimeCollisionCircles: { configurable: !0 }, crossTileID: { configurable: !0 }, textBoxScale: { configurable: !0 }, textOffset0: { configurable: !0 }, textOffset1: { configurable: !0 }, collisionCircleDiameter: { configurable: !0 } };
        return l.anchorX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.rightJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 2];
        }, l.centerJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 3];
        }, l.leftJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 4];
        }, l.verticalPlacedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 5];
        }, l.placedIconSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 6];
        }, l.verticalPlacedIconSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 7];
        }, l.key.get = function() {
          return this._structArray.uint16[this._pos2 + 8];
        }, l.textBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 9];
        }, l.textBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 10];
        }, l.verticalTextBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 11];
        }, l.verticalTextBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 12];
        }, l.iconBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 13];
        }, l.iconBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 14];
        }, l.verticalIconBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 15];
        }, l.verticalIconBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 16];
        }, l.featureIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 17];
        }, l.numHorizontalGlyphVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 18];
        }, l.numVerticalGlyphVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 19];
        }, l.numIconVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 20];
        }, l.numVerticalIconVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 21];
        }, l.useRuntimeCollisionCircles.get = function() {
          return this._structArray.uint16[this._pos2 + 22];
        }, l.crossTileID.get = function() {
          return this._structArray.uint32[this._pos4 + 12];
        }, l.crossTileID.set = function(p) {
          this._structArray.uint32[this._pos4 + 12] = p;
        }, l.textBoxScale.get = function() {
          return this._structArray.float32[this._pos4 + 13];
        }, l.textOffset0.get = function() {
          return this._structArray.float32[this._pos4 + 14];
        }, l.textOffset1.get = function() {
          return this._structArray.float32[this._pos4 + 15];
        }, l.collisionCircleDiameter.get = function() {
          return this._structArray.float32[this._pos4 + 16];
        }, Object.defineProperties(i.prototype, l), i;
      }(Sh);
      _.prototype.size = 68;
      var w = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new _(this, l);
        }, i;
      }(Mh);
      wt("SymbolInstanceArray", w);
      var E = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getoffsetX = function(l) {
          return this.float32[1 * l + 0];
        }, i;
      }(Is);
      wt("GlyphOffsetArray", E);
      var O = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getx = function(l) {
          return this.int16[3 * l + 0];
        }, i.prototype.gety = function(l) {
          return this.int16[3 * l + 1];
        }, i.prototype.gettileUnitDistanceFromAnchor = function(l) {
          return this.int16[3 * l + 2];
        }, i;
      }(Ho);
      wt("SymbolLineVertexArray", O);
      var k = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 } };
        return l.featureIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 0];
        }, l.sourceLayerIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 2];
        }, l.bucketIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 3];
        }, Object.defineProperties(i.prototype, l), i;
      }(Sh);
      k.prototype.size = 8;
      var R = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new k(this, l);
        }, i;
      }(dp);
      wt("FeatureIndexArray", R);
      var $ = yi([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, W = function(r) {
        r === void 0 && (r = []), this.segments = r;
      };
      function H(r, i) {
        return 256 * (r = q(Math.floor(r), 0, 255)) + q(Math.floor(i), 0, 255);
      }
      W.prototype.prepareSegment = function(r, i, l, p) {
        var y = this.segments[this.segments.length - 1];
        return r > W.MAX_VERTEX_ARRAY_LENGTH && at("Max vertices per segment is " + W.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + r), (!y || y.vertexLength + r > W.MAX_VERTEX_ARRAY_LENGTH || y.sortKey !== p) && (y = { vertexOffset: i.length, primitiveOffset: l.length, vertexLength: 0, primitiveLength: 0 }, p !== void 0 && (y.sortKey = p), this.segments.push(y)), y;
      }, W.prototype.get = function() {
        return this.segments;
      }, W.prototype.destroy = function() {
        for (var r = 0, i = this.segments; r < i.length; r += 1) {
          var l = i[r];
          for (var p in l.vaos)
            l.vaos[p].destroy();
        }
      }, W.simpleSegment = function(r, i, l, p) {
        return new W([{ vertexOffset: r, primitiveOffset: i, vertexLength: l, primitiveLength: p, vaos: {}, sortKey: 0 }]);
      }, W.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, wt("SegmentVector", W);
      var ne = yi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), te = m(function(r) {
        r.exports = function(i, l) {
          var p, y, v, x, S, C, A, L;
          for (y = i.length - (p = 3 & i.length), v = l, S = 3432918353, C = 461845907, L = 0; L < y; )
            A = 255 & i.charCodeAt(L) | (255 & i.charCodeAt(++L)) << 8 | (255 & i.charCodeAt(++L)) << 16 | (255 & i.charCodeAt(++L)) << 24, ++L, v = 27492 + (65535 & (x = 5 * (65535 & (v = (v ^= A = (65535 & (A = (A = (65535 & A) * S + (((A >>> 16) * S & 65535) << 16) & 4294967295) << 15 | A >>> 17)) * C + (((A >>> 16) * C & 65535) << 16) & 4294967295) << 13 | v >>> 19)) + ((5 * (v >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (x >>> 16) & 65535) << 16);
          switch (A = 0, p) {
            case 3:
              A ^= (255 & i.charCodeAt(L + 2)) << 16;
            case 2:
              A ^= (255 & i.charCodeAt(L + 1)) << 8;
            case 1:
              v ^= A = (65535 & (A = (A = (65535 & (A ^= 255 & i.charCodeAt(L))) * S + (((A >>> 16) * S & 65535) << 16) & 4294967295) << 15 | A >>> 17)) * C + (((A >>> 16) * C & 65535) << 16) & 4294967295;
          }
          return v ^= i.length, v = 2246822507 * (65535 & (v ^= v >>> 16)) + ((2246822507 * (v >>> 16) & 65535) << 16) & 4294967295, v = 3266489909 * (65535 & (v ^= v >>> 13)) + ((3266489909 * (v >>> 16) & 65535) << 16) & 4294967295, (v ^= v >>> 16) >>> 0;
        };
      }), ue = m(function(r) {
        r.exports = function(i, l) {
          for (var p, y = i.length, v = l ^ y, x = 0; y >= 4; )
            p = 1540483477 * (65535 & (p = 255 & i.charCodeAt(x) | (255 & i.charCodeAt(++x)) << 8 | (255 & i.charCodeAt(++x)) << 16 | (255 & i.charCodeAt(++x)) << 24)) + ((1540483477 * (p >>> 16) & 65535) << 16), v = 1540483477 * (65535 & v) + ((1540483477 * (v >>> 16) & 65535) << 16) ^ (p = 1540483477 * (65535 & (p ^= p >>> 24)) + ((1540483477 * (p >>> 16) & 65535) << 16)), y -= 4, ++x;
          switch (y) {
            case 3:
              v ^= (255 & i.charCodeAt(x + 2)) << 16;
            case 2:
              v ^= (255 & i.charCodeAt(x + 1)) << 8;
            case 1:
              v = 1540483477 * (65535 & (v ^= 255 & i.charCodeAt(x))) + ((1540483477 * (v >>> 16) & 65535) << 16);
          }
          return v = 1540483477 * (65535 & (v ^= v >>> 13)) + ((1540483477 * (v >>> 16) & 65535) << 16), (v ^= v >>> 15) >>> 0;
        };
      }), Y = te, le = ue;
      Y.murmur3 = te, Y.murmur2 = le;
      var me = function() {
        this.ids = [], this.positions = [], this.indexed = !1;
      };
      me.prototype.add = function(r, i, l, p) {
        this.ids.push(Ae(r)), this.positions.push(i, l, p);
      }, me.prototype.getPositions = function(r) {
        for (var i = Ae(r), l = 0, p = this.ids.length - 1; l < p; ) {
          var y = l + p >> 1;
          this.ids[y] >= i ? p = y : l = y + 1;
        }
        for (var v = []; this.ids[l] === i; )
          v.push({ index: this.positions[3 * l], start: this.positions[3 * l + 1], end: this.positions[3 * l + 2] }), l++;
        return v;
      }, me.serialize = function(r, i) {
        var l = new Float64Array(r.ids), p = new Uint32Array(r.positions);
        return function y(v, x, S, C) {
          for (; S < C; ) {
            for (var A = v[S + C >> 1], L = S - 1, D = C + 1; ; ) {
              do
                L++;
              while (v[L] < A);
              do
                D--;
              while (v[D] > A);
              if (L >= D)
                break;
              Me(v, L, D), Me(x, 3 * L, 3 * D), Me(x, 3 * L + 1, 3 * D + 1), Me(x, 3 * L + 2, 3 * D + 2);
            }
            D - S < C - D ? (y(v, x, S, D), S = D + 1) : (y(v, x, D + 1, C), C = D);
          }
        }(l, p, 0, l.length - 1), i && i.push(l.buffer, p.buffer), { ids: l, positions: p };
      }, me.deserialize = function(r) {
        var i = new me();
        return i.ids = r.ids, i.positions = r.positions, i.indexed = !0, i;
      };
      var xe = Math.pow(2, 53) - 1;
      function Ae(r) {
        var i = +r;
        return !isNaN(i) && i <= xe ? i : Y(String(r));
      }
      function Me(r, i, l) {
        var p = r[i];
        r[i] = r[l], r[l] = p;
      }
      wt("FeaturePositionMap", me);
      var ke = function(r, i) {
        this.gl = r.gl, this.location = i;
      }, je = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          this.current !== l && (this.current = l, this.gl.uniform1i(this.location, l));
        }, i;
      }(ke), nt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          this.current !== l && (this.current = l, this.gl.uniform1f(this.location, l));
        }, i;
      }(ke), tt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] || (this.current = l, this.gl.uniform2f(this.location, l[0], l[1]));
        }, i;
      }(ke), gt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] && l[2] === this.current[2] || (this.current = l, this.gl.uniform3f(this.location, l[0], l[1], l[2]));
        }, i;
      }(ke), Dt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0, 0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] && l[2] === this.current[2] && l[3] === this.current[3] || (this.current = l, this.gl.uniform4f(this.location, l[0], l[1], l[2], l[3]));
        }, i;
      }(ke), Bt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = Fr.transparent;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l.r === this.current.r && l.g === this.current.g && l.b === this.current.b && l.a === this.current.a || (this.current = l, this.gl.uniform4f(this.location, l.r, l.g, l.b, l.a));
        }, i;
      }(ke), zt = new Float32Array(16), Ir = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = zt;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          if (l[12] !== this.current[12] || l[0] !== this.current[0])
            return this.current = l, void this.gl.uniformMatrix4fv(this.location, !1, l);
          for (var p = 1; p < 16; p++)
            if (l[p] !== this.current[p]) {
              this.current = l, this.gl.uniformMatrix4fv(this.location, !1, l);
              break;
            }
        }, i;
      }(ke);
      function xt(r) {
        return [H(255 * r.r, 255 * r.g), H(255 * r.b, 255 * r.a)];
      }
      var Yt = function(r, i, l) {
        this.value = r, this.uniformNames = i.map(function(p) {
          return "u_" + p;
        }), this.type = l;
      };
      Yt.prototype.setUniform = function(r, i, l) {
        r.set(l.constantOr(this.value));
      }, Yt.prototype.getBinding = function(r, i, l) {
        return this.type === "color" ? new Bt(r, i) : new nt(r, i);
      };
      var ir = function(r, i) {
        this.uniformNames = i.map(function(l) {
          return "u_" + l;
        }), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
      };
      ir.prototype.setConstantPatternPositions = function(r, i) {
        this.pixelRatioFrom = i.pixelRatio, this.pixelRatioTo = r.pixelRatio, this.patternFrom = i.tlbr, this.patternTo = r.tlbr;
      }, ir.prototype.setUniform = function(r, i, l, p) {
        var y = p === "u_pattern_to" ? this.patternTo : p === "u_pattern_from" ? this.patternFrom : p === "u_pixel_ratio_to" ? this.pixelRatioTo : p === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
        y && r.set(y);
      }, ir.prototype.getBinding = function(r, i, l) {
        return l.substr(0, 9) === "u_pattern" ? new Dt(r, i) : new nt(r, i);
      };
      var Kt = function(r, i, l, p) {
        this.expression = r, this.type = l, this.maxValue = 0, this.paintVertexAttributes = i.map(function(y) {
          return { name: "a_" + y, type: "Float32", components: l === "color" ? 2 : 1, offset: 0 };
        }), this.paintVertexArray = new p();
      };
      Kt.prototype.populatePaintArray = function(r, i, l, p, y) {
        var v = this.paintVertexArray.length, x = this.expression.evaluate(new mr(0), i, {}, p, [], y);
        this.paintVertexArray.resize(r), this._setPaintValue(v, r, x);
      }, Kt.prototype.updatePaintArray = function(r, i, l, p) {
        var y = this.expression.evaluate({ zoom: 0 }, l, p);
        this._setPaintValue(r, i, y);
      }, Kt.prototype._setPaintValue = function(r, i, l) {
        if (this.type === "color")
          for (var p = xt(l), y = r; y < i; y++)
            this.paintVertexArray.emplace(y, p[0], p[1]);
        else {
          for (var v = r; v < i; v++)
            this.paintVertexArray.emplace(v, l);
          this.maxValue = Math.max(this.maxValue, Math.abs(l));
        }
      }, Kt.prototype.upload = function(r) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = r.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }, Kt.prototype.destroy = function() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      };
      var Xt = function(r, i, l, p, y, v) {
        this.expression = r, this.uniformNames = i.map(function(x) {
          return "u_" + x + "_t";
        }), this.type = l, this.useIntegerZoom = p, this.zoom = y, this.maxValue = 0, this.paintVertexAttributes = i.map(function(x) {
          return { name: "a_" + x, type: "Float32", components: l === "color" ? 4 : 2, offset: 0 };
        }), this.paintVertexArray = new v();
      };
      Xt.prototype.populatePaintArray = function(r, i, l, p, y) {
        var v = this.expression.evaluate(new mr(this.zoom), i, {}, p, [], y), x = this.expression.evaluate(new mr(this.zoom + 1), i, {}, p, [], y), S = this.paintVertexArray.length;
        this.paintVertexArray.resize(r), this._setPaintValue(S, r, v, x);
      }, Xt.prototype.updatePaintArray = function(r, i, l, p) {
        var y = this.expression.evaluate({ zoom: this.zoom }, l, p), v = this.expression.evaluate({ zoom: this.zoom + 1 }, l, p);
        this._setPaintValue(r, i, y, v);
      }, Xt.prototype._setPaintValue = function(r, i, l, p) {
        if (this.type === "color")
          for (var y = xt(l), v = xt(p), x = r; x < i; x++)
            this.paintVertexArray.emplace(x, y[0], y[1], v[0], v[1]);
        else {
          for (var S = r; S < i; S++)
            this.paintVertexArray.emplace(S, l, p);
          this.maxValue = Math.max(this.maxValue, Math.abs(l), Math.abs(p));
        }
      }, Xt.prototype.upload = function(r) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = r.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }, Xt.prototype.destroy = function() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }, Xt.prototype.setUniform = function(r, i) {
        var l = this.useIntegerZoom ? Math.floor(i.zoom) : i.zoom, p = q(this.expression.interpolationFactor(l, this.zoom, this.zoom + 1), 0, 1);
        r.set(p);
      }, Xt.prototype.getBinding = function(r, i, l) {
        return new nt(r, i);
      };
      var nr = function(r, i, l, p, y, v) {
        this.expression = r, this.type = i, this.useIntegerZoom = l, this.zoom = p, this.layerId = v, this.zoomInPaintVertexArray = new y(), this.zoomOutPaintVertexArray = new y();
      };
      nr.prototype.populatePaintArray = function(r, i, l) {
        var p = this.zoomInPaintVertexArray.length;
        this.zoomInPaintVertexArray.resize(r), this.zoomOutPaintVertexArray.resize(r), this._setPaintValues(p, r, i.patterns && i.patterns[this.layerId], l);
      }, nr.prototype.updatePaintArray = function(r, i, l, p, y) {
        this._setPaintValues(r, i, l.patterns && l.patterns[this.layerId], y);
      }, nr.prototype._setPaintValues = function(r, i, l, p) {
        if (p && l) {
          var y = p[l.min], v = p[l.mid], x = p[l.max];
          if (y && v && x)
            for (var S = r; S < i; S++)
              this.zoomInPaintVertexArray.emplace(S, v.tl[0], v.tl[1], v.br[0], v.br[1], y.tl[0], y.tl[1], y.br[0], y.br[1], v.pixelRatio, y.pixelRatio), this.zoomOutPaintVertexArray.emplace(S, v.tl[0], v.tl[1], v.br[0], v.br[1], x.tl[0], x.tl[1], x.br[0], x.br[1], v.pixelRatio, x.pixelRatio);
        }
      }, nr.prototype.upload = function(r) {
        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = r.createVertexBuffer(this.zoomInPaintVertexArray, ne.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = r.createVertexBuffer(this.zoomOutPaintVertexArray, ne.members, this.expression.isStateDependent));
      }, nr.prototype.destroy = function() {
        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
      };
      var Ht = function(r, i, l) {
        this.binders = {}, this._buffers = [];
        var p = [];
        for (var y in r.paint._values)
          if (l(y)) {
            var v = r.paint.get(y);
            if (v instanceof ji && yl(v.property.specification)) {
              var x = si(y, r.type), S = v.value, C = v.property.specification.type, A = v.property.useIntegerZoom, L = v.property.specification["property-type"], D = L === "cross-faded" || L === "cross-faded-data-driven";
              if (S.kind === "constant")
                this.binders[y] = D ? new ir(S.value, x) : new Yt(S.value, x, C), p.push("/u_" + y);
              else if (S.kind === "source" || D) {
                var B = On(y, C, "source");
                this.binders[y] = D ? new nr(S, C, A, i, B, r.id) : new Kt(S, x, C, B), p.push("/a_" + y);
              } else {
                var j = On(y, C, "composite");
                this.binders[y] = new Xt(S, x, C, A, i, j), p.push("/z_" + y);
              }
            }
          }
        this.cacheKey = p.sort().join("");
      };
      Ht.prototype.getMaxValue = function(r) {
        var i = this.binders[r];
        return i instanceof Kt || i instanceof Xt ? i.maxValue : 0;
      }, Ht.prototype.populatePaintArrays = function(r, i, l, p, y) {
        for (var v in this.binders) {
          var x = this.binders[v];
          (x instanceof Kt || x instanceof Xt || x instanceof nr) && x.populatePaintArray(r, i, l, p, y);
        }
      }, Ht.prototype.setConstantPatternPositions = function(r, i) {
        for (var l in this.binders) {
          var p = this.binders[l];
          p instanceof ir && p.setConstantPatternPositions(r, i);
        }
      }, Ht.prototype.updatePaintArrays = function(r, i, l, p, y) {
        var v = !1;
        for (var x in r)
          for (var S = 0, C = i.getPositions(x); S < C.length; S += 1) {
            var A = C[S], L = l.feature(A.index);
            for (var D in this.binders) {
              var B = this.binders[D];
              if ((B instanceof Kt || B instanceof Xt || B instanceof nr) && B.expression.isStateDependent === !0) {
                var j = p.paint.get(D);
                B.expression = j.value, B.updatePaintArray(A.start, A.end, L, r[x], y), v = !0;
              }
            }
          }
        return v;
      }, Ht.prototype.defines = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          (l instanceof Yt || l instanceof ir) && r.push.apply(r, l.uniformNames.map(function(p) {
            return "#define HAS_UNIFORM_" + p;
          }));
        }
        return r;
      }, Ht.prototype.getBinderAttributes = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          if (l instanceof Kt || l instanceof Xt)
            for (var p = 0; p < l.paintVertexAttributes.length; p++)
              r.push(l.paintVertexAttributes[p].name);
          else if (l instanceof nr)
            for (var y = 0; y < ne.members.length; y++)
              r.push(ne.members[y].name);
        }
        return r;
      }, Ht.prototype.getBinderUniforms = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          if (l instanceof Yt || l instanceof ir || l instanceof Xt)
            for (var p = 0, y = l.uniformNames; p < y.length; p += 1)
              r.push(y[p]);
        }
        return r;
      }, Ht.prototype.getPaintVertexBuffers = function() {
        return this._buffers;
      }, Ht.prototype.getUniforms = function(r, i) {
        var l = [];
        for (var p in this.binders) {
          var y = this.binders[p];
          if (y instanceof Yt || y instanceof ir || y instanceof Xt)
            for (var v = 0, x = y.uniformNames; v < x.length; v += 1) {
              var S = x[v];
              if (i[S]) {
                var C = y.getBinding(r, i[S], S);
                l.push({ name: S, property: p, binding: C });
              }
            }
        }
        return l;
      }, Ht.prototype.setUniforms = function(r, i, l, p) {
        for (var y = 0, v = i; y < v.length; y += 1) {
          var x = v[y], S = x.name, C = x.property;
          this.binders[C].setUniform(x.binding, p, l.get(C), S);
        }
      }, Ht.prototype.updatePaintBuffers = function(r) {
        for (var i in this._buffers = [], this.binders) {
          var l = this.binders[i];
          if (r && l instanceof nr) {
            var p = r.fromScale === 2 ? l.zoomInPaintVertexBuffer : l.zoomOutPaintVertexBuffer;
            p && this._buffers.push(p);
          } else
            (l instanceof Kt || l instanceof Xt) && l.paintVertexBuffer && this._buffers.push(l.paintVertexBuffer);
        }
      }, Ht.prototype.upload = function(r) {
        for (var i in this.binders) {
          var l = this.binders[i];
          (l instanceof Kt || l instanceof Xt || l instanceof nr) && l.upload(r);
        }
        this.updatePaintBuffers();
      }, Ht.prototype.destroy = function() {
        for (var r in this.binders) {
          var i = this.binders[r];
          (i instanceof Kt || i instanceof Xt || i instanceof nr) && i.destroy();
        }
      };
      var $t = function(r, i, l) {
        l === void 0 && (l = function() {
          return !0;
        }), this.programConfigurations = {};
        for (var p = 0, y = r; p < y.length; p += 1) {
          var v = y[p];
          this.programConfigurations[v.id] = new Ht(v, i, l);
        }
        this.needsUpload = !1, this._featureMap = new me(), this._bufferOffset = 0;
      };
      function si(r, i) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[r] || [r.replace(i + "-", "").replace(/-/g, "_")];
      }
      function On(r, i, l) {
        var p = { color: { source: iu, composite: Ih }, number: { source: Is, composite: iu } }, y = function(v) {
          return { "line-pattern": { source: Ea, composite: Ea }, "fill-pattern": { source: Ea, composite: Ea }, "fill-extrusion-pattern": { source: Ea, composite: Ea } }[v];
        }(r);
        return y && y[l] || p[i][l];
      }
      $t.prototype.populatePaintArrays = function(r, i, l, p, y, v) {
        for (var x in this.programConfigurations)
          this.programConfigurations[x].populatePaintArrays(r, i, p, y, v);
        i.id !== void 0 && this._featureMap.add(i.id, l, this._bufferOffset, r), this._bufferOffset = r, this.needsUpload = !0;
      }, $t.prototype.updatePaintArrays = function(r, i, l, p) {
        for (var y = 0, v = l; y < v.length; y += 1) {
          var x = v[y];
          this.needsUpload = this.programConfigurations[x.id].updatePaintArrays(r, this._featureMap, i, x, p) || this.needsUpload;
        }
      }, $t.prototype.get = function(r) {
        return this.programConfigurations[r];
      }, $t.prototype.upload = function(r) {
        if (this.needsUpload) {
          for (var i in this.programConfigurations)
            this.programConfigurations[i].upload(r);
          this.needsUpload = !1;
        }
      }, $t.prototype.destroy = function() {
        for (var r in this.programConfigurations)
          this.programConfigurations[r].destroy();
      }, wt("ConstantBinder", Yt), wt("CrossFadedConstantBinder", ir), wt("SourceExpressionBinder", Kt), wt("CrossFadedCompositeBinder", nr), wt("CompositeExpressionBinder", Xt), wt("ProgramConfiguration", Ht, { omit: ["_buffers"] }), wt("ProgramConfigurationSet", $t);
      var Di = Math.pow(2, 14) - 1, gi = -Di - 1;
      function Mn(r) {
        for (var i = 8192 / r.extent, l = r.loadGeometry(), p = 0; p < l.length; p++)
          for (var y = l[p], v = 0; v < y.length; v++) {
            var x = y[v], S = Math.round(x.x * i), C = Math.round(x.y * i);
            x.x = q(S, gi, Di), x.y = q(C, gi, Di), (S < x.x || S > x.x + 1 || C < x.y || C > x.y + 1) && at("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        return l;
      }
      function Dn(r, i) {
        return { type: r.type, id: r.id, properties: r.properties, geometry: i ? Mn(r) : [] };
      }
      function mo(r, i, l, p, y) {
        r.emplaceBack(2 * i + (p + 1) / 2, 2 * l + (y + 1) / 2);
      }
      var $i = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.layoutVertexArray = new bl(), this.indexArray = new Ts(), this.segments = new W(), this.programConfigurations = new $t(r.layers, r.zoom), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      function Os(r, i) {
        for (var l = 0; l < r.length; l++)
          if (Sa(i, r[l]))
            return !0;
        for (var p = 0; p < i.length; p++)
          if (Sa(r, i[p]))
            return !0;
        return !!pc(r, i);
      }
      function Qi(r, i, l) {
        return !!Sa(r, i) || !!Cs(i, r, l);
      }
      function ca(r, i) {
        if (r.length === 1)
          return dc(i, r[0]);
        for (var l = 0; l < i.length; l++)
          for (var p = i[l], y = 0; y < p.length; y++)
            if (Sa(r, p[y]))
              return !0;
        for (var v = 0; v < r.length; v++)
          if (dc(i, r[v]))
            return !0;
        for (var x = 0; x < i.length; x++)
          if (pc(r, i[x]))
            return !0;
        return !1;
      }
      function Zo(r, i, l) {
        if (r.length > 1) {
          if (pc(r, i))
            return !0;
          for (var p = 0; p < i.length; p++)
            if (Cs(i[p], r, l))
              return !0;
        }
        for (var y = 0; y < r.length; y++)
          if (Cs(r[y], i, l))
            return !0;
        return !1;
      }
      function pc(r, i) {
        if (r.length === 0 || i.length === 0)
          return !1;
        for (var l = 0; l < r.length - 1; l++)
          for (var p = r[l], y = r[l + 1], v = 0; v < i.length - 1; v++)
            if (su(p, y, i[v], i[v + 1]))
              return !0;
        return !1;
      }
      function su(r, i, l, p) {
        return be(r, l, p) !== be(i, l, p) && be(r, i, l) !== be(r, i, p);
      }
      function Cs(r, i, l) {
        var p = l * l;
        if (i.length === 1)
          return r.distSqr(i[0]) < p;
        for (var y = 1; y < i.length; y++)
          if (lu(r, i[y - 1], i[y]) < p)
            return !0;
        return !1;
      }
      function lu(r, i, l) {
        var p = i.distSqr(l);
        if (p === 0)
          return r.distSqr(i);
        var y = ((r.x - i.x) * (l.x - i.x) + (r.y - i.y) * (l.y - i.y)) / p;
        return r.distSqr(y < 0 ? i : y > 1 ? l : l.sub(i)._mult(y)._add(i));
      }
      function dc(r, i) {
        for (var l, p, y, v = !1, x = 0; x < r.length; x++)
          for (var S = 0, C = (l = r[x]).length - 1; S < l.length; C = S++)
            (p = l[S]).y > i.y != (y = l[C]).y > i.y && i.x < (y.x - p.x) * (i.y - p.y) / (y.y - p.y) + p.x && (v = !v);
        return v;
      }
      function Sa(r, i) {
        for (var l = !1, p = 0, y = r.length - 1; p < r.length; y = p++) {
          var v = r[p], x = r[y];
          v.y > i.y != x.y > i.y && i.x < (x.x - v.x) * (i.y - v.y) / (x.y - v.y) + v.x && (l = !l);
        }
        return l;
      }
      function mc(r, i, l) {
        var p = l[0], y = l[2];
        if (r.x < p.x && i.x < p.x || r.x > y.x && i.x > y.x || r.y < p.y && i.y < p.y || r.y > y.y && i.y > y.y)
          return !1;
        var v = be(r, i, l[0]);
        return v !== be(r, i, l[1]) || v !== be(r, i, l[2]) || v !== be(r, i, l[3]);
      }
      function Ta(r, i, l) {
        var p = i.paint.get(r).value;
        return p.kind === "constant" ? p.value : l.programConfigurations.get(i.id).getMaxValue(r);
      }
      function li(r) {
        return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
      }
      function $a(r, i, l, p, y) {
        if (!i[0] && !i[1])
          return r;
        var v = T.convert(i)._mult(y);
        l === "viewport" && v._rotate(-p);
        for (var x = [], S = 0; S < r.length; S++)
          x.push(r[S].sub(v));
        return x;
      }
      $i.prototype.populate = function(r, i, l) {
        var p = this.layers[0], y = [], v = null;
        p.type === "circle" && (v = p.layout.get("circle-sort-key"));
        for (var x = 0, S = r; x < S.length; x += 1) {
          var C = S[x], A = C.feature, L = C.id, D = C.index, B = C.sourceLayerIndex, j = this.layers[0]._featureFilter.needGeometry, J = Dn(A, j);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), J, l)) {
            var ee = v ? v.evaluate(J, {}, l) : void 0, he = { id: L, properties: A.properties, type: A.type, sourceLayerIndex: B, index: D, geometry: j ? J.geometry : Mn(A), patterns: {}, sortKey: ee };
            y.push(he);
          }
        }
        v && y.sort(function(ot, At) {
          return ot.sortKey - At.sortKey;
        });
        for (var oe = 0, ge = y; oe < ge.length; oe += 1) {
          var we = ge[oe], Te = we.geometry, Oe = we.index, Be = we.sourceLayerIndex, Ke = r[Oe].feature;
          this.addFeature(we, Te, Oe, l), i.featureIndex.insert(Ke, Te, Oe, Be, this.index);
        }
      }, $i.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, $i.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, $i.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, $i.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, $), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, $i.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, $i.prototype.addFeature = function(r, i, l, p) {
        for (var y = 0, v = i; y < v.length; y += 1)
          for (var x = 0, S = v[y]; x < S.length; x += 1) {
            var C = S[x], A = C.x, L = C.y;
            if (!(A < 0 || A >= 8192 || L < 0 || L >= 8192)) {
              var D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, r.sortKey), B = D.vertexLength;
              mo(this.layoutVertexArray, A, L, -1, -1), mo(this.layoutVertexArray, A, L, 1, -1), mo(this.layoutVertexArray, A, L, 1, 1), mo(this.layoutVertexArray, A, L, -1, 1), this.indexArray.emplaceBack(B, B + 1, B + 2), this.indexArray.emplaceBack(B, B + 3, B + 2), D.vertexLength += 4, D.primitiveLength += 2;
            }
          }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, {}, p);
      }, wt("CircleBucket", $i, { omit: ["layers"] });
      var As = new Ii({ "circle-sort-key": new Tt(G.layout_circle["circle-sort-key"]) }), El = { paint: new Ii({ "circle-radius": new Tt(G.paint_circle["circle-radius"]), "circle-color": new Tt(G.paint_circle["circle-color"]), "circle-blur": new Tt(G.paint_circle["circle-blur"]), "circle-opacity": new Tt(G.paint_circle["circle-opacity"]), "circle-translate": new Lt(G.paint_circle["circle-translate"]), "circle-translate-anchor": new Lt(G.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Lt(G.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Lt(G.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Tt(G.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Tt(G.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Tt(G.paint_circle["circle-stroke-opacity"]) }), layout: As }, Br = typeof Float32Array < "u" ? Float32Array : Array;
      function Oo(r) {
        return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
      }
      function eo(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3], S = i[4], C = i[5], A = i[6], L = i[7], D = i[8], B = i[9], j = i[10], J = i[11], ee = i[12], he = i[13], oe = i[14], ge = i[15], we = l[0], Te = l[1], Oe = l[2], Be = l[3];
        return r[0] = we * p + Te * S + Oe * D + Be * ee, r[1] = we * y + Te * C + Oe * B + Be * he, r[2] = we * v + Te * A + Oe * j + Be * oe, r[3] = we * x + Te * L + Oe * J + Be * ge, r[4] = (we = l[4]) * p + (Te = l[5]) * S + (Oe = l[6]) * D + (Be = l[7]) * ee, r[5] = we * y + Te * C + Oe * B + Be * he, r[6] = we * v + Te * A + Oe * j + Be * oe, r[7] = we * x + Te * L + Oe * J + Be * ge, r[8] = (we = l[8]) * p + (Te = l[9]) * S + (Oe = l[10]) * D + (Be = l[11]) * ee, r[9] = we * y + Te * C + Oe * B + Be * he, r[10] = we * v + Te * A + Oe * j + Be * oe, r[11] = we * x + Te * L + Oe * J + Be * ge, r[12] = (we = l[12]) * p + (Te = l[13]) * S + (Oe = l[14]) * D + (Be = l[15]) * ee, r[13] = we * y + Te * C + Oe * B + Be * he, r[14] = we * v + Te * A + Oe * j + Be * oe, r[15] = we * x + Te * L + Oe * J + Be * ge, r;
      }
      Math.hypot || (Math.hypot = function() {
        for (var r = arguments, i = 0, l = arguments.length; l--; )
          i += r[l] * r[l];
        return Math.sqrt(i);
      });
      var Sl, Yv = eo;
      function Oh(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3];
        return r[0] = l[0] * p + l[4] * y + l[8] * v + l[12] * x, r[1] = l[1] * p + l[5] * y + l[9] * v + l[13] * x, r[2] = l[2] * p + l[6] * y + l[10] * v + l[14] * x, r[3] = l[3] * p + l[7] * y + l[11] * v + l[15] * x, r;
      }
      Sl = new Br(3), Br != Float32Array && (Sl[0] = 0, Sl[1] = 0, Sl[2] = 0), function() {
        var r = new Br(4);
        Br != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0);
      }();
      var Jv = (function() {
        var r = new Br(2);
        Br != Float32Array && (r[0] = 0, r[1] = 0);
      }(), function(r) {
        function i(l) {
          r.call(this, l, El);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new $i(l);
        }, i.prototype.queryRadius = function(l) {
          var p = l;
          return Ta("circle-radius", this, p) + Ta("circle-stroke-width", this, p) + li(this.paint.get("circle-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C, A) {
          for (var L = $a(l, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), S.angle, C), D = this.paint.get("circle-radius").evaluate(p, y) + this.paint.get("circle-stroke-width").evaluate(p, y), B = this.paint.get("circle-pitch-alignment") === "map", j = B ? L : function(Ke, ot) {
            return Ke.map(function(At) {
              return yc(At, ot);
            });
          }(L, A), J = B ? D * C : D, ee = 0, he = v; ee < he.length; ee += 1)
            for (var oe = 0, ge = he[ee]; oe < ge.length; oe += 1) {
              var we = ge[oe], Te = B ? we : yc(we, A), Oe = J, Be = Oh([], [we.x, we.y, 0, 1], A);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Oe *= Be[3] / S.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Oe *= S.cameraToCenterDistance / Be[3]), Qi(j, Te, Oe))
                return !0;
            }
          return !1;
        }, i;
      }(wa));
      function yc(r, i) {
        var l = Oh([], [r.x, r.y, 0, 1], i);
        return new T(l[0] / l[3], l[1] / l[3]);
      }
      var zm = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }($i);
      function uu(r, i, l, p) {
        var y = i.width, v = i.height;
        if (p) {
          if (p instanceof Uint8ClampedArray)
            p = new Uint8Array(p.buffer);
          else if (p.length !== y * v * l)
            throw new RangeError("mismatched image size");
        } else
          p = new Uint8Array(y * v * l);
        return r.width = y, r.height = v, r.data = p, r;
      }
      function Ch(r, i, l) {
        var p = i.width, y = i.height;
        if (p !== r.width || y !== r.height) {
          var v = uu({}, { width: p, height: y }, l);
          Qv(r, v, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r.width, p), height: Math.min(r.height, y) }, l), r.width = p, r.height = y, r.data = v.data;
        }
      }
      function Qv(r, i, l, p, y, v) {
        if (y.width === 0 || y.height === 0)
          return i;
        if (y.width > r.width || y.height > r.height || l.x > r.width - y.width || l.y > r.height - y.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (y.width > i.width || y.height > i.height || p.x > i.width - y.width || p.y > i.height - y.height)
          throw new RangeError("out of range destination coordinates for image copy");
        for (var x = r.data, S = i.data, C = 0; C < y.height; C++)
          for (var A = ((l.y + C) * r.width + l.x) * v, L = ((p.y + C) * i.width + p.x) * v, D = 0; D < y.width * v; D++)
            S[L + D] = x[A + D];
        return i;
      }
      wt("HeatmapBucket", zm, { omit: ["layers"] });
      var gc = function(r, i) {
        uu(this, r, 1, i);
      };
      gc.prototype.resize = function(r) {
        Ch(this, r, 1);
      }, gc.prototype.clone = function() {
        return new gc({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }, gc.copy = function(r, i, l, p, y) {
        Qv(r, i, l, p, y, 1);
      };
      var yo = function(r, i) {
        uu(this, r, 4, i);
      };
      yo.prototype.resize = function(r) {
        Ch(this, r, 4);
      }, yo.prototype.replace = function(r, i) {
        i ? this.data.set(r) : this.data = r instanceof Uint8ClampedArray ? new Uint8Array(r.buffer) : r;
      }, yo.prototype.clone = function() {
        return new yo({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }, yo.copy = function(r, i, l, p, y) {
        Qv(r, i, l, p, y, 4);
      }, wt("AlphaImage", gc), wt("RGBAImage", yo);
      var jI = { paint: new Ii({ "heatmap-radius": new Tt(G.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Tt(G.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Lt(G.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ua(G.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Lt(G.paint_heatmap["heatmap-opacity"]) }) };
      function fx(r) {
        var i = {}, l = r.resolution || 256, p = r.clips ? r.clips.length : 1, y = r.image || new yo({ width: l, height: p }), v = function(J, ee, he) {
          i[r.evaluationKey] = he;
          var oe = r.expression.evaluate(i);
          y.data[J + ee + 0] = Math.floor(255 * oe.r / oe.a), y.data[J + ee + 1] = Math.floor(255 * oe.g / oe.a), y.data[J + ee + 2] = Math.floor(255 * oe.b / oe.a), y.data[J + ee + 3] = Math.floor(255 * oe.a);
        };
        if (r.clips)
          for (var x = 0, S = 0; x < p; ++x, S += 4 * l)
            for (var C = 0, A = 0; C < l; C++, A += 4) {
              var L = C / (l - 1), D = r.clips[x];
              v(S, A, D.start * (1 - L) + D.end * L);
            }
        else
          for (var B = 0, j = 0; B < l; B++, j += 4)
            v(0, j, B / (l - 1));
        return y;
      }
      var GI = function(r) {
        function i(l) {
          r.call(this, l, jI), this._updateColorRamp();
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new zm(l);
        }, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
          l === "heatmap-color" && this._updateColorRamp();
        }, i.prototype._updateColorRamp = function() {
          this.colorRamp = fx({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }, i.prototype.resize = function() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }, i.prototype.queryRadius = function() {
          return 0;
        }, i.prototype.queryIntersectsFeature = function() {
          return !1;
        }, i.prototype.hasOffscreenPass = function() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }, i;
      }(wa), $I = { paint: new Ii({ "hillshade-illumination-direction": new Lt(G.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Lt(G.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Lt(G.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Lt(G.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Lt(G.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Lt(G.paint_hillshade["hillshade-accent-color"]) }) }, qI = function(r) {
        function i(l) {
          r.call(this, l, $I);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.hasOffscreenPass = function() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }, i;
      }(wa), WI = yi([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, e_ = Fm, HI = Fm;
      function Fm(r, i, l) {
        l = l || 2;
        var p, y, v, x, S, C, A, L = i && i.length, D = L ? i[0] * l : r.length, B = px(r, 0, D, l, !0), j = [];
        if (!B || B.next === B.prev)
          return j;
        if (L && (B = function(ee, he, oe, ge) {
          var we, Te, Oe, Be = [];
          for (we = 0, Te = he.length; we < Te; we++)
            (Oe = px(ee, he[we] * ge, we < Te - 1 ? he[we + 1] * ge : ee.length, ge, !1)) === Oe.next && (Oe.steiner = !0), Be.push(tO(Oe));
          for (Be.sort(JI), we = 0; we < Be.length; we++)
            QI(Be[we], oe), oe = cu(oe, oe.next);
          return oe;
        }(r, i, B, l)), r.length > 80 * l) {
          p = v = r[0], y = x = r[1];
          for (var J = l; J < D; J += l)
            (S = r[J]) < p && (p = S), (C = r[J + 1]) < y && (y = C), S > v && (v = S), C > x && (x = C);
          A = (A = Math.max(v - p, x - y)) !== 0 ? 1 / A : 0;
        }
        return yp(B, j, l, p, y, A), j;
      }
      function px(r, i, l, p, y) {
        var v, x;
        if (y === n_(r, i, l, p) > 0)
          for (v = i; v < l; v += p)
            x = yx(v, r[v], r[v + 1], x);
        else
          for (v = l - p; v >= i; v -= p)
            x = yx(v, r[v], r[v + 1], x);
        return x && Bm(x, x.next) && (vp(x), x = x.next), x;
      }
      function cu(r, i) {
        if (!r)
          return r;
        i || (i = r);
        var l, p = r;
        do
          if (l = !1, p.steiner || !Bm(p, p.next) && Qn(p.prev, p, p.next) !== 0)
            p = p.next;
          else {
            if (vp(p), (p = i = p.prev) === p.next)
              break;
            l = !0;
          }
        while (l || p !== i);
        return i;
      }
      function yp(r, i, l, p, y, v, x) {
        if (r) {
          !x && v && function(L, D, B, j) {
            var J = L;
            do
              J.z === null && (J.z = t_(J.x, J.y, D, B, j)), J.prevZ = J.prev, J.nextZ = J.next, J = J.next;
            while (J !== L);
            J.prevZ.nextZ = null, J.prevZ = null, function(ee) {
              var he, oe, ge, we, Te, Oe, Be, Ke, ot = 1;
              do {
                for (oe = ee, ee = null, Te = null, Oe = 0; oe; ) {
                  for (Oe++, ge = oe, Be = 0, he = 0; he < ot && (Be++, ge = ge.nextZ); he++)
                    ;
                  for (Ke = ot; Be > 0 || Ke > 0 && ge; )
                    Be !== 0 && (Ke === 0 || !ge || oe.z <= ge.z) ? (we = oe, oe = oe.nextZ, Be--) : (we = ge, ge = ge.nextZ, Ke--), Te ? Te.nextZ = we : ee = we, we.prevZ = Te, Te = we;
                  oe = ge;
                }
                Te.nextZ = null, ot *= 2;
              } while (Oe > 1);
            }(J);
          }(r, p, y, v);
          for (var S, C, A = r; r.prev !== r.next; )
            if (S = r.prev, C = r.next, v ? XI(r, p, y, v) : ZI(r))
              i.push(S.i / l), i.push(r.i / l), i.push(C.i / l), vp(r), r = C.next, A = C.next;
            else if ((r = C) === A) {
              x ? x === 1 ? yp(r = KI(cu(r), i, l), i, l, p, y, v, 2) : x === 2 && YI(r, i, l, p, y, v) : yp(cu(r), i, l, p, y, v, 1);
              break;
            }
        }
      }
      function ZI(r) {
        var i = r.prev, l = r, p = r.next;
        if (Qn(i, l, p) >= 0)
          return !1;
        for (var y = r.next.next; y !== r.prev; ) {
          if (Ah(i.x, i.y, l.x, l.y, p.x, p.y, y.x, y.y) && Qn(y.prev, y, y.next) >= 0)
            return !1;
          y = y.next;
        }
        return !0;
      }
      function XI(r, i, l, p) {
        var y = r.prev, v = r, x = r.next;
        if (Qn(y, v, x) >= 0)
          return !1;
        for (var S = y.x > v.x ? y.x > x.x ? y.x : x.x : v.x > x.x ? v.x : x.x, C = y.y > v.y ? y.y > x.y ? y.y : x.y : v.y > x.y ? v.y : x.y, A = t_(y.x < v.x ? y.x < x.x ? y.x : x.x : v.x < x.x ? v.x : x.x, y.y < v.y ? y.y < x.y ? y.y : x.y : v.y < x.y ? v.y : x.y, i, l, p), L = t_(S, C, i, l, p), D = r.prevZ, B = r.nextZ; D && D.z >= A && B && B.z <= L; ) {
          if (D !== r.prev && D !== r.next && Ah(y.x, y.y, v.x, v.y, x.x, x.y, D.x, D.y) && Qn(D.prev, D, D.next) >= 0 || (D = D.prevZ, B !== r.prev && B !== r.next && Ah(y.x, y.y, v.x, v.y, x.x, x.y, B.x, B.y) && Qn(B.prev, B, B.next) >= 0))
            return !1;
          B = B.nextZ;
        }
        for (; D && D.z >= A; ) {
          if (D !== r.prev && D !== r.next && Ah(y.x, y.y, v.x, v.y, x.x, x.y, D.x, D.y) && Qn(D.prev, D, D.next) >= 0)
            return !1;
          D = D.prevZ;
        }
        for (; B && B.z <= L; ) {
          if (B !== r.prev && B !== r.next && Ah(y.x, y.y, v.x, v.y, x.x, x.y, B.x, B.y) && Qn(B.prev, B, B.next) >= 0)
            return !1;
          B = B.nextZ;
        }
        return !0;
      }
      function KI(r, i, l) {
        var p = r;
        do {
          var y = p.prev, v = p.next.next;
          !Bm(y, v) && dx(y, p, p.next, v) && gp(y, v) && gp(v, y) && (i.push(y.i / l), i.push(p.i / l), i.push(v.i / l), vp(p), vp(p.next), p = r = v), p = p.next;
        } while (p !== r);
        return cu(p);
      }
      function YI(r, i, l, p, y, v) {
        var x = r;
        do {
          for (var S = x.next.next; S !== x.prev; ) {
            if (x.i !== S.i && rO(x, S)) {
              var C = mx(x, S);
              return x = cu(x, x.next), C = cu(C, C.next), yp(x, i, l, p, y, v), void yp(C, i, l, p, y, v);
            }
            S = S.next;
          }
          x = x.next;
        } while (x !== r);
      }
      function JI(r, i) {
        return r.x - i.x;
      }
      function QI(r, i) {
        if (i = function(p, y) {
          var v, x = y, S = p.x, C = p.y, A = -1 / 0;
          do {
            if (C <= x.y && C >= x.next.y && x.next.y !== x.y) {
              var L = x.x + (C - x.y) * (x.next.x - x.x) / (x.next.y - x.y);
              if (L <= S && L > A) {
                if (A = L, L === S) {
                  if (C === x.y)
                    return x;
                  if (C === x.next.y)
                    return x.next;
                }
                v = x.x < x.next.x ? x : x.next;
              }
            }
            x = x.next;
          } while (x !== y);
          if (!v)
            return null;
          if (S === A)
            return v;
          var D, B = v, j = v.x, J = v.y, ee = 1 / 0;
          x = v;
          do
            S >= x.x && x.x >= j && S !== x.x && Ah(C < J ? S : A, C, j, J, C < J ? A : S, C, x.x, x.y) && (D = Math.abs(C - x.y) / (S - x.x), gp(x, p) && (D < ee || D === ee && (x.x > v.x || x.x === v.x && eO(v, x))) && (v = x, ee = D)), x = x.next;
          while (x !== B);
          return v;
        }(r, i)) {
          var l = mx(i, r);
          cu(i, i.next), cu(l, l.next);
        }
      }
      function eO(r, i) {
        return Qn(r.prev, r, i.prev) < 0 && Qn(i.next, r, r.next) < 0;
      }
      function t_(r, i, l, p, y) {
        return (r = 1431655765 & ((r = 858993459 & ((r = 252645135 & ((r = 16711935 & ((r = 32767 * (r - l) * y) | r << 8)) | r << 4)) | r << 2)) | r << 1)) | (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = 32767 * (i - p) * y) | i << 8)) | i << 4)) | i << 2)) | i << 1)) << 1;
      }
      function tO(r) {
        var i = r, l = r;
        do
          (i.x < l.x || i.x === l.x && i.y < l.y) && (l = i), i = i.next;
        while (i !== r);
        return l;
      }
      function Ah(r, i, l, p, y, v, x, S) {
        return (y - x) * (i - S) - (r - x) * (v - S) >= 0 && (r - x) * (p - S) - (l - x) * (i - S) >= 0 && (l - x) * (v - S) - (y - x) * (p - S) >= 0;
      }
      function rO(r, i) {
        return r.next.i !== i.i && r.prev.i !== i.i && !function(l, p) {
          var y = l;
          do {
            if (y.i !== l.i && y.next.i !== l.i && y.i !== p.i && y.next.i !== p.i && dx(y, y.next, l, p))
              return !0;
            y = y.next;
          } while (y !== l);
          return !1;
        }(r, i) && (gp(r, i) && gp(i, r) && function(l, p) {
          var y = l, v = !1, x = (l.x + p.x) / 2, S = (l.y + p.y) / 2;
          do
            y.y > S != y.next.y > S && y.next.y !== y.y && x < (y.next.x - y.x) * (S - y.y) / (y.next.y - y.y) + y.x && (v = !v), y = y.next;
          while (y !== l);
          return v;
        }(r, i) && (Qn(r.prev, r, i.prev) || Qn(r, i.prev, i)) || Bm(r, i) && Qn(r.prev, r, r.next) > 0 && Qn(i.prev, i, i.next) > 0);
      }
      function Qn(r, i, l) {
        return (i.y - r.y) * (l.x - i.x) - (i.x - r.x) * (l.y - i.y);
      }
      function Bm(r, i) {
        return r.x === i.x && r.y === i.y;
      }
      function dx(r, i, l, p) {
        var y = Um(Qn(r, i, l)), v = Um(Qn(r, i, p)), x = Um(Qn(l, p, r)), S = Um(Qn(l, p, i));
        return y !== v && x !== S || !(y !== 0 || !Vm(r, l, i)) || !(v !== 0 || !Vm(r, p, i)) || !(x !== 0 || !Vm(l, r, p)) || !(S !== 0 || !Vm(l, i, p));
      }
      function Vm(r, i, l) {
        return i.x <= Math.max(r.x, l.x) && i.x >= Math.min(r.x, l.x) && i.y <= Math.max(r.y, l.y) && i.y >= Math.min(r.y, l.y);
      }
      function Um(r) {
        return r > 0 ? 1 : r < 0 ? -1 : 0;
      }
      function gp(r, i) {
        return Qn(r.prev, r, r.next) < 0 ? Qn(r, i, r.next) >= 0 && Qn(r, r.prev, i) >= 0 : Qn(r, i, r.prev) < 0 || Qn(r, r.next, i) < 0;
      }
      function mx(r, i) {
        var l = new r_(r.i, r.x, r.y), p = new r_(i.i, i.x, i.y), y = r.next, v = i.prev;
        return r.next = i, i.prev = r, l.next = y, y.prev = l, p.next = l, l.prev = p, v.next = p, p.prev = v, p;
      }
      function yx(r, i, l, p) {
        var y = new r_(r, i, l);
        return p ? (y.next = p.next, y.prev = p, p.next.prev = y, p.next = y) : (y.prev = y, y.next = y), y;
      }
      function vp(r) {
        r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
      }
      function r_(r, i, l) {
        this.i = r, this.x = i, this.y = l, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
      }
      function n_(r, i, l, p) {
        for (var y = 0, v = i, x = l - p; v < l; v += p)
          y += (r[x] - r[v]) * (r[v + 1] + r[x + 1]), x = v;
        return y;
      }
      function nO(r, i, l, p, y) {
        (function v(x, S, C, A, L) {
          for (; A > C; ) {
            if (A - C > 600) {
              var D = A - C + 1, B = S - C + 1, j = Math.log(D), J = 0.5 * Math.exp(2 * j / 3), ee = 0.5 * Math.sqrt(j * J * (D - J) / D) * (B - D / 2 < 0 ? -1 : 1);
              v(x, S, Math.max(C, Math.floor(S - B * J / D + ee)), Math.min(A, Math.floor(S + (D - B) * J / D + ee)), L);
            }
            var he = x[S], oe = C, ge = A;
            for (_p(x, C, S), L(x[A], he) > 0 && _p(x, C, A); oe < ge; ) {
              for (_p(x, oe, ge), oe++, ge--; L(x[oe], he) < 0; )
                oe++;
              for (; L(x[ge], he) > 0; )
                ge--;
            }
            L(x[C], he) === 0 ? _p(x, C, ge) : _p(x, ++ge, A), ge <= S && (C = ge + 1), S <= ge && (A = ge - 1);
          }
        })(r, i, l || 0, p || r.length - 1, y || iO);
      }
      function _p(r, i, l) {
        var p = r[i];
        r[i] = r[l], r[l] = p;
      }
      function iO(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function i_(r, i) {
        var l = r.length;
        if (l <= 1)
          return [r];
        for (var p, y, v = [], x = 0; x < l; x++) {
          var S = Ye(r[x]);
          S !== 0 && (r[x].area = Math.abs(S), y === void 0 && (y = S < 0), y === S < 0 ? (p && v.push(p), p = [r[x]]) : p.push(r[x]));
        }
        if (p && v.push(p), i > 1)
          for (var C = 0; C < v.length; C++)
            v[C].length <= i || (nO(v[C], i, 1, v[C].length - 1, oO), v[C] = v[C].slice(0, i));
        return v;
      }
      function oO(r, i) {
        return i.area - r.area;
      }
      function o_(r, i, l) {
        for (var p = l.patternDependencies, y = !1, v = 0, x = i; v < x.length; v += 1) {
          var S = x[v].paint.get(r + "-pattern");
          S.isConstant() || (y = !0);
          var C = S.constantOr(null);
          C && (y = !0, p[C.to] = !0, p[C.from] = !0);
        }
        return y;
      }
      function a_(r, i, l, p, y) {
        for (var v = y.patternDependencies, x = 0, S = i; x < S.length; x += 1) {
          var C = S[x], A = C.paint.get(r + "-pattern").value;
          if (A.kind !== "constant") {
            var L = A.evaluate({ zoom: p - 1 }, l, {}, y.availableImages), D = A.evaluate({ zoom: p }, l, {}, y.availableImages), B = A.evaluate({ zoom: p + 1 }, l, {}, y.availableImages);
            D = D && D.name ? D.name : D, B = B && B.name ? B.name : B, v[L = L && L.name ? L.name : L] = !0, v[D] = !0, v[B] = !0, l.patterns[C.id] = { min: L, mid: D, max: B };
          }
        }
        return l;
      }
      Fm.deviation = function(r, i, l, p) {
        var y = i && i.length, v = Math.abs(n_(r, 0, y ? i[0] * l : r.length, l));
        if (y)
          for (var x = 0, S = i.length; x < S; x++)
            v -= Math.abs(n_(r, i[x] * l, x < S - 1 ? i[x + 1] * l : r.length, l));
        var C = 0;
        for (x = 0; x < p.length; x += 3) {
          var A = p[x] * l, L = p[x + 1] * l, D = p[x + 2] * l;
          C += Math.abs((r[A] - r[D]) * (r[L + 1] - r[A + 1]) - (r[A] - r[L]) * (r[D + 1] - r[A + 1]));
        }
        return v === 0 && C === 0 ? 0 : Math.abs((C - v) / v);
      }, Fm.flatten = function(r) {
        for (var i = r[0][0].length, l = { vertices: [], holes: [], dimensions: i }, p = 0, y = 0; y < r.length; y++) {
          for (var v = 0; v < r[y].length; v++)
            for (var x = 0; x < i; x++)
              l.vertices.push(r[y][v][x]);
          y > 0 && l.holes.push(p += r[y - 1].length);
        }
        return l;
      }, e_.default = HI;
      var qa = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new bl(), this.indexArray = new Ts(), this.indexArray2 = new fc(), this.programConfigurations = new $t(r.layers, r.zoom), this.segments = new W(), this.segments2 = new W(), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      qa.prototype.populate = function(r, i, l) {
        this.hasPattern = o_("fill", this.layers, i);
        for (var p = this.layers[0].layout.get("fill-sort-key"), y = [], v = 0, x = r; v < x.length; v += 1) {
          var S = x[v], C = S.feature, A = S.id, L = S.index, D = S.sourceLayerIndex, B = this.layers[0]._featureFilter.needGeometry, j = Dn(C, B);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), j, l)) {
            var J = p ? p.evaluate(j, {}, l, i.availableImages) : void 0, ee = { id: A, properties: C.properties, type: C.type, sourceLayerIndex: D, index: L, geometry: B ? j.geometry : Mn(C), patterns: {}, sortKey: J };
            y.push(ee);
          }
        }
        p && y.sort(function(Ke, ot) {
          return Ke.sortKey - ot.sortKey;
        });
        for (var he = 0, oe = y; he < oe.length; he += 1) {
          var ge = oe[he], we = ge.geometry, Te = ge.index, Oe = ge.sourceLayerIndex;
          if (this.hasPattern) {
            var Be = a_("fill", this.layers, ge, this.zoom, i);
            this.patternFeatures.push(Be);
          } else
            this.addFeature(ge, we, Te, l, {});
          i.featureIndex.insert(r[Te].feature, we, Te, Oe, this.index);
        }
      }, qa.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, qa.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.patternFeatures; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, qa.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, qa.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, qa.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, WI), this.indexBuffer = r.createIndexBuffer(this.indexArray), this.indexBuffer2 = r.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, qa.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
      }, qa.prototype.addFeature = function(r, i, l, p, y) {
        for (var v = 0, x = i_(i, 500); v < x.length; v += 1) {
          for (var S = x[v], C = 0, A = 0, L = S; A < L.length; A += 1)
            C += L[A].length;
          for (var D = this.segments.prepareSegment(C, this.layoutVertexArray, this.indexArray), B = D.vertexLength, j = [], J = [], ee = 0, he = S; ee < he.length; ee += 1) {
            var oe = he[ee];
            if (oe.length !== 0) {
              oe !== S[0] && J.push(j.length / 2);
              var ge = this.segments2.prepareSegment(oe.length, this.layoutVertexArray, this.indexArray2), we = ge.vertexLength;
              this.layoutVertexArray.emplaceBack(oe[0].x, oe[0].y), this.indexArray2.emplaceBack(we + oe.length - 1, we), j.push(oe[0].x), j.push(oe[0].y);
              for (var Te = 1; Te < oe.length; Te++)
                this.layoutVertexArray.emplaceBack(oe[Te].x, oe[Te].y), this.indexArray2.emplaceBack(we + Te - 1, we + Te), j.push(oe[Te].x), j.push(oe[Te].y);
              ge.vertexLength += oe.length, ge.primitiveLength += oe.length;
            }
          }
          for (var Oe = e_(j, J), Be = 0; Be < Oe.length; Be += 3)
            this.indexArray.emplaceBack(B + Oe[Be], B + Oe[Be + 1], B + Oe[Be + 2]);
          D.vertexLength += C, D.primitiveLength += Oe.length / 3;
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, wt("FillBucket", qa, { omit: ["layers", "patternFeatures"] });
      var aO = new Ii({ "fill-sort-key": new Tt(G.layout_fill["fill-sort-key"]) }), sO = { paint: new Ii({ "fill-antialias": new Lt(G.paint_fill["fill-antialias"]), "fill-opacity": new Tt(G.paint_fill["fill-opacity"]), "fill-color": new Tt(G.paint_fill["fill-color"]), "fill-outline-color": new Tt(G.paint_fill["fill-outline-color"]), "fill-translate": new Lt(G.paint_fill["fill-translate"]), "fill-translate-anchor": new Lt(G.paint_fill["fill-translate-anchor"]), "fill-pattern": new Eh(G.paint_fill["fill-pattern"]) }), layout: aO }, lO = function(r) {
        function i(l) {
          r.call(this, l, sO);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.recalculate = function(l, p) {
          r.prototype.recalculate.call(this, l, p);
          var y = this.paint._values["fill-outline-color"];
          y.value.kind === "constant" && y.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }, i.prototype.createBucket = function(l) {
          return new qa(l);
        }, i.prototype.queryRadius = function() {
          return li(this.paint.get("fill-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C) {
          return ca($a(l, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), S.angle, C), v);
        }, i.prototype.isTileClipped = function() {
          return !0;
        }, i;
      }(wa), uO = yi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4).members, gx = Ph;
      function Ph(r, i, l, p, y) {
        this.properties = {}, this.extent = l, this.type = 0, this._pbf = r, this._geometry = -1, this._keys = p, this._values = y, r.readFields(cO, this, i);
      }
      function cO(r, i, l) {
        r == 1 ? i.id = l.readVarint() : r == 2 ? function(p, y) {
          for (var v = p.readVarint() + p.pos; p.pos < v; ) {
            var x = y._keys[p.readVarint()], S = y._values[p.readVarint()];
            y.properties[x] = S;
          }
        }(l, i) : r == 3 ? i.type = l.readVarint() : r == 4 && (i._geometry = l.pos);
      }
      function hO(r) {
        for (var i, l, p = 0, y = 0, v = r.length, x = v - 1; y < v; x = y++)
          p += ((l = r[x]).x - (i = r[y]).x) * (i.y + l.y);
        return p;
      }
      Ph.types = ["Unknown", "Point", "LineString", "Polygon"], Ph.prototype.loadGeometry = function() {
        var r = this._pbf;
        r.pos = this._geometry;
        for (var i, l = r.readVarint() + r.pos, p = 1, y = 0, v = 0, x = 0, S = []; r.pos < l; ) {
          if (y <= 0) {
            var C = r.readVarint();
            p = 7 & C, y = C >> 3;
          }
          if (y--, p === 1 || p === 2)
            v += r.readSVarint(), x += r.readSVarint(), p === 1 && (i && S.push(i), i = []), i.push(new T(v, x));
          else {
            if (p !== 7)
              throw new Error("unknown command " + p);
            i && i.push(i[0].clone());
          }
        }
        return i && S.push(i), S;
      }, Ph.prototype.bbox = function() {
        var r = this._pbf;
        r.pos = this._geometry;
        for (var i = r.readVarint() + r.pos, l = 1, p = 0, y = 0, v = 0, x = 1 / 0, S = -1 / 0, C = 1 / 0, A = -1 / 0; r.pos < i; ) {
          if (p <= 0) {
            var L = r.readVarint();
            l = 7 & L, p = L >> 3;
          }
          if (p--, l === 1 || l === 2)
            (y += r.readSVarint()) < x && (x = y), y > S && (S = y), (v += r.readSVarint()) < C && (C = v), v > A && (A = v);
          else if (l !== 7)
            throw new Error("unknown command " + l);
        }
        return [x, C, S, A];
      }, Ph.prototype.toGeoJSON = function(r, i, l) {
        var p, y, v = this.extent * Math.pow(2, l), x = this.extent * r, S = this.extent * i, C = this.loadGeometry(), A = Ph.types[this.type];
        function L(j) {
          for (var J = 0; J < j.length; J++) {
            var ee = j[J];
            j[J] = [360 * (ee.x + x) / v - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (ee.y + S) / v) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var D = [];
            for (p = 0; p < C.length; p++)
              D[p] = C[p][0];
            L(C = D);
            break;
          case 2:
            for (p = 0; p < C.length; p++)
              L(C[p]);
            break;
          case 3:
            for (C = function(j) {
              var J = j.length;
              if (J <= 1)
                return [j];
              for (var ee, he, oe = [], ge = 0; ge < J; ge++) {
                var we = hO(j[ge]);
                we !== 0 && (he === void 0 && (he = we < 0), he === we < 0 ? (ee && oe.push(ee), ee = [j[ge]]) : ee.push(j[ge]));
              }
              return ee && oe.push(ee), oe;
            }(C), p = 0; p < C.length; p++)
              for (y = 0; y < C[p].length; y++)
                L(C[p][y]);
        }
        C.length === 1 ? C = C[0] : A = "Multi" + A;
        var B = { type: "Feature", geometry: { type: A, coordinates: C }, properties: this.properties };
        return "id" in this && (B.id = this.id), B;
      };
      var vx = _x;
      function _x(r, i) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = r, this._keys = [], this._values = [], this._features = [], r.readFields(fO, this, i), this.length = this._features.length;
      }
      function fO(r, i, l) {
        r === 15 ? i.version = l.readVarint() : r === 1 ? i.name = l.readString() : r === 5 ? i.extent = l.readVarint() : r === 2 ? i._features.push(l.pos) : r === 3 ? i._keys.push(l.readString()) : r === 4 && i._values.push(function(p) {
          for (var y = null, v = p.readVarint() + p.pos; p.pos < v; ) {
            var x = p.readVarint() >> 3;
            y = x === 1 ? p.readString() : x === 2 ? p.readFloat() : x === 3 ? p.readDouble() : x === 4 ? p.readVarint64() : x === 5 ? p.readVarint() : x === 6 ? p.readSVarint() : x === 7 ? p.readBoolean() : null;
          }
          return y;
        }(l));
      }
      function pO(r, i, l) {
        if (r === 3) {
          var p = new vx(l, l.readVarint() + l.pos);
          p.length && (i[p.name] = p);
        }
      }
      _x.prototype.feature = function(r) {
        if (r < 0 || r >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[r];
        var i = this._pbf.readVarint() + this._pbf.pos;
        return new gx(this._pbf, i, this.extent, this._keys, this._values);
      };
      var kh = { VectorTile: function(r, i) {
        this.layers = r.readFields(pO, {}, i);
      }, VectorTileFeature: gx, VectorTileLayer: vx }, dO = kh.VectorTileFeature.types, s_ = Math.pow(2, 13);
      function xp(r, i, l, p, y, v, x, S) {
        r.emplaceBack(i, l, 2 * Math.floor(p * s_) + x, y * s_ * 2, v * s_ * 2, Math.round(S));
      }
      var Wa = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.layoutVertexArray = new Ga(), this.indexArray = new Ts(), this.programConfigurations = new $t(r.layers, r.zoom), this.segments = new W(), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      function mO(r, i) {
        return r.x === i.x && (r.x < 0 || r.x > 8192) || r.y === i.y && (r.y < 0 || r.y > 8192);
      }
      Wa.prototype.populate = function(r, i, l) {
        this.features = [], this.hasPattern = o_("fill-extrusion", this.layers, i);
        for (var p = 0, y = r; p < y.length; p += 1) {
          var v = y[p], x = v.feature, S = v.id, C = v.index, A = v.sourceLayerIndex, L = this.layers[0]._featureFilter.needGeometry, D = Dn(x, L);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), D, l)) {
            var B = { id: S, sourceLayerIndex: A, index: C, geometry: L ? D.geometry : Mn(x), properties: x.properties, type: x.type, patterns: {} };
            this.hasPattern ? this.features.push(a_("fill-extrusion", this.layers, B, this.zoom, i)) : this.addFeature(B, B.geometry, C, l, {}), i.featureIndex.insert(x, B.geometry, C, A, this.index, !0);
          }
        }
      }, Wa.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.features; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, Wa.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, Wa.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, Wa.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, Wa.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, uO), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, Wa.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, Wa.prototype.addFeature = function(r, i, l, p, y) {
        for (var v = 0, x = i_(i, 500); v < x.length; v += 1) {
          for (var S = x[v], C = 0, A = 0, L = S; A < L.length; A += 1)
            C += L[A].length;
          for (var D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), B = 0, j = S; B < j.length; B += 1) {
            var J = j[B];
            if (J.length !== 0 && !((fr = J).every(function(rr) {
              return rr.x < 0;
            }) || fr.every(function(rr) {
              return rr.x > 8192;
            }) || fr.every(function(rr) {
              return rr.y < 0;
            }) || fr.every(function(rr) {
              return rr.y > 8192;
            })))
              for (var ee = 0, he = 0; he < J.length; he++) {
                var oe = J[he];
                if (he >= 1) {
                  var ge = J[he - 1];
                  if (!mO(oe, ge)) {
                    D.vertexLength + 4 > W.MAX_VERTEX_ARRAY_LENGTH && (D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    var we = oe.sub(ge)._perp()._unit(), Te = ge.dist(oe);
                    ee + Te > 32768 && (ee = 0), xp(this.layoutVertexArray, oe.x, oe.y, we.x, we.y, 0, 0, ee), xp(this.layoutVertexArray, oe.x, oe.y, we.x, we.y, 0, 1, ee), xp(this.layoutVertexArray, ge.x, ge.y, we.x, we.y, 0, 0, ee += Te), xp(this.layoutVertexArray, ge.x, ge.y, we.x, we.y, 0, 1, ee);
                    var Oe = D.vertexLength;
                    this.indexArray.emplaceBack(Oe, Oe + 2, Oe + 1), this.indexArray.emplaceBack(Oe + 1, Oe + 2, Oe + 3), D.vertexLength += 4, D.primitiveLength += 2;
                  }
                }
              }
          }
          if (D.vertexLength + C > W.MAX_VERTEX_ARRAY_LENGTH && (D = this.segments.prepareSegment(C, this.layoutVertexArray, this.indexArray)), dO[r.type] === "Polygon") {
            for (var Be = [], Ke = [], ot = D.vertexLength, At = 0, dt = S; At < dt.length; At += 1) {
              var Nt = dt[At];
              if (Nt.length !== 0) {
                Nt !== S[0] && Ke.push(Be.length / 2);
                for (var yt = 0; yt < Nt.length; yt++) {
                  var sr = Nt[yt];
                  xp(this.layoutVertexArray, sr.x, sr.y, 0, 0, 1, 1, 0), Be.push(sr.x), Be.push(sr.y);
                }
              }
            }
            for (var qt = e_(Be, Ke), Mt = 0; Mt < qt.length; Mt += 3)
              this.indexArray.emplaceBack(ot + qt[Mt], ot + qt[Mt + 2], ot + qt[Mt + 1]);
            D.primitiveLength += qt.length / 3, D.vertexLength += C;
          }
        }
        var fr;
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, wt("FillExtrusionBucket", Wa, { omit: ["layers", "features"] });
      var yO = { paint: new Ii({ "fill-extrusion-opacity": new Lt(G["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Tt(G["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Lt(G["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Lt(G["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Eh(G["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Tt(G["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Tt(G["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Lt(G["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) }, gO = function(r) {
        function i(l) {
          r.call(this, l, yO);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new Wa(l);
        }, i.prototype.queryRadius = function() {
          return li(this.paint.get("fill-extrusion-translate"));
        }, i.prototype.is3D = function() {
          return !0;
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C, A) {
          var L = $a(l, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), S.angle, C), D = this.paint.get("fill-extrusion-height").evaluate(p, y), B = this.paint.get("fill-extrusion-base").evaluate(p, y), j = function(ee, he, oe, ge) {
            for (var we = [], Te = 0, Oe = ee; Te < Oe.length; Te += 1) {
              var Be = Oe[Te], Ke = [Be.x, Be.y, 0, 1];
              Oh(Ke, Ke, he), we.push(new T(Ke[0] / Ke[3], Ke[1] / Ke[3]));
            }
            return we;
          }(L, A), J = function(ee, he, oe, ge) {
            for (var we = [], Te = [], Oe = ge[8] * he, Be = ge[9] * he, Ke = ge[10] * he, ot = ge[11] * he, At = ge[8] * oe, dt = ge[9] * oe, Nt = ge[10] * oe, yt = ge[11] * oe, sr = 0, qt = ee; sr < qt.length; sr += 1) {
              for (var Mt = [], fr = [], rr = 0, Mr = qt[sr]; rr < Mr.length; rr += 1) {
                var Rt = Mr[rr], Dr = Rt.x, gn = Rt.y, Cn = ge[0] * Dr + ge[4] * gn + ge[12], In = ge[1] * Dr + ge[5] * gn + ge[13], vn = ge[2] * Dr + ge[6] * gn + ge[14], An = ge[3] * Dr + ge[7] * gn + ge[15], ui = vn + Ke, ci = An + ot, Wi = Cn + At, _i = In + dt, Hi = vn + Nt, Nn = An + yt, xi = new T((Cn + Oe) / ci, (In + Be) / ci);
                xi.z = ui / ci, Mt.push(xi);
                var vr = new T(Wi / Nn, _i / Nn);
                vr.z = Hi / Nn, fr.push(vr);
              }
              we.push(Mt), Te.push(fr);
            }
            return [we, Te];
          }(v, B, D, A);
          return function(ee, he, oe) {
            var ge = 1 / 0;
            ca(oe, he) && (ge = xx(oe, he[0]));
            for (var we = 0; we < he.length; we++)
              for (var Te = he[we], Oe = ee[we], Be = 0; Be < Te.length - 1; Be++) {
                var Ke = Te[Be], ot = [Ke, Te[Be + 1], Oe[Be + 1], Oe[Be], Ke];
                Os(oe, ot) && (ge = Math.min(ge, xx(oe, ot)));
              }
            return ge !== 1 / 0 && ge;
          }(J[0], J[1], j);
        }, i;
      }(wa);
      function bp(r, i) {
        return r.x * i.x + r.y * i.y;
      }
      function xx(r, i) {
        if (r.length === 1) {
          for (var l, p = 0, y = i[p++]; !l || y.equals(l); )
            if (!(l = i[p++]))
              return 1 / 0;
          for (; p < i.length; p++) {
            var v = i[p], x = r[0], S = l.sub(y), C = v.sub(y), A = x.sub(y), L = bp(S, S), D = bp(S, C), B = bp(C, C), j = bp(A, S), J = bp(A, C), ee = L * B - D * D, he = (B * j - D * J) / ee, oe = (L * J - D * j) / ee, ge = y.z * (1 - he - oe) + l.z * he + v.z * oe;
            if (isFinite(ge))
              return ge;
          }
          return 1 / 0;
        }
        for (var we = 1 / 0, Te = 0, Oe = i; Te < Oe.length; Te += 1)
          we = Math.min(we, Oe[Te].z);
        return we;
      }
      var vO = yi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4).members, _O = yi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]).members, xO = kh.VectorTileFeature.types, bO = Math.cos(Math.PI / 180 * 37.5), bx = Math.pow(2, 14) / 0.5, to = function(r) {
        var i = this;
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(l) {
          return l.id;
        }), this.index = r.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(function(l) {
          i.gradients[l.id] = {};
        }), this.layoutVertexArray = new po(), this.layoutVertexArray2 = new iu(), this.indexArray = new Ts(), this.programConfigurations = new $t(r.layers, r.zoom), this.segments = new W(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(function(l) {
          return l.isStateDependent();
        }).map(function(l) {
          return l.id;
        });
      };
      to.prototype.populate = function(r, i, l) {
        this.hasPattern = o_("line", this.layers, i);
        for (var p = this.layers[0].layout.get("line-sort-key"), y = [], v = 0, x = r; v < x.length; v += 1) {
          var S = x[v], C = S.feature, A = S.id, L = S.index, D = S.sourceLayerIndex, B = this.layers[0]._featureFilter.needGeometry, j = Dn(C, B);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), j, l)) {
            var J = p ? p.evaluate(j, {}, l) : void 0, ee = { id: A, properties: C.properties, type: C.type, sourceLayerIndex: D, index: L, geometry: B ? j.geometry : Mn(C), patterns: {}, sortKey: J };
            y.push(ee);
          }
        }
        p && y.sort(function(Ke, ot) {
          return Ke.sortKey - ot.sortKey;
        });
        for (var he = 0, oe = y; he < oe.length; he += 1) {
          var ge = oe[he], we = ge.geometry, Te = ge.index, Oe = ge.sourceLayerIndex;
          if (this.hasPattern) {
            var Be = a_("line", this.layers, ge, this.zoom, i);
            this.patternFeatures.push(Be);
          } else
            this.addFeature(ge, we, Te, l, {});
          i.featureIndex.insert(r[Te].feature, we, Te, Oe, this.index);
        }
      }, to.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, to.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.patternFeatures; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, to.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, to.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, to.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = r.createVertexBuffer(this.layoutVertexArray2, _O)), this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, vO), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, to.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, to.prototype.lineFeatureClips = function(r) {
        if (r.properties && r.properties.hasOwnProperty("mapbox_clip_start") && r.properties.hasOwnProperty("mapbox_clip_end"))
          return { start: +r.properties.mapbox_clip_start, end: +r.properties.mapbox_clip_end };
      }, to.prototype.addFeature = function(r, i, l, p, y) {
        var v = this.layers[0].layout, x = v.get("line-join").evaluate(r, {}), S = v.get("line-cap"), C = v.get("line-miter-limit"), A = v.get("line-round-limit");
        this.lineClips = this.lineFeatureClips(r);
        for (var L = 0, D = i; L < D.length; L += 1)
          this.addLine(D[L], r, x, S, C, A);
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, to.prototype.addLine = function(r, i, l, p, y, v) {
        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
          this.lineClipsArray.push(this.lineClips);
          for (var x = 0; x < r.length - 1; x++)
            this.totalDistance += r[x].dist(r[x + 1]);
          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
        }
        for (var S = xO[i.type] === "Polygon", C = r.length; C >= 2 && r[C - 1].equals(r[C - 2]); )
          C--;
        for (var A = 0; A < C - 1 && r[A].equals(r[A + 1]); )
          A++;
        if (!(C < (S ? 3 : 2))) {
          l === "bevel" && (y = 1.05);
          var L, D = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, B = this.segments.prepareSegment(10 * C, this.layoutVertexArray, this.indexArray), j = void 0, J = void 0, ee = void 0, he = void 0;
          this.e1 = this.e2 = -1, S && (he = r[A].sub(L = r[C - 2])._unit()._perp());
          for (var oe = A; oe < C; oe++)
            if (!(J = oe === C - 1 ? S ? r[A + 1] : void 0 : r[oe + 1]) || !r[oe].equals(J)) {
              he && (ee = he), L && (j = L), L = r[oe], he = J ? J.sub(L)._unit()._perp() : ee;
              var ge = (ee = ee || he).add(he);
              ge.x === 0 && ge.y === 0 || ge._unit();
              var we = ee.x * he.x + ee.y * he.y, Te = ge.x * he.x + ge.y * he.y, Oe = Te !== 0 ? 1 / Te : 1 / 0, Be = 2 * Math.sqrt(2 - 2 * Te), Ke = Te < bO && j && J, ot = ee.x * he.y - ee.y * he.x > 0;
              if (Ke && oe > A) {
                var At = L.dist(j);
                if (At > 2 * D) {
                  var dt = L.sub(L.sub(j)._mult(D / At)._round());
                  this.updateDistance(j, dt), this.addCurrentVertex(dt, ee, 0, 0, B), j = dt;
                }
              }
              var Nt = j && J, yt = Nt ? l : S ? "butt" : p;
              if (Nt && yt === "round" && (Oe < v ? yt = "miter" : Oe <= 2 && (yt = "fakeround")), yt === "miter" && Oe > y && (yt = "bevel"), yt === "bevel" && (Oe > 2 && (yt = "flipbevel"), Oe < y && (yt = "miter")), j && this.updateDistance(j, L), yt === "miter")
                ge._mult(Oe), this.addCurrentVertex(L, ge, 0, 0, B);
              else if (yt === "flipbevel") {
                if (Oe > 100)
                  ge = he.mult(-1);
                else {
                  var sr = Oe * ee.add(he).mag() / ee.sub(he).mag();
                  ge._perp()._mult(sr * (ot ? -1 : 1));
                }
                this.addCurrentVertex(L, ge, 0, 0, B), this.addCurrentVertex(L, ge.mult(-1), 0, 0, B);
              } else if (yt === "bevel" || yt === "fakeround") {
                var qt = -Math.sqrt(Oe * Oe - 1), Mt = ot ? qt : 0, fr = ot ? 0 : qt;
                if (j && this.addCurrentVertex(L, ee, Mt, fr, B), yt === "fakeround")
                  for (var rr = Math.round(180 * Be / Math.PI / 20), Mr = 1; Mr < rr; Mr++) {
                    var Rt = Mr / rr;
                    if (Rt !== 0.5) {
                      var Dr = Rt - 0.5;
                      Rt += Rt * Dr * (Rt - 1) * ((1.0904 + we * (we * (3.55645 - 1.43519 * we) - 3.2452)) * Dr * Dr + (0.848013 + we * (0.215638 * we - 1.06021)));
                    }
                    var gn = he.sub(ee)._mult(Rt)._add(ee)._unit()._mult(ot ? -1 : 1);
                    this.addHalfVertex(L, gn.x, gn.y, !1, ot, 0, B);
                  }
                J && this.addCurrentVertex(L, he, -Mt, -fr, B);
              } else if (yt === "butt")
                this.addCurrentVertex(L, ge, 0, 0, B);
              else if (yt === "square") {
                var Cn = j ? 1 : -1;
                this.addCurrentVertex(L, ge, Cn, Cn, B);
              } else
                yt === "round" && (j && (this.addCurrentVertex(L, ee, 0, 0, B), this.addCurrentVertex(L, ee, 1, 1, B, !0)), J && (this.addCurrentVertex(L, he, -1, -1, B, !0), this.addCurrentVertex(L, he, 0, 0, B)));
              if (Ke && oe < C - 1) {
                var In = L.dist(J);
                if (In > 2 * D) {
                  var vn = L.add(J.sub(L)._mult(D / In)._round());
                  this.updateDistance(L, vn), this.addCurrentVertex(vn, he, 0, 0, B), L = vn;
                }
              }
            }
        }
      }, to.prototype.addCurrentVertex = function(r, i, l, p, y, v) {
        v === void 0 && (v = !1);
        var x = i.y * p - i.x, S = -i.y - i.x * p;
        this.addHalfVertex(r, i.x + i.y * l, i.y - i.x * l, v, !1, l, y), this.addHalfVertex(r, x, S, v, !0, -p, y), this.distance > bx / 2 && this.totalDistance === 0 && (this.distance = 0, this.addCurrentVertex(r, i, l, p, y, v));
      }, to.prototype.addHalfVertex = function(r, i, l, p, y, v, x) {
        var S = 0.5 * (this.lineClips ? this.scaledDistance * (bx - 1) : this.scaledDistance);
        this.layoutVertexArray.emplaceBack((r.x << 1) + (p ? 1 : 0), (r.y << 1) + (y ? 1 : 0), Math.round(63 * i) + 128, Math.round(63 * l) + 128, 1 + (v === 0 ? 0 : v < 0 ? -1 : 1) | (63 & S) << 2, S >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
        var C = x.vertexLength++;
        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, C), x.primitiveLength++), y ? this.e2 = C : this.e1 = C;
      }, to.prototype.updateScaledDistance = function() {
        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
      }, to.prototype.updateDistance = function(r, i) {
        this.distance += r.dist(i), this.updateScaledDistance();
      }, wt("LineBucket", to, { omit: ["layers", "patternFeatures"] });
      var wO = new Ii({ "line-cap": new Lt(G.layout_line["line-cap"]), "line-join": new Tt(G.layout_line["line-join"]), "line-miter-limit": new Lt(G.layout_line["line-miter-limit"]), "line-round-limit": new Lt(G.layout_line["line-round-limit"]), "line-sort-key": new Tt(G.layout_line["line-sort-key"]) }), wx = { paint: new Ii({ "line-opacity": new Tt(G.paint_line["line-opacity"]), "line-color": new Tt(G.paint_line["line-color"]), "line-translate": new Lt(G.paint_line["line-translate"]), "line-translate-anchor": new Lt(G.paint_line["line-translate-anchor"]), "line-width": new Tt(G.paint_line["line-width"]), "line-gap-width": new Tt(G.paint_line["line-gap-width"]), "line-offset": new Tt(G.paint_line["line-offset"]), "line-blur": new Tt(G.paint_line["line-blur"]), "line-dasharray": new Gi(G.paint_line["line-dasharray"]), "line-pattern": new Eh(G.paint_line["line-pattern"]), "line-gradient": new ua(G.paint_line["line-gradient"]) }), layout: wO }, Ex = new (function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.possiblyEvaluate = function(l, p) {
          return p = new mr(Math.floor(p.zoom), { now: p.now, fadeDuration: p.fadeDuration, zoomHistory: p.zoomHistory, transition: p.transition }), r.prototype.possiblyEvaluate.call(this, l, p);
        }, i.prototype.evaluate = function(l, p, y, v) {
          return p = X({}, p, { zoom: Math.floor(p.zoom) }), r.prototype.evaluate.call(this, l, p, y, v);
        }, i;
      }(Tt))(wx.paint.properties["line-width"].specification);
      Ex.useIntegerZoom = !0;
      var EO = function(r) {
        function i(l) {
          r.call(this, l, wx), this.gradientVersion = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
          l === "line-gradient" && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof lo, this.gradientVersion = (this.gradientVersion + 1) % P);
        }, i.prototype.gradientExpression = function() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }, i.prototype.recalculate = function(l, p) {
          r.prototype.recalculate.call(this, l, p), this.paint._values["line-floorwidth"] = Ex.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, l);
        }, i.prototype.createBucket = function(l) {
          return new to(l);
        }, i.prototype.queryRadius = function(l) {
          var p = l, y = Sx(Ta("line-width", this, p), Ta("line-gap-width", this, p)), v = Ta("line-offset", this, p);
          return y / 2 + Math.abs(v) + li(this.paint.get("line-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C) {
          var A = $a(l, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), S.angle, C), L = C / 2 * Sx(this.paint.get("line-width").evaluate(p, y), this.paint.get("line-gap-width").evaluate(p, y)), D = this.paint.get("line-offset").evaluate(p, y);
          return D && (v = function(B, j) {
            for (var J = [], ee = new T(0, 0), he = 0; he < B.length; he++) {
              for (var oe = B[he], ge = [], we = 0; we < oe.length; we++) {
                var Te = oe[we], Oe = oe[we + 1], Be = we === 0 ? ee : Te.sub(oe[we - 1])._unit()._perp(), Ke = we === oe.length - 1 ? ee : Oe.sub(Te)._unit()._perp(), ot = Be._add(Ke)._unit();
                ot._mult(1 / (ot.x * Ke.x + ot.y * Ke.y)), ge.push(ot._mult(j)._add(Te));
              }
              J.push(ge);
            }
            return J;
          }(v, D * C)), function(B, j, J) {
            for (var ee = 0; ee < j.length; ee++) {
              var he = j[ee];
              if (B.length >= 3) {
                for (var oe = 0; oe < he.length; oe++)
                  if (Sa(B, he[oe]))
                    return !0;
              }
              if (Zo(B, he, J))
                return !0;
            }
            return !1;
          }(A, v, L);
        }, i.prototype.isTileClipped = function() {
          return !0;
        }, i;
      }(wa);
      function Sx(r, i) {
        return i > 0 ? i + 2 * r : r;
      }
      var SO = yi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), TO = yi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), MO = (yi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), yi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }])), Tx = (yi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]), yi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), IO = yi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function OO(r, i, l) {
        return r.sections.forEach(function(p) {
          p.text = function(y, v, x) {
            var S = v.layout.get("text-transform").evaluate(x, {});
            return S === "uppercase" ? y = y.toLocaleUpperCase() : S === "lowercase" && (y = y.toLocaleLowerCase()), Io.applyArabicShaping && (y = Io.applyArabicShaping(y)), y;
          }(p.text, i, l);
        }), r;
      }
      yi([{ name: "triangle", components: 3, type: "Uint16" }]), yi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), yi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), yi([{ type: "Float32", name: "offsetX" }]), yi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
      var wp = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" }, Mx = function(r, i, l, p, y) {
        var v, x, S = 8 * y - p - 1, C = (1 << S) - 1, A = C >> 1, L = -7, D = l ? y - 1 : 0, B = l ? -1 : 1, j = r[i + D];
        for (D += B, v = j & (1 << -L) - 1, j >>= -L, L += S; L > 0; v = 256 * v + r[i + D], D += B, L -= 8)
          ;
        for (x = v & (1 << -L) - 1, v >>= -L, L += p; L > 0; x = 256 * x + r[i + D], D += B, L -= 8)
          ;
        if (v === 0)
          v = 1 - A;
        else {
          if (v === C)
            return x ? NaN : 1 / 0 * (j ? -1 : 1);
          x += Math.pow(2, p), v -= A;
        }
        return (j ? -1 : 1) * x * Math.pow(2, v - p);
      }, Ix = function(r, i, l, p, y, v) {
        var x, S, C, A = 8 * v - y - 1, L = (1 << A) - 1, D = L >> 1, B = y === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, j = p ? 0 : v - 1, J = p ? 1 : -1, ee = i < 0 || i === 0 && 1 / i < 0 ? 1 : 0;
        for (i = Math.abs(i), isNaN(i) || i === 1 / 0 ? (S = isNaN(i) ? 1 : 0, x = L) : (x = Math.floor(Math.log(i) / Math.LN2), i * (C = Math.pow(2, -x)) < 1 && (x--, C *= 2), (i += x + D >= 1 ? B / C : B * Math.pow(2, 1 - D)) * C >= 2 && (x++, C /= 2), x + D >= L ? (S = 0, x = L) : x + D >= 1 ? (S = (i * C - 1) * Math.pow(2, y), x += D) : (S = i * Math.pow(2, D - 1) * Math.pow(2, y), x = 0)); y >= 8; r[l + j] = 255 & S, j += J, S /= 256, y -= 8)
          ;
        for (x = x << y | S, A += y; A > 0; r[l + j] = 255 & x, j += J, x /= 256, A -= 8)
          ;
        r[l + j - J] |= 128 * ee;
      }, jm = tn;
      function tn(r) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(r) ? r : new Uint8Array(r || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      tn.Varint = 0, tn.Fixed64 = 1, tn.Bytes = 2, tn.Fixed32 = 5;
      var Ox = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
      function Tl(r) {
        return r.type === tn.Bytes ? r.readVarint() + r.pos : r.pos + 1;
      }
      function Lh(r, i, l) {
        return l ? 4294967296 * i + (r >>> 0) : 4294967296 * (i >>> 0) + (r >>> 0);
      }
      function Cx(r, i, l) {
        var p = i <= 16383 ? 1 : i <= 2097151 ? 2 : i <= 268435455 ? 3 : Math.floor(Math.log(i) / (7 * Math.LN2));
        l.realloc(p);
        for (var y = l.pos - 1; y >= r; y--)
          l.buf[y + p] = l.buf[y];
      }
      function CO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeVarint(r[l]);
      }
      function AO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSVarint(r[l]);
      }
      function PO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFloat(r[l]);
      }
      function kO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeDouble(r[l]);
      }
      function LO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeBoolean(r[l]);
      }
      function DO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFixed32(r[l]);
      }
      function NO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSFixed32(r[l]);
      }
      function RO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFixed64(r[l]);
      }
      function zO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSFixed64(r[l]);
      }
      function Gm(r, i) {
        return (r[i] | r[i + 1] << 8 | r[i + 2] << 16) + 16777216 * r[i + 3];
      }
      function Dh(r, i, l) {
        r[l] = i, r[l + 1] = i >>> 8, r[l + 2] = i >>> 16, r[l + 3] = i >>> 24;
      }
      function Ax(r, i) {
        return (r[i] | r[i + 1] << 8 | r[i + 2] << 16) + (r[i + 3] << 24);
      }
      function FO(r, i, l) {
        r === 1 && l.readMessage(BO, i);
      }
      function BO(r, i, l) {
        if (r === 3) {
          var p = l.readMessage(VO, {}), y = p.width, v = p.height, x = p.left, S = p.top, C = p.advance;
          i.push({ id: p.id, bitmap: new gc({ width: y + 6, height: v + 6 }, p.bitmap), metrics: { width: y, height: v, left: x, top: S, advance: C } });
        }
      }
      function VO(r, i, l) {
        r === 1 ? i.id = l.readVarint() : r === 2 ? i.bitmap = l.readBytes() : r === 3 ? i.width = l.readVarint() : r === 4 ? i.height = l.readVarint() : r === 5 ? i.left = l.readSVarint() : r === 6 ? i.top = l.readSVarint() : r === 7 && (i.advance = l.readVarint());
      }
      function Px(r) {
        for (var i = 0, l = 0, p = 0, y = r; p < y.length; p += 1) {
          var v = y[p];
          i += v.w * v.h, l = Math.max(l, v.w);
        }
        r.sort(function(ee, he) {
          return he.h - ee.h;
        });
        for (var x = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(i / 0.95)), l), h: 1 / 0 }], S = 0, C = 0, A = 0, L = r; A < L.length; A += 1)
          for (var D = L[A], B = x.length - 1; B >= 0; B--) {
            var j = x[B];
            if (!(D.w > j.w || D.h > j.h)) {
              if (D.x = j.x, D.y = j.y, C = Math.max(C, D.y + D.h), S = Math.max(S, D.x + D.w), D.w === j.w && D.h === j.h) {
                var J = x.pop();
                B < x.length && (x[B] = J);
              } else
                D.h === j.h ? (j.x += D.w, j.w -= D.w) : D.w === j.w ? (j.y += D.h, j.h -= D.h) : (x.push({ x: j.x + D.w, y: j.y, w: j.w - D.w, h: D.h }), j.y += D.h, j.h -= D.h);
              break;
            }
          }
        return { w: S, h: C, fill: i / (S * C) || 0 };
      }
      tn.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(r, i, l) {
        for (l = l || this.length; this.pos < l; ) {
          var p = this.readVarint(), y = p >> 3, v = this.pos;
          this.type = 7 & p, r(y, i, this), this.pos === v && this.skip(p);
        }
        return i;
      }, readMessage: function(r, i) {
        return this.readFields(r, i, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var r = Gm(this.buf, this.pos);
        return this.pos += 4, r;
      }, readSFixed32: function() {
        var r = Ax(this.buf, this.pos);
        return this.pos += 4, r;
      }, readFixed64: function() {
        var r = Gm(this.buf, this.pos) + 4294967296 * Gm(this.buf, this.pos + 4);
        return this.pos += 8, r;
      }, readSFixed64: function() {
        var r = Gm(this.buf, this.pos) + 4294967296 * Ax(this.buf, this.pos + 4);
        return this.pos += 8, r;
      }, readFloat: function() {
        var r = Mx(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, r;
      }, readDouble: function() {
        var r = Mx(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, r;
      }, readVarint: function(r) {
        var i, l, p = this.buf;
        return i = 127 & (l = p[this.pos++]), l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 7, l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 14, l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 21, l < 128 ? i : function(y, v, x) {
          var S, C, A = x.buf;
          if (S = (112 & (C = A[x.pos++])) >> 4, C < 128 || (S |= (127 & (C = A[x.pos++])) << 3, C < 128) || (S |= (127 & (C = A[x.pos++])) << 10, C < 128) || (S |= (127 & (C = A[x.pos++])) << 17, C < 128) || (S |= (127 & (C = A[x.pos++])) << 24, C < 128) || (S |= (1 & (C = A[x.pos++])) << 31, C < 128))
            return Lh(y, S, v);
          throw new Error("Expected varint not more than 10 bytes");
        }(i |= (15 & (l = p[this.pos])) << 28, r, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var r = this.readVarint();
        return r % 2 == 1 ? (r + 1) / -2 : r / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var r = this.readVarint() + this.pos, i = this.pos;
        return this.pos = r, r - i >= 12 && Ox ? function(l, p, y) {
          return Ox.decode(l.subarray(p, y));
        }(this.buf, i, r) : function(l, p, y) {
          for (var v = "", x = p; x < y; ) {
            var S, C, A, L = l[x], D = null, B = L > 239 ? 4 : L > 223 ? 3 : L > 191 ? 2 : 1;
            if (x + B > y)
              break;
            B === 1 ? L < 128 && (D = L) : B === 2 ? (192 & (S = l[x + 1])) == 128 && (D = (31 & L) << 6 | 63 & S) <= 127 && (D = null) : B === 3 ? (C = l[x + 2], (192 & (S = l[x + 1])) == 128 && (192 & C) == 128 && ((D = (15 & L) << 12 | (63 & S) << 6 | 63 & C) <= 2047 || D >= 55296 && D <= 57343) && (D = null)) : B === 4 && (C = l[x + 2], A = l[x + 3], (192 & (S = l[x + 1])) == 128 && (192 & C) == 128 && (192 & A) == 128 && ((D = (15 & L) << 18 | (63 & S) << 12 | (63 & C) << 6 | 63 & A) <= 65535 || D >= 1114112) && (D = null)), D === null ? (D = 65533, B = 1) : D > 65535 && (D -= 65536, v += String.fromCharCode(D >>> 10 & 1023 | 55296), D = 56320 | 1023 & D), v += String.fromCharCode(D), x += B;
          }
          return v;
        }(this.buf, i, r);
      }, readBytes: function() {
        var r = this.readVarint() + this.pos, i = this.buf.subarray(this.pos, r);
        return this.pos = r, i;
      }, readPackedVarint: function(r, i) {
        if (this.type !== tn.Bytes)
          return r.push(this.readVarint(i));
        var l = Tl(this);
        for (r = r || []; this.pos < l; )
          r.push(this.readVarint(i));
        return r;
      }, readPackedSVarint: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSVarint());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSVarint());
        return r;
      }, readPackedBoolean: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readBoolean());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readBoolean());
        return r;
      }, readPackedFloat: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFloat());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFloat());
        return r;
      }, readPackedDouble: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readDouble());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readDouble());
        return r;
      }, readPackedFixed32: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFixed32());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFixed32());
        return r;
      }, readPackedSFixed32: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSFixed32());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSFixed32());
        return r;
      }, readPackedFixed64: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFixed64());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFixed64());
        return r;
      }, readPackedSFixed64: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSFixed64());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSFixed64());
        return r;
      }, skip: function(r) {
        var i = 7 & r;
        if (i === tn.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (i === tn.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (i === tn.Fixed32)
          this.pos += 4;
        else {
          if (i !== tn.Fixed64)
            throw new Error("Unimplemented type: " + i);
          this.pos += 8;
        }
      }, writeTag: function(r, i) {
        this.writeVarint(r << 3 | i);
      }, realloc: function(r) {
        for (var i = this.length || 16; i < this.pos + r; )
          i *= 2;
        if (i !== this.length) {
          var l = new Uint8Array(i);
          l.set(this.buf), this.buf = l, this.length = i;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(r) {
        this.realloc(4), Dh(this.buf, r, this.pos), this.pos += 4;
      }, writeSFixed32: function(r) {
        this.realloc(4), Dh(this.buf, r, this.pos), this.pos += 4;
      }, writeFixed64: function(r) {
        this.realloc(8), Dh(this.buf, -1 & r, this.pos), Dh(this.buf, Math.floor(r * (1 / 4294967296)), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(r) {
        this.realloc(8), Dh(this.buf, -1 & r, this.pos), Dh(this.buf, Math.floor(r * (1 / 4294967296)), this.pos + 4), this.pos += 8;
      }, writeVarint: function(r) {
        (r = +r || 0) > 268435455 || r < 0 ? function(i, l) {
          var p, y;
          if (i >= 0 ? (p = i % 4294967296 | 0, y = i / 4294967296 | 0) : (y = ~(-i / 4294967296), 4294967295 ^ (p = ~(-i % 4294967296)) ? p = p + 1 | 0 : (p = 0, y = y + 1 | 0)), i >= 18446744073709552e3 || i < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          l.realloc(10), function(v, x, S) {
            S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, S.buf[S.pos] = 127 & (v >>>= 7);
          }(p, 0, l), function(v, x) {
            var S = (7 & v) << 4;
            x.buf[x.pos++] |= S | ((v >>>= 3) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v)))));
          }(y, l);
        }(r, this) : (this.realloc(4), this.buf[this.pos++] = 127 & r | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = r >>> 7 & 127))));
      }, writeSVarint: function(r) {
        this.writeVarint(r < 0 ? 2 * -r - 1 : 2 * r);
      }, writeBoolean: function(r) {
        this.writeVarint(Boolean(r));
      }, writeString: function(r) {
        r = String(r), this.realloc(4 * r.length), this.pos++;
        var i = this.pos;
        this.pos = function(p, y, v) {
          for (var x, S, C = 0; C < y.length; C++) {
            if ((x = y.charCodeAt(C)) > 55295 && x < 57344) {
              if (!S) {
                x > 56319 || C + 1 === y.length ? (p[v++] = 239, p[v++] = 191, p[v++] = 189) : S = x;
                continue;
              }
              if (x < 56320) {
                p[v++] = 239, p[v++] = 191, p[v++] = 189, S = x;
                continue;
              }
              x = S - 55296 << 10 | x - 56320 | 65536, S = null;
            } else
              S && (p[v++] = 239, p[v++] = 191, p[v++] = 189, S = null);
            x < 128 ? p[v++] = x : (x < 2048 ? p[v++] = x >> 6 | 192 : (x < 65536 ? p[v++] = x >> 12 | 224 : (p[v++] = x >> 18 | 240, p[v++] = x >> 12 & 63 | 128), p[v++] = x >> 6 & 63 | 128), p[v++] = 63 & x | 128);
          }
          return v;
        }(this.buf, r, this.pos);
        var l = this.pos - i;
        l >= 128 && Cx(i, l, this), this.pos = i - 1, this.writeVarint(l), this.pos += l;
      }, writeFloat: function(r) {
        this.realloc(4), Ix(this.buf, r, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(r) {
        this.realloc(8), Ix(this.buf, r, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(r) {
        var i = r.length;
        this.writeVarint(i), this.realloc(i);
        for (var l = 0; l < i; l++)
          this.buf[this.pos++] = r[l];
      }, writeRawMessage: function(r, i) {
        this.pos++;
        var l = this.pos;
        r(i, this);
        var p = this.pos - l;
        p >= 128 && Cx(l, p, this), this.pos = l - 1, this.writeVarint(p), this.pos += p;
      }, writeMessage: function(r, i, l) {
        this.writeTag(r, tn.Bytes), this.writeRawMessage(i, l);
      }, writePackedVarint: function(r, i) {
        i.length && this.writeMessage(r, CO, i);
      }, writePackedSVarint: function(r, i) {
        i.length && this.writeMessage(r, AO, i);
      }, writePackedBoolean: function(r, i) {
        i.length && this.writeMessage(r, LO, i);
      }, writePackedFloat: function(r, i) {
        i.length && this.writeMessage(r, PO, i);
      }, writePackedDouble: function(r, i) {
        i.length && this.writeMessage(r, kO, i);
      }, writePackedFixed32: function(r, i) {
        i.length && this.writeMessage(r, DO, i);
      }, writePackedSFixed32: function(r, i) {
        i.length && this.writeMessage(r, NO, i);
      }, writePackedFixed64: function(r, i) {
        i.length && this.writeMessage(r, RO, i);
      }, writePackedSFixed64: function(r, i) {
        i.length && this.writeMessage(r, zO, i);
      }, writeBytesField: function(r, i) {
        this.writeTag(r, tn.Bytes), this.writeBytes(i);
      }, writeFixed32Field: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeFixed32(i);
      }, writeSFixed32Field: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeSFixed32(i);
      }, writeFixed64Field: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeFixed64(i);
      }, writeSFixed64Field: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeSFixed64(i);
      }, writeVarintField: function(r, i) {
        this.writeTag(r, tn.Varint), this.writeVarint(i);
      }, writeSVarintField: function(r, i) {
        this.writeTag(r, tn.Varint), this.writeSVarint(i);
      }, writeStringField: function(r, i) {
        this.writeTag(r, tn.Bytes), this.writeString(i);
      }, writeFloatField: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeFloat(i);
      }, writeDoubleField: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeDouble(i);
      }, writeBooleanField: function(r, i) {
        this.writeVarintField(r, Boolean(i));
      } };
      var $m = function(r, i) {
        var l = i.pixelRatio, p = i.version, y = i.stretchX, v = i.stretchY, x = i.content;
        this.paddedRect = r, this.pixelRatio = l, this.stretchX = y, this.stretchY = v, this.content = x, this.version = p;
      }, Ep = { tl: { configurable: !0 }, br: { configurable: !0 }, tlbr: { configurable: !0 }, displaySize: { configurable: !0 } };
      Ep.tl.get = function() {
        return [this.paddedRect.x + 1, this.paddedRect.y + 1];
      }, Ep.br.get = function() {
        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
      }, Ep.tlbr.get = function() {
        return this.tl.concat(this.br);
      }, Ep.displaySize.get = function() {
        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
      }, Object.defineProperties($m.prototype, Ep);
      var Sp = function(r, i) {
        var l = {}, p = {};
        this.haveRenderCallbacks = [];
        var y = [];
        this.addImages(r, l, y), this.addImages(i, p, y);
        var v = Px(y), x = new yo({ width: v.w || 1, height: v.h || 1 });
        for (var S in r) {
          var C = r[S], A = l[S].paddedRect;
          yo.copy(C.data, x, { x: 0, y: 0 }, { x: A.x + 1, y: A.y + 1 }, C.data);
        }
        for (var L in i) {
          var D = i[L], B = p[L].paddedRect, j = B.x + 1, J = B.y + 1, ee = D.data.width, he = D.data.height;
          yo.copy(D.data, x, { x: 0, y: 0 }, { x: j, y: J }, D.data), yo.copy(D.data, x, { x: 0, y: he - 1 }, { x: j, y: J - 1 }, { width: ee, height: 1 }), yo.copy(D.data, x, { x: 0, y: 0 }, { x: j, y: J + he }, { width: ee, height: 1 }), yo.copy(D.data, x, { x: ee - 1, y: 0 }, { x: j - 1, y: J }, { width: 1, height: he }), yo.copy(D.data, x, { x: 0, y: 0 }, { x: j + ee, y: J }, { width: 1, height: he });
        }
        this.image = x, this.iconPositions = l, this.patternPositions = p;
      };
      Sp.prototype.addImages = function(r, i, l) {
        for (var p in r) {
          var y = r[p], v = { x: 0, y: 0, w: y.data.width + 2, h: y.data.height + 2 };
          l.push(v), i[p] = new $m(v, y), y.hasRenderCallback && this.haveRenderCallbacks.push(p);
        }
      }, Sp.prototype.patchUpdatedImages = function(r, i) {
        for (var l in r.dispatchRenderCallbacks(this.haveRenderCallbacks), r.updatedImages)
          this.patchUpdatedImage(this.iconPositions[l], r.getImage(l), i), this.patchUpdatedImage(this.patternPositions[l], r.getImage(l), i);
      }, Sp.prototype.patchUpdatedImage = function(r, i, l) {
        if (r && i && r.version !== i.version) {
          r.version = i.version;
          var p = r.tl;
          l.update(i.data, void 0, { x: p[0], y: p[1] });
        }
      }, wt("ImagePosition", $m), wt("ImageAtlas", Sp);
      var Xo = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, Nh = function() {
        this.scale = 1, this.fontStack = "", this.imageName = null;
      };
      Nh.forText = function(r, i) {
        var l = new Nh();
        return l.scale = r || 1, l.fontStack = i, l;
      }, Nh.forImage = function(r) {
        var i = new Nh();
        return i.imageName = r, i;
      };
      var qi = function() {
        this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
      };
      function qm(r, i, l, p, y, v, x, S, C, A, L, D, B, j, J, ee) {
        var he, oe = qi.fromFeature(r, y);
        D === Xo.vertical && oe.verticalizePunctuation();
        var ge = Io.processBidirectionalText, we = Io.processStyledBidirectionalText;
        if (ge && oe.sections.length === 1) {
          he = [];
          for (var Te = 0, Oe = ge(oe.toString(), l_(oe, A, v, i, p, j, J)); Te < Oe.length; Te += 1) {
            var Be = Oe[Te], Ke = new qi();
            Ke.text = Be, Ke.sections = oe.sections;
            for (var ot = 0; ot < Be.length; ot++)
              Ke.sectionIndex.push(0);
            he.push(Ke);
          }
        } else if (we) {
          he = [];
          for (var At = 0, dt = we(oe.text, oe.sectionIndex, l_(oe, A, v, i, p, j, J)); At < dt.length; At += 1) {
            var Nt = dt[At], yt = new qi();
            yt.text = Nt[0], yt.sectionIndex = Nt[1], yt.sections = oe.sections, he.push(yt);
          }
        } else
          he = function(Mt, fr) {
            for (var rr = [], Mr = Mt.text, Rt = 0, Dr = 0, gn = fr; Dr < gn.length; Dr += 1) {
              var Cn = gn[Dr];
              rr.push(Mt.substring(Rt, Cn)), Rt = Cn;
            }
            return Rt < Mr.length && rr.push(Mt.substring(Rt, Mr.length)), rr;
          }(oe, l_(oe, A, v, i, p, j, J));
        var sr = [], qt = { positionedLines: sr, text: oe.toString(), top: L[1], bottom: L[1], left: L[0], right: L[0], writingMode: D, iconsInText: !1, verticalizable: !1 };
        return function(Mt, fr, rr, Mr, Rt, Dr, gn, Cn, In, vn, An, ui) {
          for (var ci = 0, Wi = -17, _i = 0, Hi = 0, Nn = Cn === "right" ? 1 : Cn === "left" ? 0 : 0.5, xi = 0, vr = 0, Xr = Rt; vr < Xr.length; vr += 1) {
            var qr = Xr[vr];
            qr.trim();
            var Or = qr.getMaxScale(), ro = 24 * (Or - 1), Ni = { positionedGlyphs: [], lineOffset: 0 };
            Mt.positionedLines[xi] = Ni;
            var sn = Ni.positionedGlyphs, $n = 0;
            if (qr.length()) {
              for (var Ri = 0; Ri < qr.length(); Ri++) {
                var Nr = qr.getSection(Ri), Ps = qr.getSectionIndex(Ri), Ko = qr.getCharCode(Ri), ks = 0, Rn = null, Ls = null, Ma = null, Gh = 24, bc = !(In === Xo.horizontal || !An && !xh(Ko) || An && (Wm[Ko] || (Cl = Ko, ct.Arabic(Cl) || ct["Arabic Supplement"](Cl) || ct["Arabic Extended-A"](Cl) || ct["Arabic Presentation Forms-A"](Cl) || ct["Arabic Presentation Forms-B"](Cl))));
                if (Nr.imageName) {
                  var $h = Mr[Nr.imageName];
                  if (!$h)
                    continue;
                  Ma = Nr.imageName, Mt.iconsInText = Mt.iconsInText || !0, Ls = $h.paddedRect;
                  var Ol = $h.displaySize;
                  Nr.scale = 24 * Nr.scale / ui, ks = ro + (24 - Ol[1] * Nr.scale), Gh = (Rn = { width: Ol[0], height: Ol[1], left: 1, top: -3, advance: bc ? Ol[1] : Ol[0] }).advance;
                  var qh = bc ? Ol[0] * Nr.scale - 24 * Or : Ol[1] * Nr.scale - 24 * Or;
                  qh > 0 && qh > $n && ($n = qh);
                } else {
                  var ty = rr[Nr.fontStack], Wh = ty && ty[Ko];
                  if (Wh && Wh.rect)
                    Ls = Wh.rect, Rn = Wh.metrics;
                  else {
                    var Ip = fr[Nr.fontStack], ry = Ip && Ip[Ko];
                    if (!ry)
                      continue;
                    Rn = ry.metrics;
                  }
                  ks = 24 * (Or - Nr.scale);
                }
                bc ? (Mt.verticalizable = !0, sn.push({ glyph: Ko, imageName: Ma, x: ci, y: Wi + ks, vertical: bc, scale: Nr.scale, fontStack: Nr.fontStack, sectionIndex: Ps, metrics: Rn, rect: Ls }), ci += Gh * Nr.scale + vn) : (sn.push({ glyph: Ko, imageName: Ma, x: ci, y: Wi + ks, vertical: bc, scale: Nr.scale, fontStack: Nr.fontStack, sectionIndex: Ps, metrics: Rn, rect: Ls }), ci += Rn.advance * Nr.scale + vn);
              }
              sn.length !== 0 && (_i = Math.max(ci - vn, _i), jO(sn, 0, sn.length - 1, Nn, $n)), ci = 0;
              var ny = Dr * Or + $n;
              Ni.lineOffset = Math.max($n, ro), Wi += ny, Hi = Math.max(ny, Hi), ++xi;
            } else
              Wi += Dr, ++xi;
          }
          var Cl, Op = Wi - -17, Hh = u_(gn), fu = Hh.horizontalAlign, Zh = Hh.verticalAlign;
          (function(iy, oy, Cp, Ap, ay, Pp, kp, Lp, sy) {
            var Xh, ly = (oy - Cp) * ay;
            Xh = Pp !== kp ? -Lp * Ap - -17 : (-Ap * sy + 0.5) * kp;
            for (var Kh = 0, Dp = iy; Kh < Dp.length; Kh += 1)
              for (var wc = 0, Np = Dp[Kh].positionedGlyphs; wc < Np.length; wc += 1) {
                var Yh = Np[wc];
                Yh.x += ly, Yh.y += Xh;
              }
          })(Mt.positionedLines, Nn, fu, Zh, _i, Hi, Dr, Op, Rt.length), Mt.top += -Zh * Op, Mt.bottom = Mt.top + Op, Mt.left += -fu * _i, Mt.right = Mt.left + _i;
        }(qt, i, l, p, he, x, S, C, D, A, B, ee), !function(Mt) {
          for (var fr = 0, rr = Mt; fr < rr.length; fr += 1)
            if (rr[fr].positionedGlyphs.length !== 0)
              return !1;
          return !0;
        }(sr) && qt;
      }
      qi.fromFeature = function(r, i) {
        for (var l = new qi(), p = 0; p < r.sections.length; p++) {
          var y = r.sections[p];
          y.image ? l.addImageSection(y) : l.addTextSection(y, i);
        }
        return l;
      }, qi.prototype.length = function() {
        return this.text.length;
      }, qi.prototype.getSection = function(r) {
        return this.sections[this.sectionIndex[r]];
      }, qi.prototype.getSectionIndex = function(r) {
        return this.sectionIndex[r];
      }, qi.prototype.getCharCode = function(r) {
        return this.text.charCodeAt(r);
      }, qi.prototype.verticalizePunctuation = function() {
        this.text = function(r) {
          for (var i = "", l = 0; l < r.length; l++) {
            var p = r.charCodeAt(l + 1) || null, y = r.charCodeAt(l - 1) || null;
            i += p && sp(p) && !wp[r[l + 1]] || y && sp(y) && !wp[r[l - 1]] || !wp[r[l]] ? r[l] : wp[r[l]];
          }
          return i;
        }(this.text);
      }, qi.prototype.trim = function() {
        for (var r = 0, i = 0; i < this.text.length && Wm[this.text.charCodeAt(i)]; i++)
          r++;
        for (var l = this.text.length, p = this.text.length - 1; p >= 0 && p >= r && Wm[this.text.charCodeAt(p)]; p--)
          l--;
        this.text = this.text.substring(r, l), this.sectionIndex = this.sectionIndex.slice(r, l);
      }, qi.prototype.substring = function(r, i) {
        var l = new qi();
        return l.text = this.text.substring(r, i), l.sectionIndex = this.sectionIndex.slice(r, i), l.sections = this.sections, l;
      }, qi.prototype.toString = function() {
        return this.text;
      }, qi.prototype.getMaxScale = function() {
        var r = this;
        return this.sectionIndex.reduce(function(i, l) {
          return Math.max(i, r.sections[l].scale);
        }, 0);
      }, qi.prototype.addTextSection = function(r, i) {
        this.text += r.text, this.sections.push(Nh.forText(r.scale, r.fontStack || i));
        for (var l = this.sections.length - 1, p = 0; p < r.text.length; ++p)
          this.sectionIndex.push(l);
      }, qi.prototype.addImageSection = function(r) {
        var i = r.image ? r.image.name : "";
        if (i.length !== 0) {
          var l = this.getNextImageSectionCharCode();
          l ? (this.text += String.fromCharCode(l), this.sections.push(Nh.forImage(i)), this.sectionIndex.push(this.sections.length - 1)) : at("Reached maximum number of images 6401");
        } else
          at("Can't add FormattedSection with an empty image.");
      }, qi.prototype.getNextImageSectionCharCode = function() {
        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
      };
      var Wm = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Co = {};
      function kx(r, i, l, p, y, v) {
        if (i.imageName) {
          var x = p[i.imageName];
          return x ? x.displaySize[0] * i.scale * 24 / v + y : 0;
        }
        var S = l[i.fontStack], C = S && S[r];
        return C ? C.metrics.advance * i.scale + y : 0;
      }
      function Lx(r, i, l, p) {
        var y = Math.pow(r - i, 2);
        return p ? r < i ? y / 2 : 2 * y : y + Math.abs(l) * l;
      }
      function UO(r, i, l) {
        var p = 0;
        return r === 10 && (p -= 1e4), l && (p += 150), r !== 40 && r !== 65288 || (p += 50), i !== 41 && i !== 65289 || (p += 50), p;
      }
      function Dx(r, i, l, p, y, v) {
        for (var x = null, S = Lx(i, l, y, v), C = 0, A = p; C < A.length; C += 1) {
          var L = A[C], D = Lx(i - L.x, l, y, v) + L.badness;
          D <= S && (x = L, S = D);
        }
        return { index: r, x: i, priorBreak: x, badness: S };
      }
      function l_(r, i, l, p, y, v, x) {
        if (v !== "point")
          return [];
        if (!r)
          return [];
        for (var S, C = [], A = function(he, oe, ge, we, Te, Oe) {
          for (var Be = 0, Ke = 0; Ke < he.length(); Ke++) {
            var ot = he.getSection(Ke);
            Be += kx(he.getCharCode(Ke), ot, we, Te, oe, Oe);
          }
          return Be / Math.max(1, Math.ceil(Be / ge));
        }(r, i, l, p, y, x), L = r.text.indexOf("\u200B") >= 0, D = 0, B = 0; B < r.length(); B++) {
          var j = r.getSection(B), J = r.getCharCode(B);
          if (Wm[J] || (D += kx(J, j, p, y, i, x)), B < r.length() - 1) {
            var ee = !((S = J) < 11904 || !(ct["Bopomofo Extended"](S) || ct.Bopomofo(S) || ct["CJK Compatibility Forms"](S) || ct["CJK Compatibility Ideographs"](S) || ct["CJK Compatibility"](S) || ct["CJK Radicals Supplement"](S) || ct["CJK Strokes"](S) || ct["CJK Symbols and Punctuation"](S) || ct["CJK Unified Ideographs Extension A"](S) || ct["CJK Unified Ideographs"](S) || ct["Enclosed CJK Letters and Months"](S) || ct["Halfwidth and Fullwidth Forms"](S) || ct.Hiragana(S) || ct["Ideographic Description Characters"](S) || ct["Kangxi Radicals"](S) || ct["Katakana Phonetic Extensions"](S) || ct.Katakana(S) || ct["Vertical Forms"](S) || ct["Yi Radicals"](S) || ct["Yi Syllables"](S)));
            (Co[J] || ee || j.imageName) && C.push(Dx(B + 1, D, A, C, UO(J, r.getCharCode(B + 1), ee && L), !1));
          }
        }
        return function he(oe) {
          return oe ? he(oe.priorBreak).concat(oe.index) : [];
        }(Dx(r.length(), D, A, C, 0, !0));
      }
      function u_(r) {
        var i = 0.5, l = 0.5;
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            i = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            i = 0;
        }
        switch (r) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            l = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            l = 0;
        }
        return { horizontalAlign: i, verticalAlign: l };
      }
      function jO(r, i, l, p, y) {
        if (p || y)
          for (var v = r[l], x = (r[l].x + v.metrics.advance * v.scale) * p, S = i; S <= l; S++)
            r[S].x -= x, r[S].y += y;
      }
      function Nx(r, i, l, p, y, v) {
        var x, S = r.image;
        if (S.content) {
          var C = S.content, A = S.pixelRatio || 1;
          x = [C[0] / A, C[1] / A, S.displaySize[0] - C[2] / A, S.displaySize[1] - C[3] / A];
        }
        var L, D, B, j, J = i.left * v, ee = i.right * v;
        l === "width" || l === "both" ? (j = y[0] + J - p[3], D = y[0] + ee + p[1]) : D = (j = y[0] + (J + ee - S.displaySize[0]) / 2) + S.displaySize[0];
        var he = i.top * v, oe = i.bottom * v;
        return l === "height" || l === "both" ? (L = y[1] + he - p[0], B = y[1] + oe + p[2]) : B = (L = y[1] + (he + oe - S.displaySize[1]) / 2) + S.displaySize[1], { image: S, top: L, right: D, bottom: B, left: j, collisionPadding: x };
      }
      Co[10] = !0, Co[32] = !0, Co[38] = !0, Co[40] = !0, Co[41] = !0, Co[43] = !0, Co[45] = !0, Co[47] = !0, Co[173] = !0, Co[183] = !0, Co[8203] = !0, Co[8208] = !0, Co[8211] = !0, Co[8231] = !0;
      var Rh = function(r) {
        function i(l, p, y, v) {
          r.call(this, l, p), this.angle = y, v !== void 0 && (this.segment = v);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.clone = function() {
          return new i(this.x, this.y, this.angle, this.segment);
        }, i;
      }(T);
      function c_(r, i) {
        var l = i.expression;
        if (l.kind === "constant")
          return { kind: "constant", layoutSize: l.evaluate(new mr(r + 1)) };
        if (l.kind === "source")
          return { kind: "source" };
        for (var p = l.zoomStops, y = l.interpolationType, v = 0; v < p.length && p[v] <= r; )
          v++;
        for (var x = v = Math.max(0, v - 1); x < p.length && p[x] < r + 1; )
          x++;
        x = Math.min(p.length - 1, x);
        var S = p[v], C = p[x];
        return l.kind === "composite" ? { kind: "composite", minZoom: S, maxZoom: C, interpolationType: y } : { kind: "camera", minZoom: S, maxZoom: C, minSize: l.evaluate(new mr(S)), maxSize: l.evaluate(new mr(C)), interpolationType: y };
      }
      function Rx(r, i, l) {
        var p = i.uSize, y = l.lowerSize;
        return r.kind === "source" ? y / 128 : r.kind === "composite" ? jn(y / 128, l.upperSize / 128, i.uSizeT) : p;
      }
      function zx(r, i) {
        var l = 0, p = 0;
        if (r.kind === "constant")
          p = r.layoutSize;
        else if (r.kind !== "source") {
          var y = r.interpolationType, v = y ? q(Ti.interpolationFactor(y, i, r.minZoom, r.maxZoom), 0, 1) : 0;
          r.kind === "camera" ? p = jn(r.minSize, r.maxSize, v) : l = v;
        }
        return { uSizeT: l, uSize: p };
      }
      wt("Anchor", Rh);
      var GO = Object.freeze({ __proto__: null, getSizeData: c_, evaluateSizeForFeature: Rx, evaluateSizeForZoom: zx, SIZE_PACK_FACTOR: 128 });
      function Fx(r, i, l, p, y) {
        if (i.segment === void 0)
          return !0;
        for (var v = i, x = i.segment + 1, S = 0; S > -l / 2; ) {
          if (--x < 0)
            return !1;
          S -= r[x].dist(v), v = r[x];
        }
        S += r[x].dist(r[x + 1]), x++;
        for (var C = [], A = 0; S < l / 2; ) {
          var L = r[x], D = r[x + 1];
          if (!D)
            return !1;
          var B = r[x - 1].angleTo(L) - L.angleTo(D);
          for (B = Math.abs((B + 3 * Math.PI) % (2 * Math.PI) - Math.PI), C.push({ distance: S, angleDelta: B }), A += B; S - C[0].distance > p; )
            A -= C.shift().angleDelta;
          if (A > y)
            return !1;
          x++, S += L.dist(D);
        }
        return !0;
      }
      function Bx(r) {
        for (var i = 0, l = 0; l < r.length - 1; l++)
          i += r[l].dist(r[l + 1]);
        return i;
      }
      function Vx(r, i, l) {
        return r ? 0.6 * i * l : 0;
      }
      function Ux(r, i) {
        return Math.max(r ? r.right - r.left : 0, i ? i.right - i.left : 0);
      }
      function $O(r, i, l, p, y, v) {
        for (var x = Vx(l, y, v), S = Ux(l, p) * v, C = 0, A = Bx(r) / 2, L = 0; L < r.length - 1; L++) {
          var D = r[L], B = r[L + 1], j = D.dist(B);
          if (C + j > A) {
            var J = (A - C) / j, ee = jn(D.x, B.x, J), he = jn(D.y, B.y, J), oe = new Rh(ee, he, B.angleTo(D), L);
            return oe._round(), !x || Fx(r, oe, S, x, i) ? oe : void 0;
          }
          C += j;
        }
      }
      function qO(r, i, l, p, y, v, x, S, C) {
        var A = Vx(p, v, x), L = Ux(p, y), D = L * x, B = r[0].x === 0 || r[0].x === C || r[0].y === 0 || r[0].y === C;
        return i - D < i / 4 && (i = D + i / 4), function j(J, ee, he, oe, ge, we, Te, Oe, Be) {
          for (var Ke = we / 2, ot = Bx(J), At = 0, dt = ee - he, Nt = [], yt = 0; yt < J.length - 1; yt++) {
            for (var sr = J[yt], qt = J[yt + 1], Mt = sr.dist(qt), fr = qt.angleTo(sr); dt + he < At + Mt; ) {
              var rr = ((dt += he) - At) / Mt, Mr = jn(sr.x, qt.x, rr), Rt = jn(sr.y, qt.y, rr);
              if (Mr >= 0 && Mr < Be && Rt >= 0 && Rt < Be && dt - Ke >= 0 && dt + Ke <= ot) {
                var Dr = new Rh(Mr, Rt, fr, yt);
                Dr._round(), oe && !Fx(J, Dr, we, oe, ge) || Nt.push(Dr);
              }
            }
            At += Mt;
          }
          return Oe || Nt.length || Te || (Nt = j(J, At / 2, he, oe, ge, we, Te, !0, Be)), Nt;
        }(r, B ? i / 2 * S % i : (L / 2 + 2 * v) * x * S % i, i, A, l, D, B, !1, C);
      }
      function jx(r, i, l, p, y) {
        for (var v = [], x = 0; x < r.length; x++)
          for (var S = r[x], C = void 0, A = 0; A < S.length - 1; A++) {
            var L = S[A], D = S[A + 1];
            L.x < i && D.x < i || (L.x < i ? L = new T(i, L.y + (i - L.x) / (D.x - L.x) * (D.y - L.y))._round() : D.x < i && (D = new T(i, L.y + (i - L.x) / (D.x - L.x) * (D.y - L.y))._round()), L.y < l && D.y < l || (L.y < l ? L = new T(L.x + (l - L.y) / (D.y - L.y) * (D.x - L.x), l)._round() : D.y < l && (D = new T(L.x + (l - L.y) / (D.y - L.y) * (D.x - L.x), l)._round()), L.x >= p && D.x >= p || (L.x >= p ? L = new T(p, L.y + (p - L.x) / (D.x - L.x) * (D.y - L.y))._round() : D.x >= p && (D = new T(p, L.y + (p - L.x) / (D.x - L.x) * (D.y - L.y))._round()), L.y >= y && D.y >= y || (L.y >= y ? L = new T(L.x + (y - L.y) / (D.y - L.y) * (D.x - L.x), y)._round() : D.y >= y && (D = new T(L.x + (y - L.y) / (D.y - L.y) * (D.x - L.x), y)._round()), C && L.equals(C[C.length - 1]) || v.push(C = [L]), C.push(D)))));
          }
        return v;
      }
      function Gx(r, i, l, p) {
        var y = [], v = r.image, x = v.pixelRatio, S = v.paddedRect.w - 2, C = v.paddedRect.h - 2, A = r.right - r.left, L = r.bottom - r.top, D = v.stretchX || [[0, S]], B = v.stretchY || [[0, C]], j = function(Mr, Rt) {
          return Mr + Rt[1] - Rt[0];
        }, J = D.reduce(j, 0), ee = B.reduce(j, 0), he = S - J, oe = C - ee, ge = 0, we = J, Te = 0, Oe = ee, Be = 0, Ke = he, ot = 0, At = oe;
        if (v.content && p) {
          var dt = v.content;
          ge = Hm(D, 0, dt[0]), Te = Hm(B, 0, dt[1]), we = Hm(D, dt[0], dt[2]), Oe = Hm(B, dt[1], dt[3]), Be = dt[0] - ge, ot = dt[1] - Te, Ke = dt[2] - dt[0] - we, At = dt[3] - dt[1] - Oe;
        }
        var Nt = function(Mr, Rt, Dr, gn) {
          var Cn = Zm(Mr.stretch - ge, we, A, r.left), In = Xm(Mr.fixed - Be, Ke, Mr.stretch, J), vn = Zm(Rt.stretch - Te, Oe, L, r.top), An = Xm(Rt.fixed - ot, At, Rt.stretch, ee), ui = Zm(Dr.stretch - ge, we, A, r.left), ci = Xm(Dr.fixed - Be, Ke, Dr.stretch, J), Wi = Zm(gn.stretch - Te, Oe, L, r.top), _i = Xm(gn.fixed - ot, At, gn.stretch, ee), Hi = new T(Cn, vn), Nn = new T(ui, vn), xi = new T(ui, Wi), vr = new T(Cn, Wi), Xr = new T(In / x, An / x), qr = new T(ci / x, _i / x), Or = i * Math.PI / 180;
          if (Or) {
            var ro = Math.sin(Or), Ni = Math.cos(Or), sn = [Ni, -ro, ro, Ni];
            Hi._matMult(sn), Nn._matMult(sn), vr._matMult(sn), xi._matMult(sn);
          }
          var $n = Mr.stretch + Mr.fixed, Ri = Rt.stretch + Rt.fixed;
          return { tl: Hi, tr: Nn, bl: vr, br: xi, tex: { x: v.paddedRect.x + 1 + $n, y: v.paddedRect.y + 1 + Ri, w: Dr.stretch + Dr.fixed - $n, h: gn.stretch + gn.fixed - Ri }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Xr, pixelOffsetBR: qr, minFontScaleX: Ke / x / A, minFontScaleY: At / x / L, isSDF: l };
        };
        if (p && (v.stretchX || v.stretchY))
          for (var yt = $x(D, he, J), sr = $x(B, oe, ee), qt = 0; qt < yt.length - 1; qt++)
            for (var Mt = yt[qt], fr = yt[qt + 1], rr = 0; rr < sr.length - 1; rr++)
              y.push(Nt(Mt, sr[rr], fr, sr[rr + 1]));
        else
          y.push(Nt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: S + 1 }, { fixed: 0, stretch: C + 1 }));
        return y;
      }
      function Hm(r, i, l) {
        for (var p = 0, y = 0, v = r; y < v.length; y += 1) {
          var x = v[y];
          p += Math.max(i, Math.min(l, x[1])) - Math.max(i, Math.min(l, x[0]));
        }
        return p;
      }
      function $x(r, i, l) {
        for (var p = [{ fixed: -1, stretch: 0 }], y = 0, v = r; y < v.length; y += 1) {
          var x = v[y], S = x[0], C = x[1], A = p[p.length - 1];
          p.push({ fixed: S - A.stretch, stretch: A.stretch }), p.push({ fixed: S - A.stretch, stretch: A.stretch + (C - S) });
        }
        return p.push({ fixed: i + 1, stretch: l }), p;
      }
      function Zm(r, i, l, p) {
        return r / i * l + p;
      }
      function Xm(r, i, l, p) {
        return r - i * l / p;
      }
      var Km = function(r, i, l, p, y, v, x, S, C, A) {
        if (this.boxStartIndex = r.length, C) {
          var L = v.top, D = v.bottom, B = v.collisionPadding;
          B && (L -= B[1], D += B[3]);
          var j = D - L;
          j > 0 && (j = Math.max(10, j), this.circleDiameter = j);
        } else {
          var J = v.top * x - S, ee = v.bottom * x + S, he = v.left * x - S, oe = v.right * x + S, ge = v.collisionPadding;
          if (ge && (he -= ge[0] * x, J -= ge[1] * x, oe += ge[2] * x, ee += ge[3] * x), A) {
            var we = new T(he, J), Te = new T(oe, J), Oe = new T(he, ee), Be = new T(oe, ee), Ke = A * Math.PI / 180;
            we._rotate(Ke), Te._rotate(Ke), Oe._rotate(Ke), Be._rotate(Ke), he = Math.min(we.x, Te.x, Oe.x, Be.x), oe = Math.max(we.x, Te.x, Oe.x, Be.x), J = Math.min(we.y, Te.y, Oe.y, Be.y), ee = Math.max(we.y, Te.y, Oe.y, Be.y);
          }
          r.emplaceBack(i.x, i.y, he, J, oe, ee, l, p, y);
        }
        this.boxEndIndex = r.length;
      }, zh = function(r, i) {
        if (r === void 0 && (r = []), i === void 0 && (i = WO), this.data = r, this.length = this.data.length, this.compare = i, this.length > 0)
          for (var l = (this.length >> 1) - 1; l >= 0; l--)
            this._down(l);
      };
      function WO(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function HO(r, i, l) {
        i === void 0 && (i = 1), l === void 0 && (l = !1);
        for (var p = 1 / 0, y = 1 / 0, v = -1 / 0, x = -1 / 0, S = r[0], C = 0; C < S.length; C++) {
          var A = S[C];
          (!C || A.x < p) && (p = A.x), (!C || A.y < y) && (y = A.y), (!C || A.x > v) && (v = A.x), (!C || A.y > x) && (x = A.y);
        }
        var L = Math.min(v - p, x - y), D = L / 2, B = new zh([], ZO);
        if (L === 0)
          return new T(p, y);
        for (var j = p; j < v; j += L)
          for (var J = y; J < x; J += L)
            B.push(new Fh(j + D, J + D, D, r));
        for (var ee = function(ge) {
          for (var we = 0, Te = 0, Oe = 0, Be = ge[0], Ke = 0, ot = Be.length, At = ot - 1; Ke < ot; At = Ke++) {
            var dt = Be[Ke], Nt = Be[At], yt = dt.x * Nt.y - Nt.x * dt.y;
            Te += (dt.x + Nt.x) * yt, Oe += (dt.y + Nt.y) * yt, we += 3 * yt;
          }
          return new Fh(Te / we, Oe / we, 0, ge);
        }(r), he = B.length; B.length; ) {
          var oe = B.pop();
          (oe.d > ee.d || !ee.d) && (ee = oe, l && console.log("found best %d after %d probes", Math.round(1e4 * oe.d) / 1e4, he)), oe.max - ee.d <= i || (B.push(new Fh(oe.p.x - (D = oe.h / 2), oe.p.y - D, D, r)), B.push(new Fh(oe.p.x + D, oe.p.y - D, D, r)), B.push(new Fh(oe.p.x - D, oe.p.y + D, D, r)), B.push(new Fh(oe.p.x + D, oe.p.y + D, D, r)), he += 4);
        }
        return l && (console.log("num probes: " + he), console.log("best distance: " + ee.d)), ee.p;
      }
      function ZO(r, i) {
        return i.max - r.max;
      }
      function Fh(r, i, l, p) {
        this.p = new T(r, i), this.h = l, this.d = function(y, v) {
          for (var x = !1, S = 1 / 0, C = 0; C < v.length; C++)
            for (var A = v[C], L = 0, D = A.length, B = D - 1; L < D; B = L++) {
              var j = A[L], J = A[B];
              j.y > y.y != J.y > y.y && y.x < (J.x - j.x) * (y.y - j.y) / (J.y - j.y) + j.x && (x = !x), S = Math.min(S, lu(y, j, J));
            }
          return (x ? 1 : -1) * Math.sqrt(S);
        }(this.p, p), this.max = this.d + this.h * Math.SQRT2;
      }
      zh.prototype.push = function(r) {
        this.data.push(r), this.length++, this._up(this.length - 1);
      }, zh.prototype.pop = function() {
        if (this.length !== 0) {
          var r = this.data[0], i = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = i, this._down(0)), r;
        }
      }, zh.prototype.peek = function() {
        return this.data[0];
      }, zh.prototype._up = function(r) {
        for (var i = this.data, l = this.compare, p = i[r]; r > 0; ) {
          var y = r - 1 >> 1, v = i[y];
          if (l(p, v) >= 0)
            break;
          i[r] = v, r = y;
        }
        i[r] = p;
      }, zh.prototype._down = function(r) {
        for (var i = this.data, l = this.compare, p = this.length >> 1, y = i[r]; r < p; ) {
          var v = 1 + (r << 1), x = i[v], S = v + 1;
          if (S < this.length && l(i[S], x) < 0 && (v = S, x = i[S]), l(x, y) >= 0)
            break;
          i[r] = x, r = v;
        }
        i[r] = y;
      };
      var h_ = Number.POSITIVE_INFINITY;
      function qx(r, i) {
        return i[1] !== h_ ? function(l, p, y) {
          var v = 0, x = 0;
          switch (p = Math.abs(p), y = Math.abs(y), l) {
            case "top-right":
            case "top-left":
            case "top":
              x = y - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              x = 7 - y;
          }
          switch (l) {
            case "top-right":
            case "bottom-right":
            case "right":
              v = -p;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              v = p;
          }
          return [v, x];
        }(r, i[0], i[1]) : function(l, p) {
          var y = 0, v = 0;
          p < 0 && (p = 0);
          var x = p / Math.sqrt(2);
          switch (l) {
            case "top-right":
            case "top-left":
              v = x - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              v = 7 - x;
              break;
            case "bottom":
              v = 7 - p;
              break;
            case "top":
              v = p - 7;
          }
          switch (l) {
            case "top-right":
            case "bottom-right":
              y = -x;
              break;
            case "top-left":
            case "bottom-left":
              y = x;
              break;
            case "left":
              y = p;
              break;
            case "right":
              y = -p;
          }
          return [y, v];
        }(r, i[0]);
      }
      function f_(r) {
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function Wx(r, i, l, p, y, v, x, S, C, A, L, D, B, j, J) {
        var ee = function(Te, Oe, Be, Ke, ot, At, dt, Nt) {
          for (var yt = Ke.layout.get("text-rotate").evaluate(At, {}) * Math.PI / 180, sr = [], qt = 0, Mt = Oe.positionedLines; qt < Mt.length; qt += 1)
            for (var fr = Mt[qt], rr = 0, Mr = fr.positionedGlyphs; rr < Mr.length; rr += 1) {
              var Rt = Mr[rr];
              if (Rt.rect) {
                var Dr = Rt.rect || {}, gn = 4, Cn = !0, In = 1, vn = 0, An = (ot || Nt) && Rt.vertical, ui = Rt.metrics.advance * Rt.scale / 2;
                if (Nt && Oe.verticalizable && (vn = fr.lineOffset / 2 - (Rt.imageName ? -(24 - Rt.metrics.width * Rt.scale) / 2 : 24 * (Rt.scale - 1))), Rt.imageName) {
                  var ci = dt[Rt.imageName];
                  Cn = ci.sdf, gn = 1 / (In = ci.pixelRatio);
                }
                var Wi = ot ? [Rt.x + ui, Rt.y] : [0, 0], _i = ot ? [0, 0] : [Rt.x + ui + Be[0], Rt.y + Be[1] - vn], Hi = [0, 0];
                An && (Hi = _i, _i = [0, 0]);
                var Nn = (Rt.metrics.left - gn) * Rt.scale - ui + _i[0], xi = (-Rt.metrics.top - gn) * Rt.scale + _i[1], vr = Nn + Dr.w * Rt.scale / In, Xr = xi + Dr.h * Rt.scale / In, qr = new T(Nn, xi), Or = new T(vr, xi), ro = new T(Nn, Xr), Ni = new T(vr, Xr);
                if (An) {
                  var sn = new T(-ui, ui - -17), $n = -Math.PI / 2, Ri = 12 - ui, Nr = new T(22 - Ri, -(Rt.imageName ? Ri : 0)), Ps = new (Function.prototype.bind.apply(T, [null].concat(Hi)))();
                  qr._rotateAround($n, sn)._add(Nr)._add(Ps), Or._rotateAround($n, sn)._add(Nr)._add(Ps), ro._rotateAround($n, sn)._add(Nr)._add(Ps), Ni._rotateAround($n, sn)._add(Nr)._add(Ps);
                }
                if (yt) {
                  var Ko = Math.sin(yt), ks = Math.cos(yt), Rn = [ks, -Ko, Ko, ks];
                  qr._matMult(Rn), Or._matMult(Rn), ro._matMult(Rn), Ni._matMult(Rn);
                }
                var Ls = new T(0, 0), Ma = new T(0, 0);
                sr.push({ tl: qr, tr: Or, bl: ro, br: Ni, tex: Dr, writingMode: Oe.writingMode, glyphOffset: Wi, sectionIndex: Rt.sectionIndex, isSDF: Cn, pixelOffsetTL: Ls, pixelOffsetBR: Ma, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
          return sr;
        }(0, l, S, y, v, x, p, r.allowVerticalPlacement), he = r.textSizeData, oe = null;
        he.kind === "source" ? (oe = [128 * y.layout.get("text-size").evaluate(x, {})])[0] > 32640 && at(r.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".') : he.kind === "composite" && ((oe = [128 * j.compositeTextSizes[0].evaluate(x, {}, J), 128 * j.compositeTextSizes[1].evaluate(x, {}, J)])[0] > 32640 || oe[1] > 32640) && at(r.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".'), r.addSymbols(r.text, ee, oe, S, v, x, A, i, C.lineStartIndex, C.lineLength, B, J);
        for (var ge = 0, we = L; ge < we.length; ge += 1)
          D[we[ge]] = r.text.placedSymbolArray.length - 1;
        return 4 * ee.length;
      }
      function Hx(r) {
        for (var i in r)
          return r[i];
        return null;
      }
      function XO(r, i, l, p) {
        var y = r.compareText;
        if (i in y) {
          for (var v = y[i], x = v.length - 1; x >= 0; x--)
            if (p.dist(v[x]) < l)
              return !0;
        } else
          y[i] = [];
        return y[i].push(p), !1;
      }
      var KO = kh.VectorTileFeature.types, YO = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Ym(r, i, l, p, y, v, x, S, C, A, L, D, B) {
        var j = S ? Math.min(32640, Math.round(S[0])) : 0, J = S ? Math.min(32640, Math.round(S[1])) : 0;
        r.emplaceBack(i, l, Math.round(32 * p), Math.round(32 * y), v, x, (j << 1) + (C ? 1 : 0), J, 16 * A, 16 * L, 256 * D, 256 * B);
      }
      function p_(r, i, l) {
        r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l);
      }
      function JO(r) {
        for (var i = 0, l = r.sections; i < l.length; i += 1)
          if (bh(l[i].text))
            return !0;
        return !1;
      }
      var Bh = function(r) {
        this.layoutVertexArray = new Th(), this.indexArray = new Ts(), this.programConfigurations = r, this.segments = new W(), this.dynamicLayoutVertexArray = new ou(), this.opacityVertexArray = new hc(), this.placedSymbolArray = new d();
      };
      Bh.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
      }, Bh.prototype.upload = function(r, i, l, p) {
        this.isEmpty() || (l && (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, SO.members), this.indexBuffer = r.createIndexBuffer(this.indexArray, i), this.dynamicLayoutVertexBuffer = r.createVertexBuffer(this.dynamicLayoutVertexArray, TO.members, !0), this.opacityVertexBuffer = r.createVertexBuffer(this.opacityVertexArray, YO, !0), this.opacityVertexBuffer.itemSize = 1), (l || p) && this.programConfigurations.upload(r));
      }, Bh.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
      }, wt("SymbolBuffers", Bh);
      var Tp = function(r, i, l) {
        this.layoutVertexArray = new r(), this.layoutAttributes = i, this.indexArray = new l(), this.segments = new W(), this.collisionVertexArray = new pp();
      };
      Tp.prototype.upload = function(r) {
        this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = r.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = r.createVertexBuffer(this.collisionVertexArray, MO.members, !0);
      }, Tp.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
      }, wt("CollisionBuffers", Tp);
      var Wr = function(r) {
        this.collisionBoxArray = r.collisionBoxArray, this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(v) {
          return v.id;
        }), this.index = r.index, this.pixelRatio = r.pixelRatio, this.sourceLayerIndex = r.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Oo([]), this.placementViewportMatrix = Oo([]);
        var i = this.layers[0]._unevaluatedLayout._values;
        this.textSizeData = c_(this.zoom, i["text-size"]), this.iconSizeData = c_(this.zoom, i["icon-size"]);
        var l = this.layers[0].layout, p = l.get("symbol-sort-key"), y = l.get("symbol-z-order");
        this.canOverlap = l.get("text-allow-overlap") || l.get("icon-allow-overlap") || l.get("text-ignore-placement") || l.get("icon-ignore-placement"), this.sortFeaturesByKey = y !== "viewport-y" && p.constantOr(1) !== void 0, this.sortFeaturesByY = (y === "viewport-y" || y === "auto" && !this.sortFeaturesByKey) && this.canOverlap, l.get("symbol-placement") === "point" && (this.writingModes = l.get("text-writing-mode").map(function(v) {
          return Xo[v];
        })), this.stateDependentLayerIds = this.layers.filter(function(v) {
          return v.isStateDependent();
        }).map(function(v) {
          return v.id;
        }), this.sourceID = r.sourceID;
      };
      Wr.prototype.createArrays = function() {
        this.text = new Bh(new $t(this.layers, this.zoom, function(r) {
          return /^text/.test(r);
        })), this.icon = new Bh(new $t(this.layers, this.zoom, function(r) {
          return /^icon/.test(r);
        })), this.glyphOffsetArray = new E(), this.lineVertexArray = new O(), this.symbolInstances = new w();
      }, Wr.prototype.calculateGlyphDependencies = function(r, i, l, p, y) {
        for (var v = 0; v < r.length; v++)
          if (i[r.charCodeAt(v)] = !0, (l || p) && y) {
            var x = wp[r.charAt(v)];
            x && (i[x.charCodeAt(0)] = !0);
          }
      }, Wr.prototype.populate = function(r, i, l) {
        var p = this.layers[0], y = p.layout, v = y.get("text-font"), x = y.get("text-field"), S = y.get("icon-image"), C = (x.value.kind !== "constant" || x.value.value instanceof di && !x.value.value.isEmpty() || x.value.value.toString().length > 0) && (v.value.kind !== "constant" || v.value.value.length > 0), A = S.value.kind !== "constant" || !!S.value.value || Object.keys(S.parameters).length > 0, L = y.get("symbol-sort-key");
        if (this.features = [], C || A) {
          for (var D = i.iconDependencies, B = i.glyphDependencies, j = i.availableImages, J = new mr(this.zoom), ee = 0, he = r; ee < he.length; ee += 1) {
            var oe = he[ee], ge = oe.feature, we = oe.id, Te = oe.index, Oe = oe.sourceLayerIndex, Be = p._featureFilter.needGeometry, Ke = Dn(ge, Be);
            if (p._featureFilter.filter(J, Ke, l)) {
              Be || (Ke.geometry = Mn(ge));
              var ot = void 0;
              if (C) {
                var At = p.getValueAndResolveTokens("text-field", Ke, l, j), dt = di.factory(At);
                JO(dt) && (this.hasRTLText = !0), (!this.hasRTLText || up() === "unavailable" || this.hasRTLText && Io.isParsed()) && (ot = OO(dt, p, Ke));
              }
              var Nt = void 0;
              if (A) {
                var yt = p.getValueAndResolveTokens("icon-image", Ke, l, j);
                Nt = yt instanceof Ji ? yt : Ji.fromString(yt);
              }
              if (ot || Nt) {
                var sr = this.sortFeaturesByKey ? L.evaluate(Ke, {}, l) : void 0;
                if (this.features.push({ id: we, text: ot, icon: Nt, index: Te, sourceLayerIndex: Oe, geometry: Ke.geometry, properties: ge.properties, type: KO[ge.type], sortKey: sr }), Nt && (D[Nt.name] = !0), ot) {
                  var qt = v.evaluate(Ke, {}, l).join(","), Mt = y.get("text-rotation-alignment") === "map" && y.get("symbol-placement") !== "point";
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Xo.vertical) >= 0;
                  for (var fr = 0, rr = ot.sections; fr < rr.length; fr += 1) {
                    var Mr = rr[fr];
                    if (Mr.image)
                      D[Mr.image.name] = !0;
                    else {
                      var Rt = ap(ot.toString()), Dr = Mr.fontStack || qt, gn = B[Dr] = B[Dr] || {};
                      this.calculateGlyphDependencies(Mr.text, gn, Mt, this.allowVerticalPlacement, Rt);
                    }
                  }
                }
              }
            }
          }
          y.get("symbol-placement") === "line" && (this.features = function(Cn) {
            var In = {}, vn = {}, An = [], ui = 0;
            function ci(sn) {
              An.push(Cn[sn]), ui++;
            }
            function Wi(sn, $n, Ri) {
              var Nr = vn[sn];
              return delete vn[sn], vn[$n] = Nr, An[Nr].geometry[0].pop(), An[Nr].geometry[0] = An[Nr].geometry[0].concat(Ri[0]), Nr;
            }
            function _i(sn, $n, Ri) {
              var Nr = In[$n];
              return delete In[$n], In[sn] = Nr, An[Nr].geometry[0].shift(), An[Nr].geometry[0] = Ri[0].concat(An[Nr].geometry[0]), Nr;
            }
            function Hi(sn, $n, Ri) {
              var Nr = Ri ? $n[0][$n[0].length - 1] : $n[0][0];
              return sn + ":" + Nr.x + ":" + Nr.y;
            }
            for (var Nn = 0; Nn < Cn.length; Nn++) {
              var xi = Cn[Nn], vr = xi.geometry, Xr = xi.text ? xi.text.toString() : null;
              if (Xr) {
                var qr = Hi(Xr, vr), Or = Hi(Xr, vr, !0);
                if (qr in vn && Or in In && vn[qr] !== In[Or]) {
                  var ro = _i(qr, Or, vr), Ni = Wi(qr, Or, An[ro].geometry);
                  delete In[qr], delete vn[Or], vn[Hi(Xr, An[Ni].geometry, !0)] = Ni, An[ro].geometry = null;
                } else
                  qr in vn ? Wi(qr, Or, vr) : Or in In ? _i(qr, Or, vr) : (ci(Nn), In[qr] = ui - 1, vn[Or] = ui - 1);
              } else
                ci(Nn);
            }
            return An.filter(function(sn) {
              return sn.geometry;
            });
          }(this.features)), this.sortFeaturesByKey && this.features.sort(function(Cn, In) {
            return Cn.sortKey - In.sortKey;
          });
        }
      }, Wr.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(r, i, this.layers, l), this.icon.programConfigurations.updatePaintArrays(r, i, this.layers, l));
      }, Wr.prototype.isEmpty = function() {
        return this.symbolInstances.length === 0 && !this.hasRTLText;
      }, Wr.prototype.uploadPending = function() {
        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
      }, Wr.prototype.upload = function(r) {
        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(r), this.iconCollisionBox.upload(r)), this.text.upload(r, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(r, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
      }, Wr.prototype.destroyDebugData = function() {
        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
      }, Wr.prototype.destroy = function() {
        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
      }, Wr.prototype.addToLineVertexArray = function(r, i) {
        var l = this.lineVertexArray.length;
        if (r.segment !== void 0) {
          for (var p = r.dist(i[r.segment + 1]), y = r.dist(i[r.segment]), v = {}, x = r.segment + 1; x < i.length; x++)
            v[x] = { x: i[x].x, y: i[x].y, tileUnitDistanceFromAnchor: p }, x < i.length - 1 && (p += i[x + 1].dist(i[x]));
          for (var S = r.segment || 0; S >= 0; S--)
            v[S] = { x: i[S].x, y: i[S].y, tileUnitDistanceFromAnchor: y }, S > 0 && (y += i[S - 1].dist(i[S]));
          for (var C = 0; C < i.length; C++) {
            var A = v[C];
            this.lineVertexArray.emplaceBack(A.x, A.y, A.tileUnitDistanceFromAnchor);
          }
        }
        return { lineStartIndex: l, lineLength: this.lineVertexArray.length - l };
      }, Wr.prototype.addSymbols = function(r, i, l, p, y, v, x, S, C, A, L, D) {
        for (var B = r.indexArray, j = r.layoutVertexArray, J = r.segments.prepareSegment(4 * i.length, j, B, this.canOverlap ? v.sortKey : void 0), ee = this.glyphOffsetArray.length, he = J.vertexLength, oe = this.allowVerticalPlacement && x === Xo.vertical ? Math.PI / 2 : 0, ge = v.text && v.text.sections, we = 0; we < i.length; we++) {
          var Te = i[we], Oe = Te.tl, Be = Te.tr, Ke = Te.bl, ot = Te.br, At = Te.tex, dt = Te.pixelOffsetTL, Nt = Te.pixelOffsetBR, yt = Te.minFontScaleX, sr = Te.minFontScaleY, qt = Te.glyphOffset, Mt = Te.isSDF, fr = Te.sectionIndex, rr = J.vertexLength, Mr = qt[1];
          Ym(j, S.x, S.y, Oe.x, Mr + Oe.y, At.x, At.y, l, Mt, dt.x, dt.y, yt, sr), Ym(j, S.x, S.y, Be.x, Mr + Be.y, At.x + At.w, At.y, l, Mt, Nt.x, dt.y, yt, sr), Ym(j, S.x, S.y, Ke.x, Mr + Ke.y, At.x, At.y + At.h, l, Mt, dt.x, Nt.y, yt, sr), Ym(j, S.x, S.y, ot.x, Mr + ot.y, At.x + At.w, At.y + At.h, l, Mt, Nt.x, Nt.y, yt, sr), p_(r.dynamicLayoutVertexArray, S, oe), B.emplaceBack(rr, rr + 1, rr + 2), B.emplaceBack(rr + 1, rr + 2, rr + 3), J.vertexLength += 4, J.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(qt[0]), we !== i.length - 1 && fr === i[we + 1].sectionIndex || r.programConfigurations.populatePaintArrays(j.length, v, v.index, {}, D, ge && ge[fr]);
        }
        r.placedSymbolArray.emplaceBack(S.x, S.y, ee, this.glyphOffsetArray.length - ee, he, C, A, S.segment, l ? l[0] : 0, l ? l[1] : 0, p[0], p[1], x, 0, !1, 0, L);
      }, Wr.prototype._addCollisionDebugVertex = function(r, i, l, p, y, v) {
        return i.emplaceBack(0, 0), r.emplaceBack(l.x, l.y, p, y, Math.round(v.x), Math.round(v.y));
      }, Wr.prototype.addCollisionDebugVertices = function(r, i, l, p, y, v, x) {
        var S = y.segments.prepareSegment(4, y.layoutVertexArray, y.indexArray), C = S.vertexLength, A = y.layoutVertexArray, L = y.collisionVertexArray, D = x.anchorX, B = x.anchorY;
        this._addCollisionDebugVertex(A, L, v, D, B, new T(r, i)), this._addCollisionDebugVertex(A, L, v, D, B, new T(l, i)), this._addCollisionDebugVertex(A, L, v, D, B, new T(l, p)), this._addCollisionDebugVertex(A, L, v, D, B, new T(r, p)), S.vertexLength += 4;
        var j = y.indexArray;
        j.emplaceBack(C, C + 1), j.emplaceBack(C + 1, C + 2), j.emplaceBack(C + 2, C + 3), j.emplaceBack(C + 3, C), S.primitiveLength += 4;
      }, Wr.prototype.addDebugCollisionBoxes = function(r, i, l, p) {
        for (var y = r; y < i; y++) {
          var v = this.collisionBoxArray.get(y);
          this.addCollisionDebugVertices(v.x1, v.y1, v.x2, v.y2, p ? this.textCollisionBox : this.iconCollisionBox, v.anchorPoint, l);
        }
      }, Wr.prototype.generateCollisionDebugBuffers = function() {
        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Tp(au, Tx.members, fc), this.iconCollisionBox = new Tp(au, Tx.members, fc);
        for (var r = 0; r < this.symbolInstances.length; r++) {
          var i = this.symbolInstances.get(r);
          this.addDebugCollisionBoxes(i.textBoxStartIndex, i.textBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.iconBoxStartIndex, i.iconBoxEndIndex, i, !1), this.addDebugCollisionBoxes(i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex, i, !1);
        }
      }, Wr.prototype._deserializeCollisionBoxesForSymbol = function(r, i, l, p, y, v, x, S, C) {
        for (var A = {}, L = i; L < l; L++) {
          var D = r.get(L);
          A.textBox = { x1: D.x1, y1: D.y1, x2: D.x2, y2: D.y2, anchorPointX: D.anchorPointX, anchorPointY: D.anchorPointY }, A.textFeatureIndex = D.featureIndex;
          break;
        }
        for (var B = p; B < y; B++) {
          var j = r.get(B);
          A.verticalTextBox = { x1: j.x1, y1: j.y1, x2: j.x2, y2: j.y2, anchorPointX: j.anchorPointX, anchorPointY: j.anchorPointY }, A.verticalTextFeatureIndex = j.featureIndex;
          break;
        }
        for (var J = v; J < x; J++) {
          var ee = r.get(J);
          A.iconBox = { x1: ee.x1, y1: ee.y1, x2: ee.x2, y2: ee.y2, anchorPointX: ee.anchorPointX, anchorPointY: ee.anchorPointY }, A.iconFeatureIndex = ee.featureIndex;
          break;
        }
        for (var he = S; he < C; he++) {
          var oe = r.get(he);
          A.verticalIconBox = { x1: oe.x1, y1: oe.y1, x2: oe.x2, y2: oe.y2, anchorPointX: oe.anchorPointX, anchorPointY: oe.anchorPointY }, A.verticalIconFeatureIndex = oe.featureIndex;
          break;
        }
        return A;
      }, Wr.prototype.deserializeCollisionBoxes = function(r) {
        this.collisionArrays = [];
        for (var i = 0; i < this.symbolInstances.length; i++) {
          var l = this.symbolInstances.get(i);
          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(r, l.textBoxStartIndex, l.textBoxEndIndex, l.verticalTextBoxStartIndex, l.verticalTextBoxEndIndex, l.iconBoxStartIndex, l.iconBoxEndIndex, l.verticalIconBoxStartIndex, l.verticalIconBoxEndIndex));
        }
      }, Wr.prototype.hasTextData = function() {
        return this.text.segments.get().length > 0;
      }, Wr.prototype.hasIconData = function() {
        return this.icon.segments.get().length > 0;
      }, Wr.prototype.hasDebugData = function() {
        return this.textCollisionBox && this.iconCollisionBox;
      }, Wr.prototype.hasTextCollisionBoxData = function() {
        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
      }, Wr.prototype.hasIconCollisionBoxData = function() {
        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
      }, Wr.prototype.addIndicesForPlacedSymbol = function(r, i) {
        for (var l = r.placedSymbolArray.get(i), p = l.vertexStartIndex + 4 * l.numGlyphs, y = l.vertexStartIndex; y < p; y += 4)
          r.indexArray.emplaceBack(y, y + 1, y + 2), r.indexArray.emplaceBack(y + 1, y + 2, y + 3);
      }, Wr.prototype.getSortedSymbolIndexes = function(r) {
        if (this.sortedAngle === r && this.symbolInstanceIndexes !== void 0)
          return this.symbolInstanceIndexes;
        for (var i = Math.sin(r), l = Math.cos(r), p = [], y = [], v = [], x = 0; x < this.symbolInstances.length; ++x) {
          v.push(x);
          var S = this.symbolInstances.get(x);
          p.push(0 | Math.round(i * S.anchorX + l * S.anchorY)), y.push(S.featureIndex);
        }
        return v.sort(function(C, A) {
          return p[C] - p[A] || y[A] - y[C];
        }), v;
      }, Wr.prototype.addToSortKeyRanges = function(r, i) {
        var l = this.sortKeyRanges[this.sortKeyRanges.length - 1];
        l && l.sortKey === i ? l.symbolInstanceEnd = r + 1 : this.sortKeyRanges.push({ sortKey: i, symbolInstanceStart: r, symbolInstanceEnd: r + 1 });
      }, Wr.prototype.sortFeatures = function(r) {
        var i = this;
        if (this.sortFeaturesByY && this.sortedAngle !== r && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(r), this.sortedAngle = r, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
          for (var l = 0, p = this.symbolInstanceIndexes; l < p.length; l += 1) {
            var y = this.symbolInstances.get(p[l]);
            this.featureSortOrder.push(y.featureIndex), [y.rightJustifiedTextSymbolIndex, y.centerJustifiedTextSymbolIndex, y.leftJustifiedTextSymbolIndex].forEach(function(v, x, S) {
              v >= 0 && S.indexOf(v) === x && i.addIndicesForPlacedSymbol(i.text, v);
            }), y.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, y.verticalPlacedTextSymbolIndex), y.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, y.placedIconSymbolIndex), y.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, y.verticalPlacedIconSymbolIndex);
          }
          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
        }
      }, wt("SymbolBucket", Wr, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Wr.MAX_GLYPHS = 65535, Wr.addDynamicAttributes = p_;
      var QO = new Ii({ "symbol-placement": new Lt(G.layout_symbol["symbol-placement"]), "symbol-spacing": new Lt(G.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Lt(G.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Tt(G.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Lt(G.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Lt(G.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Lt(G.layout_symbol["icon-ignore-placement"]), "icon-optional": new Lt(G.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Lt(G.layout_symbol["icon-rotation-alignment"]), "icon-size": new Tt(G.layout_symbol["icon-size"]), "icon-text-fit": new Lt(G.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Lt(G.layout_symbol["icon-text-fit-padding"]), "icon-image": new Tt(G.layout_symbol["icon-image"]), "icon-rotate": new Tt(G.layout_symbol["icon-rotate"]), "icon-padding": new Lt(G.layout_symbol["icon-padding"]), "icon-keep-upright": new Lt(G.layout_symbol["icon-keep-upright"]), "icon-offset": new Tt(G.layout_symbol["icon-offset"]), "icon-anchor": new Tt(G.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Lt(G.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Lt(G.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Lt(G.layout_symbol["text-rotation-alignment"]), "text-field": new Tt(G.layout_symbol["text-field"]), "text-font": new Tt(G.layout_symbol["text-font"]), "text-size": new Tt(G.layout_symbol["text-size"]), "text-max-width": new Tt(G.layout_symbol["text-max-width"]), "text-line-height": new Lt(G.layout_symbol["text-line-height"]), "text-letter-spacing": new Tt(G.layout_symbol["text-letter-spacing"]), "text-justify": new Tt(G.layout_symbol["text-justify"]), "text-radial-offset": new Tt(G.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Lt(G.layout_symbol["text-variable-anchor"]), "text-anchor": new Tt(G.layout_symbol["text-anchor"]), "text-max-angle": new Lt(G.layout_symbol["text-max-angle"]), "text-writing-mode": new Lt(G.layout_symbol["text-writing-mode"]), "text-rotate": new Tt(G.layout_symbol["text-rotate"]), "text-padding": new Lt(G.layout_symbol["text-padding"]), "text-keep-upright": new Lt(G.layout_symbol["text-keep-upright"]), "text-transform": new Tt(G.layout_symbol["text-transform"]), "text-offset": new Tt(G.layout_symbol["text-offset"]), "text-allow-overlap": new Lt(G.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Lt(G.layout_symbol["text-ignore-placement"]), "text-optional": new Lt(G.layout_symbol["text-optional"]) }), d_ = { paint: new Ii({ "icon-opacity": new Tt(G.paint_symbol["icon-opacity"]), "icon-color": new Tt(G.paint_symbol["icon-color"]), "icon-halo-color": new Tt(G.paint_symbol["icon-halo-color"]), "icon-halo-width": new Tt(G.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Tt(G.paint_symbol["icon-halo-blur"]), "icon-translate": new Lt(G.paint_symbol["icon-translate"]), "icon-translate-anchor": new Lt(G.paint_symbol["icon-translate-anchor"]), "text-opacity": new Tt(G.paint_symbol["text-opacity"]), "text-color": new Tt(G.paint_symbol["text-color"], { runtimeType: De, getOverride: function(r) {
        return r.textColor;
      }, hasOverride: function(r) {
        return !!r.textColor;
      } }), "text-halo-color": new Tt(G.paint_symbol["text-halo-color"]), "text-halo-width": new Tt(G.paint_symbol["text-halo-width"]), "text-halo-blur": new Tt(G.paint_symbol["text-halo-blur"]), "text-translate": new Lt(G.paint_symbol["text-translate"]), "text-translate-anchor": new Lt(G.paint_symbol["text-translate-anchor"]) }), layout: QO }, Vh = function(r) {
        this.type = r.property.overrides ? r.property.overrides.runtimeType : _t, this.defaultValue = r;
      };
      Vh.prototype.evaluate = function(r) {
        if (r.formattedSection) {
          var i = this.defaultValue.property.overrides;
          if (i && i.hasOverride(r.formattedSection))
            return i.getOverride(r.formattedSection);
        }
        return r.feature && r.featureState ? this.defaultValue.evaluate(r.feature, r.featureState) : this.defaultValue.property.specification.default;
      }, Vh.prototype.eachChild = function(r) {
        this.defaultValue.isConstant() || r(this.defaultValue.value._styleExpression.expression);
      }, Vh.prototype.outputDefined = function() {
        return !1;
      }, Vh.prototype.serialize = function() {
        return null;
      }, wt("FormatSectionOverride", Vh, { omit: ["defaultValue"] });
      var eC = function(r) {
        function i(l) {
          r.call(this, l, d_);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.recalculate = function(l, p) {
          if (r.prototype.recalculate.call(this, l, p), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            var y = this.layout.get("text-writing-mode");
            if (y) {
              for (var v = [], x = 0, S = y; x < S.length; x += 1) {
                var C = S[x];
                v.indexOf(C) < 0 && v.push(C);
              }
              this.layout._values["text-writing-mode"] = v;
            } else
              this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }, i.prototype.getValueAndResolveTokens = function(l, p, y, v) {
          var x = this.layout.get(l).evaluate(p, {}, y, v), S = this._unevaluatedLayout._values[l];
          return S.isDataDriven() || ec(S.value) || !x ? x : function(C, A) {
            return A.replace(/{([^{}]+)}/g, function(L, D) {
              return D in C ? String(C[D]) : "";
            });
          }(p.properties, x);
        }, i.prototype.createBucket = function(l) {
          return new Wr(l);
        }, i.prototype.queryRadius = function() {
          return 0;
        }, i.prototype.queryIntersectsFeature = function() {
          return !1;
        }, i.prototype._setPaintOverrides = function() {
          for (var l = 0, p = d_.paint.overridableProperties; l < p.length; l += 1) {
            var y = p[l];
            if (i.hasPaintOverride(this.layout, y)) {
              var v, x = this.paint.get(y), S = new Vh(x), C = new Ql(S, x.property.specification);
              v = x.value.kind === "constant" || x.value.kind === "source" ? new tc("source", C) : new eu("composite", C, x.value.zoomStops, x.value._interpolationType), this.paint._values[y] = new ji(x.property, v, x.parameters);
            }
          }
        }, i.prototype._handleOverridablePaintPropertyUpdate = function(l, p, y) {
          return !(!this.layout || p.isDataDriven() || y.isDataDriven()) && i.hasPaintOverride(this.layout, l);
        }, i.hasPaintOverride = function(l, p) {
          var y = l.get("text-field"), v = d_.paint.properties[p], x = !1, S = function(L) {
            for (var D = 0, B = L; D < B.length; D += 1)
              if (v.overrides && v.overrides.hasOverride(B[D]))
                return void (x = !0);
          };
          if (y.value.kind === "constant" && y.value.value instanceof di)
            S(y.value.value.sections);
          else if (y.value.kind === "source") {
            var C = function(L) {
              x || (L instanceof Vi && Ln(L.value) === jt ? S(L.value.sections) : L instanceof ia ? S(L.sections) : L.eachChild(C));
            }, A = y.value;
            A._styleExpression && C(A._styleExpression.expression);
          }
          return x;
        }, i;
      }(wa), tC = { paint: new Ii({ "background-color": new Lt(G.paint_background["background-color"]), "background-pattern": new Gi(G.paint_background["background-pattern"]), "background-opacity": new Lt(G.paint_background["background-opacity"]) }) }, rC = function(r) {
        function i(l) {
          r.call(this, l, tC);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(wa), nC = { paint: new Ii({ "raster-opacity": new Lt(G.paint_raster["raster-opacity"]), "raster-hue-rotate": new Lt(G.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Lt(G.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Lt(G.paint_raster["raster-brightness-max"]), "raster-saturation": new Lt(G.paint_raster["raster-saturation"]), "raster-contrast": new Lt(G.paint_raster["raster-contrast"]), "raster-resampling": new Lt(G.paint_raster["raster-resampling"]), "raster-fade-duration": new Lt(G.paint_raster["raster-fade-duration"]) }) }, iC = function(r) {
        function i(l) {
          r.call(this, l, nC);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(wa), oC = function(r) {
        function i(l) {
          r.call(this, l, {}), this.implementation = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.is3D = function() {
          return this.implementation.renderingMode === "3d";
        }, i.prototype.hasOffscreenPass = function() {
          return this.implementation.prerender !== void 0;
        }, i.prototype.recalculate = function() {
        }, i.prototype.updateTransitions = function() {
        }, i.prototype.hasTransition = function() {
        }, i.prototype.serialize = function() {
        }, i.prototype.onAdd = function(l) {
          this.implementation.onAdd && this.implementation.onAdd(l, l.painter.context.gl);
        }, i.prototype.onRemove = function(l) {
          this.implementation.onRemove && this.implementation.onRemove(l, l.painter.context.gl);
        }, i;
      }(wa), aC = { circle: Jv, heatmap: GI, hillshade: qI, fill: lO, "fill-extrusion": gO, line: EO, symbol: eC, background: rC, raster: iC }, Zx = I.HTMLImageElement, Xx = I.HTMLCanvasElement, Kx = I.HTMLVideoElement, Yx = I.ImageData, Jm = I.ImageBitmap, vc = function(r, i, l, p) {
        this.context = r, this.format = l, this.texture = r.gl.createTexture(), this.update(i, p);
      };
      vc.prototype.update = function(r, i, l) {
        var p = r.width, y = r.height, v = !(this.size && this.size[0] === p && this.size[1] === y || l), x = this.context, S = x.gl;
        if (this.useMipmap = Boolean(i && i.useMipmap), S.bindTexture(S.TEXTURE_2D, this.texture), x.pixelStoreUnpackFlipY.set(!1), x.pixelStoreUnpack.set(1), x.pixelStoreUnpackPremultiplyAlpha.set(this.format === S.RGBA && (!i || i.premultiply !== !1)), v)
          this.size = [p, y], r instanceof Zx || r instanceof Xx || r instanceof Kx || r instanceof Yx || Jm && r instanceof Jm ? S.texImage2D(S.TEXTURE_2D, 0, this.format, this.format, S.UNSIGNED_BYTE, r) : S.texImage2D(S.TEXTURE_2D, 0, this.format, p, y, 0, this.format, S.UNSIGNED_BYTE, r.data);
        else {
          var C = l || { x: 0, y: 0 }, A = C.x, L = C.y;
          r instanceof Zx || r instanceof Xx || r instanceof Kx || r instanceof Yx || Jm && r instanceof Jm ? S.texSubImage2D(S.TEXTURE_2D, 0, A, L, S.RGBA, S.UNSIGNED_BYTE, r) : S.texSubImage2D(S.TEXTURE_2D, 0, A, L, p, y, S.RGBA, S.UNSIGNED_BYTE, r.data);
        }
        this.useMipmap && this.isSizePowerOfTwo() && S.generateMipmap(S.TEXTURE_2D);
      }, vc.prototype.bind = function(r, i, l) {
        var p = this.context.gl;
        p.bindTexture(p.TEXTURE_2D, this.texture), l !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (l = p.LINEAR), r !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, r), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, l || r), this.filter = r), i !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, i), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, i), this.wrap = i);
      }, vc.prototype.isSizePowerOfTwo = function() {
        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
      }, vc.prototype.destroy = function() {
        this.context.gl.deleteTexture(this.texture), this.texture = null;
      };
      var m_ = function(r) {
        var i = this;
        this._callback = r, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function() {
          i._triggered = !1, i._callback();
        });
      };
      m_.prototype.trigger = function() {
        var r = this;
        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(function() {
          r._triggered = !1, r._callback();
        }, 0));
      }, m_.prototype.remove = function() {
        delete this._channel, this._callback = function() {
        };
      };
      var Uh = function(r, i, l) {
        this.target = r, this.parent = i, this.mapId = l, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, Fe(["receive", "process"], this), this.invoker = new m_(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = ht() ? r : I;
      };
      function Jx(r, i, l) {
        var p = 2 * Math.PI * 6378137 / 256 / Math.pow(2, l);
        return [r * p - 2 * Math.PI * 6378137 / 2, i * p - 2 * Math.PI * 6378137 / 2];
      }
      Uh.prototype.send = function(r, i, l, p, y) {
        var v = this;
        y === void 0 && (y = !1);
        var x = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
        l && (this.callbacks[x] = l);
        var S = tr(this.globalScope) ? void 0 : [];
        return this.target.postMessage({ id: x, type: r, hasCallback: !!l, targetMapId: p, mustQueue: y, sourceMapId: this.mapId, data: aa(i, S) }, S), { cancel: function() {
          l && delete v.callbacks[x], v.target.postMessage({ id: x, type: "<cancel>", targetMapId: p, sourceMapId: v.mapId });
        } };
      }, Uh.prototype.receive = function(r) {
        var i = r.data, l = i.id;
        if (l && (!i.targetMapId || this.mapId === i.targetMapId))
          if (i.type === "<cancel>") {
            delete this.tasks[l];
            var p = this.cancelCallbacks[l];
            delete this.cancelCallbacks[l], p && p();
          } else
            ht() || i.mustQueue ? (this.tasks[l] = i, this.taskQueue.push(l), this.invoker.trigger()) : this.processTask(l, i);
      }, Uh.prototype.process = function() {
        if (this.taskQueue.length) {
          var r = this.taskQueue.shift(), i = this.tasks[r];
          delete this.tasks[r], this.taskQueue.length && this.invoker.trigger(), i && this.processTask(r, i);
        }
      }, Uh.prototype.processTask = function(r, i) {
        var l = this;
        if (i.type === "<response>") {
          var p = this.callbacks[r];
          delete this.callbacks[r], p && (i.error ? p(co(i.error)) : p(null, co(i.data)));
        } else {
          var y = !1, v = tr(this.globalScope) ? void 0 : [], x = i.hasCallback ? function(L, D) {
            y = !0, delete l.cancelCallbacks[r], l.target.postMessage({ id: r, type: "<response>", sourceMapId: l.mapId, error: L ? aa(L) : null, data: aa(D, v) }, v);
          } : function(L) {
            y = !0;
          }, S = null, C = co(i.data);
          if (this.parent[i.type])
            S = this.parent[i.type](i.sourceMapId, C, x);
          else if (this.parent.getWorkerSource) {
            var A = i.type.split(".");
            S = this.parent.getWorkerSource(i.sourceMapId, A[0], C.source)[A[1]](C, x);
          } else
            x(new Error("Could not find function " + i.type));
          !y && S && S.cancel && (this.cancelCallbacks[r] = S.cancel);
        }
      }, Uh.prototype.remove = function() {
        this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);
      };
      var ei = function(r, i) {
        r && (i ? this.setSouthWest(r).setNorthEast(i) : r.length === 4 ? this.setSouthWest([r[0], r[1]]).setNorthEast([r[2], r[3]]) : this.setSouthWest(r[0]).setNorthEast(r[1]));
      };
      ei.prototype.setNorthEast = function(r) {
        return this._ne = r instanceof yn ? new yn(r.lng, r.lat) : yn.convert(r), this;
      }, ei.prototype.setSouthWest = function(r) {
        return this._sw = r instanceof yn ? new yn(r.lng, r.lat) : yn.convert(r), this;
      }, ei.prototype.extend = function(r) {
        var i, l, p = this._sw, y = this._ne;
        if (r instanceof yn)
          i = r, l = r;
        else {
          if (!(r instanceof ei))
            return Array.isArray(r) ? r.length === 4 || r.every(Array.isArray) ? this.extend(ei.convert(r)) : this.extend(yn.convert(r)) : this;
          if (l = r._ne, !(i = r._sw) || !l)
            return this;
        }
        return p || y ? (p.lng = Math.min(i.lng, p.lng), p.lat = Math.min(i.lat, p.lat), y.lng = Math.max(l.lng, y.lng), y.lat = Math.max(l.lat, y.lat)) : (this._sw = new yn(i.lng, i.lat), this._ne = new yn(l.lng, l.lat)), this;
      }, ei.prototype.getCenter = function() {
        return new yn((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
      }, ei.prototype.getSouthWest = function() {
        return this._sw;
      }, ei.prototype.getNorthEast = function() {
        return this._ne;
      }, ei.prototype.getNorthWest = function() {
        return new yn(this.getWest(), this.getNorth());
      }, ei.prototype.getSouthEast = function() {
        return new yn(this.getEast(), this.getSouth());
      }, ei.prototype.getWest = function() {
        return this._sw.lng;
      }, ei.prototype.getSouth = function() {
        return this._sw.lat;
      }, ei.prototype.getEast = function() {
        return this._ne.lng;
      }, ei.prototype.getNorth = function() {
        return this._ne.lat;
      }, ei.prototype.toArray = function() {
        return [this._sw.toArray(), this._ne.toArray()];
      }, ei.prototype.toString = function() {
        return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";
      }, ei.prototype.isEmpty = function() {
        return !(this._sw && this._ne);
      }, ei.prototype.contains = function(r) {
        var i = yn.convert(r), l = i.lng, p = i.lat, y = this._sw.lng <= l && l <= this._ne.lng;
        return this._sw.lng > this._ne.lng && (y = this._sw.lng >= l && l >= this._ne.lng), this._sw.lat <= p && p <= this._ne.lat && y;
      }, ei.convert = function(r) {
        return !r || r instanceof ei ? r : new ei(r);
      };
      var yn = function(r, i) {
        if (isNaN(r) || isNaN(i))
          throw new Error("Invalid LngLat object: (" + r + ", " + i + ")");
        if (this.lng = +r, this.lat = +i, this.lat > 90 || this.lat < -90)
          throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
      };
      yn.prototype.wrap = function() {
        return new yn(re(this.lng, -180, 180), this.lat);
      }, yn.prototype.toArray = function() {
        return [this.lng, this.lat];
      }, yn.prototype.toString = function() {
        return "LngLat(" + this.lng + ", " + this.lat + ")";
      }, yn.prototype.distanceTo = function(r) {
        var i = Math.PI / 180, l = this.lat * i, p = r.lat * i, y = Math.sin(l) * Math.sin(p) + Math.cos(l) * Math.cos(p) * Math.cos((r.lng - this.lng) * i);
        return 63710088e-1 * Math.acos(Math.min(y, 1));
      }, yn.prototype.toBounds = function(r) {
        r === void 0 && (r = 0);
        var i = 360 * r / 40075017, l = i / Math.cos(Math.PI / 180 * this.lat);
        return new ei(new yn(this.lng - l, this.lat - i), new yn(this.lng + l, this.lat + i));
      }, yn.convert = function(r) {
        if (r instanceof yn)
          return r;
        if (Array.isArray(r) && (r.length === 2 || r.length === 3))
          return new yn(Number(r[0]), Number(r[1]));
        if (!Array.isArray(r) && typeof r == "object" && r !== null)
          return new yn(Number("lng" in r ? r.lng : r.lon), Number(r.lat));
        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
      };
      var Qx = 2 * Math.PI * 63710088e-1;
      function eb(r) {
        return Qx * Math.cos(r * Math.PI / 180);
      }
      function tb(r) {
        return (180 + r) / 360;
      }
      function rb(r) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
      }
      function nb(r, i) {
        return r / eb(i);
      }
      function y_(r) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90;
      }
      var _c = function(r, i, l) {
        l === void 0 && (l = 0), this.x = +r, this.y = +i, this.z = +l;
      };
      _c.fromLngLat = function(r, i) {
        i === void 0 && (i = 0);
        var l = yn.convert(r);
        return new _c(tb(l.lng), rb(l.lat), nb(i, l.lat));
      }, _c.prototype.toLngLat = function() {
        return new yn(360 * this.x - 180, y_(this.y));
      }, _c.prototype.toAltitude = function() {
        return this.z * eb(y_(this.y));
      }, _c.prototype.meterInMercatorCoordinateUnits = function() {
        return 1 / Qx * (r = y_(this.y), 1 / Math.cos(r * Math.PI / 180));
        var r;
      };
      var xc = function(r, i, l) {
        this.z = r, this.x = i, this.y = l, this.key = Mp(0, r, r, i, l);
      };
      xc.prototype.equals = function(r) {
        return this.z === r.z && this.x === r.x && this.y === r.y;
      }, xc.prototype.url = function(r, i) {
        var l, p, y, v, x, S = (p = this.y, y = this.z, v = Jx(256 * (l = this.x), 256 * (p = Math.pow(2, y) - p - 1), y), x = Jx(256 * (l + 1), 256 * (p + 1), y), v[0] + "," + v[1] + "," + x[0] + "," + x[1]), C = function(A, L, D) {
          for (var B, j = "", J = A; J > 0; J--)
            j += (L & (B = 1 << J - 1) ? 1 : 0) + (D & B ? 2 : 0);
          return j;
        }(this.z, this.x, this.y);
        return r[(this.x + this.y) % r.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String(i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", C).replace("{bbox-epsg-3857}", S);
      }, xc.prototype.getTilePoint = function(r) {
        var i = Math.pow(2, this.z);
        return new T(8192 * (r.x * i - this.x), 8192 * (r.y * i - this.y));
      }, xc.prototype.toString = function() {
        return this.z + "/" + this.x + "/" + this.y;
      };
      var ib = function(r, i) {
        this.wrap = r, this.canonical = i, this.key = Mp(r, i.z, i.z, i.x, i.y);
      }, ti = function(r, i, l, p, y) {
        this.overscaledZ = r, this.wrap = i, this.canonical = new xc(l, +p, +y), this.key = Mp(i, r, l, p, y);
      };
      function Mp(r, i, l, p, y) {
        (r *= 2) < 0 && (r = -1 * r - 1);
        var v = 1 << l;
        return (v * v * r + v * y + p).toString(36) + l.toString(36) + i.toString(36);
      }
      ti.prototype.equals = function(r) {
        return this.overscaledZ === r.overscaledZ && this.wrap === r.wrap && this.canonical.equals(r.canonical);
      }, ti.prototype.scaledTo = function(r) {
        var i = this.canonical.z - r;
        return r > this.canonical.z ? new ti(r, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ti(r, this.wrap, r, this.canonical.x >> i, this.canonical.y >> i);
      }, ti.prototype.calculateScaledKey = function(r, i) {
        var l = this.canonical.z - r;
        return r > this.canonical.z ? Mp(this.wrap * +i, r, this.canonical.z, this.canonical.x, this.canonical.y) : Mp(this.wrap * +i, r, r, this.canonical.x >> l, this.canonical.y >> l);
      }, ti.prototype.isChildOf = function(r) {
        if (r.wrap !== this.wrap)
          return !1;
        var i = this.canonical.z - r.canonical.z;
        return r.overscaledZ === 0 || r.overscaledZ < this.overscaledZ && r.canonical.x === this.canonical.x >> i && r.canonical.y === this.canonical.y >> i;
      }, ti.prototype.children = function(r) {
        if (this.overscaledZ >= r)
          return [new ti(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
        var i = this.canonical.z + 1, l = 2 * this.canonical.x, p = 2 * this.canonical.y;
        return [new ti(i, this.wrap, i, l, p), new ti(i, this.wrap, i, l + 1, p), new ti(i, this.wrap, i, l, p + 1), new ti(i, this.wrap, i, l + 1, p + 1)];
      }, ti.prototype.isLessThan = function(r) {
        return this.wrap < r.wrap || !(this.wrap > r.wrap) && (this.overscaledZ < r.overscaledZ || !(this.overscaledZ > r.overscaledZ) && (this.canonical.x < r.canonical.x || !(this.canonical.x > r.canonical.x) && this.canonical.y < r.canonical.y));
      }, ti.prototype.wrapped = function() {
        return new ti(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
      }, ti.prototype.unwrapTo = function(r) {
        return new ti(this.overscaledZ, r, this.canonical.z, this.canonical.x, this.canonical.y);
      }, ti.prototype.overscaleFactor = function() {
        return Math.pow(2, this.overscaledZ - this.canonical.z);
      }, ti.prototype.toUnwrapped = function() {
        return new ib(this.wrap, this.canonical);
      }, ti.prototype.toString = function() {
        return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;
      }, ti.prototype.getTilePoint = function(r) {
        return this.canonical.getTilePoint(new _c(r.x - this.wrap, r.y));
      }, wt("CanonicalTileID", xc), wt("OverscaledTileID", ti, { omit: ["posMatrix"] });
      var Ml = function(r, i, l) {
        if (this.uid = r, i.height !== i.width)
          throw new RangeError("DEM tiles must be square");
        if (l && l !== "mapbox" && l !== "terrarium")
          return at('"' + l + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');
        this.stride = i.height;
        var p = this.dim = i.height - 2;
        this.data = new Uint32Array(i.data.buffer), this.encoding = l || "mapbox";
        for (var y = 0; y < p; y++)
          this.data[this._idx(-1, y)] = this.data[this._idx(0, y)], this.data[this._idx(p, y)] = this.data[this._idx(p - 1, y)], this.data[this._idx(y, -1)] = this.data[this._idx(y, 0)], this.data[this._idx(y, p)] = this.data[this._idx(y, p - 1)];
        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(p, -1)] = this.data[this._idx(p - 1, 0)], this.data[this._idx(-1, p)] = this.data[this._idx(0, p - 1)], this.data[this._idx(p, p)] = this.data[this._idx(p - 1, p - 1)];
      };
      Ml.prototype.get = function(r, i) {
        var l = new Uint8Array(this.data.buffer), p = 4 * this._idx(r, i);
        return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(l[p], l[p + 1], l[p + 2]);
      }, Ml.prototype.getUnpackVector = function() {
        return this.encoding === "terrarium" ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
      }, Ml.prototype._idx = function(r, i) {
        if (r < -1 || r >= this.dim + 1 || i < -1 || i >= this.dim + 1)
          throw new RangeError("out of range source coordinates for DEM data");
        return (i + 1) * this.stride + (r + 1);
      }, Ml.prototype._unpackMapbox = function(r, i, l) {
        return (256 * r * 256 + 256 * i + l) / 10 - 1e4;
      }, Ml.prototype._unpackTerrarium = function(r, i, l) {
        return 256 * r + i + l / 256 - 32768;
      }, Ml.prototype.getPixels = function() {
        return new yo({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
      }, Ml.prototype.backfillBorder = function(r, i, l) {
        if (this.dim !== r.dim)
          throw new Error("dem dimension mismatch");
        var p = i * this.dim, y = i * this.dim + this.dim, v = l * this.dim, x = l * this.dim + this.dim;
        switch (i) {
          case -1:
            p = y - 1;
            break;
          case 1:
            y = p + 1;
        }
        switch (l) {
          case -1:
            v = x - 1;
            break;
          case 1:
            x = v + 1;
        }
        for (var S = -i * this.dim, C = -l * this.dim, A = v; A < x; A++)
          for (var L = p; L < y; L++)
            this.data[this._idx(L, A)] = r.data[this._idx(L + S, A + C)];
      }, wt("DEMData", Ml);
      var Qm = function(r) {
        this._stringToNumber = {}, this._numberToString = [];
        for (var i = 0; i < r.length; i++) {
          var l = r[i];
          this._stringToNumber[l] = i, this._numberToString[i] = l;
        }
      };
      Qm.prototype.encode = function(r) {
        return this._stringToNumber[r];
      }, Qm.prototype.decode = function(r) {
        return this._numberToString[r];
      };
      var ey = function(r, i, l, p, y) {
        this.type = "Feature", this._vectorTileFeature = r, r._z = i, r._x = l, r._y = p, this.properties = r.properties, this.id = y;
      }, g_ = { geometry: { configurable: !0 } };
      g_.geometry.get = function() {
        return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
      }, g_.geometry.set = function(r) {
        this._geometry = r;
      }, ey.prototype.toJSON = function() {
        var r = { geometry: this.geometry };
        for (var i in this)
          i !== "_geometry" && i !== "_vectorTileFeature" && (r[i] = this[i]);
        return r;
      }, Object.defineProperties(ey.prototype, g_);
      var jh = function() {
        this.state = {}, this.stateChanges = {}, this.deletedStates = {};
      };
      jh.prototype.updateState = function(r, i, l) {
        var p = String(i);
        if (this.stateChanges[r] = this.stateChanges[r] || {}, this.stateChanges[r][p] = this.stateChanges[r][p] || {}, X(this.stateChanges[r][p], l), this.deletedStates[r] === null)
          for (var y in this.deletedStates[r] = {}, this.state[r])
            y !== p && (this.deletedStates[r][y] = null);
        else if (this.deletedStates[r] && this.deletedStates[r][p] === null)
          for (var v in this.deletedStates[r][p] = {}, this.state[r][p])
            l[v] || (this.deletedStates[r][p][v] = null);
        else
          for (var x in l)
            this.deletedStates[r] && this.deletedStates[r][p] && this.deletedStates[r][p][x] === null && delete this.deletedStates[r][p][x];
      }, jh.prototype.removeFeatureState = function(r, i, l) {
        if (this.deletedStates[r] !== null) {
          var p = String(i);
          if (this.deletedStates[r] = this.deletedStates[r] || {}, l && i !== void 0)
            this.deletedStates[r][p] !== null && (this.deletedStates[r][p] = this.deletedStates[r][p] || {}, this.deletedStates[r][p][l] = null);
          else if (i !== void 0)
            if (this.stateChanges[r] && this.stateChanges[r][p])
              for (l in this.deletedStates[r][p] = {}, this.stateChanges[r][p])
                this.deletedStates[r][p][l] = null;
            else
              this.deletedStates[r][p] = null;
          else
            this.deletedStates[r] = null;
        }
      }, jh.prototype.getState = function(r, i) {
        var l = String(i), p = X({}, (this.state[r] || {})[l], (this.stateChanges[r] || {})[l]);
        if (this.deletedStates[r] === null)
          return {};
        if (this.deletedStates[r]) {
          var y = this.deletedStates[r][i];
          if (y === null)
            return {};
          for (var v in y)
            delete p[v];
        }
        return p;
      }, jh.prototype.initializeTileState = function(r, i) {
        r.setFeatureState(this.state, i);
      }, jh.prototype.coalesceChanges = function(r, i) {
        var l = {};
        for (var p in this.stateChanges) {
          this.state[p] = this.state[p] || {};
          var y = {};
          for (var v in this.stateChanges[p])
            this.state[p][v] || (this.state[p][v] = {}), X(this.state[p][v], this.stateChanges[p][v]), y[v] = this.state[p][v];
          l[p] = y;
        }
        for (var x in this.deletedStates) {
          this.state[x] = this.state[x] || {};
          var S = {};
          if (this.deletedStates[x] === null)
            for (var C in this.state[x])
              S[C] = {}, this.state[x][C] = {};
          else
            for (var A in this.deletedStates[x]) {
              if (this.deletedStates[x][A] === null)
                this.state[x][A] = {};
              else
                for (var L = 0, D = Object.keys(this.deletedStates[x][A]); L < D.length; L += 1)
                  delete this.state[x][A][D[L]];
              S[A] = this.state[x][A];
            }
          l[x] = l[x] || {}, X(l[x], S);
        }
        if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(l).length !== 0)
          for (var B in r)
            r[B].setFeatureState(l, i);
      };
      var Il = function(r, i) {
        this.tileID = r, this.x = r.canonical.x, this.y = r.canonical.y, this.z = r.canonical.z, this.grid = new Ua(8192, 16, 0), this.grid3D = new Ua(8192, 16, 0), this.featureIndexArray = new R(), this.promoteId = i;
      };
      function ob(r, i, l, p, y) {
        return Se(r, function(v, x) {
          var S = i instanceof cc ? i.get(x) : null;
          return S && S.evaluate ? S.evaluate(l, p, y) : S;
        });
      }
      function ab(r) {
        for (var i = 1 / 0, l = 1 / 0, p = -1 / 0, y = -1 / 0, v = 0, x = r; v < x.length; v += 1) {
          var S = x[v];
          i = Math.min(i, S.x), l = Math.min(l, S.y), p = Math.max(p, S.x), y = Math.max(y, S.y);
        }
        return { minX: i, minY: l, maxX: p, maxY: y };
      }
      function sC(r, i) {
        return i - r;
      }
      Il.prototype.insert = function(r, i, l, p, y, v) {
        var x = this.featureIndexArray.length;
        this.featureIndexArray.emplaceBack(l, p, y);
        for (var S = v ? this.grid3D : this.grid, C = 0; C < i.length; C++) {
          for (var A = i[C], L = [1 / 0, 1 / 0, -1 / 0, -1 / 0], D = 0; D < A.length; D++) {
            var B = A[D];
            L[0] = Math.min(L[0], B.x), L[1] = Math.min(L[1], B.y), L[2] = Math.max(L[2], B.x), L[3] = Math.max(L[3], B.y);
          }
          L[0] < 8192 && L[1] < 8192 && L[2] >= 0 && L[3] >= 0 && S.insert(x, L[0], L[1], L[2], L[3]);
        }
      }, Il.prototype.loadVTLayers = function() {
        return this.vtLayers || (this.vtLayers = new kh.VectorTile(new jm(this.rawTileData)).layers, this.sourceLayerCoder = new Qm(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
      }, Il.prototype.query = function(r, i, l, p) {
        var y = this;
        this.loadVTLayers();
        for (var v = r.params || {}, x = 8192 / r.tileSize / r.scale, S = mh(v.filter), C = r.queryGeometry, A = r.queryPadding * x, L = ab(C), D = this.grid.query(L.minX - A, L.minY - A, L.maxX + A, L.maxY + A), B = ab(r.cameraQueryGeometry), j = this.grid3D.query(B.minX - A, B.minY - A, B.maxX + A, B.maxY + A, function(Te, Oe, Be, Ke) {
          return function(ot, At, dt, Nt, yt) {
            for (var sr = 0, qt = ot; sr < qt.length; sr += 1) {
              var Mt = qt[sr];
              if (At <= Mt.x && dt <= Mt.y && Nt >= Mt.x && yt >= Mt.y)
                return !0;
            }
            var fr = [new T(At, dt), new T(At, yt), new T(Nt, yt), new T(Nt, dt)];
            if (ot.length > 2) {
              for (var rr = 0, Mr = fr; rr < Mr.length; rr += 1)
                if (Sa(ot, Mr[rr]))
                  return !0;
            }
            for (var Rt = 0; Rt < ot.length - 1; Rt++)
              if (mc(ot[Rt], ot[Rt + 1], fr))
                return !0;
            return !1;
          }(r.cameraQueryGeometry, Te - A, Oe - A, Be + A, Ke + A);
        }), J = 0, ee = j; J < ee.length; J += 1)
          D.push(ee[J]);
        D.sort(sC);
        for (var he, oe = {}, ge = function(Te) {
          var Oe = D[Te];
          if (Oe !== he) {
            he = Oe;
            var Be = y.featureIndexArray.get(Oe), Ke = null;
            y.loadMatchingFeature(oe, Be.bucketIndex, Be.sourceLayerIndex, Be.featureIndex, S, v.layers, v.availableImages, i, l, p, function(ot, At, dt) {
              return Ke || (Ke = Mn(ot)), At.queryIntersectsFeature(C, ot, dt, Ke, y.z, r.transform, x, r.pixelPosMatrix);
            });
          }
        }, we = 0; we < D.length; we++)
          ge(we);
        return oe;
      }, Il.prototype.loadMatchingFeature = function(r, i, l, p, y, v, x, S, C, A, L) {
        var D = this.bucketLayerIDs[i];
        if (!v || function(ot, At) {
          for (var dt = 0; dt < ot.length; dt++)
            if (At.indexOf(ot[dt]) >= 0)
              return !0;
          return !1;
        }(v, D)) {
          var B = this.sourceLayerCoder.decode(l), j = this.vtLayers[B].feature(p);
          if (y.needGeometry) {
            var J = Dn(j, !0);
            if (!y.filter(new mr(this.tileID.overscaledZ), J, this.tileID.canonical))
              return;
          } else if (!y.filter(new mr(this.tileID.overscaledZ), j))
            return;
          for (var ee = this.getId(j, B), he = 0; he < D.length; he++) {
            var oe = D[he];
            if (!(v && v.indexOf(oe) < 0)) {
              var ge = S[oe];
              if (ge) {
                var we = {};
                ee !== void 0 && A && (we = A.getState(ge.sourceLayer || "_geojsonTileLayer", ee));
                var Te = X({}, C[oe]);
                Te.paint = ob(Te.paint, ge.paint, j, we, x), Te.layout = ob(Te.layout, ge.layout, j, we, x);
                var Oe = !L || L(j, ge, we);
                if (Oe) {
                  var Be = new ey(j, this.z, this.x, this.y, ee);
                  Be.layer = Te;
                  var Ke = r[oe];
                  Ke === void 0 && (Ke = r[oe] = []), Ke.push({ featureIndex: p, feature: Be, intersectionZ: Oe });
                }
              }
            }
          }
        }
      }, Il.prototype.lookupSymbolFeatures = function(r, i, l, p, y, v, x, S) {
        var C = {};
        this.loadVTLayers();
        for (var A = mh(y), L = 0, D = r; L < D.length; L += 1)
          this.loadMatchingFeature(C, l, p, D[L], A, v, x, S, i);
        return C;
      }, Il.prototype.hasLayer = function(r) {
        for (var i = 0, l = this.bucketLayerIDs; i < l.length; i += 1)
          for (var p = 0, y = l[i]; p < y.length; p += 1)
            if (r === y[p])
              return !0;
        return !1;
      }, Il.prototype.getId = function(r, i) {
        var l = r.id;
        return this.promoteId && typeof (l = r.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[i]]) == "boolean" && (l = Number(l)), l;
      }, wt("FeatureIndex", Il, { omit: ["rawTileData", "sourceLayerCoder"] });
      var vi = function(r, i) {
        this.tileID = r, this.uid = ce(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
      };
      vi.prototype.registerFadeDuration = function(r) {
        var i = r + this.timeAdded;
        i < Vn.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);
      }, vi.prototype.wasRequested = function() {
        return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
      }, vi.prototype.loadVectorData = function(r, i, l) {
        if (this.hasData() && this.unloadVectorData(), this.state = "loaded", r) {
          for (var p in r.featureIndex && (this.latestFeatureIndex = r.featureIndex, r.rawTileData ? (this.latestRawTileData = r.rawTileData, this.latestFeatureIndex.rawTileData = r.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = r.collisionBoxArray, this.buckets = function(A, L) {
            var D = {};
            if (!L)
              return D;
            for (var B = function() {
              var ee = J[j], he = ee.layerIds.map(function(we) {
                return L.getLayer(we);
              }).filter(Boolean);
              if (he.length !== 0) {
                ee.layers = he, ee.stateDependentLayerIds && (ee.stateDependentLayers = ee.stateDependentLayerIds.map(function(we) {
                  return he.filter(function(Te) {
                    return Te.id === we;
                  })[0];
                }));
                for (var oe = 0, ge = he; oe < ge.length; oe += 1)
                  D[ge[oe].id] = ee;
              }
            }, j = 0, J = A; j < J.length; j += 1)
              B();
            return D;
          }(r.buckets, i.style), this.hasSymbolBuckets = !1, this.buckets) {
            var y = this.buckets[p];
            if (y instanceof Wr) {
              if (this.hasSymbolBuckets = !0, !l)
                break;
              y.justReloaded = !0;
            }
          }
          if (this.hasRTLText = !1, this.hasSymbolBuckets)
            for (var v in this.buckets) {
              var x = this.buckets[v];
              if (x instanceof Wr && x.hasRTLText) {
                this.hasRTLText = !0, Io.isLoading() || Io.isLoaded() || up() !== "deferred" || sa();
                break;
              }
            }
          for (var S in this.queryPadding = 0, this.buckets) {
            var C = this.buckets[S];
            this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(S).queryRadius(C));
          }
          r.imageAtlas && (this.imageAtlas = r.imageAtlas), r.glyphAtlasImage && (this.glyphAtlasImage = r.glyphAtlasImage);
        } else
          this.collisionBoxArray = new f();
      }, vi.prototype.unloadVectorData = function() {
        for (var r in this.buckets)
          this.buckets[r].destroy();
        this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
      }, vi.prototype.getBucket = function(r) {
        return this.buckets[r.id];
      }, vi.prototype.upload = function(r) {
        for (var i in this.buckets) {
          var l = this.buckets[i];
          l.uploadPending() && l.upload(r);
        }
        var p = r.gl;
        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new vc(r, this.imageAtlas.image, p.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new vc(r, this.glyphAtlasImage, p.ALPHA), this.glyphAtlasImage = null);
      }, vi.prototype.prepare = function(r) {
        this.imageAtlas && this.imageAtlas.patchUpdatedImages(r, this.imageAtlasTexture);
      }, vi.prototype.queryRenderedFeatures = function(r, i, l, p, y, v, x, S, C, A) {
        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: p, cameraQueryGeometry: y, scale: v, tileSize: this.tileSize, pixelPosMatrix: A, transform: S, params: x, queryPadding: this.queryPadding * C }, r, i, l) : {};
      }, vi.prototype.querySourceFeatures = function(r, i) {
        var l = this.latestFeatureIndex;
        if (l && l.rawTileData) {
          var p = l.loadVTLayers(), y = i ? i.sourceLayer : "", v = p._geojsonTileLayer || p[y];
          if (v)
            for (var x = mh(i && i.filter), S = this.tileID.canonical, C = S.z, A = S.x, L = S.y, D = { z: C, x: A, y: L }, B = 0; B < v.length; B++) {
              var j = v.feature(B);
              if (x.needGeometry) {
                var J = Dn(j, !0);
                if (!x.filter(new mr(this.tileID.overscaledZ), J, this.tileID.canonical))
                  continue;
              } else if (!x.filter(new mr(this.tileID.overscaledZ), j))
                continue;
              var ee = l.getId(j, y), he = new ey(j, C, A, L, ee);
              he.tile = D, r.push(he);
            }
        }
      }, vi.prototype.hasData = function() {
        return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
      }, vi.prototype.patternsLoaded = function() {
        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
      }, vi.prototype.setExpiryData = function(r) {
        var i = this.expirationTime;
        if (r.cacheControl) {
          var l = vt(r.cacheControl);
          l["max-age"] && (this.expirationTime = Date.now() + 1e3 * l["max-age"]);
        } else
          r.expires && (this.expirationTime = new Date(r.expires).getTime());
        if (this.expirationTime) {
          var p = Date.now(), y = !1;
          if (this.expirationTime > p)
            y = !1;
          else if (i)
            if (this.expirationTime < i)
              y = !0;
            else {
              var v = this.expirationTime - i;
              v ? this.expirationTime = p + Math.max(v, 3e4) : y = !0;
            }
          else
            y = !0;
          y ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
        }
      }, vi.prototype.getExpiryTimeout = function() {
        if (this.expirationTime)
          return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
      }, vi.prototype.setFeatureState = function(r, i) {
        if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && Object.keys(r).length !== 0) {
          var l = this.latestFeatureIndex.loadVTLayers();
          for (var p in this.buckets)
            if (i.style.hasLayer(p)) {
              var y = this.buckets[p], v = y.layers[0].sourceLayer || "_geojsonTileLayer", x = l[v], S = r[v];
              if (x && S && Object.keys(S).length !== 0) {
                y.update(S, x, this.imageAtlas && this.imageAtlas.patternPositions || {});
                var C = i && i.style && i.style.getLayer(p);
                C && (this.queryPadding = Math.max(this.queryPadding, C.queryRadius(y)));
              }
            }
        }
      }, vi.prototype.holdingForFade = function() {
        return this.symbolFadeHoldUntil !== void 0;
      }, vi.prototype.symbolFadeFinished = function() {
        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Vn.now();
      }, vi.prototype.clearFadeHold = function() {
        this.symbolFadeHoldUntil = void 0;
      }, vi.prototype.setHoldDuration = function(r) {
        this.symbolFadeHoldUntil = Vn.now() + r;
      }, vi.prototype.setDependencies = function(r, i) {
        for (var l = {}, p = 0, y = i; p < y.length; p += 1)
          l[y[p]] = !0;
        this.dependencies[r] = l;
      }, vi.prototype.hasDependency = function(r, i) {
        for (var l = 0, p = r; l < p.length; l += 1) {
          var y = this.dependencies[p[l]];
          if (y) {
            for (var v = 0, x = i; v < x.length; v += 1)
              if (y[x[v]])
                return !0;
          }
        }
        return !1;
      };
      var hu = I.performance, sb = function(r) {
        this._marks = { start: [r.url, "start"].join("#"), end: [r.url, "end"].join("#"), measure: r.url.toString() }, hu.mark(this._marks.start);
      };
      sb.prototype.finish = function() {
        hu.mark(this._marks.end);
        var r = hu.getEntriesByName(this._marks.measure);
        return r.length === 0 && (hu.measure(this._marks.measure, this._marks.start, this._marks.end), r = hu.getEntriesByName(this._marks.measure), hu.clearMarks(this._marks.start), hu.clearMarks(this._marks.end), hu.clearMeasures(this._marks.measure)), r;
      }, a.Actor = Uh, a.AlphaImage = gc, a.CanonicalTileID = xc, a.CollisionBoxArray = f, a.Color = Fr, a.DEMData = Ml, a.DataConstantProperty = Lt, a.DictionaryCoder = Qm, a.EXTENT = 8192, a.ErrorEvent = pe, a.EvaluationParameters = mr, a.Event = Q, a.Evented = de, a.FeatureIndex = Il, a.FillBucket = qa, a.FillExtrusionBucket = Wa, a.ImageAtlas = Sp, a.ImagePosition = $m, a.LineBucket = to, a.LngLat = yn, a.LngLatBounds = ei, a.MercatorCoordinate = _c, a.ONE_EM = 24, a.OverscaledTileID = ti, a.Point = T, a.Point$1 = T, a.Properties = Ii, a.Protobuf = jm, a.RGBAImage = yo, a.RequestManager = Ne, a.RequestPerformance = sb, a.ResourceType = Fa, a.SegmentVector = W, a.SourceFeatureState = jh, a.StructArrayLayout1ui2 = mp, a.StructArrayLayout2f1f2i16 = wl, a.StructArrayLayout2i4 = bl, a.StructArrayLayout3ui6 = Ts, a.StructArrayLayout4i8 = hp, a.SymbolBucket = Wr, a.Texture = vc, a.Tile = vi, a.Transitionable = Mi, a.Uniform1f = nt, a.Uniform1i = je, a.Uniform2f = tt, a.Uniform3f = gt, a.Uniform4f = Dt, a.UniformColor = Bt, a.UniformMatrix4f = Ir, a.UnwrappedTileID = ib, a.ValidationError = ie, a.WritingMode = Xo, a.ZoomHistory = op, a.add = function(r, i, l) {
        return r[0] = i[0] + l[0], r[1] = i[1] + l[1], r[2] = i[2] + l[2], r;
      }, a.addDynamicAttributes = p_, a.asyncAll = function(r, i, l) {
        if (!r.length)
          return l(null, []);
        var p = r.length, y = new Array(r.length), v = null;
        r.forEach(function(x, S) {
          i(x, function(C, A) {
            C && (v = C), y[S] = A, --p == 0 && l(v, y);
          });
        });
      }, a.bezier = z, a.bindAll = Fe, a.browser = Vn, a.cacheEntryPossiblyAdded = function(r) {
        ++Tn > Bi && (r.getActor().send("enforceCacheSizeLimit", Xn), Tn = 0);
      }, a.clamp = q, a.clearTileCache = function(r) {
        var i = I.caches.delete("mapbox-tiles");
        r && i.catch(r).then(function() {
          return r();
        });
      }, a.clipLine = jx, a.clone = function(r) {
        var i = new Br(16);
        return i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], i[4] = r[4], i[5] = r[5], i[6] = r[6], i[7] = r[7], i[8] = r[8], i[9] = r[9], i[10] = r[10], i[11] = r[11], i[12] = r[12], i[13] = r[13], i[14] = r[14], i[15] = r[15], i;
      }, a.clone$1 = Xe, a.clone$2 = function(r) {
        var i = new Br(3);
        return i[0] = r[0], i[1] = r[1], i[2] = r[2], i;
      }, a.collisionCircleLayout = IO, a.config = Tr, a.create = function() {
        var r = new Br(16);
        return Br != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;
      }, a.create$1 = function() {
        var r = new Br(9);
        return Br != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
      }, a.create$2 = function() {
        var r = new Br(4);
        return Br != Float32Array && (r[1] = 0, r[2] = 0), r[0] = 1, r[3] = 1, r;
      }, a.createCommonjsModule = m, a.createExpression = ph, a.createLayout = yi, a.createStyleLayer = function(r) {
        return r.type === "custom" ? new oC(r) : new aC[r.type](r);
      }, a.cross = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = l[0], S = l[1], C = l[2];
        return r[0] = y * C - v * S, r[1] = v * x - p * C, r[2] = p * S - y * x, r;
      }, a.deepEqual = function r(i, l) {
        if (Array.isArray(i)) {
          if (!Array.isArray(l) || i.length !== l.length)
            return !1;
          for (var p = 0; p < i.length; p++)
            if (!r(i[p], l[p]))
              return !1;
          return !0;
        }
        if (typeof i == "object" && i !== null && l !== null) {
          if (typeof l != "object" || Object.keys(i).length !== Object.keys(l).length)
            return !1;
          for (var y in i)
            if (!r(i[y], l[y]))
              return !1;
          return !0;
        }
        return i === l;
      }, a.dot = function(r, i) {
        return r[0] * i[0] + r[1] * i[1] + r[2] * i[2];
      }, a.dot$1 = function(r, i) {
        return r[0] * i[0] + r[1] * i[1] + r[2] * i[2] + r[3] * i[3];
      }, a.ease = V, a.emitValidationErrors = sc, a.endsWith = Pe, a.enforceCacheSizeLimit = function(r) {
        so(), bt && bt.then(function(i) {
          i.keys().then(function(l) {
            for (var p = 0; p < l.length - r; p++)
              i.delete(l[p]);
          });
        });
      }, a.evaluateSizeForFeature = Rx, a.evaluateSizeForZoom = zx, a.evaluateVariableOffset = qx, a.evented = lp, a.extend = X, a.featureFilter = mh, a.filterObject = Ie, a.fromRotation = function(r, i) {
        var l = Math.sin(i), p = Math.cos(i);
        return r[0] = p, r[1] = l, r[2] = 0, r[3] = -l, r[4] = p, r[5] = 0, r[6] = 0, r[7] = 0, r[8] = 1, r;
      }, a.getAnchorAlignment = u_, a.getAnchorJustification = f_, a.getArrayBuffer = ol, a.getImage = F, a.getJSON = function(r, i) {
        return So(X(r, { type: "json" }), i);
      }, a.getRTLTextPluginStatus = up, a.getReferrer = Ba, a.getVideo = function(r, i) {
        var l, p, y = I.document.createElement("video");
        y.muted = !0, y.onloadstart = function() {
          i(null, y);
        };
        for (var v = 0; v < r.length; v++) {
          var x = I.document.createElement("source");
          l = r[v], p = void 0, (p = I.document.createElement("a")).href = l, (p.protocol !== I.document.location.protocol || p.host !== I.document.location.host) && (y.crossOrigin = "Anonymous"), x.src = r[v], y.appendChild(x);
        }
        return { cancel: function() {
        } };
      }, a.identity = Oo, a.invert = function(r, i) {
        var l = i[0], p = i[1], y = i[2], v = i[3], x = i[4], S = i[5], C = i[6], A = i[7], L = i[8], D = i[9], B = i[10], j = i[11], J = i[12], ee = i[13], he = i[14], oe = i[15], ge = l * S - p * x, we = l * C - y * x, Te = l * A - v * x, Oe = p * C - y * S, Be = p * A - v * S, Ke = y * A - v * C, ot = L * ee - D * J, At = L * he - B * J, dt = L * oe - j * J, Nt = D * he - B * ee, yt = D * oe - j * ee, sr = B * oe - j * he, qt = ge * sr - we * yt + Te * Nt + Oe * dt - Be * At + Ke * ot;
        return qt ? (r[0] = (S * sr - C * yt + A * Nt) * (qt = 1 / qt), r[1] = (y * yt - p * sr - v * Nt) * qt, r[2] = (ee * Ke - he * Be + oe * Oe) * qt, r[3] = (B * Be - D * Ke - j * Oe) * qt, r[4] = (C * dt - x * sr - A * At) * qt, r[5] = (l * sr - y * dt + v * At) * qt, r[6] = (he * Te - J * Ke - oe * we) * qt, r[7] = (L * Ke - B * Te + j * we) * qt, r[8] = (x * yt - S * dt + A * ot) * qt, r[9] = (p * dt - l * yt - v * ot) * qt, r[10] = (J * Be - ee * Te + oe * ge) * qt, r[11] = (D * Te - L * Be - j * ge) * qt, r[12] = (S * At - x * Nt - C * ot) * qt, r[13] = (l * Nt - p * At + y * ot) * qt, r[14] = (ee * we - J * Oe - he * ge) * qt, r[15] = (L * Oe - D * we + B * ge) * qt, r) : null;
      }, a.isChar = ct, a.isMapboxURL = qe, a.keysDifference = function(r, i) {
        var l = [];
        for (var p in r)
          p in i || l.push(p);
        return l;
      }, a.makeRequest = So, a.mapObject = Se, a.mercatorXfromLng = tb, a.mercatorYfromLat = rb, a.mercatorZfromAltitude = nb, a.mul = Yv, a.multiply = eo, a.mvt = kh, a.nextPowerOfTwo = function(r) {
        return r <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
      }, a.normalize = function(r, i) {
        var l = i[0], p = i[1], y = i[2], v = l * l + p * p + y * y;
        return v > 0 && (v = 1 / Math.sqrt(v)), r[0] = i[0] * v, r[1] = i[1] * v, r[2] = i[2] * v, r;
      }, a.number = jn, a.offscreenCanvasSupported = ai, a.ortho = function(r, i, l, p, y, v, x) {
        var S = 1 / (i - l), C = 1 / (p - y), A = 1 / (v - x);
        return r[0] = -2 * S, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * C, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * A, r[11] = 0, r[12] = (i + l) * S, r[13] = (y + p) * C, r[14] = (x + v) * A, r[15] = 1, r;
      }, a.parseGlyphPBF = function(r) {
        return new jm(r).readFields(FO, []);
      }, a.pbf = jm, a.performSymbolLayout = function(r, i, l, p, y, v, x) {
        r.createArrays(), r.tilePixelRatio = 8192 / (512 * r.overscaling), r.compareText = {}, r.iconsNeedLinear = !1;
        var S = r.layers[0].layout, C = r.layers[0]._unevaluatedLayout._values, A = {};
        if (r.textSizeData.kind === "composite") {
          var L = r.textSizeData, D = L.maxZoom;
          A.compositeTextSizes = [C["text-size"].possiblyEvaluate(new mr(L.minZoom), x), C["text-size"].possiblyEvaluate(new mr(D), x)];
        }
        if (r.iconSizeData.kind === "composite") {
          var B = r.iconSizeData, j = B.maxZoom;
          A.compositeIconSizes = [C["icon-size"].possiblyEvaluate(new mr(B.minZoom), x), C["icon-size"].possiblyEvaluate(new mr(j), x)];
        }
        A.layoutTextSize = C["text-size"].possiblyEvaluate(new mr(r.zoom + 1), x), A.layoutIconSize = C["icon-size"].possiblyEvaluate(new mr(r.zoom + 1), x), A.textMaxSize = C["text-size"].possiblyEvaluate(new mr(18));
        for (var J = 24 * S.get("text-line-height"), ee = S.get("text-rotation-alignment") === "map" && S.get("symbol-placement") !== "point", he = S.get("text-keep-upright"), oe = S.get("text-size"), ge = function() {
          var Oe = Te[we], Be = S.get("text-font").evaluate(Oe, {}, x).join(","), Ke = oe.evaluate(Oe, {}, x), ot = A.layoutTextSize.evaluate(Oe, {}, x), At = A.layoutIconSize.evaluate(Oe, {}, x), dt = { horizontal: {}, vertical: void 0 }, Nt = Oe.text, yt = [0, 0];
          if (Nt) {
            var sr = Nt.toString(), qt = 24 * S.get("text-letter-spacing").evaluate(Oe, {}, x), Mt = function(vr) {
              for (var Xr = 0, qr = vr; Xr < qr.length; Xr += 1)
                if (Or = qr[Xr].charCodeAt(0), ct.Arabic(Or) || ct["Arabic Supplement"](Or) || ct["Arabic Extended-A"](Or) || ct["Arabic Presentation Forms-A"](Or) || ct["Arabic Presentation Forms-B"](Or))
                  return !1;
              var Or;
              return !0;
            }(sr) ? qt : 0, fr = S.get("text-anchor").evaluate(Oe, {}, x), rr = S.get("text-variable-anchor");
            if (!rr) {
              var Mr = S.get("text-radial-offset").evaluate(Oe, {}, x);
              yt = Mr ? qx(fr, [24 * Mr, h_]) : S.get("text-offset").evaluate(Oe, {}, x).map(function(vr) {
                return 24 * vr;
              });
            }
            var Rt = ee ? "center" : S.get("text-justify").evaluate(Oe, {}, x), Dr = S.get("symbol-placement"), gn = Dr === "point" ? 24 * S.get("text-max-width").evaluate(Oe, {}, x) : 0, Cn = function() {
              r.allowVerticalPlacement && ap(sr) && (dt.vertical = qm(Nt, i, l, y, Be, gn, J, fr, "left", Mt, yt, Xo.vertical, !0, Dr, ot, Ke));
            };
            if (!ee && rr) {
              for (var In = Rt === "auto" ? rr.map(function(vr) {
                return f_(vr);
              }) : [Rt], vn = !1, An = 0; An < In.length; An++) {
                var ui = In[An];
                if (!dt.horizontal[ui])
                  if (vn)
                    dt.horizontal[ui] = dt.horizontal[0];
                  else {
                    var ci = qm(Nt, i, l, y, Be, gn, J, "center", ui, Mt, yt, Xo.horizontal, !1, Dr, ot, Ke);
                    ci && (dt.horizontal[ui] = ci, vn = ci.positionedLines.length === 1);
                  }
              }
              Cn();
            } else {
              Rt === "auto" && (Rt = f_(fr));
              var Wi = qm(Nt, i, l, y, Be, gn, J, fr, Rt, Mt, yt, Xo.horizontal, !1, Dr, ot, Ke);
              Wi && (dt.horizontal[Rt] = Wi), Cn(), ap(sr) && ee && he && (dt.vertical = qm(Nt, i, l, y, Be, gn, J, fr, Rt, Mt, yt, Xo.vertical, !1, Dr, ot, Ke));
            }
          }
          var _i = void 0, Hi = !1;
          if (Oe.icon && Oe.icon.name) {
            var Nn = p[Oe.icon.name];
            Nn && (_i = function(vr, Xr, qr) {
              var Or = u_(qr), ro = Xr[0] - vr.displaySize[0] * Or.horizontalAlign, Ni = Xr[1] - vr.displaySize[1] * Or.verticalAlign;
              return { image: vr, top: Ni, bottom: Ni + vr.displaySize[1], left: ro, right: ro + vr.displaySize[0] };
            }(y[Oe.icon.name], S.get("icon-offset").evaluate(Oe, {}, x), S.get("icon-anchor").evaluate(Oe, {}, x)), Hi = Nn.sdf, r.sdfIcons === void 0 ? r.sdfIcons = Nn.sdf : r.sdfIcons !== Nn.sdf && at("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Nn.pixelRatio !== r.pixelRatio || S.get("icon-rotate").constantOr(1) !== 0) && (r.iconsNeedLinear = !0));
          }
          var xi = Hx(dt.horizontal) || dt.vertical;
          r.iconsInText = !!xi && xi.iconsInText, (xi || _i) && function(vr, Xr, qr, Or, ro, Ni, sn, $n, Ri, Nr, Ps) {
            var Ko = Ni.textMaxSize.evaluate(Xr, {});
            Ko === void 0 && (Ko = sn);
            var ks, Rn = vr.layers[0].layout, Ls = Rn.get("icon-offset").evaluate(Xr, {}, Ps), Ma = Hx(qr.horizontal), Gh = sn / 24, bc = vr.tilePixelRatio * Gh, $h = vr.tilePixelRatio * Ko / 24, Ol = vr.tilePixelRatio * $n, qh = vr.tilePixelRatio * Rn.get("symbol-spacing"), ty = Rn.get("text-padding") * vr.tilePixelRatio, Wh = Rn.get("icon-padding") * vr.tilePixelRatio, Ip = Rn.get("text-max-angle") / 180 * Math.PI, ry = Rn.get("text-rotation-alignment") === "map" && Rn.get("symbol-placement") !== "point", ny = Rn.get("icon-rotation-alignment") === "map" && Rn.get("symbol-placement") !== "point", Cl = Rn.get("symbol-placement"), Op = qh / 2, Hh = Rn.get("icon-text-fit");
            Or && Hh !== "none" && (vr.allowVerticalPlacement && qr.vertical && (ks = Nx(Or, qr.vertical, Hh, Rn.get("icon-text-fit-padding"), Ls, Gh)), Ma && (Or = Nx(Or, Ma, Hh, Rn.get("icon-text-fit-padding"), Ls, Gh)));
            var fu = function(lC, Rp) {
              Rp.x < 0 || Rp.x >= 8192 || Rp.y < 0 || Rp.y >= 8192 || function(zn, Ha, uC, pu, b_, cb, uy, Ds, cy, zp, hy, fy, w_, hb, Fp, fb, pb, db, mb, yb, Yo, py, gb, Ns, cC) {
                var vb, Ec, Jh, Qh, ef, tf = zn.addToLineVertexArray(Ha, uC), _b = 0, xb = 0, bb = 0, wb = 0, E_ = -1, S_ = -1, Al = {}, Eb = Y(""), T_ = 0, M_ = 0;
                if (Ds._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? (T_ = (vb = Ds.layout.get("text-offset").evaluate(Yo, {}, Ns).map(function(Vp) {
                  return 24 * Vp;
                }))[0], M_ = vb[1]) : (T_ = 24 * Ds.layout.get("text-radial-offset").evaluate(Yo, {}, Ns), M_ = h_), zn.allowVerticalPlacement && pu.vertical) {
                  var Sb = Ds.layout.get("text-rotate").evaluate(Yo, {}, Ns) + 90;
                  Qh = new Km(cy, Ha, zp, hy, fy, pu.vertical, w_, hb, Fp, Sb), uy && (ef = new Km(cy, Ha, zp, hy, fy, uy, pb, db, Fp, Sb));
                }
                if (b_) {
                  var I_ = Ds.layout.get("icon-rotate").evaluate(Yo, {}), Tb = Ds.layout.get("icon-text-fit") !== "none", Mb = Gx(b_, I_, gb, Tb), O_ = uy ? Gx(uy, I_, gb, Tb) : void 0;
                  Jh = new Km(cy, Ha, zp, hy, fy, b_, pb, db, !1, I_), _b = 4 * Mb.length;
                  var Ib = zn.iconSizeData, Bp = null;
                  Ib.kind === "source" ? (Bp = [128 * Ds.layout.get("icon-size").evaluate(Yo, {})])[0] > 32640 && at(zn.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".') : Ib.kind === "composite" && ((Bp = [128 * py.compositeIconSizes[0].evaluate(Yo, {}, Ns), 128 * py.compositeIconSizes[1].evaluate(Yo, {}, Ns)])[0] > 32640 || Bp[1] > 32640) && at(zn.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".'), zn.addSymbols(zn.icon, Mb, Bp, yb, mb, Yo, !1, Ha, tf.lineStartIndex, tf.lineLength, -1, Ns), E_ = zn.icon.placedSymbolArray.length - 1, O_ && (xb = 4 * O_.length, zn.addSymbols(zn.icon, O_, Bp, yb, mb, Yo, Xo.vertical, Ha, tf.lineStartIndex, tf.lineLength, -1, Ns), S_ = zn.icon.placedSymbolArray.length - 1);
                }
                for (var Ob in pu.horizontal) {
                  var dy = pu.horizontal[Ob];
                  if (!Ec) {
                    Eb = Y(dy.text);
                    var hC = Ds.layout.get("text-rotate").evaluate(Yo, {}, Ns);
                    Ec = new Km(cy, Ha, zp, hy, fy, dy, w_, hb, Fp, hC);
                  }
                  var Cb = dy.positionedLines.length === 1;
                  if (bb += Wx(zn, Ha, dy, cb, Ds, Fp, Yo, fb, tf, pu.vertical ? Xo.horizontal : Xo.horizontalOnly, Cb ? Object.keys(pu.horizontal) : [Ob], Al, E_, py, Ns), Cb)
                    break;
                }
                pu.vertical && (wb += Wx(zn, Ha, pu.vertical, cb, Ds, Fp, Yo, fb, tf, Xo.vertical, ["vertical"], Al, S_, py, Ns));
                var fC = Ec ? Ec.boxStartIndex : zn.collisionBoxArray.length, pC = Ec ? Ec.boxEndIndex : zn.collisionBoxArray.length, dC = Qh ? Qh.boxStartIndex : zn.collisionBoxArray.length, mC = Qh ? Qh.boxEndIndex : zn.collisionBoxArray.length, yC = Jh ? Jh.boxStartIndex : zn.collisionBoxArray.length, gC = Jh ? Jh.boxEndIndex : zn.collisionBoxArray.length, vC = ef ? ef.boxStartIndex : zn.collisionBoxArray.length, _C = ef ? ef.boxEndIndex : zn.collisionBoxArray.length, Rs = -1, my = function(Vp, Pb) {
                  return Vp && Vp.circleDiameter ? Math.max(Vp.circleDiameter, Pb) : Pb;
                };
                Rs = my(Ec, Rs), Rs = my(Qh, Rs), Rs = my(Jh, Rs);
                var Ab = (Rs = my(ef, Rs)) > -1 ? 1 : 0;
                Ab && (Rs *= cC / 24), zn.glyphOffsetArray.length >= Wr.MAX_GLYPHS && at("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Yo.sortKey !== void 0 && zn.addToSortKeyRanges(zn.symbolInstances.length, Yo.sortKey), zn.symbolInstances.emplaceBack(Ha.x, Ha.y, Al.right >= 0 ? Al.right : -1, Al.center >= 0 ? Al.center : -1, Al.left >= 0 ? Al.left : -1, Al.vertical || -1, E_, S_, Eb, fC, pC, dC, mC, yC, gC, vC, _C, zp, bb, wb, _b, xb, Ab, 0, w_, T_, M_, Rs);
              }(vr, Rp, lC, qr, Or, ro, ks, vr.layers[0], vr.collisionBoxArray, Xr.index, Xr.sourceLayerIndex, vr.index, bc, ty, ry, Ri, Ol, Wh, ny, Ls, Xr, Ni, Nr, Ps, sn);
            };
            if (Cl === "line")
              for (var Zh = 0, iy = jx(Xr.geometry, 0, 0, 8192, 8192); Zh < iy.length; Zh += 1)
                for (var oy = iy[Zh], Cp = 0, Ap = qO(oy, qh, Ip, qr.vertical || Ma, Or, 24, $h, vr.overscaling, 8192); Cp < Ap.length; Cp += 1) {
                  var ay = Ap[Cp];
                  Ma && XO(vr, Ma.text, Op, ay) || fu(oy, ay);
                }
            else if (Cl === "line-center")
              for (var Pp = 0, kp = Xr.geometry; Pp < kp.length; Pp += 1) {
                var Lp = kp[Pp];
                if (Lp.length > 1) {
                  var sy = $O(Lp, Ip, qr.vertical || Ma, Or, 24, $h);
                  sy && fu(Lp, sy);
                }
              }
            else if (Xr.type === "Polygon")
              for (var Xh = 0, ly = i_(Xr.geometry, 0); Xh < ly.length; Xh += 1) {
                var Kh = ly[Xh], Dp = HO(Kh, 16);
                fu(Kh[0], new Rh(Dp.x, Dp.y, 0));
              }
            else if (Xr.type === "LineString")
              for (var wc = 0, Np = Xr.geometry; wc < Np.length; wc += 1) {
                var Yh = Np[wc];
                fu(Yh, new Rh(Yh[0].x, Yh[0].y, 0));
              }
            else if (Xr.type === "Point")
              for (var v_ = 0, lb = Xr.geometry; v_ < lb.length; v_ += 1)
                for (var __ = 0, ub = lb[v_]; __ < ub.length; __ += 1) {
                  var x_ = ub[__];
                  fu([x_], new Rh(x_.x, x_.y, 0));
                }
          }(r, Oe, dt, _i, p, A, ot, At, yt, Hi, x);
        }, we = 0, Te = r.features; we < Te.length; we += 1)
          ge();
        v && r.generateCollisionDebugBuffers();
      }, a.perspective = function(r, i, l, p, y) {
        var v, x = 1 / Math.tan(i / 2);
        return r[0] = x / l, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = x, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, y != null && y !== 1 / 0 ? (r[10] = (y + p) * (v = 1 / (p - y)), r[14] = 2 * y * p * v) : (r[10] = -1, r[14] = -2 * p), r;
      }, a.pick = function(r, i) {
        for (var l = {}, p = 0; p < i.length; p++) {
          var y = i[p];
          y in r && (l[y] = r[y]);
        }
        return l;
      }, a.plugin = Io, a.polygonIntersectsPolygon = Os, a.postMapLoadEvent = Jr, a.postTurnstileEvent = Vr, a.potpack = Px, a.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], a.register = wt, a.registerForPluginStateChange = function(r) {
        return r({ pluginStatus: fo, pluginURL: ja }), lp.on("pluginStateChange", r), r;
      }, a.renderColorRamp = fx, a.rotate = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3], S = Math.sin(l), C = Math.cos(l);
        return r[0] = p * C + v * S, r[1] = y * C + x * S, r[2] = p * -S + v * C, r[3] = y * -S + x * C, r;
      }, a.rotateX = function(r, i, l) {
        var p = Math.sin(l), y = Math.cos(l), v = i[4], x = i[5], S = i[6], C = i[7], A = i[8], L = i[9], D = i[10], B = i[11];
        return i !== r && (r[0] = i[0], r[1] = i[1], r[2] = i[2], r[3] = i[3], r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15]), r[4] = v * y + A * p, r[5] = x * y + L * p, r[6] = S * y + D * p, r[7] = C * y + B * p, r[8] = A * y - v * p, r[9] = L * y - x * p, r[10] = D * y - S * p, r[11] = B * y - C * p, r;
      }, a.rotateZ = function(r, i, l) {
        var p = Math.sin(l), y = Math.cos(l), v = i[0], x = i[1], S = i[2], C = i[3], A = i[4], L = i[5], D = i[6], B = i[7];
        return i !== r && (r[8] = i[8], r[9] = i[9], r[10] = i[10], r[11] = i[11], r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15]), r[0] = v * y + A * p, r[1] = x * y + L * p, r[2] = S * y + D * p, r[3] = C * y + B * p, r[4] = A * y - v * p, r[5] = L * y - x * p, r[6] = D * y - S * p, r[7] = B * y - C * p, r;
      }, a.scale = function(r, i, l) {
        var p = l[0], y = l[1], v = l[2];
        return r[0] = i[0] * p, r[1] = i[1] * p, r[2] = i[2] * p, r[3] = i[3] * p, r[4] = i[4] * y, r[5] = i[5] * y, r[6] = i[6] * y, r[7] = i[7] * y, r[8] = i[8] * v, r[9] = i[9] * v, r[10] = i[10] * v, r[11] = i[11] * v, r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15], r;
      }, a.scale$1 = function(r, i, l) {
        return r[0] = i[0] * l, r[1] = i[1] * l, r[2] = i[2] * l, r[3] = i[3] * l, r;
      }, a.scale$2 = function(r, i, l) {
        return r[0] = i[0] * l, r[1] = i[1] * l, r[2] = i[2] * l, r;
      }, a.setCacheLimits = function(r, i) {
        Xn = r, Bi = i;
      }, a.setRTLTextPlugin = function(r, i, l) {
        if (l === void 0 && (l = !1), fo === "deferred" || fo === "loading" || fo === "loaded")
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        ja = Vn.resolveURL(r), fo = "deferred", wh = i, uc(), l || sa();
      }, a.sphericalToCartesian = function(r) {
        var i = r[0], l = r[1], p = r[2];
        return l += 90, l *= Math.PI / 180, p *= Math.PI / 180, { x: i * Math.cos(l) * Math.sin(p), y: i * Math.sin(l) * Math.sin(p), z: i * Math.cos(p) };
      }, a.sqrLen = function(r) {
        var i = r[0], l = r[1];
        return i * i + l * l;
      }, a.styleSpec = G, a.sub = function(r, i, l) {
        return r[0] = i[0] - l[0], r[1] = i[1] - l[1], r[2] = i[2] - l[2], r;
      }, a.symbolSize = GO, a.transformMat3 = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2];
        return r[0] = p * l[0] + y * l[3] + v * l[6], r[1] = p * l[1] + y * l[4] + v * l[7], r[2] = p * l[2] + y * l[5] + v * l[8], r;
      }, a.transformMat4 = Oh, a.translate = function(r, i, l) {
        var p, y, v, x, S, C, A, L, D, B, j, J, ee = l[0], he = l[1], oe = l[2];
        return i === r ? (r[12] = i[0] * ee + i[4] * he + i[8] * oe + i[12], r[13] = i[1] * ee + i[5] * he + i[9] * oe + i[13], r[14] = i[2] * ee + i[6] * he + i[10] * oe + i[14], r[15] = i[3] * ee + i[7] * he + i[11] * oe + i[15]) : (y = i[1], v = i[2], x = i[3], S = i[4], C = i[5], A = i[6], L = i[7], D = i[8], B = i[9], j = i[10], J = i[11], r[0] = p = i[0], r[1] = y, r[2] = v, r[3] = x, r[4] = S, r[5] = C, r[6] = A, r[7] = L, r[8] = D, r[9] = B, r[10] = j, r[11] = J, r[12] = p * ee + S * he + D * oe + i[12], r[13] = y * ee + C * he + B * oe + i[13], r[14] = v * ee + A * he + j * oe + i[14], r[15] = x * ee + L * he + J * oe + i[15]), r;
      }, a.triggerPluginCompletionEvent = Nm, a.uniqueId = ce, a.validateCustomStyleLayer = function(r) {
        var i = [], l = r.id;
        return l === void 0 && i.push({ message: "layers." + l + ': missing required property "id"' }), r.render === void 0 && i.push({ message: "layers." + l + ': missing required method "render"' }), r.renderingMode && r.renderingMode !== "2d" && r.renderingMode !== "3d" && i.push({ message: "layers." + l + ': property "renderingMode" must be either "2d" or "3d"' }), i;
      }, a.validateLight = Xv, a.validateStyle = oc, a.values = function(r) {
        var i = [];
        for (var l in r)
          i.push(r[l]);
        return i;
      }, a.vectorTile = kh, a.version = "1.13.3", a.warnOnce = at, a.webpSupported = Sn, a.window = I, a.wrap = re;
    }), h(["./shared"], function(a) {
      function m(N) {
        var F = typeof N;
        if (F === "number" || F === "boolean" || F === "string" || N == null)
          return JSON.stringify(N);
        if (Array.isArray(N)) {
          for (var U = "[", Z = 0, Q = N; Z < Q.length; Z += 1)
            U += m(Q[Z]) + ",";
          return U + "]";
        }
        for (var pe = Object.keys(N).sort(), de = "{", G = 0; G < pe.length; G++)
          de += JSON.stringify(pe[G]) + ":" + m(N[pe[G]]) + ",";
        return de + "}";
      }
      function g(N) {
        for (var F = "", U = 0, Z = a.refProperties; U < Z.length; U += 1)
          F += "/" + m(N[Z[U]]);
        return F;
      }
      var b = function(N) {
        this.keyCache = {}, N && this.replace(N);
      };
      b.prototype.replace = function(N) {
        this._layerConfigs = {}, this._layers = {}, this.update(N, []);
      }, b.prototype.update = function(N, F) {
        for (var U = this, Z = 0, Q = N; Z < Q.length; Z += 1) {
          var pe = Q[Z];
          this._layerConfigs[pe.id] = pe;
          var de = this._layers[pe.id] = a.createStyleLayer(pe);
          de._featureFilter = a.featureFilter(de.filter), this.keyCache[pe.id] && delete this.keyCache[pe.id];
        }
        for (var G = 0, ie = F; G < ie.length; G += 1) {
          var _e = ie[G];
          delete this.keyCache[_e], delete this._layerConfigs[_e], delete this._layers[_e];
        }
        this.familiesBySource = {};
        for (var Ge = 0, Ze = function(st, De) {
          for (var fe = {}, Ee = 0; Ee < st.length; Ee++) {
            var He = De && De[st[Ee].id] || g(st[Ee]);
            De && (De[st[Ee].id] = He);
            var jt = fe[He];
            jt || (jt = fe[He] = []), jt.push(st[Ee]);
          }
          var Wt = [];
          for (var Jt in fe)
            Wt.push(fe[Jt]);
          return Wt;
        }(a.values(this._layerConfigs), this.keyCache); Ge < Ze.length; Ge += 1) {
          var Ce = Ze[Ge].map(function(st) {
            return U._layers[st.id];
          }), Ue = Ce[0];
          if (Ue.visibility !== "none") {
            var Et = Ue.source || "", _t = this.familiesBySource[Et];
            _t || (_t = this.familiesBySource[Et] = {});
            var Le = Ue.sourceLayer || "_geojsonTileLayer", pt = _t[Le];
            pt || (pt = _t[Le] = []), pt.push(Ce);
          }
        }
      };
      var T = function(N) {
        var F = {}, U = [];
        for (var Z in N) {
          var Q = N[Z], pe = F[Z] = {};
          for (var de in Q) {
            var G = Q[+de];
            if (G && G.bitmap.width !== 0 && G.bitmap.height !== 0) {
              var ie = { x: 0, y: 0, w: G.bitmap.width + 2, h: G.bitmap.height + 2 };
              U.push(ie), pe[de] = { rect: ie, metrics: G.metrics };
            }
          }
        }
        var _e = a.potpack(U), Ge = new a.AlphaImage({ width: _e.w || 1, height: _e.h || 1 });
        for (var Ze in N) {
          var Ce = N[Ze];
          for (var Ue in Ce) {
            var Et = Ce[+Ue];
            if (Et && Et.bitmap.width !== 0 && Et.bitmap.height !== 0) {
              var _t = F[Ze][Ue].rect;
              a.AlphaImage.copy(Et.bitmap, Ge, { x: 0, y: 0 }, { x: _t.x + 1, y: _t.y + 1 }, Et.bitmap);
            }
          }
        }
        this.image = Ge, this.positions = F;
      };
      a.register("GlyphAtlas", T);
      var M = function(N) {
        this.tileID = new a.OverscaledTileID(N.tileID.overscaledZ, N.tileID.wrap, N.tileID.canonical.z, N.tileID.canonical.x, N.tileID.canonical.y), this.uid = N.uid, this.zoom = N.zoom, this.pixelRatio = N.pixelRatio, this.tileSize = N.tileSize, this.source = N.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = N.showCollisionBoxes, this.collectResourceTiming = !!N.collectResourceTiming, this.returnDependencies = !!N.returnDependencies, this.promoteId = N.promoteId;
      };
      function I(N, F, U) {
        for (var Z = new a.EvaluationParameters(F), Q = 0, pe = N; Q < pe.length; Q += 1)
          pe[Q].recalculate(Z, U);
      }
      function P(N, F) {
        var U = a.getArrayBuffer(N.request, function(Z, Q, pe, de) {
          Z ? F(Z) : Q && F(null, { vectorTile: new a.vectorTile.VectorTile(new a.pbf(Q)), rawData: Q, cacheControl: pe, expires: de });
        });
        return function() {
          U.cancel(), F();
        };
      }
      M.prototype.parse = function(N, F, U, Z, Q) {
        var pe = this;
        this.status = "parsing", this.data = N, this.collisionBoxArray = new a.CollisionBoxArray();
        var de = new a.DictionaryCoder(Object.keys(N.layers).sort()), G = new a.FeatureIndex(this.tileID, this.promoteId);
        G.bucketLayerIDs = [];
        var ie, _e, Ge, Ze, Ce = {}, Ue = { featureIndex: G, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: U }, Et = F.familiesBySource[this.source];
        for (var _t in Et) {
          var Le = N.layers[_t];
          if (Le) {
            Le.version === 1 && a.warnOnce('Vector tile source "' + this.source + '" layer "' + _t + '" does not use vector tile spec v2 and therefore may have some rendering errors.');
            for (var pt = de.encode(_t), st = [], De = 0; De < Le.length; De++) {
              var fe = Le.feature(De), Ee = G.getId(fe, _t);
              st.push({ feature: fe, id: Ee, index: De, sourceLayerIndex: pt });
            }
            for (var He = 0, jt = Et[_t]; He < jt.length; He += 1) {
              var Wt = jt[He], Jt = Wt[0];
              Jt.minzoom && this.zoom < Math.floor(Jt.minzoom) || Jt.maxzoom && this.zoom >= Jt.maxzoom || Jt.visibility !== "none" && (I(Wt, this.zoom, U), (Ce[Jt.id] = Jt.createBucket({ index: G.bucketLayerIDs.length, layers: Wt, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: pt, sourceID: this.source })).populate(st, Ue, this.tileID.canonical), G.bucketLayerIDs.push(Wt.map(function(Ur) {
                return Ur.id;
              })));
            }
          }
        }
        var Zt = a.mapObject(Ue.glyphDependencies, function(Ur) {
          return Object.keys(Ur).map(Number);
        });
        Object.keys(Zt).length ? Z.send("getGlyphs", { uid: this.uid, stacks: Zt }, function(Ur, gr) {
          ie || (ie = Ur, _e = gr, pn.call(pe));
        }) : _e = {};
        var Yn = Object.keys(Ue.iconDependencies);
        Yn.length ? Z.send("getImages", { icons: Yn, source: this.source, tileID: this.tileID, type: "icons" }, function(Ur, gr) {
          ie || (ie = Ur, Ge = gr, pn.call(pe));
        }) : Ge = {};
        var Qt = Object.keys(Ue.patternDependencies);
        function pn() {
          if (ie)
            return Q(ie);
          if (_e && Ge && Ze) {
            var Ur = new T(_e), gr = new a.ImageAtlas(Ge, Ze);
            for (var Fr in Ce) {
              var Yi = Ce[Fr];
              Yi instanceof a.SymbolBucket ? (I(Yi.layers, this.zoom, U), a.performSymbolLayout(Yi, _e, Ur.positions, Ge, gr.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : Yi.hasPattern && (Yi instanceof a.LineBucket || Yi instanceof a.FillBucket || Yi instanceof a.FillExtrusionBucket) && (I(Yi.layers, this.zoom, U), Yi.addFeatures(Ue, this.tileID.canonical, gr.patternPositions));
            }
            this.status = "done", Q(null, { buckets: a.values(Ce).filter(function(Hu) {
              return !Hu.isEmpty();
            }), featureIndex: G, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Ur.image, imageAtlas: gr, glyphMap: this.returnDependencies ? _e : null, iconMap: this.returnDependencies ? Ge : null, glyphPositions: this.returnDependencies ? Ur.positions : null });
          }
        }
        Qt.length ? Z.send("getImages", { icons: Qt, source: this.source, tileID: this.tileID, type: "patterns" }, function(Ur, gr) {
          ie || (ie = Ur, Ze = gr, pn.call(pe));
        }) : Ze = {}, pn.call(this);
      };
      var z = function(N, F, U, Z) {
        this.actor = N, this.layerIndex = F, this.availableImages = U, this.loadVectorData = Z || P, this.loading = {}, this.loaded = {};
      };
      z.prototype.loadTile = function(N, F) {
        var U = this, Z = N.uid;
        this.loading || (this.loading = {});
        var Q = !!(N && N.request && N.request.collectResourceTiming) && new a.RequestPerformance(N.request), pe = this.loading[Z] = new M(N);
        pe.abort = this.loadVectorData(N, function(de, G) {
          if (delete U.loading[Z], de || !G)
            return pe.status = "done", U.loaded[Z] = pe, F(de);
          var ie = G.rawData, _e = {};
          G.expires && (_e.expires = G.expires), G.cacheControl && (_e.cacheControl = G.cacheControl);
          var Ge = {};
          if (Q) {
            var Ze = Q.finish();
            Ze && (Ge.resourceTiming = JSON.parse(JSON.stringify(Ze)));
          }
          pe.vectorTile = G.vectorTile, pe.parse(G.vectorTile, U.layerIndex, U.availableImages, U.actor, function(Ce, Ue) {
            if (Ce || !Ue)
              return F(Ce);
            F(null, a.extend({ rawTileData: ie.slice(0) }, Ue, _e, Ge));
          }), U.loaded = U.loaded || {}, U.loaded[Z] = pe;
        });
      }, z.prototype.reloadTile = function(N, F) {
        var U = this, Z = this.loaded, Q = N.uid, pe = this;
        if (Z && Z[Q]) {
          var de = Z[Q];
          de.showCollisionBoxes = N.showCollisionBoxes;
          var G = function(ie, _e) {
            var Ge = de.reloadCallback;
            Ge && (delete de.reloadCallback, de.parse(de.vectorTile, pe.layerIndex, U.availableImages, pe.actor, Ge)), F(ie, _e);
          };
          de.status === "parsing" ? de.reloadCallback = G : de.status === "done" && (de.vectorTile ? de.parse(de.vectorTile, this.layerIndex, this.availableImages, this.actor, G) : G());
        }
      }, z.prototype.abortTile = function(N, F) {
        var U = this.loading, Z = N.uid;
        U && U[Z] && U[Z].abort && (U[Z].abort(), delete U[Z]), F();
      }, z.prototype.removeTile = function(N, F) {
        var U = this.loaded, Z = N.uid;
        U && U[Z] && delete U[Z], F();
      };
      var V = a.window.ImageBitmap, q = function() {
        this.loaded = {};
      };
      function re(N, F) {
        if (N.length !== 0) {
          X(N[0], F);
          for (var U = 1; U < N.length; U++)
            X(N[U], !F);
        }
      }
      function X(N, F) {
        for (var U = 0, Z = 0, Q = 0, pe = N.length, de = pe - 1; Q < pe; de = Q++) {
          var G = (N[Q][0] - N[de][0]) * (N[de][1] + N[Q][1]), ie = U + G;
          Z += Math.abs(U) >= Math.abs(G) ? U - ie + G : G - ie + U, U = ie;
        }
        U + Z >= 0 != !!F && N.reverse();
      }
      q.prototype.loadTile = function(N, F) {
        var U = N.uid, Z = N.encoding, Q = N.rawImageData, pe = V && Q instanceof V ? this.getImageData(Q) : Q, de = new a.DEMData(U, pe, Z);
        this.loaded = this.loaded || {}, this.loaded[U] = de, F(null, de);
      }, q.prototype.getImageData = function(N) {
        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(N.width, N.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = N.width, this.offscreenCanvas.height = N.height, this.offscreenCanvasContext.drawImage(N, 0, 0, N.width, N.height);
        var F = this.offscreenCanvasContext.getImageData(-1, -1, N.width + 2, N.height + 2);
        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new a.RGBAImage({ width: F.width, height: F.height }, F.data);
      }, q.prototype.removeTile = function(N) {
        var F = this.loaded, U = N.uid;
        F && F[U] && delete F[U];
      };
      var ae = a.vectorTile.VectorTileFeature.prototype.toGeoJSON, ce = function(N) {
        this._feature = N, this.extent = a.EXTENT, this.type = N.type, this.properties = N.tags, "id" in N && !isNaN(N.id) && (this.id = parseInt(N.id, 10));
      };
      ce.prototype.loadGeometry = function() {
        if (this._feature.type === 1) {
          for (var N = [], F = 0, U = this._feature.geometry; F < U.length; F += 1) {
            var Z = U[F];
            N.push([new a.Point$1(Z[0], Z[1])]);
          }
          return N;
        }
        for (var Q = [], pe = 0, de = this._feature.geometry; pe < de.length; pe += 1) {
          for (var G = [], ie = 0, _e = de[pe]; ie < _e.length; ie += 1) {
            var Ge = _e[ie];
            G.push(new a.Point$1(Ge[0], Ge[1]));
          }
          Q.push(G);
        }
        return Q;
      }, ce.prototype.toGeoJSON = function(N, F, U) {
        return ae.call(this, N, F, U);
      };
      var ve = function(N) {
        this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = a.EXTENT, this.length = N.length, this._features = N;
      };
      ve.prototype.feature = function(N) {
        return new ce(this._features[N]);
      };
      var Re = a.vectorTile.VectorTileFeature, Fe = Pe;
      function Pe(N, F) {
        this.options = F || {}, this.features = N, this.length = N.length;
      }
      function Se(N, F) {
        this.id = typeof N.id == "number" ? N.id : void 0, this.type = N.type, this.rawGeometry = N.type === 1 ? [N.geometry] : N.geometry, this.properties = N.tags, this.extent = F || 4096;
      }
      Pe.prototype.feature = function(N) {
        return new Se(this.features[N], this.options.extent);
      }, Se.prototype.loadGeometry = function() {
        var N = this.rawGeometry;
        this.geometry = [];
        for (var F = 0; F < N.length; F++) {
          for (var U = N[F], Z = [], Q = 0; Q < U.length; Q++)
            Z.push(new a.Point$1(U[Q][0], U[Q][1]));
          this.geometry.push(Z);
        }
        return this.geometry;
      }, Se.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var N = this.geometry, F = 1 / 0, U = -1 / 0, Z = 1 / 0, Q = -1 / 0, pe = 0; pe < N.length; pe++)
          for (var de = N[pe], G = 0; G < de.length; G++) {
            var ie = de[G];
            F = Math.min(F, ie.x), U = Math.max(U, ie.x), Z = Math.min(Z, ie.y), Q = Math.max(Q, ie.y);
          }
        return [F, Z, U, Q];
      }, Se.prototype.toGeoJSON = Re.prototype.toGeoJSON;
      var Ie = $e, Xe = Fe;
      function $e(N) {
        var F = new a.pbf();
        return function(U, Z) {
          for (var Q in U.layers)
            Z.writeMessage(3, at, U.layers[Q]);
        }(N, F), F.finish();
      }
      function at(N, F) {
        var U;
        F.writeVarintField(15, N.version || 1), F.writeStringField(1, N.name || ""), F.writeVarintField(5, N.extent || 4096);
        var Z = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (U = 0; U < N.length; U++)
          Z.feature = N.feature(U), F.writeMessage(2, be, Z);
        var Q = Z.keys;
        for (U = 0; U < Q.length; U++)
          F.writeStringField(3, Q[U]);
        var pe = Z.values;
        for (U = 0; U < pe.length; U++)
          F.writeMessage(4, tr, pe[U]);
      }
      function be(N, F) {
        var U = N.feature;
        U.id !== void 0 && F.writeVarintField(1, U.id), F.writeMessage(2, Ye, N), F.writeVarintField(3, U.type), F.writeMessage(4, Pt, U);
      }
      function Ye(N, F) {
        var U = N.feature, Z = N.keys, Q = N.values, pe = N.keycache, de = N.valuecache;
        for (var G in U.properties) {
          var ie = pe[G];
          ie === void 0 && (Z.push(G), pe[G] = ie = Z.length - 1), F.writeVarint(ie);
          var _e = U.properties[G], Ge = typeof _e;
          Ge !== "string" && Ge !== "boolean" && Ge !== "number" && (_e = JSON.stringify(_e));
          var Ze = Ge + ":" + _e, Ce = de[Ze];
          Ce === void 0 && (Q.push(_e), de[Ze] = Ce = Q.length - 1), F.writeVarint(Ce);
        }
      }
      function ht(N, F) {
        return (F << 3) + (7 & N);
      }
      function vt(N) {
        return N << 1 ^ N >> 31;
      }
      function Pt(N, F) {
        for (var U = N.loadGeometry(), Z = N.type, Q = 0, pe = 0, de = U.length, G = 0; G < de; G++) {
          var ie = U[G], _e = 1;
          Z === 1 && (_e = ie.length), F.writeVarint(ht(1, _e));
          for (var Ge = Z === 3 ? ie.length - 1 : ie.length, Ze = 0; Ze < Ge; Ze++) {
            Ze === 1 && Z !== 1 && F.writeVarint(ht(2, Ge - 1));
            var Ce = ie[Ze].x - Q, Ue = ie[Ze].y - pe;
            F.writeVarint(vt(Ce)), F.writeVarint(vt(Ue)), Q += Ce, pe += Ue;
          }
          Z === 3 && F.writeVarint(ht(7, 1));
        }
      }
      function tr(N, F) {
        var U = typeof N;
        U === "string" ? F.writeStringField(1, N) : U === "boolean" ? F.writeBooleanField(7, N) : U === "number" && (N % 1 != 0 ? F.writeDoubleField(3, N) : N < 0 ? F.writeSVarintField(6, N) : F.writeVarintField(5, N));
      }
      function kn(N, F, U, Z) {
        Rr(N, U, Z), Rr(F, 2 * U, 2 * Z), Rr(F, 2 * U + 1, 2 * Z + 1);
      }
      function Rr(N, F, U) {
        var Z = N[F];
        N[F] = N[U], N[U] = Z;
      }
      function pr(N, F, U, Z) {
        var Q = N - U, pe = F - Z;
        return Q * Q + pe * pe;
      }
      Ie.fromVectorTileJs = $e, Ie.fromGeojsonVt = function(N, F) {
        F = F || {};
        var U = {};
        for (var Z in N)
          U[Z] = new Fe(N[Z].features, F), U[Z].name = Z, U[Z].version = F.version, U[Z].extent = F.extent;
        return $e({ layers: U });
      }, Ie.GeoJSONWrapper = Xe;
      var Zn = function(N) {
        return N[0];
      }, zr = function(N) {
        return N[1];
      }, Fi = function(N, F, U, Z, Q) {
        F === void 0 && (F = Zn), U === void 0 && (U = zr), Z === void 0 && (Z = 64), Q === void 0 && (Q = Float64Array), this.nodeSize = Z, this.points = N;
        for (var pe = N.length < 65536 ? Uint16Array : Uint32Array, de = this.ids = new pe(N.length), G = this.coords = new Q(2 * N.length), ie = 0; ie < N.length; ie++)
          de[ie] = ie, G[2 * ie] = F(N[ie]), G[2 * ie + 1] = U(N[ie]);
        (function _e(Ge, Ze, Ce, Ue, Et, _t) {
          if (!(Et - Ue <= Ce)) {
            var Le = Ue + Et >> 1;
            (function pt(st, De, fe, Ee, He, jt) {
              for (; He > Ee; ) {
                if (He - Ee > 600) {
                  var Wt = He - Ee + 1, Jt = fe - Ee + 1, Zt = Math.log(Wt), Yn = 0.5 * Math.exp(2 * Zt / 3), Qt = 0.5 * Math.sqrt(Zt * Yn * (Wt - Yn) / Wt) * (Jt - Wt / 2 < 0 ? -1 : 1);
                  pt(st, De, fe, Math.max(Ee, Math.floor(fe - Jt * Yn / Wt + Qt)), Math.min(He, Math.floor(fe + (Wt - Jt) * Yn / Wt + Qt)), jt);
                }
                var pn = De[2 * fe + jt], Ur = Ee, gr = He;
                for (kn(st, De, Ee, fe), De[2 * He + jt] > pn && kn(st, De, Ee, He); Ur < gr; ) {
                  for (kn(st, De, Ur, gr), Ur++, gr--; De[2 * Ur + jt] < pn; )
                    Ur++;
                  for (; De[2 * gr + jt] > pn; )
                    gr--;
                }
                De[2 * Ee + jt] === pn ? kn(st, De, Ee, gr) : kn(st, De, ++gr, He), gr <= fe && (Ee = gr + 1), fe <= gr && (He = gr - 1);
              }
            })(Ge, Ze, Le, Ue, Et, _t % 2), _e(Ge, Ze, Ce, Ue, Le - 1, _t + 1), _e(Ge, Ze, Ce, Le + 1, Et, _t + 1);
          }
        })(de, G, Z, 0, de.length - 1, 0);
      };
      Fi.prototype.range = function(N, F, U, Z) {
        return function(Q, pe, de, G, ie, _e, Ge) {
          for (var Ze, Ce, Ue = [0, Q.length - 1, 0], Et = []; Ue.length; ) {
            var _t = Ue.pop(), Le = Ue.pop(), pt = Ue.pop();
            if (Le - pt <= Ge)
              for (var st = pt; st <= Le; st++)
                Ce = pe[2 * st + 1], (Ze = pe[2 * st]) >= de && Ze <= ie && Ce >= G && Ce <= _e && Et.push(Q[st]);
            else {
              var De = Math.floor((pt + Le) / 2);
              Ce = pe[2 * De + 1], (Ze = pe[2 * De]) >= de && Ze <= ie && Ce >= G && Ce <= _e && Et.push(Q[De]);
              var fe = (_t + 1) % 2;
              (_t === 0 ? de <= Ze : G <= Ce) && (Ue.push(pt), Ue.push(De - 1), Ue.push(fe)), (_t === 0 ? ie >= Ze : _e >= Ce) && (Ue.push(De + 1), Ue.push(Le), Ue.push(fe));
            }
          }
          return Et;
        }(this.ids, this.coords, N, F, U, Z, this.nodeSize);
      }, Fi.prototype.within = function(N, F, U) {
        return function(Z, Q, pe, de, G, ie) {
          for (var _e = [0, Z.length - 1, 0], Ge = [], Ze = G * G; _e.length; ) {
            var Ce = _e.pop(), Ue = _e.pop(), Et = _e.pop();
            if (Ue - Et <= ie)
              for (var _t = Et; _t <= Ue; _t++)
                pr(Q[2 * _t], Q[2 * _t + 1], pe, de) <= Ze && Ge.push(Z[_t]);
            else {
              var Le = Math.floor((Et + Ue) / 2), pt = Q[2 * Le], st = Q[2 * Le + 1];
              pr(pt, st, pe, de) <= Ze && Ge.push(Z[Le]);
              var De = (Ce + 1) % 2;
              (Ce === 0 ? pe - G <= pt : de - G <= st) && (_e.push(Et), _e.push(Le - 1), _e.push(De)), (Ce === 0 ? pe + G >= pt : de + G >= st) && (_e.push(Le + 1), _e.push(Ue), _e.push(De));
            }
          }
          return Ge;
        }(this.ids, this.coords, N, F, U, this.nodeSize);
      };
      var $r = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: function(N) {
        return N;
      } }, kr = function(N) {
        this.options = ye(Object.create($r), N), this.trees = new Array(this.options.maxZoom + 1);
      };
      function Vn(N, F, U, Z, Q) {
        return { x: N, y: F, zoom: 1 / 0, id: U, parentId: -1, numPoints: Z, properties: Q };
      }
      function Tr(N, F) {
        var U = N.geometry.coordinates, Z = U[1];
        return { x: Un(U[0]), y: K(Z), zoom: 1 / 0, index: F, parentId: -1 };
      }
      function Sn(N) {
        return { type: "Feature", id: N.id, properties: oi(N), geometry: { type: "Point", coordinates: [(Z = N.x, 360 * (Z - 0.5)), (F = N.y, U = (180 - 360 * F) * Math.PI / 180, 360 * Math.atan(Math.exp(U)) / Math.PI - 90)] } };
        var F, U, Z;
      }
      function oi(N) {
        var F = N.numPoints, U = F >= 1e4 ? Math.round(F / 1e3) + "k" : F >= 1e3 ? Math.round(F / 100) / 10 + "k" : F;
        return ye(ye({}, N.properties), { cluster: !0, cluster_id: N.id, point_count: F, point_count_abbreviated: U });
      }
      function Un(N) {
        return N / 360 + 0.5;
      }
      function K(N) {
        var F = Math.sin(N * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + F) / (1 - F)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function ye(N, F) {
        for (var U in F)
          N[U] = F[U];
        return N;
      }
      function Ne(N) {
        return N.x;
      }
      function qe(N) {
        return N.y;
      }
      function We(N, F, U, Z, Q, pe) {
        var de = Q - U, G = pe - Z;
        if (de !== 0 || G !== 0) {
          var ie = ((N - U) * de + (F - Z) * G) / (de * de + G * G);
          ie > 1 ? (U = Q, Z = pe) : ie > 0 && (U += de * ie, Z += G * ie);
        }
        return (de = N - U) * de + (G = F - Z) * G;
      }
      function rt(N, F, U, Z) {
        var Q = { id: N === void 0 ? null : N, type: F, geometry: U, tags: Z, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(pe) {
          var de = pe.geometry, G = pe.type;
          if (G === "Point" || G === "MultiPoint" || G === "LineString")
            mt(pe, de);
          else if (G === "Polygon" || G === "MultiLineString")
            for (var ie = 0; ie < de.length; ie++)
              mt(pe, de[ie]);
          else if (G === "MultiPolygon")
            for (ie = 0; ie < de.length; ie++)
              for (var _e = 0; _e < de[ie].length; _e++)
                mt(pe, de[ie][_e]);
        }(Q), Q;
      }
      function mt(N, F) {
        for (var U = 0; U < F.length; U += 3)
          N.minX = Math.min(N.minX, F[U]), N.minY = Math.min(N.minY, F[U + 1]), N.maxX = Math.max(N.maxX, F[U]), N.maxY = Math.max(N.maxY, F[U + 1]);
      }
      function et(N, F, U, Z) {
        if (F.geometry) {
          var Q = F.geometry.coordinates, pe = F.geometry.type, de = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2), G = [], ie = F.id;
          if (U.promoteId ? ie = F.properties[U.promoteId] : U.generateId && (ie = Z || 0), pe === "Point")
            ut(Q, G);
          else if (pe === "MultiPoint")
            for (var _e = 0; _e < Q.length; _e++)
              ut(Q[_e], G);
          else if (pe === "LineString")
            Qe(Q, G, de, !1);
          else if (pe === "MultiLineString") {
            if (U.lineMetrics) {
              for (_e = 0; _e < Q.length; _e++)
                Qe(Q[_e], G = [], de, !1), N.push(rt(ie, "LineString", G, F.properties));
              return;
            }
            It(Q, G, de, !1);
          } else if (pe === "Polygon")
            It(Q, G, de, !0);
          else {
            if (pe !== "MultiPolygon") {
              if (pe === "GeometryCollection") {
                for (_e = 0; _e < F.geometry.geometries.length; _e++)
                  et(N, { id: ie, geometry: F.geometry.geometries[_e], properties: F.properties }, U, Z);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (_e = 0; _e < Q.length; _e++) {
              var Ge = [];
              It(Q[_e], Ge, de, !0), G.push(Ge);
            }
          }
          N.push(rt(ie, pe, G, F.properties));
        }
      }
      function ut(N, F) {
        F.push(bt(N[0])), F.push(kt(N[1])), F.push(0);
      }
      function Qe(N, F, U, Z) {
        for (var Q, pe, de = 0, G = 0; G < N.length; G++) {
          var ie = bt(N[G][0]), _e = kt(N[G][1]);
          F.push(ie), F.push(_e), F.push(0), G > 0 && (de += Z ? (Q * _e - ie * pe) / 2 : Math.sqrt(Math.pow(ie - Q, 2) + Math.pow(_e - pe, 2))), Q = ie, pe = _e;
        }
        var Ge = F.length - 3;
        F[2] = 1, function Ze(Ce, Ue, Et, _t) {
          for (var Le, pt = _t, st = Et - Ue >> 1, De = Et - Ue, fe = Ce[Ue], Ee = Ce[Ue + 1], He = Ce[Et], jt = Ce[Et + 1], Wt = Ue + 3; Wt < Et; Wt += 3) {
            var Jt = We(Ce[Wt], Ce[Wt + 1], fe, Ee, He, jt);
            if (Jt > pt)
              Le = Wt, pt = Jt;
            else if (Jt === pt) {
              var Zt = Math.abs(Wt - st);
              Zt < De && (Le = Wt, De = Zt);
            }
          }
          pt > _t && (Le - Ue > 3 && Ze(Ce, Ue, Le, _t), Ce[Le + 2] = pt, Et - Le > 3 && Ze(Ce, Le, Et, _t));
        }(F, 0, Ge, U), F[Ge + 2] = 1, F.size = Math.abs(de), F.start = 0, F.end = F.size;
      }
      function It(N, F, U, Z) {
        for (var Q = 0; Q < N.length; Q++) {
          var pe = [];
          Qe(N[Q], pe, U, Z), F.push(pe);
        }
      }
      function bt(N) {
        return N / 360 + 0.5;
      }
      function kt(N) {
        var F = Math.sin(N * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + F) / (1 - F)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function Ut(N, F, U, Z, Q, pe, de, G) {
        if (Z /= F, pe >= (U /= F) && de < Z)
          return N;
        if (de < U || pe >= Z)
          return null;
        for (var ie = [], _e = 0; _e < N.length; _e++) {
          var Ge = N[_e], Ze = Ge.geometry, Ce = Ge.type, Ue = Q === 0 ? Ge.minX : Ge.minY, Et = Q === 0 ? Ge.maxX : Ge.maxY;
          if (Ue >= U && Et < Z)
            ie.push(Ge);
          else if (!(Et < U || Ue >= Z)) {
            var _t = [];
            if (Ce === "Point" || Ce === "MultiPoint")
              dr(Ze, _t, U, Z, Q);
            else if (Ce === "LineString")
              Vr(Ze, _t, U, Z, Q, !1, G.lineMetrics);
            else if (Ce === "MultiLineString")
              Jr(Ze, _t, U, Z, Q, !1);
            else if (Ce === "Polygon")
              Jr(Ze, _t, U, Z, Q, !0);
            else if (Ce === "MultiPolygon")
              for (var Le = 0; Le < Ze.length; Le++) {
                var pt = [];
                Jr(Ze[Le], pt, U, Z, Q, !0), pt.length && _t.push(pt);
              }
            if (_t.length) {
              if (G.lineMetrics && Ce === "LineString") {
                for (Le = 0; Le < _t.length; Le++)
                  ie.push(rt(Ge.id, Ce, _t[Le], Ge.tags));
                continue;
              }
              Ce !== "LineString" && Ce !== "MultiLineString" || (_t.length === 1 ? (Ce = "LineString", _t = _t[0]) : Ce = "MultiLineString"), Ce !== "Point" && Ce !== "MultiPoint" || (Ce = _t.length === 3 ? "Point" : "MultiPoint"), ie.push(rt(Ge.id, Ce, _t, Ge.tags));
            }
          }
        }
        return ie.length ? ie : null;
      }
      function dr(N, F, U, Z, Q) {
        for (var pe = 0; pe < N.length; pe += 3) {
          var de = N[pe + Q];
          de >= U && de <= Z && (F.push(N[pe]), F.push(N[pe + 1]), F.push(N[pe + 2]));
        }
      }
      function Vr(N, F, U, Z, Q, pe, de) {
        for (var G, ie, _e = Lr(N), Ge = Q === 0 ? Bi : so, Ze = N.start, Ce = 0; Ce < N.length - 3; Ce += 3) {
          var Ue = N[Ce], Et = N[Ce + 1], _t = N[Ce + 2], Le = N[Ce + 3], pt = N[Ce + 4], st = Q === 0 ? Ue : Et, De = Q === 0 ? Le : pt, fe = !1;
          de && (G = Math.sqrt(Math.pow(Ue - Le, 2) + Math.pow(Et - pt, 2))), st < U ? De > U && (ie = Ge(_e, Ue, Et, Le, pt, U), de && (_e.start = Ze + G * ie)) : st > Z ? De < Z && (ie = Ge(_e, Ue, Et, Le, pt, Z), de && (_e.start = Ze + G * ie)) : Xn(_e, Ue, Et, _t), De < U && st >= U && (ie = Ge(_e, Ue, Et, Le, pt, U), fe = !0), De > Z && st <= Z && (ie = Ge(_e, Ue, Et, Le, pt, Z), fe = !0), !pe && fe && (de && (_e.end = Ze + G * ie), F.push(_e), _e = Lr(N)), de && (Ze += G);
        }
        var Ee = N.length - 3;
        Ue = N[Ee], Et = N[Ee + 1], _t = N[Ee + 2], (st = Q === 0 ? Ue : Et) >= U && st <= Z && Xn(_e, Ue, Et, _t), Ee = _e.length - 3, pe && Ee >= 3 && (_e[Ee] !== _e[0] || _e[Ee + 1] !== _e[1]) && Xn(_e, _e[0], _e[1], _e[2]), _e.length && F.push(_e);
      }
      function Lr(N) {
        var F = [];
        return F.size = N.size, F.start = N.start, F.end = N.end, F;
      }
      function Jr(N, F, U, Z, Q, pe) {
        for (var de = 0; de < N.length; de++)
          Vr(N[de], F, U, Z, Q, pe, !1);
      }
      function Xn(N, F, U, Z) {
        N.push(F), N.push(U), N.push(Z);
      }
      function Bi(N, F, U, Z, Q, pe) {
        var de = (pe - F) / (Z - F);
        return N.push(pe), N.push(U + (Q - U) * de), N.push(1), de;
      }
      function so(N, F, U, Z, Q, pe) {
        var de = (pe - U) / (Q - U);
        return N.push(F + (Z - F) * de), N.push(pe), N.push(1), de;
      }
      function Kn(N, F) {
        for (var U = [], Z = 0; Z < N.length; Z++) {
          var Q, pe = N[Z], de = pe.type;
          if (de === "Point" || de === "MultiPoint" || de === "LineString")
            Q = Li(pe.geometry, F);
          else if (de === "MultiLineString" || de === "Polygon") {
            Q = [];
            for (var G = 0; G < pe.geometry.length; G++)
              Q.push(Li(pe.geometry[G], F));
          } else if (de === "MultiPolygon")
            for (Q = [], G = 0; G < pe.geometry.length; G++) {
              for (var ie = [], _e = 0; _e < pe.geometry[G].length; _e++)
                ie.push(Li(pe.geometry[G][_e], F));
              Q.push(ie);
            }
          U.push(rt(pe.id, de, Q, pe.tags));
        }
        return U;
      }
      function Li(N, F) {
        var U = [];
        U.size = N.size, N.start !== void 0 && (U.start = N.start, U.end = N.end);
        for (var Z = 0; Z < N.length; Z += 3)
          U.push(N[Z] + F, N[Z + 1], N[Z + 2]);
        return U;
      }
      function Tn(N, F) {
        if (N.transformed)
          return N;
        var U, Z, Q, pe = 1 << N.z, de = N.x, G = N.y;
        for (U = 0; U < N.features.length; U++) {
          var ie = N.features[U], _e = ie.geometry, Ge = ie.type;
          if (ie.geometry = [], Ge === 1)
            for (Z = 0; Z < _e.length; Z += 2)
              ie.geometry.push(ai(_e[Z], _e[Z + 1], F, pe, de, G));
          else
            for (Z = 0; Z < _e.length; Z++) {
              var Ze = [];
              for (Q = 0; Q < _e[Z].length; Q += 2)
                Ze.push(ai(_e[Z][Q], _e[Z][Q + 1], F, pe, de, G));
              ie.geometry.push(Ze);
            }
        }
        return N.transformed = !0, N;
      }
      function ai(N, F, U, Z, Q, pe) {
        return [Math.round(U * (N * Z - Q)), Math.round(U * (F * Z - pe))];
      }
      function Fa(N, F, U, Z, Q) {
        for (var pe = F === Q.maxZoom ? 0 : Q.tolerance / ((1 << F) * Q.extent), de = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: U, y: Z, z: F, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, G = 0; G < N.length; G++) {
          de.numFeatures++, Uo(de, N[G], pe, Q);
          var ie = N[G].minX, _e = N[G].minY, Ge = N[G].maxX, Ze = N[G].maxY;
          ie < de.minX && (de.minX = ie), _e < de.minY && (de.minY = _e), Ge > de.maxX && (de.maxX = Ge), Ze > de.maxY && (de.maxY = Ze);
        }
        return de;
      }
      function Uo(N, F, U, Z) {
        var Q = F.geometry, pe = F.type, de = [];
        if (pe === "Point" || pe === "MultiPoint")
          for (var G = 0; G < Q.length; G += 3)
            de.push(Q[G]), de.push(Q[G + 1]), N.numPoints++, N.numSimplified++;
        else if (pe === "LineString")
          Ba(de, Q, N, U, !1, !1);
        else if (pe === "MultiLineString" || pe === "Polygon")
          for (G = 0; G < Q.length; G++)
            Ba(de, Q[G], N, U, pe === "Polygon", G === 0);
        else if (pe === "MultiPolygon")
          for (var ie = 0; ie < Q.length; ie++) {
            var _e = Q[ie];
            for (G = 0; G < _e.length; G++)
              Ba(de, _e[G], N, U, !0, G === 0);
          }
        if (de.length) {
          var Ge = F.tags || null;
          if (pe === "LineString" && Z.lineMetrics) {
            for (var Ze in Ge = {}, F.tags)
              Ge[Ze] = F.tags[Ze];
            Ge.mapbox_clip_start = Q.start / Q.size, Ge.mapbox_clip_end = Q.end / Q.size;
          }
          var Ce = { geometry: de, type: pe === "Polygon" || pe === "MultiPolygon" ? 3 : pe === "LineString" || pe === "MultiLineString" ? 2 : 1, tags: Ge };
          F.id !== null && (Ce.id = F.id), N.features.push(Ce);
        }
      }
      function Ba(N, F, U, Z, Q, pe) {
        var de = Z * Z;
        if (Z > 0 && F.size < (Q ? de : Z))
          U.numPoints += F.length / 3;
        else {
          for (var G = [], ie = 0; ie < F.length; ie += 3)
            (Z === 0 || F[ie + 2] > de) && (U.numSimplified++, G.push(F[ie]), G.push(F[ie + 1])), U.numPoints++;
          Q && function(_e, Ge) {
            for (var Ze = 0, Ce = 0, Ue = _e.length, Et = Ue - 2; Ce < Ue; Et = Ce, Ce += 2)
              Ze += (_e[Ce] - _e[Et]) * (_e[Ce + 1] + _e[Et + 1]);
            if (Ze > 0 === Ge)
              for (Ce = 0, Ue = _e.length; Ce < Ue / 2; Ce += 2) {
                var _t = _e[Ce], Le = _e[Ce + 1];
                _e[Ce] = _e[Ue - 2 - Ce], _e[Ce + 1] = _e[Ue - 1 - Ce], _e[Ue - 2 - Ce] = _t, _e[Ue - 1 - Ce] = Le;
              }
          }(G, pe), N.push(G);
        }
      }
      function na(N, F) {
        var U = (F = this.options = function(Q, pe) {
          for (var de in pe)
            Q[de] = pe[de];
          return Q;
        }(Object.create(this.options), F)).debug;
        if (U && console.time("preprocess data"), F.maxZoom < 0 || F.maxZoom > 24)
          throw new Error("maxZoom should be in the 0-24 range");
        if (F.promoteId && F.generateId)
          throw new Error("promoteId and generateId cannot be used together.");
        var Z = function(Q, pe) {
          var de = [];
          if (Q.type === "FeatureCollection")
            for (var G = 0; G < Q.features.length; G++)
              et(de, Q.features[G], pe, G);
          else
            et(de, Q.type === "Feature" ? Q : { geometry: Q }, pe);
          return de;
        }(N, F);
        this.tiles = {}, this.tileCoords = [], U && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", F.indexMaxZoom, F.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (Z = function(Q, pe) {
          var de = pe.buffer / pe.extent, G = Q, ie = Ut(Q, 1, -1 - de, de, 0, -1, 2, pe), _e = Ut(Q, 1, 1 - de, 2 + de, 0, -1, 2, pe);
          return (ie || _e) && (G = Ut(Q, 1, -de, 1 + de, 0, -1, 2, pe) || [], ie && (G = Kn(ie, 1).concat(G)), _e && (G = G.concat(Kn(_e, -1)))), G;
        }(Z, F)).length && this.splitTile(Z, 0, 0, 0), U && (Z.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function an(N, F, U) {
        return 32 * ((1 << N) * U + F) + N;
      }
      function So(N, F) {
        var U = N.tileID.canonical;
        if (!this._geoJSONIndex)
          return F(null, null);
        var Z = this._geoJSONIndex.getTile(U.z, U.x, U.y);
        if (!Z)
          return F(null, null);
        var Q = new ve(Z.features), pe = Ie(Q);
        pe.byteOffset === 0 && pe.byteLength === pe.buffer.byteLength || (pe = new Uint8Array(pe)), F(null, { vectorTile: Q, rawData: pe.buffer });
      }
      kr.prototype.load = function(N) {
        var F = this.options, U = F.log, Z = F.minZoom, Q = F.maxZoom, pe = F.nodeSize;
        U && console.time("total time");
        var de = "prepare " + N.length + " points";
        U && console.time(de), this.points = N;
        for (var G = [], ie = 0; ie < N.length; ie++)
          N[ie].geometry && G.push(Tr(N[ie], ie));
        this.trees[Q + 1] = new Fi(G, Ne, qe, pe, Float32Array), U && console.timeEnd(de);
        for (var _e = Q; _e >= Z; _e--) {
          var Ge = +Date.now();
          G = this._cluster(G, _e), this.trees[_e] = new Fi(G, Ne, qe, pe, Float32Array), U && console.log("z%d: %d clusters in %dms", _e, G.length, +Date.now() - Ge);
        }
        return U && console.timeEnd("total time"), this;
      }, kr.prototype.getClusters = function(N, F) {
        var U = ((N[0] + 180) % 360 + 360) % 360 - 180, Z = Math.max(-90, Math.min(90, N[1])), Q = N[2] === 180 ? 180 : ((N[2] + 180) % 360 + 360) % 360 - 180, pe = Math.max(-90, Math.min(90, N[3]));
        if (N[2] - N[0] >= 360)
          U = -180, Q = 180;
        else if (U > Q) {
          var de = this.getClusters([U, Z, 180, pe], F), G = this.getClusters([-180, Z, Q, pe], F);
          return de.concat(G);
        }
        for (var ie = this.trees[this._limitZoom(F)], _e = [], Ge = 0, Ze = ie.range(Un(U), K(pe), Un(Q), K(Z)); Ge < Ze.length; Ge += 1) {
          var Ce = ie.points[Ze[Ge]];
          _e.push(Ce.numPoints ? Sn(Ce) : this.points[Ce.index]);
        }
        return _e;
      }, kr.prototype.getChildren = function(N) {
        var F = this._getOriginId(N), U = this._getOriginZoom(N), Z = "No cluster with the specified id.", Q = this.trees[U];
        if (!Q)
          throw new Error(Z);
        var pe = Q.points[F];
        if (!pe)
          throw new Error(Z);
        for (var de = this.options.radius / (this.options.extent * Math.pow(2, U - 1)), G = [], ie = 0, _e = Q.within(pe.x, pe.y, de); ie < _e.length; ie += 1) {
          var Ge = Q.points[_e[ie]];
          Ge.parentId === N && G.push(Ge.numPoints ? Sn(Ge) : this.points[Ge.index]);
        }
        if (G.length === 0)
          throw new Error(Z);
        return G;
      }, kr.prototype.getLeaves = function(N, F, U) {
        var Z = [];
        return this._appendLeaves(Z, N, F = F || 10, U = U || 0, 0), Z;
      }, kr.prototype.getTile = function(N, F, U) {
        var Z = this.trees[this._limitZoom(N)], Q = Math.pow(2, N), pe = this.options, de = pe.radius / pe.extent, G = (U - de) / Q, ie = (U + 1 + de) / Q, _e = { features: [] };
        return this._addTileFeatures(Z.range((F - de) / Q, G, (F + 1 + de) / Q, ie), Z.points, F, U, Q, _e), F === 0 && this._addTileFeatures(Z.range(1 - de / Q, G, 1, ie), Z.points, Q, U, Q, _e), F === Q - 1 && this._addTileFeatures(Z.range(0, G, de / Q, ie), Z.points, -1, U, Q, _e), _e.features.length ? _e : null;
      }, kr.prototype.getClusterExpansionZoom = function(N) {
        for (var F = this._getOriginZoom(N) - 1; F <= this.options.maxZoom; ) {
          var U = this.getChildren(N);
          if (F++, U.length !== 1)
            break;
          N = U[0].properties.cluster_id;
        }
        return F;
      }, kr.prototype._appendLeaves = function(N, F, U, Z, Q) {
        for (var pe = 0, de = this.getChildren(F); pe < de.length; pe += 1) {
          var G = de[pe], ie = G.properties;
          if (ie && ie.cluster ? Q + ie.point_count <= Z ? Q += ie.point_count : Q = this._appendLeaves(N, ie.cluster_id, U, Z, Q) : Q < Z ? Q++ : N.push(G), N.length === U)
            break;
        }
        return Q;
      }, kr.prototype._addTileFeatures = function(N, F, U, Z, Q, pe) {
        for (var de = 0, G = N; de < G.length; de += 1) {
          var ie = F[G[de]], _e = ie.numPoints, Ge = { type: 1, geometry: [[Math.round(this.options.extent * (ie.x * Q - U)), Math.round(this.options.extent * (ie.y * Q - Z))]], tags: _e ? oi(ie) : this.points[ie.index].properties }, Ze = void 0;
          _e ? Ze = ie.id : this.options.generateId ? Ze = ie.index : this.points[ie.index].id && (Ze = this.points[ie.index].id), Ze !== void 0 && (Ge.id = Ze), pe.features.push(Ge);
        }
      }, kr.prototype._limitZoom = function(N) {
        return Math.max(this.options.minZoom, Math.min(+N, this.options.maxZoom + 1));
      }, kr.prototype._cluster = function(N, F) {
        for (var U = [], Z = this.options, Q = Z.reduce, pe = Z.minPoints, de = Z.radius / (Z.extent * Math.pow(2, F)), G = 0; G < N.length; G++) {
          var ie = N[G];
          if (!(ie.zoom <= F)) {
            ie.zoom = F;
            for (var _e = this.trees[F + 1], Ge = _e.within(ie.x, ie.y, de), Ze = ie.numPoints || 1, Ce = Ze, Ue = 0, Et = Ge; Ue < Et.length; Ue += 1) {
              var _t = _e.points[Et[Ue]];
              _t.zoom > F && (Ce += _t.numPoints || 1);
            }
            if (Ce >= pe) {
              for (var Le = ie.x * Ze, pt = ie.y * Ze, st = Q && Ze > 1 ? this._map(ie, !0) : null, De = (G << 5) + (F + 1) + this.points.length, fe = 0, Ee = Ge; fe < Ee.length; fe += 1) {
                var He = _e.points[Ee[fe]];
                if (!(He.zoom <= F)) {
                  He.zoom = F;
                  var jt = He.numPoints || 1;
                  Le += He.x * jt, pt += He.y * jt, He.parentId = De, Q && (st || (st = this._map(ie, !0)), Q(st, this._map(He)));
                }
              }
              ie.parentId = De, U.push(Vn(Le / Ce, pt / Ce, De, Ce, st));
            } else if (U.push(ie), Ce > 1)
              for (var Wt = 0, Jt = Ge; Wt < Jt.length; Wt += 1) {
                var Zt = _e.points[Jt[Wt]];
                Zt.zoom <= F || (Zt.zoom = F, U.push(Zt));
              }
          }
        }
        return U;
      }, kr.prototype._getOriginId = function(N) {
        return N - this.points.length >> 5;
      }, kr.prototype._getOriginZoom = function(N) {
        return (N - this.points.length) % 32;
      }, kr.prototype._map = function(N, F) {
        if (N.numPoints)
          return F ? ye({}, N.properties) : N.properties;
        var U = this.points[N.index].properties, Z = this.options.map(U);
        return F && Z === U ? ye({}, Z) : Z;
      }, na.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, na.prototype.splitTile = function(N, F, U, Z, Q, pe, de) {
        for (var G = [N, F, U, Z], ie = this.options, _e = ie.debug; G.length; ) {
          Z = G.pop(), U = G.pop(), F = G.pop(), N = G.pop();
          var Ge = 1 << F, Ze = an(F, U, Z), Ce = this.tiles[Ze];
          if (!Ce && (_e > 1 && console.time("creation"), Ce = this.tiles[Ze] = Fa(N, F, U, Z, ie), this.tileCoords.push({ z: F, x: U, y: Z }), _e)) {
            _e > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", F, U, Z, Ce.numFeatures, Ce.numPoints, Ce.numSimplified), console.timeEnd("creation"));
            var Ue = "z" + F;
            this.stats[Ue] = (this.stats[Ue] || 0) + 1, this.total++;
          }
          if (Ce.source = N, Q) {
            if (F === ie.maxZoom || F === Q)
              continue;
            var Et = 1 << Q - F;
            if (U !== Math.floor(pe / Et) || Z !== Math.floor(de / Et))
              continue;
          } else if (F === ie.indexMaxZoom || Ce.numPoints <= ie.indexMaxPoints)
            continue;
          if (Ce.source = null, N.length !== 0) {
            _e > 1 && console.time("clipping");
            var _t, Le, pt, st, De, fe, Ee = 0.5 * ie.buffer / ie.extent, He = 0.5 - Ee, jt = 0.5 + Ee, Wt = 1 + Ee;
            _t = Le = pt = st = null, De = Ut(N, Ge, U - Ee, U + jt, 0, Ce.minX, Ce.maxX, ie), fe = Ut(N, Ge, U + He, U + Wt, 0, Ce.minX, Ce.maxX, ie), N = null, De && (_t = Ut(De, Ge, Z - Ee, Z + jt, 1, Ce.minY, Ce.maxY, ie), Le = Ut(De, Ge, Z + He, Z + Wt, 1, Ce.minY, Ce.maxY, ie), De = null), fe && (pt = Ut(fe, Ge, Z - Ee, Z + jt, 1, Ce.minY, Ce.maxY, ie), st = Ut(fe, Ge, Z + He, Z + Wt, 1, Ce.minY, Ce.maxY, ie), fe = null), _e > 1 && console.timeEnd("clipping"), G.push(_t || [], F + 1, 2 * U, 2 * Z), G.push(Le || [], F + 1, 2 * U, 2 * Z + 1), G.push(pt || [], F + 1, 2 * U + 1, 2 * Z), G.push(st || [], F + 1, 2 * U + 1, 2 * Z + 1);
          }
        }
      }, na.prototype.getTile = function(N, F, U) {
        var Z = this.options, Q = Z.extent, pe = Z.debug;
        if (N < 0 || N > 24)
          return null;
        var de = 1 << N, G = an(N, F = (F % de + de) % de, U);
        if (this.tiles[G])
          return Tn(this.tiles[G], Q);
        pe > 1 && console.log("drilling down to z%d-%d-%d", N, F, U);
        for (var ie, _e = N, Ge = F, Ze = U; !ie && _e > 0; )
          _e--, Ge = Math.floor(Ge / 2), Ze = Math.floor(Ze / 2), ie = this.tiles[an(_e, Ge, Ze)];
        return ie && ie.source ? (pe > 1 && console.log("found parent tile z%d-%d-%d", _e, Ge, Ze), pe > 1 && console.time("drilling down"), this.splitTile(ie.source, _e, Ge, Ze, N, F, U), pe > 1 && console.timeEnd("drilling down"), this.tiles[G] ? Tn(this.tiles[G], Q) : null) : null;
      };
      var ol = function(N) {
        function F(U, Z, Q, pe) {
          N.call(this, U, Z, Q, So), pe && (this.loadGeoJSON = pe);
        }
        return N && (F.__proto__ = N), (F.prototype = Object.create(N && N.prototype)).constructor = F, F.prototype.loadData = function(U, Z) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), this._pendingCallback = Z, this._pendingLoadDataParams = U, this._state && this._state !== "Idle" ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());
        }, F.prototype._loadData = function() {
          var U = this;
          if (this._pendingCallback && this._pendingLoadDataParams) {
            var Z = this._pendingCallback, Q = this._pendingLoadDataParams;
            delete this._pendingCallback, delete this._pendingLoadDataParams;
            var pe = !!(Q && Q.request && Q.request.collectResourceTiming) && new a.RequestPerformance(Q.request);
            this.loadGeoJSON(Q, function(de, G) {
              if (de || !G)
                return Z(de);
              if (typeof G != "object")
                return Z(new Error("Input data given to '" + Q.source + "' is not a valid GeoJSON object."));
              (function Ce(Ue, Et) {
                var _t, Le = Ue && Ue.type;
                if (Le === "FeatureCollection")
                  for (_t = 0; _t < Ue.features.length; _t++)
                    Ce(Ue.features[_t], Et);
                else if (Le === "GeometryCollection")
                  for (_t = 0; _t < Ue.geometries.length; _t++)
                    Ce(Ue.geometries[_t], Et);
                else if (Le === "Feature")
                  Ce(Ue.geometry, Et);
                else if (Le === "Polygon")
                  re(Ue.coordinates, Et);
                else if (Le === "MultiPolygon")
                  for (_t = 0; _t < Ue.coordinates.length; _t++)
                    re(Ue.coordinates[_t], Et);
                return Ue;
              })(G, !0);
              try {
                if (Q.filter) {
                  var ie = a.createExpression(Q.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                  if (ie.result === "error")
                    throw new Error(ie.value.map(function(Ce) {
                      return Ce.key + ": " + Ce.message;
                    }).join(", "));
                  var _e = G.features.filter(function(Ce) {
                    return ie.value.evaluate({ zoom: 0 }, Ce);
                  });
                  G = { type: "FeatureCollection", features: _e };
                }
                U._geoJSONIndex = Q.cluster ? new kr(function(Ce) {
                  var Ue = Ce.superclusterOptions, Et = Ce.clusterProperties;
                  if (!Et || !Ue)
                    return Ue;
                  for (var _t = {}, Le = {}, pt = { accumulated: null, zoom: 0 }, st = { properties: null }, De = Object.keys(Et), fe = 0, Ee = De; fe < Ee.length; fe += 1) {
                    var He = Ee[fe], jt = Et[He], Wt = jt[0], Jt = a.createExpression(jt[1]), Zt = a.createExpression(typeof Wt == "string" ? [Wt, ["accumulated"], ["get", He]] : Wt);
                    _t[He] = Jt.value, Le[He] = Zt.value;
                  }
                  return Ue.map = function(Yn) {
                    st.properties = Yn;
                    for (var Qt = {}, pn = 0, Ur = De; pn < Ur.length; pn += 1) {
                      var gr = Ur[pn];
                      Qt[gr] = _t[gr].evaluate(pt, st);
                    }
                    return Qt;
                  }, Ue.reduce = function(Yn, Qt) {
                    st.properties = Qt;
                    for (var pn = 0, Ur = De; pn < Ur.length; pn += 1) {
                      var gr = Ur[pn];
                      pt.accumulated = Yn[gr], Yn[gr] = Le[gr].evaluate(pt, st);
                    }
                  }, Ue;
                }(Q)).load(G.features) : function(Ce, Ue) {
                  return new na(Ce, Ue);
                }(G, Q.geojsonVtOptions);
              } catch (Ce) {
                return Z(Ce);
              }
              U.loaded = {};
              var Ge = {};
              if (pe) {
                var Ze = pe.finish();
                Ze && (Ge.resourceTiming = {}, Ge.resourceTiming[Q.source] = JSON.parse(JSON.stringify(Ze)));
              }
              Z(null, Ge);
            });
          }
        }, F.prototype.coalesce = function() {
          this._state === "Coalescing" ? this._state = "Idle" : this._state === "NeedsLoadData" && (this._state = "Coalescing", this._loadData());
        }, F.prototype.reloadTile = function(U, Z) {
          var Q = this.loaded;
          return Q && Q[U.uid] ? N.prototype.reloadTile.call(this, U, Z) : this.loadTile(U, Z);
        }, F.prototype.loadGeoJSON = function(U, Z) {
          if (U.request)
            a.getJSON(U.request, Z);
          else {
            if (typeof U.data != "string")
              return Z(new Error("Input data given to '" + U.source + "' is not a valid GeoJSON object."));
            try {
              return Z(null, JSON.parse(U.data));
            } catch {
              return Z(new Error("Input data given to '" + U.source + "' is not a valid GeoJSON object."));
            }
          }
        }, F.prototype.removeSource = function(U, Z) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), Z();
        }, F.prototype.getClusterExpansionZoom = function(U, Z) {
          try {
            Z(null, this._geoJSONIndex.getClusterExpansionZoom(U.clusterId));
          } catch (Q) {
            Z(Q);
          }
        }, F.prototype.getClusterChildren = function(U, Z) {
          try {
            Z(null, this._geoJSONIndex.getChildren(U.clusterId));
          } catch (Q) {
            Z(Q);
          }
        }, F.prototype.getClusterLeaves = function(U, Z) {
          try {
            Z(null, this._geoJSONIndex.getLeaves(U.clusterId, U.limit, U.offset));
          } catch (Q) {
            Z(Q);
          }
        }, F;
      }(z), bn = function(N) {
        var F = this;
        this.self = N, this.actor = new a.Actor(N, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: z, geojson: ol }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function(U, Z) {
          if (F.workerSourceTypes[U])
            throw new Error('Worker source with name "' + U + '" already registered.');
          F.workerSourceTypes[U] = Z;
        }, this.self.registerRTLTextPlugin = function(U) {
          if (a.plugin.isParsed())
            throw new Error("RTL text plugin already registered.");
          a.plugin.applyArabicShaping = U.applyArabicShaping, a.plugin.processBidirectionalText = U.processBidirectionalText, a.plugin.processStyledBidirectionalText = U.processStyledBidirectionalText;
        };
      };
      return bn.prototype.setReferrer = function(N, F) {
        this.referrer = F;
      }, bn.prototype.setImages = function(N, F, U) {
        for (var Z in this.availableImages[N] = F, this.workerSources[N]) {
          var Q = this.workerSources[N][Z];
          for (var pe in Q)
            Q[pe].availableImages = F;
        }
        U();
      }, bn.prototype.setLayers = function(N, F, U) {
        this.getLayerIndex(N).replace(F), U();
      }, bn.prototype.updateLayers = function(N, F, U) {
        this.getLayerIndex(N).update(F.layers, F.removedIds), U();
      }, bn.prototype.loadTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).loadTile(F, U);
      }, bn.prototype.loadDEMTile = function(N, F, U) {
        this.getDEMWorkerSource(N, F.source).loadTile(F, U);
      }, bn.prototype.reloadTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).reloadTile(F, U);
      }, bn.prototype.abortTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).abortTile(F, U);
      }, bn.prototype.removeTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).removeTile(F, U);
      }, bn.prototype.removeDEMTile = function(N, F) {
        this.getDEMWorkerSource(N, F.source).removeTile(F);
      }, bn.prototype.removeSource = function(N, F, U) {
        if (this.workerSources[N] && this.workerSources[N][F.type] && this.workerSources[N][F.type][F.source]) {
          var Z = this.workerSources[N][F.type][F.source];
          delete this.workerSources[N][F.type][F.source], Z.removeSource !== void 0 ? Z.removeSource(F, U) : U();
        }
      }, bn.prototype.loadWorkerSource = function(N, F, U) {
        try {
          this.self.importScripts(F.url), U();
        } catch (Z) {
          U(Z.toString());
        }
      }, bn.prototype.syncRTLPluginState = function(N, F, U) {
        try {
          a.plugin.setState(F);
          var Z = a.plugin.getPluginURL();
          if (a.plugin.isLoaded() && !a.plugin.isParsed() && Z != null) {
            this.self.importScripts(Z);
            var Q = a.plugin.isParsed();
            U(Q ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + Z), Q);
          }
        } catch (pe) {
          U(pe.toString());
        }
      }, bn.prototype.getAvailableImages = function(N) {
        var F = this.availableImages[N];
        return F || (F = []), F;
      }, bn.prototype.getLayerIndex = function(N) {
        var F = this.layerIndexes[N];
        return F || (F = this.layerIndexes[N] = new b()), F;
      }, bn.prototype.getWorkerSource = function(N, F, U) {
        var Z = this;
        return this.workerSources[N] || (this.workerSources[N] = {}), this.workerSources[N][F] || (this.workerSources[N][F] = {}), this.workerSources[N][F][U] || (this.workerSources[N][F][U] = new this.workerSourceTypes[F]({ send: function(Q, pe, de) {
          Z.actor.send(Q, pe, de, N);
        } }, this.getLayerIndex(N), this.getAvailableImages(N))), this.workerSources[N][F][U];
      }, bn.prototype.getDEMWorkerSource = function(N, F) {
        return this.demWorkerSources[N] || (this.demWorkerSources[N] = {}), this.demWorkerSources[N][F] || (this.demWorkerSources[N][F] = new q()), this.demWorkerSources[N][F];
      }, bn.prototype.enforceCacheSizeLimit = function(N, F) {
        a.enforceCacheSizeLimit(F);
      }, typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope && (self.worker = new bn(self)), bn;
    }), h(["./shared"], function(a) {
      var m = a.createCommonjsModule(function(u) {
        function f(_) {
          return !c(_);
        }
        function c(_) {
          return typeof window > "u" || typeof document > "u" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return !1;
            var E, O, k = new Blob([""], { type: "text/javascript" }), R = URL.createObjectURL(k);
            try {
              O = new Worker(R), E = !0;
            } catch {
              E = !1;
            }
            return O && O.terminate(), URL.revokeObjectURL(R), E;
          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
            var E = document.createElement("canvas");
            E.width = E.height = 1;
            var O = E.getContext("2d");
            if (!O)
              return !1;
            var k = O.getImageData(0, 0, 1, 1);
            return k && k.width === E.width;
          }() ? (d[w = _ && _.failIfMajorPerformanceCaveat] === void 0 && (d[w] = function(E) {
            var O = function(R) {
              var $ = document.createElement("canvas"), W = Object.create(f.webGLContextAttributes);
              return W.failIfMajorPerformanceCaveat = R, $.probablySupportsContext ? $.probablySupportsContext("webgl", W) || $.probablySupportsContext("experimental-webgl", W) : $.supportsContext ? $.supportsContext("webgl", W) || $.supportsContext("experimental-webgl", W) : $.getContext("webgl", W) || $.getContext("experimental-webgl", W);
            }(E);
            if (!O)
              return !1;
            var k = O.createShader(O.VERTEX_SHADER);
            return !(!k || O.isContextLost()) && (O.shaderSource(k, "void main() {}"), O.compileShader(k), O.getShaderParameter(k, O.COMPILE_STATUS) === !0);
          }(w)), d[w] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          var w;
        }
        u.exports ? u.exports = f : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = f, window.mapboxgl.notSupportedReason = c);
        var d = {};
        f.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };
      }), g = { create: function(u, f, c) {
        var d = a.window.document.createElement(u);
        return f !== void 0 && (d.className = f), c && c.appendChild(d), d;
      }, createNS: function(u, f) {
        return a.window.document.createElementNS(u, f);
      } }, b = a.window.document && a.window.document.documentElement.style;
      function T(u) {
        if (!b)
          return u[0];
        for (var f = 0; f < u.length; f++)
          if (u[f] in b)
            return u[f];
        return u[0];
      }
      var M, I = T(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);
      g.disableDrag = function() {
        b && I && (M = b[I], b[I] = "none");
      }, g.enableDrag = function() {
        b && I && (b[I] = M);
      };
      var P = T(["transform", "WebkitTransform"]);
      g.setTransform = function(u, f) {
        u.style[P] = f;
      };
      var z = !1;
      try {
        var V = Object.defineProperty({}, "passive", { get: function() {
          z = !0;
        } });
        a.window.addEventListener("test", V, V), a.window.removeEventListener("test", V, V);
      } catch {
        z = !1;
      }
      g.addEventListener = function(u, f, c, d) {
        d === void 0 && (d = {}), u.addEventListener(f, c, "passive" in d && z ? d : d.capture);
      }, g.removeEventListener = function(u, f, c, d) {
        d === void 0 && (d = {}), u.removeEventListener(f, c, "passive" in d && z ? d : d.capture);
      };
      var q = function(u) {
        u.preventDefault(), u.stopPropagation(), a.window.removeEventListener("click", q, !0);
      };
      function re(u) {
        var f = u.userImage;
        return !!(f && f.render && f.render()) && (u.data.replace(new Uint8Array(f.data.buffer)), !0);
      }
      g.suppressClick = function() {
        a.window.addEventListener("click", q, !0), a.window.setTimeout(function() {
          a.window.removeEventListener("click", q, !0);
        }, 0);
      }, g.mousePos = function(u, f) {
        var c = u.getBoundingClientRect();
        return new a.Point(f.clientX - c.left - u.clientLeft, f.clientY - c.top - u.clientTop);
      }, g.touchPos = function(u, f) {
        for (var c = u.getBoundingClientRect(), d = [], _ = 0; _ < f.length; _++)
          d.push(new a.Point(f[_].clientX - c.left - u.clientLeft, f[_].clientY - c.top - u.clientTop));
        return d;
      }, g.mouseButton = function(u) {
        return a.window.InstallTrigger !== void 0 && u.button === 2 && u.ctrlKey && a.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : u.button;
      }, g.remove = function(u) {
        u.parentNode && u.parentNode.removeChild(u);
      };
      var X = function(u) {
        function f() {
          u.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new a.RGBAImage({ width: 1, height: 1 }), this.dirty = !0;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.isLoaded = function() {
          return this.loaded;
        }, f.prototype.setLoaded = function(c) {
          if (this.loaded !== c && (this.loaded = c, c)) {
            for (var d = 0, _ = this.requestors; d < _.length; d += 1) {
              var w = _[d];
              this._notify(w.ids, w.callback);
            }
            this.requestors = [];
          }
        }, f.prototype.getImage = function(c) {
          return this.images[c];
        }, f.prototype.addImage = function(c, d) {
          this._validate(c, d) && (this.images[c] = d);
        }, f.prototype._validate = function(c, d) {
          var _ = !0;
          return this._validateStretch(d.stretchX, d.data && d.data.width) || (this.fire(new a.ErrorEvent(new Error('Image "' + c + '" has invalid "stretchX" value'))), _ = !1), this._validateStretch(d.stretchY, d.data && d.data.height) || (this.fire(new a.ErrorEvent(new Error('Image "' + c + '" has invalid "stretchY" value'))), _ = !1), this._validateContent(d.content, d) || (this.fire(new a.ErrorEvent(new Error('Image "' + c + '" has invalid "content" value'))), _ = !1), _;
        }, f.prototype._validateStretch = function(c, d) {
          if (!c)
            return !0;
          for (var _ = 0, w = 0, E = c; w < E.length; w += 1) {
            var O = E[w];
            if (O[0] < _ || O[1] < O[0] || d < O[1])
              return !1;
            _ = O[1];
          }
          return !0;
        }, f.prototype._validateContent = function(c, d) {
          return !(c && (c.length !== 4 || c[0] < 0 || d.data.width < c[0] || c[1] < 0 || d.data.height < c[1] || c[2] < 0 || d.data.width < c[2] || c[3] < 0 || d.data.height < c[3] || c[2] < c[0] || c[3] < c[1]));
        }, f.prototype.updateImage = function(c, d) {
          d.version = this.images[c].version + 1, this.images[c] = d, this.updatedImages[c] = !0;
        }, f.prototype.removeImage = function(c) {
          var d = this.images[c];
          delete this.images[c], delete this.patterns[c], d.userImage && d.userImage.onRemove && d.userImage.onRemove();
        }, f.prototype.listImages = function() {
          return Object.keys(this.images);
        }, f.prototype.getImages = function(c, d) {
          var _ = !0;
          if (!this.isLoaded())
            for (var w = 0, E = c; w < E.length; w += 1)
              this.images[E[w]] || (_ = !1);
          this.isLoaded() || _ ? this._notify(c, d) : this.requestors.push({ ids: c, callback: d });
        }, f.prototype._notify = function(c, d) {
          for (var _ = {}, w = 0, E = c; w < E.length; w += 1) {
            var O = E[w];
            this.images[O] || this.fire(new a.Event("styleimagemissing", { id: O }));
            var k = this.images[O];
            k ? _[O] = { data: k.data.clone(), pixelRatio: k.pixelRatio, sdf: k.sdf, version: k.version, stretchX: k.stretchX, stretchY: k.stretchY, content: k.content, hasRenderCallback: Boolean(k.userImage && k.userImage.render) } : a.warnOnce('Image "' + O + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');
          }
          d(null, _);
        }, f.prototype.getPixelSize = function() {
          var c = this.atlasImage;
          return { width: c.width, height: c.height };
        }, f.prototype.getPattern = function(c) {
          var d = this.patterns[c], _ = this.getImage(c);
          if (!_)
            return null;
          if (d && d.position.version === _.version)
            return d.position;
          if (d)
            d.position.version = _.version;
          else {
            var w = { w: _.data.width + 2, h: _.data.height + 2, x: 0, y: 0 }, E = new a.ImagePosition(w, _);
            this.patterns[c] = { bin: w, position: E };
          }
          return this._updatePatternAtlas(), this.patterns[c].position;
        }, f.prototype.bind = function(c) {
          var d = c.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new a.Texture(c, this.atlasImage, d.RGBA), this.atlasTexture.bind(d.LINEAR, d.CLAMP_TO_EDGE);
        }, f.prototype._updatePatternAtlas = function() {
          var c = [];
          for (var d in this.patterns)
            c.push(this.patterns[d].bin);
          var _ = a.potpack(c), w = _.w, E = _.h, O = this.atlasImage;
          for (var k in O.resize({ width: w || 1, height: E || 1 }), this.patterns) {
            var R = this.patterns[k].bin, $ = R.x + 1, W = R.y + 1, H = this.images[k].data, ne = H.width, te = H.height;
            a.RGBAImage.copy(H, O, { x: 0, y: 0 }, { x: $, y: W }, { width: ne, height: te }), a.RGBAImage.copy(H, O, { x: 0, y: te - 1 }, { x: $, y: W - 1 }, { width: ne, height: 1 }), a.RGBAImage.copy(H, O, { x: 0, y: 0 }, { x: $, y: W + te }, { width: ne, height: 1 }), a.RGBAImage.copy(H, O, { x: ne - 1, y: 0 }, { x: $ - 1, y: W }, { width: 1, height: te }), a.RGBAImage.copy(H, O, { x: 0, y: 0 }, { x: $ + ne, y: W }, { width: 1, height: te });
          }
          this.dirty = !0;
        }, f.prototype.beginFrame = function() {
          this.callbackDispatchedThisFrame = {};
        }, f.prototype.dispatchRenderCallbacks = function(c) {
          for (var d = 0, _ = c; d < _.length; d += 1) {
            var w = _[d];
            if (!this.callbackDispatchedThisFrame[w]) {
              this.callbackDispatchedThisFrame[w] = !0;
              var E = this.images[w];
              re(E) && this.updateImage(w, E);
            }
          }
        }, f;
      }(a.Evented), ae = Re, ce = Re, ve = 1e20;
      function Re(u, f, c, d, _, w) {
        this.fontSize = u || 24, this.buffer = f === void 0 ? 3 : f, this.cutoff = d || 0.25, this.fontFamily = _ || "sans-serif", this.fontWeight = w || "normal", this.radius = c || 8;
        var E = this.size = this.fontSize + 2 * this.buffer;
        this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = E, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(E * E), this.gridInner = new Float64Array(E * E), this.f = new Float64Array(E), this.d = new Float64Array(E), this.z = new Float64Array(E + 1), this.v = new Int16Array(E), this.middle = Math.round(E / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
      }
      function Fe(u, f, c, d, _, w, E) {
        for (var O = 0; O < f; O++) {
          for (var k = 0; k < c; k++)
            d[k] = u[k * f + O];
          for (Pe(d, _, w, E, c), k = 0; k < c; k++)
            u[k * f + O] = _[k];
        }
        for (k = 0; k < c; k++) {
          for (O = 0; O < f; O++)
            d[O] = u[k * f + O];
          for (Pe(d, _, w, E, f), O = 0; O < f; O++)
            u[k * f + O] = Math.sqrt(_[O]);
        }
      }
      function Pe(u, f, c, d, _) {
        c[0] = 0, d[0] = -ve, d[1] = +ve;
        for (var w = 1, E = 0; w < _; w++) {
          for (var O = (u[w] + w * w - (u[c[E]] + c[E] * c[E])) / (2 * w - 2 * c[E]); O <= d[E]; )
            E--, O = (u[w] + w * w - (u[c[E]] + c[E] * c[E])) / (2 * w - 2 * c[E]);
          c[++E] = w, d[E] = O, d[E + 1] = +ve;
        }
        for (w = 0, E = 0; w < _; w++) {
          for (; d[E + 1] < w; )
            E++;
          f[w] = (w - c[E]) * (w - c[E]) + u[c[E]];
        }
      }
      Re.prototype.draw = function(u) {
        this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(u, this.buffer, this.middle);
        for (var f = this.ctx.getImageData(0, 0, this.size, this.size), c = new Uint8ClampedArray(this.size * this.size), d = 0; d < this.size * this.size; d++) {
          var _ = f.data[4 * d + 3] / 255;
          this.gridOuter[d] = _ === 1 ? 0 : _ === 0 ? ve : Math.pow(Math.max(0, 0.5 - _), 2), this.gridInner[d] = _ === 1 ? ve : _ === 0 ? 0 : Math.pow(Math.max(0, _ - 0.5), 2);
        }
        for (Fe(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), Fe(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), d = 0; d < this.size * this.size; d++)
          c[d] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[d] - this.gridInner[d]) / this.radius + this.cutoff))));
        return c;
      }, ae.default = ce;
      var Se = function(u, f) {
        this.requestManager = u, this.localIdeographFontFamily = f, this.entries = {};
      };
      Se.prototype.setURL = function(u) {
        this.url = u;
      }, Se.prototype.getGlyphs = function(u, f) {
        var c = this, d = [];
        for (var _ in u)
          for (var w = 0, E = u[_]; w < E.length; w += 1)
            d.push({ stack: _, id: E[w] });
        a.asyncAll(d, function(O, k) {
          var R = O.stack, $ = O.id, W = c.entries[R];
          W || (W = c.entries[R] = { glyphs: {}, requests: {}, ranges: {} });
          var H = W.glyphs[$];
          if (H === void 0) {
            if (H = c._tinySDF(W, R, $))
              return W.glyphs[$] = H, void k(null, { stack: R, id: $, glyph: H });
            var ne = Math.floor($ / 256);
            if (256 * ne > 65535)
              k(new Error("glyphs > 65535 not supported"));
            else if (W.ranges[ne])
              k(null, { stack: R, id: $, glyph: H });
            else {
              var te = W.requests[ne];
              te || (te = W.requests[ne] = [], Se.loadGlyphRange(R, ne, c.url, c.requestManager, function(ue, Y) {
                if (Y) {
                  for (var le in Y)
                    c._doesCharSupportLocalGlyph(+le) || (W.glyphs[+le] = Y[+le]);
                  W.ranges[ne] = !0;
                }
                for (var me = 0, xe = te; me < xe.length; me += 1)
                  (0, xe[me])(ue, Y);
                delete W.requests[ne];
              })), te.push(function(ue, Y) {
                ue ? k(ue) : Y && k(null, { stack: R, id: $, glyph: Y[$] || null });
              });
            }
          } else
            k(null, { stack: R, id: $, glyph: H });
        }, function(O, k) {
          if (O)
            f(O);
          else if (k) {
            for (var R = {}, $ = 0, W = k; $ < W.length; $ += 1) {
              var H = W[$], ne = H.stack, te = H.id, ue = H.glyph;
              (R[ne] || (R[ne] = {}))[te] = ue && { id: ue.id, bitmap: ue.bitmap.clone(), metrics: ue.metrics };
            }
            f(null, R);
          }
        });
      }, Se.prototype._doesCharSupportLocalGlyph = function(u) {
        return !!this.localIdeographFontFamily && (a.isChar["CJK Unified Ideographs"](u) || a.isChar["Hangul Syllables"](u) || a.isChar.Hiragana(u) || a.isChar.Katakana(u));
      }, Se.prototype._tinySDF = function(u, f, c) {
        var d = this.localIdeographFontFamily;
        if (d && this._doesCharSupportLocalGlyph(c)) {
          var _ = u.tinySDF;
          if (!_) {
            var w = "400";
            /bold/i.test(f) ? w = "900" : /medium/i.test(f) ? w = "500" : /light/i.test(f) && (w = "200"), _ = u.tinySDF = new Se.TinySDF(24, 3, 8, 0.25, d, w);
          }
          return { id: c, bitmap: new a.AlphaImage({ width: 30, height: 30 }, _.draw(String.fromCharCode(c))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } };
        }
      }, Se.loadGlyphRange = function(u, f, c, d, _) {
        var w = 256 * f, E = w + 255, O = d.transformRequest(d.normalizeGlyphsURL(c).replace("{fontstack}", u).replace("{range}", w + "-" + E), a.ResourceType.Glyphs);
        a.getArrayBuffer(O, function(k, R) {
          if (k)
            _(k);
          else if (R) {
            for (var $ = {}, W = 0, H = a.parseGlyphPBF(R); W < H.length; W += 1) {
              var ne = H[W];
              $[ne.id] = ne;
            }
            _(null, $);
          }
        });
      }, Se.TinySDF = ae;
      var Ie = function() {
        this.specification = a.styleSpec.light.position;
      };
      Ie.prototype.possiblyEvaluate = function(u, f) {
        return a.sphericalToCartesian(u.expression.evaluate(f));
      }, Ie.prototype.interpolate = function(u, f, c) {
        return { x: a.number(u.x, f.x, c), y: a.number(u.y, f.y, c), z: a.number(u.z, f.z, c) };
      };
      var Xe = new a.Properties({ anchor: new a.DataConstantProperty(a.styleSpec.light.anchor), position: new Ie(), color: new a.DataConstantProperty(a.styleSpec.light.color), intensity: new a.DataConstantProperty(a.styleSpec.light.intensity) }), $e = function(u) {
        function f(c) {
          u.call(this), this._transitionable = new a.Transitionable(Xe), this.setLight(c), this._transitioning = this._transitionable.untransitioned();
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getLight = function() {
          return this._transitionable.serialize();
        }, f.prototype.setLight = function(c, d) {
          if (d === void 0 && (d = {}), !this._validate(a.validateLight, c, d))
            for (var _ in c) {
              var w = c[_];
              a.endsWith(_, "-transition") ? this._transitionable.setTransition(_.slice(0, -11), w) : this._transitionable.setValue(_, w);
            }
        }, f.prototype.updateTransitions = function(c) {
          this._transitioning = this._transitionable.transitioned(c, this._transitioning);
        }, f.prototype.hasTransition = function() {
          return this._transitioning.hasTransition();
        }, f.prototype.recalculate = function(c) {
          this.properties = this._transitioning.possiblyEvaluate(c);
        }, f.prototype._validate = function(c, d, _) {
          return (!_ || _.validate !== !1) && a.emitValidationErrors(this, c.call(a.validateStyle, a.extend({ value: d, style: { glyphs: !0, sprite: !0 }, styleSpec: a.styleSpec })));
        }, f;
      }(a.Evented), at = function(u, f) {
        this.width = u, this.height = f, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
      };
      at.prototype.getDash = function(u, f) {
        var c = u.join(",") + String(f);
        return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(u, f)), this.dashEntry[c];
      }, at.prototype.getDashRanges = function(u, f, c) {
        var d = [], _ = u.length % 2 == 1 ? -u[u.length - 1] * c : 0, w = u[0] * c, E = !0;
        d.push({ left: _, right: w, isDash: E, zeroLength: u[0] === 0 });
        for (var O = u[0], k = 1; k < u.length; k++) {
          var R = u[k];
          d.push({ left: _ = O * c, right: w = (O += R) * c, isDash: E = !E, zeroLength: R === 0 });
        }
        return d;
      }, at.prototype.addRoundDash = function(u, f, c) {
        for (var d = f / 2, _ = -c; _ <= c; _++)
          for (var w = this.width * (this.nextRow + c + _), E = 0, O = u[E], k = 0; k < this.width; k++) {
            k / O.right > 1 && (O = u[++E]);
            var R = Math.abs(k - O.left), $ = Math.abs(k - O.right), W = Math.min(R, $), H = void 0, ne = _ / c * (d + 1);
            if (O.isDash) {
              var te = d - Math.abs(ne);
              H = Math.sqrt(W * W + te * te);
            } else
              H = d - Math.sqrt(W * W + ne * ne);
            this.data[w + k] = Math.max(0, Math.min(255, H + 128));
          }
      }, at.prototype.addRegularDash = function(u) {
        for (var f = u.length - 1; f >= 0; --f) {
          var c = u[f], d = u[f + 1];
          c.zeroLength ? u.splice(f, 1) : d && d.isDash === c.isDash && (d.left = c.left, u.splice(f, 1));
        }
        var _ = u[0], w = u[u.length - 1];
        _.isDash === w.isDash && (_.left = w.left - this.width, w.right = _.right + this.width);
        for (var E = this.width * this.nextRow, O = 0, k = u[O], R = 0; R < this.width; R++) {
          R / k.right > 1 && (k = u[++O]);
          var $ = Math.abs(R - k.left), W = Math.abs(R - k.right), H = Math.min($, W);
          this.data[E + R] = Math.max(0, Math.min(255, (k.isDash ? H : -H) + 128));
        }
      }, at.prototype.addDash = function(u, f) {
        var c = f ? 7 : 0, d = 2 * c + 1;
        if (this.nextRow + d > this.height)
          return a.warnOnce("LineAtlas out of space"), null;
        for (var _ = 0, w = 0; w < u.length; w++)
          _ += u[w];
        if (_ !== 0) {
          var E = this.width / _, O = this.getDashRanges(u, this.width, E);
          f ? this.addRoundDash(O, E, c) : this.addRegularDash(O);
        }
        var k = { y: (this.nextRow + c + 0.5) / this.height, height: 2 * c / this.height, width: _ };
        return this.nextRow += d, this.dirty = !0, k;
      }, at.prototype.bind = function(u) {
        var f = u.gl;
        this.texture ? (f.bindTexture(f.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, f.texSubImage2D(f.TEXTURE_2D, 0, 0, 0, this.width, this.height, f.ALPHA, f.UNSIGNED_BYTE, this.data))) : (this.texture = f.createTexture(), f.bindTexture(f.TEXTURE_2D, this.texture), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.REPEAT), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.REPEAT), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.LINEAR), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR), f.texImage2D(f.TEXTURE_2D, 0, f.ALPHA, this.width, this.height, 0, f.ALPHA, f.UNSIGNED_BYTE, this.data));
      };
      var be = function u(f, c) {
        this.workerPool = f, this.actors = [], this.currentActor = 0, this.id = a.uniqueId();
        for (var d = this.workerPool.acquire(this.id), _ = 0; _ < d.length; _++) {
          var w = new u.Actor(d[_], c, this.id);
          w.name = "Worker " + _, this.actors.push(w);
        }
      };
      function Ye(u, f, c) {
        var d = function(_, w) {
          if (_)
            return c(_);
          if (w) {
            var E = a.pick(a.extend(w, u), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            w.vector_layers && (E.vectorLayers = w.vector_layers, E.vectorLayerIds = E.vectorLayers.map(function(O) {
              return O.id;
            })), E.tiles = f.canonicalizeTileset(E, u.url), c(null, E);
          }
        };
        return u.url ? a.getJSON(f.transformRequest(f.normalizeSourceURL(u.url), a.ResourceType.Source), d) : a.browser.frame(function() {
          return d(null, u);
        });
      }
      be.prototype.broadcast = function(u, f, c) {
        a.asyncAll(this.actors, function(d, _) {
          d.send(u, f, _);
        }, c = c || function() {
        });
      }, be.prototype.getActor = function() {
        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
      }, be.prototype.remove = function() {
        this.actors.forEach(function(u) {
          u.remove();
        }), this.actors = [], this.workerPool.release(this.id);
      }, be.Actor = a.Actor;
      var ht = function(u, f, c) {
        this.bounds = a.LngLatBounds.convert(this.validateBounds(u)), this.minzoom = f || 0, this.maxzoom = c || 24;
      };
      ht.prototype.validateBounds = function(u) {
        return Array.isArray(u) && u.length === 4 ? [Math.max(-180, u[0]), Math.max(-90, u[1]), Math.min(180, u[2]), Math.min(90, u[3])] : [-180, -90, 180, 90];
      }, ht.prototype.contains = function(u) {
        var f = Math.pow(2, u.z), c = Math.floor(a.mercatorXfromLng(this.bounds.getWest()) * f), d = Math.floor(a.mercatorYfromLat(this.bounds.getNorth()) * f), _ = Math.ceil(a.mercatorXfromLng(this.bounds.getEast()) * f), w = Math.ceil(a.mercatorYfromLat(this.bounds.getSouth()) * f);
        return u.x >= c && u.x < _ && u.y >= d && u.y < w;
      };
      var vt = function(u) {
        function f(c, d, _, w) {
          if (u.call(this), this.id = c, this.dispatcher = _, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, a.extend(this, a.pick(d, ["url", "scheme", "tileSize", "promoteId"])), this._options = a.extend({ type: "vector" }, d), this._collectResourceTiming = d.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(w);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function() {
          var c = this;
          this._loaded = !1, this.fire(new a.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = Ye(this._options, this.map._requestManager, function(d, _) {
            c._tileJSONRequest = null, c._loaded = !0, d ? c.fire(new a.ErrorEvent(d)) : _ && (a.extend(c, _), _.bounds && (c.tileBounds = new ht(_.bounds, c.minzoom, c.maxzoom)), a.postTurnstileEvent(_.tiles, c.map._requestManager._customAccessToken), a.postMapLoadEvent(_.tiles, c.map._getMapId(), c.map._requestManager._skuToken, c.map._requestManager._customAccessToken), c.fire(new a.Event("data", { dataType: "source", sourceDataType: "metadata" })), c.fire(new a.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }, f.prototype.loaded = function() {
          return this._loaded;
        }, f.prototype.hasTile = function(c) {
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }, f.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, f.prototype.setSourceProperty = function(c) {
          this._tileJSONRequest && this._tileJSONRequest.cancel(), c(), this.map.style.sourceCaches[this.id].clearTiles(), this.load();
        }, f.prototype.setTiles = function(c) {
          var d = this;
          return this.setSourceProperty(function() {
            d._options.tiles = c;
          }), this;
        }, f.prototype.setUrl = function(c) {
          var d = this;
          return this.setSourceProperty(function() {
            d.url = c, d._options.url = c;
          }), this;
        }, f.prototype.onRemove = function() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }, f.prototype.serialize = function() {
          return a.extend({}, this._options);
        }, f.prototype.loadTile = function(c, d) {
          var _ = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme)), w = { request: this.map._requestManager.transformRequest(_, a.ResourceType.Tile), uid: c.uid, tileID: c.tileID, zoom: c.tileID.overscaledZ, tileSize: this.tileSize * c.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: a.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
          function E(O, k) {
            return delete c.request, c.aborted ? d(null) : O && O.status !== 404 ? d(O) : (k && k.resourceTiming && (c.resourceTiming = k.resourceTiming), this.map._refreshExpiredTiles && k && c.setExpiryData(k), c.loadVectorData(k, this.map.painter), a.cacheEntryPossiblyAdded(this.dispatcher), d(null), void (c.reloadCallback && (this.loadTile(c, c.reloadCallback), c.reloadCallback = null)));
          }
          w.request.collectResourceTiming = this._collectResourceTiming, c.actor && c.state !== "expired" ? c.state === "loading" ? c.reloadCallback = d : c.request = c.actor.send("reloadTile", w, E.bind(this)) : (c.actor = this.dispatcher.getActor(), c.request = c.actor.send("loadTile", w, E.bind(this)));
        }, f.prototype.abortTile = function(c) {
          c.request && (c.request.cancel(), delete c.request), c.actor && c.actor.send("abortTile", { uid: c.uid, type: this.type, source: this.id }, void 0);
        }, f.prototype.unloadTile = function(c) {
          c.unloadVectorData(), c.actor && c.actor.send("removeTile", { uid: c.uid, type: this.type, source: this.id }, void 0);
        }, f.prototype.hasTransition = function() {
          return !1;
        }, f;
      }(a.Evented), Pt = function(u) {
        function f(c, d, _, w) {
          u.call(this), this.id = c, this.dispatcher = _, this.setEventedParent(w), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = a.extend({ type: "raster" }, d), a.extend(this, a.pick(d, ["url", "scheme", "tileSize"]));
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function() {
          var c = this;
          this._loaded = !1, this.fire(new a.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = Ye(this._options, this.map._requestManager, function(d, _) {
            c._tileJSONRequest = null, c._loaded = !0, d ? c.fire(new a.ErrorEvent(d)) : _ && (a.extend(c, _), _.bounds && (c.tileBounds = new ht(_.bounds, c.minzoom, c.maxzoom)), a.postTurnstileEvent(_.tiles), a.postMapLoadEvent(_.tiles, c.map._getMapId(), c.map._requestManager._skuToken), c.fire(new a.Event("data", { dataType: "source", sourceDataType: "metadata" })), c.fire(new a.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }, f.prototype.loaded = function() {
          return this._loaded;
        }, f.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, f.prototype.onRemove = function() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }, f.prototype.serialize = function() {
          return a.extend({}, this._options);
        }, f.prototype.hasTile = function(c) {
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }, f.prototype.loadTile = function(c, d) {
          var _ = this, w = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
          c.request = a.getImage(this.map._requestManager.transformRequest(w, a.ResourceType.Tile), function(E, O) {
            if (delete c.request, c.aborted)
              c.state = "unloaded", d(null);
            else if (E)
              c.state = "errored", d(E);
            else if (O) {
              _.map._refreshExpiredTiles && c.setExpiryData(O), delete O.cacheControl, delete O.expires;
              var k = _.map.painter.context, R = k.gl;
              c.texture = _.map.painter.getTileTexture(O.width), c.texture ? c.texture.update(O, { useMipmap: !0 }) : (c.texture = new a.Texture(k, O, R.RGBA, { useMipmap: !0 }), c.texture.bind(R.LINEAR, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), k.extTextureFilterAnisotropic && R.texParameterf(R.TEXTURE_2D, k.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, k.extTextureFilterAnisotropicMax)), c.state = "loaded", a.cacheEntryPossiblyAdded(_.dispatcher), d(null);
            }
          });
        }, f.prototype.abortTile = function(c, d) {
          c.request && (c.request.cancel(), delete c.request), d();
        }, f.prototype.unloadTile = function(c, d) {
          c.texture && this.map.painter.saveTileTexture(c.texture), d();
        }, f.prototype.hasTransition = function() {
          return !1;
        }, f;
      }(a.Evented), tr = function(u) {
        function f(c, d, _, w) {
          u.call(this, c, d, _, w), this.type = "raster-dem", this.maxzoom = 22, this._options = a.extend({ type: "raster-dem" }, d), this.encoding = d.encoding || "mapbox";
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.serialize = function() {
          return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
        }, f.prototype.loadTile = function(c, d) {
          var _ = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
          function w(E, O) {
            E && (c.state = "errored", d(E)), O && (c.dem = O, c.needsHillshadePrepare = !0, c.state = "loaded", d(null));
          }
          c.request = a.getImage(this.map._requestManager.transformRequest(_, a.ResourceType.Tile), function(E, O) {
            if (delete c.request, c.aborted)
              c.state = "unloaded", d(null);
            else if (E)
              c.state = "errored", d(E);
            else if (O) {
              this.map._refreshExpiredTiles && c.setExpiryData(O), delete O.cacheControl, delete O.expires;
              var k = a.window.ImageBitmap && O instanceof a.window.ImageBitmap && a.offscreenCanvasSupported() ? O : a.browser.getImageData(O, 1), R = { uid: c.uid, coord: c.tileID, source: this.id, rawImageData: k, encoding: this.encoding };
              c.actor && c.state !== "expired" || (c.actor = this.dispatcher.getActor(), c.actor.send("loadDEMTile", R, w.bind(this)));
            }
          }.bind(this)), c.neighboringTiles = this._getNeighboringTiles(c.tileID);
        }, f.prototype._getNeighboringTiles = function(c) {
          var d = c.canonical, _ = Math.pow(2, d.z), w = (d.x - 1 + _) % _, E = d.x === 0 ? c.wrap - 1 : c.wrap, O = (d.x + 1 + _) % _, k = d.x + 1 === _ ? c.wrap + 1 : c.wrap, R = {};
          return R[new a.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y).key] = { backfilled: !1 }, R[new a.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y).key] = { backfilled: !1 }, d.y > 0 && (R[new a.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y - 1).key] = { backfilled: !1 }, R[new a.OverscaledTileID(c.overscaledZ, c.wrap, d.z, d.x, d.y - 1).key] = { backfilled: !1 }, R[new a.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y - 1).key] = { backfilled: !1 }), d.y + 1 < _ && (R[new a.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y + 1).key] = { backfilled: !1 }, R[new a.OverscaledTileID(c.overscaledZ, c.wrap, d.z, d.x, d.y + 1).key] = { backfilled: !1 }, R[new a.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y + 1).key] = { backfilled: !1 }), R;
        }, f.prototype.unloadTile = function(c) {
          c.demTexture && this.map.painter.saveTileTexture(c.demTexture), c.fbo && (c.fbo.destroy(), delete c.fbo), c.dem && delete c.dem, delete c.neighboringTiles, c.state = "unloaded", c.actor && c.actor.send("removeDEMTile", { uid: c.uid, source: this.id });
        }, f;
      }(Pt), kn = function(u) {
        function f(c, d, _, w) {
          u.call(this), this.id = c, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._loaded = !1, this.actor = _.getActor(), this.setEventedParent(w), this._data = d.data, this._options = a.extend({}, d), this._collectResourceTiming = d.collectResourceTiming, this._resourceTiming = [], d.maxzoom !== void 0 && (this.maxzoom = d.maxzoom), d.type && (this.type = d.type), d.attribution && (this.attribution = d.attribution), this.promoteId = d.promoteId;
          var E = a.EXTENT / this.tileSize;
          this.workerOptions = a.extend({ source: this.id, cluster: d.cluster || !1, geojsonVtOptions: { buffer: (d.buffer !== void 0 ? d.buffer : 128) * E, tolerance: (d.tolerance !== void 0 ? d.tolerance : 0.375) * E, extent: a.EXTENT, maxZoom: this.maxzoom, lineMetrics: d.lineMetrics || !1, generateId: d.generateId || !1 }, superclusterOptions: { maxZoom: d.clusterMaxZoom !== void 0 ? Math.min(d.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, minPoints: Math.max(2, d.clusterMinPoints || 2), extent: a.EXTENT, radius: (d.clusterRadius || 50) * E, log: !1, generateId: d.generateId || !1 }, clusterProperties: d.clusterProperties, filter: d.filter }, d.workerOptions);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function() {
          var c = this;
          this.fire(new a.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(d) {
            if (d)
              c.fire(new a.ErrorEvent(d));
            else {
              var _ = { dataType: "source", sourceDataType: "metadata" };
              c._collectResourceTiming && c._resourceTiming && c._resourceTiming.length > 0 && (_.resourceTiming = c._resourceTiming, c._resourceTiming = []), c.fire(new a.Event("data", _));
            }
          });
        }, f.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, f.prototype.setData = function(c) {
          var d = this;
          return this._data = c, this.fire(new a.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(_) {
            if (_)
              d.fire(new a.ErrorEvent(_));
            else {
              var w = { dataType: "source", sourceDataType: "content" };
              d._collectResourceTiming && d._resourceTiming && d._resourceTiming.length > 0 && (w.resourceTiming = d._resourceTiming, d._resourceTiming = []), d.fire(new a.Event("data", w));
            }
          }), this;
        }, f.prototype.getClusterExpansionZoom = function(c, d) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: c, source: this.id }, d), this;
        }, f.prototype.getClusterChildren = function(c, d) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: c, source: this.id }, d), this;
        }, f.prototype.getClusterLeaves = function(c, d, _, w) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: c, limit: d, offset: _ }, w), this;
        }, f.prototype._updateWorkerData = function(c) {
          var d = this;
          this._loaded = !1;
          var _ = a.extend({}, this.workerOptions), w = this._data;
          typeof w == "string" ? (_.request = this.map._requestManager.transformRequest(a.browser.resolveURL(w), a.ResourceType.Source), _.request.collectResourceTiming = this._collectResourceTiming) : _.data = JSON.stringify(w), this.actor.send(this.type + ".loadData", _, function(E, O) {
            d._removed || O && O.abandoned || (d._loaded = !0, O && O.resourceTiming && O.resourceTiming[d.id] && (d._resourceTiming = O.resourceTiming[d.id].slice(0)), d.actor.send(d.type + ".coalesce", { source: _.source }, null), c(E));
          });
        }, f.prototype.loaded = function() {
          return this._loaded;
        }, f.prototype.loadTile = function(c, d) {
          var _ = this, w = c.actor ? "reloadTile" : "loadTile";
          c.actor = this.actor, c.request = this.actor.send(w, { type: this.type, uid: c.uid, tileID: c.tileID, zoom: c.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: a.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, function(E, O) {
            return delete c.request, c.unloadVectorData(), c.aborted ? d(null) : E ? d(E) : (c.loadVectorData(O, _.map.painter, w === "reloadTile"), d(null));
          });
        }, f.prototype.abortTile = function(c) {
          c.request && (c.request.cancel(), delete c.request), c.aborted = !0;
        }, f.prototype.unloadTile = function(c) {
          c.unloadVectorData(), this.actor.send("removeTile", { uid: c.uid, type: this.type, source: this.id });
        }, f.prototype.onRemove = function() {
          this._removed = !0, this.actor.send("removeSource", { type: this.type, source: this.id });
        }, f.prototype.serialize = function() {
          return a.extend({}, this._options, { type: this.type, data: this._data });
        }, f.prototype.hasTransition = function() {
          return !1;
        }, f;
      }(a.Evented), Rr = a.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]), pr = function(u) {
        function f(c, d, _, w) {
          u.call(this), this.id = c, this.dispatcher = _, this.coordinates = d.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(w), this.options = d;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function(c, d) {
          var _ = this;
          this._loaded = !1, this.fire(new a.Event("dataloading", { dataType: "source" })), this.url = this.options.url, a.getImage(this.map._requestManager.transformRequest(this.url, a.ResourceType.Image), function(w, E) {
            _._loaded = !0, w ? _.fire(new a.ErrorEvent(w)) : E && (_.image = E, c && (_.coordinates = c), d && d(), _._finishLoading());
          });
        }, f.prototype.loaded = function() {
          return this._loaded;
        }, f.prototype.updateImage = function(c) {
          var d = this;
          return this.image && c.url ? (this.options.url = c.url, this.load(c.coordinates, function() {
            d.texture = null;
          }), this) : this;
        }, f.prototype._finishLoading = function() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new a.Event("data", { dataType: "source", sourceDataType: "metadata" })));
        }, f.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, f.prototype.setCoordinates = function(c) {
          var d = this;
          this.coordinates = c;
          var _ = c.map(a.MercatorCoordinate.fromLngLat);
          this.tileID = function(E) {
            for (var O = 1 / 0, k = 1 / 0, R = -1 / 0, $ = -1 / 0, W = 0, H = E; W < H.length; W += 1) {
              var ne = H[W];
              O = Math.min(O, ne.x), k = Math.min(k, ne.y), R = Math.max(R, ne.x), $ = Math.max($, ne.y);
            }
            var te = Math.max(R - O, $ - k), ue = Math.max(0, Math.floor(-Math.log(te) / Math.LN2)), Y = Math.pow(2, ue);
            return new a.CanonicalTileID(ue, Math.floor((O + R) / 2 * Y), Math.floor((k + $) / 2 * Y));
          }(_), this.minzoom = this.maxzoom = this.tileID.z;
          var w = _.map(function(E) {
            return d.tileID.getTilePoint(E)._round();
          });
          return this._boundsArray = new a.StructArrayLayout4i8(), this._boundsArray.emplaceBack(w[0].x, w[0].y, 0, 0), this._boundsArray.emplaceBack(w[1].x, w[1].y, a.EXTENT, 0), this._boundsArray.emplaceBack(w[3].x, w[3].y, 0, a.EXTENT), this._boundsArray.emplaceBack(w[2].x, w[2].y, a.EXTENT, a.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new a.Event("data", { dataType: "source", sourceDataType: "content" })), this;
        }, f.prototype.prepare = function() {
          if (Object.keys(this.tiles).length !== 0 && this.image) {
            var c = this.map.painter.context, d = c.gl;
            for (var _ in this.boundsBuffer || (this.boundsBuffer = c.createVertexBuffer(this._boundsArray, Rr.members)), this.boundsSegments || (this.boundsSegments = a.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new a.Texture(c, this.image, d.RGBA), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE)), this.tiles) {
              var w = this.tiles[_];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture);
            }
          }
        }, f.prototype.loadTile = function(c, d) {
          this.tileID && this.tileID.equals(c.tileID.canonical) ? (this.tiles[String(c.tileID.wrap)] = c, c.buckets = {}, d(null)) : (c.state = "errored", d(null));
        }, f.prototype.serialize = function() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }, f.prototype.hasTransition = function() {
          return !1;
        }, f;
      }(a.Evented), Zn = function(u) {
        function f(c, d, _, w) {
          u.call(this, c, d, _, w), this.roundZoom = !0, this.type = "video", this.options = d;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function() {
          var c = this;
          this._loaded = !1;
          var d = this.options;
          this.urls = [];
          for (var _ = 0, w = d.urls; _ < w.length; _ += 1)
            this.urls.push(this.map._requestManager.transformRequest(w[_], a.ResourceType.Source).url);
          a.getVideo(this.urls, function(E, O) {
            c._loaded = !0, E ? c.fire(new a.ErrorEvent(E)) : O && (c.video = O, c.video.loop = !0, c.video.setAttribute("playsinline", ""), c.video.addEventListener("playing", function() {
              c.map.triggerRepaint();
            }), c.map && c.video.play(), c._finishLoading());
          });
        }, f.prototype.pause = function() {
          this.video && this.video.pause();
        }, f.prototype.play = function() {
          this.video && this.video.play();
        }, f.prototype.seek = function(c) {
          if (this.video) {
            var d = this.video.seekable;
            c < d.start(0) || c > d.end(0) ? this.fire(new a.ErrorEvent(new a.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + d.start(0) + " and " + d.end(0) + "-second mark."))) : this.video.currentTime = c;
          }
        }, f.prototype.getVideo = function() {
          return this.video;
        }, f.prototype.onAdd = function(c) {
          this.map || (this.map = c, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }, f.prototype.prepare = function() {
          if (!(Object.keys(this.tiles).length === 0 || this.video.readyState < 2)) {
            var c = this.map.painter.context, d = c.gl;
            for (var _ in this.boundsBuffer || (this.boundsBuffer = c.createVertexBuffer(this._boundsArray, Rr.members)), this.boundsSegments || (this.boundsSegments = a.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE), d.texSubImage2D(d.TEXTURE_2D, 0, 0, 0, d.RGBA, d.UNSIGNED_BYTE, this.video)) : (this.texture = new a.Texture(c, this.video, d.RGBA), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE)), this.tiles) {
              var w = this.tiles[_];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture);
            }
          }
        }, f.prototype.serialize = function() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }, f.prototype.hasTransition = function() {
          return this.video && !this.video.paused;
        }, f;
      }(pr), zr = function(u) {
        function f(c, d, _, w) {
          u.call(this, c, d, _, w), d.coordinates ? Array.isArray(d.coordinates) && d.coordinates.length === 4 && !d.coordinates.some(function(E) {
            return !Array.isArray(E) || E.length !== 2 || E.some(function(O) {
              return typeof O != "number";
            });
          }) || this.fire(new a.ErrorEvent(new a.ValidationError("sources." + c, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new a.ErrorEvent(new a.ValidationError("sources." + c, null, 'missing required property "coordinates"'))), d.animate && typeof d.animate != "boolean" && this.fire(new a.ErrorEvent(new a.ValidationError("sources." + c, null, 'optional "animate" property must be a boolean value'))), d.canvas ? typeof d.canvas == "string" || d.canvas instanceof a.window.HTMLCanvasElement || this.fire(new a.ErrorEvent(new a.ValidationError("sources." + c, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new a.ErrorEvent(new a.ValidationError("sources." + c, null, 'missing required property "canvas"'))), this.options = d, this.animate = d.animate === void 0 || d.animate;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function() {
          this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof a.window.HTMLCanvasElement ? this.options.canvas : a.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new a.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = !0, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = !1);
          }, this._finishLoading());
        }, f.prototype.getCanvas = function() {
          return this.canvas;
        }, f.prototype.onAdd = function(c) {
          this.map = c, this.load(), this.canvas && this.animate && this.play();
        }, f.prototype.onRemove = function() {
          this.pause();
        }, f.prototype.prepare = function() {
          var c = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, c = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, c = !0), !this._hasInvalidDimensions() && Object.keys(this.tiles).length !== 0) {
            var d = this.map.painter.context, _ = d.gl;
            for (var w in this.boundsBuffer || (this.boundsBuffer = d.createVertexBuffer(this._boundsArray, Rr.members)), this.boundsSegments || (this.boundsSegments = a.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (c || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new a.Texture(d, this.canvas, _.RGBA, { premultiply: !0 }), this.tiles) {
              var E = this.tiles[w];
              E.state !== "loaded" && (E.state = "loaded", E.texture = this.texture);
            }
          }
        }, f.prototype.serialize = function() {
          return { type: "canvas", coordinates: this.coordinates };
        }, f.prototype.hasTransition = function() {
          return this._playing;
        }, f.prototype._hasInvalidDimensions = function() {
          for (var c = 0, d = [this.canvas.width, this.canvas.height]; c < d.length; c += 1) {
            var _ = d[c];
            if (isNaN(_) || _ <= 0)
              return !0;
          }
          return !1;
        }, f;
      }(pr), Fi = { vector: vt, raster: Pt, "raster-dem": tr, geojson: kn, video: Zn, image: pr, canvas: zr };
      function $r(u, f) {
        var c = a.identity([]);
        return a.translate(c, c, [1, 1, 0]), a.scale(c, c, [0.5 * u.width, 0.5 * u.height, 1]), a.multiply(c, c, u.calculatePosMatrix(f.toUnwrapped()));
      }
      function kr(u, f, c, d, _, w) {
        var E = function(ue, Y, le) {
          if (ue)
            for (var me = 0, xe = ue; me < xe.length; me += 1) {
              var Ae = Y[xe[me]];
              if (Ae && Ae.source === le && Ae.type === "fill-extrusion")
                return !0;
            }
          else
            for (var Me in Y) {
              var ke = Y[Me];
              if (ke.source === le && ke.type === "fill-extrusion")
                return !0;
            }
          return !1;
        }(_ && _.layers, f, u.id), O = w.maxPitchScaleFactor(), k = u.tilesIn(d, O, E);
        k.sort(Vn);
        for (var R = [], $ = 0, W = k; $ < W.length; $ += 1) {
          var H = W[$];
          R.push({ wrappedTileID: H.tileID.wrapped().key, queryResults: H.tile.queryRenderedFeatures(f, c, u._state, H.queryGeometry, H.cameraQueryGeometry, H.scale, _, w, O, $r(u.transform, H.tileID)) });
        }
        var ne = function(ue) {
          for (var Y = {}, le = {}, me = 0, xe = ue; me < xe.length; me += 1) {
            var Ae = xe[me], Me = Ae.queryResults, ke = Ae.wrappedTileID, je = le[ke] = le[ke] || {};
            for (var nt in Me)
              for (var tt = Me[nt], gt = je[nt] = je[nt] || {}, Dt = Y[nt] = Y[nt] || [], Bt = 0, zt = tt; Bt < zt.length; Bt += 1) {
                var Ir = zt[Bt];
                gt[Ir.featureIndex] || (gt[Ir.featureIndex] = !0, Dt.push(Ir));
              }
          }
          return Y;
        }(R);
        for (var te in ne)
          ne[te].forEach(function(ue) {
            var Y = ue.feature, le = u.getFeatureState(Y.layer["source-layer"], Y.id);
            Y.source = Y.layer.source, Y.layer["source-layer"] && (Y.sourceLayer = Y.layer["source-layer"]), Y.state = le;
          });
        return ne;
      }
      function Vn(u, f) {
        var c = u.tileID, d = f.tileID;
        return c.overscaledZ - d.overscaledZ || c.canonical.y - d.canonical.y || c.wrap - d.wrap || c.canonical.x - d.canonical.x;
      }
      var Tr = function(u, f) {
        this.max = u, this.onRemove = f, this.reset();
      };
      Tr.prototype.reset = function() {
        for (var u in this.data)
          for (var f = 0, c = this.data[u]; f < c.length; f += 1) {
            var d = c[f];
            d.timeout && clearTimeout(d.timeout), this.onRemove(d.value);
          }
        return this.data = {}, this.order = [], this;
      }, Tr.prototype.add = function(u, f, c) {
        var d = this, _ = u.wrapped().key;
        this.data[_] === void 0 && (this.data[_] = []);
        var w = { value: f, timeout: void 0 };
        if (c !== void 0 && (w.timeout = setTimeout(function() {
          d.remove(u, w);
        }, c)), this.data[_].push(w), this.order.push(_), this.order.length > this.max) {
          var E = this._getAndRemoveByKey(this.order[0]);
          E && this.onRemove(E);
        }
        return this;
      }, Tr.prototype.has = function(u) {
        return u.wrapped().key in this.data;
      }, Tr.prototype.getAndRemove = function(u) {
        return this.has(u) ? this._getAndRemoveByKey(u.wrapped().key) : null;
      }, Tr.prototype._getAndRemoveByKey = function(u) {
        var f = this.data[u].shift();
        return f.timeout && clearTimeout(f.timeout), this.data[u].length === 0 && delete this.data[u], this.order.splice(this.order.indexOf(u), 1), f.value;
      }, Tr.prototype.getByKey = function(u) {
        var f = this.data[u];
        return f ? f[0].value : null;
      }, Tr.prototype.get = function(u) {
        return this.has(u) ? this.data[u.wrapped().key][0].value : null;
      }, Tr.prototype.remove = function(u, f) {
        if (!this.has(u))
          return this;
        var c = u.wrapped().key, d = f === void 0 ? 0 : this.data[c].indexOf(f), _ = this.data[c][d];
        return this.data[c].splice(d, 1), _.timeout && clearTimeout(_.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(_.value), this.order.splice(this.order.indexOf(c), 1), this;
      }, Tr.prototype.setMaxSize = function(u) {
        for (this.max = u; this.order.length > this.max; ) {
          var f = this._getAndRemoveByKey(this.order[0]);
          f && this.onRemove(f);
        }
        return this;
      }, Tr.prototype.filter = function(u) {
        var f = [];
        for (var c in this.data)
          for (var d = 0, _ = this.data[c]; d < _.length; d += 1) {
            var w = _[d];
            u(w.value) || f.push(w);
          }
        for (var E = 0, O = f; E < O.length; E += 1) {
          var k = O[E];
          this.remove(k.value.tileID, k);
        }
      };
      var Sn = function(u, f, c) {
        this.context = u;
        var d = u.gl;
        this.buffer = d.createBuffer(), this.dynamicDraw = Boolean(c), this.context.unbindVAO(), u.bindElementBuffer.set(this.buffer), d.bufferData(d.ELEMENT_ARRAY_BUFFER, f.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete f.arrayBuffer;
      };
      Sn.prototype.bind = function() {
        this.context.bindElementBuffer.set(this.buffer);
      }, Sn.prototype.updateData = function(u) {
        var f = this.context.gl;
        this.context.unbindVAO(), this.bind(), f.bufferSubData(f.ELEMENT_ARRAY_BUFFER, 0, u.arrayBuffer);
      }, Sn.prototype.destroy = function() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      };
      var oi = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, Un = function(u, f, c, d) {
        this.length = f.length, this.attributes = c, this.itemSize = f.bytesPerElement, this.dynamicDraw = d, this.context = u;
        var _ = u.gl;
        this.buffer = _.createBuffer(), u.bindVertexBuffer.set(this.buffer), _.bufferData(_.ARRAY_BUFFER, f.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete f.arrayBuffer;
      };
      Un.prototype.bind = function() {
        this.context.bindVertexBuffer.set(this.buffer);
      }, Un.prototype.updateData = function(u) {
        var f = this.context.gl;
        this.bind(), f.bufferSubData(f.ARRAY_BUFFER, 0, u.arrayBuffer);
      }, Un.prototype.enableAttributes = function(u, f) {
        for (var c = 0; c < this.attributes.length; c++) {
          var d = f.attributes[this.attributes[c].name];
          d !== void 0 && u.enableVertexAttribArray(d);
        }
      }, Un.prototype.setVertexAttribPointers = function(u, f, c) {
        for (var d = 0; d < this.attributes.length; d++) {
          var _ = this.attributes[d], w = f.attributes[_.name];
          w !== void 0 && u.vertexAttribPointer(w, _.components, u[oi[_.type]], !1, this.itemSize, _.offset + this.itemSize * (c || 0));
        }
      }, Un.prototype.destroy = function() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      };
      var K = function(u) {
        this.gl = u.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
      };
      K.prototype.get = function() {
        return this.current;
      }, K.prototype.set = function(u) {
      }, K.prototype.getDefault = function() {
        return this.default;
      }, K.prototype.setDefault = function() {
        this.set(this.default);
      };
      var ye = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return a.Color.transparent;
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c.r !== d.r || c.g !== d.g || c.b !== d.b || c.a !== d.a || this.dirty) && (this.gl.clearColor(c.r, c.g, c.b, c.a), this.current = c, this.dirty = !1);
        }, f;
      }(K), Ne = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return 1;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.clearDepth(c), this.current = c, this.dirty = !1);
        }, f;
      }(K), qe = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return 0;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.clearStencil(c), this.current = c, this.dirty = !1);
        }, f;
      }(K), We = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return [!0, !0, !0, !0];
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || c[3] !== d[3] || this.dirty) && (this.gl.colorMask(c[0], c[1], c[2], c[3]), this.current = c, this.dirty = !1);
        }, f;
      }(K), rt = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !0;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.depthMask(c), this.current = c, this.dirty = !1);
        }, f;
      }(K), mt = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return 255;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.stencilMask(c), this.current = c, this.dirty = !1);
        }, f;
      }(K), et = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c.func !== d.func || c.ref !== d.ref || c.mask !== d.mask || this.dirty) && (this.gl.stencilFunc(c.func, c.ref, c.mask), this.current = c, this.dirty = !1);
        }, f;
      }(K), ut = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          var c = this.gl;
          return [c.KEEP, c.KEEP, c.KEEP];
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || this.dirty) && (this.gl.stencilOp(c[0], c[1], c[2]), this.current = c, this.dirty = !1);
        }, f;
      }(K), Qe = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.STENCIL_TEST) : d.disable(d.STENCIL_TEST), this.current = c, this.dirty = !1;
          }
        }, f;
      }(K), It = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return [0, 1];
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || this.dirty) && (this.gl.depthRange(c[0], c[1]), this.current = c, this.dirty = !1);
        }, f;
      }(K), bt = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.DEPTH_TEST) : d.disable(d.DEPTH_TEST), this.current = c, this.dirty = !1;
          }
        }, f;
      }(K), kt = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return this.gl.LESS;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.depthFunc(c), this.current = c, this.dirty = !1);
        }, f;
      }(K), Ut = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.BLEND) : d.disable(d.BLEND), this.current = c, this.dirty = !1;
          }
        }, f;
      }(K), dr = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          var c = this.gl;
          return [c.ONE, c.ZERO];
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || this.dirty) && (this.gl.blendFunc(c[0], c[1]), this.current = c, this.dirty = !1);
        }, f;
      }(K), Vr = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return a.Color.transparent;
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c.r !== d.r || c.g !== d.g || c.b !== d.b || c.a !== d.a || this.dirty) && (this.gl.blendColor(c.r, c.g, c.b, c.a), this.current = c, this.dirty = !1);
        }, f;
      }(K), Lr = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return this.gl.FUNC_ADD;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.blendEquation(c), this.current = c, this.dirty = !1);
        }, f;
      }(K), Jr = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.CULL_FACE) : d.disable(d.CULL_FACE), this.current = c, this.dirty = !1;
          }
        }, f;
      }(K), Xn = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return this.gl.BACK;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.cullFace(c), this.current = c, this.dirty = !1);
        }, f;
      }(K), Bi = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return this.gl.CCW;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.frontFace(c), this.current = c, this.dirty = !1);
        }, f;
      }(K), so = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.useProgram(c), this.current = c, this.dirty = !1);
        }, f;
      }(K), Kn = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return this.gl.TEXTURE0;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.activeTexture(c), this.current = c, this.dirty = !1);
        }, f;
      }(K), Li = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          var c = this.gl;
          return [0, 0, c.drawingBufferWidth, c.drawingBufferHeight];
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || c[3] !== d[3] || this.dirty) && (this.gl.viewport(c[0], c[1], c[2], c[3]), this.current = c, this.dirty = !1);
        }, f;
      }(K), Tn = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindFramebuffer(d.FRAMEBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(K), ai = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindRenderbuffer(d.RENDERBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(K), Fa = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindTexture(d.TEXTURE_2D, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(K), Uo = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindBuffer(d.ARRAY_BUFFER, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(K), Ba = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          var d = this.gl;
          d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, c), this.current = c, this.dirty = !1;
        }, f;
      }(K), na = function(u) {
        function f(c) {
          u.call(this, c), this.vao = c.extVertexArrayObject;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          this.vao && (c !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(c), this.current = c, this.dirty = !1);
        }, f;
      }(K), an = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return 4;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_ALIGNMENT, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(K), So = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(K), ol = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(K), bn = function(u) {
        function f(c, d) {
          u.call(this, c), this.context = c, this.parent = d;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f;
      }(K), N = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.setDirty = function() {
          this.dirty = !0;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            this.context.bindFramebuffer.set(this.parent);
            var d = this.gl;
            d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, c, 0), this.current = c, this.dirty = !1;
          }
        }, f;
      }(bn), F = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            this.context.bindFramebuffer.set(this.parent);
            var d = this.gl;
            d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.RENDERBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(bn), U = function(u, f, c, d) {
        this.context = u, this.width = f, this.height = c;
        var _ = this.framebuffer = u.gl.createFramebuffer();
        this.colorAttachment = new N(u, _), d && (this.depthAttachment = new F(u, _));
      };
      U.prototype.destroy = function() {
        var u = this.context.gl, f = this.colorAttachment.get();
        if (f && u.deleteTexture(f), this.depthAttachment) {
          var c = this.depthAttachment.get();
          c && u.deleteRenderbuffer(c);
        }
        u.deleteFramebuffer(this.framebuffer);
      };
      var Z = function(u, f, c) {
        this.func = u, this.mask = f, this.range = c;
      };
      Z.ReadOnly = !1, Z.ReadWrite = !0, Z.disabled = new Z(519, Z.ReadOnly, [0, 1]);
      var Q = function(u, f, c, d, _, w) {
        this.test = u, this.ref = f, this.mask = c, this.fail = d, this.depthFail = _, this.pass = w;
      };
      Q.disabled = new Q({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
      var pe = function(u, f, c) {
        this.blendFunction = u, this.blendColor = f, this.mask = c;
      };
      pe.disabled = new pe(pe.Replace = [1, 0], a.Color.transparent, [!1, !1, !1, !1]), pe.unblended = new pe(pe.Replace, a.Color.transparent, [!0, !0, !0, !0]), pe.alphaBlended = new pe([1, 771], a.Color.transparent, [!0, !0, !0, !0]);
      var de = function(u, f, c) {
        this.enable = u, this.mode = f, this.frontFace = c;
      };
      de.disabled = new de(!1, 1029, 2305), de.backCCW = new de(!0, 1029, 2305);
      var G = function(u) {
        this.gl = u, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new ye(this), this.clearDepth = new Ne(this), this.clearStencil = new qe(this), this.colorMask = new We(this), this.depthMask = new rt(this), this.stencilMask = new mt(this), this.stencilFunc = new et(this), this.stencilOp = new ut(this), this.stencilTest = new Qe(this), this.depthRange = new It(this), this.depthTest = new bt(this), this.depthFunc = new kt(this), this.blend = new Ut(this), this.blendFunc = new dr(this), this.blendColor = new Vr(this), this.blendEquation = new Lr(this), this.cullFace = new Jr(this), this.cullFaceSide = new Xn(this), this.frontFace = new Bi(this), this.program = new so(this), this.activeTexture = new Kn(this), this.viewport = new Li(this), this.bindFramebuffer = new Tn(this), this.bindRenderbuffer = new ai(this), this.bindTexture = new Fa(this), this.bindVertexBuffer = new Uo(this), this.bindElementBuffer = new Ba(this), this.bindVertexArrayOES = this.extVertexArrayObject && new na(this), this.pixelStoreUnpack = new an(this), this.pixelStoreUnpackPremultiplyAlpha = new So(this), this.pixelStoreUnpackFlipY = new ol(this), this.extTextureFilterAnisotropic = u.getExtension("EXT_texture_filter_anisotropic") || u.getExtension("MOZ_EXT_texture_filter_anisotropic") || u.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = u.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = u.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (u.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = u.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = u.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = u.getParameter(u.MAX_TEXTURE_SIZE);
      };
      G.prototype.setDefault = function() {
        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
      }, G.prototype.setDirty = function() {
        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
      }, G.prototype.createIndexBuffer = function(u, f) {
        return new Sn(this, u, f);
      }, G.prototype.createVertexBuffer = function(u, f, c) {
        return new Un(this, u, f, c);
      }, G.prototype.createRenderbuffer = function(u, f, c) {
        var d = this.gl, _ = d.createRenderbuffer();
        return this.bindRenderbuffer.set(_), d.renderbufferStorage(d.RENDERBUFFER, u, f, c), this.bindRenderbuffer.set(null), _;
      }, G.prototype.createFramebuffer = function(u, f, c) {
        return new U(this, u, f, c);
      }, G.prototype.clear = function(u) {
        var f = u.color, c = u.depth, d = this.gl, _ = 0;
        f && (_ |= d.COLOR_BUFFER_BIT, this.clearColor.set(f), this.colorMask.set([!0, !0, !0, !0])), c !== void 0 && (_ |= d.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(c), this.depthMask.set(!0)), d.clear(_);
      }, G.prototype.setCullFace = function(u) {
        u.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(u.mode), this.frontFace.set(u.frontFace));
      }, G.prototype.setDepthMode = function(u) {
        u.func !== this.gl.ALWAYS || u.mask ? (this.depthTest.set(!0), this.depthFunc.set(u.func), this.depthMask.set(u.mask), this.depthRange.set(u.range)) : this.depthTest.set(!1);
      }, G.prototype.setStencilMode = function(u) {
        u.test.func !== this.gl.ALWAYS || u.mask ? (this.stencilTest.set(!0), this.stencilMask.set(u.mask), this.stencilOp.set([u.fail, u.depthFail, u.pass]), this.stencilFunc.set({ func: u.test.func, ref: u.ref, mask: u.test.mask })) : this.stencilTest.set(!1);
      }, G.prototype.setColorMode = function(u) {
        a.deepEqual(u.blendFunction, pe.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(u.blendFunction), this.blendColor.set(u.blendColor)), this.colorMask.set(u.mask);
      }, G.prototype.unbindVAO = function() {
        this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
      };
      var ie = function(u) {
        function f(c, d, _) {
          var w = this;
          u.call(this), this.id = c, this.dispatcher = _, this.on("data", function(E) {
            E.dataType === "source" && E.sourceDataType === "metadata" && (w._sourceLoaded = !0), w._sourceLoaded && !w._paused && E.dataType === "source" && E.sourceDataType === "content" && (w.reload(), w.transform && w.update(w.transform));
          }), this.on("error", function() {
            w._sourceErrored = !0;
          }), this._source = function(E, O, k, R) {
            var $ = new Fi[O.type](E, O, k, R);
            if ($.id !== E)
              throw new Error("Expected Source id to be " + E + " instead of " + $.id);
            return a.bindAll(["load", "abort", "unload", "serialize", "prepare"], $), $;
          }(c, d, _, this), this._tiles = {}, this._cache = new Tr(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new a.SourceFeatureState();
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.onAdd = function(c) {
          this.map = c, this._maxTileCacheSize = c ? c._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(c);
        }, f.prototype.onRemove = function(c) {
          this._source && this._source.onRemove && this._source.onRemove(c);
        }, f.prototype.loaded = function() {
          if (this._sourceErrored)
            return !0;
          if (!this._sourceLoaded || !this._source.loaded())
            return !1;
          for (var c in this._tiles) {
            var d = this._tiles[c];
            if (d.state !== "loaded" && d.state !== "errored")
              return !1;
          }
          return !0;
        }, f.prototype.getSource = function() {
          return this._source;
        }, f.prototype.pause = function() {
          this._paused = !0;
        }, f.prototype.resume = function() {
          if (this._paused) {
            var c = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, c && this.reload(), this.transform && this.update(this.transform);
          }
        }, f.prototype._loadTile = function(c, d) {
          return this._source.loadTile(c, d);
        }, f.prototype._unloadTile = function(c) {
          if (this._source.unloadTile)
            return this._source.unloadTile(c, function() {
            });
        }, f.prototype._abortTile = function(c) {
          if (this._source.abortTile)
            return this._source.abortTile(c, function() {
            });
        }, f.prototype.serialize = function() {
          return this._source.serialize();
        }, f.prototype.prepare = function(c) {
          for (var d in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {
            var _ = this._tiles[d];
            _.upload(c), _.prepare(this.map.style.imageManager);
          }
        }, f.prototype.getIds = function() {
          return a.values(this._tiles).map(function(c) {
            return c.tileID;
          }).sort(_e).map(function(c) {
            return c.key;
          });
        }, f.prototype.getRenderableIds = function(c) {
          var d = this, _ = [];
          for (var w in this._tiles)
            this._isIdRenderable(w, c) && _.push(this._tiles[w]);
          return c ? _.sort(function(E, O) {
            var k = E.tileID, R = O.tileID, $ = new a.Point(k.canonical.x, k.canonical.y)._rotate(d.transform.angle), W = new a.Point(R.canonical.x, R.canonical.y)._rotate(d.transform.angle);
            return k.overscaledZ - R.overscaledZ || W.y - $.y || W.x - $.x;
          }).map(function(E) {
            return E.tileID.key;
          }) : _.map(function(E) {
            return E.tileID;
          }).sort(_e).map(function(E) {
            return E.key;
          });
        }, f.prototype.hasRenderableParent = function(c) {
          var d = this.findLoadedParent(c, 0);
          return !!d && this._isIdRenderable(d.tileID.key);
        }, f.prototype._isIdRenderable = function(c, d) {
          return this._tiles[c] && this._tiles[c].hasData() && !this._coveredTiles[c] && (d || !this._tiles[c].holdingForFade());
        }, f.prototype.reload = function() {
          if (this._paused)
            this._shouldReloadOnResume = !0;
          else
            for (var c in this._cache.reset(), this._tiles)
              this._tiles[c].state !== "errored" && this._reloadTile(c, "reloading");
        }, f.prototype._reloadTile = function(c, d) {
          var _ = this._tiles[c];
          _ && (_.state !== "loading" && (_.state = d), this._loadTile(_, this._tileLoaded.bind(this, _, c, d)));
        }, f.prototype._tileLoaded = function(c, d, _, w) {
          if (w)
            return c.state = "errored", void (w.status !== 404 ? this._source.fire(new a.ErrorEvent(w, { tile: c })) : this.update(this.transform));
          c.timeAdded = a.browser.now(), _ === "expired" && (c.refreshedUponExpiration = !0), this._setTileReloadTimer(d, c), this.getSource().type === "raster-dem" && c.dem && this._backfillDEM(c), this._state.initializeTileState(c, this.map ? this.map.painter : null), this._source.fire(new a.Event("data", { dataType: "source", tile: c, coord: c.tileID }));
        }, f.prototype._backfillDEM = function(c) {
          for (var d = this.getRenderableIds(), _ = 0; _ < d.length; _++) {
            var w = d[_];
            if (c.neighboringTiles && c.neighboringTiles[w]) {
              var E = this.getTileByID(w);
              O(c, E), O(E, c);
            }
          }
          function O(k, R) {
            k.needsHillshadePrepare = !0;
            var $ = R.tileID.canonical.x - k.tileID.canonical.x, W = R.tileID.canonical.y - k.tileID.canonical.y, H = Math.pow(2, k.tileID.canonical.z), ne = R.tileID.key;
            $ === 0 && W === 0 || Math.abs(W) > 1 || (Math.abs($) > 1 && (Math.abs($ + H) === 1 ? $ += H : Math.abs($ - H) === 1 && ($ -= H)), R.dem && k.dem && (k.dem.backfillBorder(R.dem, $, W), k.neighboringTiles && k.neighboringTiles[ne] && (k.neighboringTiles[ne].backfilled = !0)));
          }
        }, f.prototype.getTile = function(c) {
          return this.getTileByID(c.key);
        }, f.prototype.getTileByID = function(c) {
          return this._tiles[c];
        }, f.prototype._retainLoadedChildren = function(c, d, _, w) {
          for (var E in this._tiles) {
            var O = this._tiles[E];
            if (!(w[E] || !O.hasData() || O.tileID.overscaledZ <= d || O.tileID.overscaledZ > _)) {
              for (var k = O.tileID; O && O.tileID.overscaledZ > d + 1; ) {
                var R = O.tileID.scaledTo(O.tileID.overscaledZ - 1);
                (O = this._tiles[R.key]) && O.hasData() && (k = R);
              }
              for (var $ = k; $.overscaledZ > d; )
                if (c[($ = $.scaledTo($.overscaledZ - 1)).key]) {
                  w[k.key] = k;
                  break;
                }
            }
          }
        }, f.prototype.findLoadedParent = function(c, d) {
          if (c.key in this._loadedParentTiles) {
            var _ = this._loadedParentTiles[c.key];
            return _ && _.tileID.overscaledZ >= d ? _ : null;
          }
          for (var w = c.overscaledZ - 1; w >= d; w--) {
            var E = c.scaledTo(w), O = this._getLoadedTile(E);
            if (O)
              return O;
          }
        }, f.prototype._getLoadedTile = function(c) {
          var d = this._tiles[c.key];
          return d && d.hasData() ? d : this._cache.getByKey(c.wrapped().key);
        }, f.prototype.updateCacheSize = function(c) {
          var d = Math.ceil(c.width / this._source.tileSize) + 1, _ = Math.ceil(c.height / this._source.tileSize) + 1, w = Math.floor(d * _ * 5), E = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, w) : w;
          this._cache.setMaxSize(E);
        }, f.prototype.handleWrapJump = function(c) {
          var d = Math.round((c - (this._prevLng === void 0 ? c : this._prevLng)) / 360);
          if (this._prevLng = c, d) {
            var _ = {};
            for (var w in this._tiles) {
              var E = this._tiles[w];
              E.tileID = E.tileID.unwrapTo(E.tileID.wrap + d), _[E.tileID.key] = E;
            }
            for (var O in this._tiles = _, this._timers)
              clearTimeout(this._timers[O]), delete this._timers[O];
            for (var k in this._tiles)
              this._setTileReloadTimer(k, this._tiles[k]);
          }
        }, f.prototype.update = function(c) {
          var d = this;
          if (this.transform = c, this._sourceLoaded && !this._paused) {
            var _;
            this.updateCacheSize(c), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? _ = c.getVisibleUnwrappedCoordinates(this._source.tileID).map(function(je) {
              return new a.OverscaledTileID(je.canonical.z, je.wrap, je.canonical.z, je.canonical.x, je.canonical.y);
            }) : (_ = c.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (_ = _.filter(function(je) {
              return d._source.hasTile(je);
            }))) : _ = [];
            var w = c.coveringZoomLevel(this._source), E = Math.max(w - f.maxOverzooming, this._source.minzoom), O = Math.max(w + f.maxUnderzooming, this._source.minzoom), k = this._updateRetainedTiles(_, w);
            if (Ge(this._source.type)) {
              for (var R = {}, $ = {}, W = 0, H = Object.keys(k); W < H.length; W += 1) {
                var ne = H[W], te = k[ne], ue = this._tiles[ne];
                if (ue && !(ue.fadeEndTime && ue.fadeEndTime <= a.browser.now())) {
                  var Y = this.findLoadedParent(te, E);
                  Y && (this._addTile(Y.tileID), R[Y.tileID.key] = Y.tileID), $[ne] = te;
                }
              }
              for (var le in this._retainLoadedChildren($, w, O, k), R)
                k[le] || (this._coveredTiles[le] = !0, k[le] = R[le]);
            }
            for (var me in k)
              this._tiles[me].clearFadeHold();
            for (var xe = 0, Ae = a.keysDifference(this._tiles, k); xe < Ae.length; xe += 1) {
              var Me = Ae[xe], ke = this._tiles[Me];
              ke.hasSymbolBuckets && !ke.holdingForFade() ? ke.setHoldDuration(this.map._fadeDuration) : ke.hasSymbolBuckets && !ke.symbolFadeFinished() || this._removeTile(Me);
            }
            this._updateLoadedParentTileCache();
          }
        }, f.prototype.releaseSymbolFadeTiles = function() {
          for (var c in this._tiles)
            this._tiles[c].holdingForFade() && this._removeTile(c);
        }, f.prototype._updateRetainedTiles = function(c, d) {
          for (var _ = {}, w = {}, E = Math.max(d - f.maxOverzooming, this._source.minzoom), O = Math.max(d + f.maxUnderzooming, this._source.minzoom), k = {}, R = 0, $ = c; R < $.length; R += 1) {
            var W = $[R], H = this._addTile(W);
            _[W.key] = W, H.hasData() || d < this._source.maxzoom && (k[W.key] = W);
          }
          this._retainLoadedChildren(k, d, O, _);
          for (var ne = 0, te = c; ne < te.length; ne += 1) {
            var ue = te[ne], Y = this._tiles[ue.key];
            if (!Y.hasData()) {
              if (d + 1 > this._source.maxzoom) {
                var le = ue.children(this._source.maxzoom)[0], me = this.getTile(le);
                if (me && me.hasData()) {
                  _[le.key] = le;
                  continue;
                }
              } else {
                var xe = ue.children(this._source.maxzoom);
                if (_[xe[0].key] && _[xe[1].key] && _[xe[2].key] && _[xe[3].key])
                  continue;
              }
              for (var Ae = Y.wasRequested(), Me = ue.overscaledZ - 1; Me >= E; --Me) {
                var ke = ue.scaledTo(Me);
                if (w[ke.key] || (w[ke.key] = !0, !(Y = this.getTile(ke)) && Ae && (Y = this._addTile(ke)), Y && (_[ke.key] = ke, Ae = Y.wasRequested(), Y.hasData())))
                  break;
              }
            }
          }
          return _;
        }, f.prototype._updateLoadedParentTileCache = function() {
          for (var c in this._loadedParentTiles = {}, this._tiles) {
            for (var d = [], _ = void 0, w = this._tiles[c].tileID; w.overscaledZ > 0; ) {
              if (w.key in this._loadedParentTiles) {
                _ = this._loadedParentTiles[w.key];
                break;
              }
              d.push(w.key);
              var E = w.scaledTo(w.overscaledZ - 1);
              if (_ = this._getLoadedTile(E))
                break;
              w = E;
            }
            for (var O = 0, k = d; O < k.length; O += 1)
              this._loadedParentTiles[k[O]] = _;
          }
        }, f.prototype._addTile = function(c) {
          var d = this._tiles[c.key];
          if (d)
            return d;
          (d = this._cache.getAndRemove(c)) && (this._setTileReloadTimer(c.key, d), d.tileID = c, this._state.initializeTileState(d, this.map ? this.map.painter : null), this._cacheTimers[c.key] && (clearTimeout(this._cacheTimers[c.key]), delete this._cacheTimers[c.key], this._setTileReloadTimer(c.key, d)));
          var _ = Boolean(d);
          return _ || (d = new a.Tile(c, this._source.tileSize * c.overscaleFactor()), this._loadTile(d, this._tileLoaded.bind(this, d, c.key, d.state))), d ? (d.uses++, this._tiles[c.key] = d, _ || this._source.fire(new a.Event("dataloading", { tile: d, coord: d.tileID, dataType: "source" })), d) : null;
        }, f.prototype._setTileReloadTimer = function(c, d) {
          var _ = this;
          c in this._timers && (clearTimeout(this._timers[c]), delete this._timers[c]);
          var w = d.getExpiryTimeout();
          w && (this._timers[c] = setTimeout(function() {
            _._reloadTile(c, "expired"), delete _._timers[c];
          }, w));
        }, f.prototype._removeTile = function(c) {
          var d = this._tiles[c];
          d && (d.uses--, delete this._tiles[c], this._timers[c] && (clearTimeout(this._timers[c]), delete this._timers[c]), d.uses > 0 || (d.hasData() && d.state !== "reloading" ? this._cache.add(d.tileID, d, d.getExpiryTimeout()) : (d.aborted = !0, this._abortTile(d), this._unloadTile(d))));
        }, f.prototype.clearTiles = function() {
          for (var c in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles)
            this._removeTile(c);
          this._cache.reset();
        }, f.prototype.tilesIn = function(c, d, _) {
          var w = this, E = [], O = this.transform;
          if (!O)
            return E;
          for (var k = _ ? O.getCameraQueryGeometry(c) : c, R = c.map(function(Me) {
            return O.pointCoordinate(Me);
          }), $ = k.map(function(Me) {
            return O.pointCoordinate(Me);
          }), W = this.getIds(), H = 1 / 0, ne = 1 / 0, te = -1 / 0, ue = -1 / 0, Y = 0, le = $; Y < le.length; Y += 1) {
            var me = le[Y];
            H = Math.min(H, me.x), ne = Math.min(ne, me.y), te = Math.max(te, me.x), ue = Math.max(ue, me.y);
          }
          for (var xe = function(Me) {
            var ke = w._tiles[W[Me]];
            if (!ke.holdingForFade()) {
              var je = ke.tileID, nt = Math.pow(2, O.zoom - ke.tileID.overscaledZ), tt = d * ke.queryPadding * a.EXTENT / ke.tileSize / nt, gt = [je.getTilePoint(new a.MercatorCoordinate(H, ne)), je.getTilePoint(new a.MercatorCoordinate(te, ue))];
              if (gt[0].x - tt < a.EXTENT && gt[0].y - tt < a.EXTENT && gt[1].x + tt >= 0 && gt[1].y + tt >= 0) {
                var Dt = R.map(function(zt) {
                  return je.getTilePoint(zt);
                }), Bt = $.map(function(zt) {
                  return je.getTilePoint(zt);
                });
                E.push({ tile: ke, tileID: je, queryGeometry: Dt, cameraQueryGeometry: Bt, scale: nt });
              }
            }
          }, Ae = 0; Ae < W.length; Ae++)
            xe(Ae);
          return E;
        }, f.prototype.getVisibleCoordinates = function(c) {
          for (var d = this, _ = this.getRenderableIds(c).map(function(k) {
            return d._tiles[k].tileID;
          }), w = 0, E = _; w < E.length; w += 1) {
            var O = E[w];
            O.posMatrix = this.transform.calculatePosMatrix(O.toUnwrapped());
          }
          return _;
        }, f.prototype.hasTransition = function() {
          if (this._source.hasTransition())
            return !0;
          if (Ge(this._source.type))
            for (var c in this._tiles) {
              var d = this._tiles[c];
              if (d.fadeEndTime !== void 0 && d.fadeEndTime >= a.browser.now())
                return !0;
            }
          return !1;
        }, f.prototype.setFeatureState = function(c, d, _) {
          this._state.updateState(c = c || "_geojsonTileLayer", d, _);
        }, f.prototype.removeFeatureState = function(c, d, _) {
          this._state.removeFeatureState(c = c || "_geojsonTileLayer", d, _);
        }, f.prototype.getFeatureState = function(c, d) {
          return this._state.getState(c = c || "_geojsonTileLayer", d);
        }, f.prototype.setDependencies = function(c, d, _) {
          var w = this._tiles[c];
          w && w.setDependencies(d, _);
        }, f.prototype.reloadTilesForDependencies = function(c, d) {
          for (var _ in this._tiles)
            this._tiles[_].hasDependency(c, d) && this._reloadTile(_, "reloading");
          this._cache.filter(function(w) {
            return !w.hasDependency(c, d);
          });
        }, f;
      }(a.Evented);
      function _e(u, f) {
        var c = Math.abs(2 * u.wrap) - +(u.wrap < 0), d = Math.abs(2 * f.wrap) - +(f.wrap < 0);
        return u.overscaledZ - f.overscaledZ || d - c || f.canonical.y - u.canonical.y || f.canonical.x - u.canonical.x;
      }
      function Ge(u) {
        return u === "raster" || u === "image" || u === "video";
      }
      function Ze() {
        return new a.window.Worker(Ih.workerUrl);
      }
      ie.maxOverzooming = 10, ie.maxUnderzooming = 3;
      var Ce = "mapboxgl_preloaded_worker_pool", Ue = function() {
        this.active = {};
      };
      Ue.prototype.acquire = function(u) {
        if (!this.workers)
          for (this.workers = []; this.workers.length < Ue.workerCount; )
            this.workers.push(new Ze());
        return this.active[u] = !0, this.workers.slice();
      }, Ue.prototype.release = function(u) {
        delete this.active[u], this.numActive() === 0 && (this.workers.forEach(function(f) {
          f.terminate();
        }), this.workers = null);
      }, Ue.prototype.isPreloaded = function() {
        return !!this.active[Ce];
      }, Ue.prototype.numActive = function() {
        return Object.keys(this.active).length;
      };
      var Et, _t = Math.floor(a.browser.hardwareConcurrency / 2);
      function Le() {
        return Et || (Et = new Ue()), Et;
      }
      function pt(u, f) {
        var c = {};
        for (var d in u)
          d !== "ref" && (c[d] = u[d]);
        return a.refProperties.forEach(function(_) {
          _ in f && (c[_] = f[_]);
        }), c;
      }
      function st(u) {
        u = u.slice();
        for (var f = /* @__PURE__ */ Object.create(null), c = 0; c < u.length; c++)
          f[u[c].id] = u[c];
        for (var d = 0; d < u.length; d++)
          "ref" in u[d] && (u[d] = pt(u[d], f[u[d].ref]));
        return u;
      }
      Ue.workerCount = Math.max(Math.min(_t, 6), 1);
      var De = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
      function fe(u, f, c) {
        c.push({ command: De.addSource, args: [u, f[u]] });
      }
      function Ee(u, f, c) {
        f.push({ command: De.removeSource, args: [u] }), c[u] = !0;
      }
      function He(u, f, c, d) {
        Ee(u, c, d), fe(u, f, c);
      }
      function jt(u, f, c) {
        var d;
        for (d in u[c])
          if (u[c].hasOwnProperty(d) && d !== "data" && !a.deepEqual(u[c][d], f[c][d]))
            return !1;
        for (d in f[c])
          if (f[c].hasOwnProperty(d) && d !== "data" && !a.deepEqual(u[c][d], f[c][d]))
            return !1;
        return !0;
      }
      function Wt(u, f, c, d, _, w) {
        var E;
        for (E in f = f || {}, u = u || {})
          u.hasOwnProperty(E) && (a.deepEqual(u[E], f[E]) || c.push({ command: w, args: [d, E, f[E], _] }));
        for (E in f)
          f.hasOwnProperty(E) && !u.hasOwnProperty(E) && (a.deepEqual(u[E], f[E]) || c.push({ command: w, args: [d, E, f[E], _] }));
      }
      function Jt(u) {
        return u.id;
      }
      function Zt(u, f) {
        return u[f.id] = f, u;
      }
      var Yn = function(u, f) {
        this.reset(u, f);
      };
      Yn.prototype.reset = function(u, f) {
        this.points = u || [], this._distances = [0];
        for (var c = 1; c < this.points.length; c++)
          this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(f || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
      }, Yn.prototype.lerp = function(u) {
        if (this.points.length === 1)
          return this.points[0];
        u = a.clamp(u, 0, 1);
        for (var f = 1, c = this._distances[f], d = u * this.paddedLength + this.padding; c < d && f < this._distances.length; )
          c = this._distances[++f];
        var _ = f - 1, w = this._distances[_], E = c - w, O = E > 0 ? (d - w) / E : 0;
        return this.points[_].mult(1 - O).add(this.points[f].mult(O));
      };
      var Qt = function(u, f, c) {
        var d = this.boxCells = [], _ = this.circleCells = [];
        this.xCellCount = Math.ceil(u / c), this.yCellCount = Math.ceil(f / c);
        for (var w = 0; w < this.xCellCount * this.yCellCount; w++)
          d.push([]), _.push([]);
        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = u, this.height = f, this.xScale = this.xCellCount / u, this.yScale = this.yCellCount / f, this.boxUid = 0, this.circleUid = 0;
      };
      function pn(u, f, c, d, _) {
        var w = a.create();
        return f ? (a.scale(w, w, [1 / _, 1 / _, 1]), c || a.rotateZ(w, w, d.angle)) : a.multiply(w, d.labelPlaneMatrix, u), w;
      }
      function Ur(u, f, c, d, _) {
        if (f) {
          var w = a.clone(u);
          return a.scale(w, w, [_, _, 1]), c || a.rotateZ(w, w, -d.angle), w;
        }
        return d.glCoordMatrix;
      }
      function gr(u, f) {
        var c = [u.x, u.y, 0, 1];
        mi(c, c, f);
        var d = c[3];
        return { point: new a.Point(c[0] / d, c[1] / d), signedDistanceFromCamera: d };
      }
      function Fr(u, f) {
        return 0.5 + u / f * 0.5;
      }
      function Yi(u, f) {
        var c = u[0] / u[3], d = u[1] / u[3];
        return c >= -f[0] && c <= f[0] && d >= -f[1] && d <= f[1];
      }
      function Hu(u, f, c, d, _, w, E, O) {
        var k = d ? u.textSizeData : u.iconSizeData, R = a.evaluateSizeForZoom(k, c.transform.zoom), $ = [256 / c.width * 2 + 1, 256 / c.height * 2 + 1], W = d ? u.text.dynamicLayoutVertexArray : u.icon.dynamicLayoutVertexArray;
        W.clear();
        for (var H = u.lineVertexArray, ne = d ? u.text.placedSymbolArray : u.icon.placedSymbolArray, te = c.transform.width / c.transform.height, ue = !1, Y = 0; Y < ne.length; Y++) {
          var le = ne.get(Y);
          if (le.hidden || le.writingMode === a.WritingMode.vertical && !ue)
            Vi(le.numGlyphs, W);
          else {
            ue = !1;
            var me = [le.anchorX, le.anchorY, 0, 1];
            if (a.transformMat4(me, me, f), Yi(me, $)) {
              var xe = Fr(c.transform.cameraToCenterDistance, me[3]), Ae = a.evaluateSizeForFeature(k, R, le), Me = E ? Ae / xe : Ae * xe, ke = new a.Point(le.anchorX, le.anchorY), je = gr(ke, _).point, nt = {}, tt = qf(le, Me, !1, O, f, _, w, u.glyphOffsetArray, H, W, je, ke, nt, te);
              ue = tt.useVertical, (tt.notEnoughRoom || ue || tt.needsFlipping && qf(le, Me, !0, O, f, _, w, u.glyphOffsetArray, H, W, je, ke, nt, te).notEnoughRoom) && Vi(le.numGlyphs, W);
            } else
              Vi(le.numGlyphs, W);
          }
        }
        d ? u.text.dynamicLayoutVertexBuffer.updateData(W) : u.icon.dynamicLayoutVertexBuffer.updateData(W);
      }
      function di(u, f, c, d, _, w, E, O, k, R, $) {
        var W = O.glyphStartIndex + O.numGlyphs, H = O.lineStartIndex, ne = O.lineStartIndex + O.lineLength, te = f.getoffsetX(O.glyphStartIndex), ue = f.getoffsetX(W - 1), Y = Ln(u * te, c, d, _, w, E, O.segment, H, ne, k, R, $);
        if (!Y)
          return null;
        var le = Ln(u * ue, c, d, _, w, E, O.segment, H, ne, k, R, $);
        return le ? { first: Y, last: le } : null;
      }
      function Ji(u, f, c, d) {
        return u === a.WritingMode.horizontal && Math.abs(c.y - f.y) > Math.abs(c.x - f.x) * d ? { useVertical: !0 } : (u === a.WritingMode.vertical ? f.y < c.y : f.x > c.x) ? { needsFlipping: !0 } : null;
      }
      function qf(u, f, c, d, _, w, E, O, k, R, $, W, H, ne) {
        var te, ue = f / 24, Y = u.lineOffsetX * ue, le = u.lineOffsetY * ue;
        if (u.numGlyphs > 1) {
          var me = u.glyphStartIndex + u.numGlyphs, xe = u.lineStartIndex, Ae = u.lineStartIndex + u.lineLength, Me = di(ue, O, Y, le, c, $, W, u, k, w, H);
          if (!Me)
            return { notEnoughRoom: !0 };
          var ke = gr(Me.first.point, E).point, je = gr(Me.last.point, E).point;
          if (d && !c) {
            var nt = Ji(u.writingMode, ke, je, ne);
            if (nt)
              return nt;
          }
          te = [Me.first];
          for (var tt = u.glyphStartIndex + 1; tt < me - 1; tt++)
            te.push(Ln(ue * O.getoffsetX(tt), Y, le, c, $, W, u.segment, xe, Ae, k, w, H));
          te.push(Me.last);
        } else {
          if (d && !c) {
            var gt = gr(W, _).point, Dt = u.lineStartIndex + u.segment + 1, Bt = new a.Point(k.getx(Dt), k.gety(Dt)), zt = gr(Bt, _), Ir = zt.signedDistanceFromCamera > 0 ? zt.point : Zu(W, Bt, gt, 1, _), xt = Ji(u.writingMode, gt, Ir, ne);
            if (xt)
              return xt;
          }
          var Yt = Ln(ue * O.getoffsetX(u.glyphStartIndex), Y, le, c, $, W, u.segment, u.lineStartIndex, u.lineStartIndex + u.lineLength, k, w, H);
          if (!Yt)
            return { notEnoughRoom: !0 };
          te = [Yt];
        }
        for (var ir = 0, Kt = te; ir < Kt.length; ir += 1) {
          var Xt = Kt[ir];
          a.addDynamicAttributes(R, Xt.point, Xt.angle);
        }
        return {};
      }
      function Zu(u, f, c, d, _) {
        var w = gr(u.add(u.sub(f)._unit()), _).point, E = c.sub(w);
        return c.add(E._mult(d / E.mag()));
      }
      function Ln(u, f, c, d, _, w, E, O, k, R, $, W) {
        var H = d ? u - f : u + f, ne = H > 0 ? 1 : -1, te = 0;
        d && (ne *= -1, te = Math.PI), ne < 0 && (te += Math.PI);
        for (var ue = ne > 0 ? O + E : O + E + 1, Y = _, le = _, me = 0, xe = 0, Ae = Math.abs(H), Me = []; me + xe <= Ae; ) {
          if ((ue += ne) < O || ue >= k)
            return null;
          if (le = Y, Me.push(Y), (Y = W[ue]) === void 0) {
            var ke = new a.Point(R.getx(ue), R.gety(ue)), je = gr(ke, $);
            if (je.signedDistanceFromCamera > 0)
              Y = W[ue] = je.point;
            else {
              var nt = ue - ne;
              Y = Zu(me === 0 ? w : new a.Point(R.getx(nt), R.gety(nt)), ke, le, Ae - me + 1, $);
            }
          }
          me += xe, xe = le.dist(Y);
        }
        var tt = (Ae - me) / xe, gt = Y.sub(le), Dt = gt.mult(tt)._add(le);
        Dt._add(gt._unit()._perp()._mult(c * ne));
        var Bt = te + Math.atan2(Y.y - le.y, Y.x - le.x);
        return Me.push(Dt), { point: Dt, angle: Bt, path: Me };
      }
      Qt.prototype.keysLength = function() {
        return this.boxKeys.length + this.circleKeys.length;
      }, Qt.prototype.insert = function(u, f, c, d, _) {
        this._forEachCell(f, c, d, _, this._insertBoxCell, this.boxUid++), this.boxKeys.push(u), this.bboxes.push(f), this.bboxes.push(c), this.bboxes.push(d), this.bboxes.push(_);
      }, Qt.prototype.insertCircle = function(u, f, c, d) {
        this._forEachCell(f - d, c - d, f + d, c + d, this._insertCircleCell, this.circleUid++), this.circleKeys.push(u), this.circles.push(f), this.circles.push(c), this.circles.push(d);
      }, Qt.prototype._insertBoxCell = function(u, f, c, d, _, w) {
        this.boxCells[_].push(w);
      }, Qt.prototype._insertCircleCell = function(u, f, c, d, _, w) {
        this.circleCells[_].push(w);
      }, Qt.prototype._query = function(u, f, c, d, _, w) {
        if (c < 0 || u > this.width || d < 0 || f > this.height)
          return !_ && [];
        var E = [];
        if (u <= 0 && f <= 0 && this.width <= c && this.height <= d) {
          if (_)
            return !0;
          for (var O = 0; O < this.boxKeys.length; O++)
            E.push({ key: this.boxKeys[O], x1: this.bboxes[4 * O], y1: this.bboxes[4 * O + 1], x2: this.bboxes[4 * O + 2], y2: this.bboxes[4 * O + 3] });
          for (var k = 0; k < this.circleKeys.length; k++) {
            var R = this.circles[3 * k], $ = this.circles[3 * k + 1], W = this.circles[3 * k + 2];
            E.push({ key: this.circleKeys[k], x1: R - W, y1: $ - W, x2: R + W, y2: $ + W });
          }
          return w ? E.filter(w) : E;
        }
        return this._forEachCell(u, f, c, d, this._queryCell, E, { hitTest: _, seenUids: { box: {}, circle: {} } }, w), _ ? E.length > 0 : E;
      }, Qt.prototype._queryCircle = function(u, f, c, d, _) {
        var w = u - c, E = u + c, O = f - c, k = f + c;
        if (E < 0 || w > this.width || k < 0 || O > this.height)
          return !d && [];
        var R = [];
        return this._forEachCell(w, O, E, k, this._queryCellCircle, R, { hitTest: d, circle: { x: u, y: f, radius: c }, seenUids: { box: {}, circle: {} } }, _), d ? R.length > 0 : R;
      }, Qt.prototype.query = function(u, f, c, d, _) {
        return this._query(u, f, c, d, !1, _);
      }, Qt.prototype.hitTest = function(u, f, c, d, _) {
        return this._query(u, f, c, d, !0, _);
      }, Qt.prototype.hitTestCircle = function(u, f, c, d) {
        return this._queryCircle(u, f, c, !0, d);
      }, Qt.prototype._queryCell = function(u, f, c, d, _, w, E, O) {
        var k = E.seenUids, R = this.boxCells[_];
        if (R !== null)
          for (var $ = this.bboxes, W = 0, H = R; W < H.length; W += 1) {
            var ne = H[W];
            if (!k.box[ne]) {
              k.box[ne] = !0;
              var te = 4 * ne;
              if (u <= $[te + 2] && f <= $[te + 3] && c >= $[te + 0] && d >= $[te + 1] && (!O || O(this.boxKeys[ne]))) {
                if (E.hitTest)
                  return w.push(!0), !0;
                w.push({ key: this.boxKeys[ne], x1: $[te], y1: $[te + 1], x2: $[te + 2], y2: $[te + 3] });
              }
            }
          }
        var ue = this.circleCells[_];
        if (ue !== null)
          for (var Y = this.circles, le = 0, me = ue; le < me.length; le += 1) {
            var xe = me[le];
            if (!k.circle[xe]) {
              k.circle[xe] = !0;
              var Ae = 3 * xe;
              if (this._circleAndRectCollide(Y[Ae], Y[Ae + 1], Y[Ae + 2], u, f, c, d) && (!O || O(this.circleKeys[xe]))) {
                if (E.hitTest)
                  return w.push(!0), !0;
                var Me = Y[Ae], ke = Y[Ae + 1], je = Y[Ae + 2];
                w.push({ key: this.circleKeys[xe], x1: Me - je, y1: ke - je, x2: Me + je, y2: ke + je });
              }
            }
          }
      }, Qt.prototype._queryCellCircle = function(u, f, c, d, _, w, E, O) {
        var k = E.circle, R = E.seenUids, $ = this.boxCells[_];
        if ($ !== null)
          for (var W = this.bboxes, H = 0, ne = $; H < ne.length; H += 1) {
            var te = ne[H];
            if (!R.box[te]) {
              R.box[te] = !0;
              var ue = 4 * te;
              if (this._circleAndRectCollide(k.x, k.y, k.radius, W[ue + 0], W[ue + 1], W[ue + 2], W[ue + 3]) && (!O || O(this.boxKeys[te])))
                return w.push(!0), !0;
            }
          }
        var Y = this.circleCells[_];
        if (Y !== null)
          for (var le = this.circles, me = 0, xe = Y; me < xe.length; me += 1) {
            var Ae = xe[me];
            if (!R.circle[Ae]) {
              R.circle[Ae] = !0;
              var Me = 3 * Ae;
              if (this._circlesCollide(le[Me], le[Me + 1], le[Me + 2], k.x, k.y, k.radius) && (!O || O(this.circleKeys[Ae])))
                return w.push(!0), !0;
            }
          }
      }, Qt.prototype._forEachCell = function(u, f, c, d, _, w, E, O) {
        for (var k = this._convertToXCellCoord(u), R = this._convertToYCellCoord(f), $ = this._convertToXCellCoord(c), W = this._convertToYCellCoord(d), H = k; H <= $; H++)
          for (var ne = R; ne <= W; ne++)
            if (_.call(this, u, f, c, d, this.xCellCount * ne + H, w, E, O))
              return;
      }, Qt.prototype._convertToXCellCoord = function(u) {
        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(u * this.xScale)));
      }, Qt.prototype._convertToYCellCoord = function(u) {
        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(u * this.yScale)));
      }, Qt.prototype._circlesCollide = function(u, f, c, d, _, w) {
        var E = d - u, O = _ - f, k = c + w;
        return k * k > E * E + O * O;
      }, Qt.prototype._circleAndRectCollide = function(u, f, c, d, _, w, E) {
        var O = (w - d) / 2, k = Math.abs(u - (d + O));
        if (k > O + c)
          return !1;
        var R = (E - _) / 2, $ = Math.abs(f - (_ + R));
        if ($ > R + c)
          return !1;
        if (k <= O || $ <= R)
          return !0;
        var W = k - O, H = $ - R;
        return W * W + H * H <= c * c;
      };
      var Xu = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function Vi(u, f) {
        for (var c = 0; c < u; c++) {
          var d = f.length;
          f.resize(d + 4), f.float32.set(Xu, 3 * d);
        }
      }
      function mi(u, f, c) {
        var d = f[0], _ = f[1];
        return u[0] = c[0] * d + c[4] * _ + c[12], u[1] = c[1] * d + c[5] * _ + c[13], u[3] = c[3] * d + c[7] * _ + c[15], u;
      }
      var jo = function(u, f, c) {
        f === void 0 && (f = new Qt(u.width + 200, u.height + 200, 25)), c === void 0 && (c = new Qt(u.width + 200, u.height + 200, 25)), this.transform = u, this.grid = f, this.ignoredGrid = c, this.pitchfactor = Math.cos(u._pitch) * u.cameraToCenterDistance, this.screenRightBoundary = u.width + 100, this.screenBottomBoundary = u.height + 100, this.gridRightBoundary = u.width + 200, this.gridBottomBoundary = u.height + 200;
      };
      function dn(u, f, c) {
        return f * (a.EXTENT / (u.tileSize * Math.pow(2, c - u.tileID.overscaledZ)));
      }
      jo.prototype.placeCollisionBox = function(u, f, c, d, _) {
        var w = this.projectAndGetPerspectiveRatio(d, u.anchorPointX, u.anchorPointY), E = c * w.perspectiveRatio, O = u.x1 * E + w.point.x, k = u.y1 * E + w.point.y, R = u.x2 * E + w.point.x, $ = u.y2 * E + w.point.y;
        return !this.isInsideGrid(O, k, R, $) || !f && this.grid.hitTest(O, k, R, $, _) ? { box: [], offscreen: !1 } : { box: [O, k, R, $], offscreen: this.isOffscreen(O, k, R, $) };
      }, jo.prototype.placeCollisionCircles = function(u, f, c, d, _, w, E, O, k, R, $, W, H) {
        var ne = [], te = new a.Point(f.anchorX, f.anchorY), ue = gr(te, w), Y = Fr(this.transform.cameraToCenterDistance, ue.signedDistanceFromCamera), le = (R ? _ / Y : _ * Y) / a.ONE_EM, me = gr(te, E).point, xe = di(le, d, f.lineOffsetX * le, f.lineOffsetY * le, !1, me, te, f, c, E, {}), Ae = !1, Me = !1, ke = !0;
        if (xe) {
          for (var je = 0.5 * W * Y + H, nt = new a.Point(-100, -100), tt = new a.Point(this.screenRightBoundary, this.screenBottomBoundary), gt = new Yn(), Dt = xe.first, Bt = xe.last, zt = [], Ir = Dt.path.length - 1; Ir >= 1; Ir--)
            zt.push(Dt.path[Ir]);
          for (var xt = 1; xt < Bt.path.length; xt++)
            zt.push(Bt.path[xt]);
          var Yt = 2.5 * je;
          if (O) {
            var ir = zt.map(function(Zo) {
              return gr(Zo, O);
            });
            zt = ir.some(function(Zo) {
              return Zo.signedDistanceFromCamera <= 0;
            }) ? [] : ir.map(function(Zo) {
              return Zo.point;
            });
          }
          var Kt = [];
          if (zt.length > 0) {
            for (var Xt = zt[0].clone(), nr = zt[0].clone(), Ht = 1; Ht < zt.length; Ht++)
              Xt.x = Math.min(Xt.x, zt[Ht].x), Xt.y = Math.min(Xt.y, zt[Ht].y), nr.x = Math.max(nr.x, zt[Ht].x), nr.y = Math.max(nr.y, zt[Ht].y);
            Kt = Xt.x >= nt.x && nr.x <= tt.x && Xt.y >= nt.y && nr.y <= tt.y ? [zt] : nr.x < nt.x || Xt.x > tt.x || nr.y < nt.y || Xt.y > tt.y ? [] : a.clipLine([zt], nt.x, nt.y, tt.x, tt.y);
          }
          for (var $t = 0, si = Kt; $t < si.length; $t += 1) {
            var On;
            gt.reset(si[$t], 0.25 * je), On = gt.length <= 0.5 * je ? 1 : Math.ceil(gt.paddedLength / Yt) + 1;
            for (var Di = 0; Di < On; Di++) {
              var gi = Di / Math.max(On - 1, 1), Mn = gt.lerp(gi), Dn = Mn.x + 100, mo = Mn.y + 100;
              ne.push(Dn, mo, je, 0);
              var $i = Dn - je, Os = mo - je, Qi = Dn + je, ca = mo + je;
              if (ke = ke && this.isOffscreen($i, Os, Qi, ca), Me = Me || this.isInsideGrid($i, Os, Qi, ca), !u && this.grid.hitTestCircle(Dn, mo, je, $) && (Ae = !0, !k))
                return { circles: [], offscreen: !1, collisionDetected: Ae };
            }
          }
        }
        return { circles: !k && Ae || !Me ? [] : ne, offscreen: ke, collisionDetected: Ae };
      }, jo.prototype.queryRenderedSymbols = function(u) {
        if (u.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
          return {};
        for (var f = [], c = 1 / 0, d = 1 / 0, _ = -1 / 0, w = -1 / 0, E = 0, O = u; E < O.length; E += 1) {
          var k = O[E], R = new a.Point(k.x + 100, k.y + 100);
          c = Math.min(c, R.x), d = Math.min(d, R.y), _ = Math.max(_, R.x), w = Math.max(w, R.y), f.push(R);
        }
        for (var $ = {}, W = {}, H = 0, ne = this.grid.query(c, d, _, w).concat(this.ignoredGrid.query(c, d, _, w)); H < ne.length; H += 1) {
          var te = ne[H], ue = te.key;
          if ($[ue.bucketInstanceId] === void 0 && ($[ue.bucketInstanceId] = {}), !$[ue.bucketInstanceId][ue.featureIndex]) {
            var Y = [new a.Point(te.x1, te.y1), new a.Point(te.x2, te.y1), new a.Point(te.x2, te.y2), new a.Point(te.x1, te.y2)];
            a.polygonIntersectsPolygon(f, Y) && ($[ue.bucketInstanceId][ue.featureIndex] = !0, W[ue.bucketInstanceId] === void 0 && (W[ue.bucketInstanceId] = []), W[ue.bucketInstanceId].push(ue.featureIndex));
          }
        }
        return W;
      }, jo.prototype.insertCollisionBox = function(u, f, c, d, _) {
        (f ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: c, featureIndex: d, collisionGroupID: _ }, u[0], u[1], u[2], u[3]);
      }, jo.prototype.insertCollisionCircles = function(u, f, c, d, _) {
        for (var w = f ? this.ignoredGrid : this.grid, E = { bucketInstanceId: c, featureIndex: d, collisionGroupID: _ }, O = 0; O < u.length; O += 4)
          w.insertCircle(E, u[O], u[O + 1], u[O + 2]);
      }, jo.prototype.projectAndGetPerspectiveRatio = function(u, f, c) {
        var d = [f, c, 0, 1];
        return mi(d, d, u), { point: new a.Point((d[0] / d[3] + 1) / 2 * this.transform.width + 100, (-d[1] / d[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / d[3] * 0.5 };
      }, jo.prototype.isOffscreen = function(u, f, c, d) {
        return c < 100 || u >= this.screenRightBoundary || d < 100 || f > this.screenBottomBoundary;
      }, jo.prototype.isInsideGrid = function(u, f, c, d) {
        return c >= 0 && u < this.gridRightBoundary && d >= 0 && f < this.gridBottomBoundary;
      }, jo.prototype.getViewportMatrix = function() {
        var u = a.identity([]);
        return a.translate(u, u, [-100, -100, 0]), u;
      };
      var ia = function(u, f, c, d) {
        this.opacity = u ? Math.max(0, Math.min(1, u.opacity + (u.placed ? f : -f))) : d && c ? 1 : 0, this.placed = c;
      };
      ia.prototype.isHidden = function() {
        return this.opacity === 0 && !this.placed;
      };
      var To = function(u, f, c, d, _) {
        this.text = new ia(u ? u.text : null, f, c, _), this.icon = new ia(u ? u.icon : null, f, d, _);
      };
      To.prototype.isHidden = function() {
        return this.text.isHidden() && this.icon.isHidden();
      };
      var am = function(u, f, c) {
        this.text = u, this.icon = f, this.skipFade = c;
      }, Go = function() {
        this.invProjMatrix = a.create(), this.viewportMatrix = a.create(), this.circles = [];
      }, zv = function(u, f, c, d, _) {
        this.bucketInstanceId = u, this.featureIndex = f, this.sourceLayerIndex = c, this.bucketIndex = d, this.tileID = _;
      }, Va = function(u) {
        this.crossSourceCollisions = u, this.maxGroupID = 0, this.collisionGroups = {};
      };
      function Si(u, f, c, d, _) {
        var w = a.getAnchorAlignment(u), E = -(w.horizontalAlign - 0.5) * f, O = -(w.verticalAlign - 0.5) * c, k = a.evaluateVariableOffset(u, d);
        return new a.Point(E + k[0] * _, O + k[1] * _);
      }
      function xa(u, f, c, d, _, w) {
        var E = u.x1, O = u.x2, k = u.y1, R = u.y2, $ = u.anchorPointX, W = u.anchorPointY, H = new a.Point(f, c);
        return d && H._rotate(_ ? w : -w), { x1: E + H.x, y1: k + H.y, x2: O + H.x, y2: R + H.y, anchorPointX: $, anchorPointY: W };
      }
      Va.prototype.get = function(u) {
        if (this.crossSourceCollisions)
          return { ID: 0, predicate: null };
        if (!this.collisionGroups[u]) {
          var f = ++this.maxGroupID;
          this.collisionGroups[u] = { ID: f, predicate: function(c) {
            return c.collisionGroupID === f;
          } };
        }
        return this.collisionGroups[u];
      };
      var Ui = function(u, f, c, d) {
        this.transform = u.clone(), this.collisionIndex = new jo(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = f, this.retainedQueryData = {}, this.collisionGroups = new Va(c), this.collisionCircleArrays = {}, this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {};
      };
      function al(u, f, c, d, _) {
        u.emplaceBack(f ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(f ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(f ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(f ? 1 : 0, c ? 1 : 0, d || 0, _ || 0);
      }
      Ui.prototype.getBucketParts = function(u, f, c, d) {
        var _ = c.getBucket(f), w = c.latestFeatureIndex;
        if (_ && w && f.id === _.layerIds[0]) {
          var E = c.collisionBoxArray, O = _.layers[0].layout, k = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), R = c.tileSize / a.EXTENT, $ = this.transform.calculatePosMatrix(c.tileID.toUnwrapped()), W = O.get("text-pitch-alignment") === "map", H = O.get("text-rotation-alignment") === "map", ne = dn(c, 1, this.transform.zoom), te = pn($, W, H, this.transform, ne), ue = null;
          if (W) {
            var Y = Ur($, W, H, this.transform, ne);
            ue = a.multiply([], this.transform.labelPlaneMatrix, Y);
          }
          this.retainedQueryData[_.bucketInstanceId] = new zv(_.bucketInstanceId, w, _.sourceLayerIndex, _.index, c.tileID);
          var le = { bucket: _, layout: O, posMatrix: $, textLabelPlaneMatrix: te, labelToScreenMatrix: ue, scale: k, textPixelRatio: R, holdingForFade: c.holdingForFade(), collisionBoxArray: E, partiallyEvaluatedTextSize: a.evaluateSizeForZoom(_.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(_.sourceID) };
          if (d)
            for (var me = 0, xe = _.sortKeyRanges; me < xe.length; me += 1) {
              var Ae = xe[me];
              u.push({ sortKey: Ae.sortKey, symbolInstanceStart: Ae.symbolInstanceStart, symbolInstanceEnd: Ae.symbolInstanceEnd, parameters: le });
            }
          else
            u.push({ symbolInstanceStart: 0, symbolInstanceEnd: _.symbolInstances.length, parameters: le });
        }
      }, Ui.prototype.attemptAnchorPlacement = function(u, f, c, d, _, w, E, O, k, R, $, W, H, ne, te) {
        var ue, Y = [W.textOffset0, W.textOffset1], le = Si(u, c, d, Y, _), me = this.collisionIndex.placeCollisionBox(xa(f, le.x, le.y, w, E, this.transform.angle), $, O, k, R.predicate);
        if (!te || this.collisionIndex.placeCollisionBox(xa(te, le.x, le.y, w, E, this.transform.angle), $, O, k, R.predicate).box.length !== 0)
          return me.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[W.crossTileID] && this.prevPlacement.placements[W.crossTileID] && this.prevPlacement.placements[W.crossTileID].text && (ue = this.prevPlacement.variableOffsets[W.crossTileID].anchor), this.variableOffsets[W.crossTileID] = { textOffset: Y, width: c, height: d, anchor: u, textBoxScale: _, prevAnchor: ue }, this.markUsedJustification(H, u, W, ne), H.allowVerticalPlacement && (this.markUsedOrientation(H, ne, W), this.placedOrientations[W.crossTileID] = ne), { shift: le, placedGlyphBoxes: me }) : void 0;
      }, Ui.prototype.placeLayerBucketPart = function(u, f, c) {
        var d = this, _ = u.parameters, w = _.bucket, E = _.layout, O = _.posMatrix, k = _.textLabelPlaneMatrix, R = _.labelToScreenMatrix, $ = _.textPixelRatio, W = _.holdingForFade, H = _.collisionBoxArray, ne = _.partiallyEvaluatedTextSize, te = _.collisionGroup, ue = E.get("text-optional"), Y = E.get("icon-optional"), le = E.get("text-allow-overlap"), me = E.get("icon-allow-overlap"), xe = E.get("text-rotation-alignment") === "map", Ae = E.get("text-pitch-alignment") === "map", Me = E.get("icon-text-fit") !== "none", ke = E.get("symbol-z-order") === "viewport-y", je = le && (me || !w.hasIconData() || Y), nt = me && (le || !w.hasTextData() || ue);
        !w.collisionArrays && H && w.deserializeCollisionBoxes(H);
        var tt = function(xt, Yt) {
          if (!f[xt.crossTileID])
            if (W)
              d.placements[xt.crossTileID] = new am(!1, !1, !1);
            else {
              var ir, Kt = !1, Xt = !1, nr = !0, Ht = null, $t = { box: null, offscreen: null }, si = { box: null, offscreen: null }, On = null, Di = null, gi = 0, Mn = 0, Dn = 0;
              Yt.textFeatureIndex ? gi = Yt.textFeatureIndex : xt.useRuntimeCollisionCircles && (gi = xt.featureIndex), Yt.verticalTextFeatureIndex && (Mn = Yt.verticalTextFeatureIndex);
              var mo = Yt.textBox;
              if (mo) {
                var $i = function(Br) {
                  var Oo = a.WritingMode.horizontal;
                  if (w.allowVerticalPlacement && !Br && d.prevPlacement) {
                    var eo = d.prevPlacement.placedOrientations[xt.crossTileID];
                    eo && (d.placedOrientations[xt.crossTileID] = eo, d.markUsedOrientation(w, Oo = eo, xt));
                  }
                  return Oo;
                }, Os = function(Br, Oo) {
                  if (w.allowVerticalPlacement && xt.numVerticalGlyphVertices > 0 && Yt.verticalTextBox)
                    for (var eo = 0, Sl = w.writingModes; eo < Sl.length && (Sl[eo] === a.WritingMode.vertical ? ($t = Oo(), si = $t) : $t = Br(), !($t && $t.box && $t.box.length)); eo += 1)
                      ;
                  else
                    $t = Br();
                };
                if (E.get("text-variable-anchor")) {
                  var Qi = E.get("text-variable-anchor");
                  if (d.prevPlacement && d.prevPlacement.variableOffsets[xt.crossTileID]) {
                    var ca = d.prevPlacement.variableOffsets[xt.crossTileID];
                    Qi.indexOf(ca.anchor) > 0 && (Qi = Qi.filter(function(Br) {
                      return Br !== ca.anchor;
                    })).unshift(ca.anchor);
                  }
                  var Zo = function(Br, Oo, eo) {
                    for (var Sl = Br.x2 - Br.x1, Yv = Br.y2 - Br.y1, Oh = xt.textBoxScale, Jv = Me && !me ? Oo : null, yc = { box: [], offscreen: !1 }, zm = le ? 2 * Qi.length : Qi.length, uu = 0; uu < zm; ++uu) {
                      var Ch = d.attemptAnchorPlacement(Qi[uu % Qi.length], Br, Sl, Yv, Oh, xe, Ae, $, O, te, uu >= Qi.length, xt, w, eo, Jv);
                      if (Ch && (yc = Ch.placedGlyphBoxes) && yc.box && yc.box.length) {
                        Kt = !0, Ht = Ch.shift;
                        break;
                      }
                    }
                    return yc;
                  };
                  Os(function() {
                    return Zo(mo, Yt.iconBox, a.WritingMode.horizontal);
                  }, function() {
                    var Br = Yt.verticalTextBox;
                    return w.allowVerticalPlacement && !($t && $t.box && $t.box.length) && xt.numVerticalGlyphVertices > 0 && Br ? Zo(Br, Yt.verticalIconBox, a.WritingMode.vertical) : { box: null, offscreen: null };
                  }), $t && (Kt = $t.box, nr = $t.offscreen);
                  var pc = $i($t && $t.box);
                  if (!Kt && d.prevPlacement) {
                    var su = d.prevPlacement.variableOffsets[xt.crossTileID];
                    su && (d.variableOffsets[xt.crossTileID] = su, d.markUsedJustification(w, su.anchor, xt, pc));
                  }
                } else {
                  var Cs = function(Br, Oo) {
                    var eo = d.collisionIndex.placeCollisionBox(Br, le, $, O, te.predicate);
                    return eo && eo.box && eo.box.length && (d.markUsedOrientation(w, Oo, xt), d.placedOrientations[xt.crossTileID] = Oo), eo;
                  };
                  Os(function() {
                    return Cs(mo, a.WritingMode.horizontal);
                  }, function() {
                    var Br = Yt.verticalTextBox;
                    return w.allowVerticalPlacement && xt.numVerticalGlyphVertices > 0 && Br ? Cs(Br, a.WritingMode.vertical) : { box: null, offscreen: null };
                  }), $i($t && $t.box && $t.box.length);
                }
              }
              if (Kt = (ir = $t) && ir.box && ir.box.length > 0, nr = ir && ir.offscreen, xt.useRuntimeCollisionCircles) {
                var lu = w.text.placedSymbolArray.get(xt.centerJustifiedTextSymbolIndex), dc = a.evaluateSizeForFeature(w.textSizeData, ne, lu), Sa = E.get("text-padding");
                On = d.collisionIndex.placeCollisionCircles(le, lu, w.lineVertexArray, w.glyphOffsetArray, dc, O, k, R, c, Ae, te.predicate, xt.collisionCircleDiameter, Sa), Kt = le || On.circles.length > 0 && !On.collisionDetected, nr = nr && On.offscreen;
              }
              if (Yt.iconFeatureIndex && (Dn = Yt.iconFeatureIndex), Yt.iconBox) {
                var mc = function(Br) {
                  var Oo = Me && Ht ? xa(Br, Ht.x, Ht.y, xe, Ae, d.transform.angle) : Br;
                  return d.collisionIndex.placeCollisionBox(Oo, me, $, O, te.predicate);
                };
                Xt = si && si.box && si.box.length && Yt.verticalIconBox ? (Di = mc(Yt.verticalIconBox)).box.length > 0 : (Di = mc(Yt.iconBox)).box.length > 0, nr = nr && Di.offscreen;
              }
              var Ta = ue || xt.numHorizontalGlyphVertices === 0 && xt.numVerticalGlyphVertices === 0, li = Y || xt.numIconVertices === 0;
              if (Ta || li ? li ? Ta || (Xt = Xt && Kt) : Kt = Xt && Kt : Xt = Kt = Xt && Kt, Kt && ir && ir.box && d.collisionIndex.insertCollisionBox(ir.box, E.get("text-ignore-placement"), w.bucketInstanceId, si && si.box && Mn ? Mn : gi, te.ID), Xt && Di && d.collisionIndex.insertCollisionBox(Di.box, E.get("icon-ignore-placement"), w.bucketInstanceId, Dn, te.ID), On && (Kt && d.collisionIndex.insertCollisionCircles(On.circles, E.get("text-ignore-placement"), w.bucketInstanceId, gi, te.ID), c)) {
                var $a = w.bucketInstanceId, As = d.collisionCircleArrays[$a];
                As === void 0 && (As = d.collisionCircleArrays[$a] = new Go());
                for (var El = 0; El < On.circles.length; El += 4)
                  As.circles.push(On.circles[El + 0]), As.circles.push(On.circles[El + 1]), As.circles.push(On.circles[El + 2]), As.circles.push(On.collisionDetected ? 1 : 0);
              }
              d.placements[xt.crossTileID] = new am(Kt || je, Xt || nt, nr || w.justReloaded), f[xt.crossTileID] = !0;
            }
        };
        if (ke)
          for (var gt = w.getSortedSymbolIndexes(this.transform.angle), Dt = gt.length - 1; Dt >= 0; --Dt) {
            var Bt = gt[Dt];
            tt(w.symbolInstances.get(Bt), w.collisionArrays[Bt]);
          }
        else
          for (var zt = u.symbolInstanceStart; zt < u.symbolInstanceEnd; zt++)
            tt(w.symbolInstances.get(zt), w.collisionArrays[zt]);
        if (c && w.bucketInstanceId in this.collisionCircleArrays) {
          var Ir = this.collisionCircleArrays[w.bucketInstanceId];
          a.invert(Ir.invProjMatrix, O), Ir.viewportMatrix = this.collisionIndex.getViewportMatrix();
        }
        w.justReloaded = !1;
      }, Ui.prototype.markUsedJustification = function(u, f, c, d) {
        var _;
        _ = d === a.WritingMode.vertical ? c.verticalPlacedTextSymbolIndex : { left: c.leftJustifiedTextSymbolIndex, center: c.centerJustifiedTextSymbolIndex, right: c.rightJustifiedTextSymbolIndex }[a.getAnchorJustification(f)];
        for (var w = 0, E = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex]; w < E.length; w += 1) {
          var O = E[w];
          O >= 0 && (u.text.placedSymbolArray.get(O).crossTileID = _ >= 0 && O !== _ ? 0 : c.crossTileID);
        }
      }, Ui.prototype.markUsedOrientation = function(u, f, c) {
        for (var d = f === a.WritingMode.horizontal || f === a.WritingMode.horizontalOnly ? f : 0, _ = f === a.WritingMode.vertical ? f : 0, w = 0, E = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex]; w < E.length; w += 1)
          u.text.placedSymbolArray.get(E[w]).placedOrientation = d;
        c.verticalPlacedTextSymbolIndex && (u.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = _);
      }, Ui.prototype.commit = function(u) {
        this.commitTime = u, this.zoomAtLastRecencyCheck = this.transform.zoom;
        var f = this.prevPlacement, c = !1;
        this.prevZoomAdjustment = f ? f.zoomAdjustment(this.transform.zoom) : 0;
        var d = f ? f.symbolFadeChange(u) : 1, _ = f ? f.opacities : {}, w = f ? f.variableOffsets : {}, E = f ? f.placedOrientations : {};
        for (var O in this.placements) {
          var k = this.placements[O], R = _[O];
          R ? (this.opacities[O] = new To(R, d, k.text, k.icon), c = c || k.text !== R.text.placed || k.icon !== R.icon.placed) : (this.opacities[O] = new To(null, d, k.text, k.icon, k.skipFade), c = c || k.text || k.icon);
        }
        for (var $ in _) {
          var W = _[$];
          if (!this.opacities[$]) {
            var H = new To(W, d, !1, !1);
            H.isHidden() || (this.opacities[$] = H, c = c || W.text.placed || W.icon.placed);
          }
        }
        for (var ne in w)
          this.variableOffsets[ne] || !this.opacities[ne] || this.opacities[ne].isHidden() || (this.variableOffsets[ne] = w[ne]);
        for (var te in E)
          this.placedOrientations[te] || !this.opacities[te] || this.opacities[te].isHidden() || (this.placedOrientations[te] = E[te]);
        c ? this.lastPlacementChangeTime = u : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = f ? f.lastPlacementChangeTime : u);
      }, Ui.prototype.updateLayerOpacities = function(u, f) {
        for (var c = {}, d = 0, _ = f; d < _.length; d += 1) {
          var w = _[d], E = w.getBucket(u);
          E && w.latestFeatureIndex && u.id === E.layerIds[0] && this.updateBucketOpacities(E, c, w.collisionBoxArray);
        }
      }, Ui.prototype.updateBucketOpacities = function(u, f, c) {
        var d = this;
        u.hasTextData() && u.text.opacityVertexArray.clear(), u.hasIconData() && u.icon.opacityVertexArray.clear(), u.hasIconCollisionBoxData() && u.iconCollisionBox.collisionVertexArray.clear(), u.hasTextCollisionBoxData() && u.textCollisionBox.collisionVertexArray.clear();
        var _ = u.layers[0].layout, w = new To(null, 0, !1, !1, !0), E = _.get("text-allow-overlap"), O = _.get("icon-allow-overlap"), k = _.get("text-variable-anchor"), R = _.get("text-rotation-alignment") === "map", $ = _.get("text-pitch-alignment") === "map", W = _.get("icon-text-fit") !== "none", H = new To(null, 0, E && (O || !u.hasIconData() || _.get("icon-optional")), O && (E || !u.hasTextData() || _.get("text-optional")), !0);
        !u.collisionArrays && c && (u.hasIconCollisionBoxData() || u.hasTextCollisionBoxData()) && u.deserializeCollisionBoxes(c);
        for (var ne = function(le, me, xe) {
          for (var Ae = 0; Ae < me / 4; Ae++)
            le.opacityVertexArray.emplaceBack(xe);
        }, te = function(le) {
          var me = u.symbolInstances.get(le), xe = me.numHorizontalGlyphVertices, Ae = me.numVerticalGlyphVertices, Me = me.crossTileID, ke = d.opacities[Me];
          f[Me] ? ke = w : ke || (d.opacities[Me] = ke = H), f[Me] = !0;
          var je = me.numIconVertices > 0, nt = d.placedOrientations[me.crossTileID], tt = nt === a.WritingMode.vertical, gt = nt === a.WritingMode.horizontal || nt === a.WritingMode.horizontalOnly;
          if (xe > 0 || Ae > 0) {
            var Dt = um(ke.text);
            ne(u.text, xe, tt ? Kl : Dt), ne(u.text, Ae, gt ? Kl : Dt);
            var Bt = ke.text.isHidden();
            [me.rightJustifiedTextSymbolIndex, me.centerJustifiedTextSymbolIndex, me.leftJustifiedTextSymbolIndex].forEach(function($t) {
              $t >= 0 && (u.text.placedSymbolArray.get($t).hidden = Bt || tt ? 1 : 0);
            }), me.verticalPlacedTextSymbolIndex >= 0 && (u.text.placedSymbolArray.get(me.verticalPlacedTextSymbolIndex).hidden = Bt || gt ? 1 : 0);
            var zt = d.variableOffsets[me.crossTileID];
            zt && d.markUsedJustification(u, zt.anchor, me, nt);
            var Ir = d.placedOrientations[me.crossTileID];
            Ir && (d.markUsedJustification(u, "left", me, Ir), d.markUsedOrientation(u, Ir, me));
          }
          if (je) {
            var xt = um(ke.icon), Yt = !(W && me.verticalPlacedIconSymbolIndex && tt);
            me.placedIconSymbolIndex >= 0 && (ne(u.icon, me.numIconVertices, Yt ? xt : Kl), u.icon.placedSymbolArray.get(me.placedIconSymbolIndex).hidden = ke.icon.isHidden()), me.verticalPlacedIconSymbolIndex >= 0 && (ne(u.icon, me.numVerticalIconVertices, Yt ? Kl : xt), u.icon.placedSymbolArray.get(me.verticalPlacedIconSymbolIndex).hidden = ke.icon.isHidden());
          }
          if (u.hasIconCollisionBoxData() || u.hasTextCollisionBoxData()) {
            var ir = u.collisionArrays[le];
            if (ir) {
              var Kt = new a.Point(0, 0);
              if (ir.textBox || ir.verticalTextBox) {
                var Xt = !0;
                if (k) {
                  var nr = d.variableOffsets[Me];
                  nr ? (Kt = Si(nr.anchor, nr.width, nr.height, nr.textOffset, nr.textBoxScale), R && Kt._rotate($ ? d.transform.angle : -d.transform.angle)) : Xt = !1;
                }
                ir.textBox && al(u.textCollisionBox.collisionVertexArray, ke.text.placed, !Xt || tt, Kt.x, Kt.y), ir.verticalTextBox && al(u.textCollisionBox.collisionVertexArray, ke.text.placed, !Xt || gt, Kt.x, Kt.y);
              }
              var Ht = Boolean(!gt && ir.verticalIconBox);
              ir.iconBox && al(u.iconCollisionBox.collisionVertexArray, ke.icon.placed, Ht, W ? Kt.x : 0, W ? Kt.y : 0), ir.verticalIconBox && al(u.iconCollisionBox.collisionVertexArray, ke.icon.placed, !Ht, W ? Kt.x : 0, W ? Kt.y : 0);
            }
          }
        }, ue = 0; ue < u.symbolInstances.length; ue++)
          te(ue);
        if (u.sortFeatures(this.transform.angle), this.retainedQueryData[u.bucketInstanceId] && (this.retainedQueryData[u.bucketInstanceId].featureSortOrder = u.featureSortOrder), u.hasTextData() && u.text.opacityVertexBuffer && u.text.opacityVertexBuffer.updateData(u.text.opacityVertexArray), u.hasIconData() && u.icon.opacityVertexBuffer && u.icon.opacityVertexBuffer.updateData(u.icon.opacityVertexArray), u.hasIconCollisionBoxData() && u.iconCollisionBox.collisionVertexBuffer && u.iconCollisionBox.collisionVertexBuffer.updateData(u.iconCollisionBox.collisionVertexArray), u.hasTextCollisionBoxData() && u.textCollisionBox.collisionVertexBuffer && u.textCollisionBox.collisionVertexBuffer.updateData(u.textCollisionBox.collisionVertexArray), u.bucketInstanceId in this.collisionCircleArrays) {
          var Y = this.collisionCircleArrays[u.bucketInstanceId];
          u.placementInvProjMatrix = Y.invProjMatrix, u.placementViewportMatrix = Y.viewportMatrix, u.collisionCircleArray = Y.circles, delete this.collisionCircleArrays[u.bucketInstanceId];
        }
      }, Ui.prototype.symbolFadeChange = function(u) {
        return this.fadeDuration === 0 ? 1 : (u - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
      }, Ui.prototype.zoomAdjustment = function(u) {
        return Math.max(0, (this.transform.zoom - u) / 1.5);
      }, Ui.prototype.hasTransitions = function(u) {
        return this.stale || u - this.lastPlacementChangeTime < this.fadeDuration;
      }, Ui.prototype.stillRecent = function(u, f) {
        var c = this.zoomAtLastRecencyCheck === f ? 1 - this.zoomAdjustment(f) : 1;
        return this.zoomAtLastRecencyCheck = f, this.commitTime + this.fadeDuration * c > u;
      }, Ui.prototype.setStale = function() {
        this.stale = !0;
      };
      var Fv = Math.pow(2, 25), Bv = Math.pow(2, 24), Wf = Math.pow(2, 17), Vv = Math.pow(2, 16), sm = Math.pow(2, 9), Uv = Math.pow(2, 8), lm = Math.pow(2, 1);
      function um(u) {
        if (u.opacity === 0 && !u.placed)
          return 0;
        if (u.opacity === 1 && u.placed)
          return 4294967295;
        var f = u.placed ? 1 : 0, c = Math.floor(127 * u.opacity);
        return c * Fv + f * Bv + c * Wf + f * Vv + c * sm + f * Uv + c * lm + f;
      }
      var Kl = 0, Hf = function(u) {
        this._sortAcrossTiles = u.layout.get("symbol-z-order") !== "viewport-y" && u.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
      };
      Hf.prototype.continuePlacement = function(u, f, c, d, _) {
        for (var w = this._bucketParts; this._currentTileIndex < u.length; )
          if (f.getBucketParts(w, d, u[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, _())
            return !0;
        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, w.sort(function(E, O) {
          return E.sortKey - O.sortKey;
        })); this._currentPartIndex < w.length; )
          if (f.placeLayerBucketPart(w[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, _())
            return !0;
        return !1;
      };
      var Ku = function(u, f, c, d, _, w, E) {
        this.placement = new Ui(u, _, w, E), this._currentPlacementIndex = f.length - 1, this._forceFullPlacement = c, this._showCollisionBoxes = d, this._done = !1;
      };
      Ku.prototype.isDone = function() {
        return this._done;
      }, Ku.prototype.continuePlacement = function(u, f, c) {
        for (var d = this, _ = a.browser.now(), w = function() {
          var k = a.browser.now() - _;
          return !d._forceFullPlacement && k > 2;
        }; this._currentPlacementIndex >= 0; ) {
          var E = f[u[this._currentPlacementIndex]], O = this.placement.collisionIndex.transform.zoom;
          if (E.type === "symbol" && (!E.minzoom || E.minzoom <= O) && (!E.maxzoom || E.maxzoom > O)) {
            if (this._inProgressLayer || (this._inProgressLayer = new Hf(E)), this._inProgressLayer.continuePlacement(c[E.source], this.placement, this._showCollisionBoxes, E, w))
              return;
            delete this._inProgressLayer;
          }
          this._currentPlacementIndex--;
        }
        this._done = !0;
      }, Ku.prototype.commit = function(u) {
        return this.placement.commit(u), this.placement;
      };
      var cm = 512 / a.EXTENT / 2, lh = function(u, f, c) {
        this.tileID = u, this.indexedSymbolInstances = {}, this.bucketInstanceId = c;
        for (var d = 0; d < f.length; d++) {
          var _ = f.get(d), w = _.key;
          this.indexedSymbolInstances[w] || (this.indexedSymbolInstances[w] = []), this.indexedSymbolInstances[w].push({ crossTileID: _.crossTileID, coord: this.getScaledCoordinates(_, u) });
        }
      };
      lh.prototype.getScaledCoordinates = function(u, f) {
        var c = cm / Math.pow(2, f.canonical.z - this.tileID.canonical.z);
        return { x: Math.floor((f.canonical.x * a.EXTENT + u.anchorX) * c), y: Math.floor((f.canonical.y * a.EXTENT + u.anchorY) * c) };
      }, lh.prototype.findMatches = function(u, f, c) {
        for (var d = this.tileID.canonical.z < f.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - f.canonical.z), _ = 0; _ < u.length; _++) {
          var w = u.get(_);
          if (!w.crossTileID) {
            var E = this.indexedSymbolInstances[w.key];
            if (E)
              for (var O = this.getScaledCoordinates(w, f), k = 0, R = E; k < R.length; k += 1) {
                var $ = R[k];
                if (Math.abs($.coord.x - O.x) <= d && Math.abs($.coord.y - O.y) <= d && !c[$.crossTileID]) {
                  c[$.crossTileID] = !0, w.crossTileID = $.crossTileID;
                  break;
                }
              }
          }
        }
      };
      var $o = function() {
        this.maxCrossTileID = 0;
      };
      $o.prototype.generate = function() {
        return ++this.maxCrossTileID;
      };
      var ds = function() {
        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
      };
      ds.prototype.handleWrapJump = function(u) {
        var f = Math.round((u - this.lng) / 360);
        if (f !== 0)
          for (var c in this.indexes) {
            var d = this.indexes[c], _ = {};
            for (var w in d) {
              var E = d[w];
              E.tileID = E.tileID.unwrapTo(E.tileID.wrap + f), _[E.tileID.key] = E;
            }
            this.indexes[c] = _;
          }
        this.lng = u;
      }, ds.prototype.addBucket = function(u, f, c) {
        if (this.indexes[u.overscaledZ] && this.indexes[u.overscaledZ][u.key]) {
          if (this.indexes[u.overscaledZ][u.key].bucketInstanceId === f.bucketInstanceId)
            return !1;
          this.removeBucketCrossTileIDs(u.overscaledZ, this.indexes[u.overscaledZ][u.key]);
        }
        for (var d = 0; d < f.symbolInstances.length; d++)
          f.symbolInstances.get(d).crossTileID = 0;
        this.usedCrossTileIDs[u.overscaledZ] || (this.usedCrossTileIDs[u.overscaledZ] = {});
        var _ = this.usedCrossTileIDs[u.overscaledZ];
        for (var w in this.indexes) {
          var E = this.indexes[w];
          if (Number(w) > u.overscaledZ)
            for (var O in E) {
              var k = E[O];
              k.tileID.isChildOf(u) && k.findMatches(f.symbolInstances, u, _);
            }
          else {
            var R = E[u.scaledTo(Number(w)).key];
            R && R.findMatches(f.symbolInstances, u, _);
          }
        }
        for (var $ = 0; $ < f.symbolInstances.length; $++) {
          var W = f.symbolInstances.get($);
          W.crossTileID || (W.crossTileID = c.generate(), _[W.crossTileID] = !0);
        }
        return this.indexes[u.overscaledZ] === void 0 && (this.indexes[u.overscaledZ] = {}), this.indexes[u.overscaledZ][u.key] = new lh(u, f.symbolInstances, f.bucketInstanceId), !0;
      }, ds.prototype.removeBucketCrossTileIDs = function(u, f) {
        for (var c in f.indexedSymbolInstances)
          for (var d = 0, _ = f.indexedSymbolInstances[c]; d < _.length; d += 1)
            delete this.usedCrossTileIDs[u][_[d].crossTileID];
      }, ds.prototype.removeStaleBuckets = function(u) {
        var f = !1;
        for (var c in this.indexes) {
          var d = this.indexes[c];
          for (var _ in d)
            u[d[_].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, d[_]), delete d[_], f = !0);
        }
        return f;
      };
      var ms = function() {
        this.layerIndexes = {}, this.crossTileIDs = new $o(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
      };
      ms.prototype.addLayer = function(u, f, c) {
        var d = this.layerIndexes[u.id];
        d === void 0 && (d = this.layerIndexes[u.id] = new ds());
        var _ = !1, w = {};
        d.handleWrapJump(c);
        for (var E = 0, O = f; E < O.length; E += 1) {
          var k = O[E], R = k.getBucket(u);
          R && u.id === R.layerIds[0] && (R.bucketInstanceId || (R.bucketInstanceId = ++this.maxBucketInstanceId), d.addBucket(k.tileID, R, this.crossTileIDs) && (_ = !0), w[R.bucketInstanceId] = !0);
        }
        return d.removeStaleBuckets(w) && (_ = !0), _;
      }, ms.prototype.pruneUnusedLayers = function(u) {
        var f = {};
        for (var c in u.forEach(function(d) {
          f[d] = !0;
        }), this.layerIndexes)
          f[c] || delete this.layerIndexes[c];
      };
      var sl = function(u, f) {
        return a.emitValidationErrors(u, f && f.filter(function(c) {
          return c.identifier !== "source.canvas";
        }));
      }, ys = a.pick(De, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), gs = a.pick(De, ["setCenter", "setZoom", "setBearing", "setPitch"]), uh = function() {
        var u = {}, f = a.styleSpec.$version;
        for (var c in a.styleSpec.$root) {
          var d, _ = a.styleSpec.$root[c];
          _.required && (d = c === "version" ? f : _.type === "array" ? [] : {}) != null && (u[c] = d);
        }
        return u;
      }(), lo = function(u) {
        function f(c, d) {
          var _ = this;
          d === void 0 && (d = {}), u.call(this), this.map = c, this.dispatcher = new be(Le(), this), this.imageManager = new X(), this.imageManager.setEventedParent(this), this.glyphManager = new Se(c._requestManager, d.localIdeographFontFamily), this.lineAtlas = new at(256, 512), this.crossTileSymbolIndex = new ms(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new a.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", a.getReferrer());
          var w = this;
          this._rtlTextPluginCallback = f.registerForPluginStateChange(function(E) {
            w.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: E.pluginStatus, pluginURL: E.pluginURL }, function(O, k) {
              if (a.triggerPluginCompletionEvent(O), k && k.every(function($) {
                return $;
              }))
                for (var R in w.sourceCaches)
                  w.sourceCaches[R].reload();
            });
          }), this.on("data", function(E) {
            if (E.dataType === "source" && E.sourceDataType === "metadata") {
              var O = _.sourceCaches[E.sourceId];
              if (O) {
                var k = O.getSource();
                if (k && k.vectorLayerIds)
                  for (var R in _._layers) {
                    var $ = _._layers[R];
                    $.source === k.id && _._validateLayer($);
                  }
              }
            }
          });
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.loadURL = function(c, d) {
          var _ = this;
          d === void 0 && (d = {}), this.fire(new a.Event("dataloading", { dataType: "style" }));
          var w = typeof d.validate == "boolean" ? d.validate : !a.isMapboxURL(c);
          c = this.map._requestManager.normalizeStyleURL(c, d.accessToken);
          var E = this.map._requestManager.transformRequest(c, a.ResourceType.Style);
          this._request = a.getJSON(E, function(O, k) {
            _._request = null, O ? _.fire(new a.ErrorEvent(O)) : k && _._load(k, w);
          });
        }, f.prototype.loadJSON = function(c, d) {
          var _ = this;
          d === void 0 && (d = {}), this.fire(new a.Event("dataloading", { dataType: "style" })), this._request = a.browser.frame(function() {
            _._request = null, _._load(c, d.validate !== !1);
          });
        }, f.prototype.loadEmpty = function() {
          this.fire(new a.Event("dataloading", { dataType: "style" })), this._load(uh, !1);
        }, f.prototype._load = function(c, d) {
          if (!d || !sl(this, a.validateStyle(c))) {
            for (var _ in this._loaded = !0, this.stylesheet = c, c.sources)
              this.addSource(_, c.sources[_], { validate: !1 });
            c.sprite ? this._loadSprite(c.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(c.glyphs);
            var w = st(this.stylesheet.layers);
            this._order = w.map(function(R) {
              return R.id;
            }), this._layers = {}, this._serializedLayers = {};
            for (var E = 0, O = w; E < O.length; E += 1) {
              var k = O[E];
              (k = a.createStyleLayer(k)).setEventedParent(this, { layer: { id: k.id } }), this._layers[k.id] = k, this._serializedLayers[k.id] = k.serialize();
            }
            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new $e(this.stylesheet.light), this.fire(new a.Event("data", { dataType: "style" })), this.fire(new a.Event("style.load"));
          }
        }, f.prototype._loadSprite = function(c) {
          var d = this;
          this._spriteRequest = function(_, w, E) {
            var O, k, R, $ = a.browser.devicePixelRatio > 1 ? "@2x" : "", W = a.getJSON(w.transformRequest(w.normalizeSpriteURL(_, $, ".json"), a.ResourceType.SpriteJSON), function(te, ue) {
              W = null, R || (R = te, O = ue, ne());
            }), H = a.getImage(w.transformRequest(w.normalizeSpriteURL(_, $, ".png"), a.ResourceType.SpriteImage), function(te, ue) {
              H = null, R || (R = te, k = ue, ne());
            });
            function ne() {
              if (R)
                E(R);
              else if (O && k) {
                var te = a.browser.getImageData(k), ue = {};
                for (var Y in O) {
                  var le = O[Y], me = le.width, xe = le.height, Ae = le.x, Me = le.y, ke = le.sdf, je = le.pixelRatio, nt = le.stretchX, tt = le.stretchY, gt = le.content, Dt = new a.RGBAImage({ width: me, height: xe });
                  a.RGBAImage.copy(te, Dt, { x: Ae, y: Me }, { x: 0, y: 0 }, { width: me, height: xe }), ue[Y] = { data: Dt, pixelRatio: je, sdf: ke, stretchX: nt, stretchY: tt, content: gt };
                }
                E(null, ue);
              }
            }
            return { cancel: function() {
              W && (W.cancel(), W = null), H && (H.cancel(), H = null);
            } };
          }(c, this.map._requestManager, function(_, w) {
            if (d._spriteRequest = null, _)
              d.fire(new a.ErrorEvent(_));
            else if (w)
              for (var E in w)
                d.imageManager.addImage(E, w[E]);
            d.imageManager.setLoaded(!0), d._availableImages = d.imageManager.listImages(), d.dispatcher.broadcast("setImages", d._availableImages), d.fire(new a.Event("data", { dataType: "style" }));
          });
        }, f.prototype._validateLayer = function(c) {
          var d = this.sourceCaches[c.source];
          if (d) {
            var _ = c.sourceLayer;
            if (_) {
              var w = d.getSource();
              (w.type === "geojson" || w.vectorLayerIds && w.vectorLayerIds.indexOf(_) === -1) && this.fire(new a.ErrorEvent(new Error('Source layer "' + _ + '" does not exist on source "' + w.id + '" as specified by style layer "' + c.id + '"')));
            }
          }
        }, f.prototype.loaded = function() {
          if (!this._loaded || Object.keys(this._updatedSources).length)
            return !1;
          for (var c in this.sourceCaches)
            if (!this.sourceCaches[c].loaded())
              return !1;
          return !!this.imageManager.isLoaded();
        }, f.prototype._serializeLayers = function(c) {
          for (var d = [], _ = 0, w = c; _ < w.length; _ += 1) {
            var E = this._layers[w[_]];
            E.type !== "custom" && d.push(E.serialize());
          }
          return d;
        }, f.prototype.hasTransitions = function() {
          if (this.light && this.light.hasTransition())
            return !0;
          for (var c in this.sourceCaches)
            if (this.sourceCaches[c].hasTransition())
              return !0;
          for (var d in this._layers)
            if (this._layers[d].hasTransition())
              return !0;
          return !1;
        }, f.prototype._checkLoaded = function() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }, f.prototype.update = function(c) {
          if (this._loaded) {
            var d = this._changed;
            if (this._changed) {
              var _ = Object.keys(this._updatedLayers), w = Object.keys(this._removedLayers);
              for (var E in (_.length || w.length) && this._updateWorkerLayers(_, w), this._updatedSources) {
                var O = this._updatedSources[E];
                O === "reload" ? this._reloadSource(E) : O === "clear" && this._clearSource(E);
              }
              for (var k in this._updateTilesForChangedImages(), this._updatedPaintProps)
                this._layers[k].updateTransitions(c);
              this.light.updateTransitions(c), this._resetUpdates();
            }
            var R = {};
            for (var $ in this.sourceCaches) {
              var W = this.sourceCaches[$];
              R[$] = W.used, W.used = !1;
            }
            for (var H = 0, ne = this._order; H < ne.length; H += 1) {
              var te = this._layers[ne[H]];
              te.recalculate(c, this._availableImages), !te.isHidden(c.zoom) && te.source && (this.sourceCaches[te.source].used = !0);
            }
            for (var ue in R) {
              var Y = this.sourceCaches[ue];
              R[ue] !== Y.used && Y.fire(new a.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: ue }));
            }
            this.light.recalculate(c), this.z = c.zoom, d && this.fire(new a.Event("data", { dataType: "style" }));
          }
        }, f.prototype._updateTilesForChangedImages = function() {
          var c = Object.keys(this._changedImages);
          if (c.length) {
            for (var d in this.sourceCaches)
              this.sourceCaches[d].reloadTilesForDependencies(["icons", "patterns"], c);
            this._changedImages = {};
          }
        }, f.prototype._updateWorkerLayers = function(c, d) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(c), removedIds: d });
        }, f.prototype._resetUpdates = function() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
        }, f.prototype.setState = function(c) {
          var d = this;
          if (this._checkLoaded(), sl(this, a.validateStyle(c)))
            return !1;
          (c = a.clone$1(c)).layers = st(c.layers);
          var _ = function(E, O) {
            if (!E)
              return [{ command: De.setStyle, args: [O] }];
            var k = [];
            try {
              if (!a.deepEqual(E.version, O.version))
                return [{ command: De.setStyle, args: [O] }];
              a.deepEqual(E.center, O.center) || k.push({ command: De.setCenter, args: [O.center] }), a.deepEqual(E.zoom, O.zoom) || k.push({ command: De.setZoom, args: [O.zoom] }), a.deepEqual(E.bearing, O.bearing) || k.push({ command: De.setBearing, args: [O.bearing] }), a.deepEqual(E.pitch, O.pitch) || k.push({ command: De.setPitch, args: [O.pitch] }), a.deepEqual(E.sprite, O.sprite) || k.push({ command: De.setSprite, args: [O.sprite] }), a.deepEqual(E.glyphs, O.glyphs) || k.push({ command: De.setGlyphs, args: [O.glyphs] }), a.deepEqual(E.transition, O.transition) || k.push({ command: De.setTransition, args: [O.transition] }), a.deepEqual(E.light, O.light) || k.push({ command: De.setLight, args: [O.light] });
              var R = {}, $ = [];
              (function(H, ne, te, ue) {
                var Y;
                for (Y in ne = ne || {}, H = H || {})
                  H.hasOwnProperty(Y) && (ne.hasOwnProperty(Y) || Ee(Y, te, ue));
                for (Y in ne)
                  ne.hasOwnProperty(Y) && (H.hasOwnProperty(Y) ? a.deepEqual(H[Y], ne[Y]) || (H[Y].type === "geojson" && ne[Y].type === "geojson" && jt(H, ne, Y) ? te.push({ command: De.setGeoJSONSourceData, args: [Y, ne[Y].data] }) : He(Y, ne, te, ue)) : fe(Y, ne, te));
              })(E.sources, O.sources, $, R);
              var W = [];
              E.layers && E.layers.forEach(function(H) {
                R[H.source] ? k.push({ command: De.removeLayer, args: [H.id] }) : W.push(H);
              }), k = k.concat($), function(H, ne, te) {
                ne = ne || [];
                var ue, Y, le, me, xe, Ae, Me, ke = (H = H || []).map(Jt), je = ne.map(Jt), nt = H.reduce(Zt, {}), tt = ne.reduce(Zt, {}), gt = ke.slice(), Dt = /* @__PURE__ */ Object.create(null);
                for (ue = 0, Y = 0; ue < ke.length; ue++)
                  tt.hasOwnProperty(le = ke[ue]) ? Y++ : (te.push({ command: De.removeLayer, args: [le] }), gt.splice(gt.indexOf(le, Y), 1));
                for (ue = 0, Y = 0; ue < je.length; ue++)
                  gt[gt.length - 1 - ue] !== (le = je[je.length - 1 - ue]) && (nt.hasOwnProperty(le) ? (te.push({ command: De.removeLayer, args: [le] }), gt.splice(gt.lastIndexOf(le, gt.length - Y), 1)) : Y++, te.push({ command: De.addLayer, args: [tt[le], Ae = gt[gt.length - ue]] }), gt.splice(gt.length - ue, 0, le), Dt[le] = !0);
                for (ue = 0; ue < je.length; ue++)
                  if (me = nt[le = je[ue]], xe = tt[le], !Dt[le] && !a.deepEqual(me, xe))
                    if (a.deepEqual(me.source, xe.source) && a.deepEqual(me["source-layer"], xe["source-layer"]) && a.deepEqual(me.type, xe.type)) {
                      for (Me in Wt(me.layout, xe.layout, te, le, null, De.setLayoutProperty), Wt(me.paint, xe.paint, te, le, null, De.setPaintProperty), a.deepEqual(me.filter, xe.filter) || te.push({ command: De.setFilter, args: [le, xe.filter] }), a.deepEqual(me.minzoom, xe.minzoom) && a.deepEqual(me.maxzoom, xe.maxzoom) || te.push({ command: De.setLayerZoomRange, args: [le, xe.minzoom, xe.maxzoom] }), me)
                        me.hasOwnProperty(Me) && Me !== "layout" && Me !== "paint" && Me !== "filter" && Me !== "metadata" && Me !== "minzoom" && Me !== "maxzoom" && (Me.indexOf("paint.") === 0 ? Wt(me[Me], xe[Me], te, le, Me.slice(6), De.setPaintProperty) : a.deepEqual(me[Me], xe[Me]) || te.push({ command: De.setLayerProperty, args: [le, Me, xe[Me]] }));
                      for (Me in xe)
                        xe.hasOwnProperty(Me) && !me.hasOwnProperty(Me) && Me !== "layout" && Me !== "paint" && Me !== "filter" && Me !== "metadata" && Me !== "minzoom" && Me !== "maxzoom" && (Me.indexOf("paint.") === 0 ? Wt(me[Me], xe[Me], te, le, Me.slice(6), De.setPaintProperty) : a.deepEqual(me[Me], xe[Me]) || te.push({ command: De.setLayerProperty, args: [le, Me, xe[Me]] }));
                    } else
                      te.push({ command: De.removeLayer, args: [le] }), Ae = gt[gt.lastIndexOf(le) + 1], te.push({ command: De.addLayer, args: [xe, Ae] });
              }(W, O.layers, k);
            } catch (H) {
              console.warn("Unable to compute style diff:", H), k = [{ command: De.setStyle, args: [O] }];
            }
            return k;
          }(this.serialize(), c).filter(function(E) {
            return !(E.command in gs);
          });
          if (_.length === 0)
            return !1;
          var w = _.filter(function(E) {
            return !(E.command in ys);
          });
          if (w.length > 0)
            throw new Error("Unimplemented: " + w.map(function(E) {
              return E.command;
            }).join(", ") + ".");
          return _.forEach(function(E) {
            E.command !== "setTransition" && d[E.command].apply(d, E.args);
          }), this.stylesheet = c, !0;
        }, f.prototype.addImage = function(c, d) {
          if (this.getImage(c))
            return this.fire(new a.ErrorEvent(new Error("An image with this name already exists.")));
          this.imageManager.addImage(c, d), this._afterImageUpdated(c);
        }, f.prototype.updateImage = function(c, d) {
          this.imageManager.updateImage(c, d);
        }, f.prototype.getImage = function(c) {
          return this.imageManager.getImage(c);
        }, f.prototype.removeImage = function(c) {
          if (!this.getImage(c))
            return this.fire(new a.ErrorEvent(new Error("No image with this name exists.")));
          this.imageManager.removeImage(c), this._afterImageUpdated(c);
        }, f.prototype._afterImageUpdated = function(c) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[c] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new a.Event("data", { dataType: "style" }));
        }, f.prototype.listImages = function() {
          return this._checkLoaded(), this.imageManager.listImages();
        }, f.prototype.addSource = function(c, d, _) {
          var w = this;
          if (_ === void 0 && (_ = {}), this._checkLoaded(), this.sourceCaches[c] !== void 0)
            throw new Error("There is already a source with this ID");
          if (!d.type)
            throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(d).join(", ") + ".");
          if (!(["vector", "raster", "geojson", "video", "image"].indexOf(d.type) >= 0 && this._validate(a.validateStyle.source, "sources." + c, d, null, _))) {
            this.map && this.map._collectResourceTiming && (d.collectResourceTiming = !0);
            var E = this.sourceCaches[c] = new ie(c, d, this.dispatcher);
            E.style = this, E.setEventedParent(this, function() {
              return { isSourceLoaded: w.loaded(), source: E.serialize(), sourceId: c };
            }), E.onAdd(this.map), this._changed = !0;
          }
        }, f.prototype.removeSource = function(c) {
          if (this._checkLoaded(), this.sourceCaches[c] === void 0)
            throw new Error("There is no source with this ID");
          for (var d in this._layers)
            if (this._layers[d].source === c)
              return this.fire(new a.ErrorEvent(new Error('Source "' + c + '" cannot be removed while layer "' + d + '" is using it.')));
          var _ = this.sourceCaches[c];
          delete this.sourceCaches[c], delete this._updatedSources[c], _.fire(new a.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: c })), _.setEventedParent(null), _.clearTiles(), _.onRemove && _.onRemove(this.map), this._changed = !0;
        }, f.prototype.setGeoJSONSourceData = function(c, d) {
          this._checkLoaded(), this.sourceCaches[c].getSource().setData(d), this._changed = !0;
        }, f.prototype.getSource = function(c) {
          return this.sourceCaches[c] && this.sourceCaches[c].getSource();
        }, f.prototype.addLayer = function(c, d, _) {
          _ === void 0 && (_ = {}), this._checkLoaded();
          var w = c.id;
          if (this.getLayer(w))
            this.fire(new a.ErrorEvent(new Error('Layer with id "' + w + '" already exists on this map')));
          else {
            var E;
            if (c.type === "custom") {
              if (sl(this, a.validateCustomStyleLayer(c)))
                return;
              E = a.createStyleLayer(c);
            } else {
              if (typeof c.source == "object" && (this.addSource(w, c.source), c = a.clone$1(c), c = a.extend(c, { source: w })), this._validate(a.validateStyle.layer, "layers." + w, c, { arrayIndex: -1 }, _))
                return;
              E = a.createStyleLayer(c), this._validateLayer(E), E.setEventedParent(this, { layer: { id: w } }), this._serializedLayers[E.id] = E.serialize();
            }
            var O = d ? this._order.indexOf(d) : this._order.length;
            if (d && O === -1)
              this.fire(new a.ErrorEvent(new Error('Layer with id "' + d + '" does not exist on this map.')));
            else {
              if (this._order.splice(O, 0, w), this._layerOrderChanged = !0, this._layers[w] = E, this._removedLayers[w] && E.source && E.type !== "custom") {
                var k = this._removedLayers[w];
                delete this._removedLayers[w], k.type !== E.type ? this._updatedSources[E.source] = "clear" : (this._updatedSources[E.source] = "reload", this.sourceCaches[E.source].pause());
              }
              this._updateLayer(E), E.onAdd && E.onAdd(this.map);
            }
          }
        }, f.prototype.moveLayer = function(c, d) {
          if (this._checkLoaded(), this._changed = !0, this._layers[c]) {
            if (c !== d) {
              var _ = this._order.indexOf(c);
              this._order.splice(_, 1);
              var w = d ? this._order.indexOf(d) : this._order.length;
              d && w === -1 ? this.fire(new a.ErrorEvent(new Error('Layer with id "' + d + '" does not exist on this map.'))) : (this._order.splice(w, 0, c), this._layerOrderChanged = !0);
            }
          } else
            this.fire(new a.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be moved.")));
        }, f.prototype.removeLayer = function(c) {
          this._checkLoaded();
          var d = this._layers[c];
          if (d) {
            d.setEventedParent(null);
            var _ = this._order.indexOf(c);
            this._order.splice(_, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[c] = d, delete this._layers[c], delete this._serializedLayers[c], delete this._updatedLayers[c], delete this._updatedPaintProps[c], d.onRemove && d.onRemove(this.map);
          } else
            this.fire(new a.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be removed.")));
        }, f.prototype.getLayer = function(c) {
          return this._layers[c];
        }, f.prototype.hasLayer = function(c) {
          return c in this._layers;
        }, f.prototype.setLayerZoomRange = function(c, d, _) {
          this._checkLoaded();
          var w = this.getLayer(c);
          w ? w.minzoom === d && w.maxzoom === _ || (d != null && (w.minzoom = d), _ != null && (w.maxzoom = _), this._updateLayer(w)) : this.fire(new a.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot have zoom extent.")));
        }, f.prototype.setFilter = function(c, d, _) {
          _ === void 0 && (_ = {}), this._checkLoaded();
          var w = this.getLayer(c);
          if (w) {
            if (!a.deepEqual(w.filter, d))
              return d == null ? (w.filter = void 0, void this._updateLayer(w)) : void (this._validate(a.validateStyle.filter, "layers." + w.id + ".filter", d, null, _) || (w.filter = a.clone$1(d), this._updateLayer(w)));
          } else
            this.fire(new a.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be filtered.")));
        }, f.prototype.getFilter = function(c) {
          return a.clone$1(this.getLayer(c).filter);
        }, f.prototype.setLayoutProperty = function(c, d, _, w) {
          w === void 0 && (w = {}), this._checkLoaded();
          var E = this.getLayer(c);
          E ? a.deepEqual(E.getLayoutProperty(d), _) || (E.setLayoutProperty(d, _, w), this._updateLayer(E)) : this.fire(new a.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be styled.")));
        }, f.prototype.getLayoutProperty = function(c, d) {
          var _ = this.getLayer(c);
          if (_)
            return _.getLayoutProperty(d);
          this.fire(new a.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style.")));
        }, f.prototype.setPaintProperty = function(c, d, _, w) {
          w === void 0 && (w = {}), this._checkLoaded();
          var E = this.getLayer(c);
          E ? a.deepEqual(E.getPaintProperty(d), _) || (E.setPaintProperty(d, _, w) && this._updateLayer(E), this._changed = !0, this._updatedPaintProps[c] = !0) : this.fire(new a.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be styled.")));
        }, f.prototype.getPaintProperty = function(c, d) {
          return this.getLayer(c).getPaintProperty(d);
        }, f.prototype.setFeatureState = function(c, d) {
          this._checkLoaded();
          var _ = c.source, w = c.sourceLayer, E = this.sourceCaches[_];
          if (E !== void 0) {
            var O = E.getSource().type;
            O === "geojson" && w ? this.fire(new a.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : O !== "vector" || w ? (c.id === void 0 && this.fire(new a.ErrorEvent(new Error("The feature id parameter must be provided."))), E.setFeatureState(w, c.id, d)) : this.fire(new a.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new a.ErrorEvent(new Error("The source '" + _ + "' does not exist in the map's style.")));
        }, f.prototype.removeFeatureState = function(c, d) {
          this._checkLoaded();
          var _ = c.source, w = this.sourceCaches[_];
          if (w !== void 0) {
            var E = w.getSource().type, O = E === "vector" ? c.sourceLayer : void 0;
            E !== "vector" || O ? d && typeof c.id != "string" && typeof c.id != "number" ? this.fire(new a.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : w.removeFeatureState(O, c.id, d) : this.fire(new a.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new a.ErrorEvent(new Error("The source '" + _ + "' does not exist in the map's style.")));
        }, f.prototype.getFeatureState = function(c) {
          this._checkLoaded();
          var d = c.source, _ = c.sourceLayer, w = this.sourceCaches[d];
          if (w !== void 0) {
            if (w.getSource().type !== "vector" || _)
              return c.id === void 0 && this.fire(new a.ErrorEvent(new Error("The feature id parameter must be provided."))), w.getFeatureState(_, c.id);
            this.fire(new a.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new a.ErrorEvent(new Error("The source '" + d + "' does not exist in the map's style.")));
        }, f.prototype.getTransition = function() {
          return a.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }, f.prototype.serialize = function() {
          return a.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: a.mapObject(this.sourceCaches, function(c) {
            return c.serialize();
          }), layers: this._serializeLayers(this._order) }, function(c) {
            return c !== void 0;
          });
        }, f.prototype._updateLayer = function(c) {
          this._updatedLayers[c.id] = !0, c.source && !this._updatedSources[c.source] && this.sourceCaches[c.source].getSource().type !== "raster" && (this._updatedSources[c.source] = "reload", this.sourceCaches[c.source].pause()), this._changed = !0;
        }, f.prototype._flattenAndSortRenderedFeatures = function(c) {
          for (var d = this, _ = function(nt) {
            return d._layers[nt].type === "fill-extrusion";
          }, w = {}, E = [], O = this._order.length - 1; O >= 0; O--) {
            var k = this._order[O];
            if (_(k)) {
              w[k] = O;
              for (var R = 0, $ = c; R < $.length; R += 1) {
                var W = $[R][k];
                if (W)
                  for (var H = 0, ne = W; H < ne.length; H += 1)
                    E.push(ne[H]);
              }
            }
          }
          E.sort(function(nt, tt) {
            return tt.intersectionZ - nt.intersectionZ;
          });
          for (var te = [], ue = this._order.length - 1; ue >= 0; ue--) {
            var Y = this._order[ue];
            if (_(Y))
              for (var le = E.length - 1; le >= 0; le--) {
                var me = E[le].feature;
                if (w[me.layer.id] < ue)
                  break;
                te.push(me), E.pop();
              }
            else
              for (var xe = 0, Ae = c; xe < Ae.length; xe += 1) {
                var Me = Ae[xe][Y];
                if (Me)
                  for (var ke = 0, je = Me; ke < je.length; ke += 1)
                    te.push(je[ke].feature);
              }
          }
          return te;
        }, f.prototype.queryRenderedFeatures = function(c, d, _) {
          d && d.filter && this._validate(a.validateStyle.filter, "queryRenderedFeatures.filter", d.filter, null, d);
          var w = {};
          if (d && d.layers) {
            if (!Array.isArray(d.layers))
              return this.fire(new a.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
            for (var E = 0, O = d.layers; E < O.length; E += 1) {
              var k = O[E], R = this._layers[k];
              if (!R)
                return this.fire(new a.ErrorEvent(new Error("The layer '" + k + "' does not exist in the map's style and cannot be queried for features."))), [];
              w[R.source] = !0;
            }
          }
          var $ = [];
          for (var W in d.availableImages = this._availableImages, this.sourceCaches)
            d.layers && !w[W] || $.push(kr(this.sourceCaches[W], this._layers, this._serializedLayers, c, d, _));
          return this.placement && $.push(function(H, ne, te, ue, Y, le, me) {
            for (var xe = {}, Ae = le.queryRenderedSymbols(ue), Me = [], ke = 0, je = Object.keys(Ae).map(Number); ke < je.length; ke += 1)
              Me.push(me[je[ke]]);
            Me.sort(Vn);
            for (var nt = function() {
              var zt = gt[tt], Ir = zt.featureIndex.lookupSymbolFeatures(Ae[zt.bucketInstanceId], ne, zt.bucketIndex, zt.sourceLayerIndex, Y.filter, Y.layers, Y.availableImages, H);
              for (var xt in Ir) {
                var Yt = xe[xt] = xe[xt] || [], ir = Ir[xt];
                ir.sort(function(nr, Ht) {
                  var $t = zt.featureSortOrder;
                  if ($t) {
                    var si = $t.indexOf(nr.featureIndex);
                    return $t.indexOf(Ht.featureIndex) - si;
                  }
                  return Ht.featureIndex - nr.featureIndex;
                });
                for (var Kt = 0, Xt = ir; Kt < Xt.length; Kt += 1)
                  Yt.push(Xt[Kt]);
              }
            }, tt = 0, gt = Me; tt < gt.length; tt += 1)
              nt();
            var Dt = function(zt) {
              xe[zt].forEach(function(Ir) {
                var xt = Ir.feature, Yt = te[H[zt].source].getFeatureState(xt.layer["source-layer"], xt.id);
                xt.source = xt.layer.source, xt.layer["source-layer"] && (xt.sourceLayer = xt.layer["source-layer"]), xt.state = Yt;
              });
            };
            for (var Bt in xe)
              Dt(Bt);
            return xe;
          }(this._layers, this._serializedLayers, this.sourceCaches, c, d, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures($);
        }, f.prototype.querySourceFeatures = function(c, d) {
          d && d.filter && this._validate(a.validateStyle.filter, "querySourceFeatures.filter", d.filter, null, d);
          var _ = this.sourceCaches[c];
          return _ ? function(w, E) {
            for (var O = w.getRenderableIds().map(function(ne) {
              return w.getTileByID(ne);
            }), k = [], R = {}, $ = 0; $ < O.length; $++) {
              var W = O[$], H = W.tileID.canonical.key;
              R[H] || (R[H] = !0, W.querySourceFeatures(k, E));
            }
            return k;
          }(_, d) : [];
        }, f.prototype.addSourceType = function(c, d, _) {
          return f.getSourceType(c) ? _(new Error('A source type called "' + c + '" already exists.')) : (f.setSourceType(c, d), d.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: c, url: d.workerSourceURL }, _) : _(null, null));
        }, f.prototype.getLight = function() {
          return this.light.getLight();
        }, f.prototype.setLight = function(c, d) {
          d === void 0 && (d = {}), this._checkLoaded();
          var _ = this.light.getLight(), w = !1;
          for (var E in c)
            if (!a.deepEqual(c[E], _[E])) {
              w = !0;
              break;
            }
          if (w) {
            var O = { now: a.browser.now(), transition: a.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(c, d), this.light.updateTransitions(O);
          }
        }, f.prototype._validate = function(c, d, _, w, E) {
          return E === void 0 && (E = {}), (!E || E.validate !== !1) && sl(this, c.call(a.validateStyle, a.extend({ key: d, style: this.serialize(), value: _, styleSpec: a.styleSpec }, w)));
        }, f.prototype._remove = function() {
          for (var c in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), a.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers)
            this._layers[c].setEventedParent(null);
          for (var d in this.sourceCaches)
            this.sourceCaches[d].clearTiles(), this.sourceCaches[d].setEventedParent(null);
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
        }, f.prototype._clearSource = function(c) {
          this.sourceCaches[c].clearTiles();
        }, f.prototype._reloadSource = function(c) {
          this.sourceCaches[c].resume(), this.sourceCaches[c].reload();
        }, f.prototype._updateSources = function(c) {
          for (var d in this.sourceCaches)
            this.sourceCaches[d].update(c);
        }, f.prototype._generateCollisionBoxes = function() {
          for (var c in this.sourceCaches)
            this._reloadSource(c);
        }, f.prototype._updatePlacement = function(c, d, _, w, E) {
          E === void 0 && (E = !1);
          for (var O = !1, k = !1, R = {}, $ = 0, W = this._order; $ < W.length; $ += 1) {
            var H = this._layers[W[$]];
            if (H.type === "symbol") {
              if (!R[H.source]) {
                var ne = this.sourceCaches[H.source];
                R[H.source] = ne.getRenderableIds(!0).map(function(me) {
                  return ne.getTileByID(me);
                }).sort(function(me, xe) {
                  return xe.tileID.overscaledZ - me.tileID.overscaledZ || (me.tileID.isLessThan(xe.tileID) ? -1 : 1);
                });
              }
              var te = this.crossTileSymbolIndex.addLayer(H, R[H.source], c.center.lng);
              O = O || te;
            }
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((E = E || this._layerOrderChanged || _ === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(a.browser.now(), c.zoom)) && (this.pauseablePlacement = new Ku(c, this._order, E, d, _, w, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, R), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(a.browser.now()), k = !0), O && this.pauseablePlacement.placement.setStale()), k || O)
            for (var ue = 0, Y = this._order; ue < Y.length; ue += 1) {
              var le = this._layers[Y[ue]];
              le.type === "symbol" && this.placement.updateLayerOpacities(le, R[le.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(a.browser.now());
        }, f.prototype._releaseSymbolFadeTiles = function() {
          for (var c in this.sourceCaches)
            this.sourceCaches[c].releaseSymbolFadeTiles();
        }, f.prototype.getImages = function(c, d, _) {
          this.imageManager.getImages(d.icons, _), this._updateTilesForChangedImages();
          var w = this.sourceCaches[d.source];
          w && w.setDependencies(d.tileID.key, d.type, d.icons);
        }, f.prototype.getGlyphs = function(c, d, _) {
          this.glyphManager.getGlyphs(d.stacks, _);
        }, f.prototype.getResource = function(c, d, _) {
          return a.makeRequest(d, _);
        }, f;
      }(a.Evented);
      lo.getSourceType = function(u) {
        return Fi[u];
      }, lo.setSourceType = function(u, f) {
        Fi[u] = f;
      }, lo.registerForPluginStateChange = a.registerForPluginStateChange;
      var jn = a.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), Yl = Zr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}`), hm = Zr(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), jv = Zr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), Gv = Zr(`varying vec3 v_data;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), Zf = Zr("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Xf = Zr(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`), Kf = Zr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), Yf = Zr("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), fm = Zr("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), pm = Zr("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"), $v = Zr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), Yu = Zr(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), Ju = Zr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), dm = Zr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), Ti = Zr(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), Jf = Zr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), vs = Zr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), _s = Zr(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), ll = Zr(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`), ul = Zr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`), xs = Zr(`uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), cl = Zr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), hl = Zr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), bs = Zr(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}`), mm = Zr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), ym = Zr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`);
      function Zr(u, f) {
        var c = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, d = f.match(/attribute ([\w]+) ([\w]+)/g), _ = u.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = f.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), E = w ? w.concat(_) : _, O = {};
        return { fragmentSource: u = u.replace(c, function(k, R, $, W, H) {
          return O[H] = !0, R === "define" ? `
#ifndef HAS_UNIFORM_u_` + H + `
varying ` + $ + " " + W + " " + H + `;
#else
uniform ` + $ + " " + W + " u_" + H + `;
#endif
` : `
#ifdef HAS_UNIFORM_u_` + H + `
    ` + $ + " " + W + " " + H + " = u_" + H + `;
#endif
`;
        }), vertexSource: f = f.replace(c, function(k, R, $, W, H) {
          var ne = W === "float" ? "vec2" : "vec4", te = H.match(/color/) ? "color" : ne;
          return O[H] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_` + H + `
uniform lowp float u_` + H + `_t;
attribute ` + $ + " " + ne + " a_" + H + `;
varying ` + $ + " " + W + " " + H + `;
#else
uniform ` + $ + " " + W + " u_" + H + `;
#endif
` : te === "vec4" ? `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + H + " = a_" + H + `;
#else
    ` + $ + " " + W + " " + H + " = u_" + H + `;
#endif
` : `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + H + " = unpack_mix_" + te + "(a_" + H + ", u_" + H + `_t);
#else
    ` + $ + " " + W + " " + H + " = u_" + H + `;
#endif
` : R === "define" ? `
#ifndef HAS_UNIFORM_u_` + H + `
uniform lowp float u_` + H + `_t;
attribute ` + $ + " " + ne + " a_" + H + `;
#else
uniform ` + $ + " " + W + " u_" + H + `;
#endif
` : te === "vec4" ? `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + $ + " " + W + " " + H + " = a_" + H + `;
#else
    ` + $ + " " + W + " " + H + " = u_" + H + `;
#endif
` : `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + $ + " " + W + " " + H + " = unpack_mix_" + te + "(a_" + H + ", u_" + H + `_t);
#else
    ` + $ + " " + W + " " + H + " = u_" + H + `;
#endif
`;
        }), staticAttributes: d, staticUniforms: E };
      }
      var qv = Object.freeze({ __proto__: null, prelude: Yl, background: hm, backgroundPattern: jv, circle: Gv, clippingMask: Zf, heatmap: Xf, heatmapTexture: Kf, collisionBox: Yf, collisionCircle: fm, debug: pm, fill: $v, fillOutline: Yu, fillOutlinePattern: Ju, fillPattern: dm, fillExtrusion: Ti, fillExtrusionPattern: Jf, hillshadePrepare: vs, hillshade: _s, line: ll, lineGradient: ul, linePattern: xs, lineSDF: cl, raster: hl, symbolIcon: bs, symbolSDF: mm, symbolTextAndIcon: ym }), ch = function() {
        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
      };
      function gm(u) {
        for (var f = [], c = 0; c < u.length; c++)
          if (u[c] !== null) {
            var d = u[c].split(" ");
            f.push(d.pop());
          }
        return f;
      }
      ch.prototype.bind = function(u, f, c, d, _, w, E, O) {
        this.context = u;
        for (var k = this.boundPaintVertexBuffers.length !== d.length, R = 0; !k && R < d.length; R++)
          this.boundPaintVertexBuffers[R] !== d[R] && (k = !0);
        u.extVertexArrayObject && this.vao && this.boundProgram === f && this.boundLayoutVertexBuffer === c && !k && this.boundIndexBuffer === _ && this.boundVertexOffset === w && this.boundDynamicVertexBuffer === E && this.boundDynamicVertexBuffer2 === O ? (u.bindVertexArrayOES.set(this.vao), E && E.bind(), _ && _.dynamicDraw && _.bind(), O && O.bind()) : this.freshBind(f, c, d, _, w, E, O);
      }, ch.prototype.freshBind = function(u, f, c, d, _, w, E) {
        var O, k = u.numAttributes, R = this.context, $ = R.gl;
        if (R.extVertexArrayObject)
          this.vao && this.destroy(), this.vao = R.extVertexArrayObject.createVertexArrayOES(), R.bindVertexArrayOES.set(this.vao), O = 0, this.boundProgram = u, this.boundLayoutVertexBuffer = f, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = d, this.boundVertexOffset = _, this.boundDynamicVertexBuffer = w, this.boundDynamicVertexBuffer2 = E;
        else {
          O = R.currentNumAttributes || 0;
          for (var W = k; W < O; W++)
            $.disableVertexAttribArray(W);
        }
        f.enableAttributes($, u);
        for (var H = 0, ne = c; H < ne.length; H += 1)
          ne[H].enableAttributes($, u);
        w && w.enableAttributes($, u), E && E.enableAttributes($, u), f.bind(), f.setVertexAttribPointers($, u, _);
        for (var te = 0, ue = c; te < ue.length; te += 1) {
          var Y = ue[te];
          Y.bind(), Y.setVertexAttribPointers($, u, _);
        }
        w && (w.bind(), w.setVertexAttribPointers($, u, _)), d && d.bind(), E && (E.bind(), E.setVertexAttribPointers($, u, _)), R.currentNumAttributes = k;
      }, ch.prototype.destroy = function() {
        this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
      };
      var vm = function(u, f, c, d, _, w) {
        var E = u.gl;
        this.program = E.createProgram();
        for (var O = gm(c.staticAttributes), k = d ? d.getBinderAttributes() : [], R = O.concat(k), $ = c.staticUniforms ? gm(c.staticUniforms) : [], W = d ? d.getBinderUniforms() : [], H = [], ne = 0, te = $.concat(W); ne < te.length; ne += 1) {
          var ue = te[ne];
          H.indexOf(ue) < 0 && H.push(ue);
        }
        var Y = d ? d.defines() : [];
        w && Y.push("#define OVERDRAW_INSPECTOR;");
        var le = Y.concat(Yl.fragmentSource, c.fragmentSource).join(`
`), me = Y.concat(Yl.vertexSource, c.vertexSource).join(`
`), xe = E.createShader(E.FRAGMENT_SHADER);
        if (E.isContextLost())
          this.failedToCreate = !0;
        else {
          E.shaderSource(xe, le), E.compileShader(xe), E.attachShader(this.program, xe);
          var Ae = E.createShader(E.VERTEX_SHADER);
          if (E.isContextLost())
            this.failedToCreate = !0;
          else {
            E.shaderSource(Ae, me), E.compileShader(Ae), E.attachShader(this.program, Ae), this.attributes = {};
            var Me = {};
            this.numAttributes = R.length;
            for (var ke = 0; ke < this.numAttributes; ke++)
              R[ke] && (E.bindAttribLocation(this.program, ke, R[ke]), this.attributes[R[ke]] = ke);
            E.linkProgram(this.program), E.deleteShader(Ae), E.deleteShader(xe);
            for (var je = 0; je < H.length; je++) {
              var nt = H[je];
              if (nt && !Me[nt]) {
                var tt = E.getUniformLocation(this.program, nt);
                tt && (Me[nt] = tt);
              }
            }
            this.fixedUniforms = _(u, Me), this.binderUniforms = d ? d.getUniforms(u, Me) : [];
          }
        }
      };
      function _m(u, f, c) {
        var d = 1 / dn(c, 1, f.transform.tileZoom), _ = Math.pow(2, c.tileID.overscaledZ), w = c.tileSize * Math.pow(2, f.transform.tileZoom) / _, E = w * (c.tileID.canonical.x + c.tileID.wrap * _), O = w * c.tileID.canonical.y;
        return { u_image: 0, u_texsize: c.imageAtlasTexture.size, u_scale: [d, u.fromScale, u.toScale], u_fade: u.t, u_pixel_coord_upper: [E >> 16, O >> 16], u_pixel_coord_lower: [65535 & E, 65535 & O] };
      }
      vm.prototype.draw = function(u, f, c, d, _, w, E, O, k, R, $, W, H, ne, te, ue) {
        var Y, le = u.gl;
        if (!this.failedToCreate) {
          for (var me in u.program.set(this.program), u.setDepthMode(c), u.setStencilMode(d), u.setColorMode(_), u.setCullFace(w), this.fixedUniforms)
            this.fixedUniforms[me].set(E[me]);
          ne && ne.setUniforms(u, this.binderUniforms, W, { zoom: H });
          for (var xe = (Y = {}, Y[le.LINES] = 2, Y[le.TRIANGLES] = 3, Y[le.LINE_STRIP] = 1, Y)[f], Ae = 0, Me = $.get(); Ae < Me.length; Ae += 1) {
            var ke = Me[Ae], je = ke.vaos || (ke.vaos = {});
            (je[O] || (je[O] = new ch())).bind(u, this, k, ne ? ne.getPaintVertexBuffers() : [], R, ke.vertexOffset, te, ue), le.drawElements(f, ke.primitiveLength * xe, le.UNSIGNED_SHORT, ke.primitiveOffset * xe * 2);
          }
        }
      };
      var xm = function(u, f, c, d) {
        var _ = f.style.light, w = _.properties.get("position"), E = [w.x, w.y, w.z], O = a.create$1();
        _.properties.get("anchor") === "viewport" && a.fromRotation(O, -f.transform.angle), a.transformMat3(E, E, O);
        var k = _.properties.get("color");
        return { u_matrix: u, u_lightpos: E, u_lightintensity: _.properties.get("intensity"), u_lightcolor: [k.r, k.g, k.b], u_vertical_gradient: +c, u_opacity: d };
      }, fl = function(u, f, c, d, _, w, E) {
        return a.extend(xm(u, f, c, d), _m(w, f, E), { u_height_factor: -Math.pow(2, _.overscaledZ) / E.tileSize / 8 });
      }, ws = function(u) {
        return { u_matrix: u };
      }, pl = function(u, f, c, d) {
        return a.extend(ws(u), _m(c, f, d));
      }, bm = function(u, f) {
        return { u_matrix: u, u_world: f };
      }, wm = function(u, f, c, d, _) {
        return a.extend(pl(u, f, c, d), { u_world: _ });
      }, Qf = function(u, f, c, d) {
        var _, w, E = u.transform;
        if (d.paint.get("circle-pitch-alignment") === "map") {
          var O = dn(c, 1, E.zoom);
          _ = !0, w = [O, O];
        } else
          _ = !1, w = E.pixelsToGLUnits;
        return { u_camera_to_center_distance: E.cameraToCenterDistance, u_scale_with_map: +(d.paint.get("circle-pitch-scale") === "map"), u_matrix: u.translatePosMatrix(f.posMatrix, c, d.paint.get("circle-translate"), d.paint.get("circle-translate-anchor")), u_pitch_with_map: +_, u_device_pixel_ratio: a.browser.devicePixelRatio, u_extrude_scale: w };
      }, dl = function(u, f, c) {
        var d = dn(c, 1, f.zoom), _ = Math.pow(2, f.zoom - c.tileID.overscaledZ), w = c.tileID.overscaleFactor();
        return { u_matrix: u, u_camera_to_center_distance: f.cameraToCenterDistance, u_pixels_to_tile_units: d, u_extrude_scale: [f.pixelsToGLUnits[0] / (d * _), f.pixelsToGLUnits[1] / (d * _)], u_overscale_factor: w };
      }, Em = function(u, f, c) {
        return { u_matrix: u, u_inv_matrix: f, u_camera_to_center_distance: c.cameraToCenterDistance, u_viewport_size: [c.width, c.height] };
      }, ml = function(u, f, c) {
        return c === void 0 && (c = 1), { u_matrix: u, u_color: f, u_overlay: 0, u_overlay_scale: c };
      }, yl = function(u) {
        return { u_matrix: u };
      }, Sm = function(u, f, c, d) {
        return { u_matrix: u, u_extrude_scale: dn(f, 1, c), u_intensity: d };
      }, Qu = function(u, f, c) {
        var d = u.transform;
        return { u_matrix: Tm(u, f, c), u_ratio: 1 / dn(f, 1, d.zoom), u_device_pixel_ratio: a.browser.devicePixelRatio, u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]] };
      }, Qr = function(u, f, c, d) {
        return a.extend(Qu(u, f, c), { u_image: 0, u_image_height: d });
      }, hh = function(u, f, c, d) {
        var _ = u.transform, w = Jl(f, _);
        return { u_matrix: Tm(u, f, c), u_texsize: f.imageAtlasTexture.size, u_ratio: 1 / dn(f, 1, _.zoom), u_device_pixel_ratio: a.browser.devicePixelRatio, u_image: 0, u_scale: [w, d.fromScale, d.toScale], u_fade: d.t, u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]] };
      }, Wv = function(u, f, c, d, _) {
        var w = u.lineAtlas, E = Jl(f, u.transform), O = c.layout.get("line-cap") === "round", k = w.getDash(d.from, O), R = w.getDash(d.to, O), $ = k.width * _.fromScale, W = R.width * _.toScale;
        return a.extend(Qu(u, f, c), { u_patternscale_a: [E / $, -k.height / 2], u_patternscale_b: [E / W, -R.height / 2], u_sdfgamma: w.width / (256 * Math.min($, W) * a.browser.devicePixelRatio) / 2, u_image: 0, u_tex_y_a: k.y, u_tex_y_b: R.y, u_mix: _.t });
      };
      function Jl(u, f) {
        return 1 / dn(u, 1, f.tileZoom);
      }
      function Tm(u, f, c) {
        return u.translatePosMatrix(f.tileID.posMatrix, f, c.paint.get("line-translate"), c.paint.get("line-translate-anchor"));
      }
      var Hv = function(u, f, c, d, _) {
        return { u_matrix: u, u_tl_parent: f, u_scale_parent: c, u_buffer_scale: 1, u_fade_t: d.mix, u_opacity: d.opacity * _.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: _.paint.get("raster-brightness-min"), u_brightness_high: _.paint.get("raster-brightness-max"), u_saturation_factor: (E = _.paint.get("raster-saturation"), E > 0 ? 1 - 1 / (1.001 - E) : -E), u_contrast_factor: (w = _.paint.get("raster-contrast"), w > 0 ? 1 / (1 - w) : 1 + w), u_spin_weights: Mm(_.paint.get("raster-hue-rotate")) };
        var w, E;
      };
      function Mm(u) {
        u *= Math.PI / 180;
        var f = Math.sin(u), c = Math.cos(u);
        return [(2 * c + 1) / 3, (-Math.sqrt(3) * f - c + 1) / 3, (Math.sqrt(3) * f - c + 1) / 3];
      }
      var fh, Ql = function(u, f, c, d, _, w, E, O, k, R) {
        var $ = _.transform;
        return { u_is_size_zoom_constant: +(u === "constant" || u === "source"), u_is_size_feature_constant: +(u === "constant" || u === "camera"), u_size_t: f ? f.uSizeT : 0, u_size: f ? f.uSize : 0, u_camera_to_center_distance: $.cameraToCenterDistance, u_pitch: $.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +c, u_aspect_ratio: $.width / $.height, u_fade_change: _.options.fadeDuration ? _.symbolFadeChange : 1, u_matrix: w, u_label_plane_matrix: E, u_coord_matrix: O, u_is_text: +k, u_pitch_with_map: +d, u_texsize: R, u_texture: 0 };
      }, ec = function(u, f, c, d, _, w, E, O, k, R, $) {
        var W = _.transform;
        return a.extend(Ql(u, f, c, d, _, w, E, O, k, R), { u_gamma_scale: d ? Math.cos(W._pitch) * W.cameraToCenterDistance : 1, u_device_pixel_ratio: a.browser.devicePixelRatio, u_is_halo: +$ });
      }, ph = function(u, f, c, d, _, w, E, O, k, R) {
        return a.extend(ec(u, f, c, d, _, w, E, O, !0, k, !0), { u_texsize_icon: R, u_texture_icon: 1 });
      }, tc = function(u, f, c) {
        return { u_matrix: u, u_opacity: f, u_color: c };
      }, eu = function(u, f, c, d, _, w) {
        return a.extend(function(E, O, k, R) {
          var $ = k.imageManager.getPattern(E.from.toString()), W = k.imageManager.getPattern(E.to.toString()), H = k.imageManager.getPixelSize(), ne = H.width, te = H.height, ue = Math.pow(2, R.tileID.overscaledZ), Y = R.tileSize * Math.pow(2, k.transform.tileZoom) / ue, le = Y * (R.tileID.canonical.x + R.tileID.wrap * ue), me = Y * R.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: $.tl, u_pattern_br_a: $.br, u_pattern_tl_b: W.tl, u_pattern_br_b: W.br, u_texsize: [ne, te], u_mix: O.t, u_pattern_size_a: $.displaySize, u_pattern_size_b: W.displaySize, u_scale_a: O.fromScale, u_scale_b: O.toScale, u_tile_units_to_pixels: 1 / dn(R, 1, k.transform.tileZoom), u_pixel_coord_upper: [le >> 16, me >> 16], u_pixel_coord_lower: [65535 & le, 65535 & me] };
        }(d, w, c, _), { u_matrix: u, u_opacity: f });
      }, Im = { fillExtrusion: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_lightpos: new a.Uniform3f(u, f.u_lightpos), u_lightintensity: new a.Uniform1f(u, f.u_lightintensity), u_lightcolor: new a.Uniform3f(u, f.u_lightcolor), u_vertical_gradient: new a.Uniform1f(u, f.u_vertical_gradient), u_opacity: new a.Uniform1f(u, f.u_opacity) };
      }, fillExtrusionPattern: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_lightpos: new a.Uniform3f(u, f.u_lightpos), u_lightintensity: new a.Uniform1f(u, f.u_lightintensity), u_lightcolor: new a.Uniform3f(u, f.u_lightcolor), u_vertical_gradient: new a.Uniform1f(u, f.u_vertical_gradient), u_height_factor: new a.Uniform1f(u, f.u_height_factor), u_image: new a.Uniform1i(u, f.u_image), u_texsize: new a.Uniform2f(u, f.u_texsize), u_pixel_coord_upper: new a.Uniform2f(u, f.u_pixel_coord_upper), u_pixel_coord_lower: new a.Uniform2f(u, f.u_pixel_coord_lower), u_scale: new a.Uniform3f(u, f.u_scale), u_fade: new a.Uniform1f(u, f.u_fade), u_opacity: new a.Uniform1f(u, f.u_opacity) };
      }, fill: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix) };
      }, fillPattern: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_image: new a.Uniform1i(u, f.u_image), u_texsize: new a.Uniform2f(u, f.u_texsize), u_pixel_coord_upper: new a.Uniform2f(u, f.u_pixel_coord_upper), u_pixel_coord_lower: new a.Uniform2f(u, f.u_pixel_coord_lower), u_scale: new a.Uniform3f(u, f.u_scale), u_fade: new a.Uniform1f(u, f.u_fade) };
      }, fillOutline: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_world: new a.Uniform2f(u, f.u_world) };
      }, fillOutlinePattern: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_world: new a.Uniform2f(u, f.u_world), u_image: new a.Uniform1i(u, f.u_image), u_texsize: new a.Uniform2f(u, f.u_texsize), u_pixel_coord_upper: new a.Uniform2f(u, f.u_pixel_coord_upper), u_pixel_coord_lower: new a.Uniform2f(u, f.u_pixel_coord_lower), u_scale: new a.Uniform3f(u, f.u_scale), u_fade: new a.Uniform1f(u, f.u_fade) };
      }, circle: function(u, f) {
        return { u_camera_to_center_distance: new a.Uniform1f(u, f.u_camera_to_center_distance), u_scale_with_map: new a.Uniform1i(u, f.u_scale_with_map), u_pitch_with_map: new a.Uniform1i(u, f.u_pitch_with_map), u_extrude_scale: new a.Uniform2f(u, f.u_extrude_scale), u_device_pixel_ratio: new a.Uniform1f(u, f.u_device_pixel_ratio), u_matrix: new a.UniformMatrix4f(u, f.u_matrix) };
      }, collisionBox: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_camera_to_center_distance: new a.Uniform1f(u, f.u_camera_to_center_distance), u_pixels_to_tile_units: new a.Uniform1f(u, f.u_pixels_to_tile_units), u_extrude_scale: new a.Uniform2f(u, f.u_extrude_scale), u_overscale_factor: new a.Uniform1f(u, f.u_overscale_factor) };
      }, collisionCircle: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_inv_matrix: new a.UniformMatrix4f(u, f.u_inv_matrix), u_camera_to_center_distance: new a.Uniform1f(u, f.u_camera_to_center_distance), u_viewport_size: new a.Uniform2f(u, f.u_viewport_size) };
      }, debug: function(u, f) {
        return { u_color: new a.UniformColor(u, f.u_color), u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_overlay: new a.Uniform1i(u, f.u_overlay), u_overlay_scale: new a.Uniform1f(u, f.u_overlay_scale) };
      }, clippingMask: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix) };
      }, heatmap: function(u, f) {
        return { u_extrude_scale: new a.Uniform1f(u, f.u_extrude_scale), u_intensity: new a.Uniform1f(u, f.u_intensity), u_matrix: new a.UniformMatrix4f(u, f.u_matrix) };
      }, heatmapTexture: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_world: new a.Uniform2f(u, f.u_world), u_image: new a.Uniform1i(u, f.u_image), u_color_ramp: new a.Uniform1i(u, f.u_color_ramp), u_opacity: new a.Uniform1f(u, f.u_opacity) };
      }, hillshade: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_image: new a.Uniform1i(u, f.u_image), u_latrange: new a.Uniform2f(u, f.u_latrange), u_light: new a.Uniform2f(u, f.u_light), u_shadow: new a.UniformColor(u, f.u_shadow), u_highlight: new a.UniformColor(u, f.u_highlight), u_accent: new a.UniformColor(u, f.u_accent) };
      }, hillshadePrepare: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_image: new a.Uniform1i(u, f.u_image), u_dimension: new a.Uniform2f(u, f.u_dimension), u_zoom: new a.Uniform1f(u, f.u_zoom), u_unpack: new a.Uniform4f(u, f.u_unpack) };
      }, line: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_ratio: new a.Uniform1f(u, f.u_ratio), u_device_pixel_ratio: new a.Uniform1f(u, f.u_device_pixel_ratio), u_units_to_pixels: new a.Uniform2f(u, f.u_units_to_pixels) };
      }, lineGradient: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_ratio: new a.Uniform1f(u, f.u_ratio), u_device_pixel_ratio: new a.Uniform1f(u, f.u_device_pixel_ratio), u_units_to_pixels: new a.Uniform2f(u, f.u_units_to_pixels), u_image: new a.Uniform1i(u, f.u_image), u_image_height: new a.Uniform1f(u, f.u_image_height) };
      }, linePattern: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_texsize: new a.Uniform2f(u, f.u_texsize), u_ratio: new a.Uniform1f(u, f.u_ratio), u_device_pixel_ratio: new a.Uniform1f(u, f.u_device_pixel_ratio), u_image: new a.Uniform1i(u, f.u_image), u_units_to_pixels: new a.Uniform2f(u, f.u_units_to_pixels), u_scale: new a.Uniform3f(u, f.u_scale), u_fade: new a.Uniform1f(u, f.u_fade) };
      }, lineSDF: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_ratio: new a.Uniform1f(u, f.u_ratio), u_device_pixel_ratio: new a.Uniform1f(u, f.u_device_pixel_ratio), u_units_to_pixels: new a.Uniform2f(u, f.u_units_to_pixels), u_patternscale_a: new a.Uniform2f(u, f.u_patternscale_a), u_patternscale_b: new a.Uniform2f(u, f.u_patternscale_b), u_sdfgamma: new a.Uniform1f(u, f.u_sdfgamma), u_image: new a.Uniform1i(u, f.u_image), u_tex_y_a: new a.Uniform1f(u, f.u_tex_y_a), u_tex_y_b: new a.Uniform1f(u, f.u_tex_y_b), u_mix: new a.Uniform1f(u, f.u_mix) };
      }, raster: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_tl_parent: new a.Uniform2f(u, f.u_tl_parent), u_scale_parent: new a.Uniform1f(u, f.u_scale_parent), u_buffer_scale: new a.Uniform1f(u, f.u_buffer_scale), u_fade_t: new a.Uniform1f(u, f.u_fade_t), u_opacity: new a.Uniform1f(u, f.u_opacity), u_image0: new a.Uniform1i(u, f.u_image0), u_image1: new a.Uniform1i(u, f.u_image1), u_brightness_low: new a.Uniform1f(u, f.u_brightness_low), u_brightness_high: new a.Uniform1f(u, f.u_brightness_high), u_saturation_factor: new a.Uniform1f(u, f.u_saturation_factor), u_contrast_factor: new a.Uniform1f(u, f.u_contrast_factor), u_spin_weights: new a.Uniform3f(u, f.u_spin_weights) };
      }, symbolIcon: function(u, f) {
        return { u_is_size_zoom_constant: new a.Uniform1i(u, f.u_is_size_zoom_constant), u_is_size_feature_constant: new a.Uniform1i(u, f.u_is_size_feature_constant), u_size_t: new a.Uniform1f(u, f.u_size_t), u_size: new a.Uniform1f(u, f.u_size), u_camera_to_center_distance: new a.Uniform1f(u, f.u_camera_to_center_distance), u_pitch: new a.Uniform1f(u, f.u_pitch), u_rotate_symbol: new a.Uniform1i(u, f.u_rotate_symbol), u_aspect_ratio: new a.Uniform1f(u, f.u_aspect_ratio), u_fade_change: new a.Uniform1f(u, f.u_fade_change), u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_label_plane_matrix: new a.UniformMatrix4f(u, f.u_label_plane_matrix), u_coord_matrix: new a.UniformMatrix4f(u, f.u_coord_matrix), u_is_text: new a.Uniform1i(u, f.u_is_text), u_pitch_with_map: new a.Uniform1i(u, f.u_pitch_with_map), u_texsize: new a.Uniform2f(u, f.u_texsize), u_texture: new a.Uniform1i(u, f.u_texture) };
      }, symbolSDF: function(u, f) {
        return { u_is_size_zoom_constant: new a.Uniform1i(u, f.u_is_size_zoom_constant), u_is_size_feature_constant: new a.Uniform1i(u, f.u_is_size_feature_constant), u_size_t: new a.Uniform1f(u, f.u_size_t), u_size: new a.Uniform1f(u, f.u_size), u_camera_to_center_distance: new a.Uniform1f(u, f.u_camera_to_center_distance), u_pitch: new a.Uniform1f(u, f.u_pitch), u_rotate_symbol: new a.Uniform1i(u, f.u_rotate_symbol), u_aspect_ratio: new a.Uniform1f(u, f.u_aspect_ratio), u_fade_change: new a.Uniform1f(u, f.u_fade_change), u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_label_plane_matrix: new a.UniformMatrix4f(u, f.u_label_plane_matrix), u_coord_matrix: new a.UniformMatrix4f(u, f.u_coord_matrix), u_is_text: new a.Uniform1i(u, f.u_is_text), u_pitch_with_map: new a.Uniform1i(u, f.u_pitch_with_map), u_texsize: new a.Uniform2f(u, f.u_texsize), u_texture: new a.Uniform1i(u, f.u_texture), u_gamma_scale: new a.Uniform1f(u, f.u_gamma_scale), u_device_pixel_ratio: new a.Uniform1f(u, f.u_device_pixel_ratio), u_is_halo: new a.Uniform1i(u, f.u_is_halo) };
      }, symbolTextAndIcon: function(u, f) {
        return { u_is_size_zoom_constant: new a.Uniform1i(u, f.u_is_size_zoom_constant), u_is_size_feature_constant: new a.Uniform1i(u, f.u_is_size_feature_constant), u_size_t: new a.Uniform1f(u, f.u_size_t), u_size: new a.Uniform1f(u, f.u_size), u_camera_to_center_distance: new a.Uniform1f(u, f.u_camera_to_center_distance), u_pitch: new a.Uniform1f(u, f.u_pitch), u_rotate_symbol: new a.Uniform1i(u, f.u_rotate_symbol), u_aspect_ratio: new a.Uniform1f(u, f.u_aspect_ratio), u_fade_change: new a.Uniform1f(u, f.u_fade_change), u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_label_plane_matrix: new a.UniformMatrix4f(u, f.u_label_plane_matrix), u_coord_matrix: new a.UniformMatrix4f(u, f.u_coord_matrix), u_is_text: new a.Uniform1i(u, f.u_is_text), u_pitch_with_map: new a.Uniform1i(u, f.u_pitch_with_map), u_texsize: new a.Uniform2f(u, f.u_texsize), u_texsize_icon: new a.Uniform2f(u, f.u_texsize_icon), u_texture: new a.Uniform1i(u, f.u_texture), u_texture_icon: new a.Uniform1i(u, f.u_texture_icon), u_gamma_scale: new a.Uniform1f(u, f.u_gamma_scale), u_device_pixel_ratio: new a.Uniform1f(u, f.u_device_pixel_ratio), u_is_halo: new a.Uniform1i(u, f.u_is_halo) };
      }, background: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_opacity: new a.Uniform1f(u, f.u_opacity), u_color: new a.UniformColor(u, f.u_color) };
      }, backgroundPattern: function(u, f) {
        return { u_matrix: new a.UniformMatrix4f(u, f.u_matrix), u_opacity: new a.Uniform1f(u, f.u_opacity), u_image: new a.Uniform1i(u, f.u_image), u_pattern_tl_a: new a.Uniform2f(u, f.u_pattern_tl_a), u_pattern_br_a: new a.Uniform2f(u, f.u_pattern_br_a), u_pattern_tl_b: new a.Uniform2f(u, f.u_pattern_tl_b), u_pattern_br_b: new a.Uniform2f(u, f.u_pattern_br_b), u_texsize: new a.Uniform2f(u, f.u_texsize), u_mix: new a.Uniform1f(u, f.u_mix), u_pattern_size_a: new a.Uniform2f(u, f.u_pattern_size_a), u_pattern_size_b: new a.Uniform2f(u, f.u_pattern_size_b), u_scale_a: new a.Uniform1f(u, f.u_scale_a), u_scale_b: new a.Uniform1f(u, f.u_scale_b), u_pixel_coord_upper: new a.Uniform2f(u, f.u_pixel_coord_upper), u_pixel_coord_lower: new a.Uniform2f(u, f.u_pixel_coord_lower), u_tile_units_to_pixels: new a.Uniform1f(u, f.u_tile_units_to_pixels) };
      } };
      function tu(u, f, c, d, _, w, E) {
        for (var O = u.context, k = O.gl, R = u.useProgram("collisionBox"), $ = [], W = 0, H = 0, ne = 0; ne < d.length; ne++) {
          var te = d[ne], ue = f.getTile(te), Y = ue.getBucket(c);
          if (Y) {
            var le = te.posMatrix;
            _[0] === 0 && _[1] === 0 || (le = u.translatePosMatrix(te.posMatrix, ue, _, w));
            var me = E ? Y.textCollisionBox : Y.iconCollisionBox, xe = Y.collisionCircleArray;
            if (xe.length > 0) {
              var Ae = a.create(), Me = le;
              a.mul(Ae, Y.placementInvProjMatrix, u.transform.glCoordMatrix), a.mul(Ae, Ae, Y.placementViewportMatrix), $.push({ circleArray: xe, circleOffset: H, transform: Me, invTransform: Ae }), H = W += xe.length / 4;
            }
            me && R.draw(O, k.LINES, Z.disabled, Q.disabled, u.colorModeForRenderPass(), de.disabled, dl(le, u.transform, ue), c.id, me.layoutVertexBuffer, me.indexBuffer, me.segments, null, u.transform.zoom, null, null, me.collisionVertexBuffer);
          }
        }
        if (E && $.length) {
          var ke = u.useProgram("collisionCircle"), je = new a.StructArrayLayout2f1f2i16();
          je.resize(4 * W), je._trim();
          for (var nt = 0, tt = 0, gt = $; tt < gt.length; tt += 1)
            for (var Dt = gt[tt], Bt = 0; Bt < Dt.circleArray.length / 4; Bt++) {
              var zt = 4 * Bt, Ir = Dt.circleArray[zt + 0], xt = Dt.circleArray[zt + 1], Yt = Dt.circleArray[zt + 2], ir = Dt.circleArray[zt + 3];
              je.emplace(nt++, Ir, xt, Yt, ir, 0), je.emplace(nt++, Ir, xt, Yt, ir, 1), je.emplace(nt++, Ir, xt, Yt, ir, 2), je.emplace(nt++, Ir, xt, Yt, ir, 3);
            }
          (!fh || fh.length < 2 * W) && (fh = function(On) {
            var Di = 2 * On, gi = new a.StructArrayLayout3ui6();
            gi.resize(Di), gi._trim();
            for (var Mn = 0; Mn < Di; Mn++) {
              var Dn = 6 * Mn;
              gi.uint16[Dn + 0] = 4 * Mn + 0, gi.uint16[Dn + 1] = 4 * Mn + 1, gi.uint16[Dn + 2] = 4 * Mn + 2, gi.uint16[Dn + 3] = 4 * Mn + 2, gi.uint16[Dn + 4] = 4 * Mn + 3, gi.uint16[Dn + 5] = 4 * Mn + 0;
            }
            return gi;
          }(W));
          for (var Kt = O.createIndexBuffer(fh, !0), Xt = O.createVertexBuffer(je, a.collisionCircleLayout.members, !0), nr = 0, Ht = $; nr < Ht.length; nr += 1) {
            var $t = Ht[nr], si = Em($t.transform, $t.invTransform, u.transform);
            ke.draw(O, k.TRIANGLES, Z.disabled, Q.disabled, u.colorModeForRenderPass(), de.disabled, si, c.id, Xt, Kt, a.SegmentVector.simpleSegment(0, 2 * $t.circleOffset, $t.circleArray.length, $t.circleArray.length / 2), null, u.transform.zoom, null, null, null);
          }
          Xt.destroy(), Kt.destroy();
        }
      }
      var oa = a.identity(new Float32Array(16));
      function Om(u, f, c, d, _, w) {
        var E = a.getAnchorAlignment(u), O = -(E.horizontalAlign - 0.5) * f, k = -(E.verticalAlign - 0.5) * c, R = a.evaluateVariableOffset(u, d);
        return new a.Point((O / _ + R[0]) * w, (k / _ + R[1]) * w);
      }
      function Cm(u, f, c, d, _, w, E, O, k, R, $) {
        var W = u.text.placedSymbolArray, H = u.text.dynamicLayoutVertexArray, ne = u.icon.dynamicLayoutVertexArray, te = {};
        H.clear();
        for (var ue = 0; ue < W.length; ue++) {
          var Y = W.get(ue), le = Y.hidden || !Y.crossTileID || u.allowVerticalPlacement && !Y.placedOrientation ? null : d[Y.crossTileID];
          if (le) {
            var me = new a.Point(Y.anchorX, Y.anchorY), xe = gr(me, c ? O : E), Ae = Fr(w.cameraToCenterDistance, xe.signedDistanceFromCamera), Me = _.evaluateSizeForFeature(u.textSizeData, R, Y) * Ae / a.ONE_EM;
            c && (Me *= u.tilePixelRatio / k);
            for (var ke = Om(le.anchor, le.width, le.height, le.textOffset, le.textBoxScale, Me), je = c ? gr(me.add(ke), E).point : xe.point.add(f ? ke.rotate(-w.angle) : ke), nt = u.allowVerticalPlacement && Y.placedOrientation === a.WritingMode.vertical ? Math.PI / 2 : 0, tt = 0; tt < Y.numGlyphs; tt++)
              a.addDynamicAttributes(H, je, nt);
            $ && Y.associatedIconIndex >= 0 && (te[Y.associatedIconIndex] = { shiftedAnchor: je, angle: nt });
          } else
            Vi(Y.numGlyphs, H);
        }
        if ($) {
          ne.clear();
          for (var gt = u.icon.placedSymbolArray, Dt = 0; Dt < gt.length; Dt++) {
            var Bt = gt.get(Dt);
            if (Bt.hidden)
              Vi(Bt.numGlyphs, ne);
            else {
              var zt = te[Dt];
              if (zt)
                for (var Ir = 0; Ir < Bt.numGlyphs; Ir++)
                  a.addDynamicAttributes(ne, zt.shiftedAnchor, zt.angle);
              else
                Vi(Bt.numGlyphs, ne);
            }
          }
          u.icon.dynamicLayoutVertexBuffer.updateData(ne);
        }
        u.text.dynamicLayoutVertexBuffer.updateData(H);
      }
      function Am(u, f, c) {
        return c.iconsInText && f ? "symbolTextAndIcon" : u ? "symbolSDF" : "symbolIcon";
      }
      function gl(u, f, c, d, _, w, E, O, k, R, $, W) {
        for (var H = u.context, ne = H.gl, te = u.transform, ue = O === "map", Y = k === "map", le = ue && c.layout.get("symbol-placement") !== "point", me = ue && !Y && !le, xe = c.layout.get("symbol-sort-key").constantOr(1) !== void 0, Ae = !1, Me = u.depthModeForSublayer(0, Z.ReadOnly), ke = c.layout.get("text-variable-anchor"), je = [], nt = 0, tt = d; nt < tt.length; nt += 1) {
          var gt = tt[nt], Dt = f.getTile(gt), Bt = Dt.getBucket(c);
          if (Bt) {
            var zt = _ ? Bt.text : Bt.icon;
            if (zt && zt.segments.get().length) {
              var Ir = zt.programConfigurations.get(c.id), xt = _ || Bt.sdfIcons, Yt = _ ? Bt.textSizeData : Bt.iconSizeData, ir = Y || te.pitch !== 0, Kt = u.useProgram(Am(xt, _, Bt), Ir), Xt = a.evaluateSizeForZoom(Yt, te.zoom), nr = void 0, Ht = [0, 0], $t = void 0, si = void 0, On = null, Di = void 0;
              if (_)
                $t = Dt.glyphAtlasTexture, si = ne.LINEAR, nr = Dt.glyphAtlasTexture.size, Bt.iconsInText && (Ht = Dt.imageAtlasTexture.size, On = Dt.imageAtlasTexture, Di = ir || u.options.rotating || u.options.zooming || Yt.kind === "composite" || Yt.kind === "camera" ? ne.LINEAR : ne.NEAREST);
              else {
                var gi = c.layout.get("icon-size").constantOr(0) !== 1 || Bt.iconsNeedLinear;
                $t = Dt.imageAtlasTexture, si = xt || u.options.rotating || u.options.zooming || gi || ir ? ne.LINEAR : ne.NEAREST, nr = Dt.imageAtlasTexture.size;
              }
              var Mn = dn(Dt, 1, u.transform.zoom), Dn = pn(gt.posMatrix, Y, ue, u.transform, Mn), mo = Ur(gt.posMatrix, Y, ue, u.transform, Mn), $i = ke && Bt.hasTextData(), Os = c.layout.get("icon-text-fit") !== "none" && $i && Bt.hasIconData();
              le && Hu(Bt, gt.posMatrix, u, _, Dn, mo, Y, R);
              var Qi = u.translatePosMatrix(gt.posMatrix, Dt, w, E), ca = le || _ && ke || Os ? oa : Dn, Zo = u.translatePosMatrix(mo, Dt, w, E, !0), pc = xt && c.paint.get(_ ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, su = { program: Kt, buffers: zt, uniformValues: xt ? Bt.iconsInText ? ph(Yt.kind, Xt, me, Y, u, Qi, ca, Zo, nr, Ht) : ec(Yt.kind, Xt, me, Y, u, Qi, ca, Zo, _, nr, !0) : Ql(Yt.kind, Xt, me, Y, u, Qi, ca, Zo, _, nr), atlasTexture: $t, atlasTextureIcon: On, atlasInterpolation: si, atlasInterpolationIcon: Di, isSDF: xt, hasHalo: pc };
              if (xe && Bt.canOverlap) {
                Ae = !0;
                for (var Cs = 0, lu = zt.segments.get(); Cs < lu.length; Cs += 1) {
                  var dc = lu[Cs];
                  je.push({ segments: new a.SegmentVector([dc]), sortKey: dc.sortKey, state: su });
                }
              } else
                je.push({ segments: zt.segments, sortKey: 0, state: su });
            }
          }
        }
        Ae && je.sort(function(As, El) {
          return As.sortKey - El.sortKey;
        });
        for (var Sa = 0, mc = je; Sa < mc.length; Sa += 1) {
          var Ta = mc[Sa], li = Ta.state;
          if (H.activeTexture.set(ne.TEXTURE0), li.atlasTexture.bind(li.atlasInterpolation, ne.CLAMP_TO_EDGE), li.atlasTextureIcon && (H.activeTexture.set(ne.TEXTURE1), li.atlasTextureIcon && li.atlasTextureIcon.bind(li.atlasInterpolationIcon, ne.CLAMP_TO_EDGE)), li.isSDF) {
            var $a = li.uniformValues;
            li.hasHalo && ($a.u_is_halo = 1, rc(li.buffers, Ta.segments, c, u, li.program, Me, $, W, $a)), $a.u_is_halo = 0;
          }
          rc(li.buffers, Ta.segments, c, u, li.program, Me, $, W, li.uniformValues);
        }
      }
      function rc(u, f, c, d, _, w, E, O, k) {
        var R = d.context;
        _.draw(R, R.gl.TRIANGLES, w, E, O, de.disabled, k, c.id, u.layoutVertexBuffer, u.indexBuffer, f, c.paint, d.transform.zoom, u.programConfigurations.get(c.id), u.dynamicLayoutVertexBuffer, u.opacityVertexBuffer);
      }
      function dh(u, f, c, d, _, w, E) {
        var O, k, R, $, W, H = u.context.gl, ne = c.paint.get("fill-pattern"), te = ne && ne.constantOr(1), ue = c.getCrossfadeParameters();
        E ? (k = te && !c.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", O = H.LINES) : (k = te ? "fillPattern" : "fill", O = H.TRIANGLES);
        for (var Y = 0, le = d; Y < le.length; Y += 1) {
          var me = le[Y], xe = f.getTile(me);
          if (!te || xe.patternsLoaded()) {
            var Ae = xe.getBucket(c);
            if (Ae) {
              var Me = Ae.programConfigurations.get(c.id), ke = u.useProgram(k, Me);
              te && (u.context.activeTexture.set(H.TEXTURE0), xe.imageAtlasTexture.bind(H.LINEAR, H.CLAMP_TO_EDGE), Me.updatePaintBuffers(ue));
              var je = ne.constantOr(null);
              if (je && xe.imageAtlas) {
                var nt = xe.imageAtlas, tt = nt.patternPositions[je.to.toString()], gt = nt.patternPositions[je.from.toString()];
                tt && gt && Me.setConstantPatternPositions(tt, gt);
              }
              var Dt = u.translatePosMatrix(me.posMatrix, xe, c.paint.get("fill-translate"), c.paint.get("fill-translate-anchor"));
              if (E) {
                $ = Ae.indexBuffer2, W = Ae.segments2;
                var Bt = [H.drawingBufferWidth, H.drawingBufferHeight];
                R = k === "fillOutlinePattern" && te ? wm(Dt, u, ue, xe, Bt) : bm(Dt, Bt);
              } else
                $ = Ae.indexBuffer, W = Ae.segments, R = te ? pl(Dt, u, ue, xe) : ws(Dt);
              ke.draw(u.context, O, _, u.stencilModeForClipping(me), w, de.disabled, R, c.id, Ae.layoutVertexBuffer, $, W, c.paint, u.transform.zoom, Me);
            }
          }
        }
      }
      function ep(u, f, c, d, _, w, E) {
        for (var O = u.context, k = O.gl, R = c.paint.get("fill-extrusion-pattern"), $ = R.constantOr(1), W = c.getCrossfadeParameters(), H = c.paint.get("fill-extrusion-opacity"), ne = 0, te = d; ne < te.length; ne += 1) {
          var ue = te[ne], Y = f.getTile(ue), le = Y.getBucket(c);
          if (le) {
            var me = le.programConfigurations.get(c.id), xe = u.useProgram($ ? "fillExtrusionPattern" : "fillExtrusion", me);
            $ && (u.context.activeTexture.set(k.TEXTURE0), Y.imageAtlasTexture.bind(k.LINEAR, k.CLAMP_TO_EDGE), me.updatePaintBuffers(W));
            var Ae = R.constantOr(null);
            if (Ae && Y.imageAtlas) {
              var Me = Y.imageAtlas, ke = Me.patternPositions[Ae.to.toString()], je = Me.patternPositions[Ae.from.toString()];
              ke && je && me.setConstantPatternPositions(ke, je);
            }
            var nt = u.translatePosMatrix(ue.posMatrix, Y, c.paint.get("fill-extrusion-translate"), c.paint.get("fill-extrusion-translate-anchor")), tt = c.paint.get("fill-extrusion-vertical-gradient"), gt = $ ? fl(nt, u, tt, H, ue, W, Y) : xm(nt, u, tt, H);
            xe.draw(O, O.gl.TRIANGLES, _, w, E, de.backCCW, gt, c.id, le.layoutVertexBuffer, le.indexBuffer, le.segments, c.paint, u.transform.zoom, me);
          }
        }
      }
      function mh(u, f, c, d, _, w) {
        var E = u.context, O = E.gl, k = f.fbo;
        if (k) {
          var R = u.useProgram("hillshade");
          E.activeTexture.set(O.TEXTURE0), O.bindTexture(O.TEXTURE_2D, k.colorAttachment.get());
          var $ = function(W, H, ne) {
            var te = ne.paint.get("hillshade-shadow-color"), ue = ne.paint.get("hillshade-highlight-color"), Y = ne.paint.get("hillshade-accent-color"), le = ne.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            ne.paint.get("hillshade-illumination-anchor") === "viewport" && (le -= W.transform.angle);
            var me, xe, Ae, Me = !W.options.moving;
            return { u_matrix: W.transform.calculatePosMatrix(H.tileID.toUnwrapped(), Me), u_image: 0, u_latrange: (me = H.tileID, xe = Math.pow(2, me.canonical.z), Ae = me.canonical.y, [new a.MercatorCoordinate(0, Ae / xe).toLngLat().lat, new a.MercatorCoordinate(0, (Ae + 1) / xe).toLngLat().lat]), u_light: [ne.paint.get("hillshade-exaggeration"), le], u_shadow: te, u_highlight: ue, u_accent: Y };
          }(u, f, c);
          R.draw(E, O.TRIANGLES, d, _, w, de.disabled, $, c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments);
        }
      }
      function Zv(u, f, c, d, _, w) {
        var E = u.context, O = E.gl, k = f.dem;
        if (k && k.data) {
          var R = k.dim, $ = k.stride, W = k.getPixels();
          if (E.activeTexture.set(O.TEXTURE1), E.pixelStoreUnpackPremultiplyAlpha.set(!1), f.demTexture = f.demTexture || u.getTileTexture($), f.demTexture) {
            var H = f.demTexture;
            H.update(W, { premultiply: !1 }), H.bind(O.NEAREST, O.CLAMP_TO_EDGE);
          } else
            f.demTexture = new a.Texture(E, W, O.RGBA, { premultiply: !1 }), f.demTexture.bind(O.NEAREST, O.CLAMP_TO_EDGE);
          E.activeTexture.set(O.TEXTURE0);
          var ne = f.fbo;
          if (!ne) {
            var te = new a.Texture(E, { width: R, height: R, data: null }, O.RGBA);
            te.bind(O.LINEAR, O.CLAMP_TO_EDGE), (ne = f.fbo = E.createFramebuffer(R, R, !0)).colorAttachment.set(te.texture);
          }
          E.bindFramebuffer.set(ne.framebuffer), E.viewport.set([0, 0, R, R]), u.useProgram("hillshadePrepare").draw(E, O.TRIANGLES, d, _, w, de.disabled, function(ue, Y) {
            var le = Y.stride, me = a.create();
            return a.ortho(me, 0, a.EXTENT, -a.EXTENT, 0, 0, 1), a.translate(me, me, [0, -a.EXTENT, 0]), { u_matrix: me, u_image: 1, u_dimension: [le, le], u_zoom: ue.overscaledZ, u_unpack: Y.getUnpackVector() };
          }(f.tileID, k), c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments), f.needsHillshadePrepare = !1;
        }
      }
      function yh(u, f, c, d, _) {
        var w = d.paint.get("raster-fade-duration");
        if (w > 0) {
          var E = a.browser.now(), O = (E - u.timeAdded) / w, k = f ? (E - f.timeAdded) / w : -1, R = c.getSource(), $ = _.coveringZoomLevel({ tileSize: R.tileSize, roundZoom: R.roundZoom }), W = !f || Math.abs(f.tileID.overscaledZ - $) > Math.abs(u.tileID.overscaledZ - $), H = W && u.refreshedUponExpiration ? 1 : a.clamp(W ? O : 1 - k, 0, 1);
          return u.refreshedUponExpiration && O >= 1 && (u.refreshedUponExpiration = !1), f ? { opacity: 1, mix: 1 - H } : { opacity: H, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      var tp = new a.Color(1, 0, 0, 1), Pm = new a.Color(0, 1, 0, 1), km = new a.Color(0, 0, 1, 1), gh = new a.Color(1, 0, 1, 1), rp = new a.Color(0, 1, 1, 1);
      function np(u, f, c, d) {
        nc(u, 0, f + c / 2, u.transform.width, c, d);
      }
      function ip(u, f, c, d) {
        nc(u, f - c / 2, 0, c, u.transform.height, d);
      }
      function nc(u, f, c, d, _, w) {
        var E = u.context, O = E.gl;
        O.enable(O.SCISSOR_TEST), O.scissor(f * a.browser.devicePixelRatio, c * a.browser.devicePixelRatio, d * a.browser.devicePixelRatio, _ * a.browser.devicePixelRatio), E.clear({ color: w }), O.disable(O.SCISSOR_TEST);
      }
      function Lm(u, f, c) {
        var d = u.context, _ = d.gl, w = c.posMatrix, E = u.useProgram("debug"), O = Z.disabled, k = Q.disabled, R = u.colorModeForRenderPass();
        d.activeTexture.set(_.TEXTURE0), u.emptyTexture.bind(_.LINEAR, _.CLAMP_TO_EDGE), E.draw(d, _.LINE_STRIP, O, k, R, de.disabled, ml(w, a.Color.red), "$debug", u.debugBuffer, u.tileBorderIndexBuffer, u.debugSegments);
        var $ = f.getTileByID(c.key).latestRawTileData, W = Math.floor(($ && $.byteLength || 0) / 1024), H = f.getTile(c).tileSize, ne = 512 / Math.min(H, 512) * (c.overscaledZ / u.transform.zoom) * 0.5, te = c.canonical.toString();
        c.overscaledZ !== c.canonical.z && (te += " => " + c.overscaledZ), function(ue, Y) {
          ue.initDebugOverlayCanvas();
          var le = ue.debugOverlayCanvas, me = ue.context.gl, xe = ue.debugOverlayCanvas.getContext("2d");
          xe.clearRect(0, 0, le.width, le.height), xe.shadowColor = "white", xe.shadowBlur = 2, xe.lineWidth = 1.5, xe.strokeStyle = "white", xe.textBaseline = "top", xe.font = "bold 36px Open Sans, sans-serif", xe.fillText(Y, 5, 5), xe.strokeText(Y, 5, 5), ue.debugOverlayTexture.update(le), ue.debugOverlayTexture.bind(me.LINEAR, me.CLAMP_TO_EDGE);
        }(u, te + " " + W + "kb"), E.draw(d, _.TRIANGLES, O, k, pe.alphaBlended, de.disabled, ml(w, a.Color.transparent, ne), "$debug", u.debugBuffer, u.quadTriangleIndexBuffer, u.debugSegments);
      }
      var vl = { symbol: function(u, f, c, d, _) {
        if (u.renderPass === "translucent") {
          var w = Q.disabled, E = u.colorModeForRenderPass();
          c.layout.get("text-variable-anchor") && function(O, k, R, $, W, H, ne) {
            for (var te = k.transform, ue = W === "map", Y = H === "map", le = 0, me = O; le < me.length; le += 1) {
              var xe = me[le], Ae = $.getTile(xe), Me = Ae.getBucket(R);
              if (Me && Me.text && Me.text.segments.get().length) {
                var ke = a.evaluateSizeForZoom(Me.textSizeData, te.zoom), je = dn(Ae, 1, k.transform.zoom), nt = pn(xe.posMatrix, Y, ue, k.transform, je), tt = R.layout.get("icon-text-fit") !== "none" && Me.hasIconData();
                if (ke) {
                  var gt = Math.pow(2, te.zoom - Ae.tileID.overscaledZ);
                  Cm(Me, ue, Y, ne, a.symbolSize, te, nt, xe.posMatrix, gt, ke, tt);
                }
              }
            }
          }(d, u, c, f, c.layout.get("text-rotation-alignment"), c.layout.get("text-pitch-alignment"), _), c.paint.get("icon-opacity").constantOr(1) !== 0 && gl(u, f, c, d, !1, c.paint.get("icon-translate"), c.paint.get("icon-translate-anchor"), c.layout.get("icon-rotation-alignment"), c.layout.get("icon-pitch-alignment"), c.layout.get("icon-keep-upright"), w, E), c.paint.get("text-opacity").constantOr(1) !== 0 && gl(u, f, c, d, !0, c.paint.get("text-translate"), c.paint.get("text-translate-anchor"), c.layout.get("text-rotation-alignment"), c.layout.get("text-pitch-alignment"), c.layout.get("text-keep-upright"), w, E), f.map.showCollisionBoxes && (tu(u, f, c, d, c.paint.get("text-translate"), c.paint.get("text-translate-anchor"), !0), tu(u, f, c, d, c.paint.get("icon-translate"), c.paint.get("icon-translate-anchor"), !1));
        }
      }, circle: function(u, f, c, d) {
        if (u.renderPass === "translucent") {
          var _ = c.paint.get("circle-opacity"), w = c.paint.get("circle-stroke-width"), E = c.paint.get("circle-stroke-opacity"), O = c.layout.get("circle-sort-key").constantOr(1) !== void 0;
          if (_.constantOr(1) !== 0 || w.constantOr(1) !== 0 && E.constantOr(1) !== 0) {
            for (var k = u.context, R = k.gl, $ = u.depthModeForSublayer(0, Z.ReadOnly), W = Q.disabled, H = u.colorModeForRenderPass(), ne = [], te = 0; te < d.length; te++) {
              var ue = d[te], Y = f.getTile(ue), le = Y.getBucket(c);
              if (le) {
                var me = le.programConfigurations.get(c.id), xe = { programConfiguration: me, program: u.useProgram("circle", me), layoutVertexBuffer: le.layoutVertexBuffer, indexBuffer: le.indexBuffer, uniformValues: Qf(u, ue, Y, c) };
                if (O)
                  for (var Ae = 0, Me = le.segments.get(); Ae < Me.length; Ae += 1) {
                    var ke = Me[Ae];
                    ne.push({ segments: new a.SegmentVector([ke]), sortKey: ke.sortKey, state: xe });
                  }
                else
                  ne.push({ segments: le.segments, sortKey: 0, state: xe });
              }
            }
            O && ne.sort(function(Dt, Bt) {
              return Dt.sortKey - Bt.sortKey;
            });
            for (var je = 0, nt = ne; je < nt.length; je += 1) {
              var tt = nt[je], gt = tt.state;
              gt.program.draw(k, R.TRIANGLES, $, W, H, de.disabled, gt.uniformValues, c.id, gt.layoutVertexBuffer, gt.indexBuffer, tt.segments, c.paint, u.transform.zoom, gt.programConfiguration);
            }
          }
        }
      }, heatmap: function(u, f, c, d) {
        if (c.paint.get("heatmap-opacity") !== 0)
          if (u.renderPass === "offscreen") {
            var _ = u.context, w = _.gl, E = Q.disabled, O = new pe([w.ONE, w.ONE], a.Color.transparent, [!0, !0, !0, !0]);
            (function(ne, te, ue) {
              var Y = ne.gl;
              ne.activeTexture.set(Y.TEXTURE1), ne.viewport.set([0, 0, te.width / 4, te.height / 4]);
              var le = ue.heatmapFbo;
              if (le)
                Y.bindTexture(Y.TEXTURE_2D, le.colorAttachment.get()), ne.bindFramebuffer.set(le.framebuffer);
              else {
                var me = Y.createTexture();
                Y.bindTexture(Y.TEXTURE_2D, me), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_WRAP_S, Y.CLAMP_TO_EDGE), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_WRAP_T, Y.CLAMP_TO_EDGE), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MIN_FILTER, Y.LINEAR), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MAG_FILTER, Y.LINEAR), le = ue.heatmapFbo = ne.createFramebuffer(te.width / 4, te.height / 4, !1), function(xe, Ae, Me, ke) {
                  var je = xe.gl;
                  je.texImage2D(je.TEXTURE_2D, 0, je.RGBA, Ae.width / 4, Ae.height / 4, 0, je.RGBA, xe.extRenderToTextureHalfFloat ? xe.extTextureHalfFloat.HALF_FLOAT_OES : je.UNSIGNED_BYTE, null), ke.colorAttachment.set(Me);
                }(ne, te, me, le);
              }
            })(_, u, c), _.clear({ color: a.Color.transparent });
            for (var k = 0; k < d.length; k++) {
              var R = d[k];
              if (!f.hasRenderableParent(R)) {
                var $ = f.getTile(R), W = $.getBucket(c);
                if (W) {
                  var H = W.programConfigurations.get(c.id);
                  u.useProgram("heatmap", H).draw(_, w.TRIANGLES, Z.disabled, E, O, de.disabled, Sm(R.posMatrix, $, u.transform.zoom, c.paint.get("heatmap-intensity")), c.id, W.layoutVertexBuffer, W.indexBuffer, W.segments, c.paint, u.transform.zoom, H);
                }
              }
            }
            _.viewport.set([0, 0, u.width, u.height]);
          } else
            u.renderPass === "translucent" && (u.context.setColorMode(u.colorModeForRenderPass()), function(ne, te) {
              var ue = ne.context, Y = ue.gl, le = te.heatmapFbo;
              if (le) {
                ue.activeTexture.set(Y.TEXTURE0), Y.bindTexture(Y.TEXTURE_2D, le.colorAttachment.get()), ue.activeTexture.set(Y.TEXTURE1);
                var me = te.colorRampTexture;
                me || (me = te.colorRampTexture = new a.Texture(ue, te.colorRamp, Y.RGBA)), me.bind(Y.LINEAR, Y.CLAMP_TO_EDGE), ne.useProgram("heatmapTexture").draw(ue, Y.TRIANGLES, Z.disabled, Q.disabled, ne.colorModeForRenderPass(), de.disabled, function(xe, Ae, Me, ke) {
                  var je = a.create();
                  a.ortho(je, 0, xe.width, xe.height, 0, 0, 1);
                  var nt = xe.context.gl;
                  return { u_matrix: je, u_world: [nt.drawingBufferWidth, nt.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: Ae.paint.get("heatmap-opacity") };
                }(ne, te), te.id, ne.viewportBuffer, ne.quadTriangleIndexBuffer, ne.viewportSegments, te.paint, ne.transform.zoom);
              }
            }(u, c));
      }, line: function(u, f, c, d) {
        if (u.renderPass === "translucent") {
          var _ = c.paint.get("line-opacity"), w = c.paint.get("line-width");
          if (_.constantOr(1) !== 0 && w.constantOr(1) !== 0)
            for (var E = u.depthModeForSublayer(0, Z.ReadOnly), O = u.colorModeForRenderPass(), k = c.paint.get("line-dasharray"), R = c.paint.get("line-pattern"), $ = R.constantOr(1), W = c.paint.get("line-gradient"), H = c.getCrossfadeParameters(), ne = $ ? "linePattern" : k ? "lineSDF" : W ? "lineGradient" : "line", te = u.context, ue = te.gl, Y = !0, le = 0, me = d; le < me.length; le += 1) {
              var xe = me[le], Ae = f.getTile(xe);
              if (!$ || Ae.patternsLoaded()) {
                var Me = Ae.getBucket(c);
                if (Me) {
                  var ke = Me.programConfigurations.get(c.id), je = u.context.program.get(), nt = u.useProgram(ne, ke), tt = Y || nt.program !== je, gt = R.constantOr(null);
                  if (gt && Ae.imageAtlas) {
                    var Dt = Ae.imageAtlas, Bt = Dt.patternPositions[gt.to.toString()], zt = Dt.patternPositions[gt.from.toString()];
                    Bt && zt && ke.setConstantPatternPositions(Bt, zt);
                  }
                  var Ir = $ ? hh(u, Ae, c, H) : k ? Wv(u, Ae, c, k, H) : W ? Qr(u, Ae, c, Me.lineClipsArray.length) : Qu(u, Ae, c);
                  if ($)
                    te.activeTexture.set(ue.TEXTURE0), Ae.imageAtlasTexture.bind(ue.LINEAR, ue.CLAMP_TO_EDGE), ke.updatePaintBuffers(H);
                  else if (k && (tt || u.lineAtlas.dirty))
                    te.activeTexture.set(ue.TEXTURE0), u.lineAtlas.bind(te);
                  else if (W) {
                    var xt = Me.gradients[c.id], Yt = xt.texture;
                    if (c.gradientVersion !== xt.version) {
                      var ir = 256;
                      if (c.stepInterpolant) {
                        var Kt = f.getSource().maxzoom, Xt = xe.canonical.z === Kt ? Math.ceil(1 << u.transform.maxZoom - xe.canonical.z) : 1;
                        ir = a.clamp(a.nextPowerOfTwo(Me.maxLineLength / a.EXTENT * 1024 * Xt), 256, te.maxTextureSize);
                      }
                      xt.gradient = a.renderColorRamp({ expression: c.gradientExpression(), evaluationKey: "lineProgress", resolution: ir, image: xt.gradient || void 0, clips: Me.lineClipsArray }), xt.texture ? xt.texture.update(xt.gradient) : xt.texture = new a.Texture(te, xt.gradient, ue.RGBA), xt.version = c.gradientVersion, Yt = xt.texture;
                    }
                    te.activeTexture.set(ue.TEXTURE0), Yt.bind(c.stepInterpolant ? ue.NEAREST : ue.LINEAR, ue.CLAMP_TO_EDGE);
                  }
                  nt.draw(te, ue.TRIANGLES, E, u.stencilModeForClipping(xe), O, de.disabled, Ir, c.id, Me.layoutVertexBuffer, Me.indexBuffer, Me.segments, c.paint, u.transform.zoom, ke, Me.layoutVertexBuffer2), Y = !1;
                }
              }
            }
        }
      }, fill: function(u, f, c, d) {
        var _ = c.paint.get("fill-color"), w = c.paint.get("fill-opacity");
        if (w.constantOr(1) !== 0) {
          var E = u.colorModeForRenderPass(), O = c.paint.get("fill-pattern"), k = u.opaquePassEnabledForLayer() && !O.constantOr(1) && _.constantOr(a.Color.transparent).a === 1 && w.constantOr(0) === 1 ? "opaque" : "translucent";
          if (u.renderPass === k) {
            var R = u.depthModeForSublayer(1, u.renderPass === "opaque" ? Z.ReadWrite : Z.ReadOnly);
            dh(u, f, c, d, R, E, !1);
          }
          if (u.renderPass === "translucent" && c.paint.get("fill-antialias")) {
            var $ = u.depthModeForSublayer(c.getPaintProperty("fill-outline-color") ? 2 : 0, Z.ReadOnly);
            dh(u, f, c, d, $, E, !0);
          }
        }
      }, "fill-extrusion": function(u, f, c, d) {
        var _ = c.paint.get("fill-extrusion-opacity");
        if (_ !== 0 && u.renderPass === "translucent") {
          var w = new Z(u.context.gl.LEQUAL, Z.ReadWrite, u.depthRangeFor3D);
          if (_ !== 1 || c.paint.get("fill-extrusion-pattern").constantOr(1))
            ep(u, f, c, d, w, Q.disabled, pe.disabled), ep(u, f, c, d, w, u.stencilModeFor3D(), u.colorModeForRenderPass());
          else {
            var E = u.colorModeForRenderPass();
            ep(u, f, c, d, w, Q.disabled, E);
          }
        }
      }, hillshade: function(u, f, c, d) {
        if (u.renderPass === "offscreen" || u.renderPass === "translucent") {
          for (var _ = u.context, w = u.depthModeForSublayer(0, Z.ReadOnly), E = u.colorModeForRenderPass(), O = u.renderPass === "translucent" ? u.stencilConfigForOverlap(d) : [{}, d], k = O[0], R = 0, $ = O[1]; R < $.length; R += 1) {
            var W = $[R], H = f.getTile(W);
            H.needsHillshadePrepare && u.renderPass === "offscreen" ? Zv(u, H, c, w, Q.disabled, E) : u.renderPass === "translucent" && mh(u, H, c, w, k[W.overscaledZ], E);
          }
          _.viewport.set([0, 0, u.width, u.height]);
        }
      }, raster: function(u, f, c, d) {
        if (u.renderPass === "translucent" && c.paint.get("raster-opacity") !== 0 && d.length)
          for (var _ = u.context, w = _.gl, E = f.getSource(), O = u.useProgram("raster"), k = u.colorModeForRenderPass(), R = E instanceof pr ? [{}, d] : u.stencilConfigForOverlap(d), $ = R[0], W = R[1], H = W[W.length - 1].overscaledZ, ne = !u.options.moving, te = 0, ue = W; te < ue.length; te += 1) {
            var Y = ue[te], le = u.depthModeForSublayer(Y.overscaledZ - H, c.paint.get("raster-opacity") === 1 ? Z.ReadWrite : Z.ReadOnly, w.LESS), me = f.getTile(Y), xe = u.transform.calculatePosMatrix(Y.toUnwrapped(), ne);
            me.registerFadeDuration(c.paint.get("raster-fade-duration"));
            var Ae = f.findLoadedParent(Y, 0), Me = yh(me, Ae, f, c, u.transform), ke = void 0, je = void 0, nt = c.paint.get("raster-resampling") === "nearest" ? w.NEAREST : w.LINEAR;
            _.activeTexture.set(w.TEXTURE0), me.texture.bind(nt, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST), _.activeTexture.set(w.TEXTURE1), Ae ? (Ae.texture.bind(nt, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST), ke = Math.pow(2, Ae.tileID.overscaledZ - me.tileID.overscaledZ), je = [me.tileID.canonical.x * ke % 1, me.tileID.canonical.y * ke % 1]) : me.texture.bind(nt, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST);
            var tt = Hv(xe, je || [0, 0], ke || 1, Me, c);
            E instanceof pr ? O.draw(_, w.TRIANGLES, le, Q.disabled, k, de.disabled, tt, c.id, E.boundsBuffer, u.quadTriangleIndexBuffer, E.boundsSegments) : O.draw(_, w.TRIANGLES, le, $[Y.overscaledZ], k, de.disabled, tt, c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments);
          }
      }, background: function(u, f, c) {
        var d = c.paint.get("background-color"), _ = c.paint.get("background-opacity");
        if (_ !== 0) {
          var w = u.context, E = w.gl, O = u.transform, k = O.tileSize, R = c.paint.get("background-pattern");
          if (!u.isPatternMissing(R)) {
            var $ = !R && d.a === 1 && _ === 1 && u.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (u.renderPass === $) {
              var W = Q.disabled, H = u.depthModeForSublayer(0, $ === "opaque" ? Z.ReadWrite : Z.ReadOnly), ne = u.colorModeForRenderPass(), te = u.useProgram(R ? "backgroundPattern" : "background"), ue = O.coveringTiles({ tileSize: k });
              R && (w.activeTexture.set(E.TEXTURE0), u.imageManager.bind(u.context));
              for (var Y = c.getCrossfadeParameters(), le = 0, me = ue; le < me.length; le += 1) {
                var xe = me[le], Ae = u.transform.calculatePosMatrix(xe.toUnwrapped()), Me = R ? eu(Ae, _, u, R, { tileID: xe, tileSize: k }, Y) : tc(Ae, _, d);
                te.draw(w, E.TRIANGLES, H, W, ne, de.disabled, Me, c.id, u.tileExtentBuffer, u.quadTriangleIndexBuffer, u.tileExtentSegments);
              }
            }
          }
        }
      }, debug: function(u, f, c) {
        for (var d = 0; d < c.length; d++)
          Lm(u, f, c[d]);
      }, custom: function(u, f, c) {
        var d = u.context, _ = c.implementation;
        if (u.renderPass === "offscreen") {
          var w = _.prerender;
          w && (u.setCustomLayerDefaults(), d.setColorMode(u.colorModeForRenderPass()), w.call(_, d.gl, u.transform.customLayerMatrix()), d.setDirty(), u.setBaseState());
        } else if (u.renderPass === "translucent") {
          u.setCustomLayerDefaults(), d.setColorMode(u.colorModeForRenderPass()), d.setStencilMode(Q.disabled);
          var E = _.renderingMode === "3d" ? new Z(u.context.gl.LEQUAL, Z.ReadWrite, u.depthRangeFor3D) : u.depthModeForSublayer(0, Z.ReadOnly);
          d.setDepthMode(E), _.render(d.gl, u.transform.customLayerMatrix()), d.setDirty(), u.setBaseState(), d.bindFramebuffer.set(null);
        }
      } }, mn = function(u, f) {
        this.context = new G(u), this.transform = f, this._tileTextures = {}, this.setup(), this.numSublayers = ie.maxUnderzooming + ie.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new ms(), this.gpuTimers = {};
      };
      mn.prototype.resize = function(u, f) {
        if (this.width = u * a.browser.devicePixelRatio, this.height = f * a.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
          for (var c = 0, d = this.style._order; c < d.length; c += 1)
            this.style._layers[d[c]].resize();
      }, mn.prototype.setup = function() {
        var u = this.context, f = new a.StructArrayLayout2i4();
        f.emplaceBack(0, 0), f.emplaceBack(a.EXTENT, 0), f.emplaceBack(0, a.EXTENT), f.emplaceBack(a.EXTENT, a.EXTENT), this.tileExtentBuffer = u.createVertexBuffer(f, jn.members), this.tileExtentSegments = a.SegmentVector.simpleSegment(0, 0, 4, 2);
        var c = new a.StructArrayLayout2i4();
        c.emplaceBack(0, 0), c.emplaceBack(a.EXTENT, 0), c.emplaceBack(0, a.EXTENT), c.emplaceBack(a.EXTENT, a.EXTENT), this.debugBuffer = u.createVertexBuffer(c, jn.members), this.debugSegments = a.SegmentVector.simpleSegment(0, 0, 4, 5);
        var d = new a.StructArrayLayout4i8();
        d.emplaceBack(0, 0, 0, 0), d.emplaceBack(a.EXTENT, 0, a.EXTENT, 0), d.emplaceBack(0, a.EXTENT, 0, a.EXTENT), d.emplaceBack(a.EXTENT, a.EXTENT, a.EXTENT, a.EXTENT), this.rasterBoundsBuffer = u.createVertexBuffer(d, Rr.members), this.rasterBoundsSegments = a.SegmentVector.simpleSegment(0, 0, 4, 2);
        var _ = new a.StructArrayLayout2i4();
        _.emplaceBack(0, 0), _.emplaceBack(1, 0), _.emplaceBack(0, 1), _.emplaceBack(1, 1), this.viewportBuffer = u.createVertexBuffer(_, jn.members), this.viewportSegments = a.SegmentVector.simpleSegment(0, 0, 4, 2);
        var w = new a.StructArrayLayout1ui2();
        w.emplaceBack(0), w.emplaceBack(1), w.emplaceBack(3), w.emplaceBack(2), w.emplaceBack(0), this.tileBorderIndexBuffer = u.createIndexBuffer(w);
        var E = new a.StructArrayLayout3ui6();
        E.emplaceBack(0, 1, 2), E.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = u.createIndexBuffer(E), this.emptyTexture = new a.Texture(u, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, u.gl.RGBA);
        var O = this.context.gl;
        this.stencilClearMode = new Q({ func: O.ALWAYS, mask: 0 }, 0, 255, O.ZERO, O.ZERO, O.ZERO);
      }, mn.prototype.clearStencil = function() {
        var u = this.context, f = u.gl;
        this.nextStencilID = 1, this.currentStencilSource = void 0;
        var c = a.create();
        a.ortho(c, 0, this.width, this.height, 0, 0, 1), a.scale(c, c, [f.drawingBufferWidth, f.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(u, f.TRIANGLES, Z.disabled, this.stencilClearMode, pe.disabled, de.disabled, yl(c), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
      }, mn.prototype._renderTileClippingMasks = function(u, f) {
        if (this.currentStencilSource !== u.source && u.isTileClipped() && f && f.length) {
          this.currentStencilSource = u.source;
          var c = this.context, d = c.gl;
          this.nextStencilID + f.length > 256 && this.clearStencil(), c.setColorMode(pe.disabled), c.setDepthMode(Z.disabled);
          var _ = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (var w = 0, E = f; w < E.length; w += 1) {
            var O = E[w], k = this._tileClippingMaskIDs[O.key] = this.nextStencilID++;
            _.draw(c, d.TRIANGLES, Z.disabled, new Q({ func: d.ALWAYS, mask: 0 }, k, 255, d.KEEP, d.KEEP, d.REPLACE), pe.disabled, de.disabled, yl(O.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
      }, mn.prototype.stencilModeFor3D = function() {
        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
        var u = this.nextStencilID++, f = this.context.gl;
        return new Q({ func: f.NOTEQUAL, mask: 255 }, u, 255, f.KEEP, f.KEEP, f.REPLACE);
      }, mn.prototype.stencilModeForClipping = function(u) {
        var f = this.context.gl;
        return new Q({ func: f.EQUAL, mask: 255 }, this._tileClippingMaskIDs[u.key], 0, f.KEEP, f.KEEP, f.REPLACE);
      }, mn.prototype.stencilConfigForOverlap = function(u) {
        var f, c = this.context.gl, d = u.sort(function(k, R) {
          return R.overscaledZ - k.overscaledZ;
        }), _ = d[d.length - 1].overscaledZ, w = d[0].overscaledZ - _ + 1;
        if (w > 1) {
          this.currentStencilSource = void 0, this.nextStencilID + w > 256 && this.clearStencil();
          for (var E = {}, O = 0; O < w; O++)
            E[O + _] = new Q({ func: c.GEQUAL, mask: 255 }, O + this.nextStencilID, 255, c.KEEP, c.KEEP, c.REPLACE);
          return this.nextStencilID += w, [E, d];
        }
        return [(f = {}, f[_] = Q.disabled, f), d];
      }, mn.prototype.colorModeForRenderPass = function() {
        var u = this.context.gl;
        return this._showOverdrawInspector ? new pe([u.CONSTANT_COLOR, u.ONE], new a.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? pe.unblended : pe.alphaBlended;
      }, mn.prototype.depthModeForSublayer = function(u, f, c) {
        if (!this.opaquePassEnabledForLayer())
          return Z.disabled;
        var d = 1 - ((1 + this.currentLayer) * this.numSublayers + u) * this.depthEpsilon;
        return new Z(c || this.context.gl.LEQUAL, f, [d, d]);
      }, mn.prototype.opaquePassEnabledForLayer = function() {
        return this.currentLayer < this.opaquePassCutoff;
      }, mn.prototype.render = function(u, f) {
        var c = this;
        this.style = u, this.options = f, this.lineAtlas = u.lineAtlas, this.imageManager = u.imageManager, this.glyphManager = u.glyphManager, this.symbolFadeChange = u.placement.symbolFadeChange(a.browser.now()), this.imageManager.beginFrame();
        var d = this.style._order, _ = this.style.sourceCaches;
        for (var w in _) {
          var E = _[w];
          E.used && E.prepare(this.context);
        }
        var O, k, R = {}, $ = {}, W = {};
        for (var H in _) {
          var ne = _[H];
          R[H] = ne.getVisibleCoordinates(), $[H] = R[H].slice().reverse(), W[H] = ne.getVisibleCoordinates(!0).reverse();
        }
        this.opaquePassCutoff = 1 / 0;
        for (var te = 0; te < d.length; te++)
          if (this.style._layers[d[te]].is3D()) {
            this.opaquePassCutoff = te;
            break;
          }
        this.renderPass = "offscreen";
        for (var ue = 0, Y = d; ue < Y.length; ue += 1) {
          var le = this.style._layers[Y[ue]];
          if (le.hasOffscreenPass() && !le.isHidden(this.transform.zoom)) {
            var me = $[le.source];
            (le.type === "custom" || me.length) && this.renderLayer(this, _[le.source], le, me);
          }
        }
        for (this.context.bindFramebuffer.set(null), this.context.clear({ color: f.showOverdrawInspector ? a.Color.black : a.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = f.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (u._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
          var xe = this.style._layers[d[this.currentLayer]], Ae = _[xe.source], Me = R[xe.source];
          this._renderTileClippingMasks(xe, Me), this.renderLayer(this, Ae, xe, Me);
        }
        for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
          var ke = this.style._layers[d[this.currentLayer]], je = _[ke.source], nt = (ke.type === "symbol" ? W : $)[ke.source];
          this._renderTileClippingMasks(ke, R[ke.source]), this.renderLayer(this, je, ke, nt);
        }
        this.options.showTileBoundaries && (a.values(this.style._layers).forEach(function(tt) {
          tt.source && !tt.isHidden(c.transform.zoom) && (tt.source !== (k && k.id) && (k = c.style.sourceCaches[tt.source]), (!O || O.getSource().maxzoom < k.getSource().maxzoom) && (O = k));
        }), O && vl.debug(this, O, O.getVisibleCoordinates())), this.options.showPadding && function(tt) {
          var gt = tt.transform.padding;
          np(tt, tt.transform.height - (gt.top || 0), 3, tp), np(tt, gt.bottom || 0, 3, Pm), ip(tt, gt.left || 0, 3, km), ip(tt, tt.transform.width - (gt.right || 0), 3, gh);
          var Dt = tt.transform.centerPoint;
          (function(Bt, zt, Ir, xt) {
            nc(Bt, zt - 1, Ir - 10, 2, 20, xt), nc(Bt, zt - 10, Ir - 1, 20, 2, xt);
          })(tt, Dt.x, tt.transform.height - Dt.y, rp);
        }(this), this.context.setDefault();
      }, mn.prototype.renderLayer = function(u, f, c, d) {
        c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "custom" || d.length) && (this.id = c.id, this.gpuTimingStart(c), vl[c.type](u, f, c, d, this.style.placement.variableOffsets), this.gpuTimingEnd());
      }, mn.prototype.gpuTimingStart = function(u) {
        if (this.options.gpuTiming) {
          var f = this.context.extTimerQuery, c = this.gpuTimers[u.id];
          c || (c = this.gpuTimers[u.id] = { calls: 0, cpuTime: 0, query: f.createQueryEXT() }), c.calls++, f.beginQueryEXT(f.TIME_ELAPSED_EXT, c.query);
        }
      }, mn.prototype.gpuTimingEnd = function() {
        if (this.options.gpuTiming) {
          var u = this.context.extTimerQuery;
          u.endQueryEXT(u.TIME_ELAPSED_EXT);
        }
      }, mn.prototype.collectGpuTimers = function() {
        var u = this.gpuTimers;
        return this.gpuTimers = {}, u;
      }, mn.prototype.queryGpuTimers = function(u) {
        var f = {};
        for (var c in u) {
          var d = u[c], _ = this.context.extTimerQuery, w = _.getQueryObjectEXT(d.query, _.QUERY_RESULT_EXT) / 1e6;
          _.deleteQueryEXT(d.query), f[c] = w;
        }
        return f;
      }, mn.prototype.translatePosMatrix = function(u, f, c, d, _) {
        if (!c[0] && !c[1])
          return u;
        var w = _ ? d === "map" ? this.transform.angle : 0 : d === "viewport" ? -this.transform.angle : 0;
        if (w) {
          var E = Math.sin(w), O = Math.cos(w);
          c = [c[0] * O - c[1] * E, c[0] * E + c[1] * O];
        }
        var k = [_ ? c[0] : dn(f, c[0], this.transform.zoom), _ ? c[1] : dn(f, c[1], this.transform.zoom), 0], R = new Float32Array(16);
        return a.translate(R, u, k), R;
      }, mn.prototype.saveTileTexture = function(u) {
        var f = this._tileTextures[u.size[0]];
        f ? f.push(u) : this._tileTextures[u.size[0]] = [u];
      }, mn.prototype.getTileTexture = function(u) {
        var f = this._tileTextures[u];
        return f && f.length > 0 ? f.pop() : null;
      }, mn.prototype.isPatternMissing = function(u) {
        if (!u)
          return !1;
        if (!u.from || !u.to)
          return !0;
        var f = this.imageManager.getPattern(u.from.toString()), c = this.imageManager.getPattern(u.to.toString());
        return !f || !c;
      }, mn.prototype.useProgram = function(u, f) {
        this.cache = this.cache || {};
        var c = "" + u + (f ? f.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "");
        return this.cache[c] || (this.cache[c] = new vm(this.context, u, qv[u], f, Im[u], this._showOverdrawInspector)), this.cache[c];
      }, mn.prototype.setCustomLayerDefaults = function() {
        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
      }, mn.prototype.setBaseState = function() {
        var u = this.context.gl;
        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(u.FUNC_ADD);
      }, mn.prototype.initDebugOverlayCanvas = function() {
        this.debugOverlayCanvas == null && (this.debugOverlayCanvas = a.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new a.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
      }, mn.prototype.destroy = function() {
        this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
      };
      var vh = function(u, f) {
        this.points = u, this.planes = f;
      };
      vh.fromInvProjectionMatrix = function(u, f, c) {
        var d = Math.pow(2, c), _ = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(function(E) {
          return a.transformMat4([], E, u);
        }).map(function(E) {
          return a.scale$1([], E, 1 / E[3] / f * d);
        }), w = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(function(E) {
          var O = a.sub([], _[E[0]], _[E[1]]), k = a.sub([], _[E[2]], _[E[1]]), R = a.normalize([], a.cross([], O, k)), $ = -a.dot(R, _[E[1]]);
          return R.concat($);
        });
        return new vh(_, w);
      };
      var _l = function(u, f) {
        this.min = u, this.max = f, this.center = a.scale$2([], a.add([], this.min, this.max), 0.5);
      };
      _l.prototype.quadrant = function(u) {
        for (var f = [u % 2 == 0, u < 2], c = a.clone$2(this.min), d = a.clone$2(this.max), _ = 0; _ < f.length; _++)
          c[_] = f[_] ? this.min[_] : this.center[_], d[_] = f[_] ? this.center[_] : this.max[_];
        return d[2] = this.max[2], new _l(c, d);
      }, _l.prototype.distanceX = function(u) {
        return Math.max(Math.min(this.max[0], u[0]), this.min[0]) - u[0];
      }, _l.prototype.distanceY = function(u) {
        return Math.max(Math.min(this.max[1], u[1]), this.min[1]) - u[1];
      }, _l.prototype.intersects = function(u) {
        for (var f = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], c = !0, d = 0; d < u.planes.length; d++) {
          for (var _ = u.planes[d], w = 0, E = 0; E < f.length; E++)
            w += a.dot$1(_, f[E]) >= 0;
          if (w === 0)
            return 0;
          w !== f.length && (c = !1);
        }
        if (c)
          return 2;
        for (var O = 0; O < 3; O++) {
          for (var k = Number.MAX_VALUE, R = -Number.MAX_VALUE, $ = 0; $ < u.points.length; $++) {
            var W = u.points[$][O] - this.min[O];
            k = Math.min(k, W), R = Math.max(R, W);
          }
          if (R < 0 || k > this.max[O] - this.min[O])
            return 0;
        }
        return 1;
      };
      var Es = function(u, f, c, d) {
        if (u === void 0 && (u = 0), f === void 0 && (f = 0), c === void 0 && (c = 0), d === void 0 && (d = 0), isNaN(u) || u < 0 || isNaN(f) || f < 0 || isNaN(c) || c < 0 || isNaN(d) || d < 0)
          throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
        this.top = u, this.bottom = f, this.left = c, this.right = d;
      };
      Es.prototype.interpolate = function(u, f, c) {
        return f.top != null && u.top != null && (this.top = a.number(u.top, f.top, c)), f.bottom != null && u.bottom != null && (this.bottom = a.number(u.bottom, f.bottom, c)), f.left != null && u.left != null && (this.left = a.number(u.left, f.left, c)), f.right != null && u.right != null && (this.right = a.number(u.right, f.right, c)), this;
      }, Es.prototype.getCenter = function(u, f) {
        var c = a.clamp((this.left + u - this.right) / 2, 0, u), d = a.clamp((this.top + f - this.bottom) / 2, 0, f);
        return new a.Point(c, d);
      }, Es.prototype.equals = function(u) {
        return this.top === u.top && this.bottom === u.bottom && this.left === u.left && this.right === u.right;
      }, Es.prototype.clone = function() {
        return new Es(this.top, this.bottom, this.left, this.right);
      }, Es.prototype.toJSON = function() {
        return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
      };
      var wr = function(u, f, c, d, _) {
        this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = _ === void 0 || _, this._minZoom = u || 0, this._maxZoom = f || 22, this._minPitch = c == null ? 0 : c, this._maxPitch = d == null ? 60 : d, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new a.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new Es(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
      }, en = { minZoom: { configurable: !0 }, maxZoom: { configurable: !0 }, minPitch: { configurable: !0 }, maxPitch: { configurable: !0 }, renderWorldCopies: { configurable: !0 }, worldSize: { configurable: !0 }, centerOffset: { configurable: !0 }, size: { configurable: !0 }, bearing: { configurable: !0 }, pitch: { configurable: !0 }, fov: { configurable: !0 }, zoom: { configurable: !0 }, center: { configurable: !0 }, padding: { configurable: !0 }, centerPoint: { configurable: !0 }, unmodified: { configurable: !0 }, point: { configurable: !0 } };
      wr.prototype.clone = function() {
        var u = new wr(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
        return u.tileSize = this.tileSize, u.latRange = this.latRange, u.width = this.width, u.height = this.height, u._center = this._center, u.zoom = this.zoom, u.angle = this.angle, u._fov = this._fov, u._pitch = this._pitch, u._unmodified = this._unmodified, u._edgeInsets = this._edgeInsets.clone(), u._calcMatrices(), u;
      }, en.minZoom.get = function() {
        return this._minZoom;
      }, en.minZoom.set = function(u) {
        this._minZoom !== u && (this._minZoom = u, this.zoom = Math.max(this.zoom, u));
      }, en.maxZoom.get = function() {
        return this._maxZoom;
      }, en.maxZoom.set = function(u) {
        this._maxZoom !== u && (this._maxZoom = u, this.zoom = Math.min(this.zoom, u));
      }, en.minPitch.get = function() {
        return this._minPitch;
      }, en.minPitch.set = function(u) {
        this._minPitch !== u && (this._minPitch = u, this.pitch = Math.max(this.pitch, u));
      }, en.maxPitch.get = function() {
        return this._maxPitch;
      }, en.maxPitch.set = function(u) {
        this._maxPitch !== u && (this._maxPitch = u, this.pitch = Math.min(this.pitch, u));
      }, en.renderWorldCopies.get = function() {
        return this._renderWorldCopies;
      }, en.renderWorldCopies.set = function(u) {
        u === void 0 ? u = !0 : u === null && (u = !1), this._renderWorldCopies = u;
      }, en.worldSize.get = function() {
        return this.tileSize * this.scale;
      }, en.centerOffset.get = function() {
        return this.centerPoint._sub(this.size._div(2));
      }, en.size.get = function() {
        return new a.Point(this.width, this.height);
      }, en.bearing.get = function() {
        return -this.angle / Math.PI * 180;
      }, en.bearing.set = function(u) {
        var f = -a.wrap(u, -180, 180) * Math.PI / 180;
        this.angle !== f && (this._unmodified = !1, this.angle = f, this._calcMatrices(), this.rotationMatrix = a.create$2(), a.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
      }, en.pitch.get = function() {
        return this._pitch / Math.PI * 180;
      }, en.pitch.set = function(u) {
        var f = a.clamp(u, this.minPitch, this.maxPitch) / 180 * Math.PI;
        this._pitch !== f && (this._unmodified = !1, this._pitch = f, this._calcMatrices());
      }, en.fov.get = function() {
        return this._fov / Math.PI * 180;
      }, en.fov.set = function(u) {
        u = Math.max(0.01, Math.min(60, u)), this._fov !== u && (this._unmodified = !1, this._fov = u / 180 * Math.PI, this._calcMatrices());
      }, en.zoom.get = function() {
        return this._zoom;
      }, en.zoom.set = function(u) {
        var f = Math.min(Math.max(u, this.minZoom), this.maxZoom);
        this._zoom !== f && (this._unmodified = !1, this._zoom = f, this.scale = this.zoomScale(f), this.tileZoom = Math.floor(f), this.zoomFraction = f - this.tileZoom, this._constrain(), this._calcMatrices());
      }, en.center.get = function() {
        return this._center;
      }, en.center.set = function(u) {
        u.lat === this._center.lat && u.lng === this._center.lng || (this._unmodified = !1, this._center = u, this._constrain(), this._calcMatrices());
      }, en.padding.get = function() {
        return this._edgeInsets.toJSON();
      }, en.padding.set = function(u) {
        this._edgeInsets.equals(u) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, u, 1), this._calcMatrices());
      }, en.centerPoint.get = function() {
        return this._edgeInsets.getCenter(this.width, this.height);
      }, wr.prototype.isPaddingEqual = function(u) {
        return this._edgeInsets.equals(u);
      }, wr.prototype.interpolatePadding = function(u, f, c) {
        this._unmodified = !1, this._edgeInsets.interpolate(u, f, c), this._constrain(), this._calcMatrices();
      }, wr.prototype.coveringZoomLevel = function(u) {
        var f = (u.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / u.tileSize));
        return Math.max(0, f);
      }, wr.prototype.getVisibleUnwrappedCoordinates = function(u) {
        var f = [new a.UnwrappedTileID(0, u)];
        if (this._renderWorldCopies)
          for (var c = this.pointCoordinate(new a.Point(0, 0)), d = this.pointCoordinate(new a.Point(this.width, 0)), _ = this.pointCoordinate(new a.Point(this.width, this.height)), w = this.pointCoordinate(new a.Point(0, this.height)), E = Math.floor(Math.min(c.x, d.x, _.x, w.x)), O = Math.floor(Math.max(c.x, d.x, _.x, w.x)), k = E - 1; k <= O + 1; k++)
            k !== 0 && f.push(new a.UnwrappedTileID(k, u));
        return f;
      }, wr.prototype.coveringTiles = function(u) {
        var f = this.coveringZoomLevel(u), c = f;
        if (u.minzoom !== void 0 && f < u.minzoom)
          return [];
        u.maxzoom !== void 0 && f > u.maxzoom && (f = u.maxzoom);
        var d = a.MercatorCoordinate.fromLngLat(this.center), _ = Math.pow(2, f), w = [_ * d.x, _ * d.y, 0], E = vh.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, f), O = u.minzoom || 0;
        this.pitch <= 60 && this._edgeInsets.top < 0.1 && (O = f);
        var k = function(tt) {
          return { aabb: new _l([tt * _, 0, 0], [(tt + 1) * _, _, 0]), zoom: 0, x: 0, y: 0, wrap: tt, fullyVisible: !1 };
        }, R = [], $ = [], W = f, H = u.reparseOverscaled ? c : f;
        if (this._renderWorldCopies)
          for (var ne = 1; ne <= 3; ne++)
            R.push(k(-ne)), R.push(k(ne));
        for (R.push(k(0)); R.length > 0; ) {
          var te = R.pop(), ue = te.x, Y = te.y, le = te.fullyVisible;
          if (!le) {
            var me = te.aabb.intersects(E);
            if (me === 0)
              continue;
            le = me === 2;
          }
          var xe = te.aabb.distanceX(w), Ae = te.aabb.distanceY(w), Me = Math.max(Math.abs(xe), Math.abs(Ae));
          if (te.zoom === W || Me > 3 + (1 << W - te.zoom) - 2 && te.zoom >= O)
            $.push({ tileID: new a.OverscaledTileID(te.zoom === W ? H : te.zoom, te.wrap, te.zoom, ue, Y), distanceSq: a.sqrLen([w[0] - 0.5 - ue, w[1] - 0.5 - Y]) });
          else
            for (var ke = 0; ke < 4; ke++) {
              var je = (ue << 1) + ke % 2, nt = (Y << 1) + (ke >> 1);
              R.push({ aabb: te.aabb.quadrant(ke), zoom: te.zoom + 1, x: je, y: nt, wrap: te.wrap, fullyVisible: le });
            }
        }
        return $.sort(function(tt, gt) {
          return tt.distanceSq - gt.distanceSq;
        }).map(function(tt) {
          return tt.tileID;
        });
      }, wr.prototype.resize = function(u, f) {
        this.width = u, this.height = f, this.pixelsToGLUnits = [2 / u, -2 / f], this._constrain(), this._calcMatrices();
      }, en.unmodified.get = function() {
        return this._unmodified;
      }, wr.prototype.zoomScale = function(u) {
        return Math.pow(2, u);
      }, wr.prototype.scaleZoom = function(u) {
        return Math.log(u) / Math.LN2;
      }, wr.prototype.project = function(u) {
        var f = a.clamp(u.lat, -this.maxValidLatitude, this.maxValidLatitude);
        return new a.Point(a.mercatorXfromLng(u.lng) * this.worldSize, a.mercatorYfromLat(f) * this.worldSize);
      }, wr.prototype.unproject = function(u) {
        return new a.MercatorCoordinate(u.x / this.worldSize, u.y / this.worldSize).toLngLat();
      }, en.point.get = function() {
        return this.project(this.center);
      }, wr.prototype.setLocationAtPoint = function(u, f) {
        var c = this.pointCoordinate(f), d = this.pointCoordinate(this.centerPoint), _ = this.locationCoordinate(u), w = new a.MercatorCoordinate(_.x - (c.x - d.x), _.y - (c.y - d.y));
        this.center = this.coordinateLocation(w), this._renderWorldCopies && (this.center = this.center.wrap());
      }, wr.prototype.locationPoint = function(u) {
        return this.coordinatePoint(this.locationCoordinate(u));
      }, wr.prototype.pointLocation = function(u) {
        return this.coordinateLocation(this.pointCoordinate(u));
      }, wr.prototype.locationCoordinate = function(u) {
        return a.MercatorCoordinate.fromLngLat(u);
      }, wr.prototype.coordinateLocation = function(u) {
        return u.toLngLat();
      }, wr.prototype.pointCoordinate = function(u) {
        var f = [u.x, u.y, 0, 1], c = [u.x, u.y, 1, 1];
        a.transformMat4(f, f, this.pixelMatrixInverse), a.transformMat4(c, c, this.pixelMatrixInverse);
        var d = f[3], _ = c[3], w = f[1] / d, E = c[1] / _, O = f[2] / d, k = c[2] / _, R = O === k ? 0 : (0 - O) / (k - O);
        return new a.MercatorCoordinate(a.number(f[0] / d, c[0] / _, R) / this.worldSize, a.number(w, E, R) / this.worldSize);
      }, wr.prototype.coordinatePoint = function(u) {
        var f = [u.x * this.worldSize, u.y * this.worldSize, 0, 1];
        return a.transformMat4(f, f, this.pixelMatrix), new a.Point(f[0] / f[3], f[1] / f[3]);
      }, wr.prototype.getBounds = function() {
        return new a.LngLatBounds().extend(this.pointLocation(new a.Point(0, 0))).extend(this.pointLocation(new a.Point(this.width, 0))).extend(this.pointLocation(new a.Point(this.width, this.height))).extend(this.pointLocation(new a.Point(0, this.height)));
      }, wr.prototype.getMaxBounds = function() {
        return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new a.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
      }, wr.prototype.setMaxBounds = function(u) {
        u ? (this.lngRange = [u.getWest(), u.getEast()], this.latRange = [u.getSouth(), u.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
      }, wr.prototype.calculatePosMatrix = function(u, f) {
        f === void 0 && (f = !1);
        var c = u.key, d = f ? this._alignedPosMatrixCache : this._posMatrixCache;
        if (d[c])
          return d[c];
        var _ = u.canonical, w = this.worldSize / this.zoomScale(_.z), E = _.x + Math.pow(2, _.z) * u.wrap, O = a.identity(new Float64Array(16));
        return a.translate(O, O, [E * w, _.y * w, 0]), a.scale(O, O, [w / a.EXTENT, w / a.EXTENT, 1]), a.multiply(O, f ? this.alignedProjMatrix : this.projMatrix, O), d[c] = new Float32Array(O), d[c];
      }, wr.prototype.customLayerMatrix = function() {
        return this.mercatorMatrix.slice();
      }, wr.prototype._constrain = function() {
        if (this.center && this.width && this.height && !this._constraining) {
          this._constraining = !0;
          var u, f, c, d, _ = -90, w = 90, E = -180, O = 180, k = this.size, R = this._unmodified;
          if (this.latRange) {
            var $ = this.latRange;
            _ = a.mercatorYfromLat($[1]) * this.worldSize, u = (w = a.mercatorYfromLat($[0]) * this.worldSize) - _ < k.y ? k.y / (w - _) : 0;
          }
          if (this.lngRange) {
            var W = this.lngRange;
            E = a.mercatorXfromLng(W[0]) * this.worldSize, f = (O = a.mercatorXfromLng(W[1]) * this.worldSize) - E < k.x ? k.x / (O - E) : 0;
          }
          var H = this.point, ne = Math.max(f || 0, u || 0);
          if (ne)
            return this.center = this.unproject(new a.Point(f ? (O + E) / 2 : H.x, u ? (w + _) / 2 : H.y)), this.zoom += this.scaleZoom(ne), this._unmodified = R, void (this._constraining = !1);
          if (this.latRange) {
            var te = H.y, ue = k.y / 2;
            te - ue < _ && (d = _ + ue), te + ue > w && (d = w - ue);
          }
          if (this.lngRange) {
            var Y = H.x, le = k.x / 2;
            Y - le < E && (c = E + le), Y + le > O && (c = O - le);
          }
          c === void 0 && d === void 0 || (this.center = this.unproject(new a.Point(c !== void 0 ? c : H.x, d !== void 0 ? d : H.y))), this._unmodified = R, this._constraining = !1;
        }
      }, wr.prototype._calcMatrices = function() {
        if (this.height) {
          var u = this.centerOffset;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
          var f = Math.PI / 2 + this._pitch, c = this._fov * (0.5 + u.y / this.height), d = Math.sin(c) * this.cameraToCenterDistance / Math.sin(a.clamp(Math.PI - f - c, 0.01, Math.PI - 0.01)), _ = this.point, w = _.x, E = _.y, O = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * d + this.cameraToCenterDistance), k = this.height / 50, R = new Float64Array(16);
          a.perspective(R, this._fov, this.width / this.height, k, O), R[8] = 2 * -u.x / this.width, R[9] = 2 * u.y / this.height, a.scale(R, R, [1, -1, 1]), a.translate(R, R, [0, 0, -this.cameraToCenterDistance]), a.rotateX(R, R, this._pitch), a.rotateZ(R, R, this.angle), a.translate(R, R, [-w, -E, 0]), this.mercatorMatrix = a.scale([], R, [this.worldSize, this.worldSize, this.worldSize]), a.scale(R, R, [1, 1, a.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = R, this.invProjMatrix = a.invert([], this.projMatrix);
          var $ = this.width % 2 / 2, W = this.height % 2 / 2, H = Math.cos(this.angle), ne = Math.sin(this.angle), te = w - Math.round(w) + H * $ + ne * W, ue = E - Math.round(E) + H * W + ne * $, Y = new Float64Array(R);
          if (a.translate(Y, Y, [te > 0.5 ? te - 1 : te, ue > 0.5 ? ue - 1 : ue, 0]), this.alignedProjMatrix = Y, R = a.create(), a.scale(R, R, [this.width / 2, -this.height / 2, 1]), a.translate(R, R, [1, -1, 0]), this.labelPlaneMatrix = R, R = a.create(), a.scale(R, R, [1, -1, 1]), a.translate(R, R, [-1, -1, 0]), a.scale(R, R, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = R, this.pixelMatrix = a.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(R = a.invert(new Float64Array(16), this.pixelMatrix)))
            throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = R, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }
      }, wr.prototype.maxPitchScaleFactor = function() {
        if (!this.pixelMatrixInverse)
          return 1;
        var u = this.pointCoordinate(new a.Point(0, 0)), f = [u.x * this.worldSize, u.y * this.worldSize, 0, 1];
        return a.transformMat4(f, f, this.pixelMatrix)[3] / this.cameraToCenterDistance;
      }, wr.prototype.getCameraPoint = function() {
        var u = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
        return this.centerPoint.add(new a.Point(0, u));
      }, wr.prototype.getCameraQueryGeometry = function(u) {
        var f = this.getCameraPoint();
        if (u.length === 1)
          return [u[0], f];
        for (var c = f.x, d = f.y, _ = f.x, w = f.y, E = 0, O = u; E < O.length; E += 1) {
          var k = O[E];
          c = Math.min(c, k.x), d = Math.min(d, k.y), _ = Math.max(_, k.x), w = Math.max(w, k.y);
        }
        return [new a.Point(c, d), new a.Point(_, d), new a.Point(_, w), new a.Point(c, w), new a.Point(c, d)];
      }, Object.defineProperties(wr.prototype, en);
      var Mo = function(u) {
        var f, c, d, _;
        this._hashName = u && encodeURIComponent(u), a.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (f = this._updateHashUnthrottled.bind(this), c = !1, d = null, _ = function() {
          d = null, c && (f(), d = setTimeout(_, 300), c = !1);
        }, function() {
          return c = !0, d || _(), d;
        });
      };
      Mo.prototype.addTo = function(u) {
        return this._map = u, a.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
      }, Mo.prototype.remove = function() {
        return a.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
      }, Mo.prototype.getHashString = function(u) {
        var f = this._map.getCenter(), c = Math.round(100 * this._map.getZoom()) / 100, d = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), _ = Math.pow(10, d), w = Math.round(f.lng * _) / _, E = Math.round(f.lat * _) / _, O = this._map.getBearing(), k = this._map.getPitch(), R = "";
        if (R += u ? "/" + w + "/" + E + "/" + c : c + "/" + E + "/" + w, (O || k) && (R += "/" + Math.round(10 * O) / 10), k && (R += "/" + Math.round(k)), this._hashName) {
          var $ = this._hashName, W = !1, H = a.window.location.hash.slice(1).split("&").map(function(ne) {
            var te = ne.split("=")[0];
            return te === $ ? (W = !0, te + "=" + R) : ne;
          }).filter(function(ne) {
            return ne;
          });
          return W || H.push($ + "=" + R), "#" + H.join("&");
        }
        return "#" + R;
      }, Mo.prototype._getCurrentHash = function() {
        var u, f = this, c = a.window.location.hash.replace("#", "");
        return this._hashName ? (c.split("&").map(function(d) {
          return d.split("=");
        }).forEach(function(d) {
          d[0] === f._hashName && (u = d);
        }), (u && u[1] || "").split("/")) : c.split("/");
      }, Mo.prototype._onHashChange = function() {
        var u = this._getCurrentHash();
        if (u.length >= 3 && !u.some(function(c) {
          return isNaN(c);
        })) {
          var f = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(u[3] || 0) : this._map.getBearing();
          return this._map.jumpTo({ center: [+u[2], +u[1]], zoom: +u[0], bearing: f, pitch: +(u[4] || 0) }), !0;
        }
        return !1;
      }, Mo.prototype._updateHashUnthrottled = function() {
        var u = a.window.location.href.replace(/(#.+)?$/, this.getHashString());
        try {
          a.window.history.replaceState(a.window.history.state, null, u);
        } catch {
        }
      };
      var ic = { linearity: 0.3, easing: a.bezier(0, 0, 0.3, 1) }, ru = a.extend({ deceleration: 2500, maxSpeed: 1400 }, ic), oc = a.extend({ deceleration: 20, maxSpeed: 1400 }, ic), Xv = a.extend({ deceleration: 1e3, maxSpeed: 360 }, ic), Kv = a.extend({ deceleration: 1e3, maxSpeed: 90 }, ic), ac = function(u) {
        this._map = u, this.clear();
      };
      function sc(u, f) {
        (!u.duration || u.duration < f.duration) && (u.duration = f.duration, u.easing = f.easing);
      }
      function Ua(u, f, c) {
        var d = c.maxSpeed, _ = c.linearity, w = c.deceleration, E = a.clamp(u * _ / (f / 1e3), -d, d), O = Math.abs(E) / (w * _);
        return { easing: c.easing, duration: 1e3 * O, amount: E * (O / 2) };
      }
      ac.prototype.clear = function() {
        this._inertiaBuffer = [];
      }, ac.prototype.record = function(u) {
        this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: a.browser.now(), settings: u });
      }, ac.prototype._drainInertiaBuffer = function() {
        for (var u = this._inertiaBuffer, f = a.browser.now(); u.length > 0 && f - u[0].time > 160; )
          u.shift();
      }, ac.prototype._onMoveEnd = function(u) {
        if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {
          for (var f = { zoom: 0, bearing: 0, pitch: 0, pan: new a.Point(0, 0), pinchAround: void 0, around: void 0 }, c = 0, d = this._inertiaBuffer; c < d.length; c += 1) {
            var _ = d[c].settings;
            f.zoom += _.zoomDelta || 0, f.bearing += _.bearingDelta || 0, f.pitch += _.pitchDelta || 0, _.panDelta && f.pan._add(_.panDelta), _.around && (f.around = _.around), _.pinchAround && (f.pinchAround = _.pinchAround);
          }
          var w = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, E = {};
          if (f.pan.mag()) {
            var O = Ua(f.pan.mag(), w, a.extend({}, ru, u || {}));
            E.offset = f.pan.mult(O.amount / f.pan.mag()), E.center = this._map.transform.center, sc(E, O);
          }
          if (f.zoom) {
            var k = Ua(f.zoom, w, oc);
            E.zoom = this._map.transform.zoom + k.amount, sc(E, k);
          }
          if (f.bearing) {
            var R = Ua(f.bearing, w, Xv);
            E.bearing = this._map.transform.bearing + a.clamp(R.amount, -179, 179), sc(E, R);
          }
          if (f.pitch) {
            var $ = Ua(f.pitch, w, Kv);
            E.pitch = this._map.transform.pitch + $.amount, sc(E, $);
          }
          if (E.zoom || E.bearing) {
            var W = f.pinchAround === void 0 ? f.around : f.pinchAround;
            E.around = W ? this._map.unproject(W) : this._map.getCenter();
          }
          return this.clear(), a.extend(E, { noMoveStart: !0 });
        }
      };
      var Jn = function(u) {
        function f(d, _, w, E) {
          E === void 0 && (E = {});
          var O = g.mousePos(_.getCanvasContainer(), w), k = _.unproject(O);
          u.call(this, d, a.extend({ point: O, lngLat: k, originalEvent: w }, E)), this._defaultPrevented = !1, this.target = _;
        }
        u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f;
        var c = { defaultPrevented: { configurable: !0 } };
        return f.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(f.prototype, c), f;
      }(a.Event), lc = function(u) {
        function f(d, _, w) {
          var E = d === "touchend" ? w.changedTouches : w.touches, O = g.touchPos(_.getCanvasContainer(), E), k = O.map(function(W) {
            return _.unproject(W);
          }), R = O.reduce(function(W, H, ne, te) {
            return W.add(H.div(te.length));
          }, new a.Point(0, 0)), $ = _.unproject(R);
          u.call(this, d, { points: O, point: R, lngLats: k, lngLat: $, originalEvent: w }), this._defaultPrevented = !1;
        }
        u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f;
        var c = { defaultPrevented: { configurable: !0 } };
        return f.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(f.prototype, c), f;
      }(a.Event), Dm = function(u) {
        function f(d, _, w) {
          u.call(this, d, { originalEvent: w }), this._defaultPrevented = !1;
        }
        u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f;
        var c = { defaultPrevented: { configurable: !0 } };
        return f.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(f.prototype, c), f;
      }(a.Event), Gn = function(u, f) {
        this._map = u, this._clickTolerance = f.clickTolerance;
      };
      Gn.prototype.reset = function() {
        delete this._mousedownPos;
      }, Gn.prototype.wheel = function(u) {
        return this._firePreventable(new Dm(u.type, this._map, u));
      }, Gn.prototype.mousedown = function(u, f) {
        return this._mousedownPos = f, this._firePreventable(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseup = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.click = function(u, f) {
        this._mousedownPos && this._mousedownPos.dist(f) >= this._clickTolerance || this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.dblclick = function(u) {
        return this._firePreventable(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseover = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseout = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.touchstart = function(u) {
        return this._firePreventable(new lc(u.type, this._map, u));
      }, Gn.prototype.touchmove = function(u) {
        this._map.fire(new lc(u.type, this._map, u));
      }, Gn.prototype.touchend = function(u) {
        this._map.fire(new lc(u.type, this._map, u));
      }, Gn.prototype.touchcancel = function(u) {
        this._map.fire(new lc(u.type, this._map, u));
      }, Gn.prototype._firePreventable = function(u) {
        if (this._map.fire(u), u.defaultPrevented)
          return {};
      }, Gn.prototype.isEnabled = function() {
        return !0;
      }, Gn.prototype.isActive = function() {
        return !1;
      }, Gn.prototype.enable = function() {
      }, Gn.prototype.disable = function() {
      };
      var wt = function(u) {
        this._map = u;
      };
      wt.prototype.reset = function() {
        this._delayContextMenu = !1, delete this._contextMenuEvent;
      }, wt.prototype.mousemove = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, wt.prototype.mousedown = function() {
        this._delayContextMenu = !0;
      }, wt.prototype.mouseup = function() {
        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Jn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
      }, wt.prototype.contextmenu = function(u) {
        this._delayContextMenu ? this._contextMenuEvent = u : this._map.fire(new Jn(u.type, this._map, u)), this._map.listens("contextmenu") && u.preventDefault();
      }, wt.prototype.isEnabled = function() {
        return !0;
      }, wt.prototype.isActive = function() {
        return !1;
      }, wt.prototype.enable = function() {
      }, wt.prototype.disable = function() {
      };
      var uo = function(u, f) {
        this._map = u, this._el = u.getCanvasContainer(), this._container = u.getContainer(), this._clickTolerance = f.clickTolerance || 1;
      };
      function _h(u, f) {
        for (var c = {}, d = 0; d < u.length; d++)
          c[u[d].identifier] = f[d];
        return c;
      }
      uo.prototype.isEnabled = function() {
        return !!this._enabled;
      }, uo.prototype.isActive = function() {
        return !!this._active;
      }, uo.prototype.enable = function() {
        this.isEnabled() || (this._enabled = !0);
      }, uo.prototype.disable = function() {
        this.isEnabled() && (this._enabled = !1);
      }, uo.prototype.mousedown = function(u, f) {
        this.isEnabled() && u.shiftKey && u.button === 0 && (g.disableDrag(), this._startPos = this._lastPos = f, this._active = !0);
      }, uo.prototype.mousemoveWindow = function(u, f) {
        if (this._active) {
          var c = f;
          if (!(this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance)) {
            var d = this._startPos;
            this._lastPos = c, this._box || (this._box = g.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", u));
            var _ = Math.min(d.x, c.x), w = Math.max(d.x, c.x), E = Math.min(d.y, c.y), O = Math.max(d.y, c.y);
            g.setTransform(this._box, "translate(" + _ + "px," + E + "px)"), this._box.style.width = w - _ + "px", this._box.style.height = O - E + "px";
          }
        }
      }, uo.prototype.mouseupWindow = function(u, f) {
        var c = this;
        if (this._active && u.button === 0) {
          var d = this._startPos, _ = f;
          if (this.reset(), g.suppressClick(), d.x !== _.x || d.y !== _.y)
            return this._map.fire(new a.Event("boxzoomend", { originalEvent: u })), { cameraAnimation: function(w) {
              return w.fitScreenCoordinates(d, _, c._map.getBearing(), { linear: !0 });
            } };
          this._fireEvent("boxzoomcancel", u);
        }
      }, uo.prototype.keydown = function(u) {
        this._active && u.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", u));
      }, uo.prototype.blur = function() {
        this.reset();
      }, uo.prototype.reset = function() {
        this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (g.remove(this._box), this._box = null), g.enableDrag(), delete this._startPos, delete this._lastPos;
      }, uo.prototype._fireEvent = function(u, f) {
        return this._map.fire(new a.Event(u, { originalEvent: f }));
      };
      var nu = function(u) {
        this.reset(), this.numTouches = u.numTouches;
      };
      nu.prototype.reset = function() {
        delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
      }, nu.prototype.touchstart = function(u, f, c) {
        (this.centroid || c.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = u.timeStamp), c.length === this.numTouches && (this.centroid = function(d) {
          for (var _ = new a.Point(0, 0), w = 0, E = d; w < E.length; w += 1)
            _._add(E[w]);
          return _.div(d.length);
        }(f), this.touches = _h(c, f)));
      }, nu.prototype.touchmove = function(u, f, c) {
        if (!this.aborted && this.centroid) {
          var d = _h(c, f);
          for (var _ in this.touches) {
            var w = d[_];
            (!w || w.dist(this.touches[_]) > 30) && (this.aborted = !0);
          }
        }
      }, nu.prototype.touchend = function(u, f, c) {
        if ((!this.centroid || u.timeStamp - this.startTime > 500) && (this.aborted = !0), c.length === 0) {
          var d = !this.aborted && this.centroid;
          if (this.reset(), d)
            return d;
        }
      };
      var aa = function(u) {
        this.singleTap = new nu(u), this.numTaps = u.numTaps, this.reset();
      };
      aa.prototype.reset = function() {
        this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
      }, aa.prototype.touchstart = function(u, f, c) {
        this.singleTap.touchstart(u, f, c);
      }, aa.prototype.touchmove = function(u, f, c) {
        this.singleTap.touchmove(u, f, c);
      }, aa.prototype.touchend = function(u, f, c) {
        var d = this.singleTap.touchend(u, f, c);
        if (d) {
          var _ = u.timeStamp - this.lastTime < 500, w = !this.lastTap || this.lastTap.dist(d) < 30;
          if (_ && w || this.reset(), this.count++, this.lastTime = u.timeStamp, this.lastTap = d, this.count === this.numTaps)
            return this.reset(), d;
        }
      };
      var co = function() {
        this._zoomIn = new aa({ numTouches: 1, numTaps: 2 }), this._zoomOut = new aa({ numTouches: 2, numTaps: 1 }), this.reset();
      };
      co.prototype.reset = function() {
        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
      }, co.prototype.touchstart = function(u, f, c) {
        this._zoomIn.touchstart(u, f, c), this._zoomOut.touchstart(u, f, c);
      }, co.prototype.touchmove = function(u, f, c) {
        this._zoomIn.touchmove(u, f, c), this._zoomOut.touchmove(u, f, c);
      }, co.prototype.touchend = function(u, f, c) {
        var d = this, _ = this._zoomIn.touchend(u, f, c), w = this._zoomOut.touchend(u, f, c);
        return _ ? (this._active = !0, u.preventDefault(), setTimeout(function() {
          return d.reset();
        }, 0), { cameraAnimation: function(E) {
          return E.easeTo({ duration: 300, zoom: E.getZoom() + 1, around: E.unproject(_) }, { originalEvent: u });
        } }) : w ? (this._active = !0, u.preventDefault(), setTimeout(function() {
          return d.reset();
        }, 0), { cameraAnimation: function(E) {
          return E.easeTo({ duration: 300, zoom: E.getZoom() - 1, around: E.unproject(w) }, { originalEvent: u });
        } }) : void 0;
      }, co.prototype.touchcancel = function() {
        this.reset();
      }, co.prototype.enable = function() {
        this._enabled = !0;
      }, co.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, co.prototype.isEnabled = function() {
        return this._enabled;
      }, co.prototype.isActive = function() {
        return this._active;
      };
      var op = { 0: 1, 2: 2 }, ct = function(u) {
        this.reset(), this._clickTolerance = u.clickTolerance || 1;
      };
      ct.prototype.blur = function() {
        this.reset();
      }, ct.prototype.reset = function() {
        this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;
      }, ct.prototype._correctButton = function(u, f) {
        return !1;
      }, ct.prototype._move = function(u, f) {
        return {};
      }, ct.prototype.mousedown = function(u, f) {
        if (!this._lastPoint) {
          var c = g.mouseButton(u);
          this._correctButton(u, c) && (this._lastPoint = f, this._eventButton = c);
        }
      }, ct.prototype.mousemoveWindow = function(u, f) {
        var c = this._lastPoint;
        if (c) {
          if (u.preventDefault(), function(d, _) {
            var w = op[_];
            return d.buttons === void 0 || (d.buttons & w) !== w;
          }(u, this._eventButton))
            this.reset();
          else if (this._moved || !(f.dist(c) < this._clickTolerance))
            return this._moved = !0, this._lastPoint = f, this._move(c, f);
        }
      }, ct.prototype.mouseupWindow = function(u) {
        this._lastPoint && g.mouseButton(u) === this._eventButton && (this._moved && g.suppressClick(), this.reset());
      }, ct.prototype.enable = function() {
        this._enabled = !0;
      }, ct.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, ct.prototype.isEnabled = function() {
        return this._enabled;
      }, ct.prototype.isActive = function() {
        return this._active;
      };
      var ap = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.mousedown = function(c, d) {
          u.prototype.mousedown.call(this, c, d), this._lastPoint && (this._active = !0);
        }, f.prototype._correctButton = function(c, d) {
          return d === 0 && !c.ctrlKey;
        }, f.prototype._move = function(c, d) {
          return { around: d, panDelta: d.sub(c) };
        }, f;
      }(ct), xh = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype._correctButton = function(c, d) {
          return d === 0 && c.ctrlKey || d === 2;
        }, f.prototype._move = function(c, d) {
          var _ = 0.8 * (d.x - c.x);
          if (_)
            return this._active = !0, { bearingDelta: _ };
        }, f.prototype.contextmenu = function(c) {
          c.preventDefault();
        }, f;
      }(ct), sp = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype._correctButton = function(c, d) {
          return d === 0 && c.ctrlKey || d === 2;
        }, f.prototype._move = function(c, d) {
          var _ = -0.5 * (d.y - c.y);
          if (_)
            return this._active = !0, { pitchDelta: _ };
        }, f.prototype.contextmenu = function(c) {
          c.preventDefault();
        }, f;
      }(ct), qo = function(u) {
        this._minTouches = 1, this._clickTolerance = u.clickTolerance || 1, this.reset();
      };
      qo.prototype.reset = function() {
        this._active = !1, this._touches = {}, this._sum = new a.Point(0, 0);
      }, qo.prototype.touchstart = function(u, f, c) {
        return this._calculateTransform(u, f, c);
      }, qo.prototype.touchmove = function(u, f, c) {
        if (this._active && !(c.length < this._minTouches))
          return u.preventDefault(), this._calculateTransform(u, f, c);
      }, qo.prototype.touchend = function(u, f, c) {
        this._calculateTransform(u, f, c), this._active && c.length < this._minTouches && this.reset();
      }, qo.prototype.touchcancel = function() {
        this.reset();
      }, qo.prototype._calculateTransform = function(u, f, c) {
        c.length > 0 && (this._active = !0);
        var d = _h(c, f), _ = new a.Point(0, 0), w = new a.Point(0, 0), E = 0;
        for (var O in d) {
          var k = d[O], R = this._touches[O];
          R && (_._add(k), w._add(k.sub(R)), E++, d[O] = k);
        }
        if (this._touches = d, !(E < this._minTouches) && w.mag()) {
          var $ = w.div(E);
          if (this._sum._add($), !(this._sum.mag() < this._clickTolerance))
            return { around: _.div(E), panDelta: $ };
        }
      }, qo.prototype.enable = function() {
        this._enabled = !0;
      }, qo.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, qo.prototype.isEnabled = function() {
        return this._enabled;
      }, qo.prototype.isActive = function() {
        return this._active;
      };
      var ho = function() {
        this.reset();
      };
      function bh(u, f, c) {
        for (var d = 0; d < u.length; d++)
          if (u[d].identifier === c)
            return f[d];
      }
      function wh(u, f) {
        return Math.log(u / f) / Math.LN2;
      }
      ho.prototype.reset = function() {
        this._active = !1, delete this._firstTwoTouches;
      }, ho.prototype._start = function(u) {
      }, ho.prototype._move = function(u, f, c) {
        return {};
      }, ho.prototype.touchstart = function(u, f, c) {
        this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([f[0], f[1]]));
      }, ho.prototype.touchmove = function(u, f, c) {
        if (this._firstTwoTouches) {
          u.preventDefault();
          var d = this._firstTwoTouches, _ = d[1], w = bh(c, f, d[0]), E = bh(c, f, _);
          if (w && E) {
            var O = this._aroundCenter ? null : w.add(E).div(2);
            return this._move([w, E], O, u);
          }
        }
      }, ho.prototype.touchend = function(u, f, c) {
        if (this._firstTwoTouches) {
          var d = this._firstTwoTouches, _ = d[1], w = bh(c, f, d[0]), E = bh(c, f, _);
          w && E || (this._active && g.suppressClick(), this.reset());
        }
      }, ho.prototype.touchcancel = function() {
        this.reset();
      }, ho.prototype.enable = function(u) {
        this._enabled = !0, this._aroundCenter = !!u && u.around === "center";
      }, ho.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, ho.prototype.isEnabled = function() {
        return this._enabled;
      }, ho.prototype.isActive = function() {
        return this._active;
      };
      var fo = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.reset = function() {
          u.prototype.reset.call(this), delete this._distance, delete this._startDistance;
        }, f.prototype._start = function(c) {
          this._startDistance = this._distance = c[0].dist(c[1]);
        }, f.prototype._move = function(c, d) {
          var _ = this._distance;
          if (this._distance = c[0].dist(c[1]), this._active || !(Math.abs(wh(this._distance, this._startDistance)) < 0.1))
            return this._active = !0, { zoomDelta: wh(this._distance, _), pinchAround: d };
        }, f;
      }(ho);
      function ja(u, f) {
        return 180 * u.angleWith(f) / Math.PI;
      }
      var Nm = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.reset = function() {
          u.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector;
        }, f.prototype._start = function(c) {
          this._startVector = this._vector = c[0].sub(c[1]), this._minDiameter = c[0].dist(c[1]);
        }, f.prototype._move = function(c, d) {
          var _ = this._vector;
          if (this._vector = c[0].sub(c[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = !0, { bearingDelta: ja(this._vector, _), pinchAround: d };
        }, f.prototype._isBelowThreshold = function(c) {
          this._minDiameter = Math.min(this._minDiameter, c.mag());
          var d = 25 / (Math.PI * this._minDiameter) * 360, _ = ja(c, this._startVector);
          return Math.abs(_) < d;
        }, f;
      }(ho);
      function uc(u) {
        return Math.abs(u.y) > Math.abs(u.x);
      }
      var lp = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.reset = function() {
          u.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }, f.prototype._start = function(c) {
          this._lastPoints = c, uc(c[0].sub(c[1])) && (this._valid = !1);
        }, f.prototype._move = function(c, d, _) {
          var w = c[0].sub(this._lastPoints[0]), E = c[1].sub(this._lastPoints[1]);
          if (this._valid = this.gestureBeginsVertically(w, E, _.timeStamp), this._valid)
            return this._lastPoints = c, this._active = !0, { pitchDelta: (w.y + E.y) / 2 * -0.5 };
        }, f.prototype.gestureBeginsVertically = function(c, d, _) {
          if (this._valid !== void 0)
            return this._valid;
          var w = c.mag() >= 2, E = d.mag() >= 2;
          if (w || E) {
            if (!w || !E)
              return this._firstMove === void 0 && (this._firstMove = _), _ - this._firstMove < 100 && void 0;
            var O = c.y > 0 == d.y > 0;
            return uc(c) && uc(d) && O;
          }
        }, f;
      }(ho), up = { panStep: 100, bearingStep: 15, pitchStep: 10 }, sa = function() {
        var u = up;
        this._panStep = u.panStep, this._bearingStep = u.bearingStep, this._pitchStep = u.pitchStep, this._rotationDisabled = !1;
      };
      function Io(u) {
        return u * (2 - u);
      }
      sa.prototype.blur = function() {
        this.reset();
      }, sa.prototype.reset = function() {
        this._active = !1;
      }, sa.prototype.keydown = function(u) {
        var f = this;
        if (!(u.altKey || u.ctrlKey || u.metaKey)) {
          var c = 0, d = 0, _ = 0, w = 0, E = 0;
          switch (u.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              c = 1;
              break;
            case 189:
            case 109:
            case 173:
              c = -1;
              break;
            case 37:
              u.shiftKey ? d = -1 : (u.preventDefault(), w = -1);
              break;
            case 39:
              u.shiftKey ? d = 1 : (u.preventDefault(), w = 1);
              break;
            case 38:
              u.shiftKey ? _ = 1 : (u.preventDefault(), E = -1);
              break;
            case 40:
              u.shiftKey ? _ = -1 : (u.preventDefault(), E = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (d = 0, _ = 0), { cameraAnimation: function(O) {
            var k = O.getZoom();
            O.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Io, zoom: c ? Math.round(k) + c * (u.shiftKey ? 2 : 1) : k, bearing: O.getBearing() + d * f._bearingStep, pitch: O.getPitch() + _ * f._pitchStep, offset: [-w * f._panStep, -E * f._panStep], center: O.getCenter() }, { originalEvent: u });
          } };
        }
      }, sa.prototype.enable = function() {
        this._enabled = !0;
      }, sa.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, sa.prototype.isEnabled = function() {
        return this._enabled;
      }, sa.prototype.isActive = function() {
        return this._active;
      }, sa.prototype.disableRotation = function() {
        this._rotationDisabled = !0;
      }, sa.prototype.enableRotation = function() {
        this._rotationDisabled = !1;
      };
      var mr = function(u, f) {
        this._map = u, this._el = u.getCanvasContainer(), this._handler = f, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 1 / 450, a.bindAll(["_onTimeout"], this);
      };
      mr.prototype.setZoomRate = function(u) {
        this._defaultZoomRate = u;
      }, mr.prototype.setWheelZoomRate = function(u) {
        this._wheelZoomRate = u;
      }, mr.prototype.isEnabled = function() {
        return !!this._enabled;
      }, mr.prototype.isActive = function() {
        return !!this._active || this._finishTimeout !== void 0;
      }, mr.prototype.isZooming = function() {
        return !!this._zooming;
      }, mr.prototype.enable = function(u) {
        this.isEnabled() || (this._enabled = !0, this._aroundCenter = u && u.around === "center");
      }, mr.prototype.disable = function() {
        this.isEnabled() && (this._enabled = !1);
      }, mr.prototype.wheel = function(u) {
        if (this.isEnabled()) {
          var f = u.deltaMode === a.window.WheelEvent.DOM_DELTA_LINE ? 40 * u.deltaY : u.deltaY, c = a.browser.now(), d = c - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = c, f !== 0 && f % 4.000244140625 == 0 ? this._type = "wheel" : f !== 0 && Math.abs(f) < 4 ? this._type = "trackpad" : d > 400 ? (this._type = null, this._lastValue = f, this._timeout = setTimeout(this._onTimeout, 40, u)) : this._type || (this._type = Math.abs(d * f) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, f += this._lastValue)), u.shiftKey && f && (f /= 4), this._type && (this._lastWheelEvent = u, this._delta -= f, this._active || this._start(u)), u.preventDefault();
        }
      }, mr.prototype._onTimeout = function(u) {
        this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(u);
      }, mr.prototype._start = function(u) {
        if (this._delta) {
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          var f = g.mousePos(this._el, u);
          this._around = a.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(f)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
        }
      }, mr.prototype.renderFrame = function() {
        var u = this;
        if (this._frameId && (this._frameId = null, this.isActive())) {
          var f = this._map.transform;
          if (this._delta !== 0) {
            var c = this._type === "wheel" && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, d = 2 / (1 + Math.exp(-Math.abs(this._delta * c)));
            this._delta < 0 && d !== 0 && (d = 1 / d);
            var _ = typeof this._targetZoom == "number" ? f.zoomScale(this._targetZoom) : f.scale;
            this._targetZoom = Math.min(f.maxZoom, Math.max(f.minZoom, f.scaleZoom(_ * d))), this._type === "wheel" && (this._startZoom = f.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          var w, E = typeof this._targetZoom == "number" ? this._targetZoom : f.zoom, O = this._startZoom, k = this._easing, R = !1;
          if (this._type === "wheel" && O && k) {
            var $ = Math.min((a.browser.now() - this._lastWheelEventTime) / 200, 1), W = k($);
            w = a.number(O, E, W), $ < 1 ? this._frameId || (this._frameId = !0) : R = !0;
          } else
            w = E, R = !0;
          return this._active = !0, R && (this._active = !1, this._finishTimeout = setTimeout(function() {
            u._zooming = !1, u._handler._triggerRenderFrame(), delete u._targetZoom, delete u._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !R, zoomDelta: w - f.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
      }, mr.prototype._smoothOutEasing = function(u) {
        var f = a.ease;
        if (this._prevEase) {
          var c = this._prevEase, d = (a.browser.now() - c.start) / c.duration, _ = c.easing(d + 0.01) - c.easing(d), w = 0.27 / Math.sqrt(_ * _ + 1e-4) * 0.01, E = Math.sqrt(0.0729 - w * w);
          f = a.bezier(w, E, 0.25, 1);
        }
        return this._prevEase = { start: a.browser.now(), duration: u, easing: f }, f;
      }, mr.prototype.blur = function() {
        this.reset();
      }, mr.prototype.reset = function() {
        this._active = !1;
      };
      var ba = function(u, f) {
        this._clickZoom = u, this._tapZoom = f;
      };
      ba.prototype.enable = function() {
        this._clickZoom.enable(), this._tapZoom.enable();
      }, ba.prototype.disable = function() {
        this._clickZoom.disable(), this._tapZoom.disable();
      }, ba.prototype.isEnabled = function() {
        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
      }, ba.prototype.isActive = function() {
        return this._clickZoom.isActive() || this._tapZoom.isActive();
      };
      var Wo = function() {
        this.reset();
      };
      Wo.prototype.reset = function() {
        this._active = !1;
      }, Wo.prototype.blur = function() {
        this.reset();
      }, Wo.prototype.dblclick = function(u, f) {
        return u.preventDefault(), { cameraAnimation: function(c) {
          c.easeTo({ duration: 300, zoom: c.getZoom() + (u.shiftKey ? -1 : 1), around: c.unproject(f) }, { originalEvent: u });
        } };
      }, Wo.prototype.enable = function() {
        this._enabled = !0;
      }, Wo.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, Wo.prototype.isEnabled = function() {
        return this._enabled;
      }, Wo.prototype.isActive = function() {
        return this._active;
      };
      var Mi = function() {
        this._tap = new aa({ numTouches: 1, numTaps: 1 }), this.reset();
      };
      Mi.prototype.reset = function() {
        this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
      }, Mi.prototype.touchstart = function(u, f, c) {
        this._swipePoint || (this._tapTime && u.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? c.length > 0 && (this._swipePoint = f[0], this._swipeTouch = c[0].identifier) : this._tap.touchstart(u, f, c));
      }, Mi.prototype.touchmove = function(u, f, c) {
        if (this._tapTime) {
          if (this._swipePoint) {
            if (c[0].identifier !== this._swipeTouch)
              return;
            var d = f[0], _ = d.y - this._swipePoint.y;
            return this._swipePoint = d, u.preventDefault(), this._active = !0, { zoomDelta: _ / 128 };
          }
        } else
          this._tap.touchmove(u, f, c);
      }, Mi.prototype.touchend = function(u, f, c) {
        this._tapTime ? this._swipePoint && c.length === 0 && this.reset() : this._tap.touchend(u, f, c) && (this._tapTime = u.timeStamp);
      }, Mi.prototype.touchcancel = function() {
        this.reset();
      }, Mi.prototype.enable = function() {
        this._enabled = !0;
      }, Mi.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, Mi.prototype.isEnabled = function() {
        return this._enabled;
      }, Mi.prototype.isActive = function() {
        return this._active;
      };
      var xl = function(u, f, c) {
        this._el = u, this._mousePan = f, this._touchPan = c;
      };
      xl.prototype.enable = function(u) {
        this._inertiaOptions = u || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
      }, xl.prototype.disable = function() {
        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
      }, xl.prototype.isEnabled = function() {
        return this._mousePan.isEnabled() && this._touchPan.isEnabled();
      }, xl.prototype.isActive = function() {
        return this._mousePan.isActive() || this._touchPan.isActive();
      };
      var Ss = function(u, f, c) {
        this._pitchWithRotate = u.pitchWithRotate, this._mouseRotate = f, this._mousePitch = c;
      };
      Ss.prototype.enable = function() {
        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
      }, Ss.prototype.disable = function() {
        this._mouseRotate.disable(), this._mousePitch.disable();
      }, Ss.prototype.isEnabled = function() {
        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
      }, Ss.prototype.isActive = function() {
        return this._mouseRotate.isActive() || this._mousePitch.isActive();
      };
      var la = function(u, f, c, d) {
        this._el = u, this._touchZoom = f, this._touchRotate = c, this._tapDragZoom = d, this._rotationDisabled = !1, this._enabled = !0;
      };
      la.prototype.enable = function(u) {
        this._touchZoom.enable(u), this._rotationDisabled || this._touchRotate.enable(u), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
      }, la.prototype.disable = function() {
        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
      }, la.prototype.isEnabled = function() {
        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
      }, la.prototype.isActive = function() {
        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
      }, la.prototype.disableRotation = function() {
        this._rotationDisabled = !0, this._touchRotate.disable();
      }, la.prototype.enableRotation = function() {
        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
      };
      var ji = function(u) {
        return u.zoom || u.drag || u.pitch || u.rotate;
      }, cc = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f;
      }(a.Event);
      function Lt(u) {
        return u.panDelta && u.panDelta.mag() || u.zoomDelta || u.bearingDelta || u.pitchDelta;
      }
      var Tt = function(u, f) {
        this._map = u, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ac(u), this._bearingSnap = f.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(f), a.bindAll(["handleEvent", "handleWindowEvent"], this);
        var c = this._el;
        this._listeners = [[c, "touchstart", { passive: !0 }], [c, "touchmove", { passive: !1 }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [a.window.document, "mousemove", { capture: !0 }], [a.window.document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: !1 }], [c, "keyup", void 0], [c, "wheel", { passive: !1 }], [c, "contextmenu", void 0], [a.window, "blur", void 0]];
        for (var d = 0, _ = this._listeners; d < _.length; d += 1) {
          var w = _[d], E = w[0];
          g.addEventListener(E, w[1], E === a.window.document ? this.handleWindowEvent : this.handleEvent, w[2]);
        }
      };
      Tt.prototype.destroy = function() {
        for (var u = 0, f = this._listeners; u < f.length; u += 1) {
          var c = f[u], d = c[0];
          g.removeEventListener(d, c[1], d === a.window.document ? this.handleWindowEvent : this.handleEvent, c[2]);
        }
      }, Tt.prototype._addDefaultHandlers = function(u) {
        var f = this._map, c = f.getCanvasContainer();
        this._add("mapEvent", new Gn(f, u));
        var d = f.boxZoom = new uo(f, u);
        this._add("boxZoom", d);
        var _ = new co(), w = new Wo();
        f.doubleClickZoom = new ba(w, _), this._add("tapZoom", _), this._add("clickZoom", w);
        var E = new Mi();
        this._add("tapDragZoom", E);
        var O = f.touchPitch = new lp();
        this._add("touchPitch", O);
        var k = new xh(u), R = new sp(u);
        f.dragRotate = new Ss(u, k, R), this._add("mouseRotate", k, ["mousePitch"]), this._add("mousePitch", R, ["mouseRotate"]);
        var $ = new ap(u), W = new qo(u);
        f.dragPan = new xl(c, $, W), this._add("mousePan", $), this._add("touchPan", W, ["touchZoom", "touchRotate"]);
        var H = new Nm(), ne = new fo();
        f.touchZoomRotate = new la(c, ne, H, E), this._add("touchRotate", H, ["touchPan", "touchZoom"]), this._add("touchZoom", ne, ["touchPan", "touchRotate"]);
        var te = f.scrollZoom = new mr(f, this);
        this._add("scrollZoom", te, ["mousePan"]);
        var ue = f.keyboard = new sa();
        this._add("keyboard", ue), this._add("blockableMapEvent", new wt(f));
        for (var Y = 0, le = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; Y < le.length; Y += 1) {
          var me = le[Y];
          u.interactive && u[me] && f[me].enable(u[me]);
        }
      }, Tt.prototype._add = function(u, f, c) {
        this._handlers.push({ handlerName: u, handler: f, allowed: c }), this._handlersById[u] = f;
      }, Tt.prototype.stop = function(u) {
        if (!this._updatingCamera) {
          for (var f = 0, c = this._handlers; f < c.length; f += 1)
            c[f].handler.reset();
          this._inertia.clear(), this._fireEvents({}, {}, u), this._changes = [];
        }
      }, Tt.prototype.isActive = function() {
        for (var u = 0, f = this._handlers; u < f.length; u += 1)
          if (f[u].handler.isActive())
            return !0;
        return !1;
      }, Tt.prototype.isZooming = function() {
        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
      }, Tt.prototype.isRotating = function() {
        return !!this._eventsInProgress.rotate;
      }, Tt.prototype.isMoving = function() {
        return Boolean(ji(this._eventsInProgress)) || this.isZooming();
      }, Tt.prototype._blockedByActive = function(u, f, c) {
        for (var d in u)
          if (d !== c && (!f || f.indexOf(d) < 0))
            return !0;
        return !1;
      }, Tt.prototype.handleWindowEvent = function(u) {
        this.handleEvent(u, u.type + "Window");
      }, Tt.prototype._getMapTouches = function(u) {
        for (var f = [], c = 0, d = u; c < d.length; c += 1) {
          var _ = d[c];
          this._el.contains(_.target) && f.push(_);
        }
        return f;
      }, Tt.prototype.handleEvent = function(u, f) {
        this._updatingCamera = !0;
        for (var c = u.type === "renderFrame" ? void 0 : u, d = { needsRenderFrame: !1 }, _ = {}, w = {}, E = u.touches ? this._getMapTouches(u.touches) : void 0, O = E ? g.touchPos(this._el, E) : g.mousePos(this._el, u), k = 0, R = this._handlers; k < R.length; k += 1) {
          var $ = R[k], W = $.handlerName, H = $.handler, ne = $.allowed;
          if (H.isEnabled()) {
            var te = void 0;
            this._blockedByActive(w, ne, W) ? H.reset() : H[f || u.type] && (te = H[f || u.type](u, O, E), this.mergeHandlerResult(d, _, te, W, c), te && te.needsRenderFrame && this._triggerRenderFrame()), (te || H.isActive()) && (w[W] = H);
          }
        }
        var ue = {};
        for (var Y in this._previousActiveHandlers)
          w[Y] || (ue[Y] = c);
        this._previousActiveHandlers = w, (Object.keys(ue).length || Lt(d)) && (this._changes.push([d, _, ue]), this._triggerRenderFrame()), (Object.keys(w).length || Lt(d)) && this._map._stop(!0), this._updatingCamera = !1;
        var le = d.cameraAnimation;
        le && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], le(this._map));
      }, Tt.prototype.mergeHandlerResult = function(u, f, c, d, _) {
        if (c) {
          a.extend(u, c);
          var w = { handlerName: d, originalEvent: c.originalEvent || _ };
          c.zoomDelta !== void 0 && (f.zoom = w), c.panDelta !== void 0 && (f.drag = w), c.pitchDelta !== void 0 && (f.pitch = w), c.bearingDelta !== void 0 && (f.rotate = w);
        }
      }, Tt.prototype._applyChanges = function() {
        for (var u = {}, f = {}, c = {}, d = 0, _ = this._changes; d < _.length; d += 1) {
          var w = _[d], E = w[0], O = w[1], k = w[2];
          E.panDelta && (u.panDelta = (u.panDelta || new a.Point(0, 0))._add(E.panDelta)), E.zoomDelta && (u.zoomDelta = (u.zoomDelta || 0) + E.zoomDelta), E.bearingDelta && (u.bearingDelta = (u.bearingDelta || 0) + E.bearingDelta), E.pitchDelta && (u.pitchDelta = (u.pitchDelta || 0) + E.pitchDelta), E.around !== void 0 && (u.around = E.around), E.pinchAround !== void 0 && (u.pinchAround = E.pinchAround), E.noInertia && (u.noInertia = E.noInertia), a.extend(f, O), a.extend(c, k);
        }
        this._updateMapTransform(u, f, c), this._changes = [];
      }, Tt.prototype._updateMapTransform = function(u, f, c) {
        var d = this._map, _ = d.transform;
        if (!Lt(u))
          return this._fireEvents(f, c, !0);
        var w = u.panDelta, E = u.zoomDelta, O = u.bearingDelta, k = u.pitchDelta, R = u.around, $ = u.pinchAround;
        $ !== void 0 && (R = $), d._stop(!0), R = R || d.transform.centerPoint;
        var W = _.pointLocation(w ? R.sub(w) : R);
        O && (_.bearing += O), k && (_.pitch += k), E && (_.zoom += E), _.setLocationAtPoint(W, R), this._map._update(), u.noInertia || this._inertia.record(u), this._fireEvents(f, c, !0);
      }, Tt.prototype._fireEvents = function(u, f, c) {
        var d = this, _ = ji(this._eventsInProgress), w = ji(u), E = {};
        for (var O in u)
          this._eventsInProgress[O] || (E[O + "start"] = u[O].originalEvent), this._eventsInProgress[O] = u[O];
        for (var k in !_ && w && this._fireEvent("movestart", w.originalEvent), E)
          this._fireEvent(k, E[k]);
        for (var R in w && this._fireEvent("move", w.originalEvent), u)
          this._fireEvent(R, u[R].originalEvent);
        var $, W = {};
        for (var H in this._eventsInProgress) {
          var ne = this._eventsInProgress[H], te = ne.handlerName, ue = ne.originalEvent;
          this._handlersById[te].isActive() || (delete this._eventsInProgress[H], W[H + "end"] = $ = f[te] || ue);
        }
        for (var Y in W)
          this._fireEvent(Y, W[Y]);
        var le = ji(this._eventsInProgress);
        if (c && (_ || w) && !le) {
          this._updatingCamera = !0;
          var me = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), xe = function(Ae) {
            return Ae !== 0 && -d._bearingSnap < Ae && Ae < d._bearingSnap;
          };
          me ? (xe(me.bearing || this._map.getBearing()) && (me.bearing = 0), this._map.easeTo(me, { originalEvent: $ })) : (this._map.fire(new a.Event("moveend", { originalEvent: $ })), xe(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
        }
      }, Tt.prototype._fireEvent = function(u, f) {
        this._map.fire(new a.Event(u, f ? { originalEvent: f } : {}));
      }, Tt.prototype._requestFrame = function() {
        var u = this;
        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(function(f) {
          delete u._frameId, u.handleEvent(new cc("renderFrame", { timeStamp: f })), u._applyChanges();
        });
      }, Tt.prototype._triggerRenderFrame = function() {
        this._frameId === void 0 && (this._frameId = this._requestFrame());
      };
      var Eh = function(u) {
        function f(c, d) {
          u.call(this), this._moving = !1, this._zooming = !1, this.transform = c, this._bearingSnap = d.bearingSnap, a.bindAll(["_renderFrameCallback"], this);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getCenter = function() {
          return new a.LngLat(this.transform.center.lng, this.transform.center.lat);
        }, f.prototype.setCenter = function(c, d) {
          return this.jumpTo({ center: c }, d);
        }, f.prototype.panBy = function(c, d, _) {
          return c = a.Point.convert(c).mult(-1), this.panTo(this.transform.center, a.extend({ offset: c }, d), _);
        }, f.prototype.panTo = function(c, d, _) {
          return this.easeTo(a.extend({ center: c }, d), _);
        }, f.prototype.getZoom = function() {
          return this.transform.zoom;
        }, f.prototype.setZoom = function(c, d) {
          return this.jumpTo({ zoom: c }, d), this;
        }, f.prototype.zoomTo = function(c, d, _) {
          return this.easeTo(a.extend({ zoom: c }, d), _);
        }, f.prototype.zoomIn = function(c, d) {
          return this.zoomTo(this.getZoom() + 1, c, d), this;
        }, f.prototype.zoomOut = function(c, d) {
          return this.zoomTo(this.getZoom() - 1, c, d), this;
        }, f.prototype.getBearing = function() {
          return this.transform.bearing;
        }, f.prototype.setBearing = function(c, d) {
          return this.jumpTo({ bearing: c }, d), this;
        }, f.prototype.getPadding = function() {
          return this.transform.padding;
        }, f.prototype.setPadding = function(c, d) {
          return this.jumpTo({ padding: c }, d), this;
        }, f.prototype.rotateTo = function(c, d, _) {
          return this.easeTo(a.extend({ bearing: c }, d), _);
        }, f.prototype.resetNorth = function(c, d) {
          return this.rotateTo(0, a.extend({ duration: 1e3 }, c), d), this;
        }, f.prototype.resetNorthPitch = function(c, d) {
          return this.easeTo(a.extend({ bearing: 0, pitch: 0, duration: 1e3 }, c), d), this;
        }, f.prototype.snapToNorth = function(c, d) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(c, d) : this;
        }, f.prototype.getPitch = function() {
          return this.transform.pitch;
        }, f.prototype.setPitch = function(c, d) {
          return this.jumpTo({ pitch: c }, d), this;
        }, f.prototype.cameraForBounds = function(c, d) {
          c = a.LngLatBounds.convert(c);
          var _ = d && d.bearing || 0;
          return this._cameraForBoxAndBearing(c.getNorthWest(), c.getSouthEast(), _, d);
        }, f.prototype._cameraForBoxAndBearing = function(c, d, _, w) {
          var E = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (w = a.extend({ padding: E, offset: [0, 0], maxZoom: this.transform.maxZoom }, w)).padding == "number") {
            var O = w.padding;
            w.padding = { top: O, bottom: O, right: O, left: O };
          }
          w.padding = a.extend(E, w.padding);
          var k = this.transform, R = k.padding, $ = k.project(a.LngLat.convert(c)), W = k.project(a.LngLat.convert(d)), H = $.rotate(-_ * Math.PI / 180), ne = W.rotate(-_ * Math.PI / 180), te = new a.Point(Math.max(H.x, ne.x), Math.max(H.y, ne.y)), ue = new a.Point(Math.min(H.x, ne.x), Math.min(H.y, ne.y)), Y = te.sub(ue), le = (k.width - (R.left + R.right + w.padding.left + w.padding.right)) / Y.x, me = (k.height - (R.top + R.bottom + w.padding.top + w.padding.bottom)) / Y.y;
          if (!(me < 0 || le < 0)) {
            var xe = Math.min(k.scaleZoom(k.scale * Math.min(le, me)), w.maxZoom), Ae = typeof w.offset.x == "number" ? new a.Point(w.offset.x, w.offset.y) : a.Point.convert(w.offset), Me = new a.Point((w.padding.left - w.padding.right) / 2, (w.padding.top - w.padding.bottom) / 2).rotate(_ * Math.PI / 180), ke = Ae.add(Me).mult(k.scale / k.zoomScale(xe));
            return { center: k.unproject($.add(W).div(2).sub(ke)), zoom: xe, bearing: _ };
          }
          a.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }, f.prototype.fitBounds = function(c, d, _) {
          return this._fitInternal(this.cameraForBounds(c, d), d, _);
        }, f.prototype.fitScreenCoordinates = function(c, d, _, w, E) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(a.Point.convert(c)), this.transform.pointLocation(a.Point.convert(d)), _, w), w, E);
        }, f.prototype._fitInternal = function(c, d, _) {
          return c ? (delete (d = a.extend(c, d)).padding, d.linear ? this.easeTo(d, _) : this.flyTo(d, _)) : this;
        }, f.prototype.jumpTo = function(c, d) {
          this.stop();
          var _ = this.transform, w = !1, E = !1, O = !1;
          return "zoom" in c && _.zoom !== +c.zoom && (w = !0, _.zoom = +c.zoom), c.center !== void 0 && (_.center = a.LngLat.convert(c.center)), "bearing" in c && _.bearing !== +c.bearing && (E = !0, _.bearing = +c.bearing), "pitch" in c && _.pitch !== +c.pitch && (O = !0, _.pitch = +c.pitch), c.padding == null || _.isPaddingEqual(c.padding) || (_.padding = c.padding), this.fire(new a.Event("movestart", d)).fire(new a.Event("move", d)), w && this.fire(new a.Event("zoomstart", d)).fire(new a.Event("zoom", d)).fire(new a.Event("zoomend", d)), E && this.fire(new a.Event("rotatestart", d)).fire(new a.Event("rotate", d)).fire(new a.Event("rotateend", d)), O && this.fire(new a.Event("pitchstart", d)).fire(new a.Event("pitch", d)).fire(new a.Event("pitchend", d)), this.fire(new a.Event("moveend", d));
        }, f.prototype.easeTo = function(c, d) {
          var _ = this;
          this._stop(!1, c.easeId), ((c = a.extend({ offset: [0, 0], duration: 500, easing: a.ease }, c)).animate === !1 || !c.essential && a.browser.prefersReducedMotion) && (c.duration = 0);
          var w = this.transform, E = this.getZoom(), O = this.getBearing(), k = this.getPitch(), R = this.getPadding(), $ = "zoom" in c ? +c.zoom : E, W = "bearing" in c ? this._normalizeBearing(c.bearing, O) : O, H = "pitch" in c ? +c.pitch : k, ne = "padding" in c ? c.padding : w.padding, te = a.Point.convert(c.offset), ue = w.centerPoint.add(te), Y = w.pointLocation(ue), le = a.LngLat.convert(c.center || Y);
          this._normalizeCenter(le);
          var me, xe, Ae = w.project(Y), Me = w.project(le).sub(Ae), ke = w.zoomScale($ - E);
          c.around && (me = a.LngLat.convert(c.around), xe = w.locationPoint(me));
          var je = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || $ !== E, this._rotating = this._rotating || O !== W, this._pitching = this._pitching || H !== k, this._padding = !w.isPaddingEqual(ne), this._easeId = c.easeId, this._prepareEase(d, c.noMoveStart, je), this._ease(function(nt) {
            if (_._zooming && (w.zoom = a.number(E, $, nt)), _._rotating && (w.bearing = a.number(O, W, nt)), _._pitching && (w.pitch = a.number(k, H, nt)), _._padding && (w.interpolatePadding(R, ne, nt), ue = w.centerPoint.add(te)), me)
              w.setLocationAtPoint(me, xe);
            else {
              var tt = w.zoomScale(w.zoom - E), gt = $ > E ? Math.min(2, ke) : Math.max(0.5, ke), Dt = Math.pow(gt, 1 - nt), Bt = w.unproject(Ae.add(Me.mult(nt * Dt)).mult(tt));
              w.setLocationAtPoint(w.renderWorldCopies ? Bt.wrap() : Bt, ue);
            }
            _._fireMoveEvents(d);
          }, function(nt) {
            _._afterEase(d, nt);
          }, c), this;
        }, f.prototype._prepareEase = function(c, d, _) {
          _ === void 0 && (_ = {}), this._moving = !0, d || _.moving || this.fire(new a.Event("movestart", c)), this._zooming && !_.zooming && this.fire(new a.Event("zoomstart", c)), this._rotating && !_.rotating && this.fire(new a.Event("rotatestart", c)), this._pitching && !_.pitching && this.fire(new a.Event("pitchstart", c));
        }, f.prototype._fireMoveEvents = function(c) {
          this.fire(new a.Event("move", c)), this._zooming && this.fire(new a.Event("zoom", c)), this._rotating && this.fire(new a.Event("rotate", c)), this._pitching && this.fire(new a.Event("pitch", c));
        }, f.prototype._afterEase = function(c, d) {
          if (!this._easeId || !d || this._easeId !== d) {
            delete this._easeId;
            var _ = this._zooming, w = this._rotating, E = this._pitching;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, _ && this.fire(new a.Event("zoomend", c)), w && this.fire(new a.Event("rotateend", c)), E && this.fire(new a.Event("pitchend", c)), this.fire(new a.Event("moveend", c));
          }
        }, f.prototype.flyTo = function(c, d) {
          var _ = this;
          if (!c.essential && a.browser.prefersReducedMotion) {
            var w = a.pick(c, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(w, d);
          }
          this.stop(), c = a.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: a.ease }, c);
          var E = this.transform, O = this.getZoom(), k = this.getBearing(), R = this.getPitch(), $ = this.getPadding(), W = "zoom" in c ? a.clamp(+c.zoom, E.minZoom, E.maxZoom) : O, H = "bearing" in c ? this._normalizeBearing(c.bearing, k) : k, ne = "pitch" in c ? +c.pitch : R, te = "padding" in c ? c.padding : E.padding, ue = E.zoomScale(W - O), Y = a.Point.convert(c.offset), le = E.centerPoint.add(Y), me = E.pointLocation(le), xe = a.LngLat.convert(c.center || me);
          this._normalizeCenter(xe);
          var Ae = E.project(me), Me = E.project(xe).sub(Ae), ke = c.curve, je = Math.max(E.width, E.height), nt = je / ue, tt = Me.mag();
          if ("minZoom" in c) {
            var gt = a.clamp(Math.min(c.minZoom, O, W), E.minZoom, E.maxZoom), Dt = je / E.zoomScale(gt - O);
            ke = Math.sqrt(Dt / tt * 2);
          }
          var Bt = ke * ke;
          function zt(Ht) {
            var $t = (nt * nt - je * je + (Ht ? -1 : 1) * Bt * Bt * tt * tt) / (2 * (Ht ? nt : je) * Bt * tt);
            return Math.log(Math.sqrt($t * $t + 1) - $t);
          }
          function Ir(Ht) {
            return (Math.exp(Ht) - Math.exp(-Ht)) / 2;
          }
          function xt(Ht) {
            return (Math.exp(Ht) + Math.exp(-Ht)) / 2;
          }
          var Yt = zt(0), ir = function(Ht) {
            return xt(Yt) / xt(Yt + ke * Ht);
          }, Kt = function(Ht) {
            return je * ((xt(Yt) * (Ir($t = Yt + ke * Ht) / xt($t)) - Ir(Yt)) / Bt) / tt;
            var $t;
          }, Xt = (zt(1) - Yt) / ke;
          if (Math.abs(tt) < 1e-6 || !isFinite(Xt)) {
            if (Math.abs(je - nt) < 1e-6)
              return this.easeTo(c, d);
            var nr = nt < je ? -1 : 1;
            Xt = Math.abs(Math.log(nt / je)) / ke, Kt = function() {
              return 0;
            }, ir = function(Ht) {
              return Math.exp(nr * ke * Ht);
            };
          }
          return c.duration = "duration" in c ? +c.duration : 1e3 * Xt / ("screenSpeed" in c ? +c.screenSpeed / ke : +c.speed), c.maxDuration && c.duration > c.maxDuration && (c.duration = 0), this._zooming = !0, this._rotating = k !== H, this._pitching = ne !== R, this._padding = !E.isPaddingEqual(te), this._prepareEase(d, !1), this._ease(function(Ht) {
            var $t = Ht * Xt, si = 1 / ir($t);
            E.zoom = Ht === 1 ? W : O + E.scaleZoom(si), _._rotating && (E.bearing = a.number(k, H, Ht)), _._pitching && (E.pitch = a.number(R, ne, Ht)), _._padding && (E.interpolatePadding($, te, Ht), le = E.centerPoint.add(Y));
            var On = Ht === 1 ? xe : E.unproject(Ae.add(Me.mult(Kt($t))).mult(si));
            E.setLocationAtPoint(E.renderWorldCopies ? On.wrap() : On, le), _._fireMoveEvents(d);
          }, function() {
            return _._afterEase(d);
          }, c), this;
        }, f.prototype.isEasing = function() {
          return !!this._easeFrameId;
        }, f.prototype.stop = function() {
          return this._stop();
        }, f.prototype._stop = function(c, d) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            var _ = this._onEaseEnd;
            delete this._onEaseEnd, _.call(this, d);
          }
          if (!c) {
            var w = this.handlers;
            w && w.stop(!1);
          }
          return this;
        }, f.prototype._ease = function(c, d, _) {
          _.animate === !1 || _.duration === 0 ? (c(1), d()) : (this._easeStart = a.browser.now(), this._easeOptions = _, this._onEaseFrame = c, this._onEaseEnd = d, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }, f.prototype._renderFrameCallback = function() {
          var c = Math.min((a.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
          this._onEaseFrame(this._easeOptions.easing(c)), c < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }, f.prototype._normalizeBearing = function(c, d) {
          c = a.wrap(c, -180, 180);
          var _ = Math.abs(c - d);
          return Math.abs(c - 360 - d) < _ && (c -= 360), Math.abs(c + 360 - d) < _ && (c += 360), c;
        }, f.prototype._normalizeCenter = function(c) {
          var d = this.transform;
          if (d.renderWorldCopies && !d.lngRange) {
            var _ = c.lng - d.center.lng;
            c.lng += _ > 180 ? -360 : _ < -180 ? 360 : 0;
          }
        }, f;
      }(a.Evented), Gi = function(u) {
        u === void 0 && (u = {}), this.options = u, a.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
      };
      Gi.prototype.getDefaultPosition = function() {
        return "bottom-right";
      }, Gi.prototype.onAdd = function(u) {
        var f = this.options && this.options.compact;
        return this._map = u, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = g.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = g.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), f && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), f === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
      }, Gi.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
      }, Gi.prototype._setElementTitle = function(u, f) {
        var c = this._map._getUIString("AttributionControl." + f);
        u.title = c, u.setAttribute("aria-label", c);
      }, Gi.prototype._toggleAttribution = function() {
        this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));
      }, Gi.prototype._updateEditLink = function() {
        var u = this._editLink;
        u || (u = this._editLink = this._container.querySelector(".mapbox-improve-map"));
        var f = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || a.config.ACCESS_TOKEN }];
        if (u) {
          var c = f.reduce(function(d, _, w) {
            return _.value && (d += _.key + "=" + _.value + (w < f.length - 1 ? "&" : "")), d;
          }, "?");
          u.href = a.config.FEEDBACK_URL + "/" + c + (this._map._hash ? this._map._hash.getHashString(!0) : ""), u.rel = "noopener nofollow", this._setElementTitle(u, "MapFeedback");
        }
      }, Gi.prototype._updateData = function(u) {
        !u || u.sourceDataType !== "metadata" && u.sourceDataType !== "visibility" && u.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
      }, Gi.prototype._updateAttributions = function() {
        if (this._map.style) {
          var u = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? u = u.concat(this.options.customAttribution.map(function(O) {
            return typeof O != "string" ? "" : O;
          })) : typeof this.options.customAttribution == "string" && u.push(this.options.customAttribution)), this._map.style.stylesheet) {
            var f = this._map.style.stylesheet;
            this.styleOwner = f.owner, this.styleId = f.id;
          }
          var c = this._map.style.sourceCaches;
          for (var d in c) {
            var _ = c[d];
            if (_.used) {
              var w = _.getSource();
              w.attribution && u.indexOf(w.attribution) < 0 && u.push(w.attribution);
            }
          }
          u.sort(function(O, k) {
            return O.length - k.length;
          });
          var E = (u = u.filter(function(O, k) {
            for (var R = k + 1; R < u.length; R++)
              if (u[R].indexOf(O) >= 0)
                return !1;
            return !0;
          })).join(" | ");
          E !== this._attribHTML && (this._attribHTML = E, u.length ? (this._innerContainer.innerHTML = E, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
      }, Gi.prototype._updateCompact = function() {
        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
      };
      var ua = function() {
        a.bindAll(["_updateLogo"], this), a.bindAll(["_updateCompact"], this);
      };
      ua.prototype.onAdd = function(u) {
        this._map = u, this._container = g.create("div", "mapboxgl-ctrl");
        var f = g.create("a", "mapboxgl-ctrl-logo");
        return f.target = "_blank", f.rel = "noopener nofollow", f.href = "https://www.mapbox.com/", f.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), f.setAttribute("rel", "noopener nofollow"), this._container.appendChild(f), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
      }, ua.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
      }, ua.prototype.getDefaultPosition = function() {
        return "bottom-left";
      }, ua.prototype._updateLogo = function(u) {
        u && u.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
      }, ua.prototype._logoRequired = function() {
        if (this._map.style) {
          var u = this._map.style.sourceCaches;
          for (var f in u)
            if (u[f].getSource().mapbox_logo)
              return !0;
          return !1;
        }
      }, ua.prototype._updateCompact = function() {
        var u = this._container.children;
        if (u.length) {
          var f = u[0];
          this._map.getCanvasContainer().offsetWidth < 250 ? f.classList.add("mapboxgl-compact") : f.classList.remove("mapboxgl-compact");
        }
      };
      var Ii = function() {
        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
      };
      Ii.prototype.add = function(u) {
        var f = ++this._id;
        return this._queue.push({ callback: u, id: f, cancelled: !1 }), f;
      }, Ii.prototype.remove = function(u) {
        for (var f = this._currentlyRunning, c = 0, d = f ? this._queue.concat(f) : this._queue; c < d.length; c += 1) {
          var _ = d[c];
          if (_.id === u)
            return void (_.cancelled = !0);
        }
      }, Ii.prototype.run = function(u) {
        u === void 0 && (u = 0);
        var f = this._currentlyRunning = this._queue;
        this._queue = [];
        for (var c = 0, d = f; c < d.length; c += 1) {
          var _ = d[c];
          if (!_.cancelled && (_.callback(u), this._cleared))
            break;
        }
        this._cleared = !1, this._currentlyRunning = !1;
      }, Ii.prototype.clear = function() {
        this._currentlyRunning && (this._cleared = !0), this._queue = [];
      };
      var wa = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, cp = a.window.HTMLImageElement, Sh = a.window.HTMLElement, Gr = a.window.ImageBitmap, yi = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: !0 }, Rm = function(u) {
        function f(d) {
          var _ = this;
          if ((d = a.extend({}, yi, d)).minZoom != null && d.maxZoom != null && d.minZoom > d.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (d.minPitch != null && d.maxPitch != null && d.minPitch > d.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (d.minPitch != null && d.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (d.maxPitch != null && d.maxPitch > 60)
            throw new Error("maxPitch must be less than or equal to 60");
          var w = new wr(d.minZoom, d.maxZoom, d.minPitch, d.maxPitch, d.renderWorldCopies);
          if (u.call(this, w, d), this._interactive = d.interactive, this._maxTileCacheSize = d.maxTileCacheSize, this._failIfMajorPerformanceCaveat = d.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = d.preserveDrawingBuffer, this._antialias = d.antialias, this._trackResize = d.trackResize, this._bearingSnap = d.bearingSnap, this._refreshExpiredTiles = d.refreshExpiredTiles, this._fadeDuration = d.fadeDuration, this._crossSourceCollisions = d.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = d.collectResourceTiming, this._renderTaskQueue = new Ii(), this._controls = [], this._mapId = a.uniqueId(), this._locale = a.extend({}, wa, d.locale), this._clickTolerance = d.clickTolerance, this._requestManager = new a.RequestManager(d.transformRequest, d.accessToken), typeof d.container == "string") {
            if (this._container = a.window.document.getElementById(d.container), !this._container)
              throw new Error("Container '" + d.container + "' not found.");
          } else {
            if (!(d.container instanceof Sh))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = d.container;
          }
          if (d.maxBounds && this.setMaxBounds(d.maxBounds), a.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)
            throw new Error("Failed to initialize WebGL.");
          this.on("move", function() {
            return _._update(!1);
          }), this.on("moveend", function() {
            return _._update(!1);
          }), this.on("zoom", function() {
            return _._update(!0);
          }), a.window !== void 0 && (a.window.addEventListener("online", this._onWindowOnline, !1), a.window.addEventListener("resize", this._onWindowResize, !1), a.window.addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new Tt(this, d), this._hash = d.hash && new Mo(typeof d.hash == "string" && d.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: d.center, zoom: d.zoom, bearing: d.bearing, pitch: d.pitch }), d.bounds && (this.resize(), this.fitBounds(d.bounds, a.extend({}, d.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = d.localIdeographFontFamily, d.style && this.setStyle(d.style, { localIdeographFontFamily: d.localIdeographFontFamily }), d.attributionControl && this.addControl(new Gi({ customAttribution: d.customAttribution })), this.addControl(new ua(), d.logoPosition), this.on("style.load", function() {
            _.transform.unmodified && _.jumpTo(_.style.stylesheet);
          }), this.on("data", function(E) {
            _._update(E.dataType === "style"), _.fire(new a.Event(E.dataType + "data", E));
          }), this.on("dataloading", function(E) {
            _.fire(new a.Event(E.dataType + "dataloading", E));
          });
        }
        u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f;
        var c = { showTileBoundaries: { configurable: !0 }, showPadding: { configurable: !0 }, showCollisionBoxes: { configurable: !0 }, showOverdrawInspector: { configurable: !0 }, repaint: { configurable: !0 }, vertices: { configurable: !0 }, version: { configurable: !0 } };
        return f.prototype._getMapId = function() {
          return this._mapId;
        }, f.prototype.addControl = function(d, _) {
          if (_ === void 0 && (_ = d.getDefaultPosition ? d.getDefaultPosition() : "top-right"), !d || !d.onAdd)
            return this.fire(new a.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          var w = d.onAdd(this);
          this._controls.push(d);
          var E = this._controlPositions[_];
          return _.indexOf("bottom") !== -1 ? E.insertBefore(w, E.firstChild) : E.appendChild(w), this;
        }, f.prototype.removeControl = function(d) {
          if (!d || !d.onRemove)
            return this.fire(new a.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          var _ = this._controls.indexOf(d);
          return _ > -1 && this._controls.splice(_, 1), d.onRemove(this), this;
        }, f.prototype.hasControl = function(d) {
          return this._controls.indexOf(d) > -1;
        }, f.prototype.resize = function(d) {
          var _ = this._containerDimensions(), w = _[0], E = _[1];
          if (w === this.transform.width && E === this.transform.height)
            return this;
          this._resizeCanvas(w, E), this.transform.resize(w, E), this.painter.resize(w, E);
          var O = !this._moving;
          return O && this.fire(new a.Event("movestart", d)).fire(new a.Event("move", d)), this.fire(new a.Event("resize", d)), O && this.fire(new a.Event("moveend", d)), this;
        }, f.prototype.getBounds = function() {
          return this.transform.getBounds();
        }, f.prototype.getMaxBounds = function() {
          return this.transform.getMaxBounds();
        }, f.prototype.setMaxBounds = function(d) {
          return this.transform.setMaxBounds(a.LngLatBounds.convert(d)), this._update();
        }, f.prototype.setMinZoom = function(d) {
          if ((d = d == null ? -2 : d) >= -2 && d <= this.transform.maxZoom)
            return this.transform.minZoom = d, this._update(), this.getZoom() < d && this.setZoom(d), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }, f.prototype.getMinZoom = function() {
          return this.transform.minZoom;
        }, f.prototype.setMaxZoom = function(d) {
          if ((d = d == null ? 22 : d) >= this.transform.minZoom)
            return this.transform.maxZoom = d, this._update(), this.getZoom() > d && this.setZoom(d), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }, f.prototype.getMaxZoom = function() {
          return this.transform.maxZoom;
        }, f.prototype.setMinPitch = function(d) {
          if ((d = d == null ? 0 : d) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (d >= 0 && d <= this.transform.maxPitch)
            return this.transform.minPitch = d, this._update(), this.getPitch() < d && this.setPitch(d), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }, f.prototype.getMinPitch = function() {
          return this.transform.minPitch;
        }, f.prototype.setMaxPitch = function(d) {
          if ((d = d == null ? 60 : d) > 60)
            throw new Error("maxPitch must be less than or equal to 60");
          if (d >= this.transform.minPitch)
            return this.transform.maxPitch = d, this._update(), this.getPitch() > d && this.setPitch(d), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }, f.prototype.getMaxPitch = function() {
          return this.transform.maxPitch;
        }, f.prototype.getRenderWorldCopies = function() {
          return this.transform.renderWorldCopies;
        }, f.prototype.setRenderWorldCopies = function(d) {
          return this.transform.renderWorldCopies = d, this._update();
        }, f.prototype.project = function(d) {
          return this.transform.locationPoint(a.LngLat.convert(d));
        }, f.prototype.unproject = function(d) {
          return this.transform.pointLocation(a.Point.convert(d));
        }, f.prototype.isMoving = function() {
          return this._moving || this.handlers.isMoving();
        }, f.prototype.isZooming = function() {
          return this._zooming || this.handlers.isZooming();
        }, f.prototype.isRotating = function() {
          return this._rotating || this.handlers.isRotating();
        }, f.prototype._createDelegatedListener = function(d, _, w) {
          var E, O = this;
          if (d === "mouseenter" || d === "mouseover") {
            var k = !1;
            return { layer: _, listener: w, delegates: { mousemove: function($) {
              var W = O.getLayer(_) ? O.queryRenderedFeatures($.point, { layers: [_] }) : [];
              W.length ? k || (k = !0, w.call(O, new Jn(d, O, $.originalEvent, { features: W }))) : k = !1;
            }, mouseout: function() {
              k = !1;
            } } };
          }
          if (d === "mouseleave" || d === "mouseout") {
            var R = !1;
            return { layer: _, listener: w, delegates: { mousemove: function($) {
              (O.getLayer(_) ? O.queryRenderedFeatures($.point, { layers: [_] }) : []).length ? R = !0 : R && (R = !1, w.call(O, new Jn(d, O, $.originalEvent)));
            }, mouseout: function($) {
              R && (R = !1, w.call(O, new Jn(d, O, $.originalEvent)));
            } } };
          }
          return { layer: _, listener: w, delegates: (E = {}, E[d] = function($) {
            var W = O.getLayer(_) ? O.queryRenderedFeatures($.point, { layers: [_] }) : [];
            W.length && ($.features = W, w.call(O, $), delete $.features);
          }, E) };
        }, f.prototype.on = function(d, _, w) {
          if (w === void 0)
            return u.prototype.on.call(this, d, _);
          var E = this._createDelegatedListener(d, _, w);
          for (var O in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[d] = this._delegatedListeners[d] || [], this._delegatedListeners[d].push(E), E.delegates)
            this.on(O, E.delegates[O]);
          return this;
        }, f.prototype.once = function(d, _, w) {
          if (w === void 0)
            return u.prototype.once.call(this, d, _);
          var E = this._createDelegatedListener(d, _, w);
          for (var O in E.delegates)
            this.once(O, E.delegates[O]);
          return this;
        }, f.prototype.off = function(d, _, w) {
          var E = this;
          return w === void 0 ? u.prototype.off.call(this, d, _) : (this._delegatedListeners && this._delegatedListeners[d] && function(O) {
            for (var k = O[d], R = 0; R < k.length; R++) {
              var $ = k[R];
              if ($.layer === _ && $.listener === w) {
                for (var W in $.delegates)
                  E.off(W, $.delegates[W]);
                return k.splice(R, 1), E;
              }
            }
          }(this._delegatedListeners), this);
        }, f.prototype.queryRenderedFeatures = function(d, _) {
          if (!this.style)
            return [];
          var w;
          if (_ !== void 0 || d === void 0 || d instanceof a.Point || Array.isArray(d) || (_ = d, d = void 0), _ = _ || {}, (d = d || [[0, 0], [this.transform.width, this.transform.height]]) instanceof a.Point || typeof d[0] == "number")
            w = [a.Point.convert(d)];
          else {
            var E = a.Point.convert(d[0]), O = a.Point.convert(d[1]);
            w = [E, new a.Point(O.x, E.y), O, new a.Point(E.x, O.y), E];
          }
          return this.style.queryRenderedFeatures(w, _, this.transform);
        }, f.prototype.querySourceFeatures = function(d, _) {
          return this.style.querySourceFeatures(d, _);
        }, f.prototype.setStyle = function(d, _) {
          return (_ = a.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, _)).diff !== !1 && _.localIdeographFontFamily === this._localIdeographFontFamily && this.style && d ? (this._diffStyle(d, _), this) : (this._localIdeographFontFamily = _.localIdeographFontFamily, this._updateStyle(d, _));
        }, f.prototype._getUIString = function(d) {
          var _ = this._locale[d];
          if (_ == null)
            throw new Error("Missing UI string '" + d + "'");
          return _;
        }, f.prototype._updateStyle = function(d, _) {
          return this.style && (this.style.setEventedParent(null), this.style._remove()), d ? (this.style = new lo(this, _ || {}), this.style.setEventedParent(this, { style: this.style }), typeof d == "string" ? this.style.loadURL(d) : this.style.loadJSON(d), this) : (delete this.style, this);
        }, f.prototype._lazyInitEmptyStyle = function() {
          this.style || (this.style = new lo(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }, f.prototype._diffStyle = function(d, _) {
          var w = this;
          if (typeof d == "string") {
            var E = this._requestManager.normalizeStyleURL(d), O = this._requestManager.transformRequest(E, a.ResourceType.Style);
            a.getJSON(O, function(k, R) {
              k ? w.fire(new a.ErrorEvent(k)) : R && w._updateDiff(R, _);
            });
          } else
            typeof d == "object" && this._updateDiff(d, _);
        }, f.prototype._updateDiff = function(d, _) {
          try {
            this.style.setState(d) && this._update(!0);
          } catch (w) {
            a.warnOnce("Unable to perform style diff: " + (w.message || w.error || w) + ".  Rebuilding the style from scratch."), this._updateStyle(d, _);
          }
        }, f.prototype.getStyle = function() {
          if (this.style)
            return this.style.serialize();
        }, f.prototype.isStyleLoaded = function() {
          return this.style ? this.style.loaded() : a.warnOnce("There is no style added to the map.");
        }, f.prototype.addSource = function(d, _) {
          return this._lazyInitEmptyStyle(), this.style.addSource(d, _), this._update(!0);
        }, f.prototype.isSourceLoaded = function(d) {
          var _ = this.style && this.style.sourceCaches[d];
          if (_ !== void 0)
            return _.loaded();
          this.fire(new a.ErrorEvent(new Error("There is no source with ID '" + d + "'")));
        }, f.prototype.areTilesLoaded = function() {
          var d = this.style && this.style.sourceCaches;
          for (var _ in d) {
            var w = d[_]._tiles;
            for (var E in w) {
              var O = w[E];
              if (O.state !== "loaded" && O.state !== "errored")
                return !1;
            }
          }
          return !0;
        }, f.prototype.addSourceType = function(d, _, w) {
          return this._lazyInitEmptyStyle(), this.style.addSourceType(d, _, w);
        }, f.prototype.removeSource = function(d) {
          return this.style.removeSource(d), this._update(!0);
        }, f.prototype.getSource = function(d) {
          return this.style.getSource(d);
        }, f.prototype.addImage = function(d, _, w) {
          w === void 0 && (w = {});
          var E = w.pixelRatio;
          E === void 0 && (E = 1);
          var O = w.sdf;
          O === void 0 && (O = !1);
          var k = w.stretchX, R = w.stretchY, $ = w.content;
          if (this._lazyInitEmptyStyle(), _ instanceof cp || Gr && _ instanceof Gr) {
            var W = a.browser.getImageData(_);
            this.style.addImage(d, { data: new a.RGBAImage({ width: W.width, height: W.height }, W.data), pixelRatio: E, stretchX: k, stretchY: R, content: $, sdf: O, version: 0 });
          } else {
            if (_.width === void 0 || _.height === void 0)
              return this.fire(new a.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            var H = _;
            this.style.addImage(d, { data: new a.RGBAImage({ width: _.width, height: _.height }, new Uint8Array(_.data)), pixelRatio: E, stretchX: k, stretchY: R, content: $, sdf: O, version: 0, userImage: H }), H.onAdd && H.onAdd(this, d);
          }
        }, f.prototype.updateImage = function(d, _) {
          var w = this.style.getImage(d);
          if (!w)
            return this.fire(new a.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          var E = _ instanceof cp || Gr && _ instanceof Gr ? a.browser.getImageData(_) : _, O = E.width, k = E.height, R = E.data;
          return O === void 0 || k === void 0 ? this.fire(new a.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : O !== w.data.width || k !== w.data.height ? this.fire(new a.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (w.data.replace(R, !(_ instanceof cp || Gr && _ instanceof Gr)), void this.style.updateImage(d, w));
        }, f.prototype.hasImage = function(d) {
          return d ? !!this.style.getImage(d) : (this.fire(new a.ErrorEvent(new Error("Missing required image id"))), !1);
        }, f.prototype.removeImage = function(d) {
          this.style.removeImage(d);
        }, f.prototype.loadImage = function(d, _) {
          a.getImage(this._requestManager.transformRequest(d, a.ResourceType.Image), _);
        }, f.prototype.listImages = function() {
          return this.style.listImages();
        }, f.prototype.addLayer = function(d, _) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(d, _), this._update(!0);
        }, f.prototype.moveLayer = function(d, _) {
          return this.style.moveLayer(d, _), this._update(!0);
        }, f.prototype.removeLayer = function(d) {
          return this.style.removeLayer(d), this._update(!0);
        }, f.prototype.getLayer = function(d) {
          return this.style.getLayer(d);
        }, f.prototype.setLayerZoomRange = function(d, _, w) {
          return this.style.setLayerZoomRange(d, _, w), this._update(!0);
        }, f.prototype.setFilter = function(d, _, w) {
          return w === void 0 && (w = {}), this.style.setFilter(d, _, w), this._update(!0);
        }, f.prototype.getFilter = function(d) {
          return this.style.getFilter(d);
        }, f.prototype.setPaintProperty = function(d, _, w, E) {
          return E === void 0 && (E = {}), this.style.setPaintProperty(d, _, w, E), this._update(!0);
        }, f.prototype.getPaintProperty = function(d, _) {
          return this.style.getPaintProperty(d, _);
        }, f.prototype.setLayoutProperty = function(d, _, w, E) {
          return E === void 0 && (E = {}), this.style.setLayoutProperty(d, _, w, E), this._update(!0);
        }, f.prototype.getLayoutProperty = function(d, _) {
          return this.style.getLayoutProperty(d, _);
        }, f.prototype.setLight = function(d, _) {
          return _ === void 0 && (_ = {}), this._lazyInitEmptyStyle(), this.style.setLight(d, _), this._update(!0);
        }, f.prototype.getLight = function() {
          return this.style.getLight();
        }, f.prototype.setFeatureState = function(d, _) {
          return this.style.setFeatureState(d, _), this._update();
        }, f.prototype.removeFeatureState = function(d, _) {
          return this.style.removeFeatureState(d, _), this._update();
        }, f.prototype.getFeatureState = function(d) {
          return this.style.getFeatureState(d);
        }, f.prototype.getContainer = function() {
          return this._container;
        }, f.prototype.getCanvasContainer = function() {
          return this._canvasContainer;
        }, f.prototype.getCanvas = function() {
          return this._canvas;
        }, f.prototype._containerDimensions = function() {
          var d = 0, _ = 0;
          return this._container && (d = this._container.clientWidth || 400, _ = this._container.clientHeight || 300), [d, _];
        }, f.prototype._detectMissingCSS = function() {
          a.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && a.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }, f.prototype._setupContainer = function() {
          var d = this._container;
          d.classList.add("mapboxgl-map"), (this._missingCSSCanary = g.create("div", "mapboxgl-canary", d)).style.visibility = "hidden", this._detectMissingCSS();
          var _ = this._canvasContainer = g.create("div", "mapboxgl-canvas-container", d);
          this._interactive && _.classList.add("mapboxgl-interactive"), this._canvas = g.create("canvas", "mapboxgl-canvas", _), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
          var w = this._containerDimensions();
          this._resizeCanvas(w[0], w[1]);
          var E = this._controlContainer = g.create("div", "mapboxgl-control-container", d), O = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function(k) {
            O[k] = g.create("div", "mapboxgl-ctrl-" + k, E);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }, f.prototype._resizeCanvas = function(d, _) {
          var w = a.browser.devicePixelRatio || 1;
          this._canvas.width = w * d, this._canvas.height = w * _, this._canvas.style.width = d + "px", this._canvas.style.height = _ + "px";
        }, f.prototype._setupPainter = function() {
          var d = a.extend({}, m.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), _ = this._canvas.getContext("webgl", d) || this._canvas.getContext("experimental-webgl", d);
          _ ? (this.painter = new mn(_, this.transform), a.webpSupported.testSupport(_)) : this.fire(new a.ErrorEvent(new Error("Failed to initialize WebGL")));
        }, f.prototype._contextLost = function(d) {
          d.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new a.Event("webglcontextlost", { originalEvent: d }));
        }, f.prototype._contextRestored = function(d) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new a.Event("webglcontextrestored", { originalEvent: d }));
        }, f.prototype._onMapScroll = function(d) {
          if (d.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
        }, f.prototype.loaded = function() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }, f.prototype._update = function(d) {
          return this.style ? (this._styleDirty = this._styleDirty || d, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }, f.prototype._requestRenderFrame = function(d) {
          return this._update(), this._renderTaskQueue.add(d);
        }, f.prototype._cancelRenderFrame = function(d) {
          this._renderTaskQueue.remove(d);
        }, f.prototype._render = function(d) {
          var _, w = this, E = 0, O = this.painter.context.extTimerQuery;
          if (this.listens("gpu-timing-frame") && (_ = O.createQueryEXT(), O.beginQueryEXT(O.TIME_ELAPSED_EXT, _), E = a.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(d), !this._removed) {
            var k = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              var R = this.transform.zoom, $ = a.browser.now();
              this.style.zoomHistory.update(R, $);
              var W = new a.EvaluationParameters(R, { now: $, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), H = W.crossFadingFactor();
              H === 1 && H === this._crossFadingFactor || (k = !0, this._crossFadingFactor = H), this.style.update(W);
            }
            if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new a.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new a.Event("load"))), this.style && (this.style.hasTransitions() || k) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
              var ne = a.browser.now() - E;
              O.endQueryEXT(O.TIME_ELAPSED_EXT, _), setTimeout(function() {
                var Y = O.getQueryObjectEXT(_, O.QUERY_RESULT_EXT) / 1e6;
                O.deleteQueryEXT(_), w.fire(new a.Event("gpu-timing-frame", { cpuTime: ne, gpuTime: Y }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              var te = this.painter.collectGpuTimers();
              setTimeout(function() {
                var Y = w.painter.queryGpuTimers(te);
                w.fire(new a.Event("gpu-timing-layer", { layerTimes: Y }));
              }, 50);
            }
            var ue = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return ue || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new a.Event("idle")), !this._loaded || this._fullyLoaded || ue || (this._fullyLoaded = !0), this;
          }
        }, f.prototype.remove = function() {
          this._hash && this._hash.remove();
          for (var d = 0, _ = this._controls; d < _.length; d += 1)
            _[d].onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), a.window !== void 0 && (a.window.removeEventListener("resize", this._onWindowResize, !1), a.window.removeEventListener("orientationchange", this._onWindowResize, !1), a.window.removeEventListener("online", this._onWindowOnline, !1));
          var w = this.painter.context.gl.getExtension("WEBGL_lose_context");
          w && w.loseContext(), bl(this._canvasContainer), bl(this._controlContainer), bl(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this._removed = !0, this.fire(new a.Event("remove"));
        }, f.prototype.triggerRepaint = function() {
          var d = this;
          this.style && !this._frame && (this._frame = a.browser.frame(function(_) {
            d._frame = null, d._render(_);
          }));
        }, f.prototype._onWindowOnline = function() {
          this._update();
        }, f.prototype._onWindowResize = function(d) {
          this._trackResize && this.resize({ originalEvent: d })._update();
        }, c.showTileBoundaries.get = function() {
          return !!this._showTileBoundaries;
        }, c.showTileBoundaries.set = function(d) {
          this._showTileBoundaries !== d && (this._showTileBoundaries = d, this._update());
        }, c.showPadding.get = function() {
          return !!this._showPadding;
        }, c.showPadding.set = function(d) {
          this._showPadding !== d && (this._showPadding = d, this._update());
        }, c.showCollisionBoxes.get = function() {
          return !!this._showCollisionBoxes;
        }, c.showCollisionBoxes.set = function(d) {
          this._showCollisionBoxes !== d && (this._showCollisionBoxes = d, d ? this.style._generateCollisionBoxes() : this._update());
        }, c.showOverdrawInspector.get = function() {
          return !!this._showOverdrawInspector;
        }, c.showOverdrawInspector.set = function(d) {
          this._showOverdrawInspector !== d && (this._showOverdrawInspector = d, this._update());
        }, c.repaint.get = function() {
          return !!this._repaint;
        }, c.repaint.set = function(d) {
          this._repaint !== d && (this._repaint = d, this.triggerRepaint());
        }, c.vertices.get = function() {
          return !!this._vertices;
        }, c.vertices.set = function(d) {
          this._vertices = d, this._update();
        }, f.prototype._setCacheLimits = function(d, _) {
          a.setCacheLimits(d, _);
        }, c.version.get = function() {
          return a.version;
        }, Object.defineProperties(f.prototype, c), f;
      }(Eh);
      function bl(u) {
        u.parentNode && u.parentNode.removeChild(u);
      }
      var hp = { showCompass: !0, showZoom: !0, visualizePitch: !1 }, Ga = function(u) {
        var f = this;
        this.options = a.extend({}, hp, u), this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", function(c) {
          return c.preventDefault();
        }), this.options.showZoom && (a.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", function(c) {
          return f._map.zoomIn({}, { originalEvent: c });
        }), g.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", !0), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", function(c) {
          return f._map.zoomOut({}, { originalEvent: c });
        }), g.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", !0)), this.options.showCompass && (a.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", function(c) {
          f.options.visualizePitch ? f._map.resetNorthPitch({}, { originalEvent: c }) : f._map.resetNorth({}, { originalEvent: c });
        }), this._compassIcon = g.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", !0));
      };
      Ga.prototype._updateZoomButtons = function() {
        var u = this._map.getZoom(), f = u === this._map.getMaxZoom(), c = u === this._map.getMinZoom();
        this._zoomInButton.disabled = f, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", f.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
      }, Ga.prototype._rotateCompassArrow = function() {
        var u = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";
        this._compassIcon.style.transform = u;
      }, Ga.prototype.onAdd = function(u) {
        return this._map = u, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new po(this._map, this._compass, this.options.visualizePitch)), this._container;
      }, Ga.prototype.onRemove = function() {
        g.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
      }, Ga.prototype._createButton = function(u, f) {
        var c = g.create("button", u, this._container);
        return c.type = "button", c.addEventListener("click", f), c;
      }, Ga.prototype._setButtonTitle = function(u, f) {
        var c = this._map._getUIString("NavigationControl." + f);
        u.title = c, u.setAttribute("aria-label", c);
      };
      var po = function(u, f, c) {
        c === void 0 && (c = !1), this._clickTolerance = 10, this.element = f, this.mouseRotate = new xh({ clickTolerance: u.dragRotate._mouseRotate._clickTolerance }), this.map = u, c && (this.mousePitch = new sp({ clickTolerance: u.dragRotate._mousePitch._clickTolerance })), a.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), g.addEventListener(f, "mousedown", this.mousedown), g.addEventListener(f, "touchstart", this.touchstart, { passive: !1 }), g.addEventListener(f, "touchmove", this.touchmove), g.addEventListener(f, "touchend", this.touchend), g.addEventListener(f, "touchcancel", this.reset);
      };
      function iu(u, f, c) {
        if (u = new a.LngLat(u.lng, u.lat), f) {
          var d = new a.LngLat(u.lng - 360, u.lat), _ = new a.LngLat(u.lng + 360, u.lat), w = c.locationPoint(u).distSqr(f);
          c.locationPoint(d).distSqr(f) < w ? u = d : c.locationPoint(_).distSqr(f) < w && (u = _);
        }
        for (; Math.abs(u.lng - c.center.lng) > 180; ) {
          var E = c.locationPoint(u);
          if (E.x >= 0 && E.y >= 0 && E.x <= c.width && E.y <= c.height)
            break;
          u.lng > c.center.lng ? u.lng -= 360 : u.lng += 360;
        }
        return u;
      }
      po.prototype.down = function(u, f) {
        this.mouseRotate.mousedown(u, f), this.mousePitch && this.mousePitch.mousedown(u, f), g.disableDrag();
      }, po.prototype.move = function(u, f) {
        var c = this.map, d = this.mouseRotate.mousemoveWindow(u, f);
        if (d && d.bearingDelta && c.setBearing(c.getBearing() + d.bearingDelta), this.mousePitch) {
          var _ = this.mousePitch.mousemoveWindow(u, f);
          _ && _.pitchDelta && c.setPitch(c.getPitch() + _.pitchDelta);
        }
      }, po.prototype.off = function() {
        var u = this.element;
        g.removeEventListener(u, "mousedown", this.mousedown), g.removeEventListener(u, "touchstart", this.touchstart, { passive: !1 }), g.removeEventListener(u, "touchmove", this.touchmove), g.removeEventListener(u, "touchend", this.touchend), g.removeEventListener(u, "touchcancel", this.reset), this.offTemp();
      }, po.prototype.offTemp = function() {
        g.enableDrag(), g.removeEventListener(a.window, "mousemove", this.mousemove), g.removeEventListener(a.window, "mouseup", this.mouseup);
      }, po.prototype.mousedown = function(u) {
        this.down(a.extend({}, u, { ctrlKey: !0, preventDefault: function() {
          return u.preventDefault();
        } }), g.mousePos(this.element, u)), g.addEventListener(a.window, "mousemove", this.mousemove), g.addEventListener(a.window, "mouseup", this.mouseup);
      }, po.prototype.mousemove = function(u) {
        this.move(u, g.mousePos(this.element, u));
      }, po.prototype.mouseup = function(u) {
        this.mouseRotate.mouseupWindow(u), this.mousePitch && this.mousePitch.mouseupWindow(u), this.offTemp();
      }, po.prototype.touchstart = function(u) {
        u.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = g.touchPos(this.element, u.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: function() {
          return u.preventDefault();
        } }, this._startPos));
      }, po.prototype.touchmove = function(u) {
        u.targetTouches.length !== 1 ? this.reset() : (this._lastPos = g.touchPos(this.element, u.targetTouches)[0], this.move({ preventDefault: function() {
          return u.preventDefault();
        } }, this._lastPos));
      }, po.prototype.touchend = function(u) {
        u.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
      }, po.prototype.reset = function() {
        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
      };
      var Ea = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function Th(u, f, c) {
        var d = u.classList;
        for (var _ in Ea)
          d.remove("mapboxgl-" + c + "-anchor-" + _);
        d.add("mapboxgl-" + c + "-anchor-" + f);
      }
      var ou, hc = function(u) {
        function f(c, d) {
          if (u.call(this), (c instanceof a.window.HTMLElement || d) && (c = a.extend({ element: c }, d)), a.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = c && c.anchor || "center", this._color = c && c.color || "#3FB1CE", this._scale = c && c.scale || 1, this._draggable = c && c.draggable || !1, this._clickTolerance = c && c.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = c && c.rotation || 0, this._rotationAlignment = c && c.rotationAlignment || "auto", this._pitchAlignment = c && c.pitchAlignment && c.pitchAlignment !== "auto" ? c.pitchAlignment : this._rotationAlignment, c && c.element)
            this._element = c.element, this._offset = a.Point.convert(c && c.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = g.create("div"), this._element.setAttribute("aria-label", "Map marker");
            var _ = g.createNS("http://www.w3.org/2000/svg", "svg");
            _.setAttributeNS(null, "display", "block"), _.setAttributeNS(null, "height", "41px"), _.setAttributeNS(null, "width", "27px"), _.setAttributeNS(null, "viewBox", "0 0 27 41");
            var w = g.createNS("http://www.w3.org/2000/svg", "g");
            w.setAttributeNS(null, "stroke", "none"), w.setAttributeNS(null, "stroke-width", "1"), w.setAttributeNS(null, "fill", "none"), w.setAttributeNS(null, "fill-rule", "evenodd");
            var E = g.createNS("http://www.w3.org/2000/svg", "g");
            E.setAttributeNS(null, "fill-rule", "nonzero");
            var O = g.createNS("http://www.w3.org/2000/svg", "g");
            O.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), O.setAttributeNS(null, "fill", "#000000");
            for (var k = 0, R = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; k < R.length; k += 1) {
              var $ = R[k], W = g.createNS("http://www.w3.org/2000/svg", "ellipse");
              W.setAttributeNS(null, "opacity", "0.04"), W.setAttributeNS(null, "cx", "10.5"), W.setAttributeNS(null, "cy", "5.80029008"), W.setAttributeNS(null, "rx", $.rx), W.setAttributeNS(null, "ry", $.ry), O.appendChild(W);
            }
            var H = g.createNS("http://www.w3.org/2000/svg", "g");
            H.setAttributeNS(null, "fill", this._color);
            var ne = g.createNS("http://www.w3.org/2000/svg", "path");
            ne.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), H.appendChild(ne);
            var te = g.createNS("http://www.w3.org/2000/svg", "g");
            te.setAttributeNS(null, "opacity", "0.25"), te.setAttributeNS(null, "fill", "#000000");
            var ue = g.createNS("http://www.w3.org/2000/svg", "path");
            ue.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), te.appendChild(ue);
            var Y = g.createNS("http://www.w3.org/2000/svg", "g");
            Y.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), Y.setAttributeNS(null, "fill", "#FFFFFF");
            var le = g.createNS("http://www.w3.org/2000/svg", "g");
            le.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            var me = g.createNS("http://www.w3.org/2000/svg", "circle");
            me.setAttributeNS(null, "fill", "#000000"), me.setAttributeNS(null, "opacity", "0.25"), me.setAttributeNS(null, "cx", "5.5"), me.setAttributeNS(null, "cy", "5.5"), me.setAttributeNS(null, "r", "5.4999962");
            var xe = g.createNS("http://www.w3.org/2000/svg", "circle");
            xe.setAttributeNS(null, "fill", "#FFFFFF"), xe.setAttributeNS(null, "cx", "5.5"), xe.setAttributeNS(null, "cy", "5.5"), xe.setAttributeNS(null, "r", "5.4999962"), le.appendChild(me), le.appendChild(xe), E.appendChild(O), E.appendChild(H), E.appendChild(te), E.appendChild(Y), E.appendChild(le), _.appendChild(E), _.setAttributeNS(null, "height", 41 * this._scale + "px"), _.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(_), this._offset = a.Point.convert(c && c.offset || [0, -14]);
          }
          this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", function(Ae) {
            Ae.preventDefault();
          }), this._element.addEventListener("mousedown", function(Ae) {
            Ae.preventDefault();
          }), Th(this._element, this._anchor, "marker"), this._popup = null;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.addTo = function(c) {
          return this.remove(), this._map = c, c.getCanvasContainer().appendChild(this._element), c.on("move", this._update), c.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }, f.prototype.remove = function() {
          return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), g.remove(this._element), this._popup && this._popup.remove(), this;
        }, f.prototype.getLngLat = function() {
          return this._lngLat;
        }, f.prototype.setLngLat = function(c) {
          return this._lngLat = a.LngLat.convert(c), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }, f.prototype.getElement = function() {
          return this._element;
        }, f.prototype.setPopup = function(c) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), c) {
            if (!("offset" in c.options)) {
              var d = Math.sqrt(Math.pow(13.5, 2) / 2);
              c.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [d, -1 * (24.6 + d)], "bottom-right": [-d, -1 * (24.6 + d)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset;
            }
            this._popup = c, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }, f.prototype._onKeyPress = function(c) {
          var d = c.code, _ = c.charCode || c.keyCode;
          d !== "Space" && d !== "Enter" && _ !== 32 && _ !== 13 || this.togglePopup();
        }, f.prototype._onMapClick = function(c) {
          var d = c.originalEvent.target, _ = this._element;
          this._popup && (d === _ || _.contains(d)) && this.togglePopup();
        }, f.prototype.getPopup = function() {
          return this._popup;
        }, f.prototype.togglePopup = function() {
          var c = this._popup;
          return c ? (c.isOpen() ? c.remove() : c.addTo(this._map), this) : this;
        }, f.prototype._update = function(c) {
          if (this._map) {
            this._map.transform.renderWorldCopies && (this._lngLat = iu(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
            var d = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? d = "rotateZ(" + this._rotation + "deg)" : this._rotationAlignment === "map" && (d = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");
            var _ = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? _ = "rotateX(0deg)" : this._pitchAlignment === "map" && (_ = "rotateX(" + this._map.getPitch() + "deg)"), c && c.type !== "moveend" || (this._pos = this._pos.round()), g.setTransform(this._element, Ea[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + _ + " " + d);
          }
        }, f.prototype.getOffset = function() {
          return this._offset;
        }, f.prototype.setOffset = function(c) {
          return this._offset = a.Point.convert(c), this._update(), this;
        }, f.prototype._onMove = function(c) {
          if (!this._isDragging) {
            var d = this._clickTolerance || this._map._clickTolerance;
            this._isDragging = c.point.dist(this._pointerdownPos) >= d;
          }
          this._isDragging && (this._pos = c.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new a.Event("dragstart"))), this.fire(new a.Event("drag")));
        }, f.prototype._onUp = function() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new a.Event("dragend")), this._state = "inactive";
        }, f.prototype._addDragHandler = function(c) {
          this._element.contains(c.originalEvent.target) && (c.preventDefault(), this._positionDelta = c.point.sub(this._pos).add(this._offset), this._pointerdownPos = c.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
        }, f.prototype.setDraggable = function(c) {
          return this._draggable = !!c, this._map && (c ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }, f.prototype.isDraggable = function() {
          return this._draggable;
        }, f.prototype.setRotation = function(c) {
          return this._rotation = c || 0, this._update(), this;
        }, f.prototype.getRotation = function() {
          return this._rotation;
        }, f.prototype.setRotationAlignment = function(c) {
          return this._rotationAlignment = c || "auto", this._update(), this;
        }, f.prototype.getRotationAlignment = function() {
          return this._rotationAlignment;
        }, f.prototype.setPitchAlignment = function(c) {
          return this._pitchAlignment = c && c !== "auto" ? c : this._rotationAlignment, this._update(), this;
        }, f.prototype.getPitchAlignment = function() {
          return this._pitchAlignment;
        }, f;
      }(a.Evented), fp = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 }, au = 0, wl = !1, pp = function(u) {
        function f(c) {
          u.call(this), this.options = a.extend({}, fp, c), a.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.onAdd = function(c) {
          var d;
          return this._map = c, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), d = this._setupUI, ou !== void 0 ? d(ou) : a.window.navigator.permissions !== void 0 ? a.window.navigator.permissions.query({ name: "geolocation" }).then(function(_) {
            d(ou = _.state !== "denied");
          }) : d(ou = !!a.window.navigator.geolocation), this._container;
        }, f.prototype.onRemove = function() {
          this._geolocationWatchID !== void 0 && (a.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), g.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, au = 0, wl = !1;
        }, f.prototype._isOutOfMapMaxBounds = function(c) {
          var d = this._map.getMaxBounds(), _ = c.coords;
          return d && (_.longitude < d.getWest() || _.longitude > d.getEast() || _.latitude < d.getSouth() || _.latitude > d.getNorth());
        }, f.prototype._setErrorState = function() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }, f.prototype._onSuccess = function(c) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(c))
              return this._setErrorState(), this.fire(new a.Event("outofmaxbounds", c)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = c, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(c), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(c), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new a.Event("geolocate", c)), this._finish();
          }
        }, f.prototype._updateCamera = function(c) {
          var d = new a.LngLat(c.coords.longitude, c.coords.latitude), _ = c.coords.accuracy, w = this._map.getBearing(), E = a.extend({ bearing: w }, this.options.fitBoundsOptions);
          this._map.fitBounds(d.toBounds(_), E, { geolocateSource: !0 });
        }, f.prototype._updateMarker = function(c) {
          if (c) {
            var d = new a.LngLat(c.coords.longitude, c.coords.latitude);
            this._accuracyCircleMarker.setLngLat(d).addTo(this._map), this._userLocationDotMarker.setLngLat(d).addTo(this._map), this._accuracy = c.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }, f.prototype._updateCircleRadius = function() {
          var c = this._map._container.clientHeight / 2, d = this._map.unproject([0, c]), _ = this._map.unproject([1, c]), w = d.distanceTo(_), E = Math.ceil(2 * this._accuracy / w);
          this._circleElement.style.width = E + "px", this._circleElement.style.height = E + "px";
        }, f.prototype._onZoom = function() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }, f.prototype._onError = function(c) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (c.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                var d = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = d, this._geolocateButton.setAttribute("aria-label", d), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (c.code === 3 && wl)
                  return;
                this._setErrorState();
              }
            this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new a.Event("error", c)), this._finish();
          }
        }, f.prototype._finish = function() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }, f.prototype._setupUI = function(c) {
          var d = this;
          if (this._container.addEventListener("contextmenu", function(E) {
            return E.preventDefault();
          }), this._geolocateButton = g.create("button", "mapboxgl-ctrl-geolocate", this._container), g.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", !0), this._geolocateButton.type = "button", c === !1) {
            a.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
            var _ = this._map._getUIString("GeolocateControl.LocationNotAvailable");
            this._geolocateButton.disabled = !0, this._geolocateButton.title = _, this._geolocateButton.setAttribute("aria-label", _);
          } else {
            var w = this._map._getUIString("GeolocateControl.FindMyLocation");
            this._geolocateButton.title = w, this._geolocateButton.setAttribute("aria-label", w);
          }
          this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = g.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new hc(this._dotElement), this._circleElement = g.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new hc({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", function(E) {
            E.geolocateSource || d._watchState !== "ACTIVE_LOCK" || E.originalEvent && E.originalEvent.type === "resize" || (d._watchState = "BACKGROUND", d._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), d._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), d.fire(new a.Event("trackuserlocationend")));
          });
        }, f.prototype.trigger = function() {
          if (!this._setup)
            return a.warnOnce("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new a.Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                au--, wl = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new a.Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new a.Event("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
              this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              var c;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++au > 1 ? (c = { maximumAge: 6e5, timeout: 0 }, wl = !0) : (c = this.options.positionOptions, wl = !1), this._geolocationWatchID = a.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, c);
            }
          } else
            a.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }, f.prototype._clearWatch = function() {
          a.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }, f;
      }(a.Evented), Ts = { maxWidth: 100, unit: "metric" }, Ms = function(u) {
        this.options = a.extend({}, Ts, u), a.bindAll(["_onMove", "setUnit"], this);
      };
      function Mh(u, f, c) {
        var d = c && c.maxWidth || 100, _ = u._container.clientHeight / 2, w = u.unproject([0, _]), E = u.unproject([d, _]), O = w.distanceTo(E);
        if (c && c.unit === "imperial") {
          var k = 3.2808 * O;
          k > 5280 ? Is(f, d, k / 5280, u._getUIString("ScaleControl.Miles")) : Is(f, d, k, u._getUIString("ScaleControl.Feet"));
        } else
          c && c.unit === "nautical" ? Is(f, d, O / 1852, u._getUIString("ScaleControl.NauticalMiles")) : O >= 1e3 ? Is(f, d, O / 1e3, u._getUIString("ScaleControl.Kilometers")) : Is(f, d, O, u._getUIString("ScaleControl.Meters"));
      }
      function Is(u, f, c, d) {
        var _, w, E, O = (_ = c, (w = Math.pow(10, ("" + Math.floor(_)).length - 1)) * (E = (E = _ / w) >= 10 ? 10 : E >= 5 ? 5 : E >= 3 ? 3 : E >= 2 ? 2 : E >= 1 ? 1 : function(k) {
          var R = Math.pow(10, Math.ceil(-Math.log(k) / Math.LN10));
          return Math.round(k * R) / R;
        }(E)));
        u.style.width = f * (O / c) + "px", u.innerHTML = O + "&nbsp;" + d;
      }
      Ms.prototype.getDefaultPosition = function() {
        return "bottom-left";
      }, Ms.prototype._onMove = function() {
        Mh(this._map, this._container, this.options);
      }, Ms.prototype.onAdd = function(u) {
        return this._map = u, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", u.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
      }, Ms.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
      }, Ms.prototype.setUnit = function(u) {
        this.options.unit = u, Mh(this._map, this._container, this.options);
      };
      var Ho = function(u) {
        this._fullscreen = !1, u && u.container && (u.container instanceof a.window.HTMLElement ? this._container = u.container : a.warnOnce("Full screen control 'container' must be a DOM element.")), a.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in a.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in a.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in a.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in a.window.document && (this._fullscreenchange = "MSFullscreenChange");
      };
      Ho.prototype.onAdd = function(u) {
        return this._map = u, this._container || (this._container = this._map.getContainer()), this._controlContainer = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", a.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
      }, Ho.prototype.onRemove = function() {
        g.remove(this._controlContainer), this._map = null, a.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
      }, Ho.prototype._checkFullscreenSupport = function() {
        return !!(a.window.document.fullscreenEnabled || a.window.document.mozFullScreenEnabled || a.window.document.msFullscreenEnabled || a.window.document.webkitFullscreenEnabled);
      }, Ho.prototype._setupUI = function() {
        var u = this._fullscreenButton = g.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
        g.create("span", "mapboxgl-ctrl-icon", u).setAttribute("aria-hidden", !0), u.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), a.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
      }, Ho.prototype._updateTitle = function() {
        var u = this._getTitle();
        this._fullscreenButton.setAttribute("aria-label", u), this._fullscreenButton.title = u;
      }, Ho.prototype._getTitle = function() {
        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
      }, Ho.prototype._isFullscreen = function() {
        return this._fullscreen;
      }, Ho.prototype._changeIcon = function() {
        (a.window.document.fullscreenElement || a.window.document.mozFullScreenElement || a.window.document.webkitFullscreenElement || a.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
      }, Ho.prototype._onClickFullscreen = function() {
        this._isFullscreen() ? a.window.document.exitFullscreen ? a.window.document.exitFullscreen() : a.window.document.mozCancelFullScreen ? a.window.document.mozCancelFullScreen() : a.window.document.msExitFullscreen ? a.window.document.msExitFullscreen() : a.window.document.webkitCancelFullScreen && a.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
      };
      var dp = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, fc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), mp = function(u) {
        function f(c) {
          u.call(this), this.options = a.extend(Object.create(dp), c), a.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.addTo = function(c) {
          return this._map && this.remove(), this._map = c, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new a.Event("open")), this;
        }, f.prototype.isOpen = function() {
          return !!this._map;
        }, f.prototype.remove = function() {
          return this._content && g.remove(this._content), this._container && (g.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new a.Event("close")), this;
        }, f.prototype.getLngLat = function() {
          return this._lngLat;
        }, f.prototype.setLngLat = function(c) {
          return this._lngLat = a.LngLat.convert(c), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }, f.prototype.trackPointer = function() {
          return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }, f.prototype.getElement = function() {
          return this._container;
        }, f.prototype.setText = function(c) {
          return this.setDOMContent(a.window.document.createTextNode(c));
        }, f.prototype.setHTML = function(c) {
          var d, _ = a.window.document.createDocumentFragment(), w = a.window.document.createElement("body");
          for (w.innerHTML = c; d = w.firstChild; )
            _.appendChild(d);
          return this.setDOMContent(_);
        }, f.prototype.getMaxWidth = function() {
          return this._container && this._container.style.maxWidth;
        }, f.prototype.setMaxWidth = function(c) {
          return this.options.maxWidth = c, this._update(), this;
        }, f.prototype.setDOMContent = function(c) {
          if (this._content)
            for (; this._content.hasChildNodes(); )
              this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else
            this._content = g.create("div", "mapboxgl-popup-content", this._container);
          return this._content.appendChild(c), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }, f.prototype.addClassName = function(c) {
          this._container && this._container.classList.add(c);
        }, f.prototype.removeClassName = function(c) {
          this._container && this._container.classList.remove(c);
        }, f.prototype.setOffset = function(c) {
          return this.options.offset = c, this._update(), this;
        }, f.prototype.toggleClassName = function(c) {
          if (this._container)
            return this._container.classList.toggle(c);
        }, f.prototype._createCloseButton = function() {
          this.options.closeButton && (this._closeButton = g.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }, f.prototype._onMouseUp = function(c) {
          this._update(c.point);
        }, f.prototype._onMouseMove = function(c) {
          this._update(c.point);
        }, f.prototype._onDrag = function(c) {
          this._update(c.point);
        }, f.prototype._update = function(c) {
          var d = this;
          if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = g.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = g.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function(W) {
            return d._container.classList.add(W);
          }), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = iu(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || c)) {
            var _ = this._pos = this._trackPointer && c ? c : this._map.project(this._lngLat), w = this.options.anchor, E = function W(H) {
              if (H) {
                if (typeof H == "number") {
                  var ne = Math.round(Math.sqrt(0.5 * Math.pow(H, 2)));
                  return { center: new a.Point(0, 0), top: new a.Point(0, H), "top-left": new a.Point(ne, ne), "top-right": new a.Point(-ne, ne), bottom: new a.Point(0, -H), "bottom-left": new a.Point(ne, -ne), "bottom-right": new a.Point(-ne, -ne), left: new a.Point(H, 0), right: new a.Point(-H, 0) };
                }
                if (H instanceof a.Point || Array.isArray(H)) {
                  var te = a.Point.convert(H);
                  return { center: te, top: te, "top-left": te, "top-right": te, bottom: te, "bottom-left": te, "bottom-right": te, left: te, right: te };
                }
                return { center: a.Point.convert(H.center || [0, 0]), top: a.Point.convert(H.top || [0, 0]), "top-left": a.Point.convert(H["top-left"] || [0, 0]), "top-right": a.Point.convert(H["top-right"] || [0, 0]), bottom: a.Point.convert(H.bottom || [0, 0]), "bottom-left": a.Point.convert(H["bottom-left"] || [0, 0]), "bottom-right": a.Point.convert(H["bottom-right"] || [0, 0]), left: a.Point.convert(H.left || [0, 0]), right: a.Point.convert(H.right || [0, 0]) };
              }
              return W(new a.Point(0, 0));
            }(this.options.offset);
            if (!w) {
              var O, k = this._container.offsetWidth, R = this._container.offsetHeight;
              O = _.y + E.bottom.y < R ? ["top"] : _.y > this._map.transform.height - R ? ["bottom"] : [], _.x < k / 2 ? O.push("left") : _.x > this._map.transform.width - k / 2 && O.push("right"), w = O.length === 0 ? "bottom" : O.join("-");
            }
            var $ = _.add(E[w]).round();
            g.setTransform(this._container, Ea[w] + " translate(" + $.x + "px," + $.y + "px)"), Th(this._container, w, "popup");
          }
        }, f.prototype._focusFirstElement = function() {
          if (this.options.focusAfterOpen && this._container) {
            var c = this._container.querySelector(fc);
            c && c.focus();
          }
        }, f.prototype._onClose = function() {
          this.remove();
        }, f;
      }(a.Evented), Ih = { version: a.version, supported: m, setRTLTextPlugin: a.setRTLTextPlugin, getRTLTextPluginStatus: a.getRTLTextPluginStatus, Map: Rm, NavigationControl: Ga, GeolocateControl: pp, AttributionControl: Gi, ScaleControl: Ms, FullscreenControl: Ho, Popup: mp, Marker: hc, Style: lo, LngLat: a.LngLat, LngLatBounds: a.LngLatBounds, Point: a.Point, MercatorCoordinate: a.MercatorCoordinate, Evented: a.Evented, config: a.config, prewarm: function() {
        Le().acquire(Ce);
      }, clearPrewarmedResources: function() {
        var u = Et;
        u && (u.isPreloaded() && u.numActive() === 1 ? (u.release(Ce), Et = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get accessToken() {
        return a.config.ACCESS_TOKEN;
      }, set accessToken(u) {
        a.config.ACCESS_TOKEN = u;
      }, get baseApiUrl() {
        return a.config.API_URL;
      }, set baseApiUrl(u) {
        a.config.API_URL = u;
      }, get workerCount() {
        return Ue.workerCount;
      }, set workerCount(u) {
        Ue.workerCount = u;
      }, get maxParallelImageRequests() {
        return a.config.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(u) {
        a.config.MAX_PARALLEL_IMAGE_REQUESTS = u;
      }, clearStorage: function(u) {
        a.clearTileCache(u);
      }, workerUrl: "" };
      return Ih;
    }), s;
  });
})(tI);
const rE = tI.exports;
class rI extends PC {
  constructor(e) {
    const n = Object.assign({}, e);
    delete n.accessToken, delete n.style, delete n.container, delete n.xyz, super(n), this.set("xyz", e.maplibreOptions.xyz), this.set("xyz_custom", e.maplibreOptions.xyz_custom), this.xyz_ = e.xyz, e.accessToken && (rE.accessToken = e.accessToken), this.map_ = new rE.Map({
      container: e.maplibreOptions.container,
      style: e.maplibreOptions.style,
      attributionControl: !1,
      interactive: !1
    }), this.maplibreMap = this.map_;
  }
  getMapBoxMap() {
    return this.map_;
  }
  getMapLibreMap() {
    return this.map_;
  }
  render(e) {
    const n = this.map_.getCanvas(), o = e.viewState;
    n.style.position = "absolute";
    const s = this.getVisible();
    n.style.display = s ? "block" : "none";
    const h = this.getOpacity().toString();
    h !== n.style.opacity && (n.style.opacity = h);
    const a = o.rotation;
    return a && this.map_.rotateTo(kC(-a), {
      animate: !1
    }), this.map_.jumpTo({
      center: LC(o.center),
      zoom: o.zoom - 1,
      animate: !1
    }), this.map_._frame && (this.map_._frame.cancel(), this.map_._frame = null), this.map_._render(), n;
  }
  setLayerVisibility(e, n) {
    this.map_.setLayoutProperty(
      e,
      "visibility",
      n ? "visible" : "none"
    );
  }
  getStyle() {
    return this.map_.getStyle();
  }
  getXYZ() {
    return this.get("xyz");
  }
}
class xF {
  createOlLayer(e, n) {
    const o = Vl(), { id: s, metadata: h, name: a } = e, m = n.get(s);
    if (!m)
      return;
    const g = {
      container: o.getOlMap().getTarget(),
      ...m
    }, b = new rI({
      maplibreOptions: g,
      label: a,
      id: s,
      queryable_id: s,
      metadata: h
    }), T = Ks();
    return b != null && b.getMapLibreMap().loaded() ? T.setBaseStyle(s, b == null ? void 0 : b.getMapLibreMap().getStyle()) : new Promise(
      (M) => b == null ? void 0 : b.getMapLibreMap().once("data", M)
    ).then(
      () => T.setBaseStyle(s, b == null ? void 0 : b.getMapLibreMap().getStyle())
    ), b;
  }
}
const bF = new xF();
class wF {
  createOlLayer(e, n) {
    let o;
    if (n && (o = bF.createOlLayer(e, n)), !o)
      switch (e.type) {
        case "WMS":
          o = QM.createOlLayer(e);
          break;
        case "WMTS":
        case "BG WMTS":
          o = eI.createOlLayer(e);
          break;
        default:
          throw new Error(`Unrecognized layer type: ${e.type}`);
      }
    return o.set("id", e.id), o.set("label", e.name), o.set("layer_name", e.name), o.set("metadata", e.metadata), o.set("queryable_id", e.id), o.set("current_time", hs().getLayerCurrentTime(e)), o.set("time", e.time), o.setOpacity(e.opacity), o;
  }
}
const nE = new wF();
class EF {
  setLayerTime(e, n) {
    const o = e.getSource();
    o instanceof OE && QM.setLayerTime(o, n), o instanceof CE && eI.setLayerTime(e, o, n);
  }
}
const SF = new EF(), Vy = -200;
function nI() {
  function t(P, z) {
    if (!z)
      return;
    const V = b(z);
    P.addLayer(V);
  }
  function e(P, z) {
    return P.getLayers().getArray().find((V) => V.get("id") === z);
  }
  function n(P, z) {
    const V = e(P, z);
    V && P.removeLayer(V);
  }
  function o(P, z) {
    const V = P.getLayers().getArray();
    z.forEach((q, re) => {
      const X = V.find(
        (ae) => ae.get("id") === q.id
      );
      X == null || X.setZIndex(re + 1);
    });
  }
  function s(P, z, V) {
    const q = P.getLayers().getArray().find((re) => re.get("id") === z);
    q && q.setOpacity(V);
  }
  function h(P, z) {
    const V = hs(), q = e(P, z.id), re = V.getLayerCurrentTime(z);
    re && q && SF.setLayerTime(q, re);
  }
  function a(P) {
    Wp.delete(P);
  }
  function m(P) {
    return Wp.has(P.id);
  }
  function g(P, z) {
    Wp.set(P, z);
  }
  function b(P) {
    const z = P.id, V = Wp.get(z);
    if (V)
      return V;
    {
      const q = nE.createOlLayer(P);
      return g(z, q), q;
    }
  }
  function T(P) {
    return P && Wp.get(P.id) || null;
  }
  function M(P, z) {
    const q = P.getLayers().getArray().find((re) => re.getZIndex() === Vy);
    q && z(q);
  }
  function I(P, z, V) {
    var ce;
    const q = P.getLayers(), re = q.getArray().findIndex((ve) => ve.getZIndex() === Vy), X = (ce = q.getArray()[re]) == null ? void 0 : ce.get("id");
    let ae;
    z && (m(z) ? ae = T(z) : (ae = nE.createOlLayer(
      z,
      V
    ), g(z.id, ae))), re >= 0 ? ae ? (ae.setZIndex(Vy), q.setAt(re, ae)) : q.removeAt(re) : ae && (ae.setZIndex(Vy), P.addLayer(ae)), X !== (z == null ? void 0 : z.id) && XM.restoreStyle(!0);
  }
  return {
    addLayer: t,
    findLayer: e,
    removeLayer: n,
    removeFromCache: a,
    reorderLayers: o,
    setLayerOpacity: s,
    setLayerTime: h,
    getLayerFromCache: T,
    setBgLayer: I,
    applyOnBgLayer: M
  };
}
class TF {
  constructor(e) {
    bi(this, "previousLayers");
    bi(this, "previousVectorSources");
    const n = Ei(), o = Ks(), s = Vl(), h = $f(), a = nI(), { appliedStyle: m } = xn(o);
    Pn(
      () => n.layers,
      (g) => {
        const b = {
          layers: this.previousLayers
        }, T = {
          layers: g
        }, M = s.getRemovedLayers(
          T,
          b
        ), I = s.getAddedLayers(
          T,
          b
        ), P = s.getMutatedLayers(
          T,
          b
        );
        M.forEach((z) => a.removeLayer(e, z.id)), I.forEach((z) => {
          a.addLayer(e, z.layer), a.setLayerTime(e, z.layer);
        }), P.forEach((z) => {
          a.setLayerOpacity(e, z.id, z.opacity), a.setLayerTime(e, z);
        }), T.layers && a.reorderLayers(e, T.layers), this.previousLayers = g;
      }
    ), Pn(
      () => n.bgLayer,
      (g) => g !== void 0 && a.setBgLayer(e, g, o.bgVectorSources)
    ), va(() => {
      o.isExpertStyleActive || (m.value = h.applyDefaultStyle(
        n.bgLayer,
        o.bgVectorBaseStyles,
        o.bgStyle
      ));
    }), Pn(m, (g) => {
      o.bgStyle === null && !o.isExpertStyleActive ? h.unregisterStyle(o.styleSerial, o.registerUrls).then(o.styleSerial = null) : h.registerStyle(g, o.styleSerial, o.registerUrls).then((b) => {
        var M;
        o.styleSerial = b;
        const T = (M = n == null ? void 0 : n.bgLayer) == null ? void 0 : M.id;
        (n == null ? void 0 : n.bgLayer) && T !== void 0 && b !== void 0 && (a.applyOnBgLayer(e, (I) => {
          I.set(
            "xyz_custom",
            h.getDefaultMapBoxStyleXYZ(b)
          );
        }), a.setBgLayer(
          e,
          n == null ? void 0 : n.bgLayer,
          o.bgVectorSources
        ));
      }), a.applyOnBgLayer(
        e,
        (b) => h.applyConsolidatedStyle(b, g)
      );
    }), Pn(
      () => o.bgVectorSources,
      (g) => {
        var b;
        for (const T of g.keys())
          (!this.previousVectorSources || this.previousVectorSources.get(T) !== g.get(T)) && (a.removeFromCache(T), T === ((b = n == null ? void 0 : n.bgLayer) == null ? void 0 : b.id) && a.setBgLayer(e, n == null ? void 0 : n.bgLayer, g));
        this.previousVectorSources = g;
      }
    );
  }
}
const MF = {
  0: 8,
  1: 9,
  2: 9,
  3: 10,
  4: 11,
  5: 12,
  6: 13,
  7: 14,
  8: 16,
  9: 17,
  10: 18,
  11: 19,
  12: 20,
  13: 21
};
class IF {
  bootstrap() {
    this.restore(), this.persist();
  }
  persistZoom() {
    const e = Vl().getOlMap().getView(), n = () => {
      const o = e.getZoom();
      Cr.setValue(Y2, o ? Math.ceil(o) : null);
    };
    n(), Lb.listen(
      e,
      "change:resolution",
      W2(n, 300)
    );
  }
  persistXY() {
    const e = Vl().getOlMap().getView(), n = () => {
      const o = e.getCenter();
      Cr.setValue(J2, o ? Math.round(o[0]) : null), Cr.setValue(Q2, o ? Math.round(o[1]) : null);
    };
    n(), Lb.listen(
      e,
      DC.PROPERTYCHANGE,
      W2(n, 300)
    );
  }
  persist() {
    this.persistXY(), this.persistZoom();
  }
  restore() {
    const e = Vl().getOlMap().getView(), n = Cr.getValue(Y2, Cf), o = Cr.getInitialVersion(), s = Cr.getValue(J2, Cf), h = Cr.getValue(Q2, Cf), a = Cr.getValue(X6), m = EC(
      i5,
      yd
    );
    let g, b;
    n !== void 0 ? b = o === 3 ? Number(n) : MF[n] : b = 8, s != null && h != null ? o === 3 && a != null ? g = kb([s, h], a, yd) : g = o === 3 ? [s, h] : m([h, s], void 0, 2) : g = kb(
      [6, 49.7],
      zT,
      yd
    ), e.setCenter(g), e.setZoom(b);
  }
}
const OF = new IF(), CF = {
  key: 0,
  class: "absolute bottom-0 z-10 text-[0.8em] px-[4px] text-[#6b818f] bg-[#ffffffb3]"
}, AF = /* @__PURE__ */ ar({
  __name: "attribution-control",
  setup(t) {
    const e = Ei(), n = _r("");
    return va(() => {
      var o, s;
      n.value = ((s = (o = e.bgLayer) == null ? void 0 : o.metadata) == null ? void 0 : s.attribution) || "";
    }), (o, s) => {
      const h = L1("dompurify-html");
      return n.value ? Mg((Ve(), it("div", CF, null, 512)), [
        [h, n.value]
      ]) : Je("v-if", !0);
    };
  }
}), PF = /* @__PURE__ */ ur(AF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/attribution-control.vue"]]);
function nm(t, e) {
  const n = new t(e), o = Vl(), s = Sf("olMap");
  return _a(() => {
    s.addControl(n), s.changed();
  }), Gu(() => {
    const h = o.getOlMap();
    h.removeControl(n), h.changed();
  }), {
    control: n
  };
}
const kF = ["title"], LF = /* @__PURE__ */ ar({
  __name: "location-control",
  props: {
    className: { type: String, required: !1, default: "location-button" },
    label: { type: String, required: !1, default: "\uE800" },
    tipLabel: { type: String, required: !1, default: "Location" }
  },
  setup(t) {
    const e = t, { t: n } = En(), o = _r(null);
    function s() {
    }
    return _a(
      () => nm(kE, { ...e, target: o })
    ), (h, a) => (Ve(), it("div", {
      ref_key: "controlElement",
      ref: o,
      class: Pr(`tracker-off ${e.className} ${se(AE)} ${se(PE)}`)
    }, [
      ze("button", {
        title: se(n)(e.tipLabel),
        onClick: s
      }, Gt(e.label), 9, kF)
    ], 2));
  }
}), DF = /* @__PURE__ */ ur(LF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/location-control.vue"]]), NF = ["title"], RF = /* @__PURE__ */ ar({
  __name: "map-3d",
  props: {
    className: { type: String, required: !1, default: "map-3d-button" },
    label: { type: String, required: !1, default: "\uE057" },
    tipLabel: { type: String, required: !1, default: "3d" }
  },
  setup(t) {
    const e = t, n = Ei(), { t: o } = En(), s = _r(null);
    _a(
      () => nm(kE, { ...e, target: s })
    );
    const h = () => {
      n.setIs3dActive(!n.is3dActive);
    };
    return (a, m) => (Ve(), it("div", {
      ref_key: "controlElement",
      ref: s,
      class: Pr(`${e.className} ${se(AE)} ${se(PE)} ${se(n).is3dActive ? "active" : ""}`)
    }, [
      ze("button", {
        title: se(o)(e.tipLabel),
        onClick: h
      }, Gt(e.label), 9, NF)
    ], 2));
  }
}), zF = /* @__PURE__ */ ur(RF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/map-3d.vue"]]), FF = /* @__PURE__ */ ar({
  __name: "fullscreen-control",
  props: {
    className: { type: String, required: !1 },
    label: { type: String, required: !1, default: "\uE01C" },
    labelActive: { type: String, required: !1, default: "\uE02C" }
  },
  setup(t) {
    return nm(NC, t), (n, o) => Je("v-if", !0);
  }
}), BF = /* @__PURE__ */ ur(FF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/fullscreen-control.vue"]]), VF = /* @__PURE__ */ ar({
  __name: "zoom-control",
  props: {
    className: { type: String, required: !1 },
    zoomInLabel: { type: String, required: !1, default: "\uE032" },
    zoomOutLabel: { type: String, required: !1, default: "\uE033" }
  },
  setup(t) {
    return nm(RC, t), (n, o) => Je("v-if", !0);
  }
}), UF = /* @__PURE__ */ ur(VF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/zoom-control.vue"]]);
class jF extends zC {
  constructor(n) {
    super(n);
    bi(this, "ol3dm");
  }
  handleZoomToExtent() {
    this.ol3dm && this.ol3dm.luxCameraExtentInRadians && this.ol3dm.is3dEnabled() || super.handleZoomToExtent();
  }
}
const GF = /* @__PURE__ */ ar({
  __name: "zoom-to-extent-control",
  props: {
    className: { type: String, required: !1 },
    label: { type: String, required: !1, default: "\uE01B" },
    tipLabel: { type: String, required: !1 },
    extent: { type: null, required: !0 }
  },
  setup(t) {
    return nm(jF, t), (n, o) => Je("v-if", !0);
  }
}), $F = /* @__PURE__ */ ur(GF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/zoom-to-extent-control.vue"]]), qF = /* @__PURE__ */ ar({
  __name: "map-container",
  props: {
    v4_standalone: { type: Boolean, required: !1, default: !1 }
  },
  setup(t) {
    const e = Vl(), n = _r(null), o = e.createMap(), s = [
      425152.9429259216,
      632446599999133e-8,
      914349.9239510496,
      6507914867875754e-9
    ];
    return _a(() => {
      n.value && (new TF(o), OF.bootstrap(), o.setTarget(n.value), window.olMap = o);
    }), xS("olMap", o), (h, a) => (Ve(), it("div", {
      id: "map-container",
      ref_key: "mapContainer",
      ref: n,
      class: "h-full w-full bg-white relative"
    }, [
      Ft(UF),
      Ft($F, { extent: s }),
      Ft(BF),
      Ft(PF),
      t.v4_standalone ? (Ve(), on(zF, { key: 0 })) : Je("v-if", !0),
      Ft(DF)
    ], 512));
  }
}), WF = /* @__PURE__ */ ur(qF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map/map-container.vue"]]), HF = "fr", ZF = !0, XF = !1, KF = !1, ki = ih(
  "app",
  () => {
    const t = _r(HF), e = _r(ZF), n = _r(XF), o = _r(KF), s = _r(), h = _r(), a = _r(!1);
    function m(V) {
      t.value = V;
    }
    function g(V) {
      e.value = V, V || (o.value = !1, n.value = !1);
    }
    function b(V) {
      n.value = V, V && (o.value = !1);
    }
    function T(V) {
      o.value = V;
    }
    function M(V) {
      h.value = V;
    }
    function I(V) {
      s.value = V;
    }
    function P() {
      a.value = !0;
    }
    function z() {
      a.value = !1;
    }
    return {
      lang: t,
      layersOpen: e,
      myLayersTabOpen: n,
      themeGridOpen: o,
      mapId: s,
      styleEditorOpen: a,
      remoteLayersOpen: h,
      setLang: m,
      setLayersOpen: g,
      setMyLayersTabOpen: b,
      setThemeGridOpen: T,
      setRemoteLayersOpen: M,
      setMapId: I,
      openStyleEditorPanel: P,
      closeStyleEditorPanel: z
    };
  },
  {}
), Kg = {
  name: "blank",
  id: 0
};
function iI() {
  const t = ki(), { mapId: e } = xn(t), n = Xc(), o = Ei(), s = hs(), h = or(() => {
    var M;
    if (!e.value) {
      const I = (M = Ro().theme) == null ? void 0 : M.name;
      if (I)
        return ss().bg_layer_theme_defaults[I] || g();
    }
    return g();
  });
  function a(M) {
    const I = n.findBgLayerById(M);
    m(I || null);
  }
  function m(M) {
    if (M) {
      if (M.type === "WMTS" || M.type === "BG WMTS")
        M.type = "BG WMTS";
      else if (M.type === "BG MVT")
        console.log(`passed through MVT layer ${M.name}`);
      else
        throw new Error(
          `Only WMTS and MVT BG layers are currently implemented (not ${M.type} for ${M.name})`
        );
      s.handleExclusionLayers(M), o.setBgLayer(s.initLayer(M));
    } else
      o.setBgLayer(null);
  }
  function g() {
    var M;
    return ((M = T().find((I) => I.is_default)) == null ? void 0 : M.id) || Kg.id;
  }
  function b() {
    return Kg.id;
  }
  function T() {
    return ss().bg_layers;
  }
  return {
    setBgLayer: a,
    setMapBackground: m,
    getBgLayersFromConfig: T,
    getNullId: b,
    getDefaultSelectedId: g,
    defaultSelectedBgId: h
  };
}
const YF = ["title"], JF = /* @__PURE__ */ ar({
  __name: "background-selector-item",
  props: {
    bgTitle: {
      type: String,
      default: ""
    },
    bgName: {
      type: String,
      default: ""
    }
  },
  setup(t) {
    const e = t, { t: n } = En(), o = or(() => {
      const h = n(e.bgTitle), a = e.bgTitle.length > 0, m = `${n("Background layer:")} ${n(e.bgName)}`;
      return `${h}${a ? " - " : ""}${m}`;
    }), s = or(
      () => `h-full w-full rounded-sm lux-bg-sel-icon
        lux-bg-sel-${e.bgName}
        bg-${e.bgName}_sm
        md:bg-${e.bgName}
        hd:bg-${e.bgName}_sm_hi
        hd_md:bg-${e.bgName}_hi`
    );
    return (h, a) => (Ve(), it("button", {
      title: se(o),
      class: Pr(se(s))
    }, null, 10, YF));
  }
}), iE = /* @__PURE__ */ ur(JF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/background-selector/background-selector-item.vue"]]), QF = {
  key: 0,
  class: "flex flex-row-reverse"
}, eB = /* @__PURE__ */ ar({
  __name: "background-selector",
  props: {
    isOpen: {
      type: Boolean,
      default: !1
    }
  },
  setup(t) {
    const e = t, { t: n } = En(), o = iI(), s = Ei(), h = Ro(), { bgLayer: a, is3dMesh: m } = xn(s), g = _r(e.isOpen), b = _r([]), T = or(
      () => {
        var z, V;
        return (V = (z = a.value) == null ? void 0 : z.id) != null ? V : o.getNullId();
      }
    ), M = or(
      () => {
        var z, V;
        return (V = (z = b.value) == null ? void 0 : z.find((q) => q.id === T.value)) == null ? void 0 : V.name;
      }
    );
    Pn(
      () => h.bgLayers,
      (z) => {
        b.value = ss().bg_layers.map(
          (V) => Object.assign(
            {
              id: V.id
            },
            z.find((q) => V.id === q.id),
            {
              name: V.icon_id
            }
          )
        );
      },
      { immediate: !0 }
    ), Pn(
      () => s.bgLayer,
      (z, V) => {
        const q = s.layers;
        V === void 0 && z === null && (q == null ? void 0 : q.length) === 0 && (o.setBgLayer(o.defaultSelectedBgId.value), z === null && zg().addNotification(
          n(
            "Aucune couche n'\xE9tant d\xE9finie pour cette carte, une couche de fond a automatiquement \xE9t\xE9 ajout\xE9e.",
            { ns: "client" }
          )
        ));
      }
    );
    function I(z) {
      o.setBgLayer(z.id), g.value = !1;
    }
    function P() {
      g.value = !g.value;
    }
    return (z, V) => se(m) ? Je("v-if", !0) : (Ve(), it("div", QF, [
      ze("div", {
        class: Pr(["lux-bg-sel border border-black", g.value === !0 ? "hidden" : "block"])
      }, [
        Ft(iE, {
          "aria-expanded": g.value,
          "bg-title": "Select BG layer",
          "bg-name": se(M),
          onClick: P
        }, null, 8, ["aria-expanded", "bg-name"])
      ], 2),
      ze("div", {
        class: Pr(g.value === !0 ? "flex flex-col md:flex-row" : "hidden")
      }, [
        (Ve(!0), it(cn, null, Ra(b.value, (q) => (Ve(), it("div", {
          key: q.id,
          class: Pr([
            "lux-bg-sel hover:bg-cyan-600",
            q.id === se(T) ? "border-red-500 border-2" : "border-black border"
          ])
        }, [
          Ft(iE, {
            "bg-name": q.name,
            onClick: (re) => I(q)
          }, null, 8, ["bg-name", "onClick"])
        ], 2))), 128))
      ], 2)
    ]));
  }
}), tB = /* @__PURE__ */ ur(eB, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/background-selector/background-selector.vue"]]), rB = /* @__PURE__ */ ze("div", { class: "fixed inset-0 bg-gray-900 opacity-40 z-[1050]" }, null, -1), nB = { class: "bg-white shadow-modal rounded-lg overflow-hidden w-[700px]" }, iB = { class: "relative flex flex-row justify-center p-4 border-b-[1px]" }, oB = { class: "text-xl" }, aB = /* @__PURE__ */ ze("span", { "aria-hidden": "true" }, "\xD7", -1), sB = [
  aB
], lB = {
  key: 0,
  class: "p-[15px] border-t-[1px]"
}, uB = { class: "flex flex-row justify-end" }, cB = /* @__PURE__ */ ar({
  __name: "modal-dialog",
  props: {
    footer: {
      type: Boolean,
      default: !0
    },
    maxHeight: {
      type: Boolean,
      default: !1
    },
    title: String
  },
  emits: ["close"],
  setup(t) {
    const { t: e } = En(), n = _r();
    _a(() => {
      n.value.focus();
    });
    const o = Bn(!0);
    function s() {
      o.value = !1;
    }
    return (h, a) => (Ve(), on(BS, { to: "body" }, [
      Je(" backdrop "),
      rB,
      Je(" modal "),
      Ft(Ev, {
        appear: "",
        "enter-active-class": "duration-200 ease-out",
        "enter-from-class": "transform opacity-0 -translate-y-60",
        "enter-to-class": "opacity-100 translate-y-0",
        "leave-active-class": "duration-200 ease-in",
        "leave-from-class": "opacity-100 translate-y-0",
        "leave-to-class": "transform opacity-0 -translate-y-60",
        onAfterLeave: a[3] || (a[3] = (m) => h.$emit("close"))
      }, {
        default: Ud(() => [
          se(o) ? (Ve(), it("div", {
            key: 0,
            role: "dialog",
            ref_key: "modal",
            ref: n,
            tabindex: "0",
            onKeydown: a[2] || (a[2] = Gs(js((m) => s(), ["stop"]), ["esc"])),
            class: "fixed inset-x-0 inset-y-8 flex items-start justify-center z-[1100] outline-none"
          }, [
            ze("div", nB, [
              Je(" header (title)"),
              ze("div", iB, [
                ze("h4", oB, Gt(t.title), 1),
                ze("button", {
                  type: "button",
                  class: "absolute right-2 top-1 text-slate-400 text-[24px]",
                  "data-dismiss": "modal",
                  "aria-label": "Close",
                  onClick: a[0] || (a[0] = (m) => s())
                }, sB)
              ]),
              Je(" content slot "),
              ze("div", {
                class: Pr(["p-[15px] overflow-y-auto", t.maxHeight ? "max-h-96" : "max-h-full"])
              }, [
                kP(h.$slots, "content")
              ], 2),
              Je(" footer (optional)"),
              t.footer ? (Ve(), it("div", lB, [
                ze("div", uB, [
                  ze("button", {
                    type: "button",
                    class: "lux-btn",
                    "data-dismiss": "modal",
                    onClick: a[1] || (a[1] = (m) => s())
                  }, Gt(se(e)("Close", { ns: "client" })), 1)
                ])
              ])) : Je("v-if", !0)
            ])
          ], 544)) : Je("v-if", !0)
        ]),
        _: 3
      })
    ]));
  }
}), oI = /* @__PURE__ */ ur(cB, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/modal-dialog.vue"]]), tx = ih(
  "metadata",
  () => {
    const t = _r();
    function e(o) {
      t.value = o;
    }
    function n() {
      t.value = void 0;
    }
    return {
      metadataId: t,
      setMetadataId: e,
      clearMetadataId: n
    };
  },
  {}
), hB = {
  class: "mb-px",
  key: "node.id"
}, fB = ["aria-expanded", "data-cy"], pB = { class: "leading-6" }, dB = ["aria-expanded", "data-cy"], mB = { class: "grow" }, yB = { class: "leading-6" }, gB = {
  key: 1,
  class: "flex text-tertiary pr-2"
}, vB = ["data-cy"], _B = { class: "ml-1 hover:underline" }, xB = /* @__PURE__ */ ar({
  __name: "layer-tree-node",
  props: {
    node: { type: null, required: !0 }
  },
  emits: ["toggleLayer", "toggleParent"],
  setup(t, { emit: e }) {
    const n = t, { t: o } = En(), { setMetadataId: s } = tx(), h = !!n.node.children, a = n.node.depth === 0, m = n.node.depth >= 10, g = or(() => o(n.node.name, { ns: "client" }));
    function b(M) {
      e("toggleLayer", M);
    }
    function T(M) {
      e("toggleParent", M);
    }
    return (M, I) => {
      const P = AP("layer-tree-node", !0);
      return h ? (Ve(), it("div", hB, [
        Je("    First level parents"),
        t.node.depth === 1 ? (Ve(), it("button", {
          key: 0,
          class: "group node-1 w-full text-left flex px-2 py-1.5 uppercase bg-tertiary",
          "aria-expanded": t.node.expanded,
          onClick: I[0] || (I[0] = (z) => T(t.node)),
          "data-cy": `parentLayerLabel-${t.node.id}`
        }, [
          ze("div", {
            class: Pr(["grow", t.node.expanded ? "text-white" : "text-secondary"])
          }, Gt(se(g)), 3),
          ze("div", pB, [
            ze("div", {
              class: Pr(["fa fa-sharp fa-solid group-hover:text-white text-primary", t.node.expanded ? "fa-caret-up" : "fa-caret-down"])
            }, null, 2)
          ])
        ], 8, fB)) : t.node.depth > 1 && !m ? (Ve(), it(cn, { key: 1 }, [
          Je("    Other parents"),
          ze("button", {
            class: Pr(["w-full text-left flex px-2 py-1.5 pl-2", t.node.expanded ? "text-tertiary" : "bg-white text-primary"]),
            "aria-expanded": t.node.expanded,
            onClick: I[1] || (I[1] = (z) => T(t.node)),
            "data-cy": `parentLayerLabel-${t.node.id}`
          }, [
            ze("div", mB, Gt(se(g)), 1),
            ze("div", yB, [
              ze("div", {
                class: Pr(["fa-sharp fa-solid", t.node.expanded ? "fa-minus" : "fa-plus"])
              }, null, 2)
            ])
          ], 10, dB)
        ], 2112)) : Je("v-if", !0),
        Je("    Children"),
        m ? Je("v-if", !0) : (Ve(), it("div", {
          key: 2,
          class: Pr(["bg-secondary", [
            { "pl-2": t.node.depth > 1 },
            { "lux-collapse": !a },
            { expanded: !a && t.node.expanded }
          ]])
        }, [
          (Ve(!0), it(cn, null, Ra(t.node.children, (z) => (Ve(), on(P, {
            key: z.id,
            node: z,
            onToggleParent: I[2] || (I[2] = (V) => T(V)),
            onToggleLayer: I[3] || (I[3] = (V) => b(V))
          }, null, 8, ["node"]))), 128))
        ], 2))
      ])) : (Ve(), it("div", gB, [
        ze("button", {
          class: "self-start before:text-[.85rem] before:transform before:translate-y-[.1rem] before:inline-block before:content-['\\f129'] fa-solid fa-fw fa-fh fa-info",
          onClick: I[4] || (I[4] = (z) => se(s)(t.node.id))
        }),
        ze("button", {
          class: Pr(["w-full text-left", { "font-bold": t.node.checked }]),
          onClick: I[5] || (I[5] = (z) => b(t.node)),
          "data-cy": `layerLabel-${t.node.id}`
        }, [
          ze("i", {
            class: Pr(["fa-solid", t.node.checked ? "fa-check-square" : "fa-square"])
          }, null, 2),
          ze("span", _B, Gt(se(g)), 1)
        ], 10, vB)
      ]));
    };
  }
}), u1 = /* @__PURE__ */ ur(xB, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-tree/layer-tree-node.vue"]]);
class bB {
  toggleNode(e, n, o) {
    var s;
    return (n == null ? void 0 : n.id) === e ? {
      ...n,
      [o]: !n[o]
    } : {
      ...n,
      children: (s = n.children) == null ? void 0 : s.map(
        (h) => this.toggleNode(e, h, o)
      )
    };
  }
  updateLayers(e, n) {
    const { id: o } = e;
    if (e.children)
      return {
        ...e,
        children: e.children.map((s) => this.updateLayers(s, n))
      };
    {
      const s = !!(n != null && n.find((h) => h.id === o));
      return {
        ...e,
        checked: s
      };
    }
  }
}
const Pf = new bB();
var Na = /* @__PURE__ */ ((t) => (t.WMS = "WMS", t.WMTS = "WMTS", t))(Na || {});
class n0 {
  constructor(e, n = 0, o = !1) {
    this.message = e, this.httpStatus = n, this.isCrossOriginRelated = o;
  }
}
let wB = 0;
function EB() {
  return wB++;
}
function SB(t, e, n) {
  return new Promise((o, s) => {
    const h = EB(), a = {
      requestId: h,
      taskName: t,
      params: n
    };
    e === null ? window.dispatchEvent(
      new CustomEvent("ogc-client.request", {
        detail: a
      })
    ) : e.postMessage(a);
    const m = ({ detail: g, data: b }) => {
      const T = g || b;
      T.requestId === h && (e === null ? window.removeEventListener("message", m) : e.removeEventListener("message", m), "error" in T ? s(T.error) : o(T.response));
    };
    e === null ? window.addEventListener("ogc-client.response", m) : e.addEventListener("message", m);
  });
}
function rx(t, e, n) {
  const o = typeof WorkerGlobalScope < "u", s = async ({ detail: h, data: a }) => {
    const m = h || a;
    if (m.taskName === t) {
      let g, b;
      try {
        g = await n(m.params);
      } catch (M) {
        b = M;
      }
      const T = {
        taskName: t,
        requestId: m.requestId,
        ...g && { response: g },
        ...b && { error: b }
      };
      o ? e.postMessage(T) : e.dispatchEvent(
        new CustomEvent("ogc-client.response", {
          detail: T
        })
      );
    }
  };
  o ? e.addEventListener("message", s) : e.addEventListener("ogc-client.request", s);
}
let i0;
function TB() {
  return i0 || (i0 = new Worker(URL.createObjectURL(new Blob([`function t(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function e(t,e,r,n,o,i,a){try{var c=t[i](a),u=c.value}catch(t){return void r(t)}c.done?e(u):Promise.resolve(u).then(n,o)}function r(t){return function(){var r=this,n=arguments;return new Promise((function(o,i){var a=t.apply(r,n);function c(t){e(a,o,i,c,u,"next",t)}function u(t){e(a,o,i,c,u,"throw",t)}c(void 0)}))}}function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}var o={exports:{}};!function(t){var e=function(t){var e,r=Object.prototype,o=r.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function s(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{s({},"")}catch(t){s=function(t,e,r){return t[e]=r}}function f(t,e,r,n){var o=e&&e.prototype instanceof m?e:m,i=Object.create(o.prototype),a=new j(n||[]);return i._invoke=function(t,e,r){var n=h;return function(o,i){if(n===v)throw new Error("Generator is already running");if(n===d){if("throw"===o)throw i;return G()}for(r.method=o,r.arg=i;;){var a=r.delegate;if(a){var c=k(a,r);if(c){if(c===y)continue;return c}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===h)throw n=d,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=v;var u=l(t,e,r);if("normal"===u.type){if(n=r.done?d:p,u.arg===y)continue;return{value:u.arg,done:r.done}}"throw"===u.type&&(n=d,r.method="throw",r.arg=u.arg)}}}(t,r,a),i}function l(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=f;var h="suspendedStart",p="suspendedYield",v="executing",d="completed",y={};function m(){}function g(){}function b(){}var S={};S[a]=function(){return this};var E=Object.getPrototypeOf,w=E&&E(E(C([])));w&&w!==r&&o.call(w,a)&&(S=w);var O=b.prototype=m.prototype=Object.create(S);function x(t){["next","throw","return"].forEach((function(e){s(t,e,(function(t){return this._invoke(e,t)}))}))}function P(t,e){function r(i,a,c,u){var s=l(t[i],t,a);if("throw"!==s.type){var f=s.arg,h=f.value;return h&&"object"===n(h)&&o.call(h,"__await")?e.resolve(h.__await).then((function(t){r("next",t,c,u)}),(function(t){r("throw",t,c,u)})):e.resolve(h).then((function(t){f.value=t,c(f)}),(function(t){return r("throw",t,c,u)}))}u(s.arg)}var i;this._invoke=function(t,n){function o(){return new e((function(e,o){r(t,n,e,o)}))}return i=i?i.then(o,o):o()}}function k(t,r){var n=t.iterator[r.method];if(n===e){if(r.delegate=null,"throw"===r.method){if(t.iterator.return&&(r.method="return",r.arg=e,k(t,r),"throw"===r.method))return y;r.method="throw",r.arg=new TypeError("The iterator does not provide a 'throw' method")}return y}var o=l(n,t.iterator,r.arg);if("throw"===o.type)return r.method="throw",r.arg=o.arg,r.delegate=null,y;var i=o.arg;return i?i.done?(r[t.resultName]=i.value,r.next=t.nextLoc,"return"!==r.method&&(r.method="next",r.arg=e),r.delegate=null,y):i:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function R(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function T(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function j(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(R,this),this.reset(!0)}function C(t){if(t){var r=t[a];if(r)return r.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,i=function r(){for(;++n<t.length;)if(o.call(t,n))return r.value=t[n],r.done=!1,r;return r.value=e,r.done=!0,r};return i.next=i}}return{next:G}}function G(){return{value:e,done:!0}}return g.prototype=O.constructor=b,b.constructor=g,g.displayName=s(b,u,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===g||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,b):(t.__proto__=b,s(t,u,"GeneratorFunction")),t.prototype=Object.create(O),t},t.awrap=function(t){return{__await:t}},x(P.prototype),P.prototype[c]=function(){return this},t.AsyncIterator=P,t.async=function(e,r,n,o,i){void 0===i&&(i=Promise);var a=new P(f(e,r,n,o),i);return t.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},x(O),s(O,u,"Generator"),O[a]=function(){return this},O.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=C,j.prototype={constructor:j,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(T),!t)for(var r in this)"t"===r.charAt(0)&&o.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=e)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var r=this;function n(n,o){return c.type="throw",c.arg=t,r.next=n,o&&(r.method="next",r.arg=e),!!o}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],c=a.completion;if("root"===a.tryLoc)return n("end");if(a.tryLoc<=this.prev){var u=o.call(a,"catchLoc"),s=o.call(a,"finallyLoc");if(u&&s){if(this.prev<a.catchLoc)return n(a.catchLoc,!0);if(this.prev<a.finallyLoc)return n(a.finallyLoc)}else if(u){if(this.prev<a.catchLoc)return n(a.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return n(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&o.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var i=n;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),T(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;T(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,r,n){return this.delegate={iterator:C(t),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=e),y}},t}(t.exports);try{regeneratorRuntime=e}catch(t){Function("r","regeneratorRuntime = r")(e)}}(o);var i=o.exports;function a(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?a(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(t,e,n){var o="undefined"!=typeof WorkerGlobalScope,a=function(){var a=r(i.mark((function r(a){var u,s,f,l,h,p;return i.wrap((function(r){for(;;)switch(r.prev=r.next){case 0:if(u=a.detail,s=a.data,(f=u||s).taskName!==t){r.next=14;break}return r.prev=3,r.next=6,n(f.params);case 6:l=r.sent,r.next=12;break;case 9:r.prev=9,r.t0=r.catch(3),h=r.t0;case 12:p=c(c({taskName:t,requestId:f.requestId},l&&{response:l}),h&&{error:h}),o?e.postMessage(p):e.dispatchEvent(new CustomEvent("ogc-client.response",{detail:p}));case 14:case"end":return r.stop()}}),r,null,[[3,9]])})));return function(t){return a.apply(this,arguments)}}();o?e.addEventListener("message",a):e.addEventListener("ogc-client.request",a)}function s(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function f(t){return function(t){if(Array.isArray(t))return s(t)}(t)||function(t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||function(t,e){if(t){if("string"==typeof t)return s(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?s(t,e):void 0}}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function l(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function h(t,e){return h=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},h(t,e)}function p(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&h(t,e)}function v(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function d(t){return d=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},d(t)}function y(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function m(t,e,r){return m=y()?Reflect.construct:function(t,e,r){var n=[null];n.push.apply(n,e);var o=new(Function.bind.apply(t,n));return r&&h(o,r.prototype),o},m.apply(null,arguments)}function g(t){var e="function"==typeof Map?new Map:void 0;return g=function(t){if(null===t||(r=t,-1===Function.toString.call(r).indexOf("[native code]")))return t;var r;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,n)}function n(){return m(t,arguments,d(this).constructor)}return n.prototype=Object.create(t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),h(n,t)},g(t)}function b(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function S(t,e,r){return e&&b(t.prototype,e),r&&b(t,r),t}var E=function(){function t(e){l(this,t),this.chars=f(e),this.charCount=this.chars.length,this.charIndex=0,this.charsToBytes=new Array(this.charCount),this.multiByteMode=!1,this.string=e;var r=this.chars,n=this.charCount,o=this.charsToBytes;if(n===e.length)for(var i=0;i<n;++i)o[i]=i;else{for(var a=0,c=0;c<n;++c)o[c]=a,a+=r[c].length;this.multiByteMode=!0}}return S(t,[{key:"isEnd",get:function(){return this.charIndex>=this.charCount}},{key:"_charLength",value:function(t){var e=t.length;return e<2||!this.multiByteMode?e:t.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,"_").length}},{key:"advance",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.charIndex=Math.min(this.charCount,this.charIndex+t)}},{key:"consume",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=this.peek(t);return this.advance(t),e}},{key:"consumeMatch",value:function(t){if(!t.sticky)throw new Error('\`regex\` must have a sticky flag ("y")');t.lastIndex=this.charsToBytes[this.charIndex];var e=t.exec(this.string);if(null===e)return"";var r=e[0];return this.advance(this._charLength(r)),r}},{key:"consumeMatchFn",value:function(t){for(var e=this.charIndex;!this.isEnd&&t(this.peek());)this.advance();return this.charIndex>e?this.string.slice(this.charsToBytes[e],this.charsToBytes[this.charIndex]):""}},{key:"consumeString",value:function(t){if(this.consumeStringFast(t))return t;if(!this.multiByteMode)return"";var e=t.length,r=this._charLength(t);return r!==e&&t===this.peek(r)?(this.advance(r),t):""}},{key:"consumeStringFast",value:function(t){if(this.peek()===t[0]){var e=t.length;if(1===e)return this.advance(),t;if(this.peek(e)===t)return this.advance(e),t}return""}},{key:"consumeUntilMatch",value:function(t){if(!t.global)throw new Error('\`regex\` must have a global flag ("g")');var e=this.charsToBytes[this.charIndex];t.lastIndex=e;var r=t.exec(this.string);if(null===r||r.index===e)return"";var n=this.string.slice(e,r.index);return this.advance(this._charLength(n)),n}},{key:"consumeUntilString",value:function(t){var e=this.charIndex,r=this.charsToBytes,n=this.string,o=r[e],i=n.indexOf(t,o);if(i<=0)return"";var a=n.slice(o,i);return this.advance(this._charLength(a)),a}},{key:"peek",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;if(this.charIndex>=this.charCount)return"";if(1===t)return this.chars[this.charIndex];var e=this.charsToBytes,r=this.charIndex;return this.string.slice(e[r],e[r+t])}},{key:"reset",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;this.charIndex=t>=0?Math.min(this.charCount,t):Math.max(0,this.charIndex+t)}}]),t}(),w=E,O={},x=Object.freeze(Object.assign(Object.create(null),{amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}));function P(t){if(k(t))return!0;var e=T(t);return 45===e||46===e||e>=48&&e<=57||183===e||e>=768&&e<=879||e>=8255&&e<=8256}function k(t){var e=T(t);return 58===e||95===e||e>=65&&e<=90||e>=97&&e<=122||e>=192&&e<=214||e>=216&&e<=246||e>=248&&e<=767||e>=880&&e<=893||e>=895&&e<=8191||e>=8204&&e<=8205||e>=8304&&e<=8591||e>=11264&&e<=12271||e>=12289&&e<=55295||e>=63744&&e<=64975||e>=65008&&e<=65533||e>=65536&&e<=983039}function R(t){var e=T(t);return 9===e||10===e||13===e||e>=32&&e<=55295||e>=57344&&e<=65533||e>=65536&&e<=1114111}function T(t){return t.codePointAt(0)||-1}O.predefinedEntities=x,O.isNameChar=P,O.isNameStartChar=k,O.isNotXmlChar=function(t){return!R(t)},O.isReferenceChar=function(t){return"#"===t||P(t)},O.isWhitespace=function(t){var e=T(t);return 32===e||9===e||10===e||13===e},O.isXmlChar=R;var j=function(){function t(){l(this,t),this.parent=null}return S(t,[{key:"document",get:function(){return this.parent?this.parent.document:null}},{key:"isRootNode",get:function(){return!!this.parent&&this.parent===this.document}},{key:"preserveWhitespace",get:function(){return Boolean(this.parent&&this.parent.preserveWhitespace)}},{key:"type",get:function(){return""}},{key:"toJSON",value:function(){var t={type:this.type};return this.isRootNode&&(t.isRootNode=!0),this.preserveWhitespace&&(t.preserveWhitespace=!0),t}}]),t}();j.TYPE_CDATA="cdata",j.TYPE_COMMENT="comment",j.TYPE_DOCUMENT="document",j.TYPE_ELEMENT="element",j.TYPE_PROCESSING_INSTRUCTION="pi",j.TYPE_TEXT="text";var C=j;function G(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var N=C,A=function(t){p(r,N);var e=G(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).text=n,t}return S(r,[{key:"type",get:function(){return N.TYPE_TEXT}},{key:"toJSON",value:function(){return Object.assign(N.prototype.toJSON.call(this),{text:this.text})}}]),r}(),F=A;function I(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var L=C,M=F,B=function(t){p(r,M);var e=I(r);function r(){return l(this,r),e.apply(this,arguments)}return S(r,[{key:"type",get:function(){return L.TYPE_CDATA}}]),r}(),_=B;function U(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var D=C,W=function(t){p(r,D);var e=U(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).content=n,t}return S(r,[{key:"type",get:function(){return D.TYPE_COMMENT}},{key:"toJSON",value:function(){return Object.assign(D.prototype.toJSON.call(this),{content:this.content})}}]),r}(),X=W;function Y(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var q=C,J=function(t){p(r,q);var e=Y(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Object.create(null),i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return l(this,r),(n=e.call(this)).name=t,n.attributes=o,n.children=i,n}return S(r,[{key:"isEmpty",get:function(){return 0===this.children.length}},{key:"preserveWhitespace",get:function(){for(var t=this;t instanceof r;){if("xml:space"in t.attributes)return"preserve"===t.attributes["xml:space"];t=t.parent}return!1}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return q.TYPE_ELEMENT}},{key:"toJSON",value:function(){return Object.assign(q.prototype.toJSON.call(this),{name:this.name,attributes:this.attributes,children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),V=J;function $(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var K=V,z=C,H=function(t){p(r,z);var e=$(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return l(this,r),(t=e.call(this)).children=n,t}return S(r,[{key:"document",get:function(){return this}},{key:"root",get:function(){return this.children.find((function(t){return t instanceof K}))||null}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return z.TYPE_DOCUMENT}},{key:"toJSON",value:function(){return Object.assign(z.prototype.toJSON.call(this),{children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),Q=H;function Z(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var tt=C,et=function(t){p(r,tt);var e=Z(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return l(this,r),(n=e.call(this)).name=t,n.content=o,n}return S(r,[{key:"type",get:function(){return tt.TYPE_PROCESSING_INSTRUCTION}},{key:"toJSON",value:function(){return Object.assign(tt.prototype.toJSON.call(this),{name:this.name,content:this.content})}}]),r}(),rt=et;function nt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return ot(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return ot(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function ot(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var it=w,at=O,ct=_,ut=X,st=Q,ft=V,lt=rt,ht=F,pt=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(l(this,t),this.document=new st,this.currentNode=this.document,this.options=r,this.scanner=new it(vt(e)),this.consumeProlog(),this.consumeElement()||this.error("Root element is missing or invalid");this.consumeMisc(););this.scanner.isEnd||this.error("Extra content at the end of the document")}return S(t,[{key:"addNode",value:function(t){t.parent=this.currentNode,this.currentNode.children.push(t)}},{key:"addText",value:function(t){var e=this.currentNode.children;if(e.length>0){var r=e[e.length-1];if(r instanceof ht)return void(r.text+=t)}this.addNode(new ht(t))}},{key:"consumeAttributeValue",value:function(){var t,e=this.scanner,r=e.peek();if('"'!==r&&"'"!==r)return!1;e.advance();var n=!1,o="",i='"'===r?new RegExp('[^"&<]+',"y"):new RegExp("[^'&<]+","y");t:for(;!e.isEnd;){switch((t=e.consumeMatch(i))&&(this.validateChars(t),o+=t.replace(/[\\t\\r\\n]/g," ")),e.peek()){case r:n=!0;break t;case"&":o+=this.consumeReference();continue;case"<":this.error("Unescaped \`<\` is not allowed in an attribute value");break;case"":this.error("Unclosed attribute")}}return n||this.error("Unclosed attribute"),e.advance(),o}},{key:"consumeCdataSection",value:function(){var t=this.scanner;if(!t.consumeStringFast("<![CDATA["))return!1;var e=t.consumeUntilString("]]>");return this.validateChars(e),t.consumeStringFast("]]>")||this.error("Unclosed CDATA section"),this.options.preserveCdata?this.addNode(new ct(e)):this.addText(e),!0}},{key:"consumeCharData",value:function(){var t=this.scanner,e=t.consumeUntilMatch(/<|&|]]>/g);return!!e&&(this.validateChars(e),"]"===t.peek()&&"]]>"===t.peek(3)&&this.error("Element content may not contain the CDATA section close delimiter \`]]>\`"),this.addText(e),!0)}},{key:"consumeComment",value:function(){var t=this.scanner;if(!t.consumeStringFast("\\x3c!--"))return!1;var e=t.consumeUntilString("--");return this.validateChars(e),t.consumeStringFast("--\\x3e")||("--"===t.peek(2)?this.error("The string \`--\` isn't allowed inside a comment"):this.error("Unclosed comment")),this.options.preserveComments&&this.addNode(new ut(e.trim())),!0}},{key:"consumeContentReference",value:function(){var t=this.consumeReference();return!!t&&(this.addText(t),!0)}},{key:"consumeDoctypeDeclaration",value:function(){var t=this.scanner;return!(!t.consumeStringFast("<!DOCTYPE")||!this.consumeWhitespace())&&(t.consumeMatch(new RegExp("[^[>]+","y")),t.consumeMatch(new RegExp("\\\\[[\\\\s\\\\S]+?\\\\][\\\\x20\\\\t\\\\r\\\\n]*>","y"))||t.consumeStringFast(">")||this.error("Unclosed doctype declaration"),!0)}},{key:"consumeElement",value:function(){var t=this.scanner,e=t.charIndex;if("<"!==t.peek())return!1;t.advance();var r=this.consumeName();if(!r)return t.reset(e),!1;for(var n=Object.create(null);this.consumeWhitespace();){var o=this.consumeName();if(o){var i=this.consumeEqual()&&this.consumeAttributeValue();!1===i&&this.error("Attribute value expected"),o in n&&this.error("Duplicate attribute: ".concat(o)),"xml:space"===o&&"default"!==i&&"preserve"!==i&&this.error('Value of the \`xml:space\` attribute must be "default" or "preserve"'),n[o]=i}}if(this.options.sortAttributes){for(var a=Object.keys(n).sort(),c=Object.create(null),u=0;u<a.length;++u){var s=a[u];c[s]=n[s]}n=c}var f=Boolean(t.consumeStringFast("/>")),l=new ft(r,n);if(l.parent=this.currentNode,!f){for(t.consumeStringFast(">")||this.error("Unclosed start tag for element \`".concat(r,"\`")),this.currentNode=l,this.consumeCharData();this.consumeElement()||this.consumeContentReference()||this.consumeCdataSection()||this.consumeProcessingInstruction()||this.consumeComment();)this.consumeCharData();var h,p=t.charIndex;t.consumeStringFast("</")&&(h=this.consumeName())&&h===r||(t.reset(p),this.error("Missing end tag for element ".concat(r))),this.consumeWhitespace(),t.consumeStringFast(">")||this.error("Unclosed end tag for element ".concat(r)),this.currentNode=l.parent}return this.addNode(l),!0}},{key:"consumeEqual",value:function(){return this.consumeWhitespace(),!!this.scanner.consumeStringFast("=")&&(this.consumeWhitespace(),!0)}},{key:"consumeMisc",value:function(){return this.consumeComment()||this.consumeProcessingInstruction()||this.consumeWhitespace()}},{key:"consumeName",value:function(){return at.isNameStartChar(this.scanner.peek())?this.scanner.consumeMatchFn(at.isNameChar):""}},{key:"consumeProcessingInstruction",value:function(){var t=this.scanner,e=t.charIndex;if(!t.consumeStringFast("<?"))return!1;var r=this.consumeName();if(r?"xml"===r.toLowerCase()&&(t.reset(e),this.error("XML declaration isn't allowed here")):this.error("Invalid processing instruction"),!this.consumeWhitespace()){if(t.consumeStringFast("?>"))return this.addNode(new lt(r)),!0;this.error("Whitespace is required after a processing instruction name")}var n=t.consumeUntilString("?>");return this.validateChars(n),t.consumeStringFast("?>")||this.error("Unterminated processing instruction"),this.addNode(new lt(r,n)),!0}},{key:"consumeProlog",value:function(){var t=this.scanner,e=t.charIndex;for(this.consumeXmlDeclaration();this.consumeMisc(););if(this.consumeDoctypeDeclaration())for(;this.consumeMisc(););return e<t.charIndex}},{key:"consumeReference",value:function(){var t=this.scanner;if("&"!==t.peek())return!1;t.advance();var e,r=t.consumeMatchFn(at.isReferenceChar);if(";"!==t.consume()&&this.error("Unterminated reference (a reference must end with \`;\`)"),"#"===r[0]){var o="x"===r[1]?parseInt(r.slice(2),16):parseInt(r.slice(1),10);isNaN(o)&&this.error("Invalid character reference"),e=String.fromCodePoint(o),at.isXmlChar(e)||this.error("Character reference resolves to an invalid character")}else if(void 0===(e=at.predefinedEntities[r])){var i=this.options,a=i.ignoreUndefinedEntities,c=i.resolveUndefinedEntity,u="&".concat(r,";");if(c){var s=c(u);if(null!=s){var f=n(s);if("string"!==f)throw new TypeError("\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ".concat(f));return s}}if(a)return u;t.reset(-u.length),this.error("Named entity isn't defined: ".concat(u))}return e}},{key:"consumeSystemLiteral",value:function(){var t=this.scanner,e=t.consumeStringFast('"')||t.consumeStringFast("'");if(!e)return!1;var r=t.consumeUntilString(e);return this.validateChars(r),t.consumeStringFast(e)||this.error("Missing end quote"),r}},{key:"consumeWhitespace",value:function(){return Boolean(this.scanner.consumeMatchFn(at.isWhitespace))}},{key:"consumeXmlDeclaration",value:function(){var t=this.scanner;if(!t.consumeStringFast("<?xml"))return!1;this.consumeWhitespace()||this.error("Invalid XML declaration");var e=Boolean(t.consumeStringFast("version"))&&this.consumeEqual()&&this.consumeSystemLiteral();if(!1===e?this.error("XML version is missing or invalid"):/^1\\.[0-9]+$/.test(e)||this.error("Invalid character in version number"),this.consumeWhitespace()){Boolean(t.consumeStringFast("encoding"))&&this.consumeEqual()&&this.consumeSystemLiteral()&&this.consumeWhitespace();var r=Boolean(t.consumeStringFast("standalone"))&&this.consumeEqual()&&this.consumeSystemLiteral();r&&("yes"!==r&&"no"!==r&&this.error('Only "yes" and "no" are permitted as values of \`standalone\`'),this.consumeWhitespace())}return t.consumeStringFast("?>")||this.error("Invalid or unclosed XML declaration"),!0}},{key:"error",value:function(t){for(var e=this.scanner,r=e.charIndex,n=e.string,o=1,i="",a=1,c=0;c<r;++c){var u=n[c];"\\n"===u?(o=1,i="",a+=1):(o+=1,i+=u)}var s=n.indexOf("\\n",r),f=0;(i+=-1===s?n.slice(r):n.slice(r,s)).length>50&&(o<40?i=i.slice(0,50):(f=o-20,i=i.slice(f,o+30)));var l=new Error("".concat(t," (line ").concat(a,", column ").concat(o,")\\n")+"  ".concat(i,"\\n")+" ".repeat(o-f+1)+"^\\n");throw Object.assign(l,{column:o,excerpt:i,line:a,pos:r}),l}},{key:"validateChars",value:function(t){var e,r=0,n=nt(t);try{for(n.s();!(e=n.n()).done;){var o=e.value;at.isNotXmlChar(o)&&(this.scanner.reset(-(f(t).length-r)),this.error("Invalid character")),r+=1}}catch(t){n.e(t)}finally{n.f()}}}]),t}();function vt(t){return"\\ufeff"===t[0]&&(t=t.slice(1)),t.replace(/\\r\\n?/g,"\\n")}var dt=pt,yt=_,mt=X,gt=Q,bt=V,St=C,Et=rt,wt=F;function Ot(t,e){return new dt(t,e).document}Ot.XmlCdata=yt,Ot.XmlComment=mt,Ot.XmlDocument=gt,Ot.XmlElement=bt,Ot.XmlNode=St,Ot.XmlProcessingInstruction=Et,Ot.XmlText=wt;var xt=Ot;function Pt(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var kt=function(t){p(r,g(Error));var e=Pt(r);function r(t){return l(this,r),e.call(this,t)}return r}();function Rt(t){return t.children[0]}function Tt(t){var e=t.indexOf(":");return e>-1?t.substr(e+1):t}function jt(t){return t.name||""}function Ct(t,e,r){var n=Tt(e);return t&&Array.isArray(t.children)?t.children.reduce((function t(e,o){return Tt(jt(o))===n&&e.push(o),r&&Array.isArray(o.children)?[].concat(f(e),f(o.children.reduce(t,[]))):e}),[]):[]}function Gt(t,e,r){return Ct(t,e,r)[0]||null}function Nt(t){return t&&Array.isArray(t.children)?f(t.children.filter((function(t){return"XmlElement"===t.constructor.name}))):[]}function At(t){var e=t&&Array.isArray(t.children)?t.children.find((function(t){return"text"===t.type})):null;return e?e.text:""}function Ft(t,e){return t&&t.attributes[e]||""}var It=function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];l(this,t),this.message=e,this.httpStatus=r,this.isCrossOriginRelated=n};function Lt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Mt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Mt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Mt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Bt=["utf-8","utf-16","iso-8859-1"];function _t(t,e){var r,n=e?function(t){var e=/charset=([^;]+)/.exec(t);return e?e[1]:null}(e):null,o=Lt(n?[n].concat(Bt):Bt);try{for(o.s();!(r=o.n()).done;){var i=r.value;try{return new TextDecoder(i,{fatal:!0}).decode(t)}catch(t){}}}catch(t){o.e(t)}finally{o.f()}return console.warn("XML document encoding could not be determined, falling back to ".concat("utf-8",".")),new TextDecoder("utf-8").decode(t)}function Ut(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Dt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Dt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Dt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Wt=new Map;function Xt(t){return function(t){if(Wt.has(t))return Wt.get(t);var e=fetch(t);return e.finally((function(){return Wt.delete(t)})),Wt.set(t,e),e}(t).catch((function(){return fetch(t,{method:"HEAD",mode:"no-cors"}).catch((function(t){throw new It("Fetching the document failed either due to network errors or unreachable host, error is: ".concat(t.message),0,!1)})).then((function(){throw new It("The document could not be fetched due to CORS limitations",0,!0)}))})).then(function(){var t=r(i.mark((function t(e){var r,n,o;return i.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(e.ok){t.next=5;break}return t.next=3,e.text();case 3:throw r=t.sent,new It("Received an error with code ".concat(e.status,": ").concat(r),e.status,!1);case 5:return t.next=7,e.arrayBuffer();case 7:return n=t.sent,o=e.headers.get("Content-Type"),t.abrupt("return",_t(n,o));case 10:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}()).then((function(t){return function(t){var e=null;try{e=xt(t)}catch(t){throw new kt(t.message)}return e}(t)}))}function Yt(t,e){var r=t.match(/(https?%3A%2F%2F[^/]+)$/);if(r){var n=r[1],o=Yt(decodeURIComponent(n),e);return t.replace(n,encodeURIComponent(o))}var i,a=new URL(t),c=Object.keys(e),u=c.map((function(t){return t.toLowerCase()})),s=[],f=Ut(a.searchParams.keys());try{for(f.s();!(i=f.n()).done;){var l=i.value;u.indexOf(l.toLowerCase())>-1&&s.push(l)}}catch(t){f.e(t)}finally{f.f()}return s.map((function(t){return a.searchParams.delete(t)})),c.forEach((function(t){return a.searchParams.set(t,!0===e[t]?"":e[t])})),a.toString()}var qt=["EPSG:4046","EPSG:4075","EPSG:4120","EPSG:4122","EPSG:4124","EPSG:4126","EPSG:4149","EPSG:4151","EPSG:4153","EPSG:4155","EPSG:4157","EPSG:4159","EPSG:4161","EPSG:4163","EPSG:4165","EPSG:4167","EPSG:4169","EPSG:4171","EPSG:4173","EPSG:4175","EPSG:4178","EPSG:4180","EPSG:4182","EPSG:4184","EPSG:4188","EPSG:4190","EPSG:4191","EPSG:4196","EPSG:4198","EPSG:4202","EPSG:4210","EPSG:4211","EPSG:4214","EPSG:4226","EPSG:4229","EPSG:4231","EPSG:4233","EPSG:4236","EPSG:4238","EPSG:4240","EPSG:4242","EPSG:4244","EPSG:4246","EPSG:4248","EPSG:4250","EPSG:4252","EPSG:4255","EPSG:4258","EPSG:4261","EPSG:4264","EPSG:4267","EPSG:4270","EPSG:4273","EPSG:4276","EPSG:4279","EPSG:4281","EPSG:4284","EPSG:4286","EPSG:4288","EPSG:4292","EPSG:4295","EPSG:4297","EPSG:4299","EPSG:4302","EPSG:4324","EPSG:4326"];function Jt(t){return qt.indexOf(Vt(t))>-1}function Vt(t){if(/^urn:(?:x-)?ogc:def:crs:epsg:/.test(t.toLowerCase())){var e=/([0-9]+)$/.exec(t)[1];return"EPSG:".concat(e)}return t}function $t(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function Kt(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?$t(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):$t(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function zt(t){return Rt(t).attributes.version}function Ht(t){var e=zt(t);return Ct(Gt(Rt(t),"Capability"),"Layer").map((function(t){return Qt(t,e)}))}function Qt(e,r){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a="1.3.0"===r?"CRS":"SRS",c=Ct(e,a).map(At),u=c.length>0?c:n,s=Ct(e,"Style").map(Zt),f=s.length>0?s:o;function l(t){return(Jt(Ft(t,a))&&"1.3.0"===r?["miny","minx","maxy","maxx"]:["minx","miny","maxx","maxy"]).map((function(e){return Ft(t,e)}))}var h=Gt(e,"Attribution"),p=null!==h?te(h):i,v=Ct(e,"Layer").map((function(t){return Qt(t,r,u,f,p)}));return Kt({name:At(Gt(e,"Name")),title:At(Gt(e,"Title")),abstract:At(Gt(e,"Abstract")),availableCrs:u,styles:f,attribution:p,boundingBoxes:Ct(e,"BoundingBox").reduce((function(e,r){return Kt(Kt({},e),{},t({},Ft(r,a),l(r)))}),{})},v.length&&{children:v})}function Zt(t){var e=Ft(Gt(Gt(t,"LegendURL"),"OnlineResource"),"xlink:href");return Kt({name:At(Gt(t,"Name")),title:At(Gt(t,"Title"))},e&&{legendUrl:e})}function te(t){var e=Ft(Gt(Gt(t,"LogoURL"),"OnlineResource"),"xlink:href"),r=Ft(Gt(t,"OnlineResource"),"xlink:href"),n=At(Gt(t,"Title"));return Kt(Kt(Kt({},n&&{title:n}),r&&{url:r}),e&&{logoUrl:e})}function ee(t){return Rt(t).attributes.version}function re(t){var e;if(ee(t).startsWith("1.0")){var r=Gt(Gt(Gt(Rt(t),"Capability"),"Request"),"GetFeature");e=Nt(Gt(r,"ResultFormat")).map(jt)}else{var n=Ct(Gt(Rt(t),"OperationsMetadata"),"Operation").find((function(t){return"GetFeature"===Ft(t,"name")})),o=Ct(n,"Parameter").find((function(t){return"outputFormat"===Ft(t,"name")}));e=Ct(o,"Value",!0).map(At)}return e}function ne(t){var e=ee(t),r=re(t);return Ct(Gt(Rt(t),"FeatureTypeList"),"FeatureType").map((function(t){return function(t,e,r){var n=e.startsWith("2.")?"CRS":"SRS",o=e.startsWith("1.0")?"SRS":"Default".concat(n);function i(){var e=Gt(t,"LatLongBoundingBox");return["minx","miny","maxx","maxy"].map((function(t){return Ft(e,t)})).map(parseFloat)}function a(){var e=Gt(t,"WGS84BoundingBox");return["LowerCorner","UpperCorner"].map((function(t){return Gt(e,t)})).map((function(t){return At(t).split(" ")})).reduce((function(t,e){return[].concat(f(t),f(e))})).map(parseFloat)}var c=e.startsWith("1.0")?[]:Ct(t,"Other".concat(n)).map(At).map(Vt),u=e.startsWith("1.0")?[]:Ct(Gt(t,"OutputFormats"),"Format").map(At);return{name:At(Gt(t,"Name")),title:At(Gt(t,"Title")),abstract:At(Gt(t,"Abstract")),defaultCrs:Vt(At(Gt(t,o))),otherCrs:c,outputFormats:u.length>0?u:r,latLonBoundingBox:e.startsWith("1.0")?i():a()}}(t,e,r)}))}function oe(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function ie(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?oe(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):oe(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ae(e,r,n){var o,i=Rt(e);if(n.startsWith("2.0"))o=Ct(i,"member").map((function(t){return Nt(t)[0]}));else{var a=Gt(i,"featureMembers");o=a?Nt(a):Ct(i,"featureMember").map((function(t){return Nt(t)[0]}))}var c="1.0.0"===n?"fid":"gml:id";function u(e){return Nt(e).filter((function(t){return Tt(jt(t))in r.properties})).reduce((function(e,n){var o=Tt(jt(n));return ie(ie({},e),{},t({},o,function(t,e){switch(r.properties[t]){case"integer":return parseInt(e);case"float":return parseFloat(e);case"boolean":return"true"===e;default:return e}}(o,At(n))))}),{})}return o.map((function(t){return{id:Ft(t,c),properties:u(t)}}))}function ce(e,r,n,o,i,a,c,u,s,f){var l="2.0.0"===r?"COUNT":"MAXFEATURES",h=t({SERVICE:"WFS",REQUEST:"GetFeature",VERSION:r},"2.0.0"===r?"TYPENAMES":"TYPENAME",n);if(void 0!==o&&(h.OUTPUTFORMAT=o),void 0!==a&&(h.PROPERTYNAME=a.join(",")),c?(h.RESULTTYPE="hits",h[l]="1"):void 0!==i&&(h[l]=i.toString(10)),u&&(h.SRSNAME=u),s){var p=s.join(",");h.BBOX=f?"".concat(p,",").concat(f):p}return Yt(e,h)}u("parseWmsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,r=Gt(Rt(e),"Service"),n=Ct(Gt(r,"KeywordList"),"Keyword").map(At).filter((function(t,e,r){return r.indexOf(t)===e})),{title:At(Gt(r,"Title")),name:At(Gt(r,"Name")),abstract:At(Gt(r,"Abstract")),fees:At(Gt(r,"Fees")),constraints:At(Gt(r,"AccessConstraints")),keywords:n}),layers:Ht(t),version:zt(t)};var e,r,n}))})),u("parseWfsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,n=ee(e),o=n.startsWith("1.0")?"Service":"ServiceIdentification",i=n.startsWith("1.0")?"Name":"ServiceType",a=Gt(Rt(e),o),r=n.startsWith("1.0")?At(Gt(a,"Keywords")).split(",").map((function(t){return t.trim()})):Ct(Gt(a,"Keywords"),"Keyword").map(At),{title:At(Gt(a,"Title")),name:At(Gt(a,i)),abstract:At(Gt(a,"Abstract")),fees:At(Gt(a,"Fees")),constraints:At(Gt(a,"AccessConstraints")),keywords:r,outputFormats:re(e)}),featureTypes:ne(t),version:ee(t)};var e,r,n,o,i,a}))})),u("queryWfsFeatureTypeDetails",self,(function(t){var e=t.url,r=t.serviceVersion,n=t.featureTypeFull;return Xt(ce(e,r,n.name,void 0,void 0,Object.keys(n.properties))).then((function(t){return{props:(e=ae(t,n,r),e.reduce((function(t,e){var r=function(r){var n=e.properties[r];r in t||(t[r]={uniqueValues:[]});var o=t[r].uniqueValues.find((function(t){return t.value===n}));o?o.count++:t[r].uniqueValues.push({value:n,count:1})};for(var n in e.properties)r(n);return t}),{}))};var e}))}));
`], { type: "application/javascript" })), {
    type: "module"
  })), i0;
}
function MB(t) {
  return SB("parseWmsCapabilities", TB(), {
    url: t
  });
}
const _u = "";
class IB {
  constructor(e) {
    this.chars = [...e], this.charCount = this.chars.length, this.charIndex = 0, this.charsToBytes = new Array(this.charCount), this.multiByteMode = !1, this.string = e;
    let { chars: n, charCount: o, charsToBytes: s } = this;
    if (o === e.length)
      for (let h = 0; h < o; ++h)
        s[h] = h;
    else {
      for (let h = 0, a = 0; a < o; ++a)
        s[a] = h, h += n[a].length;
      this.multiByteMode = !0;
    }
  }
  get isEnd() {
    return this.charIndex >= this.charCount;
  }
  _charLength(e) {
    let { length: n } = e;
    return n < 2 || !this.multiByteMode ? n : e.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length;
  }
  advance(e = 1) {
    this.charIndex = Math.min(this.charCount, this.charIndex + e);
  }
  consume(e = 1) {
    let n = this.peek(e);
    return this.advance(e), n;
  }
  consumeMatch(e) {
    if (!e.sticky)
      throw new Error('`regex` must have a sticky flag ("y")');
    e.lastIndex = this.charsToBytes[this.charIndex];
    let n = e.exec(this.string);
    if (n === null)
      return _u;
    let o = n[0];
    return this.advance(this._charLength(o)), o;
  }
  consumeMatchFn(e) {
    let n = this.charIndex;
    for (; !this.isEnd && e(this.peek()); )
      this.advance();
    return this.charIndex > n ? this.string.slice(this.charsToBytes[n], this.charsToBytes[this.charIndex]) : _u;
  }
  consumeString(e) {
    if (this.consumeStringFast(e))
      return e;
    if (!this.multiByteMode)
      return _u;
    let { length: n } = e, o = this._charLength(e);
    return o !== n && e === this.peek(o) ? (this.advance(o), e) : _u;
  }
  consumeStringFast(e) {
    if (this.peek() === e[0]) {
      let { length: n } = e;
      if (n === 1)
        return this.advance(), e;
      if (this.peek(n) === e)
        return this.advance(n), e;
    }
    return _u;
  }
  consumeUntilMatch(e) {
    if (!e.global)
      throw new Error('`regex` must have a global flag ("g")');
    let n = this.charsToBytes[this.charIndex];
    e.lastIndex = n;
    let o = e.exec(this.string);
    if (o === null || o.index === n)
      return _u;
    let s = this.string.slice(n, o.index);
    return this.advance(this._charLength(s)), s;
  }
  consumeUntilString(e) {
    let { charIndex: n, charsToBytes: o, string: s } = this, h = o[n], a = s.indexOf(e, h);
    if (a <= 0)
      return _u;
    let m = s.slice(h, a);
    return this.advance(this._charLength(m)), m;
  }
  peek(e = 1) {
    if (this.charIndex >= this.charCount)
      return _u;
    if (e === 1)
      return this.chars[this.charIndex];
    let { charsToBytes: n, charIndex: o } = this;
    return this.string.slice(n[o], n[o + e]);
  }
  reset(e = 0) {
    this.charIndex = e >= 0 ? Math.min(this.charCount, e) : Math.max(0, this.charIndex + e);
  }
}
var OB = IB, qu = {};
const CB = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
  amp: "&",
  apos: "'",
  gt: ">",
  lt: "<",
  quot: '"'
}));
qu.predefinedEntities = CB;
function aI(t) {
  if (sI(t))
    return !0;
  let e = Dv(t);
  return e === 45 || e === 46 || e >= 48 && e <= 57 || e === 183 || e >= 768 && e <= 879 || e >= 8255 && e <= 8256;
}
qu.isNameChar = aI;
function sI(t) {
  let e = Dv(t);
  return e === 58 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 192 && e <= 214 || e >= 216 && e <= 246 || e >= 248 && e <= 767 || e >= 880 && e <= 893 || e >= 895 && e <= 8191 || e >= 8204 && e <= 8205 || e >= 8304 && e <= 8591 || e >= 11264 && e <= 12271 || e >= 12289 && e <= 55295 || e >= 63744 && e <= 64975 || e >= 65008 && e <= 65533 || e >= 65536 && e <= 983039;
}
qu.isNameStartChar = sI;
function AB(t) {
  return !lI(t);
}
qu.isNotXmlChar = AB;
function PB(t) {
  return t === "#" || aI(t);
}
qu.isReferenceChar = PB;
function kB(t) {
  let e = Dv(t);
  return e === 32 || e === 9 || e === 10 || e === 13;
}
qu.isWhitespace = kB;
function lI(t) {
  let e = Dv(t);
  return e === 9 || e === 10 || e === 13 || e >= 32 && e <= 55295 || e >= 57344 && e <= 65533 || e >= 65536 && e <= 1114111;
}
qu.isXmlChar = lI;
function Dv(t) {
  return t.codePointAt(0) || -1;
}
class ah {
  constructor() {
    this.parent = null;
  }
  get document() {
    return this.parent ? this.parent.document : null;
  }
  get isRootNode() {
    return this.parent ? this.parent === this.document : !1;
  }
  get preserveWhitespace() {
    return Boolean(this.parent && this.parent.preserveWhitespace);
  }
  get type() {
    return "";
  }
  toJSON() {
    let e = {
      type: this.type
    };
    return this.isRootNode && (e.isRootNode = !0), this.preserveWhitespace && (e.preserveWhitespace = !0), e;
  }
}
ah.TYPE_CDATA = "cdata";
ah.TYPE_COMMENT = "comment";
ah.TYPE_DOCUMENT = "document";
ah.TYPE_ELEMENT = "element";
ah.TYPE_PROCESSING_INSTRUCTION = "pi";
ah.TYPE_TEXT = "text";
var sh = ah;
const o0 = sh;
class LB extends o0 {
  constructor(e = "") {
    super(), this.text = e;
  }
  get type() {
    return o0.TYPE_TEXT;
  }
  toJSON() {
    return Object.assign(o0.prototype.toJSON.call(this), {
      text: this.text
    });
  }
}
var nx = LB;
const DB = sh, NB = nx;
class RB extends NB {
  get type() {
    return DB.TYPE_CDATA;
  }
}
var uI = RB;
const a0 = sh;
class zB extends a0 {
  constructor(e = "") {
    super(), this.content = e;
  }
  get type() {
    return a0.TYPE_COMMENT;
  }
  toJSON() {
    return Object.assign(a0.prototype.toJSON.call(this), {
      content: this.content
    });
  }
}
var cI = zB;
const s0 = sh;
class ix extends s0 {
  constructor(e, n = /* @__PURE__ */ Object.create(null), o = []) {
    super(), this.name = e, this.attributes = n, this.children = o;
  }
  get isEmpty() {
    return this.children.length === 0;
  }
  get preserveWhitespace() {
    let e = this;
    for (; e instanceof ix; ) {
      if ("xml:space" in e.attributes)
        return e.attributes["xml:space"] === "preserve";
      e = e.parent;
    }
    return !1;
  }
  get text() {
    return this.children.map((e) => "text" in e ? e.text : "").join("");
  }
  get type() {
    return s0.TYPE_ELEMENT;
  }
  toJSON() {
    return Object.assign(s0.prototype.toJSON.call(this), {
      name: this.name,
      attributes: this.attributes,
      children: this.children.map((e) => e.toJSON())
    });
  }
}
var ox = ix;
const FB = ox, l0 = sh;
class BB extends l0 {
  constructor(e = []) {
    super(), this.children = e;
  }
  get document() {
    return this;
  }
  get root() {
    return this.children.find((e) => e instanceof FB) || null;
  }
  get text() {
    return this.children.map((e) => "text" in e ? e.text : "").join("");
  }
  get type() {
    return l0.TYPE_DOCUMENT;
  }
  toJSON() {
    return Object.assign(l0.prototype.toJSON.call(this), {
      children: this.children.map((e) => e.toJSON())
    });
  }
}
var hI = BB;
const u0 = sh;
class VB extends u0 {
  constructor(e, n = "") {
    super(), this.name = e, this.content = n;
  }
  get type() {
    return u0.TYPE_PROCESSING_INSTRUCTION;
  }
  toJSON() {
    return Object.assign(u0.prototype.toJSON.call(this), {
      name: this.name,
      content: this.content
    });
  }
}
var fI = VB;
const UB = OB, Pc = qu, jB = uI, GB = cI, $B = hI, qB = ox, oE = fI, aE = nx, c0 = "";
class WB {
  constructor(e, n = {}) {
    for (this.document = new $B(), this.currentNode = this.document, this.options = n, this.scanner = new UB(ZB(e)), this.consumeProlog(), this.consumeElement() || this.error("Root element is missing or invalid"); this.consumeMisc(); )
      ;
    this.scanner.isEnd || this.error("Extra content at the end of the document");
  }
  addNode(e) {
    e.parent = this.currentNode, this.currentNode.children.push(e);
  }
  addText(e) {
    let { children: n } = this.currentNode;
    if (n.length > 0) {
      let o = n[n.length - 1];
      if (o instanceof aE) {
        o.text += e;
        return;
      }
    }
    this.addNode(new aE(e));
  }
  consumeAttributeValue() {
    let { scanner: e } = this, n = e.peek();
    if (n !== '"' && n !== "'")
      return !1;
    e.advance();
    let o, s = !1, h = c0, a = n === '"' ? /[^"&<]+/y : /[^'&<]+/y;
    e:
      for (; !e.isEnd; )
        switch (o = e.consumeMatch(a), o && (this.validateChars(o), h += o.replace(/[\t\r\n]/g, " ")), e.peek()) {
          case n:
            s = !0;
            break e;
          case "&":
            h += this.consumeReference();
            continue;
          case "<":
            this.error("Unescaped `<` is not allowed in an attribute value");
            break;
          case c0:
            this.error("Unclosed attribute");
            break;
        }
    return s || this.error("Unclosed attribute"), e.advance(), h;
  }
  consumeCdataSection() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<![CDATA["))
      return !1;
    let n = e.consumeUntilString("]]>");
    return this.validateChars(n), e.consumeStringFast("]]>") || this.error("Unclosed CDATA section"), this.options.preserveCdata ? this.addNode(new jB(n)) : this.addText(n), !0;
  }
  consumeCharData() {
    let { scanner: e } = this, n = e.consumeUntilMatch(/<|&|]]>/g);
    return n ? (this.validateChars(n), e.peek() === "]" && e.peek(3) === "]]>" && this.error("Element content may not contain the CDATA section close delimiter `]]>`"), this.addText(n), !0) : !1;
  }
  consumeComment() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<!--"))
      return !1;
    let n = e.consumeUntilString("--");
    return this.validateChars(n), e.consumeStringFast("-->") || (e.peek(2) === "--" ? this.error("The string `--` isn't allowed inside a comment") : this.error("Unclosed comment")), this.options.preserveComments && this.addNode(new GB(n.trim())), !0;
  }
  consumeContentReference() {
    let e = this.consumeReference();
    return e ? (this.addText(e), !0) : !1;
  }
  consumeDoctypeDeclaration() {
    let { scanner: e } = this;
    return !e.consumeStringFast("<!DOCTYPE") || !this.consumeWhitespace() ? !1 : (e.consumeMatch(/[^[>]+/y), e.consumeMatch(/\[[\s\S]+?\][\x20\t\r\n]*>/y) || e.consumeStringFast(">") || this.error("Unclosed doctype declaration"), !0);
  }
  consumeElement() {
    let { scanner: e } = this, n = e.charIndex;
    if (e.peek() !== "<")
      return !1;
    e.advance();
    let o = this.consumeName();
    if (!o)
      return e.reset(n), !1;
    let s = /* @__PURE__ */ Object.create(null);
    for (; this.consumeWhitespace(); ) {
      let m = this.consumeName();
      if (!m)
        continue;
      let g = this.consumeEqual() && this.consumeAttributeValue();
      g === !1 && this.error("Attribute value expected"), m in s && this.error(`Duplicate attribute: ${m}`), m === "xml:space" && g !== "default" && g !== "preserve" && this.error('Value of the `xml:space` attribute must be "default" or "preserve"'), s[m] = g;
    }
    if (this.options.sortAttributes) {
      let m = Object.keys(s).sort(), g = /* @__PURE__ */ Object.create(null);
      for (let b = 0; b < m.length; ++b) {
        let T = m[b];
        g[T] = s[T];
      }
      s = g;
    }
    let h = Boolean(e.consumeStringFast("/>")), a = new qB(o, s);
    if (a.parent = this.currentNode, !h) {
      for (e.consumeStringFast(">") || this.error(`Unclosed start tag for element \`${o}\``), this.currentNode = a, this.consumeCharData(); this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment(); )
        this.consumeCharData();
      let m = e.charIndex, g;
      (!e.consumeStringFast("</") || !(g = this.consumeName()) || g !== o) && (e.reset(m), this.error(`Missing end tag for element ${o}`)), this.consumeWhitespace(), e.consumeStringFast(">") || this.error(`Unclosed end tag for element ${o}`), this.currentNode = a.parent;
    }
    return this.addNode(a), !0;
  }
  consumeEqual() {
    return this.consumeWhitespace(), this.scanner.consumeStringFast("=") ? (this.consumeWhitespace(), !0) : !1;
  }
  consumeMisc() {
    return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();
  }
  consumeName() {
    return Pc.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(Pc.isNameChar) : c0;
  }
  consumeProcessingInstruction() {
    let { scanner: e } = this, n = e.charIndex;
    if (!e.consumeStringFast("<?"))
      return !1;
    let o = this.consumeName();
    if (o ? o.toLowerCase() === "xml" && (e.reset(n), this.error("XML declaration isn't allowed here")) : this.error("Invalid processing instruction"), !this.consumeWhitespace()) {
      if (e.consumeStringFast("?>"))
        return this.addNode(new oE(o)), !0;
      this.error("Whitespace is required after a processing instruction name");
    }
    let s = e.consumeUntilString("?>");
    return this.validateChars(s), e.consumeStringFast("?>") || this.error("Unterminated processing instruction"), this.addNode(new oE(o, s)), !0;
  }
  consumeProlog() {
    let { scanner: e } = this, n = e.charIndex;
    for (this.consumeXmlDeclaration(); this.consumeMisc(); )
      ;
    if (this.consumeDoctypeDeclaration())
      for (; this.consumeMisc(); )
        ;
    return n < e.charIndex;
  }
  consumeReference() {
    let { scanner: e } = this;
    if (e.peek() !== "&")
      return !1;
    e.advance();
    let n = e.consumeMatchFn(Pc.isReferenceChar);
    e.consume() !== ";" && this.error("Unterminated reference (a reference must end with `;`)");
    let o;
    if (n[0] === "#") {
      let s = n[1] === "x" ? parseInt(n.slice(2), 16) : parseInt(n.slice(1), 10);
      isNaN(s) && this.error("Invalid character reference"), o = String.fromCodePoint(s), Pc.isXmlChar(o) || this.error("Character reference resolves to an invalid character");
    } else if (o = Pc.predefinedEntities[n], o === void 0) {
      let {
        ignoreUndefinedEntities: s,
        resolveUndefinedEntity: h
      } = this.options, a = `&${n};`;
      if (h) {
        let m = h(a);
        if (m != null) {
          let g = typeof m;
          if (g !== "string")
            throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${g}`);
          return m;
        }
      }
      if (s)
        return a;
      e.reset(-a.length), this.error(`Named entity isn't defined: ${a}`);
    }
    return o;
  }
  consumeSystemLiteral() {
    let { scanner: e } = this, n = e.consumeStringFast('"') || e.consumeStringFast("'");
    if (!n)
      return !1;
    let o = e.consumeUntilString(n);
    return this.validateChars(o), e.consumeStringFast(n) || this.error("Missing end quote"), o;
  }
  consumeWhitespace() {
    return Boolean(this.scanner.consumeMatchFn(Pc.isWhitespace));
  }
  consumeXmlDeclaration() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<?xml"))
      return !1;
    this.consumeWhitespace() || this.error("Invalid XML declaration");
    let n = Boolean(e.consumeStringFast("version")) && this.consumeEqual() && this.consumeSystemLiteral();
    if (n === !1 ? this.error("XML version is missing or invalid") : /^1\.[0-9]+$/.test(n) || this.error("Invalid character in version number"), this.consumeWhitespace()) {
      Boolean(e.consumeStringFast("encoding")) && this.consumeEqual() && this.consumeSystemLiteral() && this.consumeWhitespace();
      let s = Boolean(e.consumeStringFast("standalone")) && this.consumeEqual() && this.consumeSystemLiteral();
      s && (s !== "yes" && s !== "no" && this.error('Only "yes" and "no" are permitted as values of `standalone`'), this.consumeWhitespace());
    }
    return e.consumeStringFast("?>") || this.error("Invalid or unclosed XML declaration"), !0;
  }
  error(e) {
    let { charIndex: n, string: o } = this.scanner, s = 1, h = "", a = 1;
    for (let T = 0; T < n; ++T) {
      let M = o[T];
      M === `
` ? (s = 1, h = "", a += 1) : (s += 1, h += M);
    }
    let m = o.indexOf(`
`, n);
    h += m === -1 ? o.slice(n) : o.slice(n, m);
    let g = 0;
    h.length > 50 && (s < 40 ? h = h.slice(0, 50) : (g = s - 20, h = h.slice(g, s + 30)));
    let b = new Error(
      `${e} (line ${a}, column ${s})
  ${h}
` + " ".repeat(s - g + 1) + `^
`
    );
    throw Object.assign(b, {
      column: s,
      excerpt: h,
      line: a,
      pos: n
    }), b;
  }
  validateChars(e) {
    let n = 0;
    for (let o of e)
      Pc.isNotXmlChar(o) && (this.scanner.reset(-([...e].length - n)), this.error("Invalid character")), n += 1;
  }
}
var HB = WB;
function ZB(t) {
  return t[0] === "\uFEFF" && (t = t.slice(1)), t.replace(/\r\n?/g, `
`);
}
const XB = HB, KB = uI, YB = cI, JB = hI, QB = ox, e8 = sh, t8 = fI, r8 = nx;
function Wu(t, e) {
  return new XB(t, e).document;
}
Wu.XmlCdata = KB;
Wu.XmlComment = YB;
Wu.XmlDocument = JB;
Wu.XmlElement = QB;
Wu.XmlNode = e8;
Wu.XmlProcessingInstruction = t8;
Wu.XmlText = r8;
var n8 = Wu;
class i8 extends Error {
  constructor(e) {
    super(e);
  }
}
function o8(t) {
  let e = null;
  try {
    e = n8(t);
  } catch (n) {
    throw new i8(n.message);
  }
  return e;
}
function ql(t) {
  return t.children[0];
}
function Yg(t) {
  const e = t.indexOf(":");
  return e > -1 ? t.substr(e + 1) : t;
}
function Jg(t) {
  return t.name || "";
}
function Eo(t, e, n) {
  const o = Yg(e);
  function s(h, a) {
    return Yg(Jg(a)) === o && h.push(a), n && Array.isArray(a.children) ? [...h, ...a.children.reduce(s, [])] : h;
  }
  return t && Array.isArray(t.children) ? t.children.reduce(s, []) : [];
}
function Sr(t, e, n) {
  return Eo(t, e, n)[0] || null;
}
function od(t) {
  return t && Array.isArray(t.children) ? [...t.children.filter((e) => e.constructor.name === "XmlElement")] : [];
}
function _n(t) {
  const e = t && Array.isArray(t.children) ? t.children.find((n) => n.type === "text") : null;
  return e ? e.text : "";
}
function Ys(t, e) {
  return t && t.attributes[e] || "";
}
const sE = ["utf-8", "utf-16", "iso-8859-1"], lE = "utf-8";
function a8(t) {
  const e = /charset=([^;]+)/.exec(t);
  return e ? e[1] : null;
}
function s8(t, e) {
  const n = e ? a8(e) : null, o = n ? [n, ...sE] : sE;
  for (const s of o)
    try {
      return new TextDecoder(s, { fatal: !0 }).decode(t);
    } catch {
    }
  return console.warn(
    `XML document encoding could not be determined, falling back to ${lE}.`
  ), new TextDecoder(lE).decode(t);
}
const Uy = /* @__PURE__ */ new Map();
function l8(t) {
  if (Uy.has(t))
    return Uy.get(t);
  const e = fetch(t);
  return e.finally(() => Uy.delete(t)), Uy.set(t, e), e;
}
function ax(t) {
  return l8(t).catch(
    () => fetch(t, { method: "HEAD", mode: "no-cors" }).catch((e) => {
      throw new n0(
        `Fetching the document failed either due to network errors or unreachable host, error is: ${e.message}`,
        0,
        !1
      );
    }).then(() => {
      throw new n0(
        "The document could not be fetched due to CORS limitations",
        0,
        !0
      );
    })
  ).then(async (e) => {
    if (!e.ok) {
      const s = await e.text();
      throw new n0(
        `Received an error with code ${e.status}: ${s}`,
        e.status,
        !1
      );
    }
    const n = await e.arrayBuffer(), o = e.headers.get("Content-Type");
    return s8(n, o);
  }).then((e) => o8(e));
}
function sx(t, e) {
  const n = t.match(/(https?%3A%2F%2F[^/]+)$/);
  if (n) {
    const m = n[1], g = sx(decodeURIComponent(m), e);
    return t.replace(m, encodeURIComponent(g));
  }
  const o = new URL(t), s = Object.keys(e), h = s.map((m) => m.toLowerCase()), a = [];
  for (const m of o.searchParams.keys())
    h.indexOf(m.toLowerCase()) > -1 && a.push(m);
  return a.map((m) => o.searchParams.delete(m)), s.forEach(
    (m) => o.searchParams.set(m, e[m] === !0 ? "" : e[m])
  ), o.toString();
}
let u8 = 1e3 * 60 * 60;
function c8() {
  return u8;
}
const Vu = "caches" in self ? caches.open("ogc-client") : null;
async function h8(t, ...e) {
  if (!Vu)
    return;
  const n = "https://cache/" + e.join("/");
  await (await Vu).put(
    n,
    new Response(JSON.stringify(t), {
      headers: {
        "x-expiry": (Date.now() + c8()).toString(10)
      }
    })
  );
}
async function f8(...t) {
  if (!Vu)
    return !1;
  const e = "https://cache/" + t.join("/");
  return (await Vu).match(e).then((o) => !!o && parseInt(o.headers.get("x-expiry")) > Date.now());
}
async function p8(...t) {
  if (!Vu)
    return null;
  const e = "https://cache/" + t.join("/"), o = await (await Vu).match(e);
  return o ? o.clone().json() : null;
}
const jy = /* @__PURE__ */ new Map();
async function d8(t, ...e) {
  if (await m8(), await f8(...e))
    return p8(...e);
  const n = e.join("#");
  if (jy.has(n))
    return jy.get(n);
  const o = t();
  o instanceof Promise && (o.then(() => jy.delete(n)), jy.set(n, o));
  const s = await o;
  return await h8(s, ...e), s;
}
async function m8() {
  if (!Vu)
    return;
  const t = await Vu, e = await t.keys();
  for (let n of e) {
    const o = await t.match(n);
    parseInt(o.headers.get("x-expiry")) <= Date.now() && await t.delete(n);
  }
}
function y8(t, e, n, o, s, h, a, m, g, b) {
  const T = e === "2.0.0" ? "TYPENAMES" : "TYPENAME", M = e === "2.0.0" ? "COUNT" : "MAXFEATURES", I = {
    SERVICE: "WFS",
    REQUEST: "GetFeature",
    VERSION: e,
    [T]: n
  };
  if (o !== void 0 && (I.OUTPUTFORMAT = o), h !== void 0 && (I.PROPERTYNAME = h.join(",")), a ? (I.RESULTTYPE = "hits", I[M] = "1") : s !== void 0 && (I[M] = s.toString(10)), m && (I.SRSNAME = m), g) {
    const P = g.join(",");
    I.BBOX = b ? `${P},${b}` : P;
  }
  return sx(t, I);
}
class g8 {
  constructor(e) {
    const n = sx(e, {
      SERVICE: "WMS",
      REQUEST: "GetCapabilities"
    });
    this._capabilitiesPromise = d8(
      () => MB(n),
      "WMS",
      "CAPABILITIES",
      n
    ).then(({ info: o, layers: s, version: h }) => {
      this._info = o, this._layers = s, this._version = h;
    }), this._info = null, this._layers = null, this._version = null;
  }
  isReady() {
    return this._capabilitiesPromise.then(() => this);
  }
  getServiceInfo() {
    return this._info;
  }
  getLayers() {
    function e(n) {
      return {
        title: n.title,
        name: n.name,
        abstract: n.abstract,
        ..."children" in n && {
          children: n.children.map(e)
        }
      };
    }
    return this._layers.map(e);
  }
  getLayerByName(e) {
    let n = null;
    function o(s) {
      if (n === null) {
        if (s.name === e) {
          n = s;
          return;
        }
        "children" in s && s.children.map(o);
      }
    }
    return this._layers.map(o), n;
  }
  getVersion() {
    return this._version;
  }
}
const v8 = [
  "EPSG:4046",
  "EPSG:4075",
  "EPSG:4120",
  "EPSG:4122",
  "EPSG:4124",
  "EPSG:4126",
  "EPSG:4149",
  "EPSG:4151",
  "EPSG:4153",
  "EPSG:4155",
  "EPSG:4157",
  "EPSG:4159",
  "EPSG:4161",
  "EPSG:4163",
  "EPSG:4165",
  "EPSG:4167",
  "EPSG:4169",
  "EPSG:4171",
  "EPSG:4173",
  "EPSG:4175",
  "EPSG:4178",
  "EPSG:4180",
  "EPSG:4182",
  "EPSG:4184",
  "EPSG:4188",
  "EPSG:4190",
  "EPSG:4191",
  "EPSG:4196",
  "EPSG:4198",
  "EPSG:4202",
  "EPSG:4210",
  "EPSG:4211",
  "EPSG:4214",
  "EPSG:4226",
  "EPSG:4229",
  "EPSG:4231",
  "EPSG:4233",
  "EPSG:4236",
  "EPSG:4238",
  "EPSG:4240",
  "EPSG:4242",
  "EPSG:4244",
  "EPSG:4246",
  "EPSG:4248",
  "EPSG:4250",
  "EPSG:4252",
  "EPSG:4255",
  "EPSG:4258",
  "EPSG:4261",
  "EPSG:4264",
  "EPSG:4267",
  "EPSG:4270",
  "EPSG:4273",
  "EPSG:4276",
  "EPSG:4279",
  "EPSG:4281",
  "EPSG:4284",
  "EPSG:4286",
  "EPSG:4288",
  "EPSG:4292",
  "EPSG:4295",
  "EPSG:4297",
  "EPSG:4299",
  "EPSG:4302",
  "EPSG:4324",
  "EPSG:4326"
];
function _8(t) {
  return v8.indexOf(c1(t)) > -1;
}
function c1(t) {
  return /^urn:(?:x-)?ogc:def:crs:epsg:/.test(t.toLowerCase()) ? `EPSG:${/([0-9]+)$/.exec(t)[1]}` : t;
}
function pI(t) {
  return ql(t).attributes.version;
}
function x8(t) {
  const e = pI(t), n = Sr(
    ql(t),
    "Capability"
  );
  return Eo(n, "Layer").map(
    (o) => dI(o, e)
  );
}
function b8(t) {
  const e = Sr(ql(t), "Service"), n = Eo(
    Sr(e, "KeywordList"),
    "Keyword"
  ).map(_n).filter((o, s, h) => h.indexOf(o) === s);
  return {
    title: _n(Sr(e, "Title")),
    name: _n(Sr(e, "Name")),
    abstract: _n(Sr(e, "Abstract")),
    fees: _n(Sr(e, "Fees")),
    constraints: _n(Sr(e, "AccessConstraints")),
    keywords: n
  };
}
function dI(t, e, n = [], o = [], s = null) {
  const h = e === "1.3.0" ? "CRS" : "SRS", a = Eo(t, h).map(_n), m = a.length > 0 ? a : n, g = Eo(t, "Style").map(
    w8
  ), b = g.length > 0 ? g : o;
  function T(z) {
    const V = Ys(z, h);
    return (_8(V) && e === "1.3.0" ? ["miny", "minx", "maxy", "maxx"] : ["minx", "miny", "maxx", "maxy"]).map((re) => Ys(z, re));
  }
  const M = Sr(t, "Attribution"), I = M !== null ? E8(M) : s, P = Eo(t, "Layer").map(
    (z) => dI(z, e, m, b, I)
  );
  return {
    name: _n(Sr(t, "Name")),
    title: _n(Sr(t, "Title")),
    abstract: _n(Sr(t, "Abstract")),
    availableCrs: m,
    styles: b,
    attribution: I,
    boundingBoxes: Eo(t, "BoundingBox").reduce(
      (z, V) => ({
        ...z,
        [Ys(V, h)]: T(V)
      }),
      {}
    ),
    ...P.length && { children: P }
  };
}
function w8(t) {
  const e = Ys(
    Sr(Sr(t, "LegendURL"), "OnlineResource"),
    "xlink:href"
  );
  return {
    name: _n(Sr(t, "Name")),
    title: _n(Sr(t, "Title")),
    ...e && { legendUrl: e }
  };
}
function E8(t) {
  const e = Ys(
    Sr(
      Sr(t, "LogoURL"),
      "OnlineResource"
    ),
    "xlink:href"
  ), n = Ys(
    Sr(t, "OnlineResource"),
    "xlink:href"
  ), o = _n(Sr(t, "Title"));
  return {
    ...o && { title: o },
    ...n && { url: n },
    ...e && { logoUrl: e }
  };
}
function Nv(t) {
  return ql(t).attributes.version;
}
function mI(t) {
  const e = Nv(t);
  let n;
  if (e.startsWith("1.0")) {
    const o = Sr(
      Sr(
        Sr(ql(t), "Capability"),
        "Request"
      ),
      "GetFeature"
    );
    n = od(
      Sr(o, "ResultFormat")
    ).map(Jg);
  } else {
    const o = Sr(
      ql(t),
      "OperationsMetadata"
    ), s = Eo(o, "Operation").find(
      (a) => Ys(a, "name") === "GetFeature"
    ), h = Eo(s, "Parameter").find(
      (a) => Ys(a, "name") === "outputFormat"
    );
    n = Eo(h, "Value", !0).map(
      _n
    );
  }
  return n;
}
function S8(t) {
  const e = Nv(t), n = e.startsWith("1.0") ? "Service" : "ServiceIdentification", o = e.startsWith("1.0") ? "Name" : "ServiceType", s = Sr(ql(t), n);
  let h;
  return e.startsWith("1.0") ? h = _n(Sr(s, "Keywords")).split(",").map((a) => a.trim()) : h = Eo(
    Sr(s, "Keywords"),
    "Keyword"
  ).map(_n), {
    title: _n(Sr(s, "Title")),
    name: _n(Sr(s, o)),
    abstract: _n(Sr(s, "Abstract")),
    fees: _n(Sr(s, "Fees")),
    constraints: _n(Sr(s, "AccessConstraints")),
    keywords: h,
    outputFormats: mI(t)
  };
}
function T8(t) {
  const e = Nv(t), n = mI(t), o = Sr(
    ql(t),
    "FeatureTypeList"
  );
  return Eo(o, "FeatureType").map(
    (s) => M8(s, e, n)
  );
}
function M8(t, e, n) {
  const o = e.startsWith("2.") ? "CRS" : "SRS", s = e.startsWith("1.0") ? "SRS" : `Default${o}`;
  function h() {
    const b = Sr(t, "LatLongBoundingBox");
    return ["minx", "miny", "maxx", "maxy"].map((T) => Ys(b, T)).map(parseFloat);
  }
  function a() {
    const b = Sr(t, "WGS84BoundingBox");
    return ["LowerCorner", "UpperCorner"].map((T) => Sr(b, T)).map((T) => _n(T).split(" ")).reduce((T, M) => [...T, ...M]).map(parseFloat);
  }
  const m = e.startsWith("1.0") ? [] : Eo(t, `Other${o}`).map(_n).map(c1), g = e.startsWith("1.0") ? [] : Eo(
    Sr(t, "OutputFormats"),
    "Format"
  ).map(_n);
  return {
    name: _n(Sr(t, "Name")),
    title: _n(Sr(t, "Title")),
    abstract: _n(Sr(t, "Abstract")),
    defaultCrs: c1(
      _n(Sr(t, s))
    ),
    otherCrs: m,
    outputFormats: g.length > 0 ? g : n,
    latLonBoundingBox: e.startsWith("1.0") ? h() : a()
  };
}
function I8(t, e, n) {
  const o = ql(t);
  let s;
  if (n.startsWith("2.0"))
    s = Eo(o, "member").map(
      (b) => od(b)[0]
    );
  else {
    const b = Sr(o, "featureMembers");
    s = b ? od(b) : Eo(o, "featureMember").map(
      (T) => od(T)[0]
    );
  }
  const h = n === "1.0.0" ? "fid" : "gml:id";
  function a(b) {
    return b in e.properties;
  }
  function m(b, T) {
    switch (e.properties[b]) {
      case "integer":
        return parseInt(T);
      case "float":
        return parseFloat(T);
      case "boolean":
        return T === "true";
      default:
        return T;
    }
  }
  function g(b) {
    return od(b).filter((T) => a(Yg(Jg(T)))).reduce((T, M) => {
      const I = Yg(Jg(M));
      return {
        ...T,
        [I]: m(I, _n(M))
      };
    }, {});
  }
  return s.map((b) => ({
    id: Ys(b, h),
    properties: g(b)
  }));
}
function O8(t) {
  return t.reduce((e, n) => {
    for (const o in n.properties) {
      const s = n.properties[o];
      o in e || (e[o] = { uniqueValues: [] });
      const h = e[o].uniqueValues.find(
        (a) => a.value === s
      );
      h ? h.count++ : e[o].uniqueValues.push({ value: s, count: 1 });
    }
    return e;
  }, {});
}
rx(
  "parseWmsCapabilities",
  self,
  ({ url: t }) => ax(t).then((e) => ({
    info: b8(e),
    layers: x8(e),
    version: pI(e)
  }))
);
rx(
  "parseWfsCapabilities",
  self,
  ({ url: t }) => ax(t).then((e) => ({
    info: S8(e),
    featureTypes: T8(e),
    version: Nv(e)
  }))
);
rx(
  "queryWfsFeatureTypeDetails",
  self,
  ({ url: t, serviceVersion: e, featureTypeFull: n }) => {
    const o = y8(
      t,
      e,
      n.name,
      void 0,
      void 0,
      Object.keys(n.properties)
    );
    return ax(o).then((s) => ({
      props: O8(
        I8(s, n, e)
      )
    }));
  }
);
const C8 = () => [
  {
    url: "http://wmts1.geoportail.lu/opendata/service",
    label: "Open Data Webservices WMS"
  },
  {
    url: "http://ows.terrestris.de/osm-gray/service",
    label: "OpenStreetMap by Terrestris (Grey)"
  },
  {
    url: "http://ows.terrestris.de/osm/service",
    label: "OpenStreetMap by Terrestris (Color)"
  }
];
class A8 {
  constructor(e) {
    bi(this, "capabilitiesPromise");
    bi(this, "serviceInfo");
    bi(this, "layers");
    const n = new FC();
    let o = "&";
    e.indexOf("?") === -1 && (o = "?"), e.indexOf("Capabilities") === -1 && (e = e + o + "SERVICE=WMTS&REQUEST=GetCapabilities"), this.capabilitiesPromise = fetch(e).then((s) => s.text()).then((s) => {
      var a;
      const h = n.read(s);
      this.serviceInfo = this.mapServiceInfo(h.ServiceIdentification), this.layers = this.mapToRemoteLayers((a = h.Contents) == null ? void 0 : a.Layer);
    });
  }
  mapToRemoteLayers(e) {
    return [
      {
        type: Na.WMTS,
        children: e.map(
          (n) => ({
            type: Na.WMTS,
            abstract: n.Abstract,
            format: n.Format,
            name: n.Identifier,
            title: n.Title,
            tileMatrixSetLink: n.TileMatrixSetLink,
            wgs84BoundingBox: n.WGS84BoundingBox
          })
        )
      }
    ];
  }
  mapServiceInfo(e) {
    return {
      type: Na.WMTS,
      title: e.Title,
      abstract: e.Abstract,
      fees: e.Fees,
      constraints: e.AccessConstraints,
      serviceTypeVersion: e.ServiceTypeVersion
    };
  }
  isReady() {
    return this.capabilitiesPromise.then(() => this);
  }
  getLayerByName(e) {
    return this.layers[0].children.filter((n) => n.name === e)[0];
  }
  getLayers() {
    return this.layers;
  }
  getServiceInfo() {
    return this.serviceInfo;
  }
}
class P8 {
  async getRemoteEndpoint(e) {
    let n;
    return await this.getWmsEndpoint(e).isReady().catch(async () => {
      n = await this.getWmtsEndpoint(e).isReady();
    }) || n;
  }
  getWmsEndpoint(e) {
    return new g8(this.getProxyfiedUrl(e));
  }
  getWmtsEndpoint(e) {
    return new A8(this.getProxyfiedUrl(e));
  }
  getProxyfiedUrl(e) {
    return e.indexOf("httpsproxy") > 0 ? e : KM + "?url=" + encodeURIComponent(e);
  }
  async fetchRemoteWmsEndpoint() {
    return new Promise((e) => e(C8()));
  }
  isRemoteLayer(e) {
    return typeof e == "string" && (e.indexOf(Na.WMS) === 0 || e.indexOf(Na.WMTS) === 0);
  }
}
const Kc = new P8();
function k8(t, e) {
  var n, o;
  return t.children && !e.children || ((n = e.children) == null ? void 0 : n.length) === 0 ? 1 : e.children && !t.children || ((o = t.children) == null ? void 0 : o.length) === 0 ? -1 : 0;
}
function yI(t, e, n = 0) {
  const { name: o = "", type: s = Na.WMS, children: h } = t, a = `${s}||${e}||${o}`.split("-").join("%2D"), m = Ei();
  return {
    id: a,
    name: o,
    depth: n,
    children: h == null ? void 0 : h.sort(k8).map((g) => yI(g, e, n + 1)),
    checked: m.hasLayer(a),
    expanded: !1
  };
}
function L8(t) {
  const e = decodeURIComponent(t), [n, o, s] = e.split("||");
  return gI({
    id: e,
    url: Kc.getProxyfiedUrl(o),
    remoteLayer: { name: s, type: n }
  });
}
function gI({
  id: t,
  url: e,
  remoteLayer: n
}) {
  const { name: o = "", type: s = Na.WMS } = n;
  return {
    id: t,
    name: o,
    layers: o,
    url: e,
    type: s,
    imageType: jT.PNG
  };
}
const D8 = { class: "relative text-center" }, N8 = ["placeholder", "value"], R8 = {
  key: 0,
  class: "text-center"
}, z8 = { class: "lux-label" }, F8 = {
  key: 1,
  class: "text-center"
}, B8 = { class: "lux-label" }, V8 = {
  key: 2,
  class: "text-center"
}, U8 = /* @__PURE__ */ ze("div", { class: "fa fa-refresh fa-spin" }, null, -1), j8 = {
  key: 3,
  class: "overflow-auto max-h-[calc(400px-36px)]"
}, G8 = /* @__PURE__ */ ar({
  __name: "remote-layers",
  setup(t) {
    const { t: e } = En(), n = Ei(), o = hs(), s = Bn([]), h = Bn(), { remoteLayersOpen: a } = xn(ki()), { setRemoteLayersOpen: m } = ki();
    let g = !1, b, T, M;
    va(I);
    function I() {
      h.value = h.value ? Pf.updateLayers(
        h.value,
        n.layers
      ) : void 0;
    }
    Kc.fetchRemoteWmsEndpoint().then((ce) => {
      s.value = ce.map(({ url: ve, label: Re }) => ({
        label: Re,
        value: ve
      }));
    });
    async function P(ce) {
      g = !0, M = await Kc.getRemoteEndpoint(ce).catch(() => alert(e("Impossible de contacter ce WMS", { ns: "client" }))), T = ce, g = !1;
    }
    async function z() {
      const ce = M, ve = ce == null ? void 0 : ce.getLayers();
      if (ve && ve[0]) {
        const Re = yI(
          ve[0],
          T
        );
        h.value = Pf.updateLayers(Re, n.layers);
      }
    }
    async function V(ce) {
      T = b = ce, await P(T), z();
    }
    function q(ce) {
      b = ce.target.value;
    }
    async function re() {
      await P(b), z();
    }
    function X(ce) {
      h.value = Pf.toggleNode(
        ce.id,
        h.value,
        "expanded"
      );
    }
    function ae(ce) {
      const { id: ve, name: Re } = ce, Fe = M;
      if (ce.checked === !0)
        n.removeLayers(ve);
      else {
        const Pe = Fe == null ? void 0 : Fe.getLayerByName(Re);
        if (Pe) {
          const Se = o.initLayer(
            gI({
              id: ve,
              url: Kc.getProxyfiedUrl(T),
              remoteLayer: Pe
            })
          );
          n.addLayers(Se);
        }
      }
    }
    return (ce, ve) => se(a) ? (Ve(), on(oI, {
      key: 0,
      title: se(e)("Add external data", { ns: "client" }),
      onClose: ve[0] || (ve[0] = (Re) => se(m)(!1))
    }, {
      content: Ud(() => {
        var Re, Fe;
        return [
          ze("div", D8, [
            Ft(RT, {
              class: "lux-remote-services-dropdown",
              options: se(s),
              placeholder: se(e)("Predefined wms", { ns: "client" }),
              onChange: V
            }, null, 8, ["options", "placeholder"]),
            ze("input", {
              class: "lux-input w-[300px]",
              type: "url",
              placeholder: se(e)("Choose or write a WMS url", {
                ns: "client"
              }),
              value: se(T) || "",
              onChange: q
            }, null, 40, N8),
            ze("button", {
              type: "button",
              class: "lux-btn",
              onClick: re
            }, Gt(se(e)("Get the layers", { ns: "client" })), 1)
          ]),
          !se(g) && se(M) ? (Ve(), it("div", R8, [
            ze("span", z8, Gt(se(e)("Description du service :", {
              ns: "client"
            })), 1),
            Cg(" " + Gt((Re = se(M).getServiceInfo()) == null ? void 0 : Re.abstract), 1)
          ])) : Je("v-if", !0),
          !se(g) && se(M) ? (Ve(), it("div", F8, [
            ze("span", B8, Gt(se(e)("Access constraints :", {
              ns: "client"
            })), 1),
            Cg(" " + Gt((Fe = se(M).getServiceInfo()) == null ? void 0 : Fe.constraints), 1)
          ])) : Je("v-if", !0),
          se(g) ? (Ve(), it("div", V8, [
            U8,
            ze("span", null, Gt(se(e)("Chargement des informations", {
              ns: "client"
            })), 1)
          ])) : Je("v-if", !0),
          se(g) ? Je("v-if", !0) : (Ve(), it("div", j8, [
            se(h) ? (Ve(), on(u1, {
              key: 0,
              class: "block p-[10px] mb-[11px]",
              node: se(h),
              onToggleParent: X,
              onToggleLayer: ae
            }, null, 8, ["node"])) : Je("v-if", !0)
          ]))
        ];
      }),
      _: 1
    }, 8, ["title"])) : Je("v-if", !0);
  }
}), $8 = /* @__PURE__ */ ur(G8, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/remote-layers/remote-layers.vue"]]);
function q8(t, e = "fr-FR") {
  const n = new Date(t);
  return new Intl.DateTimeFormat(e).format(n);
}
const W8 = { class: "font-bold" }, H8 = { class: "col-span-2" }, Z8 = /* @__PURE__ */ ar({
  __name: "layer-metadata-item",
  props: {
    label: { type: String, required: !0 },
    value: { type: String, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, o) => (Ve(), it(cn, null, [
      ze("span", W8, Gt(e.label), 1),
      ze("span", H8, Gt(e.value), 1)
    ], 64));
  }
}), Kp = /* @__PURE__ */ ur(Z8, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-metadata/layer-metadata-item.vue"]]);
function X8(t) {
  return {
    fr: "fre",
    en: "eng",
    de: "ger",
    lb: "ltz"
  }[t.toLowerCase()];
}
function K8(t) {
  return new DOMParser().parseFromString(t, "text/html").body;
}
function Y8(t) {
  const e = [];
  function n(o) {
    const s = o.split("|");
    s[3] === "WWW:LINK-1.0-http--link" && e.indexOf(s[2]) === -1 && e.push(s[2]);
  }
  return Array.isArray(t) ? t.forEach(n, t) : n(t), e;
}
function J8(t) {
  const n = (Array.isArray(t) ? t : [t]).filter((o) => o.split("|")[1] === "metadata");
  return {
    organisaton: n[0].split("|")[2],
    name: n[0].split("|")[5],
    unknown: n[0].split("|")[6],
    address: n[0].split("|")[7],
    email: n[0].split("|")[4]
  };
}
class vI {
}
class Q8 extends vI {
  async getMetadata(e, n, o) {
    console.assert(e === Na.WMS);
    const s = Kc.getWmsEndpoint(n);
    await s.isReady();
    const h = s == null ? void 0 : s.getServiceInfo(), a = s == null ? void 0 : s.getLayerByName(o);
    return {
      title: a.title,
      description: a.abstract,
      keywords: h.keywords,
      accessConstraints: h.constraints,
      serviceDescription: h.abstract
    };
  }
}
const eV = new Q8();
class tV extends vI {
  async getMetadata(e, n, o) {
    console.assert(e === Na.WMTS);
    const s = Kc.getWmtsEndpoint(n);
    await s.isReady();
    const h = s == null ? void 0 : s.getServiceInfo(), a = s == null ? void 0 : s.getLayerByName(o);
    return {
      title: a.title,
      description: a.abstract,
      accessConstraints: h.constraints,
      serviceDescription: h.abstract
    };
  }
}
const rV = new tV();
class nV {
  async getMetadata(e, n, o) {
    if (e === Na.WMS)
      return eV.getMetadata(e, n, o);
    if (e === Na.WMTS)
      return rV.getMetadata(e, n, o);
    throw new Error(`Unsupported service type: ${e}`);
  }
}
const iV = new nV();
class oV {
  constructor() {
    bi(this, "geonetworkBaseUrl", "https://geocatalogue.geoportail.lu/geonetwork/srv");
    bi(this, "legendBaseUrl", "https://map.geoportail.lu/legends/get_html");
    bi(this, "localMetadataBaseUrl", "https://map.geoportail.lu/getMetadata");
  }
  async getLayerMetadata(e, n) {
    const o = Xc(), s = o.findBgLayerById(+e) || o.findById(+e) || o.find3dLayerById(+e);
    if (s) {
      const h = s.metadata, a = h == null ? void 0 : h.metadata_id, m = a && await this.getLocalMetadata(
        this.localMetadataBaseUrl,
        a,
        n
      ), g = s.name, b = (h == null ? void 0 : h.legend_name) || "", T = s == null ? void 0 : s.id, M = b && await this.getLegendHtml(
        this.legendBaseUrl,
        b,
        T,
        n
      );
      return {
        ...m,
        title: g,
        hasLegend: !!M,
        ...M && { legendHtml: M }
      };
    } else {
      const [h, a, m] = String(e).split("%2D").join("-").split("||");
      return iV.getMetadata(
        h,
        a,
        m
      );
    }
  }
  getLocalMetadata(e, n, o) {
    return fetch(`${e}?lang=${o}&uid=${n}`).then(async (s) => {
      const h = (await s.json()).metadata;
      return {
        name: h.title,
        serviceDescription: h.serviceDescription,
        description: h.abstract,
        legalConstraints: h.legalConstraints,
        link: Y8(h.link),
        revisionDate: h.revisionDate,
        keyword: h.keyword,
        responsibleParty: h.responsibleParty ? J8(h.responsibleParty) : void 0,
        metadataLink: `${this.geonetworkBaseUrl}/${X8(
          o
        )}/catalog.search#/metadata/${n}`,
        isError: !1
      };
    }).catch(() => ({ isError: !0 }));
  }
  getLegendHtml(e, n, o, s) {
    const h = {
      lang: s,
      ...n && { name: n },
      ...o && { id: o.toString() }
    };
    if (h.name && h.lang) {
      window.devicePixelRatio > 1 && (h.dpi = (window.devicePixelRatio * 96).toString());
      const a = `${e}?${new URLSearchParams(
        h
      ).toString()}`;
      return fetch(a).then(async (m) => {
        if (m.status >= 400 && m.status < 600)
          throw new Error("Server responded with error code");
        const g = await m.text();
        return g ? K8(g) : void 0;
      }).catch(() => {
      });
    }
  }
}
const uE = new oV(), aV = { class: "grid gap-2 grid-cols-3 pt-3 text-[13px] font-arial break-words" }, sV = {
  key: 2,
  class: "col-span-3 grid gap-2 grid-cols-3"
}, lV = { class: "font-bold" }, uV = { class: "col-span-2" }, cV = ["title"], hV = ["title"], fV = {
  key: 4,
  class: "col-span-3"
}, pV = { class: "font-bold" }, dV = { class: "col-span-2" }, mV = ["href"], yV = {
  key: 7,
  class: "col-span-3 grid gap-2 grid-cols-3"
}, gV = { class: "font-bold" }, vV = { class: "col-span-2" }, _V = { key: 0 }, xV = { key: 1 }, bV = { key: 2 }, wV = { key: 3 }, EV = { key: 4 }, SV = ["href"], TV = {
  key: 8,
  class: "grid gap-2 grid-cols-3 col-span-3"
}, MV = { class: "font-bold" }, IV = { class: "col-span-2" }, OV = ["href"], CV = {
  key: 9,
  class: "col-span-3"
}, AV = { key: 10 }, PV = { class: "text-xl" }, kV = {
  key: 11,
  class: "col-span-3"
}, LV = /* @__PURE__ */ ar({
  __name: "layer-metadata",
  setup(t) {
    const e = tx(), { metadataId: n } = xn(e), { t: o, i18next: s } = En(), h = _r(), a = _r(!0), m = 220;
    Pn(n, async (I) => {
      var P, z;
      h.value = I ? await uE.getLayerMetadata(I, s.language) : void 0, a.value = (((z = (P = h.value) == null ? void 0 : P.description) == null ? void 0 : z.length) || 0) < m;
    }), _a(() => {
      s.on("languageChanged", async () => {
        n.value && (h.value = await uE.getLayerMetadata(
          n.value,
          s.language
        ));
      });
    });
    const g = or(
      () => {
        var I, P, z;
        return a.value ? (I = h.value) == null ? void 0 : I.description : (z = (P = h.value) == null ? void 0 : P.description) == null ? void 0 : z.slice(0, m);
      }
    );
    function b() {
      a.value = !0;
    }
    function T() {
      a.value = !1;
    }
    function M() {
      e.clearMetadataId();
    }
    return (I, P) => {
      const z = L1("dompurify-html");
      return h.value ? (Ve(), on(oI, {
        key: 0,
        footer: !1,
        "max-height": !0,
        title: se(o)(`${h.value.title}`, { ns: "client" }),
        onClose: M
      }, {
        content: Ud(() => {
          var V, q, re, X, ae, ce, ve, Re, Fe, Pe, Se, Ie, Xe, $e, at;
          return [
            ze("div", aV, [
              h.value.name ? (Ve(), on(Kp, {
                key: 0,
                label: se(o)("Name"),
                value: h.value.name
              }, null, 8, ["label", "value"])) : Je("v-if", !0),
              h.value.serviceDescription ? (Ve(), on(Kp, {
                key: 1,
                label: se(o)("Description du Service"),
                value: h.value.serviceDescription
              }, null, 8, ["label", "value"])) : Je("v-if", !0),
              h.value.description ? (Ve(), it("div", sV, [
                ze("span", lV, Gt(se(o)("Description")), 1),
                ze("span", uV, [
                  Mg(ze("span", null, null, 512), [
                    [z, se(g)]
                  ]),
                  a.value ? Je("v-if", !0) : (Ve(), it("button", {
                    key: 0,
                    title: se(o)("Display full description", {
                      ns: "client"
                    }),
                    onClick: b,
                    class: "text-secondary hover:underline"
                  }, " ... ", 8, cV)),
                  a.value && (((V = se(g)) == null ? void 0 : V.length) || 0) > m ? (Ve(), it("button", {
                    key: 1,
                    title: se(o)("Hide full description", {
                      ns: "client"
                    }),
                    onClick: T,
                    class: "text-secondary hover:underline"
                  }, " - ", 8, hV)) : Je("v-if", !0)
                ])
              ])) : Je("v-if", !0),
              h.value.legalConstraints ? (Ve(), on(Kp, {
                key: 3,
                label: se(o)("Contrainte d'utilisation"),
                value: h.value.legalConstraints
              }, null, 8, ["label", "value"])) : Je("v-if", !0),
              ((q = h.value.link) == null ? void 0 : q.length) !== 0 ? (Ve(), it("div", fV, [
                (Ve(!0), it(cn, null, Ra(h.value.link, (be) => (Ve(), it("div", {
                  class: "grid gap-2 grid-cols-3",
                  key: be
                }, [
                  ze("span", pV, Gt(se(o)("Url vers la resource")), 1),
                  ze("span", dV, [
                    ze("a", {
                      class: "text-secondary hover:underline",
                      target: "_blank",
                      href: be
                    }, Gt(be), 9, mV)
                  ])
                ]))), 128))
              ])) : Je("v-if", !0),
              h.value.revisionDate ? (Ve(), on(Kp, {
                key: 5,
                label: se(o)("Revision date"),
                value: se(q8)(h.value.revisionDate, se(s).language)
              }, null, 8, ["label", "value"])) : Je("v-if", !0),
              h.value.keyword ? (Ve(), on(Kp, {
                key: 6,
                label: se(o)("Keywords"),
                value: (re = h.value.keyword) == null ? void 0 : re.join(",")
              }, null, 8, ["label", "value"])) : Je("v-if", !0),
              h.value.responsibleParty ? (Ve(), it("div", yV, [
                ze("div", gV, Gt(se(o)("Contact")), 1),
                ze("div", vV, [
                  (X = h.value.responsibleParty) != null && X.organisaton ? (Ve(), it("p", _V, Gt((ae = h.value.responsibleParty) == null ? void 0 : ae.organisaton), 1)) : Je("v-if", !0),
                  (ce = h.value.responsibleParty) != null && ce.name ? (Ve(), it("p", xV, Gt((ve = h.value.responsibleParty) == null ? void 0 : ve.name), 1)) : Je("v-if", !0),
                  (Re = h.value.responsibleParty) != null && Re.unknown ? (Ve(), it("p", bV, Gt((Fe = h.value.responsibleParty) == null ? void 0 : Fe.unknown), 1)) : Je("v-if", !0),
                  (Pe = h.value.responsibleParty) != null && Pe.address ? (Ve(), it("p", wV, Gt((Se = h.value.responsibleParty) == null ? void 0 : Se.address), 1)) : Je("v-if", !0),
                  (Ie = h.value.responsibleParty) != null && Ie.email ? (Ve(), it("p", EV, [
                    ze("a", {
                      class: "text-secondary hover:underline",
                      href: "mailto:" + ((Xe = h.value.responsibleParty) == null ? void 0 : Xe.email)
                    }, Gt(($e = h.value.responsibleParty) == null ? void 0 : $e.email), 9, SV)
                  ])) : Je("v-if", !0)
                ])
              ])) : Je("v-if", !0),
              h.value.metadataLink ? (Ve(), it("div", TV, [
                ze("span", MV, Gt(se(o)("Link to the metadata")), 1),
                ze("span", IV, [
                  ze("a", {
                    class: "text-secondary hover:underline",
                    target: "_blank",
                    href: h.value.metadataLink
                  }, Gt(se(o)("link")), 9, OV)
                ])
              ])) : Je("v-if", !0),
              h.value.isError ? (Ve(), it("div", CV, Gt(se(o)("The metadata is right now not available")), 1)) : Je("v-if", !0),
              h.value.legendHtml ? (Ve(), it("div", AV, [
                ze("h4", PV, Gt(se(o)("Legend")), 1),
                Mg(ze("span", null, null, 512), [
                  [z, (at = h.value.legendHtml) == null ? void 0 : at.innerHTML]
                ])
              ])) : Je("v-if", !0),
              h.value.hasLegend ? Je("v-if", !0) : (Ve(), it("div", kV, Gt(se(o)("The legend is not available for this layer")), 1))
            ])
          ];
        }),
        _: 1
      }, 8, ["title"])) : Je("v-if", !0);
    };
  }
}), DV = /* @__PURE__ */ ur(LV, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-metadata/layer-metadata.vue"]]), NV = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM0AAAAoCAMAAABq645qAAACPVBMVEUAAABaW13////tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy5DjxTaAAAAvXRSTlMAAAABAgMEBQYHCAkKCwwNDg8QERESFBUWFxkaGx0eHyAhIiInKSosMTIzNTY5Ojs8PUFCQ0RERkpMTk9QU1RVVldaXmFjZWZmamtwcXJzdXd3eHl7fX+AgYKDhIaHiIiKi4yOj5CTlJWWl5iZmZqcnZ+goaKjpKanqKqqq6ywsbK0tbW4u7u8vb6/wMHExcbHysvMzM7P0NDS1NXa29zd3t/g4eTl5ujp6uvs7e7u8PLz9PX29/j5+vv8/f5cALqzAAAEcklEQVRo3u3Z+ZPUVBAH8O63LsLKijoIgotHFI+HgiKNeGC8MCqgUUFAJYjgAQ6HKMgGEQQiqChIPFh1iciiwPIEhvv49t/mD5lBORa2tHbLTO2rmqnUTCrJZ3r65ZuEjDHGGLrMWGcKMah7mh/7NP8PzXBqbqgfzdtPb7i/fjQPvq8r5jUVXNNIY4moYeL6+XNfn9Ov6LUZ2/Z7Pxo3YaZWTp/uLPw/reXYbqLRPz/38g+qJ/oTEV396IzmgmquXHZoIRHd/sTs31T1DqIBcyqHZjQWtTbf6nQiokHLVVWn7ju4euXGjsX9LtTAGgPAGGMzOPZSOGFYtmAXsO8skFkgZovQgi2QcZKyIGAAjJQtIgAB/5vRTc2IvbqSqOWNJQdUVdfe+/zitmsu2jeQ/GWMC43HacRhxhAWcJRyEgmYBSVYgROwgJkzeGVEDGEGotqnPaih1Xp63KSvVFVVtz0wt23AvMVda5AZY2FM7OWO/N2DwBMgESBiQZyABUgYSYQkYSBjhAh7QXN3Zfey7YdyzXh6aQpdu2fIpWsD30CykKOU4XPgmBPEnNcmC1jgIT9uCx9ZkOW1kQi9oBm6aMvO3KIVomUPES19/KIaoNo34uA8cUgtB4DzmQXCFoCFhbXgMtgC8DNGKMj7xnIKtj2toeGf55X5c9+ZRpo1lWjyq5c/33Avj+5obpz25miiwd+p6q4/2jfvIrqtrYlemF5MzZObTuhHCw6cUd2y/91ftj5DRJOn0JKniqm56jPtUNXDx44u6NywvaPzPqL+G5v3jCimhhqaX/vyi6VTxtzyYkVV9dSsRvrmnVXUI5oo7GkNEV2RH/igaRVV1Y8fOdE+tEc0tlzqBU1tND+7U1W18t51F8/QAFJrkUccL4VjABFb+MwoMyznszWzBZxfDT2SIbZgm0/TzBbIpLqcr8GwScJxfF4UiliAgGEZ1gKx8VK4bmuafmpdrqr6cFdXBJBSORPkp9A0ZI8hAi4jYQY8CEN8MDML2K/FBBdwKU80kOp3eSBirq7BkJJLstK5UShw+eYhDBGUYNPQeN3WTND2rd+r6oquNUZQ00A49gCEJQg8RhJD8j0DQX6IEBZYMLMAAANZrpHa8lkNBwjOi0Ion90KRIDIQEzsdVfzlurhT1X11F2XqE3qwfNQMiYLGYIYNgAQMcTltXHV3z9w1dAD/8LapH/XJt9eycWudG4U8lGrjYeSIAtMFlaD1SU1NxAR0cA9qrpqr6ruaOmybxLPREBojLEOzoMNkAXsO4YNYRnIpNo3WS30+EByXt+kttY3AEdAyGmZ4/TcKORCDgDhEAg5D0wO7vK1mbmwhajxA9XWkXTTh8dVj6wZX9gr6ZFL9eTm1nbVhUREdOs2Vb25sJqmRTuOq+r+rwfmgGEHVYcU+H7a8KNrdP6kYTXBJ6qPFVjT2DxwzD/msbWqE+vnrvqvevSeutGMUm0dXC+ahk3asb5unt+8cvLIqOvr52nU7Dv7nq31afo0/0mzrhiavwAx1n2SsZnMdgAAAABJRU5ErkJggg==";
class RV {
  bootstrap() {
    this.restore();
    let e;
    e = va(() => {
      this.persist(), e && e();
    });
  }
  persist() {
    const e = ki(), { lang: n } = xn(e);
    Pn(
      n,
      (o, s) => {
        s !== o && (Cr.setValue(Du, o), document.documentElement.setAttribute("lang", o));
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Cr.getValue(Du);
    if (e) {
      const { setLang: n } = ki(), { i18next: o } = En();
      o.changeLanguage(e), n(e);
    }
  }
}
const zV = new RV(), FV = /* @__PURE__ */ ar({
  __name: "language-selector",
  setup(t) {
    const { i18next: e, t: n } = En(), { setLang: o } = ki(), { lang: s } = xn(ki()), h = or(
      () => ["en", "de", "fr", "lb"].map((g) => ({
        label: n(g),
        value: g,
        ariaLabel: n("Changer de langue : {{lang}}", { lang: g })
      }))
    ), a = n("Changer de langue");
    zV.bootstrap();
    function m(g) {
      e.changeLanguage(g), o(g);
    }
    return (g, b) => (Ve(), it("div", null, [
      Ft(RT, {
        class: "lux-navbar-dropdown lux-dropdown-inline text-white h-full",
        options: se(h),
        placeholder: se(a),
        modelValue: se(s),
        "onUpdate:modelValue": b[0] || (b[0] = (T) => hn(s) ? s.value = T : null),
        onChange: m
      }, null, 8, ["options", "placeholder", "modelValue"])
    ]));
  }
}), BV = /* @__PURE__ */ ur(FV, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/nav-bars/language-selector.vue"]]);
class VV {
  setCurrentThemeColors(e) {
    const n = document.querySelector(":root");
    ["primary", "secondary", "tertiary"].forEach((s) => {
      const h = getComputedStyle(n).getPropertyValue(
        `--${e}-${s}`
      );
      n.style.setProperty(`--color-${s}`, h);
    });
  }
}
const UV = new VV(), jV = { class: "w-full h-14 flex bg-white shadow-header z-10 shrink-0" }, GV = /* @__PURE__ */ ze("div", { class: "flex-2 p-[5px]" }, [
  /* @__PURE__ */ ze("img", { src: NV })
], -1), $V = /* @__PURE__ */ ze("div", { class: "grow text-center" }, "search", -1), qV = { class: "h-full flex" }, WV = { class: "hidden lg:inline-block" }, HV = { class: "border-l-[1px] border-stone-300 h-full" }, ZV = /* @__PURE__ */ ar({
  __name: "header-bar",
  setup(t) {
    const { t: e } = En(), n = ki(), { layersOpen: o, myLayersTabOpen: s, themeGridOpen: h } = xn(n), { setLayersOpen: a, setMyLayersTabOpen: m, setThemeGridOpen: g } = n, b = Ro(), { theme: T } = xn(b);
    Pn(
      T,
      (I) => {
        I && UV.setCurrentThemeColors(I.name);
      },
      { immediate: !0 }
    );
    function M() {
      o.value ? o.value && (h.value ? a(!1) : (s.value && m(!1), g(!0))) : (a(!0), s.value && m(!1), g(!0));
    }
    return (I, P) => {
      var z, V;
      return Ve(), it("header", jV, [
        GV,
        $V,
        ze("div", null, [
          ze("ul", qV, [
            ze("li", null, [
              ze("button", {
                class: Pr(["flex items-center before:font-icons before:text-3xl before:w-16 text-primary uppercase h-full mr-3", `before:content-${(z = se(T)) == null ? void 0 : z.name}`]),
                onClick: M
              }, [
                ze("span", WV, Gt(se(e)(`${(V = se(T)) == null ? void 0 : V.name}`)), 1)
              ], 2)
            ]),
            ze("li", HV, [
              Ft(BV, { class: "flex-none h-full" })
            ])
          ])
        ])
      ]);
    };
  }
}), XV = /* @__PURE__ */ ur(ZV, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/header/header-bar.vue"]]), KV = { class: "block text-[13px] sm:text-base uppercase" }, YV = /* @__PURE__ */ ar({
  __name: "button-icon",
  props: {
    label: { type: String, required: !0 },
    icon: { type: String, required: !0 },
    active: { type: Boolean, required: !1 }
  },
  setup(t) {
    const e = t;
    return (n, o) => (Ve(), it("button", {
      class: Pr(["h-[42px] w-full sm:h-full sm:w-16 hover:text-white hover:bg-primary", e.active ? "bg-primary text-white" : ""])
    }, [
      ze("span", {
        class: Pr(["block text-[1.7rem] sm:text-[2rem] -mt-1.5 -mb-3 after:font-icons", e.active ? "lux-close-cross" : `after:content-${e.icon}`])
      }, null, 2),
      ze("span", KV, Gt(e.label), 1)
    ], 2));
  }
}), Dl = /* @__PURE__ */ ur(YV, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/footer/button-icon.vue"]]), JV = ["href"], QV = /* @__PURE__ */ ar({
  __name: "button-link",
  props: {
    label: { type: String, required: !0 },
    link: { type: String, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, o) => (Ve(), it("a", {
      class: "h-full flex flex-col justify-center px-[7px] uppercase hover:text-white hover:bg-primary",
      href: `${e.link}`,
      target: "_blank"
    }, Gt(n.$props.label), 9, JV));
  }
}), xu = /* @__PURE__ */ ur(QV, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/footer/button-link.vue"]]), eU = { class: "flex flex-col w-12 justify-between bg-white z-5 shrink-0 sm:flex-row sm:w-full sm:h-14 sm:shadow-footer" }, tU = { class: "flex flex-col w-full sm:w-80 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" }, rU = { class: "flex flex-col w-12 sm:w-64 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" }, nU = { class: "w-[466px] hidden sm:flex flex-row justify-end text-gray-500 whitespace-nowrap" }, iU = /* @__PURE__ */ ar({
  __name: "footer-bar",
  setup(t) {
    const { t: e, i18next: n } = En(), { setLayersOpen: o } = ki(), { layersOpen: s } = xn(ki());
    return (h, a) => (Ve(), it("footer", eU, [
      Je(" left buttons "),
      ze("ul", tU, [
        ze("li", null, [
          Ft(Dl, {
            label: se(e)("Layers", { ns: "client" }),
            icon: "layers",
            active: se(s),
            onClick: a[0] || (a[0] = () => se(o)(!se(s)))
          }, null, 8, ["label", "active"])
        ]),
        Je(`TODOs in each button when implemented
        - remove class="text-gray-300"
        - add click handler that calls setLayersOpen(true) and opens tool (also via app store)
      `),
        ze("li", null, [
          Ft(Dl, {
            class: "text-gray-300",
            label: se(e)("My Maps", { ns: "client" }),
            icon: "mymaps"
          }, null, 8, ["label"])
        ]),
        ze("li", null, [
          Ft(Dl, {
            class: "text-gray-300",
            label: se(e)("Infos", { ns: "client" }),
            icon: "infos"
          }, null, 8, ["label"])
        ]),
        ze("li", null, [
          Ft(Dl, {
            class: "text-gray-300",
            label: se(e)("Legends", { ns: "client" }),
            icon: "legends"
          }, null, 8, ["label"])
        ]),
        ze("li", null, [
          Ft(Dl, {
            class: "text-gray-300",
            label: se(e)("Routing", { ns: "client" }),
            icon: "routing"
          }, null, 8, ["label"])
        ])
      ]),
      Je(" center buttons "),
      ze("div", rU, [
        Ft(Dl, {
          class: "text-gray-300",
          label: se(e)("Dessin", { ns: "client" }),
          icon: "draw"
        }, null, 8, ["label"]),
        Ft(Dl, {
          class: "text-gray-300 hidden sm:block",
          label: se(e)("Mesurer", { ns: "client" }),
          icon: "measure"
        }, null, 8, ["label"]),
        Ft(Dl, {
          class: "text-gray-300 hidden sm:block",
          label: se(e)("Imprimer", { ns: "client" }),
          icon: "print"
        }, null, 8, ["label"]),
        Ft(Dl, {
          class: "text-gray-300",
          label: se(e)("Partager", { ns: "client" }),
          icon: "share"
        }, null, 8, ["label"])
      ]),
      Je(" right buttons "),
      ze("div", nU, [
        Ft(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("What's new", { ns: "client" }),
          link: `https://geoportail.lu/${se(n).language}/questions/whats-new/`
        }, null, 8, ["label", "link"]),
        Je("TODO get geonetworkBaseUrl from config"),
        Ft(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("Geocatalogue", { ns: "client" }),
          link: ""
        }, null, 8, ["label"]),
        Je("TODO handle feedback links (for different portals?)"),
        Ft(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("Feedback", { ns: "client" }),
          link: ""
        }, null, 8, ["label"]),
        Ft(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("A Propos", { ns: "client" }),
          link: `https://www.geoportail.lu/${se(n).language}/propos/`
        }, null, 8, ["label", "link"]),
        Ft(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("Aide", { ns: "client" }),
          link: `https://www.geoportail.lu/${se(n).language}/documentation/`
        }, null, 8, ["label", "link"]),
        Ft(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("Contact", { ns: "client" }),
          link: `https://www.geoportail.lu/${se(n).language}/propos/contactez-nous/`
        }, null, 8, ["label", "link"]),
        Ft(xu, {
          class: "text-gray-500",
          label: se(e)("Legalites", { ns: "client" }),
          link: `https://www.geoportail.lu/${se(n).language}/propos/mentions-legales/`
        }, null, 8, ["label", "link"]),
        Ft(xu, {
          class: "text-gray-500",
          label: se(e)("ACT", { ns: "client" }),
          link: "http://www.act.public.lu/"
        }, null, 8, ["label", "link"])
      ])
    ]));
  }
}), oU = /* @__PURE__ */ ur(iU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/footer/footer-bar.vue"]]), aU = { class: "flex flex-row flex-wrap pl-2.5" }, sU = ["onClick"], lU = { class: "text-2xl absolute top-5" }, uU = /* @__PURE__ */ ar({
  __name: "theme-grid",
  props: {
    themes: { type: Array, required: !0 }
  },
  setup(t) {
    const e = t, { t: n } = En();
    return (o, s) => (Ve(), it("div", aU, [
      (Ve(!0), it(cn, null, Ra(e.themes, (h) => (Ve(), it("button", {
        class: Pr(["relative shrink-0 h-[150px] w-1/2 px-2.5 text-start text-gray-100/40 uppercase hover:bg-[#ccc]", `bg-${h.name}-primary hover:text-${h.name}-primary`]),
        key: h.id,
        onClick: (a) => o.$emit("setTheme", h.name)
      }, [
        ze("div", lU, Gt(se(n)(`${h.name}`)), 1),
        ze("div", {
          class: Pr(["text-6xl absolute bottom-1 after:font-icons", `after:content-${h.name}`])
        }, null, 2)
      ], 10, sU))), 128))
    ]));
  }
}), cU = /* @__PURE__ */ ur(uU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/theme-selector/theme-grid.vue"]]), hU = ["aria-expanded"], fU = { class: "py-0.5" }, pU = { class: "px-1 py-0.5 shrink-0 flex flex-row text-[12px] bg-secondary text-white" }, dU = { class: "py-[3px]" }, mU = { class: "flex flex-row flex-wrap ml-1 w-12" }, yU = /* @__PURE__ */ ar({
  __name: "theme-selector-button",
  props: {
    themes: { type: Array, required: !0 },
    currentTheme: { type: null, required: !1 },
    isOpen: { type: Boolean, required: !1 }
  },
  setup(t) {
    const e = t, { t: n } = En(), o = or(() => {
      var s;
      return ((s = e.themes) == null ? void 0 : s.slice(0, 8)) || [];
    });
    return (s, h) => {
      var a;
      return Ve(), it("button", {
        class: "w-full flex flex-row justify-between bg-tertiary text-white px-2 py-1.5 uppercase cursor-pointer hover:bg-white hover:text-primary",
        "aria-expanded": e.isOpen
      }, [
        ze("span", fU, Gt(se(n)("Theme")) + ": " + Gt(se(n)(`${(a = e.currentTheme) == null ? void 0 : a.name}`)), 1),
        ze("span", pU, [
          ze("span", dU, Gt(se(n)("Changer")), 1),
          ze("span", mU, [
            (Ve(!0), it(cn, null, Ra(se(o), (m) => (Ve(), it("div", {
              class: Pr(`h-2.5 w-2.5 m-px bg-${m.name}-primary`),
              key: m.id
            }, null, 2))), 128))
          ])
        ])
      ], 8, hU);
    };
  }
}), gU = /* @__PURE__ */ ur(yU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/theme-selector/theme-selector-button.vue"]]), vU = {
  key: 0,
  class: "absolute inset-x-0 top-14 bottom-0 mt-1 bg-primary overflow-y-auto overflow-x-hidden"
}, _U = /* @__PURE__ */ ar({
  __name: "theme-selector",
  setup(t) {
    const e = ki(), { setThemeGridOpen: n } = e, { themeGridOpen: o } = xn(e), s = Ro(), h = Xc(), { theme: a, themes: m } = xn(s), g = or(
      () => {
        var M;
        return ((M = m.value) == null ? void 0 : M.filter(
          (I) => {
            var P;
            return ((P = I.metadata) == null ? void 0 : P.display_in_switcher) === !0;
          }
        )) || [];
      }
    );
    function b() {
      n(!o.value);
    }
    function T(M) {
      h.setTheme(M), b();
    }
    return (M, I) => (Ve(), it(cn, null, [
      Ft(gU, {
        onClick: b,
        themes: se(g),
        currentTheme: se(a),
        isOpen: se(o)
      }, null, 8, ["themes", "currentTheme", "isOpen"]),
      se(o) ? (Ve(), it("div", vU, [
        Ft(cU, {
          onSetTheme: T,
          themes: se(g)
        }, null, 8, ["themes"])
      ])) : Je("v-if", !0)
    ], 64));
  }
}), xU = /* @__PURE__ */ ur(_U, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/theme-selector/theme-selector.vue"]]);
function h1(t, e = 0) {
  const { name: n, id: o, children: s, metadata: h } = t;
  return {
    name: n,
    id: o,
    depth: e,
    children: s == null ? void 0 : s.map((a) => h1(a, e + 1)),
    checked: !1,
    expanded: (h == null ? void 0 : h.is_expanded) || !1
  };
}
const bU = {
  key: 0,
  class: "mb-7"
}, wU = /* @__PURE__ */ ar({
  __name: "catalog-tree",
  setup(t) {
    const e = Ei(), n = Ro(), o = hs(), s = Bn(), h = Bn(), a = or(
      () => !e.is3dActive || e.is3dActive && !e.is3dMesh
    ), { layerTrees_3d: m } = xn(n);
    va(g);
    function g() {
      var M;
      if (n.theme && e.layers) {
        const I = s.value && s.value.id === ((M = n.theme) == null ? void 0 : M.id) ? s.value : h1(n.theme);
        s.value = Pf.updateLayers(
          I,
          e.layers
        );
      }
    }
    va(() => {
      if (m.value) {
        const M = h.value ? h.value : h1(m.value);
        h.value = Pf.updateLayers(
          M,
          e.layers3d
        );
      }
    });
    function b(M, I) {
      const P = I ? h : s;
      P.value = Pf.toggleNode(
        M.id,
        P.value,
        "expanded"
      );
    }
    function T(M, I) {
      o.toggleLayer(+M.id, !M.checked, I);
    }
    return (M, I) => (Ve(), it("div", null, [
      Je(" 3D layers catalog, only displayed when 3D is active "),
      se(h) && se(e).is3dActive ? (Ve(), it("div", bU, [
        (Ve(), on(u1, {
          node: se(h),
          key: se(h).id,
          onToggleParent: I[0] || (I[0] = (P) => b(P, !0)),
          onToggleLayer: I[1] || (I[1] = (P) => T(P, !0))
        }, null, 8, ["node"]))
      ])) : Je("v-if", !0),
      Je(" Main catalog, displays by default and 3D terrain active "),
      se(s) && se(a) ? (Ve(), on(u1, {
        node: se(s),
        key: se(s).id,
        onToggleParent: I[2] || (I[2] = (P) => b(P, !1)),
        onToggleLayer: I[3] || (I[3] = (P) => T(P, !1))
      }, null, 8, ["node"])) : Je("v-if", !0)
    ]));
  }
}), EU = /* @__PURE__ */ ur(wU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/catalog/catalog-tree.vue"]]), SU = /* @__PURE__ */ ar({
  __name: "catalog-tab",
  setup(t) {
    const { themeGridOpen: e } = xn(ki());
    return (n, o) => (Ve(), it(cn, null, [
      Ft(xU),
      se(e) === !1 ? (Ve(), on(EU, {
        key: 0,
        class: "pt-5 absolute inset-x-2.5 bg-primary overflow-y-auto overflow-x-hidden"
      })) : Je("v-if", !0)
    ], 64));
  }
}), TU = /* @__PURE__ */ ur(SU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/catalog/catalog-tab.vue"]]);
/**!
 * Sortable 1.15.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function cE(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function rl(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? cE(Object(n), !0).forEach(function(o) {
      MU(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : cE(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function fg(t) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? fg = function(e) {
    return typeof e;
  } : fg = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, fg(t);
}
function MU(t, e, n) {
  return e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Wl() {
  return Wl = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Wl.apply(this, arguments);
}
function IU(t, e) {
  if (t == null)
    return {};
  var n = {}, o = Object.keys(t), s, h;
  for (h = 0; h < o.length; h++)
    s = o[h], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
function OU(t, e) {
  if (t == null)
    return {};
  var n = IU(t, e), o, s;
  if (Object.getOwnPropertySymbols) {
    var h = Object.getOwnPropertySymbols(t);
    for (s = 0; s < h.length; s++)
      o = h[s], !(e.indexOf(o) >= 0) && (!Object.prototype.propertyIsEnumerable.call(t, o) || (n[o] = t[o]));
  }
  return n;
}
var CU = "1.15.2";
function Ul(t) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(t);
}
var Xl = Ul(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), im = Ul(/Edge/i), hE = Ul(/firefox/i), _d = Ul(/safari/i) && !Ul(/chrome/i) && !Ul(/android/i), _I = Ul(/iP(ad|od|hone)/i), xI = Ul(/chrome/i) && Ul(/android/i), bI = {
  capture: !1,
  passive: !1
};
function nn(t, e, n) {
  t.addEventListener(e, n, !Xl && bI);
}
function Kr(t, e, n) {
  t.removeEventListener(e, n, !Xl && bI);
}
function Qg(t, e) {
  if (!!e) {
    if (e[0] === ">" && (e = e.substring(1)), t)
      try {
        if (t.matches)
          return t.matches(e);
        if (t.msMatchesSelector)
          return t.msMatchesSelector(e);
        if (t.webkitMatchesSelector)
          return t.webkitMatchesSelector(e);
      } catch {
        return !1;
      }
    return !1;
  }
}
function AU(t) {
  return t.host && t !== document && t.host.nodeType ? t.host : t.parentNode;
}
function ts(t, e, n, o) {
  if (t) {
    n = n || document;
    do {
      if (e != null && (e[0] === ">" ? t.parentNode === n && Qg(t, e) : Qg(t, e)) || o && t === n)
        return t;
      if (t === n)
        break;
    } while (t = AU(t));
  }
  return null;
}
var fE = /\s+/g;
function ha(t, e, n) {
  if (t && e)
    if (t.classList)
      t.classList[n ? "add" : "remove"](e);
    else {
      var o = (" " + t.className + " ").replace(fE, " ").replace(" " + e + " ", " ");
      t.className = (o + (n ? " " + e : "")).replace(fE, " ");
    }
}
function cr(t, e, n) {
  var o = t && t.style;
  if (o) {
    if (n === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(t, "") : t.currentStyle && (n = t.currentStyle), e === void 0 ? n : n[e];
    !(e in o) && e.indexOf("webkit") === -1 && (e = "-webkit-" + e), o[e] = n + (typeof n == "string" ? "" : "px");
  }
}
function kf(t, e) {
  var n = "";
  if (typeof t == "string")
    n = t;
  else
    do {
      var o = cr(t, "transform");
      o && o !== "none" && (n = o + " " + n);
    } while (!e && (t = t.parentNode));
  var s = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return s && new s(n);
}
function wI(t, e, n) {
  if (t) {
    var o = t.getElementsByTagName(e), s = 0, h = o.length;
    if (n)
      for (; s < h; s++)
        n(o[s], s);
    return o;
  }
  return [];
}
function Js() {
  var t = document.scrollingElement;
  return t || document.documentElement;
}
function Pi(t, e, n, o, s) {
  if (!(!t.getBoundingClientRect && t !== window)) {
    var h, a, m, g, b, T, M;
    if (t !== window && t.parentNode && t !== Js() ? (h = t.getBoundingClientRect(), a = h.top, m = h.left, g = h.bottom, b = h.right, T = h.height, M = h.width) : (a = 0, m = 0, g = window.innerHeight, b = window.innerWidth, T = window.innerHeight, M = window.innerWidth), (e || n) && t !== window && (s = s || t.parentNode, !Xl))
      do
        if (s && s.getBoundingClientRect && (cr(s, "transform") !== "none" || n && cr(s, "position") !== "static")) {
          var I = s.getBoundingClientRect();
          a -= I.top + parseInt(cr(s, "border-top-width")), m -= I.left + parseInt(cr(s, "border-left-width")), g = a + h.height, b = m + h.width;
          break;
        }
      while (s = s.parentNode);
    if (o && t !== window) {
      var P = kf(s || t), z = P && P.a, V = P && P.d;
      P && (a /= V, m /= z, M /= z, T /= V, g = a + T, b = m + M);
    }
    return {
      top: a,
      left: m,
      bottom: g,
      right: b,
      width: M,
      height: T
    };
  }
}
function pE(t, e, n) {
  for (var o = Cu(t, !0), s = Pi(t)[e]; o; ) {
    var h = Pi(o)[n], a = void 0;
    if (n === "top" || n === "left" ? a = s >= h : a = s <= h, !a)
      return o;
    if (o === Js())
      break;
    o = Cu(o, !1);
  }
  return !1;
}
function Ff(t, e, n, o) {
  for (var s = 0, h = 0, a = t.children; h < a.length; ) {
    if (a[h].style.display !== "none" && a[h] !== lr.ghost && (o || a[h] !== lr.dragged) && ts(a[h], n.draggable, t, !1)) {
      if (s === e)
        return a[h];
      s++;
    }
    h++;
  }
  return null;
}
function lx(t, e) {
  for (var n = t.lastElementChild; n && (n === lr.ghost || cr(n, "display") === "none" || e && !Qg(n, e)); )
    n = n.previousElementSibling;
  return n || null;
}
function Pa(t, e) {
  var n = 0;
  if (!t || !t.parentNode)
    return -1;
  for (; t = t.previousElementSibling; )
    t.nodeName.toUpperCase() !== "TEMPLATE" && t !== lr.clone && (!e || Qg(t, e)) && n++;
  return n;
}
function dE(t) {
  var e = 0, n = 0, o = Js();
  if (t)
    do {
      var s = kf(t), h = s.a, a = s.d;
      e += t.scrollLeft * h, n += t.scrollTop * a;
    } while (t !== o && (t = t.parentNode));
  return [e, n];
}
function PU(t, e) {
  for (var n in t)
    if (!!t.hasOwnProperty(n)) {
      for (var o in e)
        if (e.hasOwnProperty(o) && e[o] === t[n][o])
          return Number(n);
    }
  return -1;
}
function Cu(t, e) {
  if (!t || !t.getBoundingClientRect)
    return Js();
  var n = t, o = !1;
  do
    if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) {
      var s = cr(n);
      if (n.clientWidth < n.scrollWidth && (s.overflowX == "auto" || s.overflowX == "scroll") || n.clientHeight < n.scrollHeight && (s.overflowY == "auto" || s.overflowY == "scroll")) {
        if (!n.getBoundingClientRect || n === document.body)
          return Js();
        if (o || e)
          return n;
        o = !0;
      }
    }
  while (n = n.parentNode);
  return Js();
}
function kU(t, e) {
  if (t && e)
    for (var n in e)
      e.hasOwnProperty(n) && (t[n] = e[n]);
  return t;
}
function h0(t, e) {
  return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width);
}
var xd;
function EI(t, e) {
  return function() {
    if (!xd) {
      var n = arguments, o = this;
      n.length === 1 ? t.call(o, n[0]) : t.apply(o, n), xd = setTimeout(function() {
        xd = void 0;
      }, e);
    }
  };
}
function LU() {
  clearTimeout(xd), xd = void 0;
}
function SI(t, e, n) {
  t.scrollLeft += e, t.scrollTop += n;
}
function TI(t) {
  var e = window.Polymer, n = window.jQuery || window.Zepto;
  return e && e.dom ? e.dom(t).cloneNode(!0) : n ? n(t).clone(!0)[0] : t.cloneNode(!0);
}
function MI(t, e, n) {
  var o = {};
  return Array.from(t.children).forEach(function(s) {
    var h, a, m, g;
    if (!(!ts(s, e.draggable, t, !1) || s.animated || s === n)) {
      var b = Pi(s);
      o.left = Math.min((h = o.left) !== null && h !== void 0 ? h : 1 / 0, b.left), o.top = Math.min((a = o.top) !== null && a !== void 0 ? a : 1 / 0, b.top), o.right = Math.max((m = o.right) !== null && m !== void 0 ? m : -1 / 0, b.right), o.bottom = Math.max((g = o.bottom) !== null && g !== void 0 ? g : -1 / 0, b.bottom);
    }
  }), o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
var ma = "Sortable" + new Date().getTime();
function DU() {
  var t = [], e;
  return {
    captureAnimationState: function() {
      if (t = [], !!this.options.animation) {
        var o = [].slice.call(this.el.children);
        o.forEach(function(s) {
          if (!(cr(s, "display") === "none" || s === lr.ghost)) {
            t.push({
              target: s,
              rect: Pi(s)
            });
            var h = rl({}, t[t.length - 1].rect);
            if (s.thisAnimationDuration) {
              var a = kf(s, !0);
              a && (h.top -= a.f, h.left -= a.e);
            }
            s.fromRect = h;
          }
        });
      }
    },
    addAnimationState: function(o) {
      t.push(o);
    },
    removeAnimationState: function(o) {
      t.splice(PU(t, {
        target: o
      }), 1);
    },
    animateAll: function(o) {
      var s = this;
      if (!this.options.animation) {
        clearTimeout(e), typeof o == "function" && o();
        return;
      }
      var h = !1, a = 0;
      t.forEach(function(m) {
        var g = 0, b = m.target, T = b.fromRect, M = Pi(b), I = b.prevFromRect, P = b.prevToRect, z = m.rect, V = kf(b, !0);
        V && (M.top -= V.f, M.left -= V.e), b.toRect = M, b.thisAnimationDuration && h0(I, M) && !h0(T, M) && (z.top - M.top) / (z.left - M.left) === (T.top - M.top) / (T.left - M.left) && (g = RU(z, I, P, s.options)), h0(M, T) || (b.prevFromRect = T, b.prevToRect = M, g || (g = s.options.animation), s.animate(b, z, M, g)), g && (h = !0, a = Math.max(a, g), clearTimeout(b.animationResetTimer), b.animationResetTimer = setTimeout(function() {
          b.animationTime = 0, b.prevFromRect = null, b.fromRect = null, b.prevToRect = null, b.thisAnimationDuration = null;
        }, g), b.thisAnimationDuration = g);
      }), clearTimeout(e), h ? e = setTimeout(function() {
        typeof o == "function" && o();
      }, a) : typeof o == "function" && o(), t = [];
    },
    animate: function(o, s, h, a) {
      if (a) {
        cr(o, "transition", ""), cr(o, "transform", "");
        var m = kf(this.el), g = m && m.a, b = m && m.d, T = (s.left - h.left) / (g || 1), M = (s.top - h.top) / (b || 1);
        o.animatingX = !!T, o.animatingY = !!M, cr(o, "transform", "translate3d(" + T + "px," + M + "px,0)"), this.forRepaintDummy = NU(o), cr(o, "transition", "transform " + a + "ms" + (this.options.easing ? " " + this.options.easing : "")), cr(o, "transform", "translate3d(0,0,0)"), typeof o.animated == "number" && clearTimeout(o.animated), o.animated = setTimeout(function() {
          cr(o, "transition", ""), cr(o, "transform", ""), o.animated = !1, o.animatingX = !1, o.animatingY = !1;
        }, a);
      }
    }
  };
}
function NU(t) {
  return t.offsetWidth;
}
function RU(t, e, n, o) {
  return Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) / Math.sqrt(Math.pow(e.top - n.top, 2) + Math.pow(e.left - n.left, 2)) * o.animation;
}
var uf = [], f0 = {
  initializeByDefault: !0
}, om = {
  mount: function(e) {
    for (var n in f0)
      f0.hasOwnProperty(n) && !(n in e) && (e[n] = f0[n]);
    uf.forEach(function(o) {
      if (o.pluginName === e.pluginName)
        throw "Sortable: Cannot mount plugin ".concat(e.pluginName, " more than once");
    }), uf.push(e);
  },
  pluginEvent: function(e, n, o) {
    var s = this;
    this.eventCanceled = !1, o.cancel = function() {
      s.eventCanceled = !0;
    };
    var h = e + "Global";
    uf.forEach(function(a) {
      !n[a.pluginName] || (n[a.pluginName][h] && n[a.pluginName][h](rl({
        sortable: n
      }, o)), n.options[a.pluginName] && n[a.pluginName][e] && n[a.pluginName][e](rl({
        sortable: n
      }, o)));
    });
  },
  initializePlugins: function(e, n, o, s) {
    uf.forEach(function(m) {
      var g = m.pluginName;
      if (!(!e.options[g] && !m.initializeByDefault)) {
        var b = new m(e, n, e.options);
        b.sortable = e, b.options = e.options, e[g] = b, Wl(o, b.defaults);
      }
    });
    for (var h in e.options)
      if (!!e.options.hasOwnProperty(h)) {
        var a = this.modifyOption(e, h, e.options[h]);
        typeof a < "u" && (e.options[h] = a);
      }
  },
  getEventProperties: function(e, n) {
    var o = {};
    return uf.forEach(function(s) {
      typeof s.eventProperties == "function" && Wl(o, s.eventProperties.call(n[s.pluginName], e));
    }), o;
  },
  modifyOption: function(e, n, o) {
    var s;
    return uf.forEach(function(h) {
      !e[h.pluginName] || h.optionListeners && typeof h.optionListeners[n] == "function" && (s = h.optionListeners[n].call(e[h.pluginName], o));
    }), s;
  }
};
function zU(t) {
  var e = t.sortable, n = t.rootEl, o = t.name, s = t.targetEl, h = t.cloneEl, a = t.toEl, m = t.fromEl, g = t.oldIndex, b = t.newIndex, T = t.oldDraggableIndex, M = t.newDraggableIndex, I = t.originalEvent, P = t.putSortable, z = t.extraEventProperties;
  if (e = e || n && n[ma], !!e) {
    var V, q = e.options, re = "on" + o.charAt(0).toUpperCase() + o.substr(1);
    window.CustomEvent && !Xl && !im ? V = new CustomEvent(o, {
      bubbles: !0,
      cancelable: !0
    }) : (V = document.createEvent("Event"), V.initEvent(o, !0, !0)), V.to = a || n, V.from = m || n, V.item = s || n, V.clone = h, V.oldIndex = g, V.newIndex = b, V.oldDraggableIndex = T, V.newDraggableIndex = M, V.originalEvent = I, V.pullMode = P ? P.lastPutMode : void 0;
    var X = rl(rl({}, z), om.getEventProperties(o, e));
    for (var ae in X)
      V[ae] = X[ae];
    n && n.dispatchEvent(V), q[re] && q[re].call(e, V);
  }
}
var FU = ["evt"], Jo = function(e, n) {
  var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = o.evt, h = OU(o, FU);
  om.pluginEvent.bind(lr)(e, n, rl({
    dragEl: St,
    parentEl: hi,
    ghostEl: xr,
    rootEl: qn,
    nextEl: Fc,
    lastDownEl: pg,
    cloneEl: ri,
    cloneHidden: Ou,
    dragStarted: ad,
    putSortable: no,
    activeSortable: lr.active,
    originalEvent: s,
    oldIndex: bf,
    oldDraggableIndex: bd,
    newIndex: fa,
    newDraggableIndex: Su,
    hideGhostForTarget: AI,
    unhideGhostForTarget: PI,
    cloneNowHidden: function() {
      Ou = !0;
    },
    cloneNowShown: function() {
      Ou = !1;
    },
    dispatchSortableEvent: function(m) {
      Lo({
        sortable: n,
        name: m,
        originalEvent: s
      });
    }
  }, h));
};
function Lo(t) {
  zU(rl({
    putSortable: no,
    cloneEl: ri,
    targetEl: St,
    rootEl: qn,
    oldIndex: bf,
    oldDraggableIndex: bd,
    newIndex: fa,
    newDraggableIndex: Su
  }, t));
}
var St, hi, xr, qn, Fc, pg, ri, Ou, bf, fa, bd, Su, Gy, no, pf = !1, ev = !1, tv = [], kc, Ja, p0, d0, mE, yE, ad, cf, wd, Ed = !1, $y = !1, dg, go, m0 = [], f1 = !1, rv = [], Rv = typeof document < "u", qy = _I, gE = im || Xl ? "cssFloat" : "float", BU = Rv && !xI && !_I && "draggable" in document.createElement("div"), II = function() {
  if (!!Rv) {
    if (Xl)
      return !1;
    var t = document.createElement("x");
    return t.style.cssText = "pointer-events:auto", t.style.pointerEvents === "auto";
  }
}(), OI = function(e, n) {
  var o = cr(e), s = parseInt(o.width) - parseInt(o.paddingLeft) - parseInt(o.paddingRight) - parseInt(o.borderLeftWidth) - parseInt(o.borderRightWidth), h = Ff(e, 0, n), a = Ff(e, 1, n), m = h && cr(h), g = a && cr(a), b = m && parseInt(m.marginLeft) + parseInt(m.marginRight) + Pi(h).width, T = g && parseInt(g.marginLeft) + parseInt(g.marginRight) + Pi(a).width;
  if (o.display === "flex")
    return o.flexDirection === "column" || o.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (o.display === "grid")
    return o.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (h && m.float && m.float !== "none") {
    var M = m.float === "left" ? "left" : "right";
    return a && (g.clear === "both" || g.clear === M) ? "vertical" : "horizontal";
  }
  return h && (m.display === "block" || m.display === "flex" || m.display === "table" || m.display === "grid" || b >= s && o[gE] === "none" || a && o[gE] === "none" && b + T > s) ? "vertical" : "horizontal";
}, VU = function(e, n, o) {
  var s = o ? e.left : e.top, h = o ? e.right : e.bottom, a = o ? e.width : e.height, m = o ? n.left : n.top, g = o ? n.right : n.bottom, b = o ? n.width : n.height;
  return s === m || h === g || s + a / 2 === m + b / 2;
}, UU = function(e, n) {
  var o;
  return tv.some(function(s) {
    var h = s[ma].options.emptyInsertThreshold;
    if (!(!h || lx(s))) {
      var a = Pi(s), m = e >= a.left - h && e <= a.right + h, g = n >= a.top - h && n <= a.bottom + h;
      if (m && g)
        return o = s;
    }
  }), o;
}, CI = function(e) {
  function n(h, a) {
    return function(m, g, b, T) {
      var M = m.options.group.name && g.options.group.name && m.options.group.name === g.options.group.name;
      if (h == null && (a || M))
        return !0;
      if (h == null || h === !1)
        return !1;
      if (a && h === "clone")
        return h;
      if (typeof h == "function")
        return n(h(m, g, b, T), a)(m, g, b, T);
      var I = (a ? m : g).options.group.name;
      return h === !0 || typeof h == "string" && h === I || h.join && h.indexOf(I) > -1;
    };
  }
  var o = {}, s = e.group;
  (!s || fg(s) != "object") && (s = {
    name: s
  }), o.name = s.name, o.checkPull = n(s.pull, !0), o.checkPut = n(s.put), o.revertClone = s.revertClone, e.group = o;
}, AI = function() {
  !II && xr && cr(xr, "display", "none");
}, PI = function() {
  !II && xr && cr(xr, "display", "");
};
Rv && !xI && document.addEventListener("click", function(t) {
  if (ev)
    return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), ev = !1, !1;
}, !0);
var Lc = function(e) {
  if (St) {
    e = e.touches ? e.touches[0] : e;
    var n = UU(e.clientX, e.clientY);
    if (n) {
      var o = {};
      for (var s in e)
        e.hasOwnProperty(s) && (o[s] = e[s]);
      o.target = o.rootEl = n, o.preventDefault = void 0, o.stopPropagation = void 0, n[ma]._onDragOver(o);
    }
  }
}, jU = function(e) {
  St && St.parentNode[ma]._isOutsideThisEl(e.target);
};
function lr(t, e) {
  if (!(t && t.nodeType && t.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t));
  this.el = t, this.options = e = Wl({}, e), t[ma] = this;
  var n = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(t.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: !1,
    invertedSwapThreshold: null,
    removeCloneOnHide: !0,
    direction: function() {
      return OI(t, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(a, m) {
      a.setData("Text", m.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: lr.supportPointer !== !1 && "PointerEvent" in window && !_d,
    emptyInsertThreshold: 5
  };
  om.initializePlugins(this, t, n);
  for (var o in n)
    !(o in e) && (e[o] = n[o]);
  CI(e);
  for (var s in this)
    s.charAt(0) === "_" && typeof this[s] == "function" && (this[s] = this[s].bind(this));
  this.nativeDraggable = e.forceFallback ? !1 : BU, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? nn(t, "pointerdown", this._onTapStart) : (nn(t, "mousedown", this._onTapStart), nn(t, "touchstart", this._onTapStart)), this.nativeDraggable && (nn(t, "dragover", this), nn(t, "dragenter", this)), tv.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), Wl(this, DU());
}
lr.prototype = {
  constructor: lr,
  _isOutsideThisEl: function(e) {
    !this.el.contains(e) && e !== this.el && (cf = null);
  },
  _getDirection: function(e, n) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, e, n, St) : this.options.direction;
  },
  _onTapStart: function(e) {
    if (!!e.cancelable) {
      var n = this, o = this.el, s = this.options, h = s.preventOnFilter, a = e.type, m = e.touches && e.touches[0] || e.pointerType && e.pointerType === "touch" && e, g = (m || e).target, b = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || g, T = s.filter;
      if (KU(o), !St && !(/mousedown|pointerdown/.test(a) && e.button !== 0 || s.disabled) && !b.isContentEditable && !(!this.nativeDraggable && _d && g && g.tagName.toUpperCase() === "SELECT") && (g = ts(g, s.draggable, o, !1), !(g && g.animated) && pg !== g)) {
        if (bf = Pa(g), bd = Pa(g, s.draggable), typeof T == "function") {
          if (T.call(this, e, g, this)) {
            Lo({
              sortable: n,
              rootEl: b,
              name: "filter",
              targetEl: g,
              toEl: o,
              fromEl: o
            }), Jo("filter", n, {
              evt: e
            }), h && e.cancelable && e.preventDefault();
            return;
          }
        } else if (T && (T = T.split(",").some(function(M) {
          if (M = ts(b, M.trim(), o, !1), M)
            return Lo({
              sortable: n,
              rootEl: M,
              name: "filter",
              targetEl: g,
              fromEl: o,
              toEl: o
            }), Jo("filter", n, {
              evt: e
            }), !0;
        }), T)) {
          h && e.cancelable && e.preventDefault();
          return;
        }
        s.handle && !ts(b, s.handle, o, !1) || this._prepareDragStart(e, m, g);
      }
    }
  },
  _prepareDragStart: function(e, n, o) {
    var s = this, h = s.el, a = s.options, m = h.ownerDocument, g;
    if (o && !St && o.parentNode === h) {
      var b = Pi(o);
      if (qn = h, St = o, hi = St.parentNode, Fc = St.nextSibling, pg = o, Gy = a.group, lr.dragged = St, kc = {
        target: St,
        clientX: (n || e).clientX,
        clientY: (n || e).clientY
      }, mE = kc.clientX - b.left, yE = kc.clientY - b.top, this._lastX = (n || e).clientX, this._lastY = (n || e).clientY, St.style["will-change"] = "all", g = function() {
        if (Jo("delayEnded", s, {
          evt: e
        }), lr.eventCanceled) {
          s._onDrop();
          return;
        }
        s._disableDelayedDragEvents(), !hE && s.nativeDraggable && (St.draggable = !0), s._triggerDragStart(e, n), Lo({
          sortable: s,
          name: "choose",
          originalEvent: e
        }), ha(St, a.chosenClass, !0);
      }, a.ignore.split(",").forEach(function(T) {
        wI(St, T.trim(), y0);
      }), nn(m, "dragover", Lc), nn(m, "mousemove", Lc), nn(m, "touchmove", Lc), nn(m, "mouseup", s._onDrop), nn(m, "touchend", s._onDrop), nn(m, "touchcancel", s._onDrop), hE && this.nativeDraggable && (this.options.touchStartThreshold = 4, St.draggable = !0), Jo("delayStart", this, {
        evt: e
      }), a.delay && (!a.delayOnTouchOnly || n) && (!this.nativeDraggable || !(im || Xl))) {
        if (lr.eventCanceled) {
          this._onDrop();
          return;
        }
        nn(m, "mouseup", s._disableDelayedDrag), nn(m, "touchend", s._disableDelayedDrag), nn(m, "touchcancel", s._disableDelayedDrag), nn(m, "mousemove", s._delayedDragTouchMoveHandler), nn(m, "touchmove", s._delayedDragTouchMoveHandler), a.supportPointer && nn(m, "pointermove", s._delayedDragTouchMoveHandler), s._dragStartTimer = setTimeout(g, a.delay);
      } else
        g();
    }
  },
  _delayedDragTouchMoveHandler: function(e) {
    var n = e.touches ? e.touches[0] : e;
    Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    St && y0(St), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var e = this.el.ownerDocument;
    Kr(e, "mouseup", this._disableDelayedDrag), Kr(e, "touchend", this._disableDelayedDrag), Kr(e, "touchcancel", this._disableDelayedDrag), Kr(e, "mousemove", this._delayedDragTouchMoveHandler), Kr(e, "touchmove", this._delayedDragTouchMoveHandler), Kr(e, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(e, n) {
    n = n || e.pointerType == "touch" && e, !this.nativeDraggable || n ? this.options.supportPointer ? nn(document, "pointermove", this._onTouchMove) : n ? nn(document, "touchmove", this._onTouchMove) : nn(document, "mousemove", this._onTouchMove) : (nn(St, "dragend", this), nn(qn, "dragstart", this._onDragStart));
    try {
      document.selection ? mg(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(e, n) {
    if (pf = !1, qn && St) {
      Jo("dragStarted", this, {
        evt: n
      }), this.nativeDraggable && nn(document, "dragover", jU);
      var o = this.options;
      !e && ha(St, o.dragClass, !1), ha(St, o.ghostClass, !0), lr.active = this, e && this._appendGhost(), Lo({
        sortable: this,
        name: "start",
        originalEvent: n
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (Ja) {
      this._lastX = Ja.clientX, this._lastY = Ja.clientY, AI();
      for (var e = document.elementFromPoint(Ja.clientX, Ja.clientY), n = e; e && e.shadowRoot && (e = e.shadowRoot.elementFromPoint(Ja.clientX, Ja.clientY), e !== n); )
        n = e;
      if (St.parentNode[ma]._isOutsideThisEl(e), n)
        do {
          if (n[ma]) {
            var o = void 0;
            if (o = n[ma]._onDragOver({
              clientX: Ja.clientX,
              clientY: Ja.clientY,
              target: e,
              rootEl: n
            }), o && !this.options.dragoverBubble)
              break;
          }
          e = n;
        } while (n = n.parentNode);
      PI();
    }
  },
  _onTouchMove: function(e) {
    if (kc) {
      var n = this.options, o = n.fallbackTolerance, s = n.fallbackOffset, h = e.touches ? e.touches[0] : e, a = xr && kf(xr, !0), m = xr && a && a.a, g = xr && a && a.d, b = qy && go && dE(go), T = (h.clientX - kc.clientX + s.x) / (m || 1) + (b ? b[0] - m0[0] : 0) / (m || 1), M = (h.clientY - kc.clientY + s.y) / (g || 1) + (b ? b[1] - m0[1] : 0) / (g || 1);
      if (!lr.active && !pf) {
        if (o && Math.max(Math.abs(h.clientX - this._lastX), Math.abs(h.clientY - this._lastY)) < o)
          return;
        this._onDragStart(e, !0);
      }
      if (xr) {
        a ? (a.e += T - (p0 || 0), a.f += M - (d0 || 0)) : a = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: T,
          f: M
        };
        var I = "matrix(".concat(a.a, ",").concat(a.b, ",").concat(a.c, ",").concat(a.d, ",").concat(a.e, ",").concat(a.f, ")");
        cr(xr, "webkitTransform", I), cr(xr, "mozTransform", I), cr(xr, "msTransform", I), cr(xr, "transform", I), p0 = T, d0 = M, Ja = h;
      }
      e.cancelable && e.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!xr) {
      var e = this.options.fallbackOnBody ? document.body : qn, n = Pi(St, !0, qy, !0, e), o = this.options;
      if (qy) {
        for (go = e; cr(go, "position") === "static" && cr(go, "transform") === "none" && go !== document; )
          go = go.parentNode;
        go !== document.body && go !== document.documentElement ? (go === document && (go = Js()), n.top += go.scrollTop, n.left += go.scrollLeft) : go = Js(), m0 = dE(go);
      }
      xr = St.cloneNode(!0), ha(xr, o.ghostClass, !1), ha(xr, o.fallbackClass, !0), ha(xr, o.dragClass, !0), cr(xr, "transition", ""), cr(xr, "transform", ""), cr(xr, "box-sizing", "border-box"), cr(xr, "margin", 0), cr(xr, "top", n.top), cr(xr, "left", n.left), cr(xr, "width", n.width), cr(xr, "height", n.height), cr(xr, "opacity", "0.8"), cr(xr, "position", qy ? "absolute" : "fixed"), cr(xr, "zIndex", "100000"), cr(xr, "pointerEvents", "none"), lr.ghost = xr, e.appendChild(xr), cr(xr, "transform-origin", mE / parseInt(xr.style.width) * 100 + "% " + yE / parseInt(xr.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(e, n) {
    var o = this, s = e.dataTransfer, h = o.options;
    if (Jo("dragStart", this, {
      evt: e
    }), lr.eventCanceled) {
      this._onDrop();
      return;
    }
    Jo("setupClone", this), lr.eventCanceled || (ri = TI(St), ri.removeAttribute("id"), ri.draggable = !1, ri.style["will-change"] = "", this._hideClone(), ha(ri, this.options.chosenClass, !1), lr.clone = ri), o.cloneId = mg(function() {
      Jo("clone", o), !lr.eventCanceled && (o.options.removeCloneOnHide || qn.insertBefore(ri, St), o._hideClone(), Lo({
        sortable: o,
        name: "clone"
      }));
    }), !n && ha(St, h.dragClass, !0), n ? (ev = !0, o._loopId = setInterval(o._emulateDragOver, 50)) : (Kr(document, "mouseup", o._onDrop), Kr(document, "touchend", o._onDrop), Kr(document, "touchcancel", o._onDrop), s && (s.effectAllowed = "move", h.setData && h.setData.call(o, s, St)), nn(document, "drop", o), cr(St, "transform", "translateZ(0)")), pf = !0, o._dragStartId = mg(o._dragStarted.bind(o, n, e)), nn(document, "selectstart", o), ad = !0, _d && cr(document.body, "user-select", "none");
  },
  _onDragOver: function(e) {
    var n = this.el, o = e.target, s, h, a, m = this.options, g = m.group, b = lr.active, T = Gy === g, M = m.sort, I = no || b, P, z = this, V = !1;
    if (f1)
      return;
    function q(Pt, tr) {
      Jo(Pt, z, rl({
        evt: e,
        isOwner: T,
        axis: P ? "vertical" : "horizontal",
        revert: a,
        dragRect: s,
        targetRect: h,
        canSort: M,
        fromSortable: I,
        target: o,
        completed: X,
        onMove: function(Rr, pr) {
          return Wy(qn, n, St, s, Rr, Pi(Rr), e, pr);
        },
        changed: ae
      }, tr));
    }
    function re() {
      q("dragOverAnimationCapture"), z.captureAnimationState(), z !== I && I.captureAnimationState();
    }
    function X(Pt) {
      return q("dragOverCompleted", {
        insertion: Pt
      }), Pt && (T ? b._hideClone() : b._showClone(z), z !== I && (ha(St, no ? no.options.ghostClass : b.options.ghostClass, !1), ha(St, m.ghostClass, !0)), no !== z && z !== lr.active ? no = z : z === lr.active && no && (no = null), I === z && (z._ignoreWhileAnimating = o), z.animateAll(function() {
        q("dragOverAnimationComplete"), z._ignoreWhileAnimating = null;
      }), z !== I && (I.animateAll(), I._ignoreWhileAnimating = null)), (o === St && !St.animated || o === n && !o.animated) && (cf = null), !m.dragoverBubble && !e.rootEl && o !== document && (St.parentNode[ma]._isOutsideThisEl(e.target), !Pt && Lc(e)), !m.dragoverBubble && e.stopPropagation && e.stopPropagation(), V = !0;
    }
    function ae() {
      fa = Pa(St), Su = Pa(St, m.draggable), Lo({
        sortable: z,
        name: "change",
        toEl: n,
        newIndex: fa,
        newDraggableIndex: Su,
        originalEvent: e
      });
    }
    if (e.preventDefault !== void 0 && e.cancelable && e.preventDefault(), o = ts(o, m.draggable, n, !0), q("dragOver"), lr.eventCanceled)
      return V;
    if (St.contains(e.target) || o.animated && o.animatingX && o.animatingY || z._ignoreWhileAnimating === o)
      return X(!1);
    if (ev = !1, b && !m.disabled && (T ? M || (a = hi !== qn) : no === this || (this.lastPutMode = Gy.checkPull(this, b, St, e)) && g.checkPut(this, b, St, e))) {
      if (P = this._getDirection(e, o) === "vertical", s = Pi(St), q("dragOverValid"), lr.eventCanceled)
        return V;
      if (a)
        return hi = qn, re(), this._hideClone(), q("revert"), lr.eventCanceled || (Fc ? qn.insertBefore(St, Fc) : qn.appendChild(St)), X(!0);
      var ce = lx(n, m.draggable);
      if (!ce || WU(e, P, this) && !ce.animated) {
        if (ce === St)
          return X(!1);
        if (ce && n === e.target && (o = ce), o && (h = Pi(o)), Wy(qn, n, St, s, o, h, e, !!o) !== !1)
          return re(), ce && ce.nextSibling ? n.insertBefore(St, ce.nextSibling) : n.appendChild(St), hi = n, ae(), X(!0);
      } else if (ce && qU(e, P, this)) {
        var ve = Ff(n, 0, m, !0);
        if (ve === St)
          return X(!1);
        if (o = ve, h = Pi(o), Wy(qn, n, St, s, o, h, e, !1) !== !1)
          return re(), n.insertBefore(St, ve), hi = n, ae(), X(!0);
      } else if (o.parentNode === n) {
        h = Pi(o);
        var Re = 0, Fe, Pe = St.parentNode !== n, Se = !VU(St.animated && St.toRect || s, o.animated && o.toRect || h, P), Ie = P ? "top" : "left", Xe = pE(o, "top", "top") || pE(St, "top", "top"), $e = Xe ? Xe.scrollTop : void 0;
        cf !== o && (Fe = h[Ie], Ed = !1, $y = !Se && m.invertSwap || Pe), Re = HU(e, o, h, P, Se ? 1 : m.swapThreshold, m.invertedSwapThreshold == null ? m.swapThreshold : m.invertedSwapThreshold, $y, cf === o);
        var at;
        if (Re !== 0) {
          var be = Pa(St);
          do
            be -= Re, at = hi.children[be];
          while (at && (cr(at, "display") === "none" || at === xr));
        }
        if (Re === 0 || at === o)
          return X(!1);
        cf = o, wd = Re;
        var Ye = o.nextElementSibling, ht = !1;
        ht = Re === 1;
        var vt = Wy(qn, n, St, s, o, h, e, ht);
        if (vt !== !1)
          return (vt === 1 || vt === -1) && (ht = vt === 1), f1 = !0, setTimeout($U, 30), re(), ht && !Ye ? n.appendChild(St) : o.parentNode.insertBefore(St, ht ? Ye : o), Xe && SI(Xe, 0, $e - Xe.scrollTop), hi = St.parentNode, Fe !== void 0 && !$y && (dg = Math.abs(Fe - Pi(o)[Ie])), ae(), X(!0);
      }
      if (n.contains(St))
        return X(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    Kr(document, "mousemove", this._onTouchMove), Kr(document, "touchmove", this._onTouchMove), Kr(document, "pointermove", this._onTouchMove), Kr(document, "dragover", Lc), Kr(document, "mousemove", Lc), Kr(document, "touchmove", Lc);
  },
  _offUpEvents: function() {
    var e = this.el.ownerDocument;
    Kr(e, "mouseup", this._onDrop), Kr(e, "touchend", this._onDrop), Kr(e, "pointerup", this._onDrop), Kr(e, "touchcancel", this._onDrop), Kr(document, "selectstart", this);
  },
  _onDrop: function(e) {
    var n = this.el, o = this.options;
    if (fa = Pa(St), Su = Pa(St, o.draggable), Jo("drop", this, {
      evt: e
    }), hi = St && St.parentNode, fa = Pa(St), Su = Pa(St, o.draggable), lr.eventCanceled) {
      this._nulling();
      return;
    }
    pf = !1, $y = !1, Ed = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), p1(this.cloneId), p1(this._dragStartId), this.nativeDraggable && (Kr(document, "drop", this), Kr(n, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), _d && cr(document.body, "user-select", ""), cr(St, "transform", ""), e && (ad && (e.cancelable && e.preventDefault(), !o.dropBubble && e.stopPropagation()), xr && xr.parentNode && xr.parentNode.removeChild(xr), (qn === hi || no && no.lastPutMode !== "clone") && ri && ri.parentNode && ri.parentNode.removeChild(ri), St && (this.nativeDraggable && Kr(St, "dragend", this), y0(St), St.style["will-change"] = "", ad && !pf && ha(St, no ? no.options.ghostClass : this.options.ghostClass, !1), ha(St, this.options.chosenClass, !1), Lo({
      sortable: this,
      name: "unchoose",
      toEl: hi,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: e
    }), qn !== hi ? (fa >= 0 && (Lo({
      rootEl: hi,
      name: "add",
      toEl: hi,
      fromEl: qn,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "remove",
      toEl: hi,
      originalEvent: e
    }), Lo({
      rootEl: hi,
      name: "sort",
      toEl: hi,
      fromEl: qn,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "sort",
      toEl: hi,
      originalEvent: e
    })), no && no.save()) : fa !== bf && fa >= 0 && (Lo({
      sortable: this,
      name: "update",
      toEl: hi,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "sort",
      toEl: hi,
      originalEvent: e
    })), lr.active && ((fa == null || fa === -1) && (fa = bf, Su = bd), Lo({
      sortable: this,
      name: "end",
      toEl: hi,
      originalEvent: e
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    Jo("nulling", this), qn = St = hi = xr = Fc = ri = pg = Ou = kc = Ja = ad = fa = Su = bf = bd = cf = wd = no = Gy = lr.dragged = lr.ghost = lr.clone = lr.active = null, rv.forEach(function(e) {
      e.checked = !0;
    }), rv.length = p0 = d0 = 0;
  },
  handleEvent: function(e) {
    switch (e.type) {
      case "drop":
      case "dragend":
        this._onDrop(e);
        break;
      case "dragenter":
      case "dragover":
        St && (this._onDragOver(e), GU(e));
        break;
      case "selectstart":
        e.preventDefault();
        break;
    }
  },
  toArray: function() {
    for (var e = [], n, o = this.el.children, s = 0, h = o.length, a = this.options; s < h; s++)
      n = o[s], ts(n, a.draggable, this.el, !1) && e.push(n.getAttribute(a.dataIdAttr) || XU(n));
    return e;
  },
  sort: function(e, n) {
    var o = {}, s = this.el;
    this.toArray().forEach(function(h, a) {
      var m = s.children[a];
      ts(m, this.options.draggable, s, !1) && (o[h] = m);
    }, this), n && this.captureAnimationState(), e.forEach(function(h) {
      o[h] && (s.removeChild(o[h]), s.appendChild(o[h]));
    }), n && this.animateAll();
  },
  save: function() {
    var e = this.options.store;
    e && e.set && e.set(this);
  },
  closest: function(e, n) {
    return ts(e, n || this.options.draggable, this.el, !1);
  },
  option: function(e, n) {
    var o = this.options;
    if (n === void 0)
      return o[e];
    var s = om.modifyOption(this, e, n);
    typeof s < "u" ? o[e] = s : o[e] = n, e === "group" && CI(o);
  },
  destroy: function() {
    Jo("destroy", this);
    var e = this.el;
    e[ma] = null, Kr(e, "mousedown", this._onTapStart), Kr(e, "touchstart", this._onTapStart), Kr(e, "pointerdown", this._onTapStart), this.nativeDraggable && (Kr(e, "dragover", this), Kr(e, "dragenter", this)), Array.prototype.forEach.call(e.querySelectorAll("[draggable]"), function(n) {
      n.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), tv.splice(tv.indexOf(this.el), 1), this.el = e = null;
  },
  _hideClone: function() {
    if (!Ou) {
      if (Jo("hideClone", this), lr.eventCanceled)
        return;
      cr(ri, "display", "none"), this.options.removeCloneOnHide && ri.parentNode && ri.parentNode.removeChild(ri), Ou = !0;
    }
  },
  _showClone: function(e) {
    if (e.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (Ou) {
      if (Jo("showClone", this), lr.eventCanceled)
        return;
      St.parentNode == qn && !this.options.group.revertClone ? qn.insertBefore(ri, St) : Fc ? qn.insertBefore(ri, Fc) : qn.appendChild(ri), this.options.group.revertClone && this.animate(St, ri), cr(ri, "display", ""), Ou = !1;
    }
  }
};
function GU(t) {
  t.dataTransfer && (t.dataTransfer.dropEffect = "move"), t.cancelable && t.preventDefault();
}
function Wy(t, e, n, o, s, h, a, m) {
  var g, b = t[ma], T = b.options.onMove, M;
  return window.CustomEvent && !Xl && !im ? g = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (g = document.createEvent("Event"), g.initEvent("move", !0, !0)), g.to = e, g.from = t, g.dragged = n, g.draggedRect = o, g.related = s || e, g.relatedRect = h || Pi(e), g.willInsertAfter = m, g.originalEvent = a, t.dispatchEvent(g), T && (M = T.call(b, g, a)), M;
}
function y0(t) {
  t.draggable = !1;
}
function $U() {
  f1 = !1;
}
function qU(t, e, n) {
  var o = Pi(Ff(n.el, 0, n.options, !0)), s = MI(n.el, n.options, xr), h = 10;
  return e ? t.clientX < s.left - h || t.clientY < o.top && t.clientX < o.right : t.clientY < s.top - h || t.clientY < o.bottom && t.clientX < o.left;
}
function WU(t, e, n) {
  var o = Pi(lx(n.el, n.options.draggable)), s = MI(n.el, n.options, xr), h = 10;
  return e ? t.clientX > s.right + h || t.clientY > o.bottom && t.clientX > o.left : t.clientY > s.bottom + h || t.clientX > o.right && t.clientY > o.top;
}
function HU(t, e, n, o, s, h, a, m) {
  var g = o ? t.clientY : t.clientX, b = o ? n.height : n.width, T = o ? n.top : n.left, M = o ? n.bottom : n.right, I = !1;
  if (!a) {
    if (m && dg < b * s) {
      if (!Ed && (wd === 1 ? g > T + b * h / 2 : g < M - b * h / 2) && (Ed = !0), Ed)
        I = !0;
      else if (wd === 1 ? g < T + dg : g > M - dg)
        return -wd;
    } else if (g > T + b * (1 - s) / 2 && g < M - b * (1 - s) / 2)
      return ZU(e);
  }
  return I = I || a, I && (g < T + b * h / 2 || g > M - b * h / 2) ? g > T + b / 2 ? 1 : -1 : 0;
}
function ZU(t) {
  return Pa(St) < Pa(t) ? 1 : -1;
}
function XU(t) {
  for (var e = t.tagName + t.className + t.src + t.href + t.textContent, n = e.length, o = 0; n--; )
    o += e.charCodeAt(n);
  return o.toString(36);
}
function KU(t) {
  rv.length = 0;
  for (var e = t.getElementsByTagName("input"), n = e.length; n--; ) {
    var o = e[n];
    o.checked && rv.push(o);
  }
}
function mg(t) {
  return setTimeout(t, 0);
}
function p1(t) {
  return clearTimeout(t);
}
Rv && nn(document, "touchmove", function(t) {
  (lr.active || pf) && t.cancelable && t.preventDefault();
});
lr.utils = {
  on: nn,
  off: Kr,
  css: cr,
  find: wI,
  is: function(e, n) {
    return !!ts(e, n, e, !1);
  },
  extend: kU,
  throttle: EI,
  closest: ts,
  toggleClass: ha,
  clone: TI,
  index: Pa,
  nextTick: mg,
  cancelNextTick: p1,
  detectDirection: OI,
  getChild: Ff
};
lr.get = function(t) {
  return t[ma];
};
lr.mount = function() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  e[0].constructor === Array && (e = e[0]), e.forEach(function(o) {
    if (!o.prototype || !o.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(o));
    o.utils && (lr.utils = rl(rl({}, lr.utils), o.utils)), om.mount(o);
  });
};
lr.create = function(t, e) {
  return new lr(t, e);
};
lr.version = CU;
var Oi = [], sd, d1, m1 = !1, g0, v0, nv, ld;
function YU() {
  function t() {
    this.defaults = {
      scroll: !0,
      forceAutoScrollFallback: !1,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var e in this)
      e.charAt(0) === "_" && typeof this[e] == "function" && (this[e] = this[e].bind(this));
  }
  return t.prototype = {
    dragStarted: function(n) {
      var o = n.originalEvent;
      this.sortable.nativeDraggable ? nn(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? nn(document, "pointermove", this._handleFallbackAutoScroll) : o.touches ? nn(document, "touchmove", this._handleFallbackAutoScroll) : nn(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(n) {
      var o = n.originalEvent;
      !this.options.dragOverBubble && !o.rootEl && this._handleAutoScroll(o);
    },
    drop: function() {
      this.sortable.nativeDraggable ? Kr(document, "dragover", this._handleAutoScroll) : (Kr(document, "pointermove", this._handleFallbackAutoScroll), Kr(document, "touchmove", this._handleFallbackAutoScroll), Kr(document, "mousemove", this._handleFallbackAutoScroll)), vE(), yg(), LU();
    },
    nulling: function() {
      nv = d1 = sd = m1 = ld = g0 = v0 = null, Oi.length = 0;
    },
    _handleFallbackAutoScroll: function(n) {
      this._handleAutoScroll(n, !0);
    },
    _handleAutoScroll: function(n, o) {
      var s = this, h = (n.touches ? n.touches[0] : n).clientX, a = (n.touches ? n.touches[0] : n).clientY, m = document.elementFromPoint(h, a);
      if (nv = n, o || this.options.forceAutoScrollFallback || im || Xl || _d) {
        _0(n, this.options, m, o);
        var g = Cu(m, !0);
        m1 && (!ld || h !== g0 || a !== v0) && (ld && vE(), ld = setInterval(function() {
          var b = Cu(document.elementFromPoint(h, a), !0);
          b !== g && (g = b, yg()), _0(n, s.options, b, o);
        }, 10), g0 = h, v0 = a);
      } else {
        if (!this.options.bubbleScroll || Cu(m, !0) === Js()) {
          yg();
          return;
        }
        _0(n, this.options, Cu(m, !1), !1);
      }
    }
  }, Wl(t, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function yg() {
  Oi.forEach(function(t) {
    clearInterval(t.pid);
  }), Oi = [];
}
function vE() {
  clearInterval(ld);
}
var _0 = EI(function(t, e, n, o) {
  if (!!e.scroll) {
    var s = (t.touches ? t.touches[0] : t).clientX, h = (t.touches ? t.touches[0] : t).clientY, a = e.scrollSensitivity, m = e.scrollSpeed, g = Js(), b = !1, T;
    d1 !== n && (d1 = n, yg(), sd = e.scroll, T = e.scrollFn, sd === !0 && (sd = Cu(n, !0)));
    var M = 0, I = sd;
    do {
      var P = I, z = Pi(P), V = z.top, q = z.bottom, re = z.left, X = z.right, ae = z.width, ce = z.height, ve = void 0, Re = void 0, Fe = P.scrollWidth, Pe = P.scrollHeight, Se = cr(P), Ie = P.scrollLeft, Xe = P.scrollTop;
      P === g ? (ve = ae < Fe && (Se.overflowX === "auto" || Se.overflowX === "scroll" || Se.overflowX === "visible"), Re = ce < Pe && (Se.overflowY === "auto" || Se.overflowY === "scroll" || Se.overflowY === "visible")) : (ve = ae < Fe && (Se.overflowX === "auto" || Se.overflowX === "scroll"), Re = ce < Pe && (Se.overflowY === "auto" || Se.overflowY === "scroll"));
      var $e = ve && (Math.abs(X - s) <= a && Ie + ae < Fe) - (Math.abs(re - s) <= a && !!Ie), at = Re && (Math.abs(q - h) <= a && Xe + ce < Pe) - (Math.abs(V - h) <= a && !!Xe);
      if (!Oi[M])
        for (var be = 0; be <= M; be++)
          Oi[be] || (Oi[be] = {});
      (Oi[M].vx != $e || Oi[M].vy != at || Oi[M].el !== P) && (Oi[M].el = P, Oi[M].vx = $e, Oi[M].vy = at, clearInterval(Oi[M].pid), ($e != 0 || at != 0) && (b = !0, Oi[M].pid = setInterval(function() {
        o && this.layer === 0 && lr.active._onTouchMove(nv);
        var Ye = Oi[this.layer].vy ? Oi[this.layer].vy * m : 0, ht = Oi[this.layer].vx ? Oi[this.layer].vx * m : 0;
        typeof T == "function" && T.call(lr.dragged.parentNode[ma], ht, Ye, t, nv, Oi[this.layer].el) !== "continue" || SI(Oi[this.layer].el, ht, Ye);
      }.bind({
        layer: M
      }), 24))), M++;
    } while (e.bubbleScroll && I !== g && (I = Cu(I, !1)));
    m1 = b;
  }
}, 30), kI = function(e) {
  var n = e.originalEvent, o = e.putSortable, s = e.dragEl, h = e.activeSortable, a = e.dispatchSortableEvent, m = e.hideGhostForTarget, g = e.unhideGhostForTarget;
  if (!!n) {
    var b = o || h;
    m();
    var T = n.changedTouches && n.changedTouches.length ? n.changedTouches[0] : n, M = document.elementFromPoint(T.clientX, T.clientY);
    g(), b && !b.el.contains(M) && (a("spill"), this.onSpill({
      dragEl: s,
      putSortable: o
    }));
  }
};
function ux() {
}
ux.prototype = {
  startIndex: null,
  dragStart: function(e) {
    var n = e.oldDraggableIndex;
    this.startIndex = n;
  },
  onSpill: function(e) {
    var n = e.dragEl, o = e.putSortable;
    this.sortable.captureAnimationState(), o && o.captureAnimationState();
    var s = Ff(this.sortable.el, this.startIndex, this.options);
    s ? this.sortable.el.insertBefore(n, s) : this.sortable.el.appendChild(n), this.sortable.animateAll(), o && o.animateAll();
  },
  drop: kI
};
Wl(ux, {
  pluginName: "revertOnSpill"
});
function cx() {
}
cx.prototype = {
  onSpill: function(e) {
    var n = e.dragEl, o = e.putSortable, s = o || this.sortable;
    s.captureAnimationState(), n.parentNode && n.parentNode.removeChild(n), s.animateAll();
  },
  drop: kI
};
Wl(cx, {
  pluginName: "removeOnSpill"
});
lr.mount(new YU());
lr.mount(cx, ux);
const LI = 0.5, JU = !1, iv = ih(
  "slider",
  () => {
    const t = Ei(), e = _r(LI), n = _r(JU), o = or(
      () => [...t.layers].reverse()[0]
    );
    function s(a) {
      let m = a;
      a < 0.1 ? m = 0.1 : a > 0.9 && (m = 0.9), e.value = m;
    }
    function h(a) {
      n.value = a != null ? a : !n.value;
    }
    return {
      sliderActive: n,
      sliderRatio: e,
      sliderTopLayer: o,
      setRatio: s,
      toggleSlider: h
    };
  },
  {}
);
function DI(t, e) {
  const { t: n } = En();
  function o() {
    e == null || e.emit("clickInfo", t);
  }
  return {
    t: n,
    onClickInfo: o
  };
}
const QU = { class: "lux-layer-manager-item mt-2.5" }, ej = ["title"], tj = { class: "flex-1 text-left cursor-default" }, rj = ["aria-label", "title"], nj = /* @__PURE__ */ ar({
  __name: "layer-item-background",
  props: {
    showEditButton: { type: Boolean, required: !0 },
    layer: { type: null, required: !0 }
  },
  emits: ["clickEdit", "clickInfo"],
  setup(t, { emit: e }) {
    const n = t, { t: o, onClickInfo: s } = DI(n.layer, { emit: e }), h = or(
      () => o('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: a()
      })
    );
    function a() {
      return o(n.layer.name, { ns: "client" });
    }
    return (m, g) => (Ve(), it("div", QU, [
      ze("button", {
        class: "fa fa-info w-3",
        title: se(h),
        onClick: g[0] || (g[0] = (...b) => se(s) && se(s)(...b))
      }, null, 8, ej),
      ze("span", tj, Gt(a()), 1),
      t.showEditButton ? (Ve(), it("button", {
        key: 0,
        class: "fa fa-pencil",
        "aria-label": se(o)("Open editor panel", { ns: "client" }),
        title: se(o)("Open editor panel", { ns: "client" }),
        onClick: g[1] || (g[1] = (b) => m.$emit("clickEdit"))
      }, null, 8, rj)) : Je("v-if", !0)
    ]));
  }
}), ij = /* @__PURE__ */ ur(nj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item-background.vue"]]), oj = ["id"], aj = ["aria-checked", "title"], sj = ["id", "value", "aria-label"], lj = ["aria-checked", "aria-label"], uj = /* @__PURE__ */ ar({
  __name: "layer-item-sub",
  props: {
    layer: { type: null, required: !0 },
    isOpen: { type: Boolean, required: !0 },
    isLayerComparatorOpen: { type: Boolean, required: !0 },
    displayLayerComparatorOpen: { type: Boolean, required: !0 }
  },
  emits: ["changeOpacity", "clickToggleLayerComparator"],
  setup(t, { emit: e }) {
    var I, P, z, V;
    const n = t, { t: o } = En(), s = hs(), h = or(
      () => o(s.getLayerCurrentLabel(n.layer), { ns: "client" })
    ), a = Bn(
      ((P = (I = n.layer) == null ? void 0 : I.opacity) != null ? P : 1) * 100
    ), m = Bn(
      ((V = (z = n.layer) == null ? void 0 : z.previousOpacity) != null ? V : a.value) * 100
    );
    function g() {
      a.value === 0 ? a.value = m.value : (m.value = a.value, a.value = 0), M();
    }
    function b(q) {
      q.target && (a.value = parseInt(q.target.value), M());
    }
    function T() {
      e("clickToggleLayerComparator", n.layer);
    }
    function M() {
      e("changeOpacity", n.layer, a.value);
    }
    return (q, re) => (Ve(), it("div", {
      class: Pr(["lux-layer-manager-item-content", t.isOpen ? "h-6" : "h-0"]),
      id: `layer-manager-item-content-${t.layer.id}`
    }, [
      ze("button", {
        class: Pr(["w-5 fa-solid", se(a) === 0 ? "fa-eye-slash" : "fa-eye"]),
        role: "switch",
        "aria-checked": se(a) === 0,
        title: se(o)("Toggle layer opacity for {{layerName}}", {
          layerName: se(h)
        }),
        onClick: g
      }, null, 10, aj),
      ze("input", {
        id: `${t.layer.id}-steps-range`,
        type: "range",
        min: "0",
        max: "100",
        value: se(a),
        step: "25",
        onChange: b,
        class: "m-2.5 w-16 h-[5px] rounded-lg appearance-none cursor-pointer",
        "aria-label": se(o)("Change opacity for {{ layerName }}", { layerName: se(h) })
      }, null, 40, sj),
      t.displayLayerComparatorOpen ? (Ve(), it("button", {
        key: 0,
        role: "switch",
        class: Pr(["fa ml-auto text-sm cursor-pointer", t.isLayerComparatorOpen ? "fa-adjust" : "fa-circle"]),
        "aria-checked": t.isLayerComparatorOpen,
        "aria-label": se(o)("Toggle layer comparator for {{ layerName }}", {
          layerName: se(h)
        }),
        onClick: T
      }, null, 10, lj)) : Je("v-if", !0)
    ], 10, oj));
  }
}), cj = /* @__PURE__ */ ur(uj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item-sub.vue"]]), hj = ["min", "max", "value"], fj = /* @__PURE__ */ ar({
  __name: "layer-time-datepicker",
  props: {
    minDateAllowed: { type: String, required: !1, default: "" },
    maxDateAllowed: { type: String, required: !1, default: "" },
    dateValue: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, o = or(() => t0(n.minDateAllowed)), s = or(() => t0(n.maxDateAllowed));
    function h(a) {
      e("change", a.target.value);
    }
    return (a, m) => (Ve(), it("input", {
      class: "lux-time-datepicker",
      type: "date",
      min: se(o),
      max: se(s),
      value: t.dateValue ? se(t0)(t.dateValue) : "",
      onChange: h
    }, null, 40, hj));
  }
}), y1 = /* @__PURE__ */ ur(fj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker.vue"]]), pj = { class: "lux-time-slider w-full" }, dj = ["for"], mj = /* @__PURE__ */ ar({
  __name: "layer-time-datepicker-value",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t) {
    const e = t, { t: n } = En(), o = Bn(
      e.layer.currentTimeMinValue
    );
    return (s, h) => {
      var a, m;
      return Ve(), it("div", pj, [
        ze("div", null, [
          ze("label", {
            for: `${t.layer.id}-time-slider-start`,
            class: "lux-time-slider-label"
          }, Gt(se(n)("Date:")), 9, dj),
          Ft(y1, {
            id: `${t.layer.id}-time-slider-start`,
            "date-value": se(o),
            "min-date-allowed": (a = e.layer.time) == null ? void 0 : a.minValue,
            "max-date-allowed": (m = e.layer.time) == null ? void 0 : m.maxValue,
            onChange: h[0] || (h[0] = (g) => s.$emit("changeTime", g))
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ])
      ]);
    };
  }
}), yj = /* @__PURE__ */ ur(mj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker-value.vue"]]), gj = { class: "lux-time-slider w-full" }, vj = ["for"], _j = ["for"], xj = /* @__PURE__ */ ar({
  __name: "layer-time-datepicker-range",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    const n = t, { t: o } = En(), s = Bn(
      n.layer.currentTimeMinValue
    ), h = Bn(
      n.layer.currentTimeMaxValue
    );
    function a(g) {
      e("changeTime", g, n.layer.currentTimeMaxValue);
    }
    function m(g) {
      e("changeTime", n.layer.currentTimeMinValue, g);
    }
    return (g, b) => {
      var T, M, I, P;
      return Ve(), it("div", gj, [
        Je(" Date START datepicker input "),
        ze("div", null, [
          ze("label", {
            for: `${t.layer.id}-time-slider-start`,
            class: "lux-time-slider-label"
          }, Gt(se(o)("From:")), 9, vj),
          Ft(y1, {
            id: `${t.layer.id}-time-slider-start`,
            "date-value": se(s),
            "min-date-allowed": (T = n.layer.time) == null ? void 0 : T.minValue,
            "max-date-allowed": (M = n.layer.time) == null ? void 0 : M.maxValue,
            onChange: a
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ]),
        Je(" Date END datepicker input "),
        ze("div", null, [
          ze("label", {
            for: `${t.layer.id}-time-slider-end`,
            class: "lux-time-slider-label"
          }, Gt(se(o)("To:")), 9, _j),
          Ft(y1, {
            id: `${t.layer.id}-time-slider-end`,
            "date-value": se(h),
            "min-date-allowed": (I = n.layer.time) == null ? void 0 : I.minValue,
            "max-date-allowed": (P = n.layer.time) == null ? void 0 : P.maxValue,
            onChange: m
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ])
      ]);
    };
  }
}), bj = /* @__PURE__ */ ur(xj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker-range.vue"]]), wj = ["onKeydown", "aria-label", "title"], Ej = /* @__PURE__ */ ar({
  __name: "slider-range-thumb",
  props: {
    ariaLabel: { type: String, required: !1 },
    maxLimit: { type: Number, required: !1, default: 100 },
    minLimit: { type: Number, required: !1, default: 0 },
    selectedValue: { type: Number, required: !0 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, o = _r(!1), s = _r(), h = _r(), a = or(() => {
      var X;
      return ((X = s.value) == null ? void 0 : X.offsetWidth) || 0;
    }), m = or(() => {
      var X;
      return ((X = h.value) == null ? void 0 : X.offsetWidth) || 40;
    }), g = _r(n.selectedValue), b = or(() => a.value * g.value / 100 - m.value / 2), T = or(() => ({ left: `${b.value}px` }));
    Gu(() => {
      document.removeEventListener("mousemove", V), document.removeEventListener("mouseup", q);
    }), Pn(
      () => n.selectedValue,
      (X) => {
        g.value = X;
      }
    );
    function M(X) {
      g.value = Math.max(Math.min(X, 100), 0), e("change", g.value, o.value);
    }
    function I() {
      M(g.value - 1);
    }
    function P() {
      M(g.value + 1);
    }
    function z() {
      o.value = !0, document.addEventListener("mousemove", V), document.addEventListener("mouseup", q);
    }
    function V(X) {
      !o.value || M(re(X));
    }
    function q(X) {
      o.value = !1, M(re(X)), document.removeEventListener("mousemove", V), document.removeEventListener("mouseup", q);
    }
    function re(X) {
      var ce, ve;
      const ae = (ce = s.value) != null && ce.offsetWidth ? (X.clientX - m.value * 2) * 100 / ((ve = s.value) == null ? void 0 : ve.offsetWidth) : 0;
      return Math.round(Math.max(Math.min(ae, n.maxLimit), n.minLimit));
    }
    return (X, ae) => (Ve(), it("div", {
      class: "w-full",
      role: "slider",
      ref_key: "elRefTrack",
      ref: s
    }, [
      ze("button", {
        class: Pr(["lux-slidebar-thumb", o.value ? "dragging" : ""]),
        ref_key: "elRefThumb",
        ref: h,
        style: ju(se(T)),
        onKeydown: [
          Gs(js(P, ["stop"]), ["space"]),
          Gs(js(P, ["stop"]), ["right"]),
          Gs(js(I, ["stop"]), ["left"]),
          Gs(js(I, ["stop"]), ["delete"])
        ],
        onMousedown: z,
        onMousemove: V,
        onMouseup: q,
        "aria-label": t.ariaLabel,
        title: t.ariaLabel
      }, null, 46, wj)
    ], 512));
  }
}), _E = /* @__PURE__ */ ur(Ej, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/slider-range/slider-range-thumb.vue"]]), Sj = /* @__PURE__ */ ar({
  __name: "slider-range-active-track",
  props: {
    selectedMinValue: { type: Number, required: !0 },
    selectedMaxValue: { type: Number, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, o = _r(), s = _r(), h = or(
      () => o.value ? Math.round(
        o.value.offsetWidth * n.selectedMinValue / 100
      ) : 0
    ), a = or(() => {
      var T, M;
      let b = 0;
      return n.selectedMaxValue !== void 0 && ((T = o.value) == null ? void 0 : T.offsetWidth) && (b = ((M = o.value) == null ? void 0 : M.offsetWidth) * n.selectedMaxValue / 100 - h.value), Math.round(b);
    }), m = or(() => ({
      left: `${h.value}px`,
      width: `${a.value}px`
    }));
    function g(b) {
      if (o.value) {
        const T = o.value.getBoundingClientRect().x, M = (b.clientX - T) * 100 / o.value.offsetWidth;
        e("change", M);
      }
    }
    return (b, T) => (Ve(), it("div", {
      ref_key: "elRefFullTrack",
      ref: o,
      class: "lux-slidebar-track"
    }, [
      t.selectedMaxValue !== void 0 ? (Ve(), it("div", {
        key: 0,
        ref_key: "elRefSelectionTrack",
        ref: s,
        class: "lux-slidebar-track-selection",
        style: ju(se(m)),
        onClick: g
      }, null, 4)) : Je("v-if", !0),
      ze("div", {
        class: "lux-slidebar-track-full",
        onClick: g
      })
    ], 512));
  }
}), Tj = /* @__PURE__ */ ur(Sj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/slider-range/slider-range-active-track.vue"]]), Mj = { class: "lux-slidebar-fake" }, Ij = /* @__PURE__ */ ar({
  __name: "slider-range",
  props: {
    selectedMinValue: { type: Number, required: !0 },
    selectedMaxValue: { type: Number, required: !1 },
    ariaLabelMin: { type: String, required: !1 },
    ariaLabelMax: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, o = _r(n.selectedMinValue), s = _r(n.selectedMaxValue);
    function h(g, b) {
      e("change", g, n.selectedMaxValue, b);
    }
    function a(g, b) {
      e("change", n.selectedMinValue, g, b);
    }
    function m(g) {
      s.value === void 0 ? o.value = g : g >= s.value ? s.value = g : g <= n.selectedMinValue ? o.value = g : Math.abs(s.value - g) < Math.abs(o.value - g) ? s.value = g : o.value = g, e("change", o.value, s.value, !1);
    }
    return (g, b) => (Ve(), it("div", Mj, [
      Je(" Draggable Max thumb button "),
      s.value !== void 0 ? (Ve(), on(_E, {
        key: 0,
        ariaLabel: t.ariaLabelMax,
        minLimit: t.selectedMinValue,
        selectedValue: s.value,
        onChange: a
      }, null, 8, ["ariaLabel", "minLimit", "selectedValue"])) : Je("v-if", !0),
      Je(" Draggable Min thumb button "),
      Je(" put Min value after Max value, this is just for z-index grabbing "),
      Ft(_E, {
        ariaLabel: t.ariaLabelMin,
        maxLimit: t.selectedMaxValue,
        selectedValue: o.value,
        onChange: h
      }, null, 8, ["ariaLabel", "maxLimit", "selectedValue"]),
      Je(" Selection highlight "),
      Ft(Tj, {
        selectedMinValue: t.selectedMinValue,
        selectedMaxValue: t.selectedMaxValue,
        onChange: m
      }, null, 8, ["selectedMinValue", "selectedMaxValue"])
    ]));
  }
}), xE = /* @__PURE__ */ ur(Ij, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/slider-range/slider-range.vue"]]), Oj = { class: "lux-time-slider w-full" }, Cj = {
  key: 0,
  class: "lux-time-slider-value mr-1.5"
}, Aj = {
  key: 1,
  class: "lux-time-slider-range mr-1.5"
}, Pj = { class: "lux-time-displayed-dates" }, kj = {
  key: 0,
  class: "lux-time-start-date grow"
}, Lj = {
  key: 1,
  class: "lux-time-slider-end-date grow text-right"
}, Dj = /* @__PURE__ */ ar({
  __name: "layer-time-slider",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    const n = t, { t: o } = En(), s = or(V), h = or(
      () => {
        var ae, ce;
        return (ae = n.layer.time) != null && ae.minValue ? new Date((ce = n.layer.time) == null ? void 0 : ce.minValue).getTime() : 0;
      }
    ), a = or(
      () => {
        var ae, ce;
        return (ae = n.layer.time) != null && ae.maxValue ? new Date((ce = n.layer.time) == null ? void 0 : ce.maxValue).getTime() : 0;
      }
    ), m = or(() => a.value - h.value), g = _r(n.layer.currentTimeMaxValue), b = _r(n.layer.currentTimeMinValue), T = or(
      () => b.value ? new Date(b.value).getTime() : void 0
    ), M = or(
      () => g.value ? new Date(g.value).getTime() : void 0
    ), I = or(
      () => z(T.value)
    ), P = or(
      () => z(M.value)
    );
    function z(ae) {
      return ae ? (ae - h.value) / m.value * 100 : 0;
    }
    function V() {
      var Ie, Xe;
      const ae = n.layer.time, ce = [];
      if (!ae)
        return;
      if (ae.values)
        return ae.values.map(($e) => new Date($e).getTime());
      const ve = new Date(ae.minValue), Re = new Date((Ie = ae.maxValue) != null ? Ie : Date.now()), Fe = 1024, Pe = new Date(ve.getTime()), Se = (Xe = ae.interval) != null ? Xe : GM;
      if (Pe.setFullYear(
        ve.getFullYear() + Fe * Se[0]
      ), Pe.setMonth(
        ve.getMonth() + Fe * Se[1],
        ve.getDate() + Fe * Se[2]
      ), Pe.setSeconds(ve.getSeconds() + Fe * Se[3]), Pe > Re)
        for (let $e = 0; ; $e++) {
          const at = new Date(ve.getTime());
          if (at.setFullYear(ve.getFullYear() + $e * Se[0]), at.setMonth(
            ve.getMonth() + $e * Se[1],
            ve.getDate() + $e * Se[2]
          ), at.setSeconds(ve.getSeconds() + $e * Se[3]), at <= Re)
            ce.push(at.getTime());
          else
            break;
        }
      return ce;
    }
    function q(ae) {
      var Re;
      const ce = ae / 100 * (a.value - h.value) + h.value, ve = B6(ce, {
        minValue: h.value,
        maxValue: a.value,
        timeValueList: s.value,
        timeInterval: (Re = n.layer.time) == null ? void 0 : Re.interval
      });
      return o1(ve);
    }
    function re(ae, ce) {
      const ve = q(ae);
      if (b.value = ve, ce) {
        const Re = q(ce);
        g.value = Re;
      }
    }
    function X(ae, ce, ve) {
      re(ae, ce), ve || e("changeTime", b.value, g.value);
    }
    return (ae, ce) => {
      var ve, Re, Fe, Pe, Se, Ie, Xe;
      return Ve(), it("div", Oj, [
        Je(" Slider LayerTimeMode.VALUE "),
        ((ve = t.layer.time) == null ? void 0 : ve.mode) === se(zl).VALUE ? (Ve(), it("div", Cj, [
          Ft(xE, {
            ariaLabelMin: `${se(o)("Modifier la date de d\xE9but", { ns: "client" })}`,
            selectedMinValue: se(I),
            onChange: X
          }, null, 8, ["ariaLabelMin", "selectedMinValue"])
        ])) : Je("v-if", !0),
        Je(" Slider LayerTimeMode.RANGE "),
        ((Re = t.layer.time) == null ? void 0 : Re.mode) === se(zl).RANGE ? (Ve(), it("div", Aj, [
          Ft(xE, {
            ariaLabelMin: `${se(o)("Modifier la date de d\xE9but", { ns: "client" })}`,
            ariaLabelMax: `${se(o)("Modifier la date de fin", { ns: "client" })}`,
            selectedMinValue: se(I),
            selectedMaxValue: se(P),
            onChange: X
          }, null, 8, ["ariaLabelMin", "ariaLabelMax", "selectedMinValue", "selectedMaxValue"])
        ])) : Je("v-if", !0),
        Je(" Display localized time values "),
        ze("div", Pj, [
          Je(" Display localized time values Min value "),
          ((Fe = t.layer.time) == null ? void 0 : Fe.mode) === se(zl).RANGE || ((Pe = t.layer.time) == null ? void 0 : Pe.mode) === se(zl).VALUE ? (Ve(), it("div", kj, [
            ze("span", null, Gt(b.value ? se($2)(b.value, (Se = t.layer.time) == null ? void 0 : Se.resolution) : "-"), 1)
          ])) : Je("v-if", !0),
          Je(" Display localized time values Max value "),
          ((Ie = t.layer.time) == null ? void 0 : Ie.mode) === se(zl).RANGE ? (Ve(), it("div", Lj, [
            ze("span", null, Gt(g.value ? se($2)(g.value, (Xe = t.layer.time) == null ? void 0 : Xe.resolution) : "-"), 1)
          ])) : Je("v-if", !0)
        ])
      ]);
    };
  }
}), Nj = /* @__PURE__ */ ur(Dj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-slider.vue"]]), Rj = /* @__PURE__ */ ar({
  __name: "layer-time",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    function n(o, s) {
      e("changeTime", o, s);
    }
    return (o, s) => {
      var h, a, m, g, b;
      return Ve(), it(cn, null, [
        Je(" Layer time: slider widget "),
        ((h = t.layer.time) == null ? void 0 : h.widget) === se(ug).SLIDER ? (Ve(), on(Nj, {
          key: 0,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : Je("v-if", !0),
        Je(" Layer time: datepicker VALUE (one date) widget "),
        ((a = t.layer.time) == null ? void 0 : a.widget) === se(ug).DATEPICKER && ((m = t.layer.time) == null ? void 0 : m.mode) === se(zl).VALUE ? (Ve(), on(yj, {
          key: 1,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : Je("v-if", !0),
        Je(' Layer time: datepicker RANGE ("from:" date - "to:" date) widget '),
        ((g = t.layer.time) == null ? void 0 : g.widget) === se(ug).DATEPICKER && ((b = t.layer.time) == null ? void 0 : b.mode) === se(zl).RANGE ? (Ve(), on(bj, {
          key: 2,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : Je("v-if", !0)
      ], 64);
    };
  }
}), zj = /* @__PURE__ */ ur(Rj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time.vue"]]), Fj = { class: "lux-layer-manager-item relative" }, Bj = { class: "w-full flex flex-nowrap items-start gap-x-2" }, Vj = ["title"], Uj = ["aria-label", "title"], jj = ["aria-expanded", "aria-controls", "data-cy"], Gj = { class: "grow" }, $j = ["title", "aria-label"], qj = /* @__PURE__ */ ar({
  __name: "layer-item",
  props: {
    is3d: { type: Boolean, required: !0 },
    layer: { type: null, required: !0 },
    dragHandleClassName: { type: String, required: !0 },
    isOpen: { type: Boolean, required: !0 },
    isLayerComparatorOpen: { type: Boolean, required: !0 },
    displayLayerComparatorOpen: { type: Boolean, required: !0 }
  },
  emits: ["clickInfo", "clickToggle", "clickToggleLayerComparator", "clickRemove", "changeOpacity", "changeTime"],
  setup(t, { emit: e }) {
    const n = t, { t: o, onClickInfo: s } = DI(n.layer, { emit: e }), h = hs(), a = or(
      () => o(h.getLayerCurrentLabel(n.layer), { ns: "client" })
    ), m = or(
      () => o('Sort "{{layerName}}" in the list', {
        ns: "client",
        layerName: a.value
      })
    ), g = or(
      () => o('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: a.value
      })
    ), b = or(
      () => o('Remove layer "{{layerName}}"', {
        ns: "client",
        layerName: a.value
      })
    );
    function T(M, I) {
      e("changeTime", M, I);
    }
    return (M, I) => (Ve(), it("div", Fj, [
      ze("div", Bj, [
        ze("button", {
          class: Pr(["fa-solid fa-bars cursor-move mt-1", t.dragHandleClassName]),
          title: se(m)
        }, null, 10, Vj),
        ze("button", {
          class: "fa-solid fa-info mt-1",
          "aria-label": se(g),
          title: se(g),
          onClick: I[0] || (I[0] = (...P) => se(s) && se(s)(...P))
        }, null, 8, Uj),
        ze("button", {
          "aria-expanded": t.isOpen,
          "aria-controls": `layer-manager-item-content-${t.layer.id}`,
          "data-cy": `myLayerItemLabel-${t.layer.id}`,
          class: Pr([t.is3d ? "cursor-default" : "", "grow text-left break-words w-[70%] flex items-center"]),
          onClick: I[1] || (I[1] = (P) => M.$emit("clickToggle", t.layer))
        }, [
          ze("span", Gj, Gt(se(a)), 1),
          t.is3d ? Je("v-if", !0) : (Ve(), it("span", {
            key: 0,
            class: Pr(["w-3.5 fa-solid", t.isOpen ? "fa-xmark" : "fa-ellipsis"]),
            "aria-hidden": "true"
          }, null, 2))
        ], 10, jj),
        ze("button", {
          class: "mt-1 fa-regular fa-trash-can",
          title: se(b),
          "aria-label": se(b),
          onClick: I[2] || (I[2] = (P) => M.$emit("clickRemove", t.layer))
        }, null, 8, $j)
      ]),
      Je(" Layer item sub content (opacity and toggle comparator) "),
      t.is3d ? Je("v-if", !0) : (Ve(), on(cj, {
        key: 0,
        layer: t.layer,
        isOpen: t.isOpen,
        isLayerComparatorOpen: t.isLayerComparatorOpen,
        displayLayerComparatorOpen: t.displayLayerComparatorOpen,
        onClickToggleLayerComparator: I[3] || (I[3] = (P) => M.$emit("clickToggleLayerComparator", P)),
        onChangeOpacity: I[4] || (I[4] = (P, z) => M.$emit("changeOpacity", P, z))
      }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen"])),
      Je(" Layer time: slider OR datepicker widgets "),
      t.layer.time ? (Ve(), on(zj, {
        key: 1,
        layer: t.layer,
        onChangeTime: T
      }, null, 8, ["layer"])) : Je("v-if", !0)
    ]));
  }
}), bE = /* @__PURE__ */ ur(qj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item.vue"]]), Wj = {
  key: 0,
  class: "mb-4 sortable-layers-3d"
}, Hj = ["id"], Zj = { class: "sortable-layers" }, Xj = ["id"], Kj = { class: "flex flex-row justify-center space-x-1 my-2" }, Yj = /* @__PURE__ */ ar({
  __name: "layer-manager",
  emits: ["displayCatalog"],
  setup(t, { emit: e }) {
    const { t: n } = En(), { setMetadataId: o } = tx(), s = Ei(), h = ki(), a = $f(), m = iv(), { bgLayer: g } = xn(s), { sliderActive: b } = xn(m), T = or(() => [...s.layers].reverse()), M = or(() => [...s.layers3d].reverse()), I = Bn(), P = "drag-handle", z = or(
      () => a.isLayerStyleEditable(g.value)
    ), { setRemoteLayersOpen: V } = ki();
    _a(() => {
      const Pe = {
        dragClass: "lux-sortable-drag",
        ghostClass: "lux-sortable-ghost",
        sort: !0,
        handle: `.${P}`,
        forceFallback: H6
      }, Se = document.querySelector(".sortable-layers"), Ie = document.querySelector(".sortable-layers-3d");
      Se && lr.create(Se, {
        ...Pe,
        onSort: q
      }), Ie && lr.create(Ie, {
        ...Pe,
        onSort: re
      });
    });
    function q(Pe, Se) {
      const Ie = [...Pe.to.children].map((Xe) => Number(Xe.id)).reverse();
      s.reorderLayers(Ie, Se);
    }
    function re(Pe) {
      q(Pe, !0);
    }
    function X(Pe, Se) {
      s.setLayerOpacity(Pe.id, Se / 100);
    }
    function ae(Pe, Se, Ie) {
      s.setLayerTime(Pe.id, Se, Ie);
    }
    function ce(Pe) {
      s.removeLayers(Pe.id);
    }
    function ve(Pe) {
      I.value = I.value !== Pe.id ? Pe.id : void 0;
    }
    function Re() {
      h.openStyleEditorPanel();
    }
    function Fe() {
      m.toggleSlider();
    }
    return (Pe, Se) => (Ve(), it("div", null, [
      se(M).length > 0 ? (Ve(), it("ul", Wj, [
        (Ve(!0), it(cn, null, Ra(se(M), (Ie, Xe) => (Ve(), it("li", {
          key: Ie.id,
          id: Ie.id
        }, [
          Ft(bE, {
            is3d: !0,
            dragHandleClassName: P,
            layer: Ie,
            isOpen: se(I) === Ie.id,
            isLayerComparatorOpen: se(b),
            displayLayerComparatorOpen: Xe === 0,
            onClickRemove: ce,
            onClickToggle: ve,
            onClickToggleLayerComparator: Fe,
            onClickInfo: ($e) => se(o)(Ie.id),
            onChangeOpacity: X,
            onChangeTime: ($e, at) => ae(Ie, $e, at)
          }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen", "onClickInfo", "onChangeTime"])
        ], 8, Hj))), 128))
      ])) : Je("v-if", !0),
      ze("ul", Zj, [
        (Ve(!0), it(cn, null, Ra(se(T), (Ie, Xe) => (Ve(), it("li", {
          key: Ie.id,
          id: Ie.id
        }, [
          Ft(bE, {
            is3d: !1,
            dragHandleClassName: P,
            layer: Ie,
            isOpen: se(I) === Ie.id,
            isLayerComparatorOpen: se(b),
            displayLayerComparatorOpen: Xe === 0,
            onClickRemove: ce,
            onClickToggle: ve,
            onClickToggleLayerComparator: Fe,
            onClickInfo: ($e) => se(o)(Ie.id),
            onChangeOpacity: X,
            onChangeTime: ($e, at) => ae(Ie, $e, at)
          }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen", "onClickInfo", "onChangeTime"])
        ], 8, Xj))), 128))
      ]),
      Ft(ij, {
        layer: se(g) || se(Kg),
        showEditButton: se(z),
        onClickInfo: Se[0] || (Se[0] = () => se(g) && se(o)(se(g).id)),
        onClickEdit: Re
      }, null, 8, ["layer", "showEditButton"]),
      ze("div", Kj, [
        ze("button", {
          class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
          onClick: Se[1] || (Se[1] = (Ie) => e("displayCatalog"))
        }, Gt(se(n)("+ Add layers", { ns: "client" })), 1),
        ze("button", {
          class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
          onClick: Se[2] || (Se[2] = (Ie) => se(V)(!0))
        }, Gt(se(n)("+ Add external Wms", { ns: "client" })), 1)
      ])
    ]));
  }
}), Jj = /* @__PURE__ */ ur(Yj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-manager.vue"]]), Qj = { class: "flex flex-col h-full pt-1.5" }, e9 = { class: "h-16 shrink-0 flex justify-between lux-panel-title" }, t9 = ["aria-label"], r9 = { class: "flex flex-row gap-2 h-10 text-2xl" }, n9 = ["aria-expanded"], i9 = { key: 0 }, o9 = ["aria-expanded"], a9 = { class: "relative grow p-2.5 bg-primary overflow-auto" }, s9 = /* @__PURE__ */ ar({
  __name: "layer-panel",
  setup(t) {
    const { t: e } = En(), n = ki(), { setLayersOpen: o } = n, { myLayersTabOpen: s } = xn(n), { layers: h } = xn(Ei());
    function a() {
      n.setMyLayersTabOpen(!0);
    }
    function m() {
      n.setMyLayersTabOpen(!1);
    }
    return (g, b) => (Ve(), it("div", Qj, [
      Je(" Panel title and close button "),
      ze("div", e9, [
        ze("h1", null, Gt(se(e)("layers", { ns: "client" })), 1),
        ze("span", null, [
          ze("button", {
            onClick: b[0] || (b[0] = () => se(o)(!1)),
            "aria-label": se(e)("Close", { ns: "client" }),
            class: "fa-sharp fa-solid fa-close"
          }, null, 8, t9)
        ])
      ]),
      Je(" My Layers and Catalog tab labels "),
      ze("div", r9, [
        ze("button", {
          onClick: a,
          class: Pr(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", se(s) ? "bg-primary" : "bg-tertiary"]),
          "aria-expanded": se(s)
        }, [
          Cg(Gt(se(e)("my_layers", { ns: "client" })) + " ", 1),
          se(h).length ? (Ve(), it("span", i9, "(" + Gt(se(h).length) + ")", 1)) : Je("v-if", !0)
        ], 10, n9),
        ze("button", {
          onClick: m,
          class: Pr(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", se(s) ? "bg-tertiary" : "bg-primary"]),
          "aria-expanded": !se(s)
        }, Gt(se(e)("Catalog", { ns: "client" })), 11, o9)
      ]),
      Je(" Panel content (MyLayers and Catalog) "),
      ze("div", a9, [
        se(s) ? (Ve(), on(Jj, {
          key: 0,
          onDisplayCatalog: m
        })) : Je("v-if", !0),
        se(s) ? Je("v-if", !0) : (Ve(), on(TU, { key: 1 }))
      ])
    ]));
  }
}), l9 = /* @__PURE__ */ ur(s9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-panel/layer-panel.vue"]]);
class u9 {
  bootstrap() {
    let e;
    e = va(() => {
      this.restore(), this.persist(), e && e();
    });
  }
  persist() {
    const e = iv();
    Pn(
      [() => e.sliderActive, () => e.sliderRatio],
      ([n, o], [s]) => {
        n !== s && Cr.setValue(s1, n), Cr.setValue(
          l1,
          o
        );
      }
    );
  }
  restore() {
    const e = Cr.getValue(s1, ex), n = Cr.getValue(l1, Cf), { toggleSlider: o, setRatio: s } = iv();
    typeof e < "u" && e !== null && (o(e), typeof n !== void 0 && n !== null && s(n != null ? n : LI));
  }
}
const c9 = new u9(), h9 = ["onKeydown"], f9 = /* @__PURE__ */ ze("span", { class: "lux-slider-line" }, null, -1), p9 = /* @__PURE__ */ ze("span", { class: "lux-slider-arrows" }, [
  /* @__PURE__ */ ze("span"),
  /* @__PURE__ */ ze("span")
], -1), d9 = {
  key: 0,
  class: "lux-slider-layer-label"
}, m9 = /* @__PURE__ */ ze("i", { class: "fa fa-arrow-left mr-2" }, null, -1), y9 = /* @__PURE__ */ ar({
  __name: "splitter-element",
  props: {
    sliderActive: { type: Boolean, required: !0 },
    sliderRatio: { type: Number, required: !0 },
    sliderTopLayer: { type: null, required: !0 },
    sliderOffset: { type: Number, required: !0 },
    containerOffset: { type: Number, required: !0 }
  },
  emits: ["moveSplitBar", "escSplitBar"],
  setup(t, { expose: e, emit: n }) {
    const o = t, s = 30, { t: h } = En(), a = _r(null), m = or(() => ({ left: `${o.sliderOffset}px` }));
    let g = !1;
    e({
      sliderElement: a
    });
    function b(q) {
      n("moveSplitBar", q + a.value.offsetWidth / 2);
    }
    function T() {
      g = !0, document.addEventListener("mousemove", M), document.addEventListener("mouseup", I);
    }
    function M(q) {
      !g || b(q.clientX);
    }
    function I() {
      g = !1, document.removeEventListener("mousemove", M), document.removeEventListener("mouseup", I);
    }
    function P() {
      const q = o.containerOffset + a.value.offsetLeft;
      b(q + s);
    }
    function z() {
      const q = o.containerOffset + a.value.offsetLeft;
      b(q - s);
    }
    function V() {
      n("escSplitBar");
    }
    return _a(() => {
      var q;
      (q = a.value) == null || q.focus({ focusVisible: !0 });
    }), Gu(() => {
      document.removeEventListener("mousemove", M), document.removeEventListener("mouseup", I);
    }), (q, re) => (Ve(), it("button", {
      ref_key: "sliderElement",
      ref: a,
      onMousedown: T,
      onMousemove: M,
      onMouseup: I,
      onKeydown: [
        Gs(js(P, ["stop"]), ["space"]),
        Gs(js(P, ["stop"]), ["right"]),
        Gs(js(z, ["stop"]), ["left"]),
        Gs(js(z, ["stop"]), ["delete"]),
        Gs(js(V, ["stop"]), ["esc"])
      ],
      class: "left-[20px] absolute h-full w-[32px] block",
      style: ju(se(m)),
      role: "seperator",
      "aria-controls": "map-container"
    }, [
      f9,
      p9,
      t.sliderTopLayer ? (Ve(), it("span", d9, [
        m9,
        ze("span", null, Gt(se(h)(t.sliderTopLayer.name)), 1)
      ])) : Je("v-if", !0)
    ], 44, h9));
  }
}), g9 = /* @__PURE__ */ ur(y9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/slider/splitter-element.vue"]]), v9 = /* @__PURE__ */ ar({
  __name: "slider-comparator",
  setup(t) {
    const e = iv(), n = nI(), o = Vl().olMap, s = _r(null), { sliderActive: h, sliderRatio: a, sliderTopLayer: m } = xn(e), g = or(
      () => {
        var X, ae;
        return ((ae = (X = s.value) == null ? void 0 : X.sliderElement) == null ? void 0 : ae.offsetWidth) || 0;
      }
    ), b = function() {
      var ae, ce, ve;
      let X = (ve = (ce = (ae = o.value) == null ? void 0 : ae.getViewport()) == null ? void 0 : ce.parentElement) == null ? void 0 : ve.offsetLeft;
      return (X === void 0 || X === 0) && (X = P == null ? void 0 : P.offsetLeft), X !== void 0 ? X : 0;
    }, T = or(() => {
      var X, ae;
      return o.value && s.value ? a.value * o.value.getSize()[0] - ((ae = (X = s.value) == null ? void 0 : X.sliderElement) == null ? void 0 : ae.offsetWidth) / 2 : 0;
    });
    let M, I, P;
    c9.bootstrap(), Pn([m, h], ([X, ae], [ce]) => {
      var ve;
      X && ae ? (X !== ce && V(), z()) : V(), (ve = o.value) == null || ve.render();
    }), Pn(T, () => {
      var X;
      (X = o.value) == null || X.render();
    });
    function z() {
      const X = n.getLayerFromCache(m.value);
      !X || (M = X.on(
        Db.PRERENDER,
        function(ae) {
          var Xe;
          const ce = ae.context, ve = (Xe = o.value) == null ? void 0 : Xe.getSize(), Re = T.value + g.value / 2, Fe = yy(ae, [0, 0]), Pe = yy(ae, [Re, 0]), Se = yy(ae, [0, ve[1]]), Ie = yy(ae, [Re, ve[0]]);
          ce.save(), ce.beginPath(), ce.moveTo(Fe[0], Fe[1]), ce.lineTo(Se[0], Se[1]), ce.lineTo(Ie[0], Ie[1]), ce.lineTo(Pe[0], Pe[1]), ce.closePath(), ce.clip();
        }
      ), I = X.on(
        Db.POSTRENDER,
        function(ae) {
          ae.context.restore();
        }
      ));
    }
    function V() {
      BC([M, I]);
    }
    function q(X) {
      var ve;
      const ae = (ve = o.value) == null ? void 0 : ve.getSize(), ce = (X - b()) / ae[0];
      e.setRatio(ce);
    }
    function re() {
      e.toggleSlider();
    }
    return _a(() => {
      var X, ae;
      P = (ae = (X = o.value) == null ? void 0 : X.getTargetElement()) == null ? void 0 : ae.closest(".map-wrapper");
    }), Gu(() => {
      V();
    }), (X, ae) => se(m) && se(h) ? (Ve(), on(g9, {
      key: 0,
      ref_key: "splitterElement",
      ref: s,
      sliderActive: se(h),
      sliderRatio: se(a),
      sliderTopLayer: se(m),
      sliderOffset: se(T),
      containerOffset: b(),
      onMoveSplitBar: q,
      onEscSplitBar: re
    }, null, 8, ["sliderActive", "sliderRatio", "sliderTopLayer", "sliderOffset", "containerOffset"])) : Je("v-if", !0);
  }
}), _9 = /* @__PURE__ */ ur(v9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/slider/slider-comparator.vue"]]), Hy = "-", x0 = ",", wE = "--";
class x9 {
  constructor() {
    bi(this, "layersOpacitiesToNumbersV2", (e) => this.layersOpacitiesToNumbers(e, x0));
  }
  layerTimesToStrings(e) {
    return e ? e.split(wE) : [];
  }
  layerIdsToLayers(e) {
    const n = Xc(), o = hs();
    return (e ? e.split(Hy) : []).map((h) => {
      const a = Kc.isRemoteLayer(h) ? L8(h) : n.findById(parseInt(h, 10));
      return a ? o.initLayer(a) : void 0;
    });
  }
  layerNamesToLayersV2(e) {
    const n = Xc(), o = hs();
    return (e ? e.split(x0) : []).map((h) => {
      const a = n.findByName(h);
      return a ? o.initLayer(a) : void 0;
    });
  }
  layersOpacitiesToNumbers(e, n = Hy) {
    return q6(e, n);
  }
  layersVisibilitiesToBooleansV2(e) {
    return W6(e, x0);
  }
  layersToLayerIds(e) {
    return (e == null ? void 0 : e.map((n) => n.id).join(Hy)) || "";
  }
  layersToLayerOpacities(e) {
    return (e == null ? void 0 : e.map((n) => {
      var o;
      return (o = n.opacity) != null ? o : 1;
    }).join(Hy)) || "";
  }
  layersToLayerTimes(e) {
    return (e == null ? void 0 : e.map((n) => {
      var o;
      return (o = hs().getLayerCurrentTime(n)) != null ? o : "";
    }).join(wE)) || "";
  }
  bgLayerNameToBgLayer(e) {
    const n = Xc();
    return e ? n.findBgLayerByName(e) : null;
  }
  bgLayerToBgLayerName(e) {
    return (e == null ? void 0 : e.name) || Kg.name;
  }
}
const da = new x9(), b9 = "basemap_2015_global", w9 = "orthogr_2013_global", E9 = {
  webbasemap: "basemap_2015_global",
  "pixelmaps-color": "topogr_global",
  "pixelmaps-gray": "topo_bw_jpeg",
  streets: "streets_jpeg",
  voidlayer: "blank"
};
class S9 {
  bootstrap() {
    const e = Ro();
    let n;
    n = va(() => {
      e.bgLayers.length > 0 && (this.restore(), this.persist(), n && n());
    });
  }
  persist() {
    const e = Ei(), { bgLayer: n } = xn(e);
    Pn(
      n,
      (o, s) => {
        s !== o && Cr.setValue(
          Z2,
          o,
          da.bgLayerToBgLayerName
        );
      },
      { immediate: !0 }
    );
  }
  restore() {
    const { setMapBackground: e } = iI(), n = this.getBgLayerFromStorage();
    e(n);
  }
  getBgLayerFromStorage() {
    const e = Cr.getInitialVersion(), n = Cr.getValue(Z2);
    return n ? e === 2 ? this.getBgLayerFromStorageV2(n) : da.bgLayerNameToBgLayer(n) : da.bgLayerNameToBgLayer(b9);
  }
  getBgLayerFromStorageV2(e) {
    const n = Cr.getValue(
      WM,
      Cf
    );
    let o = "";
    return e ? o = E9[e] : n === 0 && (o = w9), da.bgLayerNameToBgLayer(o);
  }
}
const T9 = new S9();
class M9 {
  bootstrap() {
    const e = Ro();
    let n;
    n = va(() => {
      e.themes && (this.restore(), this.persist(), n && n());
    });
  }
  persist() {
    const e = Ei(), { layers: n } = xn(e);
    Pn(
      n,
      (o, s) => {
        s !== o && (Cr.setValue(
          H2,
          o,
          da.layersToLayerIds
        ), Cr.setValue(
          X2,
          o,
          da.layersToLayerOpacities
        ), Cr.setValue(
          K2,
          o,
          da.layersToLayerTimes
        ));
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Cr.getInitialVersion(), n = Ei(), o = Cr.getValue(
      H2,
      e === 2 ? da.layerNamesToLayersV2 : da.layerIdsToLayers
    );
    this.restoreLayersOpacities(o, e), this.restoreLayersTimes(o), e === 2 && (Cr.removeItem(WM), Cr.removeItem(K6), Cr.removeItem(eE), Cr.removeItem(tE)), n.addLayers(...(o == null ? void 0 : o.filter((s) => s)) || []);
  }
  restoreLayersOpacities(e, n) {
    const o = n === 2 ? this.getOpacitiesFromStorageV2() : this.getOpacitiesFromStorage();
    o.length && (e == null || e.forEach(
      (s, h) => {
        var a;
        return s && (s.opacity = (a = o[h]) != null ? a : 1);
      }
    ));
  }
  restoreLayersTimes(e) {
    const n = Cr.getValue(
      K2,
      da.layerTimesToStrings
    );
    n.length && (e == null || e.forEach(
      (o, s) => o && n[s] && this.restoreLayerTime(o, n[s])
    ));
  }
  restoreLayerTime(e, n) {
    const o = n.split("/");
    e.currentTimeMinValue = o[0], e.currentTimeMaxValue = o[1];
  }
  getOpacitiesFromStorage() {
    return Cr.getValue(
      X2,
      da.layersOpacitiesToNumbers
    );
  }
  getOpacitiesFromStorageV2() {
    const e = Cr.getValue(
      eE,
      da.layersOpacitiesToNumbersV2
    ), n = Cr.getValue(
      tE,
      da.layersVisibilitiesToBooleansV2
    );
    return e.map((o, s) => n[s] ? o : 0);
  }
}
const I9 = new M9();
class O9 {
  themeToThemeName(e) {
    return (e == null ? void 0 : e.name) || "";
  }
}
const C9 = new O9();
class A9 {
  bootstrap() {
    this.restore();
    let e;
    e = va(() => {
      this.persist(), e && e();
    });
  }
  persist() {
    const e = Ro();
    Pn(
      () => e.theme,
      (n, o) => {
        o !== n && n && Cr.setValue(
          Rd,
          n,
          C9.themeToThemeName
        );
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Cr.getValue(Rd);
    if (e) {
      const { setTheme: n } = Ro();
      n(e);
    }
  }
}
const P9 = new A9();
class k9 {
  bootstrapLayersOpen() {
    this.restoreLayersOpen();
    let e;
    e = va(() => {
      this.persistLayersOpen(), e && e();
    });
  }
  persistLayersOpen() {
    const e = ki(), { layersOpen: n } = xn(e);
    Pn(
      n,
      (o, s) => {
        s !== o && Cr.setValue(qg, o);
      },
      { immediate: !0 }
    );
  }
  restoreLayersOpen() {
    const e = Cr.getValue(qg) !== "false", { setLayersOpen: n } = ki();
    n(e);
  }
}
const L9 = new k9();
class D9 {
  bootstrap() {
    this.restore();
    let e;
    e = va(() => {
      this.persist(), e && e();
    });
  }
  persist() {
  }
  restore() {
    const e = Cr.getValue(Z6);
    ki().setMapId(e);
  }
}
const N9 = new D9();
function g1(t) {
  return g1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, g1(t);
}
var NI = [], R9 = NI.forEach, z9 = NI.slice;
function v1(t) {
  return R9.call(z9.call(arguments, 1), function(e) {
    if (e)
      for (var n in e)
        t[n] === void 0 && (t[n] = e[n]);
  }), t;
}
function RI() {
  return typeof XMLHttpRequest == "function" || (typeof XMLHttpRequest > "u" ? "undefined" : g1(XMLHttpRequest)) === "object";
}
function F9(t) {
  return !!t && typeof t.then == "function";
}
function B9(t) {
  return F9(t) ? t : Promise.resolve(t);
}
function V9(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ov = { exports: {} }, Zy = { exports: {} }, EE;
function U9() {
  return EE || (EE = 1, function(t, e) {
    var n = typeof self < "u" ? self : $s, o = function() {
      function h() {
        this.fetch = !1, this.DOMException = n.DOMException;
      }
      return h.prototype = n, new h();
    }();
    (function(h) {
      (function(a) {
        var m = {
          searchParams: "URLSearchParams" in h,
          iterable: "Symbol" in h && "iterator" in Symbol,
          blob: "FileReader" in h && "Blob" in h && function() {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          }(),
          formData: "FormData" in h,
          arrayBuffer: "ArrayBuffer" in h
        };
        function g(be) {
          return be && DataView.prototype.isPrototypeOf(be);
        }
        if (m.arrayBuffer)
          var b = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ], T = ArrayBuffer.isView || function(be) {
            return be && b.indexOf(Object.prototype.toString.call(be)) > -1;
          };
        function M(be) {
          if (typeof be != "string" && (be = String(be)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(be))
            throw new TypeError("Invalid character in header field name");
          return be.toLowerCase();
        }
        function I(be) {
          return typeof be != "string" && (be = String(be)), be;
        }
        function P(be) {
          var Ye = {
            next: function() {
              var ht = be.shift();
              return { done: ht === void 0, value: ht };
            }
          };
          return m.iterable && (Ye[Symbol.iterator] = function() {
            return Ye;
          }), Ye;
        }
        function z(be) {
          this.map = {}, be instanceof z ? be.forEach(function(Ye, ht) {
            this.append(ht, Ye);
          }, this) : Array.isArray(be) ? be.forEach(function(Ye) {
            this.append(Ye[0], Ye[1]);
          }, this) : be && Object.getOwnPropertyNames(be).forEach(function(Ye) {
            this.append(Ye, be[Ye]);
          }, this);
        }
        z.prototype.append = function(be, Ye) {
          be = M(be), Ye = I(Ye);
          var ht = this.map[be];
          this.map[be] = ht ? ht + ", " + Ye : Ye;
        }, z.prototype.delete = function(be) {
          delete this.map[M(be)];
        }, z.prototype.get = function(be) {
          return be = M(be), this.has(be) ? this.map[be] : null;
        }, z.prototype.has = function(be) {
          return this.map.hasOwnProperty(M(be));
        }, z.prototype.set = function(be, Ye) {
          this.map[M(be)] = I(Ye);
        }, z.prototype.forEach = function(be, Ye) {
          for (var ht in this.map)
            this.map.hasOwnProperty(ht) && be.call(Ye, this.map[ht], ht, this);
        }, z.prototype.keys = function() {
          var be = [];
          return this.forEach(function(Ye, ht) {
            be.push(ht);
          }), P(be);
        }, z.prototype.values = function() {
          var be = [];
          return this.forEach(function(Ye) {
            be.push(Ye);
          }), P(be);
        }, z.prototype.entries = function() {
          var be = [];
          return this.forEach(function(Ye, ht) {
            be.push([ht, Ye]);
          }), P(be);
        }, m.iterable && (z.prototype[Symbol.iterator] = z.prototype.entries);
        function V(be) {
          if (be.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
          be.bodyUsed = !0;
        }
        function q(be) {
          return new Promise(function(Ye, ht) {
            be.onload = function() {
              Ye(be.result);
            }, be.onerror = function() {
              ht(be.error);
            };
          });
        }
        function re(be) {
          var Ye = new FileReader(), ht = q(Ye);
          return Ye.readAsArrayBuffer(be), ht;
        }
        function X(be) {
          var Ye = new FileReader(), ht = q(Ye);
          return Ye.readAsText(be), ht;
        }
        function ae(be) {
          for (var Ye = new Uint8Array(be), ht = new Array(Ye.length), vt = 0; vt < Ye.length; vt++)
            ht[vt] = String.fromCharCode(Ye[vt]);
          return ht.join("");
        }
        function ce(be) {
          if (be.slice)
            return be.slice(0);
          var Ye = new Uint8Array(be.byteLength);
          return Ye.set(new Uint8Array(be)), Ye.buffer;
        }
        function ve() {
          return this.bodyUsed = !1, this._initBody = function(be) {
            this._bodyInit = be, be ? typeof be == "string" ? this._bodyText = be : m.blob && Blob.prototype.isPrototypeOf(be) ? this._bodyBlob = be : m.formData && FormData.prototype.isPrototypeOf(be) ? this._bodyFormData = be : m.searchParams && URLSearchParams.prototype.isPrototypeOf(be) ? this._bodyText = be.toString() : m.arrayBuffer && m.blob && g(be) ? (this._bodyArrayBuffer = ce(be.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : m.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(be) || T(be)) ? this._bodyArrayBuffer = ce(be) : this._bodyText = be = Object.prototype.toString.call(be) : this._bodyText = "", this.headers.get("content-type") || (typeof be == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : m.searchParams && URLSearchParams.prototype.isPrototypeOf(be) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
          }, m.blob && (this.blob = function() {
            var be = V(this);
            if (be)
              return be;
            if (this._bodyBlob)
              return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]));
          }, this.arrayBuffer = function() {
            return this._bodyArrayBuffer ? V(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(re);
          }), this.text = function() {
            var be = V(this);
            if (be)
              return be;
            if (this._bodyBlob)
              return X(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(ae(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }, m.formData && (this.formData = function() {
            return this.text().then(Se);
          }), this.json = function() {
            return this.text().then(JSON.parse);
          }, this;
        }
        var Re = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function Fe(be) {
          var Ye = be.toUpperCase();
          return Re.indexOf(Ye) > -1 ? Ye : be;
        }
        function Pe(be, Ye) {
          Ye = Ye || {};
          var ht = Ye.body;
          if (be instanceof Pe) {
            if (be.bodyUsed)
              throw new TypeError("Already read");
            this.url = be.url, this.credentials = be.credentials, Ye.headers || (this.headers = new z(be.headers)), this.method = be.method, this.mode = be.mode, this.signal = be.signal, !ht && be._bodyInit != null && (ht = be._bodyInit, be.bodyUsed = !0);
          } else
            this.url = String(be);
          if (this.credentials = Ye.credentials || this.credentials || "same-origin", (Ye.headers || !this.headers) && (this.headers = new z(Ye.headers)), this.method = Fe(Ye.method || this.method || "GET"), this.mode = Ye.mode || this.mode || null, this.signal = Ye.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && ht)
            throw new TypeError("Body not allowed for GET or HEAD requests");
          this._initBody(ht);
        }
        Pe.prototype.clone = function() {
          return new Pe(this, { body: this._bodyInit });
        };
        function Se(be) {
          var Ye = new FormData();
          return be.trim().split("&").forEach(function(ht) {
            if (ht) {
              var vt = ht.split("="), Pt = vt.shift().replace(/\+/g, " "), tr = vt.join("=").replace(/\+/g, " ");
              Ye.append(decodeURIComponent(Pt), decodeURIComponent(tr));
            }
          }), Ye;
        }
        function Ie(be) {
          var Ye = new z(), ht = be.replace(/\r?\n[\t ]+/g, " ");
          return ht.split(/\r?\n/).forEach(function(vt) {
            var Pt = vt.split(":"), tr = Pt.shift().trim();
            if (tr) {
              var kn = Pt.join(":").trim();
              Ye.append(tr, kn);
            }
          }), Ye;
        }
        ve.call(Pe.prototype);
        function Xe(be, Ye) {
          Ye || (Ye = {}), this.type = "default", this.status = Ye.status === void 0 ? 200 : Ye.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in Ye ? Ye.statusText : "OK", this.headers = new z(Ye.headers), this.url = Ye.url || "", this._initBody(be);
        }
        ve.call(Xe.prototype), Xe.prototype.clone = function() {
          return new Xe(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new z(this.headers),
            url: this.url
          });
        }, Xe.error = function() {
          var be = new Xe(null, { status: 0, statusText: "" });
          return be.type = "error", be;
        };
        var $e = [301, 302, 303, 307, 308];
        Xe.redirect = function(be, Ye) {
          if ($e.indexOf(Ye) === -1)
            throw new RangeError("Invalid status code");
          return new Xe(null, { status: Ye, headers: { location: be } });
        }, a.DOMException = h.DOMException;
        try {
          new a.DOMException();
        } catch {
          a.DOMException = function(Ye, ht) {
            this.message = Ye, this.name = ht;
            var vt = Error(Ye);
            this.stack = vt.stack;
          }, a.DOMException.prototype = Object.create(Error.prototype), a.DOMException.prototype.constructor = a.DOMException;
        }
        function at(be, Ye) {
          return new Promise(function(ht, vt) {
            var Pt = new Pe(be, Ye);
            if (Pt.signal && Pt.signal.aborted)
              return vt(new a.DOMException("Aborted", "AbortError"));
            var tr = new XMLHttpRequest();
            function kn() {
              tr.abort();
            }
            tr.onload = function() {
              var Rr = {
                status: tr.status,
                statusText: tr.statusText,
                headers: Ie(tr.getAllResponseHeaders() || "")
              };
              Rr.url = "responseURL" in tr ? tr.responseURL : Rr.headers.get("X-Request-URL");
              var pr = "response" in tr ? tr.response : tr.responseText;
              ht(new Xe(pr, Rr));
            }, tr.onerror = function() {
              vt(new TypeError("Network request failed"));
            }, tr.ontimeout = function() {
              vt(new TypeError("Network request failed"));
            }, tr.onabort = function() {
              vt(new a.DOMException("Aborted", "AbortError"));
            }, tr.open(Pt.method, Pt.url, !0), Pt.credentials === "include" ? tr.withCredentials = !0 : Pt.credentials === "omit" && (tr.withCredentials = !1), "responseType" in tr && m.blob && (tr.responseType = "blob"), Pt.headers.forEach(function(Rr, pr) {
              tr.setRequestHeader(pr, Rr);
            }), Pt.signal && (Pt.signal.addEventListener("abort", kn), tr.onreadystatechange = function() {
              tr.readyState === 4 && Pt.signal.removeEventListener("abort", kn);
            }), tr.send(typeof Pt._bodyInit > "u" ? null : Pt._bodyInit);
          });
        }
        return at.polyfill = !0, h.fetch || (h.fetch = at, h.Headers = z, h.Request = Pe, h.Response = Xe), a.Headers = z, a.Request = Pe, a.Response = Xe, a.fetch = at, Object.defineProperty(a, "__esModule", { value: !0 }), a;
      })({});
    })(o), o.fetch.ponyfill = !0, delete o.fetch.polyfill;
    var s = o;
    e = s.fetch, e.default = s.fetch, e.fetch = s.fetch, e.Headers = s.Headers, e.Request = s.Request, e.Response = s.Response, t.exports = e;
  }(Zy, Zy.exports)), Zy.exports;
}
(function(t, e) {
  var n;
  if (typeof fetch == "function" && (typeof $s < "u" && $s.fetch ? n = $s.fetch : typeof window < "u" && window.fetch ? n = window.fetch : n = fetch), typeof V9 < "u" && (typeof window > "u" || typeof window.document > "u")) {
    var o = n || U9();
    o.default && (o = o.default), e.default = o, t.exports = e.default;
  }
})(ov, ov.exports);
const zI = ov.exports, SE = /* @__PURE__ */ UC({
  __proto__: null,
  default: zI
}, [ov.exports]);
function av(t) {
  return av = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, av(t);
}
var jl;
typeof fetch == "function" && (typeof global < "u" && global.fetch ? jl = global.fetch : typeof window < "u" && window.fetch ? jl = window.fetch : jl = fetch);
var zd;
RI() && (typeof global < "u" && global.XMLHttpRequest ? zd = global.XMLHttpRequest : typeof window < "u" && window.XMLHttpRequest && (zd = window.XMLHttpRequest));
var sv;
typeof ActiveXObject == "function" && (typeof global < "u" && global.ActiveXObject ? sv = global.ActiveXObject : typeof window < "u" && window.ActiveXObject && (sv = window.ActiveXObject));
!jl && SE && !zd && !sv && (jl = zI || SE);
typeof jl != "function" && (jl = void 0);
var _1 = function(e, n) {
  if (n && av(n) === "object") {
    var o = "";
    for (var s in n)
      o += "&" + encodeURIComponent(s) + "=" + encodeURIComponent(n[s]);
    if (!o)
      return e;
    e = e + (e.indexOf("?") !== -1 ? "&" : "?") + o.slice(1);
  }
  return e;
}, TE = function(e, n, o) {
  jl(e, n).then(function(s) {
    if (!s.ok)
      return o(s.statusText || "Error", {
        status: s.status
      });
    s.text().then(function(h) {
      o(null, {
        status: s.status,
        data: h
      });
    }).catch(o);
  }).catch(o);
}, ME = !1, j9 = function(e, n, o, s) {
  e.queryStringParams && (n = _1(n, e.queryStringParams));
  var h = v1({}, typeof e.customHeaders == "function" ? e.customHeaders() : e.customHeaders);
  o && (h["Content-Type"] = "application/json");
  var a = typeof e.requestOptions == "function" ? e.requestOptions(o) : e.requestOptions, m = v1({
    method: o ? "POST" : "GET",
    body: o ? e.stringify(o) : void 0,
    headers: h
  }, ME ? {} : a);
  try {
    TE(n, m, s);
  } catch (g) {
    if (!a || Object.keys(a).length === 0 || !g.message || g.message.indexOf("not implemented") < 0)
      return s(g);
    try {
      Object.keys(a).forEach(function(b) {
        delete m[b];
      }), TE(n, m, s), ME = !0;
    } catch (b) {
      s(b);
    }
  }
}, G9 = function(e, n, o, s) {
  o && av(o) === "object" && (o = _1("", o).slice(1)), e.queryStringParams && (n = _1(n, e.queryStringParams));
  try {
    var h;
    zd ? h = new zd() : h = new sv("MSXML2.XMLHTTP.3.0"), h.open(o ? "POST" : "GET", n, 1), e.crossDomain || h.setRequestHeader("X-Requested-With", "XMLHttpRequest"), h.withCredentials = !!e.withCredentials, o && h.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), h.overrideMimeType && h.overrideMimeType("application/json");
    var a = e.customHeaders;
    if (a = typeof a == "function" ? a() : a, a)
      for (var m in a)
        h.setRequestHeader(m, a[m]);
    h.onreadystatechange = function() {
      h.readyState > 3 && s(h.status >= 400 ? h.statusText : null, {
        status: h.status,
        data: h.responseText
      });
    }, h.send(o);
  } catch (g) {
    console && console.log(g);
  }
}, $9 = function(e, n, o, s) {
  if (typeof o == "function" && (s = o, o = void 0), s = s || function() {
  }, jl && n.indexOf("file:") !== 0)
    return j9(e, n, o, s);
  if (RI() || typeof ActiveXObject == "function")
    return G9(e, n, o, s);
  s(new Error("No fetch and no xhr implementation found!"));
};
function Fd(t) {
  return Fd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Fd(t);
}
function q9(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function IE(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, FI(o.key), o);
  }
}
function W9(t, e, n) {
  return e && IE(t.prototype, e), n && IE(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function H9(t, e, n) {
  return e = FI(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function FI(t) {
  var e = Z9(t, "string");
  return Fd(e) === "symbol" ? e : String(e);
}
function Z9(t, e) {
  if (Fd(t) !== "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (Fd(o) !== "object")
      return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var X9 = function() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    allowMultiLoading: !1,
    parse: function(n) {
      return JSON.parse(n);
    },
    stringify: JSON.stringify,
    parsePayload: function(n, o, s) {
      return H9({}, o, s || "");
    },
    request: $9,
    reloadInterval: typeof window < "u" ? !1 : 60 * 60 * 1e3,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: !1,
    withCredentials: !1,
    overrideMimeType: !1,
    requestOptions: {
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
}, BI = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    q9(this, t), this.services = e, this.options = n, this.allOptions = o, this.type = "backend", this.init(e, n, o);
  }
  return W9(t, [{
    key: "init",
    value: function(n) {
      var o = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = n, this.options = v1(s, this.options || {}, X9()), this.allOptions = h, this.services && this.options.reloadInterval && setInterval(function() {
        return o.reload();
      }, this.options.reloadInterval);
    }
  }, {
    key: "readMulti",
    value: function(n, o, s) {
      this._readAny(n, n, o, o, s);
    }
  }, {
    key: "read",
    value: function(n, o, s) {
      this._readAny([n], n, [o], o, s);
    }
  }, {
    key: "_readAny",
    value: function(n, o, s, h, a) {
      var m = this, g = this.options.loadPath;
      typeof this.options.loadPath == "function" && (g = this.options.loadPath(n, s)), g = B9(g), g.then(function(b) {
        if (!b)
          return a(null, {});
        var T = m.services.interpolator.interpolate(b, {
          lng: n.join("+"),
          ns: s.join("+")
        });
        m.loadUrl(T, a, o, h);
      });
    }
  }, {
    key: "loadUrl",
    value: function(n, o, s, h) {
      var a = this;
      this.options.request(this.options, n, void 0, function(m, g) {
        if (g && (g.status >= 500 && g.status < 600 || !g.status))
          return o("failed loading " + n + "; status code: " + g.status, !0);
        if (g && g.status >= 400 && g.status < 500)
          return o("failed loading " + n + "; status code: " + g.status, !1);
        if (!g && m && m.message && m.message.indexOf("Failed to fetch") > -1)
          return o("failed loading " + n + ": " + m.message, !0);
        if (m)
          return o(m, !1);
        var b, T;
        try {
          typeof g.data == "string" ? b = a.options.parse(g.data, s, h) : b = g.data;
        } catch {
          T = "failed parsing " + n + " to json";
        }
        if (T)
          return o(T, !1);
        o(null, b);
      });
    }
  }, {
    key: "create",
    value: function(n, o, s, h, a) {
      var m = this;
      if (!!this.options.addPath) {
        typeof n == "string" && (n = [n]);
        var g = this.options.parsePayload(o, s, h), b = 0, T = [], M = [];
        n.forEach(function(I) {
          var P = m.options.addPath;
          typeof m.options.addPath == "function" && (P = m.options.addPath(I, o));
          var z = m.services.interpolator.interpolate(P, {
            lng: I,
            ns: o
          });
          m.options.request(m.options, z, g, function(V, q) {
            b += 1, T.push(V), M.push(q), b === n.length && typeof a == "function" && a(T, M);
          });
        });
      }
    }
  }, {
    key: "reload",
    value: function() {
      var n = this, o = this.services, s = o.backendConnector, h = o.languageUtils, a = o.logger, m = s.language;
      if (!(m && m.toLowerCase() === "cimode")) {
        var g = [], b = function(M) {
          var I = h.toResolveHierarchy(M);
          I.forEach(function(P) {
            g.indexOf(P) < 0 && g.push(P);
          });
        };
        b(m), this.allOptions.preload && this.allOptions.preload.forEach(function(T) {
          return b(T);
        }), g.forEach(function(T) {
          n.allOptions.ns.forEach(function(M) {
            s.read(T, M, "read", null, null, function(I, P) {
              I && a.warn("loading namespace ".concat(M, " for language ").concat(T, " failed"), I), !I && P && a.log("loaded namespace ".concat(M, " for language ").concat(T), P), s.loaded("".concat(T, "|").concat(M), I, P);
            });
          });
        });
      }
    }
  }]), t;
}();
BI.type = "backend";
const K9 = /* @__PURE__ */ ar({
  __name: "simple-style-item",
  props: {
    styleName: { type: String, required: !0 },
    colors: { type: Array, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, o) => (Ve(!0), it(cn, null, Ra(e.colors, (s, h) => (Ve(), it("span", {
      key: `${t.styleName}-${h}`,
      class: "grow m-px",
      style: ju(`background-color: ${s}`)
    }, " \xA0 ", 4))), 128));
  }
}), Y9 = /* @__PURE__ */ ur(K9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/simple-style-item.vue"]]), J9 = { class: "text-white border-2 p-[10px] m-[10px]" }, Q9 = { class: "text-center mb-3" }, e7 = ["title"], t7 = { class: "text-white" }, r7 = ["title", "onClick"], n7 = { class: "flex" }, i7 = /* @__PURE__ */ ar({
  __name: "simple-style-selector",
  setup(t) {
    const { t: e } = En(), n = Ks(), o = $f(), { bgStyle: s } = xn(n), h = ss().simple_styles.road, a = _r(h);
    Pn(
      s,
      (g) => a.value = o.checkSelection(
        g || [],
        h
      ),
      { immediate: !0 }
    );
    function m(g) {
      n.setSimpleStyle(g);
    }
    return (g, b) => (Ve(), it("div", J9, [
      Je(" TODO: create clean container for simple and advanced style editors "),
      ze("h5", Q9, Gt(se(e)("Select a style", { ns: "client" })), 1),
      (Ve(!0), it(cn, null, Ra(a.value, (T) => (Ve(), it("div", {
        key: T.unlocalized_label,
        title: se(e)(T.unlocalized_label, { ns: "client" }),
        class: Pr(`${T.selected ? "border-dotted" : "border-hidden"} border-2 p-px`)
      }, [
        ze("span", t7, Gt(se(e)(T.unlocalized_label, { ns: "client" })) + " : ", 1),
        ze("button", {
          title: se(e)("Select style: {{styleName}}", {
            styleName: se(e)(T.unlocalized_label)
          }),
          onClick: (M) => m(T),
          class: "w-full"
        }, [
          ze("span", n7, [
            Ft(Y9, {
              colors: T.colors,
              "style-name": T.unlocalized_label
            }, null, 8, ["colors", "style-name"])
          ])
        ], 8, r7)
      ], 10, e7))), 128))
    ]));
  }
}), o7 = /* @__PURE__ */ ur(i7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/simple-style-selector.vue"]]);
function a7(t) {
  const e = s7(t);
  return !e || !e.medium_style_class ? [] : ss().medium_default_styles[e.medium_style_class];
}
function s7(t) {
  return ss().bg_layers.find((e) => e.id == (t == null ? void 0 : t.id));
}
const l7 = { class: "flex w-full items-center" }, u7 = {
  for: "colorId",
  class: "w-40"
}, c7 = { class: "grow" }, h7 = ["value"], f7 = ["checked", "aria-label"], p7 = /* @__PURE__ */ ar({
  __name: "medium-style-item",
  props: {
    style: { type: null, required: !0 },
    colorEditable: { type: Boolean, required: !0 }
  },
  emits: ["changeStyle"],
  setup(t, { emit: e }) {
    const n = t, { t: o } = En();
    function s(a) {
      if (a.target) {
        const m = {
          ...n.style,
          color: a.target.value
        };
        e("changeStyle", m);
      }
    }
    function h(a) {
      if (a) {
        const m = {
          ...n.style,
          visible: a.target.checked
        };
        e("changeStyle", m);
      }
    }
    return (a, m) => (Ve(), it("div", l7, [
      ze("label", u7, Gt(se(o)(t.style.label)), 1),
      ze("div", c7, [
        t.colorEditable && n.style.color ? (Ve(), it("input", {
          key: 0,
          id: "colorId",
          type: "color",
          class: "w-11 h-5 py-[1px] px-[2px]",
          value: n.style.color,
          onInput: s
        }, null, 40, h7)) : Je("v-if", !0)
      ]),
      ze("input", {
        type: "checkbox",
        class: "flex-none mr-3",
        checked: n.style.visible,
        onChange: h,
        "aria-label": se(o)("Show or hide {{ thematicName }}", {
          thematicName: n.style.label
        })
      }, null, 40, f7)
    ]));
  }
}), d7 = /* @__PURE__ */ ur(p7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/medium-style-item.vue"]]), m7 = { class: "text-white border-2 p-[10px] m-[10px]" }, y7 = { class: "text-center mb-3" }, g7 = /* @__PURE__ */ ar({
  __name: "medium-style-selector",
  props: {
    layer: { type: null, required: !0 }
  },
  setup(t) {
    const e = t, n = ["basemap_2015_global"], o = Ks(), { bgStyle: s } = xn(o), { t: h } = En(), a = or(
      () => n.includes(e.layer.name)
    ), m = or(
      () => s.value || a7(e.layer)
    );
    function g(b, T) {
      s.value = m.value.map(
        (M, I) => I === b ? T : M
      ), o.disableExpertStyle();
    }
    return (b, T) => (Ve(), it("div", m7, [
      ze("h5", y7, Gt(se(a) ? se(h)("Select a colour for every theme") : se(h)("Activate categories")), 1),
      (Ve(!0), it(cn, null, Ra(se(m), (M, I) => (Ve(), on(d7, {
        key: M.label,
        style: ju(M),
        onChangeStyle: (P) => g(I, P),
        colorEditable: se(a)
      }, null, 8, ["style", "onChangeStyle", "colorEditable"]))), 128))
    ]));
  }
}), v7 = /* @__PURE__ */ ur(g7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/medium-style-selector.vue"]]);
var VI = { exports: {} };
(function(t, e) {
  (function(n, o) {
    o();
  })($s, function() {
    function n(b, T) {
      return typeof T > "u" ? T = { autoBom: !1 } : typeof T != "object" && (console.warn("Deprecated: Expected third argument to be a object"), T = { autoBom: !T }), T.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(b.type) ? new Blob(["\uFEFF", b], { type: b.type }) : b;
    }
    function o(b, T, M) {
      var I = new XMLHttpRequest();
      I.open("GET", b), I.responseType = "blob", I.onload = function() {
        g(I.response, T, M);
      }, I.onerror = function() {
        console.error("could not download file");
      }, I.send();
    }
    function s(b) {
      var T = new XMLHttpRequest();
      T.open("HEAD", b, !1);
      try {
        T.send();
      } catch {
      }
      return 200 <= T.status && 299 >= T.status;
    }
    function h(b) {
      try {
        b.dispatchEvent(new MouseEvent("click"));
      } catch {
        var T = document.createEvent("MouseEvents");
        T.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), b.dispatchEvent(T);
      }
    }
    var a = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof $s == "object" && $s.global === $s ? $s : void 0, m = a.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = a.saveAs || (typeof window != "object" || window !== a ? function() {
    } : "download" in HTMLAnchorElement.prototype && !m ? function(b, T, M) {
      var I = a.URL || a.webkitURL, P = document.createElement("a");
      T = T || b.name || "download", P.download = T, P.rel = "noopener", typeof b == "string" ? (P.href = b, P.origin === location.origin ? h(P) : s(P.href) ? o(b, T, M) : h(P, P.target = "_blank")) : (P.href = I.createObjectURL(b), setTimeout(function() {
        I.revokeObjectURL(P.href);
      }, 4e4), setTimeout(function() {
        h(P);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(b, T, M) {
      if (T = T || b.name || "download", typeof b != "string")
        navigator.msSaveOrOpenBlob(n(b, M), T);
      else if (s(b))
        o(b, T, M);
      else {
        var I = document.createElement("a");
        I.href = b, I.target = "_blank", setTimeout(function() {
          h(I);
        });
      }
    } : function(b, T, M, I) {
      if (I = I || open("", "_blank"), I && (I.document.title = I.document.body.innerText = "downloading..."), typeof b == "string")
        return o(b, T, M);
      var P = b.type === "application/octet-stream", z = /constructor/i.test(a.HTMLElement) || a.safari, V = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((V || P && z || m) && typeof FileReader < "u") {
        var q = new FileReader();
        q.onloadend = function() {
          var ae = q.result;
          ae = V ? ae : ae.replace(/^data:[^;]*;/, "data:attachment/file;"), I ? I.location.href = ae : location = ae, I = null;
        }, q.readAsDataURL(b);
      } else {
        var re = a.URL || a.webkitURL, X = re.createObjectURL(b);
        I ? I.location = X : location.href = X, I = null, setTimeout(function() {
          re.revokeObjectURL(X);
        }, 4e4);
      }
    });
    a.saveAs = g.saveAs = g, t.exports = g;
  });
})(VI);
const _7 = { class: "text-white border-2 p-[10px] m-[10px] flex flex-col" }, x7 = { class: "text-center mb-3" }, b7 = { class: "flex flex-row justify-center" }, w7 = { class: "absolute top-[70px] w-full text-center text-base" }, E7 = { class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] text-sm" }, S7 = {
  class: "'block z-[5] w-full h-full cursor-pointer after:absolute after:py-[15px] after:px-[15px] after:w-full after:text-center after:content-upload",
  for: "uploadMvtStyle"
}, T7 = { class: "absolute top-[70px] w-full text-center text-base" }, M7 = ["href"], I7 = /* @__PURE__ */ ar({
  __name: "expert-style-selector",
  setup(t) {
    const e = Ei(), n = Ks(), o = $f(), { appliedStyle: s } = xn(n), { t: h } = En();
    function a() {
      const b = s.value, T = JSON.stringify(b), M = new Blob([T], { type: "text/plain;charset=utf-8" }), I = "styles.json";
      VI.exports.saveAs(M, I);
    }
    function m(b) {
      const T = b.target.files;
      if ((T == null ? void 0 : T.length) !== 1)
        return;
      const M = T[0];
      new File([], "./text.txt").text().then((P) => console.log(P)), M.type === "application/json" && (M.text().then((P) => {
        n.enableExpertStyle(), s.value = JSON.parse(P);
      }), b.target.value = "");
    }
    function g() {
      return n.styleSerial === null ? o.getDefaultMapBoxStyleUrl(
        o.getVectorId(e.bgLayer)
      ) : `${n.registerUrls.get("get")}?id=${n.styleSerial}`;
    }
    return (b, T) => (Ve(), it("div", _7, [
      ze("h5", x7, Gt(se(h)("Lancer \xE9diteur externe ou importer json")), 1),
      ze("div", b7, [
        ze("a", {
          href: "#",
          class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] z-5 text-sm after:absolute after:left-[20px] after:top-[10px] after:z-4 after:w-[3.6em] after:text-center after:content-download",
          onClick: T[0] || (T[0] = (M) => a())
        }, [
          ze("span", w7, Gt(se(h)("Download style")), 1)
        ]),
        ze("div", E7, [
          ze("label", S7, [
            ze("span", T7, Gt(se(h)("Upload style")), 1)
          ]),
          ze("input", {
            class: "invisible",
            type: "file",
            name: "uploadMvtStyle",
            id: "uploadMvtStyle",
            onChange: m
          }, null, 32)
        ])
      ]),
      ze("a", {
        href: `https://maputnik.github.io/editor/?style=${g()}`,
        target: "_blank",
        class: "lux-btn text-center"
      }, Gt(se(h)("Open Maputnik editor")), 9, M7)
    ]));
  }
}), O7 = /* @__PURE__ */ ur(I7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/expert-style-selector.vue"]]), C7 = { key: 0 }, A7 = { class: "h-20 shrink-0 flex justify-between lux-panel-title" }, P7 = { key: 0 }, k7 = { key: 1 }, L7 = { key: 2 }, D7 = /* @__PURE__ */ ar({
  __name: "style-selector",
  setup(t) {
    const { t: e } = En(), n = Ei(), o = ki(), s = Ks(), { bgLayer: h } = xn(n), a = $f(), m = or(
      () => a.getStyleCapabilitiesFromLayer(h.value)
    );
    Pn(h, (I) => {
      a.isLayerStyleEditable(I) || o.closeStyleEditorPanel();
    });
    let g = _r(!1), b = _r(!1), T = _r(!1);
    function M() {
      s.setStyle(null);
    }
    return (I, P) => se(m).isEditable ? (Ve(), it("div", C7, [
      ze("button", {
        onClick: P[0] || (P[0] = () => se(o).closeStyleEditorPanel())
      }, "X close"),
      ze("h2", A7, Gt(se(e)("Style editor")), 1),
      se(m).hasSimpleStyle ? (Ve(), it("div", P7, [
        ze("button", {
          onClick: P[1] || (P[1] = () => hn(g) ? g.value = !se(g) : g = !se(g))
        }, Gt(se(e)("Choose a predefined style")), 1),
        Ft(o7, {
          class: Pr(se(g) ? "" : "hidden")
        }, null, 8, ["class"])
      ])) : Je("v-if", !0),
      se(m).hasAdvancedStyle ? (Ve(), it("div", k7, [
        ze("button", {
          onClick: P[2] || (P[2] = () => hn(b) ? b.value = !se(b) : b = !se(b))
        }, Gt(se(e)("Change main colours")), 1),
        se(h) ? (Ve(), on(v7, {
          key: 0,
          class: Pr(se(b) ? "" : "hidden"),
          layer: se(h)
        }, null, 8, ["class", "layer"])) : Je("v-if", !0)
      ])) : Je("v-if", !0),
      se(m).hasExpertStyle ? (Ve(), it("div", L7, [
        ze("button", {
          onClick: P[3] || (P[3] = () => hn(T) ? T.value = !se(T) : T = !se(T))
        }, Gt(se(e)("Advanced settings")), 1),
        se(h) ? (Ve(), on(O7, {
          key: 0,
          class: Pr(se(T) ? "" : "hidden"),
          layer: se(h)
        }, null, 8, ["class", "layer"])) : Je("v-if", !0)
      ])) : Je("v-if", !0),
      ze("button", {
        onClick: M,
        class: "lux-btn"
      }, Gt(se(e)("Reset style", { ns: "client" })), 1)
    ])) : Je("v-if", !0);
  }
}), N7 = /* @__PURE__ */ ur(D7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/style-selector.vue"]]);
function UI(t, e, n) {
  n(t, e) && t instanceof VC && t.getLayers().forEach((s) => {
    UI(s, [...e, t], n);
  });
}
const R7 = { class: "h-screen flex flex-col overflow-hidden" }, z7 = { class: "flex grow" }, F7 = {
  key: 0,
  class: "w-full sm:w-80 bg-secondary z-10"
}, B7 = {
  key: 1,
  class: "w-80 bg-primary"
}, V7 = { class: "map-wrapper grow bg-blue-100 relative" }, U7 = { class: "absolute right-1 top-16" }, j7 = /* @__PURE__ */ ar({
  __name: "App",
  setup(t) {
    N9.bootstrap(), I9.bootstrap(), P9.bootstrap(), L9.bootstrapLayersOpen(), XM.bootstrapStyle(), T9.bootstrap();
    const { layersOpen: e, styleEditorOpen: n } = xn(ki());
    Pn(
      e,
      () => setTimeout(() => {
        o();
      }, 50)
    ), _a(() => window.addEventListener("resize", o)), Gu(() => window.removeEventListener("resize", o));
    function o() {
      const s = Vl().getOlMap();
      s.updateSize(), UI(s.getLayerGroup(), [], (h) => (h instanceof rI && h.getMapLibreMap().resize(), !0));
    }
    return (s, h) => (Ve(), it("div", R7, [
      Ft(XV),
      ze("main", z7, [
        Je(" Layer panel "),
        se(e) ? (Ve(), it("div", F7, [
          Ft(l9)
        ])) : Je("v-if", !0),
        Je(" Style editor "),
        se(n) ? (Ve(), it("div", B7, [
          Ft(N7)
        ])) : Je("v-if", !0),
        Je(" Map container and slider comparator "),
        ze("div", V7, [
          Ft(WF, { v4_standalone: !0 }),
          Ft(_9, { class: "absolute top-0" }),
          Ft($8),
          Ft(DV)
        ]),
        Je(" Background selector "),
        ze("div", U7, [
          Ft(tB)
        ])
      ]),
      Ft(oU, { class: "fixed bottom-5 sm:static z-20" }),
      Ft(K4)
    ]));
  }
}), G7 = /* @__PURE__ */ ur(j7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/App.vue"]]);
V4();
ii.use(BI);
ii.init({
  lng: "fr",
  debug: !1,
  defaultNS: "client",
  supportedLngs: ["de", "en", "fr", "lb"],
  ns: ["client", "legends", "server", "tooltips"],
  fallbackLng: "fr",
  backend: {
    loadPath: "/static-ngeo/web-components/assets/locales/{{ns}}.{{lng}}.json"
  },
  nsSeparator: "|"
});
const hx = Jk(G7);
hx.use(oD());
hx.use(V5, { i18next: ii });
hx.use(DL);
const mG = (t = {}, e = null) => U4(
  {
    setup: () => {
      const n = xv();
      Object.assign(n.appContext, e._context), Object.assign(n.provides, e._context.provides);
    },
    render: () => ZS(t)
  },
  { shadowRoot: !1 }
);
export {
  K4 as AlertNotifications,
  G7 as App,
  tB as BackgroundSelector,
  RT as DropdownList,
  oU as FooterBar,
  XV as HeaderBar,
  V5 as I18NextVue,
  DV as LayerMetadata,
  l9 as LayerPanel,
  WF as MapContainer,
  rI as MapLibreLayer,
  $8 as RemoteLayers,
  _9 as SliderComparator,
  DL as VueDOMPurifyHTML,
  hx as app,
  BI as backend,
  mG as createElementInstance,
  oD as createPinia,
  U4 as defineCustomElement,
  ii as i18next,
  T9 as statePersistorBgLayerService,
  L9 as statePersistorLayersOpenService,
  I9 as statePersistorLayersService,
  N9 as statePersistorMyMapService,
  XM as statePersistorStyleService,
  P9 as statePersistorThemeService,
  xn as storeToRefs,
  UV as themeSelectorService,
  ki as useAppStore,
  iI as useBackgroundLayer,
  hs as useLayers,
  Vl as useMap,
  Ei as useMapStore,
  $f as useMvtStyles,
  nI as useOpenLayers,
  Ks as useStyleStore,
  Ro as useThemeStore,
  Xc as useThemes,
  Pn as watch
};
