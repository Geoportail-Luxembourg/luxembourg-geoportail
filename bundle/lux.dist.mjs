var fC = Object.defineProperty;
var pC = (t, e, n) => e in t ? fC(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var bi = (t, e, n) => (pC(t, typeof e != "symbol" ? e + "" : e, n), n);
import { get as Hy, transformExtent as dC, getTransform as mC, transform as Pb } from "ol/proj";
import { register as yC } from "ol/proj/proj4";
import gC from "ol/Map";
import vC from "ol/View";
import _C from "ol/layer/Image";
import xC from "ol/layer/Tile";
import { ImageWMS as bC, WMTS as wC } from "ol/source";
import EC from "ol/tilegrid/WMTS";
import { getTopLeft as SC } from "ol/extent.js";
import TC from "ol/layer/Layer";
import { toDegrees as MC } from "ol/math";
import { toLonLat as IC } from "ol/proj.js";
import * as kb from "ol/events";
import OC from "ol/ObjectEventType";
import CC from "ol/control/Attribution";
import { CLASS_UNSELECTABLE as ME, CLASS_CONTROL as IE } from "ol/css";
import OE from "ol/control/Control";
import AC from "ol/control/FullScreen";
import PC from "ol/control/Zoom";
import kC from "ol/control/ZoomToExtent";
import LC from "ol/format/WMTSCapabilities.js";
import { getRenderPixel as dy } from "ol/render";
import { unByKey as DC } from "ol/Observable";
import Lb from "ol/render/EventType";
import NC from "ol/layer/Group.js";
function RC(t, e) {
  for (var n = 0; n < e.length; n++) {
    const a = e[n];
    if (typeof a != "string" && !Array.isArray(a)) {
      for (const s in a)
        if (s !== "default" && !(s in t)) {
          const h = Object.getOwnPropertyDescriptor(a, s);
          h && Object.defineProperty(t, s, h.get ? h : {
            enumerable: !0,
            get: () => a[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
function Bu(t, e) {
  const n = /* @__PURE__ */ Object.create(null), a = t.split(",");
  for (let s = 0; s < a.length; s++)
    n[a[s]] = !0;
  return e ? (s) => !!n[s.toLowerCase()] : (s) => !!n[s];
}
function Vu(t) {
  if (er(t)) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const a = t[n], s = Hn(a) ? VC(a) : Vu(a);
      if (s)
        for (const h in s)
          e[h] = s[h];
    }
    return e;
  } else {
    if (Hn(t))
      return t;
    if (fn(t))
      return t;
  }
}
const zC = /;(?![^(]*\))/g, FC = /:([^]+)/, BC = /\/\*.*?\*\//gs;
function VC(t) {
  const e = {};
  return t.replace(BC, "").split(zC).forEach((n) => {
    if (n) {
      const a = n.split(FC);
      a.length > 1 && (e[a[0].trim()] = a[1].trim());
    }
  }), e;
}
function Pr(t) {
  let e = "";
  if (Hn(t))
    e = t;
  else if (er(t))
    for (let n = 0; n < t.length; n++) {
      const a = Pr(t[n]);
      a && (e += a + " ");
    }
  else if (fn(t))
    for (const n in t)
      t[n] && (e += n + " ");
  return e.trim();
}
const UC = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", jC = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", GC = /* @__PURE__ */ Bu(UC), qC = /* @__PURE__ */ Bu(jC), $C = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", WC = /* @__PURE__ */ Bu($C);
function CE(t) {
  return !!t || t === "";
}
const Gt = (t) => Hn(t) ? t : t == null ? "" : er(t) || fn(t) && (t.toString === LE || !yr(t.toString)) ? JSON.stringify(t, AE, 2) : String(t), AE = (t, e) => e && e.__v_isRef ? AE(t, e.value) : Uc(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce((n, [a, s]) => (n[`${a} =>`] = s, n), {})
} : kE(e) ? {
  [`Set(${e.size})`]: [...e.values()]
} : fn(e) && !er(e) && !DE(e) ? String(e) : e, wn = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, xf = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], ao = () => {
}, PE = () => !1, HC = /^on[^a-z]/, Fd = (t) => HC.test(t), mg = (t) => t.startsWith("onUpdate:"), Wn = Object.assign, _1 = (t, e) => {
  const n = t.indexOf(e);
  n > -1 && t.splice(n, 1);
}, ZC = Object.prototype.hasOwnProperty, jr = (t, e) => ZC.call(t, e), er = Array.isArray, Uc = (t) => av(t) === "[object Map]", kE = (t) => av(t) === "[object Set]", yr = (t) => typeof t == "function", Hn = (t) => typeof t == "string", x1 = (t) => typeof t == "symbol", fn = (t) => t !== null && typeof t == "object", b1 = (t) => fn(t) && yr(t.then) && yr(t.catch), LE = Object.prototype.toString, av = (t) => LE.call(t), w1 = (t) => av(t).slice(8, -1), DE = (t) => av(t) === "[object Object]", E1 = (t) => Hn(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Zy = /* @__PURE__ */ Bu(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), XC = /* @__PURE__ */ Bu("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), sv = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = t(n));
}, KC = /-(\w)/g, ya = sv((t) => t.replace(KC, (e, n) => n ? n.toUpperCase() : "")), YC = /\B([A-Z])/g, ta = sv((t) => t.replace(YC, "-$1").toLowerCase()), Xc = sv((t) => t.charAt(0).toUpperCase() + t.slice(1)), kc = sv((t) => t ? `on${Xc(t)}` : ""), Ed = (t, e) => !Object.is(t, e), Vp = (t, e) => {
  for (let n = 0; n < t.length; n++)
    t[n](e);
}, yg = (t, e, n) => {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !1,
    value: n
  });
}, JC = (t) => {
  const e = parseFloat(t);
  return isNaN(e) ? t : e;
}, _0 = (t) => {
  const e = Hn(t) ? Number(t) : NaN;
  return isNaN(e) ? t : e;
};
let Db;
const NE = () => Db || (Db = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function gg(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
let pa;
class RE {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = pa, !e && pa && (this.index = (pa.scopes || (pa.scopes = [])).push(this) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const n = pa;
      try {
        return pa = this, e();
      } finally {
        pa = n;
      }
    } else
      process.env.NODE_ENV !== "production" && gg("cannot run an inactive effect scope.");
  }
  on() {
    pa = this;
  }
  off() {
    pa = this.parent;
  }
  stop(e) {
    if (this._active) {
      let n, a;
      for (n = 0, a = this.effects.length; n < a; n++)
        this.effects[n].stop();
      for (n = 0, a = this.cleanups.length; n < a; n++)
        this.cleanups[n]();
      if (this.scopes)
        for (n = 0, a = this.scopes.length; n < a; n++)
          this.scopes[n].stop(!0);
      if (!this.detached && this.parent && !e) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function zE(t) {
  return new RE(t);
}
function QC(t, e = pa) {
  e && e.active && e.effects.push(t);
}
function FE() {
  return pa;
}
function eA(t) {
  pa ? pa.cleanups.push(t) : process.env.NODE_ENV !== "production" && gg("onScopeDispose() is called when there is no active effect scope to be associated with.");
}
const Sd = (t) => {
  const e = new Set(t);
  return e.w = 0, e.n = 0, e;
}, BE = (t) => (t.w & Lu) > 0, VE = (t) => (t.n & Lu) > 0, tA = ({ deps: t }) => {
  if (t.length)
    for (let e = 0; e < t.length; e++)
      t[e].w |= Lu;
}, rA = (t) => {
  const { deps: e } = t;
  if (e.length) {
    let n = 0;
    for (let a = 0; a < e.length; a++) {
      const s = e[a];
      BE(s) && !VE(s) ? s.delete(t) : e[n++] = s, s.w &= ~Lu, s.n &= ~Lu;
    }
    e.length = n;
  }
}, vg = /* @__PURE__ */ new WeakMap();
let Kp = 0, Lu = 1;
const x0 = 30;
let No;
const jc = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : ""), b0 = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class S1 {
  constructor(e, n = null, a) {
    this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, QC(this, a);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = No, n = Iu;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = No, No = this, Iu = !0, Lu = 1 << ++Kp, Kp <= x0 ? tA(this) : Nb(this), this.fn();
    } finally {
      Kp <= x0 && rA(this), Lu = 1 << --Kp, No = this.parent, Iu = n, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    No === this ? this.deferStop = !0 : this.active && (Nb(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function Nb(t) {
  const { deps: e } = t;
  if (e.length) {
    for (let n = 0; n < e.length; n++)
      e[n].delete(t);
    e.length = 0;
  }
}
let Iu = !0;
const UE = [];
function eh() {
  UE.push(Iu), Iu = !1;
}
function th() {
  const t = UE.pop();
  Iu = t === void 0 ? !0 : t;
}
function Bo(t, e, n) {
  if (Iu && No) {
    let a = vg.get(t);
    a || vg.set(t, a = /* @__PURE__ */ new Map());
    let s = a.get(n);
    s || a.set(n, s = Sd());
    const h = process.env.NODE_ENV !== "production" ? { effect: No, target: t, type: e, key: n } : void 0;
    w0(s, h);
  }
}
function w0(t, e) {
  let n = !1;
  Kp <= x0 ? VE(t) || (t.n |= Lu, n = !BE(t)) : n = !t.has(No), n && (t.add(No), No.deps.push(t), process.env.NODE_ENV !== "production" && No.onTrack && No.onTrack(Object.assign({ effect: No }, e)));
}
function Vl(t, e, n, a, s, h) {
  const o = vg.get(t);
  if (!o)
    return;
  let m = [];
  if (e === "clear")
    m = [...o.values()];
  else if (n === "length" && er(t)) {
    const b = Number(a);
    o.forEach((T, M) => {
      (M === "length" || M >= b) && m.push(T);
    });
  } else
    switch (n !== void 0 && m.push(o.get(n)), e) {
      case "add":
        er(t) ? E1(n) && m.push(o.get("length")) : (m.push(o.get(jc)), Uc(t) && m.push(o.get(b0)));
        break;
      case "delete":
        er(t) || (m.push(o.get(jc)), Uc(t) && m.push(o.get(b0)));
        break;
      case "set":
        Uc(t) && m.push(o.get(jc));
        break;
    }
  const g = process.env.NODE_ENV !== "production" ? { target: t, type: e, key: n, newValue: a, oldValue: s, oldTarget: h } : void 0;
  if (m.length === 1)
    m[0] && (process.env.NODE_ENV !== "production" ? ff(m[0], g) : ff(m[0]));
  else {
    const b = [];
    for (const T of m)
      T && b.push(...T);
    process.env.NODE_ENV !== "production" ? ff(Sd(b), g) : ff(Sd(b));
  }
}
function ff(t, e) {
  const n = er(t) ? t : [...t];
  for (const a of n)
    a.computed && Rb(a, e);
  for (const a of n)
    a.computed || Rb(a, e);
}
function Rb(t, e) {
  (t !== No || t.allowRecurse) && (process.env.NODE_ENV !== "production" && t.onTrigger && t.onTrigger(Wn({ effect: t }, e)), t.scheduler ? t.scheduler() : t.run());
}
function nA(t, e) {
  var n;
  return (n = vg.get(t)) === null || n === void 0 ? void 0 : n.get(e);
}
const iA = /* @__PURE__ */ Bu("__proto__,__v_isRef,__isVue"), jE = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(x1)
), oA = /* @__PURE__ */ lv(), aA = /* @__PURE__ */ lv(!1, !0), sA = /* @__PURE__ */ lv(!0), lA = /* @__PURE__ */ lv(!0, !0), zb = /* @__PURE__ */ uA();
function uA() {
  const t = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    t[e] = function(...n) {
      const a = hr(this);
      for (let h = 0, o = this.length; h < o; h++)
        Bo(a, "get", h + "");
      const s = a[e](...n);
      return s === -1 || s === !1 ? a[e](...n.map(hr)) : s;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    t[e] = function(...n) {
      eh();
      const a = hr(this)[e].apply(this, n);
      return th(), a;
    };
  }), t;
}
function cA(t) {
  const e = hr(this);
  return Bo(e, "has", t), e.hasOwnProperty(t);
}
function lv(t = !1, e = !1) {
  return function(a, s, h) {
    if (s === "__v_isReactive")
      return !t;
    if (s === "__v_isReadonly")
      return t;
    if (s === "__v_isShallow")
      return e;
    if (s === "__v_raw" && h === (t ? e ? KE : XE : e ? ZE : HE).get(a))
      return a;
    const o = er(a);
    if (!t) {
      if (o && jr(zb, s))
        return Reflect.get(zb, s, h);
      if (s === "hasOwnProperty")
        return cA;
    }
    const m = Reflect.get(a, s, h);
    return (x1(s) ? jE.has(s) : iA(s)) || (t || Bo(a, "get", s), e) ? m : hn(m) ? o && E1(s) ? m : m.value : fn(m) ? t ? YE(m) : hv(m) : m;
  };
}
const hA = /* @__PURE__ */ GE(), fA = /* @__PURE__ */ GE(!0);
function GE(t = !1) {
  return function(n, a, s, h) {
    let o = n[a];
    if (Du(o) && hn(o) && !hn(s))
      return !1;
    if (!t && (!_g(s) && !Du(s) && (o = hr(o), s = hr(s)), !er(n) && hn(o) && !hn(s)))
      return o.value = s, !0;
    const m = er(n) && E1(a) ? Number(a) < n.length : jr(n, a), g = Reflect.set(n, a, s, h);
    return n === hr(h) && (m ? Ed(s, o) && Vl(n, "set", a, s, o) : Vl(n, "add", a, s)), g;
  };
}
function pA(t, e) {
  const n = jr(t, e), a = t[e], s = Reflect.deleteProperty(t, e);
  return s && n && Vl(t, "delete", e, void 0, a), s;
}
function dA(t, e) {
  const n = Reflect.has(t, e);
  return (!x1(e) || !jE.has(e)) && Bo(t, "has", e), n;
}
function mA(t) {
  return Bo(t, "iterate", er(t) ? "length" : jc), Reflect.ownKeys(t);
}
const qE = {
  get: oA,
  set: hA,
  deleteProperty: pA,
  has: dA,
  ownKeys: mA
}, $E = {
  get: sA,
  set(t, e) {
    return process.env.NODE_ENV !== "production" && gg(`Set operation on key "${String(e)}" failed: target is readonly.`, t), !0;
  },
  deleteProperty(t, e) {
    return process.env.NODE_ENV !== "production" && gg(`Delete operation on key "${String(e)}" failed: target is readonly.`, t), !0;
  }
}, yA = /* @__PURE__ */ Wn({}, qE, {
  get: aA,
  set: fA
}), gA = /* @__PURE__ */ Wn({}, $E, {
  get: lA
}), T1 = (t) => t, uv = (t) => Reflect.getPrototypeOf(t);
function my(t, e, n = !1, a = !1) {
  t = t.__v_raw;
  const s = hr(t), h = hr(e);
  n || (e !== h && Bo(s, "get", e), Bo(s, "get", h));
  const { has: o } = uv(s), m = a ? T1 : n ? M1 : Td;
  if (o.call(s, e))
    return m(t.get(e));
  if (o.call(s, h))
    return m(t.get(h));
  t !== s && t.get(e);
}
function yy(t, e = !1) {
  const n = this.__v_raw, a = hr(n), s = hr(t);
  return e || (t !== s && Bo(a, "has", t), Bo(a, "has", s)), t === s ? n.has(t) : n.has(t) || n.has(s);
}
function gy(t, e = !1) {
  return t = t.__v_raw, !e && Bo(hr(t), "iterate", jc), Reflect.get(t, "size", t);
}
function Fb(t) {
  t = hr(t);
  const e = hr(this);
  return uv(e).has.call(e, t) || (e.add(t), Vl(e, "add", t, t)), this;
}
function Bb(t, e) {
  e = hr(e);
  const n = hr(this), { has: a, get: s } = uv(n);
  let h = a.call(n, t);
  h ? process.env.NODE_ENV !== "production" && WE(n, a, t) : (t = hr(t), h = a.call(n, t));
  const o = s.call(n, t);
  return n.set(t, e), h ? Ed(e, o) && Vl(n, "set", t, e, o) : Vl(n, "add", t, e), this;
}
function Vb(t) {
  const e = hr(this), { has: n, get: a } = uv(e);
  let s = n.call(e, t);
  s ? process.env.NODE_ENV !== "production" && WE(e, n, t) : (t = hr(t), s = n.call(e, t));
  const h = a ? a.call(e, t) : void 0, o = e.delete(t);
  return s && Vl(e, "delete", t, void 0, h), o;
}
function Ub() {
  const t = hr(this), e = t.size !== 0, n = process.env.NODE_ENV !== "production" ? Uc(t) ? new Map(t) : new Set(t) : void 0, a = t.clear();
  return e && Vl(t, "clear", void 0, void 0, n), a;
}
function vy(t, e) {
  return function(a, s) {
    const h = this, o = h.__v_raw, m = hr(o), g = e ? T1 : t ? M1 : Td;
    return !t && Bo(m, "iterate", jc), o.forEach((b, T) => a.call(s, g(b), g(T), h));
  };
}
function _y(t, e, n) {
  return function(...a) {
    const s = this.__v_raw, h = hr(s), o = Uc(h), m = t === "entries" || t === Symbol.iterator && o, g = t === "keys" && o, b = s[t](...a), T = n ? T1 : e ? M1 : Td;
    return !e && Bo(h, "iterate", g ? b0 : jc), {
      next() {
        const { value: M, done: I } = b.next();
        return I ? { value: M, done: I } : {
          value: m ? [T(M[0]), T(M[1])] : T(M),
          done: I
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function hu(t) {
  return function(...e) {
    if (process.env.NODE_ENV !== "production") {
      const n = e[0] ? `on key "${e[0]}" ` : "";
      console.warn(`${Xc(t)} operation ${n}failed: target is readonly.`, hr(this));
    }
    return t === "delete" ? !1 : this;
  };
}
function vA() {
  const t = {
    get(h) {
      return my(this, h);
    },
    get size() {
      return gy(this);
    },
    has: yy,
    add: Fb,
    set: Bb,
    delete: Vb,
    clear: Ub,
    forEach: vy(!1, !1)
  }, e = {
    get(h) {
      return my(this, h, !1, !0);
    },
    get size() {
      return gy(this);
    },
    has: yy,
    add: Fb,
    set: Bb,
    delete: Vb,
    clear: Ub,
    forEach: vy(!1, !0)
  }, n = {
    get(h) {
      return my(this, h, !0);
    },
    get size() {
      return gy(this, !0);
    },
    has(h) {
      return yy.call(this, h, !0);
    },
    add: hu("add"),
    set: hu("set"),
    delete: hu("delete"),
    clear: hu("clear"),
    forEach: vy(!0, !1)
  }, a = {
    get(h) {
      return my(this, h, !0, !0);
    },
    get size() {
      return gy(this, !0);
    },
    has(h) {
      return yy.call(this, h, !0);
    },
    add: hu("add"),
    set: hu("set"),
    delete: hu("delete"),
    clear: hu("clear"),
    forEach: vy(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((h) => {
    t[h] = _y(h, !1, !1), n[h] = _y(h, !0, !1), e[h] = _y(h, !1, !0), a[h] = _y(h, !0, !0);
  }), [
    t,
    n,
    e,
    a
  ];
}
const [_A, xA, bA, wA] = /* @__PURE__ */ vA();
function cv(t, e) {
  const n = e ? t ? wA : bA : t ? xA : _A;
  return (a, s, h) => s === "__v_isReactive" ? !t : s === "__v_isReadonly" ? t : s === "__v_raw" ? a : Reflect.get(jr(n, s) && s in a ? n : a, s, h);
}
const EA = {
  get: /* @__PURE__ */ cv(!1, !1)
}, SA = {
  get: /* @__PURE__ */ cv(!1, !0)
}, TA = {
  get: /* @__PURE__ */ cv(!0, !1)
}, MA = {
  get: /* @__PURE__ */ cv(!0, !0)
};
function WE(t, e, n) {
  const a = hr(n);
  if (a !== n && e.call(t, a)) {
    const s = w1(t);
    console.warn(`Reactive ${s} contains both the raw and reactive versions of the same object${s === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const HE = /* @__PURE__ */ new WeakMap(), ZE = /* @__PURE__ */ new WeakMap(), XE = /* @__PURE__ */ new WeakMap(), KE = /* @__PURE__ */ new WeakMap();
function IA(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function OA(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : IA(w1(t));
}
function hv(t) {
  return Du(t) ? t : fv(t, !1, qE, EA, HE);
}
function CA(t) {
  return fv(t, !1, yA, SA, ZE);
}
function YE(t) {
  return fv(t, !0, $E, TA, XE);
}
function pf(t) {
  return fv(t, !0, gA, MA, KE);
}
function fv(t, e, n, a, s) {
  if (!fn(t))
    return process.env.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(t)}`), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  const h = s.get(t);
  if (h)
    return h;
  const o = OA(t);
  if (o === 0)
    return t;
  const m = new Proxy(t, o === 2 ? a : n);
  return s.set(t, m), m;
}
function ss(t) {
  return Du(t) ? ss(t.__v_raw) : !!(t && t.__v_isReactive);
}
function Du(t) {
  return !!(t && t.__v_isReadonly);
}
function _g(t) {
  return !!(t && t.__v_isShallow);
}
function xg(t) {
  return ss(t) || Du(t);
}
function hr(t) {
  const e = t && t.__v_raw;
  return e ? hr(e) : t;
}
function ts(t) {
  return yg(t, "__v_skip", !0), t;
}
const Td = (t) => fn(t) ? hv(t) : t, M1 = (t) => fn(t) ? YE(t) : t;
function JE(t) {
  Iu && No && (t = hr(t), process.env.NODE_ENV !== "production" ? w0(t.dep || (t.dep = Sd()), {
    target: t,
    type: "get",
    key: "value"
  }) : w0(t.dep || (t.dep = Sd())));
}
function QE(t, e) {
  t = hr(t);
  const n = t.dep;
  n && (process.env.NODE_ENV !== "production" ? ff(n, {
    target: t,
    type: "set",
    key: "value",
    newValue: e
  }) : ff(n));
}
function hn(t) {
  return !!(t && t.__v_isRef === !0);
}
function Mr(t) {
  return eS(t, !1);
}
function Fn(t) {
  return eS(t, !0);
}
function eS(t, e) {
  return hn(t) ? t : new AA(t, e);
}
class AA {
  constructor(e, n) {
    this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : hr(e), this._value = n ? e : Td(e);
  }
  get value() {
    return JE(this), this._value;
  }
  set value(e) {
    const n = this.__v_isShallow || _g(e) || Du(e);
    e = n ? e : hr(e), Ed(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : Td(e), QE(this, e));
  }
}
function ae(t) {
  return hn(t) ? t.value : t;
}
const PA = {
  get: (t, e, n) => ae(Reflect.get(t, e, n)),
  set: (t, e, n, a) => {
    const s = t[e];
    return hn(s) && !hn(n) ? (s.value = n, !0) : Reflect.set(t, e, n, a);
  }
};
function tS(t) {
  return ss(t) ? t : new Proxy(t, PA);
}
function jb(t) {
  process.env.NODE_ENV !== "production" && !xg(t) && console.warn("toRefs() expects a reactive object but received a plain one.");
  const e = er(t) ? new Array(t.length) : {};
  for (const n in t)
    e[n] = ld(t, n);
  return e;
}
class kA {
  constructor(e, n, a) {
    this._object = e, this._key = n, this._defaultValue = a, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return nA(hr(this._object), this._key);
  }
}
function ld(t, e, n) {
  const a = t[e];
  return hn(a) ? a : new kA(t, e, n);
}
var rS;
class LA {
  constructor(e, n, a, s) {
    this._setter = n, this.dep = void 0, this.__v_isRef = !0, this[rS] = !1, this._dirty = !0, this.effect = new S1(e, () => {
      this._dirty || (this._dirty = !0, QE(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = a;
  }
  get value() {
    const e = hr(this);
    return JE(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
rS = "__v_isReadonly";
function DA(t, e, n = !1) {
  let a, s;
  const h = yr(t);
  h ? (a = t, s = process.env.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : ao) : (a = t.get, s = t.set);
  const o = new LA(a, s, h || !s, n);
  return process.env.NODE_ENV !== "production" && e && !n && (o.effect.onTrack = e.onTrack, o.effect.onTrigger = e.onTrigger), o;
}
const Gc = [];
function Xy(t) {
  Gc.push(t);
}
function Ky() {
  Gc.pop();
}
function lt(t, ...e) {
  if (process.env.NODE_ENV === "production")
    return;
  eh();
  const n = Gc.length ? Gc[Gc.length - 1].component : null, a = n && n.appContext.config.warnHandler, s = NA();
  if (a)
    Rl(a, n, 11, [
      t + e.join(""),
      n && n.proxy,
      s.map(({ vnode: h }) => `at <${xv(n, h.type)}>`).join(`
`),
      s
    ]);
  else {
    const h = [`[Vue warn]: ${t}`, ...e];
    s.length && h.push(`
`, ...RA(s)), console.warn(...h);
  }
  th();
}
function NA() {
  let t = Gc[Gc.length - 1];
  if (!t)
    return [];
  const e = [];
  for (; t; ) {
    const n = e[0];
    n && n.vnode === t ? n.recurseCount++ : e.push({
      vnode: t,
      recurseCount: 0
    });
    const a = t.component && t.component.parent;
    t = a && a.vnode;
  }
  return e;
}
function RA(t) {
  const e = [];
  return t.forEach((n, a) => {
    e.push(...a === 0 ? [] : [`
`], ...zA(n));
  }), e;
}
function zA({ vnode: t, recurseCount: e }) {
  const n = e > 0 ? `... (${e} recursive calls)` : "", a = t.component ? t.component.parent == null : !1, s = ` at <${xv(t.component, t.type, a)}`, h = ">" + n;
  return t.props ? [s, ...FA(t.props), h] : [s + h];
}
function FA(t) {
  const e = [], n = Object.keys(t);
  return n.slice(0, 3).forEach((a) => {
    e.push(...nS(a, t[a]));
  }), n.length > 3 && e.push(" ..."), e;
}
function nS(t, e, n) {
  return Hn(e) ? (e = JSON.stringify(e), n ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? n ? e : [`${t}=${e}`] : hn(e) ? (e = nS(t, hr(e.value), !0), n ? e : [`${t}=Ref<`, e, ">"]) : yr(e) ? [`${t}=fn${e.name ? `<${e.name}>` : ""}`] : (e = hr(e), n ? e : [`${t}=`, e]);
}
function BA(t, e) {
  process.env.NODE_ENV !== "production" && t !== void 0 && (typeof t != "number" ? lt(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && lt(`${e} is NaN - the duration expression might be incorrect.`));
}
const I1 = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function Rl(t, e, n, a) {
  let s;
  try {
    s = a ? t(...a) : t();
  } catch (h) {
    pv(h, e, n);
  }
  return s;
}
function La(t, e, n, a) {
  if (yr(t)) {
    const h = Rl(t, e, n, a);
    return h && b1(h) && h.catch((o) => {
      pv(o, e, n);
    }), h;
  }
  const s = [];
  for (let h = 0; h < t.length; h++)
    s.push(La(t[h], e, n, a));
  return s;
}
function pv(t, e, n, a = !0) {
  const s = e ? e.vnode : null;
  if (e) {
    let h = e.parent;
    const o = e.proxy, m = process.env.NODE_ENV !== "production" ? I1[n] : n;
    for (; h; ) {
      const b = h.ec;
      if (b) {
        for (let T = 0; T < b.length; T++)
          if (b[T](t, o, m) === !1)
            return;
      }
      h = h.parent;
    }
    const g = e.appContext.config.errorHandler;
    if (g) {
      Rl(g, null, 10, [t, o, m]);
      return;
    }
  }
  VA(t, n, s, a);
}
function VA(t, e, n, a = !0) {
  if (process.env.NODE_ENV !== "production") {
    const s = I1[e];
    if (n && Xy(n), lt(`Unhandled error${s ? ` during execution of ${s}` : ""}`), n && Ky(), a)
      throw t;
    console.error(t);
  } else
    console.error(t);
}
let Md = !1, E0 = !1;
const xo = [];
let Bs = 0;
const bf = [];
let zs = null, vu = 0;
const iS = /* @__PURE__ */ Promise.resolve();
let O1 = null;
const UA = 100;
function bg(t) {
  const e = O1 || iS;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function jA(t) {
  let e = Bs + 1, n = xo.length;
  for (; e < n; ) {
    const a = e + n >>> 1;
    Id(xo[a]) < t ? e = a + 1 : n = a;
  }
  return e;
}
function dv(t) {
  (!xo.length || !xo.includes(t, Md && t.allowRecurse ? Bs + 1 : Bs)) && (t.id == null ? xo.push(t) : xo.splice(jA(t.id), 0, t), oS());
}
function oS() {
  !Md && !E0 && (E0 = !0, O1 = iS.then(lS));
}
function GA(t) {
  const e = xo.indexOf(t);
  e > Bs && xo.splice(e, 1);
}
function aS(t) {
  er(t) ? bf.push(...t) : (!zs || !zs.includes(t, t.allowRecurse ? vu + 1 : vu)) && bf.push(t), oS();
}
function Gb(t, e = Md ? Bs + 1 : 0) {
  for (process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()); e < xo.length; e++) {
    const n = xo[e];
    if (n && n.pre) {
      if (process.env.NODE_ENV !== "production" && C1(t, n))
        continue;
      xo.splice(e, 1), e--, n();
    }
  }
}
function sS(t) {
  if (bf.length) {
    const e = [...new Set(bf)];
    if (bf.length = 0, zs) {
      zs.push(...e);
      return;
    }
    for (zs = e, process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), zs.sort((n, a) => Id(n) - Id(a)), vu = 0; vu < zs.length; vu++)
      process.env.NODE_ENV !== "production" && C1(t, zs[vu]) || zs[vu]();
    zs = null, vu = 0;
  }
}
const Id = (t) => t.id == null ? 1 / 0 : t.id, qA = (t, e) => {
  const n = Id(t) - Id(e);
  if (n === 0) {
    if (t.pre && !e.pre)
      return -1;
    if (e.pre && !t.pre)
      return 1;
  }
  return n;
};
function lS(t) {
  E0 = !1, Md = !0, process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), xo.sort(qA);
  const e = process.env.NODE_ENV !== "production" ? (n) => C1(t, n) : ao;
  try {
    for (Bs = 0; Bs < xo.length; Bs++) {
      const n = xo[Bs];
      if (n && n.active !== !1) {
        if (process.env.NODE_ENV !== "production" && e(n))
          continue;
        Rl(n, null, 14);
      }
    }
  } finally {
    Bs = 0, xo.length = 0, sS(t), Md = !1, O1 = null, (xo.length || bf.length) && lS(t);
  }
}
function C1(t, e) {
  if (!t.has(e))
    t.set(e, 1);
  else {
    const n = t.get(e);
    if (n > UA) {
      const a = e.ownerInstance, s = a && R1(a.type);
      return lt(`Maximum recursive updates exceeded${s ? ` in component <${s}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`), !0;
    } else
      t.set(e, n + 1);
  }
}
let Ou = !1;
const uf = /* @__PURE__ */ new Set();
process.env.NODE_ENV !== "production" && (NE().__VUE_HMR_RUNTIME__ = {
  createRecord: I_(uS),
  rerender: I_(HA),
  reload: I_(ZA)
});
const Kc = /* @__PURE__ */ new Map();
function $A(t) {
  const e = t.type.__hmrId;
  let n = Kc.get(e);
  n || (uS(e, t.type), n = Kc.get(e)), n.instances.add(t);
}
function WA(t) {
  Kc.get(t.type.__hmrId).instances.delete(t);
}
function uS(t, e) {
  return Kc.has(t) ? !1 : (Kc.set(t, {
    initialDef: ud(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function ud(t) {
  return qS(t) ? t.__vccOpts : t;
}
function HA(t, e) {
  const n = Kc.get(t);
  !n || (n.initialDef.render = e, [...n.instances].forEach((a) => {
    e && (a.render = e, ud(a.type).render = e), a.renderCache = [], Ou = !0, a.update(), Ou = !1;
  }));
}
function ZA(t, e) {
  const n = Kc.get(t);
  if (!n)
    return;
  e = ud(e), qb(n.initialDef, e);
  const a = [...n.instances];
  for (const s of a) {
    const h = ud(s.type);
    uf.has(h) || (h !== n.initialDef && qb(h, e), uf.add(h)), s.appContext.optionsCache.delete(s.type), s.ceReload ? (uf.add(h), s.ceReload(e.styles), uf.delete(h)) : s.parent ? dv(s.parent.update) : s.appContext.reload ? s.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
  }
  aS(() => {
    for (const s of a)
      uf.delete(ud(s.type));
  });
}
function qb(t, e) {
  Wn(t, e);
  for (const n in t)
    n !== "__file" && !(n in e) && delete t[n];
}
function I_(t) {
  return (e, n) => {
    try {
      return t(e, n);
    } catch (a) {
      console.error(a), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.");
    }
  };
}
let Vs, Yp = [], S0 = !1;
function Bd(t, ...e) {
  Vs ? Vs.emit(t, ...e) : S0 || Yp.push({ event: t, args: e });
}
function cS(t, e) {
  var n, a;
  Vs = t, Vs ? (Vs.enabled = !0, Yp.forEach(({ event: s, args: h }) => Vs.emit(s, ...h)), Yp = []) : typeof window < "u" && window.HTMLElement && !(!((a = (n = window.navigator) === null || n === void 0 ? void 0 : n.userAgent) === null || a === void 0) && a.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((h) => {
    cS(h, e);
  }), setTimeout(() => {
    Vs || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, S0 = !0, Yp = []);
  }, 3e3)) : (S0 = !0, Yp = []);
}
function XA(t, e) {
  Bd("app:init", t, e, {
    Fragment: cn,
    Text: jd,
    Comment: Xi,
    Static: Yy
  });
}
function KA(t) {
  Bd("app:unmount", t);
}
const YA = /* @__PURE__ */ A1("component:added"), hS = /* @__PURE__ */ A1("component:updated"), JA = /* @__PURE__ */ A1("component:removed"), QA = (t) => {
  Vs && typeof Vs.cleanupBuffer == "function" && !Vs.cleanupBuffer(t) && JA(t);
};
function A1(t) {
  return (e) => {
    Bd(t, e.appContext.app, e.uid, e.parent ? e.parent.uid : void 0, e);
  };
}
const eP = /* @__PURE__ */ fS("perf:start"), tP = /* @__PURE__ */ fS("perf:end");
function fS(t) {
  return (e, n, a) => {
    Bd(t, e.appContext.app, e.uid, e, n, a);
  };
}
function rP(t, e, n) {
  Bd("component:emit", t.appContext.app, t, e, n);
}
function nP(t, e, ...n) {
  if (t.isUnmounted)
    return;
  const a = t.vnode.props || wn;
  if (process.env.NODE_ENV !== "production") {
    const { emitsOptions: T, propsOptions: [M] } = t;
    if (T)
      if (!(e in T))
        (!M || !(kc(e) in M)) && lt(`Component emitted event "${e}" but it is neither declared in the emits option nor as an "${kc(e)}" prop.`);
      else {
        const I = T[e];
        yr(I) && (I(...n) || lt(`Invalid event arguments: event validation failed for event "${e}".`));
      }
  }
  let s = n;
  const h = e.startsWith("update:"), o = h && e.slice(7);
  if (o && o in a) {
    const T = `${o === "modelValue" ? "model" : o}Modifiers`, { number: M, trim: I } = a[T] || wn;
    I && (s = n.map((P) => Hn(P) ? P.trim() : P)), M && (s = n.map(JC));
  }
  if (process.env.NODE_ENV !== "production" && rP(t, e, s), process.env.NODE_ENV !== "production") {
    const T = e.toLowerCase();
    T !== e && a[kc(T)] && lt(`Event "${T}" is emitted in component ${xv(t, t.type)} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${ta(e)}" instead of "${e}".`);
  }
  let m, g = a[m = kc(e)] || a[m = kc(ya(e))];
  !g && h && (g = a[m = kc(ta(e))]), g && La(g, t, 6, s);
  const b = a[m + "Once"];
  if (b) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[m])
      return;
    t.emitted[m] = !0, La(b, t, 6, s);
  }
}
function pS(t, e, n = !1) {
  const a = e.emitsCache, s = a.get(t);
  if (s !== void 0)
    return s;
  const h = t.emits;
  let o = {}, m = !1;
  if (!yr(t)) {
    const g = (b) => {
      const T = pS(b, e, !0);
      T && (m = !0, Wn(o, T));
    };
    !n && e.mixins.length && e.mixins.forEach(g), t.extends && g(t.extends), t.mixins && t.mixins.forEach(g);
  }
  return !h && !m ? (fn(t) && a.set(t, null), null) : (er(h) ? h.forEach((g) => o[g] = null) : Wn(o, h), fn(t) && a.set(t, o), o);
}
function mv(t, e) {
  return !t || !Fd(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), jr(t, e[0].toLowerCase() + e.slice(1)) || jr(t, ta(e)) || jr(t, e));
}
let zi = null, dS = null;
function wg(t) {
  const e = zi;
  return zi = t, dS = t && t.type.__scopeId || null, e;
}
function Vd(t, e = zi, n) {
  if (!e || t._n)
    return t;
  const a = (...s) => {
    a._d && nw(-1);
    const h = wg(e);
    let o;
    try {
      o = t(...s);
    } finally {
      wg(h), a._d && nw(1);
    }
    return process.env.NODE_ENV !== "production" && hS(e), o;
  };
  return a._n = !0, a._c = !0, a._d = !0, a;
}
let T0 = !1;
function Eg() {
  T0 = !0;
}
function O_(t) {
  const { type: e, vnode: n, proxy: a, withProxy: s, props: h, propsOptions: [o], slots: m, attrs: g, emit: b, render: T, renderCache: M, data: I, setupState: P, ctx: z, inheritAttrs: V } = t;
  let W, X;
  const K = wg(t);
  process.env.NODE_ENV !== "production" && (T0 = !1);
  try {
    if (n.shapeFlag & 4) {
      const xe = s || a;
      W = rs(T.call(xe, xe, M, h, P, I, z)), X = g;
    } else {
      const xe = e;
      process.env.NODE_ENV !== "production" && g === h && Eg(), W = rs(xe.length > 1 ? xe(h, process.env.NODE_ENV !== "production" ? {
        get attrs() {
          return Eg(), g;
        },
        slots: m,
        emit: b
      } : { attrs: g, slots: m, emit: b }) : xe(h, null)), X = e.props ? g : oP(g);
    }
  } catch (xe) {
    fd.length = 0, pv(xe, t, 1), W = Ft(Xi);
  }
  let se = W, pe;
  if (process.env.NODE_ENV !== "production" && W.patchFlag > 0 && W.patchFlag & 2048 && ([se, pe] = iP(W)), X && V !== !1) {
    const xe = Object.keys(X), { shapeFlag: Fe } = se;
    if (xe.length) {
      if (Fe & 7)
        o && xe.some(mg) && (X = aP(X, o)), se = Ks(se, X);
      else if (process.env.NODE_ENV !== "production" && !T0 && se.type !== Xi) {
        const ze = Object.keys(g), Pe = [], Se = [];
        for (let Ie = 0, Je = ze.length; Ie < Je; Ie++) {
          const qe = ze[Ie];
          Fd(qe) ? mg(qe) || Pe.push(qe[2].toLowerCase() + qe.slice(3)) : Se.push(qe);
        }
        Se.length && lt(`Extraneous non-props attributes (${Se.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`), Pe.length && lt(`Extraneous non-emits event listeners (${Pe.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
      }
    }
  }
  return n.dirs && (process.env.NODE_ENV !== "production" && !$b(se) && lt("Runtime directive used on component with non-element root node. The directives will not function as intended."), se = Ks(se), se.dirs = se.dirs ? se.dirs.concat(n.dirs) : n.dirs), n.transition && (process.env.NODE_ENV !== "production" && !$b(se) && lt("Component inside <Transition> renders non-element root node that cannot be animated."), se.transition = n.transition), process.env.NODE_ENV !== "production" && pe ? pe(se) : W = se, wg(K), W;
}
const iP = (t) => {
  const e = t.children, n = t.dynamicChildren, a = mS(e);
  if (!a)
    return [t, void 0];
  const s = e.indexOf(a), h = n ? n.indexOf(a) : -1, o = (m) => {
    e[s] = m, n && (h > -1 ? n[h] = m : m.patchFlag > 0 && (t.dynamicChildren = [...n, m]));
  };
  return [rs(a), o];
};
function mS(t) {
  let e;
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    if (Pf(a)) {
      if (a.type !== Xi || a.children === "v-if") {
        if (e)
          return;
        e = a;
      }
    } else
      return;
  }
  return e;
}
const oP = (t) => {
  let e;
  for (const n in t)
    (n === "class" || n === "style" || Fd(n)) && ((e || (e = {}))[n] = t[n]);
  return e;
}, aP = (t, e) => {
  const n = {};
  for (const a in t)
    (!mg(a) || !(a.slice(9) in e)) && (n[a] = t[a]);
  return n;
}, $b = (t) => t.shapeFlag & 7 || t.type === Xi;
function sP(t, e, n) {
  const { props: a, children: s, component: h } = t, { props: o, children: m, patchFlag: g } = e, b = h.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (s || m) && Ou || e.dirs || e.transition)
    return !0;
  if (n && g >= 0) {
    if (g & 1024)
      return !0;
    if (g & 16)
      return a ? Wb(a, o, b) : !!o;
    if (g & 8) {
      const T = e.dynamicProps;
      for (let M = 0; M < T.length; M++) {
        const I = T[M];
        if (o[I] !== a[I] && !mv(b, I))
          return !0;
      }
    }
  } else
    return (s || m) && (!m || !m.$stable) ? !0 : a === o ? !1 : a ? o ? Wb(a, o, b) : !0 : !!o;
  return !1;
}
function Wb(t, e, n) {
  const a = Object.keys(e);
  if (a.length !== Object.keys(t).length)
    return !0;
  for (let s = 0; s < a.length; s++) {
    const h = a[s];
    if (e[h] !== t[h] && !mv(n, h))
      return !0;
  }
  return !1;
}
function lP({ vnode: t, parent: e }, n) {
  for (; e && e.subTree === t; )
    (t = e.vnode).el = n, e = e.parent;
}
const uP = (t) => t.__isSuspense;
function cP(t, e) {
  e && e.pendingBranch ? er(t) ? e.effects.push(...t) : e.effects.push(t) : aS(t);
}
function yS(t, e) {
  if (!pi)
    process.env.NODE_ENV !== "production" && lt("provide() can only be used inside setup().");
  else {
    let n = pi.provides;
    const a = pi.parent && pi.parent.provides;
    a === n && (n = pi.provides = Object.create(a)), n[t] = e;
  }
}
function wf(t, e, n = !1) {
  const a = pi || zi;
  if (a) {
    const s = a.parent == null ? a.vnode.appContext && a.vnode.appContext.provides : a.parent.provides;
    if (s && t in s)
      return s[t];
    if (arguments.length > 1)
      return n && yr(e) ? e.call(a.proxy) : e;
    process.env.NODE_ENV !== "production" && lt(`injection "${String(t)}" not found.`);
  } else
    process.env.NODE_ENV !== "production" && lt("inject() can only be used inside setup() or functional components.");
}
function Na(t, e) {
  return P1(t, null, e);
}
const xy = {};
function Bn(t, e, n) {
  return process.env.NODE_ENV !== "production" && !yr(e) && lt("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), P1(t, e, n);
}
function P1(t, e, { immediate: n, deep: a, flush: s, onTrack: h, onTrigger: o } = wn) {
  process.env.NODE_ENV !== "production" && !e && (n !== void 0 && lt('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), a !== void 0 && lt('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));
  const m = (pe) => {
    lt("Invalid watch source: ", pe, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.");
  }, g = FE() === (pi == null ? void 0 : pi.scope) ? pi : null;
  let b, T = !1, M = !1;
  if (hn(t) ? (b = () => t.value, T = _g(t)) : ss(t) ? (b = () => t, a = !0) : er(t) ? (M = !0, T = t.some((pe) => ss(pe) || _g(pe)), b = () => t.map((pe) => {
    if (hn(pe))
      return pe.value;
    if (ss(pe))
      return Vc(pe);
    if (yr(pe))
      return Rl(pe, g, 2);
    process.env.NODE_ENV !== "production" && m(pe);
  })) : yr(t) ? e ? b = () => Rl(t, g, 2) : b = () => {
    if (!(g && g.isUnmounted))
      return I && I(), La(t, g, 3, [P]);
  } : (b = ao, process.env.NODE_ENV !== "production" && m(t)), e && a) {
    const pe = b;
    b = () => Vc(pe());
  }
  let I, P = (pe) => {
    I = K.onStop = () => {
      Rl(pe, g, 4);
    };
  }, z;
  if (Cd)
    if (P = ao, e ? n && La(e, g, 3, [
      b(),
      M ? [] : void 0,
      P
    ]) : b(), s === "sync") {
      const pe = vk();
      z = pe.__watcherHandles || (pe.__watcherHandles = []);
    } else
      return ao;
  let V = M ? new Array(t.length).fill(xy) : xy;
  const W = () => {
    if (!!K.active)
      if (e) {
        const pe = K.run();
        (a || T || (M ? pe.some((xe, Fe) => Ed(xe, V[Fe])) : Ed(pe, V))) && (I && I(), La(e, g, 3, [
          pe,
          V === xy ? void 0 : M && V[0] === xy ? [] : V,
          P
        ]), V = pe);
      } else
        K.run();
  };
  W.allowRecurse = !!e;
  let X;
  s === "sync" ? X = W : s === "post" ? X = () => ea(W, g && g.suspense) : (W.pre = !0, g && (W.id = g.uid), X = () => dv(W));
  const K = new S1(b, X);
  process.env.NODE_ENV !== "production" && (K.onTrack = h, K.onTrigger = o), e ? n ? W() : V = K.run() : s === "post" ? ea(K.run.bind(K), g && g.suspense) : K.run();
  const se = () => {
    K.stop(), g && g.scope && _1(g.scope.effects, K);
  };
  return z && z.push(se), se;
}
function hP(t, e, n) {
  const a = this.proxy, s = Hn(t) ? t.includes(".") ? gS(a, t) : () => a[t] : t.bind(a, a);
  let h;
  yr(e) ? h = e : (h = e.handler, n = e);
  const o = pi;
  kf(this);
  const m = P1(s, h.bind(a), n);
  return o ? kf(o) : $c(), m;
}
function gS(t, e) {
  const n = e.split(".");
  return () => {
    let a = t;
    for (let s = 0; s < n.length && a; s++)
      a = a[n[s]];
    return a;
  };
}
function Vc(t, e) {
  if (!fn(t) || t.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(t)))
    return t;
  if (e.add(t), hn(t))
    Vc(t.value, e);
  else if (er(t))
    for (let n = 0; n < t.length; n++)
      Vc(t[n], e);
  else if (kE(t) || Uc(t))
    t.forEach((n) => {
      Vc(n, e);
    });
  else if (DE(t))
    for (const n in t)
      Vc(t[n], e);
  return t;
}
function fP() {
  const t = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return va(() => {
    t.isMounted = !0;
  }), wS(() => {
    t.isUnmounting = !0;
  }), t;
}
const Ma = [Function, Array], pP = {
  name: "BaseTransition",
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Ma,
    onEnter: Ma,
    onAfterEnter: Ma,
    onEnterCancelled: Ma,
    onBeforeLeave: Ma,
    onLeave: Ma,
    onAfterLeave: Ma,
    onLeaveCancelled: Ma,
    onBeforeAppear: Ma,
    onAppear: Ma,
    onAfterAppear: Ma,
    onAppearCancelled: Ma
  },
  setup(t, { slots: e }) {
    const n = vv(), a = fP();
    let s;
    return () => {
      const h = e.default && xS(e.default(), !0);
      if (!h || !h.length)
        return;
      let o = h[0];
      if (h.length > 1) {
        let V = !1;
        for (const W of h)
          if (W.type !== Xi) {
            if (process.env.NODE_ENV !== "production" && V) {
              lt("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
              break;
            }
            if (o = W, V = !0, process.env.NODE_ENV === "production")
              break;
          }
      }
      const m = hr(t), { mode: g } = m;
      if (process.env.NODE_ENV !== "production" && g && g !== "in-out" && g !== "out-in" && g !== "default" && lt(`invalid <transition> mode: ${g}`), a.isLeaving)
        return C_(o);
      const b = Hb(o);
      if (!b)
        return C_(o);
      const T = M0(b, m, a, n);
      I0(b, T);
      const M = n.subTree, I = M && Hb(M);
      let P = !1;
      const { getTransitionKey: z } = b.type;
      if (z) {
        const V = z();
        s === void 0 ? s = V : V !== s && (s = V, P = !0);
      }
      if (I && I.type !== Xi && (!zc(b, I) || P)) {
        const V = M0(I, m, a, n);
        if (I0(I, V), g === "out-in")
          return a.isLeaving = !0, V.afterLeave = () => {
            a.isLeaving = !1, n.update.active !== !1 && n.update();
          }, C_(o);
        g === "in-out" && b.type !== Xi && (V.delayLeave = (W, X, K) => {
          const se = _S(a, I);
          se[String(I.key)] = I, W._leaveCb = () => {
            X(), W._leaveCb = void 0, delete T.delayedLeave;
          }, T.delayedLeave = K;
        });
      }
      return o;
    };
  }
}, vS = pP;
function _S(t, e) {
  const { leavingVNodes: n } = t;
  let a = n.get(e.type);
  return a || (a = /* @__PURE__ */ Object.create(null), n.set(e.type, a)), a;
}
function M0(t, e, n, a) {
  const { appear: s, mode: h, persisted: o = !1, onBeforeEnter: m, onEnter: g, onAfterEnter: b, onEnterCancelled: T, onBeforeLeave: M, onLeave: I, onAfterLeave: P, onLeaveCancelled: z, onBeforeAppear: V, onAppear: W, onAfterAppear: X, onAppearCancelled: K } = e, se = String(t.key), pe = _S(n, t), xe = (Pe, Se) => {
    Pe && La(Pe, a, 9, Se);
  }, Fe = (Pe, Se) => {
    const Ie = Se[1];
    xe(Pe, Se), er(Pe) ? Pe.every((Je) => Je.length <= 1) && Ie() : Pe.length <= 1 && Ie();
  }, ze = {
    mode: h,
    persisted: o,
    beforeEnter(Pe) {
      let Se = m;
      if (!n.isMounted)
        if (s)
          Se = V || m;
        else
          return;
      Pe._leaveCb && Pe._leaveCb(!0);
      const Ie = pe[se];
      Ie && zc(t, Ie) && Ie.el._leaveCb && Ie.el._leaveCb(), xe(Se, [Pe]);
    },
    enter(Pe) {
      let Se = g, Ie = b, Je = T;
      if (!n.isMounted)
        if (s)
          Se = W || g, Ie = X || b, Je = K || T;
        else
          return;
      let qe = !1;
      const at = Pe._enterCb = (be) => {
        qe || (qe = !0, be ? xe(Je, [Pe]) : xe(Ie, [Pe]), ze.delayedLeave && ze.delayedLeave(), Pe._enterCb = void 0);
      };
      Se ? Fe(Se, [Pe, at]) : at();
    },
    leave(Pe, Se) {
      const Ie = String(t.key);
      if (Pe._enterCb && Pe._enterCb(!0), n.isUnmounting)
        return Se();
      xe(M, [Pe]);
      let Je = !1;
      const qe = Pe._leaveCb = (at) => {
        Je || (Je = !0, Se(), at ? xe(z, [Pe]) : xe(P, [Pe]), Pe._leaveCb = void 0, pe[Ie] === t && delete pe[Ie]);
      };
      pe[Ie] = t, I ? Fe(I, [Pe, qe]) : qe();
    },
    clone(Pe) {
      return M0(Pe, e, n, a);
    }
  };
  return ze;
}
function C_(t) {
  if (Ud(t))
    return t = Ks(t), t.children = null, t;
}
function Hb(t) {
  return Ud(t) ? t.children ? t.children[0] : void 0 : t;
}
function I0(t, e) {
  t.shapeFlag & 6 && t.component ? I0(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
}
function xS(t, e = !1, n) {
  let a = [], s = 0;
  for (let h = 0; h < t.length; h++) {
    let o = t[h];
    const m = n == null ? o.key : String(n) + String(o.key != null ? o.key : h);
    o.type === cn ? (o.patchFlag & 128 && s++, a = a.concat(xS(o.children, e, m))) : (e || o.type !== Xi) && a.push(m != null ? Ks(o, { key: m }) : o);
  }
  if (s > 1)
    for (let h = 0; h < a.length; h++)
      a[h].patchFlag = -2;
  return a;
}
function or(t) {
  return yr(t) ? { setup: t, name: t.name } : t;
}
const cd = (t) => !!t.type.__asyncLoader, Ud = (t) => t.type.__isKeepAlive;
function dP(t, e) {
  bS(t, "a", e);
}
function mP(t, e) {
  bS(t, "da", e);
}
function bS(t, e, n = pi) {
  const a = t.__wdc || (t.__wdc = () => {
    let s = n;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return t();
  });
  if (yv(e, a, n), n) {
    let s = n.parent;
    for (; s && s.parent; )
      Ud(s.parent.vnode) && yP(a, e, n, s), s = s.parent;
  }
}
function yP(t, e, n, a) {
  const s = yv(e, t, a, !0);
  Uu(() => {
    _1(a[e], s);
  }, n);
}
function yv(t, e, n = pi, a = !1) {
  if (n) {
    const s = n[t] || (n[t] = []), h = e.__weh || (e.__weh = (...o) => {
      if (n.isUnmounted)
        return;
      eh(), kf(n);
      const m = La(e, n, t, o);
      return $c(), th(), m;
    });
    return a ? s.unshift(h) : s.push(h), h;
  } else if (process.env.NODE_ENV !== "production") {
    const s = kc(I1[t].replace(/ hook$/, ""));
    lt(`${s} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const ql = (t) => (e, n = pi) => (!Cd || t === "sp") && yv(t, (...a) => e(...a), n), gP = ql("bm"), va = ql("m"), vP = ql("bu"), _P = ql("u"), wS = ql("bum"), Uu = ql("um"), xP = ql("sp"), bP = ql("rtg"), wP = ql("rtc");
function EP(t, e = pi) {
  yv("ec", t, e);
}
function ES(t) {
  XC(t) && lt("Do not use built-in directive ids as custom directive id: " + t);
}
function O0(t, e) {
  const n = zi;
  if (n === null)
    return process.env.NODE_ENV !== "production" && lt("withDirectives can only be used inside render functions."), t;
  const a = _v(n) || n.proxy, s = t.dirs || (t.dirs = []);
  for (let h = 0; h < e.length; h++) {
    let [o, m, g, b = wn] = e[h];
    o && (yr(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Vc(m), s.push({
      dir: o,
      instance: a,
      value: m,
      oldValue: void 0,
      arg: g,
      modifiers: b
    }));
  }
  return t;
}
function wc(t, e, n, a) {
  const s = t.dirs, h = e && e.dirs;
  for (let o = 0; o < s.length; o++) {
    const m = s[o];
    h && (m.oldValue = h[o].value);
    let g = m.dir[a];
    g && (eh(), La(g, n, 8, [
      t.el,
      m,
      t,
      e
    ]), th());
  }
}
const C0 = "components", SP = "directives";
function TP(t, e) {
  return TS(C0, t, !0, e) || t;
}
const MP = Symbol();
function SS(t) {
  return TS(SP, t);
}
function TS(t, e, n = !0, a = !1) {
  const s = zi || pi;
  if (s) {
    const h = s.type;
    if (t === C0) {
      const m = R1(h, !1);
      if (m && (m === e || m === ya(e) || m === Xc(ya(e))))
        return h;
    }
    const o = Zb(s[t] || h[t], e) || Zb(s.appContext[t], e);
    if (!o && a)
      return h;
    if (process.env.NODE_ENV !== "production" && n && !o) {
      const m = t === C0 ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      lt(`Failed to resolve ${t.slice(0, -1)}: ${e}${m}`);
    }
    return o;
  } else
    process.env.NODE_ENV !== "production" && lt(`resolve${Xc(t.slice(0, -1))} can only be used in render() or setup().`);
}
function Zb(t, e) {
  return t && (t[e] || t[ya(e)] || t[Xc(ya(e))]);
}
function Ra(t, e, n, a) {
  let s;
  const h = n && n[a];
  if (er(t) || Hn(t)) {
    s = new Array(t.length);
    for (let o = 0, m = t.length; o < m; o++)
      s[o] = e(t[o], o, void 0, h && h[o]);
  } else if (typeof t == "number") {
    process.env.NODE_ENV !== "production" && !Number.isInteger(t) && lt(`The v-for range expect an integer value but got ${t}.`), s = new Array(t);
    for (let o = 0; o < t; o++)
      s[o] = e(o + 1, o, void 0, h && h[o]);
  } else if (fn(t))
    if (t[Symbol.iterator])
      s = Array.from(t, (o, m) => e(o, m, void 0, h && h[m]));
    else {
      const o = Object.keys(t);
      s = new Array(o.length);
      for (let m = 0, g = o.length; m < g; m++) {
        const b = o[m];
        s[m] = e(t[b], b, m, h && h[m]);
      }
    }
  else
    s = [];
  return n && (n[a] = s), s;
}
function IP(t, e, n = {}, a, s) {
  if (zi.isCE || zi.parent && cd(zi.parent) && zi.parent.isCE)
    return e !== "default" && (n.name = e), Ft("slot", n, a && a());
  let h = t[e];
  process.env.NODE_ENV !== "production" && h && h.length > 1 && (lt("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."), h = () => []), h && h._c && (h._d = !1), Ve();
  const o = h && MS(h(n)), m = on(cn, {
    key: n.key || o && o.key || `_${e}`
  }, o || (a ? a() : []), o && t._ === 1 ? 64 : -2);
  return !s && m.scopeId && (m.slotScopeIds = [m.scopeId + "-s"]), h && h._c && (h._d = !0), m;
}
function MS(t) {
  return t.some((e) => Pf(e) ? !(e.type === Xi || e.type === cn && !MS(e.children)) : !0) ? t : null;
}
const A0 = (t) => t ? jS(t) ? _v(t) || t.proxy : A0(t.parent) : null, qc = /* @__PURE__ */ Wn(/* @__PURE__ */ Object.create(null), {
  $: (t) => t,
  $el: (t) => t.vnode.el,
  $data: (t) => t.data,
  $props: (t) => process.env.NODE_ENV !== "production" ? pf(t.props) : t.props,
  $attrs: (t) => process.env.NODE_ENV !== "production" ? pf(t.attrs) : t.attrs,
  $slots: (t) => process.env.NODE_ENV !== "production" ? pf(t.slots) : t.slots,
  $refs: (t) => process.env.NODE_ENV !== "production" ? pf(t.refs) : t.refs,
  $parent: (t) => A0(t.parent),
  $root: (t) => A0(t.root),
  $emit: (t) => t.emit,
  $options: (t) => L1(t),
  $forceUpdate: (t) => t.f || (t.f = () => dv(t.update)),
  $nextTick: (t) => t.n || (t.n = bg.bind(t.proxy)),
  $watch: (t) => hP.bind(t)
}), k1 = (t) => t === "_" || t === "$", A_ = (t, e) => t !== wn && !t.__isScriptSetup && jr(t, e), IS = {
  get({ _: t }, e) {
    const { ctx: n, setupState: a, data: s, props: h, accessCache: o, type: m, appContext: g } = t;
    if (process.env.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let b;
    if (e[0] !== "$") {
      const P = o[e];
      if (P !== void 0)
        switch (P) {
          case 1:
            return a[e];
          case 2:
            return s[e];
          case 4:
            return n[e];
          case 3:
            return h[e];
        }
      else {
        if (A_(a, e))
          return o[e] = 1, a[e];
        if (s !== wn && jr(s, e))
          return o[e] = 2, s[e];
        if ((b = t.propsOptions[0]) && jr(b, e))
          return o[e] = 3, h[e];
        if (n !== wn && jr(n, e))
          return o[e] = 4, n[e];
        P0 && (o[e] = 0);
      }
    }
    const T = qc[e];
    let M, I;
    if (T)
      return e === "$attrs" && (Bo(t, "get", e), process.env.NODE_ENV !== "production" && Eg()), T(t);
    if ((M = m.__cssModules) && (M = M[e]))
      return M;
    if (n !== wn && jr(n, e))
      return o[e] = 4, n[e];
    if (I = g.config.globalProperties, jr(I, e))
      return I[e];
    process.env.NODE_ENV !== "production" && zi && (!Hn(e) || e.indexOf("__v") !== 0) && (s !== wn && k1(e[0]) && jr(s, e) ? lt(`Property ${JSON.stringify(e)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`) : t === zi && lt(`Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`));
  },
  set({ _: t }, e, n) {
    const { data: a, setupState: s, ctx: h } = t;
    return A_(s, e) ? (s[e] = n, !0) : process.env.NODE_ENV !== "production" && s.__isScriptSetup && jr(s, e) ? (lt(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : a !== wn && jr(a, e) ? (a[e] = n, !0) : jr(t.props, e) ? (process.env.NODE_ENV !== "production" && lt(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (process.env.NODE_ENV !== "production" && lt(`Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`), !1) : (process.env.NODE_ENV !== "production" && e in t.appContext.config.globalProperties ? Object.defineProperty(h, e, {
      enumerable: !0,
      configurable: !0,
      value: n
    }) : h[e] = n, !0);
  },
  has({ _: { data: t, setupState: e, accessCache: n, ctx: a, appContext: s, propsOptions: h } }, o) {
    let m;
    return !!n[o] || t !== wn && jr(t, o) || A_(e, o) || (m = h[0]) && jr(m, o) || jr(a, o) || jr(qc, o) || jr(s.config.globalProperties, o);
  },
  defineProperty(t, e, n) {
    return n.get != null ? t._.accessCache[e] = 0 : jr(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n);
  }
};
process.env.NODE_ENV !== "production" && (IS.ownKeys = (t) => (lt("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."), Reflect.ownKeys(t)));
function OP(t) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => t
  }), Object.keys(qc).forEach((n) => {
    Object.defineProperty(e, n, {
      configurable: !0,
      enumerable: !1,
      get: () => qc[n](t),
      set: ao
    });
  }), e;
}
function CP(t) {
  const { ctx: e, propsOptions: [n] } = t;
  n && Object.keys(n).forEach((a) => {
    Object.defineProperty(e, a, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[a],
      set: ao
    });
  });
}
function AP(t) {
  const { ctx: e, setupState: n } = t;
  Object.keys(hr(n)).forEach((a) => {
    if (!n.__isScriptSetup) {
      if (k1(a[0])) {
        lt(`setup() return property ${JSON.stringify(a)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(e, a, {
        enumerable: !0,
        configurable: !0,
        get: () => n[a],
        set: ao
      });
    }
  });
}
function PP() {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, n) => {
    t[n] ? lt(`${e} property "${n}" is already defined in ${t[n]}.`) : t[n] = e;
  };
}
let P0 = !0;
function kP(t) {
  const e = L1(t), n = t.proxy, a = t.ctx;
  P0 = !1, e.beforeCreate && Xb(e.beforeCreate, t, "bc");
  const {
    data: s,
    computed: h,
    methods: o,
    watch: m,
    provide: g,
    inject: b,
    created: T,
    beforeMount: M,
    mounted: I,
    beforeUpdate: P,
    updated: z,
    activated: V,
    deactivated: W,
    beforeDestroy: X,
    beforeUnmount: K,
    destroyed: se,
    unmounted: pe,
    render: xe,
    renderTracked: Fe,
    renderTriggered: ze,
    errorCaptured: Pe,
    serverPrefetch: Se,
    expose: Ie,
    inheritAttrs: Je,
    components: qe,
    directives: at,
    filters: be
  } = e, Ke = process.env.NODE_ENV !== "production" ? PP() : null;
  if (process.env.NODE_ENV !== "production") {
    const [vt] = t.propsOptions;
    if (vt)
      for (const Pt in vt)
        Ke("Props", Pt);
  }
  if (b && LP(b, a, Ke, t.appContext.config.unwrapInjectedRef), o)
    for (const vt in o) {
      const Pt = o[vt];
      yr(Pt) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(a, vt, {
        value: Pt.bind(n),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : a[vt] = Pt.bind(n), process.env.NODE_ENV !== "production" && Ke("Methods", vt)) : process.env.NODE_ENV !== "production" && lt(`Method "${vt}" has type "${typeof Pt}" in the component definition. Did you reference the function correctly?`);
    }
  if (s) {
    process.env.NODE_ENV !== "production" && !yr(s) && lt("The data option must be a function. Plain object usage is no longer supported.");
    const vt = s.call(n, n);
    if (process.env.NODE_ENV !== "production" && b1(vt) && lt("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."), !fn(vt))
      process.env.NODE_ENV !== "production" && lt("data() should return an object.");
    else if (t.data = hv(vt), process.env.NODE_ENV !== "production")
      for (const Pt in vt)
        Ke("Data", Pt), k1(Pt[0]) || Object.defineProperty(a, Pt, {
          configurable: !0,
          enumerable: !0,
          get: () => vt[Pt],
          set: ao
        });
  }
  if (P0 = !0, h)
    for (const vt in h) {
      const Pt = h[vt], tr = yr(Pt) ? Pt.bind(n, n) : yr(Pt.get) ? Pt.get.bind(n, n) : ao;
      process.env.NODE_ENV !== "production" && tr === ao && lt(`Computed property "${vt}" has no getter.`);
      const Pn = !yr(Pt) && yr(Pt.set) ? Pt.set.bind(n) : process.env.NODE_ENV !== "production" ? () => {
        lt(`Write operation failed: computed property "${vt}" is readonly.`);
      } : ao, Rr = lr({
        get: tr,
        set: Pn
      });
      Object.defineProperty(a, vt, {
        enumerable: !0,
        configurable: !0,
        get: () => Rr.value,
        set: (pr) => Rr.value = pr
      }), process.env.NODE_ENV !== "production" && Ke("Computed", vt);
    }
  if (m)
    for (const vt in m)
      OS(m[vt], a, n, vt);
  if (g) {
    const vt = yr(g) ? g.call(n) : g;
    Reflect.ownKeys(vt).forEach((Pt) => {
      yS(Pt, vt[Pt]);
    });
  }
  T && Xb(T, t, "c");
  function ht(vt, Pt) {
    er(Pt) ? Pt.forEach((tr) => vt(tr.bind(n))) : Pt && vt(Pt.bind(n));
  }
  if (ht(gP, M), ht(va, I), ht(vP, P), ht(_P, z), ht(dP, V), ht(mP, W), ht(EP, Pe), ht(wP, Fe), ht(bP, ze), ht(wS, K), ht(Uu, pe), ht(xP, Se), er(Ie))
    if (Ie.length) {
      const vt = t.exposed || (t.exposed = {});
      Ie.forEach((Pt) => {
        Object.defineProperty(vt, Pt, {
          get: () => n[Pt],
          set: (tr) => n[Pt] = tr
        });
      });
    } else
      t.exposed || (t.exposed = {});
  xe && t.render === ao && (t.render = xe), Je != null && (t.inheritAttrs = Je), qe && (t.components = qe), at && (t.directives = at);
}
function LP(t, e, n = ao, a = !1) {
  er(t) && (t = k0(t));
  for (const s in t) {
    const h = t[s];
    let o;
    fn(h) ? "default" in h ? o = wf(h.from || s, h.default, !0) : o = wf(h.from || s) : o = wf(h), hn(o) ? a ? Object.defineProperty(e, s, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (m) => o.value = m
    }) : (process.env.NODE_ENV !== "production" && lt(`injected property "${s}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`), e[s] = o) : e[s] = o, process.env.NODE_ENV !== "production" && n("Inject", s);
  }
}
function Xb(t, e, n) {
  La(er(t) ? t.map((a) => a.bind(e.proxy)) : t.bind(e.proxy), e, n);
}
function OS(t, e, n, a) {
  const s = a.includes(".") ? gS(n, a) : () => n[a];
  if (Hn(t)) {
    const h = e[t];
    yr(h) ? Bn(s, h) : process.env.NODE_ENV !== "production" && lt(`Invalid watch handler specified by key "${t}"`, h);
  } else if (yr(t))
    Bn(s, t.bind(n));
  else if (fn(t))
    if (er(t))
      t.forEach((h) => OS(h, e, n, a));
    else {
      const h = yr(t.handler) ? t.handler.bind(n) : e[t.handler];
      yr(h) ? Bn(s, h, t) : process.env.NODE_ENV !== "production" && lt(`Invalid watch handler specified by key "${t.handler}"`, h);
    }
  else
    process.env.NODE_ENV !== "production" && lt(`Invalid watch option: "${a}"`, t);
}
function L1(t) {
  const e = t.type, { mixins: n, extends: a } = e, { mixins: s, optionsCache: h, config: { optionMergeStrategies: o } } = t.appContext, m = h.get(e);
  let g;
  return m ? g = m : !s.length && !n && !a ? g = e : (g = {}, s.length && s.forEach((b) => Sg(g, b, o, !0)), Sg(g, e, o)), fn(e) && h.set(e, g), g;
}
function Sg(t, e, n, a = !1) {
  const { mixins: s, extends: h } = e;
  h && Sg(t, h, n, !0), s && s.forEach((o) => Sg(t, o, n, !0));
  for (const o in e)
    if (a && o === "expose")
      process.env.NODE_ENV !== "production" && lt('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');
    else {
      const m = DP[o] || n && n[o];
      t[o] = m ? m(t[o], e[o]) : e[o];
    }
  return t;
}
const DP = {
  data: Kb,
  props: Lc,
  emits: Lc,
  methods: Lc,
  computed: Lc,
  beforeCreate: ko,
  created: ko,
  beforeMount: ko,
  mounted: ko,
  beforeUpdate: ko,
  updated: ko,
  beforeDestroy: ko,
  beforeUnmount: ko,
  destroyed: ko,
  unmounted: ko,
  activated: ko,
  deactivated: ko,
  errorCaptured: ko,
  serverPrefetch: ko,
  components: Lc,
  directives: Lc,
  watch: RP,
  provide: Kb,
  inject: NP
};
function Kb(t, e) {
  return e ? t ? function() {
    return Wn(yr(t) ? t.call(this, this) : t, yr(e) ? e.call(this, this) : e);
  } : e : t;
}
function NP(t, e) {
  return Lc(k0(t), k0(e));
}
function k0(t) {
  if (er(t)) {
    const e = {};
    for (let n = 0; n < t.length; n++)
      e[t[n]] = t[n];
    return e;
  }
  return t;
}
function ko(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function Lc(t, e) {
  return t ? Wn(Wn(/* @__PURE__ */ Object.create(null), t), e) : e;
}
function RP(t, e) {
  if (!t)
    return e;
  if (!e)
    return t;
  const n = Wn(/* @__PURE__ */ Object.create(null), t);
  for (const a in e)
    n[a] = ko(t[a], e[a]);
  return n;
}
function zP(t, e, n, a = !1) {
  const s = {}, h = {};
  yg(h, gv, 1), t.propsDefaults = /* @__PURE__ */ Object.create(null), CS(t, e, s, h);
  for (const o in t.propsOptions[0])
    o in s || (s[o] = void 0);
  process.env.NODE_ENV !== "production" && PS(e || {}, s, t), n ? t.props = a ? s : CA(s) : t.type.props ? t.props = s : t.props = h, t.attrs = h;
}
function FP(t) {
  for (; t; ) {
    if (t.type.__hmrId)
      return !0;
    t = t.parent;
  }
}
function BP(t, e, n, a) {
  const { props: s, attrs: h, vnode: { patchFlag: o } } = t, m = hr(s), [g] = t.propsOptions;
  let b = !1;
  if (!(process.env.NODE_ENV !== "production" && FP(t)) && (a || o > 0) && !(o & 16)) {
    if (o & 8) {
      const T = t.vnode.dynamicProps;
      for (let M = 0; M < T.length; M++) {
        let I = T[M];
        if (mv(t.emitsOptions, I))
          continue;
        const P = e[I];
        if (g)
          if (jr(h, I))
            P !== h[I] && (h[I] = P, b = !0);
          else {
            const z = ya(I);
            s[z] = L0(g, m, z, P, t, !1);
          }
        else
          P !== h[I] && (h[I] = P, b = !0);
      }
    }
  } else {
    CS(t, e, s, h) && (b = !0);
    let T;
    for (const M in m)
      (!e || !jr(e, M) && ((T = ta(M)) === M || !jr(e, T))) && (g ? n && (n[M] !== void 0 || n[T] !== void 0) && (s[M] = L0(g, m, M, void 0, t, !0)) : delete s[M]);
    if (h !== m)
      for (const M in h)
        (!e || !jr(e, M) && !0) && (delete h[M], b = !0);
  }
  b && Vl(t, "set", "$attrs"), process.env.NODE_ENV !== "production" && PS(e || {}, s, t);
}
function CS(t, e, n, a) {
  const [s, h] = t.propsOptions;
  let o = !1, m;
  if (e)
    for (let g in e) {
      if (Zy(g))
        continue;
      const b = e[g];
      let T;
      s && jr(s, T = ya(g)) ? !h || !h.includes(T) ? n[T] = b : (m || (m = {}))[T] = b : mv(t.emitsOptions, g) || (!(g in a) || b !== a[g]) && (a[g] = b, o = !0);
    }
  if (h) {
    const g = hr(n), b = m || wn;
    for (let T = 0; T < h.length; T++) {
      const M = h[T];
      n[M] = L0(s, g, M, b[M], t, !jr(b, M));
    }
  }
  return o;
}
function L0(t, e, n, a, s, h) {
  const o = t[n];
  if (o != null) {
    const m = jr(o, "default");
    if (m && a === void 0) {
      const g = o.default;
      if (o.type !== Function && yr(g)) {
        const { propsDefaults: b } = s;
        n in b ? a = b[n] : (kf(s), a = b[n] = g.call(null, e), $c());
      } else
        a = g;
    }
    o[0] && (h && !m ? a = !1 : o[1] && (a === "" || a === ta(n)) && (a = !0));
  }
  return a;
}
function AS(t, e, n = !1) {
  const a = e.propsCache, s = a.get(t);
  if (s)
    return s;
  const h = t.props, o = {}, m = [];
  let g = !1;
  if (!yr(t)) {
    const T = (M) => {
      g = !0;
      const [I, P] = AS(M, e, !0);
      Wn(o, I), P && m.push(...P);
    };
    !n && e.mixins.length && e.mixins.forEach(T), t.extends && T(t.extends), t.mixins && t.mixins.forEach(T);
  }
  if (!h && !g)
    return fn(t) && a.set(t, xf), xf;
  if (er(h))
    for (let T = 0; T < h.length; T++) {
      process.env.NODE_ENV !== "production" && !Hn(h[T]) && lt("props must be strings when using array syntax.", h[T]);
      const M = ya(h[T]);
      Yb(M) && (o[M] = wn);
    }
  else if (h) {
    process.env.NODE_ENV !== "production" && !fn(h) && lt("invalid props options", h);
    for (const T in h) {
      const M = ya(T);
      if (Yb(M)) {
        const I = h[T], P = o[M] = er(I) || yr(I) ? { type: I } : Object.assign({}, I);
        if (P) {
          const z = Qb(Boolean, P.type), V = Qb(String, P.type);
          P[0] = z > -1, P[1] = V < 0 || z < V, (z > -1 || jr(P, "default")) && m.push(M);
        }
      }
    }
  }
  const b = [o, m];
  return fn(t) && a.set(t, b), b;
}
function Yb(t) {
  return t[0] !== "$" ? !0 : (process.env.NODE_ENV !== "production" && lt(`Invalid prop name: "${t}" is a reserved property.`), !1);
}
function D0(t) {
  const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : t === null ? "null" : "";
}
function Jb(t, e) {
  return D0(t) === D0(e);
}
function Qb(t, e) {
  return er(e) ? e.findIndex((n) => Jb(n, t)) : yr(e) && Jb(e, t) ? 0 : -1;
}
function PS(t, e, n) {
  const a = hr(e), s = n.propsOptions[0];
  for (const h in s) {
    let o = s[h];
    o != null && VP(h, a[h], o, !jr(t, h) && !jr(t, ta(h)));
  }
}
function VP(t, e, n, a) {
  const { type: s, required: h, validator: o } = n;
  if (h && a) {
    lt('Missing required prop: "' + t + '"');
    return;
  }
  if (!(e == null && !n.required)) {
    if (s != null && s !== !0) {
      let m = !1;
      const g = er(s) ? s : [s], b = [];
      for (let T = 0; T < g.length && !m; T++) {
        const { valid: M, expectedType: I } = jP(e, g[T]);
        b.push(I || ""), m = M;
      }
      if (!m) {
        lt(GP(t, e, b));
        return;
      }
    }
    o && !o(e) && lt('Invalid prop: custom validator check failed for prop "' + t + '".');
  }
}
const UP = /* @__PURE__ */ Bu("String,Number,Boolean,Function,Symbol,BigInt");
function jP(t, e) {
  let n;
  const a = D0(e);
  if (UP(a)) {
    const s = typeof t;
    n = s === a.toLowerCase(), !n && s === "object" && (n = t instanceof e);
  } else
    a === "Object" ? n = fn(t) : a === "Array" ? n = er(t) : a === "null" ? n = t === null : n = t instanceof e;
  return {
    valid: n,
    expectedType: a
  };
}
function GP(t, e, n) {
  let a = `Invalid prop: type check failed for prop "${t}". Expected ${n.map(Xc).join(" | ")}`;
  const s = n[0], h = w1(e), o = ew(e, s), m = ew(e, h);
  return n.length === 1 && tw(s) && !qP(s, h) && (a += ` with value ${o}`), a += `, got ${h} `, tw(h) && (a += `with value ${m}.`), a;
}
function ew(t, e) {
  return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`;
}
function tw(t) {
  return ["string", "number", "boolean"].some((n) => t.toLowerCase() === n);
}
function qP(...t) {
  return t.some((e) => e.toLowerCase() === "boolean");
}
const kS = (t) => t[0] === "_" || t === "$stable", D1 = (t) => er(t) ? t.map(rs) : [rs(t)], $P = (t, e, n) => {
  if (e._n)
    return e;
  const a = Vd((...s) => (process.env.NODE_ENV !== "production" && pi && lt(`Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`), D1(e(...s))), n);
  return a._c = !1, a;
}, LS = (t, e, n) => {
  const a = t._ctx;
  for (const s in t) {
    if (kS(s))
      continue;
    const h = t[s];
    if (yr(h))
      e[s] = $P(s, h, a);
    else if (h != null) {
      process.env.NODE_ENV !== "production" && lt(`Non-function value encountered for slot "${s}". Prefer function slots for better performance.`);
      const o = D1(h);
      e[s] = () => o;
    }
  }
}, DS = (t, e) => {
  process.env.NODE_ENV !== "production" && !Ud(t.vnode) && lt("Non-function value encountered for default slot. Prefer function slots for better performance.");
  const n = D1(e);
  t.slots.default = () => n;
}, WP = (t, e) => {
  if (t.vnode.shapeFlag & 32) {
    const n = e._;
    n ? (t.slots = hr(e), yg(e, "_", n)) : LS(e, t.slots = {});
  } else
    t.slots = {}, e && DS(t, e);
  yg(t.slots, gv, 1);
}, HP = (t, e, n) => {
  const { vnode: a, slots: s } = t;
  let h = !0, o = wn;
  if (a.shapeFlag & 32) {
    const m = e._;
    m ? process.env.NODE_ENV !== "production" && Ou ? Wn(s, e) : n && m === 1 ? h = !1 : (Wn(s, e), !n && m === 1 && delete s._) : (h = !e.$stable, LS(e, s)), o = e;
  } else
    e && (DS(t, e), o = { default: 1 });
  if (h)
    for (const m in s)
      !kS(m) && !(m in o) && delete s[m];
};
function NS() {
  return {
    app: null,
    config: {
      isNativeTag: PE,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let ZP = 0;
function XP(t, e) {
  return function(a, s = null) {
    yr(a) || (a = Object.assign({}, a)), s != null && !fn(s) && (process.env.NODE_ENV !== "production" && lt("root props passed to app.mount() must be an object."), s = null);
    const h = NS(), o = /* @__PURE__ */ new Set();
    let m = !1;
    const g = h.app = {
      _uid: ZP++,
      _component: a,
      _props: s,
      _container: null,
      _context: h,
      _instance: null,
      version: aw,
      get config() {
        return h.config;
      },
      set config(b) {
        process.env.NODE_ENV !== "production" && lt("app.config cannot be replaced. Modify individual options instead.");
      },
      use(b, ...T) {
        return o.has(b) ? process.env.NODE_ENV !== "production" && lt("Plugin has already been applied to target app.") : b && yr(b.install) ? (o.add(b), b.install(g, ...T)) : yr(b) ? (o.add(b), b(g, ...T)) : process.env.NODE_ENV !== "production" && lt('A plugin must either be a function or an object with an "install" function.'), g;
      },
      mixin(b) {
        return h.mixins.includes(b) ? process.env.NODE_ENV !== "production" && lt("Mixin has already been applied to target app" + (b.name ? `: ${b.name}` : "")) : h.mixins.push(b), g;
      },
      component(b, T) {
        return process.env.NODE_ENV !== "production" && z0(b, h.config), T ? (process.env.NODE_ENV !== "production" && h.components[b] && lt(`Component "${b}" has already been registered in target app.`), h.components[b] = T, g) : h.components[b];
      },
      directive(b, T) {
        return process.env.NODE_ENV !== "production" && ES(b), T ? (process.env.NODE_ENV !== "production" && h.directives[b] && lt(`Directive "${b}" has already been registered in target app.`), h.directives[b] = T, g) : h.directives[b];
      },
      mount(b, T, M) {
        if (m)
          process.env.NODE_ENV !== "production" && lt("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
        else {
          process.env.NODE_ENV !== "production" && b.__vue_app__ && lt("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");
          const I = Ft(a, s);
          return I.appContext = h, process.env.NODE_ENV !== "production" && (h.reload = () => {
            t(Ks(I), b, M);
          }), T && e ? e(I, b) : t(I, b, M), m = !0, g._container = b, b.__vue_app__ = g, process.env.NODE_ENV !== "production" && (g._instance = I.component, XA(g, aw)), _v(I.component) || I.component.proxy;
        }
      },
      unmount() {
        m ? (t(null, g._container), process.env.NODE_ENV !== "production" && (g._instance = null, KA(g)), delete g._container.__vue_app__) : process.env.NODE_ENV !== "production" && lt("Cannot unmount an app that is not mounted.");
      },
      provide(b, T) {
        return process.env.NODE_ENV !== "production" && b in h.provides && lt(`App already provides property with key "${String(b)}". It will be overwritten with the new value.`), h.provides[b] = T, g;
      }
    };
    return g;
  };
}
function N0(t, e, n, a, s = !1) {
  if (er(t)) {
    t.forEach((I, P) => N0(I, e && (er(e) ? e[P] : e), n, a, s));
    return;
  }
  if (cd(a) && !s)
    return;
  const h = a.shapeFlag & 4 ? _v(a.component) || a.component.proxy : a.el, o = s ? null : h, { i: m, r: g } = t;
  if (process.env.NODE_ENV !== "production" && !m) {
    lt("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");
    return;
  }
  const b = e && e.r, T = m.refs === wn ? m.refs = {} : m.refs, M = m.setupState;
  if (b != null && b !== g && (Hn(b) ? (T[b] = null, jr(M, b) && (M[b] = null)) : hn(b) && (b.value = null)), yr(g))
    Rl(g, m, 12, [o, T]);
  else {
    const I = Hn(g), P = hn(g);
    if (I || P) {
      const z = () => {
        if (t.f) {
          const V = I ? jr(M, g) ? M[g] : T[g] : g.value;
          s ? er(V) && _1(V, h) : er(V) ? V.includes(h) || V.push(h) : I ? (T[g] = [h], jr(M, g) && (M[g] = T[g])) : (g.value = [h], t.k && (T[t.k] = g.value));
        } else
          I ? (T[g] = o, jr(M, g) && (M[g] = o)) : P ? (g.value = o, t.k && (T[t.k] = o)) : process.env.NODE_ENV !== "production" && lt("Invalid template ref type:", g, `(${typeof g})`);
      };
      o ? (z.id = -1, ea(z, n)) : z();
    } else
      process.env.NODE_ENV !== "production" && lt("Invalid template ref type:", g, `(${typeof g})`);
  }
}
let Up, wu;
function kl(t, e) {
  t.appContext.config.performance && Tg() && wu.mark(`vue-${e}-${t.uid}`), process.env.NODE_ENV !== "production" && eP(t, e, Tg() ? wu.now() : Date.now());
}
function Ll(t, e) {
  if (t.appContext.config.performance && Tg()) {
    const n = `vue-${e}-${t.uid}`, a = n + ":end";
    wu.mark(a), wu.measure(`<${xv(t, t.type)}> ${e}`, n, a), wu.clearMarks(n), wu.clearMarks(a);
  }
  process.env.NODE_ENV !== "production" && tP(t, e, Tg() ? wu.now() : Date.now());
}
function Tg() {
  return Up !== void 0 || (typeof window < "u" && window.performance ? (Up = !0, wu = window.performance) : Up = !1), Up;
}
function KP() {
  const t = [];
  if (process.env.NODE_ENV !== "production" && t.length) {
    const e = t.length > 1;
    console.warn(`Feature flag${e ? "s" : ""} ${t.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const ea = cP;
function YP(t) {
  return JP(t);
}
function JP(t, e) {
  KP();
  const n = NE();
  n.__VUE__ = !0, process.env.NODE_ENV !== "production" && cS(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
  const { insert: a, remove: s, patchProp: h, createElement: o, createText: m, createComment: g, setText: b, setElementText: T, parentNode: M, nextSibling: I, setScopeId: P = ao, insertStaticContent: z } = t, V = (Y, ye, Ne, $e = null, We = null, rt = null, mt = !1, et = null, ut = process.env.NODE_ENV !== "production" && Ou ? !1 : !!ye.dynamicChildren) => {
    if (Y === ye)
      return;
    Y && !zc(Y, ye) && ($e = Vn(Y), Zn(Y, We, rt, !0), Y = null), ye.patchFlag === -2 && (ut = !1, ye.dynamicChildren = null);
    const { type: Qe, ref: It, shapeFlag: bt } = ye;
    switch (Qe) {
      case jd:
        W(Y, ye, Ne, $e);
        break;
      case Xi:
        X(Y, ye, Ne, $e);
        break;
      case Yy:
        Y == null ? K(ye, Ne, $e, mt) : process.env.NODE_ENV !== "production" && se(Y, ye, Ne, mt);
        break;
      case cn:
        at(Y, ye, Ne, $e, We, rt, mt, et, ut);
        break;
      default:
        bt & 1 ? Fe(Y, ye, Ne, $e, We, rt, mt, et, ut) : bt & 6 ? be(Y, ye, Ne, $e, We, rt, mt, et, ut) : bt & 64 || bt & 128 ? Qe.process(Y, ye, Ne, $e, We, rt, mt, et, ut, En) : process.env.NODE_ENV !== "production" && lt("Invalid VNode type:", Qe, `(${typeof Qe})`);
    }
    It != null && We && N0(It, Y && Y.ref, rt, ye || Y, !ye);
  }, W = (Y, ye, Ne, $e) => {
    if (Y == null)
      a(ye.el = m(ye.children), Ne, $e);
    else {
      const We = ye.el = Y.el;
      ye.children !== Y.children && b(We, ye.children);
    }
  }, X = (Y, ye, Ne, $e) => {
    Y == null ? a(ye.el = g(ye.children || ""), Ne, $e) : ye.el = Y.el;
  }, K = (Y, ye, Ne, $e) => {
    [Y.el, Y.anchor] = z(Y.children, ye, Ne, $e, Y.el, Y.anchor);
  }, se = (Y, ye, Ne, $e) => {
    if (ye.children !== Y.children) {
      const We = I(Y.anchor);
      xe(Y), [ye.el, ye.anchor] = z(ye.children, Ne, We, $e);
    } else
      ye.el = Y.el, ye.anchor = Y.anchor;
  }, pe = ({ el: Y, anchor: ye }, Ne, $e) => {
    let We;
    for (; Y && Y !== ye; )
      We = I(Y), a(Y, Ne, $e), Y = We;
    a(ye, Ne, $e);
  }, xe = ({ el: Y, anchor: ye }) => {
    let Ne;
    for (; Y && Y !== ye; )
      Ne = I(Y), s(Y), Y = Ne;
    s(ye);
  }, Fe = (Y, ye, Ne, $e, We, rt, mt, et, ut) => {
    mt = mt || ye.type === "svg", Y == null ? ze(ye, Ne, $e, We, rt, mt, et, ut) : Ie(Y, ye, We, rt, mt, et, ut);
  }, ze = (Y, ye, Ne, $e, We, rt, mt, et) => {
    let ut, Qe;
    const { type: It, props: bt, shapeFlag: kt, transition: Ut, dirs: dr } = Y;
    if (ut = Y.el = o(Y.type, rt, bt && bt.is, bt), kt & 8 ? T(ut, Y.children) : kt & 16 && Se(Y.children, ut, null, $e, We, rt && It !== "foreignObject", mt, et), dr && wc(Y, null, $e, "created"), Pe(ut, Y, Y.scopeId, mt, $e), bt) {
      for (const Lr in bt)
        Lr !== "value" && !Zy(Lr) && h(ut, Lr, null, bt[Lr], rt, Y.children, $e, We, kr);
      "value" in bt && h(ut, "value", null, bt.value), (Qe = bt.onVnodeBeforeMount) && Ns(Qe, $e, Y);
    }
    process.env.NODE_ENV !== "production" && (Object.defineProperty(ut, "__vnode", {
      value: Y,
      enumerable: !1
    }), Object.defineProperty(ut, "__vueParentComponent", {
      value: $e,
      enumerable: !1
    })), dr && wc(Y, null, $e, "beforeMount");
    const Vr = (!We || We && !We.pendingBranch) && Ut && !Ut.persisted;
    Vr && Ut.beforeEnter(ut), a(ut, ye, Ne), ((Qe = bt && bt.onVnodeMounted) || Vr || dr) && ea(() => {
      Qe && Ns(Qe, $e, Y), Vr && Ut.enter(ut), dr && wc(Y, null, $e, "mounted");
    }, We);
  }, Pe = (Y, ye, Ne, $e, We) => {
    if (Ne && P(Y, Ne), $e)
      for (let rt = 0; rt < $e.length; rt++)
        P(Y, $e[rt]);
    if (We) {
      let rt = We.subTree;
      if (process.env.NODE_ENV !== "production" && rt.patchFlag > 0 && rt.patchFlag & 2048 && (rt = mS(rt.children) || rt), ye === rt) {
        const mt = We.vnode;
        Pe(Y, mt, mt.scopeId, mt.slotScopeIds, We.parent);
      }
    }
  }, Se = (Y, ye, Ne, $e, We, rt, mt, et, ut = 0) => {
    for (let Qe = ut; Qe < Y.length; Qe++) {
      const It = Y[Qe] = et ? _u(Y[Qe]) : rs(Y[Qe]);
      V(null, It, ye, Ne, $e, We, rt, mt, et);
    }
  }, Ie = (Y, ye, Ne, $e, We, rt, mt) => {
    const et = ye.el = Y.el;
    let { patchFlag: ut, dynamicChildren: Qe, dirs: It } = ye;
    ut |= Y.patchFlag & 16;
    const bt = Y.props || wn, kt = ye.props || wn;
    let Ut;
    Ne && Ec(Ne, !1), (Ut = kt.onVnodeBeforeUpdate) && Ns(Ut, Ne, ye, Y), It && wc(ye, Y, Ne, "beforeUpdate"), Ne && Ec(Ne, !0), process.env.NODE_ENV !== "production" && Ou && (ut = 0, mt = !1, Qe = null);
    const dr = We && ye.type !== "foreignObject";
    if (Qe ? (Je(Y.dynamicChildren, Qe, et, Ne, $e, dr, rt), process.env.NODE_ENV !== "production" && Ne && Ne.type.__hmrId && hd(Y, ye)) : mt || tr(Y, ye, et, null, Ne, $e, dr, rt, !1), ut > 0) {
      if (ut & 16)
        qe(et, ye, bt, kt, Ne, $e, We);
      else if (ut & 2 && bt.class !== kt.class && h(et, "class", null, kt.class, We), ut & 4 && h(et, "style", bt.style, kt.style, We), ut & 8) {
        const Vr = ye.dynamicProps;
        for (let Lr = 0; Lr < Vr.length; Lr++) {
          const Jr = Vr[Lr], Xn = bt[Jr], Bi = kt[Jr];
          (Bi !== Xn || Jr === "value") && h(et, Jr, Xn, Bi, We, Y.children, Ne, $e, kr);
        }
      }
      ut & 1 && Y.children !== ye.children && T(et, ye.children);
    } else
      !mt && Qe == null && qe(et, ye, bt, kt, Ne, $e, We);
    ((Ut = kt.onVnodeUpdated) || It) && ea(() => {
      Ut && Ns(Ut, Ne, ye, Y), It && wc(ye, Y, Ne, "updated");
    }, $e);
  }, Je = (Y, ye, Ne, $e, We, rt, mt) => {
    for (let et = 0; et < ye.length; et++) {
      const ut = Y[et], Qe = ye[et], It = ut.el && (ut.type === cn || !zc(ut, Qe) || ut.shapeFlag & 70) ? M(ut.el) : Ne;
      V(ut, Qe, It, null, $e, We, rt, mt, !0);
    }
  }, qe = (Y, ye, Ne, $e, We, rt, mt) => {
    if (Ne !== $e) {
      if (Ne !== wn)
        for (const et in Ne)
          !Zy(et) && !(et in $e) && h(Y, et, Ne[et], null, mt, ye.children, We, rt, kr);
      for (const et in $e) {
        if (Zy(et))
          continue;
        const ut = $e[et], Qe = Ne[et];
        ut !== Qe && et !== "value" && h(Y, et, Qe, ut, mt, ye.children, We, rt, kr);
      }
      "value" in $e && h(Y, "value", Ne.value, $e.value);
    }
  }, at = (Y, ye, Ne, $e, We, rt, mt, et, ut) => {
    const Qe = ye.el = Y ? Y.el : m(""), It = ye.anchor = Y ? Y.anchor : m("");
    let { patchFlag: bt, dynamicChildren: kt, slotScopeIds: Ut } = ye;
    process.env.NODE_ENV !== "production" && (Ou || bt & 2048) && (bt = 0, ut = !1, kt = null), Ut && (et = et ? et.concat(Ut) : Ut), Y == null ? (a(Qe, Ne, $e), a(It, Ne, $e), Se(ye.children, Ne, It, We, rt, mt, et, ut)) : bt > 0 && bt & 64 && kt && Y.dynamicChildren ? (Je(Y.dynamicChildren, kt, Ne, We, rt, mt, et), process.env.NODE_ENV !== "production" && We && We.type.__hmrId ? hd(Y, ye) : (ye.key != null || We && ye === We.subTree) && hd(Y, ye, !0)) : tr(Y, ye, Ne, It, We, rt, mt, et, ut);
  }, be = (Y, ye, Ne, $e, We, rt, mt, et, ut) => {
    ye.slotScopeIds = et, Y == null ? ye.shapeFlag & 512 ? We.ctx.activate(ye, Ne, $e, mt, ut) : Ke(ye, Ne, $e, We, rt, mt, ut) : ht(Y, ye, ut);
  }, Ke = (Y, ye, Ne, $e, We, rt, mt) => {
    const et = Y.component = uk(Y, $e, We);
    if (process.env.NODE_ENV !== "production" && et.type.__hmrId && $A(et), process.env.NODE_ENV !== "production" && (Xy(Y), kl(et, "mount")), Ud(Y) && (et.ctx.renderer = En), process.env.NODE_ENV !== "production" && kl(et, "init"), hk(et), process.env.NODE_ENV !== "production" && Ll(et, "init"), et.asyncDep) {
      if (We && We.registerDep(et, vt), !Y.el) {
        const ut = et.subTree = Ft(Xi);
        X(null, ut, ye, Ne);
      }
      return;
    }
    vt(et, Y, ye, Ne, We, rt, mt), process.env.NODE_ENV !== "production" && (Ky(), Ll(et, "mount"));
  }, ht = (Y, ye, Ne) => {
    const $e = ye.component = Y.component;
    if (sP(Y, ye, Ne))
      if ($e.asyncDep && !$e.asyncResolved) {
        process.env.NODE_ENV !== "production" && Xy(ye), Pt($e, ye, Ne), process.env.NODE_ENV !== "production" && Ky();
        return;
      } else
        $e.next = ye, GA($e.update), $e.update();
    else
      ye.el = Y.el, $e.vnode = ye;
  }, vt = (Y, ye, Ne, $e, We, rt, mt) => {
    const et = () => {
      if (Y.isMounted) {
        let { next: It, bu: bt, u: kt, parent: Ut, vnode: dr } = Y, Vr = It, Lr;
        process.env.NODE_ENV !== "production" && Xy(It || Y.vnode), Ec(Y, !1), It ? (It.el = dr.el, Pt(Y, It, mt)) : It = dr, bt && Vp(bt), (Lr = It.props && It.props.onVnodeBeforeUpdate) && Ns(Lr, Ut, It, dr), Ec(Y, !0), process.env.NODE_ENV !== "production" && kl(Y, "render");
        const Jr = O_(Y);
        process.env.NODE_ENV !== "production" && Ll(Y, "render");
        const Xn = Y.subTree;
        Y.subTree = Jr, process.env.NODE_ENV !== "production" && kl(Y, "patch"), V(
          Xn,
          Jr,
          M(Xn.el),
          Vn(Xn),
          Y,
          We,
          rt
        ), process.env.NODE_ENV !== "production" && Ll(Y, "patch"), It.el = Jr.el, Vr === null && lP(Y, Jr.el), kt && ea(kt, We), (Lr = It.props && It.props.onVnodeUpdated) && ea(() => Ns(Lr, Ut, It, dr), We), process.env.NODE_ENV !== "production" && hS(Y), process.env.NODE_ENV !== "production" && Ky();
      } else {
        let It;
        const { el: bt, props: kt } = ye, { bm: Ut, m: dr, parent: Vr } = Y, Lr = cd(ye);
        if (Ec(Y, !1), Ut && Vp(Ut), !Lr && (It = kt && kt.onVnodeBeforeMount) && Ns(It, Vr, ye), Ec(Y, !0), bt && Un) {
          const Jr = () => {
            process.env.NODE_ENV !== "production" && kl(Y, "render"), Y.subTree = O_(Y), process.env.NODE_ENV !== "production" && Ll(Y, "render"), process.env.NODE_ENV !== "production" && kl(Y, "hydrate"), Un(bt, Y.subTree, Y, We, null), process.env.NODE_ENV !== "production" && Ll(Y, "hydrate");
          };
          Lr ? ye.type.__asyncLoader().then(
            () => !Y.isUnmounted && Jr()
          ) : Jr();
        } else {
          process.env.NODE_ENV !== "production" && kl(Y, "render");
          const Jr = Y.subTree = O_(Y);
          process.env.NODE_ENV !== "production" && Ll(Y, "render"), process.env.NODE_ENV !== "production" && kl(Y, "patch"), V(null, Jr, Ne, $e, Y, We, rt), process.env.NODE_ENV !== "production" && Ll(Y, "patch"), ye.el = Jr.el;
        }
        if (dr && ea(dr, We), !Lr && (It = kt && kt.onVnodeMounted)) {
          const Jr = ye;
          ea(() => Ns(It, Vr, Jr), We);
        }
        (ye.shapeFlag & 256 || Vr && cd(Vr.vnode) && Vr.vnode.shapeFlag & 256) && Y.a && ea(Y.a, We), Y.isMounted = !0, process.env.NODE_ENV !== "production" && YA(Y), ye = Ne = $e = null;
      }
    }, ut = Y.effect = new S1(
      et,
      () => dv(Qe),
      Y.scope
    ), Qe = Y.update = () => ut.run();
    Qe.id = Y.uid, Ec(Y, !0), process.env.NODE_ENV !== "production" && (ut.onTrack = Y.rtc ? (It) => Vp(Y.rtc, It) : void 0, ut.onTrigger = Y.rtg ? (It) => Vp(Y.rtg, It) : void 0, Qe.ownerInstance = Y), Qe();
  }, Pt = (Y, ye, Ne) => {
    ye.component = Y;
    const $e = Y.vnode.props;
    Y.vnode = ye, Y.next = null, BP(Y, ye.props, $e, Ne), HP(Y, ye.children, Ne), eh(), Gb(), th();
  }, tr = (Y, ye, Ne, $e, We, rt, mt, et, ut = !1) => {
    const Qe = Y && Y.children, It = Y ? Y.shapeFlag : 0, bt = ye.children, { patchFlag: kt, shapeFlag: Ut } = ye;
    if (kt > 0) {
      if (kt & 128) {
        Rr(Qe, bt, Ne, $e, We, rt, mt, et, ut);
        return;
      } else if (kt & 256) {
        Pn(Qe, bt, Ne, $e, We, rt, mt, et, ut);
        return;
      }
    }
    Ut & 8 ? (It & 16 && kr(Qe, We, rt), bt !== Qe && T(Ne, bt)) : It & 16 ? Ut & 16 ? Rr(Qe, bt, Ne, $e, We, rt, mt, et, ut) : kr(Qe, We, rt, !0) : (It & 8 && T(Ne, ""), Ut & 16 && Se(bt, Ne, $e, We, rt, mt, et, ut));
  }, Pn = (Y, ye, Ne, $e, We, rt, mt, et, ut) => {
    Y = Y || xf, ye = ye || xf;
    const Qe = Y.length, It = ye.length, bt = Math.min(Qe, It);
    let kt;
    for (kt = 0; kt < bt; kt++) {
      const Ut = ye[kt] = ut ? _u(ye[kt]) : rs(ye[kt]);
      V(Y[kt], Ut, Ne, null, We, rt, mt, et, ut);
    }
    Qe > It ? kr(Y, We, rt, !0, !1, bt) : Se(ye, Ne, $e, We, rt, mt, et, ut, bt);
  }, Rr = (Y, ye, Ne, $e, We, rt, mt, et, ut) => {
    let Qe = 0;
    const It = ye.length;
    let bt = Y.length - 1, kt = It - 1;
    for (; Qe <= bt && Qe <= kt; ) {
      const Ut = Y[Qe], dr = ye[Qe] = ut ? _u(ye[Qe]) : rs(ye[Qe]);
      if (zc(Ut, dr))
        V(Ut, dr, Ne, null, We, rt, mt, et, ut);
      else
        break;
      Qe++;
    }
    for (; Qe <= bt && Qe <= kt; ) {
      const Ut = Y[bt], dr = ye[kt] = ut ? _u(ye[kt]) : rs(ye[kt]);
      if (zc(Ut, dr))
        V(Ut, dr, Ne, null, We, rt, mt, et, ut);
      else
        break;
      bt--, kt--;
    }
    if (Qe > bt) {
      if (Qe <= kt) {
        const Ut = kt + 1, dr = Ut < It ? ye[Ut].el : $e;
        for (; Qe <= kt; )
          V(null, ye[Qe] = ut ? _u(ye[Qe]) : rs(ye[Qe]), Ne, dr, We, rt, mt, et, ut), Qe++;
      }
    } else if (Qe > kt)
      for (; Qe <= bt; )
        Zn(Y[Qe], We, rt, !0), Qe++;
    else {
      const Ut = Qe, dr = Qe, Vr = /* @__PURE__ */ new Map();
      for (Qe = dr; Qe <= kt; Qe++) {
        const Sn = ye[Qe] = ut ? _u(ye[Qe]) : rs(ye[Qe]);
        Sn.key != null && (process.env.NODE_ENV !== "production" && Vr.has(Sn.key) && lt("Duplicate keys found during update:", JSON.stringify(Sn.key), "Make sure keys are unique."), Vr.set(Sn.key, Qe));
      }
      let Lr, Jr = 0;
      const Xn = kt - dr + 1;
      let Bi = !1, so = 0;
      const Kn = new Array(Xn);
      for (Qe = 0; Qe < Xn; Qe++)
        Kn[Qe] = 0;
      for (Qe = Ut; Qe <= bt; Qe++) {
        const Sn = Y[Qe];
        if (Jr >= Xn) {
          Zn(Sn, We, rt, !0);
          continue;
        }
        let ai;
        if (Sn.key != null)
          ai = Vr.get(Sn.key);
        else
          for (Lr = dr; Lr <= kt; Lr++)
            if (Kn[Lr - dr] === 0 && zc(Sn, ye[Lr])) {
              ai = Lr;
              break;
            }
        ai === void 0 ? Zn(Sn, We, rt, !0) : (Kn[ai - dr] = Qe + 1, ai >= so ? so = ai : Bi = !0, V(Sn, ye[ai], Ne, null, We, rt, mt, et, ut), Jr++);
      }
      const ki = Bi ? QP(Kn) : xf;
      for (Lr = ki.length - 1, Qe = Xn - 1; Qe >= 0; Qe--) {
        const Sn = dr + Qe, ai = ye[Sn], Fa = Sn + 1 < It ? ye[Sn + 1].el : $e;
        Kn[Qe] === 0 ? V(null, ai, Ne, Fa, We, rt, mt, et, ut) : Bi && (Lr < 0 || Qe !== ki[Lr] ? pr(ai, Ne, Fa, 2) : Lr--);
      }
    }
  }, pr = (Y, ye, Ne, $e, We = null) => {
    const { el: rt, type: mt, transition: et, children: ut, shapeFlag: Qe } = Y;
    if (Qe & 6) {
      pr(Y.component.subTree, ye, Ne, $e);
      return;
    }
    if (Qe & 128) {
      Y.suspense.move(ye, Ne, $e);
      return;
    }
    if (Qe & 64) {
      mt.move(Y, ye, Ne, En);
      return;
    }
    if (mt === cn) {
      a(rt, ye, Ne);
      for (let bt = 0; bt < ut.length; bt++)
        pr(ut[bt], ye, Ne, $e);
      a(Y.anchor, ye, Ne);
      return;
    }
    if (mt === Yy) {
      pe(Y, ye, Ne);
      return;
    }
    if ($e !== 2 && Qe & 1 && et)
      if ($e === 0)
        et.beforeEnter(rt), a(rt, ye, Ne), ea(() => et.enter(rt), We);
      else {
        const { leave: bt, delayLeave: kt, afterLeave: Ut } = et, dr = () => a(rt, ye, Ne), Vr = () => {
          bt(rt, () => {
            dr(), Ut && Ut();
          });
        };
        kt ? kt(rt, dr, Vr) : Vr();
      }
    else
      a(rt, ye, Ne);
  }, Zn = (Y, ye, Ne, $e = !1, We = !1) => {
    const { type: rt, props: mt, ref: et, children: ut, dynamicChildren: Qe, shapeFlag: It, patchFlag: bt, dirs: kt } = Y;
    if (et != null && N0(et, null, Ne, Y, !0), It & 256) {
      ye.ctx.deactivate(Y);
      return;
    }
    const Ut = It & 1 && kt, dr = !cd(Y);
    let Vr;
    if (dr && (Vr = mt && mt.onVnodeBeforeUnmount) && Ns(Vr, ye, Y), It & 6)
      qr(Y.component, Ne, $e);
    else {
      if (It & 128) {
        Y.suspense.unmount(Ne, $e);
        return;
      }
      Ut && wc(Y, null, ye, "beforeUnmount"), It & 64 ? Y.type.remove(Y, ye, Ne, We, En, $e) : Qe && (rt !== cn || bt > 0 && bt & 64) ? kr(Qe, ye, Ne, !1, !0) : (rt === cn && bt & 384 || !We && It & 16) && kr(ut, ye, Ne), $e && zr(Y);
    }
    (dr && (Vr = mt && mt.onVnodeUnmounted) || Ut) && ea(() => {
      Vr && Ns(Vr, ye, Y), Ut && wc(Y, null, ye, "unmounted");
    }, Ne);
  }, zr = (Y) => {
    const { type: ye, el: Ne, anchor: $e, transition: We } = Y;
    if (ye === cn) {
      process.env.NODE_ENV !== "production" && Y.patchFlag > 0 && Y.patchFlag & 2048 && We && !We.persisted ? Y.children.forEach((mt) => {
        mt.type === Xi ? s(mt.el) : zr(mt);
      }) : Fi(Ne, $e);
      return;
    }
    if (ye === Yy) {
      xe(Y);
      return;
    }
    const rt = () => {
      s(Ne), We && !We.persisted && We.afterLeave && We.afterLeave();
    };
    if (Y.shapeFlag & 1 && We && !We.persisted) {
      const { leave: mt, delayLeave: et } = We, ut = () => mt(Ne, rt);
      et ? et(Y.el, rt, ut) : ut();
    } else
      rt();
  }, Fi = (Y, ye) => {
    let Ne;
    for (; Y !== ye; )
      Ne = I(Y), s(Y), Y = Ne;
    s(ye);
  }, qr = (Y, ye, Ne) => {
    process.env.NODE_ENV !== "production" && Y.type.__hmrId && WA(Y);
    const { bum: $e, scope: We, update: rt, subTree: mt, um: et } = Y;
    $e && Vp($e), We.stop(), rt && (rt.active = !1, Zn(mt, Y, ye, Ne)), et && ea(et, ye), ea(() => {
      Y.isUnmounted = !0;
    }, ye), ye && ye.pendingBranch && !ye.isUnmounted && Y.asyncDep && !Y.asyncResolved && Y.suspenseId === ye.pendingId && (ye.deps--, ye.deps === 0 && ye.resolve()), process.env.NODE_ENV !== "production" && QA(Y);
  }, kr = (Y, ye, Ne, $e = !1, We = !1, rt = 0) => {
    for (let mt = rt; mt < Y.length; mt++)
      Zn(Y[mt], ye, Ne, $e, We);
  }, Vn = (Y) => Y.shapeFlag & 6 ? Vn(Y.component.subTree) : Y.shapeFlag & 128 ? Y.suspense.next() : I(Y.anchor || Y.el), Er = (Y, ye, Ne) => {
    Y == null ? ye._vnode && Zn(ye._vnode, null, null, !0) : V(ye._vnode || null, Y, ye, null, null, null, Ne), Gb(), sS(), ye._vnode = Y;
  }, En = {
    p: V,
    um: Zn,
    m: pr,
    r: zr,
    mt: Ke,
    mc: Se,
    pc: tr,
    pbc: Je,
    n: Vn,
    o: t
  };
  let oi, Un;
  return e && ([oi, Un] = e(En)), {
    render: Er,
    hydrate: oi,
    createApp: XP(Er, oi)
  };
}
function Ec({ effect: t, update: e }, n) {
  t.allowRecurse = e.allowRecurse = n;
}
function hd(t, e, n = !1) {
  const a = t.children, s = e.children;
  if (er(a) && er(s))
    for (let h = 0; h < a.length; h++) {
      const o = a[h];
      let m = s[h];
      m.shapeFlag & 1 && !m.dynamicChildren && ((m.patchFlag <= 0 || m.patchFlag === 32) && (m = s[h] = _u(s[h]), m.el = o.el), n || hd(o, m)), m.type === jd && (m.el = o.el), process.env.NODE_ENV !== "production" && m.type === Xi && !m.el && (m.el = o.el);
    }
}
function QP(t) {
  const e = t.slice(), n = [0];
  let a, s, h, o, m;
  const g = t.length;
  for (a = 0; a < g; a++) {
    const b = t[a];
    if (b !== 0) {
      if (s = n[n.length - 1], t[s] < b) {
        e[a] = s, n.push(a);
        continue;
      }
      for (h = 0, o = n.length - 1; h < o; )
        m = h + o >> 1, t[n[m]] < b ? h = m + 1 : o = m;
      b < t[n[h]] && (h > 0 && (e[a] = n[h - 1]), n[h] = a);
    }
  }
  for (h = n.length, o = n[h - 1]; h-- > 0; )
    n[h] = o, o = e[o];
  return n;
}
const ek = (t) => t.__isTeleport, Ef = (t) => t && (t.disabled || t.disabled === ""), rw = (t) => typeof SVGElement < "u" && t instanceof SVGElement, R0 = (t, e) => {
  const n = t && t.to;
  if (Hn(n))
    if (e) {
      const a = e(n);
      return a || process.env.NODE_ENV !== "production" && lt(`Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`), a;
    } else
      return process.env.NODE_ENV !== "production" && lt("Current renderer does not support string target for Teleports. (missing querySelector renderer option)"), null;
  else
    return process.env.NODE_ENV !== "production" && !n && !Ef(t) && lt(`Invalid Teleport target: ${n}`), n;
}, tk = {
  __isTeleport: !0,
  process(t, e, n, a, s, h, o, m, g, b) {
    const { mc: T, pc: M, pbc: I, o: { insert: P, querySelector: z, createText: V, createComment: W } } = b, X = Ef(e.props);
    let { shapeFlag: K, children: se, dynamicChildren: pe } = e;
    if (process.env.NODE_ENV !== "production" && Ou && (g = !1, pe = null), t == null) {
      const xe = e.el = process.env.NODE_ENV !== "production" ? W("teleport start") : V(""), Fe = e.anchor = process.env.NODE_ENV !== "production" ? W("teleport end") : V("");
      P(xe, n, a), P(Fe, n, a);
      const ze = e.target = R0(e.props, z), Pe = e.targetAnchor = V("");
      ze ? (P(Pe, ze), o = o || rw(ze)) : process.env.NODE_ENV !== "production" && !X && lt("Invalid Teleport target on mount:", ze, `(${typeof ze})`);
      const Se = (Ie, Je) => {
        K & 16 && T(se, Ie, Je, s, h, o, m, g);
      };
      X ? Se(n, Fe) : ze && Se(ze, Pe);
    } else {
      e.el = t.el;
      const xe = e.anchor = t.anchor, Fe = e.target = t.target, ze = e.targetAnchor = t.targetAnchor, Pe = Ef(t.props), Se = Pe ? n : Fe, Ie = Pe ? xe : ze;
      if (o = o || rw(Fe), pe ? (I(t.dynamicChildren, pe, Se, s, h, o, m), hd(t, e, !0)) : g || M(t, e, Se, Ie, s, h, o, m, !1), X)
        Pe || by(e, n, xe, b, 1);
      else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
        const Je = e.target = R0(e.props, z);
        Je ? by(e, Je, null, b, 0) : process.env.NODE_ENV !== "production" && lt("Invalid Teleport target on update:", Fe, `(${typeof Fe})`);
      } else
        Pe && by(e, Fe, ze, b, 1);
    }
    zS(e);
  },
  remove(t, e, n, a, { um: s, o: { remove: h } }, o) {
    const { shapeFlag: m, children: g, anchor: b, targetAnchor: T, target: M, props: I } = t;
    if (M && h(T), (o || !Ef(I)) && (h(b), m & 16))
      for (let P = 0; P < g.length; P++) {
        const z = g[P];
        s(z, e, n, !0, !!z.dynamicChildren);
      }
  },
  move: by,
  hydrate: rk
};
function by(t, e, n, { o: { insert: a }, m: s }, h = 2) {
  h === 0 && a(t.targetAnchor, e, n);
  const { el: o, anchor: m, shapeFlag: g, children: b, props: T } = t, M = h === 2;
  if (M && a(o, e, n), (!M || Ef(T)) && g & 16)
    for (let I = 0; I < b.length; I++)
      s(b[I], e, n, 2);
  M && a(m, e, n);
}
function rk(t, e, n, a, s, h, { o: { nextSibling: o, parentNode: m, querySelector: g } }, b) {
  const T = e.target = R0(e.props, g);
  if (T) {
    const M = T._lpa || T.firstChild;
    if (e.shapeFlag & 16)
      if (Ef(e.props))
        e.anchor = b(o(t), e, m(t), n, a, s, h), e.targetAnchor = M;
      else {
        e.anchor = o(t);
        let I = M;
        for (; I; )
          if (I = o(I), I && I.nodeType === 8 && I.data === "teleport anchor") {
            e.targetAnchor = I, T._lpa = e.targetAnchor && o(e.targetAnchor);
            break;
          }
        b(M, e, T, n, a, s, h);
      }
    zS(e);
  }
  return e.anchor && o(e.anchor);
}
const RS = tk;
function zS(t) {
  const e = t.ctx;
  if (e && e.ut) {
    let n = t.children[0].el;
    for (; n !== t.targetAnchor; )
      n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid), n = n.nextSibling;
    e.ut();
  }
}
const cn = Symbol(process.env.NODE_ENV !== "production" ? "Fragment" : void 0), jd = Symbol(process.env.NODE_ENV !== "production" ? "Text" : void 0), Xi = Symbol(process.env.NODE_ENV !== "production" ? "Comment" : void 0), Yy = Symbol(process.env.NODE_ENV !== "production" ? "Static" : void 0), fd = [];
let is = null;
function Ve(t = !1) {
  fd.push(is = t ? null : []);
}
function nk() {
  fd.pop(), is = fd[fd.length - 1] || null;
}
let Od = 1;
function nw(t) {
  Od += t;
}
function FS(t) {
  return t.dynamicChildren = Od > 0 ? is || xf : null, nk(), Od > 0 && is && is.push(t), t;
}
function it(t, e, n, a, s, h) {
  return FS(Re(t, e, n, a, s, h, !0));
}
function on(t, e, n, a, s) {
  return FS(Ft(t, e, n, a, s, !0));
}
function Pf(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function zc(t, e) {
  return process.env.NODE_ENV !== "production" && e.shapeFlag & 6 && uf.has(e.type) ? (t.shapeFlag &= -257, e.shapeFlag &= -513, !1) : t.type === e.type && t.key === e.key;
}
const ik = (...t) => VS(...t), gv = "__vInternal", BS = ({ key: t }) => t != null ? t : null, Jy = ({ ref: t, ref_key: e, ref_for: n }) => t != null ? Hn(t) || hn(t) || yr(t) ? { i: zi, r: t, k: e, f: !!n } : t : null;
function Re(t, e = null, n = null, a = 0, s = null, h = t === cn ? 0 : 1, o = !1, m = !1) {
  const g = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && BS(e),
    ref: e && Jy(e),
    scopeId: dS,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: h,
    patchFlag: a,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: zi
  };
  return m ? (N1(g, n), h & 128 && t.normalize(g)) : n && (g.shapeFlag |= Hn(n) ? 8 : 16), process.env.NODE_ENV !== "production" && g.key !== g.key && lt("VNode created with invalid key (NaN). VNode type:", g.type), Od > 0 && !o && is && (g.patchFlag > 0 || h & 6) && g.patchFlag !== 32 && is.push(g), g;
}
const Ft = process.env.NODE_ENV !== "production" ? ik : VS;
function VS(t, e = null, n = null, a = 0, s = null, h = !1) {
  if ((!t || t === MP) && (process.env.NODE_ENV !== "production" && !t && lt(`Invalid vnode type when creating vnode: ${t}.`), t = Xi), Pf(t)) {
    const m = Ks(t, e, !0);
    return n && N1(m, n), Od > 0 && !h && is && (m.shapeFlag & 6 ? is[is.indexOf(t)] = m : is.push(m)), m.patchFlag |= -2, m;
  }
  if (qS(t) && (t = t.__vccOpts), e) {
    e = ok(e);
    let { class: m, style: g } = e;
    m && !Hn(m) && (e.class = Pr(m)), fn(g) && (xg(g) && !er(g) && (g = Wn({}, g)), e.style = Vu(g));
  }
  const o = Hn(t) ? 1 : uP(t) ? 128 : ek(t) ? 64 : fn(t) ? 4 : yr(t) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && o & 4 && xg(t) && (t = hr(t), lt("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `
Component that was made reactive: `, t)), Re(t, e, n, a, s, o, h, !0);
}
function ok(t) {
  return t ? xg(t) || gv in t ? Wn({}, t) : t : null;
}
function Ks(t, e, n = !1) {
  const { props: a, ref: s, patchFlag: h, children: o } = t, m = e ? ak(a || {}, e) : a;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: m,
    key: m && BS(m),
    ref: e && e.ref ? n && s ? er(s) ? s.concat(Jy(e)) : [s, Jy(e)] : Jy(e) : s,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && h === -1 && er(o) ? o.map(US) : o,
    target: t.target,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    patchFlag: e && t.type !== cn ? h === -1 ? 16 : h | 16 : h,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: t.transition,
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && Ks(t.ssContent),
    ssFallback: t.ssFallback && Ks(t.ssFallback),
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
}
function US(t) {
  const e = Ks(t);
  return er(t.children) && (e.children = t.children.map(US)), e;
}
function Mg(t = " ", e = 0) {
  return Ft(jd, null, t, e);
}
function Ye(t = "", e = !1) {
  return e ? (Ve(), on(Xi, null, t)) : Ft(Xi, null, t);
}
function rs(t) {
  return t == null || typeof t == "boolean" ? Ft(Xi) : er(t) ? Ft(
    cn,
    null,
    t.slice()
  ) : typeof t == "object" ? _u(t) : Ft(jd, null, String(t));
}
function _u(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : Ks(t);
}
function N1(t, e) {
  let n = 0;
  const { shapeFlag: a } = t;
  if (e == null)
    e = null;
  else if (er(e))
    n = 16;
  else if (typeof e == "object")
    if (a & 65) {
      const s = e.default;
      s && (s._c && (s._d = !1), N1(t, s()), s._c && (s._d = !0));
      return;
    } else {
      n = 32;
      const s = e._;
      !s && !(gv in e) ? e._ctx = zi : s === 3 && zi && (zi.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
  else
    yr(e) ? (e = { default: e, _ctx: zi }, n = 32) : (e = String(e), a & 64 ? (n = 16, e = [Mg(e)]) : n = 8);
  t.children = e, t.shapeFlag |= n;
}
function ak(...t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    for (const s in a)
      if (s === "class")
        e.class !== a.class && (e.class = Pr([e.class, a.class]));
      else if (s === "style")
        e.style = Vu([e.style, a.style]);
      else if (Fd(s)) {
        const h = e[s], o = a[s];
        o && h !== o && !(er(h) && h.includes(o)) && (e[s] = h ? [].concat(h, o) : o);
      } else
        s !== "" && (e[s] = a[s]);
  }
  return e;
}
function Ns(t, e, n, a = null) {
  La(t, e, 7, [
    n,
    a
  ]);
}
const sk = NS();
let lk = 0;
function uk(t, e, n) {
  const a = t.type, s = (e ? e.appContext : t.appContext) || sk, h = {
    uid: lk++,
    vnode: t,
    type: a,
    parent: e,
    appContext: s,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new RE(!0),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(s.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: AS(a, s),
    emitsOptions: pS(a, s),
    emit: null,
    emitted: null,
    propsDefaults: wn,
    inheritAttrs: a.inheritAttrs,
    ctx: wn,
    data: wn,
    props: wn,
    attrs: wn,
    slots: wn,
    refs: wn,
    setupState: wn,
    setupContext: null,
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return process.env.NODE_ENV !== "production" ? h.ctx = OP(h) : h.ctx = { _: h }, h.root = e ? e.root : h, h.emit = nP.bind(null, h), t.ce && t.ce(h), h;
}
let pi = null;
const vv = () => pi || zi, kf = (t) => {
  pi = t, t.scope.on();
}, $c = () => {
  pi && pi.scope.off(), pi = null;
}, ck = /* @__PURE__ */ Bu("slot,component");
function z0(t, e) {
  const n = e.isNativeTag || PE;
  (ck(t) || n(t)) && lt("Do not use built-in or reserved HTML elements as component id: " + t);
}
function jS(t) {
  return t.vnode.shapeFlag & 4;
}
let Cd = !1;
function hk(t, e = !1) {
  Cd = e;
  const { props: n, children: a } = t.vnode, s = jS(t);
  zP(t, n, s, e), WP(t, a);
  const h = s ? fk(t, e) : void 0;
  return Cd = !1, h;
}
function fk(t, e) {
  var n;
  const a = t.type;
  if (process.env.NODE_ENV !== "production") {
    if (a.name && z0(a.name, t.appContext.config), a.components) {
      const h = Object.keys(a.components);
      for (let o = 0; o < h.length; o++)
        z0(h[o], t.appContext.config);
    }
    if (a.directives) {
      const h = Object.keys(a.directives);
      for (let o = 0; o < h.length; o++)
        ES(h[o]);
    }
    a.compilerOptions && pk() && lt('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.');
  }
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = ts(new Proxy(t.ctx, IS)), process.env.NODE_ENV !== "production" && CP(t);
  const { setup: s } = a;
  if (s) {
    const h = t.setupContext = s.length > 1 ? dk(t) : null;
    kf(t), eh();
    const o = Rl(s, t, 0, [process.env.NODE_ENV !== "production" ? pf(t.props) : t.props, h]);
    if (th(), $c(), b1(o)) {
      if (o.then($c, $c), e)
        return o.then((m) => {
          iw(t, m, e);
        }).catch((m) => {
          pv(m, t, 0);
        });
      if (t.asyncDep = o, process.env.NODE_ENV !== "production" && !t.suspense) {
        const m = (n = a.name) !== null && n !== void 0 ? n : "Anonymous";
        lt(`Component <${m}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
      }
    } else
      iw(t, o, e);
  } else
    GS(t, e);
}
function iw(t, e, n) {
  yr(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : fn(e) ? (process.env.NODE_ENV !== "production" && Pf(e) && lt("setup() should not return VNodes directly - return a render function instead."), process.env.NODE_ENV !== "production" && (t.devtoolsRawSetupState = e), t.setupState = tS(e), process.env.NODE_ENV !== "production" && AP(t)) : process.env.NODE_ENV !== "production" && e !== void 0 && lt(`setup() should return an object. Received: ${e === null ? "null" : typeof e}`), GS(t, n);
}
let F0;
const pk = () => !F0;
function GS(t, e, n) {
  const a = t.type;
  if (!t.render) {
    if (!e && F0 && !a.render) {
      const s = a.template || L1(t).template;
      if (s) {
        process.env.NODE_ENV !== "production" && kl(t, "compile");
        const { isCustomElement: h, compilerOptions: o } = t.appContext.config, { delimiters: m, compilerOptions: g } = a, b = Wn(Wn({
          isCustomElement: h,
          delimiters: m
        }, o), g);
        a.render = F0(s, b), process.env.NODE_ENV !== "production" && Ll(t, "compile");
      }
    }
    t.render = a.render || ao;
  }
  kf(t), eh(), kP(t), th(), $c(), process.env.NODE_ENV !== "production" && !a.render && t.render === ao && !e && (a.template ? lt('Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".') : lt("Component is missing template or render function."));
}
function ow(t) {
  return new Proxy(t.attrs, process.env.NODE_ENV !== "production" ? {
    get(e, n) {
      return Eg(), Bo(t, "get", "$attrs"), e[n];
    },
    set() {
      return lt("setupContext.attrs is readonly."), !1;
    },
    deleteProperty() {
      return lt("setupContext.attrs is readonly."), !1;
    }
  } : {
    get(e, n) {
      return Bo(t, "get", "$attrs"), e[n];
    }
  });
}
function dk(t) {
  const e = (a) => {
    if (process.env.NODE_ENV !== "production" && (t.exposed && lt("expose() should be called only once per setup()."), a != null)) {
      let s = typeof a;
      s === "object" && (er(a) ? s = "array" : hn(a) && (s = "ref")), s !== "object" && lt(`expose() should be passed a plain object, received ${s}.`);
    }
    t.exposed = a || {};
  };
  let n;
  return process.env.NODE_ENV !== "production" ? Object.freeze({
    get attrs() {
      return n || (n = ow(t));
    },
    get slots() {
      return pf(t.slots);
    },
    get emit() {
      return (a, ...s) => t.emit(a, ...s);
    },
    expose: e
  }) : {
    get attrs() {
      return n || (n = ow(t));
    },
    slots: t.slots,
    emit: t.emit,
    expose: e
  };
}
function _v(t) {
  if (t.exposed)
    return t.exposeProxy || (t.exposeProxy = new Proxy(tS(ts(t.exposed)), {
      get(e, n) {
        if (n in e)
          return e[n];
        if (n in qc)
          return qc[n](t);
      },
      has(e, n) {
        return n in e || n in qc;
      }
    }));
}
const mk = /(?:^|[-_])(\w)/g, yk = (t) => t.replace(mk, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function R1(t, e = !0) {
  return yr(t) ? t.displayName || t.name : t.name || e && t.__name;
}
function xv(t, e, n = !1) {
  let a = R1(e);
  if (!a && e.__file) {
    const s = e.__file.match(/([^/\\]+)\.\w+$/);
    s && (a = s[1]);
  }
  if (!a && t && t.parent) {
    const s = (h) => {
      for (const o in h)
        if (h[o] === e)
          return o;
    };
    a = s(t.components || t.parent.type.components) || s(t.appContext.components);
  }
  return a ? yk(a) : n ? "App" : "Anonymous";
}
function qS(t) {
  return yr(t) && "__vccOpts" in t;
}
const lr = (t, e) => DA(t, e, Cd);
function $S(t, e, n) {
  const a = arguments.length;
  return a === 2 ? fn(e) && !er(e) ? Pf(e) ? Ft(t, null, [e]) : Ft(t, e) : Ft(t, null, e) : (a > 3 ? n = Array.prototype.slice.call(arguments, 2) : a === 3 && Pf(n) && (n = [n]), Ft(t, e, n));
}
const gk = Symbol(process.env.NODE_ENV !== "production" ? "ssrContext" : ""), vk = () => {
  {
    const t = wf(gk);
    return t || process.env.NODE_ENV !== "production" && lt("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), t;
  }
};
function P_(t) {
  return !!(t && t.__v_isShallow);
}
function _k() {
  if (process.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const t = { style: "color:#3ba776" }, e = { style: "color:#0b1bc9" }, n = { style: "color:#b62e24" }, a = { style: "color:#9d288c" }, s = {
    header(M) {
      return fn(M) ? M.__isVue ? ["div", t, "VueInstance"] : hn(M) ? [
        "div",
        {},
        ["span", t, T(M)],
        "<",
        m(M.value),
        ">"
      ] : ss(M) ? [
        "div",
        {},
        ["span", t, P_(M) ? "ShallowReactive" : "Reactive"],
        "<",
        m(M),
        `>${Du(M) ? " (readonly)" : ""}`
      ] : Du(M) ? [
        "div",
        {},
        ["span", t, P_(M) ? "ShallowReadonly" : "Readonly"],
        "<",
        m(M),
        ">"
      ] : null : null;
    },
    hasBody(M) {
      return M && M.__isVue;
    },
    body(M) {
      if (M && M.__isVue)
        return [
          "div",
          {},
          ...h(M.$)
        ];
    }
  };
  function h(M) {
    const I = [];
    M.type.props && M.props && I.push(o("props", hr(M.props))), M.setupState !== wn && I.push(o("setup", M.setupState)), M.data !== wn && I.push(o("data", hr(M.data)));
    const P = g(M, "computed");
    P && I.push(o("computed", P));
    const z = g(M, "inject");
    return z && I.push(o("injected", z)), I.push([
      "div",
      {},
      [
        "span",
        {
          style: a.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: M }]
    ]), I;
  }
  function o(M, I) {
    return I = Wn({}, I), Object.keys(I).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        M
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(I).map((P) => [
          "div",
          {},
          ["span", a, P + ": "],
          m(I[P], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function m(M, I = !0) {
    return typeof M == "number" ? ["span", e, M] : typeof M == "string" ? ["span", n, JSON.stringify(M)] : typeof M == "boolean" ? ["span", a, M] : fn(M) ? ["object", { object: I ? hr(M) : M }] : ["span", n, String(M)];
  }
  function g(M, I) {
    const P = M.type;
    if (yr(P))
      return;
    const z = {};
    for (const V in M.ctx)
      b(P, V, I) && (z[V] = M.ctx[V]);
    return z;
  }
  function b(M, I, P) {
    const z = M[P];
    if (er(z) && z.includes(I) || fn(z) && I in z || M.extends && b(M.extends, I, P) || M.mixins && M.mixins.some((V) => b(V, I, P)))
      return !0;
  }
  function T(M) {
    return P_(M) ? "ShallowRef" : M.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(s) : window.devtoolsFormatters = [s];
}
const aw = "3.2.47", xk = "http://www.w3.org/2000/svg", Fc = typeof document < "u" ? document : null, sw = Fc && /* @__PURE__ */ Fc.createElement("template"), bk = {
  insert: (t, e, n) => {
    e.insertBefore(t, n || null);
  },
  remove: (t) => {
    const e = t.parentNode;
    e && e.removeChild(t);
  },
  createElement: (t, e, n, a) => {
    const s = e ? Fc.createElementNS(xk, t) : Fc.createElement(t, n ? { is: n } : void 0);
    return t === "select" && a && a.multiple != null && s.setAttribute("multiple", a.multiple), s;
  },
  createText: (t) => Fc.createTextNode(t),
  createComment: (t) => Fc.createComment(t),
  setText: (t, e) => {
    t.nodeValue = e;
  },
  setElementText: (t, e) => {
    t.textContent = e;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => Fc.querySelector(t),
  setScopeId(t, e) {
    t.setAttribute(e, "");
  },
  insertStaticContent(t, e, n, a, s, h) {
    const o = n ? n.previousSibling : e.lastChild;
    if (s && (s === h || s.nextSibling))
      for (; e.insertBefore(s.cloneNode(!0), n), !(s === h || !(s = s.nextSibling)); )
        ;
    else {
      sw.innerHTML = a ? `<svg>${t}</svg>` : t;
      const m = sw.content;
      if (a) {
        const g = m.firstChild;
        for (; g.firstChild; )
          m.appendChild(g.firstChild);
        m.removeChild(g);
      }
      e.insertBefore(m, n);
    }
    return [
      o ? o.nextSibling : e.firstChild,
      n ? n.previousSibling : e.lastChild
    ];
  }
};
function wk(t, e, n) {
  const a = t._vtc;
  a && (e = (e ? [e, ...a] : [...a]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e;
}
function Ek(t, e, n) {
  const a = t.style, s = Hn(n);
  if (n && !s) {
    if (e && !Hn(e))
      for (const h in e)
        n[h] == null && B0(a, h, "");
    for (const h in n)
      B0(a, h, n[h]);
  } else {
    const h = a.display;
    s ? e !== n && (a.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (a.display = h);
  }
}
const Sk = /[^\\];\s*$/, lw = /\s*!important$/;
function B0(t, e, n) {
  if (er(n))
    n.forEach((a) => B0(t, e, a));
  else if (n == null && (n = ""), process.env.NODE_ENV !== "production" && Sk.test(n) && lt(`Unexpected semicolon at the end of '${e}' style value: '${n}'`), e.startsWith("--"))
    t.setProperty(e, n);
  else {
    const a = Tk(t, e);
    lw.test(n) ? t.setProperty(ta(a), n.replace(lw, ""), "important") : t[a] = n;
  }
}
const uw = ["Webkit", "Moz", "ms"], k_ = {};
function Tk(t, e) {
  const n = k_[e];
  if (n)
    return n;
  let a = ya(e);
  if (a !== "filter" && a in t)
    return k_[e] = a;
  a = Xc(a);
  for (let s = 0; s < uw.length; s++) {
    const h = uw[s] + a;
    if (h in t)
      return k_[e] = h;
  }
  return e;
}
const cw = "http://www.w3.org/1999/xlink";
function Mk(t, e, n, a, s) {
  if (a && e.startsWith("xlink:"))
    n == null ? t.removeAttributeNS(cw, e.slice(6, e.length)) : t.setAttributeNS(cw, e, n);
  else {
    const h = WC(e);
    n == null || h && !CE(n) ? t.removeAttribute(e) : t.setAttribute(e, h ? "" : n);
  }
}
function Ik(t, e, n, a, s, h, o) {
  if (e === "innerHTML" || e === "textContent") {
    a && o(a, s, h), t[e] = n == null ? "" : n;
    return;
  }
  if (e === "value" && t.tagName !== "PROGRESS" && !t.tagName.includes("-")) {
    t._value = n;
    const g = n == null ? "" : n;
    (t.value !== g || t.tagName === "OPTION") && (t.value = g), n == null && t.removeAttribute(e);
    return;
  }
  let m = !1;
  if (n === "" || n == null) {
    const g = typeof t[e];
    g === "boolean" ? n = CE(n) : n == null && g === "string" ? (n = "", m = !0) : g === "number" && (n = 0, m = !0);
  }
  try {
    t[e] = n;
  } catch (g) {
    process.env.NODE_ENV !== "production" && !m && lt(`Failed setting prop "${e}" on <${t.tagName.toLowerCase()}>: value ${n} is invalid.`, g);
  }
  m && t.removeAttribute(e);
}
function Ok(t, e, n, a) {
  t.addEventListener(e, n, a);
}
function Ck(t, e, n, a) {
  t.removeEventListener(e, n, a);
}
function Ak(t, e, n, a, s = null) {
  const h = t._vei || (t._vei = {}), o = h[e];
  if (a && o)
    o.value = a;
  else {
    const [m, g] = Pk(e);
    if (a) {
      const b = h[e] = Dk(a, s);
      Ok(t, m, b, g);
    } else
      o && (Ck(t, m, o, g), h[e] = void 0);
  }
}
const hw = /(?:Once|Passive|Capture)$/;
function Pk(t) {
  let e;
  if (hw.test(t)) {
    e = {};
    let a;
    for (; a = t.match(hw); )
      t = t.slice(0, t.length - a[0].length), e[a[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : ta(t.slice(2)), e];
}
let L_ = 0;
const kk = /* @__PURE__ */ Promise.resolve(), Lk = () => L_ || (kk.then(() => L_ = 0), L_ = Date.now());
function Dk(t, e) {
  const n = (a) => {
    if (!a._vts)
      a._vts = Date.now();
    else if (a._vts <= n.attached)
      return;
    La(Nk(a, n.value), e, 5, [a]);
  };
  return n.value = t, n.attached = Lk(), n;
}
function Nk(t, e) {
  if (er(e)) {
    const n = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      n.call(t), t._stopped = !0;
    }, e.map((a) => (s) => !s._stopped && a && a(s));
  } else
    return e;
}
const fw = /^on[a-z]/, Rk = (t, e, n, a, s = !1, h, o, m, g) => {
  e === "class" ? wk(t, a, s) : e === "style" ? Ek(t, n, a) : Fd(e) ? mg(e) || Ak(t, e, n, a, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : zk(t, e, a, s)) ? Ik(t, e, a, h, o, m, g) : (e === "true-value" ? t._trueValue = a : e === "false-value" && (t._falseValue = a), Mk(t, e, a, s));
};
function zk(t, e, n, a) {
  return a ? !!(e === "innerHTML" || e === "textContent" || e in t && fw.test(e) && yr(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || fw.test(e) && Hn(n) ? !1 : e in t;
}
const fu = "transition", jp = "animation", bv = (t, { slots: e }) => $S(vS, Fk(t), e);
bv.displayName = "Transition";
const WS = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
bv.props = /* @__PURE__ */ Wn({}, vS.props, WS);
const Sc = (t, e = []) => {
  er(t) ? t.forEach((n) => n(...e)) : t && t(...e);
}, pw = (t) => t ? er(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;
function Fk(t) {
  const e = {};
  for (const qe in t)
    qe in WS || (e[qe] = t[qe]);
  if (t.css === !1)
    return e;
  const { name: n = "v", type: a, duration: s, enterFromClass: h = `${n}-enter-from`, enterActiveClass: o = `${n}-enter-active`, enterToClass: m = `${n}-enter-to`, appearFromClass: g = h, appearActiveClass: b = o, appearToClass: T = m, leaveFromClass: M = `${n}-leave-from`, leaveActiveClass: I = `${n}-leave-active`, leaveToClass: P = `${n}-leave-to` } = t, z = Bk(s), V = z && z[0], W = z && z[1], { onBeforeEnter: X, onEnter: K, onEnterCancelled: se, onLeave: pe, onLeaveCancelled: xe, onBeforeAppear: Fe = X, onAppear: ze = K, onAppearCancelled: Pe = se } = e, Se = (qe, at, be) => {
    Tc(qe, at ? T : m), Tc(qe, at ? b : o), be && be();
  }, Ie = (qe, at) => {
    qe._isLeaving = !1, Tc(qe, M), Tc(qe, P), Tc(qe, I), at && at();
  }, Je = (qe) => (at, be) => {
    const Ke = qe ? ze : K, ht = () => Se(at, qe, be);
    Sc(Ke, [at, ht]), dw(() => {
      Tc(at, qe ? g : h), pu(at, qe ? T : m), pw(Ke) || mw(at, a, V, ht);
    });
  };
  return Wn(e, {
    onBeforeEnter(qe) {
      Sc(X, [qe]), pu(qe, h), pu(qe, o);
    },
    onBeforeAppear(qe) {
      Sc(Fe, [qe]), pu(qe, g), pu(qe, b);
    },
    onEnter: Je(!1),
    onAppear: Je(!0),
    onLeave(qe, at) {
      qe._isLeaving = !0;
      const be = () => Ie(qe, at);
      pu(qe, M), jk(), pu(qe, I), dw(() => {
        !qe._isLeaving || (Tc(qe, M), pu(qe, P), pw(pe) || mw(qe, a, W, be));
      }), Sc(pe, [qe, be]);
    },
    onEnterCancelled(qe) {
      Se(qe, !1), Sc(se, [qe]);
    },
    onAppearCancelled(qe) {
      Se(qe, !0), Sc(Pe, [qe]);
    },
    onLeaveCancelled(qe) {
      Ie(qe), Sc(xe, [qe]);
    }
  });
}
function Bk(t) {
  if (t == null)
    return null;
  if (fn(t))
    return [D_(t.enter), D_(t.leave)];
  {
    const e = D_(t);
    return [e, e];
  }
}
function D_(t) {
  const e = _0(t);
  return process.env.NODE_ENV !== "production" && BA(e, "<transition> explicit duration"), e;
}
function pu(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.add(n)), (t._vtc || (t._vtc = /* @__PURE__ */ new Set())).add(e);
}
function Tc(t, e) {
  e.split(/\s+/).forEach((a) => a && t.classList.remove(a));
  const { _vtc: n } = t;
  n && (n.delete(e), n.size || (t._vtc = void 0));
}
function dw(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let Vk = 0;
function mw(t, e, n, a) {
  const s = t._endId = ++Vk, h = () => {
    s === t._endId && a();
  };
  if (n)
    return setTimeout(h, n);
  const { type: o, timeout: m, propCount: g } = Uk(t, e);
  if (!o)
    return a();
  const b = o + "end";
  let T = 0;
  const M = () => {
    t.removeEventListener(b, I), h();
  }, I = (P) => {
    P.target === t && ++T >= g && M();
  };
  setTimeout(() => {
    T < g && M();
  }, m + 1), t.addEventListener(b, I);
}
function Uk(t, e) {
  const n = window.getComputedStyle(t), a = (z) => (n[z] || "").split(", "), s = a(`${fu}Delay`), h = a(`${fu}Duration`), o = yw(s, h), m = a(`${jp}Delay`), g = a(`${jp}Duration`), b = yw(m, g);
  let T = null, M = 0, I = 0;
  e === fu ? o > 0 && (T = fu, M = o, I = h.length) : e === jp ? b > 0 && (T = jp, M = b, I = g.length) : (M = Math.max(o, b), T = M > 0 ? o > b ? fu : jp : null, I = T ? T === fu ? h.length : g.length : 0);
  const P = T === fu && /\b(transform|all)(,|$)/.test(a(`${fu}Property`).toString());
  return {
    type: T,
    timeout: M,
    propCount: I,
    hasTransform: P
  };
}
function yw(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((n, a) => gw(n) + gw(t[a])));
}
function gw(t) {
  return Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function jk() {
  return document.body.offsetHeight;
}
const Gk = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Us = (t, e) => (n) => {
  if (!("key" in n))
    return;
  const a = ta(n.key);
  if (e.some((s) => s === a || Gk[s] === a))
    return t(n);
}, qk = /* @__PURE__ */ Wn({ patchProp: Rk }, bk);
let vw;
function HS() {
  return vw || (vw = YP(qk));
}
const _w = (...t) => {
  HS().render(...t);
}, $k = (...t) => {
  const e = HS().createApp(...t);
  process.env.NODE_ENV !== "production" && (Wk(e), Hk(e));
  const { mount: n } = e;
  return e.mount = (a) => {
    const s = Zk(a);
    if (!s)
      return;
    const h = e._component;
    !yr(h) && !h.render && !h.template && (h.template = s.innerHTML), s.innerHTML = "";
    const o = n(s, !1, s instanceof SVGElement);
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), o;
  }, e;
};
function Wk(t) {
  Object.defineProperty(t.config, "isNativeTag", {
    value: (e) => GC(e) || qC(e),
    writable: !1
  });
}
function Hk(t) {
  {
    const e = t.config.isCustomElement;
    Object.defineProperty(t.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        lt("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.");
      }
    });
    const n = t.config.compilerOptions, a = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom';
    Object.defineProperty(t.config, "compilerOptions", {
      get() {
        return lt(a), n;
      },
      set() {
        lt(a);
      }
    });
  }
}
function Zk(t) {
  if (Hn(t)) {
    const e = document.querySelector(t);
    return process.env.NODE_ENV !== "production" && !e && lt(`Failed to mount app: mount target selector "${t}" returned null.`), e;
  }
  return process.env.NODE_ENV !== "production" && window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && lt('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'), t;
}
function Xk() {
  _k();
}
process.env.NODE_ENV !== "production" && Xk();
/*! @license DOMPurify 2.4.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.5/LICENSE */
function Eu(t) {
  return Eu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Eu(t);
}
function V0(t, e) {
  return V0 = Object.setPrototypeOf || function(a, s) {
    return a.__proto__ = s, a;
  }, V0(t, e);
}
function Kk() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Qy(t, e, n) {
  return Kk() ? Qy = Reflect.construct : Qy = function(s, h, o) {
    var m = [null];
    m.push.apply(m, h);
    var g = Function.bind.apply(s, m), b = new g();
    return o && V0(b, o.prototype), b;
  }, Qy.apply(null, arguments);
}
function Qa(t) {
  return Yk(t) || Jk(t) || Qk(t) || eL();
}
function Yk(t) {
  if (Array.isArray(t))
    return U0(t);
}
function Jk(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function Qk(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return U0(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set")
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return U0(t, e);
  }
}
function U0(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, a = new Array(e); n < e; n++)
    a[n] = t[n];
  return a;
}
function eL() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var tL = Object.hasOwnProperty, xw = Object.setPrototypeOf, rL = Object.isFrozen, nL = Object.getPrototypeOf, iL = Object.getOwnPropertyDescriptor, Vo = Object.freeze, cs = Object.seal, oL = Object.create, ZS = typeof Reflect < "u" && Reflect, Ig = ZS.apply, j0 = ZS.construct;
Ig || (Ig = function(e, n, a) {
  return e.apply(n, a);
});
Vo || (Vo = function(e) {
  return e;
});
cs || (cs = function(e) {
  return e;
});
j0 || (j0 = function(e, n) {
  return Qy(e, Qa(n));
});
var aL = za(Array.prototype.forEach), bw = za(Array.prototype.pop), Gp = za(Array.prototype.push), eg = za(String.prototype.toLowerCase), N_ = za(String.prototype.toString), sL = za(String.prototype.match), Za = za(String.prototype.replace), lL = za(String.prototype.indexOf), uL = za(String.prototype.trim), Ao = za(RegExp.prototype.test), R_ = cL(TypeError);
function za(t) {
  return function(e) {
    for (var n = arguments.length, a = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      a[s - 1] = arguments[s];
    return Ig(t, e, a);
  };
}
function cL(t) {
  return function() {
    for (var e = arguments.length, n = new Array(e), a = 0; a < e; a++)
      n[a] = arguments[a];
    return j0(t, n);
  };
}
function Ar(t, e, n) {
  n = n || eg, xw && xw(t, null);
  for (var a = e.length; a--; ) {
    var s = e[a];
    if (typeof s == "string") {
      var h = n(s);
      h !== s && (rL(e) || (e[a] = h), s = h);
    }
    t[s] = !0;
  }
  return t;
}
function Mc(t) {
  var e = oL(null), n;
  for (n in t)
    Ig(tL, t, [n]) === !0 && (e[n] = t[n]);
  return e;
}
function wy(t, e) {
  for (; t !== null; ) {
    var n = iL(t, e);
    if (n) {
      if (n.get)
        return za(n.get);
      if (typeof n.value == "function")
        return za(n.value);
    }
    t = nL(t);
  }
  function a(s) {
    return console.warn("fallback value for", s), null;
  }
  return a;
}
var ww = Vo(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), z_ = Vo(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), F_ = Vo(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), hL = Vo(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), B_ = Vo(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), fL = Vo(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Ew = Vo(["#text"]), Sw = Vo(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), V_ = Vo(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Tw = Vo(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Ey = Vo(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), pL = cs(/\{\{[\w\W]*|[\w\W]*\}\}/gm), dL = cs(/<%[\w\W]*|[\w\W]*%>/gm), mL = cs(/\${[\w\W]*}/gm), yL = cs(/^data-[\-\w.\u00B7-\uFFFF]/), gL = cs(/^aria-[\-\w]+$/), vL = cs(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
), _L = cs(/^(?:\w+script|data):/i), xL = cs(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
), bL = cs(/^html$/i), wL = function() {
  return typeof window > "u" ? null : window;
}, EL = function(e, n) {
  if (Eu(e) !== "object" || typeof e.createPolicy != "function")
    return null;
  var a = null, s = "data-tt-policy-suffix";
  n.currentScript && n.currentScript.hasAttribute(s) && (a = n.currentScript.getAttribute(s));
  var h = "dompurify" + (a ? "#" + a : "");
  try {
    return e.createPolicy(h, {
      createHTML: function(m) {
        return m;
      },
      createScriptURL: function(m) {
        return m;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + h + " could not be created."), null;
  }
};
function XS() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : wL(), e = function(he) {
    return XS(he);
  };
  if (e.version = "2.4.5", e.removed = [], !t || !t.document || t.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var n = t.document, a = t.document, s = t.DocumentFragment, h = t.HTMLTemplateElement, o = t.Node, m = t.Element, g = t.NodeFilter, b = t.NamedNodeMap, T = b === void 0 ? t.NamedNodeMap || t.MozNamedAttrMap : b, M = t.HTMLFormElement, I = t.DOMParser, P = t.trustedTypes, z = m.prototype, V = wy(z, "cloneNode"), W = wy(z, "nextSibling"), X = wy(z, "childNodes"), K = wy(z, "parentNode");
  if (typeof h == "function") {
    var se = a.createElement("template");
    se.content && se.content.ownerDocument && (a = se.content.ownerDocument);
  }
  var pe = EL(P, n), xe = pe ? pe.createHTML("") : "", Fe = a, ze = Fe.implementation, Pe = Fe.createNodeIterator, Se = Fe.createDocumentFragment, Ie = Fe.getElementsByTagName, Je = n.importNode, qe = {};
  try {
    qe = Mc(a).documentMode ? a.documentMode : {};
  } catch {
  }
  var at = {};
  e.isSupported = typeof K == "function" && ze && typeof ze.createHTMLDocument < "u" && qe !== 9;
  var be = pL, Ke = dL, ht = mL, vt = yL, Pt = gL, tr = _L, Pn = xL, Rr = vL, pr = null, Zn = Ar({}, [].concat(Qa(ww), Qa(z_), Qa(F_), Qa(B_), Qa(Ew))), zr = null, Fi = Ar({}, [].concat(Qa(Sw), Qa(V_), Qa(Tw), Qa(Ey))), qr = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), kr = null, Vn = null, Er = !0, En = !0, oi = !1, Un = !0, Y = !1, ye = !1, Ne = !1, $e = !1, We = !1, rt = !1, mt = !1, et = !0, ut = !1, Qe = "user-content-", It = !0, bt = !1, kt = {}, Ut = null, dr = Ar({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Vr = null, Lr = Ar({}, ["audio", "video", "img", "source", "image", "track"]), Jr = null, Xn = Ar({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Bi = "http://www.w3.org/1998/Math/MathML", so = "http://www.w3.org/2000/svg", Kn = "http://www.w3.org/1999/xhtml", ki = Kn, Sn = !1, ai = null, Fa = Ar({}, [Bi, so, Kn], N_), Uo, Ba = ["application/xhtml+xml", "text/html"], na = "text/html", an, So = null, rl = a.createElement("form"), bn = function(he) {
    return he instanceof RegExp || he instanceof Function;
  }, N = function(he) {
    So && So === he || ((!he || Eu(he) !== "object") && (he = {}), he = Mc(he), Uo = Ba.indexOf(he.PARSER_MEDIA_TYPE) === -1 ? Uo = na : Uo = he.PARSER_MEDIA_TYPE, an = Uo === "application/xhtml+xml" ? N_ : eg, pr = "ALLOWED_TAGS" in he ? Ar({}, he.ALLOWED_TAGS, an) : Zn, zr = "ALLOWED_ATTR" in he ? Ar({}, he.ALLOWED_ATTR, an) : Fi, ai = "ALLOWED_NAMESPACES" in he ? Ar({}, he.ALLOWED_NAMESPACES, N_) : Fa, Jr = "ADD_URI_SAFE_ATTR" in he ? Ar(
      Mc(Xn),
      he.ADD_URI_SAFE_ATTR,
      an
    ) : Xn, Vr = "ADD_DATA_URI_TAGS" in he ? Ar(
      Mc(Lr),
      he.ADD_DATA_URI_TAGS,
      an
    ) : Lr, Ut = "FORBID_CONTENTS" in he ? Ar({}, he.FORBID_CONTENTS, an) : dr, kr = "FORBID_TAGS" in he ? Ar({}, he.FORBID_TAGS, an) : {}, Vn = "FORBID_ATTR" in he ? Ar({}, he.FORBID_ATTR, an) : {}, kt = "USE_PROFILES" in he ? he.USE_PROFILES : !1, Er = he.ALLOW_ARIA_ATTR !== !1, En = he.ALLOW_DATA_ATTR !== !1, oi = he.ALLOW_UNKNOWN_PROTOCOLS || !1, Un = he.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Y = he.SAFE_FOR_TEMPLATES || !1, ye = he.WHOLE_DOCUMENT || !1, We = he.RETURN_DOM || !1, rt = he.RETURN_DOM_FRAGMENT || !1, mt = he.RETURN_TRUSTED_TYPE || !1, $e = he.FORCE_BODY || !1, et = he.SANITIZE_DOM !== !1, ut = he.SANITIZE_NAMED_PROPS || !1, It = he.KEEP_CONTENT !== !1, bt = he.IN_PLACE || !1, Rr = he.ALLOWED_URI_REGEXP || Rr, ki = he.NAMESPACE || Kn, qr = he.CUSTOM_ELEMENT_HANDLING || {}, he.CUSTOM_ELEMENT_HANDLING && bn(he.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (qr.tagNameCheck = he.CUSTOM_ELEMENT_HANDLING.tagNameCheck), he.CUSTOM_ELEMENT_HANDLING && bn(he.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (qr.attributeNameCheck = he.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), he.CUSTOM_ELEMENT_HANDLING && typeof he.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (qr.allowCustomizedBuiltInElements = he.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Y && (En = !1), rt && (We = !0), kt && (pr = Ar({}, Qa(Ew)), zr = [], kt.html === !0 && (Ar(pr, ww), Ar(zr, Sw)), kt.svg === !0 && (Ar(pr, z_), Ar(zr, V_), Ar(zr, Ey)), kt.svgFilters === !0 && (Ar(pr, F_), Ar(zr, V_), Ar(zr, Ey)), kt.mathMl === !0 && (Ar(pr, B_), Ar(zr, Tw), Ar(zr, Ey))), he.ADD_TAGS && (pr === Zn && (pr = Mc(pr)), Ar(pr, he.ADD_TAGS, an)), he.ADD_ATTR && (zr === Fi && (zr = Mc(zr)), Ar(zr, he.ADD_ATTR, an)), he.ADD_URI_SAFE_ATTR && Ar(Jr, he.ADD_URI_SAFE_ATTR, an), he.FORBID_CONTENTS && (Ut === dr && (Ut = Mc(Ut)), Ar(Ut, he.FORBID_CONTENTS, an)), It && (pr["#text"] = !0), ye && Ar(pr, ["html", "head", "body"]), pr.table && (Ar(pr, ["tbody"]), delete kr.tbody), Vo && Vo(he), So = he);
  }, F = Ar({}, ["mi", "mo", "mn", "ms", "mtext"]), U = Ar({}, ["foreignobject", "desc", "title", "annotation-xml"]), Z = Ar({}, ["title", "style", "font", "a", "script"]), ee = Ar({}, z_);
  Ar(ee, F_), Ar(ee, hL);
  var fe = Ar({}, B_);
  Ar(fe, fL);
  var de = function(he) {
    var Ee = K(he);
    (!Ee || !Ee.tagName) && (Ee = {
      namespaceURI: ki,
      tagName: "template"
    });
    var He = eg(he.tagName), jt = eg(Ee.tagName);
    return ai[he.namespaceURI] ? he.namespaceURI === so ? Ee.namespaceURI === Kn ? He === "svg" : Ee.namespaceURI === Bi ? He === "svg" && (jt === "annotation-xml" || F[jt]) : Boolean(ee[He]) : he.namespaceURI === Bi ? Ee.namespaceURI === Kn ? He === "math" : Ee.namespaceURI === so ? He === "math" && U[jt] : Boolean(fe[He]) : he.namespaceURI === Kn ? Ee.namespaceURI === so && !U[jt] || Ee.namespaceURI === Bi && !F[jt] ? !1 : !fe[He] && (Z[He] || !ee[He]) : !!(Uo === "application/xhtml+xml" && ai[he.namespaceURI]) : !1;
  }, G = function(he) {
    Gp(e.removed, {
      element: he
    });
    try {
      he.parentNode.removeChild(he);
    } catch {
      try {
        he.outerHTML = xe;
      } catch {
        he.remove();
      }
    }
  }, ie = function(he, Ee) {
    try {
      Gp(e.removed, {
        attribute: Ee.getAttributeNode(he),
        from: Ee
      });
    } catch {
      Gp(e.removed, {
        attribute: null,
        from: Ee
      });
    }
    if (Ee.removeAttribute(he), he === "is" && !zr[he])
      if (We || rt)
        try {
          G(Ee);
        } catch {
        }
      else
        try {
          Ee.setAttribute(he, "");
        } catch {
        }
  }, ve = function(he) {
    var Ee, He;
    if ($e)
      he = "<remove></remove>" + he;
    else {
      var jt = sL(he, /^[\r\n\t ]+/);
      He = jt && jt[0];
    }
    Uo === "application/xhtml+xml" && ki === Kn && (he = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + he + "</body></html>");
    var Wt = pe ? pe.createHTML(he) : he;
    if (ki === Kn)
      try {
        Ee = new I().parseFromString(Wt, Uo);
      } catch {
      }
    if (!Ee || !Ee.documentElement) {
      Ee = ze.createDocument(ki, "template", null);
      try {
        Ee.documentElement.innerHTML = Sn ? xe : Wt;
      } catch {
      }
    }
    var Jt = Ee.body || Ee.documentElement;
    return he && He && Jt.insertBefore(a.createTextNode(He), Jt.childNodes[0] || null), ki === Kn ? Ie.call(Ee, ye ? "html" : "body")[0] : ye ? Ee.documentElement : Jt;
  }, Ge = function(he) {
    return Pe.call(
      he.ownerDocument || he,
      he,
      g.SHOW_ELEMENT | g.SHOW_COMMENT | g.SHOW_TEXT,
      null,
      !1
    );
  }, Ze = function(he) {
    return he instanceof M && (typeof he.nodeName != "string" || typeof he.textContent != "string" || typeof he.removeChild != "function" || !(he.attributes instanceof T) || typeof he.removeAttribute != "function" || typeof he.setAttribute != "function" || typeof he.namespaceURI != "string" || typeof he.insertBefore != "function" || typeof he.hasChildNodes != "function");
  }, Ce = function(he) {
    return Eu(o) === "object" ? he instanceof o : he && Eu(he) === "object" && typeof he.nodeType == "number" && typeof he.nodeName == "string";
  }, Ue = function(he, Ee, He) {
    !at[he] || aL(at[he], function(jt) {
      jt.call(e, Ee, He, So);
    });
  }, Et = function(he) {
    var Ee;
    if (Ue("beforeSanitizeElements", he, null), Ze(he) || Ao(/[\u0080-\uFFFF]/, he.nodeName))
      return G(he), !0;
    var He = an(he.nodeName);
    if (Ue("uponSanitizeElement", he, {
      tagName: He,
      allowedTags: pr
    }), he.hasChildNodes() && !Ce(he.firstElementChild) && (!Ce(he.content) || !Ce(he.content.firstElementChild)) && Ao(/<[/\w]/g, he.innerHTML) && Ao(/<[/\w]/g, he.textContent) || He === "select" && Ao(/<template/i, he.innerHTML))
      return G(he), !0;
    if (!pr[He] || kr[He]) {
      if (!kr[He] && Le(He) && (qr.tagNameCheck instanceof RegExp && Ao(qr.tagNameCheck, He) || qr.tagNameCheck instanceof Function && qr.tagNameCheck(He)))
        return !1;
      if (It && !Ut[He]) {
        var jt = K(he) || he.parentNode, Wt = X(he) || he.childNodes;
        if (Wt && jt)
          for (var Jt = Wt.length, Zt = Jt - 1; Zt >= 0; --Zt)
            jt.insertBefore(V(Wt[Zt], !0), W(he));
      }
      return G(he), !0;
    }
    return he instanceof m && !de(he) || (He === "noscript" || He === "noembed") && Ao(/<\/no(script|embed)/i, he.innerHTML) ? (G(he), !0) : (Y && he.nodeType === 3 && (Ee = he.textContent, Ee = Za(Ee, be, " "), Ee = Za(Ee, Ke, " "), Ee = Za(Ee, ht, " "), he.textContent !== Ee && (Gp(e.removed, {
      element: he.cloneNode()
    }), he.textContent = Ee)), Ue("afterSanitizeElements", he, null), !1);
  }, _t = function(he, Ee, He) {
    if (et && (Ee === "id" || Ee === "name") && (He in a || He in rl))
      return !1;
    if (!(En && !Vn[Ee] && Ao(vt, Ee))) {
      if (!(Er && Ao(Pt, Ee))) {
        if (!zr[Ee] || Vn[Ee]) {
          if (!(Le(he) && (qr.tagNameCheck instanceof RegExp && Ao(qr.tagNameCheck, he) || qr.tagNameCheck instanceof Function && qr.tagNameCheck(he)) && (qr.attributeNameCheck instanceof RegExp && Ao(qr.attributeNameCheck, Ee) || qr.attributeNameCheck instanceof Function && qr.attributeNameCheck(Ee)) || Ee === "is" && qr.allowCustomizedBuiltInElements && (qr.tagNameCheck instanceof RegExp && Ao(qr.tagNameCheck, He) || qr.tagNameCheck instanceof Function && qr.tagNameCheck(He))))
            return !1;
        } else if (!Jr[Ee]) {
          if (!Ao(Rr, Za(He, Pn, ""))) {
            if (!((Ee === "src" || Ee === "xlink:href" || Ee === "href") && he !== "script" && lL(He, "data:") === 0 && Vr[he])) {
              if (!(oi && !Ao(tr, Za(He, Pn, "")))) {
                if (He)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Le = function(he) {
    return he.indexOf("-") > 0;
  }, pt = function(he) {
    var Ee, He, jt, Wt;
    Ue("beforeSanitizeAttributes", he, null);
    var Jt = he.attributes;
    if (!!Jt) {
      var Zt = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: zr
      };
      for (Wt = Jt.length; Wt--; ) {
        Ee = Jt[Wt];
        var Yn = Ee, Qt = Yn.name, pn = Yn.namespaceURI;
        if (He = Qt === "value" ? Ee.value : uL(Ee.value), jt = an(Qt), Zt.attrName = jt, Zt.attrValue = He, Zt.keepAttr = !0, Zt.forceKeepAttr = void 0, Ue("uponSanitizeAttribute", he, Zt), He = Zt.attrValue, !Zt.forceKeepAttr && (ie(Qt, he), !!Zt.keepAttr)) {
          if (!Un && Ao(/\/>/i, He)) {
            ie(Qt, he);
            continue;
          }
          Y && (He = Za(He, be, " "), He = Za(He, Ke, " "), He = Za(He, ht, " "));
          var Ur = an(he.nodeName);
          if (!!_t(Ur, jt, He)) {
            if (ut && (jt === "id" || jt === "name") && (ie(Qt, he), He = Qe + He), pe && Eu(P) === "object" && typeof P.getAttributeType == "function" && !pn)
              switch (P.getAttributeType(Ur, jt)) {
                case "TrustedHTML":
                  He = pe.createHTML(He);
                  break;
                case "TrustedScriptURL":
                  He = pe.createScriptURL(He);
                  break;
              }
            try {
              pn ? he.setAttributeNS(pn, Qt, He) : he.setAttribute(Qt, He), bw(e.removed);
            } catch {
            }
          }
        }
      }
      Ue("afterSanitizeAttributes", he, null);
    }
  }, st = function De(he) {
    var Ee, He = Ge(he);
    for (Ue("beforeSanitizeShadowDOM", he, null); Ee = He.nextNode(); )
      Ue("uponSanitizeShadowNode", Ee, null), !Et(Ee) && (Ee.content instanceof s && De(Ee.content), pt(Ee));
    Ue("afterSanitizeShadowDOM", he, null);
  };
  return e.sanitize = function(De) {
    var he = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Ee, He, jt, Wt, Jt;
    if (Sn = !De, Sn && (De = "<!-->"), typeof De != "string" && !Ce(De)) {
      if (typeof De.toString != "function")
        throw R_("toString is not a function");
      if (De = De.toString(), typeof De != "string")
        throw R_("dirty is not a string, aborting");
    }
    if (!e.isSupported) {
      if (Eu(t.toStaticHTML) === "object" || typeof t.toStaticHTML == "function") {
        if (typeof De == "string")
          return t.toStaticHTML(De);
        if (Ce(De))
          return t.toStaticHTML(De.outerHTML);
      }
      return De;
    }
    if (Ne || N(he), e.removed = [], typeof De == "string" && (bt = !1), bt) {
      if (De.nodeName) {
        var Zt = an(De.nodeName);
        if (!pr[Zt] || kr[Zt])
          throw R_("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (De instanceof o)
      Ee = ve("<!---->"), He = Ee.ownerDocument.importNode(De, !0), He.nodeType === 1 && He.nodeName === "BODY" || He.nodeName === "HTML" ? Ee = He : Ee.appendChild(He);
    else {
      if (!We && !Y && !ye && De.indexOf("<") === -1)
        return pe && mt ? pe.createHTML(De) : De;
      if (Ee = ve(De), !Ee)
        return We ? null : mt ? xe : "";
    }
    Ee && $e && G(Ee.firstChild);
    for (var Yn = Ge(bt ? De : Ee); jt = Yn.nextNode(); )
      jt.nodeType === 3 && jt === Wt || Et(jt) || (jt.content instanceof s && st(jt.content), pt(jt), Wt = jt);
    if (Wt = null, bt)
      return De;
    if (We) {
      if (rt)
        for (Jt = Se.call(Ee.ownerDocument); Ee.firstChild; )
          Jt.appendChild(Ee.firstChild);
      else
        Jt = Ee;
      return (zr.shadowroot || zr.shadowrootmod) && (Jt = Je.call(n, Jt, !0)), Jt;
    }
    var Qt = ye ? Ee.outerHTML : Ee.innerHTML;
    return ye && pr["!doctype"] && Ee.ownerDocument && Ee.ownerDocument.doctype && Ee.ownerDocument.doctype.name && Ao(bL, Ee.ownerDocument.doctype.name) && (Qt = "<!DOCTYPE " + Ee.ownerDocument.doctype.name + `>
` + Qt), Y && (Qt = Za(Qt, be, " "), Qt = Za(Qt, Ke, " "), Qt = Za(Qt, ht, " ")), pe && mt ? pe.createHTML(Qt) : Qt;
  }, e.setConfig = function(De) {
    N(De), Ne = !0;
  }, e.clearConfig = function() {
    So = null, Ne = !1;
  }, e.isValidAttribute = function(De, he, Ee) {
    So || N({});
    var He = an(De), jt = an(he);
    return _t(He, jt, Ee);
  }, e.addHook = function(De, he) {
    typeof he == "function" && (at[De] = at[De] || [], Gp(at[De], he));
  }, e.removeHook = function(De) {
    if (at[De])
      return bw(at[De]);
  }, e.removeHooks = function(De) {
    at[De] && (at[De] = []);
  }, e.removeAllHooks = function() {
    at = {};
  }, e;
}
var SL = XS(), KS = !1;
function Sy(t, e, n) {
  return Array.isArray(t) ? (t.length = Math.max(t.length, e), t.splice(e, 1, n), n) : (t[e] = n, n);
}
function U_(t, e) {
  if (Array.isArray(t)) {
    t.splice(e, 1);
    return;
  }
  delete t[e];
}
function TL(t, e) {
  var s;
  const n = (s = t.hooks) != null ? s : {};
  let a;
  for (a in n) {
    const h = n[a];
    h !== void 0 && e.addHook(a, h);
  }
}
function YS() {
  return SL();
}
function ML(t = {}, e = YS) {
  const n = e();
  TL(t, n);
  const a = function(s, h) {
    var M, I;
    const o = h.value;
    if (h.oldValue === o)
      return;
    const m = `${o}`, g = h.arg, b = t.namedConfigurations, T = (M = t.default) != null ? M : {};
    if (b && g !== void 0) {
      s.innerHTML = n.sanitize(
        m,
        (I = b[g]) != null ? I : T
      );
      return;
    }
    s.innerHTML = n.sanitize(
      m,
      T
    );
  };
  return {
    mounted: a,
    updated: a
  };
}
const IL = {
  install(t, e = {}, n = YS) {
    t.directive(
      "dompurify-html",
      ML(e, n)
    );
  }
};
function OL() {
  return JS().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function JS() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
}
const CL = typeof Proxy == "function", AL = "devtools-plugin:setup", PL = "plugin:settings:set";
let ef, G0;
function kL() {
  var t;
  return ef !== void 0 || (typeof window < "u" && window.performance ? (ef = !0, G0 = window.performance) : typeof global < "u" && ((t = global.perf_hooks) === null || t === void 0 ? void 0 : t.performance) ? (ef = !0, G0 = global.perf_hooks.performance) : ef = !1), ef;
}
function LL() {
  return kL() ? G0.now() : Date.now();
}
class DL {
  constructor(e, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e, this.hook = n;
    const a = {};
    if (e.settings)
      for (const o in e.settings) {
        const m = e.settings[o];
        a[o] = m.defaultValue;
      }
    const s = `__vue-devtools-plugin-settings__${e.id}`;
    let h = Object.assign({}, a);
    try {
      const o = localStorage.getItem(s), m = JSON.parse(o);
      Object.assign(h, m);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return h;
      },
      setSettings(o) {
        try {
          localStorage.setItem(s, JSON.stringify(o));
        } catch {
        }
        h = o;
      },
      now() {
        return LL();
      }
    }, n && n.on(PL, (o, m) => {
      o === this.plugin.id && this.fallbacks.setSettings(m);
    }), this.proxiedOn = new Proxy({}, {
      get: (o, m) => this.target ? this.target.on[m] : (...g) => {
        this.onQueue.push({
          method: m,
          args: g
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (o, m) => this.target ? this.target[m] : m === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(m) ? (...g) => (this.targetQueue.push({
        method: m,
        args: g,
        resolve: () => {
        }
      }), this.fallbacks[m](...g)) : (...g) => new Promise((b) => {
        this.targetQueue.push({
          method: m,
          args: g,
          resolve: b
        });
      })
    });
  }
  async setRealTarget(e) {
    this.target = e;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function QS(t, e) {
  const n = t, a = JS(), s = OL(), h = CL && n.enableEarlyProxy;
  if (s && (a.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !h))
    s.emit(AL, t, e);
  else {
    const o = h ? new DL(n, s) : null;
    (a.__VUE_DEVTOOLS_PLUGINS__ = a.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: e,
      proxy: o
    }), o && e(o.proxiedTarget);
  }
}
/*!
  * pinia v2.0.33
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
let Jp;
const Ad = (t) => Jp = t, eT = process.env.NODE_ENV !== "production" ? Symbol("pinia") : Symbol();
function Yc(t) {
  return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
}
var $s;
(function(t) {
  t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
})($s || ($s = {}));
const wv = typeof window < "u", pd = (process.env.NODE_ENV !== "production" || !1) && process.env.NODE_ENV !== "test" && wv, Mw = /* @__PURE__ */ (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : { HTMLElement: null })();
function NL(t, { autoBom: e = !1 } = {}) {
  return e && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], { type: t.type }) : t;
}
function z1(t, e, n) {
  const a = new XMLHttpRequest();
  a.open("GET", t), a.responseType = "blob", a.onload = function() {
    nT(a.response, e, n);
  }, a.onerror = function() {
    console.error("could not download file");
  }, a.send();
}
function tT(t) {
  const e = new XMLHttpRequest();
  e.open("HEAD", t, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function tg(t) {
  try {
    t.dispatchEvent(new MouseEvent("click"));
  } catch {
    const n = document.createEvent("MouseEvents");
    n.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), t.dispatchEvent(n);
  }
}
const rg = typeof navigator == "object" ? navigator : { userAgent: "" }, rT = /* @__PURE__ */ (() => /Macintosh/.test(rg.userAgent) && /AppleWebKit/.test(rg.userAgent) && !/Safari/.test(rg.userAgent))(), nT = wv ? typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !rT ? RL : "msSaveOrOpenBlob" in rg ? zL : FL : () => {
};
function RL(t, e = "download", n) {
  const a = document.createElement("a");
  a.download = e, a.rel = "noopener", typeof t == "string" ? (a.href = t, a.origin !== location.origin ? tT(a.href) ? z1(t, e, n) : (a.target = "_blank", tg(a)) : tg(a)) : (a.href = URL.createObjectURL(t), setTimeout(function() {
    URL.revokeObjectURL(a.href);
  }, 4e4), setTimeout(function() {
    tg(a);
  }, 0));
}
function zL(t, e = "download", n) {
  if (typeof t == "string")
    if (tT(t))
      z1(t, e, n);
    else {
      const a = document.createElement("a");
      a.href = t, a.target = "_blank", setTimeout(function() {
        tg(a);
      });
    }
  else
    navigator.msSaveOrOpenBlob(NL(t, n), e);
}
function FL(t, e, n, a) {
  if (a = a || open("", "_blank"), a && (a.document.title = a.document.body.innerText = "downloading..."), typeof t == "string")
    return z1(t, e, n);
  const s = t.type === "application/octet-stream", h = /constructor/i.test(String(Mw.HTMLElement)) || "safari" in Mw, o = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((o || s && h || rT) && typeof FileReader < "u") {
    const m = new FileReader();
    m.onloadend = function() {
      let g = m.result;
      if (typeof g != "string")
        throw a = null, new Error("Wrong reader.result type");
      g = o ? g : g.replace(/^data:[^;]*;/, "data:attachment/file;"), a ? a.location.href = g : location.assign(g), a = null;
    }, m.readAsDataURL(t);
  } else {
    const m = URL.createObjectURL(t);
    a ? a.location.assign(m) : location.href = m, a = null, setTimeout(function() {
      URL.revokeObjectURL(m);
    }, 4e4);
  }
}
function Zi(t, e) {
  const n = "\u{1F34D} " + t;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(n, e) : e === "error" ? console.error(n) : e === "warn" ? console.warn(n) : console.log(n);
}
function F1(t) {
  return "_a" in t && "install" in t;
}
function iT() {
  if (!("clipboard" in navigator))
    return Zi("Your browser doesn't support the Clipboard API", "error"), !0;
}
function oT(t) {
  return t instanceof Error && t.message.toLowerCase().includes("document is not focused") ? (Zi('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) : !1;
}
async function BL(t) {
  if (!iT())
    try {
      await navigator.clipboard.writeText(JSON.stringify(t.state.value)), Zi("Global state copied to clipboard.");
    } catch (e) {
      if (oT(e))
        return;
      Zi("Failed to serialize the state. Check the console for more details.", "error"), console.error(e);
    }
}
async function VL(t) {
  if (!iT())
    try {
      t.state.value = JSON.parse(await navigator.clipboard.readText()), Zi("Global state pasted from clipboard.");
    } catch (e) {
      if (oT(e))
        return;
      Zi("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(e);
    }
}
async function UL(t) {
  try {
    nT(new Blob([JSON.stringify(t.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (e) {
    Zi("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
let Ol;
function jL() {
  Ol || (Ol = document.createElement("input"), Ol.type = "file", Ol.accept = ".json");
  function t() {
    return new Promise((e, n) => {
      Ol.onchange = async () => {
        const a = Ol.files;
        if (!a)
          return e(null);
        const s = a.item(0);
        return e(s ? { text: await s.text(), file: s } : null);
      }, Ol.oncancel = () => e(null), Ol.onerror = n, Ol.click();
    });
  }
  return t;
}
async function GL(t) {
  try {
    const n = await (await jL())();
    if (!n)
      return;
    const { text: a, file: s } = n;
    t.state.value = JSON.parse(a), Zi(`Global state imported from "${s.name}".`);
  } catch (e) {
    Zi("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
function es(t) {
  return {
    _custom: {
      display: t
    }
  };
}
const aT = "\u{1F34D} Pinia (root)", q0 = "_root";
function qL(t) {
  return F1(t) ? {
    id: q0,
    label: aT
  } : {
    id: t.$id,
    label: t.$id
  };
}
function $L(t) {
  if (F1(t)) {
    const n = Array.from(t._s.keys()), a = t._s;
    return {
      state: n.map((h) => ({
        editable: !0,
        key: h,
        value: t.state.value[h]
      })),
      getters: n.filter((h) => a.get(h)._getters).map((h) => {
        const o = a.get(h);
        return {
          editable: !1,
          key: h,
          value: o._getters.reduce((m, g) => (m[g] = o[g], m), {})
        };
      })
    };
  }
  const e = {
    state: Object.keys(t.$state).map((n) => ({
      editable: !0,
      key: n,
      value: t.$state[n]
    }))
  };
  return t._getters && t._getters.length && (e.getters = t._getters.map((n) => ({
    editable: !1,
    key: n,
    value: t[n]
  }))), t._customProperties.size && (e.customProperties = Array.from(t._customProperties).map((n) => ({
    editable: !0,
    key: n,
    value: t[n]
  }))), e;
}
function WL(t) {
  return t ? Array.isArray(t) ? t.reduce((e, n) => (e.keys.push(n.key), e.operations.push(n.type), e.oldValue[n.key] = n.oldValue, e.newValue[n.key] = n.newValue, e), {
    oldValue: {},
    keys: [],
    operations: [],
    newValue: {}
  }) : {
    operation: es(t.type),
    key: es(t.key),
    oldValue: t.oldValue,
    newValue: t.newValue
  } : {};
}
function HL(t) {
  switch (t) {
    case $s.direct:
      return "mutation";
    case $s.patchFunction:
      return "$patch";
    case $s.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let df = !0;
const ng = [], Dc = "pinia:mutations", vo = "pinia", { assign: ZL } = Object, Og = (t) => "\u{1F34D} " + t;
function XL(t, e) {
  QS({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: ng,
    app: t
  }, (n) => {
    typeof n.now != "function" && Zi("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), n.addTimelineLayer({
      id: Dc,
      label: "Pinia \u{1F34D}",
      color: 15064968
    }), n.addInspector({
      id: vo,
      label: "Pinia \u{1F34D}",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            BL(e);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: async () => {
            await VL(e), n.sendInspectorTree(vo), n.sendInspectorState(vo);
          },
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            UL(e);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: async () => {
            await GL(e), n.sendInspectorTree(vo), n.sendInspectorState(vo);
          },
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: "Reset the state (option store only)",
          action: (a) => {
            const s = e._s.get(a);
            s ? s._isOptionsAPI ? (s.$reset(), Zi(`Store "${a}" reset.`)) : Zi(`Cannot reset "${a}" store because it's a setup store.`, "warn") : Zi(`Cannot reset "${a}" store because it wasn't found.`, "warn");
          }
        }
      ]
    }), n.on.inspectComponent((a, s) => {
      const h = a.componentInstance && a.componentInstance.proxy;
      if (h && h._pStores) {
        const o = a.componentInstance.proxy._pStores;
        Object.values(o).forEach((m) => {
          a.instanceData.state.push({
            type: Og(m.$id),
            key: "state",
            editable: !0,
            value: m._isOptionsAPI ? {
              _custom: {
                value: hr(m.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => m.$reset()
                  }
                ]
              }
            } : Object.keys(m.$state).reduce((g, b) => (g[b] = m.$state[b], g), {})
          }), m._getters && m._getters.length && a.instanceData.state.push({
            type: Og(m.$id),
            key: "getters",
            editable: !1,
            value: m._getters.reduce((g, b) => {
              try {
                g[b] = m[b];
              } catch (T) {
                g[b] = T;
              }
              return g;
            }, {})
          });
        });
      }
    }), n.on.getInspectorTree((a) => {
      if (a.app === t && a.inspectorId === vo) {
        let s = [e];
        s = s.concat(Array.from(e._s.values())), a.rootNodes = (a.filter ? s.filter((h) => "$id" in h ? h.$id.toLowerCase().includes(a.filter.toLowerCase()) : aT.toLowerCase().includes(a.filter.toLowerCase())) : s).map(qL);
      }
    }), n.on.getInspectorState((a) => {
      if (a.app === t && a.inspectorId === vo) {
        const s = a.nodeId === q0 ? e : e._s.get(a.nodeId);
        if (!s)
          return;
        s && (a.state = $L(s));
      }
    }), n.on.editInspectorState((a, s) => {
      if (a.app === t && a.inspectorId === vo) {
        const h = a.nodeId === q0 ? e : e._s.get(a.nodeId);
        if (!h)
          return Zi(`store "${a.nodeId}" not found`, "error");
        const { path: o } = a;
        F1(h) ? o.unshift("state") : (o.length !== 1 || !h._customProperties.has(o[0]) || o[0] in h.$state) && o.unshift("$state"), df = !1, a.set(h, o, a.state.value), df = !0;
      }
    }), n.on.editComponentState((a) => {
      if (a.type.startsWith("\u{1F34D}")) {
        const s = a.type.replace(/^\s*/, ""), h = e._s.get(s);
        if (!h)
          return Zi(`store "${s}" not found`, "error");
        const { path: o } = a;
        if (o[0] !== "state")
          return Zi(`Invalid path for store "${s}":
${o}
Only state can be modified.`);
        o[0] = "$state", df = !1, a.set(h, o, a.state.value), df = !0;
      }
    });
  });
}
function KL(t, e) {
  ng.includes(Og(e.$id)) || ng.push(Og(e.$id)), QS({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: ng,
    app: t,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: !0
      }
    }
  }, (n) => {
    const a = typeof n.now == "function" ? n.now.bind(n) : Date.now;
    e.$onAction(({ after: o, onError: m, name: g, args: b }) => {
      const T = sT++;
      n.addTimelineEvent({
        layerId: Dc,
        event: {
          time: a(),
          title: "\u{1F6EB} " + g,
          subtitle: "start",
          data: {
            store: es(e.$id),
            action: es(g),
            args: b
          },
          groupId: T
        }
      }), o((M) => {
        Bc = void 0, n.addTimelineEvent({
          layerId: Dc,
          event: {
            time: a(),
            title: "\u{1F6EC} " + g,
            subtitle: "end",
            data: {
              store: es(e.$id),
              action: es(g),
              args: b,
              result: M
            },
            groupId: T
          }
        });
      }), m((M) => {
        Bc = void 0, n.addTimelineEvent({
          layerId: Dc,
          event: {
            time: a(),
            logType: "error",
            title: "\u{1F4A5} " + g,
            subtitle: "end",
            data: {
              store: es(e.$id),
              action: es(g),
              args: b,
              error: M
            },
            groupId: T
          }
        });
      });
    }, !0), e._customProperties.forEach((o) => {
      Bn(() => ae(e[o]), (m, g) => {
        n.notifyComponentUpdate(), n.sendInspectorState(vo), df && n.addTimelineEvent({
          layerId: Dc,
          event: {
            time: a(),
            title: "Change",
            subtitle: o,
            data: {
              newValue: m,
              oldValue: g
            },
            groupId: Bc
          }
        });
      }, { deep: !0 });
    }), e.$subscribe(({ events: o, type: m }, g) => {
      if (n.notifyComponentUpdate(), n.sendInspectorState(vo), !df)
        return;
      const b = {
        time: a(),
        title: HL(m),
        data: ZL({ store: es(e.$id) }, WL(o)),
        groupId: Bc
      };
      Bc = void 0, m === $s.patchFunction ? b.subtitle = "\u2935\uFE0F" : m === $s.patchObject ? b.subtitle = "\u{1F9E9}" : o && !Array.isArray(o) && (b.subtitle = o.type), o && (b.data["rawEvent(s)"] = {
        _custom: {
          display: "DebuggerEvent",
          type: "object",
          tooltip: "raw DebuggerEvent[]",
          value: o
        }
      }), n.addTimelineEvent({
        layerId: Dc,
        event: b
      });
    }, { detached: !0, flush: "sync" });
    const s = e._hotUpdate;
    e._hotUpdate = ts((o) => {
      s(o), n.addTimelineEvent({
        layerId: Dc,
        event: {
          time: a(),
          title: "\u{1F525} " + e.$id,
          subtitle: "HMR update",
          data: {
            store: es(e.$id),
            info: es("HMR update")
          }
        }
      }), n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo);
    });
    const { $dispose: h } = e;
    e.$dispose = () => {
      h(), n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo), n.getSettings().logStoreChanges && Zi(`Disposed "${e.$id}" store \u{1F5D1}`);
    }, n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo), n.getSettings().logStoreChanges && Zi(`"${e.$id}" store installed \u{1F195}`);
  });
}
let sT = 0, Bc;
function Iw(t, e) {
  const n = e.reduce((a, s) => (a[s] = hr(t)[s], a), {});
  for (const a in n)
    t[a] = function() {
      const s = sT, h = new Proxy(t, {
        get(...o) {
          return Bc = s, Reflect.get(...o);
        },
        set(...o) {
          return Bc = s, Reflect.set(...o);
        }
      });
      return n[a].apply(h, arguments);
    };
}
function YL({ app: t, store: e, options: n }) {
  if (!e.$id.startsWith("__hot:")) {
    if (n.state && (e._isOptionsAPI = !0), typeof n.state == "function") {
      Iw(
        e,
        Object.keys(n.actions)
      );
      const a = e._hotUpdate;
      hr(e)._hotUpdate = function(s) {
        a.apply(this, arguments), Iw(e, Object.keys(s._hmrPayload.actions));
      };
    }
    KL(
      t,
      e
    );
  }
}
function JL() {
  const t = zE(!0), e = t.run(() => Mr({}));
  let n = [], a = [];
  const s = ts({
    install(h) {
      Ad(s), s._a = h, h.provide(eT, s), h.config.globalProperties.$pinia = s, pd && XL(h, s), a.forEach((o) => n.push(o)), a = [];
    },
    use(h) {
      return !this._a && !KS ? a.push(h) : n.push(h), this;
    },
    _p: n,
    _a: null,
    _e: t,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return pd && typeof Proxy < "u" && s.use(YL), s;
}
function lT(t, e) {
  for (const n in e) {
    const a = e[n];
    if (!(n in t))
      continue;
    const s = t[n];
    Yc(s) && Yc(a) && !hn(a) && !ss(a) ? t[n] = lT(s, a) : t[n] = a;
  }
  return t;
}
const uT = () => {
};
function Ow(t, e, n, a = uT) {
  t.push(e);
  const s = () => {
    const h = t.indexOf(e);
    h > -1 && (t.splice(h, 1), a());
  };
  return !n && FE() && eA(s), s;
}
function tf(t, ...e) {
  t.slice().forEach((n) => {
    n(...e);
  });
}
function $0(t, e) {
  t instanceof Map && e instanceof Map && e.forEach((n, a) => t.set(a, n)), t instanceof Set && e instanceof Set && e.forEach(t.add, t);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const a = e[n], s = t[n];
    Yc(s) && Yc(a) && t.hasOwnProperty(n) && !hn(a) && !ss(a) ? t[n] = $0(s, a) : t[n] = a;
  }
  return t;
}
const QL = process.env.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : Symbol();
function eD(t) {
  return !Yc(t) || !t.hasOwnProperty(QL);
}
const { assign: Oa } = Object;
function Cw(t) {
  return !!(hn(t) && t.effect);
}
function Aw(t, e, n, a) {
  const { state: s, actions: h, getters: o } = e, m = n.state.value[t];
  let g;
  function b() {
    !m && (process.env.NODE_ENV === "production" || !a) && (n.state.value[t] = s ? s() : {});
    const T = process.env.NODE_ENV !== "production" && a ? jb(Mr(s ? s() : {}).value) : jb(n.state.value[t]);
    return Oa(T, h, Object.keys(o || {}).reduce((M, I) => (process.env.NODE_ENV !== "production" && I in T && console.warn(`[\u{1F34D}]: A getter cannot have the same name as another state property. Rename one of them. Found with "${I}" in store "${t}".`), M[I] = ts(lr(() => {
      Ad(n);
      const P = n._s.get(t);
      return o[I].call(P, P);
    })), M), {}));
  }
  return g = W0(t, b, e, n, a, !0), g;
}
function W0(t, e, n = {}, a, s, h) {
  let o;
  const m = Oa({ actions: {} }, n);
  if (process.env.NODE_ENV !== "production" && !a._e.active)
    throw new Error("Pinia destroyed");
  const g = {
    deep: !0
  };
  process.env.NODE_ENV !== "production" && !KS && (g.onTrigger = (Se) => {
    b ? P = Se : b == !1 && !ze._hotUpdating && (Array.isArray(P) ? P.push(Se) : console.error("\u{1F34D} debuggerEvents should be an array. This is most likely an internal Pinia bug."));
  });
  let b, T, M = ts([]), I = ts([]), P;
  const z = a.state.value[t];
  !h && !z && (process.env.NODE_ENV === "production" || !s) && (a.state.value[t] = {});
  const V = Mr({});
  let W;
  function X(Se) {
    let Ie;
    b = T = !1, process.env.NODE_ENV !== "production" && (P = []), typeof Se == "function" ? (Se(a.state.value[t]), Ie = {
      type: $s.patchFunction,
      storeId: t,
      events: P
    }) : ($0(a.state.value[t], Se), Ie = {
      type: $s.patchObject,
      payload: Se,
      storeId: t,
      events: P
    });
    const Je = W = Symbol();
    bg().then(() => {
      W === Je && (b = !0);
    }), T = !0, tf(M, Ie, a.state.value[t]);
  }
  const K = h ? function() {
    const { state: Ie } = n, Je = Ie ? Ie() : {};
    this.$patch((qe) => {
      Oa(qe, Je);
    });
  } : process.env.NODE_ENV !== "production" ? () => {
    throw new Error(`\u{1F34D}: Store "${t}" is built using the setup syntax and does not implement $reset().`);
  } : uT;
  function se() {
    o.stop(), M = [], I = [], a._s.delete(t);
  }
  function pe(Se, Ie) {
    return function() {
      Ad(a);
      const Je = Array.from(arguments), qe = [], at = [];
      function be(vt) {
        qe.push(vt);
      }
      function Ke(vt) {
        at.push(vt);
      }
      tf(I, {
        args: Je,
        name: Se,
        store: ze,
        after: be,
        onError: Ke
      });
      let ht;
      try {
        ht = Ie.apply(this && this.$id === t ? this : ze, Je);
      } catch (vt) {
        throw tf(at, vt), vt;
      }
      return ht instanceof Promise ? ht.then((vt) => (tf(qe, vt), vt)).catch((vt) => (tf(at, vt), Promise.reject(vt))) : (tf(qe, ht), ht);
    };
  }
  const xe = /* @__PURE__ */ ts({
    actions: {},
    getters: {},
    state: [],
    hotState: V
  }), Fe = {
    _p: a,
    $id: t,
    $onAction: Ow.bind(null, I),
    $patch: X,
    $reset: K,
    $subscribe(Se, Ie = {}) {
      const Je = Ow(M, Se, Ie.detached, () => qe()), qe = o.run(() => Bn(() => a.state.value[t], (at) => {
        (Ie.flush === "sync" ? T : b) && Se({
          storeId: t,
          type: $s.direct,
          events: P
        }, at);
      }, Oa({}, g, Ie)));
      return Je;
    },
    $dispose: se
  }, ze = hv(process.env.NODE_ENV !== "production" || pd ? Oa(
    {
      _hmrPayload: xe,
      _customProperties: ts(/* @__PURE__ */ new Set())
    },
    Fe
  ) : Fe);
  a._s.set(t, ze);
  const Pe = a._e.run(() => (o = zE(), o.run(() => e())));
  for (const Se in Pe) {
    const Ie = Pe[Se];
    if (hn(Ie) && !Cw(Ie) || ss(Ie))
      process.env.NODE_ENV !== "production" && s ? Sy(V.value, Se, ld(Pe, Se)) : h || (z && eD(Ie) && (hn(Ie) ? Ie.value = z[Se] : $0(Ie, z[Se])), a.state.value[t][Se] = Ie), process.env.NODE_ENV !== "production" && xe.state.push(Se);
    else if (typeof Ie == "function") {
      const Je = process.env.NODE_ENV !== "production" && s ? Ie : pe(Se, Ie);
      Pe[Se] = Je, process.env.NODE_ENV !== "production" && (xe.actions[Se] = Ie), m.actions[Se] = Ie;
    } else
      process.env.NODE_ENV !== "production" && Cw(Ie) && (xe.getters[Se] = h ? n.getters[Se] : Ie, wv && (Pe._getters || (Pe._getters = ts([]))).push(Se));
  }
  if (Oa(ze, Pe), Oa(hr(ze), Pe), Object.defineProperty(ze, "$state", {
    get: () => process.env.NODE_ENV !== "production" && s ? V.value : a.state.value[t],
    set: (Se) => {
      if (process.env.NODE_ENV !== "production" && s)
        throw new Error("cannot set hotState");
      X((Ie) => {
        Oa(Ie, Se);
      });
    }
  }), process.env.NODE_ENV !== "production" && (ze._hotUpdate = ts((Se) => {
    ze._hotUpdating = !0, Se._hmrPayload.state.forEach((Ie) => {
      if (Ie in ze.$state) {
        const Je = Se.$state[Ie], qe = ze.$state[Ie];
        typeof Je == "object" && Yc(Je) && Yc(qe) ? lT(Je, qe) : Se.$state[Ie] = qe;
      }
      Sy(ze, Ie, ld(Se.$state, Ie));
    }), Object.keys(ze.$state).forEach((Ie) => {
      Ie in Se.$state || U_(ze, Ie);
    }), b = !1, T = !1, a.state.value[t] = ld(Se._hmrPayload, "hotState"), T = !0, bg().then(() => {
      b = !0;
    });
    for (const Ie in Se._hmrPayload.actions) {
      const Je = Se[Ie];
      Sy(ze, Ie, pe(Ie, Je));
    }
    for (const Ie in Se._hmrPayload.getters) {
      const Je = Se._hmrPayload.getters[Ie], qe = h ? lr(() => (Ad(a), Je.call(ze, ze))) : Je;
      Sy(ze, Ie, qe);
    }
    Object.keys(ze._hmrPayload.getters).forEach((Ie) => {
      Ie in Se._hmrPayload.getters || U_(ze, Ie);
    }), Object.keys(ze._hmrPayload.actions).forEach((Ie) => {
      Ie in Se._hmrPayload.actions || U_(ze, Ie);
    }), ze._hmrPayload = Se._hmrPayload, ze._getters = Se._getters, ze._hotUpdating = !1;
  })), pd) {
    const Se = {
      writable: !0,
      configurable: !0,
      enumerable: !1
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((Ie) => {
      Object.defineProperty(ze, Ie, Oa({ value: ze[Ie] }, Se));
    });
  }
  return a._p.forEach((Se) => {
    if (pd) {
      const Ie = o.run(() => Se({
        store: ze,
        app: a._a,
        pinia: a,
        options: m
      }));
      Object.keys(Ie || {}).forEach((Je) => ze._customProperties.add(Je)), Oa(ze, Ie);
    } else
      Oa(ze, o.run(() => Se({
        store: ze,
        app: a._a,
        pinia: a,
        options: m
      })));
  }), process.env.NODE_ENV !== "production" && ze.$state && typeof ze.$state == "object" && typeof ze.$state.constructor == "function" && !ze.$state.constructor.toString().includes("[native code]") && console.warn(`[\u{1F34D}]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${ze.$id}".`), z && h && n.hydrate && n.hydrate(ze.$state, z), b = !0, T = !0, ze;
}
function rh(t, e, n) {
  let a, s;
  const h = typeof e == "function";
  typeof t == "string" ? (a = t, s = h ? n : e) : (s = t, a = t.id);
  function o(m, g) {
    const b = vv();
    if (m = (process.env.NODE_ENV === "test" && Jp && Jp._testing ? null : m) || b && wf(eT, null), m && Ad(m), process.env.NODE_ENV !== "production" && !Jp)
      throw new Error(`[\u{1F34D}]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);
    m = Jp, m._s.has(a) || (h ? W0(a, e, s, m) : Aw(a, s, m), process.env.NODE_ENV !== "production" && (o._pinia = m));
    const T = m._s.get(a);
    if (process.env.NODE_ENV !== "production" && g) {
      const M = "__hot:" + a, I = h ? W0(M, e, s, m, !0) : Aw(M, Oa({}, s), m, !0);
      g._hotUpdate(I), delete m.state.value[M], m._s.delete(M);
    }
    if (process.env.NODE_ENV !== "production" && wv && b && b.proxy && !g) {
      const M = b.proxy, I = "_pStores" in M ? M._pStores : M._pStores = {};
      I[a] = T;
    }
    return T;
  }
  return o.$id = a, o;
}
function xn(t) {
  {
    t = hr(t);
    const e = {};
    for (const n in t) {
      const a = t[n];
      (hn(a) || ss(a)) && (e[n] = ld(t, n));
    }
    return e;
  }
}
function tD(t) {
  t("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), t.WGS84 = t["EPSG:4326"], t["EPSG:3785"] = t["EPSG:3857"], t.GOOGLE = t["EPSG:3857"], t["EPSG:900913"] = t["EPSG:3857"], t["EPSG:102113"] = t["EPSG:3857"];
}
var Jc = 1, Qc = 2, Sf = 3, rD = 4, H0 = 5, Pw = 6378137, nD = 6356752314e-3, kw = 0.0066943799901413165, dd = 484813681109536e-20, ft = Math.PI / 2, iD = 0.16666666666666666, oD = 0.04722222222222222, aD = 0.022156084656084655, Ct = 1e-10, io = 0.017453292519943295, Gs = 57.29577951308232, ln = Math.PI / 4, Pd = Math.PI * 2, wi = 3.14159265359, ra = {};
ra.greenwich = 0;
ra.lisbon = -9.131906111111;
ra.paris = 2.337229166667;
ra.bogota = -74.080916666667;
ra.madrid = -3.687938888889;
ra.rome = 12.452333333333;
ra.bern = 7.439583333333;
ra.jakarta = 106.807719444444;
ra.ferro = -17.666666666667;
ra.brussels = 4.367975;
ra.stockholm = 18.058277777778;
ra.athens = 23.7163375;
ra.oslo = 10.722916666667;
const sD = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var Lw = /[\s_\-\/\(\)]/g;
function Nu(t, e) {
  if (t[e])
    return t[e];
  for (var n = Object.keys(t), a = e.toLowerCase().replace(Lw, ""), s = -1, h, o; ++s < n.length; )
    if (h = n[s], o = h.toLowerCase().replace(Lw, ""), o === a)
      return t[h];
}
function Z0(t) {
  var e = {}, n = t.split("+").map(function(m) {
    return m.trim();
  }).filter(function(m) {
    return m;
  }).reduce(function(m, g) {
    var b = g.split("=");
    return b.push(!0), m[b[0].toLowerCase()] = b[1], m;
  }, {}), a, s, h, o = {
    proj: "projName",
    datum: "datumCode",
    rf: function(m) {
      e.rf = parseFloat(m);
    },
    lat_0: function(m) {
      e.lat0 = m * io;
    },
    lat_1: function(m) {
      e.lat1 = m * io;
    },
    lat_2: function(m) {
      e.lat2 = m * io;
    },
    lat_ts: function(m) {
      e.lat_ts = m * io;
    },
    lon_0: function(m) {
      e.long0 = m * io;
    },
    lon_1: function(m) {
      e.long1 = m * io;
    },
    lon_2: function(m) {
      e.long2 = m * io;
    },
    alpha: function(m) {
      e.alpha = parseFloat(m) * io;
    },
    gamma: function(m) {
      e.rectified_grid_angle = parseFloat(m);
    },
    lonc: function(m) {
      e.longc = m * io;
    },
    x_0: function(m) {
      e.x0 = parseFloat(m);
    },
    y_0: function(m) {
      e.y0 = parseFloat(m);
    },
    k_0: function(m) {
      e.k0 = parseFloat(m);
    },
    k: function(m) {
      e.k0 = parseFloat(m);
    },
    a: function(m) {
      e.a = parseFloat(m);
    },
    b: function(m) {
      e.b = parseFloat(m);
    },
    r_a: function() {
      e.R_A = !0;
    },
    zone: function(m) {
      e.zone = parseInt(m, 10);
    },
    south: function() {
      e.utmSouth = !0;
    },
    towgs84: function(m) {
      e.datum_params = m.split(",").map(function(g) {
        return parseFloat(g);
      });
    },
    to_meter: function(m) {
      e.to_meter = parseFloat(m);
    },
    units: function(m) {
      e.units = m;
      var g = Nu(sD, m);
      g && (e.to_meter = g.to_meter);
    },
    from_greenwich: function(m) {
      e.from_greenwich = m * io;
    },
    pm: function(m) {
      var g = Nu(ra, m);
      e.from_greenwich = (g || parseFloat(m)) * io;
    },
    nadgrids: function(m) {
      m === "@null" ? e.datumCode = "none" : e.nadgrids = m;
    },
    axis: function(m) {
      var g = "ewnsud";
      m.length === 3 && g.indexOf(m.substr(0, 1)) !== -1 && g.indexOf(m.substr(1, 1)) !== -1 && g.indexOf(m.substr(2, 1)) !== -1 && (e.axis = m);
    },
    approx: function() {
      e.approx = !0;
    }
  };
  for (a in n)
    s = n[a], a in o ? (h = o[a], typeof h == "function" ? h(s) : e[h] = s) : e[a] = s;
  return typeof e.datumCode == "string" && e.datumCode !== "WGS84" && (e.datumCode = e.datumCode.toLowerCase()), e;
}
var kd = 1, cT = 2, hT = 3, Cg = 4, fT = 5, B1 = -1, lD = /\s/, uD = /[A-Za-z]/, cD = /[A-Za-z84_]/, Ev = /[,\]]/, pT = /[\d\.E\-\+]/;
function $l(t) {
  if (typeof t != "string")
    throw new Error("not a string");
  this.text = t.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = kd;
}
$l.prototype.readCharicter = function() {
  var t = this.text[this.place++];
  if (this.state !== Cg)
    for (; lD.test(t); ) {
      if (this.place >= this.text.length)
        return;
      t = this.text[this.place++];
    }
  switch (this.state) {
    case kd:
      return this.neutral(t);
    case cT:
      return this.keyword(t);
    case Cg:
      return this.quoted(t);
    case fT:
      return this.afterquote(t);
    case hT:
      return this.number(t);
    case B1:
      return;
  }
};
$l.prototype.afterquote = function(t) {
  if (t === '"') {
    this.word += '"', this.state = Cg;
    return;
  }
  if (Ev.test(t)) {
    this.word = this.word.trim(), this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in afterquote yet, index ' + this.place);
};
$l.prototype.afterItem = function(t) {
  if (t === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = kd;
    return;
  }
  if (t === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = kd, this.currentObject = this.stack.pop(), this.currentObject || (this.state = B1);
    return;
  }
};
$l.prototype.number = function(t) {
  if (pT.test(t)) {
    this.word += t;
    return;
  }
  if (Ev.test(t)) {
    this.word = parseFloat(this.word), this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in number yet, index ' + this.place);
};
$l.prototype.quoted = function(t) {
  if (t === '"') {
    this.state = fT;
    return;
  }
  this.word += t;
};
$l.prototype.keyword = function(t) {
  if (cD.test(t)) {
    this.word += t;
    return;
  }
  if (t === "[") {
    var e = [];
    e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, this.state = kd;
    return;
  }
  if (Ev.test(t)) {
    this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in keyword yet, index ' + this.place);
};
$l.prototype.neutral = function(t) {
  if (uD.test(t)) {
    this.word = t, this.state = cT;
    return;
  }
  if (t === '"') {
    this.word = "", this.state = Cg;
    return;
  }
  if (pT.test(t)) {
    this.word = t, this.state = hT;
    return;
  }
  if (Ev.test(t)) {
    this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in neutral yet, index ' + this.place);
};
$l.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === B1)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function hD(t) {
  var e = new $l(t);
  return e.output();
}
function Dw(t, e, n) {
  Array.isArray(e) && (n.unshift(e), e = null);
  var a = e ? {} : t, s = n.reduce(function(h, o) {
    return mf(o, h), h;
  }, a);
  e && (t[e] = s);
}
function mf(t, e) {
  if (!Array.isArray(t)) {
    e[t] = !0;
    return;
  }
  var n = t.shift();
  if (n === "PARAMETER" && (n = t.shift()), t.length === 1) {
    if (Array.isArray(t[0])) {
      e[n] = {}, mf(t[0], e[n]);
      return;
    }
    e[n] = t[0];
    return;
  }
  if (!t.length) {
    e[n] = !0;
    return;
  }
  if (n === "TOWGS84") {
    e[n] = t;
    return;
  }
  if (n === "AXIS") {
    n in e || (e[n] = []), e[n].push(t);
    return;
  }
  Array.isArray(n) || (e[n] = {});
  var a;
  switch (n) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      e[n] = {
        name: t[0].toLowerCase(),
        convert: t[1]
      }, t.length === 3 && mf(t[2], e[n]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      e[n] = {
        name: t[0],
        a: t[1],
        rf: t[2]
      }, t.length === 4 && mf(t[3], e[n]);
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      t[0] = ["name", t[0]], Dw(e, n, t);
      return;
    default:
      for (a = -1; ++a < t.length; )
        if (!Array.isArray(t[a]))
          return mf(t, e[n]);
      return Dw(e, n, t);
  }
}
var fD = 0.017453292519943295;
function pD(t, e) {
  var n = e[0], a = e[1];
  !(n in t) && a in t && (t[n] = t[a], e.length === 3 && (t[n] = e[2](t[n])));
}
function Cl(t) {
  return t * fD;
}
function dD(t) {
  if (t.type === "GEOGCS" ? t.projName = "longlat" : t.type === "LOCAL_CS" ? (t.projName = "identity", t.local = !0) : typeof t.PROJECTION == "object" ? t.projName = Object.keys(t.PROJECTION)[0] : t.projName = t.PROJECTION, t.AXIS) {
    for (var e = "", n = 0, a = t.AXIS.length; n < a; ++n) {
      var s = [t.AXIS[n][0].toLowerCase(), t.AXIS[n][1].toLowerCase()];
      s[0].indexOf("north") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "north" ? e += "n" : s[0].indexOf("south") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "south" ? e += "s" : s[0].indexOf("east") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "east" ? e += "e" : (s[0].indexOf("west") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "west") && (e += "w");
    }
    e.length === 2 && (e += "u"), e.length === 3 && (t.axis = e);
  }
  t.UNIT && (t.units = t.UNIT.name.toLowerCase(), t.units === "metre" && (t.units = "meter"), t.UNIT.convert && (t.type === "GEOGCS" ? t.DATUM && t.DATUM.SPHEROID && (t.to_meter = t.UNIT.convert * t.DATUM.SPHEROID.a) : t.to_meter = t.UNIT.convert));
  var h = t.GEOGCS;
  t.type === "GEOGCS" && (h = t), h && (h.DATUM ? t.datumCode = h.DATUM.name.toLowerCase() : t.datumCode = h.name.toLowerCase(), t.datumCode.slice(0, 2) === "d_" && (t.datumCode = t.datumCode.slice(2)), (t.datumCode === "new_zealand_geodetic_datum_1949" || t.datumCode === "new_zealand_1949") && (t.datumCode = "nzgd49"), (t.datumCode === "wgs_1984" || t.datumCode === "world_geodetic_system_1984") && (t.PROJECTION === "Mercator_Auxiliary_Sphere" && (t.sphere = !0), t.datumCode = "wgs84"), t.datumCode.slice(-6) === "_ferro" && (t.datumCode = t.datumCode.slice(0, -6)), t.datumCode.slice(-8) === "_jakarta" && (t.datumCode = t.datumCode.slice(0, -8)), ~t.datumCode.indexOf("belge") && (t.datumCode = "rnb72"), h.DATUM && h.DATUM.SPHEROID && (t.ellps = h.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), t.ellps.toLowerCase().slice(0, 13) === "international" && (t.ellps = "intl"), t.a = h.DATUM.SPHEROID.a, t.rf = parseFloat(h.DATUM.SPHEROID.rf, 10)), h.DATUM && h.DATUM.TOWGS84 && (t.datum_params = h.DATUM.TOWGS84), ~t.datumCode.indexOf("osgb_1936") && (t.datumCode = "osgb36"), ~t.datumCode.indexOf("osni_1952") && (t.datumCode = "osni52"), (~t.datumCode.indexOf("tm65") || ~t.datumCode.indexOf("geodetic_datum_of_1965")) && (t.datumCode = "ire65"), t.datumCode === "ch1903+" && (t.datumCode = "ch1903"), ~t.datumCode.indexOf("israel") && (t.datumCode = "isr93")), t.b && !isFinite(t.b) && (t.b = t.a);
  function o(b) {
    var T = t.to_meter || 1;
    return b * T;
  }
  var m = function(b) {
    return pD(t, b);
  }, g = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", Cl],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", Cl],
    ["x0", "false_easting", o],
    ["y0", "false_northing", o],
    ["long0", "central_meridian", Cl],
    ["lat0", "latitude_of_origin", Cl],
    ["lat0", "standard_parallel_1", Cl],
    ["lat1", "standard_parallel_1", Cl],
    ["lat2", "standard_parallel_2", Cl],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", Cl],
    ["srsCode", "name"]
  ];
  g.forEach(m), !t.long0 && t.longc && (t.projName === "Albers_Conic_Equal_Area" || t.projName === "Lambert_Azimuthal_Equal_Area") && (t.long0 = t.longc), !t.lat_ts && t.lat1 && (t.projName === "Stereographic_South_Pole" || t.projName === "Polar Stereographic (variant B)") && (t.lat0 = Cl(t.lat1 > 0 ? 90 : -90), t.lat_ts = t.lat1);
}
function dT(t) {
  var e = hD(t), n = e.shift(), a = e.shift();
  e.unshift(["name", a]), e.unshift(["type", n]);
  var s = {};
  return mf(e, s), dD(s), s;
}
function Do(t) {
  var e = this;
  if (arguments.length === 2) {
    var n = arguments[1];
    typeof n == "string" ? n.charAt(0) === "+" ? Do[t] = Z0(arguments[1]) : Do[t] = dT(arguments[1]) : Do[t] = n;
  } else if (arguments.length === 1) {
    if (Array.isArray(t))
      return t.map(function(a) {
        Array.isArray(a) ? Do.apply(e, a) : Do(a);
      });
    if (typeof t == "string") {
      if (t in Do)
        return Do[t];
    } else
      "EPSG" in t ? Do["EPSG:" + t.EPSG] = t : "ESRI" in t ? Do["ESRI:" + t.ESRI] = t : "IAU2000" in t ? Do["IAU2000:" + t.IAU2000] = t : console.log(t);
    return;
  }
}
tD(Do);
function mD(t) {
  return typeof t == "string";
}
function yD(t) {
  return t in Do;
}
var gD = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function vD(t) {
  return gD.some(function(e) {
    return t.indexOf(e) > -1;
  });
}
var _D = ["3857", "900913", "3785", "102113"];
function xD(t) {
  var e = Nu(t, "authority");
  if (!!e) {
    var n = Nu(e, "epsg");
    return n && _D.indexOf(n) > -1;
  }
}
function bD(t) {
  var e = Nu(t, "extension");
  if (!!e)
    return Nu(e, "proj4");
}
function wD(t) {
  return t[0] === "+";
}
function ED(t) {
  if (mD(t)) {
    if (yD(t))
      return Do[t];
    if (vD(t)) {
      var e = dT(t);
      if (xD(e))
        return Do["EPSG:3857"];
      var n = bD(e);
      return n ? Z0(n) : e;
    }
    if (wD(t))
      return Z0(t);
  } else
    return t;
}
function Nw(t, e) {
  t = t || {};
  var n, a;
  if (!e)
    return t;
  for (a in e)
    n = e[a], n !== void 0 && (t[a] = n);
  return t;
}
function Ys(t, e, n) {
  var a = t * e;
  return n / Math.sqrt(1 - a * a);
}
function Gd(t) {
  return t < 0 ? -1 : 1;
}
function Vt(t) {
  return Math.abs(t) <= wi ? t : t - Gd(t) * Pd;
}
function ls(t, e, n) {
  var a = t * n, s = 0.5 * t;
  return a = Math.pow((1 - a) / (1 + a), s), Math.tan(0.5 * (ft - e)) / a;
}
function Ld(t, e) {
  for (var n = 0.5 * t, a, s, h = ft - 2 * Math.atan(e), o = 0; o <= 15; o++)
    if (a = t * Math.sin(h), s = ft - 2 * Math.atan(e * Math.pow((1 - a) / (1 + a), n)) - h, h += s, Math.abs(s) <= 1e-10)
      return h;
  return -9999;
}
function SD() {
  var t = this.b / this.a;
  this.es = 1 - t * t, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = Ys(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function TD(t) {
  var e = t.x, n = t.y;
  if (n * Gs > 90 && n * Gs < -90 && e * Gs > 180 && e * Gs < -180)
    return null;
  var a, s;
  if (Math.abs(Math.abs(n) - ft) <= Ct)
    return null;
  if (this.sphere)
    a = this.x0 + this.a * this.k0 * Vt(e - this.long0), s = this.y0 + this.a * this.k0 * Math.log(Math.tan(ln + 0.5 * n));
  else {
    var h = Math.sin(n), o = ls(this.e, n, h);
    a = this.x0 + this.a * this.k0 * Vt(e - this.long0), s = this.y0 - this.a * this.k0 * Math.log(o);
  }
  return t.x = a, t.y = s, t;
}
function MD(t) {
  var e = t.x - this.x0, n = t.y - this.y0, a, s;
  if (this.sphere)
    s = ft - 2 * Math.atan(Math.exp(-n / (this.a * this.k0)));
  else {
    var h = Math.exp(-n / (this.a * this.k0));
    if (s = Ld(this.e, h), s === -9999)
      return null;
  }
  return a = Vt(this.long0 + e / (this.a * this.k0)), t.x = a, t.y = s, t;
}
var ID = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const OD = {
  init: SD,
  forward: TD,
  inverse: MD,
  names: ID
};
function CD() {
}
function Rw(t) {
  return t;
}
var AD = ["longlat", "identity"];
const PD = {
  init: CD,
  forward: Rw,
  inverse: Rw,
  names: AD
};
var kD = [OD, PD], ig = {}, Ag = [];
function mT(t, e) {
  var n = Ag.length;
  return t.names ? (Ag[n] = t, t.names.forEach(function(a) {
    ig[a.toLowerCase()] = n;
  }), this) : (console.log(e), !0);
}
function LD(t) {
  if (!t)
    return !1;
  var e = t.toLowerCase();
  if (typeof ig[e] < "u" && Ag[ig[e]])
    return Ag[ig[e]];
}
function DD() {
  kD.forEach(mT);
}
const ND = {
  start: DD,
  add: mT,
  get: LD
};
var _r = {};
_r.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
_r.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
_r.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
_r.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
_r.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
_r.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
_r.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
_r.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
_r.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
_r.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
_r.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
_r.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
_r.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
_r.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
_r.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
_r.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
_r.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
_r.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
_r.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
_r.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
_r.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
_r.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
_r.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
_r.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
_r.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
_r.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
_r.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
_r.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
_r.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
_r.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
_r.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
_r.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
_r.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
_r.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
_r.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
_r.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
_r.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
_r.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
_r.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
_r.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
_r.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var RD = _r.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
_r.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function zD(t, e, n, a) {
  var s = t * t, h = e * e, o = (s - h) / s, m = 0;
  a ? (t *= 1 - o * (iD + o * (oD + o * aD)), s = t * t, o = 0) : m = Math.sqrt(o);
  var g = (s - h) / h;
  return {
    es: o,
    e: m,
    ep2: g
  };
}
function FD(t, e, n, a, s) {
  if (!t) {
    var h = Nu(_r, a);
    h || (h = RD), t = h.a, e = h.b, n = h.rf;
  }
  return n && !e && (e = (1 - 1 / n) * t), (n === 0 || Math.abs(t - e) < Ct) && (s = !0, e = t), {
    a: t,
    b: e,
    rf: n,
    sphere: s
  };
}
var Ki = {};
Ki.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
Ki.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
Ki.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
Ki.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
Ki.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
Ki.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
Ki.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
Ki.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
Ki.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
Ki.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
Ki.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
Ki.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
Ki.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
Ki.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
Ki.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
Ki.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
Ki.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function BD(t, e, n, a, s, h, o) {
  var m = {};
  return t === void 0 || t === "none" ? m.datum_type = H0 : m.datum_type = rD, e && (m.datum_params = e.map(parseFloat), (m.datum_params[0] !== 0 || m.datum_params[1] !== 0 || m.datum_params[2] !== 0) && (m.datum_type = Jc), m.datum_params.length > 3 && (m.datum_params[3] !== 0 || m.datum_params[4] !== 0 || m.datum_params[5] !== 0 || m.datum_params[6] !== 0) && (m.datum_type = Qc, m.datum_params[3] *= dd, m.datum_params[4] *= dd, m.datum_params[5] *= dd, m.datum_params[6] = m.datum_params[6] / 1e6 + 1)), o && (m.datum_type = Sf, m.grids = o), m.a = n, m.b = a, m.es = s, m.ep2 = h, m;
}
var yT = {};
function VD(t, e) {
  var n = new DataView(e), a = GD(n), s = qD(n, a);
  s.nSubgrids > 1 && console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
  var h = $D(n, s, a), o = { header: s, subgrids: h };
  return yT[t] = o, o;
}
function UD(t) {
  if (t === void 0)
    return null;
  var e = t.split(",");
  return e.map(jD);
}
function jD(t) {
  if (t.length === 0)
    return null;
  var e = t[0] === "@";
  return e && (t = t.slice(1)), t === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : {
    name: t,
    mandatory: !e,
    grid: yT[t] || null,
    isNull: !1
  };
}
function yf(t) {
  return t / 3600 * Math.PI / 180;
}
function GD(t) {
  var e = t.getInt32(8, !1);
  return e === 11 ? !1 : (e = t.getInt32(8, !0), e !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function qD(t, e) {
  return {
    nFields: t.getInt32(8, e),
    nSubgridFields: t.getInt32(24, e),
    nSubgrids: t.getInt32(40, e),
    shiftType: X0(t, 56, 56 + 8).trim(),
    fromSemiMajorAxis: t.getFloat64(120, e),
    fromSemiMinorAxis: t.getFloat64(136, e),
    toSemiMajorAxis: t.getFloat64(152, e),
    toSemiMinorAxis: t.getFloat64(168, e)
  };
}
function X0(t, e, n) {
  return String.fromCharCode.apply(null, new Uint8Array(t.buffer.slice(e, n)));
}
function $D(t, e, n) {
  for (var a = 176, s = [], h = 0; h < e.nSubgrids; h++) {
    var o = HD(t, a, n), m = ZD(t, a, o, n), g = Math.round(
      1 + (o.upperLongitude - o.lowerLongitude) / o.longitudeInterval
    ), b = Math.round(
      1 + (o.upperLatitude - o.lowerLatitude) / o.latitudeInterval
    );
    s.push({
      ll: [yf(o.lowerLongitude), yf(o.lowerLatitude)],
      del: [yf(o.longitudeInterval), yf(o.latitudeInterval)],
      lim: [g, b],
      count: o.gridNodeCount,
      cvs: WD(m)
    });
  }
  return s;
}
function WD(t) {
  return t.map(function(e) {
    return [yf(e.longitudeShift), yf(e.latitudeShift)];
  });
}
function HD(t, e, n) {
  return {
    name: X0(t, e + 8, e + 16).trim(),
    parent: X0(t, e + 24, e + 24 + 8).trim(),
    lowerLatitude: t.getFloat64(e + 72, n),
    upperLatitude: t.getFloat64(e + 88, n),
    lowerLongitude: t.getFloat64(e + 104, n),
    upperLongitude: t.getFloat64(e + 120, n),
    latitudeInterval: t.getFloat64(e + 136, n),
    longitudeInterval: t.getFloat64(e + 152, n),
    gridNodeCount: t.getInt32(e + 168, n)
  };
}
function ZD(t, e, n, a) {
  for (var s = e + 176, h = 16, o = [], m = 0; m < n.gridNodeCount; m++) {
    var g = {
      latitudeShift: t.getFloat32(s + m * h, a),
      longitudeShift: t.getFloat32(s + m * h + 4, a),
      latitudeAccuracy: t.getFloat32(s + m * h + 8, a),
      longitudeAccuracy: t.getFloat32(s + m * h + 12, a)
    };
    o.push(g);
  }
  return o;
}
function Ws(t, e) {
  if (!(this instanceof Ws))
    return new Ws(t);
  e = e || function(b) {
    if (b)
      throw b;
  };
  var n = ED(t);
  if (typeof n != "object") {
    e(t);
    return;
  }
  var a = Ws.projections.get(n.projName);
  if (!a) {
    e(t);
    return;
  }
  if (n.datumCode && n.datumCode !== "none") {
    var s = Nu(Ki, n.datumCode);
    s && (n.datum_params = n.datum_params || (s.towgs84 ? s.towgs84.split(",") : null), n.ellps = s.ellipse, n.datumName = s.datumName ? s.datumName : n.datumCode);
  }
  n.k0 = n.k0 || 1, n.axis = n.axis || "enu", n.ellps = n.ellps || "wgs84", n.lat1 = n.lat1 || n.lat0;
  var h = FD(n.a, n.b, n.rf, n.ellps, n.sphere), o = zD(h.a, h.b, h.rf, n.R_A), m = UD(n.nadgrids), g = n.datum || BD(
    n.datumCode,
    n.datum_params,
    h.a,
    h.b,
    o.es,
    o.ep2,
    m
  );
  Nw(this, n), Nw(this, a), this.a = h.a, this.b = h.b, this.rf = h.rf, this.sphere = h.sphere, this.es = o.es, this.e = o.e, this.ep2 = o.ep2, this.datum = g, this.init(), e(null, this);
}
Ws.projections = ND;
Ws.projections.start();
function XD(t, e) {
  return t.datum_type !== e.datum_type || t.a !== e.a || Math.abs(t.es - e.es) > 5e-11 ? !1 : t.datum_type === Jc ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] : t.datum_type === Qc ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] && t.datum_params[3] === e.datum_params[3] && t.datum_params[4] === e.datum_params[4] && t.datum_params[5] === e.datum_params[5] && t.datum_params[6] === e.datum_params[6] : !0;
}
function gT(t, e, n) {
  var a = t.x, s = t.y, h = t.z ? t.z : 0, o, m, g, b;
  if (s < -ft && s > -1.001 * ft)
    s = -ft;
  else if (s > ft && s < 1.001 * ft)
    s = ft;
  else {
    if (s < -ft)
      return { x: -1 / 0, y: -1 / 0, z: t.z };
    if (s > ft)
      return { x: 1 / 0, y: 1 / 0, z: t.z };
  }
  return a > Math.PI && (a -= 2 * Math.PI), m = Math.sin(s), b = Math.cos(s), g = m * m, o = n / Math.sqrt(1 - e * g), {
    x: (o + h) * b * Math.cos(a),
    y: (o + h) * b * Math.sin(a),
    z: (o * (1 - e) + h) * m
  };
}
function vT(t, e, n, a) {
  var s = 1e-12, h = s * s, o = 30, m, g, b, T, M, I, P, z, V, W, X, K, se, pe = t.x, xe = t.y, Fe = t.z ? t.z : 0, ze, Pe, Se;
  if (m = Math.sqrt(pe * pe + xe * xe), g = Math.sqrt(pe * pe + xe * xe + Fe * Fe), m / n < s) {
    if (ze = 0, g / n < s)
      return Pe = ft, Se = -a, {
        x: t.x,
        y: t.y,
        z: t.z
      };
  } else
    ze = Math.atan2(xe, pe);
  b = Fe / g, T = m / g, M = 1 / Math.sqrt(1 - e * (2 - e) * T * T), z = T * (1 - e) * M, V = b * M, se = 0;
  do
    se++, P = n / Math.sqrt(1 - e * V * V), Se = m * z + Fe * V - P * (1 - e * V * V), I = e * P / (P + Se), M = 1 / Math.sqrt(1 - I * (2 - I) * T * T), W = T * (1 - I) * M, X = b * M, K = X * z - W * V, z = W, V = X;
  while (K * K > h && se < o);
  return Pe = Math.atan(X / Math.abs(W)), {
    x: ze,
    y: Pe,
    z: Se
  };
}
function KD(t, e, n) {
  if (e === Jc)
    return {
      x: t.x + n[0],
      y: t.y + n[1],
      z: t.z + n[2]
    };
  if (e === Qc) {
    var a = n[0], s = n[1], h = n[2], o = n[3], m = n[4], g = n[5], b = n[6];
    return {
      x: b * (t.x - g * t.y + m * t.z) + a,
      y: b * (g * t.x + t.y - o * t.z) + s,
      z: b * (-m * t.x + o * t.y + t.z) + h
    };
  }
}
function YD(t, e, n) {
  if (e === Jc)
    return {
      x: t.x - n[0],
      y: t.y - n[1],
      z: t.z - n[2]
    };
  if (e === Qc) {
    var a = n[0], s = n[1], h = n[2], o = n[3], m = n[4], g = n[5], b = n[6], T = (t.x - a) / b, M = (t.y - s) / b, I = (t.z - h) / b;
    return {
      x: T + g * M - m * I,
      y: -g * T + M + o * I,
      z: m * T - o * M + I
    };
  }
}
function Ty(t) {
  return t === Jc || t === Qc;
}
function JD(t, e, n) {
  if (XD(t, e) || t.datum_type === H0 || e.datum_type === H0)
    return n;
  var a = t.a, s = t.es;
  if (t.datum_type === Sf) {
    var h = zw(t, !1, n);
    if (h !== 0)
      return;
    a = Pw, s = kw;
  }
  var o = e.a, m = e.b, g = e.es;
  if (e.datum_type === Sf && (o = Pw, m = nD, g = kw), s === g && a === o && !Ty(t.datum_type) && !Ty(e.datum_type))
    return n;
  if (n = gT(n, s, a), Ty(t.datum_type) && (n = KD(n, t.datum_type, t.datum_params)), Ty(e.datum_type) && (n = YD(n, e.datum_type, e.datum_params)), n = vT(n, g, o, m), e.datum_type === Sf) {
    var b = zw(e, !0, n);
    if (b !== 0)
      return;
  }
  return n;
}
function zw(t, e, n) {
  if (t.grids === null || t.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  for (var a = { x: -n.x, y: n.y }, s = { x: Number.NaN, y: Number.NaN }, h = [], o = 0; o < t.grids.length; o++) {
    var m = t.grids[o];
    if (h.push(m.name), m.isNull) {
      s = a;
      break;
    }
    if (m.mandatory, m.grid === null) {
      if (m.mandatory)
        return console.log("Unable to find mandatory grid '" + m.name + "'"), -1;
      continue;
    }
    var g = m.grid.subgrids[0], b = (Math.abs(g.del[1]) + Math.abs(g.del[0])) / 1e4, T = g.ll[0] - b, M = g.ll[1] - b, I = g.ll[0] + (g.lim[0] - 1) * g.del[0] + b, P = g.ll[1] + (g.lim[1] - 1) * g.del[1] + b;
    if (!(M > a.y || T > a.x || P < a.y || I < a.x) && (s = QD(a, e, g), !isNaN(s.x)))
      break;
  }
  return isNaN(s.x) ? (console.log("Failed to find a grid shift table for location '" + -a.x * Gs + " " + a.y * Gs + " tried: '" + h + "'"), -1) : (n.x = -s.x, n.y = s.y, 0);
}
function QD(t, e, n) {
  var a = { x: Number.NaN, y: Number.NaN };
  if (isNaN(t.x))
    return a;
  var s = { x: t.x, y: t.y };
  s.x -= n.ll[0], s.y -= n.ll[1], s.x = Vt(s.x - Math.PI) + Math.PI;
  var h = Fw(s, n);
  if (e) {
    if (isNaN(h.x))
      return a;
    h.x = s.x - h.x, h.y = s.y - h.y;
    var o = 9, m = 1e-12, g, b;
    do {
      if (b = Fw(h, n), isNaN(b.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      g = { x: s.x - (b.x + h.x), y: s.y - (b.y + h.y) }, h.x += g.x, h.y += g.y;
    } while (o-- && Math.abs(g.x) > m && Math.abs(g.y) > m);
    if (o < 0)
      return console.log("Inverse grid shift iterator failed to converge."), a;
    a.x = Vt(h.x + n.ll[0]), a.y = h.y + n.ll[1];
  } else
    isNaN(h.x) || (a.x = t.x + h.x, a.y = t.y + h.y);
  return a;
}
function Fw(t, e) {
  var n = { x: t.x / e.del[0], y: t.y / e.del[1] }, a = { x: Math.floor(n.x), y: Math.floor(n.y) }, s = { x: n.x - 1 * a.x, y: n.y - 1 * a.y }, h = { x: Number.NaN, y: Number.NaN }, o;
  if (a.x < 0 || a.x >= e.lim[0] || a.y < 0 || a.y >= e.lim[1])
    return h;
  o = a.y * e.lim[0] + a.x;
  var m = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o++;
  var g = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o += e.lim[0];
  var b = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o--;
  var T = { x: e.cvs[o][0], y: e.cvs[o][1] }, M = s.x * s.y, I = s.x * (1 - s.y), P = (1 - s.x) * (1 - s.y), z = (1 - s.x) * s.y;
  return h.x = P * m.x + I * g.x + z * T.x + M * b.x, h.y = P * m.y + I * g.y + z * T.y + M * b.y, h;
}
function Bw(t, e, n) {
  var a = n.x, s = n.y, h = n.z || 0, o, m, g, b = {};
  for (g = 0; g < 3; g++)
    if (!(e && g === 2 && n.z === void 0))
      switch (g === 0 ? (o = a, "ew".indexOf(t.axis[g]) !== -1 ? m = "x" : m = "y") : g === 1 ? (o = s, "ns".indexOf(t.axis[g]) !== -1 ? m = "y" : m = "x") : (o = h, m = "z"), t.axis[g]) {
        case "e":
          b[m] = o;
          break;
        case "w":
          b[m] = -o;
          break;
        case "n":
          b[m] = o;
          break;
        case "s":
          b[m] = -o;
          break;
        case "u":
          n[m] !== void 0 && (b.z = o);
          break;
        case "d":
          n[m] !== void 0 && (b.z = -o);
          break;
        default:
          return null;
      }
  return b;
}
function _T(t) {
  var e = {
    x: t[0],
    y: t[1]
  };
  return t.length > 2 && (e.z = t[2]), t.length > 3 && (e.m = t[3]), e;
}
function eN(t) {
  Vw(t.x), Vw(t.y);
}
function Vw(t) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(t))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof t != "number" || t !== t || !isFinite(t))
    throw new TypeError("coordinates must be finite numbers");
}
function tN(t, e) {
  return (t.datum.datum_type === Jc || t.datum.datum_type === Qc || t.datum.datum_type === Sf) && e.datumCode !== "WGS84" || (e.datum.datum_type === Jc || e.datum.datum_type === Qc || e.datum.datum_type === Sf) && t.datumCode !== "WGS84";
}
function Pg(t, e, n, a) {
  var s;
  Array.isArray(n) ? n = _T(n) : n = {
    x: n.x,
    y: n.y,
    z: n.z,
    m: n.m
  };
  var h = n.z !== void 0;
  if (eN(n), t.datum && e.datum && tN(t, e) && (s = new Ws("WGS84"), n = Pg(t, s, n, a), t = s), a && t.axis !== "enu" && (n = Bw(t, !1, n)), t.projName === "longlat")
    n = {
      x: n.x * io,
      y: n.y * io,
      z: n.z || 0
    };
  else if (t.to_meter && (n = {
    x: n.x * t.to_meter,
    y: n.y * t.to_meter,
    z: n.z || 0
  }), n = t.inverse(n), !n)
    return;
  if (t.from_greenwich && (n.x += t.from_greenwich), n = JD(t.datum, e.datum, n), !!n)
    return e.from_greenwich && (n = {
      x: n.x - e.from_greenwich,
      y: n.y,
      z: n.z || 0
    }), e.projName === "longlat" ? n = {
      x: n.x * Gs,
      y: n.y * Gs,
      z: n.z || 0
    } : (n = e.forward(n), e.to_meter && (n = {
      x: n.x / e.to_meter,
      y: n.y / e.to_meter,
      z: n.z || 0
    })), a && e.axis !== "enu" ? Bw(e, !0, n) : (h || delete n.z, n);
}
var Uw = Ws("WGS84");
function j_(t, e, n, a) {
  var s, h, o;
  return Array.isArray(n) ? (s = Pg(t, e, n, a) || { x: NaN, y: NaN }, n.length > 2 ? typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent" ? typeof s.z == "number" ? [s.x, s.y, s.z].concat(n.splice(3)) : [s.x, s.y, n[2]].concat(n.splice(3)) : [s.x, s.y].concat(n.splice(2)) : [s.x, s.y]) : (h = Pg(t, e, n, a), o = Object.keys(n), o.length === 2 || o.forEach(function(m) {
    if (typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent") {
      if (m === "x" || m === "y" || m === "z")
        return;
    } else if (m === "x" || m === "y")
      return;
    h[m] = n[m];
  }), h);
}
function jw(t) {
  return t instanceof Ws ? t : t.oProj ? t.oProj : Ws(t);
}
function wo(t, e, n) {
  t = jw(t);
  var a = !1, s;
  return typeof e > "u" ? (e = t, t = Uw, a = !0) : (typeof e.x < "u" || Array.isArray(e)) && (n = e, e = t, t = Uw, a = !0), e = jw(e), n ? j_(t, e, n) : (s = {
    forward: function(h, o) {
      return j_(t, e, h, o);
    },
    inverse: function(h, o) {
      return j_(e, t, h, o);
    }
  }, a && (s.oProj = e), s);
}
var Gw = 6, xT = "AJSAJS", bT = "AFAFAF", gf = 65, Qo = 73, Ca = 79, Qp = 86, ed = 90;
const rN = {
  forward: wT,
  inverse: nN,
  toPoint: ET
};
function wT(t, e) {
  return e = e || 5, aN(iN({
    lat: t[1],
    lon: t[0]
  }), e);
}
function nN(t) {
  var e = V1(TT(t.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
}
function ET(t) {
  var e = V1(TT(t.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function G_(t) {
  return t * (Math.PI / 180);
}
function qw(t) {
  return 180 * (t / Math.PI);
}
function iN(t) {
  var e = t.lat, n = t.lon, a = 6378137, s = 669438e-8, h = 0.9996, o, m, g, b, T, M, I, P = G_(e), z = G_(n), V, W;
  W = Math.floor((n + 180) / 6) + 1, n === 180 && (W = 60), e >= 56 && e < 64 && n >= 3 && n < 12 && (W = 32), e >= 72 && e < 84 && (n >= 0 && n < 9 ? W = 31 : n >= 9 && n < 21 ? W = 33 : n >= 21 && n < 33 ? W = 35 : n >= 33 && n < 42 && (W = 37)), o = (W - 1) * 6 - 180 + 3, V = G_(o), m = s / (1 - s), g = a / Math.sqrt(1 - s * Math.sin(P) * Math.sin(P)), b = Math.tan(P) * Math.tan(P), T = m * Math.cos(P) * Math.cos(P), M = Math.cos(P) * (z - V), I = a * ((1 - s / 4 - 3 * s * s / 64 - 5 * s * s * s / 256) * P - (3 * s / 8 + 3 * s * s / 32 + 45 * s * s * s / 1024) * Math.sin(2 * P) + (15 * s * s / 256 + 45 * s * s * s / 1024) * Math.sin(4 * P) - 35 * s * s * s / 3072 * Math.sin(6 * P));
  var X = h * g * (M + (1 - b + T) * M * M * M / 6 + (5 - 18 * b + b * b + 72 * T - 58 * m) * M * M * M * M * M / 120) + 5e5, K = h * (I + g * Math.tan(P) * (M * M / 2 + (5 - b + 9 * T + 4 * T * T) * M * M * M * M / 24 + (61 - 58 * b + b * b + 600 * T - 330 * m) * M * M * M * M * M * M / 720));
  return e < 0 && (K += 1e7), {
    northing: Math.round(K),
    easting: Math.round(X),
    zoneNumber: W,
    zoneLetter: oN(e)
  };
}
function V1(t) {
  var e = t.northing, n = t.easting, a = t.zoneLetter, s = t.zoneNumber;
  if (s < 0 || s > 60)
    return null;
  var h = 0.9996, o = 6378137, m = 669438e-8, g, b = (1 - Math.sqrt(1 - m)) / (1 + Math.sqrt(1 - m)), T, M, I, P, z, V, W, X, K, se = n - 5e5, pe = e;
  a < "N" && (pe -= 1e7), W = (s - 1) * 6 - 180 + 3, g = m / (1 - m), V = pe / h, X = V / (o * (1 - m / 4 - 3 * m * m / 64 - 5 * m * m * m / 256)), K = X + (3 * b / 2 - 27 * b * b * b / 32) * Math.sin(2 * X) + (21 * b * b / 16 - 55 * b * b * b * b / 32) * Math.sin(4 * X) + 151 * b * b * b / 96 * Math.sin(6 * X), T = o / Math.sqrt(1 - m * Math.sin(K) * Math.sin(K)), M = Math.tan(K) * Math.tan(K), I = g * Math.cos(K) * Math.cos(K), P = o * (1 - m) / Math.pow(1 - m * Math.sin(K) * Math.sin(K), 1.5), z = se / (T * h);
  var xe = K - T * Math.tan(K) / P * (z * z / 2 - (5 + 3 * M + 10 * I - 4 * I * I - 9 * g) * z * z * z * z / 24 + (61 + 90 * M + 298 * I + 45 * M * M - 252 * g - 3 * I * I) * z * z * z * z * z * z / 720);
  xe = qw(xe);
  var Fe = (z - (1 + 2 * M + I) * z * z * z / 6 + (5 - 2 * I + 28 * M - 3 * I * I + 8 * g + 24 * M * M) * z * z * z * z * z / 120) / Math.cos(K);
  Fe = W + qw(Fe);
  var ze;
  if (t.accuracy) {
    var Pe = V1({
      northing: t.northing + t.accuracy,
      easting: t.easting + t.accuracy,
      zoneLetter: t.zoneLetter,
      zoneNumber: t.zoneNumber
    });
    ze = {
      top: Pe.lat,
      right: Pe.lon,
      bottom: xe,
      left: Fe
    };
  } else
    ze = {
      lat: xe,
      lon: Fe
    };
  return ze;
}
function oN(t) {
  var e = "Z";
  return 84 >= t && t >= 72 ? e = "X" : 72 > t && t >= 64 ? e = "W" : 64 > t && t >= 56 ? e = "V" : 56 > t && t >= 48 ? e = "U" : 48 > t && t >= 40 ? e = "T" : 40 > t && t >= 32 ? e = "S" : 32 > t && t >= 24 ? e = "R" : 24 > t && t >= 16 ? e = "Q" : 16 > t && t >= 8 ? e = "P" : 8 > t && t >= 0 ? e = "N" : 0 > t && t >= -8 ? e = "M" : -8 > t && t >= -16 ? e = "L" : -16 > t && t >= -24 ? e = "K" : -24 > t && t >= -32 ? e = "J" : -32 > t && t >= -40 ? e = "H" : -40 > t && t >= -48 ? e = "G" : -48 > t && t >= -56 ? e = "F" : -56 > t && t >= -64 ? e = "E" : -64 > t && t >= -72 ? e = "D" : -72 > t && t >= -80 && (e = "C"), e;
}
function aN(t, e) {
  var n = "00000" + t.easting, a = "00000" + t.northing;
  return t.zoneNumber + t.zoneLetter + sN(t.easting, t.northing, t.zoneNumber) + n.substr(n.length - 5, e) + a.substr(a.length - 5, e);
}
function sN(t, e, n) {
  var a = ST(n), s = Math.floor(t / 1e5), h = Math.floor(e / 1e5) % 20;
  return lN(s, h, a);
}
function ST(t) {
  var e = t % Gw;
  return e === 0 && (e = Gw), e;
}
function lN(t, e, n) {
  var a = n - 1, s = xT.charCodeAt(a), h = bT.charCodeAt(a), o = s + t - 1, m = h + e, g = !1;
  o > ed && (o = o - ed + gf - 1, g = !0), (o === Qo || s < Qo && o > Qo || (o > Qo || s < Qo) && g) && o++, (o === Ca || s < Ca && o > Ca || (o > Ca || s < Ca) && g) && (o++, o === Qo && o++), o > ed && (o = o - ed + gf - 1), m > Qp ? (m = m - Qp + gf - 1, g = !0) : g = !1, (m === Qo || h < Qo && m > Qo || (m > Qo || h < Qo) && g) && m++, (m === Ca || h < Ca && m > Ca || (m > Ca || h < Ca) && g) && (m++, m === Qo && m++), m > Qp && (m = m - Qp + gf - 1);
  var b = String.fromCharCode(o) + String.fromCharCode(m);
  return b;
}
function TT(t) {
  if (t && t.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var e = t.length, n = null, a = "", s, h = 0; !/[A-Z]/.test(s = t.charAt(h)); ) {
    if (h >= 2)
      throw "MGRSPoint bad conversion from: " + t;
    a += s, h++;
  }
  var o = parseInt(a, 10);
  if (h === 0 || h + 3 > e)
    throw "MGRSPoint bad conversion from: " + t;
  var m = t.charAt(h++);
  if (m <= "A" || m === "B" || m === "Y" || m >= "Z" || m === "I" || m === "O")
    throw "MGRSPoint zone letter " + m + " not handled: " + t;
  n = t.substring(h, h += 2);
  for (var g = ST(o), b = uN(n.charAt(0), g), T = cN(n.charAt(1), g); T < hN(m); )
    T += 2e6;
  var M = e - h;
  if (M % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + t;
  var I = M / 2, P = 0, z = 0, V, W, X, K, se;
  return I > 0 && (V = 1e5 / Math.pow(10, I), W = t.substring(h, h + I), P = parseFloat(W) * V, X = t.substring(h + I), z = parseFloat(X) * V), K = P + b, se = z + T, {
    easting: K,
    northing: se,
    zoneLetter: m,
    zoneNumber: o,
    accuracy: V
  };
}
function uN(t, e) {
  for (var n = xT.charCodeAt(e - 1), a = 1e5, s = !1; n !== t.charCodeAt(0); ) {
    if (n++, n === Qo && n++, n === Ca && n++, n > ed) {
      if (s)
        throw "Bad character: " + t;
      n = gf, s = !0;
    }
    a += 1e5;
  }
  return a;
}
function cN(t, e) {
  if (t > "V")
    throw "MGRSPoint given invalid Northing " + t;
  for (var n = bT.charCodeAt(e - 1), a = 0, s = !1; n !== t.charCodeAt(0); ) {
    if (n++, n === Qo && n++, n === Ca && n++, n > Qp) {
      if (s)
        throw "Bad character: " + t;
      n = gf, s = !0;
    }
    a += 1e5;
  }
  return a;
}
function hN(t) {
  var e;
  switch (t) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0)
    return e;
  throw "Invalid zone letter: " + t;
}
function Lf(t, e, n) {
  if (!(this instanceof Lf))
    return new Lf(t, e, n);
  if (Array.isArray(t))
    this.x = t[0], this.y = t[1], this.z = t[2] || 0;
  else if (typeof t == "object")
    this.x = t.x, this.y = t.y, this.z = t.z || 0;
  else if (typeof t == "string" && typeof e > "u") {
    var a = t.split(",");
    this.x = parseFloat(a[0], 10), this.y = parseFloat(a[1], 10), this.z = parseFloat(a[2], 10) || 0;
  } else
    this.x = t, this.y = e, this.z = n || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Lf.fromMGRS = function(t) {
  return new Lf(ET(t));
};
Lf.prototype.toMGRS = function(t) {
  return wT([this.x, this.y], t);
};
var fN = 1, pN = 0.25, $w = 0.046875, Ww = 0.01953125, Hw = 0.01068115234375, dN = 0.75, mN = 0.46875, yN = 0.013020833333333334, gN = 0.007120768229166667, vN = 0.3645833333333333, _N = 0.005696614583333333, xN = 0.3076171875;
function MT(t) {
  var e = [];
  e[0] = fN - t * (pN + t * ($w + t * (Ww + t * Hw))), e[1] = t * (dN - t * ($w + t * (Ww + t * Hw)));
  var n = t * t;
  return e[2] = n * (mN - t * (yN + t * gN)), n *= t, e[3] = n * (vN - t * _N), e[4] = n * t * xN, e;
}
function Sv(t, e, n, a) {
  return n *= e, e *= e, a[0] * t - n * (a[1] + e * (a[2] + e * (a[3] + e * a[4])));
}
var bN = 20;
function IT(t, e, n) {
  for (var a = 1 / (1 - e), s = t, h = bN; h; --h) {
    var o = Math.sin(s), m = 1 - e * o * o;
    if (m = (Sv(s, o, Math.cos(s), n) - t) * (m * Math.sqrt(m)) * a, s -= m, Math.abs(m) < Ct)
      return s;
  }
  return s;
}
function wN() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = MT(this.es), this.ml0 = Sv(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function EN(t) {
  var e = t.x, n = t.y, a = Vt(e - this.long0), s, h, o, m = Math.sin(n), g = Math.cos(n);
  if (this.es) {
    var T = g * a, M = Math.pow(T, 2), I = this.ep2 * Math.pow(g, 2), P = Math.pow(I, 2), z = Math.abs(g) > Ct ? Math.tan(n) : 0, V = Math.pow(z, 2), W = Math.pow(V, 2);
    s = 1 - this.es * Math.pow(m, 2), T = T / Math.sqrt(s);
    var X = Sv(n, m, g, this.en);
    h = this.a * (this.k0 * T * (1 + M / 6 * (1 - V + I + M / 20 * (5 - 18 * V + W + 14 * I - 58 * V * I + M / 42 * (61 + 179 * W - W * V - 479 * V))))) + this.x0, o = this.a * (this.k0 * (X - this.ml0 + m * a * T / 2 * (1 + M / 12 * (5 - V + 9 * I + 4 * P + M / 30 * (61 + W - 58 * V + 270 * I - 330 * V * I + M / 56 * (1385 + 543 * W - W * V - 3111 * V)))))) + this.y0;
  } else {
    var b = g * Math.sin(a);
    if (Math.abs(Math.abs(b) - 1) < Ct)
      return 93;
    if (h = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0, o = g * Math.cos(a) / Math.sqrt(1 - Math.pow(b, 2)), b = Math.abs(o), b >= 1) {
      if (b - 1 > Ct)
        return 93;
      o = 0;
    } else
      o = Math.acos(o);
    n < 0 && (o = -o), o = this.a * this.k0 * (o - this.lat0) + this.y0;
  }
  return t.x = h, t.y = o, t;
}
function SN(t) {
  var e, n, a, s, h = (t.x - this.x0) * (1 / this.a), o = (t.y - this.y0) * (1 / this.a);
  if (this.es)
    if (e = this.ml0 + o / this.k0, n = IT(e, this.es, this.en), Math.abs(n) < ft) {
      var M = Math.sin(n), I = Math.cos(n), P = Math.abs(I) > Ct ? Math.tan(n) : 0, z = this.ep2 * Math.pow(I, 2), V = Math.pow(z, 2), W = Math.pow(P, 2), X = Math.pow(W, 2);
      e = 1 - this.es * Math.pow(M, 2);
      var K = h * Math.sqrt(e) / this.k0, se = Math.pow(K, 2);
      e = e * P, a = n - e * se / (1 - this.es) * 0.5 * (1 - se / 12 * (5 + 3 * W - 9 * z * W + z - 4 * V - se / 30 * (61 + 90 * W - 252 * z * W + 45 * X + 46 * z - se / 56 * (1385 + 3633 * W + 4095 * X + 1574 * X * W)))), s = Vt(this.long0 + K * (1 - se / 6 * (1 + 2 * W + z - se / 20 * (5 + 28 * W + 24 * X + 8 * z * W + 6 * z - se / 42 * (61 + 662 * W + 1320 * X + 720 * X * W)))) / I);
    } else
      a = ft * Gd(o), s = 0;
  else {
    var m = Math.exp(h / this.k0), g = 0.5 * (m - 1 / m), b = this.lat0 + o / this.k0, T = Math.cos(b);
    e = Math.sqrt((1 - Math.pow(T, 2)) / (1 + Math.pow(g, 2))), a = Math.asin(e), o < 0 && (a = -a), g === 0 && T === 0 ? s = 0 : s = Vt(Math.atan2(g, T) + this.long0);
  }
  return t.x = s, t.y = a, t;
}
var TN = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const og = {
  init: wN,
  forward: EN,
  inverse: SN,
  names: TN
};
function OT(t) {
  var e = Math.exp(t);
  return e = (e - 1 / e) / 2, e;
}
function ns(t, e) {
  t = Math.abs(t), e = Math.abs(e);
  var n = Math.max(t, e), a = Math.min(t, e) / (n || 1);
  return n * Math.sqrt(1 + Math.pow(a, 2));
}
function MN(t) {
  var e = 1 + t, n = e - 1;
  return n === 0 ? t : t * Math.log(e) / n;
}
function IN(t) {
  var e = Math.abs(t);
  return e = MN(e * (1 + e / (ns(1, e) + 1))), t < 0 ? -e : e;
}
function U1(t, e) {
  for (var n = 2 * Math.cos(2 * e), a = t.length - 1, s = t[a], h = 0, o; --a >= 0; )
    o = -h + n * s + t[a], h = s, s = o;
  return e + o * Math.sin(2 * e);
}
function ON(t, e) {
  for (var n = 2 * Math.cos(e), a = t.length - 1, s = t[a], h = 0, o; --a >= 0; )
    o = -h + n * s + t[a], h = s, s = o;
  return Math.sin(e) * o;
}
function CN(t) {
  var e = Math.exp(t);
  return e = (e + 1 / e) / 2, e;
}
function CT(t, e, n) {
  for (var a = Math.sin(e), s = Math.cos(e), h = OT(n), o = CN(n), m = 2 * s * o, g = -2 * a * h, b = t.length - 1, T = t[b], M = 0, I = 0, P = 0, z, V; --b >= 0; )
    z = I, V = M, I = T, M = P, T = -z + m * I - g * M + t[b], P = -V + g * I + m * M;
  return m = a * o, g = s * h, [m * T - g * P, m * P + g * T];
}
function AN() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (og.init.apply(this), this.forward = og.forward, this.inverse = og.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var t = this.es / (1 + Math.sqrt(1 - this.es)), e = t / (2 - t), n = e;
  this.cgb[0] = e * (2 + e * (-2 / 3 + e * (-2 + e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675)))))), this.cbg[0] = e * (-2 + e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725)))))), n = n * e, this.cgb[1] = n * (7 / 3 + e * (-8 / 5 + e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))))), this.cbg[1] = n * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), n = n * e, this.cgb[2] = n * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = n * (-26 / 15 + e * (34 / 21 + e * (8 / 5 + e * (-12686 / 2835)))), n = n * e, this.cgb[3] = n * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = n * (1237 / 630 + e * (-12 / 5 + e * (-24832 / 14175))), n = n * e, this.cgb[4] = n * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = n * (-734 / 315 + e * (109598 / 31185)), n = n * e, this.cgb[5] = n * (601676 / 22275), this.cbg[5] = n * (444337 / 155925), n = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + n * (1 / 4 + n * (1 / 64 + n / 256))), this.utg[0] = e * (-0.5 + e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800)))))), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = n * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = n * (13 / 48 + e * (-3 / 5 + e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))))), n = n * e, this.utg[2] = n * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = n * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), n = n * e, this.utg[3] = n * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = n * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), n = n * e, this.utg[4] = n * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = n * (34729 / 80640 + e * (-3418889 / 1995840)), n = n * e, this.utg[5] = n * (-20648693 / 638668800), this.gtu[5] = n * (212378941 / 319334400);
  var a = U1(this.cbg, this.lat0);
  this.Zb = -this.Qn * (a + ON(this.gtu, 2 * a));
}
function PN(t) {
  var e = Vt(t.x - this.long0), n = t.y;
  n = U1(this.cbg, n);
  var a = Math.sin(n), s = Math.cos(n), h = Math.sin(e), o = Math.cos(e);
  n = Math.atan2(a, o * s), e = Math.atan2(h * s, ns(a, s * o)), e = IN(Math.tan(e));
  var m = CT(this.gtu, 2 * n, 2 * e);
  n = n + m[0], e = e + m[1];
  var g, b;
  return Math.abs(e) <= 2.623395162778 ? (g = this.a * (this.Qn * e) + this.x0, b = this.a * (this.Qn * n + this.Zb) + this.y0) : (g = 1 / 0, b = 1 / 0), t.x = g, t.y = b, t;
}
function kN(t) {
  var e = (t.x - this.x0) * (1 / this.a), n = (t.y - this.y0) * (1 / this.a);
  n = (n - this.Zb) / this.Qn, e = e / this.Qn;
  var a, s;
  if (Math.abs(e) <= 2.623395162778) {
    var h = CT(this.utg, 2 * n, 2 * e);
    n = n + h[0], e = e + h[1], e = Math.atan(OT(e));
    var o = Math.sin(n), m = Math.cos(n), g = Math.sin(e), b = Math.cos(e);
    n = Math.atan2(o * b, ns(g, b * m)), e = Math.atan2(g, b * m), a = Vt(e + this.long0), s = U1(this.cgb, n);
  } else
    a = 1 / 0, s = 1 / 0;
  return t.x = a, t.y = s, t;
}
var LN = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
const ag = {
  init: AN,
  forward: PN,
  inverse: kN,
  names: LN
};
function DN(t, e) {
  if (t === void 0) {
    if (t = Math.floor((Vt(e) + Math.PI) * 30 / Math.PI) + 1, t < 0)
      return 0;
    if (t > 60)
      return 60;
  }
  return t;
}
var NN = "etmerc";
function RN() {
  var t = DN(this.zone, this.long0);
  if (t === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(t) - 183) * io, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, ag.init.apply(this), this.forward = ag.forward, this.inverse = ag.inverse;
}
var zN = ["Universal Transverse Mercator System", "utm"];
const FN = {
  init: RN,
  names: zN,
  dependsOn: NN
};
function j1(t, e) {
  return Math.pow((1 - t) / (1 + t), e);
}
var BN = 20;
function VN() {
  var t = Math.sin(this.lat0), e = Math.cos(this.lat0);
  e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(t / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + ln) / (Math.pow(Math.tan(0.5 * this.lat0 + ln), this.C) * j1(this.e * t, this.ratexp));
}
function UN(t) {
  var e = t.x, n = t.y;
  return t.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * n + ln), this.C) * j1(this.e * Math.sin(n), this.ratexp)) - ft, t.x = this.C * e, t;
}
function jN(t) {
  for (var e = 1e-14, n = t.x / this.C, a = t.y, s = Math.pow(Math.tan(0.5 * a + ln) / this.K, 1 / this.C), h = BN; h > 0 && (a = 2 * Math.atan(s * j1(this.e * Math.sin(t.y), -0.5 * this.e)) - ft, !(Math.abs(a - t.y) < e)); --h)
    t.y = a;
  return h ? (t.x = n, t.y = a, t) : null;
}
var GN = ["gauss"];
const G1 = {
  init: VN,
  forward: UN,
  inverse: jN,
  names: GN
};
function qN() {
  G1.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function $N(t) {
  var e, n, a, s;
  return t.x = Vt(t.x - this.long0), G1.forward.apply(this, [t]), e = Math.sin(t.y), n = Math.cos(t.y), a = Math.cos(t.x), s = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * n * a), t.x = s * n * Math.sin(t.x), t.y = s * (this.cosc0 * e - this.sinc0 * n * a), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
}
function WN(t) {
  var e, n, a, s, h;
  if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, h = Math.sqrt(t.x * t.x + t.y * t.y)) {
    var o = 2 * Math.atan2(h, this.R2);
    e = Math.sin(o), n = Math.cos(o), s = Math.asin(n * this.sinc0 + t.y * e * this.cosc0 / h), a = Math.atan2(t.x * e, h * this.cosc0 * n - t.y * this.sinc0 * e);
  } else
    s = this.phic0, a = 0;
  return t.x = a, t.y = s, G1.inverse.apply(this, [t]), t.x = Vt(t.x + this.long0), t;
}
var HN = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const ZN = {
  init: qN,
  forward: $N,
  inverse: WN,
  names: HN
};
function XN(t, e, n) {
  return e *= n, Math.tan(0.5 * (ft + t)) * Math.pow((1 - e) / (1 + e), 0.5 * n);
}
function KN() {
  this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Ct && (this.k0 = 0.5 * (1 + Gd(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= Ct && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Ct && (this.k0 = 0.5 * this.cons * Ys(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / ls(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = Ys(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - ft, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function YN(t) {
  var e = t.x, n = t.y, a = Math.sin(n), s = Math.cos(n), h, o, m, g, b, T, M = Vt(e - this.long0);
  return Math.abs(Math.abs(e - this.long0) - Math.PI) <= Ct && Math.abs(n + this.lat0) <= Ct ? (t.x = NaN, t.y = NaN, t) : this.sphere ? (h = 2 * this.k0 / (1 + this.sinlat0 * a + this.coslat0 * s * Math.cos(M)), t.x = this.a * h * s * Math.sin(M) + this.x0, t.y = this.a * h * (this.coslat0 * a - this.sinlat0 * s * Math.cos(M)) + this.y0, t) : (o = 2 * Math.atan(this.ssfn_(n, a, this.e)) - ft, g = Math.cos(o), m = Math.sin(o), Math.abs(this.coslat0) <= Ct ? (b = ls(this.e, n * this.con, this.con * a), T = 2 * this.a * this.k0 * b / this.cons, t.x = this.x0 + T * Math.sin(e - this.long0), t.y = this.y0 - this.con * T * Math.cos(e - this.long0), t) : (Math.abs(this.sinlat0) < Ct ? (h = 2 * this.a * this.k0 / (1 + g * Math.cos(M)), t.y = h * m) : (h = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * m + this.cosX0 * g * Math.cos(M))), t.y = h * (this.cosX0 * m - this.sinX0 * g * Math.cos(M)) + this.y0), t.x = h * g * Math.sin(M) + this.x0, t));
}
function JN(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n, a, s, h, o = Math.sqrt(t.x * t.x + t.y * t.y);
  if (this.sphere) {
    var m = 2 * Math.atan(o / (2 * this.a * this.k0));
    return e = this.long0, n = this.lat0, o <= Ct ? (t.x = e, t.y = n, t) : (n = Math.asin(Math.cos(m) * this.sinlat0 + t.y * Math.sin(m) * this.coslat0 / o), Math.abs(this.coslat0) < Ct ? this.lat0 > 0 ? e = Vt(this.long0 + Math.atan2(t.x, -1 * t.y)) : e = Vt(this.long0 + Math.atan2(t.x, t.y)) : e = Vt(this.long0 + Math.atan2(t.x * Math.sin(m), o * this.coslat0 * Math.cos(m) - t.y * this.sinlat0 * Math.sin(m))), t.x = e, t.y = n, t);
  } else if (Math.abs(this.coslat0) <= Ct) {
    if (o <= Ct)
      return n = this.lat0, e = this.long0, t.x = e, t.y = n, t;
    t.x *= this.con, t.y *= this.con, a = o * this.cons / (2 * this.a * this.k0), n = this.con * Ld(this.e, a), e = this.con * Vt(this.con * this.long0 + Math.atan2(t.x, -1 * t.y));
  } else
    s = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, o <= Ct ? h = this.X0 : (h = Math.asin(Math.cos(s) * this.sinX0 + t.y * Math.sin(s) * this.cosX0 / o), e = Vt(this.long0 + Math.atan2(t.x * Math.sin(s), o * this.cosX0 * Math.cos(s) - t.y * this.sinX0 * Math.sin(s)))), n = -1 * Ld(this.e, Math.tan(0.5 * (ft + h)));
  return t.x = e, t.y = n, t;
}
var QN = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
const e3 = {
  init: KN,
  forward: YN,
  inverse: JN,
  names: QN,
  ssfn_: XN
};
function t3() {
  var t = this.lat0;
  this.lambda0 = this.long0;
  var e = Math.sin(t), n = this.a, a = this.rf, s = 1 / a, h = 2 * s - Math.pow(s, 2), o = this.e = Math.sqrt(h);
  this.R = this.k0 * n * Math.sqrt(1 - h) / (1 - h * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + h / (1 - h) * Math.pow(Math.cos(t), 4)), this.b0 = Math.asin(e / this.alpha);
  var m = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), g = Math.log(Math.tan(Math.PI / 4 + t / 2)), b = Math.log((1 + o * e) / (1 - o * e));
  this.K = m - this.alpha * g + this.alpha * o / 2 * b;
}
function r3(t) {
  var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)), n = this.e / 2 * Math.log((1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))), a = -this.alpha * (e + n) + this.K, s = 2 * (Math.atan(Math.exp(a)) - Math.PI / 4), h = this.alpha * (t.x - this.lambda0), o = Math.atan(Math.sin(h) / (Math.sin(this.b0) * Math.tan(s) + Math.cos(this.b0) * Math.cos(h))), m = Math.asin(Math.cos(this.b0) * Math.sin(s) - Math.sin(this.b0) * Math.cos(s) * Math.cos(h));
  return t.y = this.R / 2 * Math.log((1 + Math.sin(m)) / (1 - Math.sin(m))) + this.y0, t.x = this.R * o + this.x0, t;
}
function n3(t) {
  for (var e = t.x - this.x0, n = t.y - this.y0, a = e / this.R, s = 2 * (Math.atan(Math.exp(n / this.R)) - Math.PI / 4), h = Math.asin(Math.cos(this.b0) * Math.sin(s) + Math.sin(this.b0) * Math.cos(s) * Math.cos(a)), o = Math.atan(Math.sin(a) / (Math.cos(this.b0) * Math.cos(a) - Math.sin(this.b0) * Math.tan(s))), m = this.lambda0 + o / this.alpha, g = 0, b = h, T = -1e3, M = 0; Math.abs(b - T) > 1e-7; ) {
    if (++M > 20)
      return;
    g = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + h / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(b)) / 2)), T = b, b = 2 * Math.atan(Math.exp(g)) - Math.PI / 2;
  }
  return t.x = m, t.y = b, t;
}
var i3 = ["somerc"];
const o3 = {
  init: t3,
  forward: r3,
  inverse: n3,
  names: i3
};
var cf = 1e-7;
function a3(t) {
  var e = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], n = typeof t.PROJECTION == "object" ? Object.keys(t.PROJECTION)[0] : t.PROJECTION;
  return "no_uoff" in t || "no_off" in t || e.indexOf(n) !== -1;
}
function s3() {
  var t, e, n, a, s, h, o, m, g, b, T = 0, M, I = 0, P = 0, z = 0, V = 0, W = 0, X = 0;
  this.no_off = a3(this), this.no_rot = "no_rot" in this;
  var K = !1;
  "alpha" in this && (K = !0);
  var se = !1;
  if ("rectified_grid_angle" in this && (se = !0), K && (X = this.alpha), se && (T = this.rectified_grid_angle * io), K || se)
    I = this.longc;
  else if (P = this.long1, V = this.lat1, z = this.long2, W = this.lat2, Math.abs(V - W) <= cf || (t = Math.abs(V)) <= cf || Math.abs(t - ft) <= cf || Math.abs(Math.abs(this.lat0) - ft) <= cf || Math.abs(Math.abs(W) - ft) <= cf)
    throw new Error();
  var pe = 1 - this.es;
  e = Math.sqrt(pe), Math.abs(this.lat0) > Ct ? (m = Math.sin(this.lat0), n = Math.cos(this.lat0), t = 1 - this.es * m * m, this.B = n * n, this.B = Math.sqrt(1 + this.es * this.B * this.B / pe), this.A = this.B * this.k0 * e / t, a = this.B * e / (n * Math.sqrt(t)), s = a * a - 1, s <= 0 ? s = 0 : (s = Math.sqrt(s), this.lat0 < 0 && (s = -s)), this.E = s += a, this.E *= Math.pow(ls(this.e, this.lat0, m), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = a = s = 1), K || se ? (K ? (M = Math.asin(Math.sin(X) / a), se || (T = X)) : (M = T, X = Math.asin(a * Math.sin(M))), this.lam0 = I - Math.asin(0.5 * (s - 1 / s) * Math.tan(M)) / this.B) : (h = Math.pow(ls(this.e, V, Math.sin(V)), this.B), o = Math.pow(ls(this.e, W, Math.sin(W)), this.B), s = this.E / h, g = (o - h) / (o + h), b = this.E * this.E, b = (b - o * h) / (b + o * h), t = P - z, t < -Math.pi ? z -= Pd : t > Math.pi && (z += Pd), this.lam0 = Vt(0.5 * (P + z) - Math.atan(b * Math.tan(0.5 * this.B * (P - z)) / g) / this.B), M = Math.atan(2 * Math.sin(this.B * Vt(P - this.lam0)) / (s - 1 / s)), T = X = Math.asin(a * Math.sin(M))), this.singam = Math.sin(M), this.cosgam = Math.cos(M), this.sinrot = Math.sin(T), this.cosrot = Math.cos(T), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(a * a - 1) / Math.cos(X))), this.lat0 < 0 && (this.u_0 = -this.u_0)), s = 0.5 * M, this.v_pole_n = this.ArB * Math.log(Math.tan(ln - s)), this.v_pole_s = this.ArB * Math.log(Math.tan(ln + s));
}
function l3(t) {
  var e = {}, n, a, s, h, o, m, g, b;
  if (t.x = t.x - this.lam0, Math.abs(Math.abs(t.y) - ft) > Ct) {
    if (o = this.E / Math.pow(ls(this.e, t.y, Math.sin(t.y)), this.B), m = 1 / o, n = 0.5 * (o - m), a = 0.5 * (o + m), h = Math.sin(this.B * t.x), s = (n * this.singam - h * this.cosgam) / a, Math.abs(Math.abs(s) - 1) < Ct)
      throw new Error();
    b = 0.5 * this.ArB * Math.log((1 - s) / (1 + s)), m = Math.cos(this.B * t.x), Math.abs(m) < cf ? g = this.A * t.x : g = this.ArB * Math.atan2(n * this.cosgam + h * this.singam, m);
  } else
    b = t.y > 0 ? this.v_pole_n : this.v_pole_s, g = this.ArB * t.y;
  return this.no_rot ? (e.x = g, e.y = b) : (g -= this.u_0, e.x = b * this.cosrot + g * this.sinrot, e.y = g * this.cosrot - b * this.sinrot), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function u3(t) {
  var e, n, a, s, h, o, m, g = {};
  if (t.x = (t.x - this.x0) * (1 / this.a), t.y = (t.y - this.y0) * (1 / this.a), this.no_rot ? (n = t.y, e = t.x) : (n = t.x * this.cosrot - t.y * this.sinrot, e = t.y * this.cosrot + t.x * this.sinrot + this.u_0), a = Math.exp(-this.BrA * n), s = 0.5 * (a - 1 / a), h = 0.5 * (a + 1 / a), o = Math.sin(this.BrA * e), m = (o * this.cosgam + s * this.singam) / h, Math.abs(Math.abs(m) - 1) < Ct)
    g.x = 0, g.y = m < 0 ? -ft : ft;
  else {
    if (g.y = this.E / Math.sqrt((1 + m) / (1 - m)), g.y = Ld(this.e, Math.pow(g.y, 1 / this.B)), g.y === 1 / 0)
      throw new Error();
    g.x = -this.rB * Math.atan2(s * this.cosgam - o * this.singam, Math.cos(this.BrA * e));
  }
  return g.x += this.lam0, g;
}
var c3 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const h3 = {
  init: s3,
  forward: l3,
  inverse: u3,
  names: c3
};
function f3() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < Ct)) {
    var t = this.b / this.a;
    this.e = Math.sqrt(1 - t * t);
    var e = Math.sin(this.lat1), n = Math.cos(this.lat1), a = Ys(this.e, e, n), s = ls(this.e, this.lat1, e), h = Math.sin(this.lat2), o = Math.cos(this.lat2), m = Ys(this.e, h, o), g = ls(this.e, this.lat2, h), b = ls(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > Ct ? this.ns = Math.log(a / m) / Math.log(s / g) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = a / (this.ns * Math.pow(s, this.ns)), this.rh = this.a * this.f0 * Math.pow(b, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function p3(t) {
  var e = t.x, n = t.y;
  Math.abs(2 * Math.abs(n) - Math.PI) <= Ct && (n = Gd(n) * (ft - 2 * Ct));
  var a = Math.abs(Math.abs(n) - ft), s, h;
  if (a > Ct)
    s = ls(this.e, n, Math.sin(n)), h = this.a * this.f0 * Math.pow(s, this.ns);
  else {
    if (a = n * this.ns, a <= 0)
      return null;
    h = 0;
  }
  var o = this.ns * Vt(e - this.long0);
  return t.x = this.k0 * (h * Math.sin(o)) + this.x0, t.y = this.k0 * (this.rh - h * Math.cos(o)) + this.y0, t;
}
function d3(t) {
  var e, n, a, s, h, o = (t.x - this.x0) / this.k0, m = this.rh - (t.y - this.y0) / this.k0;
  this.ns > 0 ? (e = Math.sqrt(o * o + m * m), n = 1) : (e = -Math.sqrt(o * o + m * m), n = -1);
  var g = 0;
  if (e !== 0 && (g = Math.atan2(n * o, n * m)), e !== 0 || this.ns > 0) {
    if (n = 1 / this.ns, a = Math.pow(e / (this.a * this.f0), n), s = Ld(this.e, a), s === -9999)
      return null;
  } else
    s = -ft;
  return h = Vt(g / this.ns + this.long0), t.x = h, t.y = s, t;
}
var m3 = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const y3 = {
  init: f3,
  forward: p3,
  inverse: d3,
  names: m3
};
function g3() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function v3(t) {
  var e, n, a, s, h, o, m, g = t.x, b = t.y, T = Vt(g - this.long0);
  return e = Math.pow((1 + this.e * Math.sin(b)) / (1 - this.e * Math.sin(b)), this.alfa * this.e / 2), n = 2 * (Math.atan(this.k * Math.pow(Math.tan(b / 2 + this.s45), this.alfa) / e) - this.s45), a = -T * this.alfa, s = Math.asin(Math.cos(this.ad) * Math.sin(n) + Math.sin(this.ad) * Math.cos(n) * Math.cos(a)), h = Math.asin(Math.cos(n) * Math.sin(a) / Math.cos(s)), o = this.n * h, m = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n), t.y = m * Math.cos(o) / 1, t.x = m * Math.sin(o) / 1, this.czech || (t.y *= -1, t.x *= -1), t;
}
function _3(t) {
  var e, n, a, s, h, o, m, g, b = t.x;
  t.x = t.y, t.y = b, this.czech || (t.y *= -1, t.x *= -1), o = Math.sqrt(t.x * t.x + t.y * t.y), h = Math.atan2(t.y, t.x), s = h / Math.sin(this.s0), a = 2 * (Math.atan(Math.pow(this.ro0 / o, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(a) - Math.sin(this.ad) * Math.cos(a) * Math.cos(s)), n = Math.asin(Math.cos(a) * Math.sin(s) / Math.cos(e)), t.x = this.long0 - n / this.alfa, m = e, g = 0;
  var T = 0;
  do
    t.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(m)) / (1 - this.e * Math.sin(m)), this.e / 2)) - this.s45), Math.abs(m - t.y) < 1e-10 && (g = 1), m = t.y, T += 1;
  while (g === 0 && T < 15);
  return T >= 15 ? null : t;
}
var x3 = ["Krovak", "krovak"];
const b3 = {
  init: g3,
  forward: v3,
  inverse: _3,
  names: x3
};
function zo(t, e, n, a, s) {
  return t * s - e * Math.sin(2 * s) + n * Math.sin(4 * s) - a * Math.sin(6 * s);
}
function qd(t) {
  return 1 - 0.25 * t * (1 + t / 16 * (3 + 1.25 * t));
}
function $d(t) {
  return 0.375 * t * (1 + 0.25 * t * (1 + 0.46875 * t));
}
function Wd(t) {
  return 0.05859375 * t * t * (1 + 0.75 * t);
}
function Hd(t) {
  return t * t * t * (35 / 3072);
}
function Df(t, e, n) {
  var a = e * n;
  return t / Math.sqrt(1 - a * a);
}
function zf(t) {
  return Math.abs(t) < ft ? t : t - Gd(t) * Math.PI;
}
function kg(t, e, n, a, s) {
  var h, o;
  h = t / e;
  for (var m = 0; m < 15; m++)
    if (o = (t - (e * h - n * Math.sin(2 * h) + a * Math.sin(4 * h) - s * Math.sin(6 * h))) / (e - 2 * n * Math.cos(2 * h) + 4 * a * Math.cos(4 * h) - 6 * s * Math.cos(6 * h)), h += o, Math.abs(o) <= 1e-10)
      return h;
  return NaN;
}
function w3() {
  this.sphere || (this.e0 = qd(this.es), this.e1 = $d(this.es), this.e2 = Wd(this.es), this.e3 = Hd(this.es), this.ml0 = this.a * zo(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function E3(t) {
  var e, n, a = t.x, s = t.y;
  if (a = Vt(a - this.long0), this.sphere)
    e = this.a * Math.asin(Math.cos(s) * Math.sin(a)), n = this.a * (Math.atan2(Math.tan(s), Math.cos(a)) - this.lat0);
  else {
    var h = Math.sin(s), o = Math.cos(s), m = Df(this.a, this.e, h), g = Math.tan(s) * Math.tan(s), b = a * Math.cos(s), T = b * b, M = this.es * o * o / (1 - this.es), I = this.a * zo(this.e0, this.e1, this.e2, this.e3, s);
    e = m * b * (1 - T * g * (1 / 6 - (8 - g + 8 * M) * T / 120)), n = I - this.ml0 + m * h / o * T * (0.5 + (5 - g + 6 * M) * T / 24);
  }
  return t.x = e + this.x0, t.y = n + this.y0, t;
}
function S3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = t.x / this.a, n = t.y / this.a, a, s;
  if (this.sphere) {
    var h = n + this.lat0;
    a = Math.asin(Math.sin(h) * Math.cos(e)), s = Math.atan2(Math.tan(e), Math.cos(h));
  } else {
    var o = this.ml0 / this.a + n, m = kg(o, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(m) - ft) <= Ct)
      return t.x = this.long0, t.y = ft, n < 0 && (t.y *= -1), t;
    var g = Df(this.a, this.e, Math.sin(m)), b = g * g * g / this.a / this.a * (1 - this.es), T = Math.pow(Math.tan(m), 2), M = e * this.a / g, I = M * M;
    a = m - g * Math.tan(m) / b * M * M * (0.5 - (1 + 3 * T) * M * M / 24), s = M * (1 - I * (T / 3 + (1 + 3 * T) * T * I / 15)) / Math.cos(m);
  }
  return t.x = Vt(s + this.long0), t.y = zf(a), t;
}
var T3 = ["Cassini", "Cassini_Soldner", "cass"];
const M3 = {
  init: w3,
  forward: E3,
  inverse: S3,
  names: T3
};
function Cu(t, e) {
  var n;
  return t > 1e-7 ? (n = t * e, (1 - t * t) * (e / (1 - n * n) - 0.5 / t * Math.log((1 - n) / (1 + n)))) : 2 * e;
}
var I3 = 1, O3 = 2, C3 = 3, A3 = 4;
function P3() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - ft) < Ct ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(t) < Ct ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
    var e;
    switch (this.qp = Cu(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = V3(this.es), this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = Cu(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function k3(t) {
  var e, n, a, s, h, o, m, g, b, T, M = t.x, I = t.y;
  if (M = Vt(M - this.long0), this.sphere) {
    if (h = Math.sin(I), T = Math.cos(I), a = Math.cos(M), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (n = this.mode === this.EQUIT ? 1 + T * a : 1 + this.sinph0 * h + this.cosph0 * T * a, n <= Ct)
        return null;
      n = Math.sqrt(2 / n), e = n * T * Math.sin(M), n *= this.mode === this.EQUIT ? h : this.cosph0 * h - this.sinph0 * T * a;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (a = -a), Math.abs(I + this.lat0) < Ct)
        return null;
      n = ln - I * 0.5, n = 2 * (this.mode === this.S_POLE ? Math.cos(n) : Math.sin(n)), e = n * Math.sin(M), n *= a;
    }
  } else {
    switch (m = 0, g = 0, b = 0, a = Math.cos(M), s = Math.sin(M), h = Math.sin(I), o = Cu(this.e, h), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (m = o / this.qp, g = Math.sqrt(1 - m * m)), this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * m + this.cosb1 * g * a;
        break;
      case this.EQUIT:
        b = 1 + g * a;
        break;
      case this.N_POLE:
        b = ft + I, o = this.qp - o;
        break;
      case this.S_POLE:
        b = I - ft, o = this.qp + o;
        break;
    }
    if (Math.abs(b) < Ct)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b), this.mode === this.OBLIQ ? n = this.ymf * b * (this.cosb1 * m - this.sinb1 * g * a) : n = (b = Math.sqrt(2 / (1 + g * a))) * m * this.ymf, e = this.xmf * b * g * s;
        break;
      case this.N_POLE:
      case this.S_POLE:
        o >= 0 ? (e = (b = Math.sqrt(o)) * s, n = a * (this.mode === this.S_POLE ? b : -b)) : e = n = 0;
        break;
    }
  }
  return t.x = this.a * e + this.x0, t.y = this.a * n + this.y0, t;
}
function L3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = t.x / this.a, n = t.y / this.a, a, s, h, o, m, g, b;
  if (this.sphere) {
    var T = 0, M, I = 0;
    if (M = Math.sqrt(e * e + n * n), s = M * 0.5, s > 1)
      return null;
    switch (s = 2 * Math.asin(s), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (I = Math.sin(s), T = Math.cos(s)), this.mode) {
      case this.EQUIT:
        s = Math.abs(M) <= Ct ? 0 : Math.asin(n * I / M), e *= I, n = T * M;
        break;
      case this.OBLIQ:
        s = Math.abs(M) <= Ct ? this.lat0 : Math.asin(T * this.sinph0 + n * I * this.cosph0 / M), e *= I * this.cosph0, n = (T - Math.sin(s) * this.sinph0) * M;
        break;
      case this.N_POLE:
        n = -n, s = ft - s;
        break;
      case this.S_POLE:
        s -= ft;
        break;
    }
    a = n === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(e, n);
  } else {
    if (b = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (e /= this.dd, n *= this.dd, g = Math.sqrt(e * e + n * n), g < Ct)
        return t.x = this.long0, t.y = this.lat0, t;
      o = 2 * Math.asin(0.5 * g / this.rq), h = Math.cos(o), e *= o = Math.sin(o), this.mode === this.OBLIQ ? (b = h * this.sinb1 + n * o * this.cosb1 / g, m = this.qp * b, n = g * this.cosb1 * h - n * this.sinb1 * o) : (b = n * o / g, m = this.qp * b, n = g * h);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), m = e * e + n * n, !m)
        return t.x = this.long0, t.y = this.lat0, t;
      b = 1 - m / this.qp, this.mode === this.S_POLE && (b = -b);
    }
    a = Math.atan2(e, n), s = U3(Math.asin(b), this.apa);
  }
  return t.x = Vt(this.long0 + a), t.y = s, t;
}
var D3 = 0.3333333333333333, N3 = 0.17222222222222222, R3 = 0.10257936507936508, z3 = 0.06388888888888888, F3 = 0.0664021164021164, B3 = 0.016415012942191543;
function V3(t) {
  var e, n = [];
  return n[0] = t * D3, e = t * t, n[0] += e * N3, n[1] = e * z3, e *= t, n[0] += e * R3, n[1] += e * F3, n[2] = e * B3, n;
}
function U3(t, e) {
  var n = t + t;
  return t + e[0] * Math.sin(n) + e[1] * Math.sin(n + n) + e[2] * Math.sin(n + n + n);
}
var j3 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const G3 = {
  init: P3,
  forward: k3,
  inverse: L3,
  names: j3,
  S_POLE: I3,
  N_POLE: O3,
  EQUIT: C3,
  OBLIQ: A3
};
function Ru(t) {
  return Math.abs(t) > 1 && (t = t > 1 ? 1 : -1), Math.asin(t);
}
function q3() {
  Math.abs(this.lat1 + this.lat2) < Ct || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = Ys(this.e3, this.sin_po, this.cos_po), this.qs1 = Cu(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = Ys(this.e3, this.sin_po, this.cos_po), this.qs2 = Cu(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Cu(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > Ct ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function $3(t) {
  var e = t.x, n = t.y;
  this.sin_phi = Math.sin(n), this.cos_phi = Math.cos(n);
  var a = Cu(this.e3, this.sin_phi), s = this.a * Math.sqrt(this.c - this.ns0 * a) / this.ns0, h = this.ns0 * Vt(e - this.long0), o = s * Math.sin(h) + this.x0, m = this.rh - s * Math.cos(h) + this.y0;
  return t.x = o, t.y = m, t;
}
function W3(t) {
  var e, n, a, s, h, o;
  return t.x -= this.x0, t.y = this.rh - t.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(t.x * t.x + t.y * t.y), a = 1) : (e = -Math.sqrt(t.x * t.x + t.y * t.y), a = -1), s = 0, e !== 0 && (s = Math.atan2(a * t.x, a * t.y)), a = e * this.ns0 / this.a, this.sphere ? o = Math.asin((this.c - a * a) / (2 * this.ns0)) : (n = (this.c - a * a) / this.ns0, o = this.phi1z(this.e3, n)), h = Vt(s / this.ns0 + this.long0), t.x = h, t.y = o, t;
}
function H3(t, e) {
  var n, a, s, h, o, m = Ru(0.5 * e);
  if (t < Ct)
    return m;
  for (var g = t * t, b = 1; b <= 25; b++)
    if (n = Math.sin(m), a = Math.cos(m), s = t * n, h = 1 - s * s, o = 0.5 * h * h / a * (e / (1 - g) - n / h + 0.5 / t * Math.log((1 - s) / (1 + s))), m = m + o, Math.abs(o) <= 1e-7)
      return m;
  return null;
}
var Z3 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const X3 = {
  init: q3,
  forward: $3,
  inverse: W3,
  names: Z3,
  phi1z: H3
};
function K3() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function Y3(t) {
  var e, n, a, s, h, o, m, g, b = t.x, T = t.y;
  return a = Vt(b - this.long0), e = Math.sin(T), n = Math.cos(T), s = Math.cos(a), o = this.sin_p14 * e + this.cos_p14 * n * s, h = 1, o > 0 || Math.abs(o) <= Ct ? (m = this.x0 + this.a * h * n * Math.sin(a) / o, g = this.y0 + this.a * h * (this.cos_p14 * e - this.sin_p14 * n * s) / o) : (m = this.x0 + this.infinity_dist * n * Math.sin(a), g = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * n * s)), t.x = m, t.y = g, t;
}
function J3(t) {
  var e, n, a, s, h, o;
  return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, (e = Math.sqrt(t.x * t.x + t.y * t.y)) ? (s = Math.atan2(e, this.rc), n = Math.sin(s), a = Math.cos(s), o = Ru(a * this.sin_p14 + t.y * n * this.cos_p14 / e), h = Math.atan2(t.x * n, e * this.cos_p14 * a - t.y * this.sin_p14 * n), h = Vt(this.long0 + h)) : (o = this.phic0, h = 0), t.x = h, t.y = o, t;
}
var Q3 = ["gnom"];
const eR = {
  init: K3,
  forward: Y3,
  inverse: J3,
  names: Q3
};
function tR(t, e) {
  var n = 1 - (1 - t * t) / (2 * t) * Math.log((1 - t) / (1 + t));
  if (Math.abs(Math.abs(e) - n) < 1e-6)
    return e < 0 ? -1 * ft : ft;
  for (var a = Math.asin(0.5 * e), s, h, o, m, g = 0; g < 30; g++)
    if (h = Math.sin(a), o = Math.cos(a), m = t * h, s = Math.pow(1 - m * m, 2) / (2 * o) * (e / (1 - t * t) - h / (1 - m * m) + 0.5 / t * Math.log((1 - m) / (1 + m))), a += s, Math.abs(s) <= 1e-10)
      return a;
  return NaN;
}
function rR() {
  this.sphere || (this.k0 = Ys(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function nR(t) {
  var e = t.x, n = t.y, a, s, h = Vt(e - this.long0);
  if (this.sphere)
    a = this.x0 + this.a * h * Math.cos(this.lat_ts), s = this.y0 + this.a * Math.sin(n) / Math.cos(this.lat_ts);
  else {
    var o = Cu(this.e, Math.sin(n));
    a = this.x0 + this.a * this.k0 * h, s = this.y0 + this.a * o * 0.5 / this.k0;
  }
  return t.x = a, t.y = s, t;
}
function iR(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n;
  return this.sphere ? (e = Vt(this.long0 + t.x / this.a / Math.cos(this.lat_ts)), n = Math.asin(t.y / this.a * Math.cos(this.lat_ts))) : (n = tR(this.e, 2 * t.y * this.k0 / this.a), e = Vt(this.long0 + t.x / (this.a * this.k0))), t.x = e, t.y = n, t;
}
var oR = ["cea"];
const aR = {
  init: rR,
  forward: nR,
  inverse: iR,
  names: oR
};
function sR() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function lR(t) {
  var e = t.x, n = t.y, a = Vt(e - this.long0), s = zf(n - this.lat0);
  return t.x = this.x0 + this.a * a * this.rc, t.y = this.y0 + this.a * s, t;
}
function uR(t) {
  var e = t.x, n = t.y;
  return t.x = Vt(this.long0 + (e - this.x0) / (this.a * this.rc)), t.y = zf(this.lat0 + (n - this.y0) / this.a), t;
}
var cR = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const hR = {
  init: sR,
  forward: lR,
  inverse: uR,
  names: cR
};
var Zw = 20;
function fR() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = qd(this.es), this.e1 = $d(this.es), this.e2 = Wd(this.es), this.e3 = Hd(this.es), this.ml0 = this.a * zo(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function pR(t) {
  var e = t.x, n = t.y, a, s, h, o = Vt(e - this.long0);
  if (h = o * Math.sin(n), this.sphere)
    Math.abs(n) <= Ct ? (a = this.a * o, s = -1 * this.a * this.lat0) : (a = this.a * Math.sin(h) / Math.tan(n), s = this.a * (zf(n - this.lat0) + (1 - Math.cos(h)) / Math.tan(n)));
  else if (Math.abs(n) <= Ct)
    a = this.a * o, s = -1 * this.ml0;
  else {
    var m = Df(this.a, this.e, Math.sin(n)) / Math.tan(n);
    a = m * Math.sin(h), s = this.a * zo(this.e0, this.e1, this.e2, this.e3, n) - this.ml0 + m * (1 - Math.cos(h));
  }
  return t.x = a + this.x0, t.y = s + this.y0, t;
}
function dR(t) {
  var e, n, a, s, h, o, m, g, b;
  if (a = t.x - this.x0, s = t.y - this.y0, this.sphere)
    if (Math.abs(s + this.a * this.lat0) <= Ct)
      e = Vt(a / this.a + this.long0), n = 0;
    else {
      o = this.lat0 + s / this.a, m = a * a / this.a / this.a + o * o, g = o;
      var T;
      for (h = Zw; h; --h)
        if (T = Math.tan(g), b = -1 * (o * (g * T + 1) - g - 0.5 * (g * g + m) * T) / ((g - o) / T - 1), g += b, Math.abs(b) <= Ct) {
          n = g;
          break;
        }
      e = Vt(this.long0 + Math.asin(a * Math.tan(g) / this.a) / Math.sin(n));
    }
  else if (Math.abs(s + this.ml0) <= Ct)
    n = 0, e = Vt(this.long0 + a / this.a);
  else {
    o = (this.ml0 + s) / this.a, m = a * a / this.a / this.a + o * o, g = o;
    var M, I, P, z, V;
    for (h = Zw; h; --h)
      if (V = this.e * Math.sin(g), M = Math.sqrt(1 - V * V) * Math.tan(g), I = this.a * zo(this.e0, this.e1, this.e2, this.e3, g), P = this.e0 - 2 * this.e1 * Math.cos(2 * g) + 4 * this.e2 * Math.cos(4 * g) - 6 * this.e3 * Math.cos(6 * g), z = I / this.a, b = (o * (M * z + 1) - z - 0.5 * M * (z * z + m)) / (this.es * Math.sin(2 * g) * (z * z + m - 2 * o * z) / (4 * M) + (o - z) * (M * P - 2 / Math.sin(2 * g)) - P), g -= b, Math.abs(b) <= Ct) {
        n = g;
        break;
      }
    M = Math.sqrt(1 - this.es * Math.pow(Math.sin(n), 2)) * Math.tan(n), e = Vt(this.long0 + Math.asin(a * M / this.a) / Math.sin(n));
  }
  return t.x = e, t.y = n, t;
}
var mR = ["Polyconic", "poly"];
const yR = {
  init: fR,
  forward: pR,
  inverse: dR,
  names: mR
};
function gR() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function vR(t) {
  var e, n = t.x, a = t.y, s = a - this.lat0, h = n - this.long0, o = s / dd * 1e-5, m = h, g = 1, b = 0;
  for (e = 1; e <= 10; e++)
    g = g * o, b = b + this.A[e] * g;
  var T = b, M = m, I = 1, P = 0, z, V, W = 0, X = 0;
  for (e = 1; e <= 6; e++)
    z = I * T - P * M, V = P * T + I * M, I = z, P = V, W = W + this.B_re[e] * I - this.B_im[e] * P, X = X + this.B_im[e] * I + this.B_re[e] * P;
  return t.x = X * this.a + this.x0, t.y = W * this.a + this.y0, t;
}
function _R(t) {
  var e, n = t.x, a = t.y, s = n - this.x0, h = a - this.y0, o = h / this.a, m = s / this.a, g = 1, b = 0, T, M, I = 0, P = 0;
  for (e = 1; e <= 6; e++)
    T = g * o - b * m, M = b * o + g * m, g = T, b = M, I = I + this.C_re[e] * g - this.C_im[e] * b, P = P + this.C_im[e] * g + this.C_re[e] * b;
  for (var z = 0; z < this.iterations; z++) {
    var V = I, W = P, X, K, se = o, pe = m;
    for (e = 2; e <= 6; e++)
      X = V * I - W * P, K = W * I + V * P, V = X, W = K, se = se + (e - 1) * (this.B_re[e] * V - this.B_im[e] * W), pe = pe + (e - 1) * (this.B_im[e] * V + this.B_re[e] * W);
    V = 1, W = 0;
    var xe = this.B_re[1], Fe = this.B_im[1];
    for (e = 2; e <= 6; e++)
      X = V * I - W * P, K = W * I + V * P, V = X, W = K, xe = xe + e * (this.B_re[e] * V - this.B_im[e] * W), Fe = Fe + e * (this.B_im[e] * V + this.B_re[e] * W);
    var ze = xe * xe + Fe * Fe;
    I = (se * xe + pe * Fe) / ze, P = (pe * xe - se * Fe) / ze;
  }
  var Pe = I, Se = P, Ie = 1, Je = 0;
  for (e = 1; e <= 9; e++)
    Ie = Ie * Pe, Je = Je + this.D[e] * Ie;
  var qe = this.lat0 + Je * dd * 1e5, at = this.long0 + Se;
  return t.x = at, t.y = qe, t;
}
var xR = ["New_Zealand_Map_Grid", "nzmg"];
const bR = {
  init: gR,
  forward: vR,
  inverse: _R,
  names: xR
};
function wR() {
}
function ER(t) {
  var e = t.x, n = t.y, a = Vt(e - this.long0), s = this.x0 + this.a * a, h = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + n / 2.5)) * 1.25;
  return t.x = s, t.y = h, t;
}
function SR(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = Vt(this.long0 + t.x / this.a), n = 2.5 * (Math.atan(Math.exp(0.8 * t.y / this.a)) - Math.PI / 4);
  return t.x = e, t.y = n, t;
}
var TR = ["Miller_Cylindrical", "mill"];
const MR = {
  init: wR,
  forward: ER,
  inverse: SR,
  names: TR
};
var IR = 20;
function OR() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = MT(this.es);
}
function CR(t) {
  var e, n, a = t.x, s = t.y;
  if (a = Vt(a - this.long0), this.sphere) {
    if (!this.m)
      s = this.n !== 1 ? Math.asin(this.n * Math.sin(s)) : s;
    else
      for (var h = this.n * Math.sin(s), o = IR; o; --o) {
        var m = (this.m * s + Math.sin(s) - h) / (this.m + Math.cos(s));
        if (s -= m, Math.abs(m) < Ct)
          break;
      }
    e = this.a * this.C_x * a * (this.m + Math.cos(s)), n = this.a * this.C_y * s;
  } else {
    var g = Math.sin(s), b = Math.cos(s);
    n = this.a * Sv(s, g, b, this.en), e = this.a * a * b / Math.sqrt(1 - this.es * g * g);
  }
  return t.x = e, t.y = n, t;
}
function AR(t) {
  var e, n, a, s;
  return t.x -= this.x0, a = t.x / this.a, t.y -= this.y0, e = t.y / this.a, this.sphere ? (e /= this.C_y, a = a / (this.C_x * (this.m + Math.cos(e))), this.m ? e = Ru((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = Ru(Math.sin(e) / this.n)), a = Vt(a + this.long0), e = zf(e)) : (e = IT(t.y / this.a, this.es, this.en), s = Math.abs(e), s < ft ? (s = Math.sin(e), n = this.long0 + t.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(e)), a = Vt(n)) : s - Ct < ft && (a = this.long0)), t.x = a, t.y = e, t;
}
var PR = ["Sinusoidal", "sinu"];
const kR = {
  init: OR,
  forward: CR,
  inverse: AR,
  names: PR
};
function LR() {
}
function DR(t) {
  for (var e = t.x, n = t.y, a = Vt(e - this.long0), s = n, h = Math.PI * Math.sin(n); ; ) {
    var o = -(s + Math.sin(s) - h) / (1 + Math.cos(s));
    if (s += o, Math.abs(o) < Ct)
      break;
  }
  s /= 2, Math.PI / 2 - Math.abs(n) < Ct && (a = 0);
  var m = 0.900316316158 * this.a * a * Math.cos(s) + this.x0, g = 1.4142135623731 * this.a * Math.sin(s) + this.y0;
  return t.x = m, t.y = g, t;
}
function NR(t) {
  var e, n;
  t.x -= this.x0, t.y -= this.y0, n = t.y / (1.4142135623731 * this.a), Math.abs(n) > 0.999999999999 && (n = 0.999999999999), e = Math.asin(n);
  var a = Vt(this.long0 + t.x / (0.900316316158 * this.a * Math.cos(e)));
  a < -Math.PI && (a = -Math.PI), a > Math.PI && (a = Math.PI), n = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(n) > 1 && (n = 1);
  var s = Math.asin(n);
  return t.x = a, t.y = s, t;
}
var RR = ["Mollweide", "moll"];
const zR = {
  init: LR,
  forward: DR,
  inverse: NR,
  names: RR
};
function FR() {
  Math.abs(this.lat1 + this.lat2) < Ct || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = qd(this.es), this.e1 = $d(this.es), this.e2 = Wd(this.es), this.e3 = Hd(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = Ys(this.e, this.sinphi, this.cosphi), this.ml1 = zo(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < Ct ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = Ys(this.e, this.sinphi, this.cosphi), this.ml2 = zo(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = zo(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function BR(t) {
  var e = t.x, n = t.y, a;
  if (this.sphere)
    a = this.a * (this.g - n);
  else {
    var s = zo(this.e0, this.e1, this.e2, this.e3, n);
    a = this.a * (this.g - s);
  }
  var h = this.ns * Vt(e - this.long0), o = this.x0 + a * Math.sin(h), m = this.y0 + this.rh - a * Math.cos(h);
  return t.x = o, t.y = m, t;
}
function VR(t) {
  t.x -= this.x0, t.y = this.rh - t.y + this.y0;
  var e, n, a, s;
  this.ns >= 0 ? (n = Math.sqrt(t.x * t.x + t.y * t.y), e = 1) : (n = -Math.sqrt(t.x * t.x + t.y * t.y), e = -1);
  var h = 0;
  if (n !== 0 && (h = Math.atan2(e * t.x, e * t.y)), this.sphere)
    return s = Vt(this.long0 + h / this.ns), a = zf(this.g - n / this.a), t.x = s, t.y = a, t;
  var o = this.g - n / this.a;
  return a = kg(o, this.e0, this.e1, this.e2, this.e3), s = Vt(this.long0 + h / this.ns), t.x = s, t.y = a, t;
}
var UR = ["Equidistant_Conic", "eqdc"];
const jR = {
  init: FR,
  forward: BR,
  inverse: VR,
  names: UR
};
function GR() {
  this.R = this.a;
}
function qR(t) {
  var e = t.x, n = t.y, a = Vt(e - this.long0), s, h;
  Math.abs(n) <= Ct && (s = this.x0 + this.R * a, h = this.y0);
  var o = Ru(2 * Math.abs(n / Math.PI));
  (Math.abs(a) <= Ct || Math.abs(Math.abs(n) - ft) <= Ct) && (s = this.x0, n >= 0 ? h = this.y0 + Math.PI * this.R * Math.tan(0.5 * o) : h = this.y0 + Math.PI * this.R * -Math.tan(0.5 * o));
  var m = 0.5 * Math.abs(Math.PI / a - a / Math.PI), g = m * m, b = Math.sin(o), T = Math.cos(o), M = T / (b + T - 1), I = M * M, P = M * (2 / b - 1), z = P * P, V = Math.PI * this.R * (m * (M - z) + Math.sqrt(g * (M - z) * (M - z) - (z + g) * (I - z))) / (z + g);
  a < 0 && (V = -V), s = this.x0 + V;
  var W = g + M;
  return V = Math.PI * this.R * (P * W - m * Math.sqrt((z + g) * (g + 1) - W * W)) / (z + g), n >= 0 ? h = this.y0 + V : h = this.y0 - V, t.x = s, t.y = h, t;
}
function $R(t) {
  var e, n, a, s, h, o, m, g, b, T, M, I, P;
  return t.x -= this.x0, t.y -= this.y0, M = Math.PI * this.R, a = t.x / M, s = t.y / M, h = a * a + s * s, o = -Math.abs(s) * (1 + h), m = o - 2 * s * s + a * a, g = -2 * o + 1 + 2 * s * s + h * h, P = s * s / g + (2 * m * m * m / g / g / g - 9 * o * m / g / g) / 27, b = (o - m * m / 3 / g) / g, T = 2 * Math.sqrt(-b / 3), M = 3 * P / b / T, Math.abs(M) > 1 && (M >= 0 ? M = 1 : M = -1), I = Math.acos(M) / 3, t.y >= 0 ? n = (-T * Math.cos(I + Math.PI / 3) - m / 3 / g) * Math.PI : n = -(-T * Math.cos(I + Math.PI / 3) - m / 3 / g) * Math.PI, Math.abs(a) < Ct ? e = this.long0 : e = Vt(this.long0 + Math.PI * (h - 1 + Math.sqrt(1 + 2 * (a * a - s * s) + h * h)) / 2 / a), t.x = e, t.y = n, t;
}
var WR = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const HR = {
  init: GR,
  forward: qR,
  inverse: $R,
  names: WR
};
function ZR() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}
function XR(t) {
  var e = t.x, n = t.y, a = Math.sin(t.y), s = Math.cos(t.y), h = Vt(e - this.long0), o, m, g, b, T, M, I, P, z, V, W, X, K, se, pe, xe, Fe, ze, Pe, Se, Ie, Je, qe;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= Ct ? (t.x = this.x0 + this.a * (ft - n) * Math.sin(h), t.y = this.y0 - this.a * (ft - n) * Math.cos(h), t) : Math.abs(this.sin_p12 + 1) <= Ct ? (t.x = this.x0 + this.a * (ft + n) * Math.sin(h), t.y = this.y0 + this.a * (ft + n) * Math.cos(h), t) : (ze = this.sin_p12 * a + this.cos_p12 * s * Math.cos(h), xe = Math.acos(ze), Fe = xe ? xe / Math.sin(xe) : 1, t.x = this.x0 + this.a * Fe * s * Math.sin(h), t.y = this.y0 + this.a * Fe * (this.cos_p12 * a - this.sin_p12 * s * Math.cos(h)), t) : (o = qd(this.es), m = $d(this.es), g = Wd(this.es), b = Hd(this.es), Math.abs(this.sin_p12 - 1) <= Ct ? (T = this.a * zo(o, m, g, b, ft), M = this.a * zo(o, m, g, b, n), t.x = this.x0 + (T - M) * Math.sin(h), t.y = this.y0 - (T - M) * Math.cos(h), t) : Math.abs(this.sin_p12 + 1) <= Ct ? (T = this.a * zo(o, m, g, b, ft), M = this.a * zo(o, m, g, b, n), t.x = this.x0 + (T + M) * Math.sin(h), t.y = this.y0 + (T + M) * Math.cos(h), t) : (I = a / s, P = Df(this.a, this.e, this.sin_p12), z = Df(this.a, this.e, a), V = Math.atan((1 - this.es) * I + this.es * P * this.sin_p12 / (z * s)), W = Math.atan2(Math.sin(h), this.cos_p12 * Math.tan(V) - this.sin_p12 * Math.cos(h)), W === 0 ? Pe = Math.asin(this.cos_p12 * Math.sin(V) - this.sin_p12 * Math.cos(V)) : Math.abs(Math.abs(W) - Math.PI) <= Ct ? Pe = -Math.asin(this.cos_p12 * Math.sin(V) - this.sin_p12 * Math.cos(V)) : Pe = Math.asin(Math.sin(h) * Math.cos(V) / Math.sin(W)), X = this.e * this.sin_p12 / Math.sqrt(1 - this.es), K = this.e * this.cos_p12 * Math.cos(W) / Math.sqrt(1 - this.es), se = X * K, pe = K * K, Se = Pe * Pe, Ie = Se * Pe, Je = Ie * Pe, qe = Je * Pe, xe = P * Pe * (1 - Se * pe * (1 - pe) / 6 + Ie / 8 * se * (1 - 2 * pe) + Je / 120 * (pe * (4 - 7 * pe) - 3 * X * X * (1 - 7 * pe)) - qe / 48 * se), t.x = this.x0 + xe * Math.sin(W), t.y = this.y0 + xe * Math.cos(W), t));
}
function KR(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n, a, s, h, o, m, g, b, T, M, I, P, z, V, W, X, K, se, pe, xe, Fe, ze, Pe;
  return this.sphere ? (e = Math.sqrt(t.x * t.x + t.y * t.y), e > 2 * ft * this.a ? void 0 : (n = e / this.a, a = Math.sin(n), s = Math.cos(n), h = this.long0, Math.abs(e) <= Ct ? o = this.lat0 : (o = Ru(s * this.sin_p12 + t.y * a * this.cos_p12 / e), m = Math.abs(this.lat0) - ft, Math.abs(m) <= Ct ? this.lat0 >= 0 ? h = Vt(this.long0 + Math.atan2(t.x, -t.y)) : h = Vt(this.long0 - Math.atan2(-t.x, t.y)) : h = Vt(this.long0 + Math.atan2(t.x * a, e * this.cos_p12 * s - t.y * this.sin_p12 * a))), t.x = h, t.y = o, t)) : (g = qd(this.es), b = $d(this.es), T = Wd(this.es), M = Hd(this.es), Math.abs(this.sin_p12 - 1) <= Ct ? (I = this.a * zo(g, b, T, M, ft), e = Math.sqrt(t.x * t.x + t.y * t.y), P = I - e, o = kg(P / this.a, g, b, T, M), h = Vt(this.long0 + Math.atan2(t.x, -1 * t.y)), t.x = h, t.y = o, t) : Math.abs(this.sin_p12 + 1) <= Ct ? (I = this.a * zo(g, b, T, M, ft), e = Math.sqrt(t.x * t.x + t.y * t.y), P = e - I, o = kg(P / this.a, g, b, T, M), h = Vt(this.long0 + Math.atan2(t.x, t.y)), t.x = h, t.y = o, t) : (e = Math.sqrt(t.x * t.x + t.y * t.y), W = Math.atan2(t.x, t.y), z = Df(this.a, this.e, this.sin_p12), X = Math.cos(W), K = this.e * this.cos_p12 * X, se = -K * K / (1 - this.es), pe = 3 * this.es * (1 - se) * this.sin_p12 * this.cos_p12 * X / (1 - this.es), xe = e / z, Fe = xe - se * (1 + se) * Math.pow(xe, 3) / 6 - pe * (1 + 3 * se) * Math.pow(xe, 4) / 24, ze = 1 - se * Fe * Fe / 2 - xe * Fe * Fe * Fe / 6, V = Math.asin(this.sin_p12 * Math.cos(Fe) + this.cos_p12 * Math.sin(Fe) * X), h = Vt(this.long0 + Math.asin(Math.sin(W) * Math.sin(Fe) / Math.cos(V))), Pe = Math.sin(V), o = Math.atan2((Pe - this.es * ze * this.sin_p12) * Math.tan(V), Pe * (1 - this.es)), t.x = h, t.y = o, t));
}
var YR = ["Azimuthal_Equidistant", "aeqd"];
const JR = {
  init: ZR,
  forward: XR,
  inverse: KR,
  names: YR
};
function QR() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function e4(t) {
  var e, n, a, s, h, o, m, g, b = t.x, T = t.y;
  return a = Vt(b - this.long0), e = Math.sin(T), n = Math.cos(T), s = Math.cos(a), o = this.sin_p14 * e + this.cos_p14 * n * s, h = 1, (o > 0 || Math.abs(o) <= Ct) && (m = this.a * h * n * Math.sin(a), g = this.y0 + this.a * h * (this.cos_p14 * e - this.sin_p14 * n * s)), t.x = m, t.y = g, t;
}
function t4(t) {
  var e, n, a, s, h, o, m;
  return t.x -= this.x0, t.y -= this.y0, e = Math.sqrt(t.x * t.x + t.y * t.y), n = Ru(e / this.a), a = Math.sin(n), s = Math.cos(n), o = this.long0, Math.abs(e) <= Ct ? (m = this.lat0, t.x = o, t.y = m, t) : (m = Ru(s * this.sin_p14 + t.y * a * this.cos_p14 / e), h = Math.abs(this.lat0) - ft, Math.abs(h) <= Ct ? (this.lat0 >= 0 ? o = Vt(this.long0 + Math.atan2(t.x, -t.y)) : o = Vt(this.long0 - Math.atan2(-t.x, t.y)), t.x = o, t.y = m, t) : (o = Vt(this.long0 + Math.atan2(t.x * a, e * this.cos_p14 * s - t.y * this.sin_p14 * a)), t.x = o, t.y = m, t));
}
var r4 = ["ortho"];
const n4 = {
  init: QR,
  forward: e4,
  inverse: t4,
  names: r4
};
var ni = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, un = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function i4() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= ft - ln / 2 ? this.face = ni.TOP : this.lat0 <= -(ft - ln / 2) ? this.face = ni.BOTTOM : Math.abs(this.long0) <= ln ? this.face = ni.FRONT : Math.abs(this.long0) <= ft + ln ? this.face = this.long0 > 0 ? ni.RIGHT : ni.LEFT : this.face = ni.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function o4(t) {
  var e = { x: 0, y: 0 }, n, a, s, h, o, m, g = { value: 0 };
  if (t.x -= this.long0, this.es !== 0 ? n = Math.atan(this.one_minus_f_squared * Math.tan(t.y)) : n = t.y, a = t.x, this.face === ni.TOP)
    h = ft - n, a >= ln && a <= ft + ln ? (g.value = un.AREA_0, s = a - ft) : a > ft + ln || a <= -(ft + ln) ? (g.value = un.AREA_1, s = a > 0 ? a - wi : a + wi) : a > -(ft + ln) && a <= -ln ? (g.value = un.AREA_2, s = a + ft) : (g.value = un.AREA_3, s = a);
  else if (this.face === ni.BOTTOM)
    h = ft + n, a >= ln && a <= ft + ln ? (g.value = un.AREA_0, s = -a + ft) : a < ln && a >= -ln ? (g.value = un.AREA_1, s = -a) : a < -ln && a >= -(ft + ln) ? (g.value = un.AREA_2, s = -a - ft) : (g.value = un.AREA_3, s = a > 0 ? -a + wi : -a - wi);
  else {
    var b, T, M, I, P, z, V;
    this.face === ni.RIGHT ? a = Tf(a, +ft) : this.face === ni.BACK ? a = Tf(a, +wi) : this.face === ni.LEFT && (a = Tf(a, -ft)), I = Math.sin(n), P = Math.cos(n), z = Math.sin(a), V = Math.cos(a), b = P * V, T = P * z, M = I, this.face === ni.FRONT ? (h = Math.acos(b), s = My(h, M, T, g)) : this.face === ni.RIGHT ? (h = Math.acos(T), s = My(h, M, -b, g)) : this.face === ni.BACK ? (h = Math.acos(-b), s = My(h, M, -T, g)) : this.face === ni.LEFT ? (h = Math.acos(-T), s = My(h, M, b, g)) : (h = s = 0, g.value = un.AREA_0);
  }
  return m = Math.atan(12 / wi * (s + Math.acos(Math.sin(s) * Math.cos(ln)) - ft)), o = Math.sqrt((1 - Math.cos(h)) / (Math.cos(m) * Math.cos(m)) / (1 - Math.cos(Math.atan(1 / Math.cos(s))))), g.value === un.AREA_1 ? m += ft : g.value === un.AREA_2 ? m += wi : g.value === un.AREA_3 && (m += 1.5 * wi), e.x = o * Math.cos(m), e.y = o * Math.sin(m), e.x = e.x * this.a + this.x0, e.y = e.y * this.a + this.y0, t.x = e.x, t.y = e.y, t;
}
function a4(t) {
  var e = { lam: 0, phi: 0 }, n, a, s, h, o, m, g, b, T, M = { value: 0 };
  if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, a = Math.atan(Math.sqrt(t.x * t.x + t.y * t.y)), n = Math.atan2(t.y, t.x), t.x >= 0 && t.x >= Math.abs(t.y) ? M.value = un.AREA_0 : t.y >= 0 && t.y >= Math.abs(t.x) ? (M.value = un.AREA_1, n -= ft) : t.x < 0 && -t.x >= Math.abs(t.y) ? (M.value = un.AREA_2, n = n < 0 ? n + wi : n - wi) : (M.value = un.AREA_3, n += ft), T = wi / 12 * Math.tan(n), o = Math.sin(T) / (Math.cos(T) - 1 / Math.sqrt(2)), m = Math.atan(o), s = Math.cos(n), h = Math.tan(a), g = 1 - s * s * h * h * (1 - Math.cos(Math.atan(1 / Math.cos(m)))), g < -1 ? g = -1 : g > 1 && (g = 1), this.face === ni.TOP)
    b = Math.acos(g), e.phi = ft - b, M.value === un.AREA_0 ? e.lam = m + ft : M.value === un.AREA_1 ? e.lam = m < 0 ? m + wi : m - wi : M.value === un.AREA_2 ? e.lam = m - ft : e.lam = m;
  else if (this.face === ni.BOTTOM)
    b = Math.acos(g), e.phi = b - ft, M.value === un.AREA_0 ? e.lam = -m + ft : M.value === un.AREA_1 ? e.lam = -m : M.value === un.AREA_2 ? e.lam = -m - ft : e.lam = m < 0 ? -m - wi : -m + wi;
  else {
    var I, P, z;
    I = g, T = I * I, T >= 1 ? z = 0 : z = Math.sqrt(1 - T) * Math.sin(m), T += z * z, T >= 1 ? P = 0 : P = Math.sqrt(1 - T), M.value === un.AREA_1 ? (T = P, P = -z, z = T) : M.value === un.AREA_2 ? (P = -P, z = -z) : M.value === un.AREA_3 && (T = P, P = z, z = -T), this.face === ni.RIGHT ? (T = I, I = -P, P = T) : this.face === ni.BACK ? (I = -I, P = -P) : this.face === ni.LEFT && (T = I, I = P, P = -T), e.phi = Math.acos(-z) - ft, e.lam = Math.atan2(P, I), this.face === ni.RIGHT ? e.lam = Tf(e.lam, -ft) : this.face === ni.BACK ? e.lam = Tf(e.lam, -wi) : this.face === ni.LEFT && (e.lam = Tf(e.lam, +ft));
  }
  if (this.es !== 0) {
    var V, W, X;
    V = e.phi < 0 ? 1 : 0, W = Math.tan(e.phi), X = this.b / Math.sqrt(W * W + this.one_minus_f_squared), e.phi = Math.atan(Math.sqrt(this.a * this.a - X * X) / (this.one_minus_f * X)), V && (e.phi = -e.phi);
  }
  return e.lam += this.long0, t.x = e.lam, t.y = e.phi, t;
}
function My(t, e, n, a) {
  var s;
  return t < Ct ? (a.value = un.AREA_0, s = 0) : (s = Math.atan2(e, n), Math.abs(s) <= ln ? a.value = un.AREA_0 : s > ln && s <= ft + ln ? (a.value = un.AREA_1, s -= ft) : s > ft + ln || s <= -(ft + ln) ? (a.value = un.AREA_2, s = s >= 0 ? s - wi : s + wi) : (a.value = un.AREA_3, s += ft)), s;
}
function Tf(t, e) {
  var n = t + e;
  return n < -wi ? n += Pd : n > +wi && (n -= Pd), n;
}
var s4 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const l4 = {
  init: i4,
  forward: o4,
  inverse: a4,
  names: s4
};
var K0 = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], td = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], AT = 0.8487, PT = 1.3523, kT = Gs / 5, u4 = 1 / kT, vf = 18, Lg = function(t, e) {
  return t[0] + e * (t[1] + e * (t[2] + e * t[3]));
}, c4 = function(t, e) {
  return t[1] + e * (2 * t[2] + e * 3 * t[3]);
};
function h4(t, e, n, a) {
  for (var s = e; a; --a) {
    var h = t(s);
    if (s -= h, Math.abs(h) < n)
      break;
  }
  return s;
}
function f4() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function p4(t) {
  var e = Vt(t.x - this.long0), n = Math.abs(t.y), a = Math.floor(n * kT);
  a < 0 ? a = 0 : a >= vf && (a = vf - 1), n = Gs * (n - u4 * a);
  var s = {
    x: Lg(K0[a], n) * e,
    y: Lg(td[a], n)
  };
  return t.y < 0 && (s.y = -s.y), s.x = s.x * this.a * AT + this.x0, s.y = s.y * this.a * PT + this.y0, s;
}
function d4(t) {
  var e = {
    x: (t.x - this.x0) / (this.a * AT),
    y: Math.abs(t.y - this.y0) / (this.a * PT)
  };
  if (e.y >= 1)
    e.x /= K0[vf][0], e.y = t.y < 0 ? -ft : ft;
  else {
    var n = Math.floor(e.y * vf);
    for (n < 0 ? n = 0 : n >= vf && (n = vf - 1); ; )
      if (td[n][0] > e.y)
        --n;
      else if (td[n + 1][0] <= e.y)
        ++n;
      else
        break;
    var a = td[n], s = 5 * (e.y - a[0]) / (td[n + 1][0] - a[0]);
    s = h4(function(h) {
      return (Lg(a, h) - e.y) / c4(a, h);
    }, s, Ct, 100), e.x /= Lg(K0[n], s), e.y = (5 * n + s) * io, t.y < 0 && (e.y = -e.y);
  }
  return e.x = Vt(e.x + this.long0), e;
}
var m4 = ["Robinson", "robin"];
const y4 = {
  init: f4,
  forward: p4,
  inverse: d4,
  names: m4
};
function g4() {
  this.name = "geocent";
}
function v4(t) {
  var e = gT(t, this.es, this.a);
  return e;
}
function _4(t) {
  var e = vT(t, this.es, this.a, this.b);
  return e;
}
var x4 = ["Geocentric", "geocentric", "geocent", "Geocent"];
const b4 = {
  init: g4,
  forward: v4,
  inverse: _4,
  names: x4
};
var _o = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, qp = {
  h: { def: 1e5, num: !0 },
  azi: { def: 0, num: !0, degrees: !0 },
  tilt: { def: 0, num: !0, degrees: !0 },
  long0: { def: 0, num: !0 },
  lat0: { def: 0, num: !0 }
};
function w4() {
  if (Object.keys(qp).forEach(function(n) {
    if (typeof this[n] > "u")
      this[n] = qp[n].def;
    else {
      if (qp[n].num && isNaN(this[n]))
        throw new Error("Invalid parameter value, must be numeric " + n + " = " + this[n]);
      qp[n].num && (this[n] = parseFloat(this[n]));
    }
    qp[n].degrees && (this[n] = this[n] * io);
  }.bind(this)), Math.abs(Math.abs(this.lat0) - ft) < Ct ? this.mode = this.lat0 < 0 ? _o.S_POLE : _o.N_POLE : Math.abs(this.lat0) < Ct ? this.mode = _o.EQUIT : (this.mode = _o.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var t = this.tilt, e = this.azi;
  this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(t), this.sw = Math.sin(t);
}
function E4(t) {
  t.x -= this.long0;
  var e = Math.sin(t.y), n = Math.cos(t.y), a = Math.cos(t.x), s, h;
  switch (this.mode) {
    case _o.OBLIQ:
      h = this.sinph0 * e + this.cosph0 * n * a;
      break;
    case _o.EQUIT:
      h = n * a;
      break;
    case _o.S_POLE:
      h = -e;
      break;
    case _o.N_POLE:
      h = e;
      break;
  }
  switch (h = this.pn1 / (this.p - h), s = h * n * Math.sin(t.x), this.mode) {
    case _o.OBLIQ:
      h *= this.cosph0 * e - this.sinph0 * n * a;
      break;
    case _o.EQUIT:
      h *= e;
      break;
    case _o.N_POLE:
      h *= -(n * a);
      break;
    case _o.S_POLE:
      h *= n * a;
      break;
  }
  var o, m;
  return o = h * this.cg + s * this.sg, m = 1 / (o * this.sw * this.h1 + this.cw), s = (s * this.cg - h * this.sg) * this.cw * m, h = o * m, t.x = s * this.a, t.y = h * this.a, t;
}
function S4(t) {
  t.x /= this.a, t.y /= this.a;
  var e = { x: t.x, y: t.y }, n, a, s;
  s = 1 / (this.pn1 - t.y * this.sw), n = this.pn1 * t.x * s, a = this.pn1 * t.y * this.cw * s, t.x = n * this.cg + a * this.sg, t.y = a * this.cg - n * this.sg;
  var h = ns(t.x, t.y);
  if (Math.abs(h) < Ct)
    e.x = 0, e.y = t.y;
  else {
    var o, m;
    switch (m = 1 - h * h * this.pfact, m = (this.p - Math.sqrt(m)) / (this.pn1 / h + h / this.pn1), o = Math.sqrt(1 - m * m), this.mode) {
      case _o.OBLIQ:
        e.y = Math.asin(o * this.sinph0 + t.y * m * this.cosph0 / h), t.y = (o - this.sinph0 * Math.sin(e.y)) * h, t.x *= m * this.cosph0;
        break;
      case _o.EQUIT:
        e.y = Math.asin(t.y * m / h), t.y = o * h, t.x *= m;
        break;
      case _o.N_POLE:
        e.y = Math.asin(o), t.y = -t.y;
        break;
      case _o.S_POLE:
        e.y = -Math.asin(o);
        break;
    }
    e.x = Math.atan2(t.x, t.y);
  }
  return t.x = e.x + this.long0, t.y = e.y, t;
}
var T4 = ["Tilted_Perspective", "tpers"];
const M4 = {
  init: w4,
  forward: E4,
  inverse: S4,
  names: T4
};
function I4() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var t = 1 - this.es, e = 1 / t;
    this.radius_p = Math.sqrt(t), this.radius_p2 = t, this.radius_p_inv2 = e, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function O4(t) {
  var e = t.x, n = t.y, a, s, h, o;
  if (e = e - this.long0, this.shape === "ellipse") {
    n = Math.atan(this.radius_p2 * Math.tan(n));
    var m = this.radius_p / ns(this.radius_p * Math.cos(n), Math.sin(n));
    if (s = m * Math.cos(e) * Math.cos(n), h = m * Math.sin(e) * Math.cos(n), o = m * Math.sin(n), (this.radius_g - s) * s - h * h - o * o * this.radius_p_inv2 < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    a = this.radius_g - s, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(h / ns(o, a)), t.y = this.radius_g_1 * Math.atan(o / a)) : (t.x = this.radius_g_1 * Math.atan(h / a), t.y = this.radius_g_1 * Math.atan(o / ns(h, a)));
  } else
    this.shape === "sphere" && (a = Math.cos(n), s = Math.cos(e) * a, h = Math.sin(e) * a, o = Math.sin(n), a = this.radius_g - s, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(h / ns(o, a)), t.y = this.radius_g_1 * Math.atan(o / a)) : (t.x = this.radius_g_1 * Math.atan(h / a), t.y = this.radius_g_1 * Math.atan(o / ns(h, a))));
  return t.x = t.x * this.a, t.y = t.y * this.a, t;
}
function C4(t) {
  var e = -1, n = 0, a = 0, s, h, o, m;
  if (t.x = t.x / this.a, t.y = t.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (a = Math.tan(t.y / this.radius_g_1), n = Math.tan(t.x / this.radius_g_1) * ns(1, a)) : (n = Math.tan(t.x / this.radius_g_1), a = Math.tan(t.y / this.radius_g_1) * ns(1, n));
    var g = a / this.radius_p;
    if (s = n * n + g * g + e * e, h = 2 * this.radius_g * e, o = h * h - 4 * s * this.C, o < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    m = (-h - Math.sqrt(o)) / (2 * s), e = this.radius_g + m * e, n *= m, a *= m, t.x = Math.atan2(n, e), t.y = Math.atan(a * Math.cos(t.x) / e), t.y = Math.atan(this.radius_p_inv2 * Math.tan(t.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (a = Math.tan(t.y / this.radius_g_1), n = Math.tan(t.x / this.radius_g_1) * Math.sqrt(1 + a * a)) : (n = Math.tan(t.x / this.radius_g_1), a = Math.tan(t.y / this.radius_g_1) * Math.sqrt(1 + n * n)), s = n * n + a * a + e * e, h = 2 * this.radius_g * e, o = h * h - 4 * s * this.C, o < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    m = (-h - Math.sqrt(o)) / (2 * s), e = this.radius_g + m * e, n *= m, a *= m, t.x = Math.atan2(n, e), t.y = Math.atan(a * Math.cos(t.x) / e);
  }
  return t.x = t.x + this.long0, t;
}
var A4 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const P4 = {
  init: I4,
  forward: O4,
  inverse: C4,
  names: A4
};
function k4(t) {
  t.Proj.projections.add(og), t.Proj.projections.add(ag), t.Proj.projections.add(FN), t.Proj.projections.add(ZN), t.Proj.projections.add(e3), t.Proj.projections.add(o3), t.Proj.projections.add(h3), t.Proj.projections.add(y3), t.Proj.projections.add(b3), t.Proj.projections.add(M3), t.Proj.projections.add(G3), t.Proj.projections.add(X3), t.Proj.projections.add(eR), t.Proj.projections.add(aR), t.Proj.projections.add(hR), t.Proj.projections.add(yR), t.Proj.projections.add(bR), t.Proj.projections.add(MR), t.Proj.projections.add(kR), t.Proj.projections.add(zR), t.Proj.projections.add(jR), t.Proj.projections.add(HR), t.Proj.projections.add(JR), t.Proj.projections.add(n4), t.Proj.projections.add(l4), t.Proj.projections.add(y4), t.Proj.projections.add(b4), t.Proj.projections.add(M4), t.Proj.projections.add(P4);
}
wo.defaultDatum = "WGS84";
wo.Proj = Ws;
wo.WGS84 = new wo.Proj("WGS84");
wo.Point = Lf;
wo.toPoint = _T;
wo.defs = Do;
wo.nadgrid = VD;
wo.transform = Pg;
wo.mgrs = rN;
wo.version = "__VERSION__";
k4(wo);
function L4() {
  var t, e, n;
  wo.defs("EPSG:32632", "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs"), wo.defs("EPSG:32631", "+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs"), wo.defs(
    "EPSG:2169",
    "+proj=tmerc +lat_0=49.83333333333334 +lon_0=6.166666666666667 +k=1 +x_0=80000 +y_0=100000 +ellps=intl +towgs84=-189.681,18.3463,-42.7695,-0.33746,-3.09264,2.53861,0.4598 +units=m +no_defs"
  ), yC(wo), (t = Hy("EPSG:32632")) == null || t.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]), (e = Hy("EPSG:32631")) == null || e.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]), (n = Hy("EPSG:2169")) == null || n.setExtent([
    48225.17,
    56225.6,
    105842.04,
    139616.4
  ]);
}
function D4(t, e, n) {
  const a = or(t);
  class s extends q1 {
    constructor(o) {
      super(a, o, e, n);
    }
  }
  return bi(s, "def", a), s;
}
const N4 = typeof HTMLElement < "u" ? HTMLElement : class {
};
class q1 extends N4 {
  constructor(n, a = {}, s = {}, h) {
    super();
    bi(this, "_instance", null);
    bi(this, "_connected", !1);
    bi(this, "_resolved", !1);
    bi(this, "_numberProps", null);
    bi(this, "_styles");
    bi(this, "_slots");
    this._def = n, this._props = a, this._config = s, this._config = Wn(
      {
        shadowRoot: !0
      },
      this._config
    ), this._config.shadowRoot ? this.shadowRoot && h ? h(this._createVNode(), this.shadowRoot) : (this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def)) : h && h(this._createVNode(), this._root);
  }
  get _root() {
    return this._config.shadowRoot ? this.shadowRoot : this;
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, bg(() => {
      this._connected || (_w(null, this._root), this._instance = null);
    });
  }
  _resolveDef() {
    this._resolved = !0;
    for (let s = 0; s < this.attributes.length; s++)
      this._setAttr(this.attributes[s].name);
    new MutationObserver((s) => {
      for (const h of s)
        this._setAttr(h.attributeName);
    }).observe(this, { attributes: !0 });
    const n = (s, h = !1) => {
      const { props: o, styles: m } = s;
      let g;
      if (o && !er(o))
        for (const b in o) {
          const T = o[b];
          (T === Number || T && T.type === Number) && (b in this._props && (this._props[b] = _0(this._props[b])), (g || (g = /* @__PURE__ */ Object.create(null)))[ya(b)] = !0);
        }
      this._numberProps = g, h && this._resolveProps(s), this._applyStyles(m), this._update();
    }, a = this._def.__asyncLoader;
    a ? a().then((s) => n(s, !0)) : n(this._def);
  }
  _resolveProps(n) {
    const { props: a } = n, s = er(a) ? a : Object.keys(a || {});
    for (const h of Object.keys(this))
      h[0] !== "_" && s.includes(h) && this._setProp(h, this[h], !0, !1);
    for (const h of s.map(ya))
      Object.defineProperty(this, h, {
        get() {
          return this._getProp(h);
        },
        set(o) {
          this._setProp(h, o);
        }
      });
  }
  _setAttr(n) {
    let a = this.getAttribute(n);
    const s = ya(n);
    this._numberProps && this._numberProps[s] && (a = _0(a)), this._setProp(s, a, !1);
  }
  _getProp(n) {
    return this._props[n];
  }
  _setProp(n, a, s = !0, h = !0) {
    a !== this._props[n] && (this._props[n] = a, h && this._instance && this._update(), s && (a === !0 ? this.setAttribute(ta(n), "") : typeof a == "string" || typeof a == "number" ? this.setAttribute(ta(n), a + "") : a || this.removeAttribute(ta(n))));
  }
  _update() {
    _w(this._createVNode(), this._root);
  }
  _createVNode() {
    const n = Ft(this._def, Wn({}, this._props));
    return this._instance || (n.ce = (a) => {
      this._instance = a, a.isCE = !0;
      const s = (o, m) => {
        this.dispatchEvent(
          new CustomEvent(o, {
            detail: m
          })
        );
      };
      a.emit = (o, ...m) => {
        s(o, m), ta(o) !== o && s(ta(o), m);
      };
      let h = this;
      for (; h = h && (h.parentNode || h.host); )
        if (h instanceof q1) {
          a.parent = h._instance, a.provides = h._instance.provides;
          break;
        }
    }), n;
  }
  _applyStyles(n) {
    n && n.forEach((a) => {
      const s = document.createElement("style");
      s.textContent = a, this._root.appendChild(s);
    });
  }
}
var Dd = /* @__PURE__ */ ((t) => (t.INFO = "alert-info", t.WARNING = "alert-warning", t.ERROR = "alert-danger", t))(Dd || {});
const R4 = Dd.INFO, z4 = 7e3, F4 = 4e3, Dg = rh(
  "alert-notifications",
  () => {
    const t = Mr([]);
    function e(a, s = R4, h) {
      const o = {
        message: a,
        type: s,
        duration: h != null ? h : s === Dd.WARNING ? F4 : z4
      };
      t.value.push(o);
    }
    function n(a) {
      t.value.splice(a, 1);
    }
    return {
      notifications: t,
      addNotification: e,
      removeNotification: n
    };
  },
  {}
), B4 = /* @__PURE__ */ or({
  __name: "notification-item",
  props: {
    notification: { type: null, required: !0 }
  },
  emits: ["close"],
  setup(t) {
    const e = t, n = Fn(!0);
    function a(s, h) {
      setTimeout(() => {
        n.value = !1;
      }, e.notification.duration), h();
    }
    return (s, h) => {
      const o = SS("dompurify-html");
      return Ve(), on(bv, {
        name: "fade-out",
        appear: "",
        "leave-active-class": "duration-200 ease-in",
        "leave-from-class": "opacity-100",
        "leave-to-class": "transform opacity-0",
        onEnter: a,
        onAfterLeave: h[0] || (h[0] = (m) => s.$emit("close"))
      }, {
        default: Vd(() => [
          ae(n) ? O0((Ve(), it("div", {
            key: 0,
            class: Pr(["lux-alert", `lux-${e.notification.type}`]),
            role: "alert"
          }, null, 2)), [
            [o, e.notification.message]
          ]) : Ye("v-if", !0)
        ]),
        _: 1
      });
    };
  }
}), ur = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [a, s] of e)
    n[a] = s;
  return n;
}, V4 = /* @__PURE__ */ ur(B4, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/alert-notifications/notification-item.vue"]]), U4 = {
  key: 0,
  class: "lux-notifications fixed w-[500px] top-10 left-1/2 ml-[-250px] z-50"
}, j4 = /* @__PURE__ */ or({
  __name: "alert-notifications",
  setup(t) {
    const e = Dg(), { notifications: n } = xn(e);
    function a(s) {
      e.removeNotification(s);
    }
    return (s, h) => (Ve(), on(RS, { to: "body" }, [
      ae(n).length ? (Ve(), it("div", U4, [
        (Ve(!0), it(cn, null, Ra(ae(n), (o, m) => (Ve(), on(V4, {
          key: m,
          notification: o,
          onClose: () => a(m)
        }, null, 8, ["notification", "onClose"]))), 128))
      ])) : Ye("v-if", !0)
    ]));
  }
}), G4 = /* @__PURE__ */ ur(j4, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/alert-notifications/alert-notifications.vue"]]), q4 = { class: "lux-dropdown" }, $4 = { class: "h-full" }, W4 = ["aria-expanded"], H4 = /* @__PURE__ */ Re("span", { class: "lux-caret" }, null, -1), Z4 = { class: "lux-dropdown-wrapper" }, X4 = ["aria-label", "data-value"], K4 = /* @__PURE__ */ or({
  __name: "dropdown-list",
  props: {
    placeholder: { type: String, required: !0 },
    options: { type: Array, required: !0, default: () => [{ label: "Default label", value: "Default value" }] },
    modelValue: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, a = Fn(!1), s = Fn();
    function h(b) {
      a.value = b === void 0 ? !a.value : b;
    }
    function o(b) {
      b.stopImmediatePropagation(), h();
    }
    function m(b) {
      s.value = b.target.dataset.value, e("change", s.value);
    }
    function g() {
      h(!1);
    }
    return va(() => document.addEventListener("click", g)), Uu(() => document.removeEventListener("click", g)), (b, T) => {
      var M, I;
      return Ve(), it("div", q4, [
        Re("div", $4, [
          Re("button", {
            type: "button",
            class: Pr(["lux-btn lux-dropdown-btn", ae(a) ? "expanded" : ""]),
            "aria-expanded": ae(a),
            "aria-haspopup": "true",
            onClick: o
          }, [
            Re("span", null, Gt((I = n.placeholder) != null ? I : (M = n.options[0]) == null ? void 0 : M.label), 1),
            H4
          ], 10, W4)
        ]),
        Re("div", Z4, [
          Re("ul", {
            class: Pr(["lux-dropdown-list", ae(a) ? "" : "hidden"]),
            tabindex: "-1"
          }, [
            (Ve(!0), it(cn, null, Ra(n.options, (P) => (Ve(), it("li", {
              key: P.value,
              class: Pr(t.modelValue === P.value ? "selected" : "")
            }, [
              Re("button", {
                class: "lux-dropdown-list-item",
                "aria-label": P.ariaLabel,
                "data-value": P.value,
                onClick: m
              }, Gt(P.label), 9, X4)
            ], 2))), 128))
          ], 2)
        ])
      ]);
    };
  }
}), LT = /* @__PURE__ */ ur(K4, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/dropdown-list.vue"]]), md = "EPSG:3857", DT = "EPSG:4326", Y4 = "EPSG:2169";
let q_;
const Xw = Fn();
function zl() {
  function t() {
    return q_;
  }
  function e() {
    return Xw.value = q_ = new gC({
      view: new vC({
        zoom: 10,
        center: [682439, 6379152],
        multiWorld: !0
      }),
      controls: []
    }), q_;
  }
  function n(T, M) {
    return T.id === M.id;
  }
  function a(T, M) {
    return T === M;
  }
  function s(T, M) {
    var I;
    return (I = T.layers) == null ? void 0 : I.some((P) => n(P, M));
  }
  function h(T, M) {
    var P;
    const I = (P = T == null ? void 0 : T.layers) == null ? void 0 : P.find((z) => n(z, M));
    return !a(I, M);
  }
  function o(T, M) {
    return !(M === null || !("layers" in T) || !("layers" in M) || typeof M.layers > "u" || typeof T.layers > "u" || T.layers === M.layers);
  }
  function m(T, M) {
    return !("layers" in T) || typeof T.layers > "u" ? [] : M === null || !("layers" in M) ? T.layers.map((I, P) => ({ layer: I, position: P })) : T.layers === M.layers ? [] : T.layers.reduce(
      (I, P, z) => s(M, P) ? I : [
        ...I,
        {
          layer: P,
          position: z
        }
      ],
      []
    );
  }
  function g(T, M) {
    return o(T, M) ? M.layers.reduce(
      (I, P) => s(T, P) ? I : [...I, P],
      []
    ) : [];
  }
  function b(T, M) {
    return o(T, M) ? T.layers.reduce(
      (I, P) => h(M, P) ? [...I, P] : I,
      []
    ) : [];
  }
  return {
    olMap: Xw,
    getOlMap: t,
    createMap: e,
    equalsLayer: n,
    hasLayer: s,
    layerHasChanged: h,
    contextHasChanged: o,
    getAddedLayers: m,
    getRemovedLayers: g,
    getMutatedLayers: b
  };
}
var js = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, NT = { exports: {} };
(function(t, e) {
  (function(n, a) {
    t.exports = a();
  })(js, function() {
    var n, a, s;
    function h(o, m) {
      if (!n)
        n = m;
      else if (!a)
        a = m;
      else {
        var g = "var sharedChunk = {}; (" + n + ")(sharedChunk); (" + a + ")(sharedChunk);", b = {};
        n(b), s = m(b), typeof window < "u" && (s.workerUrl = window.URL.createObjectURL(new Blob([g], { type: "text/javascript" })));
      }
    }
    return h(["exports"], function(o) {
      function m(r, i) {
        return r(i = { exports: {} }, i.exports), i.exports;
      }
      var g = b;
      function b(r, i, l, p) {
        this.cx = 3 * r, this.bx = 3 * (l - r) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (p - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r, this.p1y = p, this.p2x = l, this.p2y = p;
      }
      b.prototype.sampleCurveX = function(r) {
        return ((this.ax * r + this.bx) * r + this.cx) * r;
      }, b.prototype.sampleCurveY = function(r) {
        return ((this.ay * r + this.by) * r + this.cy) * r;
      }, b.prototype.sampleCurveDerivativeX = function(r) {
        return (3 * this.ax * r + 2 * this.bx) * r + this.cx;
      }, b.prototype.solveCurveX = function(r, i) {
        var l, p, y, v, x;
        for (i === void 0 && (i = 1e-6), y = r, x = 0; x < 8; x++) {
          if (v = this.sampleCurveX(y) - r, Math.abs(v) < i)
            return y;
          var S = this.sampleCurveDerivativeX(y);
          if (Math.abs(S) < 1e-6)
            break;
          y -= v / S;
        }
        if ((y = r) < (l = 0))
          return l;
        if (y > (p = 1))
          return p;
        for (; l < p; ) {
          if (v = this.sampleCurveX(y), Math.abs(v - r) < i)
            return y;
          r > v ? l = y : p = y, y = 0.5 * (p - l) + l;
        }
        return y;
      }, b.prototype.solve = function(r, i) {
        return this.sampleCurveY(this.solveCurveX(r, i));
      };
      var T = M;
      function M(r, i) {
        this.x = r, this.y = i;
      }
      M.prototype = { clone: function() {
        return new M(this.x, this.y);
      }, add: function(r) {
        return this.clone()._add(r);
      }, sub: function(r) {
        return this.clone()._sub(r);
      }, multByPoint: function(r) {
        return this.clone()._multByPoint(r);
      }, divByPoint: function(r) {
        return this.clone()._divByPoint(r);
      }, mult: function(r) {
        return this.clone()._mult(r);
      }, div: function(r) {
        return this.clone()._div(r);
      }, rotate: function(r) {
        return this.clone()._rotate(r);
      }, rotateAround: function(r, i) {
        return this.clone()._rotateAround(r, i);
      }, matMult: function(r) {
        return this.clone()._matMult(r);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(r) {
        return this.x === r.x && this.y === r.y;
      }, dist: function(r) {
        return Math.sqrt(this.distSqr(r));
      }, distSqr: function(r) {
        var i = r.x - this.x, l = r.y - this.y;
        return i * i + l * l;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(r) {
        return Math.atan2(this.y - r.y, this.x - r.x);
      }, angleWith: function(r) {
        return this.angleWithSep(r.x, r.y);
      }, angleWithSep: function(r, i) {
        return Math.atan2(this.x * i - this.y * r, this.x * r + this.y * i);
      }, _matMult: function(r) {
        var i = r[2] * this.x + r[3] * this.y;
        return this.x = r[0] * this.x + r[1] * this.y, this.y = i, this;
      }, _add: function(r) {
        return this.x += r.x, this.y += r.y, this;
      }, _sub: function(r) {
        return this.x -= r.x, this.y -= r.y, this;
      }, _mult: function(r) {
        return this.x *= r, this.y *= r, this;
      }, _div: function(r) {
        return this.x /= r, this.y /= r, this;
      }, _multByPoint: function(r) {
        return this.x *= r.x, this.y *= r.y, this;
      }, _divByPoint: function(r) {
        return this.x /= r.x, this.y /= r.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var r = this.y;
        return this.y = this.x, this.x = -r, this;
      }, _rotate: function(r) {
        var i = Math.cos(r), l = Math.sin(r), p = l * this.x + i * this.y;
        return this.x = i * this.x - l * this.y, this.y = p, this;
      }, _rotateAround: function(r, i) {
        var l = Math.cos(r), p = Math.sin(r), y = i.y + p * (this.x - i.x) + l * (this.y - i.y);
        return this.x = i.x + l * (this.x - i.x) - p * (this.y - i.y), this.y = y, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, M.convert = function(r) {
        return r instanceof M ? r : Array.isArray(r) ? new M(r[0], r[1]) : r;
      };
      var I = typeof self < "u" ? self : {}, P = Math.pow(2, 53) - 1;
      function z(r, i, l, p) {
        var y = new g(r, i, l, p);
        return function(v) {
          return y.solve(v);
        };
      }
      var V = z(0.25, 0.1, 0.25, 1);
      function W(r, i, l) {
        return Math.min(l, Math.max(i, r));
      }
      function X(r, i, l) {
        var p = l - i, y = ((r - i) % p + p) % p + i;
        return y === i ? l : y;
      }
      function K(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        for (var p = 0, y = i; p < y.length; p += 1) {
          var v = y[p];
          for (var x in v)
            r[x] = v[x];
        }
        return r;
      }
      var se = 1;
      function pe() {
        return se++;
      }
      function xe() {
        return function r(i) {
          return i ? (i ^ 16 * Math.random() >> i / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, r);
        }();
      }
      function Fe(r) {
        return !!r && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(r);
      }
      function ze(r, i) {
        r.forEach(function(l) {
          i[l] && (i[l] = i[l].bind(i));
        });
      }
      function Pe(r, i) {
        return r.indexOf(i, r.length - i.length) !== -1;
      }
      function Se(r, i, l) {
        var p = {};
        for (var y in r)
          p[y] = i.call(l || this, r[y], y, r);
        return p;
      }
      function Ie(r, i, l) {
        var p = {};
        for (var y in r)
          i.call(l || this, r[y], y, r) && (p[y] = r[y]);
        return p;
      }
      function Je(r) {
        return Array.isArray(r) ? r.map(Je) : typeof r == "object" && r ? Se(r, Je) : r;
      }
      var qe = {};
      function at(r) {
        qe[r] || (typeof console < "u" && console.warn(r), qe[r] = !0);
      }
      function be(r, i, l) {
        return (l.y - r.y) * (i.x - r.x) > (i.y - r.y) * (l.x - r.x);
      }
      function Ke(r) {
        for (var i = 0, l = 0, p = r.length, y = p - 1, v = void 0, x = void 0; l < p; y = l++)
          i += ((x = r[y]).x - (v = r[l]).x) * (v.y + x.y);
        return i;
      }
      function ht() {
        return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
      }
      function vt(r) {
        var i = {};
        if (r.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, function(p, y, v, x) {
          var S = v || x;
          return i[y] = !S || S.toLowerCase(), "";
        }), i["max-age"]) {
          var l = parseInt(i["max-age"], 10);
          isNaN(l) ? delete i["max-age"] : i["max-age"] = l;
        }
        return i;
      }
      var Pt = null;
      function tr(r) {
        if (Pt == null) {
          var i = r.navigator ? r.navigator.userAgent : null;
          Pt = !!r.safari || !(!i || !(/\b(iPad|iPhone|iPod)\b/.test(i) || i.match("Safari") && !i.match("Chrome")));
        }
        return Pt;
      }
      function Pn(r) {
        try {
          var i = I[r];
          return i.setItem("_mapbox_test_", 1), i.removeItem("_mapbox_test_"), !0;
        } catch {
          return !1;
        }
      }
      var Rr, pr, Zn, zr, Fi = I.performance && I.performance.now ? I.performance.now.bind(I.performance) : Date.now.bind(Date), qr = I.requestAnimationFrame || I.mozRequestAnimationFrame || I.webkitRequestAnimationFrame || I.msRequestAnimationFrame, kr = I.cancelAnimationFrame || I.mozCancelAnimationFrame || I.webkitCancelAnimationFrame || I.msCancelAnimationFrame, Vn = { now: Fi, frame: function(r) {
        var i = qr(r);
        return { cancel: function() {
          return kr(i);
        } };
      }, getImageData: function(r, i) {
        i === void 0 && (i = 0);
        var l = I.document.createElement("canvas"), p = l.getContext("2d");
        if (!p)
          throw new Error("failed to create canvas 2d context");
        return l.width = r.width, l.height = r.height, p.drawImage(r, 0, 0, r.width, r.height), p.getImageData(-i, -i, r.width + 2 * i, r.height + 2 * i);
      }, resolveURL: function(r) {
        return Rr || (Rr = I.document.createElement("a")), Rr.href = r, Rr.href;
      }, hardwareConcurrency: I.navigator && I.navigator.hardwareConcurrency || 4, get devicePixelRatio() {
        return I.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!I.matchMedia && (pr == null && (pr = I.matchMedia("(prefers-reduced-motion: reduce)")), pr.matches);
      } }, Er = { API_URL: "https://api.mapbox.com", get EVENTS_URL() {
        return this.API_URL ? this.API_URL.indexOf("https://api.mapbox.cn") === 0 ? "https://events.mapbox.cn/events/v2" : this.API_URL.indexOf("https://api.mapbox.com") === 0 ? "https://events.mapbox.com/events/v2" : null : null;
      }, FEEDBACK_URL: "https://apps.mapbox.com/feedback", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, En = { supported: !1, testSupport: function(r) {
        !oi && zr && (Un ? Y(r) : Zn = r);
      } }, oi = !1, Un = !1;
      function Y(r) {
        var i = r.createTexture();
        r.bindTexture(r.TEXTURE_2D, i);
        try {
          if (r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, zr), r.isContextLost())
            return;
          En.supported = !0;
        } catch {
        }
        r.deleteTexture(i), oi = !0;
      }
      I.document && ((zr = I.document.createElement("img")).onload = function() {
        Zn && Y(Zn), Zn = null, Un = !0;
      }, zr.onerror = function() {
        oi = !0, Zn = null;
      }, zr.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      var ye = "01", Ne = function(r, i) {
        this._transformRequestFn = r, this._customAccessToken = i, this._createSkuToken();
      };
      function $e(r) {
        return r.indexOf("mapbox:") === 0;
      }
      Ne.prototype._createSkuToken = function() {
        var r = function() {
          for (var i = "", l = 0; l < 10; l++)
            i += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
          return { token: ["1", ye, i].join(""), tokenExpiresAt: Date.now() + 432e5 };
        }();
        this._skuToken = r.token, this._skuTokenExpiresAt = r.tokenExpiresAt;
      }, Ne.prototype._isSkuTokenExpired = function() {
        return Date.now() > this._skuTokenExpiresAt;
      }, Ne.prototype.transformRequest = function(r, i) {
        return this._transformRequestFn && this._transformRequestFn(r, i) || { url: r };
      }, Ne.prototype.normalizeStyleURL = function(r, i) {
        if (!$e(r))
          return r;
        var l = et(r);
        return l.path = "/styles/v1" + l.path, this._makeAPIURL(l, this._customAccessToken || i);
      }, Ne.prototype.normalizeGlyphsURL = function(r, i) {
        if (!$e(r))
          return r;
        var l = et(r);
        return l.path = "/fonts/v1" + l.path, this._makeAPIURL(l, this._customAccessToken || i);
      }, Ne.prototype.normalizeSourceURL = function(r, i) {
        if (!$e(r))
          return r;
        var l = et(r);
        return l.path = "/v4/" + l.authority + ".json", l.params.push("secure"), this._makeAPIURL(l, this._customAccessToken || i);
      }, Ne.prototype.normalizeSpriteURL = function(r, i, l, p) {
        var y = et(r);
        return $e(r) ? (y.path = "/styles/v1" + y.path + "/sprite" + i + l, this._makeAPIURL(y, this._customAccessToken || p)) : (y.path += "" + i + l, ut(y));
      }, Ne.prototype.normalizeTileURL = function(r, i) {
        if (this._isSkuTokenExpired() && this._createSkuToken(), r && !$e(r))
          return r;
        var l = et(r);
        l.path = l.path.replace(/(\.(png|jpg)\d*)(?=$)/, (Vn.devicePixelRatio >= 2 || i === 512 ? "@2x" : "") + (En.supported ? ".webp" : "$1")), l.path = l.path.replace(/^.+\/v4\//, "/"), l.path = "/v4" + l.path;
        var p = this._customAccessToken || function(y) {
          for (var v = 0, x = y; v < x.length; v += 1) {
            var S = x[v].match(/^access_token=(.*)$/);
            if (S)
              return S[1];
          }
          return null;
        }(l.params) || Er.ACCESS_TOKEN;
        return Er.REQUIRE_ACCESS_TOKEN && p && this._skuToken && l.params.push("sku=" + this._skuToken), this._makeAPIURL(l, p);
      }, Ne.prototype.canonicalizeTileURL = function(r, i) {
        var l = et(r);
        if (!l.path.match(/(^\/v4\/)/) || !l.path.match(/\.[\w]+$/))
          return r;
        var p = "mapbox://tiles/";
        p += l.path.replace("/v4/", "");
        var y = l.params;
        return i && (y = y.filter(function(v) {
          return !v.match(/^access_token=/);
        })), y.length && (p += "?" + y.join("&")), p;
      }, Ne.prototype.canonicalizeTileset = function(r, i) {
        for (var l = !!i && $e(i), p = [], y = 0, v = r.tiles || []; y < v.length; y += 1) {
          var x = v[y];
          rt(x) ? p.push(this.canonicalizeTileURL(x, l)) : p.push(x);
        }
        return p;
      }, Ne.prototype._makeAPIURL = function(r, i) {
        var l = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", p = et(Er.API_URL);
        if (r.protocol = p.protocol, r.authority = p.authority, r.protocol === "http") {
          var y = r.params.indexOf("secure");
          y >= 0 && r.params.splice(y, 1);
        }
        if (p.path !== "/" && (r.path = "" + p.path + r.path), !Er.REQUIRE_ACCESS_TOKEN)
          return ut(r);
        if (!(i = i || Er.ACCESS_TOKEN))
          throw new Error("An API access token is required to use Mapbox GL. " + l);
        if (i[0] === "s")
          throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + l);
        return r.params = r.params.filter(function(v) {
          return v.indexOf("access_token") === -1;
        }), r.params.push("access_token=" + i), ut(r);
      };
      var We = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
      function rt(r) {
        return We.test(r);
      }
      var mt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function et(r) {
        var i = r.match(mt);
        if (!i)
          throw new Error("Unable to parse URL object");
        return { protocol: i[1], authority: i[2], path: i[3] || "/", params: i[4] ? i[4].split("&") : [] };
      }
      function ut(r) {
        var i = r.params.length ? "?" + r.params.join("&") : "";
        return r.protocol + "://" + r.authority + r.path + i;
      }
      function Qe(r) {
        if (!r)
          return null;
        var i = r.split(".");
        if (!i || i.length !== 3)
          return null;
        try {
          return JSON.parse(decodeURIComponent(I.atob(i[1]).split("").map(function(l) {
            return "%" + ("00" + l.charCodeAt(0).toString(16)).slice(-2);
          }).join("")));
        } catch {
          return null;
        }
      }
      var It = function(r) {
        this.type = r, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
      };
      It.prototype.getStorageKey = function(r) {
        var i, l = Qe(Er.ACCESS_TOKEN);
        return i = l && l.u ? I.btoa(encodeURIComponent(l.u).replace(/%([0-9A-F]{2})/g, function(p, y) {
          return String.fromCharCode(Number("0x" + y));
        })) : Er.ACCESS_TOKEN || "", r ? "mapbox.eventData." + r + ":" + i : "mapbox.eventData:" + i;
      }, It.prototype.fetchEventData = function() {
        var r = Pn("localStorage"), i = this.getStorageKey(), l = this.getStorageKey("uuid");
        if (r)
          try {
            var p = I.localStorage.getItem(i);
            p && (this.eventData = JSON.parse(p));
            var y = I.localStorage.getItem(l);
            y && (this.anonId = y);
          } catch {
            at("Unable to read from LocalStorage");
          }
      }, It.prototype.saveEventData = function() {
        var r = Pn("localStorage"), i = this.getStorageKey(), l = this.getStorageKey("uuid");
        if (r)
          try {
            I.localStorage.setItem(l, this.anonId), Object.keys(this.eventData).length >= 1 && I.localStorage.setItem(i, JSON.stringify(this.eventData));
          } catch {
            at("Unable to write to LocalStorage");
          }
      }, It.prototype.processRequests = function(r) {
      }, It.prototype.postEvent = function(r, i, l, p) {
        var y = this;
        if (Er.EVENTS_URL) {
          var v = et(Er.EVENTS_URL);
          v.params.push("access_token=" + (p || Er.ACCESS_TOKEN || ""));
          var x = { event: this.type, created: new Date(r).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: "1.13.3", skuId: ye, userId: this.anonId }, S = i ? K(x, i) : x, C = { url: ut(v), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([S]) };
          this.pendingRequest = bn(C, function(A) {
            y.pendingRequest = null, l(A), y.saveEventData(), y.processRequests(p);
          });
        }
      }, It.prototype.queueRequest = function(r, i) {
        this.queue.push(r), this.processRequests(i);
      };
      var bt, kt, Ut = function(r) {
        function i() {
          r.call(this, "map.load"), this.success = {}, this.skuToken = "";
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.postMapLoadEvent = function(l, p, y, v) {
          this.skuToken = y;
          var x = !(!v && !Er.ACCESS_TOKEN), S = Array.isArray(l) && l.some(function(C) {
            return $e(C) || rt(C);
          });
          Er.EVENTS_URL && x && S && this.queueRequest({ id: p, timestamp: Date.now() }, v);
        }, i.prototype.processRequests = function(l) {
          var p = this;
          if (!this.pendingRequest && this.queue.length !== 0) {
            var y = this.queue.shift(), v = y.id, x = y.timestamp;
            v && this.success[v] || (this.anonId || this.fetchEventData(), Fe(this.anonId) || (this.anonId = xe()), this.postEvent(x, { skuToken: this.skuToken }, function(S) {
              S || v && (p.success[v] = !0);
            }, l));
          }
        }, i;
      }(It), dr = new (function(r) {
        function i(l) {
          r.call(this, "appUserTurnstile"), this._customAccessToken = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.postTurnstileEvent = function(l, p) {
          Er.EVENTS_URL && Er.ACCESS_TOKEN && Array.isArray(l) && l.some(function(y) {
            return $e(y) || rt(y);
          }) && this.queueRequest(Date.now(), p);
        }, i.prototype.processRequests = function(l) {
          var p = this;
          if (!this.pendingRequest && this.queue.length !== 0) {
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            var y = Qe(Er.ACCESS_TOKEN), v = y ? y.u : Er.ACCESS_TOKEN, x = v !== this.eventData.tokenU;
            Fe(this.anonId) || (this.anonId = xe(), x = !0);
            var S = this.queue.shift();
            if (this.eventData.lastSuccess) {
              var C = new Date(this.eventData.lastSuccess), A = new Date(S), L = (S - this.eventData.lastSuccess) / 864e5;
              x = x || L >= 1 || L < -1 || C.getDate() !== A.getDate();
            } else
              x = !0;
            if (!x)
              return this.processRequests();
            this.postEvent(S, { "enabled.telemetry": !1 }, function(D) {
              D || (p.eventData.lastSuccess = S, p.eventData.tokenU = v);
            }, l);
          }
        }, i;
      }(It))(), Vr = dr.postTurnstileEvent.bind(dr), Lr = new Ut(), Jr = Lr.postMapLoadEvent.bind(Lr), Xn = 500, Bi = 50;
      function so() {
        I.caches && !bt && (bt = I.caches.open("mapbox-tiles"));
      }
      function Kn(r) {
        var i = r.indexOf("?");
        return i < 0 ? r : r.slice(0, i);
      }
      var ki, Sn = 1 / 0;
      function ai() {
        return ki == null && (ki = I.OffscreenCanvas && new I.OffscreenCanvas(1, 1).getContext("2d") && typeof I.createImageBitmap == "function"), ki;
      }
      var Fa = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
      typeof Object.freeze == "function" && Object.freeze(Fa);
      var Uo = function(r) {
        function i(l, p, y) {
          p === 401 && rt(y) && (l += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), r.call(this, l), this.status = p, this.url = y, this.name = this.constructor.name, this.message = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.toString = function() {
          return this.name + ": " + this.message + " (" + this.status + "): " + this.url;
        }, i;
      }(Error), Ba = ht() ? function() {
        return self.worker && self.worker.referrer;
      } : function() {
        return (I.location.protocol === "blob:" ? I.parent : I).location.href;
      }, na, an, So = function(r, i) {
        if (!(/^file:/.test(l = r.url) || /^file:/.test(Ba()) && !/^\w+:/.test(l))) {
          if (I.fetch && I.Request && I.AbortController && I.Request.prototype.hasOwnProperty("signal"))
            return function(p, y) {
              var v, x = new I.AbortController(), S = new I.Request(p.url, { method: p.method || "GET", body: p.body, credentials: p.credentials, headers: p.headers, referrer: Ba(), signal: x.signal }), C = !1, A = !1, L = (v = S.url).indexOf("sku=") > 0 && rt(v);
              p.type === "json" && S.headers.set("Accept", "application/json");
              var D = function(j, Q, te) {
                if (!A) {
                  if (j && j.message !== "SecurityError" && at(j), Q && te)
                    return B(Q);
                  var ce = Date.now();
                  I.fetch(S).then(function(oe) {
                    if (oe.ok) {
                      var ge = L ? oe.clone() : null;
                      return B(oe, ge, ce);
                    }
                    return y(new Uo(oe.statusText, oe.status, p.url));
                  }).catch(function(oe) {
                    oe.code !== 20 && y(new Error(oe.message));
                  });
                }
              }, B = function(j, Q, te) {
                (p.type === "arrayBuffer" ? j.arrayBuffer() : p.type === "json" ? j.json() : j.text()).then(function(ce) {
                  A || (Q && te && function(oe, ge, we) {
                    if (so(), bt) {
                      var Te = { status: ge.status, statusText: ge.statusText, headers: new I.Headers() };
                      ge.headers.forEach(function(Be, Xe) {
                        return Te.headers.set(Xe, Be);
                      });
                      var Oe = vt(ge.headers.get("Cache-Control") || "");
                      Oe["no-store"] || (Oe["max-age"] && Te.headers.set("Expires", new Date(we + 1e3 * Oe["max-age"]).toUTCString()), new Date(Te.headers.get("Expires")).getTime() - we < 42e4 || function(Be, Xe) {
                        if (kt === void 0)
                          try {
                            new Response(new ReadableStream()), kt = !0;
                          } catch {
                            kt = !1;
                          }
                        kt ? Xe(Be.body) : Be.blob().then(Xe);
                      }(ge, function(Be) {
                        var Xe = new I.Response(Be, Te);
                        so(), bt && bt.then(function(ot) {
                          return ot.put(Kn(oe.url), Xe);
                        }).catch(function(ot) {
                          return at(ot.message);
                        });
                      }));
                    }
                  }(S, Q, te), C = !0, y(null, ce, j.headers.get("Cache-Control"), j.headers.get("Expires")));
                }).catch(function(ce) {
                  A || y(new Error(ce.message));
                });
              };
              return L ? function(j, Q) {
                if (so(), !bt)
                  return Q(null);
                var te = Kn(j.url);
                bt.then(function(ce) {
                  ce.match(te).then(function(oe) {
                    var ge = function(we) {
                      if (!we)
                        return !1;
                      var Te = new Date(we.headers.get("Expires") || 0), Oe = vt(we.headers.get("Cache-Control") || "");
                      return Te > Date.now() && !Oe["no-cache"];
                    }(oe);
                    ce.delete(te), ge && ce.put(te, oe.clone()), Q(null, oe, ge);
                  }).catch(Q);
                }).catch(Q);
              }(S, D) : D(null, null), { cancel: function() {
                A = !0, C || x.abort();
              } };
            }(r, i);
          if (ht() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", r, i, void 0, !0);
        }
        var l;
        return function(p, y) {
          var v = new I.XMLHttpRequest();
          for (var x in v.open(p.method || "GET", p.url, !0), p.type === "arrayBuffer" && (v.responseType = "arraybuffer"), p.headers)
            v.setRequestHeader(x, p.headers[x]);
          return p.type === "json" && (v.responseType = "text", v.setRequestHeader("Accept", "application/json")), v.withCredentials = p.credentials === "include", v.onerror = function() {
            y(new Error(v.statusText));
          }, v.onload = function() {
            if ((v.status >= 200 && v.status < 300 || v.status === 0) && v.response !== null) {
              var S = v.response;
              if (p.type === "json")
                try {
                  S = JSON.parse(v.response);
                } catch (C) {
                  return y(C);
                }
              y(null, S, v.getResponseHeader("Cache-Control"), v.getResponseHeader("Expires"));
            } else
              y(new Uo(v.statusText, v.status, p.url));
          }, v.send(p.body), { cancel: function() {
            return v.abort();
          } };
        }(r, i);
      }, rl = function(r, i) {
        return So(K(r, { type: "arrayBuffer" }), i);
      }, bn = function(r, i) {
        return So(K(r, { method: "POST" }), i);
      }, N = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      na = [], an = 0;
      var F = function(r, i) {
        if (En.supported && (r.headers || (r.headers = {}), r.headers.accept = "image/webp,*/*"), an >= Er.MAX_PARALLEL_IMAGE_REQUESTS) {
          var l = { requestParameters: r, callback: i, cancelled: !1, cancel: function() {
            this.cancelled = !0;
          } };
          return na.push(l), l;
        }
        an++;
        var p = !1, y = function() {
          if (!p)
            for (p = !0, an--; na.length && an < Er.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              var x = na.shift();
              x.cancelled || (x.cancel = F(x.requestParameters, x.callback).cancel);
            }
        }, v = rl(r, function(x, S, C, A) {
          y(), x ? i(x) : S && (ai() ? function(L, D) {
            var B = new I.Blob([new Uint8Array(L)], { type: "image/png" });
            I.createImageBitmap(B).then(function(j) {
              D(null, j);
            }).catch(function(j) {
              D(new Error("Could not load image because of " + j.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            });
          }(S, i) : function(L, D, B, j) {
            var Q = new I.Image(), te = I.URL;
            Q.onload = function() {
              D(null, Q), te.revokeObjectURL(Q.src), Q.onload = null, I.requestAnimationFrame(function() {
                Q.src = N;
              });
            }, Q.onerror = function() {
              return D(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            };
            var ce = new I.Blob([new Uint8Array(L)], { type: "image/png" });
            Q.cacheControl = B, Q.expires = j, Q.src = L.byteLength ? te.createObjectURL(ce) : N;
          }(S, i, C, A));
        });
        return { cancel: function() {
          v.cancel(), y();
        } };
      };
      function U(r, i, l) {
        l[r] && l[r].indexOf(i) !== -1 || (l[r] = l[r] || [], l[r].push(i));
      }
      function Z(r, i, l) {
        if (l && l[r]) {
          var p = l[r].indexOf(i);
          p !== -1 && l[r].splice(p, 1);
        }
      }
      var ee = function(r, i) {
        i === void 0 && (i = {}), K(this, i), this.type = r;
      }, fe = function(r) {
        function i(l, p) {
          p === void 0 && (p = {}), r.call(this, "error", K({ error: l }, p));
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(ee), de = function() {
      };
      de.prototype.on = function(r, i) {
        return this._listeners = this._listeners || {}, U(r, i, this._listeners), this;
      }, de.prototype.off = function(r, i) {
        return Z(r, i, this._listeners), Z(r, i, this._oneTimeListeners), this;
      }, de.prototype.once = function(r, i) {
        return this._oneTimeListeners = this._oneTimeListeners || {}, U(r, i, this._oneTimeListeners), this;
      }, de.prototype.fire = function(r, i) {
        typeof r == "string" && (r = new ee(r, i || {}));
        var l = r.type;
        if (this.listens(l)) {
          r.target = this;
          for (var p = 0, y = this._listeners && this._listeners[l] ? this._listeners[l].slice() : []; p < y.length; p += 1)
            y[p].call(this, r);
          for (var v = 0, x = this._oneTimeListeners && this._oneTimeListeners[l] ? this._oneTimeListeners[l].slice() : []; v < x.length; v += 1) {
            var S = x[v];
            Z(l, S, this._oneTimeListeners), S.call(this, r);
          }
          var C = this._eventedParent;
          C && (K(r, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), C.fire(r));
        } else
          r instanceof fe && console.error(r.error);
        return this;
      }, de.prototype.listens = function(r) {
        return this._listeners && this._listeners[r] && this._listeners[r].length > 0 || this._oneTimeListeners && this._oneTimeListeners[r] && this._oneTimeListeners[r].length > 0 || this._eventedParent && this._eventedParent.listens(r);
      }, de.prototype.setEventedParent = function(r, i) {
        return this._eventedParent = r, this._eventedParentData = i, this;
      };
      var G = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }, ie = function(r, i, l, p) {
        this.message = (r ? r + ": " : "") + l, p && (this.identifier = p), i != null && i.__line__ && (this.line = i.__line__);
      };
      function ve(r) {
        var i = r.value;
        return i ? [new ie(r.key, i, "constants have been deprecated as of v8")] : [];
      }
      function Ge(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        for (var p = 0, y = i; p < y.length; p += 1) {
          var v = y[p];
          for (var x in v)
            r[x] = v[x];
        }
        return r;
      }
      function Ze(r) {
        return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
      }
      function Ce(r) {
        if (Array.isArray(r))
          return r.map(Ce);
        if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
          var i = {};
          for (var l in r)
            i[l] = Ce(r[l]);
          return i;
        }
        return Ze(r);
      }
      var Ue = function(r) {
        function i(l, p) {
          r.call(this, p), this.message = p, this.key = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(Error), Et = function(r, i) {
        i === void 0 && (i = []), this.parent = r, this.bindings = {};
        for (var l = 0, p = i; l < p.length; l += 1) {
          var y = p[l];
          this.bindings[y[0]] = y[1];
        }
      };
      Et.prototype.concat = function(r) {
        return new Et(this, r);
      }, Et.prototype.get = function(r) {
        if (this.bindings[r])
          return this.bindings[r];
        if (this.parent)
          return this.parent.get(r);
        throw new Error(r + " not found in scope.");
      }, Et.prototype.has = function(r) {
        return !!this.bindings[r] || !!this.parent && this.parent.has(r);
      };
      var _t = { kind: "null" }, Le = { kind: "number" }, pt = { kind: "string" }, st = { kind: "boolean" }, De = { kind: "color" }, he = { kind: "object" }, Ee = { kind: "value" }, He = { kind: "collator" }, jt = { kind: "formatted" }, Wt = { kind: "resolvedImage" };
      function Jt(r, i) {
        return { kind: "array", itemType: r, N: i };
      }
      function Zt(r) {
        if (r.kind === "array") {
          var i = Zt(r.itemType);
          return typeof r.N == "number" ? "array<" + i + ", " + r.N + ">" : r.itemType.kind === "value" ? "array" : "array<" + i + ">";
        }
        return r.kind;
      }
      var Yn = [_t, Le, pt, st, De, jt, he, Jt(Ee), Wt];
      function Qt(r, i) {
        if (i.kind === "error")
          return null;
        if (r.kind === "array") {
          if (i.kind === "array" && (i.N === 0 && i.itemType.kind === "value" || !Qt(r.itemType, i.itemType)) && (typeof r.N != "number" || r.N === i.N))
            return null;
        } else {
          if (r.kind === i.kind)
            return null;
          if (r.kind === "value") {
            for (var l = 0, p = Yn; l < p.length; l += 1)
              if (!Qt(p[l], i))
                return null;
          }
        }
        return "Expected " + Zt(r) + " but found " + Zt(i) + " instead.";
      }
      function pn(r, i) {
        return i.some(function(l) {
          return l.kind === r.kind;
        });
      }
      function Ur(r, i) {
        return i.some(function(l) {
          return l === "null" ? r === null : l === "array" ? Array.isArray(r) : l === "object" ? r && !Array.isArray(r) && typeof r == "object" : l === typeof r;
        });
      }
      var gr = m(function(r, i) {
        var l = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function p(S) {
          return (S = Math.round(S)) < 0 ? 0 : S > 255 ? 255 : S;
        }
        function y(S) {
          return p(S[S.length - 1] === "%" ? parseFloat(S) / 100 * 255 : parseInt(S));
        }
        function v(S) {
          return (C = S[S.length - 1] === "%" ? parseFloat(S) / 100 : parseFloat(S)) < 0 ? 0 : C > 1 ? 1 : C;
          var C;
        }
        function x(S, C, A) {
          return A < 0 ? A += 1 : A > 1 && (A -= 1), 6 * A < 1 ? S + (C - S) * A * 6 : 2 * A < 1 ? C : 3 * A < 2 ? S + (C - S) * (2 / 3 - A) * 6 : S;
        }
        try {
          i.parseCSSColor = function(S) {
            var C, A = S.replace(/ /g, "").toLowerCase();
            if (A in l)
              return l[A].slice();
            if (A[0] === "#")
              return A.length === 4 ? (C = parseInt(A.substr(1), 16)) >= 0 && C <= 4095 ? [(3840 & C) >> 4 | (3840 & C) >> 8, 240 & C | (240 & C) >> 4, 15 & C | (15 & C) << 4, 1] : null : A.length === 7 && (C = parseInt(A.substr(1), 16)) >= 0 && C <= 16777215 ? [(16711680 & C) >> 16, (65280 & C) >> 8, 255 & C, 1] : null;
            var L = A.indexOf("("), D = A.indexOf(")");
            if (L !== -1 && D + 1 === A.length) {
              var B = A.substr(0, L), j = A.substr(L + 1, D - (L + 1)).split(","), Q = 1;
              switch (B) {
                case "rgba":
                  if (j.length !== 4)
                    return null;
                  Q = v(j.pop());
                case "rgb":
                  return j.length !== 3 ? null : [y(j[0]), y(j[1]), y(j[2]), Q];
                case "hsla":
                  if (j.length !== 4)
                    return null;
                  Q = v(j.pop());
                case "hsl":
                  if (j.length !== 3)
                    return null;
                  var te = (parseFloat(j[0]) % 360 + 360) % 360 / 360, ce = v(j[1]), oe = v(j[2]), ge = oe <= 0.5 ? oe * (ce + 1) : oe + ce - oe * ce, we = 2 * oe - ge;
                  return [p(255 * x(we, ge, te + 1 / 3)), p(255 * x(we, ge, te)), p(255 * x(we, ge, te - 1 / 3)), Q];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch {
        }
      }).parseCSSColor, Fr = function(r, i, l, p) {
        p === void 0 && (p = 1), this.r = r, this.g = i, this.b = l, this.a = p;
      };
      Fr.parse = function(r) {
        if (r) {
          if (r instanceof Fr)
            return r;
          if (typeof r == "string") {
            var i = gr(r);
            if (i)
              return new Fr(i[0] / 255 * i[3], i[1] / 255 * i[3], i[2] / 255 * i[3], i[3]);
          }
        }
      }, Fr.prototype.toString = function() {
        var r = this.toArray(), i = r[1], l = r[2], p = r[3];
        return "rgba(" + Math.round(r[0]) + "," + Math.round(i) + "," + Math.round(l) + "," + p + ")";
      }, Fr.prototype.toArray = function() {
        var r = this.a;
        return r === 0 ? [0, 0, 0, 0] : [255 * this.r / r, 255 * this.g / r, 255 * this.b / r, r];
      }, Fr.black = new Fr(0, 0, 0, 1), Fr.white = new Fr(1, 1, 1, 1), Fr.transparent = new Fr(0, 0, 0, 0), Fr.red = new Fr(1, 0, 0, 1);
      var Yi = function(r, i, l) {
        this.sensitivity = r ? i ? "variant" : "case" : i ? "accent" : "base", this.locale = l, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
      };
      Yi.prototype.compare = function(r, i) {
        return this.collator.compare(r, i);
      }, Yi.prototype.resolvedLocale = function() {
        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
      };
      var $u = function(r, i, l, p, y) {
        this.text = r, this.image = i, this.scale = l, this.fontStack = p, this.textColor = y;
      }, di = function(r) {
        this.sections = r;
      };
      di.fromString = function(r) {
        return new di([new $u(r, null, null, null, null)]);
      }, di.prototype.isEmpty = function() {
        return this.sections.length === 0 || !this.sections.some(function(r) {
          return r.text.length !== 0 || r.image && r.image.name.length !== 0;
        });
      }, di.factory = function(r) {
        return r instanceof di ? r : di.fromString(r);
      }, di.prototype.toString = function() {
        return this.sections.length === 0 ? "" : this.sections.map(function(r) {
          return r.text;
        }).join("");
      }, di.prototype.serialize = function() {
        for (var r = ["format"], i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          if (p.image)
            r.push(["image", p.image.name]);
          else {
            r.push(p.text);
            var y = {};
            p.fontStack && (y["text-font"] = ["literal", p.fontStack.split(",")]), p.scale && (y["font-scale"] = p.scale), p.textColor && (y["text-color"] = ["rgba"].concat(p.textColor.toArray())), r.push(y);
          }
        }
        return r;
      };
      var Ji = function(r) {
        this.name = r.name, this.available = r.available;
      };
      function qf(r, i, l, p) {
        return typeof r == "number" && r >= 0 && r <= 255 && typeof i == "number" && i >= 0 && i <= 255 && typeof l == "number" && l >= 0 && l <= 255 ? p === void 0 || typeof p == "number" && p >= 0 && p <= 1 ? null : "Invalid rgba value [" + [r, i, l, p].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + (typeof p == "number" ? [r, i, l, p] : [r, i, l]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
      }
      function Wu(r) {
        if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof Fr || r instanceof Yi || r instanceof di || r instanceof Ji)
          return !0;
        if (Array.isArray(r)) {
          for (var i = 0, l = r; i < l.length; i += 1)
            if (!Wu(l[i]))
              return !1;
          return !0;
        }
        if (typeof r == "object") {
          for (var p in r)
            if (!Wu(r[p]))
              return !1;
          return !0;
        }
        return !1;
      }
      function kn(r) {
        if (r === null)
          return _t;
        if (typeof r == "string")
          return pt;
        if (typeof r == "boolean")
          return st;
        if (typeof r == "number")
          return Le;
        if (r instanceof Fr)
          return De;
        if (r instanceof Yi)
          return He;
        if (r instanceof di)
          return jt;
        if (r instanceof Ji)
          return Wt;
        if (Array.isArray(r)) {
          for (var i, l = r.length, p = 0, y = r; p < y.length; p += 1) {
            var v = kn(y[p]);
            if (i) {
              if (i === v)
                continue;
              i = Ee;
              break;
            }
            i = v;
          }
          return Jt(i || Ee, l);
        }
        return he;
      }
      function Hu(r) {
        var i = typeof r;
        return r === null ? "" : i === "string" || i === "number" || i === "boolean" ? String(r) : r instanceof Fr || r instanceof di || r instanceof Ji ? r.toString() : JSON.stringify(r);
      }
      Ji.prototype.toString = function() {
        return this.name;
      }, Ji.fromString = function(r) {
        return r ? new Ji({ name: r, available: !1 }) : null;
      }, Ji.prototype.serialize = function() {
        return ["image", this.name];
      };
      var Vi = function(r, i) {
        this.type = r, this.value = i;
      };
      Vi.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("'literal' expression requires exactly one argument, but found " + (r.length - 1) + " instead.");
        if (!Wu(r[1]))
          return i.error("invalid value");
        var l = r[1], p = kn(l), y = i.expectedType;
        return p.kind !== "array" || p.N !== 0 || !y || y.kind !== "array" || typeof y.N == "number" && y.N !== 0 || (p = y), new Vi(p, l);
      }, Vi.prototype.evaluate = function() {
        return this.value;
      }, Vi.prototype.eachChild = function() {
      }, Vi.prototype.outputDefined = function() {
        return !0;
      }, Vi.prototype.serialize = function() {
        return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof Fr ? ["rgba"].concat(this.value.toArray()) : this.value instanceof di ? this.value.serialize() : this.value;
      };
      var mi = function(r) {
        this.name = "ExpressionEvaluationError", this.message = r;
      };
      mi.prototype.toJSON = function() {
        return this.message;
      };
      var jo = { string: pt, number: Le, boolean: st, object: he }, dn = function(r, i) {
        this.type = r, this.args = i;
      };
      dn.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l, p = 1, y = r[0];
        if (y === "array") {
          var v, x;
          if (r.length > 2) {
            var S = r[1];
            if (typeof S != "string" || !(S in jo) || S === "object")
              return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
            v = jo[S], p++;
          } else
            v = Ee;
          if (r.length > 3) {
            if (r[2] !== null && (typeof r[2] != "number" || r[2] < 0 || r[2] !== Math.floor(r[2])))
              return i.error('The length argument to "array" must be a positive integer literal', 2);
            x = r[2], p++;
          }
          l = Jt(v, x);
        } else
          l = jo[y];
        for (var C = []; p < r.length; p++) {
          var A = i.parse(r[p], p, Ee);
          if (!A)
            return null;
          C.push(A);
        }
        return new dn(l, C);
      }, dn.prototype.evaluate = function(r) {
        for (var i = 0; i < this.args.length; i++) {
          var l = this.args[i].evaluate(r);
          if (!Qt(this.type, kn(l)))
            return l;
          if (i === this.args.length - 1)
            throw new mi("Expected value to be of type " + Zt(this.type) + ", but found " + Zt(kn(l)) + " instead.");
        }
        return null;
      }, dn.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, dn.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, dn.prototype.serialize = function() {
        var r = this.type, i = [r.kind];
        if (r.kind === "array") {
          var l = r.itemType;
          if (l.kind === "string" || l.kind === "number" || l.kind === "boolean") {
            i.push(l.kind);
            var p = r.N;
            (typeof p == "number" || this.args.length > 1) && i.push(p);
          }
        }
        return i.concat(this.args.map(function(y) {
          return y.serialize();
        }));
      };
      var ia = function(r) {
        this.type = jt, this.sections = r;
      };
      ia.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l = r[1];
        if (!Array.isArray(l) && typeof l == "object")
          return i.error("First argument must be an image or text section.");
        for (var p = [], y = !1, v = 1; v <= r.length - 1; ++v) {
          var x = r[v];
          if (y && typeof x == "object" && !Array.isArray(x)) {
            y = !1;
            var S = null;
            if (x["font-scale"] && !(S = i.parse(x["font-scale"], 1, Le)))
              return null;
            var C = null;
            if (x["text-font"] && !(C = i.parse(x["text-font"], 1, Jt(pt))))
              return null;
            var A = null;
            if (x["text-color"] && !(A = i.parse(x["text-color"], 1, De)))
              return null;
            var L = p[p.length - 1];
            L.scale = S, L.font = C, L.textColor = A;
          } else {
            var D = i.parse(r[v], 1, Ee);
            if (!D)
              return null;
            var B = D.type.kind;
            if (B !== "string" && B !== "value" && B !== "null" && B !== "resolvedImage")
              return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
            y = !0, p.push({ content: D, scale: null, font: null, textColor: null });
          }
        }
        return new ia(p);
      }, ia.prototype.evaluate = function(r) {
        return new di(this.sections.map(function(i) {
          var l = i.content.evaluate(r);
          return kn(l) === Wt ? new $u("", l, null, null, null) : new $u(Hu(l), null, i.scale ? i.scale.evaluate(r) : null, i.font ? i.font.evaluate(r).join(",") : null, i.textColor ? i.textColor.evaluate(r) : null);
        }));
      }, ia.prototype.eachChild = function(r) {
        for (var i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          r(p.content), p.scale && r(p.scale), p.font && r(p.font), p.textColor && r(p.textColor);
        }
      }, ia.prototype.outputDefined = function() {
        return !1;
      }, ia.prototype.serialize = function() {
        for (var r = ["format"], i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          r.push(p.content.serialize());
          var y = {};
          p.scale && (y["font-scale"] = p.scale.serialize()), p.font && (y["text-font"] = p.font.serialize()), p.textColor && (y["text-color"] = p.textColor.serialize()), r.push(y);
        }
        return r;
      };
      var To = function(r) {
        this.type = Wt, this.input = r;
      };
      To.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected two arguments.");
        var l = i.parse(r[1], 1, pt);
        return l ? new To(l) : i.error("No image name provided.");
      }, To.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r), l = Ji.fromString(i);
        return l && r.availableImages && (l.available = r.availableImages.indexOf(i) > -1), l;
      }, To.prototype.eachChild = function(r) {
        r(this.input);
      }, To.prototype.outputDefined = function() {
        return !1;
      }, To.prototype.serialize = function() {
        return ["image", this.input.serialize()];
      };
      var im = { "to-boolean": st, "to-color": De, "to-number": Le, "to-string": pt }, Go = function(r, i) {
        this.type = r, this.args = i;
      };
      Go.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l = r[0];
        if ((l === "to-boolean" || l === "to-string") && r.length !== 2)
          return i.error("Expected one argument.");
        for (var p = im[l], y = [], v = 1; v < r.length; v++) {
          var x = i.parse(r[v], v, Ee);
          if (!x)
            return null;
          y.push(x);
        }
        return new Go(p, y);
      }, Go.prototype.evaluate = function(r) {
        if (this.type.kind === "boolean")
          return Boolean(this.args[0].evaluate(r));
        if (this.type.kind === "color") {
          for (var i, l, p = 0, y = this.args; p < y.length; p += 1) {
            if (l = null, (i = y[p].evaluate(r)) instanceof Fr)
              return i;
            if (typeof i == "string") {
              var v = r.parseColor(i);
              if (v)
                return v;
            } else if (Array.isArray(i) && !(l = i.length < 3 || i.length > 4 ? "Invalid rbga value " + JSON.stringify(i) + ": expected an array containing either three or four numeric values." : qf(i[0], i[1], i[2], i[3])))
              return new Fr(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
          }
          throw new mi(l || "Could not parse color from value '" + (typeof i == "string" ? i : String(JSON.stringify(i))) + "'");
        }
        if (this.type.kind === "number") {
          for (var x = null, S = 0, C = this.args; S < C.length; S += 1) {
            if ((x = C[S].evaluate(r)) === null)
              return 0;
            var A = Number(x);
            if (!isNaN(A))
              return A;
          }
          throw new mi("Could not convert " + JSON.stringify(x) + " to number.");
        }
        return this.type.kind === "formatted" ? di.fromString(Hu(this.args[0].evaluate(r))) : this.type.kind === "resolvedImage" ? Ji.fromString(Hu(this.args[0].evaluate(r))) : Hu(this.args[0].evaluate(r));
      }, Go.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, Go.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, Go.prototype.serialize = function() {
        if (this.type.kind === "formatted")
          return new ia([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
        if (this.type.kind === "resolvedImage")
          return new To(this.args[0]).serialize();
        var r = ["to-" + this.type.kind];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var Nv = ["Unknown", "Point", "LineString", "Polygon"], Va = function() {
        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
      };
      Va.prototype.id = function() {
        return this.feature && "id" in this.feature ? this.feature.id : null;
      }, Va.prototype.geometryType = function() {
        return this.feature ? typeof this.feature.type == "number" ? Nv[this.feature.type] : this.feature.type : null;
      }, Va.prototype.geometry = function() {
        return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
      }, Va.prototype.canonicalID = function() {
        return this.canonical;
      }, Va.prototype.properties = function() {
        return this.feature && this.feature.properties || {};
      }, Va.prototype.parseColor = function(r) {
        var i = this._parseColorCache[r];
        return i || (i = this._parseColorCache[r] = Fr.parse(r)), i;
      };
      var Ei = function(r, i, l, p) {
        this.name = r, this.type = i, this._evaluate = l, this.args = p;
      };
      Ei.prototype.evaluate = function(r) {
        return this._evaluate(r, this.args);
      }, Ei.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, Ei.prototype.outputDefined = function() {
        return !1;
      }, Ei.prototype.serialize = function() {
        return [this.name].concat(this.args.map(function(r) {
          return r.serialize();
        }));
      }, Ei.parse = function(r, i) {
        var l, p = r[0], y = Ei.definitions[p];
        if (!y)
          return i.error('Unknown expression "' + p + '". If you wanted a literal array, use ["literal", [...]].', 0);
        for (var v = Array.isArray(y) ? y[0] : y.type, x = Array.isArray(y) ? [[y[1], y[2]]] : y.overloads, S = x.filter(function(Nt) {
          var yt = Nt[0];
          return !Array.isArray(yt) || yt.length === r.length - 1;
        }), C = null, A = 0, L = S; A < L.length; A += 1) {
          var D = L[A], B = D[0], j = D[1];
          C = new ms(i.registry, i.path, null, i.scope);
          for (var Q = [], te = !1, ce = 1; ce < r.length; ce++) {
            var oe = r[ce], ge = Array.isArray(B) ? B[ce - 1] : B.type, we = C.parse(oe, 1 + Q.length, ge);
            if (!we) {
              te = !0;
              break;
            }
            Q.push(we);
          }
          if (!te)
            if (Array.isArray(B) && B.length !== Q.length)
              C.error("Expected " + B.length + " arguments, but found " + Q.length + " instead.");
            else {
              for (var Te = 0; Te < Q.length; Te++) {
                var Oe = Array.isArray(B) ? B[Te] : B.type, Be = Q[Te];
                C.concat(Te + 1).checkSubtype(Oe, Be.type);
              }
              if (C.errors.length === 0)
                return new Ei(p, v, j, Q);
            }
        }
        if (S.length === 1)
          (l = i.errors).push.apply(l, C.errors);
        else {
          for (var Xe = (S.length ? S : x).map(function(Nt) {
            var yt;
            return yt = Nt[0], Array.isArray(yt) ? "(" + yt.map(Zt).join(", ") + ")" : "(" + Zt(yt.type) + "...)";
          }).join(" | "), ot = [], At = 1; At < r.length; At++) {
            var dt = i.parse(r[At], 1 + ot.length);
            if (!dt)
              return null;
            ot.push(Zt(dt.type));
          }
          i.error("Expected arguments of type " + Xe + ", but found (" + ot.join(", ") + ") instead.");
        }
        return null;
      }, Ei.register = function(r, i) {
        for (var l in Ei.definitions = i, i)
          r[l] = Ei;
      };
      var _a = function(r, i, l) {
        this.type = He, this.locale = l, this.caseSensitive = r, this.diacriticSensitive = i;
      };
      function Ui(r, i) {
        r[0] = Math.min(r[0], i[0]), r[1] = Math.min(r[1], i[1]), r[2] = Math.max(r[2], i[0]), r[3] = Math.max(r[3], i[1]);
      }
      function nl(r, i) {
        return !(r[0] <= i[0] || r[2] >= i[2] || r[1] <= i[1] || r[3] >= i[3]);
      }
      function Rv(r, i) {
        var l = (180 + r[0]) / 360, p = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r[1] * Math.PI / 360))) / 360, y = Math.pow(2, i.z);
        return [Math.round(l * y * 8192), Math.round(p * y * 8192)];
      }
      function zv(r, i, l) {
        return i[1] > r[1] != l[1] > r[1] && r[0] < (l[0] - i[0]) * (r[1] - i[1]) / (l[1] - i[1]) + i[0];
      }
      function $f(r, i) {
        for (var l, p, y, v, x, S, C, A = !1, L = 0, D = i.length; L < D; L++)
          for (var B = i[L], j = 0, Q = B.length; j < Q - 1; j++) {
            if ((v = (l = r)[0] - (p = B[j])[0]) * (C = l[1] - (y = B[j + 1])[1]) - (S = l[0] - y[0]) * (x = l[1] - p[1]) == 0 && v * S <= 0 && x * C <= 0)
              return !1;
            zv(r, B[j], B[j + 1]) && (A = !A);
          }
        return A;
      }
      function Fv(r, i) {
        for (var l = 0; l < i.length; l++)
          if ($f(r, i[l]))
            return !0;
        return !1;
      }
      function om(r, i, l, p) {
        var y = p[0] - l[0], v = p[1] - l[1], x = (r[0] - l[0]) * v - y * (r[1] - l[1]), S = (i[0] - l[0]) * v - y * (i[1] - l[1]);
        return x > 0 && S < 0 || x < 0 && S > 0;
      }
      function Bv(r, i, l) {
        for (var p = 0, y = l; p < y.length; p += 1)
          for (var v = y[p], x = 0; x < v.length - 1; ++x)
            if ((D = [(L = v[x + 1])[0] - (A = v[x])[0], L[1] - A[1]])[0] * (B = [(C = i)[0] - (S = r)[0], C[1] - S[1]])[1] - D[1] * B[0] != 0 && om(S, C, A, L) && om(A, L, S, C))
              return !0;
        var S, C, A, L, D, B;
        return !1;
      }
      function am(r, i) {
        for (var l = 0; l < r.length; ++l)
          if (!$f(r[l], i))
            return !1;
        for (var p = 0; p < r.length - 1; ++p)
          if (Bv(r[p], r[p + 1], i))
            return !1;
        return !0;
      }
      function sm(r, i) {
        for (var l = 0; l < i.length; l++)
          if (am(r, i[l]))
            return !0;
        return !1;
      }
      function Hl(r, i, l) {
        for (var p = [], y = 0; y < r.length; y++) {
          for (var v = [], x = 0; x < r[y].length; x++) {
            var S = Rv(r[y][x], l);
            Ui(i, S), v.push(S);
          }
          p.push(v);
        }
        return p;
      }
      function Wf(r, i, l) {
        for (var p = [], y = 0; y < r.length; y++) {
          var v = Hl(r[y], i, l);
          p.push(v);
        }
        return p;
      }
      function Zu(r, i, l, p) {
        if (r[0] < l[0] || r[0] > l[2]) {
          var y = 0.5 * p, v = r[0] - l[0] > y ? -p : l[0] - r[0] > y ? p : 0;
          v === 0 && (v = r[0] - l[2] > y ? -p : l[2] - r[0] > y ? p : 0), r[0] += v;
        }
        Ui(i, r);
      }
      function lm(r, i, l, p) {
        for (var y = 8192 * Math.pow(2, p.z), v = [8192 * p.x, 8192 * p.y], x = [], S = 0, C = r; S < C.length; S += 1)
          for (var A = 0, L = C[S]; A < L.length; A += 1) {
            var D = L[A], B = [D.x + v[0], D.y + v[1]];
            Zu(B, i, l, y), x.push(B);
          }
        return x;
      }
      function ah(r, i, l, p) {
        for (var y, v = 8192 * Math.pow(2, p.z), x = [8192 * p.x, 8192 * p.y], S = [], C = 0, A = r; C < A.length; C += 1) {
          for (var L = [], D = 0, B = A[C]; D < B.length; D += 1) {
            var j = B[D], Q = [j.x + x[0], j.y + x[1]];
            Ui(i, Q), L.push(Q);
          }
          S.push(L);
        }
        if (i[2] - i[0] <= v / 2) {
          (y = i)[0] = y[1] = 1 / 0, y[2] = y[3] = -1 / 0;
          for (var te = 0, ce = S; te < ce.length; te += 1)
            for (var oe = 0, ge = ce[te]; oe < ge.length; oe += 1)
              Zu(ge[oe], i, l, v);
        }
        return S;
      }
      _a.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected one argument.");
        var l = r[1];
        if (typeof l != "object" || Array.isArray(l))
          return i.error("Collator options argument must be an object.");
        var p = i.parse(l["case-sensitive"] !== void 0 && l["case-sensitive"], 1, st);
        if (!p)
          return null;
        var y = i.parse(l["diacritic-sensitive"] !== void 0 && l["diacritic-sensitive"], 1, st);
        if (!y)
          return null;
        var v = null;
        return l.locale && !(v = i.parse(l.locale, 1, pt)) ? null : new _a(p, y, v);
      }, _a.prototype.evaluate = function(r) {
        return new Yi(this.caseSensitive.evaluate(r), this.diacriticSensitive.evaluate(r), this.locale ? this.locale.evaluate(r) : null);
      }, _a.prototype.eachChild = function(r) {
        r(this.caseSensitive), r(this.diacriticSensitive), this.locale && r(this.locale);
      }, _a.prototype.outputDefined = function() {
        return !1;
      }, _a.prototype.serialize = function() {
        var r = {};
        return r["case-sensitive"] = this.caseSensitive.serialize(), r["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (r.locale = this.locale.serialize()), ["collator", r];
      };
      var qo = function(r, i) {
        this.type = st, this.geojson = r, this.geometries = i;
      };
      function fs(r) {
        if (r instanceof Ei && (r.name === "get" && r.args.length === 1 || r.name === "feature-state" || r.name === "has" && r.args.length === 1 || r.name === "properties" || r.name === "geometry-type" || r.name === "id" || /^filter-/.test(r.name)) || r instanceof qo)
          return !1;
        var i = !0;
        return r.eachChild(function(l) {
          i && !fs(l) && (i = !1);
        }), i;
      }
      function ps(r) {
        if (r instanceof Ei && r.name === "feature-state")
          return !1;
        var i = !0;
        return r.eachChild(function(l) {
          i && !ps(l) && (i = !1);
        }), i;
      }
      function il(r, i) {
        if (r instanceof Ei && i.indexOf(r.name) >= 0)
          return !1;
        var l = !0;
        return r.eachChild(function(p) {
          l && !il(p, i) && (l = !1);
        }), l;
      }
      qo.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("'within' expression requires exactly one argument, but found " + (r.length - 1) + " instead.");
        if (Wu(r[1])) {
          var l = r[1];
          if (l.type === "FeatureCollection")
            for (var p = 0; p < l.features.length; ++p) {
              var y = l.features[p].geometry.type;
              if (y === "Polygon" || y === "MultiPolygon")
                return new qo(l, l.features[p].geometry);
            }
          else if (l.type === "Feature") {
            var v = l.geometry.type;
            if (v === "Polygon" || v === "MultiPolygon")
              return new qo(l, l.geometry);
          } else if (l.type === "Polygon" || l.type === "MultiPolygon")
            return new qo(l, l);
        }
        return i.error("'within' expression requires valid geojson object that contains polygon geometry type.");
      }, qo.prototype.evaluate = function(r) {
        if (r.geometry() != null && r.canonicalID() != null) {
          if (r.geometryType() === "Point")
            return function(i, l) {
              var p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = i.canonicalID();
              if (l.type === "Polygon") {
                var x = Hl(l.coordinates, y, v), S = lm(i.geometry(), p, y, v);
                if (!nl(p, y))
                  return !1;
                for (var C = 0, A = S; C < A.length; C += 1)
                  if (!$f(A[C], x))
                    return !1;
              }
              if (l.type === "MultiPolygon") {
                var L = Wf(l.coordinates, y, v), D = lm(i.geometry(), p, y, v);
                if (!nl(p, y))
                  return !1;
                for (var B = 0, j = D; B < j.length; B += 1)
                  if (!Fv(j[B], L))
                    return !1;
              }
              return !0;
            }(r, this.geometries);
          if (r.geometryType() === "LineString")
            return function(i, l) {
              var p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = i.canonicalID();
              if (l.type === "Polygon") {
                var x = Hl(l.coordinates, y, v), S = ah(i.geometry(), p, y, v);
                if (!nl(p, y))
                  return !1;
                for (var C = 0, A = S; C < A.length; C += 1)
                  if (!am(A[C], x))
                    return !1;
              }
              if (l.type === "MultiPolygon") {
                var L = Wf(l.coordinates, y, v), D = ah(i.geometry(), p, y, v);
                if (!nl(p, y))
                  return !1;
                for (var B = 0, j = D; B < j.length; B += 1)
                  if (!sm(j[B], L))
                    return !1;
              }
              return !0;
            }(r, this.geometries);
        }
        return !1;
      }, qo.prototype.eachChild = function() {
      }, qo.prototype.outputDefined = function() {
        return !0;
      }, qo.prototype.serialize = function() {
        return ["within", this.geojson];
      };
      var ds = function(r, i) {
        this.type = i.type, this.name = r, this.boundExpression = i;
      };
      ds.parse = function(r, i) {
        if (r.length !== 2 || typeof r[1] != "string")
          return i.error("'var' expression requires exactly one string literal argument.");
        var l = r[1];
        return i.scope.has(l) ? new ds(l, i.scope.get(l)) : i.error('Unknown variable "' + l + '". Make sure "' + l + '" has been bound in an enclosing "let" expression before using it.', 1);
      }, ds.prototype.evaluate = function(r) {
        return this.boundExpression.evaluate(r);
      }, ds.prototype.eachChild = function() {
      }, ds.prototype.outputDefined = function() {
        return !1;
      }, ds.prototype.serialize = function() {
        return ["var", this.name];
      };
      var ms = function(r, i, l, p, y) {
        i === void 0 && (i = []), p === void 0 && (p = new Et()), y === void 0 && (y = []), this.registry = r, this.path = i, this.key = i.map(function(v) {
          return "[" + v + "]";
        }).join(""), this.scope = p, this.errors = y, this.expectedType = l;
      };
      function sh(r, i) {
        for (var l, p = r.length - 1, y = 0, v = p, x = 0; y <= v; )
          if ((l = r[x = Math.floor((y + v) / 2)]) <= i) {
            if (x === p || i < r[x + 1])
              return x;
            y = x + 1;
          } else {
            if (!(l > i))
              throw new mi("Input is not a number.");
            v = x - 1;
          }
        return 0;
      }
      ms.prototype.parse = function(r, i, l, p, y) {
        return y === void 0 && (y = {}), i ? this.concat(i, l, p)._parse(r, y) : this._parse(r, y);
      }, ms.prototype._parse = function(r, i) {
        function l(A, L, D) {
          return D === "assert" ? new dn(L, [A]) : D === "coerce" ? new Go(L, [A]) : A;
        }
        if (r !== null && typeof r != "string" && typeof r != "boolean" && typeof r != "number" || (r = ["literal", r]), Array.isArray(r)) {
          if (r.length === 0)
            return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
          var p = r[0];
          if (typeof p != "string")
            return this.error("Expression name must be a string, but found " + typeof p + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null;
          var y = this.registry[p];
          if (y) {
            var v = y.parse(r, this);
            if (!v)
              return null;
            if (this.expectedType) {
              var x = this.expectedType, S = v.type;
              if (x.kind !== "string" && x.kind !== "number" && x.kind !== "boolean" && x.kind !== "object" && x.kind !== "array" || S.kind !== "value")
                if (x.kind !== "color" && x.kind !== "formatted" && x.kind !== "resolvedImage" || S.kind !== "value" && S.kind !== "string") {
                  if (this.checkSubtype(x, S))
                    return null;
                } else
                  v = l(v, x, i.typeAnnotation || "coerce");
              else
                v = l(v, x, i.typeAnnotation || "assert");
            }
            if (!(v instanceof Vi) && v.type.kind !== "resolvedImage" && function A(L) {
              if (L instanceof ds)
                return A(L.boundExpression);
              if (L instanceof Ei && L.name === "error" || L instanceof _a || L instanceof qo)
                return !1;
              var D = L instanceof Go || L instanceof dn, B = !0;
              return L.eachChild(function(j) {
                B = D ? B && A(j) : B && j instanceof Vi;
              }), !!B && fs(L) && il(L, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
            }(v)) {
              var C = new Va();
              try {
                v = new Vi(v.type, v.evaluate(C));
              } catch (A) {
                return this.error(A.message), null;
              }
            }
            return v;
          }
          return this.error('Unknown expression "' + p + '". If you wanted a literal array, use ["literal", [...]].', 0);
        }
        return this.error(r === void 0 ? "'undefined' value invalid. Use null instead." : typeof r == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found " + typeof r + " instead.");
      }, ms.prototype.concat = function(r, i, l) {
        var p = typeof r == "number" ? this.path.concat(r) : this.path, y = l ? this.scope.concat(l) : this.scope;
        return new ms(this.registry, p, i || null, y, this.errors);
      }, ms.prototype.error = function(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        var p = "" + this.key + i.map(function(y) {
          return "[" + y + "]";
        }).join("");
        this.errors.push(new Ue(p, r));
      }, ms.prototype.checkSubtype = function(r, i) {
        var l = Qt(r, i);
        return l && this.error(l), l;
      };
      var lo = function(r, i, l) {
        this.type = r, this.input = i, this.labels = [], this.outputs = [];
        for (var p = 0, y = l; p < y.length; p += 1) {
          var v = y[p], x = v[1];
          this.labels.push(v[0]), this.outputs.push(x);
        }
      };
      function jn(r, i, l) {
        return r * (1 - l) + i * l;
      }
      lo.parse = function(r, i) {
        if (r.length - 1 < 4)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if ((r.length - 1) % 2 != 0)
          return i.error("Expected an even number of arguments.");
        var l = i.parse(r[1], 1, Le);
        if (!l)
          return null;
        var p = [], y = null;
        i.expectedType && i.expectedType.kind !== "value" && (y = i.expectedType);
        for (var v = 1; v < r.length; v += 2) {
          var x = v === 1 ? -1 / 0 : r[v], S = r[v + 1], C = v, A = v + 1;
          if (typeof x != "number")
            return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', C);
          if (p.length && p[p.length - 1][0] >= x)
            return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', C);
          var L = i.parse(S, A, y);
          if (!L)
            return null;
          y = y || L.type, p.push([x, L]);
        }
        return new lo(y, l, p);
      }, lo.prototype.evaluate = function(r) {
        var i = this.labels, l = this.outputs;
        if (i.length === 1)
          return l[0].evaluate(r);
        var p = this.input.evaluate(r);
        if (p <= i[0])
          return l[0].evaluate(r);
        var y = i.length;
        return p >= i[y - 1] ? l[y - 1].evaluate(r) : l[sh(i, p)].evaluate(r);
      }, lo.prototype.eachChild = function(r) {
        r(this.input);
        for (var i = 0, l = this.outputs; i < l.length; i += 1)
          r(l[i]);
      }, lo.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        });
      }, lo.prototype.serialize = function() {
        for (var r = ["step", this.input.serialize()], i = 0; i < this.labels.length; i++)
          i > 0 && r.push(this.labels[i]), r.push(this.outputs[i].serialize());
        return r;
      };
      var Zl = Object.freeze({ __proto__: null, number: jn, color: function(r, i, l) {
        return new Fr(jn(r.r, i.r, l), jn(r.g, i.g, l), jn(r.b, i.b, l), jn(r.a, i.a, l));
      }, array: function(r, i, l) {
        return r.map(function(p, y) {
          return jn(p, i[y], l);
        });
      } }), um = 6 / 29 * 3 * (6 / 29), Vv = Math.PI / 180, Uv = 180 / Math.PI;
      function Hf(r) {
        return r > 0.008856451679035631 ? Math.pow(r, 1 / 3) : r / um + 4 / 29;
      }
      function Zf(r) {
        return r > 6 / 29 ? r * r * r : um * (r - 4 / 29);
      }
      function Xf(r) {
        return 255 * (r <= 31308e-7 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055);
      }
      function Kf(r) {
        return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      }
      function cm(r) {
        var i = Kf(r.r), l = Kf(r.g), p = Kf(r.b), y = Hf((0.4124564 * i + 0.3575761 * l + 0.1804375 * p) / 0.95047), v = Hf((0.2126729 * i + 0.7151522 * l + 0.072175 * p) / 1);
        return { l: 116 * v - 16, a: 500 * (y - v), b: 200 * (v - Hf((0.0193339 * i + 0.119192 * l + 0.9503041 * p) / 1.08883)), alpha: r.a };
      }
      function hm(r) {
        var i = (r.l + 16) / 116, l = isNaN(r.a) ? i : i + r.a / 500, p = isNaN(r.b) ? i : i - r.b / 200;
        return i = 1 * Zf(i), l = 0.95047 * Zf(l), p = 1.08883 * Zf(p), new Fr(Xf(3.2404542 * l - 1.5371385 * i - 0.4985314 * p), Xf(-0.969266 * l + 1.8760108 * i + 0.041556 * p), Xf(0.0556434 * l - 0.2040259 * i + 1.0572252 * p), r.alpha);
      }
      function jv(r, i, l) {
        var p = i - r;
        return r + l * (p > 180 || p < -180 ? p - 360 * Math.round(p / 360) : p);
      }
      var Xu = { forward: cm, reverse: hm, interpolate: function(r, i, l) {
        return { l: jn(r.l, i.l, l), a: jn(r.a, i.a, l), b: jn(r.b, i.b, l), alpha: jn(r.alpha, i.alpha, l) };
      } }, Ku = { forward: function(r) {
        var i = cm(r), l = i.l, p = i.a, y = i.b, v = Math.atan2(y, p) * Uv;
        return { h: v < 0 ? v + 360 : v, c: Math.sqrt(p * p + y * y), l, alpha: r.a };
      }, reverse: function(r) {
        var i = r.h * Vv, l = r.c;
        return hm({ l: r.l, a: Math.cos(i) * l, b: Math.sin(i) * l, alpha: r.alpha });
      }, interpolate: function(r, i, l) {
        return { h: jv(r.h, i.h, l), c: jn(r.c, i.c, l), l: jn(r.l, i.l, l), alpha: jn(r.alpha, i.alpha, l) };
      } }, fm = Object.freeze({ __proto__: null, lab: Xu, hcl: Ku }), Si = function(r, i, l, p, y) {
        this.type = r, this.operator = i, this.interpolation = l, this.input = p, this.labels = [], this.outputs = [];
        for (var v = 0, x = y; v < x.length; v += 1) {
          var S = x[v], C = S[1];
          this.labels.push(S[0]), this.outputs.push(C);
        }
      };
      function Yf(r, i, l, p) {
        var y = p - l, v = r - l;
        return y === 0 ? 0 : i === 1 ? v / y : (Math.pow(i, v) - 1) / (Math.pow(i, y) - 1);
      }
      Si.interpolationFactor = function(r, i, l, p) {
        var y = 0;
        if (r.name === "exponential")
          y = Yf(i, r.base, l, p);
        else if (r.name === "linear")
          y = Yf(i, 1, l, p);
        else if (r.name === "cubic-bezier") {
          var v = r.controlPoints;
          y = new g(v[0], v[1], v[2], v[3]).solve(Yf(i, 1, l, p));
        }
        return y;
      }, Si.parse = function(r, i) {
        var l = r[0], p = r[1], y = r[2], v = r.slice(3);
        if (!Array.isArray(p) || p.length === 0)
          return i.error("Expected an interpolation type expression.", 1);
        if (p[0] === "linear")
          p = { name: "linear" };
        else if (p[0] === "exponential") {
          var x = p[1];
          if (typeof x != "number")
            return i.error("Exponential interpolation requires a numeric base.", 1, 1);
          p = { name: "exponential", base: x };
        } else {
          if (p[0] !== "cubic-bezier")
            return i.error("Unknown interpolation type " + String(p[0]), 1, 0);
          var S = p.slice(1);
          if (S.length !== 4 || S.some(function(ce) {
            return typeof ce != "number" || ce < 0 || ce > 1;
          }))
            return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
          p = { name: "cubic-bezier", controlPoints: S };
        }
        if (r.length - 1 < 4)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if ((r.length - 1) % 2 != 0)
          return i.error("Expected an even number of arguments.");
        if (!(y = i.parse(y, 2, Le)))
          return null;
        var C = [], A = null;
        l === "interpolate-hcl" || l === "interpolate-lab" ? A = De : i.expectedType && i.expectedType.kind !== "value" && (A = i.expectedType);
        for (var L = 0; L < v.length; L += 2) {
          var D = v[L], B = v[L + 1], j = L + 3, Q = L + 4;
          if (typeof D != "number")
            return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', j);
          if (C.length && C[C.length - 1][0] >= D)
            return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', j);
          var te = i.parse(B, Q, A);
          if (!te)
            return null;
          A = A || te.type, C.push([D, te]);
        }
        return A.kind === "number" || A.kind === "color" || A.kind === "array" && A.itemType.kind === "number" && typeof A.N == "number" ? new Si(A, l, p, y, C) : i.error("Type " + Zt(A) + " is not interpolatable.");
      }, Si.prototype.evaluate = function(r) {
        var i = this.labels, l = this.outputs;
        if (i.length === 1)
          return l[0].evaluate(r);
        var p = this.input.evaluate(r);
        if (p <= i[0])
          return l[0].evaluate(r);
        var y = i.length;
        if (p >= i[y - 1])
          return l[y - 1].evaluate(r);
        var v = sh(i, p), x = Si.interpolationFactor(this.interpolation, p, i[v], i[v + 1]), S = l[v].evaluate(r), C = l[v + 1].evaluate(r);
        return this.operator === "interpolate" ? Zl[this.type.kind.toLowerCase()](S, C, x) : this.operator === "interpolate-hcl" ? Ku.reverse(Ku.interpolate(Ku.forward(S), Ku.forward(C), x)) : Xu.reverse(Xu.interpolate(Xu.forward(S), Xu.forward(C), x));
      }, Si.prototype.eachChild = function(r) {
        r(this.input);
        for (var i = 0, l = this.outputs; i < l.length; i += 1)
          r(l[i]);
      }, Si.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        });
      }, Si.prototype.serialize = function() {
        var r;
        r = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
        for (var i = [this.operator, r, this.input.serialize()], l = 0; l < this.labels.length; l++)
          i.push(this.labels[l], this.outputs[l].serialize());
        return i;
      };
      var ys = function(r, i) {
        this.type = r, this.args = i;
      };
      ys.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expectected at least one argument.");
        var l = null, p = i.expectedType;
        p && p.kind !== "value" && (l = p);
        for (var y = [], v = 0, x = r.slice(1); v < x.length; v += 1) {
          var S = i.parse(x[v], 1 + y.length, l, void 0, { typeAnnotation: "omit" });
          if (!S)
            return null;
          l = l || S.type, y.push(S);
        }
        var C = p && y.some(function(A) {
          return Qt(p, A.type);
        });
        return new ys(C ? Ee : l, y);
      }, ys.prototype.evaluate = function(r) {
        for (var i, l = null, p = 0, y = 0, v = this.args; y < v.length && (p++, (l = v[y].evaluate(r)) && l instanceof Ji && !l.available && (i || (i = l.name), l = null, p === this.args.length && (l = i)), l === null); y += 1)
          ;
        return l;
      }, ys.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, ys.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, ys.prototype.serialize = function() {
        var r = ["coalesce"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var gs = function(r, i) {
        this.type = i.type, this.bindings = [].concat(r), this.result = i;
      };
      gs.prototype.evaluate = function(r) {
        return this.result.evaluate(r);
      }, gs.prototype.eachChild = function(r) {
        for (var i = 0, l = this.bindings; i < l.length; i += 1)
          r(l[i][1]);
        r(this.result);
      }, gs.parse = function(r, i) {
        if (r.length < 4)
          return i.error("Expected at least 3 arguments, but found " + (r.length - 1) + " instead.");
        for (var l = [], p = 1; p < r.length - 1; p += 2) {
          var y = r[p];
          if (typeof y != "string")
            return i.error("Expected string, but found " + typeof y + " instead.", p);
          if (/[^a-zA-Z0-9_]/.test(y))
            return i.error("Variable names must contain only alphanumeric characters or '_'.", p);
          var v = i.parse(r[p + 1], p + 1);
          if (!v)
            return null;
          l.push([y, v]);
        }
        var x = i.parse(r[r.length - 1], r.length - 1, i.expectedType, l);
        return x ? new gs(l, x) : null;
      }, gs.prototype.outputDefined = function() {
        return this.result.outputDefined();
      }, gs.prototype.serialize = function() {
        for (var r = ["let"], i = 0, l = this.bindings; i < l.length; i += 1) {
          var p = l[i];
          r.push(p[0], p[1].serialize());
        }
        return r.push(this.result.serialize()), r;
      };
      var ol = function(r, i, l) {
        this.type = r, this.index = i, this.input = l;
      };
      ol.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected 2 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Le), p = i.parse(r[2], 2, Jt(i.expectedType || Ee));
        return l && p ? new ol(p.type.itemType, l, p) : null;
      }, ol.prototype.evaluate = function(r) {
        var i = this.index.evaluate(r), l = this.input.evaluate(r);
        if (i < 0)
          throw new mi("Array index out of bounds: " + i + " < 0.");
        if (i >= l.length)
          throw new mi("Array index out of bounds: " + i + " > " + (l.length - 1) + ".");
        if (i !== Math.floor(i))
          throw new mi("Array index must be an integer, but found " + i + " instead.");
        return l[i];
      }, ol.prototype.eachChild = function(r) {
        r(this.index), r(this.input);
      }, ol.prototype.outputDefined = function() {
        return !1;
      }, ol.prototype.serialize = function() {
        return ["at", this.index.serialize(), this.input.serialize()];
      };
      var al = function(r, i) {
        this.type = st, this.needle = r, this.haystack = i;
      };
      al.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected 2 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Ee), p = i.parse(r[2], 2, Ee);
        return l && p ? pn(l.type, [st, pt, Le, _t, Ee]) ? new al(l, p) : i.error("Expected first argument to be of type boolean, string, number or null, but found " + Zt(l.type) + " instead") : null;
      }, al.prototype.evaluate = function(r) {
        var i = this.needle.evaluate(r), l = this.haystack.evaluate(r);
        if (!l)
          return !1;
        if (!Ur(i, ["boolean", "string", "number", "null"]))
          throw new mi("Expected first argument to be of type boolean, string, number or null, but found " + Zt(kn(i)) + " instead.");
        if (!Ur(l, ["string", "array"]))
          throw new mi("Expected second argument to be of type array or string, but found " + Zt(kn(l)) + " instead.");
        return l.indexOf(i) >= 0;
      }, al.prototype.eachChild = function(r) {
        r(this.needle), r(this.haystack);
      }, al.prototype.outputDefined = function() {
        return !0;
      }, al.prototype.serialize = function() {
        return ["in", this.needle.serialize(), this.haystack.serialize()];
      };
      var vs = function(r, i, l) {
        this.type = Le, this.needle = r, this.haystack = i, this.fromIndex = l;
      };
      vs.parse = function(r, i) {
        if (r.length <= 2 || r.length >= 5)
          return i.error("Expected 3 or 4 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Ee), p = i.parse(r[2], 2, Ee);
        if (!l || !p)
          return null;
        if (!pn(l.type, [st, pt, Le, _t, Ee]))
          return i.error("Expected first argument to be of type boolean, string, number or null, but found " + Zt(l.type) + " instead");
        if (r.length === 4) {
          var y = i.parse(r[3], 3, Le);
          return y ? new vs(l, p, y) : null;
        }
        return new vs(l, p);
      }, vs.prototype.evaluate = function(r) {
        var i = this.needle.evaluate(r), l = this.haystack.evaluate(r);
        if (!Ur(i, ["boolean", "string", "number", "null"]))
          throw new mi("Expected first argument to be of type boolean, string, number or null, but found " + Zt(kn(i)) + " instead.");
        if (!Ur(l, ["string", "array"]))
          throw new mi("Expected second argument to be of type array or string, but found " + Zt(kn(l)) + " instead.");
        if (this.fromIndex) {
          var p = this.fromIndex.evaluate(r);
          return l.indexOf(i, p);
        }
        return l.indexOf(i);
      }, vs.prototype.eachChild = function(r) {
        r(this.needle), r(this.haystack), this.fromIndex && r(this.fromIndex);
      }, vs.prototype.outputDefined = function() {
        return !1;
      }, vs.prototype.serialize = function() {
        if (this.fromIndex != null && this.fromIndex !== void 0) {
          var r = this.fromIndex.serialize();
          return ["index-of", this.needle.serialize(), this.haystack.serialize(), r];
        }
        return ["index-of", this.needle.serialize(), this.haystack.serialize()];
      };
      var sl = function(r, i, l, p, y, v) {
        this.inputType = r, this.type = i, this.input = l, this.cases = p, this.outputs = y, this.otherwise = v;
      };
      sl.parse = function(r, i) {
        if (r.length < 5)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if (r.length % 2 != 1)
          return i.error("Expected an even number of arguments.");
        var l, p;
        i.expectedType && i.expectedType.kind !== "value" && (p = i.expectedType);
        for (var y = {}, v = [], x = 2; x < r.length - 1; x += 2) {
          var S = r[x], C = r[x + 1];
          Array.isArray(S) || (S = [S]);
          var A = i.concat(x);
          if (S.length === 0)
            return A.error("Expected at least one branch label.");
          for (var L = 0, D = S; L < D.length; L += 1) {
            var B = D[L];
            if (typeof B != "number" && typeof B != "string")
              return A.error("Branch labels must be numbers or strings.");
            if (typeof B == "number" && Math.abs(B) > Number.MAX_SAFE_INTEGER)
              return A.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
            if (typeof B == "number" && Math.floor(B) !== B)
              return A.error("Numeric branch labels must be integer values.");
            if (l) {
              if (A.checkSubtype(l, kn(B)))
                return null;
            } else
              l = kn(B);
            if (y[String(B)] !== void 0)
              return A.error("Branch labels must be unique.");
            y[String(B)] = v.length;
          }
          var j = i.parse(C, x, p);
          if (!j)
            return null;
          p = p || j.type, v.push(j);
        }
        var Q = i.parse(r[1], 1, Ee);
        if (!Q)
          return null;
        var te = i.parse(r[r.length - 1], r.length - 1, p);
        return te ? Q.type.kind !== "value" && i.concat(1).checkSubtype(l, Q.type) ? null : new sl(l, p, Q, y, v, te) : null;
      }, sl.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r);
        return (kn(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(r);
      }, sl.prototype.eachChild = function(r) {
        r(this.input), this.outputs.forEach(r), r(this.otherwise);
      }, sl.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        }) && this.otherwise.outputDefined();
      }, sl.prototype.serialize = function() {
        for (var r = this, i = ["match", this.input.serialize()], l = [], p = {}, y = 0, v = Object.keys(this.cases).sort(); y < v.length; y += 1) {
          var x = v[y];
          (D = p[this.cases[x]]) === void 0 ? (p[this.cases[x]] = l.length, l.push([this.cases[x], [x]])) : l[D][1].push(x);
        }
        for (var S = function(j) {
          return r.inputType.kind === "number" ? Number(j) : j;
        }, C = 0, A = l; C < A.length; C += 1) {
          var L = A[C], D = L[0], B = L[1];
          i.push(B.length === 1 ? S(B[0]) : B.map(S)), i.push(this.outputs[outputIndex$1].serialize());
        }
        return i.push(this.otherwise.serialize()), i;
      };
      var ll = function(r, i, l) {
        this.type = r, this.branches = i, this.otherwise = l;
      };
      ll.parse = function(r, i) {
        if (r.length < 4)
          return i.error("Expected at least 3 arguments, but found only " + (r.length - 1) + ".");
        if (r.length % 2 != 0)
          return i.error("Expected an odd number of arguments.");
        var l;
        i.expectedType && i.expectedType.kind !== "value" && (l = i.expectedType);
        for (var p = [], y = 1; y < r.length - 1; y += 2) {
          var v = i.parse(r[y], y, st);
          if (!v)
            return null;
          var x = i.parse(r[y + 1], y + 1, l);
          if (!x)
            return null;
          p.push([v, x]), l = l || x.type;
        }
        var S = i.parse(r[r.length - 1], r.length - 1, l);
        return S ? new ll(l, p, S) : null;
      }, ll.prototype.evaluate = function(r) {
        for (var i = 0, l = this.branches; i < l.length; i += 1) {
          var p = l[i], y = p[1];
          if (p[0].evaluate(r))
            return y.evaluate(r);
        }
        return this.otherwise.evaluate(r);
      }, ll.prototype.eachChild = function(r) {
        for (var i = 0, l = this.branches; i < l.length; i += 1) {
          var p = l[i], y = p[1];
          r(p[0]), r(y);
        }
        r(this.otherwise);
      }, ll.prototype.outputDefined = function() {
        return this.branches.every(function(r) {
          return r[1].outputDefined();
        }) && this.otherwise.outputDefined();
      }, ll.prototype.serialize = function() {
        var r = ["case"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var _s = function(r, i, l, p) {
        this.type = r, this.input = i, this.beginIndex = l, this.endIndex = p;
      };
      function pm(r, i) {
        return r === "==" || r === "!=" ? i.kind === "boolean" || i.kind === "string" || i.kind === "number" || i.kind === "null" || i.kind === "value" : i.kind === "string" || i.kind === "number" || i.kind === "value";
      }
      function dm(r, i, l, p) {
        return p.compare(i, l) === 0;
      }
      function Zr(r, i, l) {
        var p = r !== "==" && r !== "!=";
        return function() {
          function y(v, x, S) {
            this.type = st, this.lhs = v, this.rhs = x, this.collator = S, this.hasUntypedArgument = v.type.kind === "value" || x.type.kind === "value";
          }
          return y.parse = function(v, x) {
            if (v.length !== 3 && v.length !== 4)
              return x.error("Expected two or three arguments.");
            var S = v[0], C = x.parse(v[1], 1, Ee);
            if (!C)
              return null;
            if (!pm(S, C.type))
              return x.concat(1).error('"' + S + `" comparisons are not supported for type '` + Zt(C.type) + "'.");
            var A = x.parse(v[2], 2, Ee);
            if (!A)
              return null;
            if (!pm(S, A.type))
              return x.concat(2).error('"' + S + `" comparisons are not supported for type '` + Zt(A.type) + "'.");
            if (C.type.kind !== A.type.kind && C.type.kind !== "value" && A.type.kind !== "value")
              return x.error("Cannot compare types '" + Zt(C.type) + "' and '" + Zt(A.type) + "'.");
            p && (C.type.kind === "value" && A.type.kind !== "value" ? C = new dn(A.type, [C]) : C.type.kind !== "value" && A.type.kind === "value" && (A = new dn(C.type, [A])));
            var L = null;
            if (v.length === 4) {
              if (C.type.kind !== "string" && A.type.kind !== "string" && C.type.kind !== "value" && A.type.kind !== "value")
                return x.error("Cannot use collator to compare non-string types.");
              if (!(L = x.parse(v[3], 3, He)))
                return null;
            }
            return new y(C, A, L);
          }, y.prototype.evaluate = function(v) {
            var x = this.lhs.evaluate(v), S = this.rhs.evaluate(v);
            if (p && this.hasUntypedArgument) {
              var C = kn(x), A = kn(S);
              if (C.kind !== A.kind || C.kind !== "string" && C.kind !== "number")
                throw new mi('Expected arguments for "' + r + '" to be (string, string) or (number, number), but found (' + C.kind + ", " + A.kind + ") instead.");
            }
            if (this.collator && !p && this.hasUntypedArgument) {
              var L = kn(x), D = kn(S);
              if (L.kind !== "string" || D.kind !== "string")
                return i(v, x, S);
            }
            return this.collator ? l(v, x, S, this.collator.evaluate(v)) : i(v, x, S);
          }, y.prototype.eachChild = function(v) {
            v(this.lhs), v(this.rhs), this.collator && v(this.collator);
          }, y.prototype.outputDefined = function() {
            return !0;
          }, y.prototype.serialize = function() {
            var v = [r];
            return this.eachChild(function(x) {
              v.push(x.serialize());
            }), v;
          }, y;
        }();
      }
      _s.parse = function(r, i) {
        if (r.length <= 2 || r.length >= 5)
          return i.error("Expected 3 or 4 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Ee), p = i.parse(r[2], 2, Le);
        if (!l || !p)
          return null;
        if (!pn(l.type, [Jt(Ee), pt, Ee]))
          return i.error("Expected first argument to be of type array or string, but found " + Zt(l.type) + " instead");
        if (r.length === 4) {
          var y = i.parse(r[3], 3, Le);
          return y ? new _s(l.type, l, p, y) : null;
        }
        return new _s(l.type, l, p);
      }, _s.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r), l = this.beginIndex.evaluate(r);
        if (!Ur(i, ["string", "array"]))
          throw new mi("Expected first argument to be of type array or string, but found " + Zt(kn(i)) + " instead.");
        if (this.endIndex) {
          var p = this.endIndex.evaluate(r);
          return i.slice(l, p);
        }
        return i.slice(l);
      }, _s.prototype.eachChild = function(r) {
        r(this.input), r(this.beginIndex), this.endIndex && r(this.endIndex);
      }, _s.prototype.outputDefined = function() {
        return !1;
      }, _s.prototype.serialize = function() {
        if (this.endIndex != null && this.endIndex !== void 0) {
          var r = this.endIndex.serialize();
          return ["slice", this.input.serialize(), this.beginIndex.serialize(), r];
        }
        return ["slice", this.input.serialize(), this.beginIndex.serialize()];
      };
      var Gv = Zr("==", function(r, i, l) {
        return i === l;
      }, dm), lh = Zr("!=", function(r, i, l) {
        return i !== l;
      }, function(r, i, l, p) {
        return !dm(0, i, l, p);
      }), mm = Zr("<", function(r, i, l) {
        return i < l;
      }, function(r, i, l, p) {
        return p.compare(i, l) < 0;
      }), ym = Zr(">", function(r, i, l) {
        return i > l;
      }, function(r, i, l, p) {
        return p.compare(i, l) > 0;
      }), gm = Zr("<=", function(r, i, l) {
        return i <= l;
      }, function(r, i, l, p) {
        return p.compare(i, l) <= 0;
      }), vm = Zr(">=", function(r, i, l) {
        return i >= l;
      }, function(r, i, l, p) {
        return p.compare(i, l) >= 0;
      }), ul = function(r, i, l, p, y) {
        this.type = pt, this.number = r, this.locale = i, this.currency = l, this.minFractionDigits = p, this.maxFractionDigits = y;
      };
      ul.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected two arguments.");
        var l = i.parse(r[1], 1, Le);
        if (!l)
          return null;
        var p = r[2];
        if (typeof p != "object" || Array.isArray(p))
          return i.error("NumberFormat options argument must be an object.");
        var y = null;
        if (p.locale && !(y = i.parse(p.locale, 1, pt)))
          return null;
        var v = null;
        if (p.currency && !(v = i.parse(p.currency, 1, pt)))
          return null;
        var x = null;
        if (p["min-fraction-digits"] && !(x = i.parse(p["min-fraction-digits"], 1, Le)))
          return null;
        var S = null;
        return p["max-fraction-digits"] && !(S = i.parse(p["max-fraction-digits"], 1, Le)) ? null : new ul(l, y, v, x, S);
      }, ul.prototype.evaluate = function(r) {
        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(r) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(r) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(r) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(r) : void 0 }).format(this.number.evaluate(r));
      }, ul.prototype.eachChild = function(r) {
        r(this.number), this.locale && r(this.locale), this.currency && r(this.currency), this.minFractionDigits && r(this.minFractionDigits), this.maxFractionDigits && r(this.maxFractionDigits);
      }, ul.prototype.outputDefined = function() {
        return !1;
      }, ul.prototype.serialize = function() {
        var r = {};
        return this.locale && (r.locale = this.locale.serialize()), this.currency && (r.currency = this.currency.serialize()), this.minFractionDigits && (r["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (r["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), r];
      };
      var xs = function(r) {
        this.type = Le, this.input = r;
      };
      xs.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected 1 argument, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1);
        return l ? l.type.kind !== "array" && l.type.kind !== "string" && l.type.kind !== "value" ? i.error("Expected argument of type string or array, but found " + Zt(l.type) + " instead.") : new xs(l) : null;
      }, xs.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r);
        if (typeof i == "string" || Array.isArray(i))
          return i.length;
        throw new mi("Expected value to be of type string or array, but found " + Zt(kn(i)) + " instead.");
      }, xs.prototype.eachChild = function(r) {
        r(this.input);
      }, xs.prototype.outputDefined = function() {
        return !1;
      }, xs.prototype.serialize = function() {
        var r = ["length"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var cl = { "==": Gv, "!=": lh, ">": ym, "<": mm, ">=": vm, "<=": gm, array: dn, at: ol, boolean: dn, case: ll, coalesce: ys, collator: _a, format: ia, image: To, in: al, "index-of": vs, interpolate: Si, "interpolate-hcl": Si, "interpolate-lab": Si, length: xs, let: gs, literal: Vi, match: sl, number: dn, "number-format": ul, object: dn, slice: _s, step: lo, string: dn, "to-boolean": Go, "to-color": Go, "to-number": Go, "to-string": Go, var: ds, within: qo };
      function _m(r, i) {
        var l = i[0], p = i[1], y = i[2], v = i[3];
        l = l.evaluate(r), p = p.evaluate(r), y = y.evaluate(r);
        var x = v ? v.evaluate(r) : 1, S = qf(l, p, y, x);
        if (S)
          throw new mi(S);
        return new Fr(l / 255 * x, p / 255 * x, y / 255 * x, x);
      }
      function xm(r, i) {
        return r in i;
      }
      function Jf(r, i) {
        var l = i[r];
        return l === void 0 ? null : l;
      }
      function hl(r) {
        return { type: r };
      }
      function bm(r) {
        return { result: "success", value: r };
      }
      function fl(r) {
        return { result: "error", value: r };
      }
      function pl(r) {
        return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven";
      }
      function wm(r) {
        return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
      }
      function Yu(r) {
        return !!r.expression && r.expression.interpolated;
      }
      function Qr(r) {
        return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
      }
      function uh(r) {
        return typeof r == "object" && r !== null && !Array.isArray(r);
      }
      function qv(r) {
        return r;
      }
      function Xl(r, i, l) {
        return r !== void 0 ? r : i !== void 0 ? i : l !== void 0 ? l : void 0;
      }
      function Em(r, i, l, p, y) {
        return Xl(typeof l === y ? p[l] : void 0, r.default, i.default);
      }
      function $v(r, i, l) {
        if (Qr(l) !== "number")
          return Xl(r.default, i.default);
        var p = r.stops.length;
        if (p === 1 || l <= r.stops[0][0])
          return r.stops[0][1];
        if (l >= r.stops[p - 1][0])
          return r.stops[p - 1][1];
        var y = sh(r.stops.map(function(v) {
          return v[0];
        }), l);
        return r.stops[y][1];
      }
      function Sm(r, i, l) {
        var p = r.base !== void 0 ? r.base : 1;
        if (Qr(l) !== "number")
          return Xl(r.default, i.default);
        var y = r.stops.length;
        if (y === 1 || l <= r.stops[0][0])
          return r.stops[0][1];
        if (l >= r.stops[y - 1][0])
          return r.stops[y - 1][1];
        var v = sh(r.stops.map(function(D) {
          return D[0];
        }), l), x = function(D, B, j, Q) {
          var te = Q - j, ce = D - j;
          return te === 0 ? 0 : B === 1 ? ce / te : (Math.pow(B, ce) - 1) / (Math.pow(B, te) - 1);
        }(l, p, r.stops[v][0], r.stops[v + 1][0]), S = r.stops[v][1], C = r.stops[v + 1][1], A = Zl[i.type] || qv;
        if (r.colorSpace && r.colorSpace !== "rgb") {
          var L = fm[r.colorSpace];
          A = function(D, B) {
            return L.reverse(L.interpolate(L.forward(D), L.forward(B), x));
          };
        }
        return typeof S.evaluate == "function" ? { evaluate: function() {
          for (var D = [], B = arguments.length; B--; )
            D[B] = arguments[B];
          var j = S.evaluate.apply(void 0, D), Q = C.evaluate.apply(void 0, D);
          if (j !== void 0 && Q !== void 0)
            return A(j, Q, x);
        } } : A(S, C, x);
      }
      function ch(r, i, l) {
        return i.type === "color" ? l = Fr.parse(l) : i.type === "formatted" ? l = di.fromString(l.toString()) : i.type === "resolvedImage" ? l = Ji.fromString(l.toString()) : Qr(l) === i.type || i.type === "enum" && i.values[l] || (l = void 0), Xl(l, r.default, i.default);
      }
      Ei.register(cl, { error: [{ kind: "error" }, [pt], function(r, i) {
        throw new mi(i[0].evaluate(r));
      }], typeof: [pt, [Ee], function(r, i) {
        return Zt(kn(i[0].evaluate(r)));
      }], "to-rgba": [Jt(Le, 4), [De], function(r, i) {
        return i[0].evaluate(r).toArray();
      }], rgb: [De, [Le, Le, Le], _m], rgba: [De, [Le, Le, Le, Le], _m], has: { type: st, overloads: [[[pt], function(r, i) {
        return xm(i[0].evaluate(r), r.properties());
      }], [[pt, he], function(r, i) {
        var l = i[1];
        return xm(i[0].evaluate(r), l.evaluate(r));
      }]] }, get: { type: Ee, overloads: [[[pt], function(r, i) {
        return Jf(i[0].evaluate(r), r.properties());
      }], [[pt, he], function(r, i) {
        var l = i[1];
        return Jf(i[0].evaluate(r), l.evaluate(r));
      }]] }, "feature-state": [Ee, [pt], function(r, i) {
        return Jf(i[0].evaluate(r), r.featureState || {});
      }], properties: [he, [], function(r) {
        return r.properties();
      }], "geometry-type": [pt, [], function(r) {
        return r.geometryType();
      }], id: [Ee, [], function(r) {
        return r.id();
      }], zoom: [Le, [], function(r) {
        return r.globals.zoom;
      }], "heatmap-density": [Le, [], function(r) {
        return r.globals.heatmapDensity || 0;
      }], "line-progress": [Le, [], function(r) {
        return r.globals.lineProgress || 0;
      }], accumulated: [Ee, [], function(r) {
        return r.globals.accumulated === void 0 ? null : r.globals.accumulated;
      }], "+": [Le, hl(Le), function(r, i) {
        for (var l = 0, p = 0, y = i; p < y.length; p += 1)
          l += y[p].evaluate(r);
        return l;
      }], "*": [Le, hl(Le), function(r, i) {
        for (var l = 1, p = 0, y = i; p < y.length; p += 1)
          l *= y[p].evaluate(r);
        return l;
      }], "-": { type: Le, overloads: [[[Le, Le], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) - l.evaluate(r);
      }], [[Le], function(r, i) {
        return -i[0].evaluate(r);
      }]] }, "/": [Le, [Le, Le], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) / l.evaluate(r);
      }], "%": [Le, [Le, Le], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) % l.evaluate(r);
      }], ln2: [Le, [], function() {
        return Math.LN2;
      }], pi: [Le, [], function() {
        return Math.PI;
      }], e: [Le, [], function() {
        return Math.E;
      }], "^": [Le, [Le, Le], function(r, i) {
        var l = i[1];
        return Math.pow(i[0].evaluate(r), l.evaluate(r));
      }], sqrt: [Le, [Le], function(r, i) {
        return Math.sqrt(i[0].evaluate(r));
      }], log10: [Le, [Le], function(r, i) {
        return Math.log(i[0].evaluate(r)) / Math.LN10;
      }], ln: [Le, [Le], function(r, i) {
        return Math.log(i[0].evaluate(r));
      }], log2: [Le, [Le], function(r, i) {
        return Math.log(i[0].evaluate(r)) / Math.LN2;
      }], sin: [Le, [Le], function(r, i) {
        return Math.sin(i[0].evaluate(r));
      }], cos: [Le, [Le], function(r, i) {
        return Math.cos(i[0].evaluate(r));
      }], tan: [Le, [Le], function(r, i) {
        return Math.tan(i[0].evaluate(r));
      }], asin: [Le, [Le], function(r, i) {
        return Math.asin(i[0].evaluate(r));
      }], acos: [Le, [Le], function(r, i) {
        return Math.acos(i[0].evaluate(r));
      }], atan: [Le, [Le], function(r, i) {
        return Math.atan(i[0].evaluate(r));
      }], min: [Le, hl(Le), function(r, i) {
        return Math.min.apply(Math, i.map(function(l) {
          return l.evaluate(r);
        }));
      }], max: [Le, hl(Le), function(r, i) {
        return Math.max.apply(Math, i.map(function(l) {
          return l.evaluate(r);
        }));
      }], abs: [Le, [Le], function(r, i) {
        return Math.abs(i[0].evaluate(r));
      }], round: [Le, [Le], function(r, i) {
        var l = i[0].evaluate(r);
        return l < 0 ? -Math.round(-l) : Math.round(l);
      }], floor: [Le, [Le], function(r, i) {
        return Math.floor(i[0].evaluate(r));
      }], ceil: [Le, [Le], function(r, i) {
        return Math.ceil(i[0].evaluate(r));
      }], "filter-==": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1];
        return r.properties()[l.value] === p.value;
      }], "filter-id-==": [st, [Ee], function(r, i) {
        var l = i[0];
        return r.id() === l.value;
      }], "filter-type-==": [st, [pt], function(r, i) {
        var l = i[0];
        return r.geometryType() === l.value;
      }], "filter-<": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y < v;
      }], "filter-id-<": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p < y;
      }], "filter->": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y > v;
      }], "filter-id->": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p > y;
      }], "filter-<=": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y <= v;
      }], "filter-id-<=": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p <= y;
      }], "filter->=": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y >= v;
      }], "filter-id->=": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p >= y;
      }], "filter-has": [st, [Ee], function(r, i) {
        return i[0].value in r.properties();
      }], "filter-has-id": [st, [], function(r) {
        return r.id() !== null && r.id() !== void 0;
      }], "filter-type-in": [st, [Jt(pt)], function(r, i) {
        return i[0].value.indexOf(r.geometryType()) >= 0;
      }], "filter-id-in": [st, [Jt(Ee)], function(r, i) {
        return i[0].value.indexOf(r.id()) >= 0;
      }], "filter-in-small": [st, [pt, Jt(Ee)], function(r, i) {
        var l = i[0];
        return i[1].value.indexOf(r.properties()[l.value]) >= 0;
      }], "filter-in-large": [st, [pt, Jt(Ee)], function(r, i) {
        var l = i[0], p = i[1];
        return function(y, v, x, S) {
          for (; x <= S; ) {
            var C = x + S >> 1;
            if (v[C] === y)
              return !0;
            v[C] > y ? S = C - 1 : x = C + 1;
          }
          return !1;
        }(r.properties()[l.value], p.value, 0, p.value.length - 1);
      }], all: { type: st, overloads: [[[st, st], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) && l.evaluate(r);
      }], [hl(st), function(r, i) {
        for (var l = 0, p = i; l < p.length; l += 1)
          if (!p[l].evaluate(r))
            return !1;
        return !0;
      }]] }, any: { type: st, overloads: [[[st, st], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) || l.evaluate(r);
      }], [hl(st), function(r, i) {
        for (var l = 0, p = i; l < p.length; l += 1)
          if (p[l].evaluate(r))
            return !0;
        return !1;
      }]] }, "!": [st, [st], function(r, i) {
        return !i[0].evaluate(r);
      }], "is-supported-script": [st, [pt], function(r, i) {
        var l = r.globals && r.globals.isSupportedScript;
        return !l || l(i[0].evaluate(r));
      }], upcase: [pt, [pt], function(r, i) {
        return i[0].evaluate(r).toUpperCase();
      }], downcase: [pt, [pt], function(r, i) {
        return i[0].evaluate(r).toLowerCase();
      }], concat: [pt, hl(Ee), function(r, i) {
        return i.map(function(l) {
          return Hu(l.evaluate(r));
        }).join("");
      }], "resolved-locale": [pt, [He], function(r, i) {
        return i[0].evaluate(r).resolvedLocale();
      }] });
      var Kl = function(r, i) {
        this.expression = r, this._warningHistory = {}, this._evaluator = new Va(), this._defaultValue = i ? function(l) {
          return l.type === "color" && uh(l.default) ? new Fr(0, 0, 0, 0) : l.type === "color" ? Fr.parse(l.default) || null : l.default === void 0 ? null : l.default;
        }(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null;
      };
      function Ju(r) {
        return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in cl;
      }
      function hh(r, i) {
        var l = new ms(cl, [], i ? function(y) {
          var v = { color: De, string: pt, number: Le, enum: pt, boolean: st, formatted: jt, resolvedImage: Wt };
          return y.type === "array" ? Jt(v[y.value] || Ee, y.length) : v[y.type];
        }(i) : void 0), p = l.parse(r, void 0, void 0, void 0, i && i.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return p ? bm(new Kl(p, i)) : fl(l.errors);
      }
      Kl.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._evaluator.globals = r, this._evaluator.feature = i, this._evaluator.featureState = l, this._evaluator.canonical = p, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = v, this.expression.evaluate(this._evaluator);
      }, Kl.prototype.evaluate = function(r, i, l, p, y, v) {
        this._evaluator.globals = r, this._evaluator.feature = i || null, this._evaluator.featureState = l || null, this._evaluator.canonical = p, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = v || null;
        try {
          var x = this.expression.evaluate(this._evaluator);
          if (x == null || typeof x == "number" && x != x)
            return this._defaultValue;
          if (this._enumValues && !(x in this._enumValues))
            throw new mi("Expected value to be one of " + Object.keys(this._enumValues).map(function(S) {
              return JSON.stringify(S);
            }).join(", ") + ", but found " + JSON.stringify(x) + " instead.");
          return x;
        } catch (S) {
          return this._warningHistory[S.message] || (this._warningHistory[S.message] = !0, typeof console < "u" && console.warn(S.message)), this._defaultValue;
        }
      };
      var Qu = function(r, i) {
        this.kind = r, this._styleExpression = i, this.isStateDependent = r !== "constant" && !ps(i.expression);
      };
      Qu.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluateWithoutErrorHandling(r, i, l, p, y, v);
      }, Qu.prototype.evaluate = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluate(r, i, l, p, y, v);
      };
      var Yl = function(r, i, l, p) {
        this.kind = r, this.zoomStops = l, this._styleExpression = i, this.isStateDependent = r !== "camera" && !ps(i.expression), this.interpolationType = p;
      };
      function Tm(r, i) {
        if ((r = hh(r, i)).result === "error")
          return r;
        var l = r.value.expression, p = fs(l);
        if (!p && !pl(i))
          return fl([new Ue("", "data expressions not supported")]);
        var y = il(l, ["zoom"]);
        if (!y && !wm(i))
          return fl([new Ue("", "zoom expressions not supported")]);
        var v = function x(S) {
          var C = null;
          if (S instanceof gs)
            C = x(S.result);
          else if (S instanceof ys)
            for (var A = 0, L = S.args; A < L.length && !(C = x(L[A])); A += 1)
              ;
          else
            (S instanceof lo || S instanceof Si) && S.input instanceof Ei && S.input.name === "zoom" && (C = S);
          return C instanceof Ue || S.eachChild(function(D) {
            var B = x(D);
            B instanceof Ue ? C = B : !C && B ? C = new Ue("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : C && B && C !== B && (C = new Ue("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), C;
        }(l);
        return v || y ? v instanceof Ue ? fl([v]) : v instanceof Si && !Yu(i) ? fl([new Ue("", '"interpolate" expressions cannot be used with this property')]) : bm(v ? new Yl(p ? "camera" : "composite", r.value, v.labels, v instanceof Si ? v.interpolation : void 0) : new Qu(p ? "constant" : "source", r.value)) : fl([new Ue("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      Yl.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluateWithoutErrorHandling(r, i, l, p, y, v);
      }, Yl.prototype.evaluate = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluate(r, i, l, p, y, v);
      }, Yl.prototype.interpolationFactor = function(r, i, l) {
        return this.interpolationType ? Si.interpolationFactor(this.interpolationType, r, i, l) : 0;
      };
      var Jl = function(r, i) {
        this._parameters = r, this._specification = i, Ge(this, function l(p, y) {
          var v, x, S, C = y.type === "color", A = p.stops && typeof p.stops[0][0] == "object", L = A || !(A || p.property !== void 0), D = p.type || (Yu(y) ? "exponential" : "interval");
          if (C && ((p = Ge({}, p)).stops && (p.stops = p.stops.map(function(dt) {
            return [dt[0], Fr.parse(dt[1])];
          })), p.default = Fr.parse(p.default ? p.default : y.default)), p.colorSpace && p.colorSpace !== "rgb" && !fm[p.colorSpace])
            throw new Error("Unknown color space: " + p.colorSpace);
          if (D === "exponential")
            v = Sm;
          else if (D === "interval")
            v = $v;
          else if (D === "categorical") {
            v = Em, x = /* @__PURE__ */ Object.create(null);
            for (var B = 0, j = p.stops; B < j.length; B += 1) {
              var Q = j[B];
              x[Q[0]] = Q[1];
            }
            S = typeof p.stops[0][0];
          } else {
            if (D !== "identity")
              throw new Error('Unknown function type "' + D + '"');
            v = ch;
          }
          if (A) {
            for (var te = {}, ce = [], oe = 0; oe < p.stops.length; oe++) {
              var ge = p.stops[oe], we = ge[0].zoom;
              te[we] === void 0 && (te[we] = { zoom: we, type: p.type, property: p.property, default: p.default, stops: [] }, ce.push(we)), te[we].stops.push([ge[0].value, ge[1]]);
            }
            for (var Te = [], Oe = 0, Be = ce; Oe < Be.length; Oe += 1) {
              var Xe = Be[Oe];
              Te.push([te[Xe].zoom, l(te[Xe], y)]);
            }
            var ot = { name: "linear" };
            return { kind: "composite", interpolationType: ot, interpolationFactor: Si.interpolationFactor.bind(void 0, ot), zoomStops: Te.map(function(dt) {
              return dt[0];
            }), evaluate: function(dt, Nt) {
              var yt = dt.zoom;
              return Sm({ stops: Te, base: p.base }, y, yt).evaluate(yt, Nt);
            } };
          }
          if (L) {
            var At = D === "exponential" ? { name: "exponential", base: p.base !== void 0 ? p.base : 1 } : null;
            return { kind: "camera", interpolationType: At, interpolationFactor: Si.interpolationFactor.bind(void 0, At), zoomStops: p.stops.map(function(dt) {
              return dt[0];
            }), evaluate: function(dt) {
              return v(p, y, dt.zoom, x, S);
            } };
          }
          return { kind: "source", evaluate: function(dt, Nt) {
            var yt = Nt && Nt.properties ? Nt.properties[p.property] : void 0;
            return yt === void 0 ? Xl(p.default, y.default) : v(p, y, yt, x, S);
          } };
        }(this._parameters, this._specification));
      };
      function oa(r) {
        var i = r.key, l = r.value, p = r.valueSpec || {}, y = r.objectElementValidators || {}, v = r.style, x = r.styleSpec, S = [], C = Qr(l);
        if (C !== "object")
          return [new ie(i, l, "object expected, " + C + " found")];
        for (var A in l) {
          var L = A.split(".")[0], D = p[L] || p["*"], B = void 0;
          if (y[L])
            B = y[L];
          else if (p[L])
            B = xr;
          else if (y["*"])
            B = y["*"];
          else {
            if (!p["*"]) {
              S.push(new ie(i, l[A], 'unknown property "' + A + '"'));
              continue;
            }
            B = xr;
          }
          S = S.concat(B({ key: (i && i + ".") + A, value: l[A], valueSpec: D, style: v, styleSpec: x, object: l, objectKey: A }, l));
        }
        for (var j in p)
          y[j] || p[j].required && p[j].default === void 0 && l[j] === void 0 && S.push(new ie(i, l, 'missing required property "' + j + '"'));
        return S;
      }
      function Mm(r) {
        var i = r.value, l = r.valueSpec, p = r.style, y = r.styleSpec, v = r.key, x = r.arrayElementValidator || xr;
        if (Qr(i) !== "array")
          return [new ie(v, i, "array expected, " + Qr(i) + " found")];
        if (l.length && i.length !== l.length)
          return [new ie(v, i, "array length " + l.length + " expected, length " + i.length + " found")];
        if (l["min-length"] && i.length < l["min-length"])
          return [new ie(v, i, "array length at least " + l["min-length"] + " expected, length " + i.length + " found")];
        var S = { type: l.value, values: l.values };
        y.$version < 7 && (S.function = l.function), Qr(l.value) === "object" && (S = l.value);
        for (var C = [], A = 0; A < i.length; A++)
          C = C.concat(x({ array: i, arrayIndex: A, value: i[A], valueSpec: S, style: p, styleSpec: y, key: v + "[" + A + "]" }));
        return C;
      }
      function Im(r) {
        var i = r.key, l = r.value, p = r.valueSpec, y = Qr(l);
        return y === "number" && l != l && (y = "NaN"), y !== "number" ? [new ie(i, l, "number expected, " + y + " found")] : "minimum" in p && l < p.minimum ? [new ie(i, l, l + " is less than the minimum value " + p.minimum)] : "maximum" in p && l > p.maximum ? [new ie(i, l, l + " is greater than the maximum value " + p.maximum)] : [];
      }
      function Om(r) {
        var i, l, p, y = r.valueSpec, v = Ze(r.value.type), x = {}, S = v !== "categorical" && r.value.property === void 0, C = !S, A = Qr(r.value.stops) === "array" && Qr(r.value.stops[0]) === "array" && Qr(r.value.stops[0][0]) === "object", L = oa({ key: r.key, value: r.value, valueSpec: r.styleSpec.function, style: r.style, styleSpec: r.styleSpec, objectElementValidators: { stops: function(j) {
          if (v === "identity")
            return [new ie(j.key, j.value, 'identity function may not have a "stops" property')];
          var Q = [], te = j.value;
          return Q = Q.concat(Mm({ key: j.key, value: te, valueSpec: j.valueSpec, style: j.style, styleSpec: j.styleSpec, arrayElementValidator: D })), Qr(te) === "array" && te.length === 0 && Q.push(new ie(j.key, te, "array must have at least one stop")), Q;
        }, default: function(j) {
          return xr({ key: j.key, value: j.value, valueSpec: y, style: j.style, styleSpec: j.styleSpec });
        } } });
        return v === "identity" && S && L.push(new ie(r.key, r.value, 'missing required property "property"')), v === "identity" || r.value.stops || L.push(new ie(r.key, r.value, 'missing required property "stops"')), v === "exponential" && r.valueSpec.expression && !Yu(r.valueSpec) && L.push(new ie(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (C && !pl(r.valueSpec) ? L.push(new ie(r.key, r.value, "property functions not supported")) : S && !wm(r.valueSpec) && L.push(new ie(r.key, r.value, "zoom functions not supported"))), v !== "categorical" && !A || r.value.property !== void 0 || L.push(new ie(r.key, r.value, '"property" property is required')), L;
        function D(j) {
          var Q = [], te = j.value, ce = j.key;
          if (Qr(te) !== "array")
            return [new ie(ce, te, "array expected, " + Qr(te) + " found")];
          if (te.length !== 2)
            return [new ie(ce, te, "array length 2 expected, length " + te.length + " found")];
          if (A) {
            if (Qr(te[0]) !== "object")
              return [new ie(ce, te, "object expected, " + Qr(te[0]) + " found")];
            if (te[0].zoom === void 0)
              return [new ie(ce, te, "object stop key must have zoom")];
            if (te[0].value === void 0)
              return [new ie(ce, te, "object stop key must have value")];
            if (p && p > Ze(te[0].zoom))
              return [new ie(ce, te[0].zoom, "stop zoom values must appear in ascending order")];
            Ze(te[0].zoom) !== p && (p = Ze(te[0].zoom), l = void 0, x = {}), Q = Q.concat(oa({ key: ce + "[0]", value: te[0], valueSpec: { zoom: {} }, style: j.style, styleSpec: j.styleSpec, objectElementValidators: { zoom: Im, value: B } }));
          } else
            Q = Q.concat(B({ key: ce + "[0]", value: te[0], valueSpec: {}, style: j.style, styleSpec: j.styleSpec }, te));
          return Ju(Ce(te[1])) ? Q.concat([new ie(ce + "[1]", te[1], "expressions are not allowed in function stops.")]) : Q.concat(xr({ key: ce + "[1]", value: te[1], valueSpec: y, style: j.style, styleSpec: j.styleSpec }));
        }
        function B(j, Q) {
          var te = Qr(j.value), ce = Ze(j.value), oe = j.value !== null ? j.value : Q;
          if (i) {
            if (te !== i)
              return [new ie(j.key, oe, te + " stop domain type must match previous stop domain type " + i)];
          } else
            i = te;
          if (te !== "number" && te !== "string" && te !== "boolean")
            return [new ie(j.key, oe, "stop domain value must be a number, string, or boolean")];
          if (te !== "number" && v !== "categorical") {
            var ge = "number expected, " + te + " found";
            return pl(y) && v === void 0 && (ge += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ie(j.key, oe, ge)];
          }
          return v !== "categorical" || te !== "number" || isFinite(ce) && Math.floor(ce) === ce ? v !== "categorical" && te === "number" && l !== void 0 && ce < l ? [new ie(j.key, oe, "stop domain values must appear in ascending order")] : (l = ce, v === "categorical" && ce in x ? [new ie(j.key, oe, "stop domain values must be unique")] : (x[ce] = !0, [])) : [new ie(j.key, oe, "integer expected, found " + ce)];
        }
      }
      function dl(r) {
        var i = (r.expressionContext === "property" ? Tm : hh)(Ce(r.value), r.valueSpec);
        if (i.result === "error")
          return i.value.map(function(p) {
            return new ie("" + r.key + p.key, r.value, p.message);
          });
        var l = i.value.expression || i.value._styleExpression.expression;
        if (r.expressionContext === "property" && r.propertyKey === "text-font" && !l.outputDefined())
          return [new ie(r.key, r.value, 'Invalid data expression for "' + r.propertyKey + '". Output values must be contained as literals within the expression.')];
        if (r.expressionContext === "property" && r.propertyType === "layout" && !ps(l))
          return [new ie(r.key, r.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (r.expressionContext === "filter" && !ps(l))
          return [new ie(r.key, r.value, '"feature-state" data expressions are not supported with filters.')];
        if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
          if (!il(l, ["zoom", "feature-state"]))
            return [new ie(r.key, r.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (r.expressionContext === "cluster-initial" && !fs(l))
            return [new ie(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function ec(r) {
        var i = r.key, l = r.value, p = r.valueSpec, y = [];
        return Array.isArray(p.values) ? p.values.indexOf(Ze(l)) === -1 && y.push(new ie(i, l, "expected one of [" + p.values.join(", ") + "], " + JSON.stringify(l) + " found")) : Object.keys(p.values).indexOf(Ze(l)) === -1 && y.push(new ie(i, l, "expected one of [" + Object.keys(p.values).join(", ") + "], " + JSON.stringify(l) + " found")), y;
      }
      function fh(r) {
        if (r === !0 || r === !1)
          return !0;
        if (!Array.isArray(r) || r.length === 0)
          return !1;
        switch (r[0]) {
          case "has":
            return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
          case "in":
            return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
          case "any":
          case "all":
            for (var i = 0, l = r.slice(1); i < l.length; i += 1) {
              var p = l[i];
              if (!fh(p) && typeof p != "boolean")
                return !1;
            }
            return !0;
          default:
            return !0;
        }
      }
      Jl.deserialize = function(r) {
        return new Jl(r._parameters, r._specification);
      }, Jl.serialize = function(r) {
        return { _parameters: r._parameters, _specification: r._specification };
      };
      var Qf = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function ph(r) {
        if (r == null)
          return { filter: function() {
            return !0;
          }, needGeometry: !1 };
        fh(r) || (r = dh(r));
        var i = hh(r, Qf);
        if (i.result === "error")
          throw new Error(i.value.map(function(l) {
            return l.key + ": " + l.message;
          }).join(", "));
        return { filter: function(l, p, y) {
          return i.value.evaluate(l, p, {}, y);
        }, needGeometry: function l(p) {
          if (!Array.isArray(p))
            return !1;
          if (p[0] === "within")
            return !0;
          for (var y = 1; y < p.length; y++)
            if (l(p[y]))
              return !0;
          return !1;
        }(r) };
      }
      function Wv(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function dh(r) {
        if (!r)
          return !0;
        var i, l = r[0];
        return r.length <= 1 ? l !== "any" : l === "==" ? ep(r[1], r[2], "==") : l === "!=" ? mh(ep(r[1], r[2], "==")) : l === "<" || l === ">" || l === "<=" || l === ">=" ? ep(r[1], r[2], l) : l === "any" ? (i = r.slice(1), ["any"].concat(i.map(dh))) : l === "all" ? ["all"].concat(r.slice(1).map(dh)) : l === "none" ? ["all"].concat(r.slice(1).map(dh).map(mh)) : l === "in" ? Cm(r[1], r.slice(2)) : l === "!in" ? mh(Cm(r[1], r.slice(2))) : l === "has" ? Am(r[1]) : l === "!has" ? mh(Am(r[1])) : l !== "within" || r;
      }
      function ep(r, i, l) {
        switch (r) {
          case "$type":
            return ["filter-type-" + l, i];
          case "$id":
            return ["filter-id-" + l, i];
          default:
            return ["filter-" + l, r, i];
        }
      }
      function Cm(r, i) {
        if (i.length === 0)
          return !1;
        switch (r) {
          case "$type":
            return ["filter-type-in", ["literal", i]];
          case "$id":
            return ["filter-id-in", ["literal", i]];
          default:
            return i.length > 200 && !i.some(function(l) {
              return typeof l != typeof i[0];
            }) ? ["filter-in-large", r, ["literal", i.sort(Wv)]] : ["filter-in-small", r, ["literal", i]];
        }
      }
      function Am(r) {
        switch (r) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", r];
        }
      }
      function mh(r) {
        return ["!", r];
      }
      function tp(r) {
        return fh(Ce(r.value)) ? dl(Ge({}, r, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : function i(l) {
          var p = l.value, y = l.key;
          if (Qr(p) !== "array")
            return [new ie(y, p, "array expected, " + Qr(p) + " found")];
          var v, x = l.styleSpec, S = [];
          if (p.length < 1)
            return [new ie(y, p, "filter array must have at least 1 element")];
          switch (S = S.concat(ec({ key: y + "[0]", value: p[0], valueSpec: x.filter_operator, style: l.style, styleSpec: l.styleSpec })), Ze(p[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              p.length >= 2 && Ze(p[1]) === "$type" && S.push(new ie(y, p, '"$type" cannot be use with operator "' + p[0] + '"'));
            case "==":
            case "!=":
              p.length !== 3 && S.push(new ie(y, p, 'filter array for operator "' + p[0] + '" must have 3 elements'));
            case "in":
            case "!in":
              p.length >= 2 && (v = Qr(p[1])) !== "string" && S.push(new ie(y + "[1]", p[1], "string expected, " + v + " found"));
              for (var C = 2; C < p.length; C++)
                v = Qr(p[C]), Ze(p[1]) === "$type" ? S = S.concat(ec({ key: y + "[" + C + "]", value: p[C], valueSpec: x.geometry_type, style: l.style, styleSpec: l.styleSpec })) : v !== "string" && v !== "number" && v !== "boolean" && S.push(new ie(y + "[" + C + "]", p[C], "string, number, or boolean expected, " + v + " found"));
              break;
            case "any":
            case "all":
            case "none":
              for (var A = 1; A < p.length; A++)
                S = S.concat(i({ key: y + "[" + A + "]", value: p[A], style: l.style, styleSpec: l.styleSpec }));
              break;
            case "has":
            case "!has":
              v = Qr(p[1]), p.length !== 2 ? S.push(new ie(y, p, 'filter array for "' + p[0] + '" operator must have 2 elements')) : v !== "string" && S.push(new ie(y + "[1]", p[1], "string expected, " + v + " found"));
              break;
            case "within":
              v = Qr(p[1]), p.length !== 2 ? S.push(new ie(y, p, 'filter array for "' + p[0] + '" operator must have 2 elements')) : v !== "object" && S.push(new ie(y + "[1]", p[1], "object expected, " + v + " found"));
          }
          return S;
        }(r);
      }
      function rp(r, i) {
        var l = r.key, p = r.style, y = r.styleSpec, v = r.value, x = r.objectKey, S = y[i + "_" + r.layerType];
        if (!S)
          return [];
        var C = x.match(/^(.*)-transition$/);
        if (i === "paint" && C && S[C[1]] && S[C[1]].transition)
          return xr({ key: l, value: v, valueSpec: y.transition, style: p, styleSpec: y });
        var A, L = r.valueSpec || S[x];
        if (!L)
          return [new ie(l, v, 'unknown property "' + x + '"')];
        if (Qr(v) === "string" && pl(L) && !L.tokens && (A = /^{([^}]+)}$/.exec(v)))
          return [new ie(l, v, '"' + x + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(A[1]) + " }`.")];
        var D = [];
        return r.layerType === "symbol" && (x === "text-field" && p && !p.glyphs && D.push(new ie(l, v, 'use of "text-field" requires a style "glyphs" property')), x === "text-font" && uh(Ce(v)) && Ze(v.type) === "identity" && D.push(new ie(l, v, '"text-font" does not support identity functions'))), D.concat(xr({ key: r.key, value: v, valueSpec: L, style: p, styleSpec: y, expressionContext: "property", propertyType: i, propertyKey: x }));
      }
      function np(r) {
        return rp(r, "paint");
      }
      function tc(r) {
        return rp(r, "layout");
      }
      function Pm(r) {
        var i = [], l = r.value, p = r.key, y = r.style, v = r.styleSpec;
        l.type || l.ref || i.push(new ie(p, l, 'either "type" or "ref" is required'));
        var x, S = Ze(l.type), C = Ze(l.ref);
        if (l.id)
          for (var A = Ze(l.id), L = 0; L < r.arrayIndex; L++) {
            var D = y.layers[L];
            Ze(D.id) === A && i.push(new ie(p, l.id, 'duplicate layer id "' + l.id + '", previously used at line ' + D.id.__line__));
          }
        if ("ref" in l)
          ["type", "source", "source-layer", "filter", "layout"].forEach(function(Q) {
            Q in l && i.push(new ie(p, l[Q], '"' + Q + '" is prohibited for ref layers'));
          }), y.layers.forEach(function(Q) {
            Ze(Q.id) === C && (x = Q);
          }), x ? x.ref ? i.push(new ie(p, l.ref, "ref cannot reference another ref layer")) : S = Ze(x.type) : i.push(new ie(p, l.ref, 'ref layer "' + C + '" not found'));
        else if (S !== "background")
          if (l.source) {
            var B = y.sources && y.sources[l.source], j = B && Ze(B.type);
            B ? j === "vector" && S === "raster" ? i.push(new ie(p, l.source, 'layer "' + l.id + '" requires a raster source')) : j === "raster" && S !== "raster" ? i.push(new ie(p, l.source, 'layer "' + l.id + '" requires a vector source')) : j !== "vector" || l["source-layer"] ? j === "raster-dem" && S !== "hillshade" ? i.push(new ie(p, l.source, "raster-dem source can only be used with layer type 'hillshade'.")) : S !== "line" || !l.paint || !l.paint["line-gradient"] || j === "geojson" && B.lineMetrics || i.push(new ie(p, l, 'layer "' + l.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : i.push(new ie(p, l, 'layer "' + l.id + '" must specify a "source-layer"')) : i.push(new ie(p, l.source, 'source "' + l.source + '" not found'));
          } else
            i.push(new ie(p, l, 'missing required property "source"'));
        return i = i.concat(oa({ key: p, value: l, valueSpec: v.layer, style: r.style, styleSpec: r.styleSpec, objectElementValidators: { "*": function() {
          return [];
        }, type: function() {
          return xr({ key: p + ".type", value: l.type, valueSpec: v.layer.type, style: r.style, styleSpec: r.styleSpec, object: l, objectKey: "type" });
        }, filter: tp, layout: function(Q) {
          return oa({ layer: l, key: Q.key, value: Q.value, style: Q.style, styleSpec: Q.styleSpec, objectElementValidators: { "*": function(te) {
            return tc(Ge({ layerType: S }, te));
          } } });
        }, paint: function(Q) {
          return oa({ layer: l, key: Q.key, value: Q.value, style: Q.style, styleSpec: Q.styleSpec, objectElementValidators: { "*": function(te) {
            return np(Ge({ layerType: S }, te));
          } } });
        } } }));
      }
      function ml(r) {
        var i = r.value, l = r.key, p = Qr(i);
        return p !== "string" ? [new ie(l, i, "string expected, " + p + " found")] : [];
      }
      var mn = { promoteId: function(r) {
        var i = r.key, l = r.value;
        if (Qr(l) === "string")
          return ml({ key: i, value: l });
        var p = [];
        for (var y in l)
          p.push.apply(p, ml({ key: i + "." + y, value: l[y] }));
        return p;
      } };
      function yh(r) {
        var i = r.value, l = r.key, p = r.styleSpec, y = r.style;
        if (!i.type)
          return [new ie(l, i, '"type" is required')];
        var v, x = Ze(i.type);
        switch (x) {
          case "vector":
          case "raster":
          case "raster-dem":
            return oa({ key: l, value: i, valueSpec: p["source_" + x.replace("-", "_")], style: r.style, styleSpec: p, objectElementValidators: mn });
          case "geojson":
            if (v = oa({ key: l, value: i, valueSpec: p.source_geojson, style: y, styleSpec: p, objectElementValidators: mn }), i.cluster)
              for (var S in i.clusterProperties) {
                var C = i.clusterProperties[S], A = C[0], L = typeof A == "string" ? [A, ["accumulated"], ["get", S]] : A;
                v.push.apply(v, dl({ key: l + "." + S + ".map", value: C[1], expressionContext: "cluster-map" })), v.push.apply(v, dl({ key: l + "." + S + ".reduce", value: L, expressionContext: "cluster-reduce" }));
              }
            return v;
          case "video":
            return oa({ key: l, value: i, valueSpec: p.source_video, style: y, styleSpec: p });
          case "image":
            return oa({ key: l, value: i, valueSpec: p.source_image, style: y, styleSpec: p });
          case "canvas":
            return [new ie(l, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return ec({ key: l + ".type", value: i.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: y, styleSpec: p });
        }
      }
      function yl(r) {
        var i = r.value, l = r.styleSpec, p = l.light, y = r.style, v = [], x = Qr(i);
        if (i === void 0)
          return v;
        if (x !== "object")
          return v.concat([new ie("light", i, "object expected, " + x + " found")]);
        for (var S in i) {
          var C = S.match(/^(.*)-transition$/);
          v = v.concat(C && p[C[1]] && p[C[1]].transition ? xr({ key: S, value: i[S], valueSpec: l.transition, style: y, styleSpec: l }) : p[S] ? xr({ key: S, value: i[S], valueSpec: p[S], style: y, styleSpec: l }) : [new ie(S, i[S], 'unknown property "' + S + '"')]);
        }
        return v;
      }
      var bs = { "*": function() {
        return [];
      }, array: Mm, boolean: function(r) {
        var i = r.value, l = r.key, p = Qr(i);
        return p !== "boolean" ? [new ie(l, i, "boolean expected, " + p + " found")] : [];
      }, number: Im, color: function(r) {
        var i = r.key, l = r.value, p = Qr(l);
        return p !== "string" ? [new ie(i, l, "color expected, " + p + " found")] : gr(l) === null ? [new ie(i, l, 'color expected, "' + l + '" found')] : [];
      }, constants: ve, enum: ec, filter: tp, function: Om, layer: Pm, object: oa, source: yh, light: yl, string: ml, formatted: function(r) {
        return ml(r).length === 0 ? [] : dl(r);
      }, resolvedImage: function(r) {
        return ml(r).length === 0 ? [] : dl(r);
      } };
      function xr(r) {
        var i = r.value, l = r.valueSpec, p = r.styleSpec;
        return l.expression && uh(Ze(i)) ? Om(r) : l.expression && Ju(Ce(i)) ? dl(r) : l.type && bs[l.type] ? bs[l.type](r) : oa(Ge({}, r, { valueSpec: l.type ? p[l.type] : l }));
      }
      function en(r) {
        var i = r.value, l = r.key, p = ml(r);
        return p.length || (i.indexOf("{fontstack}") === -1 && p.push(new ie(l, i, '"glyphs" url must include a "{fontstack}" token')), i.indexOf("{range}") === -1 && p.push(new ie(l, i, '"glyphs" url must include a "{range}" token'))), p;
      }
      function Mo(r, i) {
        i === void 0 && (i = G);
        var l = [];
        return l = l.concat(xr({ key: "", value: r, valueSpec: i.$root, styleSpec: i, style: r, objectElementValidators: { glyphs: en, "*": function() {
          return [];
        } } })), r.constants && (l = l.concat(ve({ key: "constants", value: r.constants, style: r, styleSpec: i }))), rc(l);
      }
      function rc(r) {
        return [].concat(r).sort(function(i, l) {
          return i.line - l.line;
        });
      }
      function Ql(r) {
        return function() {
          for (var i = [], l = arguments.length; l--; )
            i[l] = arguments[l];
          return rc(r.apply(this, i));
        };
      }
      Mo.source = Ql(yh), Mo.light = Ql(yl), Mo.layer = Ql(Pm), Mo.filter = Ql(tp), Mo.paintProperty = Ql(np), Mo.layoutProperty = Ql(tc);
      var nc = Mo, Hv = nc.light, Zv = nc.paintProperty, ic = nc.layoutProperty;
      function oc(r, i) {
        var l = !1;
        if (i && i.length)
          for (var p = 0, y = i; p < y.length; p += 1)
            r.fire(new fe(new Error(y[p].message))), l = !0;
        return l;
      }
      var Ua = Jn;
      function Jn(r, i, l) {
        var p = this.cells = [];
        if (r instanceof ArrayBuffer) {
          this.arrayBuffer = r;
          var y = new Int32Array(this.arrayBuffer);
          r = y[0], this.d = (i = y[1]) + 2 * (l = y[2]);
          for (var v = 0; v < this.d * this.d; v++) {
            var x = y[3 + v], S = y[3 + v + 1];
            p.push(x === S ? null : y.subarray(x, S));
          }
          var C = y[3 + p.length + 1];
          this.keys = y.subarray(y[3 + p.length], C), this.bboxes = y.subarray(C), this.insert = this._insertReadonly;
        } else {
          this.d = i + 2 * l;
          for (var A = 0; A < this.d * this.d; A++)
            p.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = i, this.extent = r, this.padding = l, this.scale = i / r, this.uid = 0;
        var L = l / i * r;
        this.min = -L, this.max = r + L;
      }
      Jn.prototype.insert = function(r, i, l, p, y) {
        this._forEachCell(i, l, p, y, this._insertCell, this.uid++), this.keys.push(r), this.bboxes.push(i), this.bboxes.push(l), this.bboxes.push(p), this.bboxes.push(y);
      }, Jn.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, Jn.prototype._insertCell = function(r, i, l, p, y, v) {
        this.cells[y].push(v);
      }, Jn.prototype.query = function(r, i, l, p, y) {
        var v = this.min, x = this.max;
        if (r <= v && i <= v && x <= l && x <= p && !y)
          return Array.prototype.slice.call(this.keys);
        var S = [];
        return this._forEachCell(r, i, l, p, this._queryCell, S, {}, y), S;
      }, Jn.prototype._queryCell = function(r, i, l, p, y, v, x, S) {
        var C = this.cells[y];
        if (C !== null)
          for (var A = this.keys, L = this.bboxes, D = 0; D < C.length; D++) {
            var B = C[D];
            if (x[B] === void 0) {
              var j = 4 * B;
              (S ? S(L[j + 0], L[j + 1], L[j + 2], L[j + 3]) : r <= L[j + 2] && i <= L[j + 3] && l >= L[j + 0] && p >= L[j + 1]) ? (x[B] = !0, v.push(A[B])) : x[B] = !1;
            }
          }
      }, Jn.prototype._forEachCell = function(r, i, l, p, y, v, x, S) {
        for (var C = this._convertToCellCoord(r), A = this._convertToCellCoord(i), L = this._convertToCellCoord(l), D = this._convertToCellCoord(p), B = C; B <= L; B++)
          for (var j = A; j <= D; j++) {
            var Q = this.d * j + B;
            if ((!S || S(this._convertFromCellCoord(B), this._convertFromCellCoord(j), this._convertFromCellCoord(B + 1), this._convertFromCellCoord(j + 1))) && y.call(this, r, i, l, p, Q, v, x, S))
              return;
          }
      }, Jn.prototype._convertFromCellCoord = function(r) {
        return (r - this.padding) / this.scale;
      }, Jn.prototype._convertToCellCoord = function(r) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(r * this.scale) + this.padding));
      }, Jn.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer)
          return this.arrayBuffer;
        for (var r = this.cells, i = 3 + this.cells.length + 1 + 1, l = 0, p = 0; p < this.cells.length; p++)
          l += this.cells[p].length;
        var y = new Int32Array(i + l + this.keys.length + this.bboxes.length);
        y[0] = this.extent, y[1] = this.n, y[2] = this.padding;
        for (var v = i, x = 0; x < r.length; x++) {
          var S = r[x];
          y[3 + x] = v, y.set(S, v), v += S.length;
        }
        return y[3 + r.length] = v, y.set(this.keys, v), y[3 + r.length + 1] = v += this.keys.length, y.set(this.bboxes, v), v += this.bboxes.length, y.buffer;
      };
      var ac = I.ImageData, km = I.ImageBitmap, Gn = {};
      function wt(r, i, l) {
        l === void 0 && (l = {}), Object.defineProperty(i, "_classRegistryKey", { value: r, writeable: !1 }), Gn[r] = { klass: i, omit: l.omit || [], shallow: l.shallow || [] };
      }
      for (var uo in wt("Object", Object), Ua.serialize = function(r, i) {
        var l = r.toArrayBuffer();
        return i && i.push(l), { buffer: l };
      }, Ua.deserialize = function(r) {
        return new Ua(r.buffer);
      }, wt("Grid", Ua), wt("Color", Fr), wt("Error", Error), wt("ResolvedImage", Ji), wt("StylePropertyFunction", Jl), wt("StyleExpression", Kl, { omit: ["_evaluator"] }), wt("ZoomDependentExpression", Yl), wt("ZoomConstantExpression", Qu), wt("CompoundExpression", Ei, { omit: ["_evaluate"] }), cl)
        cl[uo]._classRegistryKey || wt("Expression_" + uo, cl[uo]);
      function gh(r) {
        return r && typeof ArrayBuffer < "u" && (r instanceof ArrayBuffer || r.constructor && r.constructor.name === "ArrayBuffer");
      }
      function eu(r) {
        return km && r instanceof km;
      }
      function aa(r, i) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp)
          return r;
        if (gh(r) || eu(r))
          return i && i.push(r), r;
        if (ArrayBuffer.isView(r)) {
          var l = r;
          return i && i.push(l.buffer), l;
        }
        if (r instanceof ac)
          return i && i.push(r.data.buffer), r;
        if (Array.isArray(r)) {
          for (var p = [], y = 0, v = r; y < v.length; y += 1)
            p.push(aa(v[y], i));
          return p;
        }
        if (typeof r == "object") {
          var x = r.constructor, S = x._classRegistryKey;
          if (!S)
            throw new Error("can't serialize object of unregistered class");
          var C = x.serialize ? x.serialize(r, i) : {};
          if (!x.serialize) {
            for (var A in r)
              if (r.hasOwnProperty(A) && !(Gn[S].omit.indexOf(A) >= 0)) {
                var L = r[A];
                C[A] = Gn[S].shallow.indexOf(A) >= 0 ? L : aa(L, i);
              }
            r instanceof Error && (C.message = r.message);
          }
          if (C.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return S !== "Object" && (C.$name = S), C;
        }
        throw new Error("can't serialize object of type " + typeof r);
      }
      function co(r) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp || gh(r) || eu(r) || ArrayBuffer.isView(r) || r instanceof ac)
          return r;
        if (Array.isArray(r))
          return r.map(co);
        if (typeof r == "object") {
          var i = r.$name || "Object", l = Gn[i].klass;
          if (!l)
            throw new Error("can't deserialize unregistered class " + i);
          if (l.deserialize)
            return l.deserialize(r);
          for (var p = Object.create(l.prototype), y = 0, v = Object.keys(r); y < v.length; y += 1) {
            var x = v[y];
            if (x !== "$name") {
              var S = r[x];
              p[x] = Gn[i].shallow.indexOf(x) >= 0 ? S : co(S);
            }
          }
          return p;
        }
        throw new Error("can't deserialize object of type " + typeof r);
      }
      var ip = function() {
        this.first = !0;
      };
      ip.prototype.update = function(r, i) {
        var l = Math.floor(r);
        return this.first ? (this.first = !1, this.lastIntegerZoom = l, this.lastIntegerZoomTime = 0, this.lastZoom = r, this.lastFloorZoom = l, !0) : (this.lastFloorZoom > l ? (this.lastIntegerZoom = l + 1, this.lastIntegerZoomTime = i) : this.lastFloorZoom < l && (this.lastIntegerZoom = l, this.lastIntegerZoomTime = i), r !== this.lastZoom && (this.lastZoom = r, this.lastFloorZoom = l, !0));
      };
      var ct = { "Latin-1 Supplement": function(r) {
        return r >= 128 && r <= 255;
      }, Arabic: function(r) {
        return r >= 1536 && r <= 1791;
      }, "Arabic Supplement": function(r) {
        return r >= 1872 && r <= 1919;
      }, "Arabic Extended-A": function(r) {
        return r >= 2208 && r <= 2303;
      }, "Hangul Jamo": function(r) {
        return r >= 4352 && r <= 4607;
      }, "Unified Canadian Aboriginal Syllabics": function(r) {
        return r >= 5120 && r <= 5759;
      }, Khmer: function(r) {
        return r >= 6016 && r <= 6143;
      }, "Unified Canadian Aboriginal Syllabics Extended": function(r) {
        return r >= 6320 && r <= 6399;
      }, "General Punctuation": function(r) {
        return r >= 8192 && r <= 8303;
      }, "Letterlike Symbols": function(r) {
        return r >= 8448 && r <= 8527;
      }, "Number Forms": function(r) {
        return r >= 8528 && r <= 8591;
      }, "Miscellaneous Technical": function(r) {
        return r >= 8960 && r <= 9215;
      }, "Control Pictures": function(r) {
        return r >= 9216 && r <= 9279;
      }, "Optical Character Recognition": function(r) {
        return r >= 9280 && r <= 9311;
      }, "Enclosed Alphanumerics": function(r) {
        return r >= 9312 && r <= 9471;
      }, "Geometric Shapes": function(r) {
        return r >= 9632 && r <= 9727;
      }, "Miscellaneous Symbols": function(r) {
        return r >= 9728 && r <= 9983;
      }, "Miscellaneous Symbols and Arrows": function(r) {
        return r >= 11008 && r <= 11263;
      }, "CJK Radicals Supplement": function(r) {
        return r >= 11904 && r <= 12031;
      }, "Kangxi Radicals": function(r) {
        return r >= 12032 && r <= 12255;
      }, "Ideographic Description Characters": function(r) {
        return r >= 12272 && r <= 12287;
      }, "CJK Symbols and Punctuation": function(r) {
        return r >= 12288 && r <= 12351;
      }, Hiragana: function(r) {
        return r >= 12352 && r <= 12447;
      }, Katakana: function(r) {
        return r >= 12448 && r <= 12543;
      }, Bopomofo: function(r) {
        return r >= 12544 && r <= 12591;
      }, "Hangul Compatibility Jamo": function(r) {
        return r >= 12592 && r <= 12687;
      }, Kanbun: function(r) {
        return r >= 12688 && r <= 12703;
      }, "Bopomofo Extended": function(r) {
        return r >= 12704 && r <= 12735;
      }, "CJK Strokes": function(r) {
        return r >= 12736 && r <= 12783;
      }, "Katakana Phonetic Extensions": function(r) {
        return r >= 12784 && r <= 12799;
      }, "Enclosed CJK Letters and Months": function(r) {
        return r >= 12800 && r <= 13055;
      }, "CJK Compatibility": function(r) {
        return r >= 13056 && r <= 13311;
      }, "CJK Unified Ideographs Extension A": function(r) {
        return r >= 13312 && r <= 19903;
      }, "Yijing Hexagram Symbols": function(r) {
        return r >= 19904 && r <= 19967;
      }, "CJK Unified Ideographs": function(r) {
        return r >= 19968 && r <= 40959;
      }, "Yi Syllables": function(r) {
        return r >= 40960 && r <= 42127;
      }, "Yi Radicals": function(r) {
        return r >= 42128 && r <= 42191;
      }, "Hangul Jamo Extended-A": function(r) {
        return r >= 43360 && r <= 43391;
      }, "Hangul Syllables": function(r) {
        return r >= 44032 && r <= 55215;
      }, "Hangul Jamo Extended-B": function(r) {
        return r >= 55216 && r <= 55295;
      }, "Private Use Area": function(r) {
        return r >= 57344 && r <= 63743;
      }, "CJK Compatibility Ideographs": function(r) {
        return r >= 63744 && r <= 64255;
      }, "Arabic Presentation Forms-A": function(r) {
        return r >= 64336 && r <= 65023;
      }, "Vertical Forms": function(r) {
        return r >= 65040 && r <= 65055;
      }, "CJK Compatibility Forms": function(r) {
        return r >= 65072 && r <= 65103;
      }, "Small Form Variants": function(r) {
        return r >= 65104 && r <= 65135;
      }, "Arabic Presentation Forms-B": function(r) {
        return r >= 65136 && r <= 65279;
      }, "Halfwidth and Fullwidth Forms": function(r) {
        return r >= 65280 && r <= 65519;
      } };
      function op(r) {
        for (var i = 0, l = r; i < l.length; i += 1)
          if (vh(l[i].charCodeAt(0)))
            return !0;
        return !1;
      }
      function vh(r) {
        return !(r !== 746 && r !== 747 && (r < 4352 || !(ct["Bopomofo Extended"](r) || ct.Bopomofo(r) || ct["CJK Compatibility Forms"](r) && !(r >= 65097 && r <= 65103) || ct["CJK Compatibility Ideographs"](r) || ct["CJK Compatibility"](r) || ct["CJK Radicals Supplement"](r) || ct["CJK Strokes"](r) || !(!ct["CJK Symbols and Punctuation"](r) || r >= 12296 && r <= 12305 || r >= 12308 && r <= 12319 || r === 12336) || ct["CJK Unified Ideographs Extension A"](r) || ct["CJK Unified Ideographs"](r) || ct["Enclosed CJK Letters and Months"](r) || ct["Hangul Compatibility Jamo"](r) || ct["Hangul Jamo Extended-A"](r) || ct["Hangul Jamo Extended-B"](r) || ct["Hangul Jamo"](r) || ct["Hangul Syllables"](r) || ct.Hiragana(r) || ct["Ideographic Description Characters"](r) || ct.Kanbun(r) || ct["Kangxi Radicals"](r) || ct["Katakana Phonetic Extensions"](r) || ct.Katakana(r) && r !== 12540 || !(!ct["Halfwidth and Fullwidth Forms"](r) || r === 65288 || r === 65289 || r === 65293 || r >= 65306 && r <= 65310 || r === 65339 || r === 65341 || r === 65343 || r >= 65371 && r <= 65503 || r === 65507 || r >= 65512 && r <= 65519) || !(!ct["Small Form Variants"](r) || r >= 65112 && r <= 65118 || r >= 65123 && r <= 65126) || ct["Unified Canadian Aboriginal Syllabics"](r) || ct["Unified Canadian Aboriginal Syllabics Extended"](r) || ct["Vertical Forms"](r) || ct["Yijing Hexagram Symbols"](r) || ct["Yi Syllables"](r) || ct["Yi Radicals"](r))));
      }
      function ap(r) {
        return !(vh(r) || function(i) {
          return !!(ct["Latin-1 Supplement"](i) && (i === 167 || i === 169 || i === 174 || i === 177 || i === 188 || i === 189 || i === 190 || i === 215 || i === 247) || ct["General Punctuation"](i) && (i === 8214 || i === 8224 || i === 8225 || i === 8240 || i === 8241 || i === 8251 || i === 8252 || i === 8258 || i === 8263 || i === 8264 || i === 8265 || i === 8273) || ct["Letterlike Symbols"](i) || ct["Number Forms"](i) || ct["Miscellaneous Technical"](i) && (i >= 8960 && i <= 8967 || i >= 8972 && i <= 8991 || i >= 8996 && i <= 9e3 || i === 9003 || i >= 9085 && i <= 9114 || i >= 9150 && i <= 9165 || i === 9167 || i >= 9169 && i <= 9179 || i >= 9186 && i <= 9215) || ct["Control Pictures"](i) && i !== 9251 || ct["Optical Character Recognition"](i) || ct["Enclosed Alphanumerics"](i) || ct["Geometric Shapes"](i) || ct["Miscellaneous Symbols"](i) && !(i >= 9754 && i <= 9759) || ct["Miscellaneous Symbols and Arrows"](i) && (i >= 11026 && i <= 11055 || i >= 11088 && i <= 11097 || i >= 11192 && i <= 11243) || ct["CJK Symbols and Punctuation"](i) || ct.Katakana(i) || ct["Private Use Area"](i) || ct["CJK Compatibility Forms"](i) || ct["Small Form Variants"](i) || ct["Halfwidth and Fullwidth Forms"](i) || i === 8734 || i === 8756 || i === 8757 || i >= 9984 && i <= 10087 || i >= 10102 && i <= 10131 || i === 65532 || i === 65533);
        }(r));
      }
      function $o(r) {
        return r >= 1424 && r <= 2303 || ct["Arabic Presentation Forms-A"](r) || ct["Arabic Presentation Forms-B"](r);
      }
      function ho(r, i) {
        return !(!i && $o(r) || r >= 2304 && r <= 3583 || r >= 3840 && r <= 4255 || ct.Khmer(r));
      }
      function _h(r) {
        for (var i = 0, l = r; i < l.length; i += 1)
          if ($o(l[i].charCodeAt(0)))
            return !0;
        return !1;
      }
      var xh = null, fo = "unavailable", ja = null, Lm = function(r) {
        r && typeof r == "string" && r.indexOf("NetworkError") > -1 && (fo = "error"), xh && xh(r);
      };
      function sc() {
        sp.fire(new ee("pluginStateChange", { pluginStatus: fo, pluginURL: ja }));
      }
      var sp = new de(), lp = function() {
        return fo;
      }, sa = function() {
        if (fo !== "deferred" || !ja)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        fo = "loading", sc(), ja && rl({ url: ja }, function(r) {
          r ? Lm(r) : (fo = "loaded", sc());
        });
      }, Io = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function() {
        return fo === "loaded" || Io.applyArabicShaping != null;
      }, isLoading: function() {
        return fo === "loading";
      }, setState: function(r) {
        fo = r.pluginStatus, ja = r.pluginURL;
      }, isParsed: function() {
        return Io.applyArabicShaping != null && Io.processBidirectionalText != null && Io.processStyledBidirectionalText != null;
      }, getPluginURL: function() {
        return ja;
      } }, mr = function(r, i) {
        this.zoom = r, i ? (this.now = i.now, this.fadeDuration = i.fadeDuration, this.zoomHistory = i.zoomHistory, this.transition = i.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ip(), this.transition = {});
      };
      mr.prototype.isSupportedScript = function(r) {
        return function(i, l) {
          for (var p = 0, y = i; p < y.length; p += 1)
            if (!ho(y[p].charCodeAt(0), l))
              return !1;
          return !0;
        }(r, Io.isLoaded());
      }, mr.prototype.crossFadingFactor = function() {
        return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
      }, mr.prototype.getCrossfadeParameters = function() {
        var r = this.zoom, i = r - Math.floor(r), l = this.crossFadingFactor();
        return r > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: i + (1 - i) * l } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - l) * i };
      };
      var xa = function(r, i) {
        this.property = r, this.value = i, this.expression = function(l, p) {
          if (uh(l))
            return new Jl(l, p);
          if (Ju(l)) {
            var y = Tm(l, p);
            if (y.result === "error")
              throw new Error(y.value.map(function(x) {
                return x.key + ": " + x.message;
              }).join(", "));
            return y.value;
          }
          var v = l;
          return typeof l == "string" && p.type === "color" && (v = Fr.parse(l)), { kind: "constant", evaluate: function() {
            return v;
          } };
        }(i === void 0 ? r.specification.default : i, r.specification);
      };
      xa.prototype.isDataDriven = function() {
        return this.expression.kind === "source" || this.expression.kind === "composite";
      }, xa.prototype.possiblyEvaluate = function(r, i, l) {
        return this.property.possiblyEvaluate(this, r, i, l);
      };
      var Wo = function(r) {
        this.property = r, this.value = new xa(r, void 0);
      };
      Wo.prototype.transitioned = function(r, i) {
        return new gl(this.property, this.value, i, K({}, r.transition, this.transition), r.now);
      }, Wo.prototype.untransitioned = function() {
        return new gl(this.property, this.value, null, {}, 0);
      };
      var Ti = function(r) {
        this._properties = r, this._values = Object.create(r.defaultTransitionablePropertyValues);
      };
      Ti.prototype.getValue = function(r) {
        return Je(this._values[r].value.value);
      }, Ti.prototype.setValue = function(r, i) {
        this._values.hasOwnProperty(r) || (this._values[r] = new Wo(this._values[r].property)), this._values[r].value = new xa(this._values[r].property, i === null ? void 0 : Je(i));
      }, Ti.prototype.getTransition = function(r) {
        return Je(this._values[r].transition);
      }, Ti.prototype.setTransition = function(r, i) {
        this._values.hasOwnProperty(r) || (this._values[r] = new Wo(this._values[r].property)), this._values[r].transition = Je(i) || void 0;
      }, Ti.prototype.serialize = function() {
        for (var r = {}, i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i], y = this.getValue(p);
          y !== void 0 && (r[p] = y);
          var v = this.getTransition(p);
          v !== void 0 && (r[p + "-transition"] = v);
        }
        return r;
      }, Ti.prototype.transitioned = function(r, i) {
        for (var l = new ws(this._properties), p = 0, y = Object.keys(this._values); p < y.length; p += 1) {
          var v = y[p];
          l._values[v] = this._values[v].transitioned(r, i._values[v]);
        }
        return l;
      }, Ti.prototype.untransitioned = function() {
        for (var r = new ws(this._properties), i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i];
          r._values[p] = this._values[p].untransitioned();
        }
        return r;
      };
      var gl = function(r, i, l, p, y) {
        this.property = r, this.value = i, this.begin = y + p.delay || 0, this.end = this.begin + p.duration || 0, r.specification.transition && (p.delay || p.duration) && (this.prior = l);
      };
      gl.prototype.possiblyEvaluate = function(r, i, l) {
        var p = r.now || 0, y = this.value.possiblyEvaluate(r, i, l), v = this.prior;
        if (v) {
          if (p > this.end)
            return this.prior = null, y;
          if (this.value.isDataDriven())
            return this.prior = null, y;
          if (p < this.begin)
            return v.possiblyEvaluate(r, i, l);
          var x = (p - this.begin) / (this.end - this.begin);
          return this.property.interpolate(v.possiblyEvaluate(r, i, l), y, function(S) {
            if (S <= 0)
              return 0;
            if (S >= 1)
              return 1;
            var C = S * S, A = C * S;
            return 4 * (S < 0.5 ? A : 3 * (S - C) + A - 0.75);
          }(x));
        }
        return y;
      };
      var ws = function(r) {
        this._properties = r, this._values = Object.create(r.defaultTransitioningPropertyValues);
      };
      ws.prototype.possiblyEvaluate = function(r, i, l) {
        for (var p = new lc(this._properties), y = 0, v = Object.keys(this._values); y < v.length; y += 1) {
          var x = v[y];
          p._values[x] = this._values[x].possiblyEvaluate(r, i, l);
        }
        return p;
      }, ws.prototype.hasTransition = function() {
        for (var r = 0, i = Object.keys(this._values); r < i.length; r += 1)
          if (this._values[i[r]].prior)
            return !0;
        return !1;
      };
      var la = function(r) {
        this._properties = r, this._values = Object.create(r.defaultPropertyValues);
      };
      la.prototype.getValue = function(r) {
        return Je(this._values[r].value);
      }, la.prototype.setValue = function(r, i) {
        this._values[r] = new xa(this._values[r].property, i === null ? void 0 : Je(i));
      }, la.prototype.serialize = function() {
        for (var r = {}, i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i], y = this.getValue(p);
          y !== void 0 && (r[p] = y);
        }
        return r;
      }, la.prototype.possiblyEvaluate = function(r, i, l) {
        for (var p = new lc(this._properties), y = 0, v = Object.keys(this._values); y < v.length; y += 1) {
          var x = v[y];
          p._values[x] = this._values[x].possiblyEvaluate(r, i, l);
        }
        return p;
      };
      var ji = function(r, i, l) {
        this.property = r, this.value = i, this.parameters = l;
      };
      ji.prototype.isConstant = function() {
        return this.value.kind === "constant";
      }, ji.prototype.constantOr = function(r) {
        return this.value.kind === "constant" ? this.value.value : r;
      }, ji.prototype.evaluate = function(r, i, l, p) {
        return this.property.evaluate(this.value, this.parameters, r, i, l, p);
      };
      var lc = function(r) {
        this._properties = r, this._values = Object.create(r.defaultPossiblyEvaluatedValues);
      };
      lc.prototype.get = function(r) {
        return this._values[r];
      };
      var Lt = function(r) {
        this.specification = r;
      };
      Lt.prototype.possiblyEvaluate = function(r, i) {
        return r.expression.evaluate(i);
      }, Lt.prototype.interpolate = function(r, i, l) {
        var p = Zl[this.specification.type];
        return p ? p(r, i, l) : r;
      };
      var Tt = function(r, i) {
        this.specification = r, this.overrides = i;
      };
      Tt.prototype.possiblyEvaluate = function(r, i, l, p) {
        return new ji(this, r.expression.kind === "constant" || r.expression.kind === "camera" ? { kind: "constant", value: r.expression.evaluate(i, null, {}, l, p) } : r.expression, i);
      }, Tt.prototype.interpolate = function(r, i, l) {
        if (r.value.kind !== "constant" || i.value.kind !== "constant")
          return r;
        if (r.value.value === void 0 || i.value.value === void 0)
          return new ji(this, { kind: "constant", value: void 0 }, r.parameters);
        var p = Zl[this.specification.type];
        return p ? new ji(this, { kind: "constant", value: p(r.value.value, i.value.value, l) }, r.parameters) : r;
      }, Tt.prototype.evaluate = function(r, i, l, p, y, v) {
        return r.kind === "constant" ? r.value : r.evaluate(i, l, p, y, v);
      };
      var bh = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.possiblyEvaluate = function(l, p, y, v) {
          if (l.value === void 0)
            return new ji(this, { kind: "constant", value: void 0 }, p);
          if (l.expression.kind === "constant") {
            var x = l.expression.evaluate(p, null, {}, y, v), S = l.property.specification.type === "resolvedImage" && typeof x != "string" ? x.name : x, C = this._calculate(S, S, S, p);
            return new ji(this, { kind: "constant", value: C }, p);
          }
          if (l.expression.kind === "camera") {
            var A = this._calculate(l.expression.evaluate({ zoom: p.zoom - 1 }), l.expression.evaluate({ zoom: p.zoom }), l.expression.evaluate({ zoom: p.zoom + 1 }), p);
            return new ji(this, { kind: "constant", value: A }, p);
          }
          return new ji(this, l.expression, p);
        }, i.prototype.evaluate = function(l, p, y, v, x, S) {
          if (l.kind === "source") {
            var C = l.evaluate(p, y, v, x, S);
            return this._calculate(C, C, C, p);
          }
          return l.kind === "composite" ? this._calculate(l.evaluate({ zoom: Math.floor(p.zoom) - 1 }, y, v), l.evaluate({ zoom: Math.floor(p.zoom) }, y, v), l.evaluate({ zoom: Math.floor(p.zoom) + 1 }, y, v), p) : l.value;
        }, i.prototype._calculate = function(l, p, y, v) {
          return v.zoom > v.zoomHistory.lastIntegerZoom ? { from: l, to: p } : { from: y, to: p };
        }, i.prototype.interpolate = function(l) {
          return l;
        }, i;
      }(Tt), Gi = function(r) {
        this.specification = r;
      };
      Gi.prototype.possiblyEvaluate = function(r, i, l, p) {
        if (r.value !== void 0) {
          if (r.expression.kind === "constant") {
            var y = r.expression.evaluate(i, null, {}, l, p);
            return this._calculate(y, y, y, i);
          }
          return this._calculate(r.expression.evaluate(new mr(Math.floor(i.zoom - 1), i)), r.expression.evaluate(new mr(Math.floor(i.zoom), i)), r.expression.evaluate(new mr(Math.floor(i.zoom + 1), i)), i);
        }
      }, Gi.prototype._calculate = function(r, i, l, p) {
        return p.zoom > p.zoomHistory.lastIntegerZoom ? { from: r, to: i } : { from: l, to: i };
      }, Gi.prototype.interpolate = function(r) {
        return r;
      };
      var ua = function(r) {
        this.specification = r;
      };
      ua.prototype.possiblyEvaluate = function(r, i, l, p) {
        return !!r.expression.evaluate(i, null, {}, l, p);
      }, ua.prototype.interpolate = function() {
        return !1;
      };
      var Mi = function(r) {
        for (var i in this.properties = r, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], r) {
          var l = r[i];
          l.specification.overridable && this.overridableProperties.push(i);
          var p = this.defaultPropertyValues[i] = new xa(l, void 0), y = this.defaultTransitionablePropertyValues[i] = new Wo(l);
          this.defaultTransitioningPropertyValues[i] = y.untransitioned(), this.defaultPossiblyEvaluatedValues[i] = p.possiblyEvaluate({});
        }
      };
      wt("DataDrivenProperty", Tt), wt("DataConstantProperty", Lt), wt("CrossFadedDataDrivenProperty", bh), wt("CrossFadedProperty", Gi), wt("ColorRampProperty", ua);
      var ba = function(r) {
        function i(l, p) {
          if (r.call(this), this.id = l.id, this.type = l.type, this._featureFilter = { filter: function() {
            return !0;
          }, needGeometry: !1 }, l.type !== "custom" && (this.metadata = (l = l).metadata, this.minzoom = l.minzoom, this.maxzoom = l.maxzoom, l.type !== "background" && (this.source = l.source, this.sourceLayer = l["source-layer"], this.filter = l.filter), p.layout && (this._unevaluatedLayout = new la(p.layout)), p.paint)) {
            for (var y in this._transitionablePaint = new Ti(p.paint), l.paint)
              this.setPaintProperty(y, l.paint[y], { validate: !1 });
            for (var v in l.layout)
              this.setLayoutProperty(v, l.layout[v], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new lc(p.paint);
          }
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getCrossfadeParameters = function() {
          return this._crossfadeParameters;
        }, i.prototype.getLayoutProperty = function(l) {
          return l === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(l);
        }, i.prototype.setLayoutProperty = function(l, p, y) {
          y === void 0 && (y = {}), p != null && this._validate(ic, "layers." + this.id + ".layout." + l, l, p, y) || (l !== "visibility" ? this._unevaluatedLayout.setValue(l, p) : this.visibility = p);
        }, i.prototype.getPaintProperty = function(l) {
          return Pe(l, "-transition") ? this._transitionablePaint.getTransition(l.slice(0, -11)) : this._transitionablePaint.getValue(l);
        }, i.prototype.setPaintProperty = function(l, p, y) {
          if (y === void 0 && (y = {}), p != null && this._validate(Zv, "layers." + this.id + ".paint." + l, l, p, y))
            return !1;
          if (Pe(l, "-transition"))
            return this._transitionablePaint.setTransition(l.slice(0, -11), p || void 0), !1;
          var v = this._transitionablePaint._values[l], x = v.property.specification["property-type"] === "cross-faded-data-driven", S = v.value.isDataDriven(), C = v.value;
          this._transitionablePaint.setValue(l, p), this._handleSpecialPaintPropertyUpdate(l);
          var A = this._transitionablePaint._values[l].value;
          return A.isDataDriven() || S || x || this._handleOverridablePaintPropertyUpdate(l, C, A);
        }, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
        }, i.prototype._handleOverridablePaintPropertyUpdate = function(l, p, y) {
          return !1;
        }, i.prototype.isHidden = function(l) {
          return !!(this.minzoom && l < this.minzoom) || !!(this.maxzoom && l >= this.maxzoom) || this.visibility === "none";
        }, i.prototype.updateTransitions = function(l) {
          this._transitioningPaint = this._transitionablePaint.transitioned(l, this._transitioningPaint);
        }, i.prototype.hasTransition = function() {
          return this._transitioningPaint.hasTransition();
        }, i.prototype.recalculate = function(l, p) {
          l.getCrossfadeParameters && (this._crossfadeParameters = l.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(l, void 0, p)), this.paint = this._transitioningPaint.possiblyEvaluate(l, void 0, p);
        }, i.prototype.serialize = function() {
          var l = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (l.layout = l.layout || {}, l.layout.visibility = this.visibility), Ie(l, function(p, y) {
            return !(p === void 0 || y === "layout" && !Object.keys(p).length || y === "paint" && !Object.keys(p).length);
          });
        }, i.prototype._validate = function(l, p, y, v, x) {
          return x === void 0 && (x = {}), (!x || x.validate !== !1) && oc(this, l.call(nc, { key: p, layerType: this.type, objectKey: y, value: v, styleSpec: G, style: { glyphs: !0, sprite: !0 } }));
        }, i.prototype.is3D = function() {
          return !1;
        }, i.prototype.isTileClipped = function() {
          return !1;
        }, i.prototype.hasOffscreenPass = function() {
          return !1;
        }, i.prototype.resize = function() {
        }, i.prototype.isStateDependent = function() {
          for (var l in this.paint._values) {
            var p = this.paint.get(l);
            if (p instanceof ji && pl(p.property.specification) && (p.value.kind === "source" || p.value.kind === "composite") && p.value.isStateDependent)
              return !0;
          }
          return !1;
        }, i;
      }(de), up = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, wh = function(r, i) {
        this._structArray = r, this._pos1 = i * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
      }, Gr = function() {
        this.isTransferred = !1, this.capacity = -1, this.resize(0);
      };
      function yi(r, i) {
        i === void 0 && (i = 1);
        var l = 0, p = 0;
        return { members: r.map(function(y) {
          var v = up[y.type].BYTES_PER_ELEMENT, x = l = Dm(l, Math.max(i, v)), S = y.components || 1;
          return p = Math.max(p, v), l += v * S, { name: y.name, type: y.type, components: S, offset: x };
        }), size: Dm(l, Math.max(p, i)), alignment: i };
      }
      function Dm(r, i) {
        return Math.ceil(r / i) * i;
      }
      Gr.serialize = function(r, i) {
        return r._trim(), i && (r.isTransferred = !0, i.push(r.arrayBuffer)), { length: r.length, arrayBuffer: r.arrayBuffer };
      }, Gr.deserialize = function(r) {
        var i = Object.create(this.prototype);
        return i.arrayBuffer = r.arrayBuffer, i.length = r.length, i.capacity = r.arrayBuffer.byteLength / i.bytesPerElement, i._refreshViews(), i;
      }, Gr.prototype._trim = function() {
        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
      }, Gr.prototype.clear = function() {
        this.length = 0;
      }, Gr.prototype.resize = function(r) {
        this.reserve(r), this.length = r;
      }, Gr.prototype.reserve = function(r) {
        if (r > this.capacity) {
          this.capacity = Math.max(r, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
          var i = this.uint8;
          this._refreshViews(), i && this.uint8.set(i);
        }
      }, Gr.prototype._refreshViews = function() {
        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
      };
      var vl = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.int16[v + 0] = p, this.int16[v + 1] = y, l;
        }, i;
      }(Gr);
      vl.prototype.bytesPerElement = 4, wt("StructArrayLayout2i4", vl);
      var cp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 4 * l;
          return this.int16[S + 0] = p, this.int16[S + 1] = y, this.int16[S + 2] = v, this.int16[S + 3] = x, l;
        }, i;
      }(Gr);
      cp.prototype.bytesPerElement = 8, wt("StructArrayLayout4i8", cp);
      var Ga = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var A = 6 * l;
          return this.int16[A + 0] = p, this.int16[A + 1] = y, this.int16[A + 2] = v, this.int16[A + 3] = x, this.int16[A + 4] = S, this.int16[A + 5] = C, l;
        }, i;
      }(Gr);
      Ga.prototype.bytesPerElement = 12, wt("StructArrayLayout2i4i12", Ga);
      var po = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var A = 4 * l, L = 8 * l;
          return this.int16[A + 0] = p, this.int16[A + 1] = y, this.uint8[L + 4] = v, this.uint8[L + 5] = x, this.uint8[L + 6] = S, this.uint8[L + 7] = C, l;
        }, i;
      }(Gr);
      po.prototype.bytesPerElement = 8, wt("StructArrayLayout2i4ub8", po);
      var tu = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.float32[v + 0] = p, this.float32[v + 1] = y, l;
        }, i;
      }(Gr);
      tu.prototype.bytesPerElement = 8, wt("StructArrayLayout2f8", tu);
      var wa = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, A, L, D) {
          var B = this.length;
          return this.resize(B + 1), this.emplace(B, l, p, y, v, x, S, C, A, L, D);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, A, L, D, B) {
          var j = 10 * l;
          return this.uint16[j + 0] = p, this.uint16[j + 1] = y, this.uint16[j + 2] = v, this.uint16[j + 3] = x, this.uint16[j + 4] = S, this.uint16[j + 5] = C, this.uint16[j + 6] = A, this.uint16[j + 7] = L, this.uint16[j + 8] = D, this.uint16[j + 9] = B, l;
        }, i;
      }(Gr);
      wa.prototype.bytesPerElement = 20, wt("StructArrayLayout10ui20", wa);
      var Eh = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, A, L, D, B, j) {
          var Q = this.length;
          return this.resize(Q + 1), this.emplace(Q, l, p, y, v, x, S, C, A, L, D, B, j);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, A, L, D, B, j, Q) {
          var te = 12 * l;
          return this.int16[te + 0] = p, this.int16[te + 1] = y, this.int16[te + 2] = v, this.int16[te + 3] = x, this.uint16[te + 4] = S, this.uint16[te + 5] = C, this.uint16[te + 6] = A, this.uint16[te + 7] = L, this.int16[te + 8] = D, this.int16[te + 9] = B, this.int16[te + 10] = j, this.int16[te + 11] = Q, l;
        }, i;
      }(Gr);
      Eh.prototype.bytesPerElement = 24, wt("StructArrayLayout4i4ui4i24", Eh);
      var ru = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.float32[x + 0] = p, this.float32[x + 1] = y, this.float32[x + 2] = v, l;
        }, i;
      }(Gr);
      ru.prototype.bytesPerElement = 12, wt("StructArrayLayout3f12", ru);
      var uc = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.uint32[1 * l + 0] = p, l;
        }, i;
      }(Gr);
      uc.prototype.bytesPerElement = 4, wt("StructArrayLayout1ul4", uc);
      var hp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, A, L) {
          var D = this.length;
          return this.resize(D + 1), this.emplace(D, l, p, y, v, x, S, C, A, L);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, A, L, D) {
          var B = 10 * l, j = 5 * l;
          return this.int16[B + 0] = p, this.int16[B + 1] = y, this.int16[B + 2] = v, this.int16[B + 3] = x, this.int16[B + 4] = S, this.int16[B + 5] = C, this.uint32[j + 3] = A, this.uint16[B + 8] = L, this.uint16[B + 9] = D, l;
        }, i;
      }(Gr);
      hp.prototype.bytesPerElement = 20, wt("StructArrayLayout6i1ul2ui20", hp);
      var nu = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var A = 6 * l;
          return this.int16[A + 0] = p, this.int16[A + 1] = y, this.int16[A + 2] = v, this.int16[A + 3] = x, this.int16[A + 4] = S, this.int16[A + 5] = C, l;
        }, i;
      }(Gr);
      nu.prototype.bytesPerElement = 12, wt("StructArrayLayout2i2i2i12", nu);
      var _l = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x) {
          var S = this.length;
          return this.resize(S + 1), this.emplace(S, l, p, y, v, x);
        }, i.prototype.emplace = function(l, p, y, v, x, S) {
          var C = 4 * l, A = 8 * l;
          return this.float32[C + 0] = p, this.float32[C + 1] = y, this.float32[C + 2] = v, this.int16[A + 6] = x, this.int16[A + 7] = S, l;
        }, i;
      }(Gr);
      _l.prototype.bytesPerElement = 16, wt("StructArrayLayout2f1f2i16", _l);
      var fp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 12 * l, C = 3 * l;
          return this.uint8[S + 0] = p, this.uint8[S + 1] = y, this.float32[C + 1] = v, this.float32[C + 2] = x, l;
        }, i;
      }(Gr);
      fp.prototype.bytesPerElement = 12, wt("StructArrayLayout2ub2f12", fp);
      var Es = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.uint16[x + 0] = p, this.uint16[x + 1] = y, this.uint16[x + 2] = v, l;
        }, i;
      }(Gr);
      Es.prototype.bytesPerElement = 6, wt("StructArrayLayout3ui6", Es);
      var Ss = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, A, L, D, B, j, Q, te, ce, oe, ge) {
          var we = this.length;
          return this.resize(we + 1), this.emplace(we, l, p, y, v, x, S, C, A, L, D, B, j, Q, te, ce, oe, ge);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, A, L, D, B, j, Q, te, ce, oe, ge, we) {
          var Te = 24 * l, Oe = 12 * l, Be = 48 * l;
          return this.int16[Te + 0] = p, this.int16[Te + 1] = y, this.uint16[Te + 2] = v, this.uint16[Te + 3] = x, this.uint32[Oe + 2] = S, this.uint32[Oe + 3] = C, this.uint32[Oe + 4] = A, this.uint16[Te + 10] = L, this.uint16[Te + 11] = D, this.uint16[Te + 12] = B, this.float32[Oe + 7] = j, this.float32[Oe + 8] = Q, this.uint8[Be + 36] = te, this.uint8[Be + 37] = ce, this.uint8[Be + 38] = oe, this.uint32[Oe + 10] = ge, this.int16[Te + 22] = we, l;
        }, i;
      }(Gr);
      Ss.prototype.bytesPerElement = 48, wt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ss);
      var Sh = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, A, L, D, B, j, Q, te, ce, oe, ge, we, Te, Oe, Be, Xe, ot, At, dt, Nt, yt, ar) {
          var $t = this.length;
          return this.resize($t + 1), this.emplace($t, l, p, y, v, x, S, C, A, L, D, B, j, Q, te, ce, oe, ge, we, Te, Oe, Be, Xe, ot, At, dt, Nt, yt, ar);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, A, L, D, B, j, Q, te, ce, oe, ge, we, Te, Oe, Be, Xe, ot, At, dt, Nt, yt, ar, $t) {
          var Mt = 34 * l, fr = 17 * l;
          return this.int16[Mt + 0] = p, this.int16[Mt + 1] = y, this.int16[Mt + 2] = v, this.int16[Mt + 3] = x, this.int16[Mt + 4] = S, this.int16[Mt + 5] = C, this.int16[Mt + 6] = A, this.int16[Mt + 7] = L, this.uint16[Mt + 8] = D, this.uint16[Mt + 9] = B, this.uint16[Mt + 10] = j, this.uint16[Mt + 11] = Q, this.uint16[Mt + 12] = te, this.uint16[Mt + 13] = ce, this.uint16[Mt + 14] = oe, this.uint16[Mt + 15] = ge, this.uint16[Mt + 16] = we, this.uint16[Mt + 17] = Te, this.uint16[Mt + 18] = Oe, this.uint16[Mt + 19] = Be, this.uint16[Mt + 20] = Xe, this.uint16[Mt + 21] = ot, this.uint16[Mt + 22] = At, this.uint32[fr + 12] = dt, this.float32[fr + 13] = Nt, this.float32[fr + 14] = yt, this.float32[fr + 15] = ar, this.float32[fr + 16] = $t, l;
        }, i;
      }(Gr);
      Sh.prototype.bytesPerElement = 68, wt("StructArrayLayout8i15ui1ul4f68", Sh);
      var Ts = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.float32[1 * l + 0] = p, l;
        }, i;
      }(Gr);
      Ts.prototype.bytesPerElement = 4, wt("StructArrayLayout1f4", Ts);
      var Ho = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.int16[x + 0] = p, this.int16[x + 1] = y, this.int16[x + 2] = v, l;
        }, i;
      }(Gr);
      Ho.prototype.bytesPerElement = 6, wt("StructArrayLayout3i6", Ho);
      var pp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 4 * l;
          return this.uint32[2 * l + 0] = p, this.uint16[x + 2] = y, this.uint16[x + 3] = v, l;
        }, i;
      }(Gr);
      pp.prototype.bytesPerElement = 8, wt("StructArrayLayout1ul2ui8", pp);
      var cc = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.uint16[v + 0] = p, this.uint16[v + 1] = y, l;
        }, i;
      }(Gr);
      cc.prototype.bytesPerElement = 4, wt("StructArrayLayout2ui4", cc);
      var dp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.uint16[1 * l + 0] = p, l;
        }, i;
      }(Gr);
      dp.prototype.bytesPerElement = 2, wt("StructArrayLayout1ui2", dp);
      var Th = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 4 * l;
          return this.float32[S + 0] = p, this.float32[S + 1] = y, this.float32[S + 2] = v, this.float32[S + 3] = x, l;
        }, i;
      }(Gr);
      Th.prototype.bytesPerElement = 16, wt("StructArrayLayout4f16", Th);
      var u = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorPointX: { configurable: !0 }, anchorPointY: { configurable: !0 }, x1: { configurable: !0 }, y1: { configurable: !0 }, x2: { configurable: !0 }, y2: { configurable: !0 }, featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 }, anchorPoint: { configurable: !0 } };
        return l.anchorPointX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorPointY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.x1.get = function() {
          return this._structArray.int16[this._pos2 + 2];
        }, l.y1.get = function() {
          return this._structArray.int16[this._pos2 + 3];
        }, l.x2.get = function() {
          return this._structArray.int16[this._pos2 + 4];
        }, l.y2.get = function() {
          return this._structArray.int16[this._pos2 + 5];
        }, l.featureIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 3];
        }, l.sourceLayerIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 8];
        }, l.bucketIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 9];
        }, l.anchorPoint.get = function() {
          return new T(this.anchorPointX, this.anchorPointY);
        }, Object.defineProperties(i.prototype, l), i;
      }(wh);
      u.prototype.size = 20;
      var f = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new u(this, l);
        }, i;
      }(hp);
      wt("CollisionBoxArray", f);
      var c = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, glyphStartIndex: { configurable: !0 }, numGlyphs: { configurable: !0 }, vertexStartIndex: { configurable: !0 }, lineStartIndex: { configurable: !0 }, lineLength: { configurable: !0 }, segment: { configurable: !0 }, lowerSize: { configurable: !0 }, upperSize: { configurable: !0 }, lineOffsetX: { configurable: !0 }, lineOffsetY: { configurable: !0 }, writingMode: { configurable: !0 }, placedOrientation: { configurable: !0 }, hidden: { configurable: !0 }, crossTileID: { configurable: !0 }, associatedIconIndex: { configurable: !0 } };
        return l.anchorX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.glyphStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 2];
        }, l.numGlyphs.get = function() {
          return this._structArray.uint16[this._pos2 + 3];
        }, l.vertexStartIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 2];
        }, l.lineStartIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 3];
        }, l.lineLength.get = function() {
          return this._structArray.uint32[this._pos4 + 4];
        }, l.segment.get = function() {
          return this._structArray.uint16[this._pos2 + 10];
        }, l.lowerSize.get = function() {
          return this._structArray.uint16[this._pos2 + 11];
        }, l.upperSize.get = function() {
          return this._structArray.uint16[this._pos2 + 12];
        }, l.lineOffsetX.get = function() {
          return this._structArray.float32[this._pos4 + 7];
        }, l.lineOffsetY.get = function() {
          return this._structArray.float32[this._pos4 + 8];
        }, l.writingMode.get = function() {
          return this._structArray.uint8[this._pos1 + 36];
        }, l.placedOrientation.get = function() {
          return this._structArray.uint8[this._pos1 + 37];
        }, l.placedOrientation.set = function(p) {
          this._structArray.uint8[this._pos1 + 37] = p;
        }, l.hidden.get = function() {
          return this._structArray.uint8[this._pos1 + 38];
        }, l.hidden.set = function(p) {
          this._structArray.uint8[this._pos1 + 38] = p;
        }, l.crossTileID.get = function() {
          return this._structArray.uint32[this._pos4 + 10];
        }, l.crossTileID.set = function(p) {
          this._structArray.uint32[this._pos4 + 10] = p;
        }, l.associatedIconIndex.get = function() {
          return this._structArray.int16[this._pos2 + 22];
        }, Object.defineProperties(i.prototype, l), i;
      }(wh);
      c.prototype.size = 48;
      var d = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new c(this, l);
        }, i;
      }(Ss);
      wt("PlacedSymbolArray", d);
      var _ = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, rightJustifiedTextSymbolIndex: { configurable: !0 }, centerJustifiedTextSymbolIndex: { configurable: !0 }, leftJustifiedTextSymbolIndex: { configurable: !0 }, verticalPlacedTextSymbolIndex: { configurable: !0 }, placedIconSymbolIndex: { configurable: !0 }, verticalPlacedIconSymbolIndex: { configurable: !0 }, key: { configurable: !0 }, textBoxStartIndex: { configurable: !0 }, textBoxEndIndex: { configurable: !0 }, verticalTextBoxStartIndex: { configurable: !0 }, verticalTextBoxEndIndex: { configurable: !0 }, iconBoxStartIndex: { configurable: !0 }, iconBoxEndIndex: { configurable: !0 }, verticalIconBoxStartIndex: { configurable: !0 }, verticalIconBoxEndIndex: { configurable: !0 }, featureIndex: { configurable: !0 }, numHorizontalGlyphVertices: { configurable: !0 }, numVerticalGlyphVertices: { configurable: !0 }, numIconVertices: { configurable: !0 }, numVerticalIconVertices: { configurable: !0 }, useRuntimeCollisionCircles: { configurable: !0 }, crossTileID: { configurable: !0 }, textBoxScale: { configurable: !0 }, textOffset0: { configurable: !0 }, textOffset1: { configurable: !0 }, collisionCircleDiameter: { configurable: !0 } };
        return l.anchorX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.rightJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 2];
        }, l.centerJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 3];
        }, l.leftJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 4];
        }, l.verticalPlacedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 5];
        }, l.placedIconSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 6];
        }, l.verticalPlacedIconSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 7];
        }, l.key.get = function() {
          return this._structArray.uint16[this._pos2 + 8];
        }, l.textBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 9];
        }, l.textBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 10];
        }, l.verticalTextBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 11];
        }, l.verticalTextBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 12];
        }, l.iconBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 13];
        }, l.iconBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 14];
        }, l.verticalIconBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 15];
        }, l.verticalIconBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 16];
        }, l.featureIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 17];
        }, l.numHorizontalGlyphVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 18];
        }, l.numVerticalGlyphVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 19];
        }, l.numIconVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 20];
        }, l.numVerticalIconVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 21];
        }, l.useRuntimeCollisionCircles.get = function() {
          return this._structArray.uint16[this._pos2 + 22];
        }, l.crossTileID.get = function() {
          return this._structArray.uint32[this._pos4 + 12];
        }, l.crossTileID.set = function(p) {
          this._structArray.uint32[this._pos4 + 12] = p;
        }, l.textBoxScale.get = function() {
          return this._structArray.float32[this._pos4 + 13];
        }, l.textOffset0.get = function() {
          return this._structArray.float32[this._pos4 + 14];
        }, l.textOffset1.get = function() {
          return this._structArray.float32[this._pos4 + 15];
        }, l.collisionCircleDiameter.get = function() {
          return this._structArray.float32[this._pos4 + 16];
        }, Object.defineProperties(i.prototype, l), i;
      }(wh);
      _.prototype.size = 68;
      var w = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new _(this, l);
        }, i;
      }(Sh);
      wt("SymbolInstanceArray", w);
      var E = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getoffsetX = function(l) {
          return this.float32[1 * l + 0];
        }, i;
      }(Ts);
      wt("GlyphOffsetArray", E);
      var O = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getx = function(l) {
          return this.int16[3 * l + 0];
        }, i.prototype.gety = function(l) {
          return this.int16[3 * l + 1];
        }, i.prototype.gettileUnitDistanceFromAnchor = function(l) {
          return this.int16[3 * l + 2];
        }, i;
      }(Ho);
      wt("SymbolLineVertexArray", O);
      var k = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 } };
        return l.featureIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 0];
        }, l.sourceLayerIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 2];
        }, l.bucketIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 3];
        }, Object.defineProperties(i.prototype, l), i;
      }(wh);
      k.prototype.size = 8;
      var R = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new k(this, l);
        }, i;
      }(pp);
      wt("FeatureIndexArray", R);
      var q = yi([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, $ = function(r) {
        r === void 0 && (r = []), this.segments = r;
      };
      function H(r, i) {
        return 256 * (r = W(Math.floor(r), 0, 255)) + W(Math.floor(i), 0, 255);
      }
      $.prototype.prepareSegment = function(r, i, l, p) {
        var y = this.segments[this.segments.length - 1];
        return r > $.MAX_VERTEX_ARRAY_LENGTH && at("Max vertices per segment is " + $.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + r), (!y || y.vertexLength + r > $.MAX_VERTEX_ARRAY_LENGTH || y.sortKey !== p) && (y = { vertexOffset: i.length, primitiveOffset: l.length, vertexLength: 0, primitiveLength: 0 }, p !== void 0 && (y.sortKey = p), this.segments.push(y)), y;
      }, $.prototype.get = function() {
        return this.segments;
      }, $.prototype.destroy = function() {
        for (var r = 0, i = this.segments; r < i.length; r += 1) {
          var l = i[r];
          for (var p in l.vaos)
            l.vaos[p].destroy();
        }
      }, $.simpleSegment = function(r, i, l, p) {
        return new $([{ vertexOffset: r, primitiveOffset: i, vertexLength: l, primitiveLength: p, vaos: {}, sortKey: 0 }]);
      }, $.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, wt("SegmentVector", $);
      var ne = yi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), re = m(function(r) {
        r.exports = function(i, l) {
          var p, y, v, x, S, C, A, L;
          for (y = i.length - (p = 3 & i.length), v = l, S = 3432918353, C = 461845907, L = 0; L < y; )
            A = 255 & i.charCodeAt(L) | (255 & i.charCodeAt(++L)) << 8 | (255 & i.charCodeAt(++L)) << 16 | (255 & i.charCodeAt(++L)) << 24, ++L, v = 27492 + (65535 & (x = 5 * (65535 & (v = (v ^= A = (65535 & (A = (A = (65535 & A) * S + (((A >>> 16) * S & 65535) << 16) & 4294967295) << 15 | A >>> 17)) * C + (((A >>> 16) * C & 65535) << 16) & 4294967295) << 13 | v >>> 19)) + ((5 * (v >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (x >>> 16) & 65535) << 16);
          switch (A = 0, p) {
            case 3:
              A ^= (255 & i.charCodeAt(L + 2)) << 16;
            case 2:
              A ^= (255 & i.charCodeAt(L + 1)) << 8;
            case 1:
              v ^= A = (65535 & (A = (A = (65535 & (A ^= 255 & i.charCodeAt(L))) * S + (((A >>> 16) * S & 65535) << 16) & 4294967295) << 15 | A >>> 17)) * C + (((A >>> 16) * C & 65535) << 16) & 4294967295;
          }
          return v ^= i.length, v = 2246822507 * (65535 & (v ^= v >>> 16)) + ((2246822507 * (v >>> 16) & 65535) << 16) & 4294967295, v = 3266489909 * (65535 & (v ^= v >>> 13)) + ((3266489909 * (v >>> 16) & 65535) << 16) & 4294967295, (v ^= v >>> 16) >>> 0;
        };
      }), ue = m(function(r) {
        r.exports = function(i, l) {
          for (var p, y = i.length, v = l ^ y, x = 0; y >= 4; )
            p = 1540483477 * (65535 & (p = 255 & i.charCodeAt(x) | (255 & i.charCodeAt(++x)) << 8 | (255 & i.charCodeAt(++x)) << 16 | (255 & i.charCodeAt(++x)) << 24)) + ((1540483477 * (p >>> 16) & 65535) << 16), v = 1540483477 * (65535 & v) + ((1540483477 * (v >>> 16) & 65535) << 16) ^ (p = 1540483477 * (65535 & (p ^= p >>> 24)) + ((1540483477 * (p >>> 16) & 65535) << 16)), y -= 4, ++x;
          switch (y) {
            case 3:
              v ^= (255 & i.charCodeAt(x + 2)) << 16;
            case 2:
              v ^= (255 & i.charCodeAt(x + 1)) << 8;
            case 1:
              v = 1540483477 * (65535 & (v ^= 255 & i.charCodeAt(x))) + ((1540483477 * (v >>> 16) & 65535) << 16);
          }
          return v = 1540483477 * (65535 & (v ^= v >>> 13)) + ((1540483477 * (v >>> 16) & 65535) << 16), (v ^= v >>> 15) >>> 0;
        };
      }), J = re, le = ue;
      J.murmur3 = re, J.murmur2 = le;
      var me = function() {
        this.ids = [], this.positions = [], this.indexed = !1;
      };
      me.prototype.add = function(r, i, l, p) {
        this.ids.push(Ae(r)), this.positions.push(i, l, p);
      }, me.prototype.getPositions = function(r) {
        for (var i = Ae(r), l = 0, p = this.ids.length - 1; l < p; ) {
          var y = l + p >> 1;
          this.ids[y] >= i ? p = y : l = y + 1;
        }
        for (var v = []; this.ids[l] === i; )
          v.push({ index: this.positions[3 * l], start: this.positions[3 * l + 1], end: this.positions[3 * l + 2] }), l++;
        return v;
      }, me.serialize = function(r, i) {
        var l = new Float64Array(r.ids), p = new Uint32Array(r.positions);
        return function y(v, x, S, C) {
          for (; S < C; ) {
            for (var A = v[S + C >> 1], L = S - 1, D = C + 1; ; ) {
              do
                L++;
              while (v[L] < A);
              do
                D--;
              while (v[D] > A);
              if (L >= D)
                break;
              Me(v, L, D), Me(x, 3 * L, 3 * D), Me(x, 3 * L + 1, 3 * D + 1), Me(x, 3 * L + 2, 3 * D + 2);
            }
            D - S < C - D ? (y(v, x, S, D), S = D + 1) : (y(v, x, D + 1, C), C = D);
          }
        }(l, p, 0, l.length - 1), i && i.push(l.buffer, p.buffer), { ids: l, positions: p };
      }, me.deserialize = function(r) {
        var i = new me();
        return i.ids = r.ids, i.positions = r.positions, i.indexed = !0, i;
      };
      var _e = Math.pow(2, 53) - 1;
      function Ae(r) {
        var i = +r;
        return !isNaN(i) && i <= _e ? i : J(String(r));
      }
      function Me(r, i, l) {
        var p = r[i];
        r[i] = r[l], r[l] = p;
      }
      wt("FeaturePositionMap", me);
      var ke = function(r, i) {
        this.gl = r.gl, this.location = i;
      }, je = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          this.current !== l && (this.current = l, this.gl.uniform1i(this.location, l));
        }, i;
      }(ke), nt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          this.current !== l && (this.current = l, this.gl.uniform1f(this.location, l));
        }, i;
      }(ke), tt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] || (this.current = l, this.gl.uniform2f(this.location, l[0], l[1]));
        }, i;
      }(ke), gt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] && l[2] === this.current[2] || (this.current = l, this.gl.uniform3f(this.location, l[0], l[1], l[2]));
        }, i;
      }(ke), Dt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0, 0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] && l[2] === this.current[2] && l[3] === this.current[3] || (this.current = l, this.gl.uniform4f(this.location, l[0], l[1], l[2], l[3]));
        }, i;
      }(ke), Bt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = Fr.transparent;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l.r === this.current.r && l.g === this.current.g && l.b === this.current.b && l.a === this.current.a || (this.current = l, this.gl.uniform4f(this.location, l.r, l.g, l.b, l.a));
        }, i;
      }(ke), zt = new Float32Array(16), Ir = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = zt;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          if (l[12] !== this.current[12] || l[0] !== this.current[0])
            return this.current = l, void this.gl.uniformMatrix4fv(this.location, !1, l);
          for (var p = 1; p < 16; p++)
            if (l[p] !== this.current[p]) {
              this.current = l, this.gl.uniformMatrix4fv(this.location, !1, l);
              break;
            }
        }, i;
      }(ke);
      function xt(r) {
        return [H(255 * r.r, 255 * r.g), H(255 * r.b, 255 * r.a)];
      }
      var Yt = function(r, i, l) {
        this.value = r, this.uniformNames = i.map(function(p) {
          return "u_" + p;
        }), this.type = l;
      };
      Yt.prototype.setUniform = function(r, i, l) {
        r.set(l.constantOr(this.value));
      }, Yt.prototype.getBinding = function(r, i, l) {
        return this.type === "color" ? new Bt(r, i) : new nt(r, i);
      };
      var ir = function(r, i) {
        this.uniformNames = i.map(function(l) {
          return "u_" + l;
        }), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
      };
      ir.prototype.setConstantPatternPositions = function(r, i) {
        this.pixelRatioFrom = i.pixelRatio, this.pixelRatioTo = r.pixelRatio, this.patternFrom = i.tlbr, this.patternTo = r.tlbr;
      }, ir.prototype.setUniform = function(r, i, l, p) {
        var y = p === "u_pattern_to" ? this.patternTo : p === "u_pattern_from" ? this.patternFrom : p === "u_pixel_ratio_to" ? this.pixelRatioTo : p === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
        y && r.set(y);
      }, ir.prototype.getBinding = function(r, i, l) {
        return l.substr(0, 9) === "u_pattern" ? new Dt(r, i) : new nt(r, i);
      };
      var Kt = function(r, i, l, p) {
        this.expression = r, this.type = l, this.maxValue = 0, this.paintVertexAttributes = i.map(function(y) {
          return { name: "a_" + y, type: "Float32", components: l === "color" ? 2 : 1, offset: 0 };
        }), this.paintVertexArray = new p();
      };
      Kt.prototype.populatePaintArray = function(r, i, l, p, y) {
        var v = this.paintVertexArray.length, x = this.expression.evaluate(new mr(0), i, {}, p, [], y);
        this.paintVertexArray.resize(r), this._setPaintValue(v, r, x);
      }, Kt.prototype.updatePaintArray = function(r, i, l, p) {
        var y = this.expression.evaluate({ zoom: 0 }, l, p);
        this._setPaintValue(r, i, y);
      }, Kt.prototype._setPaintValue = function(r, i, l) {
        if (this.type === "color")
          for (var p = xt(l), y = r; y < i; y++)
            this.paintVertexArray.emplace(y, p[0], p[1]);
        else {
          for (var v = r; v < i; v++)
            this.paintVertexArray.emplace(v, l);
          this.maxValue = Math.max(this.maxValue, Math.abs(l));
        }
      }, Kt.prototype.upload = function(r) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = r.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }, Kt.prototype.destroy = function() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      };
      var Xt = function(r, i, l, p, y, v) {
        this.expression = r, this.uniformNames = i.map(function(x) {
          return "u_" + x + "_t";
        }), this.type = l, this.useIntegerZoom = p, this.zoom = y, this.maxValue = 0, this.paintVertexAttributes = i.map(function(x) {
          return { name: "a_" + x, type: "Float32", components: l === "color" ? 4 : 2, offset: 0 };
        }), this.paintVertexArray = new v();
      };
      Xt.prototype.populatePaintArray = function(r, i, l, p, y) {
        var v = this.expression.evaluate(new mr(this.zoom), i, {}, p, [], y), x = this.expression.evaluate(new mr(this.zoom + 1), i, {}, p, [], y), S = this.paintVertexArray.length;
        this.paintVertexArray.resize(r), this._setPaintValue(S, r, v, x);
      }, Xt.prototype.updatePaintArray = function(r, i, l, p) {
        var y = this.expression.evaluate({ zoom: this.zoom }, l, p), v = this.expression.evaluate({ zoom: this.zoom + 1 }, l, p);
        this._setPaintValue(r, i, y, v);
      }, Xt.prototype._setPaintValue = function(r, i, l, p) {
        if (this.type === "color")
          for (var y = xt(l), v = xt(p), x = r; x < i; x++)
            this.paintVertexArray.emplace(x, y[0], y[1], v[0], v[1]);
        else {
          for (var S = r; S < i; S++)
            this.paintVertexArray.emplace(S, l, p);
          this.maxValue = Math.max(this.maxValue, Math.abs(l), Math.abs(p));
        }
      }, Xt.prototype.upload = function(r) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = r.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }, Xt.prototype.destroy = function() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }, Xt.prototype.setUniform = function(r, i) {
        var l = this.useIntegerZoom ? Math.floor(i.zoom) : i.zoom, p = W(this.expression.interpolationFactor(l, this.zoom, this.zoom + 1), 0, 1);
        r.set(p);
      }, Xt.prototype.getBinding = function(r, i, l) {
        return new nt(r, i);
      };
      var nr = function(r, i, l, p, y, v) {
        this.expression = r, this.type = i, this.useIntegerZoom = l, this.zoom = p, this.layerId = v, this.zoomInPaintVertexArray = new y(), this.zoomOutPaintVertexArray = new y();
      };
      nr.prototype.populatePaintArray = function(r, i, l) {
        var p = this.zoomInPaintVertexArray.length;
        this.zoomInPaintVertexArray.resize(r), this.zoomOutPaintVertexArray.resize(r), this._setPaintValues(p, r, i.patterns && i.patterns[this.layerId], l);
      }, nr.prototype.updatePaintArray = function(r, i, l, p, y) {
        this._setPaintValues(r, i, l.patterns && l.patterns[this.layerId], y);
      }, nr.prototype._setPaintValues = function(r, i, l, p) {
        if (p && l) {
          var y = p[l.min], v = p[l.mid], x = p[l.max];
          if (y && v && x)
            for (var S = r; S < i; S++)
              this.zoomInPaintVertexArray.emplace(S, v.tl[0], v.tl[1], v.br[0], v.br[1], y.tl[0], y.tl[1], y.br[0], y.br[1], v.pixelRatio, y.pixelRatio), this.zoomOutPaintVertexArray.emplace(S, v.tl[0], v.tl[1], v.br[0], v.br[1], x.tl[0], x.tl[1], x.br[0], x.br[1], v.pixelRatio, x.pixelRatio);
        }
      }, nr.prototype.upload = function(r) {
        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = r.createVertexBuffer(this.zoomInPaintVertexArray, ne.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = r.createVertexBuffer(this.zoomOutPaintVertexArray, ne.members, this.expression.isStateDependent));
      }, nr.prototype.destroy = function() {
        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
      };
      var Ht = function(r, i, l) {
        this.binders = {}, this._buffers = [];
        var p = [];
        for (var y in r.paint._values)
          if (l(y)) {
            var v = r.paint.get(y);
            if (v instanceof ji && pl(v.property.specification)) {
              var x = si(y, r.type), S = v.value, C = v.property.specification.type, A = v.property.useIntegerZoom, L = v.property.specification["property-type"], D = L === "cross-faded" || L === "cross-faded-data-driven";
              if (S.kind === "constant")
                this.binders[y] = D ? new ir(S.value, x) : new Yt(S.value, x, C), p.push("/u_" + y);
              else if (S.kind === "source" || D) {
                var B = On(y, C, "source");
                this.binders[y] = D ? new nr(S, C, A, i, B, r.id) : new Kt(S, x, C, B), p.push("/a_" + y);
              } else {
                var j = On(y, C, "composite");
                this.binders[y] = new Xt(S, x, C, A, i, j), p.push("/z_" + y);
              }
            }
          }
        this.cacheKey = p.sort().join("");
      };
      Ht.prototype.getMaxValue = function(r) {
        var i = this.binders[r];
        return i instanceof Kt || i instanceof Xt ? i.maxValue : 0;
      }, Ht.prototype.populatePaintArrays = function(r, i, l, p, y) {
        for (var v in this.binders) {
          var x = this.binders[v];
          (x instanceof Kt || x instanceof Xt || x instanceof nr) && x.populatePaintArray(r, i, l, p, y);
        }
      }, Ht.prototype.setConstantPatternPositions = function(r, i) {
        for (var l in this.binders) {
          var p = this.binders[l];
          p instanceof ir && p.setConstantPatternPositions(r, i);
        }
      }, Ht.prototype.updatePaintArrays = function(r, i, l, p, y) {
        var v = !1;
        for (var x in r)
          for (var S = 0, C = i.getPositions(x); S < C.length; S += 1) {
            var A = C[S], L = l.feature(A.index);
            for (var D in this.binders) {
              var B = this.binders[D];
              if ((B instanceof Kt || B instanceof Xt || B instanceof nr) && B.expression.isStateDependent === !0) {
                var j = p.paint.get(D);
                B.expression = j.value, B.updatePaintArray(A.start, A.end, L, r[x], y), v = !0;
              }
            }
          }
        return v;
      }, Ht.prototype.defines = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          (l instanceof Yt || l instanceof ir) && r.push.apply(r, l.uniformNames.map(function(p) {
            return "#define HAS_UNIFORM_" + p;
          }));
        }
        return r;
      }, Ht.prototype.getBinderAttributes = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          if (l instanceof Kt || l instanceof Xt)
            for (var p = 0; p < l.paintVertexAttributes.length; p++)
              r.push(l.paintVertexAttributes[p].name);
          else if (l instanceof nr)
            for (var y = 0; y < ne.members.length; y++)
              r.push(ne.members[y].name);
        }
        return r;
      }, Ht.prototype.getBinderUniforms = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          if (l instanceof Yt || l instanceof ir || l instanceof Xt)
            for (var p = 0, y = l.uniformNames; p < y.length; p += 1)
              r.push(y[p]);
        }
        return r;
      }, Ht.prototype.getPaintVertexBuffers = function() {
        return this._buffers;
      }, Ht.prototype.getUniforms = function(r, i) {
        var l = [];
        for (var p in this.binders) {
          var y = this.binders[p];
          if (y instanceof Yt || y instanceof ir || y instanceof Xt)
            for (var v = 0, x = y.uniformNames; v < x.length; v += 1) {
              var S = x[v];
              if (i[S]) {
                var C = y.getBinding(r, i[S], S);
                l.push({ name: S, property: p, binding: C });
              }
            }
        }
        return l;
      }, Ht.prototype.setUniforms = function(r, i, l, p) {
        for (var y = 0, v = i; y < v.length; y += 1) {
          var x = v[y], S = x.name, C = x.property;
          this.binders[C].setUniform(x.binding, p, l.get(C), S);
        }
      }, Ht.prototype.updatePaintBuffers = function(r) {
        for (var i in this._buffers = [], this.binders) {
          var l = this.binders[i];
          if (r && l instanceof nr) {
            var p = r.fromScale === 2 ? l.zoomInPaintVertexBuffer : l.zoomOutPaintVertexBuffer;
            p && this._buffers.push(p);
          } else
            (l instanceof Kt || l instanceof Xt) && l.paintVertexBuffer && this._buffers.push(l.paintVertexBuffer);
        }
      }, Ht.prototype.upload = function(r) {
        for (var i in this.binders) {
          var l = this.binders[i];
          (l instanceof Kt || l instanceof Xt || l instanceof nr) && l.upload(r);
        }
        this.updatePaintBuffers();
      }, Ht.prototype.destroy = function() {
        for (var r in this.binders) {
          var i = this.binders[r];
          (i instanceof Kt || i instanceof Xt || i instanceof nr) && i.destroy();
        }
      };
      var qt = function(r, i, l) {
        l === void 0 && (l = function() {
          return !0;
        }), this.programConfigurations = {};
        for (var p = 0, y = r; p < y.length; p += 1) {
          var v = y[p];
          this.programConfigurations[v.id] = new Ht(v, i, l);
        }
        this.needsUpload = !1, this._featureMap = new me(), this._bufferOffset = 0;
      };
      function si(r, i) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[r] || [r.replace(i + "-", "").replace(/-/g, "_")];
      }
      function On(r, i, l) {
        var p = { color: { source: tu, composite: Th }, number: { source: Ts, composite: tu } }, y = function(v) {
          return { "line-pattern": { source: wa, composite: wa }, "fill-pattern": { source: wa, composite: wa }, "fill-extrusion-pattern": { source: wa, composite: wa } }[v];
        }(r);
        return y && y[l] || p[i][l];
      }
      qt.prototype.populatePaintArrays = function(r, i, l, p, y, v) {
        for (var x in this.programConfigurations)
          this.programConfigurations[x].populatePaintArrays(r, i, p, y, v);
        i.id !== void 0 && this._featureMap.add(i.id, l, this._bufferOffset, r), this._bufferOffset = r, this.needsUpload = !0;
      }, qt.prototype.updatePaintArrays = function(r, i, l, p) {
        for (var y = 0, v = l; y < v.length; y += 1) {
          var x = v[y];
          this.needsUpload = this.programConfigurations[x.id].updatePaintArrays(r, this._featureMap, i, x, p) || this.needsUpload;
        }
      }, qt.prototype.get = function(r) {
        return this.programConfigurations[r];
      }, qt.prototype.upload = function(r) {
        if (this.needsUpload) {
          for (var i in this.programConfigurations)
            this.programConfigurations[i].upload(r);
          this.needsUpload = !1;
        }
      }, qt.prototype.destroy = function() {
        for (var r in this.programConfigurations)
          this.programConfigurations[r].destroy();
      }, wt("ConstantBinder", Yt), wt("CrossFadedConstantBinder", ir), wt("SourceExpressionBinder", Kt), wt("CrossFadedCompositeBinder", nr), wt("CompositeExpressionBinder", Xt), wt("ProgramConfiguration", Ht, { omit: ["_buffers"] }), wt("ProgramConfigurationSet", qt);
      var Li = Math.pow(2, 14) - 1, gi = -Li - 1;
      function Tn(r) {
        for (var i = 8192 / r.extent, l = r.loadGeometry(), p = 0; p < l.length; p++)
          for (var y = l[p], v = 0; v < y.length; v++) {
            var x = y[v], S = Math.round(x.x * i), C = Math.round(x.y * i);
            x.x = W(S, gi, Li), x.y = W(C, gi, Li), (S < x.x || S > x.x + 1 || C < x.y || C > x.y + 1) && at("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        return l;
      }
      function Ln(r, i) {
        return { type: r.type, id: r.id, properties: r.properties, geometry: i ? Tn(r) : [] };
      }
      function mo(r, i, l, p, y) {
        r.emplaceBack(2 * i + (p + 1) / 2, 2 * l + (y + 1) / 2);
      }
      var qi = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.layoutVertexArray = new vl(), this.indexArray = new Es(), this.segments = new $(), this.programConfigurations = new qt(r.layers, r.zoom), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      function Ms(r, i) {
        for (var l = 0; l < r.length; l++)
          if (Ea(i, r[l]))
            return !0;
        for (var p = 0; p < i.length; p++)
          if (Ea(r, i[p]))
            return !0;
        return !!hc(r, i);
      }
      function Qi(r, i, l) {
        return !!Ea(r, i) || !!Is(i, r, l);
      }
      function ca(r, i) {
        if (r.length === 1)
          return fc(i, r[0]);
        for (var l = 0; l < i.length; l++)
          for (var p = i[l], y = 0; y < p.length; y++)
            if (Ea(r, p[y]))
              return !0;
        for (var v = 0; v < r.length; v++)
          if (fc(i, r[v]))
            return !0;
        for (var x = 0; x < i.length; x++)
          if (hc(r, i[x]))
            return !0;
        return !1;
      }
      function Zo(r, i, l) {
        if (r.length > 1) {
          if (hc(r, i))
            return !0;
          for (var p = 0; p < i.length; p++)
            if (Is(i[p], r, l))
              return !0;
        }
        for (var y = 0; y < r.length; y++)
          if (Is(r[y], i, l))
            return !0;
        return !1;
      }
      function hc(r, i) {
        if (r.length === 0 || i.length === 0)
          return !1;
        for (var l = 0; l < r.length - 1; l++)
          for (var p = r[l], y = r[l + 1], v = 0; v < i.length - 1; v++)
            if (iu(p, y, i[v], i[v + 1]))
              return !0;
        return !1;
      }
      function iu(r, i, l, p) {
        return be(r, l, p) !== be(i, l, p) && be(r, i, l) !== be(r, i, p);
      }
      function Is(r, i, l) {
        var p = l * l;
        if (i.length === 1)
          return r.distSqr(i[0]) < p;
        for (var y = 1; y < i.length; y++)
          if (ou(r, i[y - 1], i[y]) < p)
            return !0;
        return !1;
      }
      function ou(r, i, l) {
        var p = i.distSqr(l);
        if (p === 0)
          return r.distSqr(i);
        var y = ((r.x - i.x) * (l.x - i.x) + (r.y - i.y) * (l.y - i.y)) / p;
        return r.distSqr(y < 0 ? i : y > 1 ? l : l.sub(i)._mult(y)._add(i));
      }
      function fc(r, i) {
        for (var l, p, y, v = !1, x = 0; x < r.length; x++)
          for (var S = 0, C = (l = r[x]).length - 1; S < l.length; C = S++)
            (p = l[S]).y > i.y != (y = l[C]).y > i.y && i.x < (y.x - p.x) * (i.y - p.y) / (y.y - p.y) + p.x && (v = !v);
        return v;
      }
      function Ea(r, i) {
        for (var l = !1, p = 0, y = r.length - 1; p < r.length; y = p++) {
          var v = r[p], x = r[y];
          v.y > i.y != x.y > i.y && i.x < (x.x - v.x) * (i.y - v.y) / (x.y - v.y) + v.x && (l = !l);
        }
        return l;
      }
      function pc(r, i, l) {
        var p = l[0], y = l[2];
        if (r.x < p.x && i.x < p.x || r.x > y.x && i.x > y.x || r.y < p.y && i.y < p.y || r.y > y.y && i.y > y.y)
          return !1;
        var v = be(r, i, l[0]);
        return v !== be(r, i, l[1]) || v !== be(r, i, l[2]) || v !== be(r, i, l[3]);
      }
      function Sa(r, i, l) {
        var p = i.paint.get(r).value;
        return p.kind === "constant" ? p.value : l.programConfigurations.get(i.id).getMaxValue(r);
      }
      function li(r) {
        return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
      }
      function qa(r, i, l, p, y) {
        if (!i[0] && !i[1])
          return r;
        var v = T.convert(i)._mult(y);
        l === "viewport" && v._rotate(-p);
        for (var x = [], S = 0; S < r.length; S++)
          x.push(r[S].sub(v));
        return x;
      }
      qi.prototype.populate = function(r, i, l) {
        var p = this.layers[0], y = [], v = null;
        p.type === "circle" && (v = p.layout.get("circle-sort-key"));
        for (var x = 0, S = r; x < S.length; x += 1) {
          var C = S[x], A = C.feature, L = C.id, D = C.index, B = C.sourceLayerIndex, j = this.layers[0]._featureFilter.needGeometry, Q = Ln(A, j);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), Q, l)) {
            var te = v ? v.evaluate(Q, {}, l) : void 0, ce = { id: L, properties: A.properties, type: A.type, sourceLayerIndex: B, index: D, geometry: j ? Q.geometry : Tn(A), patterns: {}, sortKey: te };
            y.push(ce);
          }
        }
        v && y.sort(function(ot, At) {
          return ot.sortKey - At.sortKey;
        });
        for (var oe = 0, ge = y; oe < ge.length; oe += 1) {
          var we = ge[oe], Te = we.geometry, Oe = we.index, Be = we.sourceLayerIndex, Xe = r[Oe].feature;
          this.addFeature(we, Te, Oe, l), i.featureIndex.insert(Xe, Te, Oe, Be, this.index);
        }
      }, qi.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, qi.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, qi.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, qi.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, q), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, qi.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, qi.prototype.addFeature = function(r, i, l, p) {
        for (var y = 0, v = i; y < v.length; y += 1)
          for (var x = 0, S = v[y]; x < S.length; x += 1) {
            var C = S[x], A = C.x, L = C.y;
            if (!(A < 0 || A >= 8192 || L < 0 || L >= 8192)) {
              var D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, r.sortKey), B = D.vertexLength;
              mo(this.layoutVertexArray, A, L, -1, -1), mo(this.layoutVertexArray, A, L, 1, -1), mo(this.layoutVertexArray, A, L, 1, 1), mo(this.layoutVertexArray, A, L, -1, 1), this.indexArray.emplaceBack(B, B + 1, B + 2), this.indexArray.emplaceBack(B, B + 3, B + 2), D.vertexLength += 4, D.primitiveLength += 2;
            }
          }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, {}, p);
      }, wt("CircleBucket", qi, { omit: ["layers"] });
      var Os = new Mi({ "circle-sort-key": new Tt(G.layout_circle["circle-sort-key"]) }), xl = { paint: new Mi({ "circle-radius": new Tt(G.paint_circle["circle-radius"]), "circle-color": new Tt(G.paint_circle["circle-color"]), "circle-blur": new Tt(G.paint_circle["circle-blur"]), "circle-opacity": new Tt(G.paint_circle["circle-opacity"]), "circle-translate": new Lt(G.paint_circle["circle-translate"]), "circle-translate-anchor": new Lt(G.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Lt(G.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Lt(G.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Tt(G.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Tt(G.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Tt(G.paint_circle["circle-stroke-opacity"]) }), layout: Os }, Br = typeof Float32Array < "u" ? Float32Array : Array;
      function Oo(r) {
        return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
      }
      function eo(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3], S = i[4], C = i[5], A = i[6], L = i[7], D = i[8], B = i[9], j = i[10], Q = i[11], te = i[12], ce = i[13], oe = i[14], ge = i[15], we = l[0], Te = l[1], Oe = l[2], Be = l[3];
        return r[0] = we * p + Te * S + Oe * D + Be * te, r[1] = we * y + Te * C + Oe * B + Be * ce, r[2] = we * v + Te * A + Oe * j + Be * oe, r[3] = we * x + Te * L + Oe * Q + Be * ge, r[4] = (we = l[4]) * p + (Te = l[5]) * S + (Oe = l[6]) * D + (Be = l[7]) * te, r[5] = we * y + Te * C + Oe * B + Be * ce, r[6] = we * v + Te * A + Oe * j + Be * oe, r[7] = we * x + Te * L + Oe * Q + Be * ge, r[8] = (we = l[8]) * p + (Te = l[9]) * S + (Oe = l[10]) * D + (Be = l[11]) * te, r[9] = we * y + Te * C + Oe * B + Be * ce, r[10] = we * v + Te * A + Oe * j + Be * oe, r[11] = we * x + Te * L + Oe * Q + Be * ge, r[12] = (we = l[12]) * p + (Te = l[13]) * S + (Oe = l[14]) * D + (Be = l[15]) * te, r[13] = we * y + Te * C + Oe * B + Be * ce, r[14] = we * v + Te * A + Oe * j + Be * oe, r[15] = we * x + Te * L + Oe * Q + Be * ge, r;
      }
      Math.hypot || (Math.hypot = function() {
        for (var r = arguments, i = 0, l = arguments.length; l--; )
          i += r[l] * r[l];
        return Math.sqrt(i);
      });
      var bl, Xv = eo;
      function Mh(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3];
        return r[0] = l[0] * p + l[4] * y + l[8] * v + l[12] * x, r[1] = l[1] * p + l[5] * y + l[9] * v + l[13] * x, r[2] = l[2] * p + l[6] * y + l[10] * v + l[14] * x, r[3] = l[3] * p + l[7] * y + l[11] * v + l[15] * x, r;
      }
      bl = new Br(3), Br != Float32Array && (bl[0] = 0, bl[1] = 0, bl[2] = 0), function() {
        var r = new Br(4);
        Br != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0);
      }();
      var Kv = (function() {
        var r = new Br(2);
        Br != Float32Array && (r[0] = 0, r[1] = 0);
      }(), function(r) {
        function i(l) {
          r.call(this, l, xl);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new qi(l);
        }, i.prototype.queryRadius = function(l) {
          var p = l;
          return Sa("circle-radius", this, p) + Sa("circle-stroke-width", this, p) + li(this.paint.get("circle-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C, A) {
          for (var L = qa(l, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), S.angle, C), D = this.paint.get("circle-radius").evaluate(p, y) + this.paint.get("circle-stroke-width").evaluate(p, y), B = this.paint.get("circle-pitch-alignment") === "map", j = B ? L : function(Xe, ot) {
            return Xe.map(function(At) {
              return dc(At, ot);
            });
          }(L, A), Q = B ? D * C : D, te = 0, ce = v; te < ce.length; te += 1)
            for (var oe = 0, ge = ce[te]; oe < ge.length; oe += 1) {
              var we = ge[oe], Te = B ? we : dc(we, A), Oe = Q, Be = Mh([], [we.x, we.y, 0, 1], A);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Oe *= Be[3] / S.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Oe *= S.cameraToCenterDistance / Be[3]), Qi(j, Te, Oe))
                return !0;
            }
          return !1;
        }, i;
      }(ba));
      function dc(r, i) {
        var l = Mh([], [r.x, r.y, 0, 1], i);
        return new T(l[0] / l[3], l[1] / l[3]);
      }
      var Nm = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(qi);
      function au(r, i, l, p) {
        var y = i.width, v = i.height;
        if (p) {
          if (p instanceof Uint8ClampedArray)
            p = new Uint8Array(p.buffer);
          else if (p.length !== y * v * l)
            throw new RangeError("mismatched image size");
        } else
          p = new Uint8Array(y * v * l);
        return r.width = y, r.height = v, r.data = p, r;
      }
      function Ih(r, i, l) {
        var p = i.width, y = i.height;
        if (p !== r.width || y !== r.height) {
          var v = au({}, { width: p, height: y }, l);
          Yv(r, v, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r.width, p), height: Math.min(r.height, y) }, l), r.width = p, r.height = y, r.data = v.data;
        }
      }
      function Yv(r, i, l, p, y, v) {
        if (y.width === 0 || y.height === 0)
          return i;
        if (y.width > r.width || y.height > r.height || l.x > r.width - y.width || l.y > r.height - y.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (y.width > i.width || y.height > i.height || p.x > i.width - y.width || p.y > i.height - y.height)
          throw new RangeError("out of range destination coordinates for image copy");
        for (var x = r.data, S = i.data, C = 0; C < y.height; C++)
          for (var A = ((l.y + C) * r.width + l.x) * v, L = ((p.y + C) * i.width + p.x) * v, D = 0; D < y.width * v; D++)
            S[L + D] = x[A + D];
        return i;
      }
      wt("HeatmapBucket", Nm, { omit: ["layers"] });
      var mc = function(r, i) {
        au(this, r, 1, i);
      };
      mc.prototype.resize = function(r) {
        Ih(this, r, 1);
      }, mc.prototype.clone = function() {
        return new mc({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }, mc.copy = function(r, i, l, p, y) {
        Yv(r, i, l, p, y, 1);
      };
      var yo = function(r, i) {
        au(this, r, 4, i);
      };
      yo.prototype.resize = function(r) {
        Ih(this, r, 4);
      }, yo.prototype.replace = function(r, i) {
        i ? this.data.set(r) : this.data = r instanceof Uint8ClampedArray ? new Uint8Array(r.buffer) : r;
      }, yo.prototype.clone = function() {
        return new yo({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }, yo.copy = function(r, i, l, p, y) {
        Yv(r, i, l, p, y, 4);
      }, wt("AlphaImage", mc), wt("RGBAImage", yo);
      var DI = { paint: new Mi({ "heatmap-radius": new Tt(G.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Tt(G.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Lt(G.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ua(G.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Lt(G.paint_heatmap["heatmap-opacity"]) }) };
      function hx(r) {
        var i = {}, l = r.resolution || 256, p = r.clips ? r.clips.length : 1, y = r.image || new yo({ width: l, height: p }), v = function(Q, te, ce) {
          i[r.evaluationKey] = ce;
          var oe = r.expression.evaluate(i);
          y.data[Q + te + 0] = Math.floor(255 * oe.r / oe.a), y.data[Q + te + 1] = Math.floor(255 * oe.g / oe.a), y.data[Q + te + 2] = Math.floor(255 * oe.b / oe.a), y.data[Q + te + 3] = Math.floor(255 * oe.a);
        };
        if (r.clips)
          for (var x = 0, S = 0; x < p; ++x, S += 4 * l)
            for (var C = 0, A = 0; C < l; C++, A += 4) {
              var L = C / (l - 1), D = r.clips[x];
              v(S, A, D.start * (1 - L) + D.end * L);
            }
        else
          for (var B = 0, j = 0; B < l; B++, j += 4)
            v(0, j, B / (l - 1));
        return y;
      }
      var NI = function(r) {
        function i(l) {
          r.call(this, l, DI), this._updateColorRamp();
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new Nm(l);
        }, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
          l === "heatmap-color" && this._updateColorRamp();
        }, i.prototype._updateColorRamp = function() {
          this.colorRamp = hx({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }, i.prototype.resize = function() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }, i.prototype.queryRadius = function() {
          return 0;
        }, i.prototype.queryIntersectsFeature = function() {
          return !1;
        }, i.prototype.hasOffscreenPass = function() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }, i;
      }(ba), RI = { paint: new Mi({ "hillshade-illumination-direction": new Lt(G.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Lt(G.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Lt(G.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Lt(G.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Lt(G.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Lt(G.paint_hillshade["hillshade-accent-color"]) }) }, zI = function(r) {
        function i(l) {
          r.call(this, l, RI);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.hasOffscreenPass = function() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }, i;
      }(ba), FI = yi([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, Jv = Rm, BI = Rm;
      function Rm(r, i, l) {
        l = l || 2;
        var p, y, v, x, S, C, A, L = i && i.length, D = L ? i[0] * l : r.length, B = fx(r, 0, D, l, !0), j = [];
        if (!B || B.next === B.prev)
          return j;
        if (L && (B = function(te, ce, oe, ge) {
          var we, Te, Oe, Be = [];
          for (we = 0, Te = ce.length; we < Te; we++)
            (Oe = fx(te, ce[we] * ge, we < Te - 1 ? ce[we + 1] * ge : te.length, ge, !1)) === Oe.next && (Oe.steiner = !0), Be.push(HI(Oe));
          for (Be.sort(qI), we = 0; we < Be.length; we++)
            $I(Be[we], oe), oe = su(oe, oe.next);
          return oe;
        }(r, i, B, l)), r.length > 80 * l) {
          p = v = r[0], y = x = r[1];
          for (var Q = l; Q < D; Q += l)
            (S = r[Q]) < p && (p = S), (C = r[Q + 1]) < y && (y = C), S > v && (v = S), C > x && (x = C);
          A = (A = Math.max(v - p, x - y)) !== 0 ? 1 / A : 0;
        }
        return mp(B, j, l, p, y, A), j;
      }
      function fx(r, i, l, p, y) {
        var v, x;
        if (y === t_(r, i, l, p) > 0)
          for (v = i; v < l; v += p)
            x = mx(v, r[v], r[v + 1], x);
        else
          for (v = l - p; v >= i; v -= p)
            x = mx(v, r[v], r[v + 1], x);
        return x && zm(x, x.next) && (gp(x), x = x.next), x;
      }
      function su(r, i) {
        if (!r)
          return r;
        i || (i = r);
        var l, p = r;
        do
          if (l = !1, p.steiner || !zm(p, p.next) && Qn(p.prev, p, p.next) !== 0)
            p = p.next;
          else {
            if (gp(p), (p = i = p.prev) === p.next)
              break;
            l = !0;
          }
        while (l || p !== i);
        return i;
      }
      function mp(r, i, l, p, y, v, x) {
        if (r) {
          !x && v && function(L, D, B, j) {
            var Q = L;
            do
              Q.z === null && (Q.z = Qv(Q.x, Q.y, D, B, j)), Q.prevZ = Q.prev, Q.nextZ = Q.next, Q = Q.next;
            while (Q !== L);
            Q.prevZ.nextZ = null, Q.prevZ = null, function(te) {
              var ce, oe, ge, we, Te, Oe, Be, Xe, ot = 1;
              do {
                for (oe = te, te = null, Te = null, Oe = 0; oe; ) {
                  for (Oe++, ge = oe, Be = 0, ce = 0; ce < ot && (Be++, ge = ge.nextZ); ce++)
                    ;
                  for (Xe = ot; Be > 0 || Xe > 0 && ge; )
                    Be !== 0 && (Xe === 0 || !ge || oe.z <= ge.z) ? (we = oe, oe = oe.nextZ, Be--) : (we = ge, ge = ge.nextZ, Xe--), Te ? Te.nextZ = we : te = we, we.prevZ = Te, Te = we;
                  oe = ge;
                }
                Te.nextZ = null, ot *= 2;
              } while (Oe > 1);
            }(Q);
          }(r, p, y, v);
          for (var S, C, A = r; r.prev !== r.next; )
            if (S = r.prev, C = r.next, v ? UI(r, p, y, v) : VI(r))
              i.push(S.i / l), i.push(r.i / l), i.push(C.i / l), gp(r), r = C.next, A = C.next;
            else if ((r = C) === A) {
              x ? x === 1 ? mp(r = jI(su(r), i, l), i, l, p, y, v, 2) : x === 2 && GI(r, i, l, p, y, v) : mp(su(r), i, l, p, y, v, 1);
              break;
            }
        }
      }
      function VI(r) {
        var i = r.prev, l = r, p = r.next;
        if (Qn(i, l, p) >= 0)
          return !1;
        for (var y = r.next.next; y !== r.prev; ) {
          if (Oh(i.x, i.y, l.x, l.y, p.x, p.y, y.x, y.y) && Qn(y.prev, y, y.next) >= 0)
            return !1;
          y = y.next;
        }
        return !0;
      }
      function UI(r, i, l, p) {
        var y = r.prev, v = r, x = r.next;
        if (Qn(y, v, x) >= 0)
          return !1;
        for (var S = y.x > v.x ? y.x > x.x ? y.x : x.x : v.x > x.x ? v.x : x.x, C = y.y > v.y ? y.y > x.y ? y.y : x.y : v.y > x.y ? v.y : x.y, A = Qv(y.x < v.x ? y.x < x.x ? y.x : x.x : v.x < x.x ? v.x : x.x, y.y < v.y ? y.y < x.y ? y.y : x.y : v.y < x.y ? v.y : x.y, i, l, p), L = Qv(S, C, i, l, p), D = r.prevZ, B = r.nextZ; D && D.z >= A && B && B.z <= L; ) {
          if (D !== r.prev && D !== r.next && Oh(y.x, y.y, v.x, v.y, x.x, x.y, D.x, D.y) && Qn(D.prev, D, D.next) >= 0 || (D = D.prevZ, B !== r.prev && B !== r.next && Oh(y.x, y.y, v.x, v.y, x.x, x.y, B.x, B.y) && Qn(B.prev, B, B.next) >= 0))
            return !1;
          B = B.nextZ;
        }
        for (; D && D.z >= A; ) {
          if (D !== r.prev && D !== r.next && Oh(y.x, y.y, v.x, v.y, x.x, x.y, D.x, D.y) && Qn(D.prev, D, D.next) >= 0)
            return !1;
          D = D.prevZ;
        }
        for (; B && B.z <= L; ) {
          if (B !== r.prev && B !== r.next && Oh(y.x, y.y, v.x, v.y, x.x, x.y, B.x, B.y) && Qn(B.prev, B, B.next) >= 0)
            return !1;
          B = B.nextZ;
        }
        return !0;
      }
      function jI(r, i, l) {
        var p = r;
        do {
          var y = p.prev, v = p.next.next;
          !zm(y, v) && px(y, p, p.next, v) && yp(y, v) && yp(v, y) && (i.push(y.i / l), i.push(p.i / l), i.push(v.i / l), gp(p), gp(p.next), p = r = v), p = p.next;
        } while (p !== r);
        return su(p);
      }
      function GI(r, i, l, p, y, v) {
        var x = r;
        do {
          for (var S = x.next.next; S !== x.prev; ) {
            if (x.i !== S.i && ZI(x, S)) {
              var C = dx(x, S);
              return x = su(x, x.next), C = su(C, C.next), mp(x, i, l, p, y, v), void mp(C, i, l, p, y, v);
            }
            S = S.next;
          }
          x = x.next;
        } while (x !== r);
      }
      function qI(r, i) {
        return r.x - i.x;
      }
      function $I(r, i) {
        if (i = function(p, y) {
          var v, x = y, S = p.x, C = p.y, A = -1 / 0;
          do {
            if (C <= x.y && C >= x.next.y && x.next.y !== x.y) {
              var L = x.x + (C - x.y) * (x.next.x - x.x) / (x.next.y - x.y);
              if (L <= S && L > A) {
                if (A = L, L === S) {
                  if (C === x.y)
                    return x;
                  if (C === x.next.y)
                    return x.next;
                }
                v = x.x < x.next.x ? x : x.next;
              }
            }
            x = x.next;
          } while (x !== y);
          if (!v)
            return null;
          if (S === A)
            return v;
          var D, B = v, j = v.x, Q = v.y, te = 1 / 0;
          x = v;
          do
            S >= x.x && x.x >= j && S !== x.x && Oh(C < Q ? S : A, C, j, Q, C < Q ? A : S, C, x.x, x.y) && (D = Math.abs(C - x.y) / (S - x.x), yp(x, p) && (D < te || D === te && (x.x > v.x || x.x === v.x && WI(v, x))) && (v = x, te = D)), x = x.next;
          while (x !== B);
          return v;
        }(r, i)) {
          var l = dx(i, r);
          su(i, i.next), su(l, l.next);
        }
      }
      function WI(r, i) {
        return Qn(r.prev, r, i.prev) < 0 && Qn(i.next, r, r.next) < 0;
      }
      function Qv(r, i, l, p, y) {
        return (r = 1431655765 & ((r = 858993459 & ((r = 252645135 & ((r = 16711935 & ((r = 32767 * (r - l) * y) | r << 8)) | r << 4)) | r << 2)) | r << 1)) | (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = 32767 * (i - p) * y) | i << 8)) | i << 4)) | i << 2)) | i << 1)) << 1;
      }
      function HI(r) {
        var i = r, l = r;
        do
          (i.x < l.x || i.x === l.x && i.y < l.y) && (l = i), i = i.next;
        while (i !== r);
        return l;
      }
      function Oh(r, i, l, p, y, v, x, S) {
        return (y - x) * (i - S) - (r - x) * (v - S) >= 0 && (r - x) * (p - S) - (l - x) * (i - S) >= 0 && (l - x) * (v - S) - (y - x) * (p - S) >= 0;
      }
      function ZI(r, i) {
        return r.next.i !== i.i && r.prev.i !== i.i && !function(l, p) {
          var y = l;
          do {
            if (y.i !== l.i && y.next.i !== l.i && y.i !== p.i && y.next.i !== p.i && px(y, y.next, l, p))
              return !0;
            y = y.next;
          } while (y !== l);
          return !1;
        }(r, i) && (yp(r, i) && yp(i, r) && function(l, p) {
          var y = l, v = !1, x = (l.x + p.x) / 2, S = (l.y + p.y) / 2;
          do
            y.y > S != y.next.y > S && y.next.y !== y.y && x < (y.next.x - y.x) * (S - y.y) / (y.next.y - y.y) + y.x && (v = !v), y = y.next;
          while (y !== l);
          return v;
        }(r, i) && (Qn(r.prev, r, i.prev) || Qn(r, i.prev, i)) || zm(r, i) && Qn(r.prev, r, r.next) > 0 && Qn(i.prev, i, i.next) > 0);
      }
      function Qn(r, i, l) {
        return (i.y - r.y) * (l.x - i.x) - (i.x - r.x) * (l.y - i.y);
      }
      function zm(r, i) {
        return r.x === i.x && r.y === i.y;
      }
      function px(r, i, l, p) {
        var y = Bm(Qn(r, i, l)), v = Bm(Qn(r, i, p)), x = Bm(Qn(l, p, r)), S = Bm(Qn(l, p, i));
        return y !== v && x !== S || !(y !== 0 || !Fm(r, l, i)) || !(v !== 0 || !Fm(r, p, i)) || !(x !== 0 || !Fm(l, r, p)) || !(S !== 0 || !Fm(l, i, p));
      }
      function Fm(r, i, l) {
        return i.x <= Math.max(r.x, l.x) && i.x >= Math.min(r.x, l.x) && i.y <= Math.max(r.y, l.y) && i.y >= Math.min(r.y, l.y);
      }
      function Bm(r) {
        return r > 0 ? 1 : r < 0 ? -1 : 0;
      }
      function yp(r, i) {
        return Qn(r.prev, r, r.next) < 0 ? Qn(r, i, r.next) >= 0 && Qn(r, r.prev, i) >= 0 : Qn(r, i, r.prev) < 0 || Qn(r, r.next, i) < 0;
      }
      function dx(r, i) {
        var l = new e_(r.i, r.x, r.y), p = new e_(i.i, i.x, i.y), y = r.next, v = i.prev;
        return r.next = i, i.prev = r, l.next = y, y.prev = l, p.next = l, l.prev = p, v.next = p, p.prev = v, p;
      }
      function mx(r, i, l, p) {
        var y = new e_(r, i, l);
        return p ? (y.next = p.next, y.prev = p, p.next.prev = y, p.next = y) : (y.prev = y, y.next = y), y;
      }
      function gp(r) {
        r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
      }
      function e_(r, i, l) {
        this.i = r, this.x = i, this.y = l, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
      }
      function t_(r, i, l, p) {
        for (var y = 0, v = i, x = l - p; v < l; v += p)
          y += (r[x] - r[v]) * (r[v + 1] + r[x + 1]), x = v;
        return y;
      }
      function XI(r, i, l, p, y) {
        (function v(x, S, C, A, L) {
          for (; A > C; ) {
            if (A - C > 600) {
              var D = A - C + 1, B = S - C + 1, j = Math.log(D), Q = 0.5 * Math.exp(2 * j / 3), te = 0.5 * Math.sqrt(j * Q * (D - Q) / D) * (B - D / 2 < 0 ? -1 : 1);
              v(x, S, Math.max(C, Math.floor(S - B * Q / D + te)), Math.min(A, Math.floor(S + (D - B) * Q / D + te)), L);
            }
            var ce = x[S], oe = C, ge = A;
            for (vp(x, C, S), L(x[A], ce) > 0 && vp(x, C, A); oe < ge; ) {
              for (vp(x, oe, ge), oe++, ge--; L(x[oe], ce) < 0; )
                oe++;
              for (; L(x[ge], ce) > 0; )
                ge--;
            }
            L(x[C], ce) === 0 ? vp(x, C, ge) : vp(x, ++ge, A), ge <= S && (C = ge + 1), S <= ge && (A = ge - 1);
          }
        })(r, i, l || 0, p || r.length - 1, y || KI);
      }
      function vp(r, i, l) {
        var p = r[i];
        r[i] = r[l], r[l] = p;
      }
      function KI(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function r_(r, i) {
        var l = r.length;
        if (l <= 1)
          return [r];
        for (var p, y, v = [], x = 0; x < l; x++) {
          var S = Ke(r[x]);
          S !== 0 && (r[x].area = Math.abs(S), y === void 0 && (y = S < 0), y === S < 0 ? (p && v.push(p), p = [r[x]]) : p.push(r[x]));
        }
        if (p && v.push(p), i > 1)
          for (var C = 0; C < v.length; C++)
            v[C].length <= i || (XI(v[C], i, 1, v[C].length - 1, YI), v[C] = v[C].slice(0, i));
        return v;
      }
      function YI(r, i) {
        return i.area - r.area;
      }
      function n_(r, i, l) {
        for (var p = l.patternDependencies, y = !1, v = 0, x = i; v < x.length; v += 1) {
          var S = x[v].paint.get(r + "-pattern");
          S.isConstant() || (y = !0);
          var C = S.constantOr(null);
          C && (y = !0, p[C.to] = !0, p[C.from] = !0);
        }
        return y;
      }
      function i_(r, i, l, p, y) {
        for (var v = y.patternDependencies, x = 0, S = i; x < S.length; x += 1) {
          var C = S[x], A = C.paint.get(r + "-pattern").value;
          if (A.kind !== "constant") {
            var L = A.evaluate({ zoom: p - 1 }, l, {}, y.availableImages), D = A.evaluate({ zoom: p }, l, {}, y.availableImages), B = A.evaluate({ zoom: p + 1 }, l, {}, y.availableImages);
            D = D && D.name ? D.name : D, B = B && B.name ? B.name : B, v[L = L && L.name ? L.name : L] = !0, v[D] = !0, v[B] = !0, l.patterns[C.id] = { min: L, mid: D, max: B };
          }
        }
        return l;
      }
      Rm.deviation = function(r, i, l, p) {
        var y = i && i.length, v = Math.abs(t_(r, 0, y ? i[0] * l : r.length, l));
        if (y)
          for (var x = 0, S = i.length; x < S; x++)
            v -= Math.abs(t_(r, i[x] * l, x < S - 1 ? i[x + 1] * l : r.length, l));
        var C = 0;
        for (x = 0; x < p.length; x += 3) {
          var A = p[x] * l, L = p[x + 1] * l, D = p[x + 2] * l;
          C += Math.abs((r[A] - r[D]) * (r[L + 1] - r[A + 1]) - (r[A] - r[L]) * (r[D + 1] - r[A + 1]));
        }
        return v === 0 && C === 0 ? 0 : Math.abs((C - v) / v);
      }, Rm.flatten = function(r) {
        for (var i = r[0][0].length, l = { vertices: [], holes: [], dimensions: i }, p = 0, y = 0; y < r.length; y++) {
          for (var v = 0; v < r[y].length; v++)
            for (var x = 0; x < i; x++)
              l.vertices.push(r[y][v][x]);
          y > 0 && l.holes.push(p += r[y - 1].length);
        }
        return l;
      }, Jv.default = BI;
      var $a = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new vl(), this.indexArray = new Es(), this.indexArray2 = new cc(), this.programConfigurations = new qt(r.layers, r.zoom), this.segments = new $(), this.segments2 = new $(), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      $a.prototype.populate = function(r, i, l) {
        this.hasPattern = n_("fill", this.layers, i);
        for (var p = this.layers[0].layout.get("fill-sort-key"), y = [], v = 0, x = r; v < x.length; v += 1) {
          var S = x[v], C = S.feature, A = S.id, L = S.index, D = S.sourceLayerIndex, B = this.layers[0]._featureFilter.needGeometry, j = Ln(C, B);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), j, l)) {
            var Q = p ? p.evaluate(j, {}, l, i.availableImages) : void 0, te = { id: A, properties: C.properties, type: C.type, sourceLayerIndex: D, index: L, geometry: B ? j.geometry : Tn(C), patterns: {}, sortKey: Q };
            y.push(te);
          }
        }
        p && y.sort(function(Xe, ot) {
          return Xe.sortKey - ot.sortKey;
        });
        for (var ce = 0, oe = y; ce < oe.length; ce += 1) {
          var ge = oe[ce], we = ge.geometry, Te = ge.index, Oe = ge.sourceLayerIndex;
          if (this.hasPattern) {
            var Be = i_("fill", this.layers, ge, this.zoom, i);
            this.patternFeatures.push(Be);
          } else
            this.addFeature(ge, we, Te, l, {});
          i.featureIndex.insert(r[Te].feature, we, Te, Oe, this.index);
        }
      }, $a.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, $a.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.patternFeatures; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, $a.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, $a.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, $a.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, FI), this.indexBuffer = r.createIndexBuffer(this.indexArray), this.indexBuffer2 = r.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, $a.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
      }, $a.prototype.addFeature = function(r, i, l, p, y) {
        for (var v = 0, x = r_(i, 500); v < x.length; v += 1) {
          for (var S = x[v], C = 0, A = 0, L = S; A < L.length; A += 1)
            C += L[A].length;
          for (var D = this.segments.prepareSegment(C, this.layoutVertexArray, this.indexArray), B = D.vertexLength, j = [], Q = [], te = 0, ce = S; te < ce.length; te += 1) {
            var oe = ce[te];
            if (oe.length !== 0) {
              oe !== S[0] && Q.push(j.length / 2);
              var ge = this.segments2.prepareSegment(oe.length, this.layoutVertexArray, this.indexArray2), we = ge.vertexLength;
              this.layoutVertexArray.emplaceBack(oe[0].x, oe[0].y), this.indexArray2.emplaceBack(we + oe.length - 1, we), j.push(oe[0].x), j.push(oe[0].y);
              for (var Te = 1; Te < oe.length; Te++)
                this.layoutVertexArray.emplaceBack(oe[Te].x, oe[Te].y), this.indexArray2.emplaceBack(we + Te - 1, we + Te), j.push(oe[Te].x), j.push(oe[Te].y);
              ge.vertexLength += oe.length, ge.primitiveLength += oe.length;
            }
          }
          for (var Oe = Jv(j, Q), Be = 0; Be < Oe.length; Be += 3)
            this.indexArray.emplaceBack(B + Oe[Be], B + Oe[Be + 1], B + Oe[Be + 2]);
          D.vertexLength += C, D.primitiveLength += Oe.length / 3;
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, wt("FillBucket", $a, { omit: ["layers", "patternFeatures"] });
      var JI = new Mi({ "fill-sort-key": new Tt(G.layout_fill["fill-sort-key"]) }), QI = { paint: new Mi({ "fill-antialias": new Lt(G.paint_fill["fill-antialias"]), "fill-opacity": new Tt(G.paint_fill["fill-opacity"]), "fill-color": new Tt(G.paint_fill["fill-color"]), "fill-outline-color": new Tt(G.paint_fill["fill-outline-color"]), "fill-translate": new Lt(G.paint_fill["fill-translate"]), "fill-translate-anchor": new Lt(G.paint_fill["fill-translate-anchor"]), "fill-pattern": new bh(G.paint_fill["fill-pattern"]) }), layout: JI }, eO = function(r) {
        function i(l) {
          r.call(this, l, QI);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.recalculate = function(l, p) {
          r.prototype.recalculate.call(this, l, p);
          var y = this.paint._values["fill-outline-color"];
          y.value.kind === "constant" && y.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }, i.prototype.createBucket = function(l) {
          return new $a(l);
        }, i.prototype.queryRadius = function() {
          return li(this.paint.get("fill-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C) {
          return ca(qa(l, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), S.angle, C), v);
        }, i.prototype.isTileClipped = function() {
          return !0;
        }, i;
      }(ba), tO = yi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4).members, yx = Ch;
      function Ch(r, i, l, p, y) {
        this.properties = {}, this.extent = l, this.type = 0, this._pbf = r, this._geometry = -1, this._keys = p, this._values = y, r.readFields(rO, this, i);
      }
      function rO(r, i, l) {
        r == 1 ? i.id = l.readVarint() : r == 2 ? function(p, y) {
          for (var v = p.readVarint() + p.pos; p.pos < v; ) {
            var x = y._keys[p.readVarint()], S = y._values[p.readVarint()];
            y.properties[x] = S;
          }
        }(l, i) : r == 3 ? i.type = l.readVarint() : r == 4 && (i._geometry = l.pos);
      }
      function nO(r) {
        for (var i, l, p = 0, y = 0, v = r.length, x = v - 1; y < v; x = y++)
          p += ((l = r[x]).x - (i = r[y]).x) * (i.y + l.y);
        return p;
      }
      Ch.types = ["Unknown", "Point", "LineString", "Polygon"], Ch.prototype.loadGeometry = function() {
        var r = this._pbf;
        r.pos = this._geometry;
        for (var i, l = r.readVarint() + r.pos, p = 1, y = 0, v = 0, x = 0, S = []; r.pos < l; ) {
          if (y <= 0) {
            var C = r.readVarint();
            p = 7 & C, y = C >> 3;
          }
          if (y--, p === 1 || p === 2)
            v += r.readSVarint(), x += r.readSVarint(), p === 1 && (i && S.push(i), i = []), i.push(new T(v, x));
          else {
            if (p !== 7)
              throw new Error("unknown command " + p);
            i && i.push(i[0].clone());
          }
        }
        return i && S.push(i), S;
      }, Ch.prototype.bbox = function() {
        var r = this._pbf;
        r.pos = this._geometry;
        for (var i = r.readVarint() + r.pos, l = 1, p = 0, y = 0, v = 0, x = 1 / 0, S = -1 / 0, C = 1 / 0, A = -1 / 0; r.pos < i; ) {
          if (p <= 0) {
            var L = r.readVarint();
            l = 7 & L, p = L >> 3;
          }
          if (p--, l === 1 || l === 2)
            (y += r.readSVarint()) < x && (x = y), y > S && (S = y), (v += r.readSVarint()) < C && (C = v), v > A && (A = v);
          else if (l !== 7)
            throw new Error("unknown command " + l);
        }
        return [x, C, S, A];
      }, Ch.prototype.toGeoJSON = function(r, i, l) {
        var p, y, v = this.extent * Math.pow(2, l), x = this.extent * r, S = this.extent * i, C = this.loadGeometry(), A = Ch.types[this.type];
        function L(j) {
          for (var Q = 0; Q < j.length; Q++) {
            var te = j[Q];
            j[Q] = [360 * (te.x + x) / v - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (te.y + S) / v) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var D = [];
            for (p = 0; p < C.length; p++)
              D[p] = C[p][0];
            L(C = D);
            break;
          case 2:
            for (p = 0; p < C.length; p++)
              L(C[p]);
            break;
          case 3:
            for (C = function(j) {
              var Q = j.length;
              if (Q <= 1)
                return [j];
              for (var te, ce, oe = [], ge = 0; ge < Q; ge++) {
                var we = nO(j[ge]);
                we !== 0 && (ce === void 0 && (ce = we < 0), ce === we < 0 ? (te && oe.push(te), te = [j[ge]]) : te.push(j[ge]));
              }
              return te && oe.push(te), oe;
            }(C), p = 0; p < C.length; p++)
              for (y = 0; y < C[p].length; y++)
                L(C[p][y]);
        }
        C.length === 1 ? C = C[0] : A = "Multi" + A;
        var B = { type: "Feature", geometry: { type: A, coordinates: C }, properties: this.properties };
        return "id" in this && (B.id = this.id), B;
      };
      var gx = vx;
      function vx(r, i) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = r, this._keys = [], this._values = [], this._features = [], r.readFields(iO, this, i), this.length = this._features.length;
      }
      function iO(r, i, l) {
        r === 15 ? i.version = l.readVarint() : r === 1 ? i.name = l.readString() : r === 5 ? i.extent = l.readVarint() : r === 2 ? i._features.push(l.pos) : r === 3 ? i._keys.push(l.readString()) : r === 4 && i._values.push(function(p) {
          for (var y = null, v = p.readVarint() + p.pos; p.pos < v; ) {
            var x = p.readVarint() >> 3;
            y = x === 1 ? p.readString() : x === 2 ? p.readFloat() : x === 3 ? p.readDouble() : x === 4 ? p.readVarint64() : x === 5 ? p.readVarint() : x === 6 ? p.readSVarint() : x === 7 ? p.readBoolean() : null;
          }
          return y;
        }(l));
      }
      function oO(r, i, l) {
        if (r === 3) {
          var p = new gx(l, l.readVarint() + l.pos);
          p.length && (i[p.name] = p);
        }
      }
      vx.prototype.feature = function(r) {
        if (r < 0 || r >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[r];
        var i = this._pbf.readVarint() + this._pbf.pos;
        return new yx(this._pbf, i, this.extent, this._keys, this._values);
      };
      var Ah = { VectorTile: function(r, i) {
        this.layers = r.readFields(oO, {}, i);
      }, VectorTileFeature: yx, VectorTileLayer: gx }, aO = Ah.VectorTileFeature.types, o_ = Math.pow(2, 13);
      function _p(r, i, l, p, y, v, x, S) {
        r.emplaceBack(i, l, 2 * Math.floor(p * o_) + x, y * o_ * 2, v * o_ * 2, Math.round(S));
      }
      var Wa = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.layoutVertexArray = new Ga(), this.indexArray = new Es(), this.programConfigurations = new qt(r.layers, r.zoom), this.segments = new $(), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      function sO(r, i) {
        return r.x === i.x && (r.x < 0 || r.x > 8192) || r.y === i.y && (r.y < 0 || r.y > 8192);
      }
      Wa.prototype.populate = function(r, i, l) {
        this.features = [], this.hasPattern = n_("fill-extrusion", this.layers, i);
        for (var p = 0, y = r; p < y.length; p += 1) {
          var v = y[p], x = v.feature, S = v.id, C = v.index, A = v.sourceLayerIndex, L = this.layers[0]._featureFilter.needGeometry, D = Ln(x, L);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), D, l)) {
            var B = { id: S, sourceLayerIndex: A, index: C, geometry: L ? D.geometry : Tn(x), properties: x.properties, type: x.type, patterns: {} };
            this.hasPattern ? this.features.push(i_("fill-extrusion", this.layers, B, this.zoom, i)) : this.addFeature(B, B.geometry, C, l, {}), i.featureIndex.insert(x, B.geometry, C, A, this.index, !0);
          }
        }
      }, Wa.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.features; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, Wa.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, Wa.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, Wa.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, Wa.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, tO), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, Wa.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, Wa.prototype.addFeature = function(r, i, l, p, y) {
        for (var v = 0, x = r_(i, 500); v < x.length; v += 1) {
          for (var S = x[v], C = 0, A = 0, L = S; A < L.length; A += 1)
            C += L[A].length;
          for (var D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), B = 0, j = S; B < j.length; B += 1) {
            var Q = j[B];
            if (Q.length !== 0 && !((fr = Q).every(function(rr) {
              return rr.x < 0;
            }) || fr.every(function(rr) {
              return rr.x > 8192;
            }) || fr.every(function(rr) {
              return rr.y < 0;
            }) || fr.every(function(rr) {
              return rr.y > 8192;
            })))
              for (var te = 0, ce = 0; ce < Q.length; ce++) {
                var oe = Q[ce];
                if (ce >= 1) {
                  var ge = Q[ce - 1];
                  if (!sO(oe, ge)) {
                    D.vertexLength + 4 > $.MAX_VERTEX_ARRAY_LENGTH && (D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    var we = oe.sub(ge)._perp()._unit(), Te = ge.dist(oe);
                    te + Te > 32768 && (te = 0), _p(this.layoutVertexArray, oe.x, oe.y, we.x, we.y, 0, 0, te), _p(this.layoutVertexArray, oe.x, oe.y, we.x, we.y, 0, 1, te), _p(this.layoutVertexArray, ge.x, ge.y, we.x, we.y, 0, 0, te += Te), _p(this.layoutVertexArray, ge.x, ge.y, we.x, we.y, 0, 1, te);
                    var Oe = D.vertexLength;
                    this.indexArray.emplaceBack(Oe, Oe + 2, Oe + 1), this.indexArray.emplaceBack(Oe + 1, Oe + 2, Oe + 3), D.vertexLength += 4, D.primitiveLength += 2;
                  }
                }
              }
          }
          if (D.vertexLength + C > $.MAX_VERTEX_ARRAY_LENGTH && (D = this.segments.prepareSegment(C, this.layoutVertexArray, this.indexArray)), aO[r.type] === "Polygon") {
            for (var Be = [], Xe = [], ot = D.vertexLength, At = 0, dt = S; At < dt.length; At += 1) {
              var Nt = dt[At];
              if (Nt.length !== 0) {
                Nt !== S[0] && Xe.push(Be.length / 2);
                for (var yt = 0; yt < Nt.length; yt++) {
                  var ar = Nt[yt];
                  _p(this.layoutVertexArray, ar.x, ar.y, 0, 0, 1, 1, 0), Be.push(ar.x), Be.push(ar.y);
                }
              }
            }
            for (var $t = Jv(Be, Xe), Mt = 0; Mt < $t.length; Mt += 3)
              this.indexArray.emplaceBack(ot + $t[Mt], ot + $t[Mt + 2], ot + $t[Mt + 1]);
            D.primitiveLength += $t.length / 3, D.vertexLength += C;
          }
        }
        var fr;
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, wt("FillExtrusionBucket", Wa, { omit: ["layers", "features"] });
      var lO = { paint: new Mi({ "fill-extrusion-opacity": new Lt(G["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Tt(G["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Lt(G["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Lt(G["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new bh(G["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Tt(G["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Tt(G["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Lt(G["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) }, uO = function(r) {
        function i(l) {
          r.call(this, l, lO);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new Wa(l);
        }, i.prototype.queryRadius = function() {
          return li(this.paint.get("fill-extrusion-translate"));
        }, i.prototype.is3D = function() {
          return !0;
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C, A) {
          var L = qa(l, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), S.angle, C), D = this.paint.get("fill-extrusion-height").evaluate(p, y), B = this.paint.get("fill-extrusion-base").evaluate(p, y), j = function(te, ce, oe, ge) {
            for (var we = [], Te = 0, Oe = te; Te < Oe.length; Te += 1) {
              var Be = Oe[Te], Xe = [Be.x, Be.y, 0, 1];
              Mh(Xe, Xe, ce), we.push(new T(Xe[0] / Xe[3], Xe[1] / Xe[3]));
            }
            return we;
          }(L, A), Q = function(te, ce, oe, ge) {
            for (var we = [], Te = [], Oe = ge[8] * ce, Be = ge[9] * ce, Xe = ge[10] * ce, ot = ge[11] * ce, At = ge[8] * oe, dt = ge[9] * oe, Nt = ge[10] * oe, yt = ge[11] * oe, ar = 0, $t = te; ar < $t.length; ar += 1) {
              for (var Mt = [], fr = [], rr = 0, Sr = $t[ar]; rr < Sr.length; rr += 1) {
                var Rt = Sr[rr], Dr = Rt.x, gn = Rt.y, Cn = ge[0] * Dr + ge[4] * gn + ge[12], Mn = ge[1] * Dr + ge[5] * gn + ge[13], vn = ge[2] * Dr + ge[6] * gn + ge[14], An = ge[3] * Dr + ge[7] * gn + ge[15], ui = vn + Xe, ci = An + ot, Wi = Cn + At, _i = Mn + dt, Hi = vn + Nt, Dn = An + yt, xi = new T((Cn + Oe) / ci, (Mn + Be) / ci);
                xi.z = ui / ci, Mt.push(xi);
                var vr = new T(Wi / Dn, _i / Dn);
                vr.z = Hi / Dn, fr.push(vr);
              }
              we.push(Mt), Te.push(fr);
            }
            return [we, Te];
          }(v, B, D, A);
          return function(te, ce, oe) {
            var ge = 1 / 0;
            ca(oe, ce) && (ge = _x(oe, ce[0]));
            for (var we = 0; we < ce.length; we++)
              for (var Te = ce[we], Oe = te[we], Be = 0; Be < Te.length - 1; Be++) {
                var Xe = Te[Be], ot = [Xe, Te[Be + 1], Oe[Be + 1], Oe[Be], Xe];
                Ms(oe, ot) && (ge = Math.min(ge, _x(oe, ot)));
              }
            return ge !== 1 / 0 && ge;
          }(Q[0], Q[1], j);
        }, i;
      }(ba);
      function xp(r, i) {
        return r.x * i.x + r.y * i.y;
      }
      function _x(r, i) {
        if (r.length === 1) {
          for (var l, p = 0, y = i[p++]; !l || y.equals(l); )
            if (!(l = i[p++]))
              return 1 / 0;
          for (; p < i.length; p++) {
            var v = i[p], x = r[0], S = l.sub(y), C = v.sub(y), A = x.sub(y), L = xp(S, S), D = xp(S, C), B = xp(C, C), j = xp(A, S), Q = xp(A, C), te = L * B - D * D, ce = (B * j - D * Q) / te, oe = (L * Q - D * j) / te, ge = y.z * (1 - ce - oe) + l.z * ce + v.z * oe;
            if (isFinite(ge))
              return ge;
          }
          return 1 / 0;
        }
        for (var we = 1 / 0, Te = 0, Oe = i; Te < Oe.length; Te += 1)
          we = Math.min(we, Oe[Te].z);
        return we;
      }
      var cO = yi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4).members, hO = yi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]).members, fO = Ah.VectorTileFeature.types, pO = Math.cos(Math.PI / 180 * 37.5), xx = Math.pow(2, 14) / 0.5, to = function(r) {
        var i = this;
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(l) {
          return l.id;
        }), this.index = r.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(function(l) {
          i.gradients[l.id] = {};
        }), this.layoutVertexArray = new po(), this.layoutVertexArray2 = new tu(), this.indexArray = new Es(), this.programConfigurations = new qt(r.layers, r.zoom), this.segments = new $(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(function(l) {
          return l.isStateDependent();
        }).map(function(l) {
          return l.id;
        });
      };
      to.prototype.populate = function(r, i, l) {
        this.hasPattern = n_("line", this.layers, i);
        for (var p = this.layers[0].layout.get("line-sort-key"), y = [], v = 0, x = r; v < x.length; v += 1) {
          var S = x[v], C = S.feature, A = S.id, L = S.index, D = S.sourceLayerIndex, B = this.layers[0]._featureFilter.needGeometry, j = Ln(C, B);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), j, l)) {
            var Q = p ? p.evaluate(j, {}, l) : void 0, te = { id: A, properties: C.properties, type: C.type, sourceLayerIndex: D, index: L, geometry: B ? j.geometry : Tn(C), patterns: {}, sortKey: Q };
            y.push(te);
          }
        }
        p && y.sort(function(Xe, ot) {
          return Xe.sortKey - ot.sortKey;
        });
        for (var ce = 0, oe = y; ce < oe.length; ce += 1) {
          var ge = oe[ce], we = ge.geometry, Te = ge.index, Oe = ge.sourceLayerIndex;
          if (this.hasPattern) {
            var Be = i_("line", this.layers, ge, this.zoom, i);
            this.patternFeatures.push(Be);
          } else
            this.addFeature(ge, we, Te, l, {});
          i.featureIndex.insert(r[Te].feature, we, Te, Oe, this.index);
        }
      }, to.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, to.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.patternFeatures; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, to.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, to.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, to.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = r.createVertexBuffer(this.layoutVertexArray2, hO)), this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, cO), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, to.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, to.prototype.lineFeatureClips = function(r) {
        if (r.properties && r.properties.hasOwnProperty("mapbox_clip_start") && r.properties.hasOwnProperty("mapbox_clip_end"))
          return { start: +r.properties.mapbox_clip_start, end: +r.properties.mapbox_clip_end };
      }, to.prototype.addFeature = function(r, i, l, p, y) {
        var v = this.layers[0].layout, x = v.get("line-join").evaluate(r, {}), S = v.get("line-cap"), C = v.get("line-miter-limit"), A = v.get("line-round-limit");
        this.lineClips = this.lineFeatureClips(r);
        for (var L = 0, D = i; L < D.length; L += 1)
          this.addLine(D[L], r, x, S, C, A);
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, to.prototype.addLine = function(r, i, l, p, y, v) {
        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
          this.lineClipsArray.push(this.lineClips);
          for (var x = 0; x < r.length - 1; x++)
            this.totalDistance += r[x].dist(r[x + 1]);
          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
        }
        for (var S = fO[i.type] === "Polygon", C = r.length; C >= 2 && r[C - 1].equals(r[C - 2]); )
          C--;
        for (var A = 0; A < C - 1 && r[A].equals(r[A + 1]); )
          A++;
        if (!(C < (S ? 3 : 2))) {
          l === "bevel" && (y = 1.05);
          var L, D = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, B = this.segments.prepareSegment(10 * C, this.layoutVertexArray, this.indexArray), j = void 0, Q = void 0, te = void 0, ce = void 0;
          this.e1 = this.e2 = -1, S && (ce = r[A].sub(L = r[C - 2])._unit()._perp());
          for (var oe = A; oe < C; oe++)
            if (!(Q = oe === C - 1 ? S ? r[A + 1] : void 0 : r[oe + 1]) || !r[oe].equals(Q)) {
              ce && (te = ce), L && (j = L), L = r[oe], ce = Q ? Q.sub(L)._unit()._perp() : te;
              var ge = (te = te || ce).add(ce);
              ge.x === 0 && ge.y === 0 || ge._unit();
              var we = te.x * ce.x + te.y * ce.y, Te = ge.x * ce.x + ge.y * ce.y, Oe = Te !== 0 ? 1 / Te : 1 / 0, Be = 2 * Math.sqrt(2 - 2 * Te), Xe = Te < pO && j && Q, ot = te.x * ce.y - te.y * ce.x > 0;
              if (Xe && oe > A) {
                var At = L.dist(j);
                if (At > 2 * D) {
                  var dt = L.sub(L.sub(j)._mult(D / At)._round());
                  this.updateDistance(j, dt), this.addCurrentVertex(dt, te, 0, 0, B), j = dt;
                }
              }
              var Nt = j && Q, yt = Nt ? l : S ? "butt" : p;
              if (Nt && yt === "round" && (Oe < v ? yt = "miter" : Oe <= 2 && (yt = "fakeround")), yt === "miter" && Oe > y && (yt = "bevel"), yt === "bevel" && (Oe > 2 && (yt = "flipbevel"), Oe < y && (yt = "miter")), j && this.updateDistance(j, L), yt === "miter")
                ge._mult(Oe), this.addCurrentVertex(L, ge, 0, 0, B);
              else if (yt === "flipbevel") {
                if (Oe > 100)
                  ge = ce.mult(-1);
                else {
                  var ar = Oe * te.add(ce).mag() / te.sub(ce).mag();
                  ge._perp()._mult(ar * (ot ? -1 : 1));
                }
                this.addCurrentVertex(L, ge, 0, 0, B), this.addCurrentVertex(L, ge.mult(-1), 0, 0, B);
              } else if (yt === "bevel" || yt === "fakeround") {
                var $t = -Math.sqrt(Oe * Oe - 1), Mt = ot ? $t : 0, fr = ot ? 0 : $t;
                if (j && this.addCurrentVertex(L, te, Mt, fr, B), yt === "fakeround")
                  for (var rr = Math.round(180 * Be / Math.PI / 20), Sr = 1; Sr < rr; Sr++) {
                    var Rt = Sr / rr;
                    if (Rt !== 0.5) {
                      var Dr = Rt - 0.5;
                      Rt += Rt * Dr * (Rt - 1) * ((1.0904 + we * (we * (3.55645 - 1.43519 * we) - 3.2452)) * Dr * Dr + (0.848013 + we * (0.215638 * we - 1.06021)));
                    }
                    var gn = ce.sub(te)._mult(Rt)._add(te)._unit()._mult(ot ? -1 : 1);
                    this.addHalfVertex(L, gn.x, gn.y, !1, ot, 0, B);
                  }
                Q && this.addCurrentVertex(L, ce, -Mt, -fr, B);
              } else if (yt === "butt")
                this.addCurrentVertex(L, ge, 0, 0, B);
              else if (yt === "square") {
                var Cn = j ? 1 : -1;
                this.addCurrentVertex(L, ge, Cn, Cn, B);
              } else
                yt === "round" && (j && (this.addCurrentVertex(L, te, 0, 0, B), this.addCurrentVertex(L, te, 1, 1, B, !0)), Q && (this.addCurrentVertex(L, ce, -1, -1, B, !0), this.addCurrentVertex(L, ce, 0, 0, B)));
              if (Xe && oe < C - 1) {
                var Mn = L.dist(Q);
                if (Mn > 2 * D) {
                  var vn = L.add(Q.sub(L)._mult(D / Mn)._round());
                  this.updateDistance(L, vn), this.addCurrentVertex(vn, ce, 0, 0, B), L = vn;
                }
              }
            }
        }
      }, to.prototype.addCurrentVertex = function(r, i, l, p, y, v) {
        v === void 0 && (v = !1);
        var x = i.y * p - i.x, S = -i.y - i.x * p;
        this.addHalfVertex(r, i.x + i.y * l, i.y - i.x * l, v, !1, l, y), this.addHalfVertex(r, x, S, v, !0, -p, y), this.distance > xx / 2 && this.totalDistance === 0 && (this.distance = 0, this.addCurrentVertex(r, i, l, p, y, v));
      }, to.prototype.addHalfVertex = function(r, i, l, p, y, v, x) {
        var S = 0.5 * (this.lineClips ? this.scaledDistance * (xx - 1) : this.scaledDistance);
        this.layoutVertexArray.emplaceBack((r.x << 1) + (p ? 1 : 0), (r.y << 1) + (y ? 1 : 0), Math.round(63 * i) + 128, Math.round(63 * l) + 128, 1 + (v === 0 ? 0 : v < 0 ? -1 : 1) | (63 & S) << 2, S >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
        var C = x.vertexLength++;
        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, C), x.primitiveLength++), y ? this.e2 = C : this.e1 = C;
      }, to.prototype.updateScaledDistance = function() {
        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
      }, to.prototype.updateDistance = function(r, i) {
        this.distance += r.dist(i), this.updateScaledDistance();
      }, wt("LineBucket", to, { omit: ["layers", "patternFeatures"] });
      var dO = new Mi({ "line-cap": new Lt(G.layout_line["line-cap"]), "line-join": new Tt(G.layout_line["line-join"]), "line-miter-limit": new Lt(G.layout_line["line-miter-limit"]), "line-round-limit": new Lt(G.layout_line["line-round-limit"]), "line-sort-key": new Tt(G.layout_line["line-sort-key"]) }), bx = { paint: new Mi({ "line-opacity": new Tt(G.paint_line["line-opacity"]), "line-color": new Tt(G.paint_line["line-color"]), "line-translate": new Lt(G.paint_line["line-translate"]), "line-translate-anchor": new Lt(G.paint_line["line-translate-anchor"]), "line-width": new Tt(G.paint_line["line-width"]), "line-gap-width": new Tt(G.paint_line["line-gap-width"]), "line-offset": new Tt(G.paint_line["line-offset"]), "line-blur": new Tt(G.paint_line["line-blur"]), "line-dasharray": new Gi(G.paint_line["line-dasharray"]), "line-pattern": new bh(G.paint_line["line-pattern"]), "line-gradient": new ua(G.paint_line["line-gradient"]) }), layout: dO }, wx = new (function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.possiblyEvaluate = function(l, p) {
          return p = new mr(Math.floor(p.zoom), { now: p.now, fadeDuration: p.fadeDuration, zoomHistory: p.zoomHistory, transition: p.transition }), r.prototype.possiblyEvaluate.call(this, l, p);
        }, i.prototype.evaluate = function(l, p, y, v) {
          return p = K({}, p, { zoom: Math.floor(p.zoom) }), r.prototype.evaluate.call(this, l, p, y, v);
        }, i;
      }(Tt))(bx.paint.properties["line-width"].specification);
      wx.useIntegerZoom = !0;
      var mO = function(r) {
        function i(l) {
          r.call(this, l, bx), this.gradientVersion = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
          l === "line-gradient" && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof lo, this.gradientVersion = (this.gradientVersion + 1) % P);
        }, i.prototype.gradientExpression = function() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }, i.prototype.recalculate = function(l, p) {
          r.prototype.recalculate.call(this, l, p), this.paint._values["line-floorwidth"] = wx.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, l);
        }, i.prototype.createBucket = function(l) {
          return new to(l);
        }, i.prototype.queryRadius = function(l) {
          var p = l, y = Ex(Sa("line-width", this, p), Sa("line-gap-width", this, p)), v = Sa("line-offset", this, p);
          return y / 2 + Math.abs(v) + li(this.paint.get("line-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C) {
          var A = qa(l, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), S.angle, C), L = C / 2 * Ex(this.paint.get("line-width").evaluate(p, y), this.paint.get("line-gap-width").evaluate(p, y)), D = this.paint.get("line-offset").evaluate(p, y);
          return D && (v = function(B, j) {
            for (var Q = [], te = new T(0, 0), ce = 0; ce < B.length; ce++) {
              for (var oe = B[ce], ge = [], we = 0; we < oe.length; we++) {
                var Te = oe[we], Oe = oe[we + 1], Be = we === 0 ? te : Te.sub(oe[we - 1])._unit()._perp(), Xe = we === oe.length - 1 ? te : Oe.sub(Te)._unit()._perp(), ot = Be._add(Xe)._unit();
                ot._mult(1 / (ot.x * Xe.x + ot.y * Xe.y)), ge.push(ot._mult(j)._add(Te));
              }
              Q.push(ge);
            }
            return Q;
          }(v, D * C)), function(B, j, Q) {
            for (var te = 0; te < j.length; te++) {
              var ce = j[te];
              if (B.length >= 3) {
                for (var oe = 0; oe < ce.length; oe++)
                  if (Ea(B, ce[oe]))
                    return !0;
              }
              if (Zo(B, ce, Q))
                return !0;
            }
            return !1;
          }(A, v, L);
        }, i.prototype.isTileClipped = function() {
          return !0;
        }, i;
      }(ba);
      function Ex(r, i) {
        return i > 0 ? i + 2 * r : r;
      }
      var yO = yi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), gO = yi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), vO = (yi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), yi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }])), Sx = (yi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]), yi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), _O = yi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function xO(r, i, l) {
        return r.sections.forEach(function(p) {
          p.text = function(y, v, x) {
            var S = v.layout.get("text-transform").evaluate(x, {});
            return S === "uppercase" ? y = y.toLocaleUpperCase() : S === "lowercase" && (y = y.toLocaleLowerCase()), Io.applyArabicShaping && (y = Io.applyArabicShaping(y)), y;
          }(p.text, i, l);
        }), r;
      }
      yi([{ name: "triangle", components: 3, type: "Uint16" }]), yi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), yi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), yi([{ type: "Float32", name: "offsetX" }]), yi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
      var bp = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" }, Tx = function(r, i, l, p, y) {
        var v, x, S = 8 * y - p - 1, C = (1 << S) - 1, A = C >> 1, L = -7, D = l ? y - 1 : 0, B = l ? -1 : 1, j = r[i + D];
        for (D += B, v = j & (1 << -L) - 1, j >>= -L, L += S; L > 0; v = 256 * v + r[i + D], D += B, L -= 8)
          ;
        for (x = v & (1 << -L) - 1, v >>= -L, L += p; L > 0; x = 256 * x + r[i + D], D += B, L -= 8)
          ;
        if (v === 0)
          v = 1 - A;
        else {
          if (v === C)
            return x ? NaN : 1 / 0 * (j ? -1 : 1);
          x += Math.pow(2, p), v -= A;
        }
        return (j ? -1 : 1) * x * Math.pow(2, v - p);
      }, Mx = function(r, i, l, p, y, v) {
        var x, S, C, A = 8 * v - y - 1, L = (1 << A) - 1, D = L >> 1, B = y === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, j = p ? 0 : v - 1, Q = p ? 1 : -1, te = i < 0 || i === 0 && 1 / i < 0 ? 1 : 0;
        for (i = Math.abs(i), isNaN(i) || i === 1 / 0 ? (S = isNaN(i) ? 1 : 0, x = L) : (x = Math.floor(Math.log(i) / Math.LN2), i * (C = Math.pow(2, -x)) < 1 && (x--, C *= 2), (i += x + D >= 1 ? B / C : B * Math.pow(2, 1 - D)) * C >= 2 && (x++, C /= 2), x + D >= L ? (S = 0, x = L) : x + D >= 1 ? (S = (i * C - 1) * Math.pow(2, y), x += D) : (S = i * Math.pow(2, D - 1) * Math.pow(2, y), x = 0)); y >= 8; r[l + j] = 255 & S, j += Q, S /= 256, y -= 8)
          ;
        for (x = x << y | S, A += y; A > 0; r[l + j] = 255 & x, j += Q, x /= 256, A -= 8)
          ;
        r[l + j - Q] |= 128 * te;
      }, Vm = tn;
      function tn(r) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(r) ? r : new Uint8Array(r || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      tn.Varint = 0, tn.Fixed64 = 1, tn.Bytes = 2, tn.Fixed32 = 5;
      var Ix = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
      function wl(r) {
        return r.type === tn.Bytes ? r.readVarint() + r.pos : r.pos + 1;
      }
      function Ph(r, i, l) {
        return l ? 4294967296 * i + (r >>> 0) : 4294967296 * (i >>> 0) + (r >>> 0);
      }
      function Ox(r, i, l) {
        var p = i <= 16383 ? 1 : i <= 2097151 ? 2 : i <= 268435455 ? 3 : Math.floor(Math.log(i) / (7 * Math.LN2));
        l.realloc(p);
        for (var y = l.pos - 1; y >= r; y--)
          l.buf[y + p] = l.buf[y];
      }
      function bO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeVarint(r[l]);
      }
      function wO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSVarint(r[l]);
      }
      function EO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFloat(r[l]);
      }
      function SO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeDouble(r[l]);
      }
      function TO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeBoolean(r[l]);
      }
      function MO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFixed32(r[l]);
      }
      function IO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSFixed32(r[l]);
      }
      function OO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFixed64(r[l]);
      }
      function CO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSFixed64(r[l]);
      }
      function Um(r, i) {
        return (r[i] | r[i + 1] << 8 | r[i + 2] << 16) + 16777216 * r[i + 3];
      }
      function kh(r, i, l) {
        r[l] = i, r[l + 1] = i >>> 8, r[l + 2] = i >>> 16, r[l + 3] = i >>> 24;
      }
      function Cx(r, i) {
        return (r[i] | r[i + 1] << 8 | r[i + 2] << 16) + (r[i + 3] << 24);
      }
      function AO(r, i, l) {
        r === 1 && l.readMessage(PO, i);
      }
      function PO(r, i, l) {
        if (r === 3) {
          var p = l.readMessage(kO, {}), y = p.width, v = p.height, x = p.left, S = p.top, C = p.advance;
          i.push({ id: p.id, bitmap: new mc({ width: y + 6, height: v + 6 }, p.bitmap), metrics: { width: y, height: v, left: x, top: S, advance: C } });
        }
      }
      function kO(r, i, l) {
        r === 1 ? i.id = l.readVarint() : r === 2 ? i.bitmap = l.readBytes() : r === 3 ? i.width = l.readVarint() : r === 4 ? i.height = l.readVarint() : r === 5 ? i.left = l.readSVarint() : r === 6 ? i.top = l.readSVarint() : r === 7 && (i.advance = l.readVarint());
      }
      function Ax(r) {
        for (var i = 0, l = 0, p = 0, y = r; p < y.length; p += 1) {
          var v = y[p];
          i += v.w * v.h, l = Math.max(l, v.w);
        }
        r.sort(function(te, ce) {
          return ce.h - te.h;
        });
        for (var x = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(i / 0.95)), l), h: 1 / 0 }], S = 0, C = 0, A = 0, L = r; A < L.length; A += 1)
          for (var D = L[A], B = x.length - 1; B >= 0; B--) {
            var j = x[B];
            if (!(D.w > j.w || D.h > j.h)) {
              if (D.x = j.x, D.y = j.y, C = Math.max(C, D.y + D.h), S = Math.max(S, D.x + D.w), D.w === j.w && D.h === j.h) {
                var Q = x.pop();
                B < x.length && (x[B] = Q);
              } else
                D.h === j.h ? (j.x += D.w, j.w -= D.w) : D.w === j.w ? (j.y += D.h, j.h -= D.h) : (x.push({ x: j.x + D.w, y: j.y, w: j.w - D.w, h: D.h }), j.y += D.h, j.h -= D.h);
              break;
            }
          }
        return { w: S, h: C, fill: i / (S * C) || 0 };
      }
      tn.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(r, i, l) {
        for (l = l || this.length; this.pos < l; ) {
          var p = this.readVarint(), y = p >> 3, v = this.pos;
          this.type = 7 & p, r(y, i, this), this.pos === v && this.skip(p);
        }
        return i;
      }, readMessage: function(r, i) {
        return this.readFields(r, i, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var r = Um(this.buf, this.pos);
        return this.pos += 4, r;
      }, readSFixed32: function() {
        var r = Cx(this.buf, this.pos);
        return this.pos += 4, r;
      }, readFixed64: function() {
        var r = Um(this.buf, this.pos) + 4294967296 * Um(this.buf, this.pos + 4);
        return this.pos += 8, r;
      }, readSFixed64: function() {
        var r = Um(this.buf, this.pos) + 4294967296 * Cx(this.buf, this.pos + 4);
        return this.pos += 8, r;
      }, readFloat: function() {
        var r = Tx(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, r;
      }, readDouble: function() {
        var r = Tx(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, r;
      }, readVarint: function(r) {
        var i, l, p = this.buf;
        return i = 127 & (l = p[this.pos++]), l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 7, l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 14, l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 21, l < 128 ? i : function(y, v, x) {
          var S, C, A = x.buf;
          if (S = (112 & (C = A[x.pos++])) >> 4, C < 128 || (S |= (127 & (C = A[x.pos++])) << 3, C < 128) || (S |= (127 & (C = A[x.pos++])) << 10, C < 128) || (S |= (127 & (C = A[x.pos++])) << 17, C < 128) || (S |= (127 & (C = A[x.pos++])) << 24, C < 128) || (S |= (1 & (C = A[x.pos++])) << 31, C < 128))
            return Ph(y, S, v);
          throw new Error("Expected varint not more than 10 bytes");
        }(i |= (15 & (l = p[this.pos])) << 28, r, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var r = this.readVarint();
        return r % 2 == 1 ? (r + 1) / -2 : r / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var r = this.readVarint() + this.pos, i = this.pos;
        return this.pos = r, r - i >= 12 && Ix ? function(l, p, y) {
          return Ix.decode(l.subarray(p, y));
        }(this.buf, i, r) : function(l, p, y) {
          for (var v = "", x = p; x < y; ) {
            var S, C, A, L = l[x], D = null, B = L > 239 ? 4 : L > 223 ? 3 : L > 191 ? 2 : 1;
            if (x + B > y)
              break;
            B === 1 ? L < 128 && (D = L) : B === 2 ? (192 & (S = l[x + 1])) == 128 && (D = (31 & L) << 6 | 63 & S) <= 127 && (D = null) : B === 3 ? (C = l[x + 2], (192 & (S = l[x + 1])) == 128 && (192 & C) == 128 && ((D = (15 & L) << 12 | (63 & S) << 6 | 63 & C) <= 2047 || D >= 55296 && D <= 57343) && (D = null)) : B === 4 && (C = l[x + 2], A = l[x + 3], (192 & (S = l[x + 1])) == 128 && (192 & C) == 128 && (192 & A) == 128 && ((D = (15 & L) << 18 | (63 & S) << 12 | (63 & C) << 6 | 63 & A) <= 65535 || D >= 1114112) && (D = null)), D === null ? (D = 65533, B = 1) : D > 65535 && (D -= 65536, v += String.fromCharCode(D >>> 10 & 1023 | 55296), D = 56320 | 1023 & D), v += String.fromCharCode(D), x += B;
          }
          return v;
        }(this.buf, i, r);
      }, readBytes: function() {
        var r = this.readVarint() + this.pos, i = this.buf.subarray(this.pos, r);
        return this.pos = r, i;
      }, readPackedVarint: function(r, i) {
        if (this.type !== tn.Bytes)
          return r.push(this.readVarint(i));
        var l = wl(this);
        for (r = r || []; this.pos < l; )
          r.push(this.readVarint(i));
        return r;
      }, readPackedSVarint: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSVarint());
        var i = wl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSVarint());
        return r;
      }, readPackedBoolean: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readBoolean());
        var i = wl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readBoolean());
        return r;
      }, readPackedFloat: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFloat());
        var i = wl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFloat());
        return r;
      }, readPackedDouble: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readDouble());
        var i = wl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readDouble());
        return r;
      }, readPackedFixed32: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFixed32());
        var i = wl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFixed32());
        return r;
      }, readPackedSFixed32: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSFixed32());
        var i = wl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSFixed32());
        return r;
      }, readPackedFixed64: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFixed64());
        var i = wl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFixed64());
        return r;
      }, readPackedSFixed64: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSFixed64());
        var i = wl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSFixed64());
        return r;
      }, skip: function(r) {
        var i = 7 & r;
        if (i === tn.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (i === tn.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (i === tn.Fixed32)
          this.pos += 4;
        else {
          if (i !== tn.Fixed64)
            throw new Error("Unimplemented type: " + i);
          this.pos += 8;
        }
      }, writeTag: function(r, i) {
        this.writeVarint(r << 3 | i);
      }, realloc: function(r) {
        for (var i = this.length || 16; i < this.pos + r; )
          i *= 2;
        if (i !== this.length) {
          var l = new Uint8Array(i);
          l.set(this.buf), this.buf = l, this.length = i;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(r) {
        this.realloc(4), kh(this.buf, r, this.pos), this.pos += 4;
      }, writeSFixed32: function(r) {
        this.realloc(4), kh(this.buf, r, this.pos), this.pos += 4;
      }, writeFixed64: function(r) {
        this.realloc(8), kh(this.buf, -1 & r, this.pos), kh(this.buf, Math.floor(r * (1 / 4294967296)), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(r) {
        this.realloc(8), kh(this.buf, -1 & r, this.pos), kh(this.buf, Math.floor(r * (1 / 4294967296)), this.pos + 4), this.pos += 8;
      }, writeVarint: function(r) {
        (r = +r || 0) > 268435455 || r < 0 ? function(i, l) {
          var p, y;
          if (i >= 0 ? (p = i % 4294967296 | 0, y = i / 4294967296 | 0) : (y = ~(-i / 4294967296), 4294967295 ^ (p = ~(-i % 4294967296)) ? p = p + 1 | 0 : (p = 0, y = y + 1 | 0)), i >= 18446744073709552e3 || i < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          l.realloc(10), function(v, x, S) {
            S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, S.buf[S.pos] = 127 & (v >>>= 7);
          }(p, 0, l), function(v, x) {
            var S = (7 & v) << 4;
            x.buf[x.pos++] |= S | ((v >>>= 3) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v)))));
          }(y, l);
        }(r, this) : (this.realloc(4), this.buf[this.pos++] = 127 & r | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = r >>> 7 & 127))));
      }, writeSVarint: function(r) {
        this.writeVarint(r < 0 ? 2 * -r - 1 : 2 * r);
      }, writeBoolean: function(r) {
        this.writeVarint(Boolean(r));
      }, writeString: function(r) {
        r = String(r), this.realloc(4 * r.length), this.pos++;
        var i = this.pos;
        this.pos = function(p, y, v) {
          for (var x, S, C = 0; C < y.length; C++) {
            if ((x = y.charCodeAt(C)) > 55295 && x < 57344) {
              if (!S) {
                x > 56319 || C + 1 === y.length ? (p[v++] = 239, p[v++] = 191, p[v++] = 189) : S = x;
                continue;
              }
              if (x < 56320) {
                p[v++] = 239, p[v++] = 191, p[v++] = 189, S = x;
                continue;
              }
              x = S - 55296 << 10 | x - 56320 | 65536, S = null;
            } else
              S && (p[v++] = 239, p[v++] = 191, p[v++] = 189, S = null);
            x < 128 ? p[v++] = x : (x < 2048 ? p[v++] = x >> 6 | 192 : (x < 65536 ? p[v++] = x >> 12 | 224 : (p[v++] = x >> 18 | 240, p[v++] = x >> 12 & 63 | 128), p[v++] = x >> 6 & 63 | 128), p[v++] = 63 & x | 128);
          }
          return v;
        }(this.buf, r, this.pos);
        var l = this.pos - i;
        l >= 128 && Ox(i, l, this), this.pos = i - 1, this.writeVarint(l), this.pos += l;
      }, writeFloat: function(r) {
        this.realloc(4), Mx(this.buf, r, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(r) {
        this.realloc(8), Mx(this.buf, r, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(r) {
        var i = r.length;
        this.writeVarint(i), this.realloc(i);
        for (var l = 0; l < i; l++)
          this.buf[this.pos++] = r[l];
      }, writeRawMessage: function(r, i) {
        this.pos++;
        var l = this.pos;
        r(i, this);
        var p = this.pos - l;
        p >= 128 && Ox(l, p, this), this.pos = l - 1, this.writeVarint(p), this.pos += p;
      }, writeMessage: function(r, i, l) {
        this.writeTag(r, tn.Bytes), this.writeRawMessage(i, l);
      }, writePackedVarint: function(r, i) {
        i.length && this.writeMessage(r, bO, i);
      }, writePackedSVarint: function(r, i) {
        i.length && this.writeMessage(r, wO, i);
      }, writePackedBoolean: function(r, i) {
        i.length && this.writeMessage(r, TO, i);
      }, writePackedFloat: function(r, i) {
        i.length && this.writeMessage(r, EO, i);
      }, writePackedDouble: function(r, i) {
        i.length && this.writeMessage(r, SO, i);
      }, writePackedFixed32: function(r, i) {
        i.length && this.writeMessage(r, MO, i);
      }, writePackedSFixed32: function(r, i) {
        i.length && this.writeMessage(r, IO, i);
      }, writePackedFixed64: function(r, i) {
        i.length && this.writeMessage(r, OO, i);
      }, writePackedSFixed64: function(r, i) {
        i.length && this.writeMessage(r, CO, i);
      }, writeBytesField: function(r, i) {
        this.writeTag(r, tn.Bytes), this.writeBytes(i);
      }, writeFixed32Field: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeFixed32(i);
      }, writeSFixed32Field: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeSFixed32(i);
      }, writeFixed64Field: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeFixed64(i);
      }, writeSFixed64Field: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeSFixed64(i);
      }, writeVarintField: function(r, i) {
        this.writeTag(r, tn.Varint), this.writeVarint(i);
      }, writeSVarintField: function(r, i) {
        this.writeTag(r, tn.Varint), this.writeSVarint(i);
      }, writeStringField: function(r, i) {
        this.writeTag(r, tn.Bytes), this.writeString(i);
      }, writeFloatField: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeFloat(i);
      }, writeDoubleField: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeDouble(i);
      }, writeBooleanField: function(r, i) {
        this.writeVarintField(r, Boolean(i));
      } };
      var jm = function(r, i) {
        var l = i.pixelRatio, p = i.version, y = i.stretchX, v = i.stretchY, x = i.content;
        this.paddedRect = r, this.pixelRatio = l, this.stretchX = y, this.stretchY = v, this.content = x, this.version = p;
      }, wp = { tl: { configurable: !0 }, br: { configurable: !0 }, tlbr: { configurable: !0 }, displaySize: { configurable: !0 } };
      wp.tl.get = function() {
        return [this.paddedRect.x + 1, this.paddedRect.y + 1];
      }, wp.br.get = function() {
        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
      }, wp.tlbr.get = function() {
        return this.tl.concat(this.br);
      }, wp.displaySize.get = function() {
        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
      }, Object.defineProperties(jm.prototype, wp);
      var Ep = function(r, i) {
        var l = {}, p = {};
        this.haveRenderCallbacks = [];
        var y = [];
        this.addImages(r, l, y), this.addImages(i, p, y);
        var v = Ax(y), x = new yo({ width: v.w || 1, height: v.h || 1 });
        for (var S in r) {
          var C = r[S], A = l[S].paddedRect;
          yo.copy(C.data, x, { x: 0, y: 0 }, { x: A.x + 1, y: A.y + 1 }, C.data);
        }
        for (var L in i) {
          var D = i[L], B = p[L].paddedRect, j = B.x + 1, Q = B.y + 1, te = D.data.width, ce = D.data.height;
          yo.copy(D.data, x, { x: 0, y: 0 }, { x: j, y: Q }, D.data), yo.copy(D.data, x, { x: 0, y: ce - 1 }, { x: j, y: Q - 1 }, { width: te, height: 1 }), yo.copy(D.data, x, { x: 0, y: 0 }, { x: j, y: Q + ce }, { width: te, height: 1 }), yo.copy(D.data, x, { x: te - 1, y: 0 }, { x: j - 1, y: Q }, { width: 1, height: ce }), yo.copy(D.data, x, { x: 0, y: 0 }, { x: j + te, y: Q }, { width: 1, height: ce });
        }
        this.image = x, this.iconPositions = l, this.patternPositions = p;
      };
      Ep.prototype.addImages = function(r, i, l) {
        for (var p in r) {
          var y = r[p], v = { x: 0, y: 0, w: y.data.width + 2, h: y.data.height + 2 };
          l.push(v), i[p] = new jm(v, y), y.hasRenderCallback && this.haveRenderCallbacks.push(p);
        }
      }, Ep.prototype.patchUpdatedImages = function(r, i) {
        for (var l in r.dispatchRenderCallbacks(this.haveRenderCallbacks), r.updatedImages)
          this.patchUpdatedImage(this.iconPositions[l], r.getImage(l), i), this.patchUpdatedImage(this.patternPositions[l], r.getImage(l), i);
      }, Ep.prototype.patchUpdatedImage = function(r, i, l) {
        if (r && i && r.version !== i.version) {
          r.version = i.version;
          var p = r.tl;
          l.update(i.data, void 0, { x: p[0], y: p[1] });
        }
      }, wt("ImagePosition", jm), wt("ImageAtlas", Ep);
      var Xo = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, Lh = function() {
        this.scale = 1, this.fontStack = "", this.imageName = null;
      };
      Lh.forText = function(r, i) {
        var l = new Lh();
        return l.scale = r || 1, l.fontStack = i, l;
      }, Lh.forImage = function(r) {
        var i = new Lh();
        return i.imageName = r, i;
      };
      var $i = function() {
        this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
      };
      function Gm(r, i, l, p, y, v, x, S, C, A, L, D, B, j, Q, te) {
        var ce, oe = $i.fromFeature(r, y);
        D === Xo.vertical && oe.verticalizePunctuation();
        var ge = Io.processBidirectionalText, we = Io.processStyledBidirectionalText;
        if (ge && oe.sections.length === 1) {
          ce = [];
          for (var Te = 0, Oe = ge(oe.toString(), a_(oe, A, v, i, p, j, Q)); Te < Oe.length; Te += 1) {
            var Be = Oe[Te], Xe = new $i();
            Xe.text = Be, Xe.sections = oe.sections;
            for (var ot = 0; ot < Be.length; ot++)
              Xe.sectionIndex.push(0);
            ce.push(Xe);
          }
        } else if (we) {
          ce = [];
          for (var At = 0, dt = we(oe.text, oe.sectionIndex, a_(oe, A, v, i, p, j, Q)); At < dt.length; At += 1) {
            var Nt = dt[At], yt = new $i();
            yt.text = Nt[0], yt.sectionIndex = Nt[1], yt.sections = oe.sections, ce.push(yt);
          }
        } else
          ce = function(Mt, fr) {
            for (var rr = [], Sr = Mt.text, Rt = 0, Dr = 0, gn = fr; Dr < gn.length; Dr += 1) {
              var Cn = gn[Dr];
              rr.push(Mt.substring(Rt, Cn)), Rt = Cn;
            }
            return Rt < Sr.length && rr.push(Mt.substring(Rt, Sr.length)), rr;
          }(oe, a_(oe, A, v, i, p, j, Q));
        var ar = [], $t = { positionedLines: ar, text: oe.toString(), top: L[1], bottom: L[1], left: L[0], right: L[0], writingMode: D, iconsInText: !1, verticalizable: !1 };
        return function(Mt, fr, rr, Sr, Rt, Dr, gn, Cn, Mn, vn, An, ui) {
          for (var ci = 0, Wi = -17, _i = 0, Hi = 0, Dn = Cn === "right" ? 1 : Cn === "left" ? 0 : 0.5, xi = 0, vr = 0, Xr = Rt; vr < Xr.length; vr += 1) {
            var $r = Xr[vr];
            $r.trim();
            var Or = $r.getMaxScale(), ro = 24 * (Or - 1), Di = { positionedGlyphs: [], lineOffset: 0 };
            Mt.positionedLines[xi] = Di;
            var sn = Di.positionedGlyphs, qn = 0;
            if ($r.length()) {
              for (var Ni = 0; Ni < $r.length(); Ni++) {
                var Nr = $r.getSection(Ni), Cs = $r.getSectionIndex(Ni), Ko = $r.getCharCode(Ni), As = 0, Nn = null, Ps = null, Ta = null, Uh = 24, _c = !(Mn === Xo.horizontal || !An && !vh(Ko) || An && (qm[Ko] || (Ml = Ko, ct.Arabic(Ml) || ct["Arabic Supplement"](Ml) || ct["Arabic Extended-A"](Ml) || ct["Arabic Presentation Forms-A"](Ml) || ct["Arabic Presentation Forms-B"](Ml))));
                if (Nr.imageName) {
                  var jh = Sr[Nr.imageName];
                  if (!jh)
                    continue;
                  Ta = Nr.imageName, Mt.iconsInText = Mt.iconsInText || !0, Ps = jh.paddedRect;
                  var Tl = jh.displaySize;
                  Nr.scale = 24 * Nr.scale / ui, As = ro + (24 - Tl[1] * Nr.scale), Uh = (Nn = { width: Tl[0], height: Tl[1], left: 1, top: -3, advance: _c ? Tl[1] : Tl[0] }).advance;
                  var Gh = _c ? Tl[0] * Nr.scale - 24 * Or : Tl[1] * Nr.scale - 24 * Or;
                  Gh > 0 && Gh > qn && (qn = Gh);
                } else {
                  var Qm = rr[Nr.fontStack], qh = Qm && Qm[Ko];
                  if (qh && qh.rect)
                    Ps = qh.rect, Nn = qh.metrics;
                  else {
                    var Mp = fr[Nr.fontStack], ey = Mp && Mp[Ko];
                    if (!ey)
                      continue;
                    Nn = ey.metrics;
                  }
                  As = 24 * (Or - Nr.scale);
                }
                _c ? (Mt.verticalizable = !0, sn.push({ glyph: Ko, imageName: Ta, x: ci, y: Wi + As, vertical: _c, scale: Nr.scale, fontStack: Nr.fontStack, sectionIndex: Cs, metrics: Nn, rect: Ps }), ci += Uh * Nr.scale + vn) : (sn.push({ glyph: Ko, imageName: Ta, x: ci, y: Wi + As, vertical: _c, scale: Nr.scale, fontStack: Nr.fontStack, sectionIndex: Cs, metrics: Nn, rect: Ps }), ci += Nn.advance * Nr.scale + vn);
              }
              sn.length !== 0 && (_i = Math.max(ci - vn, _i), DO(sn, 0, sn.length - 1, Dn, qn)), ci = 0;
              var ty = Dr * Or + qn;
              Di.lineOffset = Math.max(qn, ro), Wi += ty, Hi = Math.max(ty, Hi), ++xi;
            } else
              Wi += Dr, ++xi;
          }
          var Ml, Ip = Wi - -17, $h = s_(gn), uu = $h.horizontalAlign, Wh = $h.verticalAlign;
          (function(ry, ny, Op, Cp, iy, Ap, Pp, kp, oy) {
            var Hh, ay = (ny - Op) * iy;
            Hh = Ap !== Pp ? -kp * Cp - -17 : (-Cp * oy + 0.5) * Pp;
            for (var Zh = 0, Lp = ry; Zh < Lp.length; Zh += 1)
              for (var xc = 0, Dp = Lp[Zh].positionedGlyphs; xc < Dp.length; xc += 1) {
                var Xh = Dp[xc];
                Xh.x += ay, Xh.y += Hh;
              }
          })(Mt.positionedLines, Dn, uu, Wh, _i, Hi, Dr, Ip, Rt.length), Mt.top += -Wh * Ip, Mt.bottom = Mt.top + Ip, Mt.left += -uu * _i, Mt.right = Mt.left + _i;
        }($t, i, l, p, ce, x, S, C, D, A, B, te), !function(Mt) {
          for (var fr = 0, rr = Mt; fr < rr.length; fr += 1)
            if (rr[fr].positionedGlyphs.length !== 0)
              return !1;
          return !0;
        }(ar) && $t;
      }
      $i.fromFeature = function(r, i) {
        for (var l = new $i(), p = 0; p < r.sections.length; p++) {
          var y = r.sections[p];
          y.image ? l.addImageSection(y) : l.addTextSection(y, i);
        }
        return l;
      }, $i.prototype.length = function() {
        return this.text.length;
      }, $i.prototype.getSection = function(r) {
        return this.sections[this.sectionIndex[r]];
      }, $i.prototype.getSectionIndex = function(r) {
        return this.sectionIndex[r];
      }, $i.prototype.getCharCode = function(r) {
        return this.text.charCodeAt(r);
      }, $i.prototype.verticalizePunctuation = function() {
        this.text = function(r) {
          for (var i = "", l = 0; l < r.length; l++) {
            var p = r.charCodeAt(l + 1) || null, y = r.charCodeAt(l - 1) || null;
            i += p && ap(p) && !bp[r[l + 1]] || y && ap(y) && !bp[r[l - 1]] || !bp[r[l]] ? r[l] : bp[r[l]];
          }
          return i;
        }(this.text);
      }, $i.prototype.trim = function() {
        for (var r = 0, i = 0; i < this.text.length && qm[this.text.charCodeAt(i)]; i++)
          r++;
        for (var l = this.text.length, p = this.text.length - 1; p >= 0 && p >= r && qm[this.text.charCodeAt(p)]; p--)
          l--;
        this.text = this.text.substring(r, l), this.sectionIndex = this.sectionIndex.slice(r, l);
      }, $i.prototype.substring = function(r, i) {
        var l = new $i();
        return l.text = this.text.substring(r, i), l.sectionIndex = this.sectionIndex.slice(r, i), l.sections = this.sections, l;
      }, $i.prototype.toString = function() {
        return this.text;
      }, $i.prototype.getMaxScale = function() {
        var r = this;
        return this.sectionIndex.reduce(function(i, l) {
          return Math.max(i, r.sections[l].scale);
        }, 0);
      }, $i.prototype.addTextSection = function(r, i) {
        this.text += r.text, this.sections.push(Lh.forText(r.scale, r.fontStack || i));
        for (var l = this.sections.length - 1, p = 0; p < r.text.length; ++p)
          this.sectionIndex.push(l);
      }, $i.prototype.addImageSection = function(r) {
        var i = r.image ? r.image.name : "";
        if (i.length !== 0) {
          var l = this.getNextImageSectionCharCode();
          l ? (this.text += String.fromCharCode(l), this.sections.push(Lh.forImage(i)), this.sectionIndex.push(this.sections.length - 1)) : at("Reached maximum number of images 6401");
        } else
          at("Can't add FormattedSection with an empty image.");
      }, $i.prototype.getNextImageSectionCharCode = function() {
        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
      };
      var qm = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Co = {};
      function Px(r, i, l, p, y, v) {
        if (i.imageName) {
          var x = p[i.imageName];
          return x ? x.displaySize[0] * i.scale * 24 / v + y : 0;
        }
        var S = l[i.fontStack], C = S && S[r];
        return C ? C.metrics.advance * i.scale + y : 0;
      }
      function kx(r, i, l, p) {
        var y = Math.pow(r - i, 2);
        return p ? r < i ? y / 2 : 2 * y : y + Math.abs(l) * l;
      }
      function LO(r, i, l) {
        var p = 0;
        return r === 10 && (p -= 1e4), l && (p += 150), r !== 40 && r !== 65288 || (p += 50), i !== 41 && i !== 65289 || (p += 50), p;
      }
      function Lx(r, i, l, p, y, v) {
        for (var x = null, S = kx(i, l, y, v), C = 0, A = p; C < A.length; C += 1) {
          var L = A[C], D = kx(i - L.x, l, y, v) + L.badness;
          D <= S && (x = L, S = D);
        }
        return { index: r, x: i, priorBreak: x, badness: S };
      }
      function a_(r, i, l, p, y, v, x) {
        if (v !== "point")
          return [];
        if (!r)
          return [];
        for (var S, C = [], A = function(ce, oe, ge, we, Te, Oe) {
          for (var Be = 0, Xe = 0; Xe < ce.length(); Xe++) {
            var ot = ce.getSection(Xe);
            Be += Px(ce.getCharCode(Xe), ot, we, Te, oe, Oe);
          }
          return Be / Math.max(1, Math.ceil(Be / ge));
        }(r, i, l, p, y, x), L = r.text.indexOf("\u200B") >= 0, D = 0, B = 0; B < r.length(); B++) {
          var j = r.getSection(B), Q = r.getCharCode(B);
          if (qm[Q] || (D += Px(Q, j, p, y, i, x)), B < r.length() - 1) {
            var te = !((S = Q) < 11904 || !(ct["Bopomofo Extended"](S) || ct.Bopomofo(S) || ct["CJK Compatibility Forms"](S) || ct["CJK Compatibility Ideographs"](S) || ct["CJK Compatibility"](S) || ct["CJK Radicals Supplement"](S) || ct["CJK Strokes"](S) || ct["CJK Symbols and Punctuation"](S) || ct["CJK Unified Ideographs Extension A"](S) || ct["CJK Unified Ideographs"](S) || ct["Enclosed CJK Letters and Months"](S) || ct["Halfwidth and Fullwidth Forms"](S) || ct.Hiragana(S) || ct["Ideographic Description Characters"](S) || ct["Kangxi Radicals"](S) || ct["Katakana Phonetic Extensions"](S) || ct.Katakana(S) || ct["Vertical Forms"](S) || ct["Yi Radicals"](S) || ct["Yi Syllables"](S)));
            (Co[Q] || te || j.imageName) && C.push(Lx(B + 1, D, A, C, LO(Q, r.getCharCode(B + 1), te && L), !1));
          }
        }
        return function ce(oe) {
          return oe ? ce(oe.priorBreak).concat(oe.index) : [];
        }(Lx(r.length(), D, A, C, 0, !0));
      }
      function s_(r) {
        var i = 0.5, l = 0.5;
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            i = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            i = 0;
        }
        switch (r) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            l = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            l = 0;
        }
        return { horizontalAlign: i, verticalAlign: l };
      }
      function DO(r, i, l, p, y) {
        if (p || y)
          for (var v = r[l], x = (r[l].x + v.metrics.advance * v.scale) * p, S = i; S <= l; S++)
            r[S].x -= x, r[S].y += y;
      }
      function Dx(r, i, l, p, y, v) {
        var x, S = r.image;
        if (S.content) {
          var C = S.content, A = S.pixelRatio || 1;
          x = [C[0] / A, C[1] / A, S.displaySize[0] - C[2] / A, S.displaySize[1] - C[3] / A];
        }
        var L, D, B, j, Q = i.left * v, te = i.right * v;
        l === "width" || l === "both" ? (j = y[0] + Q - p[3], D = y[0] + te + p[1]) : D = (j = y[0] + (Q + te - S.displaySize[0]) / 2) + S.displaySize[0];
        var ce = i.top * v, oe = i.bottom * v;
        return l === "height" || l === "both" ? (L = y[1] + ce - p[0], B = y[1] + oe + p[2]) : B = (L = y[1] + (ce + oe - S.displaySize[1]) / 2) + S.displaySize[1], { image: S, top: L, right: D, bottom: B, left: j, collisionPadding: x };
      }
      Co[10] = !0, Co[32] = !0, Co[38] = !0, Co[40] = !0, Co[41] = !0, Co[43] = !0, Co[45] = !0, Co[47] = !0, Co[173] = !0, Co[183] = !0, Co[8203] = !0, Co[8208] = !0, Co[8211] = !0, Co[8231] = !0;
      var Dh = function(r) {
        function i(l, p, y, v) {
          r.call(this, l, p), this.angle = y, v !== void 0 && (this.segment = v);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.clone = function() {
          return new i(this.x, this.y, this.angle, this.segment);
        }, i;
      }(T);
      function l_(r, i) {
        var l = i.expression;
        if (l.kind === "constant")
          return { kind: "constant", layoutSize: l.evaluate(new mr(r + 1)) };
        if (l.kind === "source")
          return { kind: "source" };
        for (var p = l.zoomStops, y = l.interpolationType, v = 0; v < p.length && p[v] <= r; )
          v++;
        for (var x = v = Math.max(0, v - 1); x < p.length && p[x] < r + 1; )
          x++;
        x = Math.min(p.length - 1, x);
        var S = p[v], C = p[x];
        return l.kind === "composite" ? { kind: "composite", minZoom: S, maxZoom: C, interpolationType: y } : { kind: "camera", minZoom: S, maxZoom: C, minSize: l.evaluate(new mr(S)), maxSize: l.evaluate(new mr(C)), interpolationType: y };
      }
      function Nx(r, i, l) {
        var p = i.uSize, y = l.lowerSize;
        return r.kind === "source" ? y / 128 : r.kind === "composite" ? jn(y / 128, l.upperSize / 128, i.uSizeT) : p;
      }
      function Rx(r, i) {
        var l = 0, p = 0;
        if (r.kind === "constant")
          p = r.layoutSize;
        else if (r.kind !== "source") {
          var y = r.interpolationType, v = y ? W(Si.interpolationFactor(y, i, r.minZoom, r.maxZoom), 0, 1) : 0;
          r.kind === "camera" ? p = jn(r.minSize, r.maxSize, v) : l = v;
        }
        return { uSizeT: l, uSize: p };
      }
      wt("Anchor", Dh);
      var NO = Object.freeze({ __proto__: null, getSizeData: l_, evaluateSizeForFeature: Nx, evaluateSizeForZoom: Rx, SIZE_PACK_FACTOR: 128 });
      function zx(r, i, l, p, y) {
        if (i.segment === void 0)
          return !0;
        for (var v = i, x = i.segment + 1, S = 0; S > -l / 2; ) {
          if (--x < 0)
            return !1;
          S -= r[x].dist(v), v = r[x];
        }
        S += r[x].dist(r[x + 1]), x++;
        for (var C = [], A = 0; S < l / 2; ) {
          var L = r[x], D = r[x + 1];
          if (!D)
            return !1;
          var B = r[x - 1].angleTo(L) - L.angleTo(D);
          for (B = Math.abs((B + 3 * Math.PI) % (2 * Math.PI) - Math.PI), C.push({ distance: S, angleDelta: B }), A += B; S - C[0].distance > p; )
            A -= C.shift().angleDelta;
          if (A > y)
            return !1;
          x++, S += L.dist(D);
        }
        return !0;
      }
      function Fx(r) {
        for (var i = 0, l = 0; l < r.length - 1; l++)
          i += r[l].dist(r[l + 1]);
        return i;
      }
      function Bx(r, i, l) {
        return r ? 0.6 * i * l : 0;
      }
      function Vx(r, i) {
        return Math.max(r ? r.right - r.left : 0, i ? i.right - i.left : 0);
      }
      function RO(r, i, l, p, y, v) {
        for (var x = Bx(l, y, v), S = Vx(l, p) * v, C = 0, A = Fx(r) / 2, L = 0; L < r.length - 1; L++) {
          var D = r[L], B = r[L + 1], j = D.dist(B);
          if (C + j > A) {
            var Q = (A - C) / j, te = jn(D.x, B.x, Q), ce = jn(D.y, B.y, Q), oe = new Dh(te, ce, B.angleTo(D), L);
            return oe._round(), !x || zx(r, oe, S, x, i) ? oe : void 0;
          }
          C += j;
        }
      }
      function zO(r, i, l, p, y, v, x, S, C) {
        var A = Bx(p, v, x), L = Vx(p, y), D = L * x, B = r[0].x === 0 || r[0].x === C || r[0].y === 0 || r[0].y === C;
        return i - D < i / 4 && (i = D + i / 4), function j(Q, te, ce, oe, ge, we, Te, Oe, Be) {
          for (var Xe = we / 2, ot = Fx(Q), At = 0, dt = te - ce, Nt = [], yt = 0; yt < Q.length - 1; yt++) {
            for (var ar = Q[yt], $t = Q[yt + 1], Mt = ar.dist($t), fr = $t.angleTo(ar); dt + ce < At + Mt; ) {
              var rr = ((dt += ce) - At) / Mt, Sr = jn(ar.x, $t.x, rr), Rt = jn(ar.y, $t.y, rr);
              if (Sr >= 0 && Sr < Be && Rt >= 0 && Rt < Be && dt - Xe >= 0 && dt + Xe <= ot) {
                var Dr = new Dh(Sr, Rt, fr, yt);
                Dr._round(), oe && !zx(Q, Dr, we, oe, ge) || Nt.push(Dr);
              }
            }
            At += Mt;
          }
          return Oe || Nt.length || Te || (Nt = j(Q, At / 2, ce, oe, ge, we, Te, !0, Be)), Nt;
        }(r, B ? i / 2 * S % i : (L / 2 + 2 * v) * x * S % i, i, A, l, D, B, !1, C);
      }
      function Ux(r, i, l, p, y) {
        for (var v = [], x = 0; x < r.length; x++)
          for (var S = r[x], C = void 0, A = 0; A < S.length - 1; A++) {
            var L = S[A], D = S[A + 1];
            L.x < i && D.x < i || (L.x < i ? L = new T(i, L.y + (i - L.x) / (D.x - L.x) * (D.y - L.y))._round() : D.x < i && (D = new T(i, L.y + (i - L.x) / (D.x - L.x) * (D.y - L.y))._round()), L.y < l && D.y < l || (L.y < l ? L = new T(L.x + (l - L.y) / (D.y - L.y) * (D.x - L.x), l)._round() : D.y < l && (D = new T(L.x + (l - L.y) / (D.y - L.y) * (D.x - L.x), l)._round()), L.x >= p && D.x >= p || (L.x >= p ? L = new T(p, L.y + (p - L.x) / (D.x - L.x) * (D.y - L.y))._round() : D.x >= p && (D = new T(p, L.y + (p - L.x) / (D.x - L.x) * (D.y - L.y))._round()), L.y >= y && D.y >= y || (L.y >= y ? L = new T(L.x + (y - L.y) / (D.y - L.y) * (D.x - L.x), y)._round() : D.y >= y && (D = new T(L.x + (y - L.y) / (D.y - L.y) * (D.x - L.x), y)._round()), C && L.equals(C[C.length - 1]) || v.push(C = [L]), C.push(D)))));
          }
        return v;
      }
      function jx(r, i, l, p) {
        var y = [], v = r.image, x = v.pixelRatio, S = v.paddedRect.w - 2, C = v.paddedRect.h - 2, A = r.right - r.left, L = r.bottom - r.top, D = v.stretchX || [[0, S]], B = v.stretchY || [[0, C]], j = function(Sr, Rt) {
          return Sr + Rt[1] - Rt[0];
        }, Q = D.reduce(j, 0), te = B.reduce(j, 0), ce = S - Q, oe = C - te, ge = 0, we = Q, Te = 0, Oe = te, Be = 0, Xe = ce, ot = 0, At = oe;
        if (v.content && p) {
          var dt = v.content;
          ge = $m(D, 0, dt[0]), Te = $m(B, 0, dt[1]), we = $m(D, dt[0], dt[2]), Oe = $m(B, dt[1], dt[3]), Be = dt[0] - ge, ot = dt[1] - Te, Xe = dt[2] - dt[0] - we, At = dt[3] - dt[1] - Oe;
        }
        var Nt = function(Sr, Rt, Dr, gn) {
          var Cn = Wm(Sr.stretch - ge, we, A, r.left), Mn = Hm(Sr.fixed - Be, Xe, Sr.stretch, Q), vn = Wm(Rt.stretch - Te, Oe, L, r.top), An = Hm(Rt.fixed - ot, At, Rt.stretch, te), ui = Wm(Dr.stretch - ge, we, A, r.left), ci = Hm(Dr.fixed - Be, Xe, Dr.stretch, Q), Wi = Wm(gn.stretch - Te, Oe, L, r.top), _i = Hm(gn.fixed - ot, At, gn.stretch, te), Hi = new T(Cn, vn), Dn = new T(ui, vn), xi = new T(ui, Wi), vr = new T(Cn, Wi), Xr = new T(Mn / x, An / x), $r = new T(ci / x, _i / x), Or = i * Math.PI / 180;
          if (Or) {
            var ro = Math.sin(Or), Di = Math.cos(Or), sn = [Di, -ro, ro, Di];
            Hi._matMult(sn), Dn._matMult(sn), vr._matMult(sn), xi._matMult(sn);
          }
          var qn = Sr.stretch + Sr.fixed, Ni = Rt.stretch + Rt.fixed;
          return { tl: Hi, tr: Dn, bl: vr, br: xi, tex: { x: v.paddedRect.x + 1 + qn, y: v.paddedRect.y + 1 + Ni, w: Dr.stretch + Dr.fixed - qn, h: gn.stretch + gn.fixed - Ni }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Xr, pixelOffsetBR: $r, minFontScaleX: Xe / x / A, minFontScaleY: At / x / L, isSDF: l };
        };
        if (p && (v.stretchX || v.stretchY))
          for (var yt = Gx(D, ce, Q), ar = Gx(B, oe, te), $t = 0; $t < yt.length - 1; $t++)
            for (var Mt = yt[$t], fr = yt[$t + 1], rr = 0; rr < ar.length - 1; rr++)
              y.push(Nt(Mt, ar[rr], fr, ar[rr + 1]));
        else
          y.push(Nt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: S + 1 }, { fixed: 0, stretch: C + 1 }));
        return y;
      }
      function $m(r, i, l) {
        for (var p = 0, y = 0, v = r; y < v.length; y += 1) {
          var x = v[y];
          p += Math.max(i, Math.min(l, x[1])) - Math.max(i, Math.min(l, x[0]));
        }
        return p;
      }
      function Gx(r, i, l) {
        for (var p = [{ fixed: -1, stretch: 0 }], y = 0, v = r; y < v.length; y += 1) {
          var x = v[y], S = x[0], C = x[1], A = p[p.length - 1];
          p.push({ fixed: S - A.stretch, stretch: A.stretch }), p.push({ fixed: S - A.stretch, stretch: A.stretch + (C - S) });
        }
        return p.push({ fixed: i + 1, stretch: l }), p;
      }
      function Wm(r, i, l, p) {
        return r / i * l + p;
      }
      function Hm(r, i, l, p) {
        return r - i * l / p;
      }
      var Zm = function(r, i, l, p, y, v, x, S, C, A) {
        if (this.boxStartIndex = r.length, C) {
          var L = v.top, D = v.bottom, B = v.collisionPadding;
          B && (L -= B[1], D += B[3]);
          var j = D - L;
          j > 0 && (j = Math.max(10, j), this.circleDiameter = j);
        } else {
          var Q = v.top * x - S, te = v.bottom * x + S, ce = v.left * x - S, oe = v.right * x + S, ge = v.collisionPadding;
          if (ge && (ce -= ge[0] * x, Q -= ge[1] * x, oe += ge[2] * x, te += ge[3] * x), A) {
            var we = new T(ce, Q), Te = new T(oe, Q), Oe = new T(ce, te), Be = new T(oe, te), Xe = A * Math.PI / 180;
            we._rotate(Xe), Te._rotate(Xe), Oe._rotate(Xe), Be._rotate(Xe), ce = Math.min(we.x, Te.x, Oe.x, Be.x), oe = Math.max(we.x, Te.x, Oe.x, Be.x), Q = Math.min(we.y, Te.y, Oe.y, Be.y), te = Math.max(we.y, Te.y, Oe.y, Be.y);
          }
          r.emplaceBack(i.x, i.y, ce, Q, oe, te, l, p, y);
        }
        this.boxEndIndex = r.length;
      }, Nh = function(r, i) {
        if (r === void 0 && (r = []), i === void 0 && (i = FO), this.data = r, this.length = this.data.length, this.compare = i, this.length > 0)
          for (var l = (this.length >> 1) - 1; l >= 0; l--)
            this._down(l);
      };
      function FO(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function BO(r, i, l) {
        i === void 0 && (i = 1), l === void 0 && (l = !1);
        for (var p = 1 / 0, y = 1 / 0, v = -1 / 0, x = -1 / 0, S = r[0], C = 0; C < S.length; C++) {
          var A = S[C];
          (!C || A.x < p) && (p = A.x), (!C || A.y < y) && (y = A.y), (!C || A.x > v) && (v = A.x), (!C || A.y > x) && (x = A.y);
        }
        var L = Math.min(v - p, x - y), D = L / 2, B = new Nh([], VO);
        if (L === 0)
          return new T(p, y);
        for (var j = p; j < v; j += L)
          for (var Q = y; Q < x; Q += L)
            B.push(new Rh(j + D, Q + D, D, r));
        for (var te = function(ge) {
          for (var we = 0, Te = 0, Oe = 0, Be = ge[0], Xe = 0, ot = Be.length, At = ot - 1; Xe < ot; At = Xe++) {
            var dt = Be[Xe], Nt = Be[At], yt = dt.x * Nt.y - Nt.x * dt.y;
            Te += (dt.x + Nt.x) * yt, Oe += (dt.y + Nt.y) * yt, we += 3 * yt;
          }
          return new Rh(Te / we, Oe / we, 0, ge);
        }(r), ce = B.length; B.length; ) {
          var oe = B.pop();
          (oe.d > te.d || !te.d) && (te = oe, l && console.log("found best %d after %d probes", Math.round(1e4 * oe.d) / 1e4, ce)), oe.max - te.d <= i || (B.push(new Rh(oe.p.x - (D = oe.h / 2), oe.p.y - D, D, r)), B.push(new Rh(oe.p.x + D, oe.p.y - D, D, r)), B.push(new Rh(oe.p.x - D, oe.p.y + D, D, r)), B.push(new Rh(oe.p.x + D, oe.p.y + D, D, r)), ce += 4);
        }
        return l && (console.log("num probes: " + ce), console.log("best distance: " + te.d)), te.p;
      }
      function VO(r, i) {
        return i.max - r.max;
      }
      function Rh(r, i, l, p) {
        this.p = new T(r, i), this.h = l, this.d = function(y, v) {
          for (var x = !1, S = 1 / 0, C = 0; C < v.length; C++)
            for (var A = v[C], L = 0, D = A.length, B = D - 1; L < D; B = L++) {
              var j = A[L], Q = A[B];
              j.y > y.y != Q.y > y.y && y.x < (Q.x - j.x) * (y.y - j.y) / (Q.y - j.y) + j.x && (x = !x), S = Math.min(S, ou(y, j, Q));
            }
          return (x ? 1 : -1) * Math.sqrt(S);
        }(this.p, p), this.max = this.d + this.h * Math.SQRT2;
      }
      Nh.prototype.push = function(r) {
        this.data.push(r), this.length++, this._up(this.length - 1);
      }, Nh.prototype.pop = function() {
        if (this.length !== 0) {
          var r = this.data[0], i = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = i, this._down(0)), r;
        }
      }, Nh.prototype.peek = function() {
        return this.data[0];
      }, Nh.prototype._up = function(r) {
        for (var i = this.data, l = this.compare, p = i[r]; r > 0; ) {
          var y = r - 1 >> 1, v = i[y];
          if (l(p, v) >= 0)
            break;
          i[r] = v, r = y;
        }
        i[r] = p;
      }, Nh.prototype._down = function(r) {
        for (var i = this.data, l = this.compare, p = this.length >> 1, y = i[r]; r < p; ) {
          var v = 1 + (r << 1), x = i[v], S = v + 1;
          if (S < this.length && l(i[S], x) < 0 && (v = S, x = i[S]), l(x, y) >= 0)
            break;
          i[r] = x, r = v;
        }
        i[r] = y;
      };
      var u_ = Number.POSITIVE_INFINITY;
      function qx(r, i) {
        return i[1] !== u_ ? function(l, p, y) {
          var v = 0, x = 0;
          switch (p = Math.abs(p), y = Math.abs(y), l) {
            case "top-right":
            case "top-left":
            case "top":
              x = y - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              x = 7 - y;
          }
          switch (l) {
            case "top-right":
            case "bottom-right":
            case "right":
              v = -p;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              v = p;
          }
          return [v, x];
        }(r, i[0], i[1]) : function(l, p) {
          var y = 0, v = 0;
          p < 0 && (p = 0);
          var x = p / Math.sqrt(2);
          switch (l) {
            case "top-right":
            case "top-left":
              v = x - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              v = 7 - x;
              break;
            case "bottom":
              v = 7 - p;
              break;
            case "top":
              v = p - 7;
          }
          switch (l) {
            case "top-right":
            case "bottom-right":
              y = -x;
              break;
            case "top-left":
            case "bottom-left":
              y = x;
              break;
            case "left":
              y = p;
              break;
            case "right":
              y = -p;
          }
          return [y, v];
        }(r, i[0]);
      }
      function c_(r) {
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function $x(r, i, l, p, y, v, x, S, C, A, L, D, B, j, Q) {
        var te = function(Te, Oe, Be, Xe, ot, At, dt, Nt) {
          for (var yt = Xe.layout.get("text-rotate").evaluate(At, {}) * Math.PI / 180, ar = [], $t = 0, Mt = Oe.positionedLines; $t < Mt.length; $t += 1)
            for (var fr = Mt[$t], rr = 0, Sr = fr.positionedGlyphs; rr < Sr.length; rr += 1) {
              var Rt = Sr[rr];
              if (Rt.rect) {
                var Dr = Rt.rect || {}, gn = 4, Cn = !0, Mn = 1, vn = 0, An = (ot || Nt) && Rt.vertical, ui = Rt.metrics.advance * Rt.scale / 2;
                if (Nt && Oe.verticalizable && (vn = fr.lineOffset / 2 - (Rt.imageName ? -(24 - Rt.metrics.width * Rt.scale) / 2 : 24 * (Rt.scale - 1))), Rt.imageName) {
                  var ci = dt[Rt.imageName];
                  Cn = ci.sdf, gn = 1 / (Mn = ci.pixelRatio);
                }
                var Wi = ot ? [Rt.x + ui, Rt.y] : [0, 0], _i = ot ? [0, 0] : [Rt.x + ui + Be[0], Rt.y + Be[1] - vn], Hi = [0, 0];
                An && (Hi = _i, _i = [0, 0]);
                var Dn = (Rt.metrics.left - gn) * Rt.scale - ui + _i[0], xi = (-Rt.metrics.top - gn) * Rt.scale + _i[1], vr = Dn + Dr.w * Rt.scale / Mn, Xr = xi + Dr.h * Rt.scale / Mn, $r = new T(Dn, xi), Or = new T(vr, xi), ro = new T(Dn, Xr), Di = new T(vr, Xr);
                if (An) {
                  var sn = new T(-ui, ui - -17), qn = -Math.PI / 2, Ni = 12 - ui, Nr = new T(22 - Ni, -(Rt.imageName ? Ni : 0)), Cs = new (Function.prototype.bind.apply(T, [null].concat(Hi)))();
                  $r._rotateAround(qn, sn)._add(Nr)._add(Cs), Or._rotateAround(qn, sn)._add(Nr)._add(Cs), ro._rotateAround(qn, sn)._add(Nr)._add(Cs), Di._rotateAround(qn, sn)._add(Nr)._add(Cs);
                }
                if (yt) {
                  var Ko = Math.sin(yt), As = Math.cos(yt), Nn = [As, -Ko, Ko, As];
                  $r._matMult(Nn), Or._matMult(Nn), ro._matMult(Nn), Di._matMult(Nn);
                }
                var Ps = new T(0, 0), Ta = new T(0, 0);
                ar.push({ tl: $r, tr: Or, bl: ro, br: Di, tex: Dr, writingMode: Oe.writingMode, glyphOffset: Wi, sectionIndex: Rt.sectionIndex, isSDF: Cn, pixelOffsetTL: Ps, pixelOffsetBR: Ta, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
          return ar;
        }(0, l, S, y, v, x, p, r.allowVerticalPlacement), ce = r.textSizeData, oe = null;
        ce.kind === "source" ? (oe = [128 * y.layout.get("text-size").evaluate(x, {})])[0] > 32640 && at(r.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".') : ce.kind === "composite" && ((oe = [128 * j.compositeTextSizes[0].evaluate(x, {}, Q), 128 * j.compositeTextSizes[1].evaluate(x, {}, Q)])[0] > 32640 || oe[1] > 32640) && at(r.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".'), r.addSymbols(r.text, te, oe, S, v, x, A, i, C.lineStartIndex, C.lineLength, B, Q);
        for (var ge = 0, we = L; ge < we.length; ge += 1)
          D[we[ge]] = r.text.placedSymbolArray.length - 1;
        return 4 * te.length;
      }
      function Wx(r) {
        for (var i in r)
          return r[i];
        return null;
      }
      function UO(r, i, l, p) {
        var y = r.compareText;
        if (i in y) {
          for (var v = y[i], x = v.length - 1; x >= 0; x--)
            if (p.dist(v[x]) < l)
              return !0;
        } else
          y[i] = [];
        return y[i].push(p), !1;
      }
      var jO = Ah.VectorTileFeature.types, GO = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Xm(r, i, l, p, y, v, x, S, C, A, L, D, B) {
        var j = S ? Math.min(32640, Math.round(S[0])) : 0, Q = S ? Math.min(32640, Math.round(S[1])) : 0;
        r.emplaceBack(i, l, Math.round(32 * p), Math.round(32 * y), v, x, (j << 1) + (C ? 1 : 0), Q, 16 * A, 16 * L, 256 * D, 256 * B);
      }
      function h_(r, i, l) {
        r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l);
      }
      function qO(r) {
        for (var i = 0, l = r.sections; i < l.length; i += 1)
          if (_h(l[i].text))
            return !0;
        return !1;
      }
      var zh = function(r) {
        this.layoutVertexArray = new Eh(), this.indexArray = new Es(), this.programConfigurations = r, this.segments = new $(), this.dynamicLayoutVertexArray = new ru(), this.opacityVertexArray = new uc(), this.placedSymbolArray = new d();
      };
      zh.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
      }, zh.prototype.upload = function(r, i, l, p) {
        this.isEmpty() || (l && (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, yO.members), this.indexBuffer = r.createIndexBuffer(this.indexArray, i), this.dynamicLayoutVertexBuffer = r.createVertexBuffer(this.dynamicLayoutVertexArray, gO.members, !0), this.opacityVertexBuffer = r.createVertexBuffer(this.opacityVertexArray, GO, !0), this.opacityVertexBuffer.itemSize = 1), (l || p) && this.programConfigurations.upload(r));
      }, zh.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
      }, wt("SymbolBuffers", zh);
      var Sp = function(r, i, l) {
        this.layoutVertexArray = new r(), this.layoutAttributes = i, this.indexArray = new l(), this.segments = new $(), this.collisionVertexArray = new fp();
      };
      Sp.prototype.upload = function(r) {
        this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = r.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = r.createVertexBuffer(this.collisionVertexArray, vO.members, !0);
      }, Sp.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
      }, wt("CollisionBuffers", Sp);
      var Wr = function(r) {
        this.collisionBoxArray = r.collisionBoxArray, this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(v) {
          return v.id;
        }), this.index = r.index, this.pixelRatio = r.pixelRatio, this.sourceLayerIndex = r.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Oo([]), this.placementViewportMatrix = Oo([]);
        var i = this.layers[0]._unevaluatedLayout._values;
        this.textSizeData = l_(this.zoom, i["text-size"]), this.iconSizeData = l_(this.zoom, i["icon-size"]);
        var l = this.layers[0].layout, p = l.get("symbol-sort-key"), y = l.get("symbol-z-order");
        this.canOverlap = l.get("text-allow-overlap") || l.get("icon-allow-overlap") || l.get("text-ignore-placement") || l.get("icon-ignore-placement"), this.sortFeaturesByKey = y !== "viewport-y" && p.constantOr(1) !== void 0, this.sortFeaturesByY = (y === "viewport-y" || y === "auto" && !this.sortFeaturesByKey) && this.canOverlap, l.get("symbol-placement") === "point" && (this.writingModes = l.get("text-writing-mode").map(function(v) {
          return Xo[v];
        })), this.stateDependentLayerIds = this.layers.filter(function(v) {
          return v.isStateDependent();
        }).map(function(v) {
          return v.id;
        }), this.sourceID = r.sourceID;
      };
      Wr.prototype.createArrays = function() {
        this.text = new zh(new qt(this.layers, this.zoom, function(r) {
          return /^text/.test(r);
        })), this.icon = new zh(new qt(this.layers, this.zoom, function(r) {
          return /^icon/.test(r);
        })), this.glyphOffsetArray = new E(), this.lineVertexArray = new O(), this.symbolInstances = new w();
      }, Wr.prototype.calculateGlyphDependencies = function(r, i, l, p, y) {
        for (var v = 0; v < r.length; v++)
          if (i[r.charCodeAt(v)] = !0, (l || p) && y) {
            var x = bp[r.charAt(v)];
            x && (i[x.charCodeAt(0)] = !0);
          }
      }, Wr.prototype.populate = function(r, i, l) {
        var p = this.layers[0], y = p.layout, v = y.get("text-font"), x = y.get("text-field"), S = y.get("icon-image"), C = (x.value.kind !== "constant" || x.value.value instanceof di && !x.value.value.isEmpty() || x.value.value.toString().length > 0) && (v.value.kind !== "constant" || v.value.value.length > 0), A = S.value.kind !== "constant" || !!S.value.value || Object.keys(S.parameters).length > 0, L = y.get("symbol-sort-key");
        if (this.features = [], C || A) {
          for (var D = i.iconDependencies, B = i.glyphDependencies, j = i.availableImages, Q = new mr(this.zoom), te = 0, ce = r; te < ce.length; te += 1) {
            var oe = ce[te], ge = oe.feature, we = oe.id, Te = oe.index, Oe = oe.sourceLayerIndex, Be = p._featureFilter.needGeometry, Xe = Ln(ge, Be);
            if (p._featureFilter.filter(Q, Xe, l)) {
              Be || (Xe.geometry = Tn(ge));
              var ot = void 0;
              if (C) {
                var At = p.getValueAndResolveTokens("text-field", Xe, l, j), dt = di.factory(At);
                qO(dt) && (this.hasRTLText = !0), (!this.hasRTLText || lp() === "unavailable" || this.hasRTLText && Io.isParsed()) && (ot = xO(dt, p, Xe));
              }
              var Nt = void 0;
              if (A) {
                var yt = p.getValueAndResolveTokens("icon-image", Xe, l, j);
                Nt = yt instanceof Ji ? yt : Ji.fromString(yt);
              }
              if (ot || Nt) {
                var ar = this.sortFeaturesByKey ? L.evaluate(Xe, {}, l) : void 0;
                if (this.features.push({ id: we, text: ot, icon: Nt, index: Te, sourceLayerIndex: Oe, geometry: Xe.geometry, properties: ge.properties, type: jO[ge.type], sortKey: ar }), Nt && (D[Nt.name] = !0), ot) {
                  var $t = v.evaluate(Xe, {}, l).join(","), Mt = y.get("text-rotation-alignment") === "map" && y.get("symbol-placement") !== "point";
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Xo.vertical) >= 0;
                  for (var fr = 0, rr = ot.sections; fr < rr.length; fr += 1) {
                    var Sr = rr[fr];
                    if (Sr.image)
                      D[Sr.image.name] = !0;
                    else {
                      var Rt = op(ot.toString()), Dr = Sr.fontStack || $t, gn = B[Dr] = B[Dr] || {};
                      this.calculateGlyphDependencies(Sr.text, gn, Mt, this.allowVerticalPlacement, Rt);
                    }
                  }
                }
              }
            }
          }
          y.get("symbol-placement") === "line" && (this.features = function(Cn) {
            var Mn = {}, vn = {}, An = [], ui = 0;
            function ci(sn) {
              An.push(Cn[sn]), ui++;
            }
            function Wi(sn, qn, Ni) {
              var Nr = vn[sn];
              return delete vn[sn], vn[qn] = Nr, An[Nr].geometry[0].pop(), An[Nr].geometry[0] = An[Nr].geometry[0].concat(Ni[0]), Nr;
            }
            function _i(sn, qn, Ni) {
              var Nr = Mn[qn];
              return delete Mn[qn], Mn[sn] = Nr, An[Nr].geometry[0].shift(), An[Nr].geometry[0] = Ni[0].concat(An[Nr].geometry[0]), Nr;
            }
            function Hi(sn, qn, Ni) {
              var Nr = Ni ? qn[0][qn[0].length - 1] : qn[0][0];
              return sn + ":" + Nr.x + ":" + Nr.y;
            }
            for (var Dn = 0; Dn < Cn.length; Dn++) {
              var xi = Cn[Dn], vr = xi.geometry, Xr = xi.text ? xi.text.toString() : null;
              if (Xr) {
                var $r = Hi(Xr, vr), Or = Hi(Xr, vr, !0);
                if ($r in vn && Or in Mn && vn[$r] !== Mn[Or]) {
                  var ro = _i($r, Or, vr), Di = Wi($r, Or, An[ro].geometry);
                  delete Mn[$r], delete vn[Or], vn[Hi(Xr, An[Di].geometry, !0)] = Di, An[ro].geometry = null;
                } else
                  $r in vn ? Wi($r, Or, vr) : Or in Mn ? _i($r, Or, vr) : (ci(Dn), Mn[$r] = ui - 1, vn[Or] = ui - 1);
              } else
                ci(Dn);
            }
            return An.filter(function(sn) {
              return sn.geometry;
            });
          }(this.features)), this.sortFeaturesByKey && this.features.sort(function(Cn, Mn) {
            return Cn.sortKey - Mn.sortKey;
          });
        }
      }, Wr.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(r, i, this.layers, l), this.icon.programConfigurations.updatePaintArrays(r, i, this.layers, l));
      }, Wr.prototype.isEmpty = function() {
        return this.symbolInstances.length === 0 && !this.hasRTLText;
      }, Wr.prototype.uploadPending = function() {
        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
      }, Wr.prototype.upload = function(r) {
        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(r), this.iconCollisionBox.upload(r)), this.text.upload(r, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(r, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
      }, Wr.prototype.destroyDebugData = function() {
        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
      }, Wr.prototype.destroy = function() {
        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
      }, Wr.prototype.addToLineVertexArray = function(r, i) {
        var l = this.lineVertexArray.length;
        if (r.segment !== void 0) {
          for (var p = r.dist(i[r.segment + 1]), y = r.dist(i[r.segment]), v = {}, x = r.segment + 1; x < i.length; x++)
            v[x] = { x: i[x].x, y: i[x].y, tileUnitDistanceFromAnchor: p }, x < i.length - 1 && (p += i[x + 1].dist(i[x]));
          for (var S = r.segment || 0; S >= 0; S--)
            v[S] = { x: i[S].x, y: i[S].y, tileUnitDistanceFromAnchor: y }, S > 0 && (y += i[S - 1].dist(i[S]));
          for (var C = 0; C < i.length; C++) {
            var A = v[C];
            this.lineVertexArray.emplaceBack(A.x, A.y, A.tileUnitDistanceFromAnchor);
          }
        }
        return { lineStartIndex: l, lineLength: this.lineVertexArray.length - l };
      }, Wr.prototype.addSymbols = function(r, i, l, p, y, v, x, S, C, A, L, D) {
        for (var B = r.indexArray, j = r.layoutVertexArray, Q = r.segments.prepareSegment(4 * i.length, j, B, this.canOverlap ? v.sortKey : void 0), te = this.glyphOffsetArray.length, ce = Q.vertexLength, oe = this.allowVerticalPlacement && x === Xo.vertical ? Math.PI / 2 : 0, ge = v.text && v.text.sections, we = 0; we < i.length; we++) {
          var Te = i[we], Oe = Te.tl, Be = Te.tr, Xe = Te.bl, ot = Te.br, At = Te.tex, dt = Te.pixelOffsetTL, Nt = Te.pixelOffsetBR, yt = Te.minFontScaleX, ar = Te.minFontScaleY, $t = Te.glyphOffset, Mt = Te.isSDF, fr = Te.sectionIndex, rr = Q.vertexLength, Sr = $t[1];
          Xm(j, S.x, S.y, Oe.x, Sr + Oe.y, At.x, At.y, l, Mt, dt.x, dt.y, yt, ar), Xm(j, S.x, S.y, Be.x, Sr + Be.y, At.x + At.w, At.y, l, Mt, Nt.x, dt.y, yt, ar), Xm(j, S.x, S.y, Xe.x, Sr + Xe.y, At.x, At.y + At.h, l, Mt, dt.x, Nt.y, yt, ar), Xm(j, S.x, S.y, ot.x, Sr + ot.y, At.x + At.w, At.y + At.h, l, Mt, Nt.x, Nt.y, yt, ar), h_(r.dynamicLayoutVertexArray, S, oe), B.emplaceBack(rr, rr + 1, rr + 2), B.emplaceBack(rr + 1, rr + 2, rr + 3), Q.vertexLength += 4, Q.primitiveLength += 2, this.glyphOffsetArray.emplaceBack($t[0]), we !== i.length - 1 && fr === i[we + 1].sectionIndex || r.programConfigurations.populatePaintArrays(j.length, v, v.index, {}, D, ge && ge[fr]);
        }
        r.placedSymbolArray.emplaceBack(S.x, S.y, te, this.glyphOffsetArray.length - te, ce, C, A, S.segment, l ? l[0] : 0, l ? l[1] : 0, p[0], p[1], x, 0, !1, 0, L);
      }, Wr.prototype._addCollisionDebugVertex = function(r, i, l, p, y, v) {
        return i.emplaceBack(0, 0), r.emplaceBack(l.x, l.y, p, y, Math.round(v.x), Math.round(v.y));
      }, Wr.prototype.addCollisionDebugVertices = function(r, i, l, p, y, v, x) {
        var S = y.segments.prepareSegment(4, y.layoutVertexArray, y.indexArray), C = S.vertexLength, A = y.layoutVertexArray, L = y.collisionVertexArray, D = x.anchorX, B = x.anchorY;
        this._addCollisionDebugVertex(A, L, v, D, B, new T(r, i)), this._addCollisionDebugVertex(A, L, v, D, B, new T(l, i)), this._addCollisionDebugVertex(A, L, v, D, B, new T(l, p)), this._addCollisionDebugVertex(A, L, v, D, B, new T(r, p)), S.vertexLength += 4;
        var j = y.indexArray;
        j.emplaceBack(C, C + 1), j.emplaceBack(C + 1, C + 2), j.emplaceBack(C + 2, C + 3), j.emplaceBack(C + 3, C), S.primitiveLength += 4;
      }, Wr.prototype.addDebugCollisionBoxes = function(r, i, l, p) {
        for (var y = r; y < i; y++) {
          var v = this.collisionBoxArray.get(y);
          this.addCollisionDebugVertices(v.x1, v.y1, v.x2, v.y2, p ? this.textCollisionBox : this.iconCollisionBox, v.anchorPoint, l);
        }
      }, Wr.prototype.generateCollisionDebugBuffers = function() {
        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Sp(nu, Sx.members, cc), this.iconCollisionBox = new Sp(nu, Sx.members, cc);
        for (var r = 0; r < this.symbolInstances.length; r++) {
          var i = this.symbolInstances.get(r);
          this.addDebugCollisionBoxes(i.textBoxStartIndex, i.textBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.iconBoxStartIndex, i.iconBoxEndIndex, i, !1), this.addDebugCollisionBoxes(i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex, i, !1);
        }
      }, Wr.prototype._deserializeCollisionBoxesForSymbol = function(r, i, l, p, y, v, x, S, C) {
        for (var A = {}, L = i; L < l; L++) {
          var D = r.get(L);
          A.textBox = { x1: D.x1, y1: D.y1, x2: D.x2, y2: D.y2, anchorPointX: D.anchorPointX, anchorPointY: D.anchorPointY }, A.textFeatureIndex = D.featureIndex;
          break;
        }
        for (var B = p; B < y; B++) {
          var j = r.get(B);
          A.verticalTextBox = { x1: j.x1, y1: j.y1, x2: j.x2, y2: j.y2, anchorPointX: j.anchorPointX, anchorPointY: j.anchorPointY }, A.verticalTextFeatureIndex = j.featureIndex;
          break;
        }
        for (var Q = v; Q < x; Q++) {
          var te = r.get(Q);
          A.iconBox = { x1: te.x1, y1: te.y1, x2: te.x2, y2: te.y2, anchorPointX: te.anchorPointX, anchorPointY: te.anchorPointY }, A.iconFeatureIndex = te.featureIndex;
          break;
        }
        for (var ce = S; ce < C; ce++) {
          var oe = r.get(ce);
          A.verticalIconBox = { x1: oe.x1, y1: oe.y1, x2: oe.x2, y2: oe.y2, anchorPointX: oe.anchorPointX, anchorPointY: oe.anchorPointY }, A.verticalIconFeatureIndex = oe.featureIndex;
          break;
        }
        return A;
      }, Wr.prototype.deserializeCollisionBoxes = function(r) {
        this.collisionArrays = [];
        for (var i = 0; i < this.symbolInstances.length; i++) {
          var l = this.symbolInstances.get(i);
          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(r, l.textBoxStartIndex, l.textBoxEndIndex, l.verticalTextBoxStartIndex, l.verticalTextBoxEndIndex, l.iconBoxStartIndex, l.iconBoxEndIndex, l.verticalIconBoxStartIndex, l.verticalIconBoxEndIndex));
        }
      }, Wr.prototype.hasTextData = function() {
        return this.text.segments.get().length > 0;
      }, Wr.prototype.hasIconData = function() {
        return this.icon.segments.get().length > 0;
      }, Wr.prototype.hasDebugData = function() {
        return this.textCollisionBox && this.iconCollisionBox;
      }, Wr.prototype.hasTextCollisionBoxData = function() {
        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
      }, Wr.prototype.hasIconCollisionBoxData = function() {
        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
      }, Wr.prototype.addIndicesForPlacedSymbol = function(r, i) {
        for (var l = r.placedSymbolArray.get(i), p = l.vertexStartIndex + 4 * l.numGlyphs, y = l.vertexStartIndex; y < p; y += 4)
          r.indexArray.emplaceBack(y, y + 1, y + 2), r.indexArray.emplaceBack(y + 1, y + 2, y + 3);
      }, Wr.prototype.getSortedSymbolIndexes = function(r) {
        if (this.sortedAngle === r && this.symbolInstanceIndexes !== void 0)
          return this.symbolInstanceIndexes;
        for (var i = Math.sin(r), l = Math.cos(r), p = [], y = [], v = [], x = 0; x < this.symbolInstances.length; ++x) {
          v.push(x);
          var S = this.symbolInstances.get(x);
          p.push(0 | Math.round(i * S.anchorX + l * S.anchorY)), y.push(S.featureIndex);
        }
        return v.sort(function(C, A) {
          return p[C] - p[A] || y[A] - y[C];
        }), v;
      }, Wr.prototype.addToSortKeyRanges = function(r, i) {
        var l = this.sortKeyRanges[this.sortKeyRanges.length - 1];
        l && l.sortKey === i ? l.symbolInstanceEnd = r + 1 : this.sortKeyRanges.push({ sortKey: i, symbolInstanceStart: r, symbolInstanceEnd: r + 1 });
      }, Wr.prototype.sortFeatures = function(r) {
        var i = this;
        if (this.sortFeaturesByY && this.sortedAngle !== r && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(r), this.sortedAngle = r, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
          for (var l = 0, p = this.symbolInstanceIndexes; l < p.length; l += 1) {
            var y = this.symbolInstances.get(p[l]);
            this.featureSortOrder.push(y.featureIndex), [y.rightJustifiedTextSymbolIndex, y.centerJustifiedTextSymbolIndex, y.leftJustifiedTextSymbolIndex].forEach(function(v, x, S) {
              v >= 0 && S.indexOf(v) === x && i.addIndicesForPlacedSymbol(i.text, v);
            }), y.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, y.verticalPlacedTextSymbolIndex), y.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, y.placedIconSymbolIndex), y.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, y.verticalPlacedIconSymbolIndex);
          }
          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
        }
      }, wt("SymbolBucket", Wr, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Wr.MAX_GLYPHS = 65535, Wr.addDynamicAttributes = h_;
      var $O = new Mi({ "symbol-placement": new Lt(G.layout_symbol["symbol-placement"]), "symbol-spacing": new Lt(G.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Lt(G.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Tt(G.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Lt(G.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Lt(G.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Lt(G.layout_symbol["icon-ignore-placement"]), "icon-optional": new Lt(G.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Lt(G.layout_symbol["icon-rotation-alignment"]), "icon-size": new Tt(G.layout_symbol["icon-size"]), "icon-text-fit": new Lt(G.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Lt(G.layout_symbol["icon-text-fit-padding"]), "icon-image": new Tt(G.layout_symbol["icon-image"]), "icon-rotate": new Tt(G.layout_symbol["icon-rotate"]), "icon-padding": new Lt(G.layout_symbol["icon-padding"]), "icon-keep-upright": new Lt(G.layout_symbol["icon-keep-upright"]), "icon-offset": new Tt(G.layout_symbol["icon-offset"]), "icon-anchor": new Tt(G.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Lt(G.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Lt(G.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Lt(G.layout_symbol["text-rotation-alignment"]), "text-field": new Tt(G.layout_symbol["text-field"]), "text-font": new Tt(G.layout_symbol["text-font"]), "text-size": new Tt(G.layout_symbol["text-size"]), "text-max-width": new Tt(G.layout_symbol["text-max-width"]), "text-line-height": new Lt(G.layout_symbol["text-line-height"]), "text-letter-spacing": new Tt(G.layout_symbol["text-letter-spacing"]), "text-justify": new Tt(G.layout_symbol["text-justify"]), "text-radial-offset": new Tt(G.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Lt(G.layout_symbol["text-variable-anchor"]), "text-anchor": new Tt(G.layout_symbol["text-anchor"]), "text-max-angle": new Lt(G.layout_symbol["text-max-angle"]), "text-writing-mode": new Lt(G.layout_symbol["text-writing-mode"]), "text-rotate": new Tt(G.layout_symbol["text-rotate"]), "text-padding": new Lt(G.layout_symbol["text-padding"]), "text-keep-upright": new Lt(G.layout_symbol["text-keep-upright"]), "text-transform": new Tt(G.layout_symbol["text-transform"]), "text-offset": new Tt(G.layout_symbol["text-offset"]), "text-allow-overlap": new Lt(G.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Lt(G.layout_symbol["text-ignore-placement"]), "text-optional": new Lt(G.layout_symbol["text-optional"]) }), f_ = { paint: new Mi({ "icon-opacity": new Tt(G.paint_symbol["icon-opacity"]), "icon-color": new Tt(G.paint_symbol["icon-color"]), "icon-halo-color": new Tt(G.paint_symbol["icon-halo-color"]), "icon-halo-width": new Tt(G.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Tt(G.paint_symbol["icon-halo-blur"]), "icon-translate": new Lt(G.paint_symbol["icon-translate"]), "icon-translate-anchor": new Lt(G.paint_symbol["icon-translate-anchor"]), "text-opacity": new Tt(G.paint_symbol["text-opacity"]), "text-color": new Tt(G.paint_symbol["text-color"], { runtimeType: De, getOverride: function(r) {
        return r.textColor;
      }, hasOverride: function(r) {
        return !!r.textColor;
      } }), "text-halo-color": new Tt(G.paint_symbol["text-halo-color"]), "text-halo-width": new Tt(G.paint_symbol["text-halo-width"]), "text-halo-blur": new Tt(G.paint_symbol["text-halo-blur"]), "text-translate": new Lt(G.paint_symbol["text-translate"]), "text-translate-anchor": new Lt(G.paint_symbol["text-translate-anchor"]) }), layout: $O }, Fh = function(r) {
        this.type = r.property.overrides ? r.property.overrides.runtimeType : _t, this.defaultValue = r;
      };
      Fh.prototype.evaluate = function(r) {
        if (r.formattedSection) {
          var i = this.defaultValue.property.overrides;
          if (i && i.hasOverride(r.formattedSection))
            return i.getOverride(r.formattedSection);
        }
        return r.feature && r.featureState ? this.defaultValue.evaluate(r.feature, r.featureState) : this.defaultValue.property.specification.default;
      }, Fh.prototype.eachChild = function(r) {
        this.defaultValue.isConstant() || r(this.defaultValue.value._styleExpression.expression);
      }, Fh.prototype.outputDefined = function() {
        return !1;
      }, Fh.prototype.serialize = function() {
        return null;
      }, wt("FormatSectionOverride", Fh, { omit: ["defaultValue"] });
      var WO = function(r) {
        function i(l) {
          r.call(this, l, f_);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.recalculate = function(l, p) {
          if (r.prototype.recalculate.call(this, l, p), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            var y = this.layout.get("text-writing-mode");
            if (y) {
              for (var v = [], x = 0, S = y; x < S.length; x += 1) {
                var C = S[x];
                v.indexOf(C) < 0 && v.push(C);
              }
              this.layout._values["text-writing-mode"] = v;
            } else
              this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }, i.prototype.getValueAndResolveTokens = function(l, p, y, v) {
          var x = this.layout.get(l).evaluate(p, {}, y, v), S = this._unevaluatedLayout._values[l];
          return S.isDataDriven() || Ju(S.value) || !x ? x : function(C, A) {
            return A.replace(/{([^{}]+)}/g, function(L, D) {
              return D in C ? String(C[D]) : "";
            });
          }(p.properties, x);
        }, i.prototype.createBucket = function(l) {
          return new Wr(l);
        }, i.prototype.queryRadius = function() {
          return 0;
        }, i.prototype.queryIntersectsFeature = function() {
          return !1;
        }, i.prototype._setPaintOverrides = function() {
          for (var l = 0, p = f_.paint.overridableProperties; l < p.length; l += 1) {
            var y = p[l];
            if (i.hasPaintOverride(this.layout, y)) {
              var v, x = this.paint.get(y), S = new Fh(x), C = new Kl(S, x.property.specification);
              v = x.value.kind === "constant" || x.value.kind === "source" ? new Qu("source", C) : new Yl("composite", C, x.value.zoomStops, x.value._interpolationType), this.paint._values[y] = new ji(x.property, v, x.parameters);
            }
          }
        }, i.prototype._handleOverridablePaintPropertyUpdate = function(l, p, y) {
          return !(!this.layout || p.isDataDriven() || y.isDataDriven()) && i.hasPaintOverride(this.layout, l);
        }, i.hasPaintOverride = function(l, p) {
          var y = l.get("text-field"), v = f_.paint.properties[p], x = !1, S = function(L) {
            for (var D = 0, B = L; D < B.length; D += 1)
              if (v.overrides && v.overrides.hasOverride(B[D]))
                return void (x = !0);
          };
          if (y.value.kind === "constant" && y.value.value instanceof di)
            S(y.value.value.sections);
          else if (y.value.kind === "source") {
            var C = function(L) {
              x || (L instanceof Vi && kn(L.value) === jt ? S(L.value.sections) : L instanceof ia ? S(L.sections) : L.eachChild(C));
            }, A = y.value;
            A._styleExpression && C(A._styleExpression.expression);
          }
          return x;
        }, i;
      }(ba), HO = { paint: new Mi({ "background-color": new Lt(G.paint_background["background-color"]), "background-pattern": new Gi(G.paint_background["background-pattern"]), "background-opacity": new Lt(G.paint_background["background-opacity"]) }) }, ZO = function(r) {
        function i(l) {
          r.call(this, l, HO);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(ba), XO = { paint: new Mi({ "raster-opacity": new Lt(G.paint_raster["raster-opacity"]), "raster-hue-rotate": new Lt(G.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Lt(G.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Lt(G.paint_raster["raster-brightness-max"]), "raster-saturation": new Lt(G.paint_raster["raster-saturation"]), "raster-contrast": new Lt(G.paint_raster["raster-contrast"]), "raster-resampling": new Lt(G.paint_raster["raster-resampling"]), "raster-fade-duration": new Lt(G.paint_raster["raster-fade-duration"]) }) }, KO = function(r) {
        function i(l) {
          r.call(this, l, XO);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(ba), YO = function(r) {
        function i(l) {
          r.call(this, l, {}), this.implementation = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.is3D = function() {
          return this.implementation.renderingMode === "3d";
        }, i.prototype.hasOffscreenPass = function() {
          return this.implementation.prerender !== void 0;
        }, i.prototype.recalculate = function() {
        }, i.prototype.updateTransitions = function() {
        }, i.prototype.hasTransition = function() {
        }, i.prototype.serialize = function() {
        }, i.prototype.onAdd = function(l) {
          this.implementation.onAdd && this.implementation.onAdd(l, l.painter.context.gl);
        }, i.prototype.onRemove = function(l) {
          this.implementation.onRemove && this.implementation.onRemove(l, l.painter.context.gl);
        }, i;
      }(ba), JO = { circle: Kv, heatmap: NI, hillshade: zI, fill: eO, "fill-extrusion": uO, line: mO, symbol: WO, background: ZO, raster: KO }, Hx = I.HTMLImageElement, Zx = I.HTMLCanvasElement, Xx = I.HTMLVideoElement, Kx = I.ImageData, Km = I.ImageBitmap, yc = function(r, i, l, p) {
        this.context = r, this.format = l, this.texture = r.gl.createTexture(), this.update(i, p);
      };
      yc.prototype.update = function(r, i, l) {
        var p = r.width, y = r.height, v = !(this.size && this.size[0] === p && this.size[1] === y || l), x = this.context, S = x.gl;
        if (this.useMipmap = Boolean(i && i.useMipmap), S.bindTexture(S.TEXTURE_2D, this.texture), x.pixelStoreUnpackFlipY.set(!1), x.pixelStoreUnpack.set(1), x.pixelStoreUnpackPremultiplyAlpha.set(this.format === S.RGBA && (!i || i.premultiply !== !1)), v)
          this.size = [p, y], r instanceof Hx || r instanceof Zx || r instanceof Xx || r instanceof Kx || Km && r instanceof Km ? S.texImage2D(S.TEXTURE_2D, 0, this.format, this.format, S.UNSIGNED_BYTE, r) : S.texImage2D(S.TEXTURE_2D, 0, this.format, p, y, 0, this.format, S.UNSIGNED_BYTE, r.data);
        else {
          var C = l || { x: 0, y: 0 }, A = C.x, L = C.y;
          r instanceof Hx || r instanceof Zx || r instanceof Xx || r instanceof Kx || Km && r instanceof Km ? S.texSubImage2D(S.TEXTURE_2D, 0, A, L, S.RGBA, S.UNSIGNED_BYTE, r) : S.texSubImage2D(S.TEXTURE_2D, 0, A, L, p, y, S.RGBA, S.UNSIGNED_BYTE, r.data);
        }
        this.useMipmap && this.isSizePowerOfTwo() && S.generateMipmap(S.TEXTURE_2D);
      }, yc.prototype.bind = function(r, i, l) {
        var p = this.context.gl;
        p.bindTexture(p.TEXTURE_2D, this.texture), l !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (l = p.LINEAR), r !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, r), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, l || r), this.filter = r), i !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, i), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, i), this.wrap = i);
      }, yc.prototype.isSizePowerOfTwo = function() {
        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
      }, yc.prototype.destroy = function() {
        this.context.gl.deleteTexture(this.texture), this.texture = null;
      };
      var p_ = function(r) {
        var i = this;
        this._callback = r, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function() {
          i._triggered = !1, i._callback();
        });
      };
      p_.prototype.trigger = function() {
        var r = this;
        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(function() {
          r._triggered = !1, r._callback();
        }, 0));
      }, p_.prototype.remove = function() {
        delete this._channel, this._callback = function() {
        };
      };
      var Bh = function(r, i, l) {
        this.target = r, this.parent = i, this.mapId = l, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, ze(["receive", "process"], this), this.invoker = new p_(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = ht() ? r : I;
      };
      function Yx(r, i, l) {
        var p = 2 * Math.PI * 6378137 / 256 / Math.pow(2, l);
        return [r * p - 2 * Math.PI * 6378137 / 2, i * p - 2 * Math.PI * 6378137 / 2];
      }
      Bh.prototype.send = function(r, i, l, p, y) {
        var v = this;
        y === void 0 && (y = !1);
        var x = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
        l && (this.callbacks[x] = l);
        var S = tr(this.globalScope) ? void 0 : [];
        return this.target.postMessage({ id: x, type: r, hasCallback: !!l, targetMapId: p, mustQueue: y, sourceMapId: this.mapId, data: aa(i, S) }, S), { cancel: function() {
          l && delete v.callbacks[x], v.target.postMessage({ id: x, type: "<cancel>", targetMapId: p, sourceMapId: v.mapId });
        } };
      }, Bh.prototype.receive = function(r) {
        var i = r.data, l = i.id;
        if (l && (!i.targetMapId || this.mapId === i.targetMapId))
          if (i.type === "<cancel>") {
            delete this.tasks[l];
            var p = this.cancelCallbacks[l];
            delete this.cancelCallbacks[l], p && p();
          } else
            ht() || i.mustQueue ? (this.tasks[l] = i, this.taskQueue.push(l), this.invoker.trigger()) : this.processTask(l, i);
      }, Bh.prototype.process = function() {
        if (this.taskQueue.length) {
          var r = this.taskQueue.shift(), i = this.tasks[r];
          delete this.tasks[r], this.taskQueue.length && this.invoker.trigger(), i && this.processTask(r, i);
        }
      }, Bh.prototype.processTask = function(r, i) {
        var l = this;
        if (i.type === "<response>") {
          var p = this.callbacks[r];
          delete this.callbacks[r], p && (i.error ? p(co(i.error)) : p(null, co(i.data)));
        } else {
          var y = !1, v = tr(this.globalScope) ? void 0 : [], x = i.hasCallback ? function(L, D) {
            y = !0, delete l.cancelCallbacks[r], l.target.postMessage({ id: r, type: "<response>", sourceMapId: l.mapId, error: L ? aa(L) : null, data: aa(D, v) }, v);
          } : function(L) {
            y = !0;
          }, S = null, C = co(i.data);
          if (this.parent[i.type])
            S = this.parent[i.type](i.sourceMapId, C, x);
          else if (this.parent.getWorkerSource) {
            var A = i.type.split(".");
            S = this.parent.getWorkerSource(i.sourceMapId, A[0], C.source)[A[1]](C, x);
          } else
            x(new Error("Could not find function " + i.type));
          !y && S && S.cancel && (this.cancelCallbacks[r] = S.cancel);
        }
      }, Bh.prototype.remove = function() {
        this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);
      };
      var ei = function(r, i) {
        r && (i ? this.setSouthWest(r).setNorthEast(i) : r.length === 4 ? this.setSouthWest([r[0], r[1]]).setNorthEast([r[2], r[3]]) : this.setSouthWest(r[0]).setNorthEast(r[1]));
      };
      ei.prototype.setNorthEast = function(r) {
        return this._ne = r instanceof yn ? new yn(r.lng, r.lat) : yn.convert(r), this;
      }, ei.prototype.setSouthWest = function(r) {
        return this._sw = r instanceof yn ? new yn(r.lng, r.lat) : yn.convert(r), this;
      }, ei.prototype.extend = function(r) {
        var i, l, p = this._sw, y = this._ne;
        if (r instanceof yn)
          i = r, l = r;
        else {
          if (!(r instanceof ei))
            return Array.isArray(r) ? r.length === 4 || r.every(Array.isArray) ? this.extend(ei.convert(r)) : this.extend(yn.convert(r)) : this;
          if (l = r._ne, !(i = r._sw) || !l)
            return this;
        }
        return p || y ? (p.lng = Math.min(i.lng, p.lng), p.lat = Math.min(i.lat, p.lat), y.lng = Math.max(l.lng, y.lng), y.lat = Math.max(l.lat, y.lat)) : (this._sw = new yn(i.lng, i.lat), this._ne = new yn(l.lng, l.lat)), this;
      }, ei.prototype.getCenter = function() {
        return new yn((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
      }, ei.prototype.getSouthWest = function() {
        return this._sw;
      }, ei.prototype.getNorthEast = function() {
        return this._ne;
      }, ei.prototype.getNorthWest = function() {
        return new yn(this.getWest(), this.getNorth());
      }, ei.prototype.getSouthEast = function() {
        return new yn(this.getEast(), this.getSouth());
      }, ei.prototype.getWest = function() {
        return this._sw.lng;
      }, ei.prototype.getSouth = function() {
        return this._sw.lat;
      }, ei.prototype.getEast = function() {
        return this._ne.lng;
      }, ei.prototype.getNorth = function() {
        return this._ne.lat;
      }, ei.prototype.toArray = function() {
        return [this._sw.toArray(), this._ne.toArray()];
      }, ei.prototype.toString = function() {
        return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";
      }, ei.prototype.isEmpty = function() {
        return !(this._sw && this._ne);
      }, ei.prototype.contains = function(r) {
        var i = yn.convert(r), l = i.lng, p = i.lat, y = this._sw.lng <= l && l <= this._ne.lng;
        return this._sw.lng > this._ne.lng && (y = this._sw.lng >= l && l >= this._ne.lng), this._sw.lat <= p && p <= this._ne.lat && y;
      }, ei.convert = function(r) {
        return !r || r instanceof ei ? r : new ei(r);
      };
      var yn = function(r, i) {
        if (isNaN(r) || isNaN(i))
          throw new Error("Invalid LngLat object: (" + r + ", " + i + ")");
        if (this.lng = +r, this.lat = +i, this.lat > 90 || this.lat < -90)
          throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
      };
      yn.prototype.wrap = function() {
        return new yn(X(this.lng, -180, 180), this.lat);
      }, yn.prototype.toArray = function() {
        return [this.lng, this.lat];
      }, yn.prototype.toString = function() {
        return "LngLat(" + this.lng + ", " + this.lat + ")";
      }, yn.prototype.distanceTo = function(r) {
        var i = Math.PI / 180, l = this.lat * i, p = r.lat * i, y = Math.sin(l) * Math.sin(p) + Math.cos(l) * Math.cos(p) * Math.cos((r.lng - this.lng) * i);
        return 63710088e-1 * Math.acos(Math.min(y, 1));
      }, yn.prototype.toBounds = function(r) {
        r === void 0 && (r = 0);
        var i = 360 * r / 40075017, l = i / Math.cos(Math.PI / 180 * this.lat);
        return new ei(new yn(this.lng - l, this.lat - i), new yn(this.lng + l, this.lat + i));
      }, yn.convert = function(r) {
        if (r instanceof yn)
          return r;
        if (Array.isArray(r) && (r.length === 2 || r.length === 3))
          return new yn(Number(r[0]), Number(r[1]));
        if (!Array.isArray(r) && typeof r == "object" && r !== null)
          return new yn(Number("lng" in r ? r.lng : r.lon), Number(r.lat));
        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
      };
      var Jx = 2 * Math.PI * 63710088e-1;
      function Qx(r) {
        return Jx * Math.cos(r * Math.PI / 180);
      }
      function eb(r) {
        return (180 + r) / 360;
      }
      function tb(r) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
      }
      function rb(r, i) {
        return r / Qx(i);
      }
      function d_(r) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90;
      }
      var gc = function(r, i, l) {
        l === void 0 && (l = 0), this.x = +r, this.y = +i, this.z = +l;
      };
      gc.fromLngLat = function(r, i) {
        i === void 0 && (i = 0);
        var l = yn.convert(r);
        return new gc(eb(l.lng), tb(l.lat), rb(i, l.lat));
      }, gc.prototype.toLngLat = function() {
        return new yn(360 * this.x - 180, d_(this.y));
      }, gc.prototype.toAltitude = function() {
        return this.z * Qx(d_(this.y));
      }, gc.prototype.meterInMercatorCoordinateUnits = function() {
        return 1 / Jx * (r = d_(this.y), 1 / Math.cos(r * Math.PI / 180));
        var r;
      };
      var vc = function(r, i, l) {
        this.z = r, this.x = i, this.y = l, this.key = Tp(0, r, r, i, l);
      };
      vc.prototype.equals = function(r) {
        return this.z === r.z && this.x === r.x && this.y === r.y;
      }, vc.prototype.url = function(r, i) {
        var l, p, y, v, x, S = (p = this.y, y = this.z, v = Yx(256 * (l = this.x), 256 * (p = Math.pow(2, y) - p - 1), y), x = Yx(256 * (l + 1), 256 * (p + 1), y), v[0] + "," + v[1] + "," + x[0] + "," + x[1]), C = function(A, L, D) {
          for (var B, j = "", Q = A; Q > 0; Q--)
            j += (L & (B = 1 << Q - 1) ? 1 : 0) + (D & B ? 2 : 0);
          return j;
        }(this.z, this.x, this.y);
        return r[(this.x + this.y) % r.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String(i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", C).replace("{bbox-epsg-3857}", S);
      }, vc.prototype.getTilePoint = function(r) {
        var i = Math.pow(2, this.z);
        return new T(8192 * (r.x * i - this.x), 8192 * (r.y * i - this.y));
      }, vc.prototype.toString = function() {
        return this.z + "/" + this.x + "/" + this.y;
      };
      var nb = function(r, i) {
        this.wrap = r, this.canonical = i, this.key = Tp(r, i.z, i.z, i.x, i.y);
      }, ti = function(r, i, l, p, y) {
        this.overscaledZ = r, this.wrap = i, this.canonical = new vc(l, +p, +y), this.key = Tp(i, r, l, p, y);
      };
      function Tp(r, i, l, p, y) {
        (r *= 2) < 0 && (r = -1 * r - 1);
        var v = 1 << l;
        return (v * v * r + v * y + p).toString(36) + l.toString(36) + i.toString(36);
      }
      ti.prototype.equals = function(r) {
        return this.overscaledZ === r.overscaledZ && this.wrap === r.wrap && this.canonical.equals(r.canonical);
      }, ti.prototype.scaledTo = function(r) {
        var i = this.canonical.z - r;
        return r > this.canonical.z ? new ti(r, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ti(r, this.wrap, r, this.canonical.x >> i, this.canonical.y >> i);
      }, ti.prototype.calculateScaledKey = function(r, i) {
        var l = this.canonical.z - r;
        return r > this.canonical.z ? Tp(this.wrap * +i, r, this.canonical.z, this.canonical.x, this.canonical.y) : Tp(this.wrap * +i, r, r, this.canonical.x >> l, this.canonical.y >> l);
      }, ti.prototype.isChildOf = function(r) {
        if (r.wrap !== this.wrap)
          return !1;
        var i = this.canonical.z - r.canonical.z;
        return r.overscaledZ === 0 || r.overscaledZ < this.overscaledZ && r.canonical.x === this.canonical.x >> i && r.canonical.y === this.canonical.y >> i;
      }, ti.prototype.children = function(r) {
        if (this.overscaledZ >= r)
          return [new ti(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
        var i = this.canonical.z + 1, l = 2 * this.canonical.x, p = 2 * this.canonical.y;
        return [new ti(i, this.wrap, i, l, p), new ti(i, this.wrap, i, l + 1, p), new ti(i, this.wrap, i, l, p + 1), new ti(i, this.wrap, i, l + 1, p + 1)];
      }, ti.prototype.isLessThan = function(r) {
        return this.wrap < r.wrap || !(this.wrap > r.wrap) && (this.overscaledZ < r.overscaledZ || !(this.overscaledZ > r.overscaledZ) && (this.canonical.x < r.canonical.x || !(this.canonical.x > r.canonical.x) && this.canonical.y < r.canonical.y));
      }, ti.prototype.wrapped = function() {
        return new ti(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
      }, ti.prototype.unwrapTo = function(r) {
        return new ti(this.overscaledZ, r, this.canonical.z, this.canonical.x, this.canonical.y);
      }, ti.prototype.overscaleFactor = function() {
        return Math.pow(2, this.overscaledZ - this.canonical.z);
      }, ti.prototype.toUnwrapped = function() {
        return new nb(this.wrap, this.canonical);
      }, ti.prototype.toString = function() {
        return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;
      }, ti.prototype.getTilePoint = function(r) {
        return this.canonical.getTilePoint(new gc(r.x - this.wrap, r.y));
      }, wt("CanonicalTileID", vc), wt("OverscaledTileID", ti, { omit: ["posMatrix"] });
      var El = function(r, i, l) {
        if (this.uid = r, i.height !== i.width)
          throw new RangeError("DEM tiles must be square");
        if (l && l !== "mapbox" && l !== "terrarium")
          return at('"' + l + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');
        this.stride = i.height;
        var p = this.dim = i.height - 2;
        this.data = new Uint32Array(i.data.buffer), this.encoding = l || "mapbox";
        for (var y = 0; y < p; y++)
          this.data[this._idx(-1, y)] = this.data[this._idx(0, y)], this.data[this._idx(p, y)] = this.data[this._idx(p - 1, y)], this.data[this._idx(y, -1)] = this.data[this._idx(y, 0)], this.data[this._idx(y, p)] = this.data[this._idx(y, p - 1)];
        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(p, -1)] = this.data[this._idx(p - 1, 0)], this.data[this._idx(-1, p)] = this.data[this._idx(0, p - 1)], this.data[this._idx(p, p)] = this.data[this._idx(p - 1, p - 1)];
      };
      El.prototype.get = function(r, i) {
        var l = new Uint8Array(this.data.buffer), p = 4 * this._idx(r, i);
        return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(l[p], l[p + 1], l[p + 2]);
      }, El.prototype.getUnpackVector = function() {
        return this.encoding === "terrarium" ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
      }, El.prototype._idx = function(r, i) {
        if (r < -1 || r >= this.dim + 1 || i < -1 || i >= this.dim + 1)
          throw new RangeError("out of range source coordinates for DEM data");
        return (i + 1) * this.stride + (r + 1);
      }, El.prototype._unpackMapbox = function(r, i, l) {
        return (256 * r * 256 + 256 * i + l) / 10 - 1e4;
      }, El.prototype._unpackTerrarium = function(r, i, l) {
        return 256 * r + i + l / 256 - 32768;
      }, El.prototype.getPixels = function() {
        return new yo({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
      }, El.prototype.backfillBorder = function(r, i, l) {
        if (this.dim !== r.dim)
          throw new Error("dem dimension mismatch");
        var p = i * this.dim, y = i * this.dim + this.dim, v = l * this.dim, x = l * this.dim + this.dim;
        switch (i) {
          case -1:
            p = y - 1;
            break;
          case 1:
            y = p + 1;
        }
        switch (l) {
          case -1:
            v = x - 1;
            break;
          case 1:
            x = v + 1;
        }
        for (var S = -i * this.dim, C = -l * this.dim, A = v; A < x; A++)
          for (var L = p; L < y; L++)
            this.data[this._idx(L, A)] = r.data[this._idx(L + S, A + C)];
      }, wt("DEMData", El);
      var Ym = function(r) {
        this._stringToNumber = {}, this._numberToString = [];
        for (var i = 0; i < r.length; i++) {
          var l = r[i];
          this._stringToNumber[l] = i, this._numberToString[i] = l;
        }
      };
      Ym.prototype.encode = function(r) {
        return this._stringToNumber[r];
      }, Ym.prototype.decode = function(r) {
        return this._numberToString[r];
      };
      var Jm = function(r, i, l, p, y) {
        this.type = "Feature", this._vectorTileFeature = r, r._z = i, r._x = l, r._y = p, this.properties = r.properties, this.id = y;
      }, m_ = { geometry: { configurable: !0 } };
      m_.geometry.get = function() {
        return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
      }, m_.geometry.set = function(r) {
        this._geometry = r;
      }, Jm.prototype.toJSON = function() {
        var r = { geometry: this.geometry };
        for (var i in this)
          i !== "_geometry" && i !== "_vectorTileFeature" && (r[i] = this[i]);
        return r;
      }, Object.defineProperties(Jm.prototype, m_);
      var Vh = function() {
        this.state = {}, this.stateChanges = {}, this.deletedStates = {};
      };
      Vh.prototype.updateState = function(r, i, l) {
        var p = String(i);
        if (this.stateChanges[r] = this.stateChanges[r] || {}, this.stateChanges[r][p] = this.stateChanges[r][p] || {}, K(this.stateChanges[r][p], l), this.deletedStates[r] === null)
          for (var y in this.deletedStates[r] = {}, this.state[r])
            y !== p && (this.deletedStates[r][y] = null);
        else if (this.deletedStates[r] && this.deletedStates[r][p] === null)
          for (var v in this.deletedStates[r][p] = {}, this.state[r][p])
            l[v] || (this.deletedStates[r][p][v] = null);
        else
          for (var x in l)
            this.deletedStates[r] && this.deletedStates[r][p] && this.deletedStates[r][p][x] === null && delete this.deletedStates[r][p][x];
      }, Vh.prototype.removeFeatureState = function(r, i, l) {
        if (this.deletedStates[r] !== null) {
          var p = String(i);
          if (this.deletedStates[r] = this.deletedStates[r] || {}, l && i !== void 0)
            this.deletedStates[r][p] !== null && (this.deletedStates[r][p] = this.deletedStates[r][p] || {}, this.deletedStates[r][p][l] = null);
          else if (i !== void 0)
            if (this.stateChanges[r] && this.stateChanges[r][p])
              for (l in this.deletedStates[r][p] = {}, this.stateChanges[r][p])
                this.deletedStates[r][p][l] = null;
            else
              this.deletedStates[r][p] = null;
          else
            this.deletedStates[r] = null;
        }
      }, Vh.prototype.getState = function(r, i) {
        var l = String(i), p = K({}, (this.state[r] || {})[l], (this.stateChanges[r] || {})[l]);
        if (this.deletedStates[r] === null)
          return {};
        if (this.deletedStates[r]) {
          var y = this.deletedStates[r][i];
          if (y === null)
            return {};
          for (var v in y)
            delete p[v];
        }
        return p;
      }, Vh.prototype.initializeTileState = function(r, i) {
        r.setFeatureState(this.state, i);
      }, Vh.prototype.coalesceChanges = function(r, i) {
        var l = {};
        for (var p in this.stateChanges) {
          this.state[p] = this.state[p] || {};
          var y = {};
          for (var v in this.stateChanges[p])
            this.state[p][v] || (this.state[p][v] = {}), K(this.state[p][v], this.stateChanges[p][v]), y[v] = this.state[p][v];
          l[p] = y;
        }
        for (var x in this.deletedStates) {
          this.state[x] = this.state[x] || {};
          var S = {};
          if (this.deletedStates[x] === null)
            for (var C in this.state[x])
              S[C] = {}, this.state[x][C] = {};
          else
            for (var A in this.deletedStates[x]) {
              if (this.deletedStates[x][A] === null)
                this.state[x][A] = {};
              else
                for (var L = 0, D = Object.keys(this.deletedStates[x][A]); L < D.length; L += 1)
                  delete this.state[x][A][D[L]];
              S[A] = this.state[x][A];
            }
          l[x] = l[x] || {}, K(l[x], S);
        }
        if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(l).length !== 0)
          for (var B in r)
            r[B].setFeatureState(l, i);
      };
      var Sl = function(r, i) {
        this.tileID = r, this.x = r.canonical.x, this.y = r.canonical.y, this.z = r.canonical.z, this.grid = new Ua(8192, 16, 0), this.grid3D = new Ua(8192, 16, 0), this.featureIndexArray = new R(), this.promoteId = i;
      };
      function ib(r, i, l, p, y) {
        return Se(r, function(v, x) {
          var S = i instanceof lc ? i.get(x) : null;
          return S && S.evaluate ? S.evaluate(l, p, y) : S;
        });
      }
      function ob(r) {
        for (var i = 1 / 0, l = 1 / 0, p = -1 / 0, y = -1 / 0, v = 0, x = r; v < x.length; v += 1) {
          var S = x[v];
          i = Math.min(i, S.x), l = Math.min(l, S.y), p = Math.max(p, S.x), y = Math.max(y, S.y);
        }
        return { minX: i, minY: l, maxX: p, maxY: y };
      }
      function QO(r, i) {
        return i - r;
      }
      Sl.prototype.insert = function(r, i, l, p, y, v) {
        var x = this.featureIndexArray.length;
        this.featureIndexArray.emplaceBack(l, p, y);
        for (var S = v ? this.grid3D : this.grid, C = 0; C < i.length; C++) {
          for (var A = i[C], L = [1 / 0, 1 / 0, -1 / 0, -1 / 0], D = 0; D < A.length; D++) {
            var B = A[D];
            L[0] = Math.min(L[0], B.x), L[1] = Math.min(L[1], B.y), L[2] = Math.max(L[2], B.x), L[3] = Math.max(L[3], B.y);
          }
          L[0] < 8192 && L[1] < 8192 && L[2] >= 0 && L[3] >= 0 && S.insert(x, L[0], L[1], L[2], L[3]);
        }
      }, Sl.prototype.loadVTLayers = function() {
        return this.vtLayers || (this.vtLayers = new Ah.VectorTile(new Vm(this.rawTileData)).layers, this.sourceLayerCoder = new Ym(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
      }, Sl.prototype.query = function(r, i, l, p) {
        var y = this;
        this.loadVTLayers();
        for (var v = r.params || {}, x = 8192 / r.tileSize / r.scale, S = ph(v.filter), C = r.queryGeometry, A = r.queryPadding * x, L = ob(C), D = this.grid.query(L.minX - A, L.minY - A, L.maxX + A, L.maxY + A), B = ob(r.cameraQueryGeometry), j = this.grid3D.query(B.minX - A, B.minY - A, B.maxX + A, B.maxY + A, function(Te, Oe, Be, Xe) {
          return function(ot, At, dt, Nt, yt) {
            for (var ar = 0, $t = ot; ar < $t.length; ar += 1) {
              var Mt = $t[ar];
              if (At <= Mt.x && dt <= Mt.y && Nt >= Mt.x && yt >= Mt.y)
                return !0;
            }
            var fr = [new T(At, dt), new T(At, yt), new T(Nt, yt), new T(Nt, dt)];
            if (ot.length > 2) {
              for (var rr = 0, Sr = fr; rr < Sr.length; rr += 1)
                if (Ea(ot, Sr[rr]))
                  return !0;
            }
            for (var Rt = 0; Rt < ot.length - 1; Rt++)
              if (pc(ot[Rt], ot[Rt + 1], fr))
                return !0;
            return !1;
          }(r.cameraQueryGeometry, Te - A, Oe - A, Be + A, Xe + A);
        }), Q = 0, te = j; Q < te.length; Q += 1)
          D.push(te[Q]);
        D.sort(QO);
        for (var ce, oe = {}, ge = function(Te) {
          var Oe = D[Te];
          if (Oe !== ce) {
            ce = Oe;
            var Be = y.featureIndexArray.get(Oe), Xe = null;
            y.loadMatchingFeature(oe, Be.bucketIndex, Be.sourceLayerIndex, Be.featureIndex, S, v.layers, v.availableImages, i, l, p, function(ot, At, dt) {
              return Xe || (Xe = Tn(ot)), At.queryIntersectsFeature(C, ot, dt, Xe, y.z, r.transform, x, r.pixelPosMatrix);
            });
          }
        }, we = 0; we < D.length; we++)
          ge(we);
        return oe;
      }, Sl.prototype.loadMatchingFeature = function(r, i, l, p, y, v, x, S, C, A, L) {
        var D = this.bucketLayerIDs[i];
        if (!v || function(ot, At) {
          for (var dt = 0; dt < ot.length; dt++)
            if (At.indexOf(ot[dt]) >= 0)
              return !0;
          return !1;
        }(v, D)) {
          var B = this.sourceLayerCoder.decode(l), j = this.vtLayers[B].feature(p);
          if (y.needGeometry) {
            var Q = Ln(j, !0);
            if (!y.filter(new mr(this.tileID.overscaledZ), Q, this.tileID.canonical))
              return;
          } else if (!y.filter(new mr(this.tileID.overscaledZ), j))
            return;
          for (var te = this.getId(j, B), ce = 0; ce < D.length; ce++) {
            var oe = D[ce];
            if (!(v && v.indexOf(oe) < 0)) {
              var ge = S[oe];
              if (ge) {
                var we = {};
                te !== void 0 && A && (we = A.getState(ge.sourceLayer || "_geojsonTileLayer", te));
                var Te = K({}, C[oe]);
                Te.paint = ib(Te.paint, ge.paint, j, we, x), Te.layout = ib(Te.layout, ge.layout, j, we, x);
                var Oe = !L || L(j, ge, we);
                if (Oe) {
                  var Be = new Jm(j, this.z, this.x, this.y, te);
                  Be.layer = Te;
                  var Xe = r[oe];
                  Xe === void 0 && (Xe = r[oe] = []), Xe.push({ featureIndex: p, feature: Be, intersectionZ: Oe });
                }
              }
            }
          }
        }
      }, Sl.prototype.lookupSymbolFeatures = function(r, i, l, p, y, v, x, S) {
        var C = {};
        this.loadVTLayers();
        for (var A = ph(y), L = 0, D = r; L < D.length; L += 1)
          this.loadMatchingFeature(C, l, p, D[L], A, v, x, S, i);
        return C;
      }, Sl.prototype.hasLayer = function(r) {
        for (var i = 0, l = this.bucketLayerIDs; i < l.length; i += 1)
          for (var p = 0, y = l[i]; p < y.length; p += 1)
            if (r === y[p])
              return !0;
        return !1;
      }, Sl.prototype.getId = function(r, i) {
        var l = r.id;
        return this.promoteId && typeof (l = r.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[i]]) == "boolean" && (l = Number(l)), l;
      }, wt("FeatureIndex", Sl, { omit: ["rawTileData", "sourceLayerCoder"] });
      var vi = function(r, i) {
        this.tileID = r, this.uid = pe(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
      };
      vi.prototype.registerFadeDuration = function(r) {
        var i = r + this.timeAdded;
        i < Vn.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);
      }, vi.prototype.wasRequested = function() {
        return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
      }, vi.prototype.loadVectorData = function(r, i, l) {
        if (this.hasData() && this.unloadVectorData(), this.state = "loaded", r) {
          for (var p in r.featureIndex && (this.latestFeatureIndex = r.featureIndex, r.rawTileData ? (this.latestRawTileData = r.rawTileData, this.latestFeatureIndex.rawTileData = r.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = r.collisionBoxArray, this.buckets = function(A, L) {
            var D = {};
            if (!L)
              return D;
            for (var B = function() {
              var te = Q[j], ce = te.layerIds.map(function(we) {
                return L.getLayer(we);
              }).filter(Boolean);
              if (ce.length !== 0) {
                te.layers = ce, te.stateDependentLayerIds && (te.stateDependentLayers = te.stateDependentLayerIds.map(function(we) {
                  return ce.filter(function(Te) {
                    return Te.id === we;
                  })[0];
                }));
                for (var oe = 0, ge = ce; oe < ge.length; oe += 1)
                  D[ge[oe].id] = te;
              }
            }, j = 0, Q = A; j < Q.length; j += 1)
              B();
            return D;
          }(r.buckets, i.style), this.hasSymbolBuckets = !1, this.buckets) {
            var y = this.buckets[p];
            if (y instanceof Wr) {
              if (this.hasSymbolBuckets = !0, !l)
                break;
              y.justReloaded = !0;
            }
          }
          if (this.hasRTLText = !1, this.hasSymbolBuckets)
            for (var v in this.buckets) {
              var x = this.buckets[v];
              if (x instanceof Wr && x.hasRTLText) {
                this.hasRTLText = !0, Io.isLoading() || Io.isLoaded() || lp() !== "deferred" || sa();
                break;
              }
            }
          for (var S in this.queryPadding = 0, this.buckets) {
            var C = this.buckets[S];
            this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(S).queryRadius(C));
          }
          r.imageAtlas && (this.imageAtlas = r.imageAtlas), r.glyphAtlasImage && (this.glyphAtlasImage = r.glyphAtlasImage);
        } else
          this.collisionBoxArray = new f();
      }, vi.prototype.unloadVectorData = function() {
        for (var r in this.buckets)
          this.buckets[r].destroy();
        this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
      }, vi.prototype.getBucket = function(r) {
        return this.buckets[r.id];
      }, vi.prototype.upload = function(r) {
        for (var i in this.buckets) {
          var l = this.buckets[i];
          l.uploadPending() && l.upload(r);
        }
        var p = r.gl;
        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new yc(r, this.imageAtlas.image, p.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new yc(r, this.glyphAtlasImage, p.ALPHA), this.glyphAtlasImage = null);
      }, vi.prototype.prepare = function(r) {
        this.imageAtlas && this.imageAtlas.patchUpdatedImages(r, this.imageAtlasTexture);
      }, vi.prototype.queryRenderedFeatures = function(r, i, l, p, y, v, x, S, C, A) {
        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: p, cameraQueryGeometry: y, scale: v, tileSize: this.tileSize, pixelPosMatrix: A, transform: S, params: x, queryPadding: this.queryPadding * C }, r, i, l) : {};
      }, vi.prototype.querySourceFeatures = function(r, i) {
        var l = this.latestFeatureIndex;
        if (l && l.rawTileData) {
          var p = l.loadVTLayers(), y = i ? i.sourceLayer : "", v = p._geojsonTileLayer || p[y];
          if (v)
            for (var x = ph(i && i.filter), S = this.tileID.canonical, C = S.z, A = S.x, L = S.y, D = { z: C, x: A, y: L }, B = 0; B < v.length; B++) {
              var j = v.feature(B);
              if (x.needGeometry) {
                var Q = Ln(j, !0);
                if (!x.filter(new mr(this.tileID.overscaledZ), Q, this.tileID.canonical))
                  continue;
              } else if (!x.filter(new mr(this.tileID.overscaledZ), j))
                continue;
              var te = l.getId(j, y), ce = new Jm(j, C, A, L, te);
              ce.tile = D, r.push(ce);
            }
        }
      }, vi.prototype.hasData = function() {
        return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
      }, vi.prototype.patternsLoaded = function() {
        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
      }, vi.prototype.setExpiryData = function(r) {
        var i = this.expirationTime;
        if (r.cacheControl) {
          var l = vt(r.cacheControl);
          l["max-age"] && (this.expirationTime = Date.now() + 1e3 * l["max-age"]);
        } else
          r.expires && (this.expirationTime = new Date(r.expires).getTime());
        if (this.expirationTime) {
          var p = Date.now(), y = !1;
          if (this.expirationTime > p)
            y = !1;
          else if (i)
            if (this.expirationTime < i)
              y = !0;
            else {
              var v = this.expirationTime - i;
              v ? this.expirationTime = p + Math.max(v, 3e4) : y = !0;
            }
          else
            y = !0;
          y ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
        }
      }, vi.prototype.getExpiryTimeout = function() {
        if (this.expirationTime)
          return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
      }, vi.prototype.setFeatureState = function(r, i) {
        if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && Object.keys(r).length !== 0) {
          var l = this.latestFeatureIndex.loadVTLayers();
          for (var p in this.buckets)
            if (i.style.hasLayer(p)) {
              var y = this.buckets[p], v = y.layers[0].sourceLayer || "_geojsonTileLayer", x = l[v], S = r[v];
              if (x && S && Object.keys(S).length !== 0) {
                y.update(S, x, this.imageAtlas && this.imageAtlas.patternPositions || {});
                var C = i && i.style && i.style.getLayer(p);
                C && (this.queryPadding = Math.max(this.queryPadding, C.queryRadius(y)));
              }
            }
        }
      }, vi.prototype.holdingForFade = function() {
        return this.symbolFadeHoldUntil !== void 0;
      }, vi.prototype.symbolFadeFinished = function() {
        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Vn.now();
      }, vi.prototype.clearFadeHold = function() {
        this.symbolFadeHoldUntil = void 0;
      }, vi.prototype.setHoldDuration = function(r) {
        this.symbolFadeHoldUntil = Vn.now() + r;
      }, vi.prototype.setDependencies = function(r, i) {
        for (var l = {}, p = 0, y = i; p < y.length; p += 1)
          l[y[p]] = !0;
        this.dependencies[r] = l;
      }, vi.prototype.hasDependency = function(r, i) {
        for (var l = 0, p = r; l < p.length; l += 1) {
          var y = this.dependencies[p[l]];
          if (y) {
            for (var v = 0, x = i; v < x.length; v += 1)
              if (y[x[v]])
                return !0;
          }
        }
        return !1;
      };
      var lu = I.performance, ab = function(r) {
        this._marks = { start: [r.url, "start"].join("#"), end: [r.url, "end"].join("#"), measure: r.url.toString() }, lu.mark(this._marks.start);
      };
      ab.prototype.finish = function() {
        lu.mark(this._marks.end);
        var r = lu.getEntriesByName(this._marks.measure);
        return r.length === 0 && (lu.measure(this._marks.measure, this._marks.start, this._marks.end), r = lu.getEntriesByName(this._marks.measure), lu.clearMarks(this._marks.start), lu.clearMarks(this._marks.end), lu.clearMeasures(this._marks.measure)), r;
      }, o.Actor = Bh, o.AlphaImage = mc, o.CanonicalTileID = vc, o.CollisionBoxArray = f, o.Color = Fr, o.DEMData = El, o.DataConstantProperty = Lt, o.DictionaryCoder = Ym, o.EXTENT = 8192, o.ErrorEvent = fe, o.EvaluationParameters = mr, o.Event = ee, o.Evented = de, o.FeatureIndex = Sl, o.FillBucket = $a, o.FillExtrusionBucket = Wa, o.ImageAtlas = Ep, o.ImagePosition = jm, o.LineBucket = to, o.LngLat = yn, o.LngLatBounds = ei, o.MercatorCoordinate = gc, o.ONE_EM = 24, o.OverscaledTileID = ti, o.Point = T, o.Point$1 = T, o.Properties = Mi, o.Protobuf = Vm, o.RGBAImage = yo, o.RequestManager = Ne, o.RequestPerformance = ab, o.ResourceType = Fa, o.SegmentVector = $, o.SourceFeatureState = Vh, o.StructArrayLayout1ui2 = dp, o.StructArrayLayout2f1f2i16 = _l, o.StructArrayLayout2i4 = vl, o.StructArrayLayout3ui6 = Es, o.StructArrayLayout4i8 = cp, o.SymbolBucket = Wr, o.Texture = yc, o.Tile = vi, o.Transitionable = Ti, o.Uniform1f = nt, o.Uniform1i = je, o.Uniform2f = tt, o.Uniform3f = gt, o.Uniform4f = Dt, o.UniformColor = Bt, o.UniformMatrix4f = Ir, o.UnwrappedTileID = nb, o.ValidationError = ie, o.WritingMode = Xo, o.ZoomHistory = ip, o.add = function(r, i, l) {
        return r[0] = i[0] + l[0], r[1] = i[1] + l[1], r[2] = i[2] + l[2], r;
      }, o.addDynamicAttributes = h_, o.asyncAll = function(r, i, l) {
        if (!r.length)
          return l(null, []);
        var p = r.length, y = new Array(r.length), v = null;
        r.forEach(function(x, S) {
          i(x, function(C, A) {
            C && (v = C), y[S] = A, --p == 0 && l(v, y);
          });
        });
      }, o.bezier = z, o.bindAll = ze, o.browser = Vn, o.cacheEntryPossiblyAdded = function(r) {
        ++Sn > Bi && (r.getActor().send("enforceCacheSizeLimit", Xn), Sn = 0);
      }, o.clamp = W, o.clearTileCache = function(r) {
        var i = I.caches.delete("mapbox-tiles");
        r && i.catch(r).then(function() {
          return r();
        });
      }, o.clipLine = Ux, o.clone = function(r) {
        var i = new Br(16);
        return i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], i[4] = r[4], i[5] = r[5], i[6] = r[6], i[7] = r[7], i[8] = r[8], i[9] = r[9], i[10] = r[10], i[11] = r[11], i[12] = r[12], i[13] = r[13], i[14] = r[14], i[15] = r[15], i;
      }, o.clone$1 = Je, o.clone$2 = function(r) {
        var i = new Br(3);
        return i[0] = r[0], i[1] = r[1], i[2] = r[2], i;
      }, o.collisionCircleLayout = _O, o.config = Er, o.create = function() {
        var r = new Br(16);
        return Br != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;
      }, o.create$1 = function() {
        var r = new Br(9);
        return Br != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
      }, o.create$2 = function() {
        var r = new Br(4);
        return Br != Float32Array && (r[1] = 0, r[2] = 0), r[0] = 1, r[3] = 1, r;
      }, o.createCommonjsModule = m, o.createExpression = hh, o.createLayout = yi, o.createStyleLayer = function(r) {
        return r.type === "custom" ? new YO(r) : new JO[r.type](r);
      }, o.cross = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = l[0], S = l[1], C = l[2];
        return r[0] = y * C - v * S, r[1] = v * x - p * C, r[2] = p * S - y * x, r;
      }, o.deepEqual = function r(i, l) {
        if (Array.isArray(i)) {
          if (!Array.isArray(l) || i.length !== l.length)
            return !1;
          for (var p = 0; p < i.length; p++)
            if (!r(i[p], l[p]))
              return !1;
          return !0;
        }
        if (typeof i == "object" && i !== null && l !== null) {
          if (typeof l != "object" || Object.keys(i).length !== Object.keys(l).length)
            return !1;
          for (var y in i)
            if (!r(i[y], l[y]))
              return !1;
          return !0;
        }
        return i === l;
      }, o.dot = function(r, i) {
        return r[0] * i[0] + r[1] * i[1] + r[2] * i[2];
      }, o.dot$1 = function(r, i) {
        return r[0] * i[0] + r[1] * i[1] + r[2] * i[2] + r[3] * i[3];
      }, o.ease = V, o.emitValidationErrors = oc, o.endsWith = Pe, o.enforceCacheSizeLimit = function(r) {
        so(), bt && bt.then(function(i) {
          i.keys().then(function(l) {
            for (var p = 0; p < l.length - r; p++)
              i.delete(l[p]);
          });
        });
      }, o.evaluateSizeForFeature = Nx, o.evaluateSizeForZoom = Rx, o.evaluateVariableOffset = qx, o.evented = sp, o.extend = K, o.featureFilter = ph, o.filterObject = Ie, o.fromRotation = function(r, i) {
        var l = Math.sin(i), p = Math.cos(i);
        return r[0] = p, r[1] = l, r[2] = 0, r[3] = -l, r[4] = p, r[5] = 0, r[6] = 0, r[7] = 0, r[8] = 1, r;
      }, o.getAnchorAlignment = s_, o.getAnchorJustification = c_, o.getArrayBuffer = rl, o.getImage = F, o.getJSON = function(r, i) {
        return So(K(r, { type: "json" }), i);
      }, o.getRTLTextPluginStatus = lp, o.getReferrer = Ba, o.getVideo = function(r, i) {
        var l, p, y = I.document.createElement("video");
        y.muted = !0, y.onloadstart = function() {
          i(null, y);
        };
        for (var v = 0; v < r.length; v++) {
          var x = I.document.createElement("source");
          l = r[v], p = void 0, (p = I.document.createElement("a")).href = l, (p.protocol !== I.document.location.protocol || p.host !== I.document.location.host) && (y.crossOrigin = "Anonymous"), x.src = r[v], y.appendChild(x);
        }
        return { cancel: function() {
        } };
      }, o.identity = Oo, o.invert = function(r, i) {
        var l = i[0], p = i[1], y = i[2], v = i[3], x = i[4], S = i[5], C = i[6], A = i[7], L = i[8], D = i[9], B = i[10], j = i[11], Q = i[12], te = i[13], ce = i[14], oe = i[15], ge = l * S - p * x, we = l * C - y * x, Te = l * A - v * x, Oe = p * C - y * S, Be = p * A - v * S, Xe = y * A - v * C, ot = L * te - D * Q, At = L * ce - B * Q, dt = L * oe - j * Q, Nt = D * ce - B * te, yt = D * oe - j * te, ar = B * oe - j * ce, $t = ge * ar - we * yt + Te * Nt + Oe * dt - Be * At + Xe * ot;
        return $t ? (r[0] = (S * ar - C * yt + A * Nt) * ($t = 1 / $t), r[1] = (y * yt - p * ar - v * Nt) * $t, r[2] = (te * Xe - ce * Be + oe * Oe) * $t, r[3] = (B * Be - D * Xe - j * Oe) * $t, r[4] = (C * dt - x * ar - A * At) * $t, r[5] = (l * ar - y * dt + v * At) * $t, r[6] = (ce * Te - Q * Xe - oe * we) * $t, r[7] = (L * Xe - B * Te + j * we) * $t, r[8] = (x * yt - S * dt + A * ot) * $t, r[9] = (p * dt - l * yt - v * ot) * $t, r[10] = (Q * Be - te * Te + oe * ge) * $t, r[11] = (D * Te - L * Be - j * ge) * $t, r[12] = (S * At - x * Nt - C * ot) * $t, r[13] = (l * Nt - p * At + y * ot) * $t, r[14] = (te * we - Q * Oe - ce * ge) * $t, r[15] = (L * Oe - D * we + B * ge) * $t, r) : null;
      }, o.isChar = ct, o.isMapboxURL = $e, o.keysDifference = function(r, i) {
        var l = [];
        for (var p in r)
          p in i || l.push(p);
        return l;
      }, o.makeRequest = So, o.mapObject = Se, o.mercatorXfromLng = eb, o.mercatorYfromLat = tb, o.mercatorZfromAltitude = rb, o.mul = Xv, o.multiply = eo, o.mvt = Ah, o.nextPowerOfTwo = function(r) {
        return r <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
      }, o.normalize = function(r, i) {
        var l = i[0], p = i[1], y = i[2], v = l * l + p * p + y * y;
        return v > 0 && (v = 1 / Math.sqrt(v)), r[0] = i[0] * v, r[1] = i[1] * v, r[2] = i[2] * v, r;
      }, o.number = jn, o.offscreenCanvasSupported = ai, o.ortho = function(r, i, l, p, y, v, x) {
        var S = 1 / (i - l), C = 1 / (p - y), A = 1 / (v - x);
        return r[0] = -2 * S, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * C, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * A, r[11] = 0, r[12] = (i + l) * S, r[13] = (y + p) * C, r[14] = (x + v) * A, r[15] = 1, r;
      }, o.parseGlyphPBF = function(r) {
        return new Vm(r).readFields(AO, []);
      }, o.pbf = Vm, o.performSymbolLayout = function(r, i, l, p, y, v, x) {
        r.createArrays(), r.tilePixelRatio = 8192 / (512 * r.overscaling), r.compareText = {}, r.iconsNeedLinear = !1;
        var S = r.layers[0].layout, C = r.layers[0]._unevaluatedLayout._values, A = {};
        if (r.textSizeData.kind === "composite") {
          var L = r.textSizeData, D = L.maxZoom;
          A.compositeTextSizes = [C["text-size"].possiblyEvaluate(new mr(L.minZoom), x), C["text-size"].possiblyEvaluate(new mr(D), x)];
        }
        if (r.iconSizeData.kind === "composite") {
          var B = r.iconSizeData, j = B.maxZoom;
          A.compositeIconSizes = [C["icon-size"].possiblyEvaluate(new mr(B.minZoom), x), C["icon-size"].possiblyEvaluate(new mr(j), x)];
        }
        A.layoutTextSize = C["text-size"].possiblyEvaluate(new mr(r.zoom + 1), x), A.layoutIconSize = C["icon-size"].possiblyEvaluate(new mr(r.zoom + 1), x), A.textMaxSize = C["text-size"].possiblyEvaluate(new mr(18));
        for (var Q = 24 * S.get("text-line-height"), te = S.get("text-rotation-alignment") === "map" && S.get("symbol-placement") !== "point", ce = S.get("text-keep-upright"), oe = S.get("text-size"), ge = function() {
          var Oe = Te[we], Be = S.get("text-font").evaluate(Oe, {}, x).join(","), Xe = oe.evaluate(Oe, {}, x), ot = A.layoutTextSize.evaluate(Oe, {}, x), At = A.layoutIconSize.evaluate(Oe, {}, x), dt = { horizontal: {}, vertical: void 0 }, Nt = Oe.text, yt = [0, 0];
          if (Nt) {
            var ar = Nt.toString(), $t = 24 * S.get("text-letter-spacing").evaluate(Oe, {}, x), Mt = function(vr) {
              for (var Xr = 0, $r = vr; Xr < $r.length; Xr += 1)
                if (Or = $r[Xr].charCodeAt(0), ct.Arabic(Or) || ct["Arabic Supplement"](Or) || ct["Arabic Extended-A"](Or) || ct["Arabic Presentation Forms-A"](Or) || ct["Arabic Presentation Forms-B"](Or))
                  return !1;
              var Or;
              return !0;
            }(ar) ? $t : 0, fr = S.get("text-anchor").evaluate(Oe, {}, x), rr = S.get("text-variable-anchor");
            if (!rr) {
              var Sr = S.get("text-radial-offset").evaluate(Oe, {}, x);
              yt = Sr ? qx(fr, [24 * Sr, u_]) : S.get("text-offset").evaluate(Oe, {}, x).map(function(vr) {
                return 24 * vr;
              });
            }
            var Rt = te ? "center" : S.get("text-justify").evaluate(Oe, {}, x), Dr = S.get("symbol-placement"), gn = Dr === "point" ? 24 * S.get("text-max-width").evaluate(Oe, {}, x) : 0, Cn = function() {
              r.allowVerticalPlacement && op(ar) && (dt.vertical = Gm(Nt, i, l, y, Be, gn, Q, fr, "left", Mt, yt, Xo.vertical, !0, Dr, ot, Xe));
            };
            if (!te && rr) {
              for (var Mn = Rt === "auto" ? rr.map(function(vr) {
                return c_(vr);
              }) : [Rt], vn = !1, An = 0; An < Mn.length; An++) {
                var ui = Mn[An];
                if (!dt.horizontal[ui])
                  if (vn)
                    dt.horizontal[ui] = dt.horizontal[0];
                  else {
                    var ci = Gm(Nt, i, l, y, Be, gn, Q, "center", ui, Mt, yt, Xo.horizontal, !1, Dr, ot, Xe);
                    ci && (dt.horizontal[ui] = ci, vn = ci.positionedLines.length === 1);
                  }
              }
              Cn();
            } else {
              Rt === "auto" && (Rt = c_(fr));
              var Wi = Gm(Nt, i, l, y, Be, gn, Q, fr, Rt, Mt, yt, Xo.horizontal, !1, Dr, ot, Xe);
              Wi && (dt.horizontal[Rt] = Wi), Cn(), op(ar) && te && ce && (dt.vertical = Gm(Nt, i, l, y, Be, gn, Q, fr, Rt, Mt, yt, Xo.vertical, !1, Dr, ot, Xe));
            }
          }
          var _i = void 0, Hi = !1;
          if (Oe.icon && Oe.icon.name) {
            var Dn = p[Oe.icon.name];
            Dn && (_i = function(vr, Xr, $r) {
              var Or = s_($r), ro = Xr[0] - vr.displaySize[0] * Or.horizontalAlign, Di = Xr[1] - vr.displaySize[1] * Or.verticalAlign;
              return { image: vr, top: Di, bottom: Di + vr.displaySize[1], left: ro, right: ro + vr.displaySize[0] };
            }(y[Oe.icon.name], S.get("icon-offset").evaluate(Oe, {}, x), S.get("icon-anchor").evaluate(Oe, {}, x)), Hi = Dn.sdf, r.sdfIcons === void 0 ? r.sdfIcons = Dn.sdf : r.sdfIcons !== Dn.sdf && at("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Dn.pixelRatio !== r.pixelRatio || S.get("icon-rotate").constantOr(1) !== 0) && (r.iconsNeedLinear = !0));
          }
          var xi = Wx(dt.horizontal) || dt.vertical;
          r.iconsInText = !!xi && xi.iconsInText, (xi || _i) && function(vr, Xr, $r, Or, ro, Di, sn, qn, Ni, Nr, Cs) {
            var Ko = Di.textMaxSize.evaluate(Xr, {});
            Ko === void 0 && (Ko = sn);
            var As, Nn = vr.layers[0].layout, Ps = Nn.get("icon-offset").evaluate(Xr, {}, Cs), Ta = Wx($r.horizontal), Uh = sn / 24, _c = vr.tilePixelRatio * Uh, jh = vr.tilePixelRatio * Ko / 24, Tl = vr.tilePixelRatio * qn, Gh = vr.tilePixelRatio * Nn.get("symbol-spacing"), Qm = Nn.get("text-padding") * vr.tilePixelRatio, qh = Nn.get("icon-padding") * vr.tilePixelRatio, Mp = Nn.get("text-max-angle") / 180 * Math.PI, ey = Nn.get("text-rotation-alignment") === "map" && Nn.get("symbol-placement") !== "point", ty = Nn.get("icon-rotation-alignment") === "map" && Nn.get("symbol-placement") !== "point", Ml = Nn.get("symbol-placement"), Ip = Gh / 2, $h = Nn.get("icon-text-fit");
            Or && $h !== "none" && (vr.allowVerticalPlacement && $r.vertical && (As = Dx(Or, $r.vertical, $h, Nn.get("icon-text-fit-padding"), Ps, Uh)), Ta && (Or = Dx(Or, Ta, $h, Nn.get("icon-text-fit-padding"), Ps, Uh)));
            var uu = function(eC, Np) {
              Np.x < 0 || Np.x >= 8192 || Np.y < 0 || Np.y >= 8192 || function(Rn, Ha, tC, cu, __, ub, sy, ks, ly, Rp, uy, cy, x_, cb, zp, hb, fb, pb, db, mb, Yo, hy, yb, Ls, rC) {
                var gb, bc, Kh, Yh, Jh, Qh = Rn.addToLineVertexArray(Ha, tC), vb = 0, _b = 0, xb = 0, bb = 0, b_ = -1, w_ = -1, Il = {}, wb = J(""), E_ = 0, S_ = 0;
                if (ks._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? (E_ = (gb = ks.layout.get("text-offset").evaluate(Yo, {}, Ls).map(function(Bp) {
                  return 24 * Bp;
                }))[0], S_ = gb[1]) : (E_ = 24 * ks.layout.get("text-radial-offset").evaluate(Yo, {}, Ls), S_ = u_), Rn.allowVerticalPlacement && cu.vertical) {
                  var Eb = ks.layout.get("text-rotate").evaluate(Yo, {}, Ls) + 90;
                  Yh = new Zm(ly, Ha, Rp, uy, cy, cu.vertical, x_, cb, zp, Eb), sy && (Jh = new Zm(ly, Ha, Rp, uy, cy, sy, fb, pb, zp, Eb));
                }
                if (__) {
                  var T_ = ks.layout.get("icon-rotate").evaluate(Yo, {}), Sb = ks.layout.get("icon-text-fit") !== "none", Tb = jx(__, T_, yb, Sb), M_ = sy ? jx(sy, T_, yb, Sb) : void 0;
                  Kh = new Zm(ly, Ha, Rp, uy, cy, __, fb, pb, !1, T_), vb = 4 * Tb.length;
                  var Mb = Rn.iconSizeData, Fp = null;
                  Mb.kind === "source" ? (Fp = [128 * ks.layout.get("icon-size").evaluate(Yo, {})])[0] > 32640 && at(Rn.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".') : Mb.kind === "composite" && ((Fp = [128 * hy.compositeIconSizes[0].evaluate(Yo, {}, Ls), 128 * hy.compositeIconSizes[1].evaluate(Yo, {}, Ls)])[0] > 32640 || Fp[1] > 32640) && at(Rn.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".'), Rn.addSymbols(Rn.icon, Tb, Fp, mb, db, Yo, !1, Ha, Qh.lineStartIndex, Qh.lineLength, -1, Ls), b_ = Rn.icon.placedSymbolArray.length - 1, M_ && (_b = 4 * M_.length, Rn.addSymbols(Rn.icon, M_, Fp, mb, db, Yo, Xo.vertical, Ha, Qh.lineStartIndex, Qh.lineLength, -1, Ls), w_ = Rn.icon.placedSymbolArray.length - 1);
                }
                for (var Ib in cu.horizontal) {
                  var fy = cu.horizontal[Ib];
                  if (!bc) {
                    wb = J(fy.text);
                    var nC = ks.layout.get("text-rotate").evaluate(Yo, {}, Ls);
                    bc = new Zm(ly, Ha, Rp, uy, cy, fy, x_, cb, zp, nC);
                  }
                  var Ob = fy.positionedLines.length === 1;
                  if (xb += $x(Rn, Ha, fy, ub, ks, zp, Yo, hb, Qh, cu.vertical ? Xo.horizontal : Xo.horizontalOnly, Ob ? Object.keys(cu.horizontal) : [Ib], Il, b_, hy, Ls), Ob)
                    break;
                }
                cu.vertical && (bb += $x(Rn, Ha, cu.vertical, ub, ks, zp, Yo, hb, Qh, Xo.vertical, ["vertical"], Il, w_, hy, Ls));
                var iC = bc ? bc.boxStartIndex : Rn.collisionBoxArray.length, oC = bc ? bc.boxEndIndex : Rn.collisionBoxArray.length, aC = Yh ? Yh.boxStartIndex : Rn.collisionBoxArray.length, sC = Yh ? Yh.boxEndIndex : Rn.collisionBoxArray.length, lC = Kh ? Kh.boxStartIndex : Rn.collisionBoxArray.length, uC = Kh ? Kh.boxEndIndex : Rn.collisionBoxArray.length, cC = Jh ? Jh.boxStartIndex : Rn.collisionBoxArray.length, hC = Jh ? Jh.boxEndIndex : Rn.collisionBoxArray.length, Ds = -1, py = function(Bp, Ab) {
                  return Bp && Bp.circleDiameter ? Math.max(Bp.circleDiameter, Ab) : Ab;
                };
                Ds = py(bc, Ds), Ds = py(Yh, Ds), Ds = py(Kh, Ds);
                var Cb = (Ds = py(Jh, Ds)) > -1 ? 1 : 0;
                Cb && (Ds *= rC / 24), Rn.glyphOffsetArray.length >= Wr.MAX_GLYPHS && at("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Yo.sortKey !== void 0 && Rn.addToSortKeyRanges(Rn.symbolInstances.length, Yo.sortKey), Rn.symbolInstances.emplaceBack(Ha.x, Ha.y, Il.right >= 0 ? Il.right : -1, Il.center >= 0 ? Il.center : -1, Il.left >= 0 ? Il.left : -1, Il.vertical || -1, b_, w_, wb, iC, oC, aC, sC, lC, uC, cC, hC, Rp, xb, bb, vb, _b, Cb, 0, x_, E_, S_, Ds);
              }(vr, Np, eC, $r, Or, ro, As, vr.layers[0], vr.collisionBoxArray, Xr.index, Xr.sourceLayerIndex, vr.index, _c, Qm, ey, Ni, Tl, qh, ty, Ps, Xr, Di, Nr, Cs, sn);
            };
            if (Ml === "line")
              for (var Wh = 0, ry = Ux(Xr.geometry, 0, 0, 8192, 8192); Wh < ry.length; Wh += 1)
                for (var ny = ry[Wh], Op = 0, Cp = zO(ny, Gh, Mp, $r.vertical || Ta, Or, 24, jh, vr.overscaling, 8192); Op < Cp.length; Op += 1) {
                  var iy = Cp[Op];
                  Ta && UO(vr, Ta.text, Ip, iy) || uu(ny, iy);
                }
            else if (Ml === "line-center")
              for (var Ap = 0, Pp = Xr.geometry; Ap < Pp.length; Ap += 1) {
                var kp = Pp[Ap];
                if (kp.length > 1) {
                  var oy = RO(kp, Mp, $r.vertical || Ta, Or, 24, jh);
                  oy && uu(kp, oy);
                }
              }
            else if (Xr.type === "Polygon")
              for (var Hh = 0, ay = r_(Xr.geometry, 0); Hh < ay.length; Hh += 1) {
                var Zh = ay[Hh], Lp = BO(Zh, 16);
                uu(Zh[0], new Dh(Lp.x, Lp.y, 0));
              }
            else if (Xr.type === "LineString")
              for (var xc = 0, Dp = Xr.geometry; xc < Dp.length; xc += 1) {
                var Xh = Dp[xc];
                uu(Xh, new Dh(Xh[0].x, Xh[0].y, 0));
              }
            else if (Xr.type === "Point")
              for (var y_ = 0, sb = Xr.geometry; y_ < sb.length; y_ += 1)
                for (var g_ = 0, lb = sb[y_]; g_ < lb.length; g_ += 1) {
                  var v_ = lb[g_];
                  uu([v_], new Dh(v_.x, v_.y, 0));
                }
          }(r, Oe, dt, _i, p, A, ot, At, yt, Hi, x);
        }, we = 0, Te = r.features; we < Te.length; we += 1)
          ge();
        v && r.generateCollisionDebugBuffers();
      }, o.perspective = function(r, i, l, p, y) {
        var v, x = 1 / Math.tan(i / 2);
        return r[0] = x / l, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = x, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, y != null && y !== 1 / 0 ? (r[10] = (y + p) * (v = 1 / (p - y)), r[14] = 2 * y * p * v) : (r[10] = -1, r[14] = -2 * p), r;
      }, o.pick = function(r, i) {
        for (var l = {}, p = 0; p < i.length; p++) {
          var y = i[p];
          y in r && (l[y] = r[y]);
        }
        return l;
      }, o.plugin = Io, o.polygonIntersectsPolygon = Ms, o.postMapLoadEvent = Jr, o.postTurnstileEvent = Vr, o.potpack = Ax, o.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], o.register = wt, o.registerForPluginStateChange = function(r) {
        return r({ pluginStatus: fo, pluginURL: ja }), sp.on("pluginStateChange", r), r;
      }, o.renderColorRamp = hx, o.rotate = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3], S = Math.sin(l), C = Math.cos(l);
        return r[0] = p * C + v * S, r[1] = y * C + x * S, r[2] = p * -S + v * C, r[3] = y * -S + x * C, r;
      }, o.rotateX = function(r, i, l) {
        var p = Math.sin(l), y = Math.cos(l), v = i[4], x = i[5], S = i[6], C = i[7], A = i[8], L = i[9], D = i[10], B = i[11];
        return i !== r && (r[0] = i[0], r[1] = i[1], r[2] = i[2], r[3] = i[3], r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15]), r[4] = v * y + A * p, r[5] = x * y + L * p, r[6] = S * y + D * p, r[7] = C * y + B * p, r[8] = A * y - v * p, r[9] = L * y - x * p, r[10] = D * y - S * p, r[11] = B * y - C * p, r;
      }, o.rotateZ = function(r, i, l) {
        var p = Math.sin(l), y = Math.cos(l), v = i[0], x = i[1], S = i[2], C = i[3], A = i[4], L = i[5], D = i[6], B = i[7];
        return i !== r && (r[8] = i[8], r[9] = i[9], r[10] = i[10], r[11] = i[11], r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15]), r[0] = v * y + A * p, r[1] = x * y + L * p, r[2] = S * y + D * p, r[3] = C * y + B * p, r[4] = A * y - v * p, r[5] = L * y - x * p, r[6] = D * y - S * p, r[7] = B * y - C * p, r;
      }, o.scale = function(r, i, l) {
        var p = l[0], y = l[1], v = l[2];
        return r[0] = i[0] * p, r[1] = i[1] * p, r[2] = i[2] * p, r[3] = i[3] * p, r[4] = i[4] * y, r[5] = i[5] * y, r[6] = i[6] * y, r[7] = i[7] * y, r[8] = i[8] * v, r[9] = i[9] * v, r[10] = i[10] * v, r[11] = i[11] * v, r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15], r;
      }, o.scale$1 = function(r, i, l) {
        return r[0] = i[0] * l, r[1] = i[1] * l, r[2] = i[2] * l, r[3] = i[3] * l, r;
      }, o.scale$2 = function(r, i, l) {
        return r[0] = i[0] * l, r[1] = i[1] * l, r[2] = i[2] * l, r;
      }, o.setCacheLimits = function(r, i) {
        Xn = r, Bi = i;
      }, o.setRTLTextPlugin = function(r, i, l) {
        if (l === void 0 && (l = !1), fo === "deferred" || fo === "loading" || fo === "loaded")
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        ja = Vn.resolveURL(r), fo = "deferred", xh = i, sc(), l || sa();
      }, o.sphericalToCartesian = function(r) {
        var i = r[0], l = r[1], p = r[2];
        return l += 90, l *= Math.PI / 180, p *= Math.PI / 180, { x: i * Math.cos(l) * Math.sin(p), y: i * Math.sin(l) * Math.sin(p), z: i * Math.cos(p) };
      }, o.sqrLen = function(r) {
        var i = r[0], l = r[1];
        return i * i + l * l;
      }, o.styleSpec = G, o.sub = function(r, i, l) {
        return r[0] = i[0] - l[0], r[1] = i[1] - l[1], r[2] = i[2] - l[2], r;
      }, o.symbolSize = NO, o.transformMat3 = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2];
        return r[0] = p * l[0] + y * l[3] + v * l[6], r[1] = p * l[1] + y * l[4] + v * l[7], r[2] = p * l[2] + y * l[5] + v * l[8], r;
      }, o.transformMat4 = Mh, o.translate = function(r, i, l) {
        var p, y, v, x, S, C, A, L, D, B, j, Q, te = l[0], ce = l[1], oe = l[2];
        return i === r ? (r[12] = i[0] * te + i[4] * ce + i[8] * oe + i[12], r[13] = i[1] * te + i[5] * ce + i[9] * oe + i[13], r[14] = i[2] * te + i[6] * ce + i[10] * oe + i[14], r[15] = i[3] * te + i[7] * ce + i[11] * oe + i[15]) : (y = i[1], v = i[2], x = i[3], S = i[4], C = i[5], A = i[6], L = i[7], D = i[8], B = i[9], j = i[10], Q = i[11], r[0] = p = i[0], r[1] = y, r[2] = v, r[3] = x, r[4] = S, r[5] = C, r[6] = A, r[7] = L, r[8] = D, r[9] = B, r[10] = j, r[11] = Q, r[12] = p * te + S * ce + D * oe + i[12], r[13] = y * te + C * ce + B * oe + i[13], r[14] = v * te + A * ce + j * oe + i[14], r[15] = x * te + L * ce + Q * oe + i[15]), r;
      }, o.triggerPluginCompletionEvent = Lm, o.uniqueId = pe, o.validateCustomStyleLayer = function(r) {
        var i = [], l = r.id;
        return l === void 0 && i.push({ message: "layers." + l + ': missing required property "id"' }), r.render === void 0 && i.push({ message: "layers." + l + ': missing required method "render"' }), r.renderingMode && r.renderingMode !== "2d" && r.renderingMode !== "3d" && i.push({ message: "layers." + l + ': property "renderingMode" must be either "2d" or "3d"' }), i;
      }, o.validateLight = Hv, o.validateStyle = nc, o.values = function(r) {
        var i = [];
        for (var l in r)
          i.push(r[l]);
        return i;
      }, o.vectorTile = Ah, o.version = "1.13.3", o.warnOnce = at, o.webpSupported = En, o.window = I, o.wrap = X;
    }), h(["./shared"], function(o) {
      function m(N) {
        var F = typeof N;
        if (F === "number" || F === "boolean" || F === "string" || N == null)
          return JSON.stringify(N);
        if (Array.isArray(N)) {
          for (var U = "[", Z = 0, ee = N; Z < ee.length; Z += 1)
            U += m(ee[Z]) + ",";
          return U + "]";
        }
        for (var fe = Object.keys(N).sort(), de = "{", G = 0; G < fe.length; G++)
          de += JSON.stringify(fe[G]) + ":" + m(N[fe[G]]) + ",";
        return de + "}";
      }
      function g(N) {
        for (var F = "", U = 0, Z = o.refProperties; U < Z.length; U += 1)
          F += "/" + m(N[Z[U]]);
        return F;
      }
      var b = function(N) {
        this.keyCache = {}, N && this.replace(N);
      };
      b.prototype.replace = function(N) {
        this._layerConfigs = {}, this._layers = {}, this.update(N, []);
      }, b.prototype.update = function(N, F) {
        for (var U = this, Z = 0, ee = N; Z < ee.length; Z += 1) {
          var fe = ee[Z];
          this._layerConfigs[fe.id] = fe;
          var de = this._layers[fe.id] = o.createStyleLayer(fe);
          de._featureFilter = o.featureFilter(de.filter), this.keyCache[fe.id] && delete this.keyCache[fe.id];
        }
        for (var G = 0, ie = F; G < ie.length; G += 1) {
          var ve = ie[G];
          delete this.keyCache[ve], delete this._layerConfigs[ve], delete this._layers[ve];
        }
        this.familiesBySource = {};
        for (var Ge = 0, Ze = function(st, De) {
          for (var he = {}, Ee = 0; Ee < st.length; Ee++) {
            var He = De && De[st[Ee].id] || g(st[Ee]);
            De && (De[st[Ee].id] = He);
            var jt = he[He];
            jt || (jt = he[He] = []), jt.push(st[Ee]);
          }
          var Wt = [];
          for (var Jt in he)
            Wt.push(he[Jt]);
          return Wt;
        }(o.values(this._layerConfigs), this.keyCache); Ge < Ze.length; Ge += 1) {
          var Ce = Ze[Ge].map(function(st) {
            return U._layers[st.id];
          }), Ue = Ce[0];
          if (Ue.visibility !== "none") {
            var Et = Ue.source || "", _t = this.familiesBySource[Et];
            _t || (_t = this.familiesBySource[Et] = {});
            var Le = Ue.sourceLayer || "_geojsonTileLayer", pt = _t[Le];
            pt || (pt = _t[Le] = []), pt.push(Ce);
          }
        }
      };
      var T = function(N) {
        var F = {}, U = [];
        for (var Z in N) {
          var ee = N[Z], fe = F[Z] = {};
          for (var de in ee) {
            var G = ee[+de];
            if (G && G.bitmap.width !== 0 && G.bitmap.height !== 0) {
              var ie = { x: 0, y: 0, w: G.bitmap.width + 2, h: G.bitmap.height + 2 };
              U.push(ie), fe[de] = { rect: ie, metrics: G.metrics };
            }
          }
        }
        var ve = o.potpack(U), Ge = new o.AlphaImage({ width: ve.w || 1, height: ve.h || 1 });
        for (var Ze in N) {
          var Ce = N[Ze];
          for (var Ue in Ce) {
            var Et = Ce[+Ue];
            if (Et && Et.bitmap.width !== 0 && Et.bitmap.height !== 0) {
              var _t = F[Ze][Ue].rect;
              o.AlphaImage.copy(Et.bitmap, Ge, { x: 0, y: 0 }, { x: _t.x + 1, y: _t.y + 1 }, Et.bitmap);
            }
          }
        }
        this.image = Ge, this.positions = F;
      };
      o.register("GlyphAtlas", T);
      var M = function(N) {
        this.tileID = new o.OverscaledTileID(N.tileID.overscaledZ, N.tileID.wrap, N.tileID.canonical.z, N.tileID.canonical.x, N.tileID.canonical.y), this.uid = N.uid, this.zoom = N.zoom, this.pixelRatio = N.pixelRatio, this.tileSize = N.tileSize, this.source = N.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = N.showCollisionBoxes, this.collectResourceTiming = !!N.collectResourceTiming, this.returnDependencies = !!N.returnDependencies, this.promoteId = N.promoteId;
      };
      function I(N, F, U) {
        for (var Z = new o.EvaluationParameters(F), ee = 0, fe = N; ee < fe.length; ee += 1)
          fe[ee].recalculate(Z, U);
      }
      function P(N, F) {
        var U = o.getArrayBuffer(N.request, function(Z, ee, fe, de) {
          Z ? F(Z) : ee && F(null, { vectorTile: new o.vectorTile.VectorTile(new o.pbf(ee)), rawData: ee, cacheControl: fe, expires: de });
        });
        return function() {
          U.cancel(), F();
        };
      }
      M.prototype.parse = function(N, F, U, Z, ee) {
        var fe = this;
        this.status = "parsing", this.data = N, this.collisionBoxArray = new o.CollisionBoxArray();
        var de = new o.DictionaryCoder(Object.keys(N.layers).sort()), G = new o.FeatureIndex(this.tileID, this.promoteId);
        G.bucketLayerIDs = [];
        var ie, ve, Ge, Ze, Ce = {}, Ue = { featureIndex: G, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: U }, Et = F.familiesBySource[this.source];
        for (var _t in Et) {
          var Le = N.layers[_t];
          if (Le) {
            Le.version === 1 && o.warnOnce('Vector tile source "' + this.source + '" layer "' + _t + '" does not use vector tile spec v2 and therefore may have some rendering errors.');
            for (var pt = de.encode(_t), st = [], De = 0; De < Le.length; De++) {
              var he = Le.feature(De), Ee = G.getId(he, _t);
              st.push({ feature: he, id: Ee, index: De, sourceLayerIndex: pt });
            }
            for (var He = 0, jt = Et[_t]; He < jt.length; He += 1) {
              var Wt = jt[He], Jt = Wt[0];
              Jt.minzoom && this.zoom < Math.floor(Jt.minzoom) || Jt.maxzoom && this.zoom >= Jt.maxzoom || Jt.visibility !== "none" && (I(Wt, this.zoom, U), (Ce[Jt.id] = Jt.createBucket({ index: G.bucketLayerIDs.length, layers: Wt, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: pt, sourceID: this.source })).populate(st, Ue, this.tileID.canonical), G.bucketLayerIDs.push(Wt.map(function(Ur) {
                return Ur.id;
              })));
            }
          }
        }
        var Zt = o.mapObject(Ue.glyphDependencies, function(Ur) {
          return Object.keys(Ur).map(Number);
        });
        Object.keys(Zt).length ? Z.send("getGlyphs", { uid: this.uid, stacks: Zt }, function(Ur, gr) {
          ie || (ie = Ur, ve = gr, pn.call(fe));
        }) : ve = {};
        var Yn = Object.keys(Ue.iconDependencies);
        Yn.length ? Z.send("getImages", { icons: Yn, source: this.source, tileID: this.tileID, type: "icons" }, function(Ur, gr) {
          ie || (ie = Ur, Ge = gr, pn.call(fe));
        }) : Ge = {};
        var Qt = Object.keys(Ue.patternDependencies);
        function pn() {
          if (ie)
            return ee(ie);
          if (ve && Ge && Ze) {
            var Ur = new T(ve), gr = new o.ImageAtlas(Ge, Ze);
            for (var Fr in Ce) {
              var Yi = Ce[Fr];
              Yi instanceof o.SymbolBucket ? (I(Yi.layers, this.zoom, U), o.performSymbolLayout(Yi, ve, Ur.positions, Ge, gr.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : Yi.hasPattern && (Yi instanceof o.LineBucket || Yi instanceof o.FillBucket || Yi instanceof o.FillExtrusionBucket) && (I(Yi.layers, this.zoom, U), Yi.addFeatures(Ue, this.tileID.canonical, gr.patternPositions));
            }
            this.status = "done", ee(null, { buckets: o.values(Ce).filter(function($u) {
              return !$u.isEmpty();
            }), featureIndex: G, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Ur.image, imageAtlas: gr, glyphMap: this.returnDependencies ? ve : null, iconMap: this.returnDependencies ? Ge : null, glyphPositions: this.returnDependencies ? Ur.positions : null });
          }
        }
        Qt.length ? Z.send("getImages", { icons: Qt, source: this.source, tileID: this.tileID, type: "patterns" }, function(Ur, gr) {
          ie || (ie = Ur, Ze = gr, pn.call(fe));
        }) : Ze = {}, pn.call(this);
      };
      var z = function(N, F, U, Z) {
        this.actor = N, this.layerIndex = F, this.availableImages = U, this.loadVectorData = Z || P, this.loading = {}, this.loaded = {};
      };
      z.prototype.loadTile = function(N, F) {
        var U = this, Z = N.uid;
        this.loading || (this.loading = {});
        var ee = !!(N && N.request && N.request.collectResourceTiming) && new o.RequestPerformance(N.request), fe = this.loading[Z] = new M(N);
        fe.abort = this.loadVectorData(N, function(de, G) {
          if (delete U.loading[Z], de || !G)
            return fe.status = "done", U.loaded[Z] = fe, F(de);
          var ie = G.rawData, ve = {};
          G.expires && (ve.expires = G.expires), G.cacheControl && (ve.cacheControl = G.cacheControl);
          var Ge = {};
          if (ee) {
            var Ze = ee.finish();
            Ze && (Ge.resourceTiming = JSON.parse(JSON.stringify(Ze)));
          }
          fe.vectorTile = G.vectorTile, fe.parse(G.vectorTile, U.layerIndex, U.availableImages, U.actor, function(Ce, Ue) {
            if (Ce || !Ue)
              return F(Ce);
            F(null, o.extend({ rawTileData: ie.slice(0) }, Ue, ve, Ge));
          }), U.loaded = U.loaded || {}, U.loaded[Z] = fe;
        });
      }, z.prototype.reloadTile = function(N, F) {
        var U = this, Z = this.loaded, ee = N.uid, fe = this;
        if (Z && Z[ee]) {
          var de = Z[ee];
          de.showCollisionBoxes = N.showCollisionBoxes;
          var G = function(ie, ve) {
            var Ge = de.reloadCallback;
            Ge && (delete de.reloadCallback, de.parse(de.vectorTile, fe.layerIndex, U.availableImages, fe.actor, Ge)), F(ie, ve);
          };
          de.status === "parsing" ? de.reloadCallback = G : de.status === "done" && (de.vectorTile ? de.parse(de.vectorTile, this.layerIndex, this.availableImages, this.actor, G) : G());
        }
      }, z.prototype.abortTile = function(N, F) {
        var U = this.loading, Z = N.uid;
        U && U[Z] && U[Z].abort && (U[Z].abort(), delete U[Z]), F();
      }, z.prototype.removeTile = function(N, F) {
        var U = this.loaded, Z = N.uid;
        U && U[Z] && delete U[Z], F();
      };
      var V = o.window.ImageBitmap, W = function() {
        this.loaded = {};
      };
      function X(N, F) {
        if (N.length !== 0) {
          K(N[0], F);
          for (var U = 1; U < N.length; U++)
            K(N[U], !F);
        }
      }
      function K(N, F) {
        for (var U = 0, Z = 0, ee = 0, fe = N.length, de = fe - 1; ee < fe; de = ee++) {
          var G = (N[ee][0] - N[de][0]) * (N[de][1] + N[ee][1]), ie = U + G;
          Z += Math.abs(U) >= Math.abs(G) ? U - ie + G : G - ie + U, U = ie;
        }
        U + Z >= 0 != !!F && N.reverse();
      }
      W.prototype.loadTile = function(N, F) {
        var U = N.uid, Z = N.encoding, ee = N.rawImageData, fe = V && ee instanceof V ? this.getImageData(ee) : ee, de = new o.DEMData(U, fe, Z);
        this.loaded = this.loaded || {}, this.loaded[U] = de, F(null, de);
      }, W.prototype.getImageData = function(N) {
        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(N.width, N.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = N.width, this.offscreenCanvas.height = N.height, this.offscreenCanvasContext.drawImage(N, 0, 0, N.width, N.height);
        var F = this.offscreenCanvasContext.getImageData(-1, -1, N.width + 2, N.height + 2);
        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new o.RGBAImage({ width: F.width, height: F.height }, F.data);
      }, W.prototype.removeTile = function(N) {
        var F = this.loaded, U = N.uid;
        F && F[U] && delete F[U];
      };
      var se = o.vectorTile.VectorTileFeature.prototype.toGeoJSON, pe = function(N) {
        this._feature = N, this.extent = o.EXTENT, this.type = N.type, this.properties = N.tags, "id" in N && !isNaN(N.id) && (this.id = parseInt(N.id, 10));
      };
      pe.prototype.loadGeometry = function() {
        if (this._feature.type === 1) {
          for (var N = [], F = 0, U = this._feature.geometry; F < U.length; F += 1) {
            var Z = U[F];
            N.push([new o.Point$1(Z[0], Z[1])]);
          }
          return N;
        }
        for (var ee = [], fe = 0, de = this._feature.geometry; fe < de.length; fe += 1) {
          for (var G = [], ie = 0, ve = de[fe]; ie < ve.length; ie += 1) {
            var Ge = ve[ie];
            G.push(new o.Point$1(Ge[0], Ge[1]));
          }
          ee.push(G);
        }
        return ee;
      }, pe.prototype.toGeoJSON = function(N, F, U) {
        return se.call(this, N, F, U);
      };
      var xe = function(N) {
        this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = o.EXTENT, this.length = N.length, this._features = N;
      };
      xe.prototype.feature = function(N) {
        return new pe(this._features[N]);
      };
      var Fe = o.vectorTile.VectorTileFeature, ze = Pe;
      function Pe(N, F) {
        this.options = F || {}, this.features = N, this.length = N.length;
      }
      function Se(N, F) {
        this.id = typeof N.id == "number" ? N.id : void 0, this.type = N.type, this.rawGeometry = N.type === 1 ? [N.geometry] : N.geometry, this.properties = N.tags, this.extent = F || 4096;
      }
      Pe.prototype.feature = function(N) {
        return new Se(this.features[N], this.options.extent);
      }, Se.prototype.loadGeometry = function() {
        var N = this.rawGeometry;
        this.geometry = [];
        for (var F = 0; F < N.length; F++) {
          for (var U = N[F], Z = [], ee = 0; ee < U.length; ee++)
            Z.push(new o.Point$1(U[ee][0], U[ee][1]));
          this.geometry.push(Z);
        }
        return this.geometry;
      }, Se.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var N = this.geometry, F = 1 / 0, U = -1 / 0, Z = 1 / 0, ee = -1 / 0, fe = 0; fe < N.length; fe++)
          for (var de = N[fe], G = 0; G < de.length; G++) {
            var ie = de[G];
            F = Math.min(F, ie.x), U = Math.max(U, ie.x), Z = Math.min(Z, ie.y), ee = Math.max(ee, ie.y);
          }
        return [F, Z, U, ee];
      }, Se.prototype.toGeoJSON = Fe.prototype.toGeoJSON;
      var Ie = qe, Je = ze;
      function qe(N) {
        var F = new o.pbf();
        return function(U, Z) {
          for (var ee in U.layers)
            Z.writeMessage(3, at, U.layers[ee]);
        }(N, F), F.finish();
      }
      function at(N, F) {
        var U;
        F.writeVarintField(15, N.version || 1), F.writeStringField(1, N.name || ""), F.writeVarintField(5, N.extent || 4096);
        var Z = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (U = 0; U < N.length; U++)
          Z.feature = N.feature(U), F.writeMessage(2, be, Z);
        var ee = Z.keys;
        for (U = 0; U < ee.length; U++)
          F.writeStringField(3, ee[U]);
        var fe = Z.values;
        for (U = 0; U < fe.length; U++)
          F.writeMessage(4, tr, fe[U]);
      }
      function be(N, F) {
        var U = N.feature;
        U.id !== void 0 && F.writeVarintField(1, U.id), F.writeMessage(2, Ke, N), F.writeVarintField(3, U.type), F.writeMessage(4, Pt, U);
      }
      function Ke(N, F) {
        var U = N.feature, Z = N.keys, ee = N.values, fe = N.keycache, de = N.valuecache;
        for (var G in U.properties) {
          var ie = fe[G];
          ie === void 0 && (Z.push(G), fe[G] = ie = Z.length - 1), F.writeVarint(ie);
          var ve = U.properties[G], Ge = typeof ve;
          Ge !== "string" && Ge !== "boolean" && Ge !== "number" && (ve = JSON.stringify(ve));
          var Ze = Ge + ":" + ve, Ce = de[Ze];
          Ce === void 0 && (ee.push(ve), de[Ze] = Ce = ee.length - 1), F.writeVarint(Ce);
        }
      }
      function ht(N, F) {
        return (F << 3) + (7 & N);
      }
      function vt(N) {
        return N << 1 ^ N >> 31;
      }
      function Pt(N, F) {
        for (var U = N.loadGeometry(), Z = N.type, ee = 0, fe = 0, de = U.length, G = 0; G < de; G++) {
          var ie = U[G], ve = 1;
          Z === 1 && (ve = ie.length), F.writeVarint(ht(1, ve));
          for (var Ge = Z === 3 ? ie.length - 1 : ie.length, Ze = 0; Ze < Ge; Ze++) {
            Ze === 1 && Z !== 1 && F.writeVarint(ht(2, Ge - 1));
            var Ce = ie[Ze].x - ee, Ue = ie[Ze].y - fe;
            F.writeVarint(vt(Ce)), F.writeVarint(vt(Ue)), ee += Ce, fe += Ue;
          }
          Z === 3 && F.writeVarint(ht(7, 1));
        }
      }
      function tr(N, F) {
        var U = typeof N;
        U === "string" ? F.writeStringField(1, N) : U === "boolean" ? F.writeBooleanField(7, N) : U === "number" && (N % 1 != 0 ? F.writeDoubleField(3, N) : N < 0 ? F.writeSVarintField(6, N) : F.writeVarintField(5, N));
      }
      function Pn(N, F, U, Z) {
        Rr(N, U, Z), Rr(F, 2 * U, 2 * Z), Rr(F, 2 * U + 1, 2 * Z + 1);
      }
      function Rr(N, F, U) {
        var Z = N[F];
        N[F] = N[U], N[U] = Z;
      }
      function pr(N, F, U, Z) {
        var ee = N - U, fe = F - Z;
        return ee * ee + fe * fe;
      }
      Ie.fromVectorTileJs = qe, Ie.fromGeojsonVt = function(N, F) {
        F = F || {};
        var U = {};
        for (var Z in N)
          U[Z] = new ze(N[Z].features, F), U[Z].name = Z, U[Z].version = F.version, U[Z].extent = F.extent;
        return qe({ layers: U });
      }, Ie.GeoJSONWrapper = Je;
      var Zn = function(N) {
        return N[0];
      }, zr = function(N) {
        return N[1];
      }, Fi = function(N, F, U, Z, ee) {
        F === void 0 && (F = Zn), U === void 0 && (U = zr), Z === void 0 && (Z = 64), ee === void 0 && (ee = Float64Array), this.nodeSize = Z, this.points = N;
        for (var fe = N.length < 65536 ? Uint16Array : Uint32Array, de = this.ids = new fe(N.length), G = this.coords = new ee(2 * N.length), ie = 0; ie < N.length; ie++)
          de[ie] = ie, G[2 * ie] = F(N[ie]), G[2 * ie + 1] = U(N[ie]);
        (function ve(Ge, Ze, Ce, Ue, Et, _t) {
          if (!(Et - Ue <= Ce)) {
            var Le = Ue + Et >> 1;
            (function pt(st, De, he, Ee, He, jt) {
              for (; He > Ee; ) {
                if (He - Ee > 600) {
                  var Wt = He - Ee + 1, Jt = he - Ee + 1, Zt = Math.log(Wt), Yn = 0.5 * Math.exp(2 * Zt / 3), Qt = 0.5 * Math.sqrt(Zt * Yn * (Wt - Yn) / Wt) * (Jt - Wt / 2 < 0 ? -1 : 1);
                  pt(st, De, he, Math.max(Ee, Math.floor(he - Jt * Yn / Wt + Qt)), Math.min(He, Math.floor(he + (Wt - Jt) * Yn / Wt + Qt)), jt);
                }
                var pn = De[2 * he + jt], Ur = Ee, gr = He;
                for (Pn(st, De, Ee, he), De[2 * He + jt] > pn && Pn(st, De, Ee, He); Ur < gr; ) {
                  for (Pn(st, De, Ur, gr), Ur++, gr--; De[2 * Ur + jt] < pn; )
                    Ur++;
                  for (; De[2 * gr + jt] > pn; )
                    gr--;
                }
                De[2 * Ee + jt] === pn ? Pn(st, De, Ee, gr) : Pn(st, De, ++gr, He), gr <= he && (Ee = gr + 1), he <= gr && (He = gr - 1);
              }
            })(Ge, Ze, Le, Ue, Et, _t % 2), ve(Ge, Ze, Ce, Ue, Le - 1, _t + 1), ve(Ge, Ze, Ce, Le + 1, Et, _t + 1);
          }
        })(de, G, Z, 0, de.length - 1, 0);
      };
      Fi.prototype.range = function(N, F, U, Z) {
        return function(ee, fe, de, G, ie, ve, Ge) {
          for (var Ze, Ce, Ue = [0, ee.length - 1, 0], Et = []; Ue.length; ) {
            var _t = Ue.pop(), Le = Ue.pop(), pt = Ue.pop();
            if (Le - pt <= Ge)
              for (var st = pt; st <= Le; st++)
                Ce = fe[2 * st + 1], (Ze = fe[2 * st]) >= de && Ze <= ie && Ce >= G && Ce <= ve && Et.push(ee[st]);
            else {
              var De = Math.floor((pt + Le) / 2);
              Ce = fe[2 * De + 1], (Ze = fe[2 * De]) >= de && Ze <= ie && Ce >= G && Ce <= ve && Et.push(ee[De]);
              var he = (_t + 1) % 2;
              (_t === 0 ? de <= Ze : G <= Ce) && (Ue.push(pt), Ue.push(De - 1), Ue.push(he)), (_t === 0 ? ie >= Ze : ve >= Ce) && (Ue.push(De + 1), Ue.push(Le), Ue.push(he));
            }
          }
          return Et;
        }(this.ids, this.coords, N, F, U, Z, this.nodeSize);
      }, Fi.prototype.within = function(N, F, U) {
        return function(Z, ee, fe, de, G, ie) {
          for (var ve = [0, Z.length - 1, 0], Ge = [], Ze = G * G; ve.length; ) {
            var Ce = ve.pop(), Ue = ve.pop(), Et = ve.pop();
            if (Ue - Et <= ie)
              for (var _t = Et; _t <= Ue; _t++)
                pr(ee[2 * _t], ee[2 * _t + 1], fe, de) <= Ze && Ge.push(Z[_t]);
            else {
              var Le = Math.floor((Et + Ue) / 2), pt = ee[2 * Le], st = ee[2 * Le + 1];
              pr(pt, st, fe, de) <= Ze && Ge.push(Z[Le]);
              var De = (Ce + 1) % 2;
              (Ce === 0 ? fe - G <= pt : de - G <= st) && (ve.push(Et), ve.push(Le - 1), ve.push(De)), (Ce === 0 ? fe + G >= pt : de + G >= st) && (ve.push(Le + 1), ve.push(Ue), ve.push(De));
            }
          }
          return Ge;
        }(this.ids, this.coords, N, F, U, this.nodeSize);
      };
      var qr = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: function(N) {
        return N;
      } }, kr = function(N) {
        this.options = ye(Object.create(qr), N), this.trees = new Array(this.options.maxZoom + 1);
      };
      function Vn(N, F, U, Z, ee) {
        return { x: N, y: F, zoom: 1 / 0, id: U, parentId: -1, numPoints: Z, properties: ee };
      }
      function Er(N, F) {
        var U = N.geometry.coordinates, Z = U[1];
        return { x: Un(U[0]), y: Y(Z), zoom: 1 / 0, index: F, parentId: -1 };
      }
      function En(N) {
        return { type: "Feature", id: N.id, properties: oi(N), geometry: { type: "Point", coordinates: [(Z = N.x, 360 * (Z - 0.5)), (F = N.y, U = (180 - 360 * F) * Math.PI / 180, 360 * Math.atan(Math.exp(U)) / Math.PI - 90)] } };
        var F, U, Z;
      }
      function oi(N) {
        var F = N.numPoints, U = F >= 1e4 ? Math.round(F / 1e3) + "k" : F >= 1e3 ? Math.round(F / 100) / 10 + "k" : F;
        return ye(ye({}, N.properties), { cluster: !0, cluster_id: N.id, point_count: F, point_count_abbreviated: U });
      }
      function Un(N) {
        return N / 360 + 0.5;
      }
      function Y(N) {
        var F = Math.sin(N * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + F) / (1 - F)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function ye(N, F) {
        for (var U in F)
          N[U] = F[U];
        return N;
      }
      function Ne(N) {
        return N.x;
      }
      function $e(N) {
        return N.y;
      }
      function We(N, F, U, Z, ee, fe) {
        var de = ee - U, G = fe - Z;
        if (de !== 0 || G !== 0) {
          var ie = ((N - U) * de + (F - Z) * G) / (de * de + G * G);
          ie > 1 ? (U = ee, Z = fe) : ie > 0 && (U += de * ie, Z += G * ie);
        }
        return (de = N - U) * de + (G = F - Z) * G;
      }
      function rt(N, F, U, Z) {
        var ee = { id: N === void 0 ? null : N, type: F, geometry: U, tags: Z, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(fe) {
          var de = fe.geometry, G = fe.type;
          if (G === "Point" || G === "MultiPoint" || G === "LineString")
            mt(fe, de);
          else if (G === "Polygon" || G === "MultiLineString")
            for (var ie = 0; ie < de.length; ie++)
              mt(fe, de[ie]);
          else if (G === "MultiPolygon")
            for (ie = 0; ie < de.length; ie++)
              for (var ve = 0; ve < de[ie].length; ve++)
                mt(fe, de[ie][ve]);
        }(ee), ee;
      }
      function mt(N, F) {
        for (var U = 0; U < F.length; U += 3)
          N.minX = Math.min(N.minX, F[U]), N.minY = Math.min(N.minY, F[U + 1]), N.maxX = Math.max(N.maxX, F[U]), N.maxY = Math.max(N.maxY, F[U + 1]);
      }
      function et(N, F, U, Z) {
        if (F.geometry) {
          var ee = F.geometry.coordinates, fe = F.geometry.type, de = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2), G = [], ie = F.id;
          if (U.promoteId ? ie = F.properties[U.promoteId] : U.generateId && (ie = Z || 0), fe === "Point")
            ut(ee, G);
          else if (fe === "MultiPoint")
            for (var ve = 0; ve < ee.length; ve++)
              ut(ee[ve], G);
          else if (fe === "LineString")
            Qe(ee, G, de, !1);
          else if (fe === "MultiLineString") {
            if (U.lineMetrics) {
              for (ve = 0; ve < ee.length; ve++)
                Qe(ee[ve], G = [], de, !1), N.push(rt(ie, "LineString", G, F.properties));
              return;
            }
            It(ee, G, de, !1);
          } else if (fe === "Polygon")
            It(ee, G, de, !0);
          else {
            if (fe !== "MultiPolygon") {
              if (fe === "GeometryCollection") {
                for (ve = 0; ve < F.geometry.geometries.length; ve++)
                  et(N, { id: ie, geometry: F.geometry.geometries[ve], properties: F.properties }, U, Z);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (ve = 0; ve < ee.length; ve++) {
              var Ge = [];
              It(ee[ve], Ge, de, !0), G.push(Ge);
            }
          }
          N.push(rt(ie, fe, G, F.properties));
        }
      }
      function ut(N, F) {
        F.push(bt(N[0])), F.push(kt(N[1])), F.push(0);
      }
      function Qe(N, F, U, Z) {
        for (var ee, fe, de = 0, G = 0; G < N.length; G++) {
          var ie = bt(N[G][0]), ve = kt(N[G][1]);
          F.push(ie), F.push(ve), F.push(0), G > 0 && (de += Z ? (ee * ve - ie * fe) / 2 : Math.sqrt(Math.pow(ie - ee, 2) + Math.pow(ve - fe, 2))), ee = ie, fe = ve;
        }
        var Ge = F.length - 3;
        F[2] = 1, function Ze(Ce, Ue, Et, _t) {
          for (var Le, pt = _t, st = Et - Ue >> 1, De = Et - Ue, he = Ce[Ue], Ee = Ce[Ue + 1], He = Ce[Et], jt = Ce[Et + 1], Wt = Ue + 3; Wt < Et; Wt += 3) {
            var Jt = We(Ce[Wt], Ce[Wt + 1], he, Ee, He, jt);
            if (Jt > pt)
              Le = Wt, pt = Jt;
            else if (Jt === pt) {
              var Zt = Math.abs(Wt - st);
              Zt < De && (Le = Wt, De = Zt);
            }
          }
          pt > _t && (Le - Ue > 3 && Ze(Ce, Ue, Le, _t), Ce[Le + 2] = pt, Et - Le > 3 && Ze(Ce, Le, Et, _t));
        }(F, 0, Ge, U), F[Ge + 2] = 1, F.size = Math.abs(de), F.start = 0, F.end = F.size;
      }
      function It(N, F, U, Z) {
        for (var ee = 0; ee < N.length; ee++) {
          var fe = [];
          Qe(N[ee], fe, U, Z), F.push(fe);
        }
      }
      function bt(N) {
        return N / 360 + 0.5;
      }
      function kt(N) {
        var F = Math.sin(N * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + F) / (1 - F)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function Ut(N, F, U, Z, ee, fe, de, G) {
        if (Z /= F, fe >= (U /= F) && de < Z)
          return N;
        if (de < U || fe >= Z)
          return null;
        for (var ie = [], ve = 0; ve < N.length; ve++) {
          var Ge = N[ve], Ze = Ge.geometry, Ce = Ge.type, Ue = ee === 0 ? Ge.minX : Ge.minY, Et = ee === 0 ? Ge.maxX : Ge.maxY;
          if (Ue >= U && Et < Z)
            ie.push(Ge);
          else if (!(Et < U || Ue >= Z)) {
            var _t = [];
            if (Ce === "Point" || Ce === "MultiPoint")
              dr(Ze, _t, U, Z, ee);
            else if (Ce === "LineString")
              Vr(Ze, _t, U, Z, ee, !1, G.lineMetrics);
            else if (Ce === "MultiLineString")
              Jr(Ze, _t, U, Z, ee, !1);
            else if (Ce === "Polygon")
              Jr(Ze, _t, U, Z, ee, !0);
            else if (Ce === "MultiPolygon")
              for (var Le = 0; Le < Ze.length; Le++) {
                var pt = [];
                Jr(Ze[Le], pt, U, Z, ee, !0), pt.length && _t.push(pt);
              }
            if (_t.length) {
              if (G.lineMetrics && Ce === "LineString") {
                for (Le = 0; Le < _t.length; Le++)
                  ie.push(rt(Ge.id, Ce, _t[Le], Ge.tags));
                continue;
              }
              Ce !== "LineString" && Ce !== "MultiLineString" || (_t.length === 1 ? (Ce = "LineString", _t = _t[0]) : Ce = "MultiLineString"), Ce !== "Point" && Ce !== "MultiPoint" || (Ce = _t.length === 3 ? "Point" : "MultiPoint"), ie.push(rt(Ge.id, Ce, _t, Ge.tags));
            }
          }
        }
        return ie.length ? ie : null;
      }
      function dr(N, F, U, Z, ee) {
        for (var fe = 0; fe < N.length; fe += 3) {
          var de = N[fe + ee];
          de >= U && de <= Z && (F.push(N[fe]), F.push(N[fe + 1]), F.push(N[fe + 2]));
        }
      }
      function Vr(N, F, U, Z, ee, fe, de) {
        for (var G, ie, ve = Lr(N), Ge = ee === 0 ? Bi : so, Ze = N.start, Ce = 0; Ce < N.length - 3; Ce += 3) {
          var Ue = N[Ce], Et = N[Ce + 1], _t = N[Ce + 2], Le = N[Ce + 3], pt = N[Ce + 4], st = ee === 0 ? Ue : Et, De = ee === 0 ? Le : pt, he = !1;
          de && (G = Math.sqrt(Math.pow(Ue - Le, 2) + Math.pow(Et - pt, 2))), st < U ? De > U && (ie = Ge(ve, Ue, Et, Le, pt, U), de && (ve.start = Ze + G * ie)) : st > Z ? De < Z && (ie = Ge(ve, Ue, Et, Le, pt, Z), de && (ve.start = Ze + G * ie)) : Xn(ve, Ue, Et, _t), De < U && st >= U && (ie = Ge(ve, Ue, Et, Le, pt, U), he = !0), De > Z && st <= Z && (ie = Ge(ve, Ue, Et, Le, pt, Z), he = !0), !fe && he && (de && (ve.end = Ze + G * ie), F.push(ve), ve = Lr(N)), de && (Ze += G);
        }
        var Ee = N.length - 3;
        Ue = N[Ee], Et = N[Ee + 1], _t = N[Ee + 2], (st = ee === 0 ? Ue : Et) >= U && st <= Z && Xn(ve, Ue, Et, _t), Ee = ve.length - 3, fe && Ee >= 3 && (ve[Ee] !== ve[0] || ve[Ee + 1] !== ve[1]) && Xn(ve, ve[0], ve[1], ve[2]), ve.length && F.push(ve);
      }
      function Lr(N) {
        var F = [];
        return F.size = N.size, F.start = N.start, F.end = N.end, F;
      }
      function Jr(N, F, U, Z, ee, fe) {
        for (var de = 0; de < N.length; de++)
          Vr(N[de], F, U, Z, ee, fe, !1);
      }
      function Xn(N, F, U, Z) {
        N.push(F), N.push(U), N.push(Z);
      }
      function Bi(N, F, U, Z, ee, fe) {
        var de = (fe - F) / (Z - F);
        return N.push(fe), N.push(U + (ee - U) * de), N.push(1), de;
      }
      function so(N, F, U, Z, ee, fe) {
        var de = (fe - U) / (ee - U);
        return N.push(F + (Z - F) * de), N.push(fe), N.push(1), de;
      }
      function Kn(N, F) {
        for (var U = [], Z = 0; Z < N.length; Z++) {
          var ee, fe = N[Z], de = fe.type;
          if (de === "Point" || de === "MultiPoint" || de === "LineString")
            ee = ki(fe.geometry, F);
          else if (de === "MultiLineString" || de === "Polygon") {
            ee = [];
            for (var G = 0; G < fe.geometry.length; G++)
              ee.push(ki(fe.geometry[G], F));
          } else if (de === "MultiPolygon")
            for (ee = [], G = 0; G < fe.geometry.length; G++) {
              for (var ie = [], ve = 0; ve < fe.geometry[G].length; ve++)
                ie.push(ki(fe.geometry[G][ve], F));
              ee.push(ie);
            }
          U.push(rt(fe.id, de, ee, fe.tags));
        }
        return U;
      }
      function ki(N, F) {
        var U = [];
        U.size = N.size, N.start !== void 0 && (U.start = N.start, U.end = N.end);
        for (var Z = 0; Z < N.length; Z += 3)
          U.push(N[Z] + F, N[Z + 1], N[Z + 2]);
        return U;
      }
      function Sn(N, F) {
        if (N.transformed)
          return N;
        var U, Z, ee, fe = 1 << N.z, de = N.x, G = N.y;
        for (U = 0; U < N.features.length; U++) {
          var ie = N.features[U], ve = ie.geometry, Ge = ie.type;
          if (ie.geometry = [], Ge === 1)
            for (Z = 0; Z < ve.length; Z += 2)
              ie.geometry.push(ai(ve[Z], ve[Z + 1], F, fe, de, G));
          else
            for (Z = 0; Z < ve.length; Z++) {
              var Ze = [];
              for (ee = 0; ee < ve[Z].length; ee += 2)
                Ze.push(ai(ve[Z][ee], ve[Z][ee + 1], F, fe, de, G));
              ie.geometry.push(Ze);
            }
        }
        return N.transformed = !0, N;
      }
      function ai(N, F, U, Z, ee, fe) {
        return [Math.round(U * (N * Z - ee)), Math.round(U * (F * Z - fe))];
      }
      function Fa(N, F, U, Z, ee) {
        for (var fe = F === ee.maxZoom ? 0 : ee.tolerance / ((1 << F) * ee.extent), de = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: U, y: Z, z: F, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, G = 0; G < N.length; G++) {
          de.numFeatures++, Uo(de, N[G], fe, ee);
          var ie = N[G].minX, ve = N[G].minY, Ge = N[G].maxX, Ze = N[G].maxY;
          ie < de.minX && (de.minX = ie), ve < de.minY && (de.minY = ve), Ge > de.maxX && (de.maxX = Ge), Ze > de.maxY && (de.maxY = Ze);
        }
        return de;
      }
      function Uo(N, F, U, Z) {
        var ee = F.geometry, fe = F.type, de = [];
        if (fe === "Point" || fe === "MultiPoint")
          for (var G = 0; G < ee.length; G += 3)
            de.push(ee[G]), de.push(ee[G + 1]), N.numPoints++, N.numSimplified++;
        else if (fe === "LineString")
          Ba(de, ee, N, U, !1, !1);
        else if (fe === "MultiLineString" || fe === "Polygon")
          for (G = 0; G < ee.length; G++)
            Ba(de, ee[G], N, U, fe === "Polygon", G === 0);
        else if (fe === "MultiPolygon")
          for (var ie = 0; ie < ee.length; ie++) {
            var ve = ee[ie];
            for (G = 0; G < ve.length; G++)
              Ba(de, ve[G], N, U, !0, G === 0);
          }
        if (de.length) {
          var Ge = F.tags || null;
          if (fe === "LineString" && Z.lineMetrics) {
            for (var Ze in Ge = {}, F.tags)
              Ge[Ze] = F.tags[Ze];
            Ge.mapbox_clip_start = ee.start / ee.size, Ge.mapbox_clip_end = ee.end / ee.size;
          }
          var Ce = { geometry: de, type: fe === "Polygon" || fe === "MultiPolygon" ? 3 : fe === "LineString" || fe === "MultiLineString" ? 2 : 1, tags: Ge };
          F.id !== null && (Ce.id = F.id), N.features.push(Ce);
        }
      }
      function Ba(N, F, U, Z, ee, fe) {
        var de = Z * Z;
        if (Z > 0 && F.size < (ee ? de : Z))
          U.numPoints += F.length / 3;
        else {
          for (var G = [], ie = 0; ie < F.length; ie += 3)
            (Z === 0 || F[ie + 2] > de) && (U.numSimplified++, G.push(F[ie]), G.push(F[ie + 1])), U.numPoints++;
          ee && function(ve, Ge) {
            for (var Ze = 0, Ce = 0, Ue = ve.length, Et = Ue - 2; Ce < Ue; Et = Ce, Ce += 2)
              Ze += (ve[Ce] - ve[Et]) * (ve[Ce + 1] + ve[Et + 1]);
            if (Ze > 0 === Ge)
              for (Ce = 0, Ue = ve.length; Ce < Ue / 2; Ce += 2) {
                var _t = ve[Ce], Le = ve[Ce + 1];
                ve[Ce] = ve[Ue - 2 - Ce], ve[Ce + 1] = ve[Ue - 1 - Ce], ve[Ue - 2 - Ce] = _t, ve[Ue - 1 - Ce] = Le;
              }
          }(G, fe), N.push(G);
        }
      }
      function na(N, F) {
        var U = (F = this.options = function(ee, fe) {
          for (var de in fe)
            ee[de] = fe[de];
          return ee;
        }(Object.create(this.options), F)).debug;
        if (U && console.time("preprocess data"), F.maxZoom < 0 || F.maxZoom > 24)
          throw new Error("maxZoom should be in the 0-24 range");
        if (F.promoteId && F.generateId)
          throw new Error("promoteId and generateId cannot be used together.");
        var Z = function(ee, fe) {
          var de = [];
          if (ee.type === "FeatureCollection")
            for (var G = 0; G < ee.features.length; G++)
              et(de, ee.features[G], fe, G);
          else
            et(de, ee.type === "Feature" ? ee : { geometry: ee }, fe);
          return de;
        }(N, F);
        this.tiles = {}, this.tileCoords = [], U && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", F.indexMaxZoom, F.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (Z = function(ee, fe) {
          var de = fe.buffer / fe.extent, G = ee, ie = Ut(ee, 1, -1 - de, de, 0, -1, 2, fe), ve = Ut(ee, 1, 1 - de, 2 + de, 0, -1, 2, fe);
          return (ie || ve) && (G = Ut(ee, 1, -de, 1 + de, 0, -1, 2, fe) || [], ie && (G = Kn(ie, 1).concat(G)), ve && (G = G.concat(Kn(ve, -1)))), G;
        }(Z, F)).length && this.splitTile(Z, 0, 0, 0), U && (Z.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function an(N, F, U) {
        return 32 * ((1 << N) * U + F) + N;
      }
      function So(N, F) {
        var U = N.tileID.canonical;
        if (!this._geoJSONIndex)
          return F(null, null);
        var Z = this._geoJSONIndex.getTile(U.z, U.x, U.y);
        if (!Z)
          return F(null, null);
        var ee = new xe(Z.features), fe = Ie(ee);
        fe.byteOffset === 0 && fe.byteLength === fe.buffer.byteLength || (fe = new Uint8Array(fe)), F(null, { vectorTile: ee, rawData: fe.buffer });
      }
      kr.prototype.load = function(N) {
        var F = this.options, U = F.log, Z = F.minZoom, ee = F.maxZoom, fe = F.nodeSize;
        U && console.time("total time");
        var de = "prepare " + N.length + " points";
        U && console.time(de), this.points = N;
        for (var G = [], ie = 0; ie < N.length; ie++)
          N[ie].geometry && G.push(Er(N[ie], ie));
        this.trees[ee + 1] = new Fi(G, Ne, $e, fe, Float32Array), U && console.timeEnd(de);
        for (var ve = ee; ve >= Z; ve--) {
          var Ge = +Date.now();
          G = this._cluster(G, ve), this.trees[ve] = new Fi(G, Ne, $e, fe, Float32Array), U && console.log("z%d: %d clusters in %dms", ve, G.length, +Date.now() - Ge);
        }
        return U && console.timeEnd("total time"), this;
      }, kr.prototype.getClusters = function(N, F) {
        var U = ((N[0] + 180) % 360 + 360) % 360 - 180, Z = Math.max(-90, Math.min(90, N[1])), ee = N[2] === 180 ? 180 : ((N[2] + 180) % 360 + 360) % 360 - 180, fe = Math.max(-90, Math.min(90, N[3]));
        if (N[2] - N[0] >= 360)
          U = -180, ee = 180;
        else if (U > ee) {
          var de = this.getClusters([U, Z, 180, fe], F), G = this.getClusters([-180, Z, ee, fe], F);
          return de.concat(G);
        }
        for (var ie = this.trees[this._limitZoom(F)], ve = [], Ge = 0, Ze = ie.range(Un(U), Y(fe), Un(ee), Y(Z)); Ge < Ze.length; Ge += 1) {
          var Ce = ie.points[Ze[Ge]];
          ve.push(Ce.numPoints ? En(Ce) : this.points[Ce.index]);
        }
        return ve;
      }, kr.prototype.getChildren = function(N) {
        var F = this._getOriginId(N), U = this._getOriginZoom(N), Z = "No cluster with the specified id.", ee = this.trees[U];
        if (!ee)
          throw new Error(Z);
        var fe = ee.points[F];
        if (!fe)
          throw new Error(Z);
        for (var de = this.options.radius / (this.options.extent * Math.pow(2, U - 1)), G = [], ie = 0, ve = ee.within(fe.x, fe.y, de); ie < ve.length; ie += 1) {
          var Ge = ee.points[ve[ie]];
          Ge.parentId === N && G.push(Ge.numPoints ? En(Ge) : this.points[Ge.index]);
        }
        if (G.length === 0)
          throw new Error(Z);
        return G;
      }, kr.prototype.getLeaves = function(N, F, U) {
        var Z = [];
        return this._appendLeaves(Z, N, F = F || 10, U = U || 0, 0), Z;
      }, kr.prototype.getTile = function(N, F, U) {
        var Z = this.trees[this._limitZoom(N)], ee = Math.pow(2, N), fe = this.options, de = fe.radius / fe.extent, G = (U - de) / ee, ie = (U + 1 + de) / ee, ve = { features: [] };
        return this._addTileFeatures(Z.range((F - de) / ee, G, (F + 1 + de) / ee, ie), Z.points, F, U, ee, ve), F === 0 && this._addTileFeatures(Z.range(1 - de / ee, G, 1, ie), Z.points, ee, U, ee, ve), F === ee - 1 && this._addTileFeatures(Z.range(0, G, de / ee, ie), Z.points, -1, U, ee, ve), ve.features.length ? ve : null;
      }, kr.prototype.getClusterExpansionZoom = function(N) {
        for (var F = this._getOriginZoom(N) - 1; F <= this.options.maxZoom; ) {
          var U = this.getChildren(N);
          if (F++, U.length !== 1)
            break;
          N = U[0].properties.cluster_id;
        }
        return F;
      }, kr.prototype._appendLeaves = function(N, F, U, Z, ee) {
        for (var fe = 0, de = this.getChildren(F); fe < de.length; fe += 1) {
          var G = de[fe], ie = G.properties;
          if (ie && ie.cluster ? ee + ie.point_count <= Z ? ee += ie.point_count : ee = this._appendLeaves(N, ie.cluster_id, U, Z, ee) : ee < Z ? ee++ : N.push(G), N.length === U)
            break;
        }
        return ee;
      }, kr.prototype._addTileFeatures = function(N, F, U, Z, ee, fe) {
        for (var de = 0, G = N; de < G.length; de += 1) {
          var ie = F[G[de]], ve = ie.numPoints, Ge = { type: 1, geometry: [[Math.round(this.options.extent * (ie.x * ee - U)), Math.round(this.options.extent * (ie.y * ee - Z))]], tags: ve ? oi(ie) : this.points[ie.index].properties }, Ze = void 0;
          ve ? Ze = ie.id : this.options.generateId ? Ze = ie.index : this.points[ie.index].id && (Ze = this.points[ie.index].id), Ze !== void 0 && (Ge.id = Ze), fe.features.push(Ge);
        }
      }, kr.prototype._limitZoom = function(N) {
        return Math.max(this.options.minZoom, Math.min(+N, this.options.maxZoom + 1));
      }, kr.prototype._cluster = function(N, F) {
        for (var U = [], Z = this.options, ee = Z.reduce, fe = Z.minPoints, de = Z.radius / (Z.extent * Math.pow(2, F)), G = 0; G < N.length; G++) {
          var ie = N[G];
          if (!(ie.zoom <= F)) {
            ie.zoom = F;
            for (var ve = this.trees[F + 1], Ge = ve.within(ie.x, ie.y, de), Ze = ie.numPoints || 1, Ce = Ze, Ue = 0, Et = Ge; Ue < Et.length; Ue += 1) {
              var _t = ve.points[Et[Ue]];
              _t.zoom > F && (Ce += _t.numPoints || 1);
            }
            if (Ce >= fe) {
              for (var Le = ie.x * Ze, pt = ie.y * Ze, st = ee && Ze > 1 ? this._map(ie, !0) : null, De = (G << 5) + (F + 1) + this.points.length, he = 0, Ee = Ge; he < Ee.length; he += 1) {
                var He = ve.points[Ee[he]];
                if (!(He.zoom <= F)) {
                  He.zoom = F;
                  var jt = He.numPoints || 1;
                  Le += He.x * jt, pt += He.y * jt, He.parentId = De, ee && (st || (st = this._map(ie, !0)), ee(st, this._map(He)));
                }
              }
              ie.parentId = De, U.push(Vn(Le / Ce, pt / Ce, De, Ce, st));
            } else if (U.push(ie), Ce > 1)
              for (var Wt = 0, Jt = Ge; Wt < Jt.length; Wt += 1) {
                var Zt = ve.points[Jt[Wt]];
                Zt.zoom <= F || (Zt.zoom = F, U.push(Zt));
              }
          }
        }
        return U;
      }, kr.prototype._getOriginId = function(N) {
        return N - this.points.length >> 5;
      }, kr.prototype._getOriginZoom = function(N) {
        return (N - this.points.length) % 32;
      }, kr.prototype._map = function(N, F) {
        if (N.numPoints)
          return F ? ye({}, N.properties) : N.properties;
        var U = this.points[N.index].properties, Z = this.options.map(U);
        return F && Z === U ? ye({}, Z) : Z;
      }, na.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, na.prototype.splitTile = function(N, F, U, Z, ee, fe, de) {
        for (var G = [N, F, U, Z], ie = this.options, ve = ie.debug; G.length; ) {
          Z = G.pop(), U = G.pop(), F = G.pop(), N = G.pop();
          var Ge = 1 << F, Ze = an(F, U, Z), Ce = this.tiles[Ze];
          if (!Ce && (ve > 1 && console.time("creation"), Ce = this.tiles[Ze] = Fa(N, F, U, Z, ie), this.tileCoords.push({ z: F, x: U, y: Z }), ve)) {
            ve > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", F, U, Z, Ce.numFeatures, Ce.numPoints, Ce.numSimplified), console.timeEnd("creation"));
            var Ue = "z" + F;
            this.stats[Ue] = (this.stats[Ue] || 0) + 1, this.total++;
          }
          if (Ce.source = N, ee) {
            if (F === ie.maxZoom || F === ee)
              continue;
            var Et = 1 << ee - F;
            if (U !== Math.floor(fe / Et) || Z !== Math.floor(de / Et))
              continue;
          } else if (F === ie.indexMaxZoom || Ce.numPoints <= ie.indexMaxPoints)
            continue;
          if (Ce.source = null, N.length !== 0) {
            ve > 1 && console.time("clipping");
            var _t, Le, pt, st, De, he, Ee = 0.5 * ie.buffer / ie.extent, He = 0.5 - Ee, jt = 0.5 + Ee, Wt = 1 + Ee;
            _t = Le = pt = st = null, De = Ut(N, Ge, U - Ee, U + jt, 0, Ce.minX, Ce.maxX, ie), he = Ut(N, Ge, U + He, U + Wt, 0, Ce.minX, Ce.maxX, ie), N = null, De && (_t = Ut(De, Ge, Z - Ee, Z + jt, 1, Ce.minY, Ce.maxY, ie), Le = Ut(De, Ge, Z + He, Z + Wt, 1, Ce.minY, Ce.maxY, ie), De = null), he && (pt = Ut(he, Ge, Z - Ee, Z + jt, 1, Ce.minY, Ce.maxY, ie), st = Ut(he, Ge, Z + He, Z + Wt, 1, Ce.minY, Ce.maxY, ie), he = null), ve > 1 && console.timeEnd("clipping"), G.push(_t || [], F + 1, 2 * U, 2 * Z), G.push(Le || [], F + 1, 2 * U, 2 * Z + 1), G.push(pt || [], F + 1, 2 * U + 1, 2 * Z), G.push(st || [], F + 1, 2 * U + 1, 2 * Z + 1);
          }
        }
      }, na.prototype.getTile = function(N, F, U) {
        var Z = this.options, ee = Z.extent, fe = Z.debug;
        if (N < 0 || N > 24)
          return null;
        var de = 1 << N, G = an(N, F = (F % de + de) % de, U);
        if (this.tiles[G])
          return Sn(this.tiles[G], ee);
        fe > 1 && console.log("drilling down to z%d-%d-%d", N, F, U);
        for (var ie, ve = N, Ge = F, Ze = U; !ie && ve > 0; )
          ve--, Ge = Math.floor(Ge / 2), Ze = Math.floor(Ze / 2), ie = this.tiles[an(ve, Ge, Ze)];
        return ie && ie.source ? (fe > 1 && console.log("found parent tile z%d-%d-%d", ve, Ge, Ze), fe > 1 && console.time("drilling down"), this.splitTile(ie.source, ve, Ge, Ze, N, F, U), fe > 1 && console.timeEnd("drilling down"), this.tiles[G] ? Sn(this.tiles[G], ee) : null) : null;
      };
      var rl = function(N) {
        function F(U, Z, ee, fe) {
          N.call(this, U, Z, ee, So), fe && (this.loadGeoJSON = fe);
        }
        return N && (F.__proto__ = N), (F.prototype = Object.create(N && N.prototype)).constructor = F, F.prototype.loadData = function(U, Z) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), this._pendingCallback = Z, this._pendingLoadDataParams = U, this._state && this._state !== "Idle" ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());
        }, F.prototype._loadData = function() {
          var U = this;
          if (this._pendingCallback && this._pendingLoadDataParams) {
            var Z = this._pendingCallback, ee = this._pendingLoadDataParams;
            delete this._pendingCallback, delete this._pendingLoadDataParams;
            var fe = !!(ee && ee.request && ee.request.collectResourceTiming) && new o.RequestPerformance(ee.request);
            this.loadGeoJSON(ee, function(de, G) {
              if (de || !G)
                return Z(de);
              if (typeof G != "object")
                return Z(new Error("Input data given to '" + ee.source + "' is not a valid GeoJSON object."));
              (function Ce(Ue, Et) {
                var _t, Le = Ue && Ue.type;
                if (Le === "FeatureCollection")
                  for (_t = 0; _t < Ue.features.length; _t++)
                    Ce(Ue.features[_t], Et);
                else if (Le === "GeometryCollection")
                  for (_t = 0; _t < Ue.geometries.length; _t++)
                    Ce(Ue.geometries[_t], Et);
                else if (Le === "Feature")
                  Ce(Ue.geometry, Et);
                else if (Le === "Polygon")
                  X(Ue.coordinates, Et);
                else if (Le === "MultiPolygon")
                  for (_t = 0; _t < Ue.coordinates.length; _t++)
                    X(Ue.coordinates[_t], Et);
                return Ue;
              })(G, !0);
              try {
                if (ee.filter) {
                  var ie = o.createExpression(ee.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                  if (ie.result === "error")
                    throw new Error(ie.value.map(function(Ce) {
                      return Ce.key + ": " + Ce.message;
                    }).join(", "));
                  var ve = G.features.filter(function(Ce) {
                    return ie.value.evaluate({ zoom: 0 }, Ce);
                  });
                  G = { type: "FeatureCollection", features: ve };
                }
                U._geoJSONIndex = ee.cluster ? new kr(function(Ce) {
                  var Ue = Ce.superclusterOptions, Et = Ce.clusterProperties;
                  if (!Et || !Ue)
                    return Ue;
                  for (var _t = {}, Le = {}, pt = { accumulated: null, zoom: 0 }, st = { properties: null }, De = Object.keys(Et), he = 0, Ee = De; he < Ee.length; he += 1) {
                    var He = Ee[he], jt = Et[He], Wt = jt[0], Jt = o.createExpression(jt[1]), Zt = o.createExpression(typeof Wt == "string" ? [Wt, ["accumulated"], ["get", He]] : Wt);
                    _t[He] = Jt.value, Le[He] = Zt.value;
                  }
                  return Ue.map = function(Yn) {
                    st.properties = Yn;
                    for (var Qt = {}, pn = 0, Ur = De; pn < Ur.length; pn += 1) {
                      var gr = Ur[pn];
                      Qt[gr] = _t[gr].evaluate(pt, st);
                    }
                    return Qt;
                  }, Ue.reduce = function(Yn, Qt) {
                    st.properties = Qt;
                    for (var pn = 0, Ur = De; pn < Ur.length; pn += 1) {
                      var gr = Ur[pn];
                      pt.accumulated = Yn[gr], Yn[gr] = Le[gr].evaluate(pt, st);
                    }
                  }, Ue;
                }(ee)).load(G.features) : function(Ce, Ue) {
                  return new na(Ce, Ue);
                }(G, ee.geojsonVtOptions);
              } catch (Ce) {
                return Z(Ce);
              }
              U.loaded = {};
              var Ge = {};
              if (fe) {
                var Ze = fe.finish();
                Ze && (Ge.resourceTiming = {}, Ge.resourceTiming[ee.source] = JSON.parse(JSON.stringify(Ze)));
              }
              Z(null, Ge);
            });
          }
        }, F.prototype.coalesce = function() {
          this._state === "Coalescing" ? this._state = "Idle" : this._state === "NeedsLoadData" && (this._state = "Coalescing", this._loadData());
        }, F.prototype.reloadTile = function(U, Z) {
          var ee = this.loaded;
          return ee && ee[U.uid] ? N.prototype.reloadTile.call(this, U, Z) : this.loadTile(U, Z);
        }, F.prototype.loadGeoJSON = function(U, Z) {
          if (U.request)
            o.getJSON(U.request, Z);
          else {
            if (typeof U.data != "string")
              return Z(new Error("Input data given to '" + U.source + "' is not a valid GeoJSON object."));
            try {
              return Z(null, JSON.parse(U.data));
            } catch {
              return Z(new Error("Input data given to '" + U.source + "' is not a valid GeoJSON object."));
            }
          }
        }, F.prototype.removeSource = function(U, Z) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), Z();
        }, F.prototype.getClusterExpansionZoom = function(U, Z) {
          try {
            Z(null, this._geoJSONIndex.getClusterExpansionZoom(U.clusterId));
          } catch (ee) {
            Z(ee);
          }
        }, F.prototype.getClusterChildren = function(U, Z) {
          try {
            Z(null, this._geoJSONIndex.getChildren(U.clusterId));
          } catch (ee) {
            Z(ee);
          }
        }, F.prototype.getClusterLeaves = function(U, Z) {
          try {
            Z(null, this._geoJSONIndex.getLeaves(U.clusterId, U.limit, U.offset));
          } catch (ee) {
            Z(ee);
          }
        }, F;
      }(z), bn = function(N) {
        var F = this;
        this.self = N, this.actor = new o.Actor(N, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: z, geojson: rl }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function(U, Z) {
          if (F.workerSourceTypes[U])
            throw new Error('Worker source with name "' + U + '" already registered.');
          F.workerSourceTypes[U] = Z;
        }, this.self.registerRTLTextPlugin = function(U) {
          if (o.plugin.isParsed())
            throw new Error("RTL text plugin already registered.");
          o.plugin.applyArabicShaping = U.applyArabicShaping, o.plugin.processBidirectionalText = U.processBidirectionalText, o.plugin.processStyledBidirectionalText = U.processStyledBidirectionalText;
        };
      };
      return bn.prototype.setReferrer = function(N, F) {
        this.referrer = F;
      }, bn.prototype.setImages = function(N, F, U) {
        for (var Z in this.availableImages[N] = F, this.workerSources[N]) {
          var ee = this.workerSources[N][Z];
          for (var fe in ee)
            ee[fe].availableImages = F;
        }
        U();
      }, bn.prototype.setLayers = function(N, F, U) {
        this.getLayerIndex(N).replace(F), U();
      }, bn.prototype.updateLayers = function(N, F, U) {
        this.getLayerIndex(N).update(F.layers, F.removedIds), U();
      }, bn.prototype.loadTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).loadTile(F, U);
      }, bn.prototype.loadDEMTile = function(N, F, U) {
        this.getDEMWorkerSource(N, F.source).loadTile(F, U);
      }, bn.prototype.reloadTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).reloadTile(F, U);
      }, bn.prototype.abortTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).abortTile(F, U);
      }, bn.prototype.removeTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).removeTile(F, U);
      }, bn.prototype.removeDEMTile = function(N, F) {
        this.getDEMWorkerSource(N, F.source).removeTile(F);
      }, bn.prototype.removeSource = function(N, F, U) {
        if (this.workerSources[N] && this.workerSources[N][F.type] && this.workerSources[N][F.type][F.source]) {
          var Z = this.workerSources[N][F.type][F.source];
          delete this.workerSources[N][F.type][F.source], Z.removeSource !== void 0 ? Z.removeSource(F, U) : U();
        }
      }, bn.prototype.loadWorkerSource = function(N, F, U) {
        try {
          this.self.importScripts(F.url), U();
        } catch (Z) {
          U(Z.toString());
        }
      }, bn.prototype.syncRTLPluginState = function(N, F, U) {
        try {
          o.plugin.setState(F);
          var Z = o.plugin.getPluginURL();
          if (o.plugin.isLoaded() && !o.plugin.isParsed() && Z != null) {
            this.self.importScripts(Z);
            var ee = o.plugin.isParsed();
            U(ee ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + Z), ee);
          }
        } catch (fe) {
          U(fe.toString());
        }
      }, bn.prototype.getAvailableImages = function(N) {
        var F = this.availableImages[N];
        return F || (F = []), F;
      }, bn.prototype.getLayerIndex = function(N) {
        var F = this.layerIndexes[N];
        return F || (F = this.layerIndexes[N] = new b()), F;
      }, bn.prototype.getWorkerSource = function(N, F, U) {
        var Z = this;
        return this.workerSources[N] || (this.workerSources[N] = {}), this.workerSources[N][F] || (this.workerSources[N][F] = {}), this.workerSources[N][F][U] || (this.workerSources[N][F][U] = new this.workerSourceTypes[F]({ send: function(ee, fe, de) {
          Z.actor.send(ee, fe, de, N);
        } }, this.getLayerIndex(N), this.getAvailableImages(N))), this.workerSources[N][F][U];
      }, bn.prototype.getDEMWorkerSource = function(N, F) {
        return this.demWorkerSources[N] || (this.demWorkerSources[N] = {}), this.demWorkerSources[N][F] || (this.demWorkerSources[N][F] = new W()), this.demWorkerSources[N][F];
      }, bn.prototype.enforceCacheSizeLimit = function(N, F) {
        o.enforceCacheSizeLimit(F);
      }, typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope && (self.worker = new bn(self)), bn;
    }), h(["./shared"], function(o) {
      var m = o.createCommonjsModule(function(u) {
        function f(_) {
          return !c(_);
        }
        function c(_) {
          return typeof window > "u" || typeof document > "u" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return !1;
            var E, O, k = new Blob([""], { type: "text/javascript" }), R = URL.createObjectURL(k);
            try {
              O = new Worker(R), E = !0;
            } catch {
              E = !1;
            }
            return O && O.terminate(), URL.revokeObjectURL(R), E;
          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
            var E = document.createElement("canvas");
            E.width = E.height = 1;
            var O = E.getContext("2d");
            if (!O)
              return !1;
            var k = O.getImageData(0, 0, 1, 1);
            return k && k.width === E.width;
          }() ? (d[w = _ && _.failIfMajorPerformanceCaveat] === void 0 && (d[w] = function(E) {
            var O = function(R) {
              var q = document.createElement("canvas"), $ = Object.create(f.webGLContextAttributes);
              return $.failIfMajorPerformanceCaveat = R, q.probablySupportsContext ? q.probablySupportsContext("webgl", $) || q.probablySupportsContext("experimental-webgl", $) : q.supportsContext ? q.supportsContext("webgl", $) || q.supportsContext("experimental-webgl", $) : q.getContext("webgl", $) || q.getContext("experimental-webgl", $);
            }(E);
            if (!O)
              return !1;
            var k = O.createShader(O.VERTEX_SHADER);
            return !(!k || O.isContextLost()) && (O.shaderSource(k, "void main() {}"), O.compileShader(k), O.getShaderParameter(k, O.COMPILE_STATUS) === !0);
          }(w)), d[w] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          var w;
        }
        u.exports ? u.exports = f : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = f, window.mapboxgl.notSupportedReason = c);
        var d = {};
        f.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };
      }), g = { create: function(u, f, c) {
        var d = o.window.document.createElement(u);
        return f !== void 0 && (d.className = f), c && c.appendChild(d), d;
      }, createNS: function(u, f) {
        return o.window.document.createElementNS(u, f);
      } }, b = o.window.document && o.window.document.documentElement.style;
      function T(u) {
        if (!b)
          return u[0];
        for (var f = 0; f < u.length; f++)
          if (u[f] in b)
            return u[f];
        return u[0];
      }
      var M, I = T(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);
      g.disableDrag = function() {
        b && I && (M = b[I], b[I] = "none");
      }, g.enableDrag = function() {
        b && I && (b[I] = M);
      };
      var P = T(["transform", "WebkitTransform"]);
      g.setTransform = function(u, f) {
        u.style[P] = f;
      };
      var z = !1;
      try {
        var V = Object.defineProperty({}, "passive", { get: function() {
          z = !0;
        } });
        o.window.addEventListener("test", V, V), o.window.removeEventListener("test", V, V);
      } catch {
        z = !1;
      }
      g.addEventListener = function(u, f, c, d) {
        d === void 0 && (d = {}), u.addEventListener(f, c, "passive" in d && z ? d : d.capture);
      }, g.removeEventListener = function(u, f, c, d) {
        d === void 0 && (d = {}), u.removeEventListener(f, c, "passive" in d && z ? d : d.capture);
      };
      var W = function(u) {
        u.preventDefault(), u.stopPropagation(), o.window.removeEventListener("click", W, !0);
      };
      function X(u) {
        var f = u.userImage;
        return !!(f && f.render && f.render()) && (u.data.replace(new Uint8Array(f.data.buffer)), !0);
      }
      g.suppressClick = function() {
        o.window.addEventListener("click", W, !0), o.window.setTimeout(function() {
          o.window.removeEventListener("click", W, !0);
        }, 0);
      }, g.mousePos = function(u, f) {
        var c = u.getBoundingClientRect();
        return new o.Point(f.clientX - c.left - u.clientLeft, f.clientY - c.top - u.clientTop);
      }, g.touchPos = function(u, f) {
        for (var c = u.getBoundingClientRect(), d = [], _ = 0; _ < f.length; _++)
          d.push(new o.Point(f[_].clientX - c.left - u.clientLeft, f[_].clientY - c.top - u.clientTop));
        return d;
      }, g.mouseButton = function(u) {
        return o.window.InstallTrigger !== void 0 && u.button === 2 && u.ctrlKey && o.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : u.button;
      }, g.remove = function(u) {
        u.parentNode && u.parentNode.removeChild(u);
      };
      var K = function(u) {
        function f() {
          u.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.RGBAImage({ width: 1, height: 1 }), this.dirty = !0;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.isLoaded = function() {
          return this.loaded;
        }, f.prototype.setLoaded = function(c) {
          if (this.loaded !== c && (this.loaded = c, c)) {
            for (var d = 0, _ = this.requestors; d < _.length; d += 1) {
              var w = _[d];
              this._notify(w.ids, w.callback);
            }
            this.requestors = [];
          }
        }, f.prototype.getImage = function(c) {
          return this.images[c];
        }, f.prototype.addImage = function(c, d) {
          this._validate(c, d) && (this.images[c] = d);
        }, f.prototype._validate = function(c, d) {
          var _ = !0;
          return this._validateStretch(d.stretchX, d.data && d.data.width) || (this.fire(new o.ErrorEvent(new Error('Image "' + c + '" has invalid "stretchX" value'))), _ = !1), this._validateStretch(d.stretchY, d.data && d.data.height) || (this.fire(new o.ErrorEvent(new Error('Image "' + c + '" has invalid "stretchY" value'))), _ = !1), this._validateContent(d.content, d) || (this.fire(new o.ErrorEvent(new Error('Image "' + c + '" has invalid "content" value'))), _ = !1), _;
        }, f.prototype._validateStretch = function(c, d) {
          if (!c)
            return !0;
          for (var _ = 0, w = 0, E = c; w < E.length; w += 1) {
            var O = E[w];
            if (O[0] < _ || O[1] < O[0] || d < O[1])
              return !1;
            _ = O[1];
          }
          return !0;
        }, f.prototype._validateContent = function(c, d) {
          return !(c && (c.length !== 4 || c[0] < 0 || d.data.width < c[0] || c[1] < 0 || d.data.height < c[1] || c[2] < 0 || d.data.width < c[2] || c[3] < 0 || d.data.height < c[3] || c[2] < c[0] || c[3] < c[1]));
        }, f.prototype.updateImage = function(c, d) {
          d.version = this.images[c].version + 1, this.images[c] = d, this.updatedImages[c] = !0;
        }, f.prototype.removeImage = function(c) {
          var d = this.images[c];
          delete this.images[c], delete this.patterns[c], d.userImage && d.userImage.onRemove && d.userImage.onRemove();
        }, f.prototype.listImages = function() {
          return Object.keys(this.images);
        }, f.prototype.getImages = function(c, d) {
          var _ = !0;
          if (!this.isLoaded())
            for (var w = 0, E = c; w < E.length; w += 1)
              this.images[E[w]] || (_ = !1);
          this.isLoaded() || _ ? this._notify(c, d) : this.requestors.push({ ids: c, callback: d });
        }, f.prototype._notify = function(c, d) {
          for (var _ = {}, w = 0, E = c; w < E.length; w += 1) {
            var O = E[w];
            this.images[O] || this.fire(new o.Event("styleimagemissing", { id: O }));
            var k = this.images[O];
            k ? _[O] = { data: k.data.clone(), pixelRatio: k.pixelRatio, sdf: k.sdf, version: k.version, stretchX: k.stretchX, stretchY: k.stretchY, content: k.content, hasRenderCallback: Boolean(k.userImage && k.userImage.render) } : o.warnOnce('Image "' + O + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');
          }
          d(null, _);
        }, f.prototype.getPixelSize = function() {
          var c = this.atlasImage;
          return { width: c.width, height: c.height };
        }, f.prototype.getPattern = function(c) {
          var d = this.patterns[c], _ = this.getImage(c);
          if (!_)
            return null;
          if (d && d.position.version === _.version)
            return d.position;
          if (d)
            d.position.version = _.version;
          else {
            var w = { w: _.data.width + 2, h: _.data.height + 2, x: 0, y: 0 }, E = new o.ImagePosition(w, _);
            this.patterns[c] = { bin: w, position: E };
          }
          return this._updatePatternAtlas(), this.patterns[c].position;
        }, f.prototype.bind = function(c) {
          var d = c.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new o.Texture(c, this.atlasImage, d.RGBA), this.atlasTexture.bind(d.LINEAR, d.CLAMP_TO_EDGE);
        }, f.prototype._updatePatternAtlas = function() {
          var c = [];
          for (var d in this.patterns)
            c.push(this.patterns[d].bin);
          var _ = o.potpack(c), w = _.w, E = _.h, O = this.atlasImage;
          for (var k in O.resize({ width: w || 1, height: E || 1 }), this.patterns) {
            var R = this.patterns[k].bin, q = R.x + 1, $ = R.y + 1, H = this.images[k].data, ne = H.width, re = H.height;
            o.RGBAImage.copy(H, O, { x: 0, y: 0 }, { x: q, y: $ }, { width: ne, height: re }), o.RGBAImage.copy(H, O, { x: 0, y: re - 1 }, { x: q, y: $ - 1 }, { width: ne, height: 1 }), o.RGBAImage.copy(H, O, { x: 0, y: 0 }, { x: q, y: $ + re }, { width: ne, height: 1 }), o.RGBAImage.copy(H, O, { x: ne - 1, y: 0 }, { x: q - 1, y: $ }, { width: 1, height: re }), o.RGBAImage.copy(H, O, { x: 0, y: 0 }, { x: q + ne, y: $ }, { width: 1, height: re });
          }
          this.dirty = !0;
        }, f.prototype.beginFrame = function() {
          this.callbackDispatchedThisFrame = {};
        }, f.prototype.dispatchRenderCallbacks = function(c) {
          for (var d = 0, _ = c; d < _.length; d += 1) {
            var w = _[d];
            if (!this.callbackDispatchedThisFrame[w]) {
              this.callbackDispatchedThisFrame[w] = !0;
              var E = this.images[w];
              X(E) && this.updateImage(w, E);
            }
          }
        }, f;
      }(o.Evented), se = Fe, pe = Fe, xe = 1e20;
      function Fe(u, f, c, d, _, w) {
        this.fontSize = u || 24, this.buffer = f === void 0 ? 3 : f, this.cutoff = d || 0.25, this.fontFamily = _ || "sans-serif", this.fontWeight = w || "normal", this.radius = c || 8;
        var E = this.size = this.fontSize + 2 * this.buffer;
        this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = E, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(E * E), this.gridInner = new Float64Array(E * E), this.f = new Float64Array(E), this.d = new Float64Array(E), this.z = new Float64Array(E + 1), this.v = new Int16Array(E), this.middle = Math.round(E / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
      }
      function ze(u, f, c, d, _, w, E) {
        for (var O = 0; O < f; O++) {
          for (var k = 0; k < c; k++)
            d[k] = u[k * f + O];
          for (Pe(d, _, w, E, c), k = 0; k < c; k++)
            u[k * f + O] = _[k];
        }
        for (k = 0; k < c; k++) {
          for (O = 0; O < f; O++)
            d[O] = u[k * f + O];
          for (Pe(d, _, w, E, f), O = 0; O < f; O++)
            u[k * f + O] = Math.sqrt(_[O]);
        }
      }
      function Pe(u, f, c, d, _) {
        c[0] = 0, d[0] = -xe, d[1] = +xe;
        for (var w = 1, E = 0; w < _; w++) {
          for (var O = (u[w] + w * w - (u[c[E]] + c[E] * c[E])) / (2 * w - 2 * c[E]); O <= d[E]; )
            E--, O = (u[w] + w * w - (u[c[E]] + c[E] * c[E])) / (2 * w - 2 * c[E]);
          c[++E] = w, d[E] = O, d[E + 1] = +xe;
        }
        for (w = 0, E = 0; w < _; w++) {
          for (; d[E + 1] < w; )
            E++;
          f[w] = (w - c[E]) * (w - c[E]) + u[c[E]];
        }
      }
      Fe.prototype.draw = function(u) {
        this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(u, this.buffer, this.middle);
        for (var f = this.ctx.getImageData(0, 0, this.size, this.size), c = new Uint8ClampedArray(this.size * this.size), d = 0; d < this.size * this.size; d++) {
          var _ = f.data[4 * d + 3] / 255;
          this.gridOuter[d] = _ === 1 ? 0 : _ === 0 ? xe : Math.pow(Math.max(0, 0.5 - _), 2), this.gridInner[d] = _ === 1 ? xe : _ === 0 ? 0 : Math.pow(Math.max(0, _ - 0.5), 2);
        }
        for (ze(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), ze(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), d = 0; d < this.size * this.size; d++)
          c[d] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[d] - this.gridInner[d]) / this.radius + this.cutoff))));
        return c;
      }, se.default = pe;
      var Se = function(u, f) {
        this.requestManager = u, this.localIdeographFontFamily = f, this.entries = {};
      };
      Se.prototype.setURL = function(u) {
        this.url = u;
      }, Se.prototype.getGlyphs = function(u, f) {
        var c = this, d = [];
        for (var _ in u)
          for (var w = 0, E = u[_]; w < E.length; w += 1)
            d.push({ stack: _, id: E[w] });
        o.asyncAll(d, function(O, k) {
          var R = O.stack, q = O.id, $ = c.entries[R];
          $ || ($ = c.entries[R] = { glyphs: {}, requests: {}, ranges: {} });
          var H = $.glyphs[q];
          if (H === void 0) {
            if (H = c._tinySDF($, R, q))
              return $.glyphs[q] = H, void k(null, { stack: R, id: q, glyph: H });
            var ne = Math.floor(q / 256);
            if (256 * ne > 65535)
              k(new Error("glyphs > 65535 not supported"));
            else if ($.ranges[ne])
              k(null, { stack: R, id: q, glyph: H });
            else {
              var re = $.requests[ne];
              re || (re = $.requests[ne] = [], Se.loadGlyphRange(R, ne, c.url, c.requestManager, function(ue, J) {
                if (J) {
                  for (var le in J)
                    c._doesCharSupportLocalGlyph(+le) || ($.glyphs[+le] = J[+le]);
                  $.ranges[ne] = !0;
                }
                for (var me = 0, _e = re; me < _e.length; me += 1)
                  (0, _e[me])(ue, J);
                delete $.requests[ne];
              })), re.push(function(ue, J) {
                ue ? k(ue) : J && k(null, { stack: R, id: q, glyph: J[q] || null });
              });
            }
          } else
            k(null, { stack: R, id: q, glyph: H });
        }, function(O, k) {
          if (O)
            f(O);
          else if (k) {
            for (var R = {}, q = 0, $ = k; q < $.length; q += 1) {
              var H = $[q], ne = H.stack, re = H.id, ue = H.glyph;
              (R[ne] || (R[ne] = {}))[re] = ue && { id: ue.id, bitmap: ue.bitmap.clone(), metrics: ue.metrics };
            }
            f(null, R);
          }
        });
      }, Se.prototype._doesCharSupportLocalGlyph = function(u) {
        return !!this.localIdeographFontFamily && (o.isChar["CJK Unified Ideographs"](u) || o.isChar["Hangul Syllables"](u) || o.isChar.Hiragana(u) || o.isChar.Katakana(u));
      }, Se.prototype._tinySDF = function(u, f, c) {
        var d = this.localIdeographFontFamily;
        if (d && this._doesCharSupportLocalGlyph(c)) {
          var _ = u.tinySDF;
          if (!_) {
            var w = "400";
            /bold/i.test(f) ? w = "900" : /medium/i.test(f) ? w = "500" : /light/i.test(f) && (w = "200"), _ = u.tinySDF = new Se.TinySDF(24, 3, 8, 0.25, d, w);
          }
          return { id: c, bitmap: new o.AlphaImage({ width: 30, height: 30 }, _.draw(String.fromCharCode(c))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } };
        }
      }, Se.loadGlyphRange = function(u, f, c, d, _) {
        var w = 256 * f, E = w + 255, O = d.transformRequest(d.normalizeGlyphsURL(c).replace("{fontstack}", u).replace("{range}", w + "-" + E), o.ResourceType.Glyphs);
        o.getArrayBuffer(O, function(k, R) {
          if (k)
            _(k);
          else if (R) {
            for (var q = {}, $ = 0, H = o.parseGlyphPBF(R); $ < H.length; $ += 1) {
              var ne = H[$];
              q[ne.id] = ne;
            }
            _(null, q);
          }
        });
      }, Se.TinySDF = se;
      var Ie = function() {
        this.specification = o.styleSpec.light.position;
      };
      Ie.prototype.possiblyEvaluate = function(u, f) {
        return o.sphericalToCartesian(u.expression.evaluate(f));
      }, Ie.prototype.interpolate = function(u, f, c) {
        return { x: o.number(u.x, f.x, c), y: o.number(u.y, f.y, c), z: o.number(u.z, f.z, c) };
      };
      var Je = new o.Properties({ anchor: new o.DataConstantProperty(o.styleSpec.light.anchor), position: new Ie(), color: new o.DataConstantProperty(o.styleSpec.light.color), intensity: new o.DataConstantProperty(o.styleSpec.light.intensity) }), qe = function(u) {
        function f(c) {
          u.call(this), this._transitionable = new o.Transitionable(Je), this.setLight(c), this._transitioning = this._transitionable.untransitioned();
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getLight = function() {
          return this._transitionable.serialize();
        }, f.prototype.setLight = function(c, d) {
          if (d === void 0 && (d = {}), !this._validate(o.validateLight, c, d))
            for (var _ in c) {
              var w = c[_];
              o.endsWith(_, "-transition") ? this._transitionable.setTransition(_.slice(0, -11), w) : this._transitionable.setValue(_, w);
            }
        }, f.prototype.updateTransitions = function(c) {
          this._transitioning = this._transitionable.transitioned(c, this._transitioning);
        }, f.prototype.hasTransition = function() {
          return this._transitioning.hasTransition();
        }, f.prototype.recalculate = function(c) {
          this.properties = this._transitioning.possiblyEvaluate(c);
        }, f.prototype._validate = function(c, d, _) {
          return (!_ || _.validate !== !1) && o.emitValidationErrors(this, c.call(o.validateStyle, o.extend({ value: d, style: { glyphs: !0, sprite: !0 }, styleSpec: o.styleSpec })));
        }, f;
      }(o.Evented), at = function(u, f) {
        this.width = u, this.height = f, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
      };
      at.prototype.getDash = function(u, f) {
        var c = u.join(",") + String(f);
        return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(u, f)), this.dashEntry[c];
      }, at.prototype.getDashRanges = function(u, f, c) {
        var d = [], _ = u.length % 2 == 1 ? -u[u.length - 1] * c : 0, w = u[0] * c, E = !0;
        d.push({ left: _, right: w, isDash: E, zeroLength: u[0] === 0 });
        for (var O = u[0], k = 1; k < u.length; k++) {
          var R = u[k];
          d.push({ left: _ = O * c, right: w = (O += R) * c, isDash: E = !E, zeroLength: R === 0 });
        }
        return d;
      }, at.prototype.addRoundDash = function(u, f, c) {
        for (var d = f / 2, _ = -c; _ <= c; _++)
          for (var w = this.width * (this.nextRow + c + _), E = 0, O = u[E], k = 0; k < this.width; k++) {
            k / O.right > 1 && (O = u[++E]);
            var R = Math.abs(k - O.left), q = Math.abs(k - O.right), $ = Math.min(R, q), H = void 0, ne = _ / c * (d + 1);
            if (O.isDash) {
              var re = d - Math.abs(ne);
              H = Math.sqrt($ * $ + re * re);
            } else
              H = d - Math.sqrt($ * $ + ne * ne);
            this.data[w + k] = Math.max(0, Math.min(255, H + 128));
          }
      }, at.prototype.addRegularDash = function(u) {
        for (var f = u.length - 1; f >= 0; --f) {
          var c = u[f], d = u[f + 1];
          c.zeroLength ? u.splice(f, 1) : d && d.isDash === c.isDash && (d.left = c.left, u.splice(f, 1));
        }
        var _ = u[0], w = u[u.length - 1];
        _.isDash === w.isDash && (_.left = w.left - this.width, w.right = _.right + this.width);
        for (var E = this.width * this.nextRow, O = 0, k = u[O], R = 0; R < this.width; R++) {
          R / k.right > 1 && (k = u[++O]);
          var q = Math.abs(R - k.left), $ = Math.abs(R - k.right), H = Math.min(q, $);
          this.data[E + R] = Math.max(0, Math.min(255, (k.isDash ? H : -H) + 128));
        }
      }, at.prototype.addDash = function(u, f) {
        var c = f ? 7 : 0, d = 2 * c + 1;
        if (this.nextRow + d > this.height)
          return o.warnOnce("LineAtlas out of space"), null;
        for (var _ = 0, w = 0; w < u.length; w++)
          _ += u[w];
        if (_ !== 0) {
          var E = this.width / _, O = this.getDashRanges(u, this.width, E);
          f ? this.addRoundDash(O, E, c) : this.addRegularDash(O);
        }
        var k = { y: (this.nextRow + c + 0.5) / this.height, height: 2 * c / this.height, width: _ };
        return this.nextRow += d, this.dirty = !0, k;
      }, at.prototype.bind = function(u) {
        var f = u.gl;
        this.texture ? (f.bindTexture(f.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, f.texSubImage2D(f.TEXTURE_2D, 0, 0, 0, this.width, this.height, f.ALPHA, f.UNSIGNED_BYTE, this.data))) : (this.texture = f.createTexture(), f.bindTexture(f.TEXTURE_2D, this.texture), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.REPEAT), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.REPEAT), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.LINEAR), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR), f.texImage2D(f.TEXTURE_2D, 0, f.ALPHA, this.width, this.height, 0, f.ALPHA, f.UNSIGNED_BYTE, this.data));
      };
      var be = function u(f, c) {
        this.workerPool = f, this.actors = [], this.currentActor = 0, this.id = o.uniqueId();
        for (var d = this.workerPool.acquire(this.id), _ = 0; _ < d.length; _++) {
          var w = new u.Actor(d[_], c, this.id);
          w.name = "Worker " + _, this.actors.push(w);
        }
      };
      function Ke(u, f, c) {
        var d = function(_, w) {
          if (_)
            return c(_);
          if (w) {
            var E = o.pick(o.extend(w, u), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            w.vector_layers && (E.vectorLayers = w.vector_layers, E.vectorLayerIds = E.vectorLayers.map(function(O) {
              return O.id;
            })), E.tiles = f.canonicalizeTileset(E, u.url), c(null, E);
          }
        };
        return u.url ? o.getJSON(f.transformRequest(f.normalizeSourceURL(u.url), o.ResourceType.Source), d) : o.browser.frame(function() {
          return d(null, u);
        });
      }
      be.prototype.broadcast = function(u, f, c) {
        o.asyncAll(this.actors, function(d, _) {
          d.send(u, f, _);
        }, c = c || function() {
        });
      }, be.prototype.getActor = function() {
        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
      }, be.prototype.remove = function() {
        this.actors.forEach(function(u) {
          u.remove();
        }), this.actors = [], this.workerPool.release(this.id);
      }, be.Actor = o.Actor;
      var ht = function(u, f, c) {
        this.bounds = o.LngLatBounds.convert(this.validateBounds(u)), this.minzoom = f || 0, this.maxzoom = c || 24;
      };
      ht.prototype.validateBounds = function(u) {
        return Array.isArray(u) && u.length === 4 ? [Math.max(-180, u[0]), Math.max(-90, u[1]), Math.min(180, u[2]), Math.min(90, u[3])] : [-180, -90, 180, 90];
      }, ht.prototype.contains = function(u) {
        var f = Math.pow(2, u.z), c = Math.floor(o.mercatorXfromLng(this.bounds.getWest()) * f), d = Math.floor(o.mercatorYfromLat(this.bounds.getNorth()) * f), _ = Math.ceil(o.mercatorXfromLng(this.bounds.getEast()) * f), w = Math.ceil(o.mercatorYfromLat(this.bounds.getSouth()) * f);
        return u.x >= c && u.x < _ && u.y >= d && u.y < w;
      };
      var vt = function(u) {
        function f(c, d, _, w) {
          if (u.call(this), this.id = c, this.dispatcher = _, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.extend(this, o.pick(d, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.extend({ type: "vector" }, d), this._collectResourceTiming = d.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(w);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function() {
          var c = this;
          this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = Ke(this._options, this.map._requestManager, function(d, _) {
            c._tileJSONRequest = null, c._loaded = !0, d ? c.fire(new o.ErrorEvent(d)) : _ && (o.extend(c, _), _.bounds && (c.tileBounds = new ht(_.bounds, c.minzoom, c.maxzoom)), o.postTurnstileEvent(_.tiles, c.map._requestManager._customAccessToken), o.postMapLoadEvent(_.tiles, c.map._getMapId(), c.map._requestManager._skuToken, c.map._requestManager._customAccessToken), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }, f.prototype.loaded = function() {
          return this._loaded;
        }, f.prototype.hasTile = function(c) {
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }, f.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, f.prototype.setSourceProperty = function(c) {
          this._tileJSONRequest && this._tileJSONRequest.cancel(), c(), this.map.style.sourceCaches[this.id].clearTiles(), this.load();
        }, f.prototype.setTiles = function(c) {
          var d = this;
          return this.setSourceProperty(function() {
            d._options.tiles = c;
          }), this;
        }, f.prototype.setUrl = function(c) {
          var d = this;
          return this.setSourceProperty(function() {
            d.url = c, d._options.url = c;
          }), this;
        }, f.prototype.onRemove = function() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }, f.prototype.serialize = function() {
          return o.extend({}, this._options);
        }, f.prototype.loadTile = function(c, d) {
          var _ = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme)), w = { request: this.map._requestManager.transformRequest(_, o.ResourceType.Tile), uid: c.uid, tileID: c.tileID, zoom: c.tileID.overscaledZ, tileSize: this.tileSize * c.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: o.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
          function E(O, k) {
            return delete c.request, c.aborted ? d(null) : O && O.status !== 404 ? d(O) : (k && k.resourceTiming && (c.resourceTiming = k.resourceTiming), this.map._refreshExpiredTiles && k && c.setExpiryData(k), c.loadVectorData(k, this.map.painter), o.cacheEntryPossiblyAdded(this.dispatcher), d(null), void (c.reloadCallback && (this.loadTile(c, c.reloadCallback), c.reloadCallback = null)));
          }
          w.request.collectResourceTiming = this._collectResourceTiming, c.actor && c.state !== "expired" ? c.state === "loading" ? c.reloadCallback = d : c.request = c.actor.send("reloadTile", w, E.bind(this)) : (c.actor = this.dispatcher.getActor(), c.request = c.actor.send("loadTile", w, E.bind(this)));
        }, f.prototype.abortTile = function(c) {
          c.request && (c.request.cancel(), delete c.request), c.actor && c.actor.send("abortTile", { uid: c.uid, type: this.type, source: this.id }, void 0);
        }, f.prototype.unloadTile = function(c) {
          c.unloadVectorData(), c.actor && c.actor.send("removeTile", { uid: c.uid, type: this.type, source: this.id }, void 0);
        }, f.prototype.hasTransition = function() {
          return !1;
        }, f;
      }(o.Evented), Pt = function(u) {
        function f(c, d, _, w) {
          u.call(this), this.id = c, this.dispatcher = _, this.setEventedParent(w), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.extend({ type: "raster" }, d), o.extend(this, o.pick(d, ["url", "scheme", "tileSize"]));
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function() {
          var c = this;
          this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = Ke(this._options, this.map._requestManager, function(d, _) {
            c._tileJSONRequest = null, c._loaded = !0, d ? c.fire(new o.ErrorEvent(d)) : _ && (o.extend(c, _), _.bounds && (c.tileBounds = new ht(_.bounds, c.minzoom, c.maxzoom)), o.postTurnstileEvent(_.tiles), o.postMapLoadEvent(_.tiles, c.map._getMapId(), c.map._requestManager._skuToken), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }, f.prototype.loaded = function() {
          return this._loaded;
        }, f.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, f.prototype.onRemove = function() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }, f.prototype.serialize = function() {
          return o.extend({}, this._options);
        }, f.prototype.hasTile = function(c) {
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }, f.prototype.loadTile = function(c, d) {
          var _ = this, w = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
          c.request = o.getImage(this.map._requestManager.transformRequest(w, o.ResourceType.Tile), function(E, O) {
            if (delete c.request, c.aborted)
              c.state = "unloaded", d(null);
            else if (E)
              c.state = "errored", d(E);
            else if (O) {
              _.map._refreshExpiredTiles && c.setExpiryData(O), delete O.cacheControl, delete O.expires;
              var k = _.map.painter.context, R = k.gl;
              c.texture = _.map.painter.getTileTexture(O.width), c.texture ? c.texture.update(O, { useMipmap: !0 }) : (c.texture = new o.Texture(k, O, R.RGBA, { useMipmap: !0 }), c.texture.bind(R.LINEAR, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), k.extTextureFilterAnisotropic && R.texParameterf(R.TEXTURE_2D, k.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, k.extTextureFilterAnisotropicMax)), c.state = "loaded", o.cacheEntryPossiblyAdded(_.dispatcher), d(null);
            }
          });
        }, f.prototype.abortTile = function(c, d) {
          c.request && (c.request.cancel(), delete c.request), d();
        }, f.prototype.unloadTile = function(c, d) {
          c.texture && this.map.painter.saveTileTexture(c.texture), d();
        }, f.prototype.hasTransition = function() {
          return !1;
        }, f;
      }(o.Evented), tr = function(u) {
        function f(c, d, _, w) {
          u.call(this, c, d, _, w), this.type = "raster-dem", this.maxzoom = 22, this._options = o.extend({ type: "raster-dem" }, d), this.encoding = d.encoding || "mapbox";
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.serialize = function() {
          return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
        }, f.prototype.loadTile = function(c, d) {
          var _ = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
          function w(E, O) {
            E && (c.state = "errored", d(E)), O && (c.dem = O, c.needsHillshadePrepare = !0, c.state = "loaded", d(null));
          }
          c.request = o.getImage(this.map._requestManager.transformRequest(_, o.ResourceType.Tile), function(E, O) {
            if (delete c.request, c.aborted)
              c.state = "unloaded", d(null);
            else if (E)
              c.state = "errored", d(E);
            else if (O) {
              this.map._refreshExpiredTiles && c.setExpiryData(O), delete O.cacheControl, delete O.expires;
              var k = o.window.ImageBitmap && O instanceof o.window.ImageBitmap && o.offscreenCanvasSupported() ? O : o.browser.getImageData(O, 1), R = { uid: c.uid, coord: c.tileID, source: this.id, rawImageData: k, encoding: this.encoding };
              c.actor && c.state !== "expired" || (c.actor = this.dispatcher.getActor(), c.actor.send("loadDEMTile", R, w.bind(this)));
            }
          }.bind(this)), c.neighboringTiles = this._getNeighboringTiles(c.tileID);
        }, f.prototype._getNeighboringTiles = function(c) {
          var d = c.canonical, _ = Math.pow(2, d.z), w = (d.x - 1 + _) % _, E = d.x === 0 ? c.wrap - 1 : c.wrap, O = (d.x + 1 + _) % _, k = d.x + 1 === _ ? c.wrap + 1 : c.wrap, R = {};
          return R[new o.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y).key] = { backfilled: !1 }, d.y > 0 && (R[new o.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y - 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, c.wrap, d.z, d.x, d.y - 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y - 1).key] = { backfilled: !1 }), d.y + 1 < _ && (R[new o.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y + 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, c.wrap, d.z, d.x, d.y + 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y + 1).key] = { backfilled: !1 }), R;
        }, f.prototype.unloadTile = function(c) {
          c.demTexture && this.map.painter.saveTileTexture(c.demTexture), c.fbo && (c.fbo.destroy(), delete c.fbo), c.dem && delete c.dem, delete c.neighboringTiles, c.state = "unloaded", c.actor && c.actor.send("removeDEMTile", { uid: c.uid, source: this.id });
        }, f;
      }(Pt), Pn = function(u) {
        function f(c, d, _, w) {
          u.call(this), this.id = c, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._loaded = !1, this.actor = _.getActor(), this.setEventedParent(w), this._data = d.data, this._options = o.extend({}, d), this._collectResourceTiming = d.collectResourceTiming, this._resourceTiming = [], d.maxzoom !== void 0 && (this.maxzoom = d.maxzoom), d.type && (this.type = d.type), d.attribution && (this.attribution = d.attribution), this.promoteId = d.promoteId;
          var E = o.EXTENT / this.tileSize;
          this.workerOptions = o.extend({ source: this.id, cluster: d.cluster || !1, geojsonVtOptions: { buffer: (d.buffer !== void 0 ? d.buffer : 128) * E, tolerance: (d.tolerance !== void 0 ? d.tolerance : 0.375) * E, extent: o.EXTENT, maxZoom: this.maxzoom, lineMetrics: d.lineMetrics || !1, generateId: d.generateId || !1 }, superclusterOptions: { maxZoom: d.clusterMaxZoom !== void 0 ? Math.min(d.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, minPoints: Math.max(2, d.clusterMinPoints || 2), extent: o.EXTENT, radius: (d.clusterRadius || 50) * E, log: !1, generateId: d.generateId || !1 }, clusterProperties: d.clusterProperties, filter: d.filter }, d.workerOptions);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function() {
          var c = this;
          this.fire(new o.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(d) {
            if (d)
              c.fire(new o.ErrorEvent(d));
            else {
              var _ = { dataType: "source", sourceDataType: "metadata" };
              c._collectResourceTiming && c._resourceTiming && c._resourceTiming.length > 0 && (_.resourceTiming = c._resourceTiming, c._resourceTiming = []), c.fire(new o.Event("data", _));
            }
          });
        }, f.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, f.prototype.setData = function(c) {
          var d = this;
          return this._data = c, this.fire(new o.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(_) {
            if (_)
              d.fire(new o.ErrorEvent(_));
            else {
              var w = { dataType: "source", sourceDataType: "content" };
              d._collectResourceTiming && d._resourceTiming && d._resourceTiming.length > 0 && (w.resourceTiming = d._resourceTiming, d._resourceTiming = []), d.fire(new o.Event("data", w));
            }
          }), this;
        }, f.prototype.getClusterExpansionZoom = function(c, d) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: c, source: this.id }, d), this;
        }, f.prototype.getClusterChildren = function(c, d) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: c, source: this.id }, d), this;
        }, f.prototype.getClusterLeaves = function(c, d, _, w) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: c, limit: d, offset: _ }, w), this;
        }, f.prototype._updateWorkerData = function(c) {
          var d = this;
          this._loaded = !1;
          var _ = o.extend({}, this.workerOptions), w = this._data;
          typeof w == "string" ? (_.request = this.map._requestManager.transformRequest(o.browser.resolveURL(w), o.ResourceType.Source), _.request.collectResourceTiming = this._collectResourceTiming) : _.data = JSON.stringify(w), this.actor.send(this.type + ".loadData", _, function(E, O) {
            d._removed || O && O.abandoned || (d._loaded = !0, O && O.resourceTiming && O.resourceTiming[d.id] && (d._resourceTiming = O.resourceTiming[d.id].slice(0)), d.actor.send(d.type + ".coalesce", { source: _.source }, null), c(E));
          });
        }, f.prototype.loaded = function() {
          return this._loaded;
        }, f.prototype.loadTile = function(c, d) {
          var _ = this, w = c.actor ? "reloadTile" : "loadTile";
          c.actor = this.actor, c.request = this.actor.send(w, { type: this.type, uid: c.uid, tileID: c.tileID, zoom: c.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: o.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, function(E, O) {
            return delete c.request, c.unloadVectorData(), c.aborted ? d(null) : E ? d(E) : (c.loadVectorData(O, _.map.painter, w === "reloadTile"), d(null));
          });
        }, f.prototype.abortTile = function(c) {
          c.request && (c.request.cancel(), delete c.request), c.aborted = !0;
        }, f.prototype.unloadTile = function(c) {
          c.unloadVectorData(), this.actor.send("removeTile", { uid: c.uid, type: this.type, source: this.id });
        }, f.prototype.onRemove = function() {
          this._removed = !0, this.actor.send("removeSource", { type: this.type, source: this.id });
        }, f.prototype.serialize = function() {
          return o.extend({}, this._options, { type: this.type, data: this._data });
        }, f.prototype.hasTransition = function() {
          return !1;
        }, f;
      }(o.Evented), Rr = o.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]), pr = function(u) {
        function f(c, d, _, w) {
          u.call(this), this.id = c, this.dispatcher = _, this.coordinates = d.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(w), this.options = d;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function(c, d) {
          var _ = this;
          this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this.url = this.options.url, o.getImage(this.map._requestManager.transformRequest(this.url, o.ResourceType.Image), function(w, E) {
            _._loaded = !0, w ? _.fire(new o.ErrorEvent(w)) : E && (_.image = E, c && (_.coordinates = c), d && d(), _._finishLoading());
          });
        }, f.prototype.loaded = function() {
          return this._loaded;
        }, f.prototype.updateImage = function(c) {
          var d = this;
          return this.image && c.url ? (this.options.url = c.url, this.load(c.coordinates, function() {
            d.texture = null;
          }), this) : this;
        }, f.prototype._finishLoading = function() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })));
        }, f.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, f.prototype.setCoordinates = function(c) {
          var d = this;
          this.coordinates = c;
          var _ = c.map(o.MercatorCoordinate.fromLngLat);
          this.tileID = function(E) {
            for (var O = 1 / 0, k = 1 / 0, R = -1 / 0, q = -1 / 0, $ = 0, H = E; $ < H.length; $ += 1) {
              var ne = H[$];
              O = Math.min(O, ne.x), k = Math.min(k, ne.y), R = Math.max(R, ne.x), q = Math.max(q, ne.y);
            }
            var re = Math.max(R - O, q - k), ue = Math.max(0, Math.floor(-Math.log(re) / Math.LN2)), J = Math.pow(2, ue);
            return new o.CanonicalTileID(ue, Math.floor((O + R) / 2 * J), Math.floor((k + q) / 2 * J));
          }(_), this.minzoom = this.maxzoom = this.tileID.z;
          var w = _.map(function(E) {
            return d.tileID.getTilePoint(E)._round();
          });
          return this._boundsArray = new o.StructArrayLayout4i8(), this._boundsArray.emplaceBack(w[0].x, w[0].y, 0, 0), this._boundsArray.emplaceBack(w[1].x, w[1].y, o.EXTENT, 0), this._boundsArray.emplaceBack(w[3].x, w[3].y, 0, o.EXTENT), this._boundsArray.emplaceBack(w[2].x, w[2].y, o.EXTENT, o.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })), this;
        }, f.prototype.prepare = function() {
          if (Object.keys(this.tiles).length !== 0 && this.image) {
            var c = this.map.painter.context, d = c.gl;
            for (var _ in this.boundsBuffer || (this.boundsBuffer = c.createVertexBuffer(this._boundsArray, Rr.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new o.Texture(c, this.image, d.RGBA), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE)), this.tiles) {
              var w = this.tiles[_];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture);
            }
          }
        }, f.prototype.loadTile = function(c, d) {
          this.tileID && this.tileID.equals(c.tileID.canonical) ? (this.tiles[String(c.tileID.wrap)] = c, c.buckets = {}, d(null)) : (c.state = "errored", d(null));
        }, f.prototype.serialize = function() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }, f.prototype.hasTransition = function() {
          return !1;
        }, f;
      }(o.Evented), Zn = function(u) {
        function f(c, d, _, w) {
          u.call(this, c, d, _, w), this.roundZoom = !0, this.type = "video", this.options = d;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function() {
          var c = this;
          this._loaded = !1;
          var d = this.options;
          this.urls = [];
          for (var _ = 0, w = d.urls; _ < w.length; _ += 1)
            this.urls.push(this.map._requestManager.transformRequest(w[_], o.ResourceType.Source).url);
          o.getVideo(this.urls, function(E, O) {
            c._loaded = !0, E ? c.fire(new o.ErrorEvent(E)) : O && (c.video = O, c.video.loop = !0, c.video.setAttribute("playsinline", ""), c.video.addEventListener("playing", function() {
              c.map.triggerRepaint();
            }), c.map && c.video.play(), c._finishLoading());
          });
        }, f.prototype.pause = function() {
          this.video && this.video.pause();
        }, f.prototype.play = function() {
          this.video && this.video.play();
        }, f.prototype.seek = function(c) {
          if (this.video) {
            var d = this.video.seekable;
            c < d.start(0) || c > d.end(0) ? this.fire(new o.ErrorEvent(new o.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + d.start(0) + " and " + d.end(0) + "-second mark."))) : this.video.currentTime = c;
          }
        }, f.prototype.getVideo = function() {
          return this.video;
        }, f.prototype.onAdd = function(c) {
          this.map || (this.map = c, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }, f.prototype.prepare = function() {
          if (!(Object.keys(this.tiles).length === 0 || this.video.readyState < 2)) {
            var c = this.map.painter.context, d = c.gl;
            for (var _ in this.boundsBuffer || (this.boundsBuffer = c.createVertexBuffer(this._boundsArray, Rr.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE), d.texSubImage2D(d.TEXTURE_2D, 0, 0, 0, d.RGBA, d.UNSIGNED_BYTE, this.video)) : (this.texture = new o.Texture(c, this.video, d.RGBA), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE)), this.tiles) {
              var w = this.tiles[_];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture);
            }
          }
        }, f.prototype.serialize = function() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }, f.prototype.hasTransition = function() {
          return this.video && !this.video.paused;
        }, f;
      }(pr), zr = function(u) {
        function f(c, d, _, w) {
          u.call(this, c, d, _, w), d.coordinates ? Array.isArray(d.coordinates) && d.coordinates.length === 4 && !d.coordinates.some(function(E) {
            return !Array.isArray(E) || E.length !== 2 || E.some(function(O) {
              return typeof O != "number";
            });
          }) || this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, 'missing required property "coordinates"'))), d.animate && typeof d.animate != "boolean" && this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, 'optional "animate" property must be a boolean value'))), d.canvas ? typeof d.canvas == "string" || d.canvas instanceof o.window.HTMLCanvasElement || this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, 'missing required property "canvas"'))), this.options = d, this.animate = d.animate === void 0 || d.animate;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.load = function() {
          this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof o.window.HTMLCanvasElement ? this.options.canvas : o.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = !0, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = !1);
          }, this._finishLoading());
        }, f.prototype.getCanvas = function() {
          return this.canvas;
        }, f.prototype.onAdd = function(c) {
          this.map = c, this.load(), this.canvas && this.animate && this.play();
        }, f.prototype.onRemove = function() {
          this.pause();
        }, f.prototype.prepare = function() {
          var c = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, c = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, c = !0), !this._hasInvalidDimensions() && Object.keys(this.tiles).length !== 0) {
            var d = this.map.painter.context, _ = d.gl;
            for (var w in this.boundsBuffer || (this.boundsBuffer = d.createVertexBuffer(this._boundsArray, Rr.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (c || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new o.Texture(d, this.canvas, _.RGBA, { premultiply: !0 }), this.tiles) {
              var E = this.tiles[w];
              E.state !== "loaded" && (E.state = "loaded", E.texture = this.texture);
            }
          }
        }, f.prototype.serialize = function() {
          return { type: "canvas", coordinates: this.coordinates };
        }, f.prototype.hasTransition = function() {
          return this._playing;
        }, f.prototype._hasInvalidDimensions = function() {
          for (var c = 0, d = [this.canvas.width, this.canvas.height]; c < d.length; c += 1) {
            var _ = d[c];
            if (isNaN(_) || _ <= 0)
              return !0;
          }
          return !1;
        }, f;
      }(pr), Fi = { vector: vt, raster: Pt, "raster-dem": tr, geojson: Pn, video: Zn, image: pr, canvas: zr };
      function qr(u, f) {
        var c = o.identity([]);
        return o.translate(c, c, [1, 1, 0]), o.scale(c, c, [0.5 * u.width, 0.5 * u.height, 1]), o.multiply(c, c, u.calculatePosMatrix(f.toUnwrapped()));
      }
      function kr(u, f, c, d, _, w) {
        var E = function(ue, J, le) {
          if (ue)
            for (var me = 0, _e = ue; me < _e.length; me += 1) {
              var Ae = J[_e[me]];
              if (Ae && Ae.source === le && Ae.type === "fill-extrusion")
                return !0;
            }
          else
            for (var Me in J) {
              var ke = J[Me];
              if (ke.source === le && ke.type === "fill-extrusion")
                return !0;
            }
          return !1;
        }(_ && _.layers, f, u.id), O = w.maxPitchScaleFactor(), k = u.tilesIn(d, O, E);
        k.sort(Vn);
        for (var R = [], q = 0, $ = k; q < $.length; q += 1) {
          var H = $[q];
          R.push({ wrappedTileID: H.tileID.wrapped().key, queryResults: H.tile.queryRenderedFeatures(f, c, u._state, H.queryGeometry, H.cameraQueryGeometry, H.scale, _, w, O, qr(u.transform, H.tileID)) });
        }
        var ne = function(ue) {
          for (var J = {}, le = {}, me = 0, _e = ue; me < _e.length; me += 1) {
            var Ae = _e[me], Me = Ae.queryResults, ke = Ae.wrappedTileID, je = le[ke] = le[ke] || {};
            for (var nt in Me)
              for (var tt = Me[nt], gt = je[nt] = je[nt] || {}, Dt = J[nt] = J[nt] || [], Bt = 0, zt = tt; Bt < zt.length; Bt += 1) {
                var Ir = zt[Bt];
                gt[Ir.featureIndex] || (gt[Ir.featureIndex] = !0, Dt.push(Ir));
              }
          }
          return J;
        }(R);
        for (var re in ne)
          ne[re].forEach(function(ue) {
            var J = ue.feature, le = u.getFeatureState(J.layer["source-layer"], J.id);
            J.source = J.layer.source, J.layer["source-layer"] && (J.sourceLayer = J.layer["source-layer"]), J.state = le;
          });
        return ne;
      }
      function Vn(u, f) {
        var c = u.tileID, d = f.tileID;
        return c.overscaledZ - d.overscaledZ || c.canonical.y - d.canonical.y || c.wrap - d.wrap || c.canonical.x - d.canonical.x;
      }
      var Er = function(u, f) {
        this.max = u, this.onRemove = f, this.reset();
      };
      Er.prototype.reset = function() {
        for (var u in this.data)
          for (var f = 0, c = this.data[u]; f < c.length; f += 1) {
            var d = c[f];
            d.timeout && clearTimeout(d.timeout), this.onRemove(d.value);
          }
        return this.data = {}, this.order = [], this;
      }, Er.prototype.add = function(u, f, c) {
        var d = this, _ = u.wrapped().key;
        this.data[_] === void 0 && (this.data[_] = []);
        var w = { value: f, timeout: void 0 };
        if (c !== void 0 && (w.timeout = setTimeout(function() {
          d.remove(u, w);
        }, c)), this.data[_].push(w), this.order.push(_), this.order.length > this.max) {
          var E = this._getAndRemoveByKey(this.order[0]);
          E && this.onRemove(E);
        }
        return this;
      }, Er.prototype.has = function(u) {
        return u.wrapped().key in this.data;
      }, Er.prototype.getAndRemove = function(u) {
        return this.has(u) ? this._getAndRemoveByKey(u.wrapped().key) : null;
      }, Er.prototype._getAndRemoveByKey = function(u) {
        var f = this.data[u].shift();
        return f.timeout && clearTimeout(f.timeout), this.data[u].length === 0 && delete this.data[u], this.order.splice(this.order.indexOf(u), 1), f.value;
      }, Er.prototype.getByKey = function(u) {
        var f = this.data[u];
        return f ? f[0].value : null;
      }, Er.prototype.get = function(u) {
        return this.has(u) ? this.data[u.wrapped().key][0].value : null;
      }, Er.prototype.remove = function(u, f) {
        if (!this.has(u))
          return this;
        var c = u.wrapped().key, d = f === void 0 ? 0 : this.data[c].indexOf(f), _ = this.data[c][d];
        return this.data[c].splice(d, 1), _.timeout && clearTimeout(_.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(_.value), this.order.splice(this.order.indexOf(c), 1), this;
      }, Er.prototype.setMaxSize = function(u) {
        for (this.max = u; this.order.length > this.max; ) {
          var f = this._getAndRemoveByKey(this.order[0]);
          f && this.onRemove(f);
        }
        return this;
      }, Er.prototype.filter = function(u) {
        var f = [];
        for (var c in this.data)
          for (var d = 0, _ = this.data[c]; d < _.length; d += 1) {
            var w = _[d];
            u(w.value) || f.push(w);
          }
        for (var E = 0, O = f; E < O.length; E += 1) {
          var k = O[E];
          this.remove(k.value.tileID, k);
        }
      };
      var En = function(u, f, c) {
        this.context = u;
        var d = u.gl;
        this.buffer = d.createBuffer(), this.dynamicDraw = Boolean(c), this.context.unbindVAO(), u.bindElementBuffer.set(this.buffer), d.bufferData(d.ELEMENT_ARRAY_BUFFER, f.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete f.arrayBuffer;
      };
      En.prototype.bind = function() {
        this.context.bindElementBuffer.set(this.buffer);
      }, En.prototype.updateData = function(u) {
        var f = this.context.gl;
        this.context.unbindVAO(), this.bind(), f.bufferSubData(f.ELEMENT_ARRAY_BUFFER, 0, u.arrayBuffer);
      }, En.prototype.destroy = function() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      };
      var oi = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, Un = function(u, f, c, d) {
        this.length = f.length, this.attributes = c, this.itemSize = f.bytesPerElement, this.dynamicDraw = d, this.context = u;
        var _ = u.gl;
        this.buffer = _.createBuffer(), u.bindVertexBuffer.set(this.buffer), _.bufferData(_.ARRAY_BUFFER, f.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete f.arrayBuffer;
      };
      Un.prototype.bind = function() {
        this.context.bindVertexBuffer.set(this.buffer);
      }, Un.prototype.updateData = function(u) {
        var f = this.context.gl;
        this.bind(), f.bufferSubData(f.ARRAY_BUFFER, 0, u.arrayBuffer);
      }, Un.prototype.enableAttributes = function(u, f) {
        for (var c = 0; c < this.attributes.length; c++) {
          var d = f.attributes[this.attributes[c].name];
          d !== void 0 && u.enableVertexAttribArray(d);
        }
      }, Un.prototype.setVertexAttribPointers = function(u, f, c) {
        for (var d = 0; d < this.attributes.length; d++) {
          var _ = this.attributes[d], w = f.attributes[_.name];
          w !== void 0 && u.vertexAttribPointer(w, _.components, u[oi[_.type]], !1, this.itemSize, _.offset + this.itemSize * (c || 0));
        }
      }, Un.prototype.destroy = function() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      };
      var Y = function(u) {
        this.gl = u.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
      };
      Y.prototype.get = function() {
        return this.current;
      }, Y.prototype.set = function(u) {
      }, Y.prototype.getDefault = function() {
        return this.default;
      }, Y.prototype.setDefault = function() {
        this.set(this.default);
      };
      var ye = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return o.Color.transparent;
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c.r !== d.r || c.g !== d.g || c.b !== d.b || c.a !== d.a || this.dirty) && (this.gl.clearColor(c.r, c.g, c.b, c.a), this.current = c, this.dirty = !1);
        }, f;
      }(Y), Ne = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return 1;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.clearDepth(c), this.current = c, this.dirty = !1);
        }, f;
      }(Y), $e = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return 0;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.clearStencil(c), this.current = c, this.dirty = !1);
        }, f;
      }(Y), We = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return [!0, !0, !0, !0];
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || c[3] !== d[3] || this.dirty) && (this.gl.colorMask(c[0], c[1], c[2], c[3]), this.current = c, this.dirty = !1);
        }, f;
      }(Y), rt = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !0;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.depthMask(c), this.current = c, this.dirty = !1);
        }, f;
      }(Y), mt = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return 255;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.stencilMask(c), this.current = c, this.dirty = !1);
        }, f;
      }(Y), et = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c.func !== d.func || c.ref !== d.ref || c.mask !== d.mask || this.dirty) && (this.gl.stencilFunc(c.func, c.ref, c.mask), this.current = c, this.dirty = !1);
        }, f;
      }(Y), ut = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          var c = this.gl;
          return [c.KEEP, c.KEEP, c.KEEP];
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || this.dirty) && (this.gl.stencilOp(c[0], c[1], c[2]), this.current = c, this.dirty = !1);
        }, f;
      }(Y), Qe = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.STENCIL_TEST) : d.disable(d.STENCIL_TEST), this.current = c, this.dirty = !1;
          }
        }, f;
      }(Y), It = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return [0, 1];
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || this.dirty) && (this.gl.depthRange(c[0], c[1]), this.current = c, this.dirty = !1);
        }, f;
      }(Y), bt = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.DEPTH_TEST) : d.disable(d.DEPTH_TEST), this.current = c, this.dirty = !1;
          }
        }, f;
      }(Y), kt = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return this.gl.LESS;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.depthFunc(c), this.current = c, this.dirty = !1);
        }, f;
      }(Y), Ut = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.BLEND) : d.disable(d.BLEND), this.current = c, this.dirty = !1;
          }
        }, f;
      }(Y), dr = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          var c = this.gl;
          return [c.ONE, c.ZERO];
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || this.dirty) && (this.gl.blendFunc(c[0], c[1]), this.current = c, this.dirty = !1);
        }, f;
      }(Y), Vr = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return o.Color.transparent;
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c.r !== d.r || c.g !== d.g || c.b !== d.b || c.a !== d.a || this.dirty) && (this.gl.blendColor(c.r, c.g, c.b, c.a), this.current = c, this.dirty = !1);
        }, f;
      }(Y), Lr = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return this.gl.FUNC_ADD;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.blendEquation(c), this.current = c, this.dirty = !1);
        }, f;
      }(Y), Jr = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.CULL_FACE) : d.disable(d.CULL_FACE), this.current = c, this.dirty = !1;
          }
        }, f;
      }(Y), Xn = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return this.gl.BACK;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.cullFace(c), this.current = c, this.dirty = !1);
        }, f;
      }(Y), Bi = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return this.gl.CCW;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.frontFace(c), this.current = c, this.dirty = !1);
        }, f;
      }(Y), so = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.useProgram(c), this.current = c, this.dirty = !1);
        }, f;
      }(Y), Kn = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return this.gl.TEXTURE0;
        }, f.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.activeTexture(c), this.current = c, this.dirty = !1);
        }, f;
      }(Y), ki = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          var c = this.gl;
          return [0, 0, c.drawingBufferWidth, c.drawingBufferHeight];
        }, f.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || c[3] !== d[3] || this.dirty) && (this.gl.viewport(c[0], c[1], c[2], c[3]), this.current = c, this.dirty = !1);
        }, f;
      }(Y), Sn = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindFramebuffer(d.FRAMEBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(Y), ai = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindRenderbuffer(d.RENDERBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(Y), Fa = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindTexture(d.TEXTURE_2D, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(Y), Uo = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindBuffer(d.ARRAY_BUFFER, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(Y), Ba = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          var d = this.gl;
          d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, c), this.current = c, this.dirty = !1;
        }, f;
      }(Y), na = function(u) {
        function f(c) {
          u.call(this, c), this.vao = c.extVertexArrayObject;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f.prototype.set = function(c) {
          this.vao && (c !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(c), this.current = c, this.dirty = !1);
        }, f;
      }(Y), an = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return 4;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_ALIGNMENT, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(Y), So = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(Y), rl = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return !1;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(Y), bn = function(u) {
        function f(c, d) {
          u.call(this, c), this.context = c, this.parent = d;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getDefault = function() {
          return null;
        }, f;
      }(Y), N = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.setDirty = function() {
          this.dirty = !0;
        }, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            this.context.bindFramebuffer.set(this.parent);
            var d = this.gl;
            d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, c, 0), this.current = c, this.dirty = !1;
          }
        }, f;
      }(bn), F = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            this.context.bindFramebuffer.set(this.parent);
            var d = this.gl;
            d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.RENDERBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, f;
      }(bn), U = function(u, f, c, d) {
        this.context = u, this.width = f, this.height = c;
        var _ = this.framebuffer = u.gl.createFramebuffer();
        this.colorAttachment = new N(u, _), d && (this.depthAttachment = new F(u, _));
      };
      U.prototype.destroy = function() {
        var u = this.context.gl, f = this.colorAttachment.get();
        if (f && u.deleteTexture(f), this.depthAttachment) {
          var c = this.depthAttachment.get();
          c && u.deleteRenderbuffer(c);
        }
        u.deleteFramebuffer(this.framebuffer);
      };
      var Z = function(u, f, c) {
        this.func = u, this.mask = f, this.range = c;
      };
      Z.ReadOnly = !1, Z.ReadWrite = !0, Z.disabled = new Z(519, Z.ReadOnly, [0, 1]);
      var ee = function(u, f, c, d, _, w) {
        this.test = u, this.ref = f, this.mask = c, this.fail = d, this.depthFail = _, this.pass = w;
      };
      ee.disabled = new ee({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
      var fe = function(u, f, c) {
        this.blendFunction = u, this.blendColor = f, this.mask = c;
      };
      fe.disabled = new fe(fe.Replace = [1, 0], o.Color.transparent, [!1, !1, !1, !1]), fe.unblended = new fe(fe.Replace, o.Color.transparent, [!0, !0, !0, !0]), fe.alphaBlended = new fe([1, 771], o.Color.transparent, [!0, !0, !0, !0]);
      var de = function(u, f, c) {
        this.enable = u, this.mode = f, this.frontFace = c;
      };
      de.disabled = new de(!1, 1029, 2305), de.backCCW = new de(!0, 1029, 2305);
      var G = function(u) {
        this.gl = u, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new ye(this), this.clearDepth = new Ne(this), this.clearStencil = new $e(this), this.colorMask = new We(this), this.depthMask = new rt(this), this.stencilMask = new mt(this), this.stencilFunc = new et(this), this.stencilOp = new ut(this), this.stencilTest = new Qe(this), this.depthRange = new It(this), this.depthTest = new bt(this), this.depthFunc = new kt(this), this.blend = new Ut(this), this.blendFunc = new dr(this), this.blendColor = new Vr(this), this.blendEquation = new Lr(this), this.cullFace = new Jr(this), this.cullFaceSide = new Xn(this), this.frontFace = new Bi(this), this.program = new so(this), this.activeTexture = new Kn(this), this.viewport = new ki(this), this.bindFramebuffer = new Sn(this), this.bindRenderbuffer = new ai(this), this.bindTexture = new Fa(this), this.bindVertexBuffer = new Uo(this), this.bindElementBuffer = new Ba(this), this.bindVertexArrayOES = this.extVertexArrayObject && new na(this), this.pixelStoreUnpack = new an(this), this.pixelStoreUnpackPremultiplyAlpha = new So(this), this.pixelStoreUnpackFlipY = new rl(this), this.extTextureFilterAnisotropic = u.getExtension("EXT_texture_filter_anisotropic") || u.getExtension("MOZ_EXT_texture_filter_anisotropic") || u.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = u.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = u.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (u.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = u.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = u.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = u.getParameter(u.MAX_TEXTURE_SIZE);
      };
      G.prototype.setDefault = function() {
        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
      }, G.prototype.setDirty = function() {
        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
      }, G.prototype.createIndexBuffer = function(u, f) {
        return new En(this, u, f);
      }, G.prototype.createVertexBuffer = function(u, f, c) {
        return new Un(this, u, f, c);
      }, G.prototype.createRenderbuffer = function(u, f, c) {
        var d = this.gl, _ = d.createRenderbuffer();
        return this.bindRenderbuffer.set(_), d.renderbufferStorage(d.RENDERBUFFER, u, f, c), this.bindRenderbuffer.set(null), _;
      }, G.prototype.createFramebuffer = function(u, f, c) {
        return new U(this, u, f, c);
      }, G.prototype.clear = function(u) {
        var f = u.color, c = u.depth, d = this.gl, _ = 0;
        f && (_ |= d.COLOR_BUFFER_BIT, this.clearColor.set(f), this.colorMask.set([!0, !0, !0, !0])), c !== void 0 && (_ |= d.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(c), this.depthMask.set(!0)), d.clear(_);
      }, G.prototype.setCullFace = function(u) {
        u.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(u.mode), this.frontFace.set(u.frontFace));
      }, G.prototype.setDepthMode = function(u) {
        u.func !== this.gl.ALWAYS || u.mask ? (this.depthTest.set(!0), this.depthFunc.set(u.func), this.depthMask.set(u.mask), this.depthRange.set(u.range)) : this.depthTest.set(!1);
      }, G.prototype.setStencilMode = function(u) {
        u.test.func !== this.gl.ALWAYS || u.mask ? (this.stencilTest.set(!0), this.stencilMask.set(u.mask), this.stencilOp.set([u.fail, u.depthFail, u.pass]), this.stencilFunc.set({ func: u.test.func, ref: u.ref, mask: u.test.mask })) : this.stencilTest.set(!1);
      }, G.prototype.setColorMode = function(u) {
        o.deepEqual(u.blendFunction, fe.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(u.blendFunction), this.blendColor.set(u.blendColor)), this.colorMask.set(u.mask);
      }, G.prototype.unbindVAO = function() {
        this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
      };
      var ie = function(u) {
        function f(c, d, _) {
          var w = this;
          u.call(this), this.id = c, this.dispatcher = _, this.on("data", function(E) {
            E.dataType === "source" && E.sourceDataType === "metadata" && (w._sourceLoaded = !0), w._sourceLoaded && !w._paused && E.dataType === "source" && E.sourceDataType === "content" && (w.reload(), w.transform && w.update(w.transform));
          }), this.on("error", function() {
            w._sourceErrored = !0;
          }), this._source = function(E, O, k, R) {
            var q = new Fi[O.type](E, O, k, R);
            if (q.id !== E)
              throw new Error("Expected Source id to be " + E + " instead of " + q.id);
            return o.bindAll(["load", "abort", "unload", "serialize", "prepare"], q), q;
          }(c, d, _, this), this._tiles = {}, this._cache = new Er(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new o.SourceFeatureState();
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.onAdd = function(c) {
          this.map = c, this._maxTileCacheSize = c ? c._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(c);
        }, f.prototype.onRemove = function(c) {
          this._source && this._source.onRemove && this._source.onRemove(c);
        }, f.prototype.loaded = function() {
          if (this._sourceErrored)
            return !0;
          if (!this._sourceLoaded || !this._source.loaded())
            return !1;
          for (var c in this._tiles) {
            var d = this._tiles[c];
            if (d.state !== "loaded" && d.state !== "errored")
              return !1;
          }
          return !0;
        }, f.prototype.getSource = function() {
          return this._source;
        }, f.prototype.pause = function() {
          this._paused = !0;
        }, f.prototype.resume = function() {
          if (this._paused) {
            var c = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, c && this.reload(), this.transform && this.update(this.transform);
          }
        }, f.prototype._loadTile = function(c, d) {
          return this._source.loadTile(c, d);
        }, f.prototype._unloadTile = function(c) {
          if (this._source.unloadTile)
            return this._source.unloadTile(c, function() {
            });
        }, f.prototype._abortTile = function(c) {
          if (this._source.abortTile)
            return this._source.abortTile(c, function() {
            });
        }, f.prototype.serialize = function() {
          return this._source.serialize();
        }, f.prototype.prepare = function(c) {
          for (var d in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {
            var _ = this._tiles[d];
            _.upload(c), _.prepare(this.map.style.imageManager);
          }
        }, f.prototype.getIds = function() {
          return o.values(this._tiles).map(function(c) {
            return c.tileID;
          }).sort(ve).map(function(c) {
            return c.key;
          });
        }, f.prototype.getRenderableIds = function(c) {
          var d = this, _ = [];
          for (var w in this._tiles)
            this._isIdRenderable(w, c) && _.push(this._tiles[w]);
          return c ? _.sort(function(E, O) {
            var k = E.tileID, R = O.tileID, q = new o.Point(k.canonical.x, k.canonical.y)._rotate(d.transform.angle), $ = new o.Point(R.canonical.x, R.canonical.y)._rotate(d.transform.angle);
            return k.overscaledZ - R.overscaledZ || $.y - q.y || $.x - q.x;
          }).map(function(E) {
            return E.tileID.key;
          }) : _.map(function(E) {
            return E.tileID;
          }).sort(ve).map(function(E) {
            return E.key;
          });
        }, f.prototype.hasRenderableParent = function(c) {
          var d = this.findLoadedParent(c, 0);
          return !!d && this._isIdRenderable(d.tileID.key);
        }, f.prototype._isIdRenderable = function(c, d) {
          return this._tiles[c] && this._tiles[c].hasData() && !this._coveredTiles[c] && (d || !this._tiles[c].holdingForFade());
        }, f.prototype.reload = function() {
          if (this._paused)
            this._shouldReloadOnResume = !0;
          else
            for (var c in this._cache.reset(), this._tiles)
              this._tiles[c].state !== "errored" && this._reloadTile(c, "reloading");
        }, f.prototype._reloadTile = function(c, d) {
          var _ = this._tiles[c];
          _ && (_.state !== "loading" && (_.state = d), this._loadTile(_, this._tileLoaded.bind(this, _, c, d)));
        }, f.prototype._tileLoaded = function(c, d, _, w) {
          if (w)
            return c.state = "errored", void (w.status !== 404 ? this._source.fire(new o.ErrorEvent(w, { tile: c })) : this.update(this.transform));
          c.timeAdded = o.browser.now(), _ === "expired" && (c.refreshedUponExpiration = !0), this._setTileReloadTimer(d, c), this.getSource().type === "raster-dem" && c.dem && this._backfillDEM(c), this._state.initializeTileState(c, this.map ? this.map.painter : null), this._source.fire(new o.Event("data", { dataType: "source", tile: c, coord: c.tileID }));
        }, f.prototype._backfillDEM = function(c) {
          for (var d = this.getRenderableIds(), _ = 0; _ < d.length; _++) {
            var w = d[_];
            if (c.neighboringTiles && c.neighboringTiles[w]) {
              var E = this.getTileByID(w);
              O(c, E), O(E, c);
            }
          }
          function O(k, R) {
            k.needsHillshadePrepare = !0;
            var q = R.tileID.canonical.x - k.tileID.canonical.x, $ = R.tileID.canonical.y - k.tileID.canonical.y, H = Math.pow(2, k.tileID.canonical.z), ne = R.tileID.key;
            q === 0 && $ === 0 || Math.abs($) > 1 || (Math.abs(q) > 1 && (Math.abs(q + H) === 1 ? q += H : Math.abs(q - H) === 1 && (q -= H)), R.dem && k.dem && (k.dem.backfillBorder(R.dem, q, $), k.neighboringTiles && k.neighboringTiles[ne] && (k.neighboringTiles[ne].backfilled = !0)));
          }
        }, f.prototype.getTile = function(c) {
          return this.getTileByID(c.key);
        }, f.prototype.getTileByID = function(c) {
          return this._tiles[c];
        }, f.prototype._retainLoadedChildren = function(c, d, _, w) {
          for (var E in this._tiles) {
            var O = this._tiles[E];
            if (!(w[E] || !O.hasData() || O.tileID.overscaledZ <= d || O.tileID.overscaledZ > _)) {
              for (var k = O.tileID; O && O.tileID.overscaledZ > d + 1; ) {
                var R = O.tileID.scaledTo(O.tileID.overscaledZ - 1);
                (O = this._tiles[R.key]) && O.hasData() && (k = R);
              }
              for (var q = k; q.overscaledZ > d; )
                if (c[(q = q.scaledTo(q.overscaledZ - 1)).key]) {
                  w[k.key] = k;
                  break;
                }
            }
          }
        }, f.prototype.findLoadedParent = function(c, d) {
          if (c.key in this._loadedParentTiles) {
            var _ = this._loadedParentTiles[c.key];
            return _ && _.tileID.overscaledZ >= d ? _ : null;
          }
          for (var w = c.overscaledZ - 1; w >= d; w--) {
            var E = c.scaledTo(w), O = this._getLoadedTile(E);
            if (O)
              return O;
          }
        }, f.prototype._getLoadedTile = function(c) {
          var d = this._tiles[c.key];
          return d && d.hasData() ? d : this._cache.getByKey(c.wrapped().key);
        }, f.prototype.updateCacheSize = function(c) {
          var d = Math.ceil(c.width / this._source.tileSize) + 1, _ = Math.ceil(c.height / this._source.tileSize) + 1, w = Math.floor(d * _ * 5), E = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, w) : w;
          this._cache.setMaxSize(E);
        }, f.prototype.handleWrapJump = function(c) {
          var d = Math.round((c - (this._prevLng === void 0 ? c : this._prevLng)) / 360);
          if (this._prevLng = c, d) {
            var _ = {};
            for (var w in this._tiles) {
              var E = this._tiles[w];
              E.tileID = E.tileID.unwrapTo(E.tileID.wrap + d), _[E.tileID.key] = E;
            }
            for (var O in this._tiles = _, this._timers)
              clearTimeout(this._timers[O]), delete this._timers[O];
            for (var k in this._tiles)
              this._setTileReloadTimer(k, this._tiles[k]);
          }
        }, f.prototype.update = function(c) {
          var d = this;
          if (this.transform = c, this._sourceLoaded && !this._paused) {
            var _;
            this.updateCacheSize(c), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? _ = c.getVisibleUnwrappedCoordinates(this._source.tileID).map(function(je) {
              return new o.OverscaledTileID(je.canonical.z, je.wrap, je.canonical.z, je.canonical.x, je.canonical.y);
            }) : (_ = c.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (_ = _.filter(function(je) {
              return d._source.hasTile(je);
            }))) : _ = [];
            var w = c.coveringZoomLevel(this._source), E = Math.max(w - f.maxOverzooming, this._source.minzoom), O = Math.max(w + f.maxUnderzooming, this._source.minzoom), k = this._updateRetainedTiles(_, w);
            if (Ge(this._source.type)) {
              for (var R = {}, q = {}, $ = 0, H = Object.keys(k); $ < H.length; $ += 1) {
                var ne = H[$], re = k[ne], ue = this._tiles[ne];
                if (ue && !(ue.fadeEndTime && ue.fadeEndTime <= o.browser.now())) {
                  var J = this.findLoadedParent(re, E);
                  J && (this._addTile(J.tileID), R[J.tileID.key] = J.tileID), q[ne] = re;
                }
              }
              for (var le in this._retainLoadedChildren(q, w, O, k), R)
                k[le] || (this._coveredTiles[le] = !0, k[le] = R[le]);
            }
            for (var me in k)
              this._tiles[me].clearFadeHold();
            for (var _e = 0, Ae = o.keysDifference(this._tiles, k); _e < Ae.length; _e += 1) {
              var Me = Ae[_e], ke = this._tiles[Me];
              ke.hasSymbolBuckets && !ke.holdingForFade() ? ke.setHoldDuration(this.map._fadeDuration) : ke.hasSymbolBuckets && !ke.symbolFadeFinished() || this._removeTile(Me);
            }
            this._updateLoadedParentTileCache();
          }
        }, f.prototype.releaseSymbolFadeTiles = function() {
          for (var c in this._tiles)
            this._tiles[c].holdingForFade() && this._removeTile(c);
        }, f.prototype._updateRetainedTiles = function(c, d) {
          for (var _ = {}, w = {}, E = Math.max(d - f.maxOverzooming, this._source.minzoom), O = Math.max(d + f.maxUnderzooming, this._source.minzoom), k = {}, R = 0, q = c; R < q.length; R += 1) {
            var $ = q[R], H = this._addTile($);
            _[$.key] = $, H.hasData() || d < this._source.maxzoom && (k[$.key] = $);
          }
          this._retainLoadedChildren(k, d, O, _);
          for (var ne = 0, re = c; ne < re.length; ne += 1) {
            var ue = re[ne], J = this._tiles[ue.key];
            if (!J.hasData()) {
              if (d + 1 > this._source.maxzoom) {
                var le = ue.children(this._source.maxzoom)[0], me = this.getTile(le);
                if (me && me.hasData()) {
                  _[le.key] = le;
                  continue;
                }
              } else {
                var _e = ue.children(this._source.maxzoom);
                if (_[_e[0].key] && _[_e[1].key] && _[_e[2].key] && _[_e[3].key])
                  continue;
              }
              for (var Ae = J.wasRequested(), Me = ue.overscaledZ - 1; Me >= E; --Me) {
                var ke = ue.scaledTo(Me);
                if (w[ke.key] || (w[ke.key] = !0, !(J = this.getTile(ke)) && Ae && (J = this._addTile(ke)), J && (_[ke.key] = ke, Ae = J.wasRequested(), J.hasData())))
                  break;
              }
            }
          }
          return _;
        }, f.prototype._updateLoadedParentTileCache = function() {
          for (var c in this._loadedParentTiles = {}, this._tiles) {
            for (var d = [], _ = void 0, w = this._tiles[c].tileID; w.overscaledZ > 0; ) {
              if (w.key in this._loadedParentTiles) {
                _ = this._loadedParentTiles[w.key];
                break;
              }
              d.push(w.key);
              var E = w.scaledTo(w.overscaledZ - 1);
              if (_ = this._getLoadedTile(E))
                break;
              w = E;
            }
            for (var O = 0, k = d; O < k.length; O += 1)
              this._loadedParentTiles[k[O]] = _;
          }
        }, f.prototype._addTile = function(c) {
          var d = this._tiles[c.key];
          if (d)
            return d;
          (d = this._cache.getAndRemove(c)) && (this._setTileReloadTimer(c.key, d), d.tileID = c, this._state.initializeTileState(d, this.map ? this.map.painter : null), this._cacheTimers[c.key] && (clearTimeout(this._cacheTimers[c.key]), delete this._cacheTimers[c.key], this._setTileReloadTimer(c.key, d)));
          var _ = Boolean(d);
          return _ || (d = new o.Tile(c, this._source.tileSize * c.overscaleFactor()), this._loadTile(d, this._tileLoaded.bind(this, d, c.key, d.state))), d ? (d.uses++, this._tiles[c.key] = d, _ || this._source.fire(new o.Event("dataloading", { tile: d, coord: d.tileID, dataType: "source" })), d) : null;
        }, f.prototype._setTileReloadTimer = function(c, d) {
          var _ = this;
          c in this._timers && (clearTimeout(this._timers[c]), delete this._timers[c]);
          var w = d.getExpiryTimeout();
          w && (this._timers[c] = setTimeout(function() {
            _._reloadTile(c, "expired"), delete _._timers[c];
          }, w));
        }, f.prototype._removeTile = function(c) {
          var d = this._tiles[c];
          d && (d.uses--, delete this._tiles[c], this._timers[c] && (clearTimeout(this._timers[c]), delete this._timers[c]), d.uses > 0 || (d.hasData() && d.state !== "reloading" ? this._cache.add(d.tileID, d, d.getExpiryTimeout()) : (d.aborted = !0, this._abortTile(d), this._unloadTile(d))));
        }, f.prototype.clearTiles = function() {
          for (var c in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles)
            this._removeTile(c);
          this._cache.reset();
        }, f.prototype.tilesIn = function(c, d, _) {
          var w = this, E = [], O = this.transform;
          if (!O)
            return E;
          for (var k = _ ? O.getCameraQueryGeometry(c) : c, R = c.map(function(Me) {
            return O.pointCoordinate(Me);
          }), q = k.map(function(Me) {
            return O.pointCoordinate(Me);
          }), $ = this.getIds(), H = 1 / 0, ne = 1 / 0, re = -1 / 0, ue = -1 / 0, J = 0, le = q; J < le.length; J += 1) {
            var me = le[J];
            H = Math.min(H, me.x), ne = Math.min(ne, me.y), re = Math.max(re, me.x), ue = Math.max(ue, me.y);
          }
          for (var _e = function(Me) {
            var ke = w._tiles[$[Me]];
            if (!ke.holdingForFade()) {
              var je = ke.tileID, nt = Math.pow(2, O.zoom - ke.tileID.overscaledZ), tt = d * ke.queryPadding * o.EXTENT / ke.tileSize / nt, gt = [je.getTilePoint(new o.MercatorCoordinate(H, ne)), je.getTilePoint(new o.MercatorCoordinate(re, ue))];
              if (gt[0].x - tt < o.EXTENT && gt[0].y - tt < o.EXTENT && gt[1].x + tt >= 0 && gt[1].y + tt >= 0) {
                var Dt = R.map(function(zt) {
                  return je.getTilePoint(zt);
                }), Bt = q.map(function(zt) {
                  return je.getTilePoint(zt);
                });
                E.push({ tile: ke, tileID: je, queryGeometry: Dt, cameraQueryGeometry: Bt, scale: nt });
              }
            }
          }, Ae = 0; Ae < $.length; Ae++)
            _e(Ae);
          return E;
        }, f.prototype.getVisibleCoordinates = function(c) {
          for (var d = this, _ = this.getRenderableIds(c).map(function(k) {
            return d._tiles[k].tileID;
          }), w = 0, E = _; w < E.length; w += 1) {
            var O = E[w];
            O.posMatrix = this.transform.calculatePosMatrix(O.toUnwrapped());
          }
          return _;
        }, f.prototype.hasTransition = function() {
          if (this._source.hasTransition())
            return !0;
          if (Ge(this._source.type))
            for (var c in this._tiles) {
              var d = this._tiles[c];
              if (d.fadeEndTime !== void 0 && d.fadeEndTime >= o.browser.now())
                return !0;
            }
          return !1;
        }, f.prototype.setFeatureState = function(c, d, _) {
          this._state.updateState(c = c || "_geojsonTileLayer", d, _);
        }, f.prototype.removeFeatureState = function(c, d, _) {
          this._state.removeFeatureState(c = c || "_geojsonTileLayer", d, _);
        }, f.prototype.getFeatureState = function(c, d) {
          return this._state.getState(c = c || "_geojsonTileLayer", d);
        }, f.prototype.setDependencies = function(c, d, _) {
          var w = this._tiles[c];
          w && w.setDependencies(d, _);
        }, f.prototype.reloadTilesForDependencies = function(c, d) {
          for (var _ in this._tiles)
            this._tiles[_].hasDependency(c, d) && this._reloadTile(_, "reloading");
          this._cache.filter(function(w) {
            return !w.hasDependency(c, d);
          });
        }, f;
      }(o.Evented);
      function ve(u, f) {
        var c = Math.abs(2 * u.wrap) - +(u.wrap < 0), d = Math.abs(2 * f.wrap) - +(f.wrap < 0);
        return u.overscaledZ - f.overscaledZ || d - c || f.canonical.y - u.canonical.y || f.canonical.x - u.canonical.x;
      }
      function Ge(u) {
        return u === "raster" || u === "image" || u === "video";
      }
      function Ze() {
        return new o.window.Worker(Th.workerUrl);
      }
      ie.maxOverzooming = 10, ie.maxUnderzooming = 3;
      var Ce = "mapboxgl_preloaded_worker_pool", Ue = function() {
        this.active = {};
      };
      Ue.prototype.acquire = function(u) {
        if (!this.workers)
          for (this.workers = []; this.workers.length < Ue.workerCount; )
            this.workers.push(new Ze());
        return this.active[u] = !0, this.workers.slice();
      }, Ue.prototype.release = function(u) {
        delete this.active[u], this.numActive() === 0 && (this.workers.forEach(function(f) {
          f.terminate();
        }), this.workers = null);
      }, Ue.prototype.isPreloaded = function() {
        return !!this.active[Ce];
      }, Ue.prototype.numActive = function() {
        return Object.keys(this.active).length;
      };
      var Et, _t = Math.floor(o.browser.hardwareConcurrency / 2);
      function Le() {
        return Et || (Et = new Ue()), Et;
      }
      function pt(u, f) {
        var c = {};
        for (var d in u)
          d !== "ref" && (c[d] = u[d]);
        return o.refProperties.forEach(function(_) {
          _ in f && (c[_] = f[_]);
        }), c;
      }
      function st(u) {
        u = u.slice();
        for (var f = /* @__PURE__ */ Object.create(null), c = 0; c < u.length; c++)
          f[u[c].id] = u[c];
        for (var d = 0; d < u.length; d++)
          "ref" in u[d] && (u[d] = pt(u[d], f[u[d].ref]));
        return u;
      }
      Ue.workerCount = Math.max(Math.min(_t, 6), 1);
      var De = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
      function he(u, f, c) {
        c.push({ command: De.addSource, args: [u, f[u]] });
      }
      function Ee(u, f, c) {
        f.push({ command: De.removeSource, args: [u] }), c[u] = !0;
      }
      function He(u, f, c, d) {
        Ee(u, c, d), he(u, f, c);
      }
      function jt(u, f, c) {
        var d;
        for (d in u[c])
          if (u[c].hasOwnProperty(d) && d !== "data" && !o.deepEqual(u[c][d], f[c][d]))
            return !1;
        for (d in f[c])
          if (f[c].hasOwnProperty(d) && d !== "data" && !o.deepEqual(u[c][d], f[c][d]))
            return !1;
        return !0;
      }
      function Wt(u, f, c, d, _, w) {
        var E;
        for (E in f = f || {}, u = u || {})
          u.hasOwnProperty(E) && (o.deepEqual(u[E], f[E]) || c.push({ command: w, args: [d, E, f[E], _] }));
        for (E in f)
          f.hasOwnProperty(E) && !u.hasOwnProperty(E) && (o.deepEqual(u[E], f[E]) || c.push({ command: w, args: [d, E, f[E], _] }));
      }
      function Jt(u) {
        return u.id;
      }
      function Zt(u, f) {
        return u[f.id] = f, u;
      }
      var Yn = function(u, f) {
        this.reset(u, f);
      };
      Yn.prototype.reset = function(u, f) {
        this.points = u || [], this._distances = [0];
        for (var c = 1; c < this.points.length; c++)
          this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(f || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
      }, Yn.prototype.lerp = function(u) {
        if (this.points.length === 1)
          return this.points[0];
        u = o.clamp(u, 0, 1);
        for (var f = 1, c = this._distances[f], d = u * this.paddedLength + this.padding; c < d && f < this._distances.length; )
          c = this._distances[++f];
        var _ = f - 1, w = this._distances[_], E = c - w, O = E > 0 ? (d - w) / E : 0;
        return this.points[_].mult(1 - O).add(this.points[f].mult(O));
      };
      var Qt = function(u, f, c) {
        var d = this.boxCells = [], _ = this.circleCells = [];
        this.xCellCount = Math.ceil(u / c), this.yCellCount = Math.ceil(f / c);
        for (var w = 0; w < this.xCellCount * this.yCellCount; w++)
          d.push([]), _.push([]);
        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = u, this.height = f, this.xScale = this.xCellCount / u, this.yScale = this.yCellCount / f, this.boxUid = 0, this.circleUid = 0;
      };
      function pn(u, f, c, d, _) {
        var w = o.create();
        return f ? (o.scale(w, w, [1 / _, 1 / _, 1]), c || o.rotateZ(w, w, d.angle)) : o.multiply(w, d.labelPlaneMatrix, u), w;
      }
      function Ur(u, f, c, d, _) {
        if (f) {
          var w = o.clone(u);
          return o.scale(w, w, [_, _, 1]), c || o.rotateZ(w, w, -d.angle), w;
        }
        return d.glCoordMatrix;
      }
      function gr(u, f) {
        var c = [u.x, u.y, 0, 1];
        mi(c, c, f);
        var d = c[3];
        return { point: new o.Point(c[0] / d, c[1] / d), signedDistanceFromCamera: d };
      }
      function Fr(u, f) {
        return 0.5 + u / f * 0.5;
      }
      function Yi(u, f) {
        var c = u[0] / u[3], d = u[1] / u[3];
        return c >= -f[0] && c <= f[0] && d >= -f[1] && d <= f[1];
      }
      function $u(u, f, c, d, _, w, E, O) {
        var k = d ? u.textSizeData : u.iconSizeData, R = o.evaluateSizeForZoom(k, c.transform.zoom), q = [256 / c.width * 2 + 1, 256 / c.height * 2 + 1], $ = d ? u.text.dynamicLayoutVertexArray : u.icon.dynamicLayoutVertexArray;
        $.clear();
        for (var H = u.lineVertexArray, ne = d ? u.text.placedSymbolArray : u.icon.placedSymbolArray, re = c.transform.width / c.transform.height, ue = !1, J = 0; J < ne.length; J++) {
          var le = ne.get(J);
          if (le.hidden || le.writingMode === o.WritingMode.vertical && !ue)
            Vi(le.numGlyphs, $);
          else {
            ue = !1;
            var me = [le.anchorX, le.anchorY, 0, 1];
            if (o.transformMat4(me, me, f), Yi(me, q)) {
              var _e = Fr(c.transform.cameraToCenterDistance, me[3]), Ae = o.evaluateSizeForFeature(k, R, le), Me = E ? Ae / _e : Ae * _e, ke = new o.Point(le.anchorX, le.anchorY), je = gr(ke, _).point, nt = {}, tt = qf(le, Me, !1, O, f, _, w, u.glyphOffsetArray, H, $, je, ke, nt, re);
              ue = tt.useVertical, (tt.notEnoughRoom || ue || tt.needsFlipping && qf(le, Me, !0, O, f, _, w, u.glyphOffsetArray, H, $, je, ke, nt, re).notEnoughRoom) && Vi(le.numGlyphs, $);
            } else
              Vi(le.numGlyphs, $);
          }
        }
        d ? u.text.dynamicLayoutVertexBuffer.updateData($) : u.icon.dynamicLayoutVertexBuffer.updateData($);
      }
      function di(u, f, c, d, _, w, E, O, k, R, q) {
        var $ = O.glyphStartIndex + O.numGlyphs, H = O.lineStartIndex, ne = O.lineStartIndex + O.lineLength, re = f.getoffsetX(O.glyphStartIndex), ue = f.getoffsetX($ - 1), J = kn(u * re, c, d, _, w, E, O.segment, H, ne, k, R, q);
        if (!J)
          return null;
        var le = kn(u * ue, c, d, _, w, E, O.segment, H, ne, k, R, q);
        return le ? { first: J, last: le } : null;
      }
      function Ji(u, f, c, d) {
        return u === o.WritingMode.horizontal && Math.abs(c.y - f.y) > Math.abs(c.x - f.x) * d ? { useVertical: !0 } : (u === o.WritingMode.vertical ? f.y < c.y : f.x > c.x) ? { needsFlipping: !0 } : null;
      }
      function qf(u, f, c, d, _, w, E, O, k, R, q, $, H, ne) {
        var re, ue = f / 24, J = u.lineOffsetX * ue, le = u.lineOffsetY * ue;
        if (u.numGlyphs > 1) {
          var me = u.glyphStartIndex + u.numGlyphs, _e = u.lineStartIndex, Ae = u.lineStartIndex + u.lineLength, Me = di(ue, O, J, le, c, q, $, u, k, w, H);
          if (!Me)
            return { notEnoughRoom: !0 };
          var ke = gr(Me.first.point, E).point, je = gr(Me.last.point, E).point;
          if (d && !c) {
            var nt = Ji(u.writingMode, ke, je, ne);
            if (nt)
              return nt;
          }
          re = [Me.first];
          for (var tt = u.glyphStartIndex + 1; tt < me - 1; tt++)
            re.push(kn(ue * O.getoffsetX(tt), J, le, c, q, $, u.segment, _e, Ae, k, w, H));
          re.push(Me.last);
        } else {
          if (d && !c) {
            var gt = gr($, _).point, Dt = u.lineStartIndex + u.segment + 1, Bt = new o.Point(k.getx(Dt), k.gety(Dt)), zt = gr(Bt, _), Ir = zt.signedDistanceFromCamera > 0 ? zt.point : Wu($, Bt, gt, 1, _), xt = Ji(u.writingMode, gt, Ir, ne);
            if (xt)
              return xt;
          }
          var Yt = kn(ue * O.getoffsetX(u.glyphStartIndex), J, le, c, q, $, u.segment, u.lineStartIndex, u.lineStartIndex + u.lineLength, k, w, H);
          if (!Yt)
            return { notEnoughRoom: !0 };
          re = [Yt];
        }
        for (var ir = 0, Kt = re; ir < Kt.length; ir += 1) {
          var Xt = Kt[ir];
          o.addDynamicAttributes(R, Xt.point, Xt.angle);
        }
        return {};
      }
      function Wu(u, f, c, d, _) {
        var w = gr(u.add(u.sub(f)._unit()), _).point, E = c.sub(w);
        return c.add(E._mult(d / E.mag()));
      }
      function kn(u, f, c, d, _, w, E, O, k, R, q, $) {
        var H = d ? u - f : u + f, ne = H > 0 ? 1 : -1, re = 0;
        d && (ne *= -1, re = Math.PI), ne < 0 && (re += Math.PI);
        for (var ue = ne > 0 ? O + E : O + E + 1, J = _, le = _, me = 0, _e = 0, Ae = Math.abs(H), Me = []; me + _e <= Ae; ) {
          if ((ue += ne) < O || ue >= k)
            return null;
          if (le = J, Me.push(J), (J = $[ue]) === void 0) {
            var ke = new o.Point(R.getx(ue), R.gety(ue)), je = gr(ke, q);
            if (je.signedDistanceFromCamera > 0)
              J = $[ue] = je.point;
            else {
              var nt = ue - ne;
              J = Wu(me === 0 ? w : new o.Point(R.getx(nt), R.gety(nt)), ke, le, Ae - me + 1, q);
            }
          }
          me += _e, _e = le.dist(J);
        }
        var tt = (Ae - me) / _e, gt = J.sub(le), Dt = gt.mult(tt)._add(le);
        Dt._add(gt._unit()._perp()._mult(c * ne));
        var Bt = re + Math.atan2(J.y - le.y, J.x - le.x);
        return Me.push(Dt), { point: Dt, angle: Bt, path: Me };
      }
      Qt.prototype.keysLength = function() {
        return this.boxKeys.length + this.circleKeys.length;
      }, Qt.prototype.insert = function(u, f, c, d, _) {
        this._forEachCell(f, c, d, _, this._insertBoxCell, this.boxUid++), this.boxKeys.push(u), this.bboxes.push(f), this.bboxes.push(c), this.bboxes.push(d), this.bboxes.push(_);
      }, Qt.prototype.insertCircle = function(u, f, c, d) {
        this._forEachCell(f - d, c - d, f + d, c + d, this._insertCircleCell, this.circleUid++), this.circleKeys.push(u), this.circles.push(f), this.circles.push(c), this.circles.push(d);
      }, Qt.prototype._insertBoxCell = function(u, f, c, d, _, w) {
        this.boxCells[_].push(w);
      }, Qt.prototype._insertCircleCell = function(u, f, c, d, _, w) {
        this.circleCells[_].push(w);
      }, Qt.prototype._query = function(u, f, c, d, _, w) {
        if (c < 0 || u > this.width || d < 0 || f > this.height)
          return !_ && [];
        var E = [];
        if (u <= 0 && f <= 0 && this.width <= c && this.height <= d) {
          if (_)
            return !0;
          for (var O = 0; O < this.boxKeys.length; O++)
            E.push({ key: this.boxKeys[O], x1: this.bboxes[4 * O], y1: this.bboxes[4 * O + 1], x2: this.bboxes[4 * O + 2], y2: this.bboxes[4 * O + 3] });
          for (var k = 0; k < this.circleKeys.length; k++) {
            var R = this.circles[3 * k], q = this.circles[3 * k + 1], $ = this.circles[3 * k + 2];
            E.push({ key: this.circleKeys[k], x1: R - $, y1: q - $, x2: R + $, y2: q + $ });
          }
          return w ? E.filter(w) : E;
        }
        return this._forEachCell(u, f, c, d, this._queryCell, E, { hitTest: _, seenUids: { box: {}, circle: {} } }, w), _ ? E.length > 0 : E;
      }, Qt.prototype._queryCircle = function(u, f, c, d, _) {
        var w = u - c, E = u + c, O = f - c, k = f + c;
        if (E < 0 || w > this.width || k < 0 || O > this.height)
          return !d && [];
        var R = [];
        return this._forEachCell(w, O, E, k, this._queryCellCircle, R, { hitTest: d, circle: { x: u, y: f, radius: c }, seenUids: { box: {}, circle: {} } }, _), d ? R.length > 0 : R;
      }, Qt.prototype.query = function(u, f, c, d, _) {
        return this._query(u, f, c, d, !1, _);
      }, Qt.prototype.hitTest = function(u, f, c, d, _) {
        return this._query(u, f, c, d, !0, _);
      }, Qt.prototype.hitTestCircle = function(u, f, c, d) {
        return this._queryCircle(u, f, c, !0, d);
      }, Qt.prototype._queryCell = function(u, f, c, d, _, w, E, O) {
        var k = E.seenUids, R = this.boxCells[_];
        if (R !== null)
          for (var q = this.bboxes, $ = 0, H = R; $ < H.length; $ += 1) {
            var ne = H[$];
            if (!k.box[ne]) {
              k.box[ne] = !0;
              var re = 4 * ne;
              if (u <= q[re + 2] && f <= q[re + 3] && c >= q[re + 0] && d >= q[re + 1] && (!O || O(this.boxKeys[ne]))) {
                if (E.hitTest)
                  return w.push(!0), !0;
                w.push({ key: this.boxKeys[ne], x1: q[re], y1: q[re + 1], x2: q[re + 2], y2: q[re + 3] });
              }
            }
          }
        var ue = this.circleCells[_];
        if (ue !== null)
          for (var J = this.circles, le = 0, me = ue; le < me.length; le += 1) {
            var _e = me[le];
            if (!k.circle[_e]) {
              k.circle[_e] = !0;
              var Ae = 3 * _e;
              if (this._circleAndRectCollide(J[Ae], J[Ae + 1], J[Ae + 2], u, f, c, d) && (!O || O(this.circleKeys[_e]))) {
                if (E.hitTest)
                  return w.push(!0), !0;
                var Me = J[Ae], ke = J[Ae + 1], je = J[Ae + 2];
                w.push({ key: this.circleKeys[_e], x1: Me - je, y1: ke - je, x2: Me + je, y2: ke + je });
              }
            }
          }
      }, Qt.prototype._queryCellCircle = function(u, f, c, d, _, w, E, O) {
        var k = E.circle, R = E.seenUids, q = this.boxCells[_];
        if (q !== null)
          for (var $ = this.bboxes, H = 0, ne = q; H < ne.length; H += 1) {
            var re = ne[H];
            if (!R.box[re]) {
              R.box[re] = !0;
              var ue = 4 * re;
              if (this._circleAndRectCollide(k.x, k.y, k.radius, $[ue + 0], $[ue + 1], $[ue + 2], $[ue + 3]) && (!O || O(this.boxKeys[re])))
                return w.push(!0), !0;
            }
          }
        var J = this.circleCells[_];
        if (J !== null)
          for (var le = this.circles, me = 0, _e = J; me < _e.length; me += 1) {
            var Ae = _e[me];
            if (!R.circle[Ae]) {
              R.circle[Ae] = !0;
              var Me = 3 * Ae;
              if (this._circlesCollide(le[Me], le[Me + 1], le[Me + 2], k.x, k.y, k.radius) && (!O || O(this.circleKeys[Ae])))
                return w.push(!0), !0;
            }
          }
      }, Qt.prototype._forEachCell = function(u, f, c, d, _, w, E, O) {
        for (var k = this._convertToXCellCoord(u), R = this._convertToYCellCoord(f), q = this._convertToXCellCoord(c), $ = this._convertToYCellCoord(d), H = k; H <= q; H++)
          for (var ne = R; ne <= $; ne++)
            if (_.call(this, u, f, c, d, this.xCellCount * ne + H, w, E, O))
              return;
      }, Qt.prototype._convertToXCellCoord = function(u) {
        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(u * this.xScale)));
      }, Qt.prototype._convertToYCellCoord = function(u) {
        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(u * this.yScale)));
      }, Qt.prototype._circlesCollide = function(u, f, c, d, _, w) {
        var E = d - u, O = _ - f, k = c + w;
        return k * k > E * E + O * O;
      }, Qt.prototype._circleAndRectCollide = function(u, f, c, d, _, w, E) {
        var O = (w - d) / 2, k = Math.abs(u - (d + O));
        if (k > O + c)
          return !1;
        var R = (E - _) / 2, q = Math.abs(f - (_ + R));
        if (q > R + c)
          return !1;
        if (k <= O || q <= R)
          return !0;
        var $ = k - O, H = q - R;
        return $ * $ + H * H <= c * c;
      };
      var Hu = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function Vi(u, f) {
        for (var c = 0; c < u; c++) {
          var d = f.length;
          f.resize(d + 4), f.float32.set(Hu, 3 * d);
        }
      }
      function mi(u, f, c) {
        var d = f[0], _ = f[1];
        return u[0] = c[0] * d + c[4] * _ + c[12], u[1] = c[1] * d + c[5] * _ + c[13], u[3] = c[3] * d + c[7] * _ + c[15], u;
      }
      var jo = function(u, f, c) {
        f === void 0 && (f = new Qt(u.width + 200, u.height + 200, 25)), c === void 0 && (c = new Qt(u.width + 200, u.height + 200, 25)), this.transform = u, this.grid = f, this.ignoredGrid = c, this.pitchfactor = Math.cos(u._pitch) * u.cameraToCenterDistance, this.screenRightBoundary = u.width + 100, this.screenBottomBoundary = u.height + 100, this.gridRightBoundary = u.width + 200, this.gridBottomBoundary = u.height + 200;
      };
      function dn(u, f, c) {
        return f * (o.EXTENT / (u.tileSize * Math.pow(2, c - u.tileID.overscaledZ)));
      }
      jo.prototype.placeCollisionBox = function(u, f, c, d, _) {
        var w = this.projectAndGetPerspectiveRatio(d, u.anchorPointX, u.anchorPointY), E = c * w.perspectiveRatio, O = u.x1 * E + w.point.x, k = u.y1 * E + w.point.y, R = u.x2 * E + w.point.x, q = u.y2 * E + w.point.y;
        return !this.isInsideGrid(O, k, R, q) || !f && this.grid.hitTest(O, k, R, q, _) ? { box: [], offscreen: !1 } : { box: [O, k, R, q], offscreen: this.isOffscreen(O, k, R, q) };
      }, jo.prototype.placeCollisionCircles = function(u, f, c, d, _, w, E, O, k, R, q, $, H) {
        var ne = [], re = new o.Point(f.anchorX, f.anchorY), ue = gr(re, w), J = Fr(this.transform.cameraToCenterDistance, ue.signedDistanceFromCamera), le = (R ? _ / J : _ * J) / o.ONE_EM, me = gr(re, E).point, _e = di(le, d, f.lineOffsetX * le, f.lineOffsetY * le, !1, me, re, f, c, E, {}), Ae = !1, Me = !1, ke = !0;
        if (_e) {
          for (var je = 0.5 * $ * J + H, nt = new o.Point(-100, -100), tt = new o.Point(this.screenRightBoundary, this.screenBottomBoundary), gt = new Yn(), Dt = _e.first, Bt = _e.last, zt = [], Ir = Dt.path.length - 1; Ir >= 1; Ir--)
            zt.push(Dt.path[Ir]);
          for (var xt = 1; xt < Bt.path.length; xt++)
            zt.push(Bt.path[xt]);
          var Yt = 2.5 * je;
          if (O) {
            var ir = zt.map(function(Zo) {
              return gr(Zo, O);
            });
            zt = ir.some(function(Zo) {
              return Zo.signedDistanceFromCamera <= 0;
            }) ? [] : ir.map(function(Zo) {
              return Zo.point;
            });
          }
          var Kt = [];
          if (zt.length > 0) {
            for (var Xt = zt[0].clone(), nr = zt[0].clone(), Ht = 1; Ht < zt.length; Ht++)
              Xt.x = Math.min(Xt.x, zt[Ht].x), Xt.y = Math.min(Xt.y, zt[Ht].y), nr.x = Math.max(nr.x, zt[Ht].x), nr.y = Math.max(nr.y, zt[Ht].y);
            Kt = Xt.x >= nt.x && nr.x <= tt.x && Xt.y >= nt.y && nr.y <= tt.y ? [zt] : nr.x < nt.x || Xt.x > tt.x || nr.y < nt.y || Xt.y > tt.y ? [] : o.clipLine([zt], nt.x, nt.y, tt.x, tt.y);
          }
          for (var qt = 0, si = Kt; qt < si.length; qt += 1) {
            var On;
            gt.reset(si[qt], 0.25 * je), On = gt.length <= 0.5 * je ? 1 : Math.ceil(gt.paddedLength / Yt) + 1;
            for (var Li = 0; Li < On; Li++) {
              var gi = Li / Math.max(On - 1, 1), Tn = gt.lerp(gi), Ln = Tn.x + 100, mo = Tn.y + 100;
              ne.push(Ln, mo, je, 0);
              var qi = Ln - je, Ms = mo - je, Qi = Ln + je, ca = mo + je;
              if (ke = ke && this.isOffscreen(qi, Ms, Qi, ca), Me = Me || this.isInsideGrid(qi, Ms, Qi, ca), !u && this.grid.hitTestCircle(Ln, mo, je, q) && (Ae = !0, !k))
                return { circles: [], offscreen: !1, collisionDetected: Ae };
            }
          }
        }
        return { circles: !k && Ae || !Me ? [] : ne, offscreen: ke, collisionDetected: Ae };
      }, jo.prototype.queryRenderedSymbols = function(u) {
        if (u.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
          return {};
        for (var f = [], c = 1 / 0, d = 1 / 0, _ = -1 / 0, w = -1 / 0, E = 0, O = u; E < O.length; E += 1) {
          var k = O[E], R = new o.Point(k.x + 100, k.y + 100);
          c = Math.min(c, R.x), d = Math.min(d, R.y), _ = Math.max(_, R.x), w = Math.max(w, R.y), f.push(R);
        }
        for (var q = {}, $ = {}, H = 0, ne = this.grid.query(c, d, _, w).concat(this.ignoredGrid.query(c, d, _, w)); H < ne.length; H += 1) {
          var re = ne[H], ue = re.key;
          if (q[ue.bucketInstanceId] === void 0 && (q[ue.bucketInstanceId] = {}), !q[ue.bucketInstanceId][ue.featureIndex]) {
            var J = [new o.Point(re.x1, re.y1), new o.Point(re.x2, re.y1), new o.Point(re.x2, re.y2), new o.Point(re.x1, re.y2)];
            o.polygonIntersectsPolygon(f, J) && (q[ue.bucketInstanceId][ue.featureIndex] = !0, $[ue.bucketInstanceId] === void 0 && ($[ue.bucketInstanceId] = []), $[ue.bucketInstanceId].push(ue.featureIndex));
          }
        }
        return $;
      }, jo.prototype.insertCollisionBox = function(u, f, c, d, _) {
        (f ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: c, featureIndex: d, collisionGroupID: _ }, u[0], u[1], u[2], u[3]);
      }, jo.prototype.insertCollisionCircles = function(u, f, c, d, _) {
        for (var w = f ? this.ignoredGrid : this.grid, E = { bucketInstanceId: c, featureIndex: d, collisionGroupID: _ }, O = 0; O < u.length; O += 4)
          w.insertCircle(E, u[O], u[O + 1], u[O + 2]);
      }, jo.prototype.projectAndGetPerspectiveRatio = function(u, f, c) {
        var d = [f, c, 0, 1];
        return mi(d, d, u), { point: new o.Point((d[0] / d[3] + 1) / 2 * this.transform.width + 100, (-d[1] / d[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / d[3] * 0.5 };
      }, jo.prototype.isOffscreen = function(u, f, c, d) {
        return c < 100 || u >= this.screenRightBoundary || d < 100 || f > this.screenBottomBoundary;
      }, jo.prototype.isInsideGrid = function(u, f, c, d) {
        return c >= 0 && u < this.gridRightBoundary && d >= 0 && f < this.gridBottomBoundary;
      }, jo.prototype.getViewportMatrix = function() {
        var u = o.identity([]);
        return o.translate(u, u, [-100, -100, 0]), u;
      };
      var ia = function(u, f, c, d) {
        this.opacity = u ? Math.max(0, Math.min(1, u.opacity + (u.placed ? f : -f))) : d && c ? 1 : 0, this.placed = c;
      };
      ia.prototype.isHidden = function() {
        return this.opacity === 0 && !this.placed;
      };
      var To = function(u, f, c, d, _) {
        this.text = new ia(u ? u.text : null, f, c, _), this.icon = new ia(u ? u.icon : null, f, d, _);
      };
      To.prototype.isHidden = function() {
        return this.text.isHidden() && this.icon.isHidden();
      };
      var im = function(u, f, c) {
        this.text = u, this.icon = f, this.skipFade = c;
      }, Go = function() {
        this.invProjMatrix = o.create(), this.viewportMatrix = o.create(), this.circles = [];
      }, Nv = function(u, f, c, d, _) {
        this.bucketInstanceId = u, this.featureIndex = f, this.sourceLayerIndex = c, this.bucketIndex = d, this.tileID = _;
      }, Va = function(u) {
        this.crossSourceCollisions = u, this.maxGroupID = 0, this.collisionGroups = {};
      };
      function Ei(u, f, c, d, _) {
        var w = o.getAnchorAlignment(u), E = -(w.horizontalAlign - 0.5) * f, O = -(w.verticalAlign - 0.5) * c, k = o.evaluateVariableOffset(u, d);
        return new o.Point(E + k[0] * _, O + k[1] * _);
      }
      function _a(u, f, c, d, _, w) {
        var E = u.x1, O = u.x2, k = u.y1, R = u.y2, q = u.anchorPointX, $ = u.anchorPointY, H = new o.Point(f, c);
        return d && H._rotate(_ ? w : -w), { x1: E + H.x, y1: k + H.y, x2: O + H.x, y2: R + H.y, anchorPointX: q, anchorPointY: $ };
      }
      Va.prototype.get = function(u) {
        if (this.crossSourceCollisions)
          return { ID: 0, predicate: null };
        if (!this.collisionGroups[u]) {
          var f = ++this.maxGroupID;
          this.collisionGroups[u] = { ID: f, predicate: function(c) {
            return c.collisionGroupID === f;
          } };
        }
        return this.collisionGroups[u];
      };
      var Ui = function(u, f, c, d) {
        this.transform = u.clone(), this.collisionIndex = new jo(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = f, this.retainedQueryData = {}, this.collisionGroups = new Va(c), this.collisionCircleArrays = {}, this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {};
      };
      function nl(u, f, c, d, _) {
        u.emplaceBack(f ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(f ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(f ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(f ? 1 : 0, c ? 1 : 0, d || 0, _ || 0);
      }
      Ui.prototype.getBucketParts = function(u, f, c, d) {
        var _ = c.getBucket(f), w = c.latestFeatureIndex;
        if (_ && w && f.id === _.layerIds[0]) {
          var E = c.collisionBoxArray, O = _.layers[0].layout, k = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), R = c.tileSize / o.EXTENT, q = this.transform.calculatePosMatrix(c.tileID.toUnwrapped()), $ = O.get("text-pitch-alignment") === "map", H = O.get("text-rotation-alignment") === "map", ne = dn(c, 1, this.transform.zoom), re = pn(q, $, H, this.transform, ne), ue = null;
          if ($) {
            var J = Ur(q, $, H, this.transform, ne);
            ue = o.multiply([], this.transform.labelPlaneMatrix, J);
          }
          this.retainedQueryData[_.bucketInstanceId] = new Nv(_.bucketInstanceId, w, _.sourceLayerIndex, _.index, c.tileID);
          var le = { bucket: _, layout: O, posMatrix: q, textLabelPlaneMatrix: re, labelToScreenMatrix: ue, scale: k, textPixelRatio: R, holdingForFade: c.holdingForFade(), collisionBoxArray: E, partiallyEvaluatedTextSize: o.evaluateSizeForZoom(_.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(_.sourceID) };
          if (d)
            for (var me = 0, _e = _.sortKeyRanges; me < _e.length; me += 1) {
              var Ae = _e[me];
              u.push({ sortKey: Ae.sortKey, symbolInstanceStart: Ae.symbolInstanceStart, symbolInstanceEnd: Ae.symbolInstanceEnd, parameters: le });
            }
          else
            u.push({ symbolInstanceStart: 0, symbolInstanceEnd: _.symbolInstances.length, parameters: le });
        }
      }, Ui.prototype.attemptAnchorPlacement = function(u, f, c, d, _, w, E, O, k, R, q, $, H, ne, re) {
        var ue, J = [$.textOffset0, $.textOffset1], le = Ei(u, c, d, J, _), me = this.collisionIndex.placeCollisionBox(_a(f, le.x, le.y, w, E, this.transform.angle), q, O, k, R.predicate);
        if (!re || this.collisionIndex.placeCollisionBox(_a(re, le.x, le.y, w, E, this.transform.angle), q, O, k, R.predicate).box.length !== 0)
          return me.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[$.crossTileID] && this.prevPlacement.placements[$.crossTileID] && this.prevPlacement.placements[$.crossTileID].text && (ue = this.prevPlacement.variableOffsets[$.crossTileID].anchor), this.variableOffsets[$.crossTileID] = { textOffset: J, width: c, height: d, anchor: u, textBoxScale: _, prevAnchor: ue }, this.markUsedJustification(H, u, $, ne), H.allowVerticalPlacement && (this.markUsedOrientation(H, ne, $), this.placedOrientations[$.crossTileID] = ne), { shift: le, placedGlyphBoxes: me }) : void 0;
      }, Ui.prototype.placeLayerBucketPart = function(u, f, c) {
        var d = this, _ = u.parameters, w = _.bucket, E = _.layout, O = _.posMatrix, k = _.textLabelPlaneMatrix, R = _.labelToScreenMatrix, q = _.textPixelRatio, $ = _.holdingForFade, H = _.collisionBoxArray, ne = _.partiallyEvaluatedTextSize, re = _.collisionGroup, ue = E.get("text-optional"), J = E.get("icon-optional"), le = E.get("text-allow-overlap"), me = E.get("icon-allow-overlap"), _e = E.get("text-rotation-alignment") === "map", Ae = E.get("text-pitch-alignment") === "map", Me = E.get("icon-text-fit") !== "none", ke = E.get("symbol-z-order") === "viewport-y", je = le && (me || !w.hasIconData() || J), nt = me && (le || !w.hasTextData() || ue);
        !w.collisionArrays && H && w.deserializeCollisionBoxes(H);
        var tt = function(xt, Yt) {
          if (!f[xt.crossTileID])
            if ($)
              d.placements[xt.crossTileID] = new im(!1, !1, !1);
            else {
              var ir, Kt = !1, Xt = !1, nr = !0, Ht = null, qt = { box: null, offscreen: null }, si = { box: null, offscreen: null }, On = null, Li = null, gi = 0, Tn = 0, Ln = 0;
              Yt.textFeatureIndex ? gi = Yt.textFeatureIndex : xt.useRuntimeCollisionCircles && (gi = xt.featureIndex), Yt.verticalTextFeatureIndex && (Tn = Yt.verticalTextFeatureIndex);
              var mo = Yt.textBox;
              if (mo) {
                var qi = function(Br) {
                  var Oo = o.WritingMode.horizontal;
                  if (w.allowVerticalPlacement && !Br && d.prevPlacement) {
                    var eo = d.prevPlacement.placedOrientations[xt.crossTileID];
                    eo && (d.placedOrientations[xt.crossTileID] = eo, d.markUsedOrientation(w, Oo = eo, xt));
                  }
                  return Oo;
                }, Ms = function(Br, Oo) {
                  if (w.allowVerticalPlacement && xt.numVerticalGlyphVertices > 0 && Yt.verticalTextBox)
                    for (var eo = 0, bl = w.writingModes; eo < bl.length && (bl[eo] === o.WritingMode.vertical ? (qt = Oo(), si = qt) : qt = Br(), !(qt && qt.box && qt.box.length)); eo += 1)
                      ;
                  else
                    qt = Br();
                };
                if (E.get("text-variable-anchor")) {
                  var Qi = E.get("text-variable-anchor");
                  if (d.prevPlacement && d.prevPlacement.variableOffsets[xt.crossTileID]) {
                    var ca = d.prevPlacement.variableOffsets[xt.crossTileID];
                    Qi.indexOf(ca.anchor) > 0 && (Qi = Qi.filter(function(Br) {
                      return Br !== ca.anchor;
                    })).unshift(ca.anchor);
                  }
                  var Zo = function(Br, Oo, eo) {
                    for (var bl = Br.x2 - Br.x1, Xv = Br.y2 - Br.y1, Mh = xt.textBoxScale, Kv = Me && !me ? Oo : null, dc = { box: [], offscreen: !1 }, Nm = le ? 2 * Qi.length : Qi.length, au = 0; au < Nm; ++au) {
                      var Ih = d.attemptAnchorPlacement(Qi[au % Qi.length], Br, bl, Xv, Mh, _e, Ae, q, O, re, au >= Qi.length, xt, w, eo, Kv);
                      if (Ih && (dc = Ih.placedGlyphBoxes) && dc.box && dc.box.length) {
                        Kt = !0, Ht = Ih.shift;
                        break;
                      }
                    }
                    return dc;
                  };
                  Ms(function() {
                    return Zo(mo, Yt.iconBox, o.WritingMode.horizontal);
                  }, function() {
                    var Br = Yt.verticalTextBox;
                    return w.allowVerticalPlacement && !(qt && qt.box && qt.box.length) && xt.numVerticalGlyphVertices > 0 && Br ? Zo(Br, Yt.verticalIconBox, o.WritingMode.vertical) : { box: null, offscreen: null };
                  }), qt && (Kt = qt.box, nr = qt.offscreen);
                  var hc = qi(qt && qt.box);
                  if (!Kt && d.prevPlacement) {
                    var iu = d.prevPlacement.variableOffsets[xt.crossTileID];
                    iu && (d.variableOffsets[xt.crossTileID] = iu, d.markUsedJustification(w, iu.anchor, xt, hc));
                  }
                } else {
                  var Is = function(Br, Oo) {
                    var eo = d.collisionIndex.placeCollisionBox(Br, le, q, O, re.predicate);
                    return eo && eo.box && eo.box.length && (d.markUsedOrientation(w, Oo, xt), d.placedOrientations[xt.crossTileID] = Oo), eo;
                  };
                  Ms(function() {
                    return Is(mo, o.WritingMode.horizontal);
                  }, function() {
                    var Br = Yt.verticalTextBox;
                    return w.allowVerticalPlacement && xt.numVerticalGlyphVertices > 0 && Br ? Is(Br, o.WritingMode.vertical) : { box: null, offscreen: null };
                  }), qi(qt && qt.box && qt.box.length);
                }
              }
              if (Kt = (ir = qt) && ir.box && ir.box.length > 0, nr = ir && ir.offscreen, xt.useRuntimeCollisionCircles) {
                var ou = w.text.placedSymbolArray.get(xt.centerJustifiedTextSymbolIndex), fc = o.evaluateSizeForFeature(w.textSizeData, ne, ou), Ea = E.get("text-padding");
                On = d.collisionIndex.placeCollisionCircles(le, ou, w.lineVertexArray, w.glyphOffsetArray, fc, O, k, R, c, Ae, re.predicate, xt.collisionCircleDiameter, Ea), Kt = le || On.circles.length > 0 && !On.collisionDetected, nr = nr && On.offscreen;
              }
              if (Yt.iconFeatureIndex && (Ln = Yt.iconFeatureIndex), Yt.iconBox) {
                var pc = function(Br) {
                  var Oo = Me && Ht ? _a(Br, Ht.x, Ht.y, _e, Ae, d.transform.angle) : Br;
                  return d.collisionIndex.placeCollisionBox(Oo, me, q, O, re.predicate);
                };
                Xt = si && si.box && si.box.length && Yt.verticalIconBox ? (Li = pc(Yt.verticalIconBox)).box.length > 0 : (Li = pc(Yt.iconBox)).box.length > 0, nr = nr && Li.offscreen;
              }
              var Sa = ue || xt.numHorizontalGlyphVertices === 0 && xt.numVerticalGlyphVertices === 0, li = J || xt.numIconVertices === 0;
              if (Sa || li ? li ? Sa || (Xt = Xt && Kt) : Kt = Xt && Kt : Xt = Kt = Xt && Kt, Kt && ir && ir.box && d.collisionIndex.insertCollisionBox(ir.box, E.get("text-ignore-placement"), w.bucketInstanceId, si && si.box && Tn ? Tn : gi, re.ID), Xt && Li && d.collisionIndex.insertCollisionBox(Li.box, E.get("icon-ignore-placement"), w.bucketInstanceId, Ln, re.ID), On && (Kt && d.collisionIndex.insertCollisionCircles(On.circles, E.get("text-ignore-placement"), w.bucketInstanceId, gi, re.ID), c)) {
                var qa = w.bucketInstanceId, Os = d.collisionCircleArrays[qa];
                Os === void 0 && (Os = d.collisionCircleArrays[qa] = new Go());
                for (var xl = 0; xl < On.circles.length; xl += 4)
                  Os.circles.push(On.circles[xl + 0]), Os.circles.push(On.circles[xl + 1]), Os.circles.push(On.circles[xl + 2]), Os.circles.push(On.collisionDetected ? 1 : 0);
              }
              d.placements[xt.crossTileID] = new im(Kt || je, Xt || nt, nr || w.justReloaded), f[xt.crossTileID] = !0;
            }
        };
        if (ke)
          for (var gt = w.getSortedSymbolIndexes(this.transform.angle), Dt = gt.length - 1; Dt >= 0; --Dt) {
            var Bt = gt[Dt];
            tt(w.symbolInstances.get(Bt), w.collisionArrays[Bt]);
          }
        else
          for (var zt = u.symbolInstanceStart; zt < u.symbolInstanceEnd; zt++)
            tt(w.symbolInstances.get(zt), w.collisionArrays[zt]);
        if (c && w.bucketInstanceId in this.collisionCircleArrays) {
          var Ir = this.collisionCircleArrays[w.bucketInstanceId];
          o.invert(Ir.invProjMatrix, O), Ir.viewportMatrix = this.collisionIndex.getViewportMatrix();
        }
        w.justReloaded = !1;
      }, Ui.prototype.markUsedJustification = function(u, f, c, d) {
        var _;
        _ = d === o.WritingMode.vertical ? c.verticalPlacedTextSymbolIndex : { left: c.leftJustifiedTextSymbolIndex, center: c.centerJustifiedTextSymbolIndex, right: c.rightJustifiedTextSymbolIndex }[o.getAnchorJustification(f)];
        for (var w = 0, E = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex]; w < E.length; w += 1) {
          var O = E[w];
          O >= 0 && (u.text.placedSymbolArray.get(O).crossTileID = _ >= 0 && O !== _ ? 0 : c.crossTileID);
        }
      }, Ui.prototype.markUsedOrientation = function(u, f, c) {
        for (var d = f === o.WritingMode.horizontal || f === o.WritingMode.horizontalOnly ? f : 0, _ = f === o.WritingMode.vertical ? f : 0, w = 0, E = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex]; w < E.length; w += 1)
          u.text.placedSymbolArray.get(E[w]).placedOrientation = d;
        c.verticalPlacedTextSymbolIndex && (u.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = _);
      }, Ui.prototype.commit = function(u) {
        this.commitTime = u, this.zoomAtLastRecencyCheck = this.transform.zoom;
        var f = this.prevPlacement, c = !1;
        this.prevZoomAdjustment = f ? f.zoomAdjustment(this.transform.zoom) : 0;
        var d = f ? f.symbolFadeChange(u) : 1, _ = f ? f.opacities : {}, w = f ? f.variableOffsets : {}, E = f ? f.placedOrientations : {};
        for (var O in this.placements) {
          var k = this.placements[O], R = _[O];
          R ? (this.opacities[O] = new To(R, d, k.text, k.icon), c = c || k.text !== R.text.placed || k.icon !== R.icon.placed) : (this.opacities[O] = new To(null, d, k.text, k.icon, k.skipFade), c = c || k.text || k.icon);
        }
        for (var q in _) {
          var $ = _[q];
          if (!this.opacities[q]) {
            var H = new To($, d, !1, !1);
            H.isHidden() || (this.opacities[q] = H, c = c || $.text.placed || $.icon.placed);
          }
        }
        for (var ne in w)
          this.variableOffsets[ne] || !this.opacities[ne] || this.opacities[ne].isHidden() || (this.variableOffsets[ne] = w[ne]);
        for (var re in E)
          this.placedOrientations[re] || !this.opacities[re] || this.opacities[re].isHidden() || (this.placedOrientations[re] = E[re]);
        c ? this.lastPlacementChangeTime = u : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = f ? f.lastPlacementChangeTime : u);
      }, Ui.prototype.updateLayerOpacities = function(u, f) {
        for (var c = {}, d = 0, _ = f; d < _.length; d += 1) {
          var w = _[d], E = w.getBucket(u);
          E && w.latestFeatureIndex && u.id === E.layerIds[0] && this.updateBucketOpacities(E, c, w.collisionBoxArray);
        }
      }, Ui.prototype.updateBucketOpacities = function(u, f, c) {
        var d = this;
        u.hasTextData() && u.text.opacityVertexArray.clear(), u.hasIconData() && u.icon.opacityVertexArray.clear(), u.hasIconCollisionBoxData() && u.iconCollisionBox.collisionVertexArray.clear(), u.hasTextCollisionBoxData() && u.textCollisionBox.collisionVertexArray.clear();
        var _ = u.layers[0].layout, w = new To(null, 0, !1, !1, !0), E = _.get("text-allow-overlap"), O = _.get("icon-allow-overlap"), k = _.get("text-variable-anchor"), R = _.get("text-rotation-alignment") === "map", q = _.get("text-pitch-alignment") === "map", $ = _.get("icon-text-fit") !== "none", H = new To(null, 0, E && (O || !u.hasIconData() || _.get("icon-optional")), O && (E || !u.hasTextData() || _.get("text-optional")), !0);
        !u.collisionArrays && c && (u.hasIconCollisionBoxData() || u.hasTextCollisionBoxData()) && u.deserializeCollisionBoxes(c);
        for (var ne = function(le, me, _e) {
          for (var Ae = 0; Ae < me / 4; Ae++)
            le.opacityVertexArray.emplaceBack(_e);
        }, re = function(le) {
          var me = u.symbolInstances.get(le), _e = me.numHorizontalGlyphVertices, Ae = me.numVerticalGlyphVertices, Me = me.crossTileID, ke = d.opacities[Me];
          f[Me] ? ke = w : ke || (d.opacities[Me] = ke = H), f[Me] = !0;
          var je = me.numIconVertices > 0, nt = d.placedOrientations[me.crossTileID], tt = nt === o.WritingMode.vertical, gt = nt === o.WritingMode.horizontal || nt === o.WritingMode.horizontalOnly;
          if (_e > 0 || Ae > 0) {
            var Dt = sm(ke.text);
            ne(u.text, _e, tt ? Hl : Dt), ne(u.text, Ae, gt ? Hl : Dt);
            var Bt = ke.text.isHidden();
            [me.rightJustifiedTextSymbolIndex, me.centerJustifiedTextSymbolIndex, me.leftJustifiedTextSymbolIndex].forEach(function(qt) {
              qt >= 0 && (u.text.placedSymbolArray.get(qt).hidden = Bt || tt ? 1 : 0);
            }), me.verticalPlacedTextSymbolIndex >= 0 && (u.text.placedSymbolArray.get(me.verticalPlacedTextSymbolIndex).hidden = Bt || gt ? 1 : 0);
            var zt = d.variableOffsets[me.crossTileID];
            zt && d.markUsedJustification(u, zt.anchor, me, nt);
            var Ir = d.placedOrientations[me.crossTileID];
            Ir && (d.markUsedJustification(u, "left", me, Ir), d.markUsedOrientation(u, Ir, me));
          }
          if (je) {
            var xt = sm(ke.icon), Yt = !($ && me.verticalPlacedIconSymbolIndex && tt);
            me.placedIconSymbolIndex >= 0 && (ne(u.icon, me.numIconVertices, Yt ? xt : Hl), u.icon.placedSymbolArray.get(me.placedIconSymbolIndex).hidden = ke.icon.isHidden()), me.verticalPlacedIconSymbolIndex >= 0 && (ne(u.icon, me.numVerticalIconVertices, Yt ? Hl : xt), u.icon.placedSymbolArray.get(me.verticalPlacedIconSymbolIndex).hidden = ke.icon.isHidden());
          }
          if (u.hasIconCollisionBoxData() || u.hasTextCollisionBoxData()) {
            var ir = u.collisionArrays[le];
            if (ir) {
              var Kt = new o.Point(0, 0);
              if (ir.textBox || ir.verticalTextBox) {
                var Xt = !0;
                if (k) {
                  var nr = d.variableOffsets[Me];
                  nr ? (Kt = Ei(nr.anchor, nr.width, nr.height, nr.textOffset, nr.textBoxScale), R && Kt._rotate(q ? d.transform.angle : -d.transform.angle)) : Xt = !1;
                }
                ir.textBox && nl(u.textCollisionBox.collisionVertexArray, ke.text.placed, !Xt || tt, Kt.x, Kt.y), ir.verticalTextBox && nl(u.textCollisionBox.collisionVertexArray, ke.text.placed, !Xt || gt, Kt.x, Kt.y);
              }
              var Ht = Boolean(!gt && ir.verticalIconBox);
              ir.iconBox && nl(u.iconCollisionBox.collisionVertexArray, ke.icon.placed, Ht, $ ? Kt.x : 0, $ ? Kt.y : 0), ir.verticalIconBox && nl(u.iconCollisionBox.collisionVertexArray, ke.icon.placed, !Ht, $ ? Kt.x : 0, $ ? Kt.y : 0);
            }
          }
        }, ue = 0; ue < u.symbolInstances.length; ue++)
          re(ue);
        if (u.sortFeatures(this.transform.angle), this.retainedQueryData[u.bucketInstanceId] && (this.retainedQueryData[u.bucketInstanceId].featureSortOrder = u.featureSortOrder), u.hasTextData() && u.text.opacityVertexBuffer && u.text.opacityVertexBuffer.updateData(u.text.opacityVertexArray), u.hasIconData() && u.icon.opacityVertexBuffer && u.icon.opacityVertexBuffer.updateData(u.icon.opacityVertexArray), u.hasIconCollisionBoxData() && u.iconCollisionBox.collisionVertexBuffer && u.iconCollisionBox.collisionVertexBuffer.updateData(u.iconCollisionBox.collisionVertexArray), u.hasTextCollisionBoxData() && u.textCollisionBox.collisionVertexBuffer && u.textCollisionBox.collisionVertexBuffer.updateData(u.textCollisionBox.collisionVertexArray), u.bucketInstanceId in this.collisionCircleArrays) {
          var J = this.collisionCircleArrays[u.bucketInstanceId];
          u.placementInvProjMatrix = J.invProjMatrix, u.placementViewportMatrix = J.viewportMatrix, u.collisionCircleArray = J.circles, delete this.collisionCircleArrays[u.bucketInstanceId];
        }
      }, Ui.prototype.symbolFadeChange = function(u) {
        return this.fadeDuration === 0 ? 1 : (u - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
      }, Ui.prototype.zoomAdjustment = function(u) {
        return Math.max(0, (this.transform.zoom - u) / 1.5);
      }, Ui.prototype.hasTransitions = function(u) {
        return this.stale || u - this.lastPlacementChangeTime < this.fadeDuration;
      }, Ui.prototype.stillRecent = function(u, f) {
        var c = this.zoomAtLastRecencyCheck === f ? 1 - this.zoomAdjustment(f) : 1;
        return this.zoomAtLastRecencyCheck = f, this.commitTime + this.fadeDuration * c > u;
      }, Ui.prototype.setStale = function() {
        this.stale = !0;
      };
      var Rv = Math.pow(2, 25), zv = Math.pow(2, 24), $f = Math.pow(2, 17), Fv = Math.pow(2, 16), om = Math.pow(2, 9), Bv = Math.pow(2, 8), am = Math.pow(2, 1);
      function sm(u) {
        if (u.opacity === 0 && !u.placed)
          return 0;
        if (u.opacity === 1 && u.placed)
          return 4294967295;
        var f = u.placed ? 1 : 0, c = Math.floor(127 * u.opacity);
        return c * Rv + f * zv + c * $f + f * Fv + c * om + f * Bv + c * am + f;
      }
      var Hl = 0, Wf = function(u) {
        this._sortAcrossTiles = u.layout.get("symbol-z-order") !== "viewport-y" && u.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
      };
      Wf.prototype.continuePlacement = function(u, f, c, d, _) {
        for (var w = this._bucketParts; this._currentTileIndex < u.length; )
          if (f.getBucketParts(w, d, u[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, _())
            return !0;
        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, w.sort(function(E, O) {
          return E.sortKey - O.sortKey;
        })); this._currentPartIndex < w.length; )
          if (f.placeLayerBucketPart(w[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, _())
            return !0;
        return !1;
      };
      var Zu = function(u, f, c, d, _, w, E) {
        this.placement = new Ui(u, _, w, E), this._currentPlacementIndex = f.length - 1, this._forceFullPlacement = c, this._showCollisionBoxes = d, this._done = !1;
      };
      Zu.prototype.isDone = function() {
        return this._done;
      }, Zu.prototype.continuePlacement = function(u, f, c) {
        for (var d = this, _ = o.browser.now(), w = function() {
          var k = o.browser.now() - _;
          return !d._forceFullPlacement && k > 2;
        }; this._currentPlacementIndex >= 0; ) {
          var E = f[u[this._currentPlacementIndex]], O = this.placement.collisionIndex.transform.zoom;
          if (E.type === "symbol" && (!E.minzoom || E.minzoom <= O) && (!E.maxzoom || E.maxzoom > O)) {
            if (this._inProgressLayer || (this._inProgressLayer = new Wf(E)), this._inProgressLayer.continuePlacement(c[E.source], this.placement, this._showCollisionBoxes, E, w))
              return;
            delete this._inProgressLayer;
          }
          this._currentPlacementIndex--;
        }
        this._done = !0;
      }, Zu.prototype.commit = function(u) {
        return this.placement.commit(u), this.placement;
      };
      var lm = 512 / o.EXTENT / 2, ah = function(u, f, c) {
        this.tileID = u, this.indexedSymbolInstances = {}, this.bucketInstanceId = c;
        for (var d = 0; d < f.length; d++) {
          var _ = f.get(d), w = _.key;
          this.indexedSymbolInstances[w] || (this.indexedSymbolInstances[w] = []), this.indexedSymbolInstances[w].push({ crossTileID: _.crossTileID, coord: this.getScaledCoordinates(_, u) });
        }
      };
      ah.prototype.getScaledCoordinates = function(u, f) {
        var c = lm / Math.pow(2, f.canonical.z - this.tileID.canonical.z);
        return { x: Math.floor((f.canonical.x * o.EXTENT + u.anchorX) * c), y: Math.floor((f.canonical.y * o.EXTENT + u.anchorY) * c) };
      }, ah.prototype.findMatches = function(u, f, c) {
        for (var d = this.tileID.canonical.z < f.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - f.canonical.z), _ = 0; _ < u.length; _++) {
          var w = u.get(_);
          if (!w.crossTileID) {
            var E = this.indexedSymbolInstances[w.key];
            if (E)
              for (var O = this.getScaledCoordinates(w, f), k = 0, R = E; k < R.length; k += 1) {
                var q = R[k];
                if (Math.abs(q.coord.x - O.x) <= d && Math.abs(q.coord.y - O.y) <= d && !c[q.crossTileID]) {
                  c[q.crossTileID] = !0, w.crossTileID = q.crossTileID;
                  break;
                }
              }
          }
        }
      };
      var qo = function() {
        this.maxCrossTileID = 0;
      };
      qo.prototype.generate = function() {
        return ++this.maxCrossTileID;
      };
      var fs = function() {
        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
      };
      fs.prototype.handleWrapJump = function(u) {
        var f = Math.round((u - this.lng) / 360);
        if (f !== 0)
          for (var c in this.indexes) {
            var d = this.indexes[c], _ = {};
            for (var w in d) {
              var E = d[w];
              E.tileID = E.tileID.unwrapTo(E.tileID.wrap + f), _[E.tileID.key] = E;
            }
            this.indexes[c] = _;
          }
        this.lng = u;
      }, fs.prototype.addBucket = function(u, f, c) {
        if (this.indexes[u.overscaledZ] && this.indexes[u.overscaledZ][u.key]) {
          if (this.indexes[u.overscaledZ][u.key].bucketInstanceId === f.bucketInstanceId)
            return !1;
          this.removeBucketCrossTileIDs(u.overscaledZ, this.indexes[u.overscaledZ][u.key]);
        }
        for (var d = 0; d < f.symbolInstances.length; d++)
          f.symbolInstances.get(d).crossTileID = 0;
        this.usedCrossTileIDs[u.overscaledZ] || (this.usedCrossTileIDs[u.overscaledZ] = {});
        var _ = this.usedCrossTileIDs[u.overscaledZ];
        for (var w in this.indexes) {
          var E = this.indexes[w];
          if (Number(w) > u.overscaledZ)
            for (var O in E) {
              var k = E[O];
              k.tileID.isChildOf(u) && k.findMatches(f.symbolInstances, u, _);
            }
          else {
            var R = E[u.scaledTo(Number(w)).key];
            R && R.findMatches(f.symbolInstances, u, _);
          }
        }
        for (var q = 0; q < f.symbolInstances.length; q++) {
          var $ = f.symbolInstances.get(q);
          $.crossTileID || ($.crossTileID = c.generate(), _[$.crossTileID] = !0);
        }
        return this.indexes[u.overscaledZ] === void 0 && (this.indexes[u.overscaledZ] = {}), this.indexes[u.overscaledZ][u.key] = new ah(u, f.symbolInstances, f.bucketInstanceId), !0;
      }, fs.prototype.removeBucketCrossTileIDs = function(u, f) {
        for (var c in f.indexedSymbolInstances)
          for (var d = 0, _ = f.indexedSymbolInstances[c]; d < _.length; d += 1)
            delete this.usedCrossTileIDs[u][_[d].crossTileID];
      }, fs.prototype.removeStaleBuckets = function(u) {
        var f = !1;
        for (var c in this.indexes) {
          var d = this.indexes[c];
          for (var _ in d)
            u[d[_].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, d[_]), delete d[_], f = !0);
        }
        return f;
      };
      var ps = function() {
        this.layerIndexes = {}, this.crossTileIDs = new qo(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
      };
      ps.prototype.addLayer = function(u, f, c) {
        var d = this.layerIndexes[u.id];
        d === void 0 && (d = this.layerIndexes[u.id] = new fs());
        var _ = !1, w = {};
        d.handleWrapJump(c);
        for (var E = 0, O = f; E < O.length; E += 1) {
          var k = O[E], R = k.getBucket(u);
          R && u.id === R.layerIds[0] && (R.bucketInstanceId || (R.bucketInstanceId = ++this.maxBucketInstanceId), d.addBucket(k.tileID, R, this.crossTileIDs) && (_ = !0), w[R.bucketInstanceId] = !0);
        }
        return d.removeStaleBuckets(w) && (_ = !0), _;
      }, ps.prototype.pruneUnusedLayers = function(u) {
        var f = {};
        for (var c in u.forEach(function(d) {
          f[d] = !0;
        }), this.layerIndexes)
          f[c] || delete this.layerIndexes[c];
      };
      var il = function(u, f) {
        return o.emitValidationErrors(u, f && f.filter(function(c) {
          return c.identifier !== "source.canvas";
        }));
      }, ds = o.pick(De, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), ms = o.pick(De, ["setCenter", "setZoom", "setBearing", "setPitch"]), sh = function() {
        var u = {}, f = o.styleSpec.$version;
        for (var c in o.styleSpec.$root) {
          var d, _ = o.styleSpec.$root[c];
          _.required && (d = c === "version" ? f : _.type === "array" ? [] : {}) != null && (u[c] = d);
        }
        return u;
      }(), lo = function(u) {
        function f(c, d) {
          var _ = this;
          d === void 0 && (d = {}), u.call(this), this.map = c, this.dispatcher = new be(Le(), this), this.imageManager = new K(), this.imageManager.setEventedParent(this), this.glyphManager = new Se(c._requestManager, d.localIdeographFontFamily), this.lineAtlas = new at(256, 512), this.crossTileSymbolIndex = new ps(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", o.getReferrer());
          var w = this;
          this._rtlTextPluginCallback = f.registerForPluginStateChange(function(E) {
            w.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: E.pluginStatus, pluginURL: E.pluginURL }, function(O, k) {
              if (o.triggerPluginCompletionEvent(O), k && k.every(function(q) {
                return q;
              }))
                for (var R in w.sourceCaches)
                  w.sourceCaches[R].reload();
            });
          }), this.on("data", function(E) {
            if (E.dataType === "source" && E.sourceDataType === "metadata") {
              var O = _.sourceCaches[E.sourceId];
              if (O) {
                var k = O.getSource();
                if (k && k.vectorLayerIds)
                  for (var R in _._layers) {
                    var q = _._layers[R];
                    q.source === k.id && _._validateLayer(q);
                  }
              }
            }
          });
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.loadURL = function(c, d) {
          var _ = this;
          d === void 0 && (d = {}), this.fire(new o.Event("dataloading", { dataType: "style" }));
          var w = typeof d.validate == "boolean" ? d.validate : !o.isMapboxURL(c);
          c = this.map._requestManager.normalizeStyleURL(c, d.accessToken);
          var E = this.map._requestManager.transformRequest(c, o.ResourceType.Style);
          this._request = o.getJSON(E, function(O, k) {
            _._request = null, O ? _.fire(new o.ErrorEvent(O)) : k && _._load(k, w);
          });
        }, f.prototype.loadJSON = function(c, d) {
          var _ = this;
          d === void 0 && (d = {}), this.fire(new o.Event("dataloading", { dataType: "style" })), this._request = o.browser.frame(function() {
            _._request = null, _._load(c, d.validate !== !1);
          });
        }, f.prototype.loadEmpty = function() {
          this.fire(new o.Event("dataloading", { dataType: "style" })), this._load(sh, !1);
        }, f.prototype._load = function(c, d) {
          if (!d || !il(this, o.validateStyle(c))) {
            for (var _ in this._loaded = !0, this.stylesheet = c, c.sources)
              this.addSource(_, c.sources[_], { validate: !1 });
            c.sprite ? this._loadSprite(c.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(c.glyphs);
            var w = st(this.stylesheet.layers);
            this._order = w.map(function(R) {
              return R.id;
            }), this._layers = {}, this._serializedLayers = {};
            for (var E = 0, O = w; E < O.length; E += 1) {
              var k = O[E];
              (k = o.createStyleLayer(k)).setEventedParent(this, { layer: { id: k.id } }), this._layers[k.id] = k, this._serializedLayers[k.id] = k.serialize();
            }
            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new qe(this.stylesheet.light), this.fire(new o.Event("data", { dataType: "style" })), this.fire(new o.Event("style.load"));
          }
        }, f.prototype._loadSprite = function(c) {
          var d = this;
          this._spriteRequest = function(_, w, E) {
            var O, k, R, q = o.browser.devicePixelRatio > 1 ? "@2x" : "", $ = o.getJSON(w.transformRequest(w.normalizeSpriteURL(_, q, ".json"), o.ResourceType.SpriteJSON), function(re, ue) {
              $ = null, R || (R = re, O = ue, ne());
            }), H = o.getImage(w.transformRequest(w.normalizeSpriteURL(_, q, ".png"), o.ResourceType.SpriteImage), function(re, ue) {
              H = null, R || (R = re, k = ue, ne());
            });
            function ne() {
              if (R)
                E(R);
              else if (O && k) {
                var re = o.browser.getImageData(k), ue = {};
                for (var J in O) {
                  var le = O[J], me = le.width, _e = le.height, Ae = le.x, Me = le.y, ke = le.sdf, je = le.pixelRatio, nt = le.stretchX, tt = le.stretchY, gt = le.content, Dt = new o.RGBAImage({ width: me, height: _e });
                  o.RGBAImage.copy(re, Dt, { x: Ae, y: Me }, { x: 0, y: 0 }, { width: me, height: _e }), ue[J] = { data: Dt, pixelRatio: je, sdf: ke, stretchX: nt, stretchY: tt, content: gt };
                }
                E(null, ue);
              }
            }
            return { cancel: function() {
              $ && ($.cancel(), $ = null), H && (H.cancel(), H = null);
            } };
          }(c, this.map._requestManager, function(_, w) {
            if (d._spriteRequest = null, _)
              d.fire(new o.ErrorEvent(_));
            else if (w)
              for (var E in w)
                d.imageManager.addImage(E, w[E]);
            d.imageManager.setLoaded(!0), d._availableImages = d.imageManager.listImages(), d.dispatcher.broadcast("setImages", d._availableImages), d.fire(new o.Event("data", { dataType: "style" }));
          });
        }, f.prototype._validateLayer = function(c) {
          var d = this.sourceCaches[c.source];
          if (d) {
            var _ = c.sourceLayer;
            if (_) {
              var w = d.getSource();
              (w.type === "geojson" || w.vectorLayerIds && w.vectorLayerIds.indexOf(_) === -1) && this.fire(new o.ErrorEvent(new Error('Source layer "' + _ + '" does not exist on source "' + w.id + '" as specified by style layer "' + c.id + '"')));
            }
          }
        }, f.prototype.loaded = function() {
          if (!this._loaded || Object.keys(this._updatedSources).length)
            return !1;
          for (var c in this.sourceCaches)
            if (!this.sourceCaches[c].loaded())
              return !1;
          return !!this.imageManager.isLoaded();
        }, f.prototype._serializeLayers = function(c) {
          for (var d = [], _ = 0, w = c; _ < w.length; _ += 1) {
            var E = this._layers[w[_]];
            E.type !== "custom" && d.push(E.serialize());
          }
          return d;
        }, f.prototype.hasTransitions = function() {
          if (this.light && this.light.hasTransition())
            return !0;
          for (var c in this.sourceCaches)
            if (this.sourceCaches[c].hasTransition())
              return !0;
          for (var d in this._layers)
            if (this._layers[d].hasTransition())
              return !0;
          return !1;
        }, f.prototype._checkLoaded = function() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }, f.prototype.update = function(c) {
          if (this._loaded) {
            var d = this._changed;
            if (this._changed) {
              var _ = Object.keys(this._updatedLayers), w = Object.keys(this._removedLayers);
              for (var E in (_.length || w.length) && this._updateWorkerLayers(_, w), this._updatedSources) {
                var O = this._updatedSources[E];
                O === "reload" ? this._reloadSource(E) : O === "clear" && this._clearSource(E);
              }
              for (var k in this._updateTilesForChangedImages(), this._updatedPaintProps)
                this._layers[k].updateTransitions(c);
              this.light.updateTransitions(c), this._resetUpdates();
            }
            var R = {};
            for (var q in this.sourceCaches) {
              var $ = this.sourceCaches[q];
              R[q] = $.used, $.used = !1;
            }
            for (var H = 0, ne = this._order; H < ne.length; H += 1) {
              var re = this._layers[ne[H]];
              re.recalculate(c, this._availableImages), !re.isHidden(c.zoom) && re.source && (this.sourceCaches[re.source].used = !0);
            }
            for (var ue in R) {
              var J = this.sourceCaches[ue];
              R[ue] !== J.used && J.fire(new o.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: ue }));
            }
            this.light.recalculate(c), this.z = c.zoom, d && this.fire(new o.Event("data", { dataType: "style" }));
          }
        }, f.prototype._updateTilesForChangedImages = function() {
          var c = Object.keys(this._changedImages);
          if (c.length) {
            for (var d in this.sourceCaches)
              this.sourceCaches[d].reloadTilesForDependencies(["icons", "patterns"], c);
            this._changedImages = {};
          }
        }, f.prototype._updateWorkerLayers = function(c, d) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(c), removedIds: d });
        }, f.prototype._resetUpdates = function() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
        }, f.prototype.setState = function(c) {
          var d = this;
          if (this._checkLoaded(), il(this, o.validateStyle(c)))
            return !1;
          (c = o.clone$1(c)).layers = st(c.layers);
          var _ = function(E, O) {
            if (!E)
              return [{ command: De.setStyle, args: [O] }];
            var k = [];
            try {
              if (!o.deepEqual(E.version, O.version))
                return [{ command: De.setStyle, args: [O] }];
              o.deepEqual(E.center, O.center) || k.push({ command: De.setCenter, args: [O.center] }), o.deepEqual(E.zoom, O.zoom) || k.push({ command: De.setZoom, args: [O.zoom] }), o.deepEqual(E.bearing, O.bearing) || k.push({ command: De.setBearing, args: [O.bearing] }), o.deepEqual(E.pitch, O.pitch) || k.push({ command: De.setPitch, args: [O.pitch] }), o.deepEqual(E.sprite, O.sprite) || k.push({ command: De.setSprite, args: [O.sprite] }), o.deepEqual(E.glyphs, O.glyphs) || k.push({ command: De.setGlyphs, args: [O.glyphs] }), o.deepEqual(E.transition, O.transition) || k.push({ command: De.setTransition, args: [O.transition] }), o.deepEqual(E.light, O.light) || k.push({ command: De.setLight, args: [O.light] });
              var R = {}, q = [];
              (function(H, ne, re, ue) {
                var J;
                for (J in ne = ne || {}, H = H || {})
                  H.hasOwnProperty(J) && (ne.hasOwnProperty(J) || Ee(J, re, ue));
                for (J in ne)
                  ne.hasOwnProperty(J) && (H.hasOwnProperty(J) ? o.deepEqual(H[J], ne[J]) || (H[J].type === "geojson" && ne[J].type === "geojson" && jt(H, ne, J) ? re.push({ command: De.setGeoJSONSourceData, args: [J, ne[J].data] }) : He(J, ne, re, ue)) : he(J, ne, re));
              })(E.sources, O.sources, q, R);
              var $ = [];
              E.layers && E.layers.forEach(function(H) {
                R[H.source] ? k.push({ command: De.removeLayer, args: [H.id] }) : $.push(H);
              }), k = k.concat(q), function(H, ne, re) {
                ne = ne || [];
                var ue, J, le, me, _e, Ae, Me, ke = (H = H || []).map(Jt), je = ne.map(Jt), nt = H.reduce(Zt, {}), tt = ne.reduce(Zt, {}), gt = ke.slice(), Dt = /* @__PURE__ */ Object.create(null);
                for (ue = 0, J = 0; ue < ke.length; ue++)
                  tt.hasOwnProperty(le = ke[ue]) ? J++ : (re.push({ command: De.removeLayer, args: [le] }), gt.splice(gt.indexOf(le, J), 1));
                for (ue = 0, J = 0; ue < je.length; ue++)
                  gt[gt.length - 1 - ue] !== (le = je[je.length - 1 - ue]) && (nt.hasOwnProperty(le) ? (re.push({ command: De.removeLayer, args: [le] }), gt.splice(gt.lastIndexOf(le, gt.length - J), 1)) : J++, re.push({ command: De.addLayer, args: [tt[le], Ae = gt[gt.length - ue]] }), gt.splice(gt.length - ue, 0, le), Dt[le] = !0);
                for (ue = 0; ue < je.length; ue++)
                  if (me = nt[le = je[ue]], _e = tt[le], !Dt[le] && !o.deepEqual(me, _e))
                    if (o.deepEqual(me.source, _e.source) && o.deepEqual(me["source-layer"], _e["source-layer"]) && o.deepEqual(me.type, _e.type)) {
                      for (Me in Wt(me.layout, _e.layout, re, le, null, De.setLayoutProperty), Wt(me.paint, _e.paint, re, le, null, De.setPaintProperty), o.deepEqual(me.filter, _e.filter) || re.push({ command: De.setFilter, args: [le, _e.filter] }), o.deepEqual(me.minzoom, _e.minzoom) && o.deepEqual(me.maxzoom, _e.maxzoom) || re.push({ command: De.setLayerZoomRange, args: [le, _e.minzoom, _e.maxzoom] }), me)
                        me.hasOwnProperty(Me) && Me !== "layout" && Me !== "paint" && Me !== "filter" && Me !== "metadata" && Me !== "minzoom" && Me !== "maxzoom" && (Me.indexOf("paint.") === 0 ? Wt(me[Me], _e[Me], re, le, Me.slice(6), De.setPaintProperty) : o.deepEqual(me[Me], _e[Me]) || re.push({ command: De.setLayerProperty, args: [le, Me, _e[Me]] }));
                      for (Me in _e)
                        _e.hasOwnProperty(Me) && !me.hasOwnProperty(Me) && Me !== "layout" && Me !== "paint" && Me !== "filter" && Me !== "metadata" && Me !== "minzoom" && Me !== "maxzoom" && (Me.indexOf("paint.") === 0 ? Wt(me[Me], _e[Me], re, le, Me.slice(6), De.setPaintProperty) : o.deepEqual(me[Me], _e[Me]) || re.push({ command: De.setLayerProperty, args: [le, Me, _e[Me]] }));
                    } else
                      re.push({ command: De.removeLayer, args: [le] }), Ae = gt[gt.lastIndexOf(le) + 1], re.push({ command: De.addLayer, args: [_e, Ae] });
              }($, O.layers, k);
            } catch (H) {
              console.warn("Unable to compute style diff:", H), k = [{ command: De.setStyle, args: [O] }];
            }
            return k;
          }(this.serialize(), c).filter(function(E) {
            return !(E.command in ms);
          });
          if (_.length === 0)
            return !1;
          var w = _.filter(function(E) {
            return !(E.command in ds);
          });
          if (w.length > 0)
            throw new Error("Unimplemented: " + w.map(function(E) {
              return E.command;
            }).join(", ") + ".");
          return _.forEach(function(E) {
            E.command !== "setTransition" && d[E.command].apply(d, E.args);
          }), this.stylesheet = c, !0;
        }, f.prototype.addImage = function(c, d) {
          if (this.getImage(c))
            return this.fire(new o.ErrorEvent(new Error("An image with this name already exists.")));
          this.imageManager.addImage(c, d), this._afterImageUpdated(c);
        }, f.prototype.updateImage = function(c, d) {
          this.imageManager.updateImage(c, d);
        }, f.prototype.getImage = function(c) {
          return this.imageManager.getImage(c);
        }, f.prototype.removeImage = function(c) {
          if (!this.getImage(c))
            return this.fire(new o.ErrorEvent(new Error("No image with this name exists.")));
          this.imageManager.removeImage(c), this._afterImageUpdated(c);
        }, f.prototype._afterImageUpdated = function(c) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[c] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new o.Event("data", { dataType: "style" }));
        }, f.prototype.listImages = function() {
          return this._checkLoaded(), this.imageManager.listImages();
        }, f.prototype.addSource = function(c, d, _) {
          var w = this;
          if (_ === void 0 && (_ = {}), this._checkLoaded(), this.sourceCaches[c] !== void 0)
            throw new Error("There is already a source with this ID");
          if (!d.type)
            throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(d).join(", ") + ".");
          if (!(["vector", "raster", "geojson", "video", "image"].indexOf(d.type) >= 0 && this._validate(o.validateStyle.source, "sources." + c, d, null, _))) {
            this.map && this.map._collectResourceTiming && (d.collectResourceTiming = !0);
            var E = this.sourceCaches[c] = new ie(c, d, this.dispatcher);
            E.style = this, E.setEventedParent(this, function() {
              return { isSourceLoaded: w.loaded(), source: E.serialize(), sourceId: c };
            }), E.onAdd(this.map), this._changed = !0;
          }
        }, f.prototype.removeSource = function(c) {
          if (this._checkLoaded(), this.sourceCaches[c] === void 0)
            throw new Error("There is no source with this ID");
          for (var d in this._layers)
            if (this._layers[d].source === c)
              return this.fire(new o.ErrorEvent(new Error('Source "' + c + '" cannot be removed while layer "' + d + '" is using it.')));
          var _ = this.sourceCaches[c];
          delete this.sourceCaches[c], delete this._updatedSources[c], _.fire(new o.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: c })), _.setEventedParent(null), _.clearTiles(), _.onRemove && _.onRemove(this.map), this._changed = !0;
        }, f.prototype.setGeoJSONSourceData = function(c, d) {
          this._checkLoaded(), this.sourceCaches[c].getSource().setData(d), this._changed = !0;
        }, f.prototype.getSource = function(c) {
          return this.sourceCaches[c] && this.sourceCaches[c].getSource();
        }, f.prototype.addLayer = function(c, d, _) {
          _ === void 0 && (_ = {}), this._checkLoaded();
          var w = c.id;
          if (this.getLayer(w))
            this.fire(new o.ErrorEvent(new Error('Layer with id "' + w + '" already exists on this map')));
          else {
            var E;
            if (c.type === "custom") {
              if (il(this, o.validateCustomStyleLayer(c)))
                return;
              E = o.createStyleLayer(c);
            } else {
              if (typeof c.source == "object" && (this.addSource(w, c.source), c = o.clone$1(c), c = o.extend(c, { source: w })), this._validate(o.validateStyle.layer, "layers." + w, c, { arrayIndex: -1 }, _))
                return;
              E = o.createStyleLayer(c), this._validateLayer(E), E.setEventedParent(this, { layer: { id: w } }), this._serializedLayers[E.id] = E.serialize();
            }
            var O = d ? this._order.indexOf(d) : this._order.length;
            if (d && O === -1)
              this.fire(new o.ErrorEvent(new Error('Layer with id "' + d + '" does not exist on this map.')));
            else {
              if (this._order.splice(O, 0, w), this._layerOrderChanged = !0, this._layers[w] = E, this._removedLayers[w] && E.source && E.type !== "custom") {
                var k = this._removedLayers[w];
                delete this._removedLayers[w], k.type !== E.type ? this._updatedSources[E.source] = "clear" : (this._updatedSources[E.source] = "reload", this.sourceCaches[E.source].pause());
              }
              this._updateLayer(E), E.onAdd && E.onAdd(this.map);
            }
          }
        }, f.prototype.moveLayer = function(c, d) {
          if (this._checkLoaded(), this._changed = !0, this._layers[c]) {
            if (c !== d) {
              var _ = this._order.indexOf(c);
              this._order.splice(_, 1);
              var w = d ? this._order.indexOf(d) : this._order.length;
              d && w === -1 ? this.fire(new o.ErrorEvent(new Error('Layer with id "' + d + '" does not exist on this map.'))) : (this._order.splice(w, 0, c), this._layerOrderChanged = !0);
            }
          } else
            this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be moved.")));
        }, f.prototype.removeLayer = function(c) {
          this._checkLoaded();
          var d = this._layers[c];
          if (d) {
            d.setEventedParent(null);
            var _ = this._order.indexOf(c);
            this._order.splice(_, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[c] = d, delete this._layers[c], delete this._serializedLayers[c], delete this._updatedLayers[c], delete this._updatedPaintProps[c], d.onRemove && d.onRemove(this.map);
          } else
            this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be removed.")));
        }, f.prototype.getLayer = function(c) {
          return this._layers[c];
        }, f.prototype.hasLayer = function(c) {
          return c in this._layers;
        }, f.prototype.setLayerZoomRange = function(c, d, _) {
          this._checkLoaded();
          var w = this.getLayer(c);
          w ? w.minzoom === d && w.maxzoom === _ || (d != null && (w.minzoom = d), _ != null && (w.maxzoom = _), this._updateLayer(w)) : this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot have zoom extent.")));
        }, f.prototype.setFilter = function(c, d, _) {
          _ === void 0 && (_ = {}), this._checkLoaded();
          var w = this.getLayer(c);
          if (w) {
            if (!o.deepEqual(w.filter, d))
              return d == null ? (w.filter = void 0, void this._updateLayer(w)) : void (this._validate(o.validateStyle.filter, "layers." + w.id + ".filter", d, null, _) || (w.filter = o.clone$1(d), this._updateLayer(w)));
          } else
            this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be filtered.")));
        }, f.prototype.getFilter = function(c) {
          return o.clone$1(this.getLayer(c).filter);
        }, f.prototype.setLayoutProperty = function(c, d, _, w) {
          w === void 0 && (w = {}), this._checkLoaded();
          var E = this.getLayer(c);
          E ? o.deepEqual(E.getLayoutProperty(d), _) || (E.setLayoutProperty(d, _, w), this._updateLayer(E)) : this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be styled.")));
        }, f.prototype.getLayoutProperty = function(c, d) {
          var _ = this.getLayer(c);
          if (_)
            return _.getLayoutProperty(d);
          this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style.")));
        }, f.prototype.setPaintProperty = function(c, d, _, w) {
          w === void 0 && (w = {}), this._checkLoaded();
          var E = this.getLayer(c);
          E ? o.deepEqual(E.getPaintProperty(d), _) || (E.setPaintProperty(d, _, w) && this._updateLayer(E), this._changed = !0, this._updatedPaintProps[c] = !0) : this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be styled.")));
        }, f.prototype.getPaintProperty = function(c, d) {
          return this.getLayer(c).getPaintProperty(d);
        }, f.prototype.setFeatureState = function(c, d) {
          this._checkLoaded();
          var _ = c.source, w = c.sourceLayer, E = this.sourceCaches[_];
          if (E !== void 0) {
            var O = E.getSource().type;
            O === "geojson" && w ? this.fire(new o.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : O !== "vector" || w ? (c.id === void 0 && this.fire(new o.ErrorEvent(new Error("The feature id parameter must be provided."))), E.setFeatureState(w, c.id, d)) : this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new o.ErrorEvent(new Error("The source '" + _ + "' does not exist in the map's style.")));
        }, f.prototype.removeFeatureState = function(c, d) {
          this._checkLoaded();
          var _ = c.source, w = this.sourceCaches[_];
          if (w !== void 0) {
            var E = w.getSource().type, O = E === "vector" ? c.sourceLayer : void 0;
            E !== "vector" || O ? d && typeof c.id != "string" && typeof c.id != "number" ? this.fire(new o.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : w.removeFeatureState(O, c.id, d) : this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new o.ErrorEvent(new Error("The source '" + _ + "' does not exist in the map's style.")));
        }, f.prototype.getFeatureState = function(c) {
          this._checkLoaded();
          var d = c.source, _ = c.sourceLayer, w = this.sourceCaches[d];
          if (w !== void 0) {
            if (w.getSource().type !== "vector" || _)
              return c.id === void 0 && this.fire(new o.ErrorEvent(new Error("The feature id parameter must be provided."))), w.getFeatureState(_, c.id);
            this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new o.ErrorEvent(new Error("The source '" + d + "' does not exist in the map's style.")));
        }, f.prototype.getTransition = function() {
          return o.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }, f.prototype.serialize = function() {
          return o.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: o.mapObject(this.sourceCaches, function(c) {
            return c.serialize();
          }), layers: this._serializeLayers(this._order) }, function(c) {
            return c !== void 0;
          });
        }, f.prototype._updateLayer = function(c) {
          this._updatedLayers[c.id] = !0, c.source && !this._updatedSources[c.source] && this.sourceCaches[c.source].getSource().type !== "raster" && (this._updatedSources[c.source] = "reload", this.sourceCaches[c.source].pause()), this._changed = !0;
        }, f.prototype._flattenAndSortRenderedFeatures = function(c) {
          for (var d = this, _ = function(nt) {
            return d._layers[nt].type === "fill-extrusion";
          }, w = {}, E = [], O = this._order.length - 1; O >= 0; O--) {
            var k = this._order[O];
            if (_(k)) {
              w[k] = O;
              for (var R = 0, q = c; R < q.length; R += 1) {
                var $ = q[R][k];
                if ($)
                  for (var H = 0, ne = $; H < ne.length; H += 1)
                    E.push(ne[H]);
              }
            }
          }
          E.sort(function(nt, tt) {
            return tt.intersectionZ - nt.intersectionZ;
          });
          for (var re = [], ue = this._order.length - 1; ue >= 0; ue--) {
            var J = this._order[ue];
            if (_(J))
              for (var le = E.length - 1; le >= 0; le--) {
                var me = E[le].feature;
                if (w[me.layer.id] < ue)
                  break;
                re.push(me), E.pop();
              }
            else
              for (var _e = 0, Ae = c; _e < Ae.length; _e += 1) {
                var Me = Ae[_e][J];
                if (Me)
                  for (var ke = 0, je = Me; ke < je.length; ke += 1)
                    re.push(je[ke].feature);
              }
          }
          return re;
        }, f.prototype.queryRenderedFeatures = function(c, d, _) {
          d && d.filter && this._validate(o.validateStyle.filter, "queryRenderedFeatures.filter", d.filter, null, d);
          var w = {};
          if (d && d.layers) {
            if (!Array.isArray(d.layers))
              return this.fire(new o.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
            for (var E = 0, O = d.layers; E < O.length; E += 1) {
              var k = O[E], R = this._layers[k];
              if (!R)
                return this.fire(new o.ErrorEvent(new Error("The layer '" + k + "' does not exist in the map's style and cannot be queried for features."))), [];
              w[R.source] = !0;
            }
          }
          var q = [];
          for (var $ in d.availableImages = this._availableImages, this.sourceCaches)
            d.layers && !w[$] || q.push(kr(this.sourceCaches[$], this._layers, this._serializedLayers, c, d, _));
          return this.placement && q.push(function(H, ne, re, ue, J, le, me) {
            for (var _e = {}, Ae = le.queryRenderedSymbols(ue), Me = [], ke = 0, je = Object.keys(Ae).map(Number); ke < je.length; ke += 1)
              Me.push(me[je[ke]]);
            Me.sort(Vn);
            for (var nt = function() {
              var zt = gt[tt], Ir = zt.featureIndex.lookupSymbolFeatures(Ae[zt.bucketInstanceId], ne, zt.bucketIndex, zt.sourceLayerIndex, J.filter, J.layers, J.availableImages, H);
              for (var xt in Ir) {
                var Yt = _e[xt] = _e[xt] || [], ir = Ir[xt];
                ir.sort(function(nr, Ht) {
                  var qt = zt.featureSortOrder;
                  if (qt) {
                    var si = qt.indexOf(nr.featureIndex);
                    return qt.indexOf(Ht.featureIndex) - si;
                  }
                  return Ht.featureIndex - nr.featureIndex;
                });
                for (var Kt = 0, Xt = ir; Kt < Xt.length; Kt += 1)
                  Yt.push(Xt[Kt]);
              }
            }, tt = 0, gt = Me; tt < gt.length; tt += 1)
              nt();
            var Dt = function(zt) {
              _e[zt].forEach(function(Ir) {
                var xt = Ir.feature, Yt = re[H[zt].source].getFeatureState(xt.layer["source-layer"], xt.id);
                xt.source = xt.layer.source, xt.layer["source-layer"] && (xt.sourceLayer = xt.layer["source-layer"]), xt.state = Yt;
              });
            };
            for (var Bt in _e)
              Dt(Bt);
            return _e;
          }(this._layers, this._serializedLayers, this.sourceCaches, c, d, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(q);
        }, f.prototype.querySourceFeatures = function(c, d) {
          d && d.filter && this._validate(o.validateStyle.filter, "querySourceFeatures.filter", d.filter, null, d);
          var _ = this.sourceCaches[c];
          return _ ? function(w, E) {
            for (var O = w.getRenderableIds().map(function(ne) {
              return w.getTileByID(ne);
            }), k = [], R = {}, q = 0; q < O.length; q++) {
              var $ = O[q], H = $.tileID.canonical.key;
              R[H] || (R[H] = !0, $.querySourceFeatures(k, E));
            }
            return k;
          }(_, d) : [];
        }, f.prototype.addSourceType = function(c, d, _) {
          return f.getSourceType(c) ? _(new Error('A source type called "' + c + '" already exists.')) : (f.setSourceType(c, d), d.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: c, url: d.workerSourceURL }, _) : _(null, null));
        }, f.prototype.getLight = function() {
          return this.light.getLight();
        }, f.prototype.setLight = function(c, d) {
          d === void 0 && (d = {}), this._checkLoaded();
          var _ = this.light.getLight(), w = !1;
          for (var E in c)
            if (!o.deepEqual(c[E], _[E])) {
              w = !0;
              break;
            }
          if (w) {
            var O = { now: o.browser.now(), transition: o.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(c, d), this.light.updateTransitions(O);
          }
        }, f.prototype._validate = function(c, d, _, w, E) {
          return E === void 0 && (E = {}), (!E || E.validate !== !1) && il(this, c.call(o.validateStyle, o.extend({ key: d, style: this.serialize(), value: _, styleSpec: o.styleSpec }, w)));
        }, f.prototype._remove = function() {
          for (var c in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), o.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers)
            this._layers[c].setEventedParent(null);
          for (var d in this.sourceCaches)
            this.sourceCaches[d].clearTiles(), this.sourceCaches[d].setEventedParent(null);
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
        }, f.prototype._clearSource = function(c) {
          this.sourceCaches[c].clearTiles();
        }, f.prototype._reloadSource = function(c) {
          this.sourceCaches[c].resume(), this.sourceCaches[c].reload();
        }, f.prototype._updateSources = function(c) {
          for (var d in this.sourceCaches)
            this.sourceCaches[d].update(c);
        }, f.prototype._generateCollisionBoxes = function() {
          for (var c in this.sourceCaches)
            this._reloadSource(c);
        }, f.prototype._updatePlacement = function(c, d, _, w, E) {
          E === void 0 && (E = !1);
          for (var O = !1, k = !1, R = {}, q = 0, $ = this._order; q < $.length; q += 1) {
            var H = this._layers[$[q]];
            if (H.type === "symbol") {
              if (!R[H.source]) {
                var ne = this.sourceCaches[H.source];
                R[H.source] = ne.getRenderableIds(!0).map(function(me) {
                  return ne.getTileByID(me);
                }).sort(function(me, _e) {
                  return _e.tileID.overscaledZ - me.tileID.overscaledZ || (me.tileID.isLessThan(_e.tileID) ? -1 : 1);
                });
              }
              var re = this.crossTileSymbolIndex.addLayer(H, R[H.source], c.center.lng);
              O = O || re;
            }
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((E = E || this._layerOrderChanged || _ === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(o.browser.now(), c.zoom)) && (this.pauseablePlacement = new Zu(c, this._order, E, d, _, w, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, R), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(o.browser.now()), k = !0), O && this.pauseablePlacement.placement.setStale()), k || O)
            for (var ue = 0, J = this._order; ue < J.length; ue += 1) {
              var le = this._layers[J[ue]];
              le.type === "symbol" && this.placement.updateLayerOpacities(le, R[le.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(o.browser.now());
        }, f.prototype._releaseSymbolFadeTiles = function() {
          for (var c in this.sourceCaches)
            this.sourceCaches[c].releaseSymbolFadeTiles();
        }, f.prototype.getImages = function(c, d, _) {
          this.imageManager.getImages(d.icons, _), this._updateTilesForChangedImages();
          var w = this.sourceCaches[d.source];
          w && w.setDependencies(d.tileID.key, d.type, d.icons);
        }, f.prototype.getGlyphs = function(c, d, _) {
          this.glyphManager.getGlyphs(d.stacks, _);
        }, f.prototype.getResource = function(c, d, _) {
          return o.makeRequest(d, _);
        }, f;
      }(o.Evented);
      lo.getSourceType = function(u) {
        return Fi[u];
      }, lo.setSourceType = function(u, f) {
        Fi[u] = f;
      }, lo.registerForPluginStateChange = o.registerForPluginStateChange;
      var jn = o.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), Zl = Zr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}`), um = Zr(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Vv = Zr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), Uv = Zr(`varying vec3 v_data;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), Hf = Zr("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Zf = Zr(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`), Xf = Zr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), Kf = Zr("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), cm = Zr("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), hm = Zr("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"), jv = Zr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), Xu = Zr(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), Ku = Zr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fm = Zr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), Si = Zr(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), Yf = Zr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), ys = Zr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), gs = Zr(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), ol = Zr(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`), al = Zr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`), vs = Zr(`uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), sl = Zr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), ll = Zr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), _s = Zr(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}`), pm = Zr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), dm = Zr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`);
      function Zr(u, f) {
        var c = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, d = f.match(/attribute ([\w]+) ([\w]+)/g), _ = u.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = f.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), E = w ? w.concat(_) : _, O = {};
        return { fragmentSource: u = u.replace(c, function(k, R, q, $, H) {
          return O[H] = !0, R === "define" ? `
#ifndef HAS_UNIFORM_u_` + H + `
varying ` + q + " " + $ + " " + H + `;
#else
uniform ` + q + " " + $ + " u_" + H + `;
#endif
` : `
#ifdef HAS_UNIFORM_u_` + H + `
    ` + q + " " + $ + " " + H + " = u_" + H + `;
#endif
`;
        }), vertexSource: f = f.replace(c, function(k, R, q, $, H) {
          var ne = $ === "float" ? "vec2" : "vec4", re = H.match(/color/) ? "color" : ne;
          return O[H] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_` + H + `
uniform lowp float u_` + H + `_t;
attribute ` + q + " " + ne + " a_" + H + `;
varying ` + q + " " + $ + " " + H + `;
#else
uniform ` + q + " " + $ + " u_" + H + `;
#endif
` : re === "vec4" ? `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + H + " = a_" + H + `;
#else
    ` + q + " " + $ + " " + H + " = u_" + H + `;
#endif
` : `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + H + " = unpack_mix_" + re + "(a_" + H + ", u_" + H + `_t);
#else
    ` + q + " " + $ + " " + H + " = u_" + H + `;
#endif
` : R === "define" ? `
#ifndef HAS_UNIFORM_u_` + H + `
uniform lowp float u_` + H + `_t;
attribute ` + q + " " + ne + " a_" + H + `;
#else
uniform ` + q + " " + $ + " u_" + H + `;
#endif
` : re === "vec4" ? `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + q + " " + $ + " " + H + " = a_" + H + `;
#else
    ` + q + " " + $ + " " + H + " = u_" + H + `;
#endif
` : `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + q + " " + $ + " " + H + " = unpack_mix_" + re + "(a_" + H + ", u_" + H + `_t);
#else
    ` + q + " " + $ + " " + H + " = u_" + H + `;
#endif
`;
        }), staticAttributes: d, staticUniforms: E };
      }
      var Gv = Object.freeze({ __proto__: null, prelude: Zl, background: um, backgroundPattern: Vv, circle: Uv, clippingMask: Hf, heatmap: Zf, heatmapTexture: Xf, collisionBox: Kf, collisionCircle: cm, debug: hm, fill: jv, fillOutline: Xu, fillOutlinePattern: Ku, fillPattern: fm, fillExtrusion: Si, fillExtrusionPattern: Yf, hillshadePrepare: ys, hillshade: gs, line: ol, lineGradient: al, linePattern: vs, lineSDF: sl, raster: ll, symbolIcon: _s, symbolSDF: pm, symbolTextAndIcon: dm }), lh = function() {
        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
      };
      function mm(u) {
        for (var f = [], c = 0; c < u.length; c++)
          if (u[c] !== null) {
            var d = u[c].split(" ");
            f.push(d.pop());
          }
        return f;
      }
      lh.prototype.bind = function(u, f, c, d, _, w, E, O) {
        this.context = u;
        for (var k = this.boundPaintVertexBuffers.length !== d.length, R = 0; !k && R < d.length; R++)
          this.boundPaintVertexBuffers[R] !== d[R] && (k = !0);
        u.extVertexArrayObject && this.vao && this.boundProgram === f && this.boundLayoutVertexBuffer === c && !k && this.boundIndexBuffer === _ && this.boundVertexOffset === w && this.boundDynamicVertexBuffer === E && this.boundDynamicVertexBuffer2 === O ? (u.bindVertexArrayOES.set(this.vao), E && E.bind(), _ && _.dynamicDraw && _.bind(), O && O.bind()) : this.freshBind(f, c, d, _, w, E, O);
      }, lh.prototype.freshBind = function(u, f, c, d, _, w, E) {
        var O, k = u.numAttributes, R = this.context, q = R.gl;
        if (R.extVertexArrayObject)
          this.vao && this.destroy(), this.vao = R.extVertexArrayObject.createVertexArrayOES(), R.bindVertexArrayOES.set(this.vao), O = 0, this.boundProgram = u, this.boundLayoutVertexBuffer = f, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = d, this.boundVertexOffset = _, this.boundDynamicVertexBuffer = w, this.boundDynamicVertexBuffer2 = E;
        else {
          O = R.currentNumAttributes || 0;
          for (var $ = k; $ < O; $++)
            q.disableVertexAttribArray($);
        }
        f.enableAttributes(q, u);
        for (var H = 0, ne = c; H < ne.length; H += 1)
          ne[H].enableAttributes(q, u);
        w && w.enableAttributes(q, u), E && E.enableAttributes(q, u), f.bind(), f.setVertexAttribPointers(q, u, _);
        for (var re = 0, ue = c; re < ue.length; re += 1) {
          var J = ue[re];
          J.bind(), J.setVertexAttribPointers(q, u, _);
        }
        w && (w.bind(), w.setVertexAttribPointers(q, u, _)), d && d.bind(), E && (E.bind(), E.setVertexAttribPointers(q, u, _)), R.currentNumAttributes = k;
      }, lh.prototype.destroy = function() {
        this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
      };
      var ym = function(u, f, c, d, _, w) {
        var E = u.gl;
        this.program = E.createProgram();
        for (var O = mm(c.staticAttributes), k = d ? d.getBinderAttributes() : [], R = O.concat(k), q = c.staticUniforms ? mm(c.staticUniforms) : [], $ = d ? d.getBinderUniforms() : [], H = [], ne = 0, re = q.concat($); ne < re.length; ne += 1) {
          var ue = re[ne];
          H.indexOf(ue) < 0 && H.push(ue);
        }
        var J = d ? d.defines() : [];
        w && J.push("#define OVERDRAW_INSPECTOR;");
        var le = J.concat(Zl.fragmentSource, c.fragmentSource).join(`
`), me = J.concat(Zl.vertexSource, c.vertexSource).join(`
`), _e = E.createShader(E.FRAGMENT_SHADER);
        if (E.isContextLost())
          this.failedToCreate = !0;
        else {
          E.shaderSource(_e, le), E.compileShader(_e), E.attachShader(this.program, _e);
          var Ae = E.createShader(E.VERTEX_SHADER);
          if (E.isContextLost())
            this.failedToCreate = !0;
          else {
            E.shaderSource(Ae, me), E.compileShader(Ae), E.attachShader(this.program, Ae), this.attributes = {};
            var Me = {};
            this.numAttributes = R.length;
            for (var ke = 0; ke < this.numAttributes; ke++)
              R[ke] && (E.bindAttribLocation(this.program, ke, R[ke]), this.attributes[R[ke]] = ke);
            E.linkProgram(this.program), E.deleteShader(Ae), E.deleteShader(_e);
            for (var je = 0; je < H.length; je++) {
              var nt = H[je];
              if (nt && !Me[nt]) {
                var tt = E.getUniformLocation(this.program, nt);
                tt && (Me[nt] = tt);
              }
            }
            this.fixedUniforms = _(u, Me), this.binderUniforms = d ? d.getUniforms(u, Me) : [];
          }
        }
      };
      function gm(u, f, c) {
        var d = 1 / dn(c, 1, f.transform.tileZoom), _ = Math.pow(2, c.tileID.overscaledZ), w = c.tileSize * Math.pow(2, f.transform.tileZoom) / _, E = w * (c.tileID.canonical.x + c.tileID.wrap * _), O = w * c.tileID.canonical.y;
        return { u_image: 0, u_texsize: c.imageAtlasTexture.size, u_scale: [d, u.fromScale, u.toScale], u_fade: u.t, u_pixel_coord_upper: [E >> 16, O >> 16], u_pixel_coord_lower: [65535 & E, 65535 & O] };
      }
      ym.prototype.draw = function(u, f, c, d, _, w, E, O, k, R, q, $, H, ne, re, ue) {
        var J, le = u.gl;
        if (!this.failedToCreate) {
          for (var me in u.program.set(this.program), u.setDepthMode(c), u.setStencilMode(d), u.setColorMode(_), u.setCullFace(w), this.fixedUniforms)
            this.fixedUniforms[me].set(E[me]);
          ne && ne.setUniforms(u, this.binderUniforms, $, { zoom: H });
          for (var _e = (J = {}, J[le.LINES] = 2, J[le.TRIANGLES] = 3, J[le.LINE_STRIP] = 1, J)[f], Ae = 0, Me = q.get(); Ae < Me.length; Ae += 1) {
            var ke = Me[Ae], je = ke.vaos || (ke.vaos = {});
            (je[O] || (je[O] = new lh())).bind(u, this, k, ne ? ne.getPaintVertexBuffers() : [], R, ke.vertexOffset, re, ue), le.drawElements(f, ke.primitiveLength * _e, le.UNSIGNED_SHORT, ke.primitiveOffset * _e * 2);
          }
        }
      };
      var vm = function(u, f, c, d) {
        var _ = f.style.light, w = _.properties.get("position"), E = [w.x, w.y, w.z], O = o.create$1();
        _.properties.get("anchor") === "viewport" && o.fromRotation(O, -f.transform.angle), o.transformMat3(E, E, O);
        var k = _.properties.get("color");
        return { u_matrix: u, u_lightpos: E, u_lightintensity: _.properties.get("intensity"), u_lightcolor: [k.r, k.g, k.b], u_vertical_gradient: +c, u_opacity: d };
      }, ul = function(u, f, c, d, _, w, E) {
        return o.extend(vm(u, f, c, d), gm(w, f, E), { u_height_factor: -Math.pow(2, _.overscaledZ) / E.tileSize / 8 });
      }, xs = function(u) {
        return { u_matrix: u };
      }, cl = function(u, f, c, d) {
        return o.extend(xs(u), gm(c, f, d));
      }, _m = function(u, f) {
        return { u_matrix: u, u_world: f };
      }, xm = function(u, f, c, d, _) {
        return o.extend(cl(u, f, c, d), { u_world: _ });
      }, Jf = function(u, f, c, d) {
        var _, w, E = u.transform;
        if (d.paint.get("circle-pitch-alignment") === "map") {
          var O = dn(c, 1, E.zoom);
          _ = !0, w = [O, O];
        } else
          _ = !1, w = E.pixelsToGLUnits;
        return { u_camera_to_center_distance: E.cameraToCenterDistance, u_scale_with_map: +(d.paint.get("circle-pitch-scale") === "map"), u_matrix: u.translatePosMatrix(f.posMatrix, c, d.paint.get("circle-translate"), d.paint.get("circle-translate-anchor")), u_pitch_with_map: +_, u_device_pixel_ratio: o.browser.devicePixelRatio, u_extrude_scale: w };
      }, hl = function(u, f, c) {
        var d = dn(c, 1, f.zoom), _ = Math.pow(2, f.zoom - c.tileID.overscaledZ), w = c.tileID.overscaleFactor();
        return { u_matrix: u, u_camera_to_center_distance: f.cameraToCenterDistance, u_pixels_to_tile_units: d, u_extrude_scale: [f.pixelsToGLUnits[0] / (d * _), f.pixelsToGLUnits[1] / (d * _)], u_overscale_factor: w };
      }, bm = function(u, f, c) {
        return { u_matrix: u, u_inv_matrix: f, u_camera_to_center_distance: c.cameraToCenterDistance, u_viewport_size: [c.width, c.height] };
      }, fl = function(u, f, c) {
        return c === void 0 && (c = 1), { u_matrix: u, u_color: f, u_overlay: 0, u_overlay_scale: c };
      }, pl = function(u) {
        return { u_matrix: u };
      }, wm = function(u, f, c, d) {
        return { u_matrix: u, u_extrude_scale: dn(f, 1, c), u_intensity: d };
      }, Yu = function(u, f, c) {
        var d = u.transform;
        return { u_matrix: Em(u, f, c), u_ratio: 1 / dn(f, 1, d.zoom), u_device_pixel_ratio: o.browser.devicePixelRatio, u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]] };
      }, Qr = function(u, f, c, d) {
        return o.extend(Yu(u, f, c), { u_image: 0, u_image_height: d });
      }, uh = function(u, f, c, d) {
        var _ = u.transform, w = Xl(f, _);
        return { u_matrix: Em(u, f, c), u_texsize: f.imageAtlasTexture.size, u_ratio: 1 / dn(f, 1, _.zoom), u_device_pixel_ratio: o.browser.devicePixelRatio, u_image: 0, u_scale: [w, d.fromScale, d.toScale], u_fade: d.t, u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]] };
      }, qv = function(u, f, c, d, _) {
        var w = u.lineAtlas, E = Xl(f, u.transform), O = c.layout.get("line-cap") === "round", k = w.getDash(d.from, O), R = w.getDash(d.to, O), q = k.width * _.fromScale, $ = R.width * _.toScale;
        return o.extend(Yu(u, f, c), { u_patternscale_a: [E / q, -k.height / 2], u_patternscale_b: [E / $, -R.height / 2], u_sdfgamma: w.width / (256 * Math.min(q, $) * o.browser.devicePixelRatio) / 2, u_image: 0, u_tex_y_a: k.y, u_tex_y_b: R.y, u_mix: _.t });
      };
      function Xl(u, f) {
        return 1 / dn(u, 1, f.tileZoom);
      }
      function Em(u, f, c) {
        return u.translatePosMatrix(f.tileID.posMatrix, f, c.paint.get("line-translate"), c.paint.get("line-translate-anchor"));
      }
      var $v = function(u, f, c, d, _) {
        return { u_matrix: u, u_tl_parent: f, u_scale_parent: c, u_buffer_scale: 1, u_fade_t: d.mix, u_opacity: d.opacity * _.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: _.paint.get("raster-brightness-min"), u_brightness_high: _.paint.get("raster-brightness-max"), u_saturation_factor: (E = _.paint.get("raster-saturation"), E > 0 ? 1 - 1 / (1.001 - E) : -E), u_contrast_factor: (w = _.paint.get("raster-contrast"), w > 0 ? 1 / (1 - w) : 1 + w), u_spin_weights: Sm(_.paint.get("raster-hue-rotate")) };
        var w, E;
      };
      function Sm(u) {
        u *= Math.PI / 180;
        var f = Math.sin(u), c = Math.cos(u);
        return [(2 * c + 1) / 3, (-Math.sqrt(3) * f - c + 1) / 3, (Math.sqrt(3) * f - c + 1) / 3];
      }
      var ch, Kl = function(u, f, c, d, _, w, E, O, k, R) {
        var q = _.transform;
        return { u_is_size_zoom_constant: +(u === "constant" || u === "source"), u_is_size_feature_constant: +(u === "constant" || u === "camera"), u_size_t: f ? f.uSizeT : 0, u_size: f ? f.uSize : 0, u_camera_to_center_distance: q.cameraToCenterDistance, u_pitch: q.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +c, u_aspect_ratio: q.width / q.height, u_fade_change: _.options.fadeDuration ? _.symbolFadeChange : 1, u_matrix: w, u_label_plane_matrix: E, u_coord_matrix: O, u_is_text: +k, u_pitch_with_map: +d, u_texsize: R, u_texture: 0 };
      }, Ju = function(u, f, c, d, _, w, E, O, k, R, q) {
        var $ = _.transform;
        return o.extend(Kl(u, f, c, d, _, w, E, O, k, R), { u_gamma_scale: d ? Math.cos($._pitch) * $.cameraToCenterDistance : 1, u_device_pixel_ratio: o.browser.devicePixelRatio, u_is_halo: +q });
      }, hh = function(u, f, c, d, _, w, E, O, k, R) {
        return o.extend(Ju(u, f, c, d, _, w, E, O, !0, k, !0), { u_texsize_icon: R, u_texture_icon: 1 });
      }, Qu = function(u, f, c) {
        return { u_matrix: u, u_opacity: f, u_color: c };
      }, Yl = function(u, f, c, d, _, w) {
        return o.extend(function(E, O, k, R) {
          var q = k.imageManager.getPattern(E.from.toString()), $ = k.imageManager.getPattern(E.to.toString()), H = k.imageManager.getPixelSize(), ne = H.width, re = H.height, ue = Math.pow(2, R.tileID.overscaledZ), J = R.tileSize * Math.pow(2, k.transform.tileZoom) / ue, le = J * (R.tileID.canonical.x + R.tileID.wrap * ue), me = J * R.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: q.tl, u_pattern_br_a: q.br, u_pattern_tl_b: $.tl, u_pattern_br_b: $.br, u_texsize: [ne, re], u_mix: O.t, u_pattern_size_a: q.displaySize, u_pattern_size_b: $.displaySize, u_scale_a: O.fromScale, u_scale_b: O.toScale, u_tile_units_to_pixels: 1 / dn(R, 1, k.transform.tileZoom), u_pixel_coord_upper: [le >> 16, me >> 16], u_pixel_coord_lower: [65535 & le, 65535 & me] };
        }(d, w, c, _), { u_matrix: u, u_opacity: f });
      }, Tm = { fillExtrusion: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_lightpos: new o.Uniform3f(u, f.u_lightpos), u_lightintensity: new o.Uniform1f(u, f.u_lightintensity), u_lightcolor: new o.Uniform3f(u, f.u_lightcolor), u_vertical_gradient: new o.Uniform1f(u, f.u_vertical_gradient), u_opacity: new o.Uniform1f(u, f.u_opacity) };
      }, fillExtrusionPattern: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_lightpos: new o.Uniform3f(u, f.u_lightpos), u_lightintensity: new o.Uniform1f(u, f.u_lightintensity), u_lightcolor: new o.Uniform3f(u, f.u_lightcolor), u_vertical_gradient: new o.Uniform1f(u, f.u_vertical_gradient), u_height_factor: new o.Uniform1f(u, f.u_height_factor), u_image: new o.Uniform1i(u, f.u_image), u_texsize: new o.Uniform2f(u, f.u_texsize), u_pixel_coord_upper: new o.Uniform2f(u, f.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, f.u_pixel_coord_lower), u_scale: new o.Uniform3f(u, f.u_scale), u_fade: new o.Uniform1f(u, f.u_fade), u_opacity: new o.Uniform1f(u, f.u_opacity) };
      }, fill: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix) };
      }, fillPattern: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_image: new o.Uniform1i(u, f.u_image), u_texsize: new o.Uniform2f(u, f.u_texsize), u_pixel_coord_upper: new o.Uniform2f(u, f.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, f.u_pixel_coord_lower), u_scale: new o.Uniform3f(u, f.u_scale), u_fade: new o.Uniform1f(u, f.u_fade) };
      }, fillOutline: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_world: new o.Uniform2f(u, f.u_world) };
      }, fillOutlinePattern: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_world: new o.Uniform2f(u, f.u_world), u_image: new o.Uniform1i(u, f.u_image), u_texsize: new o.Uniform2f(u, f.u_texsize), u_pixel_coord_upper: new o.Uniform2f(u, f.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, f.u_pixel_coord_lower), u_scale: new o.Uniform3f(u, f.u_scale), u_fade: new o.Uniform1f(u, f.u_fade) };
      }, circle: function(u, f) {
        return { u_camera_to_center_distance: new o.Uniform1f(u, f.u_camera_to_center_distance), u_scale_with_map: new o.Uniform1i(u, f.u_scale_with_map), u_pitch_with_map: new o.Uniform1i(u, f.u_pitch_with_map), u_extrude_scale: new o.Uniform2f(u, f.u_extrude_scale), u_device_pixel_ratio: new o.Uniform1f(u, f.u_device_pixel_ratio), u_matrix: new o.UniformMatrix4f(u, f.u_matrix) };
      }, collisionBox: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_camera_to_center_distance: new o.Uniform1f(u, f.u_camera_to_center_distance), u_pixels_to_tile_units: new o.Uniform1f(u, f.u_pixels_to_tile_units), u_extrude_scale: new o.Uniform2f(u, f.u_extrude_scale), u_overscale_factor: new o.Uniform1f(u, f.u_overscale_factor) };
      }, collisionCircle: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_inv_matrix: new o.UniformMatrix4f(u, f.u_inv_matrix), u_camera_to_center_distance: new o.Uniform1f(u, f.u_camera_to_center_distance), u_viewport_size: new o.Uniform2f(u, f.u_viewport_size) };
      }, debug: function(u, f) {
        return { u_color: new o.UniformColor(u, f.u_color), u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_overlay: new o.Uniform1i(u, f.u_overlay), u_overlay_scale: new o.Uniform1f(u, f.u_overlay_scale) };
      }, clippingMask: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix) };
      }, heatmap: function(u, f) {
        return { u_extrude_scale: new o.Uniform1f(u, f.u_extrude_scale), u_intensity: new o.Uniform1f(u, f.u_intensity), u_matrix: new o.UniformMatrix4f(u, f.u_matrix) };
      }, heatmapTexture: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_world: new o.Uniform2f(u, f.u_world), u_image: new o.Uniform1i(u, f.u_image), u_color_ramp: new o.Uniform1i(u, f.u_color_ramp), u_opacity: new o.Uniform1f(u, f.u_opacity) };
      }, hillshade: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_image: new o.Uniform1i(u, f.u_image), u_latrange: new o.Uniform2f(u, f.u_latrange), u_light: new o.Uniform2f(u, f.u_light), u_shadow: new o.UniformColor(u, f.u_shadow), u_highlight: new o.UniformColor(u, f.u_highlight), u_accent: new o.UniformColor(u, f.u_accent) };
      }, hillshadePrepare: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_image: new o.Uniform1i(u, f.u_image), u_dimension: new o.Uniform2f(u, f.u_dimension), u_zoom: new o.Uniform1f(u, f.u_zoom), u_unpack: new o.Uniform4f(u, f.u_unpack) };
      }, line: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_ratio: new o.Uniform1f(u, f.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, f.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(u, f.u_units_to_pixels) };
      }, lineGradient: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_ratio: new o.Uniform1f(u, f.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, f.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(u, f.u_units_to_pixels), u_image: new o.Uniform1i(u, f.u_image), u_image_height: new o.Uniform1f(u, f.u_image_height) };
      }, linePattern: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_texsize: new o.Uniform2f(u, f.u_texsize), u_ratio: new o.Uniform1f(u, f.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, f.u_device_pixel_ratio), u_image: new o.Uniform1i(u, f.u_image), u_units_to_pixels: new o.Uniform2f(u, f.u_units_to_pixels), u_scale: new o.Uniform3f(u, f.u_scale), u_fade: new o.Uniform1f(u, f.u_fade) };
      }, lineSDF: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_ratio: new o.Uniform1f(u, f.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, f.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(u, f.u_units_to_pixels), u_patternscale_a: new o.Uniform2f(u, f.u_patternscale_a), u_patternscale_b: new o.Uniform2f(u, f.u_patternscale_b), u_sdfgamma: new o.Uniform1f(u, f.u_sdfgamma), u_image: new o.Uniform1i(u, f.u_image), u_tex_y_a: new o.Uniform1f(u, f.u_tex_y_a), u_tex_y_b: new o.Uniform1f(u, f.u_tex_y_b), u_mix: new o.Uniform1f(u, f.u_mix) };
      }, raster: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_tl_parent: new o.Uniform2f(u, f.u_tl_parent), u_scale_parent: new o.Uniform1f(u, f.u_scale_parent), u_buffer_scale: new o.Uniform1f(u, f.u_buffer_scale), u_fade_t: new o.Uniform1f(u, f.u_fade_t), u_opacity: new o.Uniform1f(u, f.u_opacity), u_image0: new o.Uniform1i(u, f.u_image0), u_image1: new o.Uniform1i(u, f.u_image1), u_brightness_low: new o.Uniform1f(u, f.u_brightness_low), u_brightness_high: new o.Uniform1f(u, f.u_brightness_high), u_saturation_factor: new o.Uniform1f(u, f.u_saturation_factor), u_contrast_factor: new o.Uniform1f(u, f.u_contrast_factor), u_spin_weights: new o.Uniform3f(u, f.u_spin_weights) };
      }, symbolIcon: function(u, f) {
        return { u_is_size_zoom_constant: new o.Uniform1i(u, f.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(u, f.u_is_size_feature_constant), u_size_t: new o.Uniform1f(u, f.u_size_t), u_size: new o.Uniform1f(u, f.u_size), u_camera_to_center_distance: new o.Uniform1f(u, f.u_camera_to_center_distance), u_pitch: new o.Uniform1f(u, f.u_pitch), u_rotate_symbol: new o.Uniform1i(u, f.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(u, f.u_aspect_ratio), u_fade_change: new o.Uniform1f(u, f.u_fade_change), u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(u, f.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(u, f.u_coord_matrix), u_is_text: new o.Uniform1i(u, f.u_is_text), u_pitch_with_map: new o.Uniform1i(u, f.u_pitch_with_map), u_texsize: new o.Uniform2f(u, f.u_texsize), u_texture: new o.Uniform1i(u, f.u_texture) };
      }, symbolSDF: function(u, f) {
        return { u_is_size_zoom_constant: new o.Uniform1i(u, f.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(u, f.u_is_size_feature_constant), u_size_t: new o.Uniform1f(u, f.u_size_t), u_size: new o.Uniform1f(u, f.u_size), u_camera_to_center_distance: new o.Uniform1f(u, f.u_camera_to_center_distance), u_pitch: new o.Uniform1f(u, f.u_pitch), u_rotate_symbol: new o.Uniform1i(u, f.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(u, f.u_aspect_ratio), u_fade_change: new o.Uniform1f(u, f.u_fade_change), u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(u, f.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(u, f.u_coord_matrix), u_is_text: new o.Uniform1i(u, f.u_is_text), u_pitch_with_map: new o.Uniform1i(u, f.u_pitch_with_map), u_texsize: new o.Uniform2f(u, f.u_texsize), u_texture: new o.Uniform1i(u, f.u_texture), u_gamma_scale: new o.Uniform1f(u, f.u_gamma_scale), u_device_pixel_ratio: new o.Uniform1f(u, f.u_device_pixel_ratio), u_is_halo: new o.Uniform1i(u, f.u_is_halo) };
      }, symbolTextAndIcon: function(u, f) {
        return { u_is_size_zoom_constant: new o.Uniform1i(u, f.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(u, f.u_is_size_feature_constant), u_size_t: new o.Uniform1f(u, f.u_size_t), u_size: new o.Uniform1f(u, f.u_size), u_camera_to_center_distance: new o.Uniform1f(u, f.u_camera_to_center_distance), u_pitch: new o.Uniform1f(u, f.u_pitch), u_rotate_symbol: new o.Uniform1i(u, f.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(u, f.u_aspect_ratio), u_fade_change: new o.Uniform1f(u, f.u_fade_change), u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(u, f.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(u, f.u_coord_matrix), u_is_text: new o.Uniform1i(u, f.u_is_text), u_pitch_with_map: new o.Uniform1i(u, f.u_pitch_with_map), u_texsize: new o.Uniform2f(u, f.u_texsize), u_texsize_icon: new o.Uniform2f(u, f.u_texsize_icon), u_texture: new o.Uniform1i(u, f.u_texture), u_texture_icon: new o.Uniform1i(u, f.u_texture_icon), u_gamma_scale: new o.Uniform1f(u, f.u_gamma_scale), u_device_pixel_ratio: new o.Uniform1f(u, f.u_device_pixel_ratio), u_is_halo: new o.Uniform1i(u, f.u_is_halo) };
      }, background: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_opacity: new o.Uniform1f(u, f.u_opacity), u_color: new o.UniformColor(u, f.u_color) };
      }, backgroundPattern: function(u, f) {
        return { u_matrix: new o.UniformMatrix4f(u, f.u_matrix), u_opacity: new o.Uniform1f(u, f.u_opacity), u_image: new o.Uniform1i(u, f.u_image), u_pattern_tl_a: new o.Uniform2f(u, f.u_pattern_tl_a), u_pattern_br_a: new o.Uniform2f(u, f.u_pattern_br_a), u_pattern_tl_b: new o.Uniform2f(u, f.u_pattern_tl_b), u_pattern_br_b: new o.Uniform2f(u, f.u_pattern_br_b), u_texsize: new o.Uniform2f(u, f.u_texsize), u_mix: new o.Uniform1f(u, f.u_mix), u_pattern_size_a: new o.Uniform2f(u, f.u_pattern_size_a), u_pattern_size_b: new o.Uniform2f(u, f.u_pattern_size_b), u_scale_a: new o.Uniform1f(u, f.u_scale_a), u_scale_b: new o.Uniform1f(u, f.u_scale_b), u_pixel_coord_upper: new o.Uniform2f(u, f.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, f.u_pixel_coord_lower), u_tile_units_to_pixels: new o.Uniform1f(u, f.u_tile_units_to_pixels) };
      } };
      function Jl(u, f, c, d, _, w, E) {
        for (var O = u.context, k = O.gl, R = u.useProgram("collisionBox"), q = [], $ = 0, H = 0, ne = 0; ne < d.length; ne++) {
          var re = d[ne], ue = f.getTile(re), J = ue.getBucket(c);
          if (J) {
            var le = re.posMatrix;
            _[0] === 0 && _[1] === 0 || (le = u.translatePosMatrix(re.posMatrix, ue, _, w));
            var me = E ? J.textCollisionBox : J.iconCollisionBox, _e = J.collisionCircleArray;
            if (_e.length > 0) {
              var Ae = o.create(), Me = le;
              o.mul(Ae, J.placementInvProjMatrix, u.transform.glCoordMatrix), o.mul(Ae, Ae, J.placementViewportMatrix), q.push({ circleArray: _e, circleOffset: H, transform: Me, invTransform: Ae }), H = $ += _e.length / 4;
            }
            me && R.draw(O, k.LINES, Z.disabled, ee.disabled, u.colorModeForRenderPass(), de.disabled, hl(le, u.transform, ue), c.id, me.layoutVertexBuffer, me.indexBuffer, me.segments, null, u.transform.zoom, null, null, me.collisionVertexBuffer);
          }
        }
        if (E && q.length) {
          var ke = u.useProgram("collisionCircle"), je = new o.StructArrayLayout2f1f2i16();
          je.resize(4 * $), je._trim();
          for (var nt = 0, tt = 0, gt = q; tt < gt.length; tt += 1)
            for (var Dt = gt[tt], Bt = 0; Bt < Dt.circleArray.length / 4; Bt++) {
              var zt = 4 * Bt, Ir = Dt.circleArray[zt + 0], xt = Dt.circleArray[zt + 1], Yt = Dt.circleArray[zt + 2], ir = Dt.circleArray[zt + 3];
              je.emplace(nt++, Ir, xt, Yt, ir, 0), je.emplace(nt++, Ir, xt, Yt, ir, 1), je.emplace(nt++, Ir, xt, Yt, ir, 2), je.emplace(nt++, Ir, xt, Yt, ir, 3);
            }
          (!ch || ch.length < 2 * $) && (ch = function(On) {
            var Li = 2 * On, gi = new o.StructArrayLayout3ui6();
            gi.resize(Li), gi._trim();
            for (var Tn = 0; Tn < Li; Tn++) {
              var Ln = 6 * Tn;
              gi.uint16[Ln + 0] = 4 * Tn + 0, gi.uint16[Ln + 1] = 4 * Tn + 1, gi.uint16[Ln + 2] = 4 * Tn + 2, gi.uint16[Ln + 3] = 4 * Tn + 2, gi.uint16[Ln + 4] = 4 * Tn + 3, gi.uint16[Ln + 5] = 4 * Tn + 0;
            }
            return gi;
          }($));
          for (var Kt = O.createIndexBuffer(ch, !0), Xt = O.createVertexBuffer(je, o.collisionCircleLayout.members, !0), nr = 0, Ht = q; nr < Ht.length; nr += 1) {
            var qt = Ht[nr], si = bm(qt.transform, qt.invTransform, u.transform);
            ke.draw(O, k.TRIANGLES, Z.disabled, ee.disabled, u.colorModeForRenderPass(), de.disabled, si, c.id, Xt, Kt, o.SegmentVector.simpleSegment(0, 2 * qt.circleOffset, qt.circleArray.length, qt.circleArray.length / 2), null, u.transform.zoom, null, null, null);
          }
          Xt.destroy(), Kt.destroy();
        }
      }
      var oa = o.identity(new Float32Array(16));
      function Mm(u, f, c, d, _, w) {
        var E = o.getAnchorAlignment(u), O = -(E.horizontalAlign - 0.5) * f, k = -(E.verticalAlign - 0.5) * c, R = o.evaluateVariableOffset(u, d);
        return new o.Point((O / _ + R[0]) * w, (k / _ + R[1]) * w);
      }
      function Im(u, f, c, d, _, w, E, O, k, R, q) {
        var $ = u.text.placedSymbolArray, H = u.text.dynamicLayoutVertexArray, ne = u.icon.dynamicLayoutVertexArray, re = {};
        H.clear();
        for (var ue = 0; ue < $.length; ue++) {
          var J = $.get(ue), le = J.hidden || !J.crossTileID || u.allowVerticalPlacement && !J.placedOrientation ? null : d[J.crossTileID];
          if (le) {
            var me = new o.Point(J.anchorX, J.anchorY), _e = gr(me, c ? O : E), Ae = Fr(w.cameraToCenterDistance, _e.signedDistanceFromCamera), Me = _.evaluateSizeForFeature(u.textSizeData, R, J) * Ae / o.ONE_EM;
            c && (Me *= u.tilePixelRatio / k);
            for (var ke = Mm(le.anchor, le.width, le.height, le.textOffset, le.textBoxScale, Me), je = c ? gr(me.add(ke), E).point : _e.point.add(f ? ke.rotate(-w.angle) : ke), nt = u.allowVerticalPlacement && J.placedOrientation === o.WritingMode.vertical ? Math.PI / 2 : 0, tt = 0; tt < J.numGlyphs; tt++)
              o.addDynamicAttributes(H, je, nt);
            q && J.associatedIconIndex >= 0 && (re[J.associatedIconIndex] = { shiftedAnchor: je, angle: nt });
          } else
            Vi(J.numGlyphs, H);
        }
        if (q) {
          ne.clear();
          for (var gt = u.icon.placedSymbolArray, Dt = 0; Dt < gt.length; Dt++) {
            var Bt = gt.get(Dt);
            if (Bt.hidden)
              Vi(Bt.numGlyphs, ne);
            else {
              var zt = re[Dt];
              if (zt)
                for (var Ir = 0; Ir < Bt.numGlyphs; Ir++)
                  o.addDynamicAttributes(ne, zt.shiftedAnchor, zt.angle);
              else
                Vi(Bt.numGlyphs, ne);
            }
          }
          u.icon.dynamicLayoutVertexBuffer.updateData(ne);
        }
        u.text.dynamicLayoutVertexBuffer.updateData(H);
      }
      function Om(u, f, c) {
        return c.iconsInText && f ? "symbolTextAndIcon" : u ? "symbolSDF" : "symbolIcon";
      }
      function dl(u, f, c, d, _, w, E, O, k, R, q, $) {
        for (var H = u.context, ne = H.gl, re = u.transform, ue = O === "map", J = k === "map", le = ue && c.layout.get("symbol-placement") !== "point", me = ue && !J && !le, _e = c.layout.get("symbol-sort-key").constantOr(1) !== void 0, Ae = !1, Me = u.depthModeForSublayer(0, Z.ReadOnly), ke = c.layout.get("text-variable-anchor"), je = [], nt = 0, tt = d; nt < tt.length; nt += 1) {
          var gt = tt[nt], Dt = f.getTile(gt), Bt = Dt.getBucket(c);
          if (Bt) {
            var zt = _ ? Bt.text : Bt.icon;
            if (zt && zt.segments.get().length) {
              var Ir = zt.programConfigurations.get(c.id), xt = _ || Bt.sdfIcons, Yt = _ ? Bt.textSizeData : Bt.iconSizeData, ir = J || re.pitch !== 0, Kt = u.useProgram(Om(xt, _, Bt), Ir), Xt = o.evaluateSizeForZoom(Yt, re.zoom), nr = void 0, Ht = [0, 0], qt = void 0, si = void 0, On = null, Li = void 0;
              if (_)
                qt = Dt.glyphAtlasTexture, si = ne.LINEAR, nr = Dt.glyphAtlasTexture.size, Bt.iconsInText && (Ht = Dt.imageAtlasTexture.size, On = Dt.imageAtlasTexture, Li = ir || u.options.rotating || u.options.zooming || Yt.kind === "composite" || Yt.kind === "camera" ? ne.LINEAR : ne.NEAREST);
              else {
                var gi = c.layout.get("icon-size").constantOr(0) !== 1 || Bt.iconsNeedLinear;
                qt = Dt.imageAtlasTexture, si = xt || u.options.rotating || u.options.zooming || gi || ir ? ne.LINEAR : ne.NEAREST, nr = Dt.imageAtlasTexture.size;
              }
              var Tn = dn(Dt, 1, u.transform.zoom), Ln = pn(gt.posMatrix, J, ue, u.transform, Tn), mo = Ur(gt.posMatrix, J, ue, u.transform, Tn), qi = ke && Bt.hasTextData(), Ms = c.layout.get("icon-text-fit") !== "none" && qi && Bt.hasIconData();
              le && $u(Bt, gt.posMatrix, u, _, Ln, mo, J, R);
              var Qi = u.translatePosMatrix(gt.posMatrix, Dt, w, E), ca = le || _ && ke || Ms ? oa : Ln, Zo = u.translatePosMatrix(mo, Dt, w, E, !0), hc = xt && c.paint.get(_ ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, iu = { program: Kt, buffers: zt, uniformValues: xt ? Bt.iconsInText ? hh(Yt.kind, Xt, me, J, u, Qi, ca, Zo, nr, Ht) : Ju(Yt.kind, Xt, me, J, u, Qi, ca, Zo, _, nr, !0) : Kl(Yt.kind, Xt, me, J, u, Qi, ca, Zo, _, nr), atlasTexture: qt, atlasTextureIcon: On, atlasInterpolation: si, atlasInterpolationIcon: Li, isSDF: xt, hasHalo: hc };
              if (_e && Bt.canOverlap) {
                Ae = !0;
                for (var Is = 0, ou = zt.segments.get(); Is < ou.length; Is += 1) {
                  var fc = ou[Is];
                  je.push({ segments: new o.SegmentVector([fc]), sortKey: fc.sortKey, state: iu });
                }
              } else
                je.push({ segments: zt.segments, sortKey: 0, state: iu });
            }
          }
        }
        Ae && je.sort(function(Os, xl) {
          return Os.sortKey - xl.sortKey;
        });
        for (var Ea = 0, pc = je; Ea < pc.length; Ea += 1) {
          var Sa = pc[Ea], li = Sa.state;
          if (H.activeTexture.set(ne.TEXTURE0), li.atlasTexture.bind(li.atlasInterpolation, ne.CLAMP_TO_EDGE), li.atlasTextureIcon && (H.activeTexture.set(ne.TEXTURE1), li.atlasTextureIcon && li.atlasTextureIcon.bind(li.atlasInterpolationIcon, ne.CLAMP_TO_EDGE)), li.isSDF) {
            var qa = li.uniformValues;
            li.hasHalo && (qa.u_is_halo = 1, ec(li.buffers, Sa.segments, c, u, li.program, Me, q, $, qa)), qa.u_is_halo = 0;
          }
          ec(li.buffers, Sa.segments, c, u, li.program, Me, q, $, li.uniformValues);
        }
      }
      function ec(u, f, c, d, _, w, E, O, k) {
        var R = d.context;
        _.draw(R, R.gl.TRIANGLES, w, E, O, de.disabled, k, c.id, u.layoutVertexBuffer, u.indexBuffer, f, c.paint, d.transform.zoom, u.programConfigurations.get(c.id), u.dynamicLayoutVertexBuffer, u.opacityVertexBuffer);
      }
      function fh(u, f, c, d, _, w, E) {
        var O, k, R, q, $, H = u.context.gl, ne = c.paint.get("fill-pattern"), re = ne && ne.constantOr(1), ue = c.getCrossfadeParameters();
        E ? (k = re && !c.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", O = H.LINES) : (k = re ? "fillPattern" : "fill", O = H.TRIANGLES);
        for (var J = 0, le = d; J < le.length; J += 1) {
          var me = le[J], _e = f.getTile(me);
          if (!re || _e.patternsLoaded()) {
            var Ae = _e.getBucket(c);
            if (Ae) {
              var Me = Ae.programConfigurations.get(c.id), ke = u.useProgram(k, Me);
              re && (u.context.activeTexture.set(H.TEXTURE0), _e.imageAtlasTexture.bind(H.LINEAR, H.CLAMP_TO_EDGE), Me.updatePaintBuffers(ue));
              var je = ne.constantOr(null);
              if (je && _e.imageAtlas) {
                var nt = _e.imageAtlas, tt = nt.patternPositions[je.to.toString()], gt = nt.patternPositions[je.from.toString()];
                tt && gt && Me.setConstantPatternPositions(tt, gt);
              }
              var Dt = u.translatePosMatrix(me.posMatrix, _e, c.paint.get("fill-translate"), c.paint.get("fill-translate-anchor"));
              if (E) {
                q = Ae.indexBuffer2, $ = Ae.segments2;
                var Bt = [H.drawingBufferWidth, H.drawingBufferHeight];
                R = k === "fillOutlinePattern" && re ? xm(Dt, u, ue, _e, Bt) : _m(Dt, Bt);
              } else
                q = Ae.indexBuffer, $ = Ae.segments, R = re ? cl(Dt, u, ue, _e) : xs(Dt);
              ke.draw(u.context, O, _, u.stencilModeForClipping(me), w, de.disabled, R, c.id, Ae.layoutVertexBuffer, q, $, c.paint, u.transform.zoom, Me);
            }
          }
        }
      }
      function Qf(u, f, c, d, _, w, E) {
        for (var O = u.context, k = O.gl, R = c.paint.get("fill-extrusion-pattern"), q = R.constantOr(1), $ = c.getCrossfadeParameters(), H = c.paint.get("fill-extrusion-opacity"), ne = 0, re = d; ne < re.length; ne += 1) {
          var ue = re[ne], J = f.getTile(ue), le = J.getBucket(c);
          if (le) {
            var me = le.programConfigurations.get(c.id), _e = u.useProgram(q ? "fillExtrusionPattern" : "fillExtrusion", me);
            q && (u.context.activeTexture.set(k.TEXTURE0), J.imageAtlasTexture.bind(k.LINEAR, k.CLAMP_TO_EDGE), me.updatePaintBuffers($));
            var Ae = R.constantOr(null);
            if (Ae && J.imageAtlas) {
              var Me = J.imageAtlas, ke = Me.patternPositions[Ae.to.toString()], je = Me.patternPositions[Ae.from.toString()];
              ke && je && me.setConstantPatternPositions(ke, je);
            }
            var nt = u.translatePosMatrix(ue.posMatrix, J, c.paint.get("fill-extrusion-translate"), c.paint.get("fill-extrusion-translate-anchor")), tt = c.paint.get("fill-extrusion-vertical-gradient"), gt = q ? ul(nt, u, tt, H, ue, $, J) : vm(nt, u, tt, H);
            _e.draw(O, O.gl.TRIANGLES, _, w, E, de.backCCW, gt, c.id, le.layoutVertexBuffer, le.indexBuffer, le.segments, c.paint, u.transform.zoom, me);
          }
        }
      }
      function ph(u, f, c, d, _, w) {
        var E = u.context, O = E.gl, k = f.fbo;
        if (k) {
          var R = u.useProgram("hillshade");
          E.activeTexture.set(O.TEXTURE0), O.bindTexture(O.TEXTURE_2D, k.colorAttachment.get());
          var q = function($, H, ne) {
            var re = ne.paint.get("hillshade-shadow-color"), ue = ne.paint.get("hillshade-highlight-color"), J = ne.paint.get("hillshade-accent-color"), le = ne.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            ne.paint.get("hillshade-illumination-anchor") === "viewport" && (le -= $.transform.angle);
            var me, _e, Ae, Me = !$.options.moving;
            return { u_matrix: $.transform.calculatePosMatrix(H.tileID.toUnwrapped(), Me), u_image: 0, u_latrange: (me = H.tileID, _e = Math.pow(2, me.canonical.z), Ae = me.canonical.y, [new o.MercatorCoordinate(0, Ae / _e).toLngLat().lat, new o.MercatorCoordinate(0, (Ae + 1) / _e).toLngLat().lat]), u_light: [ne.paint.get("hillshade-exaggeration"), le], u_shadow: re, u_highlight: ue, u_accent: J };
          }(u, f, c);
          R.draw(E, O.TRIANGLES, d, _, w, de.disabled, q, c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments);
        }
      }
      function Wv(u, f, c, d, _, w) {
        var E = u.context, O = E.gl, k = f.dem;
        if (k && k.data) {
          var R = k.dim, q = k.stride, $ = k.getPixels();
          if (E.activeTexture.set(O.TEXTURE1), E.pixelStoreUnpackPremultiplyAlpha.set(!1), f.demTexture = f.demTexture || u.getTileTexture(q), f.demTexture) {
            var H = f.demTexture;
            H.update($, { premultiply: !1 }), H.bind(O.NEAREST, O.CLAMP_TO_EDGE);
          } else
            f.demTexture = new o.Texture(E, $, O.RGBA, { premultiply: !1 }), f.demTexture.bind(O.NEAREST, O.CLAMP_TO_EDGE);
          E.activeTexture.set(O.TEXTURE0);
          var ne = f.fbo;
          if (!ne) {
            var re = new o.Texture(E, { width: R, height: R, data: null }, O.RGBA);
            re.bind(O.LINEAR, O.CLAMP_TO_EDGE), (ne = f.fbo = E.createFramebuffer(R, R, !0)).colorAttachment.set(re.texture);
          }
          E.bindFramebuffer.set(ne.framebuffer), E.viewport.set([0, 0, R, R]), u.useProgram("hillshadePrepare").draw(E, O.TRIANGLES, d, _, w, de.disabled, function(ue, J) {
            var le = J.stride, me = o.create();
            return o.ortho(me, 0, o.EXTENT, -o.EXTENT, 0, 0, 1), o.translate(me, me, [0, -o.EXTENT, 0]), { u_matrix: me, u_image: 1, u_dimension: [le, le], u_zoom: ue.overscaledZ, u_unpack: J.getUnpackVector() };
          }(f.tileID, k), c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments), f.needsHillshadePrepare = !1;
        }
      }
      function dh(u, f, c, d, _) {
        var w = d.paint.get("raster-fade-duration");
        if (w > 0) {
          var E = o.browser.now(), O = (E - u.timeAdded) / w, k = f ? (E - f.timeAdded) / w : -1, R = c.getSource(), q = _.coveringZoomLevel({ tileSize: R.tileSize, roundZoom: R.roundZoom }), $ = !f || Math.abs(f.tileID.overscaledZ - q) > Math.abs(u.tileID.overscaledZ - q), H = $ && u.refreshedUponExpiration ? 1 : o.clamp($ ? O : 1 - k, 0, 1);
          return u.refreshedUponExpiration && O >= 1 && (u.refreshedUponExpiration = !1), f ? { opacity: 1, mix: 1 - H } : { opacity: H, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      var ep = new o.Color(1, 0, 0, 1), Cm = new o.Color(0, 1, 0, 1), Am = new o.Color(0, 0, 1, 1), mh = new o.Color(1, 0, 1, 1), tp = new o.Color(0, 1, 1, 1);
      function rp(u, f, c, d) {
        tc(u, 0, f + c / 2, u.transform.width, c, d);
      }
      function np(u, f, c, d) {
        tc(u, f - c / 2, 0, c, u.transform.height, d);
      }
      function tc(u, f, c, d, _, w) {
        var E = u.context, O = E.gl;
        O.enable(O.SCISSOR_TEST), O.scissor(f * o.browser.devicePixelRatio, c * o.browser.devicePixelRatio, d * o.browser.devicePixelRatio, _ * o.browser.devicePixelRatio), E.clear({ color: w }), O.disable(O.SCISSOR_TEST);
      }
      function Pm(u, f, c) {
        var d = u.context, _ = d.gl, w = c.posMatrix, E = u.useProgram("debug"), O = Z.disabled, k = ee.disabled, R = u.colorModeForRenderPass();
        d.activeTexture.set(_.TEXTURE0), u.emptyTexture.bind(_.LINEAR, _.CLAMP_TO_EDGE), E.draw(d, _.LINE_STRIP, O, k, R, de.disabled, fl(w, o.Color.red), "$debug", u.debugBuffer, u.tileBorderIndexBuffer, u.debugSegments);
        var q = f.getTileByID(c.key).latestRawTileData, $ = Math.floor((q && q.byteLength || 0) / 1024), H = f.getTile(c).tileSize, ne = 512 / Math.min(H, 512) * (c.overscaledZ / u.transform.zoom) * 0.5, re = c.canonical.toString();
        c.overscaledZ !== c.canonical.z && (re += " => " + c.overscaledZ), function(ue, J) {
          ue.initDebugOverlayCanvas();
          var le = ue.debugOverlayCanvas, me = ue.context.gl, _e = ue.debugOverlayCanvas.getContext("2d");
          _e.clearRect(0, 0, le.width, le.height), _e.shadowColor = "white", _e.shadowBlur = 2, _e.lineWidth = 1.5, _e.strokeStyle = "white", _e.textBaseline = "top", _e.font = "bold 36px Open Sans, sans-serif", _e.fillText(J, 5, 5), _e.strokeText(J, 5, 5), ue.debugOverlayTexture.update(le), ue.debugOverlayTexture.bind(me.LINEAR, me.CLAMP_TO_EDGE);
        }(u, re + " " + $ + "kb"), E.draw(d, _.TRIANGLES, O, k, fe.alphaBlended, de.disabled, fl(w, o.Color.transparent, ne), "$debug", u.debugBuffer, u.quadTriangleIndexBuffer, u.debugSegments);
      }
      var ml = { symbol: function(u, f, c, d, _) {
        if (u.renderPass === "translucent") {
          var w = ee.disabled, E = u.colorModeForRenderPass();
          c.layout.get("text-variable-anchor") && function(O, k, R, q, $, H, ne) {
            for (var re = k.transform, ue = $ === "map", J = H === "map", le = 0, me = O; le < me.length; le += 1) {
              var _e = me[le], Ae = q.getTile(_e), Me = Ae.getBucket(R);
              if (Me && Me.text && Me.text.segments.get().length) {
                var ke = o.evaluateSizeForZoom(Me.textSizeData, re.zoom), je = dn(Ae, 1, k.transform.zoom), nt = pn(_e.posMatrix, J, ue, k.transform, je), tt = R.layout.get("icon-text-fit") !== "none" && Me.hasIconData();
                if (ke) {
                  var gt = Math.pow(2, re.zoom - Ae.tileID.overscaledZ);
                  Im(Me, ue, J, ne, o.symbolSize, re, nt, _e.posMatrix, gt, ke, tt);
                }
              }
            }
          }(d, u, c, f, c.layout.get("text-rotation-alignment"), c.layout.get("text-pitch-alignment"), _), c.paint.get("icon-opacity").constantOr(1) !== 0 && dl(u, f, c, d, !1, c.paint.get("icon-translate"), c.paint.get("icon-translate-anchor"), c.layout.get("icon-rotation-alignment"), c.layout.get("icon-pitch-alignment"), c.layout.get("icon-keep-upright"), w, E), c.paint.get("text-opacity").constantOr(1) !== 0 && dl(u, f, c, d, !0, c.paint.get("text-translate"), c.paint.get("text-translate-anchor"), c.layout.get("text-rotation-alignment"), c.layout.get("text-pitch-alignment"), c.layout.get("text-keep-upright"), w, E), f.map.showCollisionBoxes && (Jl(u, f, c, d, c.paint.get("text-translate"), c.paint.get("text-translate-anchor"), !0), Jl(u, f, c, d, c.paint.get("icon-translate"), c.paint.get("icon-translate-anchor"), !1));
        }
      }, circle: function(u, f, c, d) {
        if (u.renderPass === "translucent") {
          var _ = c.paint.get("circle-opacity"), w = c.paint.get("circle-stroke-width"), E = c.paint.get("circle-stroke-opacity"), O = c.layout.get("circle-sort-key").constantOr(1) !== void 0;
          if (_.constantOr(1) !== 0 || w.constantOr(1) !== 0 && E.constantOr(1) !== 0) {
            for (var k = u.context, R = k.gl, q = u.depthModeForSublayer(0, Z.ReadOnly), $ = ee.disabled, H = u.colorModeForRenderPass(), ne = [], re = 0; re < d.length; re++) {
              var ue = d[re], J = f.getTile(ue), le = J.getBucket(c);
              if (le) {
                var me = le.programConfigurations.get(c.id), _e = { programConfiguration: me, program: u.useProgram("circle", me), layoutVertexBuffer: le.layoutVertexBuffer, indexBuffer: le.indexBuffer, uniformValues: Jf(u, ue, J, c) };
                if (O)
                  for (var Ae = 0, Me = le.segments.get(); Ae < Me.length; Ae += 1) {
                    var ke = Me[Ae];
                    ne.push({ segments: new o.SegmentVector([ke]), sortKey: ke.sortKey, state: _e });
                  }
                else
                  ne.push({ segments: le.segments, sortKey: 0, state: _e });
              }
            }
            O && ne.sort(function(Dt, Bt) {
              return Dt.sortKey - Bt.sortKey;
            });
            for (var je = 0, nt = ne; je < nt.length; je += 1) {
              var tt = nt[je], gt = tt.state;
              gt.program.draw(k, R.TRIANGLES, q, $, H, de.disabled, gt.uniformValues, c.id, gt.layoutVertexBuffer, gt.indexBuffer, tt.segments, c.paint, u.transform.zoom, gt.programConfiguration);
            }
          }
        }
      }, heatmap: function(u, f, c, d) {
        if (c.paint.get("heatmap-opacity") !== 0)
          if (u.renderPass === "offscreen") {
            var _ = u.context, w = _.gl, E = ee.disabled, O = new fe([w.ONE, w.ONE], o.Color.transparent, [!0, !0, !0, !0]);
            (function(ne, re, ue) {
              var J = ne.gl;
              ne.activeTexture.set(J.TEXTURE1), ne.viewport.set([0, 0, re.width / 4, re.height / 4]);
              var le = ue.heatmapFbo;
              if (le)
                J.bindTexture(J.TEXTURE_2D, le.colorAttachment.get()), ne.bindFramebuffer.set(le.framebuffer);
              else {
                var me = J.createTexture();
                J.bindTexture(J.TEXTURE_2D, me), J.texParameteri(J.TEXTURE_2D, J.TEXTURE_WRAP_S, J.CLAMP_TO_EDGE), J.texParameteri(J.TEXTURE_2D, J.TEXTURE_WRAP_T, J.CLAMP_TO_EDGE), J.texParameteri(J.TEXTURE_2D, J.TEXTURE_MIN_FILTER, J.LINEAR), J.texParameteri(J.TEXTURE_2D, J.TEXTURE_MAG_FILTER, J.LINEAR), le = ue.heatmapFbo = ne.createFramebuffer(re.width / 4, re.height / 4, !1), function(_e, Ae, Me, ke) {
                  var je = _e.gl;
                  je.texImage2D(je.TEXTURE_2D, 0, je.RGBA, Ae.width / 4, Ae.height / 4, 0, je.RGBA, _e.extRenderToTextureHalfFloat ? _e.extTextureHalfFloat.HALF_FLOAT_OES : je.UNSIGNED_BYTE, null), ke.colorAttachment.set(Me);
                }(ne, re, me, le);
              }
            })(_, u, c), _.clear({ color: o.Color.transparent });
            for (var k = 0; k < d.length; k++) {
              var R = d[k];
              if (!f.hasRenderableParent(R)) {
                var q = f.getTile(R), $ = q.getBucket(c);
                if ($) {
                  var H = $.programConfigurations.get(c.id);
                  u.useProgram("heatmap", H).draw(_, w.TRIANGLES, Z.disabled, E, O, de.disabled, wm(R.posMatrix, q, u.transform.zoom, c.paint.get("heatmap-intensity")), c.id, $.layoutVertexBuffer, $.indexBuffer, $.segments, c.paint, u.transform.zoom, H);
                }
              }
            }
            _.viewport.set([0, 0, u.width, u.height]);
          } else
            u.renderPass === "translucent" && (u.context.setColorMode(u.colorModeForRenderPass()), function(ne, re) {
              var ue = ne.context, J = ue.gl, le = re.heatmapFbo;
              if (le) {
                ue.activeTexture.set(J.TEXTURE0), J.bindTexture(J.TEXTURE_2D, le.colorAttachment.get()), ue.activeTexture.set(J.TEXTURE1);
                var me = re.colorRampTexture;
                me || (me = re.colorRampTexture = new o.Texture(ue, re.colorRamp, J.RGBA)), me.bind(J.LINEAR, J.CLAMP_TO_EDGE), ne.useProgram("heatmapTexture").draw(ue, J.TRIANGLES, Z.disabled, ee.disabled, ne.colorModeForRenderPass(), de.disabled, function(_e, Ae, Me, ke) {
                  var je = o.create();
                  o.ortho(je, 0, _e.width, _e.height, 0, 0, 1);
                  var nt = _e.context.gl;
                  return { u_matrix: je, u_world: [nt.drawingBufferWidth, nt.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: Ae.paint.get("heatmap-opacity") };
                }(ne, re), re.id, ne.viewportBuffer, ne.quadTriangleIndexBuffer, ne.viewportSegments, re.paint, ne.transform.zoom);
              }
            }(u, c));
      }, line: function(u, f, c, d) {
        if (u.renderPass === "translucent") {
          var _ = c.paint.get("line-opacity"), w = c.paint.get("line-width");
          if (_.constantOr(1) !== 0 && w.constantOr(1) !== 0)
            for (var E = u.depthModeForSublayer(0, Z.ReadOnly), O = u.colorModeForRenderPass(), k = c.paint.get("line-dasharray"), R = c.paint.get("line-pattern"), q = R.constantOr(1), $ = c.paint.get("line-gradient"), H = c.getCrossfadeParameters(), ne = q ? "linePattern" : k ? "lineSDF" : $ ? "lineGradient" : "line", re = u.context, ue = re.gl, J = !0, le = 0, me = d; le < me.length; le += 1) {
              var _e = me[le], Ae = f.getTile(_e);
              if (!q || Ae.patternsLoaded()) {
                var Me = Ae.getBucket(c);
                if (Me) {
                  var ke = Me.programConfigurations.get(c.id), je = u.context.program.get(), nt = u.useProgram(ne, ke), tt = J || nt.program !== je, gt = R.constantOr(null);
                  if (gt && Ae.imageAtlas) {
                    var Dt = Ae.imageAtlas, Bt = Dt.patternPositions[gt.to.toString()], zt = Dt.patternPositions[gt.from.toString()];
                    Bt && zt && ke.setConstantPatternPositions(Bt, zt);
                  }
                  var Ir = q ? uh(u, Ae, c, H) : k ? qv(u, Ae, c, k, H) : $ ? Qr(u, Ae, c, Me.lineClipsArray.length) : Yu(u, Ae, c);
                  if (q)
                    re.activeTexture.set(ue.TEXTURE0), Ae.imageAtlasTexture.bind(ue.LINEAR, ue.CLAMP_TO_EDGE), ke.updatePaintBuffers(H);
                  else if (k && (tt || u.lineAtlas.dirty))
                    re.activeTexture.set(ue.TEXTURE0), u.lineAtlas.bind(re);
                  else if ($) {
                    var xt = Me.gradients[c.id], Yt = xt.texture;
                    if (c.gradientVersion !== xt.version) {
                      var ir = 256;
                      if (c.stepInterpolant) {
                        var Kt = f.getSource().maxzoom, Xt = _e.canonical.z === Kt ? Math.ceil(1 << u.transform.maxZoom - _e.canonical.z) : 1;
                        ir = o.clamp(o.nextPowerOfTwo(Me.maxLineLength / o.EXTENT * 1024 * Xt), 256, re.maxTextureSize);
                      }
                      xt.gradient = o.renderColorRamp({ expression: c.gradientExpression(), evaluationKey: "lineProgress", resolution: ir, image: xt.gradient || void 0, clips: Me.lineClipsArray }), xt.texture ? xt.texture.update(xt.gradient) : xt.texture = new o.Texture(re, xt.gradient, ue.RGBA), xt.version = c.gradientVersion, Yt = xt.texture;
                    }
                    re.activeTexture.set(ue.TEXTURE0), Yt.bind(c.stepInterpolant ? ue.NEAREST : ue.LINEAR, ue.CLAMP_TO_EDGE);
                  }
                  nt.draw(re, ue.TRIANGLES, E, u.stencilModeForClipping(_e), O, de.disabled, Ir, c.id, Me.layoutVertexBuffer, Me.indexBuffer, Me.segments, c.paint, u.transform.zoom, ke, Me.layoutVertexBuffer2), J = !1;
                }
              }
            }
        }
      }, fill: function(u, f, c, d) {
        var _ = c.paint.get("fill-color"), w = c.paint.get("fill-opacity");
        if (w.constantOr(1) !== 0) {
          var E = u.colorModeForRenderPass(), O = c.paint.get("fill-pattern"), k = u.opaquePassEnabledForLayer() && !O.constantOr(1) && _.constantOr(o.Color.transparent).a === 1 && w.constantOr(0) === 1 ? "opaque" : "translucent";
          if (u.renderPass === k) {
            var R = u.depthModeForSublayer(1, u.renderPass === "opaque" ? Z.ReadWrite : Z.ReadOnly);
            fh(u, f, c, d, R, E, !1);
          }
          if (u.renderPass === "translucent" && c.paint.get("fill-antialias")) {
            var q = u.depthModeForSublayer(c.getPaintProperty("fill-outline-color") ? 2 : 0, Z.ReadOnly);
            fh(u, f, c, d, q, E, !0);
          }
        }
      }, "fill-extrusion": function(u, f, c, d) {
        var _ = c.paint.get("fill-extrusion-opacity");
        if (_ !== 0 && u.renderPass === "translucent") {
          var w = new Z(u.context.gl.LEQUAL, Z.ReadWrite, u.depthRangeFor3D);
          if (_ !== 1 || c.paint.get("fill-extrusion-pattern").constantOr(1))
            Qf(u, f, c, d, w, ee.disabled, fe.disabled), Qf(u, f, c, d, w, u.stencilModeFor3D(), u.colorModeForRenderPass());
          else {
            var E = u.colorModeForRenderPass();
            Qf(u, f, c, d, w, ee.disabled, E);
          }
        }
      }, hillshade: function(u, f, c, d) {
        if (u.renderPass === "offscreen" || u.renderPass === "translucent") {
          for (var _ = u.context, w = u.depthModeForSublayer(0, Z.ReadOnly), E = u.colorModeForRenderPass(), O = u.renderPass === "translucent" ? u.stencilConfigForOverlap(d) : [{}, d], k = O[0], R = 0, q = O[1]; R < q.length; R += 1) {
            var $ = q[R], H = f.getTile($);
            H.needsHillshadePrepare && u.renderPass === "offscreen" ? Wv(u, H, c, w, ee.disabled, E) : u.renderPass === "translucent" && ph(u, H, c, w, k[$.overscaledZ], E);
          }
          _.viewport.set([0, 0, u.width, u.height]);
        }
      }, raster: function(u, f, c, d) {
        if (u.renderPass === "translucent" && c.paint.get("raster-opacity") !== 0 && d.length)
          for (var _ = u.context, w = _.gl, E = f.getSource(), O = u.useProgram("raster"), k = u.colorModeForRenderPass(), R = E instanceof pr ? [{}, d] : u.stencilConfigForOverlap(d), q = R[0], $ = R[1], H = $[$.length - 1].overscaledZ, ne = !u.options.moving, re = 0, ue = $; re < ue.length; re += 1) {
            var J = ue[re], le = u.depthModeForSublayer(J.overscaledZ - H, c.paint.get("raster-opacity") === 1 ? Z.ReadWrite : Z.ReadOnly, w.LESS), me = f.getTile(J), _e = u.transform.calculatePosMatrix(J.toUnwrapped(), ne);
            me.registerFadeDuration(c.paint.get("raster-fade-duration"));
            var Ae = f.findLoadedParent(J, 0), Me = dh(me, Ae, f, c, u.transform), ke = void 0, je = void 0, nt = c.paint.get("raster-resampling") === "nearest" ? w.NEAREST : w.LINEAR;
            _.activeTexture.set(w.TEXTURE0), me.texture.bind(nt, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST), _.activeTexture.set(w.TEXTURE1), Ae ? (Ae.texture.bind(nt, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST), ke = Math.pow(2, Ae.tileID.overscaledZ - me.tileID.overscaledZ), je = [me.tileID.canonical.x * ke % 1, me.tileID.canonical.y * ke % 1]) : me.texture.bind(nt, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST);
            var tt = $v(_e, je || [0, 0], ke || 1, Me, c);
            E instanceof pr ? O.draw(_, w.TRIANGLES, le, ee.disabled, k, de.disabled, tt, c.id, E.boundsBuffer, u.quadTriangleIndexBuffer, E.boundsSegments) : O.draw(_, w.TRIANGLES, le, q[J.overscaledZ], k, de.disabled, tt, c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments);
          }
      }, background: function(u, f, c) {
        var d = c.paint.get("background-color"), _ = c.paint.get("background-opacity");
        if (_ !== 0) {
          var w = u.context, E = w.gl, O = u.transform, k = O.tileSize, R = c.paint.get("background-pattern");
          if (!u.isPatternMissing(R)) {
            var q = !R && d.a === 1 && _ === 1 && u.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (u.renderPass === q) {
              var $ = ee.disabled, H = u.depthModeForSublayer(0, q === "opaque" ? Z.ReadWrite : Z.ReadOnly), ne = u.colorModeForRenderPass(), re = u.useProgram(R ? "backgroundPattern" : "background"), ue = O.coveringTiles({ tileSize: k });
              R && (w.activeTexture.set(E.TEXTURE0), u.imageManager.bind(u.context));
              for (var J = c.getCrossfadeParameters(), le = 0, me = ue; le < me.length; le += 1) {
                var _e = me[le], Ae = u.transform.calculatePosMatrix(_e.toUnwrapped()), Me = R ? Yl(Ae, _, u, R, { tileID: _e, tileSize: k }, J) : Qu(Ae, _, d);
                re.draw(w, E.TRIANGLES, H, $, ne, de.disabled, Me, c.id, u.tileExtentBuffer, u.quadTriangleIndexBuffer, u.tileExtentSegments);
              }
            }
          }
        }
      }, debug: function(u, f, c) {
        for (var d = 0; d < c.length; d++)
          Pm(u, f, c[d]);
      }, custom: function(u, f, c) {
        var d = u.context, _ = c.implementation;
        if (u.renderPass === "offscreen") {
          var w = _.prerender;
          w && (u.setCustomLayerDefaults(), d.setColorMode(u.colorModeForRenderPass()), w.call(_, d.gl, u.transform.customLayerMatrix()), d.setDirty(), u.setBaseState());
        } else if (u.renderPass === "translucent") {
          u.setCustomLayerDefaults(), d.setColorMode(u.colorModeForRenderPass()), d.setStencilMode(ee.disabled);
          var E = _.renderingMode === "3d" ? new Z(u.context.gl.LEQUAL, Z.ReadWrite, u.depthRangeFor3D) : u.depthModeForSublayer(0, Z.ReadOnly);
          d.setDepthMode(E), _.render(d.gl, u.transform.customLayerMatrix()), d.setDirty(), u.setBaseState(), d.bindFramebuffer.set(null);
        }
      } }, mn = function(u, f) {
        this.context = new G(u), this.transform = f, this._tileTextures = {}, this.setup(), this.numSublayers = ie.maxUnderzooming + ie.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new ps(), this.gpuTimers = {};
      };
      mn.prototype.resize = function(u, f) {
        if (this.width = u * o.browser.devicePixelRatio, this.height = f * o.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
          for (var c = 0, d = this.style._order; c < d.length; c += 1)
            this.style._layers[d[c]].resize();
      }, mn.prototype.setup = function() {
        var u = this.context, f = new o.StructArrayLayout2i4();
        f.emplaceBack(0, 0), f.emplaceBack(o.EXTENT, 0), f.emplaceBack(0, o.EXTENT), f.emplaceBack(o.EXTENT, o.EXTENT), this.tileExtentBuffer = u.createVertexBuffer(f, jn.members), this.tileExtentSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
        var c = new o.StructArrayLayout2i4();
        c.emplaceBack(0, 0), c.emplaceBack(o.EXTENT, 0), c.emplaceBack(0, o.EXTENT), c.emplaceBack(o.EXTENT, o.EXTENT), this.debugBuffer = u.createVertexBuffer(c, jn.members), this.debugSegments = o.SegmentVector.simpleSegment(0, 0, 4, 5);
        var d = new o.StructArrayLayout4i8();
        d.emplaceBack(0, 0, 0, 0), d.emplaceBack(o.EXTENT, 0, o.EXTENT, 0), d.emplaceBack(0, o.EXTENT, 0, o.EXTENT), d.emplaceBack(o.EXTENT, o.EXTENT, o.EXTENT, o.EXTENT), this.rasterBoundsBuffer = u.createVertexBuffer(d, Rr.members), this.rasterBoundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
        var _ = new o.StructArrayLayout2i4();
        _.emplaceBack(0, 0), _.emplaceBack(1, 0), _.emplaceBack(0, 1), _.emplaceBack(1, 1), this.viewportBuffer = u.createVertexBuffer(_, jn.members), this.viewportSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
        var w = new o.StructArrayLayout1ui2();
        w.emplaceBack(0), w.emplaceBack(1), w.emplaceBack(3), w.emplaceBack(2), w.emplaceBack(0), this.tileBorderIndexBuffer = u.createIndexBuffer(w);
        var E = new o.StructArrayLayout3ui6();
        E.emplaceBack(0, 1, 2), E.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = u.createIndexBuffer(E), this.emptyTexture = new o.Texture(u, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, u.gl.RGBA);
        var O = this.context.gl;
        this.stencilClearMode = new ee({ func: O.ALWAYS, mask: 0 }, 0, 255, O.ZERO, O.ZERO, O.ZERO);
      }, mn.prototype.clearStencil = function() {
        var u = this.context, f = u.gl;
        this.nextStencilID = 1, this.currentStencilSource = void 0;
        var c = o.create();
        o.ortho(c, 0, this.width, this.height, 0, 0, 1), o.scale(c, c, [f.drawingBufferWidth, f.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(u, f.TRIANGLES, Z.disabled, this.stencilClearMode, fe.disabled, de.disabled, pl(c), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
      }, mn.prototype._renderTileClippingMasks = function(u, f) {
        if (this.currentStencilSource !== u.source && u.isTileClipped() && f && f.length) {
          this.currentStencilSource = u.source;
          var c = this.context, d = c.gl;
          this.nextStencilID + f.length > 256 && this.clearStencil(), c.setColorMode(fe.disabled), c.setDepthMode(Z.disabled);
          var _ = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (var w = 0, E = f; w < E.length; w += 1) {
            var O = E[w], k = this._tileClippingMaskIDs[O.key] = this.nextStencilID++;
            _.draw(c, d.TRIANGLES, Z.disabled, new ee({ func: d.ALWAYS, mask: 0 }, k, 255, d.KEEP, d.KEEP, d.REPLACE), fe.disabled, de.disabled, pl(O.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
      }, mn.prototype.stencilModeFor3D = function() {
        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
        var u = this.nextStencilID++, f = this.context.gl;
        return new ee({ func: f.NOTEQUAL, mask: 255 }, u, 255, f.KEEP, f.KEEP, f.REPLACE);
      }, mn.prototype.stencilModeForClipping = function(u) {
        var f = this.context.gl;
        return new ee({ func: f.EQUAL, mask: 255 }, this._tileClippingMaskIDs[u.key], 0, f.KEEP, f.KEEP, f.REPLACE);
      }, mn.prototype.stencilConfigForOverlap = function(u) {
        var f, c = this.context.gl, d = u.sort(function(k, R) {
          return R.overscaledZ - k.overscaledZ;
        }), _ = d[d.length - 1].overscaledZ, w = d[0].overscaledZ - _ + 1;
        if (w > 1) {
          this.currentStencilSource = void 0, this.nextStencilID + w > 256 && this.clearStencil();
          for (var E = {}, O = 0; O < w; O++)
            E[O + _] = new ee({ func: c.GEQUAL, mask: 255 }, O + this.nextStencilID, 255, c.KEEP, c.KEEP, c.REPLACE);
          return this.nextStencilID += w, [E, d];
        }
        return [(f = {}, f[_] = ee.disabled, f), d];
      }, mn.prototype.colorModeForRenderPass = function() {
        var u = this.context.gl;
        return this._showOverdrawInspector ? new fe([u.CONSTANT_COLOR, u.ONE], new o.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? fe.unblended : fe.alphaBlended;
      }, mn.prototype.depthModeForSublayer = function(u, f, c) {
        if (!this.opaquePassEnabledForLayer())
          return Z.disabled;
        var d = 1 - ((1 + this.currentLayer) * this.numSublayers + u) * this.depthEpsilon;
        return new Z(c || this.context.gl.LEQUAL, f, [d, d]);
      }, mn.prototype.opaquePassEnabledForLayer = function() {
        return this.currentLayer < this.opaquePassCutoff;
      }, mn.prototype.render = function(u, f) {
        var c = this;
        this.style = u, this.options = f, this.lineAtlas = u.lineAtlas, this.imageManager = u.imageManager, this.glyphManager = u.glyphManager, this.symbolFadeChange = u.placement.symbolFadeChange(o.browser.now()), this.imageManager.beginFrame();
        var d = this.style._order, _ = this.style.sourceCaches;
        for (var w in _) {
          var E = _[w];
          E.used && E.prepare(this.context);
        }
        var O, k, R = {}, q = {}, $ = {};
        for (var H in _) {
          var ne = _[H];
          R[H] = ne.getVisibleCoordinates(), q[H] = R[H].slice().reverse(), $[H] = ne.getVisibleCoordinates(!0).reverse();
        }
        this.opaquePassCutoff = 1 / 0;
        for (var re = 0; re < d.length; re++)
          if (this.style._layers[d[re]].is3D()) {
            this.opaquePassCutoff = re;
            break;
          }
        this.renderPass = "offscreen";
        for (var ue = 0, J = d; ue < J.length; ue += 1) {
          var le = this.style._layers[J[ue]];
          if (le.hasOffscreenPass() && !le.isHidden(this.transform.zoom)) {
            var me = q[le.source];
            (le.type === "custom" || me.length) && this.renderLayer(this, _[le.source], le, me);
          }
        }
        for (this.context.bindFramebuffer.set(null), this.context.clear({ color: f.showOverdrawInspector ? o.Color.black : o.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = f.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (u._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
          var _e = this.style._layers[d[this.currentLayer]], Ae = _[_e.source], Me = R[_e.source];
          this._renderTileClippingMasks(_e, Me), this.renderLayer(this, Ae, _e, Me);
        }
        for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
          var ke = this.style._layers[d[this.currentLayer]], je = _[ke.source], nt = (ke.type === "symbol" ? $ : q)[ke.source];
          this._renderTileClippingMasks(ke, R[ke.source]), this.renderLayer(this, je, ke, nt);
        }
        this.options.showTileBoundaries && (o.values(this.style._layers).forEach(function(tt) {
          tt.source && !tt.isHidden(c.transform.zoom) && (tt.source !== (k && k.id) && (k = c.style.sourceCaches[tt.source]), (!O || O.getSource().maxzoom < k.getSource().maxzoom) && (O = k));
        }), O && ml.debug(this, O, O.getVisibleCoordinates())), this.options.showPadding && function(tt) {
          var gt = tt.transform.padding;
          rp(tt, tt.transform.height - (gt.top || 0), 3, ep), rp(tt, gt.bottom || 0, 3, Cm), np(tt, gt.left || 0, 3, Am), np(tt, tt.transform.width - (gt.right || 0), 3, mh);
          var Dt = tt.transform.centerPoint;
          (function(Bt, zt, Ir, xt) {
            tc(Bt, zt - 1, Ir - 10, 2, 20, xt), tc(Bt, zt - 10, Ir - 1, 20, 2, xt);
          })(tt, Dt.x, tt.transform.height - Dt.y, tp);
        }(this), this.context.setDefault();
      }, mn.prototype.renderLayer = function(u, f, c, d) {
        c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "custom" || d.length) && (this.id = c.id, this.gpuTimingStart(c), ml[c.type](u, f, c, d, this.style.placement.variableOffsets), this.gpuTimingEnd());
      }, mn.prototype.gpuTimingStart = function(u) {
        if (this.options.gpuTiming) {
          var f = this.context.extTimerQuery, c = this.gpuTimers[u.id];
          c || (c = this.gpuTimers[u.id] = { calls: 0, cpuTime: 0, query: f.createQueryEXT() }), c.calls++, f.beginQueryEXT(f.TIME_ELAPSED_EXT, c.query);
        }
      }, mn.prototype.gpuTimingEnd = function() {
        if (this.options.gpuTiming) {
          var u = this.context.extTimerQuery;
          u.endQueryEXT(u.TIME_ELAPSED_EXT);
        }
      }, mn.prototype.collectGpuTimers = function() {
        var u = this.gpuTimers;
        return this.gpuTimers = {}, u;
      }, mn.prototype.queryGpuTimers = function(u) {
        var f = {};
        for (var c in u) {
          var d = u[c], _ = this.context.extTimerQuery, w = _.getQueryObjectEXT(d.query, _.QUERY_RESULT_EXT) / 1e6;
          _.deleteQueryEXT(d.query), f[c] = w;
        }
        return f;
      }, mn.prototype.translatePosMatrix = function(u, f, c, d, _) {
        if (!c[0] && !c[1])
          return u;
        var w = _ ? d === "map" ? this.transform.angle : 0 : d === "viewport" ? -this.transform.angle : 0;
        if (w) {
          var E = Math.sin(w), O = Math.cos(w);
          c = [c[0] * O - c[1] * E, c[0] * E + c[1] * O];
        }
        var k = [_ ? c[0] : dn(f, c[0], this.transform.zoom), _ ? c[1] : dn(f, c[1], this.transform.zoom), 0], R = new Float32Array(16);
        return o.translate(R, u, k), R;
      }, mn.prototype.saveTileTexture = function(u) {
        var f = this._tileTextures[u.size[0]];
        f ? f.push(u) : this._tileTextures[u.size[0]] = [u];
      }, mn.prototype.getTileTexture = function(u) {
        var f = this._tileTextures[u];
        return f && f.length > 0 ? f.pop() : null;
      }, mn.prototype.isPatternMissing = function(u) {
        if (!u)
          return !1;
        if (!u.from || !u.to)
          return !0;
        var f = this.imageManager.getPattern(u.from.toString()), c = this.imageManager.getPattern(u.to.toString());
        return !f || !c;
      }, mn.prototype.useProgram = function(u, f) {
        this.cache = this.cache || {};
        var c = "" + u + (f ? f.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "");
        return this.cache[c] || (this.cache[c] = new ym(this.context, u, Gv[u], f, Tm[u], this._showOverdrawInspector)), this.cache[c];
      }, mn.prototype.setCustomLayerDefaults = function() {
        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
      }, mn.prototype.setBaseState = function() {
        var u = this.context.gl;
        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(u.FUNC_ADD);
      }, mn.prototype.initDebugOverlayCanvas = function() {
        this.debugOverlayCanvas == null && (this.debugOverlayCanvas = o.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new o.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
      }, mn.prototype.destroy = function() {
        this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
      };
      var yh = function(u, f) {
        this.points = u, this.planes = f;
      };
      yh.fromInvProjectionMatrix = function(u, f, c) {
        var d = Math.pow(2, c), _ = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(function(E) {
          return o.transformMat4([], E, u);
        }).map(function(E) {
          return o.scale$1([], E, 1 / E[3] / f * d);
        }), w = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(function(E) {
          var O = o.sub([], _[E[0]], _[E[1]]), k = o.sub([], _[E[2]], _[E[1]]), R = o.normalize([], o.cross([], O, k)), q = -o.dot(R, _[E[1]]);
          return R.concat(q);
        });
        return new yh(_, w);
      };
      var yl = function(u, f) {
        this.min = u, this.max = f, this.center = o.scale$2([], o.add([], this.min, this.max), 0.5);
      };
      yl.prototype.quadrant = function(u) {
        for (var f = [u % 2 == 0, u < 2], c = o.clone$2(this.min), d = o.clone$2(this.max), _ = 0; _ < f.length; _++)
          c[_] = f[_] ? this.min[_] : this.center[_], d[_] = f[_] ? this.center[_] : this.max[_];
        return d[2] = this.max[2], new yl(c, d);
      }, yl.prototype.distanceX = function(u) {
        return Math.max(Math.min(this.max[0], u[0]), this.min[0]) - u[0];
      }, yl.prototype.distanceY = function(u) {
        return Math.max(Math.min(this.max[1], u[1]), this.min[1]) - u[1];
      }, yl.prototype.intersects = function(u) {
        for (var f = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], c = !0, d = 0; d < u.planes.length; d++) {
          for (var _ = u.planes[d], w = 0, E = 0; E < f.length; E++)
            w += o.dot$1(_, f[E]) >= 0;
          if (w === 0)
            return 0;
          w !== f.length && (c = !1);
        }
        if (c)
          return 2;
        for (var O = 0; O < 3; O++) {
          for (var k = Number.MAX_VALUE, R = -Number.MAX_VALUE, q = 0; q < u.points.length; q++) {
            var $ = u.points[q][O] - this.min[O];
            k = Math.min(k, $), R = Math.max(R, $);
          }
          if (R < 0 || k > this.max[O] - this.min[O])
            return 0;
        }
        return 1;
      };
      var bs = function(u, f, c, d) {
        if (u === void 0 && (u = 0), f === void 0 && (f = 0), c === void 0 && (c = 0), d === void 0 && (d = 0), isNaN(u) || u < 0 || isNaN(f) || f < 0 || isNaN(c) || c < 0 || isNaN(d) || d < 0)
          throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
        this.top = u, this.bottom = f, this.left = c, this.right = d;
      };
      bs.prototype.interpolate = function(u, f, c) {
        return f.top != null && u.top != null && (this.top = o.number(u.top, f.top, c)), f.bottom != null && u.bottom != null && (this.bottom = o.number(u.bottom, f.bottom, c)), f.left != null && u.left != null && (this.left = o.number(u.left, f.left, c)), f.right != null && u.right != null && (this.right = o.number(u.right, f.right, c)), this;
      }, bs.prototype.getCenter = function(u, f) {
        var c = o.clamp((this.left + u - this.right) / 2, 0, u), d = o.clamp((this.top + f - this.bottom) / 2, 0, f);
        return new o.Point(c, d);
      }, bs.prototype.equals = function(u) {
        return this.top === u.top && this.bottom === u.bottom && this.left === u.left && this.right === u.right;
      }, bs.prototype.clone = function() {
        return new bs(this.top, this.bottom, this.left, this.right);
      }, bs.prototype.toJSON = function() {
        return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
      };
      var xr = function(u, f, c, d, _) {
        this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = _ === void 0 || _, this._minZoom = u || 0, this._maxZoom = f || 22, this._minPitch = c == null ? 0 : c, this._maxPitch = d == null ? 60 : d, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new o.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new bs(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
      }, en = { minZoom: { configurable: !0 }, maxZoom: { configurable: !0 }, minPitch: { configurable: !0 }, maxPitch: { configurable: !0 }, renderWorldCopies: { configurable: !0 }, worldSize: { configurable: !0 }, centerOffset: { configurable: !0 }, size: { configurable: !0 }, bearing: { configurable: !0 }, pitch: { configurable: !0 }, fov: { configurable: !0 }, zoom: { configurable: !0 }, center: { configurable: !0 }, padding: { configurable: !0 }, centerPoint: { configurable: !0 }, unmodified: { configurable: !0 }, point: { configurable: !0 } };
      xr.prototype.clone = function() {
        var u = new xr(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
        return u.tileSize = this.tileSize, u.latRange = this.latRange, u.width = this.width, u.height = this.height, u._center = this._center, u.zoom = this.zoom, u.angle = this.angle, u._fov = this._fov, u._pitch = this._pitch, u._unmodified = this._unmodified, u._edgeInsets = this._edgeInsets.clone(), u._calcMatrices(), u;
      }, en.minZoom.get = function() {
        return this._minZoom;
      }, en.minZoom.set = function(u) {
        this._minZoom !== u && (this._minZoom = u, this.zoom = Math.max(this.zoom, u));
      }, en.maxZoom.get = function() {
        return this._maxZoom;
      }, en.maxZoom.set = function(u) {
        this._maxZoom !== u && (this._maxZoom = u, this.zoom = Math.min(this.zoom, u));
      }, en.minPitch.get = function() {
        return this._minPitch;
      }, en.minPitch.set = function(u) {
        this._minPitch !== u && (this._minPitch = u, this.pitch = Math.max(this.pitch, u));
      }, en.maxPitch.get = function() {
        return this._maxPitch;
      }, en.maxPitch.set = function(u) {
        this._maxPitch !== u && (this._maxPitch = u, this.pitch = Math.min(this.pitch, u));
      }, en.renderWorldCopies.get = function() {
        return this._renderWorldCopies;
      }, en.renderWorldCopies.set = function(u) {
        u === void 0 ? u = !0 : u === null && (u = !1), this._renderWorldCopies = u;
      }, en.worldSize.get = function() {
        return this.tileSize * this.scale;
      }, en.centerOffset.get = function() {
        return this.centerPoint._sub(this.size._div(2));
      }, en.size.get = function() {
        return new o.Point(this.width, this.height);
      }, en.bearing.get = function() {
        return -this.angle / Math.PI * 180;
      }, en.bearing.set = function(u) {
        var f = -o.wrap(u, -180, 180) * Math.PI / 180;
        this.angle !== f && (this._unmodified = !1, this.angle = f, this._calcMatrices(), this.rotationMatrix = o.create$2(), o.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
      }, en.pitch.get = function() {
        return this._pitch / Math.PI * 180;
      }, en.pitch.set = function(u) {
        var f = o.clamp(u, this.minPitch, this.maxPitch) / 180 * Math.PI;
        this._pitch !== f && (this._unmodified = !1, this._pitch = f, this._calcMatrices());
      }, en.fov.get = function() {
        return this._fov / Math.PI * 180;
      }, en.fov.set = function(u) {
        u = Math.max(0.01, Math.min(60, u)), this._fov !== u && (this._unmodified = !1, this._fov = u / 180 * Math.PI, this._calcMatrices());
      }, en.zoom.get = function() {
        return this._zoom;
      }, en.zoom.set = function(u) {
        var f = Math.min(Math.max(u, this.minZoom), this.maxZoom);
        this._zoom !== f && (this._unmodified = !1, this._zoom = f, this.scale = this.zoomScale(f), this.tileZoom = Math.floor(f), this.zoomFraction = f - this.tileZoom, this._constrain(), this._calcMatrices());
      }, en.center.get = function() {
        return this._center;
      }, en.center.set = function(u) {
        u.lat === this._center.lat && u.lng === this._center.lng || (this._unmodified = !1, this._center = u, this._constrain(), this._calcMatrices());
      }, en.padding.get = function() {
        return this._edgeInsets.toJSON();
      }, en.padding.set = function(u) {
        this._edgeInsets.equals(u) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, u, 1), this._calcMatrices());
      }, en.centerPoint.get = function() {
        return this._edgeInsets.getCenter(this.width, this.height);
      }, xr.prototype.isPaddingEqual = function(u) {
        return this._edgeInsets.equals(u);
      }, xr.prototype.interpolatePadding = function(u, f, c) {
        this._unmodified = !1, this._edgeInsets.interpolate(u, f, c), this._constrain(), this._calcMatrices();
      }, xr.prototype.coveringZoomLevel = function(u) {
        var f = (u.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / u.tileSize));
        return Math.max(0, f);
      }, xr.prototype.getVisibleUnwrappedCoordinates = function(u) {
        var f = [new o.UnwrappedTileID(0, u)];
        if (this._renderWorldCopies)
          for (var c = this.pointCoordinate(new o.Point(0, 0)), d = this.pointCoordinate(new o.Point(this.width, 0)), _ = this.pointCoordinate(new o.Point(this.width, this.height)), w = this.pointCoordinate(new o.Point(0, this.height)), E = Math.floor(Math.min(c.x, d.x, _.x, w.x)), O = Math.floor(Math.max(c.x, d.x, _.x, w.x)), k = E - 1; k <= O + 1; k++)
            k !== 0 && f.push(new o.UnwrappedTileID(k, u));
        return f;
      }, xr.prototype.coveringTiles = function(u) {
        var f = this.coveringZoomLevel(u), c = f;
        if (u.minzoom !== void 0 && f < u.minzoom)
          return [];
        u.maxzoom !== void 0 && f > u.maxzoom && (f = u.maxzoom);
        var d = o.MercatorCoordinate.fromLngLat(this.center), _ = Math.pow(2, f), w = [_ * d.x, _ * d.y, 0], E = yh.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, f), O = u.minzoom || 0;
        this.pitch <= 60 && this._edgeInsets.top < 0.1 && (O = f);
        var k = function(tt) {
          return { aabb: new yl([tt * _, 0, 0], [(tt + 1) * _, _, 0]), zoom: 0, x: 0, y: 0, wrap: tt, fullyVisible: !1 };
        }, R = [], q = [], $ = f, H = u.reparseOverscaled ? c : f;
        if (this._renderWorldCopies)
          for (var ne = 1; ne <= 3; ne++)
            R.push(k(-ne)), R.push(k(ne));
        for (R.push(k(0)); R.length > 0; ) {
          var re = R.pop(), ue = re.x, J = re.y, le = re.fullyVisible;
          if (!le) {
            var me = re.aabb.intersects(E);
            if (me === 0)
              continue;
            le = me === 2;
          }
          var _e = re.aabb.distanceX(w), Ae = re.aabb.distanceY(w), Me = Math.max(Math.abs(_e), Math.abs(Ae));
          if (re.zoom === $ || Me > 3 + (1 << $ - re.zoom) - 2 && re.zoom >= O)
            q.push({ tileID: new o.OverscaledTileID(re.zoom === $ ? H : re.zoom, re.wrap, re.zoom, ue, J), distanceSq: o.sqrLen([w[0] - 0.5 - ue, w[1] - 0.5 - J]) });
          else
            for (var ke = 0; ke < 4; ke++) {
              var je = (ue << 1) + ke % 2, nt = (J << 1) + (ke >> 1);
              R.push({ aabb: re.aabb.quadrant(ke), zoom: re.zoom + 1, x: je, y: nt, wrap: re.wrap, fullyVisible: le });
            }
        }
        return q.sort(function(tt, gt) {
          return tt.distanceSq - gt.distanceSq;
        }).map(function(tt) {
          return tt.tileID;
        });
      }, xr.prototype.resize = function(u, f) {
        this.width = u, this.height = f, this.pixelsToGLUnits = [2 / u, -2 / f], this._constrain(), this._calcMatrices();
      }, en.unmodified.get = function() {
        return this._unmodified;
      }, xr.prototype.zoomScale = function(u) {
        return Math.pow(2, u);
      }, xr.prototype.scaleZoom = function(u) {
        return Math.log(u) / Math.LN2;
      }, xr.prototype.project = function(u) {
        var f = o.clamp(u.lat, -this.maxValidLatitude, this.maxValidLatitude);
        return new o.Point(o.mercatorXfromLng(u.lng) * this.worldSize, o.mercatorYfromLat(f) * this.worldSize);
      }, xr.prototype.unproject = function(u) {
        return new o.MercatorCoordinate(u.x / this.worldSize, u.y / this.worldSize).toLngLat();
      }, en.point.get = function() {
        return this.project(this.center);
      }, xr.prototype.setLocationAtPoint = function(u, f) {
        var c = this.pointCoordinate(f), d = this.pointCoordinate(this.centerPoint), _ = this.locationCoordinate(u), w = new o.MercatorCoordinate(_.x - (c.x - d.x), _.y - (c.y - d.y));
        this.center = this.coordinateLocation(w), this._renderWorldCopies && (this.center = this.center.wrap());
      }, xr.prototype.locationPoint = function(u) {
        return this.coordinatePoint(this.locationCoordinate(u));
      }, xr.prototype.pointLocation = function(u) {
        return this.coordinateLocation(this.pointCoordinate(u));
      }, xr.prototype.locationCoordinate = function(u) {
        return o.MercatorCoordinate.fromLngLat(u);
      }, xr.prototype.coordinateLocation = function(u) {
        return u.toLngLat();
      }, xr.prototype.pointCoordinate = function(u) {
        var f = [u.x, u.y, 0, 1], c = [u.x, u.y, 1, 1];
        o.transformMat4(f, f, this.pixelMatrixInverse), o.transformMat4(c, c, this.pixelMatrixInverse);
        var d = f[3], _ = c[3], w = f[1] / d, E = c[1] / _, O = f[2] / d, k = c[2] / _, R = O === k ? 0 : (0 - O) / (k - O);
        return new o.MercatorCoordinate(o.number(f[0] / d, c[0] / _, R) / this.worldSize, o.number(w, E, R) / this.worldSize);
      }, xr.prototype.coordinatePoint = function(u) {
        var f = [u.x * this.worldSize, u.y * this.worldSize, 0, 1];
        return o.transformMat4(f, f, this.pixelMatrix), new o.Point(f[0] / f[3], f[1] / f[3]);
      }, xr.prototype.getBounds = function() {
        return new o.LngLatBounds().extend(this.pointLocation(new o.Point(0, 0))).extend(this.pointLocation(new o.Point(this.width, 0))).extend(this.pointLocation(new o.Point(this.width, this.height))).extend(this.pointLocation(new o.Point(0, this.height)));
      }, xr.prototype.getMaxBounds = function() {
        return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new o.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
      }, xr.prototype.setMaxBounds = function(u) {
        u ? (this.lngRange = [u.getWest(), u.getEast()], this.latRange = [u.getSouth(), u.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
      }, xr.prototype.calculatePosMatrix = function(u, f) {
        f === void 0 && (f = !1);
        var c = u.key, d = f ? this._alignedPosMatrixCache : this._posMatrixCache;
        if (d[c])
          return d[c];
        var _ = u.canonical, w = this.worldSize / this.zoomScale(_.z), E = _.x + Math.pow(2, _.z) * u.wrap, O = o.identity(new Float64Array(16));
        return o.translate(O, O, [E * w, _.y * w, 0]), o.scale(O, O, [w / o.EXTENT, w / o.EXTENT, 1]), o.multiply(O, f ? this.alignedProjMatrix : this.projMatrix, O), d[c] = new Float32Array(O), d[c];
      }, xr.prototype.customLayerMatrix = function() {
        return this.mercatorMatrix.slice();
      }, xr.prototype._constrain = function() {
        if (this.center && this.width && this.height && !this._constraining) {
          this._constraining = !0;
          var u, f, c, d, _ = -90, w = 90, E = -180, O = 180, k = this.size, R = this._unmodified;
          if (this.latRange) {
            var q = this.latRange;
            _ = o.mercatorYfromLat(q[1]) * this.worldSize, u = (w = o.mercatorYfromLat(q[0]) * this.worldSize) - _ < k.y ? k.y / (w - _) : 0;
          }
          if (this.lngRange) {
            var $ = this.lngRange;
            E = o.mercatorXfromLng($[0]) * this.worldSize, f = (O = o.mercatorXfromLng($[1]) * this.worldSize) - E < k.x ? k.x / (O - E) : 0;
          }
          var H = this.point, ne = Math.max(f || 0, u || 0);
          if (ne)
            return this.center = this.unproject(new o.Point(f ? (O + E) / 2 : H.x, u ? (w + _) / 2 : H.y)), this.zoom += this.scaleZoom(ne), this._unmodified = R, void (this._constraining = !1);
          if (this.latRange) {
            var re = H.y, ue = k.y / 2;
            re - ue < _ && (d = _ + ue), re + ue > w && (d = w - ue);
          }
          if (this.lngRange) {
            var J = H.x, le = k.x / 2;
            J - le < E && (c = E + le), J + le > O && (c = O - le);
          }
          c === void 0 && d === void 0 || (this.center = this.unproject(new o.Point(c !== void 0 ? c : H.x, d !== void 0 ? d : H.y))), this._unmodified = R, this._constraining = !1;
        }
      }, xr.prototype._calcMatrices = function() {
        if (this.height) {
          var u = this.centerOffset;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
          var f = Math.PI / 2 + this._pitch, c = this._fov * (0.5 + u.y / this.height), d = Math.sin(c) * this.cameraToCenterDistance / Math.sin(o.clamp(Math.PI - f - c, 0.01, Math.PI - 0.01)), _ = this.point, w = _.x, E = _.y, O = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * d + this.cameraToCenterDistance), k = this.height / 50, R = new Float64Array(16);
          o.perspective(R, this._fov, this.width / this.height, k, O), R[8] = 2 * -u.x / this.width, R[9] = 2 * u.y / this.height, o.scale(R, R, [1, -1, 1]), o.translate(R, R, [0, 0, -this.cameraToCenterDistance]), o.rotateX(R, R, this._pitch), o.rotateZ(R, R, this.angle), o.translate(R, R, [-w, -E, 0]), this.mercatorMatrix = o.scale([], R, [this.worldSize, this.worldSize, this.worldSize]), o.scale(R, R, [1, 1, o.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = R, this.invProjMatrix = o.invert([], this.projMatrix);
          var q = this.width % 2 / 2, $ = this.height % 2 / 2, H = Math.cos(this.angle), ne = Math.sin(this.angle), re = w - Math.round(w) + H * q + ne * $, ue = E - Math.round(E) + H * $ + ne * q, J = new Float64Array(R);
          if (o.translate(J, J, [re > 0.5 ? re - 1 : re, ue > 0.5 ? ue - 1 : ue, 0]), this.alignedProjMatrix = J, R = o.create(), o.scale(R, R, [this.width / 2, -this.height / 2, 1]), o.translate(R, R, [1, -1, 0]), this.labelPlaneMatrix = R, R = o.create(), o.scale(R, R, [1, -1, 1]), o.translate(R, R, [-1, -1, 0]), o.scale(R, R, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = R, this.pixelMatrix = o.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(R = o.invert(new Float64Array(16), this.pixelMatrix)))
            throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = R, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }
      }, xr.prototype.maxPitchScaleFactor = function() {
        if (!this.pixelMatrixInverse)
          return 1;
        var u = this.pointCoordinate(new o.Point(0, 0)), f = [u.x * this.worldSize, u.y * this.worldSize, 0, 1];
        return o.transformMat4(f, f, this.pixelMatrix)[3] / this.cameraToCenterDistance;
      }, xr.prototype.getCameraPoint = function() {
        var u = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
        return this.centerPoint.add(new o.Point(0, u));
      }, xr.prototype.getCameraQueryGeometry = function(u) {
        var f = this.getCameraPoint();
        if (u.length === 1)
          return [u[0], f];
        for (var c = f.x, d = f.y, _ = f.x, w = f.y, E = 0, O = u; E < O.length; E += 1) {
          var k = O[E];
          c = Math.min(c, k.x), d = Math.min(d, k.y), _ = Math.max(_, k.x), w = Math.max(w, k.y);
        }
        return [new o.Point(c, d), new o.Point(_, d), new o.Point(_, w), new o.Point(c, w), new o.Point(c, d)];
      }, Object.defineProperties(xr.prototype, en);
      var Mo = function(u) {
        var f, c, d, _;
        this._hashName = u && encodeURIComponent(u), o.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (f = this._updateHashUnthrottled.bind(this), c = !1, d = null, _ = function() {
          d = null, c && (f(), d = setTimeout(_, 300), c = !1);
        }, function() {
          return c = !0, d || _(), d;
        });
      };
      Mo.prototype.addTo = function(u) {
        return this._map = u, o.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
      }, Mo.prototype.remove = function() {
        return o.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
      }, Mo.prototype.getHashString = function(u) {
        var f = this._map.getCenter(), c = Math.round(100 * this._map.getZoom()) / 100, d = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), _ = Math.pow(10, d), w = Math.round(f.lng * _) / _, E = Math.round(f.lat * _) / _, O = this._map.getBearing(), k = this._map.getPitch(), R = "";
        if (R += u ? "/" + w + "/" + E + "/" + c : c + "/" + E + "/" + w, (O || k) && (R += "/" + Math.round(10 * O) / 10), k && (R += "/" + Math.round(k)), this._hashName) {
          var q = this._hashName, $ = !1, H = o.window.location.hash.slice(1).split("&").map(function(ne) {
            var re = ne.split("=")[0];
            return re === q ? ($ = !0, re + "=" + R) : ne;
          }).filter(function(ne) {
            return ne;
          });
          return $ || H.push(q + "=" + R), "#" + H.join("&");
        }
        return "#" + R;
      }, Mo.prototype._getCurrentHash = function() {
        var u, f = this, c = o.window.location.hash.replace("#", "");
        return this._hashName ? (c.split("&").map(function(d) {
          return d.split("=");
        }).forEach(function(d) {
          d[0] === f._hashName && (u = d);
        }), (u && u[1] || "").split("/")) : c.split("/");
      }, Mo.prototype._onHashChange = function() {
        var u = this._getCurrentHash();
        if (u.length >= 3 && !u.some(function(c) {
          return isNaN(c);
        })) {
          var f = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(u[3] || 0) : this._map.getBearing();
          return this._map.jumpTo({ center: [+u[2], +u[1]], zoom: +u[0], bearing: f, pitch: +(u[4] || 0) }), !0;
        }
        return !1;
      }, Mo.prototype._updateHashUnthrottled = function() {
        var u = o.window.location.href.replace(/(#.+)?$/, this.getHashString());
        try {
          o.window.history.replaceState(o.window.history.state, null, u);
        } catch {
        }
      };
      var rc = { linearity: 0.3, easing: o.bezier(0, 0, 0.3, 1) }, Ql = o.extend({ deceleration: 2500, maxSpeed: 1400 }, rc), nc = o.extend({ deceleration: 20, maxSpeed: 1400 }, rc), Hv = o.extend({ deceleration: 1e3, maxSpeed: 360 }, rc), Zv = o.extend({ deceleration: 1e3, maxSpeed: 90 }, rc), ic = function(u) {
        this._map = u, this.clear();
      };
      function oc(u, f) {
        (!u.duration || u.duration < f.duration) && (u.duration = f.duration, u.easing = f.easing);
      }
      function Ua(u, f, c) {
        var d = c.maxSpeed, _ = c.linearity, w = c.deceleration, E = o.clamp(u * _ / (f / 1e3), -d, d), O = Math.abs(E) / (w * _);
        return { easing: c.easing, duration: 1e3 * O, amount: E * (O / 2) };
      }
      ic.prototype.clear = function() {
        this._inertiaBuffer = [];
      }, ic.prototype.record = function(u) {
        this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: o.browser.now(), settings: u });
      }, ic.prototype._drainInertiaBuffer = function() {
        for (var u = this._inertiaBuffer, f = o.browser.now(); u.length > 0 && f - u[0].time > 160; )
          u.shift();
      }, ic.prototype._onMoveEnd = function(u) {
        if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {
          for (var f = { zoom: 0, bearing: 0, pitch: 0, pan: new o.Point(0, 0), pinchAround: void 0, around: void 0 }, c = 0, d = this._inertiaBuffer; c < d.length; c += 1) {
            var _ = d[c].settings;
            f.zoom += _.zoomDelta || 0, f.bearing += _.bearingDelta || 0, f.pitch += _.pitchDelta || 0, _.panDelta && f.pan._add(_.panDelta), _.around && (f.around = _.around), _.pinchAround && (f.pinchAround = _.pinchAround);
          }
          var w = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, E = {};
          if (f.pan.mag()) {
            var O = Ua(f.pan.mag(), w, o.extend({}, Ql, u || {}));
            E.offset = f.pan.mult(O.amount / f.pan.mag()), E.center = this._map.transform.center, oc(E, O);
          }
          if (f.zoom) {
            var k = Ua(f.zoom, w, nc);
            E.zoom = this._map.transform.zoom + k.amount, oc(E, k);
          }
          if (f.bearing) {
            var R = Ua(f.bearing, w, Hv);
            E.bearing = this._map.transform.bearing + o.clamp(R.amount, -179, 179), oc(E, R);
          }
          if (f.pitch) {
            var q = Ua(f.pitch, w, Zv);
            E.pitch = this._map.transform.pitch + q.amount, oc(E, q);
          }
          if (E.zoom || E.bearing) {
            var $ = f.pinchAround === void 0 ? f.around : f.pinchAround;
            E.around = $ ? this._map.unproject($) : this._map.getCenter();
          }
          return this.clear(), o.extend(E, { noMoveStart: !0 });
        }
      };
      var Jn = function(u) {
        function f(d, _, w, E) {
          E === void 0 && (E = {});
          var O = g.mousePos(_.getCanvasContainer(), w), k = _.unproject(O);
          u.call(this, d, o.extend({ point: O, lngLat: k, originalEvent: w }, E)), this._defaultPrevented = !1, this.target = _;
        }
        u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f;
        var c = { defaultPrevented: { configurable: !0 } };
        return f.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(f.prototype, c), f;
      }(o.Event), ac = function(u) {
        function f(d, _, w) {
          var E = d === "touchend" ? w.changedTouches : w.touches, O = g.touchPos(_.getCanvasContainer(), E), k = O.map(function($) {
            return _.unproject($);
          }), R = O.reduce(function($, H, ne, re) {
            return $.add(H.div(re.length));
          }, new o.Point(0, 0)), q = _.unproject(R);
          u.call(this, d, { points: O, point: R, lngLats: k, lngLat: q, originalEvent: w }), this._defaultPrevented = !1;
        }
        u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f;
        var c = { defaultPrevented: { configurable: !0 } };
        return f.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(f.prototype, c), f;
      }(o.Event), km = function(u) {
        function f(d, _, w) {
          u.call(this, d, { originalEvent: w }), this._defaultPrevented = !1;
        }
        u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f;
        var c = { defaultPrevented: { configurable: !0 } };
        return f.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(f.prototype, c), f;
      }(o.Event), Gn = function(u, f) {
        this._map = u, this._clickTolerance = f.clickTolerance;
      };
      Gn.prototype.reset = function() {
        delete this._mousedownPos;
      }, Gn.prototype.wheel = function(u) {
        return this._firePreventable(new km(u.type, this._map, u));
      }, Gn.prototype.mousedown = function(u, f) {
        return this._mousedownPos = f, this._firePreventable(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseup = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.click = function(u, f) {
        this._mousedownPos && this._mousedownPos.dist(f) >= this._clickTolerance || this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.dblclick = function(u) {
        return this._firePreventable(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseover = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseout = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.touchstart = function(u) {
        return this._firePreventable(new ac(u.type, this._map, u));
      }, Gn.prototype.touchmove = function(u) {
        this._map.fire(new ac(u.type, this._map, u));
      }, Gn.prototype.touchend = function(u) {
        this._map.fire(new ac(u.type, this._map, u));
      }, Gn.prototype.touchcancel = function(u) {
        this._map.fire(new ac(u.type, this._map, u));
      }, Gn.prototype._firePreventable = function(u) {
        if (this._map.fire(u), u.defaultPrevented)
          return {};
      }, Gn.prototype.isEnabled = function() {
        return !0;
      }, Gn.prototype.isActive = function() {
        return !1;
      }, Gn.prototype.enable = function() {
      }, Gn.prototype.disable = function() {
      };
      var wt = function(u) {
        this._map = u;
      };
      wt.prototype.reset = function() {
        this._delayContextMenu = !1, delete this._contextMenuEvent;
      }, wt.prototype.mousemove = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, wt.prototype.mousedown = function() {
        this._delayContextMenu = !0;
      }, wt.prototype.mouseup = function() {
        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Jn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
      }, wt.prototype.contextmenu = function(u) {
        this._delayContextMenu ? this._contextMenuEvent = u : this._map.fire(new Jn(u.type, this._map, u)), this._map.listens("contextmenu") && u.preventDefault();
      }, wt.prototype.isEnabled = function() {
        return !0;
      }, wt.prototype.isActive = function() {
        return !1;
      }, wt.prototype.enable = function() {
      }, wt.prototype.disable = function() {
      };
      var uo = function(u, f) {
        this._map = u, this._el = u.getCanvasContainer(), this._container = u.getContainer(), this._clickTolerance = f.clickTolerance || 1;
      };
      function gh(u, f) {
        for (var c = {}, d = 0; d < u.length; d++)
          c[u[d].identifier] = f[d];
        return c;
      }
      uo.prototype.isEnabled = function() {
        return !!this._enabled;
      }, uo.prototype.isActive = function() {
        return !!this._active;
      }, uo.prototype.enable = function() {
        this.isEnabled() || (this._enabled = !0);
      }, uo.prototype.disable = function() {
        this.isEnabled() && (this._enabled = !1);
      }, uo.prototype.mousedown = function(u, f) {
        this.isEnabled() && u.shiftKey && u.button === 0 && (g.disableDrag(), this._startPos = this._lastPos = f, this._active = !0);
      }, uo.prototype.mousemoveWindow = function(u, f) {
        if (this._active) {
          var c = f;
          if (!(this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance)) {
            var d = this._startPos;
            this._lastPos = c, this._box || (this._box = g.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", u));
            var _ = Math.min(d.x, c.x), w = Math.max(d.x, c.x), E = Math.min(d.y, c.y), O = Math.max(d.y, c.y);
            g.setTransform(this._box, "translate(" + _ + "px," + E + "px)"), this._box.style.width = w - _ + "px", this._box.style.height = O - E + "px";
          }
        }
      }, uo.prototype.mouseupWindow = function(u, f) {
        var c = this;
        if (this._active && u.button === 0) {
          var d = this._startPos, _ = f;
          if (this.reset(), g.suppressClick(), d.x !== _.x || d.y !== _.y)
            return this._map.fire(new o.Event("boxzoomend", { originalEvent: u })), { cameraAnimation: function(w) {
              return w.fitScreenCoordinates(d, _, c._map.getBearing(), { linear: !0 });
            } };
          this._fireEvent("boxzoomcancel", u);
        }
      }, uo.prototype.keydown = function(u) {
        this._active && u.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", u));
      }, uo.prototype.blur = function() {
        this.reset();
      }, uo.prototype.reset = function() {
        this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (g.remove(this._box), this._box = null), g.enableDrag(), delete this._startPos, delete this._lastPos;
      }, uo.prototype._fireEvent = function(u, f) {
        return this._map.fire(new o.Event(u, { originalEvent: f }));
      };
      var eu = function(u) {
        this.reset(), this.numTouches = u.numTouches;
      };
      eu.prototype.reset = function() {
        delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
      }, eu.prototype.touchstart = function(u, f, c) {
        (this.centroid || c.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = u.timeStamp), c.length === this.numTouches && (this.centroid = function(d) {
          for (var _ = new o.Point(0, 0), w = 0, E = d; w < E.length; w += 1)
            _._add(E[w]);
          return _.div(d.length);
        }(f), this.touches = gh(c, f)));
      }, eu.prototype.touchmove = function(u, f, c) {
        if (!this.aborted && this.centroid) {
          var d = gh(c, f);
          for (var _ in this.touches) {
            var w = d[_];
            (!w || w.dist(this.touches[_]) > 30) && (this.aborted = !0);
          }
        }
      }, eu.prototype.touchend = function(u, f, c) {
        if ((!this.centroid || u.timeStamp - this.startTime > 500) && (this.aborted = !0), c.length === 0) {
          var d = !this.aborted && this.centroid;
          if (this.reset(), d)
            return d;
        }
      };
      var aa = function(u) {
        this.singleTap = new eu(u), this.numTaps = u.numTaps, this.reset();
      };
      aa.prototype.reset = function() {
        this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
      }, aa.prototype.touchstart = function(u, f, c) {
        this.singleTap.touchstart(u, f, c);
      }, aa.prototype.touchmove = function(u, f, c) {
        this.singleTap.touchmove(u, f, c);
      }, aa.prototype.touchend = function(u, f, c) {
        var d = this.singleTap.touchend(u, f, c);
        if (d) {
          var _ = u.timeStamp - this.lastTime < 500, w = !this.lastTap || this.lastTap.dist(d) < 30;
          if (_ && w || this.reset(), this.count++, this.lastTime = u.timeStamp, this.lastTap = d, this.count === this.numTaps)
            return this.reset(), d;
        }
      };
      var co = function() {
        this._zoomIn = new aa({ numTouches: 1, numTaps: 2 }), this._zoomOut = new aa({ numTouches: 2, numTaps: 1 }), this.reset();
      };
      co.prototype.reset = function() {
        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
      }, co.prototype.touchstart = function(u, f, c) {
        this._zoomIn.touchstart(u, f, c), this._zoomOut.touchstart(u, f, c);
      }, co.prototype.touchmove = function(u, f, c) {
        this._zoomIn.touchmove(u, f, c), this._zoomOut.touchmove(u, f, c);
      }, co.prototype.touchend = function(u, f, c) {
        var d = this, _ = this._zoomIn.touchend(u, f, c), w = this._zoomOut.touchend(u, f, c);
        return _ ? (this._active = !0, u.preventDefault(), setTimeout(function() {
          return d.reset();
        }, 0), { cameraAnimation: function(E) {
          return E.easeTo({ duration: 300, zoom: E.getZoom() + 1, around: E.unproject(_) }, { originalEvent: u });
        } }) : w ? (this._active = !0, u.preventDefault(), setTimeout(function() {
          return d.reset();
        }, 0), { cameraAnimation: function(E) {
          return E.easeTo({ duration: 300, zoom: E.getZoom() - 1, around: E.unproject(w) }, { originalEvent: u });
        } }) : void 0;
      }, co.prototype.touchcancel = function() {
        this.reset();
      }, co.prototype.enable = function() {
        this._enabled = !0;
      }, co.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, co.prototype.isEnabled = function() {
        return this._enabled;
      }, co.prototype.isActive = function() {
        return this._active;
      };
      var ip = { 0: 1, 2: 2 }, ct = function(u) {
        this.reset(), this._clickTolerance = u.clickTolerance || 1;
      };
      ct.prototype.blur = function() {
        this.reset();
      }, ct.prototype.reset = function() {
        this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;
      }, ct.prototype._correctButton = function(u, f) {
        return !1;
      }, ct.prototype._move = function(u, f) {
        return {};
      }, ct.prototype.mousedown = function(u, f) {
        if (!this._lastPoint) {
          var c = g.mouseButton(u);
          this._correctButton(u, c) && (this._lastPoint = f, this._eventButton = c);
        }
      }, ct.prototype.mousemoveWindow = function(u, f) {
        var c = this._lastPoint;
        if (c) {
          if (u.preventDefault(), function(d, _) {
            var w = ip[_];
            return d.buttons === void 0 || (d.buttons & w) !== w;
          }(u, this._eventButton))
            this.reset();
          else if (this._moved || !(f.dist(c) < this._clickTolerance))
            return this._moved = !0, this._lastPoint = f, this._move(c, f);
        }
      }, ct.prototype.mouseupWindow = function(u) {
        this._lastPoint && g.mouseButton(u) === this._eventButton && (this._moved && g.suppressClick(), this.reset());
      }, ct.prototype.enable = function() {
        this._enabled = !0;
      }, ct.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, ct.prototype.isEnabled = function() {
        return this._enabled;
      }, ct.prototype.isActive = function() {
        return this._active;
      };
      var op = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.mousedown = function(c, d) {
          u.prototype.mousedown.call(this, c, d), this._lastPoint && (this._active = !0);
        }, f.prototype._correctButton = function(c, d) {
          return d === 0 && !c.ctrlKey;
        }, f.prototype._move = function(c, d) {
          return { around: d, panDelta: d.sub(c) };
        }, f;
      }(ct), vh = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype._correctButton = function(c, d) {
          return d === 0 && c.ctrlKey || d === 2;
        }, f.prototype._move = function(c, d) {
          var _ = 0.8 * (d.x - c.x);
          if (_)
            return this._active = !0, { bearingDelta: _ };
        }, f.prototype.contextmenu = function(c) {
          c.preventDefault();
        }, f;
      }(ct), ap = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype._correctButton = function(c, d) {
          return d === 0 && c.ctrlKey || d === 2;
        }, f.prototype._move = function(c, d) {
          var _ = -0.5 * (d.y - c.y);
          if (_)
            return this._active = !0, { pitchDelta: _ };
        }, f.prototype.contextmenu = function(c) {
          c.preventDefault();
        }, f;
      }(ct), $o = function(u) {
        this._minTouches = 1, this._clickTolerance = u.clickTolerance || 1, this.reset();
      };
      $o.prototype.reset = function() {
        this._active = !1, this._touches = {}, this._sum = new o.Point(0, 0);
      }, $o.prototype.touchstart = function(u, f, c) {
        return this._calculateTransform(u, f, c);
      }, $o.prototype.touchmove = function(u, f, c) {
        if (this._active && !(c.length < this._minTouches))
          return u.preventDefault(), this._calculateTransform(u, f, c);
      }, $o.prototype.touchend = function(u, f, c) {
        this._calculateTransform(u, f, c), this._active && c.length < this._minTouches && this.reset();
      }, $o.prototype.touchcancel = function() {
        this.reset();
      }, $o.prototype._calculateTransform = function(u, f, c) {
        c.length > 0 && (this._active = !0);
        var d = gh(c, f), _ = new o.Point(0, 0), w = new o.Point(0, 0), E = 0;
        for (var O in d) {
          var k = d[O], R = this._touches[O];
          R && (_._add(k), w._add(k.sub(R)), E++, d[O] = k);
        }
        if (this._touches = d, !(E < this._minTouches) && w.mag()) {
          var q = w.div(E);
          if (this._sum._add(q), !(this._sum.mag() < this._clickTolerance))
            return { around: _.div(E), panDelta: q };
        }
      }, $o.prototype.enable = function() {
        this._enabled = !0;
      }, $o.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, $o.prototype.isEnabled = function() {
        return this._enabled;
      }, $o.prototype.isActive = function() {
        return this._active;
      };
      var ho = function() {
        this.reset();
      };
      function _h(u, f, c) {
        for (var d = 0; d < u.length; d++)
          if (u[d].identifier === c)
            return f[d];
      }
      function xh(u, f) {
        return Math.log(u / f) / Math.LN2;
      }
      ho.prototype.reset = function() {
        this._active = !1, delete this._firstTwoTouches;
      }, ho.prototype._start = function(u) {
      }, ho.prototype._move = function(u, f, c) {
        return {};
      }, ho.prototype.touchstart = function(u, f, c) {
        this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([f[0], f[1]]));
      }, ho.prototype.touchmove = function(u, f, c) {
        if (this._firstTwoTouches) {
          u.preventDefault();
          var d = this._firstTwoTouches, _ = d[1], w = _h(c, f, d[0]), E = _h(c, f, _);
          if (w && E) {
            var O = this._aroundCenter ? null : w.add(E).div(2);
            return this._move([w, E], O, u);
          }
        }
      }, ho.prototype.touchend = function(u, f, c) {
        if (this._firstTwoTouches) {
          var d = this._firstTwoTouches, _ = d[1], w = _h(c, f, d[0]), E = _h(c, f, _);
          w && E || (this._active && g.suppressClick(), this.reset());
        }
      }, ho.prototype.touchcancel = function() {
        this.reset();
      }, ho.prototype.enable = function(u) {
        this._enabled = !0, this._aroundCenter = !!u && u.around === "center";
      }, ho.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, ho.prototype.isEnabled = function() {
        return this._enabled;
      }, ho.prototype.isActive = function() {
        return this._active;
      };
      var fo = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.reset = function() {
          u.prototype.reset.call(this), delete this._distance, delete this._startDistance;
        }, f.prototype._start = function(c) {
          this._startDistance = this._distance = c[0].dist(c[1]);
        }, f.prototype._move = function(c, d) {
          var _ = this._distance;
          if (this._distance = c[0].dist(c[1]), this._active || !(Math.abs(xh(this._distance, this._startDistance)) < 0.1))
            return this._active = !0, { zoomDelta: xh(this._distance, _), pinchAround: d };
        }, f;
      }(ho);
      function ja(u, f) {
        return 180 * u.angleWith(f) / Math.PI;
      }
      var Lm = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.reset = function() {
          u.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector;
        }, f.prototype._start = function(c) {
          this._startVector = this._vector = c[0].sub(c[1]), this._minDiameter = c[0].dist(c[1]);
        }, f.prototype._move = function(c, d) {
          var _ = this._vector;
          if (this._vector = c[0].sub(c[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = !0, { bearingDelta: ja(this._vector, _), pinchAround: d };
        }, f.prototype._isBelowThreshold = function(c) {
          this._minDiameter = Math.min(this._minDiameter, c.mag());
          var d = 25 / (Math.PI * this._minDiameter) * 360, _ = ja(c, this._startVector);
          return Math.abs(_) < d;
        }, f;
      }(ho);
      function sc(u) {
        return Math.abs(u.y) > Math.abs(u.x);
      }
      var sp = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.reset = function() {
          u.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }, f.prototype._start = function(c) {
          this._lastPoints = c, sc(c[0].sub(c[1])) && (this._valid = !1);
        }, f.prototype._move = function(c, d, _) {
          var w = c[0].sub(this._lastPoints[0]), E = c[1].sub(this._lastPoints[1]);
          if (this._valid = this.gestureBeginsVertically(w, E, _.timeStamp), this._valid)
            return this._lastPoints = c, this._active = !0, { pitchDelta: (w.y + E.y) / 2 * -0.5 };
        }, f.prototype.gestureBeginsVertically = function(c, d, _) {
          if (this._valid !== void 0)
            return this._valid;
          var w = c.mag() >= 2, E = d.mag() >= 2;
          if (w || E) {
            if (!w || !E)
              return this._firstMove === void 0 && (this._firstMove = _), _ - this._firstMove < 100 && void 0;
            var O = c.y > 0 == d.y > 0;
            return sc(c) && sc(d) && O;
          }
        }, f;
      }(ho), lp = { panStep: 100, bearingStep: 15, pitchStep: 10 }, sa = function() {
        var u = lp;
        this._panStep = u.panStep, this._bearingStep = u.bearingStep, this._pitchStep = u.pitchStep, this._rotationDisabled = !1;
      };
      function Io(u) {
        return u * (2 - u);
      }
      sa.prototype.blur = function() {
        this.reset();
      }, sa.prototype.reset = function() {
        this._active = !1;
      }, sa.prototype.keydown = function(u) {
        var f = this;
        if (!(u.altKey || u.ctrlKey || u.metaKey)) {
          var c = 0, d = 0, _ = 0, w = 0, E = 0;
          switch (u.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              c = 1;
              break;
            case 189:
            case 109:
            case 173:
              c = -1;
              break;
            case 37:
              u.shiftKey ? d = -1 : (u.preventDefault(), w = -1);
              break;
            case 39:
              u.shiftKey ? d = 1 : (u.preventDefault(), w = 1);
              break;
            case 38:
              u.shiftKey ? _ = 1 : (u.preventDefault(), E = -1);
              break;
            case 40:
              u.shiftKey ? _ = -1 : (u.preventDefault(), E = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (d = 0, _ = 0), { cameraAnimation: function(O) {
            var k = O.getZoom();
            O.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Io, zoom: c ? Math.round(k) + c * (u.shiftKey ? 2 : 1) : k, bearing: O.getBearing() + d * f._bearingStep, pitch: O.getPitch() + _ * f._pitchStep, offset: [-w * f._panStep, -E * f._panStep], center: O.getCenter() }, { originalEvent: u });
          } };
        }
      }, sa.prototype.enable = function() {
        this._enabled = !0;
      }, sa.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, sa.prototype.isEnabled = function() {
        return this._enabled;
      }, sa.prototype.isActive = function() {
        return this._active;
      }, sa.prototype.disableRotation = function() {
        this._rotationDisabled = !0;
      }, sa.prototype.enableRotation = function() {
        this._rotationDisabled = !1;
      };
      var mr = function(u, f) {
        this._map = u, this._el = u.getCanvasContainer(), this._handler = f, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 1 / 450, o.bindAll(["_onTimeout"], this);
      };
      mr.prototype.setZoomRate = function(u) {
        this._defaultZoomRate = u;
      }, mr.prototype.setWheelZoomRate = function(u) {
        this._wheelZoomRate = u;
      }, mr.prototype.isEnabled = function() {
        return !!this._enabled;
      }, mr.prototype.isActive = function() {
        return !!this._active || this._finishTimeout !== void 0;
      }, mr.prototype.isZooming = function() {
        return !!this._zooming;
      }, mr.prototype.enable = function(u) {
        this.isEnabled() || (this._enabled = !0, this._aroundCenter = u && u.around === "center");
      }, mr.prototype.disable = function() {
        this.isEnabled() && (this._enabled = !1);
      }, mr.prototype.wheel = function(u) {
        if (this.isEnabled()) {
          var f = u.deltaMode === o.window.WheelEvent.DOM_DELTA_LINE ? 40 * u.deltaY : u.deltaY, c = o.browser.now(), d = c - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = c, f !== 0 && f % 4.000244140625 == 0 ? this._type = "wheel" : f !== 0 && Math.abs(f) < 4 ? this._type = "trackpad" : d > 400 ? (this._type = null, this._lastValue = f, this._timeout = setTimeout(this._onTimeout, 40, u)) : this._type || (this._type = Math.abs(d * f) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, f += this._lastValue)), u.shiftKey && f && (f /= 4), this._type && (this._lastWheelEvent = u, this._delta -= f, this._active || this._start(u)), u.preventDefault();
        }
      }, mr.prototype._onTimeout = function(u) {
        this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(u);
      }, mr.prototype._start = function(u) {
        if (this._delta) {
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          var f = g.mousePos(this._el, u);
          this._around = o.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(f)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
        }
      }, mr.prototype.renderFrame = function() {
        var u = this;
        if (this._frameId && (this._frameId = null, this.isActive())) {
          var f = this._map.transform;
          if (this._delta !== 0) {
            var c = this._type === "wheel" && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, d = 2 / (1 + Math.exp(-Math.abs(this._delta * c)));
            this._delta < 0 && d !== 0 && (d = 1 / d);
            var _ = typeof this._targetZoom == "number" ? f.zoomScale(this._targetZoom) : f.scale;
            this._targetZoom = Math.min(f.maxZoom, Math.max(f.minZoom, f.scaleZoom(_ * d))), this._type === "wheel" && (this._startZoom = f.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          var w, E = typeof this._targetZoom == "number" ? this._targetZoom : f.zoom, O = this._startZoom, k = this._easing, R = !1;
          if (this._type === "wheel" && O && k) {
            var q = Math.min((o.browser.now() - this._lastWheelEventTime) / 200, 1), $ = k(q);
            w = o.number(O, E, $), q < 1 ? this._frameId || (this._frameId = !0) : R = !0;
          } else
            w = E, R = !0;
          return this._active = !0, R && (this._active = !1, this._finishTimeout = setTimeout(function() {
            u._zooming = !1, u._handler._triggerRenderFrame(), delete u._targetZoom, delete u._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !R, zoomDelta: w - f.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
      }, mr.prototype._smoothOutEasing = function(u) {
        var f = o.ease;
        if (this._prevEase) {
          var c = this._prevEase, d = (o.browser.now() - c.start) / c.duration, _ = c.easing(d + 0.01) - c.easing(d), w = 0.27 / Math.sqrt(_ * _ + 1e-4) * 0.01, E = Math.sqrt(0.0729 - w * w);
          f = o.bezier(w, E, 0.25, 1);
        }
        return this._prevEase = { start: o.browser.now(), duration: u, easing: f }, f;
      }, mr.prototype.blur = function() {
        this.reset();
      }, mr.prototype.reset = function() {
        this._active = !1;
      };
      var xa = function(u, f) {
        this._clickZoom = u, this._tapZoom = f;
      };
      xa.prototype.enable = function() {
        this._clickZoom.enable(), this._tapZoom.enable();
      }, xa.prototype.disable = function() {
        this._clickZoom.disable(), this._tapZoom.disable();
      }, xa.prototype.isEnabled = function() {
        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
      }, xa.prototype.isActive = function() {
        return this._clickZoom.isActive() || this._tapZoom.isActive();
      };
      var Wo = function() {
        this.reset();
      };
      Wo.prototype.reset = function() {
        this._active = !1;
      }, Wo.prototype.blur = function() {
        this.reset();
      }, Wo.prototype.dblclick = function(u, f) {
        return u.preventDefault(), { cameraAnimation: function(c) {
          c.easeTo({ duration: 300, zoom: c.getZoom() + (u.shiftKey ? -1 : 1), around: c.unproject(f) }, { originalEvent: u });
        } };
      }, Wo.prototype.enable = function() {
        this._enabled = !0;
      }, Wo.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, Wo.prototype.isEnabled = function() {
        return this._enabled;
      }, Wo.prototype.isActive = function() {
        return this._active;
      };
      var Ti = function() {
        this._tap = new aa({ numTouches: 1, numTaps: 1 }), this.reset();
      };
      Ti.prototype.reset = function() {
        this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
      }, Ti.prototype.touchstart = function(u, f, c) {
        this._swipePoint || (this._tapTime && u.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? c.length > 0 && (this._swipePoint = f[0], this._swipeTouch = c[0].identifier) : this._tap.touchstart(u, f, c));
      }, Ti.prototype.touchmove = function(u, f, c) {
        if (this._tapTime) {
          if (this._swipePoint) {
            if (c[0].identifier !== this._swipeTouch)
              return;
            var d = f[0], _ = d.y - this._swipePoint.y;
            return this._swipePoint = d, u.preventDefault(), this._active = !0, { zoomDelta: _ / 128 };
          }
        } else
          this._tap.touchmove(u, f, c);
      }, Ti.prototype.touchend = function(u, f, c) {
        this._tapTime ? this._swipePoint && c.length === 0 && this.reset() : this._tap.touchend(u, f, c) && (this._tapTime = u.timeStamp);
      }, Ti.prototype.touchcancel = function() {
        this.reset();
      }, Ti.prototype.enable = function() {
        this._enabled = !0;
      }, Ti.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, Ti.prototype.isEnabled = function() {
        return this._enabled;
      }, Ti.prototype.isActive = function() {
        return this._active;
      };
      var gl = function(u, f, c) {
        this._el = u, this._mousePan = f, this._touchPan = c;
      };
      gl.prototype.enable = function(u) {
        this._inertiaOptions = u || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
      }, gl.prototype.disable = function() {
        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
      }, gl.prototype.isEnabled = function() {
        return this._mousePan.isEnabled() && this._touchPan.isEnabled();
      }, gl.prototype.isActive = function() {
        return this._mousePan.isActive() || this._touchPan.isActive();
      };
      var ws = function(u, f, c) {
        this._pitchWithRotate = u.pitchWithRotate, this._mouseRotate = f, this._mousePitch = c;
      };
      ws.prototype.enable = function() {
        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
      }, ws.prototype.disable = function() {
        this._mouseRotate.disable(), this._mousePitch.disable();
      }, ws.prototype.isEnabled = function() {
        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
      }, ws.prototype.isActive = function() {
        return this._mouseRotate.isActive() || this._mousePitch.isActive();
      };
      var la = function(u, f, c, d) {
        this._el = u, this._touchZoom = f, this._touchRotate = c, this._tapDragZoom = d, this._rotationDisabled = !1, this._enabled = !0;
      };
      la.prototype.enable = function(u) {
        this._touchZoom.enable(u), this._rotationDisabled || this._touchRotate.enable(u), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
      }, la.prototype.disable = function() {
        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
      }, la.prototype.isEnabled = function() {
        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
      }, la.prototype.isActive = function() {
        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
      }, la.prototype.disableRotation = function() {
        this._rotationDisabled = !0, this._touchRotate.disable();
      }, la.prototype.enableRotation = function() {
        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
      };
      var ji = function(u) {
        return u.zoom || u.drag || u.pitch || u.rotate;
      }, lc = function(u) {
        function f() {
          u.apply(this, arguments);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f;
      }(o.Event);
      function Lt(u) {
        return u.panDelta && u.panDelta.mag() || u.zoomDelta || u.bearingDelta || u.pitchDelta;
      }
      var Tt = function(u, f) {
        this._map = u, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ic(u), this._bearingSnap = f.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(f), o.bindAll(["handleEvent", "handleWindowEvent"], this);
        var c = this._el;
        this._listeners = [[c, "touchstart", { passive: !0 }], [c, "touchmove", { passive: !1 }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [o.window.document, "mousemove", { capture: !0 }], [o.window.document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: !1 }], [c, "keyup", void 0], [c, "wheel", { passive: !1 }], [c, "contextmenu", void 0], [o.window, "blur", void 0]];
        for (var d = 0, _ = this._listeners; d < _.length; d += 1) {
          var w = _[d], E = w[0];
          g.addEventListener(E, w[1], E === o.window.document ? this.handleWindowEvent : this.handleEvent, w[2]);
        }
      };
      Tt.prototype.destroy = function() {
        for (var u = 0, f = this._listeners; u < f.length; u += 1) {
          var c = f[u], d = c[0];
          g.removeEventListener(d, c[1], d === o.window.document ? this.handleWindowEvent : this.handleEvent, c[2]);
        }
      }, Tt.prototype._addDefaultHandlers = function(u) {
        var f = this._map, c = f.getCanvasContainer();
        this._add("mapEvent", new Gn(f, u));
        var d = f.boxZoom = new uo(f, u);
        this._add("boxZoom", d);
        var _ = new co(), w = new Wo();
        f.doubleClickZoom = new xa(w, _), this._add("tapZoom", _), this._add("clickZoom", w);
        var E = new Ti();
        this._add("tapDragZoom", E);
        var O = f.touchPitch = new sp();
        this._add("touchPitch", O);
        var k = new vh(u), R = new ap(u);
        f.dragRotate = new ws(u, k, R), this._add("mouseRotate", k, ["mousePitch"]), this._add("mousePitch", R, ["mouseRotate"]);
        var q = new op(u), $ = new $o(u);
        f.dragPan = new gl(c, q, $), this._add("mousePan", q), this._add("touchPan", $, ["touchZoom", "touchRotate"]);
        var H = new Lm(), ne = new fo();
        f.touchZoomRotate = new la(c, ne, H, E), this._add("touchRotate", H, ["touchPan", "touchZoom"]), this._add("touchZoom", ne, ["touchPan", "touchRotate"]);
        var re = f.scrollZoom = new mr(f, this);
        this._add("scrollZoom", re, ["mousePan"]);
        var ue = f.keyboard = new sa();
        this._add("keyboard", ue), this._add("blockableMapEvent", new wt(f));
        for (var J = 0, le = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; J < le.length; J += 1) {
          var me = le[J];
          u.interactive && u[me] && f[me].enable(u[me]);
        }
      }, Tt.prototype._add = function(u, f, c) {
        this._handlers.push({ handlerName: u, handler: f, allowed: c }), this._handlersById[u] = f;
      }, Tt.prototype.stop = function(u) {
        if (!this._updatingCamera) {
          for (var f = 0, c = this._handlers; f < c.length; f += 1)
            c[f].handler.reset();
          this._inertia.clear(), this._fireEvents({}, {}, u), this._changes = [];
        }
      }, Tt.prototype.isActive = function() {
        for (var u = 0, f = this._handlers; u < f.length; u += 1)
          if (f[u].handler.isActive())
            return !0;
        return !1;
      }, Tt.prototype.isZooming = function() {
        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
      }, Tt.prototype.isRotating = function() {
        return !!this._eventsInProgress.rotate;
      }, Tt.prototype.isMoving = function() {
        return Boolean(ji(this._eventsInProgress)) || this.isZooming();
      }, Tt.prototype._blockedByActive = function(u, f, c) {
        for (var d in u)
          if (d !== c && (!f || f.indexOf(d) < 0))
            return !0;
        return !1;
      }, Tt.prototype.handleWindowEvent = function(u) {
        this.handleEvent(u, u.type + "Window");
      }, Tt.prototype._getMapTouches = function(u) {
        for (var f = [], c = 0, d = u; c < d.length; c += 1) {
          var _ = d[c];
          this._el.contains(_.target) && f.push(_);
        }
        return f;
      }, Tt.prototype.handleEvent = function(u, f) {
        this._updatingCamera = !0;
        for (var c = u.type === "renderFrame" ? void 0 : u, d = { needsRenderFrame: !1 }, _ = {}, w = {}, E = u.touches ? this._getMapTouches(u.touches) : void 0, O = E ? g.touchPos(this._el, E) : g.mousePos(this._el, u), k = 0, R = this._handlers; k < R.length; k += 1) {
          var q = R[k], $ = q.handlerName, H = q.handler, ne = q.allowed;
          if (H.isEnabled()) {
            var re = void 0;
            this._blockedByActive(w, ne, $) ? H.reset() : H[f || u.type] && (re = H[f || u.type](u, O, E), this.mergeHandlerResult(d, _, re, $, c), re && re.needsRenderFrame && this._triggerRenderFrame()), (re || H.isActive()) && (w[$] = H);
          }
        }
        var ue = {};
        for (var J in this._previousActiveHandlers)
          w[J] || (ue[J] = c);
        this._previousActiveHandlers = w, (Object.keys(ue).length || Lt(d)) && (this._changes.push([d, _, ue]), this._triggerRenderFrame()), (Object.keys(w).length || Lt(d)) && this._map._stop(!0), this._updatingCamera = !1;
        var le = d.cameraAnimation;
        le && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], le(this._map));
      }, Tt.prototype.mergeHandlerResult = function(u, f, c, d, _) {
        if (c) {
          o.extend(u, c);
          var w = { handlerName: d, originalEvent: c.originalEvent || _ };
          c.zoomDelta !== void 0 && (f.zoom = w), c.panDelta !== void 0 && (f.drag = w), c.pitchDelta !== void 0 && (f.pitch = w), c.bearingDelta !== void 0 && (f.rotate = w);
        }
      }, Tt.prototype._applyChanges = function() {
        for (var u = {}, f = {}, c = {}, d = 0, _ = this._changes; d < _.length; d += 1) {
          var w = _[d], E = w[0], O = w[1], k = w[2];
          E.panDelta && (u.panDelta = (u.panDelta || new o.Point(0, 0))._add(E.panDelta)), E.zoomDelta && (u.zoomDelta = (u.zoomDelta || 0) + E.zoomDelta), E.bearingDelta && (u.bearingDelta = (u.bearingDelta || 0) + E.bearingDelta), E.pitchDelta && (u.pitchDelta = (u.pitchDelta || 0) + E.pitchDelta), E.around !== void 0 && (u.around = E.around), E.pinchAround !== void 0 && (u.pinchAround = E.pinchAround), E.noInertia && (u.noInertia = E.noInertia), o.extend(f, O), o.extend(c, k);
        }
        this._updateMapTransform(u, f, c), this._changes = [];
      }, Tt.prototype._updateMapTransform = function(u, f, c) {
        var d = this._map, _ = d.transform;
        if (!Lt(u))
          return this._fireEvents(f, c, !0);
        var w = u.panDelta, E = u.zoomDelta, O = u.bearingDelta, k = u.pitchDelta, R = u.around, q = u.pinchAround;
        q !== void 0 && (R = q), d._stop(!0), R = R || d.transform.centerPoint;
        var $ = _.pointLocation(w ? R.sub(w) : R);
        O && (_.bearing += O), k && (_.pitch += k), E && (_.zoom += E), _.setLocationAtPoint($, R), this._map._update(), u.noInertia || this._inertia.record(u), this._fireEvents(f, c, !0);
      }, Tt.prototype._fireEvents = function(u, f, c) {
        var d = this, _ = ji(this._eventsInProgress), w = ji(u), E = {};
        for (var O in u)
          this._eventsInProgress[O] || (E[O + "start"] = u[O].originalEvent), this._eventsInProgress[O] = u[O];
        for (var k in !_ && w && this._fireEvent("movestart", w.originalEvent), E)
          this._fireEvent(k, E[k]);
        for (var R in w && this._fireEvent("move", w.originalEvent), u)
          this._fireEvent(R, u[R].originalEvent);
        var q, $ = {};
        for (var H in this._eventsInProgress) {
          var ne = this._eventsInProgress[H], re = ne.handlerName, ue = ne.originalEvent;
          this._handlersById[re].isActive() || (delete this._eventsInProgress[H], $[H + "end"] = q = f[re] || ue);
        }
        for (var J in $)
          this._fireEvent(J, $[J]);
        var le = ji(this._eventsInProgress);
        if (c && (_ || w) && !le) {
          this._updatingCamera = !0;
          var me = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), _e = function(Ae) {
            return Ae !== 0 && -d._bearingSnap < Ae && Ae < d._bearingSnap;
          };
          me ? (_e(me.bearing || this._map.getBearing()) && (me.bearing = 0), this._map.easeTo(me, { originalEvent: q })) : (this._map.fire(new o.Event("moveend", { originalEvent: q })), _e(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
        }
      }, Tt.prototype._fireEvent = function(u, f) {
        this._map.fire(new o.Event(u, f ? { originalEvent: f } : {}));
      }, Tt.prototype._requestFrame = function() {
        var u = this;
        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(function(f) {
          delete u._frameId, u.handleEvent(new lc("renderFrame", { timeStamp: f })), u._applyChanges();
        });
      }, Tt.prototype._triggerRenderFrame = function() {
        this._frameId === void 0 && (this._frameId = this._requestFrame());
      };
      var bh = function(u) {
        function f(c, d) {
          u.call(this), this._moving = !1, this._zooming = !1, this.transform = c, this._bearingSnap = d.bearingSnap, o.bindAll(["_renderFrameCallback"], this);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.getCenter = function() {
          return new o.LngLat(this.transform.center.lng, this.transform.center.lat);
        }, f.prototype.setCenter = function(c, d) {
          return this.jumpTo({ center: c }, d);
        }, f.prototype.panBy = function(c, d, _) {
          return c = o.Point.convert(c).mult(-1), this.panTo(this.transform.center, o.extend({ offset: c }, d), _);
        }, f.prototype.panTo = function(c, d, _) {
          return this.easeTo(o.extend({ center: c }, d), _);
        }, f.prototype.getZoom = function() {
          return this.transform.zoom;
        }, f.prototype.setZoom = function(c, d) {
          return this.jumpTo({ zoom: c }, d), this;
        }, f.prototype.zoomTo = function(c, d, _) {
          return this.easeTo(o.extend({ zoom: c }, d), _);
        }, f.prototype.zoomIn = function(c, d) {
          return this.zoomTo(this.getZoom() + 1, c, d), this;
        }, f.prototype.zoomOut = function(c, d) {
          return this.zoomTo(this.getZoom() - 1, c, d), this;
        }, f.prototype.getBearing = function() {
          return this.transform.bearing;
        }, f.prototype.setBearing = function(c, d) {
          return this.jumpTo({ bearing: c }, d), this;
        }, f.prototype.getPadding = function() {
          return this.transform.padding;
        }, f.prototype.setPadding = function(c, d) {
          return this.jumpTo({ padding: c }, d), this;
        }, f.prototype.rotateTo = function(c, d, _) {
          return this.easeTo(o.extend({ bearing: c }, d), _);
        }, f.prototype.resetNorth = function(c, d) {
          return this.rotateTo(0, o.extend({ duration: 1e3 }, c), d), this;
        }, f.prototype.resetNorthPitch = function(c, d) {
          return this.easeTo(o.extend({ bearing: 0, pitch: 0, duration: 1e3 }, c), d), this;
        }, f.prototype.snapToNorth = function(c, d) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(c, d) : this;
        }, f.prototype.getPitch = function() {
          return this.transform.pitch;
        }, f.prototype.setPitch = function(c, d) {
          return this.jumpTo({ pitch: c }, d), this;
        }, f.prototype.cameraForBounds = function(c, d) {
          c = o.LngLatBounds.convert(c);
          var _ = d && d.bearing || 0;
          return this._cameraForBoxAndBearing(c.getNorthWest(), c.getSouthEast(), _, d);
        }, f.prototype._cameraForBoxAndBearing = function(c, d, _, w) {
          var E = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (w = o.extend({ padding: E, offset: [0, 0], maxZoom: this.transform.maxZoom }, w)).padding == "number") {
            var O = w.padding;
            w.padding = { top: O, bottom: O, right: O, left: O };
          }
          w.padding = o.extend(E, w.padding);
          var k = this.transform, R = k.padding, q = k.project(o.LngLat.convert(c)), $ = k.project(o.LngLat.convert(d)), H = q.rotate(-_ * Math.PI / 180), ne = $.rotate(-_ * Math.PI / 180), re = new o.Point(Math.max(H.x, ne.x), Math.max(H.y, ne.y)), ue = new o.Point(Math.min(H.x, ne.x), Math.min(H.y, ne.y)), J = re.sub(ue), le = (k.width - (R.left + R.right + w.padding.left + w.padding.right)) / J.x, me = (k.height - (R.top + R.bottom + w.padding.top + w.padding.bottom)) / J.y;
          if (!(me < 0 || le < 0)) {
            var _e = Math.min(k.scaleZoom(k.scale * Math.min(le, me)), w.maxZoom), Ae = typeof w.offset.x == "number" ? new o.Point(w.offset.x, w.offset.y) : o.Point.convert(w.offset), Me = new o.Point((w.padding.left - w.padding.right) / 2, (w.padding.top - w.padding.bottom) / 2).rotate(_ * Math.PI / 180), ke = Ae.add(Me).mult(k.scale / k.zoomScale(_e));
            return { center: k.unproject(q.add($).div(2).sub(ke)), zoom: _e, bearing: _ };
          }
          o.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }, f.prototype.fitBounds = function(c, d, _) {
          return this._fitInternal(this.cameraForBounds(c, d), d, _);
        }, f.prototype.fitScreenCoordinates = function(c, d, _, w, E) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(o.Point.convert(c)), this.transform.pointLocation(o.Point.convert(d)), _, w), w, E);
        }, f.prototype._fitInternal = function(c, d, _) {
          return c ? (delete (d = o.extend(c, d)).padding, d.linear ? this.easeTo(d, _) : this.flyTo(d, _)) : this;
        }, f.prototype.jumpTo = function(c, d) {
          this.stop();
          var _ = this.transform, w = !1, E = !1, O = !1;
          return "zoom" in c && _.zoom !== +c.zoom && (w = !0, _.zoom = +c.zoom), c.center !== void 0 && (_.center = o.LngLat.convert(c.center)), "bearing" in c && _.bearing !== +c.bearing && (E = !0, _.bearing = +c.bearing), "pitch" in c && _.pitch !== +c.pitch && (O = !0, _.pitch = +c.pitch), c.padding == null || _.isPaddingEqual(c.padding) || (_.padding = c.padding), this.fire(new o.Event("movestart", d)).fire(new o.Event("move", d)), w && this.fire(new o.Event("zoomstart", d)).fire(new o.Event("zoom", d)).fire(new o.Event("zoomend", d)), E && this.fire(new o.Event("rotatestart", d)).fire(new o.Event("rotate", d)).fire(new o.Event("rotateend", d)), O && this.fire(new o.Event("pitchstart", d)).fire(new o.Event("pitch", d)).fire(new o.Event("pitchend", d)), this.fire(new o.Event("moveend", d));
        }, f.prototype.easeTo = function(c, d) {
          var _ = this;
          this._stop(!1, c.easeId), ((c = o.extend({ offset: [0, 0], duration: 500, easing: o.ease }, c)).animate === !1 || !c.essential && o.browser.prefersReducedMotion) && (c.duration = 0);
          var w = this.transform, E = this.getZoom(), O = this.getBearing(), k = this.getPitch(), R = this.getPadding(), q = "zoom" in c ? +c.zoom : E, $ = "bearing" in c ? this._normalizeBearing(c.bearing, O) : O, H = "pitch" in c ? +c.pitch : k, ne = "padding" in c ? c.padding : w.padding, re = o.Point.convert(c.offset), ue = w.centerPoint.add(re), J = w.pointLocation(ue), le = o.LngLat.convert(c.center || J);
          this._normalizeCenter(le);
          var me, _e, Ae = w.project(J), Me = w.project(le).sub(Ae), ke = w.zoomScale(q - E);
          c.around && (me = o.LngLat.convert(c.around), _e = w.locationPoint(me));
          var je = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || q !== E, this._rotating = this._rotating || O !== $, this._pitching = this._pitching || H !== k, this._padding = !w.isPaddingEqual(ne), this._easeId = c.easeId, this._prepareEase(d, c.noMoveStart, je), this._ease(function(nt) {
            if (_._zooming && (w.zoom = o.number(E, q, nt)), _._rotating && (w.bearing = o.number(O, $, nt)), _._pitching && (w.pitch = o.number(k, H, nt)), _._padding && (w.interpolatePadding(R, ne, nt), ue = w.centerPoint.add(re)), me)
              w.setLocationAtPoint(me, _e);
            else {
              var tt = w.zoomScale(w.zoom - E), gt = q > E ? Math.min(2, ke) : Math.max(0.5, ke), Dt = Math.pow(gt, 1 - nt), Bt = w.unproject(Ae.add(Me.mult(nt * Dt)).mult(tt));
              w.setLocationAtPoint(w.renderWorldCopies ? Bt.wrap() : Bt, ue);
            }
            _._fireMoveEvents(d);
          }, function(nt) {
            _._afterEase(d, nt);
          }, c), this;
        }, f.prototype._prepareEase = function(c, d, _) {
          _ === void 0 && (_ = {}), this._moving = !0, d || _.moving || this.fire(new o.Event("movestart", c)), this._zooming && !_.zooming && this.fire(new o.Event("zoomstart", c)), this._rotating && !_.rotating && this.fire(new o.Event("rotatestart", c)), this._pitching && !_.pitching && this.fire(new o.Event("pitchstart", c));
        }, f.prototype._fireMoveEvents = function(c) {
          this.fire(new o.Event("move", c)), this._zooming && this.fire(new o.Event("zoom", c)), this._rotating && this.fire(new o.Event("rotate", c)), this._pitching && this.fire(new o.Event("pitch", c));
        }, f.prototype._afterEase = function(c, d) {
          if (!this._easeId || !d || this._easeId !== d) {
            delete this._easeId;
            var _ = this._zooming, w = this._rotating, E = this._pitching;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, _ && this.fire(new o.Event("zoomend", c)), w && this.fire(new o.Event("rotateend", c)), E && this.fire(new o.Event("pitchend", c)), this.fire(new o.Event("moveend", c));
          }
        }, f.prototype.flyTo = function(c, d) {
          var _ = this;
          if (!c.essential && o.browser.prefersReducedMotion) {
            var w = o.pick(c, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(w, d);
          }
          this.stop(), c = o.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: o.ease }, c);
          var E = this.transform, O = this.getZoom(), k = this.getBearing(), R = this.getPitch(), q = this.getPadding(), $ = "zoom" in c ? o.clamp(+c.zoom, E.minZoom, E.maxZoom) : O, H = "bearing" in c ? this._normalizeBearing(c.bearing, k) : k, ne = "pitch" in c ? +c.pitch : R, re = "padding" in c ? c.padding : E.padding, ue = E.zoomScale($ - O), J = o.Point.convert(c.offset), le = E.centerPoint.add(J), me = E.pointLocation(le), _e = o.LngLat.convert(c.center || me);
          this._normalizeCenter(_e);
          var Ae = E.project(me), Me = E.project(_e).sub(Ae), ke = c.curve, je = Math.max(E.width, E.height), nt = je / ue, tt = Me.mag();
          if ("minZoom" in c) {
            var gt = o.clamp(Math.min(c.minZoom, O, $), E.minZoom, E.maxZoom), Dt = je / E.zoomScale(gt - O);
            ke = Math.sqrt(Dt / tt * 2);
          }
          var Bt = ke * ke;
          function zt(Ht) {
            var qt = (nt * nt - je * je + (Ht ? -1 : 1) * Bt * Bt * tt * tt) / (2 * (Ht ? nt : je) * Bt * tt);
            return Math.log(Math.sqrt(qt * qt + 1) - qt);
          }
          function Ir(Ht) {
            return (Math.exp(Ht) - Math.exp(-Ht)) / 2;
          }
          function xt(Ht) {
            return (Math.exp(Ht) + Math.exp(-Ht)) / 2;
          }
          var Yt = zt(0), ir = function(Ht) {
            return xt(Yt) / xt(Yt + ke * Ht);
          }, Kt = function(Ht) {
            return je * ((xt(Yt) * (Ir(qt = Yt + ke * Ht) / xt(qt)) - Ir(Yt)) / Bt) / tt;
            var qt;
          }, Xt = (zt(1) - Yt) / ke;
          if (Math.abs(tt) < 1e-6 || !isFinite(Xt)) {
            if (Math.abs(je - nt) < 1e-6)
              return this.easeTo(c, d);
            var nr = nt < je ? -1 : 1;
            Xt = Math.abs(Math.log(nt / je)) / ke, Kt = function() {
              return 0;
            }, ir = function(Ht) {
              return Math.exp(nr * ke * Ht);
            };
          }
          return c.duration = "duration" in c ? +c.duration : 1e3 * Xt / ("screenSpeed" in c ? +c.screenSpeed / ke : +c.speed), c.maxDuration && c.duration > c.maxDuration && (c.duration = 0), this._zooming = !0, this._rotating = k !== H, this._pitching = ne !== R, this._padding = !E.isPaddingEqual(re), this._prepareEase(d, !1), this._ease(function(Ht) {
            var qt = Ht * Xt, si = 1 / ir(qt);
            E.zoom = Ht === 1 ? $ : O + E.scaleZoom(si), _._rotating && (E.bearing = o.number(k, H, Ht)), _._pitching && (E.pitch = o.number(R, ne, Ht)), _._padding && (E.interpolatePadding(q, re, Ht), le = E.centerPoint.add(J));
            var On = Ht === 1 ? _e : E.unproject(Ae.add(Me.mult(Kt(qt))).mult(si));
            E.setLocationAtPoint(E.renderWorldCopies ? On.wrap() : On, le), _._fireMoveEvents(d);
          }, function() {
            return _._afterEase(d);
          }, c), this;
        }, f.prototype.isEasing = function() {
          return !!this._easeFrameId;
        }, f.prototype.stop = function() {
          return this._stop();
        }, f.prototype._stop = function(c, d) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            var _ = this._onEaseEnd;
            delete this._onEaseEnd, _.call(this, d);
          }
          if (!c) {
            var w = this.handlers;
            w && w.stop(!1);
          }
          return this;
        }, f.prototype._ease = function(c, d, _) {
          _.animate === !1 || _.duration === 0 ? (c(1), d()) : (this._easeStart = o.browser.now(), this._easeOptions = _, this._onEaseFrame = c, this._onEaseEnd = d, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }, f.prototype._renderFrameCallback = function() {
          var c = Math.min((o.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
          this._onEaseFrame(this._easeOptions.easing(c)), c < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }, f.prototype._normalizeBearing = function(c, d) {
          c = o.wrap(c, -180, 180);
          var _ = Math.abs(c - d);
          return Math.abs(c - 360 - d) < _ && (c -= 360), Math.abs(c + 360 - d) < _ && (c += 360), c;
        }, f.prototype._normalizeCenter = function(c) {
          var d = this.transform;
          if (d.renderWorldCopies && !d.lngRange) {
            var _ = c.lng - d.center.lng;
            c.lng += _ > 180 ? -360 : _ < -180 ? 360 : 0;
          }
        }, f;
      }(o.Evented), Gi = function(u) {
        u === void 0 && (u = {}), this.options = u, o.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
      };
      Gi.prototype.getDefaultPosition = function() {
        return "bottom-right";
      }, Gi.prototype.onAdd = function(u) {
        var f = this.options && this.options.compact;
        return this._map = u, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = g.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = g.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), f && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), f === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
      }, Gi.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
      }, Gi.prototype._setElementTitle = function(u, f) {
        var c = this._map._getUIString("AttributionControl." + f);
        u.title = c, u.setAttribute("aria-label", c);
      }, Gi.prototype._toggleAttribution = function() {
        this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));
      }, Gi.prototype._updateEditLink = function() {
        var u = this._editLink;
        u || (u = this._editLink = this._container.querySelector(".mapbox-improve-map"));
        var f = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || o.config.ACCESS_TOKEN }];
        if (u) {
          var c = f.reduce(function(d, _, w) {
            return _.value && (d += _.key + "=" + _.value + (w < f.length - 1 ? "&" : "")), d;
          }, "?");
          u.href = o.config.FEEDBACK_URL + "/" + c + (this._map._hash ? this._map._hash.getHashString(!0) : ""), u.rel = "noopener nofollow", this._setElementTitle(u, "MapFeedback");
        }
      }, Gi.prototype._updateData = function(u) {
        !u || u.sourceDataType !== "metadata" && u.sourceDataType !== "visibility" && u.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
      }, Gi.prototype._updateAttributions = function() {
        if (this._map.style) {
          var u = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? u = u.concat(this.options.customAttribution.map(function(O) {
            return typeof O != "string" ? "" : O;
          })) : typeof this.options.customAttribution == "string" && u.push(this.options.customAttribution)), this._map.style.stylesheet) {
            var f = this._map.style.stylesheet;
            this.styleOwner = f.owner, this.styleId = f.id;
          }
          var c = this._map.style.sourceCaches;
          for (var d in c) {
            var _ = c[d];
            if (_.used) {
              var w = _.getSource();
              w.attribution && u.indexOf(w.attribution) < 0 && u.push(w.attribution);
            }
          }
          u.sort(function(O, k) {
            return O.length - k.length;
          });
          var E = (u = u.filter(function(O, k) {
            for (var R = k + 1; R < u.length; R++)
              if (u[R].indexOf(O) >= 0)
                return !1;
            return !0;
          })).join(" | ");
          E !== this._attribHTML && (this._attribHTML = E, u.length ? (this._innerContainer.innerHTML = E, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
      }, Gi.prototype._updateCompact = function() {
        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
      };
      var ua = function() {
        o.bindAll(["_updateLogo"], this), o.bindAll(["_updateCompact"], this);
      };
      ua.prototype.onAdd = function(u) {
        this._map = u, this._container = g.create("div", "mapboxgl-ctrl");
        var f = g.create("a", "mapboxgl-ctrl-logo");
        return f.target = "_blank", f.rel = "noopener nofollow", f.href = "https://www.mapbox.com/", f.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), f.setAttribute("rel", "noopener nofollow"), this._container.appendChild(f), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
      }, ua.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
      }, ua.prototype.getDefaultPosition = function() {
        return "bottom-left";
      }, ua.prototype._updateLogo = function(u) {
        u && u.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
      }, ua.prototype._logoRequired = function() {
        if (this._map.style) {
          var u = this._map.style.sourceCaches;
          for (var f in u)
            if (u[f].getSource().mapbox_logo)
              return !0;
          return !1;
        }
      }, ua.prototype._updateCompact = function() {
        var u = this._container.children;
        if (u.length) {
          var f = u[0];
          this._map.getCanvasContainer().offsetWidth < 250 ? f.classList.add("mapboxgl-compact") : f.classList.remove("mapboxgl-compact");
        }
      };
      var Mi = function() {
        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
      };
      Mi.prototype.add = function(u) {
        var f = ++this._id;
        return this._queue.push({ callback: u, id: f, cancelled: !1 }), f;
      }, Mi.prototype.remove = function(u) {
        for (var f = this._currentlyRunning, c = 0, d = f ? this._queue.concat(f) : this._queue; c < d.length; c += 1) {
          var _ = d[c];
          if (_.id === u)
            return void (_.cancelled = !0);
        }
      }, Mi.prototype.run = function(u) {
        u === void 0 && (u = 0);
        var f = this._currentlyRunning = this._queue;
        this._queue = [];
        for (var c = 0, d = f; c < d.length; c += 1) {
          var _ = d[c];
          if (!_.cancelled && (_.callback(u), this._cleared))
            break;
        }
        this._cleared = !1, this._currentlyRunning = !1;
      }, Mi.prototype.clear = function() {
        this._currentlyRunning && (this._cleared = !0), this._queue = [];
      };
      var ba = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, up = o.window.HTMLImageElement, wh = o.window.HTMLElement, Gr = o.window.ImageBitmap, yi = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: !0 }, Dm = function(u) {
        function f(d) {
          var _ = this;
          if ((d = o.extend({}, yi, d)).minZoom != null && d.maxZoom != null && d.minZoom > d.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (d.minPitch != null && d.maxPitch != null && d.minPitch > d.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (d.minPitch != null && d.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (d.maxPitch != null && d.maxPitch > 60)
            throw new Error("maxPitch must be less than or equal to 60");
          var w = new xr(d.minZoom, d.maxZoom, d.minPitch, d.maxPitch, d.renderWorldCopies);
          if (u.call(this, w, d), this._interactive = d.interactive, this._maxTileCacheSize = d.maxTileCacheSize, this._failIfMajorPerformanceCaveat = d.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = d.preserveDrawingBuffer, this._antialias = d.antialias, this._trackResize = d.trackResize, this._bearingSnap = d.bearingSnap, this._refreshExpiredTiles = d.refreshExpiredTiles, this._fadeDuration = d.fadeDuration, this._crossSourceCollisions = d.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = d.collectResourceTiming, this._renderTaskQueue = new Mi(), this._controls = [], this._mapId = o.uniqueId(), this._locale = o.extend({}, ba, d.locale), this._clickTolerance = d.clickTolerance, this._requestManager = new o.RequestManager(d.transformRequest, d.accessToken), typeof d.container == "string") {
            if (this._container = o.window.document.getElementById(d.container), !this._container)
              throw new Error("Container '" + d.container + "' not found.");
          } else {
            if (!(d.container instanceof wh))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = d.container;
          }
          if (d.maxBounds && this.setMaxBounds(d.maxBounds), o.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)
            throw new Error("Failed to initialize WebGL.");
          this.on("move", function() {
            return _._update(!1);
          }), this.on("moveend", function() {
            return _._update(!1);
          }), this.on("zoom", function() {
            return _._update(!0);
          }), o.window !== void 0 && (o.window.addEventListener("online", this._onWindowOnline, !1), o.window.addEventListener("resize", this._onWindowResize, !1), o.window.addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new Tt(this, d), this._hash = d.hash && new Mo(typeof d.hash == "string" && d.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: d.center, zoom: d.zoom, bearing: d.bearing, pitch: d.pitch }), d.bounds && (this.resize(), this.fitBounds(d.bounds, o.extend({}, d.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = d.localIdeographFontFamily, d.style && this.setStyle(d.style, { localIdeographFontFamily: d.localIdeographFontFamily }), d.attributionControl && this.addControl(new Gi({ customAttribution: d.customAttribution })), this.addControl(new ua(), d.logoPosition), this.on("style.load", function() {
            _.transform.unmodified && _.jumpTo(_.style.stylesheet);
          }), this.on("data", function(E) {
            _._update(E.dataType === "style"), _.fire(new o.Event(E.dataType + "data", E));
          }), this.on("dataloading", function(E) {
            _.fire(new o.Event(E.dataType + "dataloading", E));
          });
        }
        u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f;
        var c = { showTileBoundaries: { configurable: !0 }, showPadding: { configurable: !0 }, showCollisionBoxes: { configurable: !0 }, showOverdrawInspector: { configurable: !0 }, repaint: { configurable: !0 }, vertices: { configurable: !0 }, version: { configurable: !0 } };
        return f.prototype._getMapId = function() {
          return this._mapId;
        }, f.prototype.addControl = function(d, _) {
          if (_ === void 0 && (_ = d.getDefaultPosition ? d.getDefaultPosition() : "top-right"), !d || !d.onAdd)
            return this.fire(new o.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          var w = d.onAdd(this);
          this._controls.push(d);
          var E = this._controlPositions[_];
          return _.indexOf("bottom") !== -1 ? E.insertBefore(w, E.firstChild) : E.appendChild(w), this;
        }, f.prototype.removeControl = function(d) {
          if (!d || !d.onRemove)
            return this.fire(new o.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          var _ = this._controls.indexOf(d);
          return _ > -1 && this._controls.splice(_, 1), d.onRemove(this), this;
        }, f.prototype.hasControl = function(d) {
          return this._controls.indexOf(d) > -1;
        }, f.prototype.resize = function(d) {
          var _ = this._containerDimensions(), w = _[0], E = _[1];
          if (w === this.transform.width && E === this.transform.height)
            return this;
          this._resizeCanvas(w, E), this.transform.resize(w, E), this.painter.resize(w, E);
          var O = !this._moving;
          return O && this.fire(new o.Event("movestart", d)).fire(new o.Event("move", d)), this.fire(new o.Event("resize", d)), O && this.fire(new o.Event("moveend", d)), this;
        }, f.prototype.getBounds = function() {
          return this.transform.getBounds();
        }, f.prototype.getMaxBounds = function() {
          return this.transform.getMaxBounds();
        }, f.prototype.setMaxBounds = function(d) {
          return this.transform.setMaxBounds(o.LngLatBounds.convert(d)), this._update();
        }, f.prototype.setMinZoom = function(d) {
          if ((d = d == null ? -2 : d) >= -2 && d <= this.transform.maxZoom)
            return this.transform.minZoom = d, this._update(), this.getZoom() < d && this.setZoom(d), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }, f.prototype.getMinZoom = function() {
          return this.transform.minZoom;
        }, f.prototype.setMaxZoom = function(d) {
          if ((d = d == null ? 22 : d) >= this.transform.minZoom)
            return this.transform.maxZoom = d, this._update(), this.getZoom() > d && this.setZoom(d), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }, f.prototype.getMaxZoom = function() {
          return this.transform.maxZoom;
        }, f.prototype.setMinPitch = function(d) {
          if ((d = d == null ? 0 : d) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (d >= 0 && d <= this.transform.maxPitch)
            return this.transform.minPitch = d, this._update(), this.getPitch() < d && this.setPitch(d), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }, f.prototype.getMinPitch = function() {
          return this.transform.minPitch;
        }, f.prototype.setMaxPitch = function(d) {
          if ((d = d == null ? 60 : d) > 60)
            throw new Error("maxPitch must be less than or equal to 60");
          if (d >= this.transform.minPitch)
            return this.transform.maxPitch = d, this._update(), this.getPitch() > d && this.setPitch(d), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }, f.prototype.getMaxPitch = function() {
          return this.transform.maxPitch;
        }, f.prototype.getRenderWorldCopies = function() {
          return this.transform.renderWorldCopies;
        }, f.prototype.setRenderWorldCopies = function(d) {
          return this.transform.renderWorldCopies = d, this._update();
        }, f.prototype.project = function(d) {
          return this.transform.locationPoint(o.LngLat.convert(d));
        }, f.prototype.unproject = function(d) {
          return this.transform.pointLocation(o.Point.convert(d));
        }, f.prototype.isMoving = function() {
          return this._moving || this.handlers.isMoving();
        }, f.prototype.isZooming = function() {
          return this._zooming || this.handlers.isZooming();
        }, f.prototype.isRotating = function() {
          return this._rotating || this.handlers.isRotating();
        }, f.prototype._createDelegatedListener = function(d, _, w) {
          var E, O = this;
          if (d === "mouseenter" || d === "mouseover") {
            var k = !1;
            return { layer: _, listener: w, delegates: { mousemove: function(q) {
              var $ = O.getLayer(_) ? O.queryRenderedFeatures(q.point, { layers: [_] }) : [];
              $.length ? k || (k = !0, w.call(O, new Jn(d, O, q.originalEvent, { features: $ }))) : k = !1;
            }, mouseout: function() {
              k = !1;
            } } };
          }
          if (d === "mouseleave" || d === "mouseout") {
            var R = !1;
            return { layer: _, listener: w, delegates: { mousemove: function(q) {
              (O.getLayer(_) ? O.queryRenderedFeatures(q.point, { layers: [_] }) : []).length ? R = !0 : R && (R = !1, w.call(O, new Jn(d, O, q.originalEvent)));
            }, mouseout: function(q) {
              R && (R = !1, w.call(O, new Jn(d, O, q.originalEvent)));
            } } };
          }
          return { layer: _, listener: w, delegates: (E = {}, E[d] = function(q) {
            var $ = O.getLayer(_) ? O.queryRenderedFeatures(q.point, { layers: [_] }) : [];
            $.length && (q.features = $, w.call(O, q), delete q.features);
          }, E) };
        }, f.prototype.on = function(d, _, w) {
          if (w === void 0)
            return u.prototype.on.call(this, d, _);
          var E = this._createDelegatedListener(d, _, w);
          for (var O in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[d] = this._delegatedListeners[d] || [], this._delegatedListeners[d].push(E), E.delegates)
            this.on(O, E.delegates[O]);
          return this;
        }, f.prototype.once = function(d, _, w) {
          if (w === void 0)
            return u.prototype.once.call(this, d, _);
          var E = this._createDelegatedListener(d, _, w);
          for (var O in E.delegates)
            this.once(O, E.delegates[O]);
          return this;
        }, f.prototype.off = function(d, _, w) {
          var E = this;
          return w === void 0 ? u.prototype.off.call(this, d, _) : (this._delegatedListeners && this._delegatedListeners[d] && function(O) {
            for (var k = O[d], R = 0; R < k.length; R++) {
              var q = k[R];
              if (q.layer === _ && q.listener === w) {
                for (var $ in q.delegates)
                  E.off($, q.delegates[$]);
                return k.splice(R, 1), E;
              }
            }
          }(this._delegatedListeners), this);
        }, f.prototype.queryRenderedFeatures = function(d, _) {
          if (!this.style)
            return [];
          var w;
          if (_ !== void 0 || d === void 0 || d instanceof o.Point || Array.isArray(d) || (_ = d, d = void 0), _ = _ || {}, (d = d || [[0, 0], [this.transform.width, this.transform.height]]) instanceof o.Point || typeof d[0] == "number")
            w = [o.Point.convert(d)];
          else {
            var E = o.Point.convert(d[0]), O = o.Point.convert(d[1]);
            w = [E, new o.Point(O.x, E.y), O, new o.Point(E.x, O.y), E];
          }
          return this.style.queryRenderedFeatures(w, _, this.transform);
        }, f.prototype.querySourceFeatures = function(d, _) {
          return this.style.querySourceFeatures(d, _);
        }, f.prototype.setStyle = function(d, _) {
          return (_ = o.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, _)).diff !== !1 && _.localIdeographFontFamily === this._localIdeographFontFamily && this.style && d ? (this._diffStyle(d, _), this) : (this._localIdeographFontFamily = _.localIdeographFontFamily, this._updateStyle(d, _));
        }, f.prototype._getUIString = function(d) {
          var _ = this._locale[d];
          if (_ == null)
            throw new Error("Missing UI string '" + d + "'");
          return _;
        }, f.prototype._updateStyle = function(d, _) {
          return this.style && (this.style.setEventedParent(null), this.style._remove()), d ? (this.style = new lo(this, _ || {}), this.style.setEventedParent(this, { style: this.style }), typeof d == "string" ? this.style.loadURL(d) : this.style.loadJSON(d), this) : (delete this.style, this);
        }, f.prototype._lazyInitEmptyStyle = function() {
          this.style || (this.style = new lo(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }, f.prototype._diffStyle = function(d, _) {
          var w = this;
          if (typeof d == "string") {
            var E = this._requestManager.normalizeStyleURL(d), O = this._requestManager.transformRequest(E, o.ResourceType.Style);
            o.getJSON(O, function(k, R) {
              k ? w.fire(new o.ErrorEvent(k)) : R && w._updateDiff(R, _);
            });
          } else
            typeof d == "object" && this._updateDiff(d, _);
        }, f.prototype._updateDiff = function(d, _) {
          try {
            this.style.setState(d) && this._update(!0);
          } catch (w) {
            o.warnOnce("Unable to perform style diff: " + (w.message || w.error || w) + ".  Rebuilding the style from scratch."), this._updateStyle(d, _);
          }
        }, f.prototype.getStyle = function() {
          if (this.style)
            return this.style.serialize();
        }, f.prototype.isStyleLoaded = function() {
          return this.style ? this.style.loaded() : o.warnOnce("There is no style added to the map.");
        }, f.prototype.addSource = function(d, _) {
          return this._lazyInitEmptyStyle(), this.style.addSource(d, _), this._update(!0);
        }, f.prototype.isSourceLoaded = function(d) {
          var _ = this.style && this.style.sourceCaches[d];
          if (_ !== void 0)
            return _.loaded();
          this.fire(new o.ErrorEvent(new Error("There is no source with ID '" + d + "'")));
        }, f.prototype.areTilesLoaded = function() {
          var d = this.style && this.style.sourceCaches;
          for (var _ in d) {
            var w = d[_]._tiles;
            for (var E in w) {
              var O = w[E];
              if (O.state !== "loaded" && O.state !== "errored")
                return !1;
            }
          }
          return !0;
        }, f.prototype.addSourceType = function(d, _, w) {
          return this._lazyInitEmptyStyle(), this.style.addSourceType(d, _, w);
        }, f.prototype.removeSource = function(d) {
          return this.style.removeSource(d), this._update(!0);
        }, f.prototype.getSource = function(d) {
          return this.style.getSource(d);
        }, f.prototype.addImage = function(d, _, w) {
          w === void 0 && (w = {});
          var E = w.pixelRatio;
          E === void 0 && (E = 1);
          var O = w.sdf;
          O === void 0 && (O = !1);
          var k = w.stretchX, R = w.stretchY, q = w.content;
          if (this._lazyInitEmptyStyle(), _ instanceof up || Gr && _ instanceof Gr) {
            var $ = o.browser.getImageData(_);
            this.style.addImage(d, { data: new o.RGBAImage({ width: $.width, height: $.height }, $.data), pixelRatio: E, stretchX: k, stretchY: R, content: q, sdf: O, version: 0 });
          } else {
            if (_.width === void 0 || _.height === void 0)
              return this.fire(new o.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            var H = _;
            this.style.addImage(d, { data: new o.RGBAImage({ width: _.width, height: _.height }, new Uint8Array(_.data)), pixelRatio: E, stretchX: k, stretchY: R, content: q, sdf: O, version: 0, userImage: H }), H.onAdd && H.onAdd(this, d);
          }
        }, f.prototype.updateImage = function(d, _) {
          var w = this.style.getImage(d);
          if (!w)
            return this.fire(new o.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          var E = _ instanceof up || Gr && _ instanceof Gr ? o.browser.getImageData(_) : _, O = E.width, k = E.height, R = E.data;
          return O === void 0 || k === void 0 ? this.fire(new o.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : O !== w.data.width || k !== w.data.height ? this.fire(new o.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (w.data.replace(R, !(_ instanceof up || Gr && _ instanceof Gr)), void this.style.updateImage(d, w));
        }, f.prototype.hasImage = function(d) {
          return d ? !!this.style.getImage(d) : (this.fire(new o.ErrorEvent(new Error("Missing required image id"))), !1);
        }, f.prototype.removeImage = function(d) {
          this.style.removeImage(d);
        }, f.prototype.loadImage = function(d, _) {
          o.getImage(this._requestManager.transformRequest(d, o.ResourceType.Image), _);
        }, f.prototype.listImages = function() {
          return this.style.listImages();
        }, f.prototype.addLayer = function(d, _) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(d, _), this._update(!0);
        }, f.prototype.moveLayer = function(d, _) {
          return this.style.moveLayer(d, _), this._update(!0);
        }, f.prototype.removeLayer = function(d) {
          return this.style.removeLayer(d), this._update(!0);
        }, f.prototype.getLayer = function(d) {
          return this.style.getLayer(d);
        }, f.prototype.setLayerZoomRange = function(d, _, w) {
          return this.style.setLayerZoomRange(d, _, w), this._update(!0);
        }, f.prototype.setFilter = function(d, _, w) {
          return w === void 0 && (w = {}), this.style.setFilter(d, _, w), this._update(!0);
        }, f.prototype.getFilter = function(d) {
          return this.style.getFilter(d);
        }, f.prototype.setPaintProperty = function(d, _, w, E) {
          return E === void 0 && (E = {}), this.style.setPaintProperty(d, _, w, E), this._update(!0);
        }, f.prototype.getPaintProperty = function(d, _) {
          return this.style.getPaintProperty(d, _);
        }, f.prototype.setLayoutProperty = function(d, _, w, E) {
          return E === void 0 && (E = {}), this.style.setLayoutProperty(d, _, w, E), this._update(!0);
        }, f.prototype.getLayoutProperty = function(d, _) {
          return this.style.getLayoutProperty(d, _);
        }, f.prototype.setLight = function(d, _) {
          return _ === void 0 && (_ = {}), this._lazyInitEmptyStyle(), this.style.setLight(d, _), this._update(!0);
        }, f.prototype.getLight = function() {
          return this.style.getLight();
        }, f.prototype.setFeatureState = function(d, _) {
          return this.style.setFeatureState(d, _), this._update();
        }, f.prototype.removeFeatureState = function(d, _) {
          return this.style.removeFeatureState(d, _), this._update();
        }, f.prototype.getFeatureState = function(d) {
          return this.style.getFeatureState(d);
        }, f.prototype.getContainer = function() {
          return this._container;
        }, f.prototype.getCanvasContainer = function() {
          return this._canvasContainer;
        }, f.prototype.getCanvas = function() {
          return this._canvas;
        }, f.prototype._containerDimensions = function() {
          var d = 0, _ = 0;
          return this._container && (d = this._container.clientWidth || 400, _ = this._container.clientHeight || 300), [d, _];
        }, f.prototype._detectMissingCSS = function() {
          o.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && o.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }, f.prototype._setupContainer = function() {
          var d = this._container;
          d.classList.add("mapboxgl-map"), (this._missingCSSCanary = g.create("div", "mapboxgl-canary", d)).style.visibility = "hidden", this._detectMissingCSS();
          var _ = this._canvasContainer = g.create("div", "mapboxgl-canvas-container", d);
          this._interactive && _.classList.add("mapboxgl-interactive"), this._canvas = g.create("canvas", "mapboxgl-canvas", _), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
          var w = this._containerDimensions();
          this._resizeCanvas(w[0], w[1]);
          var E = this._controlContainer = g.create("div", "mapboxgl-control-container", d), O = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function(k) {
            O[k] = g.create("div", "mapboxgl-ctrl-" + k, E);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }, f.prototype._resizeCanvas = function(d, _) {
          var w = o.browser.devicePixelRatio || 1;
          this._canvas.width = w * d, this._canvas.height = w * _, this._canvas.style.width = d + "px", this._canvas.style.height = _ + "px";
        }, f.prototype._setupPainter = function() {
          var d = o.extend({}, m.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), _ = this._canvas.getContext("webgl", d) || this._canvas.getContext("experimental-webgl", d);
          _ ? (this.painter = new mn(_, this.transform), o.webpSupported.testSupport(_)) : this.fire(new o.ErrorEvent(new Error("Failed to initialize WebGL")));
        }, f.prototype._contextLost = function(d) {
          d.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new o.Event("webglcontextlost", { originalEvent: d }));
        }, f.prototype._contextRestored = function(d) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new o.Event("webglcontextrestored", { originalEvent: d }));
        }, f.prototype._onMapScroll = function(d) {
          if (d.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
        }, f.prototype.loaded = function() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }, f.prototype._update = function(d) {
          return this.style ? (this._styleDirty = this._styleDirty || d, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }, f.prototype._requestRenderFrame = function(d) {
          return this._update(), this._renderTaskQueue.add(d);
        }, f.prototype._cancelRenderFrame = function(d) {
          this._renderTaskQueue.remove(d);
        }, f.prototype._render = function(d) {
          var _, w = this, E = 0, O = this.painter.context.extTimerQuery;
          if (this.listens("gpu-timing-frame") && (_ = O.createQueryEXT(), O.beginQueryEXT(O.TIME_ELAPSED_EXT, _), E = o.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(d), !this._removed) {
            var k = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              var R = this.transform.zoom, q = o.browser.now();
              this.style.zoomHistory.update(R, q);
              var $ = new o.EvaluationParameters(R, { now: q, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), H = $.crossFadingFactor();
              H === 1 && H === this._crossFadingFactor || (k = !0, this._crossFadingFactor = H), this.style.update($);
            }
            if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new o.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new o.Event("load"))), this.style && (this.style.hasTransitions() || k) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
              var ne = o.browser.now() - E;
              O.endQueryEXT(O.TIME_ELAPSED_EXT, _), setTimeout(function() {
                var J = O.getQueryObjectEXT(_, O.QUERY_RESULT_EXT) / 1e6;
                O.deleteQueryEXT(_), w.fire(new o.Event("gpu-timing-frame", { cpuTime: ne, gpuTime: J }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              var re = this.painter.collectGpuTimers();
              setTimeout(function() {
                var J = w.painter.queryGpuTimers(re);
                w.fire(new o.Event("gpu-timing-layer", { layerTimes: J }));
              }, 50);
            }
            var ue = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return ue || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.Event("idle")), !this._loaded || this._fullyLoaded || ue || (this._fullyLoaded = !0), this;
          }
        }, f.prototype.remove = function() {
          this._hash && this._hash.remove();
          for (var d = 0, _ = this._controls; d < _.length; d += 1)
            _[d].onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), o.window !== void 0 && (o.window.removeEventListener("resize", this._onWindowResize, !1), o.window.removeEventListener("orientationchange", this._onWindowResize, !1), o.window.removeEventListener("online", this._onWindowOnline, !1));
          var w = this.painter.context.gl.getExtension("WEBGL_lose_context");
          w && w.loseContext(), vl(this._canvasContainer), vl(this._controlContainer), vl(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this._removed = !0, this.fire(new o.Event("remove"));
        }, f.prototype.triggerRepaint = function() {
          var d = this;
          this.style && !this._frame && (this._frame = o.browser.frame(function(_) {
            d._frame = null, d._render(_);
          }));
        }, f.prototype._onWindowOnline = function() {
          this._update();
        }, f.prototype._onWindowResize = function(d) {
          this._trackResize && this.resize({ originalEvent: d })._update();
        }, c.showTileBoundaries.get = function() {
          return !!this._showTileBoundaries;
        }, c.showTileBoundaries.set = function(d) {
          this._showTileBoundaries !== d && (this._showTileBoundaries = d, this._update());
        }, c.showPadding.get = function() {
          return !!this._showPadding;
        }, c.showPadding.set = function(d) {
          this._showPadding !== d && (this._showPadding = d, this._update());
        }, c.showCollisionBoxes.get = function() {
          return !!this._showCollisionBoxes;
        }, c.showCollisionBoxes.set = function(d) {
          this._showCollisionBoxes !== d && (this._showCollisionBoxes = d, d ? this.style._generateCollisionBoxes() : this._update());
        }, c.showOverdrawInspector.get = function() {
          return !!this._showOverdrawInspector;
        }, c.showOverdrawInspector.set = function(d) {
          this._showOverdrawInspector !== d && (this._showOverdrawInspector = d, this._update());
        }, c.repaint.get = function() {
          return !!this._repaint;
        }, c.repaint.set = function(d) {
          this._repaint !== d && (this._repaint = d, this.triggerRepaint());
        }, c.vertices.get = function() {
          return !!this._vertices;
        }, c.vertices.set = function(d) {
          this._vertices = d, this._update();
        }, f.prototype._setCacheLimits = function(d, _) {
          o.setCacheLimits(d, _);
        }, c.version.get = function() {
          return o.version;
        }, Object.defineProperties(f.prototype, c), f;
      }(bh);
      function vl(u) {
        u.parentNode && u.parentNode.removeChild(u);
      }
      var cp = { showCompass: !0, showZoom: !0, visualizePitch: !1 }, Ga = function(u) {
        var f = this;
        this.options = o.extend({}, cp, u), this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", function(c) {
          return c.preventDefault();
        }), this.options.showZoom && (o.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", function(c) {
          return f._map.zoomIn({}, { originalEvent: c });
        }), g.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", !0), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", function(c) {
          return f._map.zoomOut({}, { originalEvent: c });
        }), g.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", !0)), this.options.showCompass && (o.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", function(c) {
          f.options.visualizePitch ? f._map.resetNorthPitch({}, { originalEvent: c }) : f._map.resetNorth({}, { originalEvent: c });
        }), this._compassIcon = g.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", !0));
      };
      Ga.prototype._updateZoomButtons = function() {
        var u = this._map.getZoom(), f = u === this._map.getMaxZoom(), c = u === this._map.getMinZoom();
        this._zoomInButton.disabled = f, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", f.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
      }, Ga.prototype._rotateCompassArrow = function() {
        var u = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";
        this._compassIcon.style.transform = u;
      }, Ga.prototype.onAdd = function(u) {
        return this._map = u, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new po(this._map, this._compass, this.options.visualizePitch)), this._container;
      }, Ga.prototype.onRemove = function() {
        g.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
      }, Ga.prototype._createButton = function(u, f) {
        var c = g.create("button", u, this._container);
        return c.type = "button", c.addEventListener("click", f), c;
      }, Ga.prototype._setButtonTitle = function(u, f) {
        var c = this._map._getUIString("NavigationControl." + f);
        u.title = c, u.setAttribute("aria-label", c);
      };
      var po = function(u, f, c) {
        c === void 0 && (c = !1), this._clickTolerance = 10, this.element = f, this.mouseRotate = new vh({ clickTolerance: u.dragRotate._mouseRotate._clickTolerance }), this.map = u, c && (this.mousePitch = new ap({ clickTolerance: u.dragRotate._mousePitch._clickTolerance })), o.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), g.addEventListener(f, "mousedown", this.mousedown), g.addEventListener(f, "touchstart", this.touchstart, { passive: !1 }), g.addEventListener(f, "touchmove", this.touchmove), g.addEventListener(f, "touchend", this.touchend), g.addEventListener(f, "touchcancel", this.reset);
      };
      function tu(u, f, c) {
        if (u = new o.LngLat(u.lng, u.lat), f) {
          var d = new o.LngLat(u.lng - 360, u.lat), _ = new o.LngLat(u.lng + 360, u.lat), w = c.locationPoint(u).distSqr(f);
          c.locationPoint(d).distSqr(f) < w ? u = d : c.locationPoint(_).distSqr(f) < w && (u = _);
        }
        for (; Math.abs(u.lng - c.center.lng) > 180; ) {
          var E = c.locationPoint(u);
          if (E.x >= 0 && E.y >= 0 && E.x <= c.width && E.y <= c.height)
            break;
          u.lng > c.center.lng ? u.lng -= 360 : u.lng += 360;
        }
        return u;
      }
      po.prototype.down = function(u, f) {
        this.mouseRotate.mousedown(u, f), this.mousePitch && this.mousePitch.mousedown(u, f), g.disableDrag();
      }, po.prototype.move = function(u, f) {
        var c = this.map, d = this.mouseRotate.mousemoveWindow(u, f);
        if (d && d.bearingDelta && c.setBearing(c.getBearing() + d.bearingDelta), this.mousePitch) {
          var _ = this.mousePitch.mousemoveWindow(u, f);
          _ && _.pitchDelta && c.setPitch(c.getPitch() + _.pitchDelta);
        }
      }, po.prototype.off = function() {
        var u = this.element;
        g.removeEventListener(u, "mousedown", this.mousedown), g.removeEventListener(u, "touchstart", this.touchstart, { passive: !1 }), g.removeEventListener(u, "touchmove", this.touchmove), g.removeEventListener(u, "touchend", this.touchend), g.removeEventListener(u, "touchcancel", this.reset), this.offTemp();
      }, po.prototype.offTemp = function() {
        g.enableDrag(), g.removeEventListener(o.window, "mousemove", this.mousemove), g.removeEventListener(o.window, "mouseup", this.mouseup);
      }, po.prototype.mousedown = function(u) {
        this.down(o.extend({}, u, { ctrlKey: !0, preventDefault: function() {
          return u.preventDefault();
        } }), g.mousePos(this.element, u)), g.addEventListener(o.window, "mousemove", this.mousemove), g.addEventListener(o.window, "mouseup", this.mouseup);
      }, po.prototype.mousemove = function(u) {
        this.move(u, g.mousePos(this.element, u));
      }, po.prototype.mouseup = function(u) {
        this.mouseRotate.mouseupWindow(u), this.mousePitch && this.mousePitch.mouseupWindow(u), this.offTemp();
      }, po.prototype.touchstart = function(u) {
        u.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = g.touchPos(this.element, u.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: function() {
          return u.preventDefault();
        } }, this._startPos));
      }, po.prototype.touchmove = function(u) {
        u.targetTouches.length !== 1 ? this.reset() : (this._lastPos = g.touchPos(this.element, u.targetTouches)[0], this.move({ preventDefault: function() {
          return u.preventDefault();
        } }, this._lastPos));
      }, po.prototype.touchend = function(u) {
        u.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
      }, po.prototype.reset = function() {
        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
      };
      var wa = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function Eh(u, f, c) {
        var d = u.classList;
        for (var _ in wa)
          d.remove("mapboxgl-" + c + "-anchor-" + _);
        d.add("mapboxgl-" + c + "-anchor-" + f);
      }
      var ru, uc = function(u) {
        function f(c, d) {
          if (u.call(this), (c instanceof o.window.HTMLElement || d) && (c = o.extend({ element: c }, d)), o.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = c && c.anchor || "center", this._color = c && c.color || "#3FB1CE", this._scale = c && c.scale || 1, this._draggable = c && c.draggable || !1, this._clickTolerance = c && c.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = c && c.rotation || 0, this._rotationAlignment = c && c.rotationAlignment || "auto", this._pitchAlignment = c && c.pitchAlignment && c.pitchAlignment !== "auto" ? c.pitchAlignment : this._rotationAlignment, c && c.element)
            this._element = c.element, this._offset = o.Point.convert(c && c.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = g.create("div"), this._element.setAttribute("aria-label", "Map marker");
            var _ = g.createNS("http://www.w3.org/2000/svg", "svg");
            _.setAttributeNS(null, "display", "block"), _.setAttributeNS(null, "height", "41px"), _.setAttributeNS(null, "width", "27px"), _.setAttributeNS(null, "viewBox", "0 0 27 41");
            var w = g.createNS("http://www.w3.org/2000/svg", "g");
            w.setAttributeNS(null, "stroke", "none"), w.setAttributeNS(null, "stroke-width", "1"), w.setAttributeNS(null, "fill", "none"), w.setAttributeNS(null, "fill-rule", "evenodd");
            var E = g.createNS("http://www.w3.org/2000/svg", "g");
            E.setAttributeNS(null, "fill-rule", "nonzero");
            var O = g.createNS("http://www.w3.org/2000/svg", "g");
            O.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), O.setAttributeNS(null, "fill", "#000000");
            for (var k = 0, R = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; k < R.length; k += 1) {
              var q = R[k], $ = g.createNS("http://www.w3.org/2000/svg", "ellipse");
              $.setAttributeNS(null, "opacity", "0.04"), $.setAttributeNS(null, "cx", "10.5"), $.setAttributeNS(null, "cy", "5.80029008"), $.setAttributeNS(null, "rx", q.rx), $.setAttributeNS(null, "ry", q.ry), O.appendChild($);
            }
            var H = g.createNS("http://www.w3.org/2000/svg", "g");
            H.setAttributeNS(null, "fill", this._color);
            var ne = g.createNS("http://www.w3.org/2000/svg", "path");
            ne.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), H.appendChild(ne);
            var re = g.createNS("http://www.w3.org/2000/svg", "g");
            re.setAttributeNS(null, "opacity", "0.25"), re.setAttributeNS(null, "fill", "#000000");
            var ue = g.createNS("http://www.w3.org/2000/svg", "path");
            ue.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), re.appendChild(ue);
            var J = g.createNS("http://www.w3.org/2000/svg", "g");
            J.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), J.setAttributeNS(null, "fill", "#FFFFFF");
            var le = g.createNS("http://www.w3.org/2000/svg", "g");
            le.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            var me = g.createNS("http://www.w3.org/2000/svg", "circle");
            me.setAttributeNS(null, "fill", "#000000"), me.setAttributeNS(null, "opacity", "0.25"), me.setAttributeNS(null, "cx", "5.5"), me.setAttributeNS(null, "cy", "5.5"), me.setAttributeNS(null, "r", "5.4999962");
            var _e = g.createNS("http://www.w3.org/2000/svg", "circle");
            _e.setAttributeNS(null, "fill", "#FFFFFF"), _e.setAttributeNS(null, "cx", "5.5"), _e.setAttributeNS(null, "cy", "5.5"), _e.setAttributeNS(null, "r", "5.4999962"), le.appendChild(me), le.appendChild(_e), E.appendChild(O), E.appendChild(H), E.appendChild(re), E.appendChild(J), E.appendChild(le), _.appendChild(E), _.setAttributeNS(null, "height", 41 * this._scale + "px"), _.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(_), this._offset = o.Point.convert(c && c.offset || [0, -14]);
          }
          this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", function(Ae) {
            Ae.preventDefault();
          }), this._element.addEventListener("mousedown", function(Ae) {
            Ae.preventDefault();
          }), Eh(this._element, this._anchor, "marker"), this._popup = null;
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.addTo = function(c) {
          return this.remove(), this._map = c, c.getCanvasContainer().appendChild(this._element), c.on("move", this._update), c.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }, f.prototype.remove = function() {
          return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), g.remove(this._element), this._popup && this._popup.remove(), this;
        }, f.prototype.getLngLat = function() {
          return this._lngLat;
        }, f.prototype.setLngLat = function(c) {
          return this._lngLat = o.LngLat.convert(c), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }, f.prototype.getElement = function() {
          return this._element;
        }, f.prototype.setPopup = function(c) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), c) {
            if (!("offset" in c.options)) {
              var d = Math.sqrt(Math.pow(13.5, 2) / 2);
              c.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [d, -1 * (24.6 + d)], "bottom-right": [-d, -1 * (24.6 + d)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset;
            }
            this._popup = c, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }, f.prototype._onKeyPress = function(c) {
          var d = c.code, _ = c.charCode || c.keyCode;
          d !== "Space" && d !== "Enter" && _ !== 32 && _ !== 13 || this.togglePopup();
        }, f.prototype._onMapClick = function(c) {
          var d = c.originalEvent.target, _ = this._element;
          this._popup && (d === _ || _.contains(d)) && this.togglePopup();
        }, f.prototype.getPopup = function() {
          return this._popup;
        }, f.prototype.togglePopup = function() {
          var c = this._popup;
          return c ? (c.isOpen() ? c.remove() : c.addTo(this._map), this) : this;
        }, f.prototype._update = function(c) {
          if (this._map) {
            this._map.transform.renderWorldCopies && (this._lngLat = tu(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
            var d = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? d = "rotateZ(" + this._rotation + "deg)" : this._rotationAlignment === "map" && (d = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");
            var _ = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? _ = "rotateX(0deg)" : this._pitchAlignment === "map" && (_ = "rotateX(" + this._map.getPitch() + "deg)"), c && c.type !== "moveend" || (this._pos = this._pos.round()), g.setTransform(this._element, wa[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + _ + " " + d);
          }
        }, f.prototype.getOffset = function() {
          return this._offset;
        }, f.prototype.setOffset = function(c) {
          return this._offset = o.Point.convert(c), this._update(), this;
        }, f.prototype._onMove = function(c) {
          if (!this._isDragging) {
            var d = this._clickTolerance || this._map._clickTolerance;
            this._isDragging = c.point.dist(this._pointerdownPos) >= d;
          }
          this._isDragging && (this._pos = c.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.Event("dragstart"))), this.fire(new o.Event("drag")));
        }, f.prototype._onUp = function() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.Event("dragend")), this._state = "inactive";
        }, f.prototype._addDragHandler = function(c) {
          this._element.contains(c.originalEvent.target) && (c.preventDefault(), this._positionDelta = c.point.sub(this._pos).add(this._offset), this._pointerdownPos = c.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
        }, f.prototype.setDraggable = function(c) {
          return this._draggable = !!c, this._map && (c ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }, f.prototype.isDraggable = function() {
          return this._draggable;
        }, f.prototype.setRotation = function(c) {
          return this._rotation = c || 0, this._update(), this;
        }, f.prototype.getRotation = function() {
          return this._rotation;
        }, f.prototype.setRotationAlignment = function(c) {
          return this._rotationAlignment = c || "auto", this._update(), this;
        }, f.prototype.getRotationAlignment = function() {
          return this._rotationAlignment;
        }, f.prototype.setPitchAlignment = function(c) {
          return this._pitchAlignment = c && c !== "auto" ? c : this._rotationAlignment, this._update(), this;
        }, f.prototype.getPitchAlignment = function() {
          return this._pitchAlignment;
        }, f;
      }(o.Evented), hp = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 }, nu = 0, _l = !1, fp = function(u) {
        function f(c) {
          u.call(this), this.options = o.extend({}, hp, c), o.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.onAdd = function(c) {
          var d;
          return this._map = c, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), d = this._setupUI, ru !== void 0 ? d(ru) : o.window.navigator.permissions !== void 0 ? o.window.navigator.permissions.query({ name: "geolocation" }).then(function(_) {
            d(ru = _.state !== "denied");
          }) : d(ru = !!o.window.navigator.geolocation), this._container;
        }, f.prototype.onRemove = function() {
          this._geolocationWatchID !== void 0 && (o.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), g.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, nu = 0, _l = !1;
        }, f.prototype._isOutOfMapMaxBounds = function(c) {
          var d = this._map.getMaxBounds(), _ = c.coords;
          return d && (_.longitude < d.getWest() || _.longitude > d.getEast() || _.latitude < d.getSouth() || _.latitude > d.getNorth());
        }, f.prototype._setErrorState = function() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }, f.prototype._onSuccess = function(c) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(c))
              return this._setErrorState(), this.fire(new o.Event("outofmaxbounds", c)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = c, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(c), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(c), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new o.Event("geolocate", c)), this._finish();
          }
        }, f.prototype._updateCamera = function(c) {
          var d = new o.LngLat(c.coords.longitude, c.coords.latitude), _ = c.coords.accuracy, w = this._map.getBearing(), E = o.extend({ bearing: w }, this.options.fitBoundsOptions);
          this._map.fitBounds(d.toBounds(_), E, { geolocateSource: !0 });
        }, f.prototype._updateMarker = function(c) {
          if (c) {
            var d = new o.LngLat(c.coords.longitude, c.coords.latitude);
            this._accuracyCircleMarker.setLngLat(d).addTo(this._map), this._userLocationDotMarker.setLngLat(d).addTo(this._map), this._accuracy = c.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }, f.prototype._updateCircleRadius = function() {
          var c = this._map._container.clientHeight / 2, d = this._map.unproject([0, c]), _ = this._map.unproject([1, c]), w = d.distanceTo(_), E = Math.ceil(2 * this._accuracy / w);
          this._circleElement.style.width = E + "px", this._circleElement.style.height = E + "px";
        }, f.prototype._onZoom = function() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }, f.prototype._onError = function(c) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (c.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                var d = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = d, this._geolocateButton.setAttribute("aria-label", d), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (c.code === 3 && _l)
                  return;
                this._setErrorState();
              }
            this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new o.Event("error", c)), this._finish();
          }
        }, f.prototype._finish = function() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }, f.prototype._setupUI = function(c) {
          var d = this;
          if (this._container.addEventListener("contextmenu", function(E) {
            return E.preventDefault();
          }), this._geolocateButton = g.create("button", "mapboxgl-ctrl-geolocate", this._container), g.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", !0), this._geolocateButton.type = "button", c === !1) {
            o.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
            var _ = this._map._getUIString("GeolocateControl.LocationNotAvailable");
            this._geolocateButton.disabled = !0, this._geolocateButton.title = _, this._geolocateButton.setAttribute("aria-label", _);
          } else {
            var w = this._map._getUIString("GeolocateControl.FindMyLocation");
            this._geolocateButton.title = w, this._geolocateButton.setAttribute("aria-label", w);
          }
          this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = g.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new uc(this._dotElement), this._circleElement = g.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new uc({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", function(E) {
            E.geolocateSource || d._watchState !== "ACTIVE_LOCK" || E.originalEvent && E.originalEvent.type === "resize" || (d._watchState = "BACKGROUND", d._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), d._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), d.fire(new o.Event("trackuserlocationend")));
          });
        }, f.prototype.trigger = function() {
          if (!this._setup)
            return o.warnOnce("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new o.Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                nu--, _l = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new o.Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.Event("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
              this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              var c;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++nu > 1 ? (c = { maximumAge: 6e5, timeout: 0 }, _l = !0) : (c = this.options.positionOptions, _l = !1), this._geolocationWatchID = o.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, c);
            }
          } else
            o.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }, f.prototype._clearWatch = function() {
          o.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }, f;
      }(o.Evented), Es = { maxWidth: 100, unit: "metric" }, Ss = function(u) {
        this.options = o.extend({}, Es, u), o.bindAll(["_onMove", "setUnit"], this);
      };
      function Sh(u, f, c) {
        var d = c && c.maxWidth || 100, _ = u._container.clientHeight / 2, w = u.unproject([0, _]), E = u.unproject([d, _]), O = w.distanceTo(E);
        if (c && c.unit === "imperial") {
          var k = 3.2808 * O;
          k > 5280 ? Ts(f, d, k / 5280, u._getUIString("ScaleControl.Miles")) : Ts(f, d, k, u._getUIString("ScaleControl.Feet"));
        } else
          c && c.unit === "nautical" ? Ts(f, d, O / 1852, u._getUIString("ScaleControl.NauticalMiles")) : O >= 1e3 ? Ts(f, d, O / 1e3, u._getUIString("ScaleControl.Kilometers")) : Ts(f, d, O, u._getUIString("ScaleControl.Meters"));
      }
      function Ts(u, f, c, d) {
        var _, w, E, O = (_ = c, (w = Math.pow(10, ("" + Math.floor(_)).length - 1)) * (E = (E = _ / w) >= 10 ? 10 : E >= 5 ? 5 : E >= 3 ? 3 : E >= 2 ? 2 : E >= 1 ? 1 : function(k) {
          var R = Math.pow(10, Math.ceil(-Math.log(k) / Math.LN10));
          return Math.round(k * R) / R;
        }(E)));
        u.style.width = f * (O / c) + "px", u.innerHTML = O + "&nbsp;" + d;
      }
      Ss.prototype.getDefaultPosition = function() {
        return "bottom-left";
      }, Ss.prototype._onMove = function() {
        Sh(this._map, this._container, this.options);
      }, Ss.prototype.onAdd = function(u) {
        return this._map = u, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", u.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
      }, Ss.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
      }, Ss.prototype.setUnit = function(u) {
        this.options.unit = u, Sh(this._map, this._container, this.options);
      };
      var Ho = function(u) {
        this._fullscreen = !1, u && u.container && (u.container instanceof o.window.HTMLElement ? this._container = u.container : o.warnOnce("Full screen control 'container' must be a DOM element.")), o.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in o.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in o.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in o.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in o.window.document && (this._fullscreenchange = "MSFullscreenChange");
      };
      Ho.prototype.onAdd = function(u) {
        return this._map = u, this._container || (this._container = this._map.getContainer()), this._controlContainer = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", o.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
      }, Ho.prototype.onRemove = function() {
        g.remove(this._controlContainer), this._map = null, o.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
      }, Ho.prototype._checkFullscreenSupport = function() {
        return !!(o.window.document.fullscreenEnabled || o.window.document.mozFullScreenEnabled || o.window.document.msFullscreenEnabled || o.window.document.webkitFullscreenEnabled);
      }, Ho.prototype._setupUI = function() {
        var u = this._fullscreenButton = g.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
        g.create("span", "mapboxgl-ctrl-icon", u).setAttribute("aria-hidden", !0), u.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), o.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
      }, Ho.prototype._updateTitle = function() {
        var u = this._getTitle();
        this._fullscreenButton.setAttribute("aria-label", u), this._fullscreenButton.title = u;
      }, Ho.prototype._getTitle = function() {
        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
      }, Ho.prototype._isFullscreen = function() {
        return this._fullscreen;
      }, Ho.prototype._changeIcon = function() {
        (o.window.document.fullscreenElement || o.window.document.mozFullScreenElement || o.window.document.webkitFullscreenElement || o.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
      }, Ho.prototype._onClickFullscreen = function() {
        this._isFullscreen() ? o.window.document.exitFullscreen ? o.window.document.exitFullscreen() : o.window.document.mozCancelFullScreen ? o.window.document.mozCancelFullScreen() : o.window.document.msExitFullscreen ? o.window.document.msExitFullscreen() : o.window.document.webkitCancelFullScreen && o.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
      };
      var pp = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, cc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), dp = function(u) {
        function f(c) {
          u.call(this), this.options = o.extend(Object.create(pp), c), o.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
        }
        return u && (f.__proto__ = u), (f.prototype = Object.create(u && u.prototype)).constructor = f, f.prototype.addTo = function(c) {
          return this._map && this.remove(), this._map = c, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.Event("open")), this;
        }, f.prototype.isOpen = function() {
          return !!this._map;
        }, f.prototype.remove = function() {
          return this._content && g.remove(this._content), this._container && (g.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new o.Event("close")), this;
        }, f.prototype.getLngLat = function() {
          return this._lngLat;
        }, f.prototype.setLngLat = function(c) {
          return this._lngLat = o.LngLat.convert(c), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }, f.prototype.trackPointer = function() {
          return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }, f.prototype.getElement = function() {
          return this._container;
        }, f.prototype.setText = function(c) {
          return this.setDOMContent(o.window.document.createTextNode(c));
        }, f.prototype.setHTML = function(c) {
          var d, _ = o.window.document.createDocumentFragment(), w = o.window.document.createElement("body");
          for (w.innerHTML = c; d = w.firstChild; )
            _.appendChild(d);
          return this.setDOMContent(_);
        }, f.prototype.getMaxWidth = function() {
          return this._container && this._container.style.maxWidth;
        }, f.prototype.setMaxWidth = function(c) {
          return this.options.maxWidth = c, this._update(), this;
        }, f.prototype.setDOMContent = function(c) {
          if (this._content)
            for (; this._content.hasChildNodes(); )
              this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else
            this._content = g.create("div", "mapboxgl-popup-content", this._container);
          return this._content.appendChild(c), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }, f.prototype.addClassName = function(c) {
          this._container && this._container.classList.add(c);
        }, f.prototype.removeClassName = function(c) {
          this._container && this._container.classList.remove(c);
        }, f.prototype.setOffset = function(c) {
          return this.options.offset = c, this._update(), this;
        }, f.prototype.toggleClassName = function(c) {
          if (this._container)
            return this._container.classList.toggle(c);
        }, f.prototype._createCloseButton = function() {
          this.options.closeButton && (this._closeButton = g.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }, f.prototype._onMouseUp = function(c) {
          this._update(c.point);
        }, f.prototype._onMouseMove = function(c) {
          this._update(c.point);
        }, f.prototype._onDrag = function(c) {
          this._update(c.point);
        }, f.prototype._update = function(c) {
          var d = this;
          if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = g.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = g.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function($) {
            return d._container.classList.add($);
          }), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = tu(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || c)) {
            var _ = this._pos = this._trackPointer && c ? c : this._map.project(this._lngLat), w = this.options.anchor, E = function $(H) {
              if (H) {
                if (typeof H == "number") {
                  var ne = Math.round(Math.sqrt(0.5 * Math.pow(H, 2)));
                  return { center: new o.Point(0, 0), top: new o.Point(0, H), "top-left": new o.Point(ne, ne), "top-right": new o.Point(-ne, ne), bottom: new o.Point(0, -H), "bottom-left": new o.Point(ne, -ne), "bottom-right": new o.Point(-ne, -ne), left: new o.Point(H, 0), right: new o.Point(-H, 0) };
                }
                if (H instanceof o.Point || Array.isArray(H)) {
                  var re = o.Point.convert(H);
                  return { center: re, top: re, "top-left": re, "top-right": re, bottom: re, "bottom-left": re, "bottom-right": re, left: re, right: re };
                }
                return { center: o.Point.convert(H.center || [0, 0]), top: o.Point.convert(H.top || [0, 0]), "top-left": o.Point.convert(H["top-left"] || [0, 0]), "top-right": o.Point.convert(H["top-right"] || [0, 0]), bottom: o.Point.convert(H.bottom || [0, 0]), "bottom-left": o.Point.convert(H["bottom-left"] || [0, 0]), "bottom-right": o.Point.convert(H["bottom-right"] || [0, 0]), left: o.Point.convert(H.left || [0, 0]), right: o.Point.convert(H.right || [0, 0]) };
              }
              return $(new o.Point(0, 0));
            }(this.options.offset);
            if (!w) {
              var O, k = this._container.offsetWidth, R = this._container.offsetHeight;
              O = _.y + E.bottom.y < R ? ["top"] : _.y > this._map.transform.height - R ? ["bottom"] : [], _.x < k / 2 ? O.push("left") : _.x > this._map.transform.width - k / 2 && O.push("right"), w = O.length === 0 ? "bottom" : O.join("-");
            }
            var q = _.add(E[w]).round();
            g.setTransform(this._container, wa[w] + " translate(" + q.x + "px," + q.y + "px)"), Eh(this._container, w, "popup");
          }
        }, f.prototype._focusFirstElement = function() {
          if (this.options.focusAfterOpen && this._container) {
            var c = this._container.querySelector(cc);
            c && c.focus();
          }
        }, f.prototype._onClose = function() {
          this.remove();
        }, f;
      }(o.Evented), Th = { version: o.version, supported: m, setRTLTextPlugin: o.setRTLTextPlugin, getRTLTextPluginStatus: o.getRTLTextPluginStatus, Map: Dm, NavigationControl: Ga, GeolocateControl: fp, AttributionControl: Gi, ScaleControl: Ss, FullscreenControl: Ho, Popup: dp, Marker: uc, Style: lo, LngLat: o.LngLat, LngLatBounds: o.LngLatBounds, Point: o.Point, MercatorCoordinate: o.MercatorCoordinate, Evented: o.Evented, config: o.config, prewarm: function() {
        Le().acquire(Ce);
      }, clearPrewarmedResources: function() {
        var u = Et;
        u && (u.isPreloaded() && u.numActive() === 1 ? (u.release(Ce), Et = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get accessToken() {
        return o.config.ACCESS_TOKEN;
      }, set accessToken(u) {
        o.config.ACCESS_TOKEN = u;
      }, get baseApiUrl() {
        return o.config.API_URL;
      }, set baseApiUrl(u) {
        o.config.API_URL = u;
      }, get workerCount() {
        return Ue.workerCount;
      }, set workerCount(u) {
        Ue.workerCount = u;
      }, get maxParallelImageRequests() {
        return o.config.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(u) {
        o.config.MAX_PARALLEL_IMAGE_REQUESTS = u;
      }, clearStorage: function(u) {
        o.clearTileCache(u);
      }, workerUrl: "" };
      return Th;
    }), s;
  });
})(NT);
const Kw = NT.exports;
class RT extends TC {
  constructor(e) {
    const n = Object.assign({}, e);
    delete n.accessToken, delete n.style, delete n.container, delete n.xyz, super(n), this.set("xyz", e.maplibreOptions.xyz), this.set("xyz_custom", e.maplibreOptions.xyz_custom), this.xyz_ = e.xyz, e.accessToken && (Kw.accessToken = e.accessToken), this.map_ = new Kw.Map({
      container: e.maplibreOptions.container,
      style: e.maplibreOptions.style,
      attributionControl: !1,
      interactive: !1
    }), this.maplibreMap = this.map_;
  }
  getMapBoxMap() {
    return this.map_;
  }
  getMapLibreMap() {
    return this.map_;
  }
  render(e) {
    const n = this.map_.getCanvas(), a = e.viewState;
    n.style.position = "absolute";
    const s = this.getVisible();
    n.style.display = s ? "block" : "none";
    const h = this.getOpacity().toString();
    h !== n.style.opacity && (n.style.opacity = h);
    const o = a.rotation;
    return o && this.map_.rotateTo(MC(-o), {
      animate: !1
    }), this.map_.jumpTo({
      center: IC(a.center),
      zoom: a.zoom - 1,
      animate: !1
    }), this.map_._frame && (this.map_._frame.cancel(), this.map_._frame = null), this.map_._render(), n;
  }
  setLayerVisibility(e, n) {
    this.map_.setLayoutProperty(
      e,
      "visibility",
      n ? "visible" : "none"
    );
  }
  getStyle() {
    return this.map_.getStyle();
  }
  getXYZ() {
    return this.get("xyz");
  }
}
const $p = /* @__PURE__ */ new Map();
class J4 {
  styleSerialToStyle(e) {
    return e ? JSON.parse(decodeURIComponent(e)) || [] : [];
  }
  styleLocalStorageToStyle(e) {
    return e ? JSON.parse(e).medium || [] : [];
  }
  styleToSerial(e) {
    return e && e.length > 0 ? JSON.stringify(e) : "";
  }
  styleToLocalStorage(e) {
    return e && e.length > 0 ? JSON.stringify({ medium: e }) : "";
  }
}
const Iy = new J4();
function Yw(t, e) {
  let n;
  return (...a) => {
    clearTimeout(n), n = setTimeout(() => {
      t.apply(a);
    }, e);
  };
}
function Mf(t) {
  return (t == null ? void 0 : t.trim()) && !isNaN(Number(t)) ? Number(t) : void 0;
}
function Q4(t, e) {
  return (t == null ? void 0 : t.split(e).map(
    (n) => n !== null && !isNaN(Number(n)) ? parseFloat(n) : void 0
  )) || [];
}
function e5(t, e) {
  return (t == null ? void 0 : t.split(e).map($1)) || [];
}
function $1(t) {
  return (t == null ? void 0 : t.trim()) === "true" ? !0 : (t == null ? void 0 : t.trim()) === "false" ? !1 : void 0;
}
function zT() {
  return window.matchMedia(
    "(-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2), (min-resolution: 192dpi)"
  ).matches;
}
const Zd = "ipv6", Xd = "applogin", Kd = "localforage", If = "debug", Ng = "fid", Au = "lang", Rg = "layersOpen", zg = "address", Y0 = "version", t5 = "map_id", Jw = "layers", Qw = "bgLayer", e2 = "opacities", Nd = "theme", t2 = "time", r2 = "zoom", r5 = "SRS", n2 = "X", i2 = "Y", Fg = "serial", FT = [
  "basemap_2015_global",
  "topogr_global",
  "topo_bw_jpeg"
], J0 = "lc", Q0 = "sliderRatio", BT = "bgOpacity", n5 = "layers_indices", o2 = "layers_opacity", a2 = "layers_visibility";
var oo = /* @__PURE__ */ ((t) => (t[t.localStorage = 0] = "localStorage", t[t.permalink = 1] = "permalink", t[t.permalinkAsPath = 2] = "permalinkAsPath", t[t.permalinkAndLocalStorage = 3] = "permalinkAndLocalStorage", t))(oo || {});
class VT {
}
class Bg extends VT {
  static processRules(e) {
    return Bg.ruleUseLocalStorage(e) ? oo.localStorage : oo.permalink;
  }
  static processRulesForKey(e, n) {
    if (e === Nd && {}.VITE_DEPLOY_GHPAGES !== "true")
      return oo.permalinkAsPath;
    if (FT.includes(e))
      return oo.localStorage;
    if (e === Fg)
      return oo.permalink;
    if (e === Rg)
      return oo.localStorage;
  }
  static ruleUseLocalStorage(e) {
    return [i5, o5, a5].reduce(
      (n, a) => n || a(e),
      !1
    );
  }
}
const i5 = (t) => Object.keys(t).length === 0, o5 = (t) => Object.keys(t).length === 1 && (t.hasOwnProperty(Zd) || t.hasOwnProperty(Xd) || t.hasOwnProperty(Kd)), a5 = (t) => Object.keys(t).length === 3 && t.hasOwnProperty(Zd) && t.hasOwnProperty(Xd) && t.hasOwnProperty(Kd);
class Vg extends VT {
  static processRules() {
    return oo.permalinkAndLocalStorage;
  }
  static processRulesForKey(e, n) {
    if (Vg.ruleUsePermalink(e))
      return oo.permalink;
    if (e === Rg || FT.includes(e))
      return oo.localStorage;
    if (e === Fg)
      return oo.permalink;
    if (e === Nd)
      return oo.permalinkAsPath;
  }
  static ruleUsePermalink(e) {
    return [
      s5,
      l5,
      u5
    ].reduce(
      (n, a) => n || a(e),
      !1
    );
  }
}
const s5 = (t) => t === J0 || t === Q0, l5 = (t) => t === Y0, u5 = (t) => t === Nd && {}.VITE_DEPLOY_GHPAGES === "true";
class UT {
  constructor() {
    bi(this, "snappedUrl");
    this.snappedUrl = new URL(window.location.toString());
  }
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(e) {
    throw new Error("Method key() not implemented. " + e);
  }
  getSnappedUrl() {
    return this.snappedUrl;
  }
  getSnappedParamsAsObj() {
    return this.getSnappedParams().reduce(
      (e, n) => {
        const [a, s] = n.split("=");
        return { ...e, [a]: s };
      },
      {}
    );
  }
  getSnappedParams() {
    return this.getSnappedUrl().search.replace("?", "").split("&").filter((e) => e.split("=")[1]);
  }
  setItem(e, n) {
    const a = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    a.set(encodeURIComponent(e), encodeURIComponent(n));
    try {
      window.history.replaceState(null, "", "?" + a.toString());
    } catch {
    }
  }
  getItem(e) {
    const n = this.getSnappedUrl().searchParams.get(e);
    return n !== null ? decodeURIComponent(n) : n;
  }
  removeItem(e) {
    const n = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    n.delete(e);
    try {
      window.history.replaceState(null, "", "?" + n.toString());
    } catch {
    }
  }
  encodeQueryParam(e, n) {
    return `${encodeURIComponent(e)}=${encodeURIComponent(n)}`;
  }
}
const $_ = new UT();
class c5 extends UT {
  getItem(e) {
    const n = this.getSnappedUrl().pathname.split("/"), a = n.findIndex((s) => s === e);
    return n[a + 1];
  }
  setItem(e, n) {
    const a = new URL(window.location.toString()).search, s = `/${e}/${n}${a}`;
    try {
      window.history.replaceState(null, "", s);
    } catch {
    }
  }
}
const h5 = new c5();
class f5 {
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(e) {
    throw new Error("Method key() not implemented. " + e);
  }
  removeItem(e) {
    const n = this.getWriteStorages(e);
    n == null || n.map(
      (a) => a.removeItem(e)
    );
  }
  setItem(e, n) {
    this.setValue(e, n);
  }
  getItem(e) {
    return this.getValue(e);
  }
  get paramKeys() {
    return $_.getSnappedParamsAsObj();
  }
  getValue(e) {
    var s;
    const n = (s = this.correspondingStorages(
      Bg.processRules(this.paramKeys)
    )) == null ? void 0 : s.pop(), a = this.storageForKey(e, Bg, n);
    return a ? a.getItem(e) : null;
  }
  setValue(e, n) {
    const a = this.getWriteStorages(e);
    a == null || a.map(
      (s) => s.setItem(e, n)
    );
  }
  getWriteStorages(e) {
    const n = this.correspondingStorages(
      Vg.processRules()
    ), a = this.storageForKey(e, Vg);
    return a ? [a] : n;
  }
  storageForKey(e, n, a) {
    var h;
    const s = (h = this.correspondingStorages(
      n.processRulesForKey(e, this.paramKeys)
    )) == null ? void 0 : h.pop();
    return s != null ? s : a;
  }
  correspondingStorages(e) {
    if (e === oo.permalinkAndLocalStorage)
      return [$_, localStorage];
    if (e === oo.localStorage)
      return [localStorage];
    if (e === oo.permalink)
      return [$_];
    if (e === oo.permalinkAsPath)
      return [h5];
  }
}
const Oy = new f5();
function p5(t) {
  return d5(t) || m5(t) || y5(t) || g5(t);
}
const d5 = (t) => Object.keys(t).length === 0, m5 = (t) => {
  const e = Object.keys(t);
  return Object.keys(t).length === 1 && [
    Zd,
    Xd,
    Kd,
    Ng,
    Au,
    zg,
    If
  ].some((n) => e.indexOf(n) !== -1);
}, y5 = (t) => {
  const e = Object.keys(t), n = (s) => e.indexOf(s) !== -1, a = [
    [Xd, Kd],
    [If, Ng],
    [Au, Ng],
    [If, Au],
    [If, zg],
    [Au, zg]
  ];
  return Object.keys(t).length === 2 && a.reduce(
    (s, h) => s || h.every(n),
    !1
  );
}, g5 = (t) => {
  const e = Object.keys(t), n = (o) => e.indexOf(o) !== -1, a = [Zd, Xd, Kd].every(
    n
  ), s = [If, Ng, Au].every(n), h = [If, zg, Au].every(n);
  return Object.keys(t).length === 3 && (a || s || h);
};
class v5 {
  constructor() {
    bi(this, "intialVersion");
    const e = Oy.paramKeys, n = this.getValue(Y0, Mf);
    this.intialVersion = n ? Math.max(2, Math.min(n, 3)) : p5(e) ? 3 : 2, this.setValue(Y0, 3);
  }
  getInitialVersion() {
    return this.intialVersion;
  }
  mapToEntity(e, n) {
    return n ? n(e) : e;
  }
  mapToStorage(e, n) {
    return n ? n(e) : String(e);
  }
  getValue(e, n) {
    return this.mapToEntity(Oy.getValue(e), n);
  }
  setValue(e, n, a) {
    Oy.setValue(e, this.mapToStorage(n, a));
  }
  removeItem(e) {
    Oy.removeItem(e);
  }
}
const Cr = new v5(), _5 = [
  "line",
  "fill",
  "symbol",
  "fill-extrusion",
  "background",
  "hillshade"
], os = () => ({
  bg_layers: [
    {
      icon_id: "route",
      vector_id: "roadmap",
      simple_style_class: "road",
      medium_style_class: "road",
      expert_style_class: "maputnik",
      id: 556,
      is_default: !0
    },
    {
      icon_id: "topo",
      vector_id: "topomap",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 529
    },
    {
      icon_id: "topo_bw",
      vector_id: "topomap_gray",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 502
    },
    {
      icon_id: "ortho",
      id: 530
    },
    {
      icon_id: "hybrid",
      id: 501
    },
    {
      icon_id: "blank",
      id: 0
    }
  ],
  bg_layer_theme_defaults: {
    tourisme: 502
  },
  simple_styles: {
    road: [
      {
        unlocalized_label: "Light grey",
        hillshade: !1,
        colors: [
          "#ffffff",
          "#ffffff",
          "#d6e0d7",
          "#e1e1e1",
          "#cccccc",
          "#f2f2f2"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Dark grey",
        hillshade: !1,
        colors: [
          "#808080",
          "#808080",
          "#494b4a",
          "#505052",
          "#232426",
          "#454545"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Dark sand",
        hillshade: !1,
        colors: [
          "#9e9375",
          "#9e9375",
          "#6b6249",
          "#403928",
          "#b8aa84",
          "#1a1814"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Kids",
        hillshade: !1,
        colors: [
          "#f9c50d",
          "#ffffff",
          "#839836",
          "#d6d3ce",
          "#2a5ba8",
          "#eeeeee"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Light mauve",
        hillshade: !1,
        colors: [
          "#f3edf5",
          "#f3edf5",
          "#9d7da8",
          "#caa9d1",
          "#613b5c",
          "#e5d3e6"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Light Blue",
        hillshade: !1,
        colors: [
          "#dceaf5",
          "#dceaf5",
          "#5598cf",
          "#81b7e3",
          "#3b576e",
          "#b6cde0"
        ],
        selected: !1
      }
    ]
  },
  medium_default_styles: {
    road: [
      {
        label: "Roads primary",
        color: "#f7f7f7",
        lines: [
          "lu_road_trunk_primary",
          "lu_bridge_major",
          "lu_tunnel_major",
          "lu_road_major_motorway"
        ],
        visible: !0
      },
      {
        label: "Roads secondary",
        color: "#f7f7f7",
        lines: [
          "lu_road_minor",
          "lu_road_secondary_tertiary",
          "lu_bridge_minor",
          "lu_road_path",
          "lu_bridge_path",
          "lu_bridge_railway case",
          "lu_bridge_path case"
        ],
        visible: !0
      },
      {
        label: "Vegetation",
        color: "#B8D293",
        opacity: "1",
        fills: [
          "lu_landcover_wood",
          "lu_landcover_grass",
          "lu_landuse_stadium",
          "lu_landuse_cemetery"
        ],
        visible: !0
      },
      {
        label: "Buildings",
        color: "#D6AA85",
        opacity: "1",
        fillExtrusions: ["lu_building-3d_public", "lu_building-3d"],
        fills: ["lu_building", "lu_building_public"],
        lines: ["lu_bridge_railway", "lu_railway", "lu_tunnel_railway"],
        visible: !0
      },
      {
        label: "Water",
        color: "#94c1e1",
        lines: [
          "lu_waterway",
          "lu_waterway_tunnel",
          "lu_waterway_intermittent"
        ],
        fills: ["lu_water"],
        visible: !0
      },
      {
        label: "Background",
        color: "#e7e7e7",
        backgrounds: ["background"],
        visible: !0
      },
      {
        label: "Hillshade",
        hillshades: ["hillshade"],
        visible: !0
      }
    ],
    topo: [
      {
        label: "Primary Names",
        symbols: [
          "lu_place-label_other",
          "lu_place-label_city",
          "lu_place-label_canton",
          "lu_country-label-other",
          "lu_country-label",
          "place_label_other",
          "place_label_city",
          "country_label-other",
          "country_label"
        ],
        visible: !0
      },
      {
        label: "Secondary Names",
        symbols: [
          "lu_place-label_isolated",
          "lu_place-label_locality_forest",
          "lu_place-label_locality_lieudit"
        ],
        visible: !0
      },
      {
        label: "Transport",
        lines: [
          "lu_tunnel_track-casing",
          "lu_tunnel_major_motorway-casing",
          "lu_tunnel_railway_transit",
          "lu_tunnel_railway",
          "lu_tunnel_railway-hatching",
          "lu_tunnel_path",
          "lu_tunnel_track",
          "lu_tunnel_minor",
          "lu_tunnel_major_motorway",
          "lu_tunnel_secondary_tertiary",
          "lu_tunnel_trunk_primary",
          "lu_road_track-casing",
          "lu_road_minor-casing",
          "lu_road_major_motorway-casing",
          "lu_road_secondary_tertiary-casing",
          "lu_road_trunk_primary-casing",
          "lu_road_pier",
          "lu_road_path",
          "lu_road_track",
          "lu_road_minor",
          "lu_road_major_motorway",
          "lu_road_secondary_tertiary",
          "lu_road_trunk_primary",
          "lu_tram",
          "lu_tram-hatching",
          "lu_railway_transit",
          "lu_railway",
          "lu_railway-hatching",
          "lu_bridge_railway-casing",
          "lu_bridge_track-casing",
          "lu_bridge_path-casing",
          "lu_bridge_minor-casing",
          "lu_bridge_major_motorway-casing",
          "lu_bridge_secondary_tertiary-casing",
          "lu_bridge_trunk_primary-casing",
          "lu_bridge_railway",
          "lu_bridge_path",
          "lu_bridge_track",
          "lu_bridge_minor",
          "lu_bridge_major_motorway",
          "lu_bridge_secondary_tertiary",
          "lu_bridge_trunk_primary",
          "tunnel_track-casing",
          "tunnel_major_motorway-casing",
          "tunnel_railway_transit",
          "tunnel_railway_transit-hatching",
          "tunnel_railway",
          "tunnel_railway-hatching",
          "tunnel_path",
          "tunnel_track",
          "tunnel_minor",
          "tunnel_major_motorway",
          "tunnel_secondary_tertiary",
          "tunnel_trunk_primary",
          "road_track-casing",
          "road_minor-casing",
          "road_major_motorway-casing",
          "road_secondary_tertiary-casing",
          "road_trunk_primary-casing",
          "road_pier",
          "road_path",
          "road_track",
          "road_minor",
          "road_major_motorway",
          "road_secondary_tertiary",
          "road_trunk_primary",
          "railway-transit",
          "railway-transit-hatching",
          "railway",
          "railway-hatching",
          "bridge_railway-casing",
          "bridge_path-casing",
          "bridge_track_casing",
          "bridge_minor-casing",
          "bridge_major_motorway-casing",
          "bridge_secondary_tertiary-casing",
          "bridge_trunk_primary-casing",
          "bridge_railway",
          "bridge_path",
          "bridge_track",
          "bridge_minor",
          "bridge_major_motorway",
          "bridge_secondary_tertiary",
          "bridge_trunk_primary"
        ],
        symbols: [
          "lu_road_major-label",
          "lu_motorway-shield",
          "lu_road-shield"
        ],
        visible: !0
      },
      {
        label: "Vegetation",
        fills: [
          "lu_landuse_stadium",
          "lu_landuse_cemetery",
          "lu_landuse_gras",
          "lu_landuse_park",
          "lu_landuse_park-outline",
          "lu_landuse_vineyard",
          "lu_landuse_orchard",
          "lu_landuse_wood",
          "landcover_grass",
          "landcover_wood"
        ],
        visible: !0
      },
      {
        label: "Electricity",
        fills: ["lu_power_station", "lu_power_pylone"],
        lines: ["lu_power_line", "lu_power_station-outline"],
        symbols: ["lu_power_station-label", "lu_eolienne"],
        visible: !0
      },
      {
        label: "Contours and Height Points",
        lines: [
          "lu_contour-100",
          "lu_contour-50",
          "lu_contour-20",
          "lu_contour-10",
          "lu_contour"
        ],
        symbols: [
          "lu_contour-label-100",
          "lu_contour-label-20",
          "lu_apex-label"
        ],
        visible: !0
      },
      {
        label: "Hillshade",
        hillshades: ["lu_hillshade"],
        visible: !0
      }
    ]
  },
  http_bg_server: "wmts{1-2}",
  https_bg_server: "wmts{3-4}",
  bg_wmts_server_path: "mapproxy_4_v3/wmts/{Layer}",
  bg_wmts_tile_template: "{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}",
  bg_layer_projection: "EPSG:3857",
  olcs_extent: [5.31, 49.38, 6.64, 50.21],
  olcs_extent_projection: "EPSG:3857",
  bg_layer_resolutions: [
    156543.033928,
    78271.516964,
    39135.758482,
    19567.879241,
    9783.9396205,
    4891.96981025,
    2445.98490513,
    1222.99245256,
    611.496226281,
    305.748113141,
    152.87405657,
    76.4370282852,
    38.2185141426,
    19.1092570713,
    9.55462853565,
    4.77731426782,
    2.38865713391,
    1.19432856696,
    0.597164283478,
    0.298582141739,
    0.1492910708695,
    0.07464553543475
  ],
  bg_matrix_ids: [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "20",
    "21"
  ]
});
function Ff() {
  function t(V) {
    const W = new URLSearchParams(document.location.search), X = W.get("embeddedserver"), K = W.get("embeddedserverprotocol") || "http";
    return (X ? `${K}://${X}` : "https://vectortiles.geoportail.lu") + `/styles/${V}/style.json`;
  }
  function e(V) {
    return `https://vectortiles.geoportail.lu/styles/${V}/{z}/{x}/{y}.png`;
  }
  function n(V) {
    return /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/gi.test(V);
  }
  const a = Hs();
  function s(V, W) {
    if (V == null)
      return;
    const X = /* @__PURE__ */ new Map();
    a.bgVectorSources.forEach((K, se) => {
      if (se === V.id) {
        const pe = { ...K, xyz_custom: W };
        X.set(se, pe);
      } else
        X.set(se, K);
    }), a.setBgVectorSources(X);
  }
  function h(V, W, X = !1) {
    const K = "", se = t(W), pe = e(W), xe = {
      label: V,
      defaultMapBoxStyle: se,
      defaultMapBoxStyleXYZ: pe,
      xyz: pe,
      xyz_custom: K,
      style: se
    }, Fe = new URLSearchParams(window.location.search).get("serial"), ze = new URLSearchParams(window.location.search).get(
      "serialLayer"
    );
    if (Fe)
      n(Fe) && console.log(ze);
    else if (!X)
      return Promise.resolve(xe);
    return Promise.resolve(xe);
  }
  function o(V) {
    const W = os().medium_default_styles.road;
    if (V) {
      V.colors.forEach((K, se) => {
        W[se].color = K;
      });
      const X = W.findIndex(
        (K) => K.label === "Hillshade"
      );
      W[X].visible = V.hillshade;
    }
    return W;
  }
  function m(V, W, X) {
    if (!V || !W.get(V.id))
      return;
    const K = JSON.parse(
      JSON.stringify(W.get(V.id))
    );
    if (!!K && !(!K || !K.layers))
      return X && X.forEach((se) => {
        K == null || K.layers.forEach((pe, xe) => {
          for (const Fe of _5)
            if ((se[`${Fe}s`] || []).includes(pe.id)) {
              const Pe = Object.assign(
                {},
                K.layers[xe].paint
              );
              se.color && (Pe[`${Fe}-color`] = se.color, Pe[`${Fe}-opacity`] = 1, K.layers[xe].paint = Pe), K.layers[xe].layout = Object.assign(
                {},
                K.layers[xe].layout,
                { visibility: se.visible ? "visible" : "none" }
              );
            }
        });
      }), K;
  }
  function g(V, W) {
    if (V === null)
      return Promise.resolve();
    {
      const X = `${W.get("delete")}?id=${V}`;
      return fetch(X).catch(() => "");
    }
  }
  function b(V, W, X) {
    return g(W, X).then(() => {
      const K = new FormData(), se = JSON.stringify(V), pe = new Blob([se], { type: "application/json" });
      K.append("style", pe, "style.json");
      const xe = {
        method: "POST",
        body: K
      };
      return fetch(X.get("upload") || "", xe).then((Fe) => Fe.json()).then((Fe) => Fe.id);
    });
  }
  function T(V, W) {
    if (!W)
      return;
    const X = V.maplibreMap;
    !X || (X.loaded() ? X.setStyle(W) : new Promise((K) => X.once("data", K)).then(
      () => X.setStyle(W)
    ));
  }
  function M(V) {
    const W = os().bg_layers.find(
      (X) => X.id == (V == null ? void 0 : V.id)
    );
    return W == null ? void 0 : W.vector_id;
  }
  function I(V) {
    const W = os().bg_layers.find(
      (X) => X.id == (V == null ? void 0 : V.id)
    );
    return (W == null ? void 0 : W.vector_id) !== void 0;
  }
  function P(V) {
    const W = os().bg_layers.find(
      (X) => X.id == (V == null ? void 0 : V.id)
    );
    return {
      isEditable: (W == null ? void 0 : W.vector_id) !== void 0,
      hasSimpleStyle: (W == null ? void 0 : W.simple_style_class) !== void 0,
      hasAdvancedStyle: (W == null ? void 0 : W.medium_style_class) !== void 0,
      hasExpertStyle: (W == null ? void 0 : W.expert_style_class) !== void 0
    };
  }
  function z(V, W) {
    return W.map(
      (X) => Object.assign(X, {
        selected: X.colors.every(
          (K, se) => {
            var pe;
            return ((pe = V[se]) == null ? void 0 : pe.color) === K;
          }
        )
      })
    );
  }
  return {
    getDefaultMapBoxStyleUrl: t,
    getDefaultMapBoxStyleXYZ: e,
    setConfigForLayer: h,
    getRoadStyleFromSimpleStyle: o,
    applyDefaultStyle: m,
    applyConsolidatedStyle: T,
    getVectorId: M,
    setCustomStyleSerial: s,
    unregisterStyle: g,
    registerStyle: b,
    checkSelection: z,
    isLayerStyleEditable: I,
    getStyleCapabilitiesFromLayer: P
  };
}
const Hs = rh(
  "style",
  () => {
    const t = Ff(), e = Fn(), n = Fn(/* @__PURE__ */ new Map()), a = Fn(
      /* @__PURE__ */ new Map()
    ), s = Fn(!1), h = Fn(null), o = Fn(), m = Fn(
      /* @__PURE__ */ new Map([
        ["get", "/getvtstyle"],
        ["upload", "/uploadvtstyle"],
        ["delete", "/deletevtstyle"]
      ])
    ), g = [];
    os().bg_layers.forEach((X) => {
      if (X.vector_id) {
        const K = t.setConfigForLayer(
          X.icon_id,
          X.vector_id
        );
        g.push(
          K.then((se) => ({ id: X.id, config: se }))
        );
      }
    }), Promise.all(g).then((X) => {
      const K = /* @__PURE__ */ new Map();
      X.forEach((se) => K.set(se.id, se.config)), n.value = K;
    });
    function b(X, K) {
      m.value.set(X, K);
    }
    function T(X) {
      n.value = X;
    }
    function M(X) {
      const K = /* @__PURE__ */ new Map();
      a.value.forEach((se, pe) => {
        pe !== X && K.set(pe, se);
      }), a.value = K;
    }
    function I(X, K) {
      const se = /* @__PURE__ */ new Map();
      a.value.forEach(
        (pe, xe) => se.set(xe, pe)
      ), se.set(X, K), a.value = se;
    }
    function P(X) {
      e.value = t.getRoadStyleFromSimpleStyle(X), V();
    }
    function z(X) {
      e.value = X, V();
    }
    function V() {
      s.value = !1;
    }
    function W() {
      s.value = !0;
    }
    return {
      bgStyle: e,
      bgVectorSources: n,
      bgVectorBaseStyles: a,
      isExpertStyleActive: s,
      appliedStyle: o,
      removeBaseStyle: M,
      setBaseStyle: I,
      setBgVectorSources: T,
      setRegisterUrl: b,
      setSimpleStyle: P,
      setStyle: z,
      disableExpertStyle: V,
      enableExpertStyle: W,
      styleSerial: h,
      registerUrls: m
    };
  },
  {}
);
function x5(t, {
  i18next: e,
  rerenderOn: n = ["languageChanged", "loaded", "added", "removed"]
}) {
  const a = e.t.bind(e), s = Mr(new Date()), h = () => s.value = new Date(), o = () => s.value;
  n.forEach((T) => {
    var M;
    switch (T) {
      case "added":
      case "removed":
        (M = e.store) == null || M.on(T, h);
        break;
      default:
        e.on(T, h);
        break;
    }
  }), t.component("i18next", b5), t.mixin({
    beforeCreate() {
      var T, M;
      const I = this.$options;
      if (!I.__i18n && !I.i18nOptions) {
        this.__translate = void 0;
        return;
      }
      const P = this.$options.name, z = (Math.random() * 10 ** 8 | 0).toString(), V = [P, z].filter((xe) => !!xe).join("-");
      this.__bundles = [];
      const W = (xe) => {
        Object.entries(xe).forEach(([Fe, ze]) => {
          e.addResourceBundle(Fe, V, ze, !0, !1), this.__bundles.push([Fe, V]);
        });
      };
      (T = I.__i18n) == null || T.forEach((xe) => {
        W(JSON.parse(xe));
      });
      let { lng: X, ns: K, keyPrefix: se } = b(I, W);
      (M = this.__bundles) != null && M.length && (K = [V].concat(K != null ? K : []));
      const pe = m(X, K);
      this.__translate = (xe, Fe) => !se || g(xe) ? pe(xe, Fe) : pe(se + "." + xe, Fe);
    },
    unmounted() {
      var T;
      (T = this.__bundles) == null || T.forEach(([M, I]) => e.removeResourceBundle(M, I));
    }
  }), t.config.globalProperties.$t = function(T, M) {
    var I;
    return o(), e.isInitialized ? ((I = this == null ? void 0 : this.__translate) != null ? I : a)(T, M) : T;
  }, t.config.globalProperties.$i18next = new Proxy(e, {
    get(T, M) {
      return o(), Reflect.get(T, M);
    }
  });
  function m(T, M) {
    return T ? e.getFixedT(T, M) : M ? e.getFixedT(null, M) : a;
  }
  function g(T) {
    const M = e.options.nsSeparator;
    return typeof M == "string" && T.includes(M);
  }
  function b(T, M) {
    let I, P, z;
    if (T.i18nOptions) {
      let V, W;
      ({
        lng: I,
        namespaces: W = e.options.defaultNS,
        keyPrefix: z,
        messages: V
      } = T.i18nOptions), V && M(V), P = typeof W == "string" ? [W] : W, P && e.loadNamespaces(P);
    }
    return { lng: I, ns: P, keyPrefix: z };
  }
}
function In() {
  const t = vv();
  if (!t)
    throw new Error("i18next-vue: No Vue instance in context. Make sure to register the i18next-vue plugin using app.use(...).");
  const e = t.appContext.config.globalProperties;
  return {
    i18next: e.$i18next,
    t: e.$t.bind(t.proxy)
  };
}
var s2 = new RegExp("{\\s*([a-z0-9\\-]+)\\s*}", "gi"), b5 = or({
  props: {
    translation: {
      type: String,
      required: !0
    }
  },
  setup(t, { slots: e }) {
    return () => {
      const n = t.translation, a = [];
      let s, h = 0;
      for (; (s = s2.exec(n)) !== null; ) {
        a.push(n.substring(h, s.index));
        const o = e[s[1]];
        o ? a.push(...o()) : a.push(s[0]), h = s2.lastIndex;
      }
      return a.push(n.substring(h)), a;
    };
  }
});
class nh extends Error {
}
class w5 extends nh {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class E5 extends nh {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class S5 extends nh {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class rd extends nh {
}
class jT extends nh {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class Pa extends nh {
}
class du extends nh {
  constructor() {
    super("Zone is an abstract class");
  }
}
const Ot = "numeric", hs = "short", ga = "long", Ug = {
  year: Ot,
  month: Ot,
  day: Ot
}, GT = {
  year: Ot,
  month: hs,
  day: Ot
}, T5 = {
  year: Ot,
  month: hs,
  day: Ot,
  weekday: hs
}, qT = {
  year: Ot,
  month: ga,
  day: Ot
}, $T = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga
}, WT = {
  hour: Ot,
  minute: Ot
}, HT = {
  hour: Ot,
  minute: Ot,
  second: Ot
}, ZT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: hs
}, XT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: ga
}, KT = {
  hour: Ot,
  minute: Ot,
  hourCycle: "h23"
}, YT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23"
}, JT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23",
  timeZoneName: hs
}, QT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23",
  timeZoneName: ga
}, eM = {
  year: Ot,
  month: Ot,
  day: Ot,
  hour: Ot,
  minute: Ot
}, tM = {
  year: Ot,
  month: Ot,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot
}, rM = {
  year: Ot,
  month: hs,
  day: Ot,
  hour: Ot,
  minute: Ot
}, nM = {
  year: Ot,
  month: hs,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot
}, M5 = {
  year: Ot,
  month: hs,
  day: Ot,
  weekday: hs,
  hour: Ot,
  minute: Ot
}, iM = {
  year: Ot,
  month: ga,
  day: Ot,
  hour: Ot,
  minute: Ot,
  timeZoneName: hs
}, oM = {
  year: Ot,
  month: ga,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: hs
}, aM = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga,
  hour: Ot,
  minute: Ot,
  timeZoneName: ga
}, sM = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga,
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: ga
};
class Yd {
  get type() {
    throw new du();
  }
  get name() {
    throw new du();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new du();
  }
  offsetName(e, n) {
    throw new du();
  }
  formatOffset(e, n) {
    throw new du();
  }
  offset(e) {
    throw new du();
  }
  equals(e) {
    throw new du();
  }
  get isValid() {
    throw new du();
  }
}
let W_ = null;
class Tv extends Yd {
  static get instance() {
    return W_ === null && (W_ = new Tv()), W_;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: n, locale: a }) {
    return uM(e, n, a);
  }
  formatOffset(e, n) {
    return gd(this.offset(e), n);
  }
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  equals(e) {
    return e.type === "system";
  }
  get isValid() {
    return !0;
  }
}
let sg = {};
function I5(t) {
  return sg[t] || (sg[t] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: t,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), sg[t];
}
const O5 = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function C5(t, e) {
  const n = t.format(e).replace(/\u200E/g, ""), a = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n), [, s, h, o, m, g, b, T] = a;
  return [o, s, h, m, g, b, T];
}
function A5(t, e) {
  const n = t.formatToParts(e), a = [];
  for (let s = 0; s < n.length; s++) {
    const { type: h, value: o } = n[s], m = O5[h];
    h === "era" ? a[m] = o : Hr(m) || (a[m] = parseInt(o, 10));
  }
  return a;
}
let Cy = {};
class Ul extends Yd {
  static create(e) {
    return Cy[e] || (Cy[e] = new Ul(e)), Cy[e];
  }
  static resetCache() {
    Cy = {}, sg = {};
  }
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  static isValidZone(e) {
    if (!e)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = Ul.isValidZone(e);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: n, locale: a }) {
    return uM(e, n, a, this.name);
  }
  formatOffset(e, n) {
    return gd(this.offset(e), n);
  }
  offset(e) {
    const n = new Date(e);
    if (isNaN(n))
      return NaN;
    const a = I5(this.name);
    let [s, h, o, m, g, b, T] = a.formatToParts ? A5(a, n) : C5(a, n);
    m === "BC" && (s = -Math.abs(s) + 1);
    const I = Iv({
      year: s,
      month: h,
      day: o,
      hour: g === 24 ? 0 : g,
      minute: b,
      second: T,
      millisecond: 0
    });
    let P = +n;
    const z = P % 1e3;
    return P -= z >= 0 ? z : 1e3 + z, (I - P) / (60 * 1e3);
  }
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
}
let l2 = {};
function P5(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let a = l2[n];
  return a || (a = new Intl.ListFormat(t, e), l2[n] = a), a;
}
let e1 = {};
function t1(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let a = e1[n];
  return a || (a = new Intl.DateTimeFormat(t, e), e1[n] = a), a;
}
let r1 = {};
function k5(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let a = r1[n];
  return a || (a = new Intl.NumberFormat(t, e), r1[n] = a), a;
}
let n1 = {};
function L5(t, e = {}) {
  const { base: n, ...a } = e, s = JSON.stringify([t, a]);
  let h = n1[s];
  return h || (h = new Intl.RelativeTimeFormat(t, e), n1[s] = h), h;
}
let nd = null;
function D5() {
  return nd || (nd = new Intl.DateTimeFormat().resolvedOptions().locale, nd);
}
function N5(t) {
  const e = t.indexOf("-x-");
  e !== -1 && (t = t.substring(0, e));
  const n = t.indexOf("-u-");
  if (n === -1)
    return [t];
  {
    let a, s;
    try {
      a = t1(t).resolvedOptions(), s = t;
    } catch {
      const g = t.substring(0, n);
      a = t1(g).resolvedOptions(), s = g;
    }
    const { numberingSystem: h, calendar: o } = a;
    return [s, h, o];
  }
}
function R5(t, e, n) {
  return (n || e) && (t.includes("-u-") || (t += "-u"), n && (t += `-ca-${n}`), e && (t += `-nu-${e}`)), t;
}
function z5(t) {
  const e = [];
  for (let n = 1; n <= 12; n++) {
    const a = br.utc(2009, n, 1);
    e.push(t(a));
  }
  return e;
}
function F5(t) {
  const e = [];
  for (let n = 1; n <= 7; n++) {
    const a = br.utc(2016, 11, 13 + n);
    e.push(t(a));
  }
  return e;
}
function Ay(t, e, n, a) {
  const s = t.listingMode();
  return s === "error" ? null : s === "en" ? n(e) : a(e);
}
function B5(t) {
  return t.numberingSystem && t.numberingSystem !== "latn" ? !1 : t.numberingSystem === "latn" || !t.locale || t.locale.startsWith("en") || new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem === "latn";
}
class V5 {
  constructor(e, n, a) {
    this.padTo = a.padTo || 0, this.floor = a.floor || !1;
    const { padTo: s, floor: h, ...o } = a;
    if (!n || Object.keys(o).length > 0) {
      const m = { useGrouping: !1, ...a };
      a.padTo > 0 && (m.minimumIntegerDigits = a.padTo), this.inf = k5(e, m);
    }
  }
  format(e) {
    if (this.inf) {
      const n = this.floor ? Math.floor(e) : e;
      return this.inf.format(n);
    } else {
      const n = this.floor ? Math.floor(e) : H1(e, 3);
      return Ci(n, this.padTo);
    }
  }
}
class U5 {
  constructor(e, n, a) {
    this.opts = a, this.originalZone = void 0;
    let s;
    if (this.opts.timeZone)
      this.dt = e;
    else if (e.zone.type === "fixed") {
      const o = -1 * (e.offset / 60), m = o >= 0 ? `Etc/GMT+${o}` : `Etc/GMT${o}`;
      e.offset !== 0 && Ul.create(m).valid ? (s = m, this.dt = e) : (s = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    } else
      e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, s = e.zone.name) : (s = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    const h = { ...this.opts };
    h.timeZone = h.timeZone || s, this.dtf = t1(n, h);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? e.map((n) => {
      if (n.type === "timeZoneName") {
        const a = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...n,
          value: a
        };
      } else
        return n;
    }) : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class j5 {
  constructor(e, n, a) {
    this.opts = { style: "long", ...a }, !n && lM() && (this.rtf = L5(e, a));
  }
  format(e, n) {
    return this.rtf ? this.rtf.format(e, n) : az(n, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, n) {
    return this.rtf ? this.rtf.formatToParts(e, n) : [];
  }
}
class zn {
  static fromOpts(e) {
    return zn.create(e.locale, e.numberingSystem, e.outputCalendar, e.defaultToEN);
  }
  static create(e, n, a, s = !1) {
    const h = e || Oi.defaultLocale, o = h || (s ? "en-US" : D5()), m = n || Oi.defaultNumberingSystem, g = a || Oi.defaultOutputCalendar;
    return new zn(o, m, g, h);
  }
  static resetCache() {
    nd = null, e1 = {}, r1 = {}, n1 = {};
  }
  static fromObject({ locale: e, numberingSystem: n, outputCalendar: a } = {}) {
    return zn.create(e, n, a);
  }
  constructor(e, n, a, s) {
    const [h, o, m] = N5(e);
    this.locale = h, this.numberingSystem = n || o || null, this.outputCalendar = a || m || null, this.intl = R5(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = s, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = B5(this)), this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish(), n = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && n ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : zn.create(
      e.locale || this.specifiedLocale,
      e.numberingSystem || this.numberingSystem,
      e.outputCalendar || this.outputCalendar,
      e.defaultToEN || !1
    );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, n = !1) {
    return Ay(this, e, fM, () => {
      const a = n ? { month: e, day: "numeric" } : { month: e }, s = n ? "format" : "standalone";
      return this.monthsCache[s][e] || (this.monthsCache[s][e] = z5((h) => this.extract(h, a, "month"))), this.monthsCache[s][e];
    });
  }
  weekdays(e, n = !1) {
    return Ay(this, e, mM, () => {
      const a = n ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, s = n ? "format" : "standalone";
      return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = F5(
        (h) => this.extract(h, a, "weekday")
      )), this.weekdaysCache[s][e];
    });
  }
  meridiems() {
    return Ay(
      this,
      void 0,
      () => yM,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [br.utc(2016, 11, 13, 9), br.utc(2016, 11, 13, 19)].map(
            (n) => this.extract(n, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return Ay(this, e, gM, () => {
      const n = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [br.utc(-40, 1, 1), br.utc(2017, 1, 1)].map(
        (a) => this.extract(a, n, "era")
      )), this.eraCache[e];
    });
  }
  extract(e, n, a) {
    const s = this.dtFormatter(e, n), h = s.formatToParts(), o = h.find((m) => m.type.toLowerCase() === a);
    return o ? o.value : null;
  }
  numberFormatter(e = {}) {
    return new V5(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, n = {}) {
    return new U5(e, this.intl, n);
  }
  relFormatter(e = {}) {
    return new j5(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return P5(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
}
let H_ = null;
class Fo extends Yd {
  static get utcInstance() {
    return H_ === null && (H_ = new Fo(0)), H_;
  }
  static instance(e) {
    return e === 0 ? Fo.utcInstance : new Fo(e);
  }
  static parseSpecifier(e) {
    if (e) {
      const n = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (n)
        return new Fo(Ov(n[1], n[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${gd(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${gd(-this.fixed, "narrow")}`;
  }
  offsetName() {
    return this.name;
  }
  formatOffset(e, n) {
    return gd(this.fixed, n);
  }
  get isUniversal() {
    return !0;
  }
  offset() {
    return this.fixed;
  }
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  get isValid() {
    return !0;
  }
}
class G5 extends Yd {
  constructor(e) {
    super(), this.zoneName = e;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return !1;
  }
  get isValid() {
    return !1;
  }
}
function Su(t, e) {
  if (Hr(t) || t === null)
    return e;
  if (t instanceof Yd)
    return t;
  if (q5(t)) {
    const n = t.toLowerCase();
    return n === "default" ? e : n === "local" || n === "system" ? Tv.instance : n === "utc" || n === "gmt" ? Fo.utcInstance : Fo.parseSpecifier(n) || Ul.create(t);
  } else
    return Wc(t) ? Fo.instance(t) : typeof t == "object" && "offset" in t && typeof t.offset == "function" ? t : new G5(t);
}
let u2 = () => Date.now(), c2 = "system", h2 = null, f2 = null, p2 = null, d2 = 60, m2;
class Oi {
  static get now() {
    return u2;
  }
  static set now(e) {
    u2 = e;
  }
  static set defaultZone(e) {
    c2 = e;
  }
  static get defaultZone() {
    return Su(c2, Tv.instance);
  }
  static get defaultLocale() {
    return h2;
  }
  static set defaultLocale(e) {
    h2 = e;
  }
  static get defaultNumberingSystem() {
    return f2;
  }
  static set defaultNumberingSystem(e) {
    f2 = e;
  }
  static get defaultOutputCalendar() {
    return p2;
  }
  static set defaultOutputCalendar(e) {
    p2 = e;
  }
  static get twoDigitCutoffYear() {
    return d2;
  }
  static set twoDigitCutoffYear(e) {
    d2 = e % 100;
  }
  static get throwOnInvalid() {
    return m2;
  }
  static set throwOnInvalid(e) {
    m2 = e;
  }
  static resetCaches() {
    zn.resetCache(), Ul.resetCache();
  }
}
function Hr(t) {
  return typeof t > "u";
}
function Wc(t) {
  return typeof t == "number";
}
function Mv(t) {
  return typeof t == "number" && t % 1 === 0;
}
function q5(t) {
  return typeof t == "string";
}
function $5(t) {
  return Object.prototype.toString.call(t) === "[object Date]";
}
function lM() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function W5(t) {
  return Array.isArray(t) ? t : [t];
}
function y2(t, e, n) {
  if (t.length !== 0)
    return t.reduce((a, s) => {
      const h = [e(s), s];
      return a && n(a[0], h[0]) === a[0] ? a : h;
    }, null)[1];
}
function H5(t, e) {
  return e.reduce((n, a) => (n[a] = t[a], n), {});
}
function Nf(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function Nl(t, e, n) {
  return Mv(t) && t >= e && t <= n;
}
function Z5(t, e) {
  return t - e * Math.floor(t / e);
}
function Ci(t, e = 2) {
  const n = t < 0;
  let a;
  return n ? a = "-" + ("" + -t).padStart(e, "0") : a = ("" + t).padStart(e, "0"), a;
}
function xu(t) {
  if (!(Hr(t) || t === null || t === ""))
    return parseInt(t, 10);
}
function Ic(t) {
  if (!(Hr(t) || t === null || t === ""))
    return parseFloat(t);
}
function W1(t) {
  if (!(Hr(t) || t === null || t === "")) {
    const e = parseFloat("0." + t) * 1e3;
    return Math.floor(e);
  }
}
function X5(t) {
  return t > 0 ? Math.floor(t) : Math.ceil(t);
}
function H1(t, e, n = !1) {
  const a = 10 ** e;
  return (n ? Math.trunc : Math.round)(t * a) / a;
}
function Jd(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function yd(t) {
  return Jd(t) ? 366 : 365;
}
function jg(t, e) {
  const n = Z5(e - 1, 12) + 1, a = t + (e - n) / 12;
  return n === 2 ? Jd(a) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1];
}
function Iv(t) {
  let e = Date.UTC(
    t.year,
    t.month - 1,
    t.day,
    t.hour,
    t.minute,
    t.second,
    t.millisecond
  );
  return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(t.year, t.month - 1, t.day)), +e;
}
function Gg(t) {
  const e = (t + Math.floor(t / 4) - Math.floor(t / 100) + Math.floor(t / 400)) % 7, n = t - 1, a = (n + Math.floor(n / 4) - Math.floor(n / 100) + Math.floor(n / 400)) % 7;
  return e === 4 || a === 3 ? 53 : 52;
}
function i1(t) {
  return t > 99 ? t : t > Oi.twoDigitCutoffYear ? 1900 + t : 2e3 + t;
}
function uM(t, e, n, a = null) {
  const s = new Date(t), h = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  a && (h.timeZone = a);
  const o = { timeZoneName: e, ...h }, m = new Intl.DateTimeFormat(n, o).formatToParts(s).find((g) => g.type.toLowerCase() === "timezonename");
  return m ? m.value : null;
}
function Ov(t, e) {
  let n = parseInt(t, 10);
  Number.isNaN(n) && (n = 0);
  const a = parseInt(e, 10) || 0, s = n < 0 || Object.is(n, -0) ? -a : a;
  return n * 60 + s;
}
function cM(t) {
  const e = Number(t);
  if (typeof t == "boolean" || t === "" || Number.isNaN(e))
    throw new Pa(`Invalid unit value ${t}`);
  return e;
}
function qg(t, e) {
  const n = {};
  for (const a in t)
    if (Nf(t, a)) {
      const s = t[a];
      if (s == null)
        continue;
      n[e(a)] = cM(s);
    }
  return n;
}
function gd(t, e) {
  const n = Math.trunc(Math.abs(t / 60)), a = Math.trunc(Math.abs(t % 60)), s = t >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${s}${Ci(n, 2)}:${Ci(a, 2)}`;
    case "narrow":
      return `${s}${n}${a > 0 ? `:${a}` : ""}`;
    case "techie":
      return `${s}${Ci(n, 2)}${Ci(a, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function Cv(t) {
  return H5(t, ["hour", "minute", "second", "millisecond"]);
}
const K5 = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], hM = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], Y5 = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function fM(t) {
  switch (t) {
    case "narrow":
      return [...Y5];
    case "short":
      return [...hM];
    case "long":
      return [...K5];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const pM = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], dM = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], J5 = ["M", "T", "W", "T", "F", "S", "S"];
function mM(t) {
  switch (t) {
    case "narrow":
      return [...J5];
    case "short":
      return [...dM];
    case "long":
      return [...pM];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const yM = ["AM", "PM"], Q5 = ["Before Christ", "Anno Domini"], ez = ["BC", "AD"], tz = ["B", "A"];
function gM(t) {
  switch (t) {
    case "narrow":
      return [...tz];
    case "short":
      return [...ez];
    case "long":
      return [...Q5];
    default:
      return null;
  }
}
function rz(t) {
  return yM[t.hour < 12 ? 0 : 1];
}
function nz(t, e) {
  return mM(e)[t.weekday - 1];
}
function iz(t, e) {
  return fM(e)[t.month - 1];
}
function oz(t, e) {
  return gM(e)[t.year < 0 ? 0 : 1];
}
function az(t, e, n = "always", a = !1) {
  const s = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, h = ["hours", "minutes", "seconds"].indexOf(t) === -1;
  if (n === "auto" && h) {
    const M = t === "days";
    switch (e) {
      case 1:
        return M ? "tomorrow" : `next ${s[t][0]}`;
      case -1:
        return M ? "yesterday" : `last ${s[t][0]}`;
      case 0:
        return M ? "today" : `this ${s[t][0]}`;
    }
  }
  const o = Object.is(e, -0) || e < 0, m = Math.abs(e), g = m === 1, b = s[t], T = a ? g ? b[1] : b[2] || b[1] : g ? s[t][0] : t;
  return o ? `${m} ${T} ago` : `in ${m} ${T}`;
}
function g2(t, e) {
  let n = "";
  for (const a of t)
    a.literal ? n += a.val : n += e(a.val);
  return n;
}
const sz = {
  D: Ug,
  DD: GT,
  DDD: qT,
  DDDD: $T,
  t: WT,
  tt: HT,
  ttt: ZT,
  tttt: XT,
  T: KT,
  TT: YT,
  TTT: JT,
  TTTT: QT,
  f: eM,
  ff: rM,
  fff: iM,
  ffff: aM,
  F: tM,
  FF: nM,
  FFF: oM,
  FFFF: sM
};
class bo {
  static create(e, n = {}) {
    return new bo(e, n);
  }
  static parseFormat(e) {
    let n = null, a = "", s = !1;
    const h = [];
    for (let o = 0; o < e.length; o++) {
      const m = e.charAt(o);
      m === "'" ? (a.length > 0 && h.push({ literal: s || /^\s+$/.test(a), val: a }), n = null, a = "", s = !s) : s || m === n ? a += m : (a.length > 0 && h.push({ literal: /^\s+$/.test(a), val: a }), a = m, n = m);
    }
    return a.length > 0 && h.push({ literal: s || /^\s+$/.test(a), val: a }), h;
  }
  static macroTokenToFormatOpts(e) {
    return sz[e];
  }
  constructor(e, n) {
    this.opts = n, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, n) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...n }).format();
  }
  dtFormatter(e, n = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...n });
  }
  formatDateTime(e, n) {
    return this.dtFormatter(e, n).format();
  }
  formatDateTimeParts(e, n) {
    return this.dtFormatter(e, n).formatToParts();
  }
  formatInterval(e, n) {
    return this.dtFormatter(e.start, n).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, n) {
    return this.dtFormatter(e, n).resolvedOptions();
  }
  num(e, n = 0) {
    if (this.opts.forceSimple)
      return Ci(e, n);
    const a = { ...this.opts };
    return n > 0 && (a.padTo = n), this.loc.numberFormatter(a).format(e);
  }
  formatDateTimeFromString(e, n) {
    const a = this.loc.listingMode() === "en", s = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", h = (P, z) => this.loc.extract(e, P, z), o = (P) => e.isOffsetFixed && e.offset === 0 && P.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, P.format) : "", m = () => a ? rz(e) : h({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), g = (P, z) => a ? iz(e, P) : h(z ? { month: P } : { month: P, day: "numeric" }, "month"), b = (P, z) => a ? nz(e, P) : h(
      z ? { weekday: P } : { weekday: P, month: "long", day: "numeric" },
      "weekday"
    ), T = (P) => {
      const z = bo.macroTokenToFormatOpts(P);
      return z ? this.formatWithSystemDefault(e, z) : P;
    }, M = (P) => a ? oz(e, P) : h({ era: P }, "era"), I = (P) => {
      switch (P) {
        case "S":
          return this.num(e.millisecond);
        case "u":
        case "SSS":
          return this.num(e.millisecond, 3);
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        case "Z":
          return o({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return o({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return o({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return e.zoneName;
        case "a":
          return m();
        case "d":
          return s ? h({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return s ? h({ day: "2-digit" }, "day") : this.num(e.day, 2);
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return b("short", !0);
        case "cccc":
          return b("long", !0);
        case "ccccc":
          return b("narrow", !0);
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return b("short", !1);
        case "EEEE":
          return b("long", !1);
        case "EEEEE":
          return b("narrow", !1);
        case "L":
          return s ? h({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return s ? h({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return g("short", !0);
        case "LLLL":
          return g("long", !0);
        case "LLLLL":
          return g("narrow", !0);
        case "M":
          return s ? h({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return s ? h({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return g("short", !1);
        case "MMMM":
          return g("long", !1);
        case "MMMMM":
          return g("narrow", !1);
        case "y":
          return s ? h({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return s ? h({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return s ? h({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return s ? h({ year: "numeric" }, "year") : this.num(e.year, 6);
        case "G":
          return M("short");
        case "GG":
          return M("long");
        case "GGGGG":
          return M("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return T(P);
      }
    };
    return g2(bo.parseFormat(n), I);
  }
  formatDurationFromString(e, n) {
    const a = (g) => {
      switch (g[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, s = (g) => (b) => {
      const T = a(b);
      return T ? this.num(g.get(T), b.length) : b;
    }, h = bo.parseFormat(n), o = h.reduce(
      (g, { literal: b, val: T }) => b ? g : g.concat(T),
      []
    ), m = e.shiftTo(...o.map(a).filter((g) => g));
    return g2(h, s(m));
  }
}
class as {
  constructor(e, n) {
    this.reason = e, this.explanation = n;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const vM = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function Bf(...t) {
  const e = t.reduce((n, a) => n + a.source, "");
  return RegExp(`^${e}$`);
}
function Vf(...t) {
  return (e) => t.reduce(
    ([n, a, s], h) => {
      const [o, m, g] = h(e, s);
      return [{ ...n, ...o }, m || a, g];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function Uf(t, ...e) {
  if (t == null)
    return [null, null];
  for (const [n, a] of e) {
    const s = n.exec(t);
    if (s)
      return a(s);
  }
  return [null, null];
}
function _M(...t) {
  return (e, n) => {
    const a = {};
    let s;
    for (s = 0; s < t.length; s++)
      a[t[s]] = xu(e[n + s]);
    return [a, null, n + s];
  };
}
const xM = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, lz = `(?:${xM.source}?(?:\\[(${vM.source})\\])?)?`, Z1 = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, bM = RegExp(`${Z1.source}${lz}`), X1 = RegExp(`(?:T${bM.source})?`), uz = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, cz = /(\d{4})-?W(\d\d)(?:-?(\d))?/, hz = /(\d{4})-?(\d{3})/, fz = _M("weekYear", "weekNumber", "weekDay"), pz = _M("year", "ordinal"), dz = /(\d{4})-(\d\d)-(\d\d)/, wM = RegExp(
  `${Z1.source} ?(?:${xM.source}|(${vM.source}))?`
), mz = RegExp(`(?: ${wM.source})?`);
function Of(t, e, n) {
  const a = t[e];
  return Hr(a) ? n : xu(a);
}
function yz(t, e) {
  return [{
    year: Of(t, e),
    month: Of(t, e + 1, 1),
    day: Of(t, e + 2, 1)
  }, null, e + 3];
}
function jf(t, e) {
  return [{
    hours: Of(t, e, 0),
    minutes: Of(t, e + 1, 0),
    seconds: Of(t, e + 2, 0),
    milliseconds: W1(t[e + 3])
  }, null, e + 4];
}
function Qd(t, e) {
  const n = !t[e] && !t[e + 1], a = Ov(t[e + 1], t[e + 2]), s = n ? null : Fo.instance(a);
  return [{}, s, e + 3];
}
function em(t, e) {
  const n = t[e] ? Ul.create(t[e]) : null;
  return [{}, n, e + 1];
}
const gz = RegExp(`^T?${Z1.source}$`), vz = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function _z(t) {
  const [e, n, a, s, h, o, m, g, b] = t, T = e[0] === "-", M = g && g[0] === "-", I = (P, z = !1) => P !== void 0 && (z || P && T) ? -P : P;
  return [
    {
      years: I(Ic(n)),
      months: I(Ic(a)),
      weeks: I(Ic(s)),
      days: I(Ic(h)),
      hours: I(Ic(o)),
      minutes: I(Ic(m)),
      seconds: I(Ic(g), g === "-0"),
      milliseconds: I(W1(b), M)
    }
  ];
}
const xz = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function K1(t, e, n, a, s, h, o) {
  const m = {
    year: e.length === 2 ? i1(xu(e)) : xu(e),
    month: hM.indexOf(n) + 1,
    day: xu(a),
    hour: xu(s),
    minute: xu(h)
  };
  return o && (m.second = xu(o)), t && (m.weekday = t.length > 3 ? pM.indexOf(t) + 1 : dM.indexOf(t) + 1), m;
}
const bz = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function wz(t) {
  const [
    ,
    e,
    n,
    a,
    s,
    h,
    o,
    m,
    g,
    b,
    T,
    M
  ] = t, I = K1(e, s, a, n, h, o, m);
  let P;
  return g ? P = xz[g] : b ? P = 0 : P = Ov(T, M), [I, new Fo(P)];
}
function Ez(t) {
  return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const Sz = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, Tz = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Mz = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function v2(t) {
  const [, e, n, a, s, h, o, m] = t;
  return [K1(e, s, a, n, h, o, m), Fo.utcInstance];
}
function Iz(t) {
  const [, e, n, a, s, h, o, m] = t;
  return [K1(e, m, n, a, s, h, o), Fo.utcInstance];
}
const Oz = Bf(uz, X1), Cz = Bf(cz, X1), Az = Bf(hz, X1), Pz = Bf(bM), EM = Vf(
  yz,
  jf,
  Qd,
  em
), kz = Vf(
  fz,
  jf,
  Qd,
  em
), Lz = Vf(
  pz,
  jf,
  Qd,
  em
), Dz = Vf(
  jf,
  Qd,
  em
);
function Nz(t) {
  return Uf(
    t,
    [Oz, EM],
    [Cz, kz],
    [Az, Lz],
    [Pz, Dz]
  );
}
function Rz(t) {
  return Uf(Ez(t), [bz, wz]);
}
function zz(t) {
  return Uf(
    t,
    [Sz, v2],
    [Tz, v2],
    [Mz, Iz]
  );
}
function Fz(t) {
  return Uf(t, [vz, _z]);
}
const Bz = Vf(jf);
function Vz(t) {
  return Uf(t, [gz, Bz]);
}
const Uz = Bf(dz, mz), jz = Bf(wM), Gz = Vf(
  jf,
  Qd,
  em
);
function qz(t) {
  return Uf(
    t,
    [Uz, EM],
    [jz, Gz]
  );
}
const _2 = "Invalid Duration", SM = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, $z = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...SM
}, Ia = 146097 / 400, rf = 146097 / 4800, Wz = {
  years: {
    quarters: 4,
    months: 12,
    weeks: Ia / 7,
    days: Ia,
    hours: Ia * 24,
    minutes: Ia * 24 * 60,
    seconds: Ia * 24 * 60 * 60,
    milliseconds: Ia * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: Ia / 28,
    days: Ia / 4,
    hours: Ia * 24 / 4,
    minutes: Ia * 24 * 60 / 4,
    seconds: Ia * 24 * 60 * 60 / 4,
    milliseconds: Ia * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: rf / 7,
    days: rf,
    hours: rf * 24,
    minutes: rf * 24 * 60,
    seconds: rf * 24 * 60 * 60,
    milliseconds: rf * 24 * 60 * 60 * 1e3
  },
  ...SM
}, Nc = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], TM = Nc.slice(0).reverse();
function mu(t, e, n = !1) {
  const a = {
    values: n ? e.values : { ...t.values, ...e.values || {} },
    loc: t.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy,
    matrix: e.matrix || t.matrix
  };
  return new Yr(a);
}
function x2(t) {
  return Math.trunc(t * 1e3) / 1e3;
}
function MM(t, e, n, a, s) {
  const h = t[s][n], o = e[n] / h, m = X5(o);
  a[s] = x2(a[s] + m), e[n] = x2(e[n] - m * h);
}
function Hz(t, e) {
  TM.reduce((n, a) => Hr(e[a]) ? n : (n && MM(t, e, n, e, a), a), null);
}
function Zz(t) {
  const e = {};
  for (const [n, a] of Object.entries(t))
    a !== 0 && (e[n] = a);
  return e;
}
class Yr {
  constructor(e) {
    const n = e.conversionAccuracy === "longterm" || !1;
    let a = n ? Wz : $z;
    e.matrix && (a = e.matrix), this.values = e.values, this.loc = e.loc || zn.create(), this.conversionAccuracy = n ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = a, this.isLuxonDuration = !0;
  }
  static fromMillis(e, n) {
    return Yr.fromObject({ milliseconds: e }, n);
  }
  static fromObject(e, n = {}) {
    if (e == null || typeof e != "object")
      throw new Pa(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
      );
    return new Yr({
      values: qg(e, Yr.normalizeUnit),
      loc: zn.fromObject(n),
      conversionAccuracy: n.conversionAccuracy,
      matrix: n.matrix
    });
  }
  static fromDurationLike(e) {
    if (Wc(e))
      return Yr.fromMillis(e);
    if (Yr.isDuration(e))
      return e;
    if (typeof e == "object")
      return Yr.fromObject(e);
    throw new Pa(
      `Unknown duration argument ${e} of type ${typeof e}`
    );
  }
  static fromISO(e, n) {
    const [a] = Fz(e);
    return a ? Yr.fromObject(a, n) : Yr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static fromISOTime(e, n) {
    const [a] = Vz(e);
    return a ? Yr.fromObject(a, n) : Yr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static invalid(e, n = null) {
    if (!e)
      throw new Pa("need to specify a reason the Duration is invalid");
    const a = e instanceof as ? e : new as(e, n);
    if (Oi.throwOnInvalid)
      throw new S5(a);
    return new Yr({ invalid: a });
  }
  static normalizeUnit(e) {
    const n = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[e && e.toLowerCase()];
    if (!n)
      throw new jT(e);
    return n;
  }
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(e, n = {}) {
    const a = {
      ...n,
      floor: n.round !== !1 && n.floor !== !1
    };
    return this.isValid ? bo.create(this.loc, a).formatDurationFromString(this, e) : _2;
  }
  toHuman(e = {}) {
    if (!this.isValid)
      return _2;
    const n = Nc.map((a) => {
      const s = this.values[a];
      return Hr(s) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: a.slice(0, -1) }).format(s);
    }).filter((a) => a);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(n);
  }
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  toISO() {
    if (!this.isValid)
      return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += H1(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  toISOTime(e = {}) {
    if (!this.isValid)
      return null;
    const n = this.toMillis();
    return n < 0 || n >= 864e5 ? null : (e = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...e,
      includeOffset: !1
    }, br.fromMillis(n, { zone: "UTC" }).toISOTime(e));
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  toMillis() {
    var n;
    if (!this.isValid)
      return NaN;
    let e = (n = this.values.milliseconds) != null ? n : 0;
    for (let a of TM.slice(1))
      this.values[a] && (e += this.values[a] * this.matrix[a].milliseconds);
    return e;
  }
  valueOf() {
    return this.toMillis();
  }
  plus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e), a = {};
    for (const s of Nc)
      (Nf(n.values, s) || Nf(this.values, s)) && (a[s] = n.get(s) + this.get(s));
    return mu(this, { values: a }, !0);
  }
  minus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e);
    return this.plus(n.negate());
  }
  mapUnits(e) {
    if (!this.isValid)
      return this;
    const n = {};
    for (const a of Object.keys(this.values))
      n[a] = cM(e(this.values[a], a));
    return mu(this, { values: n }, !0);
  }
  get(e) {
    return this[Yr.normalizeUnit(e)];
  }
  set(e) {
    if (!this.isValid)
      return this;
    const n = { ...this.values, ...qg(e, Yr.normalizeUnit) };
    return mu(this, { values: n });
  }
  reconfigure({ locale: e, numberingSystem: n, conversionAccuracy: a, matrix: s } = {}) {
    const o = { loc: this.loc.clone({ locale: e, numberingSystem: n }), matrix: s, conversionAccuracy: a };
    return mu(this, o);
  }
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  normalize() {
    if (!this.isValid)
      return this;
    const e = this.toObject();
    return this.valueOf() >= 0 ? (Hz(this.matrix, e), mu(this, { values: e }, !0)) : this.negate().normalize().negate();
  }
  rescale() {
    if (!this.isValid)
      return this;
    const e = Zz(this.normalize().shiftToAll().toObject());
    return mu(this, { values: e }, !0);
  }
  shiftTo(...e) {
    if (!this.isValid)
      return this;
    if (e.length === 0)
      return this;
    e = e.map((o) => Yr.normalizeUnit(o));
    const n = {}, a = {}, s = this.toObject();
    let h;
    for (const o of Nc)
      if (e.indexOf(o) >= 0) {
        h = o;
        let m = 0;
        for (const b in a)
          m += this.matrix[b][o] * a[b], a[b] = 0;
        Wc(s[o]) && (m += s[o]);
        const g = Math.trunc(m);
        n[o] = g, a[o] = (m * 1e3 - g * 1e3) / 1e3;
        for (const b in s)
          Nc.indexOf(b) > Nc.indexOf(o) && MM(this.matrix, s, b, n, o);
      } else
        Wc(s[o]) && (a[o] = s[o]);
    for (const o in a)
      a[o] !== 0 && (n[h] += o === h ? a[o] : a[o] / this.matrix[h][o]);
    return mu(this, { values: n }, !0).normalize();
  }
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  negate() {
    if (!this.isValid)
      return this;
    const e = {};
    for (const n of Object.keys(this.values))
      e[n] = this.values[n] === 0 ? 0 : -this.values[n];
    return mu(this, { values: e }, !0);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
      return !1;
    function n(a, s) {
      return a === void 0 || a === 0 ? s === void 0 || s === 0 : a === s;
    }
    for (const a of Nc)
      if (!n(this.values[a], e.values[a]))
        return !1;
    return !0;
  }
}
const nf = "Invalid Interval";
function Xz(t, e) {
  return !t || !t.isValid ? fi.invalid("missing or invalid start") : !e || !e.isValid ? fi.invalid("missing or invalid end") : e < t ? fi.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`
  ) : null;
}
class fi {
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  static invalid(e, n = null) {
    if (!e)
      throw new Pa("need to specify a reason the Interval is invalid");
    const a = e instanceof as ? e : new as(e, n);
    if (Oi.throwOnInvalid)
      throw new E5(a);
    return new fi({ invalid: a });
  }
  static fromDateTimes(e, n) {
    const a = Hp(e), s = Hp(n), h = Xz(a, s);
    return h == null ? new fi({
      start: a,
      end: s
    }) : h;
  }
  static after(e, n) {
    const a = Yr.fromDurationLike(n), s = Hp(e);
    return fi.fromDateTimes(s, s.plus(a));
  }
  static before(e, n) {
    const a = Yr.fromDurationLike(n), s = Hp(e);
    return fi.fromDateTimes(s.minus(a), s);
  }
  static fromISO(e, n) {
    const [a, s] = (e || "").split("/", 2);
    if (a && s) {
      let h, o;
      try {
        h = br.fromISO(a, n), o = h.isValid;
      } catch {
        o = !1;
      }
      let m, g;
      try {
        m = br.fromISO(s, n), g = m.isValid;
      } catch {
        g = !1;
      }
      if (o && g)
        return fi.fromDateTimes(h, m);
      if (o) {
        const b = Yr.fromISO(s, n);
        if (b.isValid)
          return fi.after(h, b);
      } else if (g) {
        const b = Yr.fromISO(a, n);
        if (b.isValid)
          return fi.before(m, b);
      }
    }
    return fi.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  count(e = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const n = this.start.startOf(e), a = this.end.startOf(e);
    return Math.floor(a.diff(n, e).get(e)) + (a.valueOf() !== this.end.valueOf());
  }
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  set({ start: e, end: n } = {}) {
    return this.isValid ? fi.fromDateTimes(e || this.s, n || this.e) : this;
  }
  splitAt(...e) {
    if (!this.isValid)
      return [];
    const n = e.map(Hp).filter((o) => this.contains(o)).sort(), a = [];
    let { s } = this, h = 0;
    for (; s < this.e; ) {
      const o = n[h] || this.e, m = +o > +this.e ? this.e : o;
      a.push(fi.fromDateTimes(s, m)), s = m, h += 1;
    }
    return a;
  }
  splitBy(e) {
    const n = Yr.fromDurationLike(e);
    if (!this.isValid || !n.isValid || n.as("milliseconds") === 0)
      return [];
    let { s: a } = this, s = 1, h;
    const o = [];
    for (; a < this.e; ) {
      const m = this.start.plus(n.mapUnits((g) => g * s));
      h = +m > +this.e ? this.e : m, o.push(fi.fromDateTimes(a, h)), a = h, s += 1;
    }
    return o;
  }
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  intersection(e) {
    if (!this.isValid)
      return this;
    const n = this.s > e.s ? this.s : e.s, a = this.e < e.e ? this.e : e.e;
    return n >= a ? null : fi.fromDateTimes(n, a);
  }
  union(e) {
    if (!this.isValid)
      return this;
    const n = this.s < e.s ? this.s : e.s, a = this.e > e.e ? this.e : e.e;
    return fi.fromDateTimes(n, a);
  }
  static merge(e) {
    const [n, a] = e.sort((s, h) => s.s - h.s).reduce(
      ([s, h], o) => h ? h.overlaps(o) || h.abutsStart(o) ? [s, h.union(o)] : [s.concat([h]), o] : [s, o],
      [[], null]
    );
    return a && n.push(a), n;
  }
  static xor(e) {
    let n = null, a = 0;
    const s = [], h = e.map((g) => [
      { time: g.s, type: "s" },
      { time: g.e, type: "e" }
    ]), o = Array.prototype.concat(...h), m = o.sort((g, b) => g.time - b.time);
    for (const g of m)
      a += g.type === "s" ? 1 : -1, a === 1 ? n = g.time : (n && +n != +g.time && s.push(fi.fromDateTimes(n, g.time)), n = null);
    return fi.merge(s);
  }
  difference(...e) {
    return fi.xor([this].concat(e)).map((n) => this.intersection(n)).filter((n) => n && !n.isEmpty());
  }
  toString() {
    return this.isValid ? `[${this.s.toISO()} \u2013 ${this.e.toISO()})` : nf;
  }
  toLocaleString(e = Ug, n = {}) {
    return this.isValid ? bo.create(this.s.loc.clone(n), e).formatInterval(this) : nf;
  }
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : nf;
  }
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : nf;
  }
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : nf;
  }
  toFormat(e, { separator: n = " \u2013 " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${n}${this.e.toFormat(e)}` : nf;
  }
  toDuration(e, n) {
    return this.isValid ? this.e.diff(this.s, e, n) : Yr.invalid(this.invalidReason);
  }
  mapEndpoints(e) {
    return fi.fromDateTimes(e(this.s), e(this.e));
  }
}
class Py {
  static hasDST(e = Oi.defaultZone) {
    const n = br.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && n.offset !== n.set({ month: 6 }).offset;
  }
  static isValidIANAZone(e) {
    return Ul.isValidZone(e);
  }
  static normalizeZone(e) {
    return Su(e, Oi.defaultZone);
  }
  static months(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null, outputCalendar: h = "gregory" } = {}) {
    return (s || zn.create(n, a, h)).months(e);
  }
  static monthsFormat(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null, outputCalendar: h = "gregory" } = {}) {
    return (s || zn.create(n, a, h)).months(e, !0);
  }
  static weekdays(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null } = {}) {
    return (s || zn.create(n, a, null)).weekdays(e);
  }
  static weekdaysFormat(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null } = {}) {
    return (s || zn.create(n, a, null)).weekdays(e, !0);
  }
  static meridiems({ locale: e = null } = {}) {
    return zn.create(e).meridiems();
  }
  static eras(e = "short", { locale: n = null } = {}) {
    return zn.create(n, null, "gregory").eras(e);
  }
  static features() {
    return { relative: lM() };
  }
}
function b2(t, e) {
  const n = (s) => s.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), a = n(e) - n(t);
  return Math.floor(Yr.fromMillis(a).as("days"));
}
function Kz(t, e, n) {
  const a = [
    ["years", (g, b) => b.year - g.year],
    ["quarters", (g, b) => b.quarter - g.quarter + (b.year - g.year) * 4],
    ["months", (g, b) => b.month - g.month + (b.year - g.year) * 12],
    [
      "weeks",
      (g, b) => {
        const T = b2(g, b);
        return (T - T % 7) / 7;
      }
    ],
    ["days", b2]
  ], s = {}, h = t;
  let o, m;
  for (const [g, b] of a)
    n.indexOf(g) >= 0 && (o = g, s[g] = b(t, e), m = h.plus(s), m > e ? (s[g]--, t = h.plus(s), t > e && (m = t, s[g]--, t = h.plus(s))) : t = m);
  return [t, s, m, o];
}
function Yz(t, e, n, a) {
  let [s, h, o, m] = Kz(t, e, n);
  const g = e - s, b = n.filter(
    (M) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(M) >= 0
  );
  b.length === 0 && (o < e && (o = s.plus({ [m]: 1 })), o !== s && (h[m] = (h[m] || 0) + g / (o - s)));
  const T = Yr.fromObject(h, a);
  return b.length > 0 ? Yr.fromMillis(g, a).shiftTo(...b).plus(T) : T;
}
const Y1 = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
}, w2 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, Jz = Y1.hanidec.replace(/[\[|\]]/g, "").split("");
function Qz(t) {
  let e = parseInt(t, 10);
  if (isNaN(e)) {
    e = "";
    for (let n = 0; n < t.length; n++) {
      const a = t.charCodeAt(n);
      if (t[n].search(Y1.hanidec) !== -1)
        e += Jz.indexOf(t[n]);
      else
        for (const s in w2) {
          const [h, o] = w2[s];
          a >= h && a <= o && (e += a - h);
        }
    }
    return parseInt(e, 10);
  } else
    return e;
}
function Xa({ numberingSystem: t }, e = "") {
  return new RegExp(`${Y1[t || "latn"]}${e}`);
}
const e6 = "missing Intl.DateTimeFormat.formatToParts support";
function rn(t, e = (n) => n) {
  return { regex: t, deser: ([n]) => e(Qz(n)) };
}
const t6 = String.fromCharCode(160), IM = `[ ${t6}]`, OM = new RegExp(IM, "g");
function r6(t) {
  return t.replace(/\./g, "\\.?").replace(OM, IM);
}
function E2(t) {
  return t.replace(/\./g, "").replace(OM, " ").toLowerCase();
}
function Ka(t, e) {
  return t === null ? null : {
    regex: RegExp(t.map(r6).join("|")),
    deser: ([n]) => t.findIndex((a) => E2(n) === E2(a)) + e
  };
}
function S2(t, e) {
  return { regex: t, deser: ([, n, a]) => Ov(n, a), groups: e };
}
function ky(t) {
  return { regex: t, deser: ([e]) => e };
}
function n6(t) {
  return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function i6(t, e) {
  const n = Xa(e), a = Xa(e, "{2}"), s = Xa(e, "{3}"), h = Xa(e, "{4}"), o = Xa(e, "{6}"), m = Xa(e, "{1,2}"), g = Xa(e, "{1,3}"), b = Xa(e, "{1,6}"), T = Xa(e, "{1,9}"), M = Xa(e, "{2,4}"), I = Xa(e, "{4,6}"), P = (W) => ({ regex: RegExp(n6(W.val)), deser: ([X]) => X, literal: !0 }), V = ((W) => {
    if (t.literal)
      return P(W);
    switch (W.val) {
      case "G":
        return Ka(e.eras("short"), 0);
      case "GG":
        return Ka(e.eras("long"), 0);
      case "y":
        return rn(b);
      case "yy":
        return rn(M, i1);
      case "yyyy":
        return rn(h);
      case "yyyyy":
        return rn(I);
      case "yyyyyy":
        return rn(o);
      case "M":
        return rn(m);
      case "MM":
        return rn(a);
      case "MMM":
        return Ka(e.months("short", !0), 1);
      case "MMMM":
        return Ka(e.months("long", !0), 1);
      case "L":
        return rn(m);
      case "LL":
        return rn(a);
      case "LLL":
        return Ka(e.months("short", !1), 1);
      case "LLLL":
        return Ka(e.months("long", !1), 1);
      case "d":
        return rn(m);
      case "dd":
        return rn(a);
      case "o":
        return rn(g);
      case "ooo":
        return rn(s);
      case "HH":
        return rn(a);
      case "H":
        return rn(m);
      case "hh":
        return rn(a);
      case "h":
        return rn(m);
      case "mm":
        return rn(a);
      case "m":
        return rn(m);
      case "q":
        return rn(m);
      case "qq":
        return rn(a);
      case "s":
        return rn(m);
      case "ss":
        return rn(a);
      case "S":
        return rn(g);
      case "SSS":
        return rn(s);
      case "u":
        return ky(T);
      case "uu":
        return ky(m);
      case "uuu":
        return rn(n);
      case "a":
        return Ka(e.meridiems(), 0);
      case "kkkk":
        return rn(h);
      case "kk":
        return rn(M, i1);
      case "W":
        return rn(m);
      case "WW":
        return rn(a);
      case "E":
      case "c":
        return rn(n);
      case "EEE":
        return Ka(e.weekdays("short", !1), 1);
      case "EEEE":
        return Ka(e.weekdays("long", !1), 1);
      case "ccc":
        return Ka(e.weekdays("short", !0), 1);
      case "cccc":
        return Ka(e.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return S2(new RegExp(`([+-]${m.source})(?::(${a.source}))?`), 2);
      case "ZZZ":
        return S2(new RegExp(`([+-]${m.source})(${a.source})?`), 2);
      case "z":
        return ky(/[a-z_+-/]{1,256}?/i);
      case " ":
        return ky(/[^\S\n\r]/);
      default:
        return P(W);
    }
  })(t) || {
    invalidReason: e6
  };
  return V.token = t, V;
}
const o6 = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function a6(t, e, n) {
  const { type: a, value: s } = t;
  if (a === "literal") {
    const g = /^\s+$/.test(s);
    return {
      literal: !g,
      val: g ? " " : s
    };
  }
  const h = e[a];
  let o = a;
  a === "hour" && (e.hour12 != null ? o = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? o = "hour12" : o = "hour24" : o = n.hour12 ? "hour12" : "hour24");
  let m = o6[o];
  if (typeof m == "object" && (m = m[h]), m)
    return {
      literal: !1,
      val: m
    };
}
function s6(t) {
  return [`^${t.map((n) => n.regex).reduce((n, a) => `${n}(${a.source})`, "")}$`, t];
}
function l6(t, e, n) {
  const a = t.match(e);
  if (a) {
    const s = {};
    let h = 1;
    for (const o in n)
      if (Nf(n, o)) {
        const m = n[o], g = m.groups ? m.groups + 1 : 1;
        !m.literal && m.token && (s[m.token.val[0]] = m.deser(a.slice(h, h + g))), h += g;
      }
    return [a, s];
  } else
    return [a, {}];
}
function u6(t) {
  const e = (h) => {
    switch (h) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let n = null, a;
  return Hr(t.z) || (n = Ul.create(t.z)), Hr(t.Z) || (n || (n = new Fo(t.Z)), a = t.Z), Hr(t.q) || (t.M = (t.q - 1) * 3 + 1), Hr(t.h) || (t.h < 12 && t.a === 1 ? t.h += 12 : t.h === 12 && t.a === 0 && (t.h = 0)), t.G === 0 && t.y && (t.y = -t.y), Hr(t.u) || (t.S = W1(t.u)), [Object.keys(t).reduce((h, o) => {
    const m = e(o);
    return m && (h[m] = t[o]), h;
  }, {}), n, a];
}
let Z_ = null;
function c6() {
  return Z_ || (Z_ = br.fromMillis(1555555555555)), Z_;
}
function h6(t, e) {
  if (t.literal)
    return t;
  const n = bo.macroTokenToFormatOpts(t.val), a = PM(n, e);
  return a == null || a.includes(void 0) ? t : a;
}
function CM(t, e) {
  return Array.prototype.concat(...t.map((n) => h6(n, e)));
}
function AM(t, e, n) {
  const a = CM(bo.parseFormat(n), t), s = a.map((o) => i6(o, t)), h = s.find((o) => o.invalidReason);
  if (h)
    return { input: e, tokens: a, invalidReason: h.invalidReason };
  {
    const [o, m] = s6(s), g = RegExp(o, "i"), [b, T] = l6(e, g, m), [M, I, P] = T ? u6(T) : [null, null, void 0];
    if (Nf(T, "a") && Nf(T, "H"))
      throw new rd(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: e, tokens: a, regex: g, rawMatches: b, matches: T, result: M, zone: I, specificOffset: P };
  }
}
function f6(t, e, n) {
  const { result: a, zone: s, specificOffset: h, invalidReason: o } = AM(t, e, n);
  return [a, s, h, o];
}
function PM(t, e) {
  if (!t)
    return null;
  const a = bo.create(e, t).dtFormatter(c6()), s = a.formatToParts(), h = a.resolvedOptions();
  return s.map((o) => a6(o, t, h));
}
const kM = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], LM = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function ka(t, e) {
  return new as(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`
  );
}
function DM(t, e, n) {
  const a = new Date(Date.UTC(t, e - 1, n));
  t < 100 && t >= 0 && a.setUTCFullYear(a.getUTCFullYear() - 1900);
  const s = a.getUTCDay();
  return s === 0 ? 7 : s;
}
function NM(t, e, n) {
  return n + (Jd(t) ? LM : kM)[e - 1];
}
function RM(t, e) {
  const n = Jd(t) ? LM : kM, a = n.findIndex((h) => h < e), s = e - n[a];
  return { month: a + 1, day: s };
}
function o1(t) {
  const { year: e, month: n, day: a } = t, s = NM(e, n, a), h = DM(e, n, a);
  let o = Math.floor((s - h + 10) / 7), m;
  return o < 1 ? (m = e - 1, o = Gg(m)) : o > Gg(e) ? (m = e + 1, o = 1) : m = e, { weekYear: m, weekNumber: o, weekday: h, ...Cv(t) };
}
function T2(t) {
  const { weekYear: e, weekNumber: n, weekday: a } = t, s = DM(e, 1, 4), h = yd(e);
  let o = n * 7 + a - s - 3, m;
  o < 1 ? (m = e - 1, o += yd(m)) : o > h ? (m = e + 1, o -= yd(e)) : m = e;
  const { month: g, day: b } = RM(m, o);
  return { year: m, month: g, day: b, ...Cv(t) };
}
function X_(t) {
  const { year: e, month: n, day: a } = t, s = NM(e, n, a);
  return { year: e, ordinal: s, ...Cv(t) };
}
function M2(t) {
  const { year: e, ordinal: n } = t, { month: a, day: s } = RM(e, n);
  return { year: e, month: a, day: s, ...Cv(t) };
}
function p6(t) {
  const e = Mv(t.weekYear), n = Nl(t.weekNumber, 1, Gg(t.weekYear)), a = Nl(t.weekday, 1, 7);
  return e ? n ? a ? !1 : ka("weekday", t.weekday) : ka("week", t.week) : ka("weekYear", t.weekYear);
}
function d6(t) {
  const e = Mv(t.year), n = Nl(t.ordinal, 1, yd(t.year));
  return e ? n ? !1 : ka("ordinal", t.ordinal) : ka("year", t.year);
}
function zM(t) {
  const e = Mv(t.year), n = Nl(t.month, 1, 12), a = Nl(t.day, 1, jg(t.year, t.month));
  return e ? n ? a ? !1 : ka("day", t.day) : ka("month", t.month) : ka("year", t.year);
}
function FM(t) {
  const { hour: e, minute: n, second: a, millisecond: s } = t, h = Nl(e, 0, 23) || e === 24 && n === 0 && a === 0 && s === 0, o = Nl(n, 0, 59), m = Nl(a, 0, 59), g = Nl(s, 0, 999);
  return h ? o ? m ? g ? !1 : ka("millisecond", s) : ka("second", a) : ka("minute", n) : ka("hour", e);
}
const K_ = "Invalid DateTime", I2 = 864e13;
function Ly(t) {
  return new as("unsupported zone", `the zone "${t.name}" is not supported`);
}
function Y_(t) {
  return t.weekData === null && (t.weekData = o1(t.c)), t.weekData;
}
function Oc(t, e) {
  const n = {
    ts: t.ts,
    zone: t.zone,
    c: t.c,
    o: t.o,
    loc: t.loc,
    invalid: t.invalid
  };
  return new br({ ...n, ...e, old: n });
}
function BM(t, e, n) {
  let a = t - e * 60 * 1e3;
  const s = n.offset(a);
  if (e === s)
    return [a, e];
  a -= (s - e) * 60 * 1e3;
  const h = n.offset(a);
  return s === h ? [a, s] : [t - Math.min(s, h) * 60 * 1e3, Math.max(s, h)];
}
function Dy(t, e) {
  t += e * 60 * 1e3;
  const n = new Date(t);
  return {
    year: n.getUTCFullYear(),
    month: n.getUTCMonth() + 1,
    day: n.getUTCDate(),
    hour: n.getUTCHours(),
    minute: n.getUTCMinutes(),
    second: n.getUTCSeconds(),
    millisecond: n.getUTCMilliseconds()
  };
}
function lg(t, e, n) {
  return BM(Iv(t), e, n);
}
function O2(t, e) {
  const n = t.o, a = t.c.year + Math.trunc(e.years), s = t.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, h = {
    ...t.c,
    year: a,
    month: s,
    day: Math.min(t.c.day, jg(a, s)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
  }, o = Yr.fromObject({
    years: e.years - Math.trunc(e.years),
    quarters: e.quarters - Math.trunc(e.quarters),
    months: e.months - Math.trunc(e.months),
    weeks: e.weeks - Math.trunc(e.weeks),
    days: e.days - Math.trunc(e.days),
    hours: e.hours,
    minutes: e.minutes,
    seconds: e.seconds,
    milliseconds: e.milliseconds
  }).as("milliseconds"), m = Iv(h);
  let [g, b] = BM(m, n, t.zone);
  return o !== 0 && (g += o, b = t.zone.offset(g)), { ts: g, o: b };
}
function Wp(t, e, n, a, s, h) {
  const { setZone: o, zone: m } = n;
  if (t && Object.keys(t).length !== 0 || e) {
    const g = e || m, b = br.fromObject(t, {
      ...n,
      zone: g,
      specificOffset: h
    });
    return o ? b : b.setZone(m);
  } else
    return br.invalid(
      new as("unparsable", `the input "${s}" can't be parsed as ${a}`)
    );
}
function Ny(t, e, n = !0) {
  return t.isValid ? bo.create(zn.create("en-US"), {
    allowZ: n,
    forceSimple: !0
  }).formatDateTimeFromString(t, e) : null;
}
function J_(t, e) {
  const n = t.c.year > 9999 || t.c.year < 0;
  let a = "";
  return n && t.c.year >= 0 && (a += "+"), a += Ci(t.c.year, n ? 6 : 4), e ? (a += "-", a += Ci(t.c.month), a += "-", a += Ci(t.c.day)) : (a += Ci(t.c.month), a += Ci(t.c.day)), a;
}
function C2(t, e, n, a, s, h) {
  let o = Ci(t.c.hour);
  return e ? (o += ":", o += Ci(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (o += ":")) : o += Ci(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (o += Ci(t.c.second), (t.c.millisecond !== 0 || !a) && (o += ".", o += Ci(t.c.millisecond, 3))), s && (t.isOffsetFixed && t.offset === 0 && !h ? o += "Z" : t.o < 0 ? (o += "-", o += Ci(Math.trunc(-t.o / 60)), o += ":", o += Ci(Math.trunc(-t.o % 60))) : (o += "+", o += Ci(Math.trunc(t.o / 60)), o += ":", o += Ci(Math.trunc(t.o % 60)))), h && (o += "[" + t.zone.ianaName + "]"), o;
}
const VM = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, m6 = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, y6 = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, UM = ["year", "month", "day", "hour", "minute", "second", "millisecond"], g6 = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], v6 = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function A2(t) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[t.toLowerCase()];
  if (!e)
    throw new jT(t);
  return e;
}
function P2(t, e) {
  const n = Su(e.zone, Oi.defaultZone), a = zn.fromObject(e), s = Oi.now();
  let h, o;
  if (Hr(t.year))
    h = s;
  else {
    for (const b of UM)
      Hr(t[b]) && (t[b] = VM[b]);
    const m = zM(t) || FM(t);
    if (m)
      return br.invalid(m);
    const g = n.offset(s);
    [h, o] = lg(t, g, n);
  }
  return new br({ ts: h, zone: n, loc: a, o });
}
function k2(t, e, n) {
  const a = Hr(n.round) ? !0 : n.round, s = (o, m) => (o = H1(o, a || n.calendary ? 0 : 2, !0), e.loc.clone(n).relFormatter(n).format(o, m)), h = (o) => n.calendary ? e.hasSame(t, o) ? 0 : e.startOf(o).diff(t.startOf(o), o).get(o) : e.diff(t, o).get(o);
  if (n.unit)
    return s(h(n.unit), n.unit);
  for (const o of n.units) {
    const m = h(o);
    if (Math.abs(m) >= 1)
      return s(m, o);
  }
  return s(t > e ? -0 : 0, n.units[n.units.length - 1]);
}
function L2(t) {
  let e = {}, n;
  return t.length > 0 && typeof t[t.length - 1] == "object" ? (e = t[t.length - 1], n = Array.from(t).slice(0, t.length - 1)) : n = Array.from(t), [e, n];
}
class br {
  constructor(e) {
    const n = e.zone || Oi.defaultZone;
    let a = e.invalid || (Number.isNaN(e.ts) ? new as("invalid input") : null) || (n.isValid ? null : Ly(n));
    this.ts = Hr(e.ts) ? Oi.now() : e.ts;
    let s = null, h = null;
    if (!a)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(n))
        [s, h] = [e.old.c, e.old.o];
      else {
        const m = n.offset(this.ts);
        s = Dy(this.ts, m), a = Number.isNaN(s.year) ? new as("invalid input") : null, s = a ? null : s, h = a ? null : m;
      }
    this._zone = n, this.loc = e.loc || zn.create(), this.invalid = a, this.weekData = null, this.c = s, this.o = h, this.isLuxonDateTime = !0;
  }
  static now() {
    return new br({});
  }
  static local() {
    const [e, n] = L2(arguments), [a, s, h, o, m, g, b] = n;
    return P2({ year: a, month: s, day: h, hour: o, minute: m, second: g, millisecond: b }, e);
  }
  static utc() {
    const [e, n] = L2(arguments), [a, s, h, o, m, g, b] = n;
    return e.zone = Fo.utcInstance, P2({ year: a, month: s, day: h, hour: o, minute: m, second: g, millisecond: b }, e);
  }
  static fromJSDate(e, n = {}) {
    const a = $5(e) ? e.valueOf() : NaN;
    if (Number.isNaN(a))
      return br.invalid("invalid input");
    const s = Su(n.zone, Oi.defaultZone);
    return s.isValid ? new br({
      ts: a,
      zone: s,
      loc: zn.fromObject(n)
    }) : br.invalid(Ly(s));
  }
  static fromMillis(e, n = {}) {
    if (Wc(e))
      return e < -I2 || e > I2 ? br.invalid("Timestamp out of range") : new br({
        ts: e,
        zone: Su(n.zone, Oi.defaultZone),
        loc: zn.fromObject(n)
      });
    throw new Pa(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
    );
  }
  static fromSeconds(e, n = {}) {
    if (Wc(e))
      return new br({
        ts: e * 1e3,
        zone: Su(n.zone, Oi.defaultZone),
        loc: zn.fromObject(n)
      });
    throw new Pa("fromSeconds requires a numerical input");
  }
  static fromObject(e, n = {}) {
    e = e || {};
    const a = Su(n.zone, Oi.defaultZone);
    if (!a.isValid)
      return br.invalid(Ly(a));
    const s = Oi.now(), h = Hr(n.specificOffset) ? a.offset(s) : n.specificOffset, o = qg(e, A2), m = !Hr(o.ordinal), g = !Hr(o.year), b = !Hr(o.month) || !Hr(o.day), T = g || b, M = o.weekYear || o.weekNumber, I = zn.fromObject(n);
    if ((T || m) && M)
      throw new rd(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (b && m)
      throw new rd("Can't mix ordinal dates with month/day");
    const P = M || o.weekday && !T;
    let z, V, W = Dy(s, h);
    P ? (z = g6, V = m6, W = o1(W)) : m ? (z = v6, V = y6, W = X_(W)) : (z = UM, V = VM);
    let X = !1;
    for (const Pe of z) {
      const Se = o[Pe];
      Hr(Se) ? X ? o[Pe] = V[Pe] : o[Pe] = W[Pe] : X = !0;
    }
    const K = P ? p6(o) : m ? d6(o) : zM(o), se = K || FM(o);
    if (se)
      return br.invalid(se);
    const pe = P ? T2(o) : m ? M2(o) : o, [xe, Fe] = lg(pe, h, a), ze = new br({
      ts: xe,
      zone: a,
      o: Fe,
      loc: I
    });
    return o.weekday && T && e.weekday !== ze.weekday ? br.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${o.weekday} and a date of ${ze.toISO()}`
    ) : ze;
  }
  static fromISO(e, n = {}) {
    const [a, s] = Nz(e);
    return Wp(a, s, n, "ISO 8601", e);
  }
  static fromRFC2822(e, n = {}) {
    const [a, s] = Rz(e);
    return Wp(a, s, n, "RFC 2822", e);
  }
  static fromHTTP(e, n = {}) {
    const [a, s] = zz(e);
    return Wp(a, s, n, "HTTP", n);
  }
  static fromFormat(e, n, a = {}) {
    if (Hr(e) || Hr(n))
      throw new Pa("fromFormat requires an input string and a format");
    const { locale: s = null, numberingSystem: h = null } = a, o = zn.fromOpts({
      locale: s,
      numberingSystem: h,
      defaultToEN: !0
    }), [m, g, b, T] = f6(o, e, n);
    return T ? br.invalid(T) : Wp(m, g, a, `format ${n}`, e, b);
  }
  static fromString(e, n, a = {}) {
    return br.fromFormat(e, n, a);
  }
  static fromSQL(e, n = {}) {
    const [a, s] = qz(e);
    return Wp(a, s, n, "SQL", e);
  }
  static invalid(e, n = null) {
    if (!e)
      throw new Pa("need to specify a reason the DateTime is invalid");
    const a = e instanceof as ? e : new as(e, n);
    if (Oi.throwOnInvalid)
      throw new w5(a);
    return new br({ invalid: a });
  }
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  static parseFormatForOpts(e, n = {}) {
    const a = PM(e, zn.fromObject(n));
    return a ? a.map((s) => s ? s.val : null).join("") : null;
  }
  static expandFormat(e, n = {}) {
    return CM(bo.parseFormat(e), zn.fromObject(n)).map((s) => s.val).join("");
  }
  get(e) {
    return this[e];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? Y_(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? Y_(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? Y_(this).weekday : NaN;
  }
  get ordinal() {
    return this.isValid ? X_(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? Py.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? Py.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? Py.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? Py.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const e = 864e5, n = 6e4, a = Iv(this.c), s = this.zone.offset(a - e), h = this.zone.offset(a + e), o = this.zone.offset(a - s * n), m = this.zone.offset(a - h * n);
    if (o === m)
      return [this];
    const g = a - o * n, b = a - m * n, T = Dy(g, o), M = Dy(b, m);
    return T.hour === M.hour && T.minute === M.minute && T.second === M.second && T.millisecond === M.millisecond ? [Oc(this, { ts: g }), Oc(this, { ts: b })] : [this];
  }
  get isInLeapYear() {
    return Jd(this.year);
  }
  get daysInMonth() {
    return jg(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? yd(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? Gg(this.weekYear) : NaN;
  }
  resolvedLocaleOptions(e = {}) {
    const { locale: n, numberingSystem: a, calendar: s } = bo.create(
      this.loc.clone(e),
      e
    ).resolvedOptions(this);
    return { locale: n, numberingSystem: a, outputCalendar: s };
  }
  toUTC(e = 0, n = {}) {
    return this.setZone(Fo.instance(e), n);
  }
  toLocal() {
    return this.setZone(Oi.defaultZone);
  }
  setZone(e, { keepLocalTime: n = !1, keepCalendarTime: a = !1 } = {}) {
    if (e = Su(e, Oi.defaultZone), e.equals(this.zone))
      return this;
    if (e.isValid) {
      let s = this.ts;
      if (n || a) {
        const h = e.offset(this.ts), o = this.toObject();
        [s] = lg(o, h, e);
      }
      return Oc(this, { ts: s, zone: e });
    } else
      return br.invalid(Ly(e));
  }
  reconfigure({ locale: e, numberingSystem: n, outputCalendar: a } = {}) {
    const s = this.loc.clone({ locale: e, numberingSystem: n, outputCalendar: a });
    return Oc(this, { loc: s });
  }
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  set(e) {
    if (!this.isValid)
      return this;
    const n = qg(e, A2), a = !Hr(n.weekYear) || !Hr(n.weekNumber) || !Hr(n.weekday), s = !Hr(n.ordinal), h = !Hr(n.year), o = !Hr(n.month) || !Hr(n.day), m = h || o, g = n.weekYear || n.weekNumber;
    if ((m || s) && g)
      throw new rd(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (o && s)
      throw new rd("Can't mix ordinal dates with month/day");
    let b;
    a ? b = T2({ ...o1(this.c), ...n }) : Hr(n.ordinal) ? (b = { ...this.toObject(), ...n }, Hr(n.day) && (b.day = Math.min(jg(b.year, b.month), b.day))) : b = M2({ ...X_(this.c), ...n });
    const [T, M] = lg(b, this.o, this.zone);
    return Oc(this, { ts: T, o: M });
  }
  plus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e);
    return Oc(this, O2(this, n));
  }
  minus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e).negate();
    return Oc(this, O2(this, n));
  }
  startOf(e) {
    if (!this.isValid)
      return this;
    const n = {}, a = Yr.normalizeUnit(e);
    switch (a) {
      case "years":
        n.month = 1;
      case "quarters":
      case "months":
        n.day = 1;
      case "weeks":
      case "days":
        n.hour = 0;
      case "hours":
        n.minute = 0;
      case "minutes":
        n.second = 0;
      case "seconds":
        n.millisecond = 0;
        break;
    }
    if (a === "weeks" && (n.weekday = 1), a === "quarters") {
      const s = Math.ceil(this.month / 3);
      n.month = (s - 1) * 3 + 1;
    }
    return this.set(n);
  }
  endOf(e) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e).minus(1) : this;
  }
  toFormat(e, n = {}) {
    return this.isValid ? bo.create(this.loc.redefaultToEN(n)).formatDateTimeFromString(this, e) : K_;
  }
  toLocaleString(e = Ug, n = {}) {
    return this.isValid ? bo.create(this.loc.clone(n), e).formatDateTime(this) : K_;
  }
  toLocaleParts(e = {}) {
    return this.isValid ? bo.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  toISO({
    format: e = "extended",
    suppressSeconds: n = !1,
    suppressMilliseconds: a = !1,
    includeOffset: s = !0,
    extendedZone: h = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const o = e === "extended";
    let m = J_(this, o);
    return m += "T", m += C2(this, o, n, a, s, h), m;
  }
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? J_(this, e === "extended") : null;
  }
  toISOWeekDate() {
    return Ny(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: n = !1,
    includeOffset: a = !0,
    includePrefix: s = !1,
    extendedZone: h = !1,
    format: o = "extended"
  } = {}) {
    return this.isValid ? (s ? "T" : "") + C2(
      this,
      o === "extended",
      n,
      e,
      a,
      h
    ) : null;
  }
  toRFC2822() {
    return Ny(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  toHTTP() {
    return Ny(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    return this.isValid ? J_(this, !0) : null;
  }
  toSQLTime({ includeOffset: e = !0, includeZone: n = !1, includeOffsetSpace: a = !0 } = {}) {
    let s = "HH:mm:ss.SSS";
    return (n || e) && (a && (s += " "), n ? s += "z" : e && (s += "ZZ")), Ny(this, s, !0);
  }
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  toString() {
    return this.isValid ? this.toISO() : K_;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(e = {}) {
    if (!this.isValid)
      return {};
    const n = { ...this.c };
    return e.includeConfig && (n.outputCalendar = this.outputCalendar, n.numberingSystem = this.loc.numberingSystem, n.locale = this.loc.locale), n;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(e, n = "milliseconds", a = {}) {
    if (!this.isValid || !e.isValid)
      return Yr.invalid("created by diffing an invalid DateTime");
    const s = { locale: this.locale, numberingSystem: this.numberingSystem, ...a }, h = W5(n).map(Yr.normalizeUnit), o = e.valueOf() > this.valueOf(), m = o ? this : e, g = o ? e : this, b = Yz(m, g, h, s);
    return o ? b.negate() : b;
  }
  diffNow(e = "milliseconds", n = {}) {
    return this.diff(br.now(), e, n);
  }
  until(e) {
    return this.isValid ? fi.fromDateTimes(this, e) : this;
  }
  hasSame(e, n) {
    if (!this.isValid)
      return !1;
    const a = e.valueOf(), s = this.setZone(e.zone, { keepLocalTime: !0 });
    return s.startOf(n) <= a && a <= s.endOf(n);
  }
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  toRelative(e = {}) {
    if (!this.isValid)
      return null;
    const n = e.base || br.fromObject({}, { zone: this.zone }), a = e.padding ? this < n ? -e.padding : e.padding : 0;
    let s = ["years", "months", "days", "hours", "minutes", "seconds"], h = e.unit;
    return Array.isArray(e.unit) && (s = e.unit, h = void 0), k2(n, this.plus(a), {
      ...e,
      numeric: "always",
      units: s,
      unit: h
    });
  }
  toRelativeCalendar(e = {}) {
    return this.isValid ? k2(e.base || br.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  static min(...e) {
    if (!e.every(br.isDateTime))
      throw new Pa("min requires all arguments be DateTimes");
    return y2(e, (n) => n.valueOf(), Math.min);
  }
  static max(...e) {
    if (!e.every(br.isDateTime))
      throw new Pa("max requires all arguments be DateTimes");
    return y2(e, (n) => n.valueOf(), Math.max);
  }
  static fromFormatExplain(e, n, a = {}) {
    const { locale: s = null, numberingSystem: h = null } = a, o = zn.fromOpts({
      locale: s,
      numberingSystem: h,
      defaultToEN: !0
    });
    return AM(o, e, n);
  }
  static fromStringExplain(e, n, a = {}) {
    return br.fromFormatExplain(e, n, a);
  }
  static get DATE_SHORT() {
    return Ug;
  }
  static get DATE_MED() {
    return GT;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return T5;
  }
  static get DATE_FULL() {
    return qT;
  }
  static get DATE_HUGE() {
    return $T;
  }
  static get TIME_SIMPLE() {
    return WT;
  }
  static get TIME_WITH_SECONDS() {
    return HT;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return ZT;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return XT;
  }
  static get TIME_24_SIMPLE() {
    return KT;
  }
  static get TIME_24_WITH_SECONDS() {
    return YT;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return JT;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return QT;
  }
  static get DATETIME_SHORT() {
    return eM;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return tM;
  }
  static get DATETIME_MED() {
    return rM;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return nM;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return M5;
  }
  static get DATETIME_FULL() {
    return iM;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return oM;
  }
  static get DATETIME_HUGE() {
    return aM;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return sM;
  }
}
function Hp(t) {
  if (br.isDateTime(t))
    return t;
  if (t && t.valueOf && Wc(t.valueOf()))
    return br.fromJSDate(t);
  if (t && typeof t == "object")
    return br.fromObject(t);
  throw new Pa(
    `Unknown datetime argument: ${t}, of type ${typeof t}`
  );
}
const jM = [0, 1, 0, 0];
function D2(t, e = "second", n, a) {
  const { t: s } = In(), h = new Date(t).toISOString(), o = {
    year: s("yyyy"),
    month: s("M/yyyy"),
    day: s("M/d/yyyy"),
    second: s("M/d/yyyy HH:mm:ss")
  }, g = (n ? {
    year: "yyyy",
    month: "yyyy-MM",
    day: "yyyy-MM-dd",
    second: void 0
  } : o)[e];
  return g ? br.fromISO(h).toFormat(
    `${a ? "UTC:" : ""}${g}`
  ) : h.replace(/\.\d{3}/, "");
}
function a1(t) {
  return new Date(t).toISOString().split(".")[0] + "Z";
}
function Q_(t) {
  return br.fromISO(t).toFormat("yyyy-MM-dd");
}
function _6(t, e) {
  return t <= e.minValue ? e.minValue : t >= e.maxValue ? e.maxValue : e.timeValueList ? x6(t, e) : b6(t, e);
}
function x6(t, e) {
  var g;
  const n = (g = e.timeValueList) != null ? g : [];
  let a, s = 0, h = n.length - 1;
  for (; h - s > 1; )
    a = Math.floor((s + h) / 2), n[a] >= t ? h = a : s = a;
  const o = Math.abs(n[s] - t), m = Math.abs(n[h] - t);
  return n[o < m ? s : h];
}
function b6(t, e) {
  var g;
  const n = (g = e.timeInterval) != null ? g : jM, a = new Date(t).getTime(), s = new Date(e.minValue), h = e.maxValue;
  let o = e.minValue, m = Math.abs(a - o);
  for (let b = 1; ; b++) {
    const T = new Date(s.getTime());
    if (T.setFullYear(s.getFullYear() + b * n[0]), T.setMonth(
      s.getMonth() + b * n[1],
      s.getDate() + b * n[2]
    ), T.setSeconds(s.getSeconds() + b * n[3]), T.getTime() > h)
      break;
    const M = Math.abs(a - T.getTime());
    if (M <= m)
      o = T.getTime(), m = M;
    else
      break;
  }
  return o;
}
const Ai = rh("map", () => {
  const t = Mr({}), e = Fn([]), n = Fn([]), a = Mr(!1), s = Mr(!1), h = Mr(void 0);
  function o(X) {
    h.value = X;
  }
  function m(...X) {
    e.value = [.../* @__PURE__ */ new Set([...e.value, ...X])];
  }
  function g(...X) {
    n.value = [.../* @__PURE__ */ new Set([...n.value, ...X])];
  }
  function b(...X) {
    e.value = e.value.filter(
      (K) => X.indexOf(K.id) === -1
    ), n.value = n.value.filter(
      (K) => X.indexOf(K.id) === -1
    );
  }
  function T() {
    e.value = [];
  }
  function M(X) {
    var K;
    return !!((K = e.value) != null && K.find((se) => se.id === X));
  }
  function I(X, K = !1) {
    var pe;
    const se = K ? n : e;
    se.value = [
      ...((pe = se.value) == null ? void 0 : pe.sort(
        (xe, Fe) => X.indexOf(xe.id) - X.indexOf(Fe.id)
      )) || []
    ];
  }
  function P(X, K) {
    e.value = e.value.map((se) => se.id === X ? { ...se, opacity: K, previousOpacity: se.opacity } : se);
  }
  function z(X, K, se) {
    e.value = e.value.map((pe) => pe.id === X ? {
      ...pe,
      currentTimeMinValue: K ? a1(K) : void 0,
      currentTimeMaxValue: se ? a1(se) : void 0
    } : pe);
  }
  function V(X) {
    a.value = X;
  }
  function W(X) {
    s.value = X;
  }
  return {
    map: t,
    layers: e,
    layers3d: n,
    is3dActive: a,
    is3dMesh: s,
    bgLayer: h,
    addLayers: m,
    add3dLayers: g,
    removeLayers: b,
    removeAllLayers: T,
    reorderLayers: I,
    setLayerOpacity: P,
    setLayerTime: z,
    setBgLayer: o,
    setIs3dActive: V,
    setIs3dMesh: W,
    hasLayer: M
  };
});
class w6 {
  constructor() {
    bi(this, "styleWatcher");
  }
  bootstrapStyle() {
    const e = Hs();
    let n, a = !1;
    n = Na(() => {
      e.bgVectorSources && (this.restoreStyle(!1), a && this.persistStyle(), a = !0, n && n());
    });
  }
  persistStyle() {
    const e = Hs(), { bgStyle: n } = xn(e);
    this.styleWatcher || (this.styleWatcher = Bn(
      n,
      (a, s) => {
        if (s !== a) {
          const h = Ai();
          h.bgLayer && (Cr.setValue(
            h.bgLayer.name,
            a || [],
            Iy.styleToLocalStorage
          ), Cr.setValue(
            Fg,
            a || [],
            Iy.styleToSerial
          ));
        }
      },
      { immediate: !0 }
    ));
  }
  restoreStyle(e) {
    const n = Hs();
    n.setStyle(null);
    const s = Ai().bgLayer;
    if (s) {
      let h = [];
      e || (h = Cr.getValue(
        Fg,
        Iy.styleSerialToStyle
      )), h.length === 0 && (h = Cr.getValue(
        s.name,
        Iy.styleLocalStorageToStyle
      )), h && h.length > 0 && n.setStyle(h);
    }
  }
}
const GM = new w6(), E6 = [
  156543.033928,
  78271.516964,
  39135.758482,
  19567.879241,
  9783.9396205,
  4891.96981025,
  2445.98490513,
  1222.99245256,
  611.496226281,
  305.748113141,
  152.87405657,
  76.4370282852,
  38.2185141426,
  19.1092570713,
  9.55462853565,
  4.77731426782,
  2.38865713391,
  1.19432856696,
  0.597164283478,
  0.298582141739,
  0.1492910708695,
  0.07464553543475
], S6 = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "20",
  "21"
];
function us(t) {
  return us = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, us(t);
}
function el(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function T6(t, e) {
  if (us(t) !== "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var a = n.call(t, e || "default");
    if (us(a) !== "object")
      return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function qM(t) {
  var e = T6(t, "string");
  return us(e) === "symbol" ? e : String(e);
}
function N2(t, e) {
  for (var n = 0; n < e.length; n++) {
    var a = e[n];
    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, qM(a.key), a);
  }
}
function tl(t, e, n) {
  return e && N2(t.prototype, e), n && N2(t, n), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function Pu(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function s1(t, e) {
  return s1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, s) {
    return a.__proto__ = s, a;
  }, s1(t, e);
}
function Av(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && s1(t, e);
}
function tm(t, e) {
  if (e && (us(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Pu(t);
}
function Js(t) {
  return Js = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, Js(t);
}
function ju(t, e, n) {
  return e = qM(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function M6(t) {
  if (Array.isArray(t))
    return t;
}
function I6(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function R2(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, a = new Array(e); n < e; n++)
    a[n] = t[n];
  return a;
}
function O6(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return R2(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set")
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return R2(t, e);
  }
}
function C6() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function A6(t) {
  return M6(t) || I6(t) || O6(t) || C6();
}
function z2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function F2(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? z2(Object(n), !0).forEach(function(a) {
      ju(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : z2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
var P6 = {
  type: "logger",
  log: function(e) {
    this.output("log", e);
  },
  warn: function(e) {
    this.output("warn", e);
  },
  error: function(e) {
    this.output("error", e);
  },
  output: function(e, n) {
    console && console[e] && console[e].apply(console, n);
  }
}, k6 = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    el(this, t), this.init(e, n);
  }
  return tl(t, [{
    key: "init",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = a.prefix || "i18next:", this.logger = n || P6, this.options = a, this.debug = a.debug;
    }
  }, {
    key: "setDebug",
    value: function(n) {
      this.debug = n;
    }
  }, {
    key: "log",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(n, a, s, h) {
      return h && !this.debug ? null : (typeof n[0] == "string" && (n[0] = "".concat(s).concat(this.prefix, " ").concat(n[0])), this.logger[a](n));
    }
  }, {
    key: "create",
    value: function(n) {
      return new t(this.logger, F2(F2({}, {
        prefix: "".concat(this.prefix, ":").concat(n, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function(n) {
      return n = n || this.options, n.prefix = n.prefix || this.prefix, new t(this.logger, n);
    }
  }]), t;
}(), qs = new k6(), zu = function() {
  function t() {
    el(this, t), this.observers = {};
  }
  return tl(t, [{
    key: "on",
    value: function(n, a) {
      var s = this;
      return n.split(" ").forEach(function(h) {
        s.observers[h] = s.observers[h] || [], s.observers[h].push(a);
      }), this;
    }
  }, {
    key: "off",
    value: function(n, a) {
      if (!!this.observers[n]) {
        if (!a) {
          delete this.observers[n];
          return;
        }
        this.observers[n] = this.observers[n].filter(function(s) {
          return s !== a;
        });
      }
    }
  }, {
    key: "emit",
    value: function(n) {
      for (var a = arguments.length, s = new Array(a > 1 ? a - 1 : 0), h = 1; h < a; h++)
        s[h - 1] = arguments[h];
      if (this.observers[n]) {
        var o = [].concat(this.observers[n]);
        o.forEach(function(g) {
          g.apply(void 0, s);
        });
      }
      if (this.observers["*"]) {
        var m = [].concat(this.observers["*"]);
        m.forEach(function(g) {
          g.apply(g, [n].concat(s));
        });
      }
    }
  }]), t;
}();
function Zp() {
  var t, e, n = new Promise(function(a, s) {
    t = a, e = s;
  });
  return n.resolve = t, n.reject = e, n;
}
function B2(t) {
  return t == null ? "" : "" + t;
}
function L6(t, e, n) {
  t.forEach(function(a) {
    e[a] && (n[a] = e[a]);
  });
}
function J1(t, e, n) {
  function a(m) {
    return m && m.indexOf("###") > -1 ? m.replace(/###/g, ".") : m;
  }
  function s() {
    return !t || typeof t == "string";
  }
  for (var h = typeof e != "string" ? [].concat(e) : e.split("."); h.length > 1; ) {
    if (s())
      return {};
    var o = a(h.shift());
    !t[o] && n && (t[o] = new n()), Object.prototype.hasOwnProperty.call(t, o) ? t = t[o] : t = {};
  }
  return s() ? {} : {
    obj: t,
    k: a(h.shift())
  };
}
function V2(t, e, n) {
  var a = J1(t, e, Object), s = a.obj, h = a.k;
  s[h] = n;
}
function D6(t, e, n, a) {
  var s = J1(t, e, Object), h = s.obj, o = s.k;
  h[o] = h[o] || [], a && (h[o] = h[o].concat(n)), a || h[o].push(n);
}
function $g(t, e) {
  var n = J1(t, e), a = n.obj, s = n.k;
  if (!!a)
    return a[s];
}
function U2(t, e, n) {
  var a = $g(t, n);
  return a !== void 0 ? a : $g(e, n);
}
function $M(t, e, n) {
  for (var a in e)
    a !== "__proto__" && a !== "constructor" && (a in t ? typeof t[a] == "string" || t[a] instanceof String || typeof e[a] == "string" || e[a] instanceof String ? n && (t[a] = e[a]) : $M(t[a], e[a], n) : t[a] = e[a]);
  return t;
}
function of(t) {
  return t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var N6 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function R6(t) {
  return typeof t == "string" ? t.replace(/[&<>"'\/]/g, function(e) {
    return N6[e];
  }) : t;
}
var Pv = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, z6 = [" ", ",", "?", "!", ";"];
function F6(t, e, n) {
  e = e || "", n = n || "";
  var a = z6.filter(function(m) {
    return e.indexOf(m) < 0 && n.indexOf(m) < 0;
  });
  if (a.length === 0)
    return !0;
  var s = new RegExp("(".concat(a.map(function(m) {
    return m === "?" ? "\\?" : m;
  }).join("|"), ")")), h = !s.test(t);
  if (!h) {
    var o = t.indexOf(n);
    o > 0 && !s.test(t.substring(0, o)) && (h = !0);
  }
  return h;
}
function j2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Ry(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? j2(Object(n), !0).forEach(function(a) {
      ju(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : j2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function B6(t) {
  var e = V6();
  return function() {
    var a = Js(t), s;
    if (e) {
      var h = Js(this).constructor;
      s = Reflect.construct(a, arguments, h);
    } else
      s = a.apply(this, arguments);
    return tm(this, s);
  };
}
function V6() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function WM(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!!t) {
    if (t[e])
      return t[e];
    for (var a = e.split(n), s = t, h = 0; h < a.length; ++h) {
      if (!s || typeof s[a[h]] == "string" && h + 1 < a.length)
        return;
      if (s[a[h]] === void 0) {
        for (var o = 2, m = a.slice(h, h + o).join(n), g = s[m]; g === void 0 && a.length > h + o; )
          o++, m = a.slice(h, h + o).join(n), g = s[m];
        if (g === void 0)
          return;
        if (g === null)
          return null;
        if (e.endsWith(m)) {
          if (typeof g == "string")
            return g;
          if (m && typeof g[m] == "string")
            return g[m];
        }
        var b = a.slice(h + o).join(n);
        return b ? WM(g, b, n) : void 0;
      }
      s = s[a[h]];
    }
    return s;
  }
}
var U6 = function(t) {
  Av(n, t);
  var e = B6(n);
  function n(a) {
    var s, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return el(this, n), s = e.call(this), Pv && zu.call(Pu(s)), s.data = a || {}, s.options = h, s.options.keySeparator === void 0 && (s.options.keySeparator = "."), s.options.ignoreJSONStructure === void 0 && (s.options.ignoreJSONStructure = !0), s;
  }
  return tl(n, [{
    key: "addNamespaces",
    value: function(s) {
      this.options.ns.indexOf(s) < 0 && this.options.ns.push(s);
    }
  }, {
    key: "removeNamespaces",
    value: function(s) {
      var h = this.options.ns.indexOf(s);
      h > -1 && this.options.ns.splice(h, 1);
    }
  }, {
    key: "getResource",
    value: function(s, h, o) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, g = m.keySeparator !== void 0 ? m.keySeparator : this.options.keySeparator, b = m.ignoreJSONStructure !== void 0 ? m.ignoreJSONStructure : this.options.ignoreJSONStructure, T = [s, h];
      o && typeof o != "string" && (T = T.concat(o)), o && typeof o == "string" && (T = T.concat(g ? o.split(g) : o)), s.indexOf(".") > -1 && (T = s.split("."));
      var M = $g(this.data, T);
      return M || !b || typeof o != "string" ? M : WM(this.data && this.data[s] && this.data[s][h], o, g);
    }
  }, {
    key: "addResource",
    value: function(s, h, o, m) {
      var g = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, b = this.options.keySeparator;
      b === void 0 && (b = ".");
      var T = [s, h];
      o && (T = T.concat(b ? o.split(b) : o)), s.indexOf(".") > -1 && (T = s.split("."), m = h, h = T[1]), this.addNamespaces(h), V2(this.data, T, m), g.silent || this.emit("added", s, h, o, m);
    }
  }, {
    key: "addResources",
    value: function(s, h, o) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var g in o)
        (typeof o[g] == "string" || Object.prototype.toString.apply(o[g]) === "[object Array]") && this.addResource(s, h, g, o[g], {
          silent: !0
        });
      m.silent || this.emit("added", s, h, o);
    }
  }, {
    key: "addResourceBundle",
    value: function(s, h, o, m, g) {
      var b = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, T = [s, h];
      s.indexOf(".") > -1 && (T = s.split("."), m = o, o = h, h = T[1]), this.addNamespaces(h);
      var M = $g(this.data, T) || {};
      m ? $M(M, o, g) : M = Ry(Ry({}, M), o), V2(this.data, T, M), b.silent || this.emit("added", s, h, o);
    }
  }, {
    key: "removeResourceBundle",
    value: function(s, h) {
      this.hasResourceBundle(s, h) && delete this.data[s][h], this.removeNamespaces(h), this.emit("removed", s, h);
    }
  }, {
    key: "hasResourceBundle",
    value: function(s, h) {
      return this.getResource(s, h) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(s, h) {
      return h || (h = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? Ry(Ry({}, {}), this.getResource(s, h)) : this.getResource(s, h);
    }
  }, {
    key: "getDataByLanguage",
    value: function(s) {
      return this.data[s];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function(s) {
      var h = this.getDataByLanguage(s), o = h && Object.keys(h) || [];
      return !!o.find(function(m) {
        return h[m] && Object.keys(h[m]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), n;
}(zu), HM = {
  processors: {},
  addPostProcessor: function(e) {
    this.processors[e.name] = e;
  },
  handle: function(e, n, a, s, h) {
    var o = this;
    return e.forEach(function(m) {
      o.processors[m] && (n = o.processors[m].process(n, a, s, h));
    }), n;
  }
};
function G2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Po(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? G2(Object(n), !0).forEach(function(a) {
      ju(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : G2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function j6(t) {
  var e = G6();
  return function() {
    var a = Js(t), s;
    if (e) {
      var h = Js(this).constructor;
      s = Reflect.construct(a, arguments, h);
    } else
      s = a.apply(this, arguments);
    return tm(this, s);
  };
}
function G6() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var q2 = {}, $2 = function(t) {
  Av(n, t);
  var e = j6(n);
  function n(a) {
    var s, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return el(this, n), s = e.call(this), Pv && zu.call(Pu(s)), L6(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], a, Pu(s)), s.options = h, s.options.keySeparator === void 0 && (s.options.keySeparator = "."), s.logger = qs.create("translator"), s;
  }
  return tl(n, [{
    key: "changeLanguage",
    value: function(s) {
      s && (this.language = s);
    }
  }, {
    key: "exists",
    value: function(s) {
      var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (s == null)
        return !1;
      var o = this.resolve(s, h);
      return o && o.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(s, h) {
      var o = h.nsSeparator !== void 0 ? h.nsSeparator : this.options.nsSeparator;
      o === void 0 && (o = ":");
      var m = h.keySeparator !== void 0 ? h.keySeparator : this.options.keySeparator, g = h.ns || this.options.defaultNS || [], b = o && s.indexOf(o) > -1, T = !this.options.userDefinedKeySeparator && !h.keySeparator && !this.options.userDefinedNsSeparator && !h.nsSeparator && !F6(s, o, m);
      if (b && !T) {
        var M = s.match(this.interpolator.nestingRegexp);
        if (M && M.length > 0)
          return {
            key: s,
            namespaces: g
          };
        var I = s.split(o);
        (o !== m || o === m && this.options.ns.indexOf(I[0]) > -1) && (g = I.shift()), s = I.join(m);
      }
      return typeof g == "string" && (g = [g]), {
        key: s,
        namespaces: g
      };
    }
  }, {
    key: "translate",
    value: function(s, h, o) {
      var m = this;
      if (us(h) !== "object" && this.options.overloadTranslationOptionHandler && (h = this.options.overloadTranslationOptionHandler(arguments)), h || (h = {}), s == null)
        return "";
      Array.isArray(s) || (s = [String(s)]);
      var g = h.returnDetails !== void 0 ? h.returnDetails : this.options.returnDetails, b = h.keySeparator !== void 0 ? h.keySeparator : this.options.keySeparator, T = this.extractFromKey(s[s.length - 1], h), M = T.key, I = T.namespaces, P = I[I.length - 1], z = h.lng || this.language, V = h.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (z && z.toLowerCase() === "cimode") {
        if (V) {
          var W = h.nsSeparator || this.options.nsSeparator;
          return g ? {
            res: "".concat(P).concat(W).concat(M),
            usedKey: M,
            exactUsedKey: M,
            usedLng: z,
            usedNS: P
          } : "".concat(P).concat(W).concat(M);
        }
        return g ? {
          res: M,
          usedKey: M,
          exactUsedKey: M,
          usedLng: z,
          usedNS: P
        } : M;
      }
      var X = this.resolve(s, h), K = X && X.res, se = X && X.usedKey || M, pe = X && X.exactUsedKey || M, xe = Object.prototype.toString.apply(K), Fe = ["[object Number]", "[object Function]", "[object RegExp]"], ze = h.joinArrays !== void 0 ? h.joinArrays : this.options.joinArrays, Pe = !this.i18nFormat || this.i18nFormat.handleAsObject, Se = typeof K != "string" && typeof K != "boolean" && typeof K != "number";
      if (Pe && K && Se && Fe.indexOf(xe) < 0 && !(typeof ze == "string" && xe === "[object Array]")) {
        if (!h.returnObjects && !this.options.returnObjects) {
          this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          var Ie = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(se, K, Po(Po({}, h), {}, {
            ns: I
          })) : "key '".concat(M, " (").concat(this.language, ")' returned an object instead of string.");
          return g ? (X.res = Ie, X) : Ie;
        }
        if (b) {
          var Je = xe === "[object Array]", qe = Je ? [] : {}, at = Je ? pe : se;
          for (var be in K)
            if (Object.prototype.hasOwnProperty.call(K, be)) {
              var Ke = "".concat(at).concat(b).concat(be);
              qe[be] = this.translate(Ke, Po(Po({}, h), {
                joinArrays: !1,
                ns: I
              })), qe[be] === Ke && (qe[be] = K[be]);
            }
          K = qe;
        }
      } else if (Pe && typeof ze == "string" && xe === "[object Array]")
        K = K.join(ze), K && (K = this.extendTranslation(K, s, h, o));
      else {
        var ht = !1, vt = !1, Pt = h.count !== void 0 && typeof h.count != "string", tr = n.hasDefaultValue(h), Pn = Pt ? this.pluralResolver.getSuffix(z, h.count, h) : "", Rr = h["defaultValue".concat(Pn)] || h.defaultValue;
        !this.isValidLookup(K) && tr && (ht = !0, K = Rr), this.isValidLookup(K) || (vt = !0, K = M);
        var pr = h.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, Zn = pr && vt ? void 0 : K, zr = tr && Rr !== K && this.options.updateMissing;
        if (vt || ht || zr) {
          if (this.logger.log(zr ? "updateKey" : "missingKey", z, P, M, zr ? Rr : K), b) {
            var Fi = this.resolve(M, Po(Po({}, h), {}, {
              keySeparator: !1
            }));
            Fi && Fi.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var qr = [], kr = this.languageUtils.getFallbackCodes(this.options.fallbackLng, h.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && kr && kr[0])
            for (var Vn = 0; Vn < kr.length; Vn++)
              qr.push(kr[Vn]);
          else
            this.options.saveMissingTo === "all" ? qr = this.languageUtils.toResolveHierarchy(h.lng || this.language) : qr.push(h.lng || this.language);
          var Er = function(oi, Un, Y) {
            var ye = tr && Y !== K ? Y : Zn;
            m.options.missingKeyHandler ? m.options.missingKeyHandler(oi, P, Un, ye, zr, h) : m.backendConnector && m.backendConnector.saveMissing && m.backendConnector.saveMissing(oi, P, Un, ye, zr, h), m.emit("missingKey", oi, P, Un, K);
          };
          this.options.saveMissing && (this.options.saveMissingPlurals && Pt ? qr.forEach(function(En) {
            m.pluralResolver.getSuffixes(En, h).forEach(function(oi) {
              Er([En], M + oi, h["defaultValue".concat(oi)] || Rr);
            });
          }) : Er(qr, M, Rr));
        }
        K = this.extendTranslation(K, s, h, X, o), vt && K === M && this.options.appendNamespaceToMissingKey && (K = "".concat(P, ":").concat(M)), (vt || ht) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? K = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(P, ":").concat(M) : M, ht ? K : void 0) : K = this.options.parseMissingKeyHandler(K));
      }
      return g ? (X.res = K, X) : K;
    }
  }, {
    key: "extendTranslation",
    value: function(s, h, o, m, g) {
      var b = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        s = this.i18nFormat.parse(s, Po(Po({}, this.options.interpolation.defaultVariables), o), m.usedLng, m.usedNS, m.usedKey, {
          resolved: m
        });
      else if (!o.skipInterpolation) {
        o.interpolation && this.interpolator.init(Po(Po({}, o), {
          interpolation: Po(Po({}, this.options.interpolation), o.interpolation)
        }));
        var T = typeof s == "string" && (o && o.interpolation && o.interpolation.skipOnVariables !== void 0 ? o.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), M;
        if (T) {
          var I = s.match(this.interpolator.nestingRegexp);
          M = I && I.length;
        }
        var P = o.replace && typeof o.replace != "string" ? o.replace : o;
        if (this.options.interpolation.defaultVariables && (P = Po(Po({}, this.options.interpolation.defaultVariables), P)), s = this.interpolator.interpolate(s, P, o.lng || this.language, o), T) {
          var z = s.match(this.interpolator.nestingRegexp), V = z && z.length;
          M < V && (o.nest = !1);
        }
        o.nest !== !1 && (s = this.interpolator.nest(s, function() {
          for (var K = arguments.length, se = new Array(K), pe = 0; pe < K; pe++)
            se[pe] = arguments[pe];
          return g && g[0] === se[0] && !o.context ? (b.logger.warn("It seems you are nesting recursively key: ".concat(se[0], " in key: ").concat(h[0])), null) : b.translate.apply(b, se.concat([h]));
        }, o)), o.interpolation && this.interpolator.reset();
      }
      var W = o.postProcess || this.options.postProcess, X = typeof W == "string" ? [W] : W;
      return s != null && X && X.length && o.applyPostProcessor !== !1 && (s = HM.handle(X, s, h, this.options && this.options.postProcessPassResolved ? Po({
        i18nResolved: m
      }, o) : o, this)), s;
    }
  }, {
    key: "resolve",
    value: function(s) {
      var h = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, m, g, b, T, M;
      return typeof s == "string" && (s = [s]), s.forEach(function(I) {
        if (!h.isValidLookup(m)) {
          var P = h.extractFromKey(I, o), z = P.key;
          g = z;
          var V = P.namespaces;
          h.options.fallbackNS && (V = V.concat(h.options.fallbackNS));
          var W = o.count !== void 0 && typeof o.count != "string", X = W && !o.ordinal && o.count === 0 && h.pluralResolver.shouldUseIntlApi(), K = o.context !== void 0 && (typeof o.context == "string" || typeof o.context == "number") && o.context !== "", se = o.lngs ? o.lngs : h.languageUtils.toResolveHierarchy(o.lng || h.language, o.fallbackLng);
          V.forEach(function(pe) {
            h.isValidLookup(m) || (M = pe, !q2["".concat(se[0], "-").concat(pe)] && h.utils && h.utils.hasLoadedNamespace && !h.utils.hasLoadedNamespace(M) && (q2["".concat(se[0], "-").concat(pe)] = !0, h.logger.warn('key "'.concat(g, '" for languages "').concat(se.join(", "), `" won't get resolved as namespace "`).concat(M, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), se.forEach(function(xe) {
              if (!h.isValidLookup(m)) {
                T = xe;
                var Fe = [z];
                if (h.i18nFormat && h.i18nFormat.addLookupKeys)
                  h.i18nFormat.addLookupKeys(Fe, z, xe, pe, o);
                else {
                  var ze;
                  W && (ze = h.pluralResolver.getSuffix(xe, o.count, o));
                  var Pe = "".concat(h.options.pluralSeparator, "zero");
                  if (W && (Fe.push(z + ze), X && Fe.push(z + Pe)), K) {
                    var Se = "".concat(z).concat(h.options.contextSeparator).concat(o.context);
                    Fe.push(Se), W && (Fe.push(Se + ze), X && Fe.push(Se + Pe));
                  }
                }
                for (var Ie; Ie = Fe.pop(); )
                  h.isValidLookup(m) || (b = Ie, m = h.getResource(xe, pe, Ie, o));
              }
            }));
          });
        }
      }), {
        res: m,
        usedKey: g,
        exactUsedKey: b,
        usedLng: T,
        usedNS: M
      };
    }
  }, {
    key: "isValidLookup",
    value: function(s) {
      return s !== void 0 && !(!this.options.returnNull && s === null) && !(!this.options.returnEmptyString && s === "");
    }
  }, {
    key: "getResource",
    value: function(s, h, o) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(s, h, o, m) : this.resourceStore.getResource(s, h, o, m);
    }
  }], [{
    key: "hasDefaultValue",
    value: function(s) {
      var h = "defaultValue";
      for (var o in s)
        if (Object.prototype.hasOwnProperty.call(s, o) && h === o.substring(0, h.length) && s[o] !== void 0)
          return !0;
      return !1;
    }
  }]), n;
}(zu);
function e0(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
var W2 = function() {
  function t(e) {
    el(this, t), this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = qs.create("languageUtils");
  }
  return tl(t, [{
    key: "getScriptPartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return null;
      var a = n.split("-");
      return a.length === 2 || (a.pop(), a[a.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(a.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return n;
      var a = n.split("-");
      return this.formatLanguageCode(a[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(n) {
      if (typeof n == "string" && n.indexOf("-") > -1) {
        var a = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], s = n.split("-");
        return this.options.lowerCaseLng ? s = s.map(function(h) {
          return h.toLowerCase();
        }) : s.length === 2 ? (s[0] = s[0].toLowerCase(), s[1] = s[1].toUpperCase(), a.indexOf(s[1].toLowerCase()) > -1 && (s[1] = e0(s[1].toLowerCase()))) : s.length === 3 && (s[0] = s[0].toLowerCase(), s[1].length === 2 && (s[1] = s[1].toUpperCase()), s[0] !== "sgn" && s[2].length === 2 && (s[2] = s[2].toUpperCase()), a.indexOf(s[1].toLowerCase()) > -1 && (s[1] = e0(s[1].toLowerCase())), a.indexOf(s[2].toLowerCase()) > -1 && (s[2] = e0(s[2].toLowerCase()))), s.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? n.toLowerCase() : n;
    }
  }, {
    key: "isSupportedCode",
    value: function(n) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (n = this.getLanguagePartFromCode(n)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(n) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function(n) {
      var a = this;
      if (!n)
        return null;
      var s;
      return n.forEach(function(h) {
        if (!s) {
          var o = a.formatLanguageCode(h);
          (!a.options.supportedLngs || a.isSupportedCode(o)) && (s = o);
        }
      }), !s && this.options.supportedLngs && n.forEach(function(h) {
        if (!s) {
          var o = a.getLanguagePartFromCode(h);
          if (a.isSupportedCode(o))
            return s = o;
          s = a.options.supportedLngs.find(function(m) {
            if (m.indexOf(o) === 0)
              return m;
          });
        }
      }), s || (s = this.getFallbackCodes(this.options.fallbackLng)[0]), s;
    }
  }, {
    key: "getFallbackCodes",
    value: function(n, a) {
      if (!n)
        return [];
      if (typeof n == "function" && (n = n(a)), typeof n == "string" && (n = [n]), Object.prototype.toString.apply(n) === "[object Array]")
        return n;
      if (!a)
        return n.default || [];
      var s = n[a];
      return s || (s = n[this.getScriptPartFromCode(a)]), s || (s = n[this.formatLanguageCode(a)]), s || (s = n[this.getLanguagePartFromCode(a)]), s || (s = n.default), s || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(n, a) {
      var s = this, h = this.getFallbackCodes(a || this.options.fallbackLng || [], n), o = [], m = function(b) {
        !b || (s.isSupportedCode(b) ? o.push(b) : s.logger.warn("rejecting language code not found in supportedLngs: ".concat(b)));
      };
      return typeof n == "string" && n.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && m(this.formatLanguageCode(n)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && m(this.getScriptPartFromCode(n)), this.options.load !== "currentOnly" && m(this.getLanguagePartFromCode(n))) : typeof n == "string" && m(this.formatLanguageCode(n)), h.forEach(function(g) {
        o.indexOf(g) < 0 && m(s.formatLanguageCode(g));
      }), o;
    }
  }]), t;
}(), q6 = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], $6 = {
  1: function(e) {
    return Number(e > 1);
  },
  2: function(e) {
    return Number(e != 1);
  },
  3: function(e) {
    return 0;
  },
  4: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  5: function(e) {
    return Number(e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5);
  },
  6: function(e) {
    return Number(e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2);
  },
  7: function(e) {
    return Number(e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  8: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3);
  },
  9: function(e) {
    return Number(e >= 2);
  },
  10: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4);
  },
  11: function(e) {
    return Number(e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3);
  },
  12: function(e) {
    return Number(e % 10 != 1 || e % 100 == 11);
  },
  13: function(e) {
    return Number(e !== 0);
  },
  14: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3);
  },
  15: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  16: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2);
  },
  17: function(e) {
    return Number(e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1);
  },
  18: function(e) {
    return Number(e == 0 ? 0 : e == 1 ? 1 : 2);
  },
  19: function(e) {
    return Number(e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3);
  },
  20: function(e) {
    return Number(e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2);
  },
  21: function(e) {
    return Number(e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0);
  },
  22: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3);
  }
}, W6 = ["v1", "v2", "v3"], H2 = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function H6() {
  var t = {};
  return q6.forEach(function(e) {
    e.lngs.forEach(function(n) {
      t[n] = {
        numbers: e.nr,
        plurals: $6[e.fc]
      };
    });
  }), t;
}
var Z6 = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    el(this, t), this.languageUtils = e, this.options = n, this.logger = qs.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = H6();
  }
  return tl(t, [{
    key: "addRule",
    value: function(n, a) {
      this.rules[n] = a;
    }
  }, {
    key: "getRule",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
        try {
          return new Intl.PluralRules(n, {
            type: a.ordinal ? "ordinal" : "cardinal"
          });
        } catch {
          return;
        }
      return this.rules[n] || this.rules[this.languageUtils.getLanguagePartFromCode(n)];
    }
  }, {
    key: "needsPlural",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = this.getRule(n, a);
      return this.shouldUseIntlApi() ? s && s.resolvedOptions().pluralCategories.length > 1 : s && s.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(n, a) {
      var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(n, s).map(function(h) {
        return "".concat(a).concat(h);
      });
    }
  }, {
    key: "getSuffixes",
    value: function(n) {
      var a = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, h = this.getRule(n, s);
      return h ? this.shouldUseIntlApi() ? h.resolvedOptions().pluralCategories.sort(function(o, m) {
        return H2[o] - H2[m];
      }).map(function(o) {
        return "".concat(a.options.prepend).concat(o);
      }) : h.numbers.map(function(o) {
        return a.getSuffix(n, o, s);
      }) : [];
    }
  }, {
    key: "getSuffix",
    value: function(n, a) {
      var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = this.getRule(n, s);
      return h ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(h.select(a)) : this.getSuffixRetroCompatible(h, a) : (this.logger.warn("no plural rule found for: ".concat(n)), "");
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function(n, a) {
      var s = this, h = n.noAbs ? n.plurals(a) : n.plurals(Math.abs(a)), o = n.numbers[h];
      this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 && (o === 2 ? o = "plural" : o === 1 && (o = ""));
      var m = function() {
        return s.options.prepend && o.toString() ? s.options.prepend + o.toString() : o.toString();
      };
      return this.options.compatibilityJSON === "v1" ? o === 1 ? "" : typeof o == "number" ? "_plural_".concat(o.toString()) : m() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 ? m() : this.options.prepend && h.toString() ? this.options.prepend + h.toString() : h.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function() {
      return !W6.includes(this.options.compatibilityJSON);
    }
  }]), t;
}();
function Z2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Ya(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Z2(Object(n), !0).forEach(function(a) {
      ju(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Z2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
var X6 = function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    el(this, t), this.logger = qs.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || function(n) {
      return n;
    }, this.init(e);
  }
  return tl(t, [{
    key: "init",
    value: function() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      n.interpolation || (n.interpolation = {
        escapeValue: !0
      });
      var a = n.interpolation;
      this.escape = a.escape !== void 0 ? a.escape : R6, this.escapeValue = a.escapeValue !== void 0 ? a.escapeValue : !0, this.useRawValueToEscape = a.useRawValueToEscape !== void 0 ? a.useRawValueToEscape : !1, this.prefix = a.prefix ? of(a.prefix) : a.prefixEscaped || "{{", this.suffix = a.suffix ? of(a.suffix) : a.suffixEscaped || "}}", this.formatSeparator = a.formatSeparator ? a.formatSeparator : a.formatSeparator || ",", this.unescapePrefix = a.unescapeSuffix ? "" : a.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : a.unescapeSuffix || "", this.nestingPrefix = a.nestingPrefix ? of(a.nestingPrefix) : a.nestingPrefixEscaped || of("$t("), this.nestingSuffix = a.nestingSuffix ? of(a.nestingSuffix) : a.nestingSuffixEscaped || of(")"), this.nestingOptionsSeparator = a.nestingOptionsSeparator ? a.nestingOptionsSeparator : a.nestingOptionsSeparator || ",", this.maxReplaces = a.maxReplaces ? a.maxReplaces : 1e3, this.alwaysFormat = a.alwaysFormat !== void 0 ? a.alwaysFormat : !1, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var n = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(n, "g");
      var a = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(a, "g");
      var s = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(s, "g");
    }
  }, {
    key: "interpolate",
    value: function(n, a, s, h) {
      var o = this, m, g, b, T = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function M(W) {
        return W.replace(/\$/g, "$$$$");
      }
      var I = function(X) {
        if (X.indexOf(o.formatSeparator) < 0) {
          var K = U2(a, T, X);
          return o.alwaysFormat ? o.format(K, void 0, s, Ya(Ya(Ya({}, h), a), {}, {
            interpolationkey: X
          })) : K;
        }
        var se = X.split(o.formatSeparator), pe = se.shift().trim(), xe = se.join(o.formatSeparator).trim();
        return o.format(U2(a, T, pe), xe, s, Ya(Ya(Ya({}, h), a), {}, {
          interpolationkey: pe
        }));
      };
      this.resetRegExp();
      var P = h && h.missingInterpolationHandler || this.options.missingInterpolationHandler, z = h && h.interpolation && h.interpolation.skipOnVariables !== void 0 ? h.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, V = [{
        regex: this.regexpUnescape,
        safeValue: function(X) {
          return M(X);
        }
      }, {
        regex: this.regexp,
        safeValue: function(X) {
          return o.escapeValue ? M(o.escape(X)) : M(X);
        }
      }];
      return V.forEach(function(W) {
        for (b = 0; m = W.regex.exec(n); ) {
          var X = m[1].trim();
          if (g = I(X), g === void 0)
            if (typeof P == "function") {
              var K = P(n, m, h);
              g = typeof K == "string" ? K : "";
            } else if (h && Object.prototype.hasOwnProperty.call(h, X))
              g = "";
            else if (z) {
              g = m[0];
              continue;
            } else
              o.logger.warn("missed to pass in variable ".concat(X, " for interpolating ").concat(n)), g = "";
          else
            typeof g != "string" && !o.useRawValueToEscape && (g = B2(g));
          var se = W.safeValue(g);
          if (n = n.replace(m[0], se), z ? (W.regex.lastIndex += g.length, W.regex.lastIndex -= m[0].length) : W.regex.lastIndex = 0, b++, b >= o.maxReplaces)
            break;
        }
      }), n;
    }
  }, {
    key: "nest",
    value: function(n, a) {
      var s = this, h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o, m, g;
      function b(P, z) {
        var V = this.nestingOptionsSeparator;
        if (P.indexOf(V) < 0)
          return P;
        var W = P.split(new RegExp("".concat(V, "[ ]*{"))), X = "{".concat(W[1]);
        P = W[0], X = this.interpolate(X, g);
        var K = X.match(/'/g), se = X.match(/"/g);
        (K && K.length % 2 === 0 && !se || se.length % 2 !== 0) && (X = X.replace(/'/g, '"'));
        try {
          g = JSON.parse(X), z && (g = Ya(Ya({}, z), g));
        } catch (pe) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(P), pe), "".concat(P).concat(V).concat(X);
        }
        return delete g.defaultValue, P;
      }
      for (; o = this.nestingRegexp.exec(n); ) {
        var T = [];
        g = Ya({}, h), g = g.replace && typeof g.replace != "string" ? g.replace : g, g.applyPostProcessor = !1, delete g.defaultValue;
        var M = !1;
        if (o[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(o[1])) {
          var I = o[1].split(this.formatSeparator).map(function(P) {
            return P.trim();
          });
          o[1] = I.shift(), T = I, M = !0;
        }
        if (m = a(b.call(this, o[1].trim(), g), g), m && o[0] === n && typeof m != "string")
          return m;
        typeof m != "string" && (m = B2(m)), m || (this.logger.warn("missed to resolve ".concat(o[1], " for nesting ").concat(n)), m = ""), M && (m = T.reduce(function(P, z) {
          return s.format(P, z, h.lng, Ya(Ya({}, h), {}, {
            interpolationkey: o[1].trim()
          }));
        }, m.trim())), n = n.replace(o[0], m), this.regexp.lastIndex = 0;
      }
      return n;
    }
  }]), t;
}();
function X2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Al(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? X2(Object(n), !0).forEach(function(a) {
      ju(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : X2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function K6(t) {
  var e = t.toLowerCase().trim(), n = {};
  if (t.indexOf("(") > -1) {
    var a = t.split("(");
    e = a[0].toLowerCase().trim();
    var s = a[1].substring(0, a[1].length - 1);
    if (e === "currency" && s.indexOf(":") < 0)
      n.currency || (n.currency = s.trim());
    else if (e === "relativetime" && s.indexOf(":") < 0)
      n.range || (n.range = s.trim());
    else {
      var h = s.split(";");
      h.forEach(function(o) {
        if (!!o) {
          var m = o.split(":"), g = A6(m), b = g[0], T = g.slice(1), M = T.join(":").trim().replace(/^'+|'+$/g, "");
          n[b.trim()] || (n[b.trim()] = M), M === "false" && (n[b.trim()] = !1), M === "true" && (n[b.trim()] = !0), isNaN(M) || (n[b.trim()] = parseInt(M, 10));
        }
      });
    }
  }
  return {
    formatName: e,
    formatOptions: n
  };
}
function af(t) {
  var e = {};
  return function(a, s, h) {
    var o = s + JSON.stringify(h), m = e[o];
    return m || (m = t(s, h), e[o] = m), m(a);
  };
}
var Y6 = function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    el(this, t), this.logger = qs.create("formatter"), this.options = e, this.formats = {
      number: af(function(n, a) {
        var s = new Intl.NumberFormat(n, Al({}, a));
        return function(h) {
          return s.format(h);
        };
      }),
      currency: af(function(n, a) {
        var s = new Intl.NumberFormat(n, Al(Al({}, a), {}, {
          style: "currency"
        }));
        return function(h) {
          return s.format(h);
        };
      }),
      datetime: af(function(n, a) {
        var s = new Intl.DateTimeFormat(n, Al({}, a));
        return function(h) {
          return s.format(h);
        };
      }),
      relativetime: af(function(n, a) {
        var s = new Intl.RelativeTimeFormat(n, Al({}, a));
        return function(h) {
          return s.format(h, a.range || "day");
        };
      }),
      list: af(function(n, a) {
        var s = new Intl.ListFormat(n, Al({}, a));
        return function(h) {
          return s.format(h);
        };
      })
    }, this.init(e);
  }
  return tl(t, [{
    key: "init",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, s = a.interpolation;
      this.formatSeparator = s.formatSeparator ? s.formatSeparator : s.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function(n, a) {
      this.formats[n.toLowerCase().trim()] = a;
    }
  }, {
    key: "addCached",
    value: function(n, a) {
      this.formats[n.toLowerCase().trim()] = af(a);
    }
  }, {
    key: "format",
    value: function(n, a, s) {
      var h = this, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, m = a.split(this.formatSeparator), g = m.reduce(function(b, T) {
        var M = K6(T), I = M.formatName, P = M.formatOptions;
        if (h.formats[I]) {
          var z = b;
          try {
            var V = o && o.formatParams && o.formatParams[o.interpolationkey] || {}, W = V.locale || V.lng || o.locale || o.lng || s;
            z = h.formats[I](b, W, Al(Al(Al({}, P), o), V));
          } catch (X) {
            h.logger.warn(X);
          }
          return z;
        } else
          h.logger.warn("there was no format function for ".concat(I));
        return b;
      }, n);
      return g;
    }
  }]), t;
}();
function K2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Y2(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? K2(Object(n), !0).forEach(function(a) {
      ju(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : K2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function J6(t) {
  var e = Q6();
  return function() {
    var a = Js(t), s;
    if (e) {
      var h = Js(this).constructor;
      s = Reflect.construct(a, arguments, h);
    } else
      s = a.apply(this, arguments);
    return tm(this, s);
  };
}
function Q6() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function eF(t, e) {
  t.pending[e] !== void 0 && (delete t.pending[e], t.pendingCount--);
}
var tF = function(t) {
  Av(n, t);
  var e = J6(n);
  function n(a, s, h) {
    var o, m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return el(this, n), o = e.call(this), Pv && zu.call(Pu(o)), o.backend = a, o.store = s, o.services = h, o.languageUtils = h.languageUtils, o.options = m, o.logger = qs.create("backendConnector"), o.waitingReads = [], o.maxParallelReads = m.maxParallelReads || 10, o.readingCalls = 0, o.maxRetries = m.maxRetries >= 0 ? m.maxRetries : 5, o.retryTimeout = m.retryTimeout >= 1 ? m.retryTimeout : 350, o.state = {}, o.queue = [], o.backend && o.backend.init && o.backend.init(h, m.backend, m), o;
  }
  return tl(n, [{
    key: "queueLoad",
    value: function(s, h, o, m) {
      var g = this, b = {}, T = {}, M = {}, I = {};
      return s.forEach(function(P) {
        var z = !0;
        h.forEach(function(V) {
          var W = "".concat(P, "|").concat(V);
          !o.reload && g.store.hasResourceBundle(P, V) ? g.state[W] = 2 : g.state[W] < 0 || (g.state[W] === 1 ? T[W] === void 0 && (T[W] = !0) : (g.state[W] = 1, z = !1, T[W] === void 0 && (T[W] = !0), b[W] === void 0 && (b[W] = !0), I[V] === void 0 && (I[V] = !0)));
        }), z || (M[P] = !0);
      }), (Object.keys(b).length || Object.keys(T).length) && this.queue.push({
        pending: T,
        pendingCount: Object.keys(T).length,
        loaded: {},
        errors: [],
        callback: m
      }), {
        toLoad: Object.keys(b),
        pending: Object.keys(T),
        toLoadLanguages: Object.keys(M),
        toLoadNamespaces: Object.keys(I)
      };
    }
  }, {
    key: "loaded",
    value: function(s, h, o) {
      var m = s.split("|"), g = m[0], b = m[1];
      h && this.emit("failedLoading", g, b, h), o && this.store.addResourceBundle(g, b, o), this.state[s] = h ? -1 : 2;
      var T = {};
      this.queue.forEach(function(M) {
        D6(M.loaded, [g], b), eF(M, s), h && M.errors.push(h), M.pendingCount === 0 && !M.done && (Object.keys(M.loaded).forEach(function(I) {
          T[I] || (T[I] = {});
          var P = M.loaded[I];
          P.length && P.forEach(function(z) {
            T[I][z] === void 0 && (T[I][z] = !0);
          });
        }), M.done = !0, M.errors.length ? M.callback(M.errors) : M.callback());
      }), this.emit("loaded", T), this.queue = this.queue.filter(function(M) {
        return !M.done;
      });
    }
  }, {
    key: "read",
    value: function(s, h, o) {
      var m = this, g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, b = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, T = arguments.length > 5 ? arguments[5] : void 0;
      if (!s.length)
        return T(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: s,
          ns: h,
          fcName: o,
          tried: g,
          wait: b,
          callback: T
        });
        return;
      }
      this.readingCalls++;
      var M = function(V, W) {
        if (m.readingCalls--, m.waitingReads.length > 0) {
          var X = m.waitingReads.shift();
          m.read(X.lng, X.ns, X.fcName, X.tried, X.wait, X.callback);
        }
        if (V && W && g < m.maxRetries) {
          setTimeout(function() {
            m.read.call(m, s, h, o, g + 1, b * 2, T);
          }, b);
          return;
        }
        T(V, W);
      }, I = this.backend[o].bind(this.backend);
      if (I.length === 2) {
        try {
          var P = I(s, h);
          P && typeof P.then == "function" ? P.then(function(z) {
            return M(null, z);
          }).catch(M) : M(null, P);
        } catch (z) {
          M(z);
        }
        return;
      }
      return I(s, h, M);
    }
  }, {
    key: "prepareLoading",
    value: function(s, h) {
      var o = this, m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, g = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), g && g();
      typeof s == "string" && (s = this.languageUtils.toResolveHierarchy(s)), typeof h == "string" && (h = [h]);
      var b = this.queueLoad(s, h, m, g);
      if (!b.toLoad.length)
        return b.pending.length || g(), null;
      b.toLoad.forEach(function(T) {
        o.loadOne(T);
      });
    }
  }, {
    key: "load",
    value: function(s, h, o) {
      this.prepareLoading(s, h, {}, o);
    }
  }, {
    key: "reload",
    value: function(s, h, o) {
      this.prepareLoading(s, h, {
        reload: !0
      }, o);
    }
  }, {
    key: "loadOne",
    value: function(s) {
      var h = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", m = s.split("|"), g = m[0], b = m[1];
      this.read(g, b, "read", void 0, void 0, function(T, M) {
        T && h.logger.warn("".concat(o, "loading namespace ").concat(b, " for language ").concat(g, " failed"), T), !T && M && h.logger.log("".concat(o, "loaded namespace ").concat(b, " for language ").concat(g), M), h.loaded(s, T, M);
      });
    }
  }, {
    key: "saveMissing",
    value: function(s, h, o, m, g) {
      var b = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, T = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function() {
      };
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(h)) {
        this.logger.warn('did not save key "'.concat(o, '" as the namespace "').concat(h, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (!(o == null || o === "")) {
        if (this.backend && this.backend.create) {
          var M = Y2(Y2({}, b), {}, {
            isUpdate: g
          }), I = this.backend.create.bind(this.backend);
          if (I.length < 6)
            try {
              var P;
              I.length === 5 ? P = I(s, h, o, m, M) : P = I(s, h, o, m), P && typeof P.then == "function" ? P.then(function(z) {
                return T(null, z);
              }).catch(T) : T(null, P);
            } catch (z) {
              T(z);
            }
          else
            I(s, h, o, m, T, M);
        }
        !s || !s[0] || this.store.addResource(s[0], h, o, m);
      }
    }
  }]), n;
}(zu);
function J2() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      var n = {};
      if (us(e[1]) === "object" && (n = e[1]), typeof e[1] == "string" && (n.defaultValue = e[1]), typeof e[2] == "string" && (n.tDescription = e[2]), us(e[2]) === "object" || us(e[3]) === "object") {
        var a = e[3] || e[2];
        Object.keys(a).forEach(function(s) {
          n[s] = a[s];
        });
      }
      return n;
    },
    interpolation: {
      escapeValue: !0,
      format: function(e, n, a, s) {
        return e;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function Q2(t) {
  return typeof t.ns == "string" && (t.ns = [t.ns]), typeof t.fallbackLng == "string" && (t.fallbackLng = [t.fallbackLng]), typeof t.fallbackNS == "string" && (t.fallbackNS = [t.fallbackNS]), t.supportedLngs && t.supportedLngs.indexOf("cimode") < 0 && (t.supportedLngs = t.supportedLngs.concat(["cimode"])), t;
}
function eE(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Rs(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? eE(Object(n), !0).forEach(function(a) {
      ju(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : eE(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function rF(t) {
  var e = nF();
  return function() {
    var a = Js(t), s;
    if (e) {
      var h = Js(this).constructor;
      s = Reflect.construct(a, arguments, h);
    } else
      s = a.apply(this, arguments);
    return tm(this, s);
  };
}
function nF() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function zy() {
}
function iF(t) {
  var e = Object.getOwnPropertyNames(Object.getPrototypeOf(t));
  e.forEach(function(n) {
    typeof t[n] == "function" && (t[n] = t[n].bind(t));
  });
}
var Wg = function(t) {
  Av(n, t);
  var e = rF(n);
  function n() {
    var a, s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 ? arguments[1] : void 0;
    if (el(this, n), a = e.call(this), Pv && zu.call(Pu(a)), a.options = Q2(s), a.services = {}, a.logger = qs, a.modules = {
      external: []
    }, iF(Pu(a)), h && !a.isInitialized && !s.isClone) {
      if (!a.options.initImmediate)
        return a.init(s, h), tm(a, Pu(a));
      setTimeout(function() {
        a.init(s, h);
      }, 0);
    }
    return a;
  }
  return tl(n, [{
    key: "init",
    value: function() {
      var s = this, h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 ? arguments[1] : void 0;
      typeof h == "function" && (o = h, h = {}), !h.defaultNS && h.defaultNS !== !1 && h.ns && (typeof h.ns == "string" ? h.defaultNS = h.ns : h.ns.indexOf("translation") < 0 && (h.defaultNS = h.ns[0]));
      var m = J2();
      this.options = Rs(Rs(Rs({}, m), this.options), Q2(h)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = Rs(Rs({}, m.interpolation), this.options.interpolation)), h.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = h.keySeparator), h.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = h.nsSeparator);
      function g(X) {
        return X ? typeof X == "function" ? new X() : X : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? qs.init(g(this.modules.logger), this.options) : qs.init(null, this.options);
        var b;
        this.modules.formatter ? b = this.modules.formatter : typeof Intl < "u" && (b = Y6);
        var T = new W2(this.options);
        this.store = new U6(this.options.resources, this.options);
        var M = this.services;
        M.logger = qs, M.resourceStore = this.store, M.languageUtils = T, M.pluralResolver = new Z6(T, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), b && (!this.options.interpolation.format || this.options.interpolation.format === m.interpolation.format) && (M.formatter = g(b), M.formatter.init(M, this.options), this.options.interpolation.format = M.formatter.format.bind(M.formatter)), M.interpolator = new X6(this.options), M.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, M.backendConnector = new tF(g(this.modules.backend), M.resourceStore, M, this.options), M.backendConnector.on("*", function(X) {
          for (var K = arguments.length, se = new Array(K > 1 ? K - 1 : 0), pe = 1; pe < K; pe++)
            se[pe - 1] = arguments[pe];
          s.emit.apply(s, [X].concat(se));
        }), this.modules.languageDetector && (M.languageDetector = g(this.modules.languageDetector), M.languageDetector.init && M.languageDetector.init(M, this.options.detection, this.options)), this.modules.i18nFormat && (M.i18nFormat = g(this.modules.i18nFormat), M.i18nFormat.init && M.i18nFormat.init(this)), this.translator = new $2(this.services, this.options), this.translator.on("*", function(X) {
          for (var K = arguments.length, se = new Array(K > 1 ? K - 1 : 0), pe = 1; pe < K; pe++)
            se[pe - 1] = arguments[pe];
          s.emit.apply(s, [X].concat(se));
        }), this.modules.external.forEach(function(X) {
          X.init && X.init(s);
        });
      }
      if (this.format = this.options.interpolation.format, o || (o = zy), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var I = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        I.length > 0 && I[0] !== "dev" && (this.options.lng = I[0]);
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var P = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      P.forEach(function(X) {
        s[X] = function() {
          var K;
          return (K = s.store)[X].apply(K, arguments);
        };
      });
      var z = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      z.forEach(function(X) {
        s[X] = function() {
          var K;
          return (K = s.store)[X].apply(K, arguments), s;
        };
      });
      var V = Zp(), W = function() {
        var K = function(pe, xe) {
          s.isInitialized && !s.initializedStoreOnce && s.logger.warn("init: i18next is already initialized. You should call init just once!"), s.isInitialized = !0, s.options.isClone || s.logger.log("initialized", s.options), s.emit("initialized", s.options), V.resolve(xe), o(pe, xe);
        };
        if (s.languages && s.options.compatibilityAPI !== "v1" && !s.isInitialized)
          return K(null, s.t.bind(s));
        s.changeLanguage(s.options.lng, K);
      };
      return this.options.resources || !this.options.initImmediate ? W() : setTimeout(W, 0), V;
    }
  }, {
    key: "loadResources",
    value: function(s) {
      var h = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : zy, m = o, g = typeof s == "string" ? s : this.language;
      if (typeof s == "function" && (m = s), !this.options.resources || this.options.partialBundledLanguages) {
        if (g && g.toLowerCase() === "cimode")
          return m();
        var b = [], T = function(P) {
          if (!!P) {
            var z = h.services.languageUtils.toResolveHierarchy(P);
            z.forEach(function(V) {
              b.indexOf(V) < 0 && b.push(V);
            });
          }
        };
        if (g)
          T(g);
        else {
          var M = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          M.forEach(function(I) {
            return T(I);
          });
        }
        this.options.preload && this.options.preload.forEach(function(I) {
          return T(I);
        }), this.services.backendConnector.load(b, this.options.ns, function(I) {
          !I && !h.resolvedLanguage && h.language && h.setResolvedLanguage(h.language), m(I);
        });
      } else
        m(null);
    }
  }, {
    key: "reloadResources",
    value: function(s, h, o) {
      var m = Zp();
      return s || (s = this.languages), h || (h = this.options.ns), o || (o = zy), this.services.backendConnector.reload(s, h, function(g) {
        m.resolve(), o(g);
      }), m;
    }
  }, {
    key: "use",
    value: function(s) {
      if (!s)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!s.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return s.type === "backend" && (this.modules.backend = s), (s.type === "logger" || s.log && s.warn && s.error) && (this.modules.logger = s), s.type === "languageDetector" && (this.modules.languageDetector = s), s.type === "i18nFormat" && (this.modules.i18nFormat = s), s.type === "postProcessor" && HM.addPostProcessor(s), s.type === "formatter" && (this.modules.formatter = s), s.type === "3rdParty" && this.modules.external.push(s), this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function(s) {
      if (!(!s || !this.languages) && !(["cimode", "dev"].indexOf(s) > -1))
        for (var h = 0; h < this.languages.length; h++) {
          var o = this.languages[h];
          if (!(["cimode", "dev"].indexOf(o) > -1) && this.store.hasLanguageSomeTranslations(o)) {
            this.resolvedLanguage = o;
            break;
          }
        }
    }
  }, {
    key: "changeLanguage",
    value: function(s, h) {
      var o = this;
      this.isLanguageChangingTo = s;
      var m = Zp();
      this.emit("languageChanging", s);
      var g = function(I) {
        o.language = I, o.languages = o.services.languageUtils.toResolveHierarchy(I), o.resolvedLanguage = void 0, o.setResolvedLanguage(I);
      }, b = function(I, P) {
        P ? (g(P), o.translator.changeLanguage(P), o.isLanguageChangingTo = void 0, o.emit("languageChanged", P), o.logger.log("languageChanged", P)) : o.isLanguageChangingTo = void 0, m.resolve(function() {
          return o.t.apply(o, arguments);
        }), h && h(I, function() {
          return o.t.apply(o, arguments);
        });
      }, T = function(I) {
        !s && !I && o.services.languageDetector && (I = []);
        var P = typeof I == "string" ? I : o.services.languageUtils.getBestMatchFromCodes(I);
        P && (o.language || g(P), o.translator.language || o.translator.changeLanguage(P), o.services.languageDetector && o.services.languageDetector.cacheUserLanguage && o.services.languageDetector.cacheUserLanguage(P)), o.loadResources(P, function(z) {
          b(z, P);
        });
      };
      return !s && this.services.languageDetector && !this.services.languageDetector.async ? T(this.services.languageDetector.detect()) : !s && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(T) : this.services.languageDetector.detect(T) : T(s), m;
    }
  }, {
    key: "getFixedT",
    value: function(s, h, o) {
      var m = this, g = function b(T, M) {
        var I;
        if (us(M) !== "object") {
          for (var P = arguments.length, z = new Array(P > 2 ? P - 2 : 0), V = 2; V < P; V++)
            z[V - 2] = arguments[V];
          I = m.options.overloadTranslationOptionHandler([T, M].concat(z));
        } else
          I = Rs({}, M);
        I.lng = I.lng || b.lng, I.lngs = I.lngs || b.lngs, I.ns = I.ns || b.ns, I.keyPrefix = I.keyPrefix || o || b.keyPrefix;
        var W = m.options.keySeparator || ".", X;
        return I.keyPrefix && Array.isArray(T) ? X = T.map(function(K) {
          return "".concat(I.keyPrefix).concat(W).concat(K);
        }) : X = I.keyPrefix ? "".concat(I.keyPrefix).concat(W).concat(T) : T, m.t(X, I);
      };
      return typeof s == "string" ? g.lng = s : g.lngs = s, g.ns = h, g.keyPrefix = o, g;
    }
  }, {
    key: "t",
    value: function() {
      var s;
      return this.translator && (s = this.translator).translate.apply(s, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var s;
      return this.translator && (s = this.translator).exists.apply(s, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(s) {
      this.options.defaultNS = s;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(s) {
      var h = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var m = this.resolvedLanguage || this.languages[0], g = this.options ? this.options.fallbackLng : !1, b = this.languages[this.languages.length - 1];
      if (m.toLowerCase() === "cimode")
        return !0;
      var T = function(P, z) {
        var V = h.services.backendConnector.state["".concat(P, "|").concat(z)];
        return V === -1 || V === 2;
      };
      if (o.precheck) {
        var M = o.precheck(this, T);
        if (M !== void 0)
          return M;
      }
      return !!(this.hasResourceBundle(m, s) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || T(m, s) && (!g || T(b, s)));
    }
  }, {
    key: "loadNamespaces",
    value: function(s, h) {
      var o = this, m = Zp();
      return this.options.ns ? (typeof s == "string" && (s = [s]), s.forEach(function(g) {
        o.options.ns.indexOf(g) < 0 && o.options.ns.push(g);
      }), this.loadResources(function(g) {
        m.resolve(), h && h(g);
      }), m) : (h && h(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(s, h) {
      var o = Zp();
      typeof s == "string" && (s = [s]);
      var m = this.options.preload || [], g = s.filter(function(b) {
        return m.indexOf(b) < 0;
      });
      return g.length ? (this.options.preload = m.concat(g), this.loadResources(function(b) {
        o.resolve(), h && h(b);
      }), o) : (h && h(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(s) {
      if (s || (s = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !s)
        return "rtl";
      var h = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], o = this.services && this.services.languageUtils || new W2(J2());
      return h.indexOf(o.getLanguagePartFromCode(s)) > -1 || s.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var s = this, h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : zy, m = Rs(Rs(Rs({}, this.options), h), {
        isClone: !0
      }), g = new n(m);
      (h.debug !== void 0 || h.prefix !== void 0) && (g.logger = g.logger.clone(h));
      var b = ["store", "services", "language"];
      return b.forEach(function(T) {
        g[T] = s[T];
      }), g.services = Rs({}, this.services), g.services.utils = {
        hasLoadedNamespace: g.hasLoadedNamespace.bind(g)
      }, g.translator = new $2(g.services, g.options), g.translator.on("*", function(T) {
        for (var M = arguments.length, I = new Array(M > 1 ? M - 1 : 0), P = 1; P < M; P++)
          I[P - 1] = arguments[P];
        g.emit.apply(g, [T].concat(I));
      }), g.init(m, o), g.translator.options = g.options, g.translator.backendConnector.services.utils = {
        hasLoadedNamespace: g.hasLoadedNamespace.bind(g)
      }, g;
    }
  }, {
    key: "toJSON",
    value: function() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]), n;
}(zu);
ju(Wg, "createInstance", function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0;
  return new Wg(t, e);
});
var ii = Wg.createInstance();
ii.createInstance = Wg.createInstance;
ii.createInstance;
ii.dir;
ii.init;
ii.loadResources;
ii.reloadResources;
ii.use;
ii.changeLanguage;
ii.getFixedT;
ii.t;
ii.exists;
ii.setDefaultNamespace;
ii.hasLoadedNamespace;
ii.loadNamespaces;
ii.loadLanguages;
const oF = "/";
var ZM = /* @__PURE__ */ ((t) => (t.PNG = "image/png", t.JPG = "image/jpeg", t))(ZM || {}), Dl = /* @__PURE__ */ ((t) => (t.VALUE = "value", t.RANGE = "range", t))(Dl || {}), ug = /* @__PURE__ */ ((t) => (t.DATEPICKER = "datepicker", t.SLIDER = "slider", t))(ug || {});
const aF = "root_3d", sF = -222, Ro = rh(
  "config",
  () => {
    const t = Fn(), e = Mr("main"), n = lr(() => {
      var g;
      return (g = t.value) == null ? void 0 : g.themes;
    }), a = lr(
      () => {
        var g;
        return (g = n.value) == null ? void 0 : g.find((b) => b.name === e.value);
      }
    ), s = lr(() => {
      var g;
      return ((g = t.value) == null ? void 0 : g.background_layers) || [];
    }), h = lr(() => {
      var b;
      const g = (b = n.value) == null ? void 0 : b.filter(
        (T) => {
          var M;
          return ((M = T.metadata) == null ? void 0 : M.ol3d_type) !== void 0;
        }
      );
      if (!!g)
        return {
          name: aF,
          id: sF,
          children: g.flatMap(
            (T) => T != null && T.children ? T.children : T
          ),
          metadata: {}
        };
    });
    function o(g) {
      t.value = g;
    }
    function m(g) {
      e.value = g;
    }
    return {
      config: t,
      themes: n,
      themeName: e,
      theme: a,
      bgLayers: s,
      layerTrees_3d: h,
      setTheme: m,
      setThemes: o
    };
  },
  {}
);
function Hc() {
  function t(m, g) {
    return n(m, void 0, g);
  }
  function e(m, g) {
    return n(void 0, m, g);
  }
  function n(m, g, b) {
    const { theme: T } = Ro();
    if (b = b || T, m && (b == null ? void 0 : b.id) === m || g && (b == null ? void 0 : b.name) === g)
      return b;
    if (b != null && b.children)
      for (const M of b.children) {
        const I = n(m, g, M);
        if (I)
          return I;
      }
  }
  function a(m) {
    const { layerTrees_3d: g } = Ro();
    return n(m, void 0, g);
  }
  function s(m) {
    const { bgLayers: g } = Ro();
    return g.find((b) => b.id === m);
  }
  function h(m) {
    const { bgLayers: g } = Ro();
    return g.find((b) => b.name === m);
  }
  function o(m) {
    const { setTheme: g } = Ro();
    g(m);
  }
  return {
    findById: t,
    findByName: e,
    find3dLayerById: a,
    findBgLayerById: s,
    findBgLayerByName: h,
    setTheme: o
  };
}
const tE = Hc();
function ku() {
  function t(m, g) {
    try {
      const b = JSON.parse(m).concat(JSON.parse(g));
      return new Set(b).size < b.length;
    } catch {
      return !1;
    }
  }
  function e(m) {
    var g, b;
    return m.opacity = m.previousOpacity = (b = (g = m.metadata) == null ? void 0 : g.start_opacity) != null ? b : 1, n(m), m;
  }
  function n(m) {
    var b, T, M, I, P, z, V;
    m.currentTimeMinValue || (m.currentTimeMinValue = (M = (b = m.time) == null ? void 0 : b.minDefValue) != null ? M : (T = m.time) == null ? void 0 : T.minValue);
    const g = ((I = m.time) == null ? void 0 : I.mode) === Dl.RANGE;
    !m.currentTimeMaxValue && g && (m.currentTimeMaxValue = (V = (P = m.time) == null ? void 0 : P.maxDefValue) != null ? V : (z = m.time) == null ? void 0 : z.maxValue);
  }
  function a(m) {
    return [
      m.currentTimeMinValue,
      ...m.currentTimeMaxValue ? [m.currentTimeMaxValue] : []
    ].join(oF);
  }
  function s(m) {
    var M, I;
    const g = Dg();
    if (!((M = m.metadata) != null && M.exclusion))
      return;
    const b = Ai(), T = b.layers.filter(
      (P) => {
        var z, V;
        return t(
          (z = m == null ? void 0 : m.metadata) == null ? void 0 : z.exclusion,
          (V = P == null ? void 0 : P.metadata) == null ? void 0 : V.exclusion
        );
      }
    );
    T.length > 0 && (b.removeLayers(...T.map((P) => P.id)), g.addNotification(
      ii.t(
        "The layer <b>{{layersToRemove}}</b> has been removed because it cannot be displayed while the layer <b>{{layer}}</b> is displayed",
        {
          count: T.length,
          layersToRemove: T.map((P) => ii.t(P.name, { ns: "client" })).join(", "),
          layer: ii.t(m.name, { ns: "client" }),
          ns: "client"
        }
      ),
      Dd.WARNING
    )), m.id !== ((I = b.bgLayer) == null ? void 0 : I.id) && h(m);
  }
  function h(m) {
    var T, M, I;
    const g = Ai(), b = Dg();
    t(
      (T = m.metadata) == null ? void 0 : T.exclusion,
      (I = (M = g.bgLayer) == null ? void 0 : M.metadata) == null ? void 0 : I.exclusion
    ) && (g.setBgLayer(null), b.addNotification(
      ii.t(
        "Background has been deactivated because the layer {{layer}} cannot be displayed on top of it.",
        {
          layer: ii.t(m.name, { ns: "client" }),
          ns: "client"
        }
      ),
      Dd.WARNING
    ));
  }
  function o(m, g = !0, b) {
    var z;
    const T = Ro(), M = Ai(), I = b ? T.layerTrees_3d : T.theme, P = tE.findById(m, I);
    if (P) {
      const V = ((z = P.metadata) == null ? void 0 : z.linked_layers) || [];
      g === !1 ? M.removeLayers(P.id, ...V) : (s(P), (b ? M.add3dLayers : M.addLayers)(
        e(P),
        ...V.map(
          (X) => e(
            tE.findById(parseInt(X, 10))
          )
        )
      ));
    }
  }
  return {
    initLayer: e,
    getLayerCurrentTime: a,
    handleExclusionLayers: s,
    toggleLayer: o
  };
}
const Fy = -200, lF = "https://map.geoportail.lu/ogcproxywms", XM = "https://map.geoportail.lu/httpsproxy";
function Hg() {
  return dC(
    [5.31, 49.38, 6.64, 50.21],
    DT,
    md
  );
}
function uF(t) {
  const { name: e, layers: n, imageType: a, url: s, id: h } = t, o = new bC({
    url: s || lF,
    hidpi: zT(),
    serverType: "mapserver",
    params: {
      FORMAT: a,
      LAYERS: n
    },
    ...s != null || XM ? { crossOrigin: "anonymous" } : {}
  });
  if (t.currentTimeMinValue) {
    const g = o.getParams();
    g.TIME = ku().getLayerCurrentTime(t), o.updateParams(g);
  }
  const m = new _C({
    properties: {
      "olcs.extent": Hg(),
      label: e,
      id: h
    },
    source: o
  });
  return m.set("olcs.extent", Hg()), m.set("label", e), m.set("id", h), m;
}
function cF(t) {
  var b, T;
  const { name: e, imageType: n, id: a } = t, s = KM(t), h = Hy(md), o = h.getExtent(), m = new wC({
    url: fF(t),
    tilePixelRatio: s ? 2 : 1,
    layer: e,
    matrixSet: `GLOBAL_WEBMERCATOR_4_V3${s ? "_HD" : ""}`,
    format: n,
    requestEncoding: "REST",
    projection: h,
    tileGrid: new EC({
      origin: SC(o),
      extent: o,
      resolutions: E6,
      matrixIds: S6
    }),
    style: "default",
    crossOrigin: "anonymous"
  }), g = new xC({
    source: m,
    properties: {
      "olcs.extent": Hg(),
      label: e,
      id: a
    }
  });
  if (g.set("olcs.extent", Hg()), g.set("label", e), g.set("id", a), t.currentTimeMinValue) {
    const M = (T = (b = t.metadata) == null ? void 0 : b.time_layers) == null ? void 0 : T[t.currentTimeMinValue], I = m.getUrls();
    if (M && I) {
      const P = I.map(
        (z) => z.replace(
          /\/[^/]*\/{TileMatrixSet}/,
          "/" + M + "/{TileMatrixSet}"
        )
      );
      m.setUrls(P), g.set("label", M);
    }
  }
  return g;
}
function hF(t, e) {
  const n = zl(), a = t.get(e.id);
  if (!a)
    return;
  const s = Object.assign(
    {
      container: n.getOlMap().getTarget()
    },
    a
  ), h = new RT({
    maplibreOptions: s,
    label: e.name,
    id: e.id,
    queryable_id: e.id,
    metadata: e.metadata
  }), o = Hs();
  return h != null && h.getMapLibreMap().loaded() ? o.setBaseStyle(
    e.id,
    h == null ? void 0 : h.getMapLibreMap().getStyle()
  ) : new Promise(
    (m) => h == null ? void 0 : h.getMapLibreMap().once("data", m)
  ).then(
    () => o.setBaseStyle(
      e.id,
      h == null ? void 0 : h.getMapLibreMap().getStyle()
    )
  ), h;
}
function fF(t, e = "https") {
  const n = t.imageType.split("/")[1], a = Cr.getValue(Zd, $1) ? "app.geoportail.lu" : "geoportail.lu";
  return `${e === "https" ? "//wmts{3-4}." : "//wmts{1-2}."}${a}/mapproxy_4_v3/wmts/{Layer}${KM(t) ? "_hd" : ""}/{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}.${n}`;
}
function KM(t) {
  var e;
  return !!((e = t == null ? void 0 : t.metadata) != null && e.hasRetina) && zT();
}
function YM() {
  function t(P) {
    var V;
    let z;
    switch (P.type) {
      case "WMS": {
        z = uF(P);
        break;
      }
      case "WMTS":
      case "BG WMTS": {
        z = cF(P);
        break;
      }
      default:
        throw new Error(`Unrecognized layer type: ${P.type}`);
    }
    if (z.set("metadata", P.metadata), z.set("queryable_id", P.id), z.set("current_time", ku().getLayerCurrentTime(P)), z.set("time", P.time), z.setOpacity(P.opacity), (V = P.metadata) != null && V.hasOwnProperty("attribution")) {
      const W = z.getSource();
      W == null || W.setAttributions(P.metadata.attribution);
    }
    return z;
  }
  function e(P, z) {
    if (!z)
      return;
    const V = b(z);
    P.addLayer(V);
  }
  function n(P, z) {
    return P.getLayers().getArray().find((V) => V.get("id") === z);
  }
  function a(P, z) {
    const V = n(P, z);
    V && P.removeLayer(V);
  }
  function s(P, z) {
    const V = P.getLayers().getArray();
    z.forEach((W, X) => {
      const K = V.find(
        (se) => se.get("id") === W.id
      );
      K == null || K.setZIndex(X + 1);
    });
  }
  function h(P, z, V) {
    const W = P.getLayers().getArray().find((X) => X.get("id") === z);
    W && W.setOpacity(V);
  }
  function o(P) {
    $p.delete(P);
  }
  function m(P) {
    return $p.has(P.id);
  }
  function g(P, z) {
    $p.set(P, z);
  }
  function b(P) {
    const z = P.id, V = $p.get(z);
    if (V)
      return V;
    {
      const W = t(P);
      return g(z, W), W;
    }
  }
  function T(P) {
    return P && $p.get(P.id) || null;
  }
  function M(P, z) {
    const W = P.getLayers().getArray().find((X) => X.getZIndex() === Fy);
    W && z(W);
  }
  function I(P, z, V) {
    var pe;
    const W = P.getLayers(), X = W.getArray().findIndex((xe) => xe.getZIndex() === Fy), K = (pe = W.getArray()[X]) == null ? void 0 : pe.get("id");
    let se;
    z && (m(z) ? se = T(z) : (V && (se = hF(V, z)), se = se || t(z), g(z.id, se))), X >= 0 ? se ? (se.setZIndex(Fy), W.setAt(X, se)) : W.removeAt(X) : se && (se.setZIndex(Fy), P.addLayer(se)), K !== (z == null ? void 0 : z.id) && GM.restoreStyle(!0);
  }
  return {
    createLayer: t,
    addLayer: e,
    findLayer: n,
    removeLayer: a,
    removeFromCache: o,
    reorderLayers: s,
    setLayerOpacity: h,
    getLayerFromCache: T,
    setBgLayer: I,
    applyOnBgLayer: M
  };
}
class pF {
  constructor(e) {
    bi(this, "previousLayers");
    bi(this, "previousVectorSources");
    const n = Ai(), a = Hs(), s = zl(), h = Ff(), o = YM(), { appliedStyle: m } = xn(a);
    Bn(
      () => n.layers,
      (g) => {
        const b = {
          layers: this.previousLayers
        }, T = {
          layers: g
        }, M = s.getRemovedLayers(
          T,
          b
        ), I = s.getAddedLayers(
          T,
          b
        ), P = s.getMutatedLayers(
          T,
          b
        );
        M.forEach((z) => o.removeLayer(e, z.id)), I.forEach(
          (z) => o.addLayer(e, z.layer)
        ), P.forEach((z) => {
          o.setLayerOpacity(e, z.id, z.opacity);
        }), T.layers && o.reorderLayers(e, T.layers), this.previousLayers = g;
      }
    ), Bn(
      () => n.bgLayer,
      (g) => g !== void 0 && o.setBgLayer(e, g, a.bgVectorSources)
    ), Na(() => {
      a.isExpertStyleActive || (m.value = h.applyDefaultStyle(
        n.bgLayer,
        a.bgVectorBaseStyles,
        a.bgStyle
      ));
    }), Bn(m, (g) => {
      a.bgStyle === null && !a.isExpertStyleActive ? h.unregisterStyle(a.styleSerial, a.registerUrls).then(a.styleSerial = null) : h.registerStyle(g, a.styleSerial, a.registerUrls).then((b) => {
        var M;
        a.styleSerial = b;
        const T = (M = n == null ? void 0 : n.bgLayer) == null ? void 0 : M.id;
        (n == null ? void 0 : n.bgLayer) && T !== void 0 && b !== void 0 && (o.applyOnBgLayer(e, (I) => {
          I.set(
            "xyz_custom",
            h.getDefaultMapBoxStyleXYZ(b)
          );
        }), o.setBgLayer(
          e,
          n == null ? void 0 : n.bgLayer,
          a.bgVectorSources
        ));
      }), o.applyOnBgLayer(
        e,
        (b) => h.applyConsolidatedStyle(b, g)
      );
    }), Bn(
      () => a.bgVectorSources,
      (g) => {
        var b;
        for (const T of g.keys())
          (!this.previousVectorSources || this.previousVectorSources.get(T) !== g.get(T)) && (o.removeFromCache(T), T === ((b = n == null ? void 0 : n.bgLayer) == null ? void 0 : b.id) && o.setBgLayer(e, n == null ? void 0 : n.bgLayer, g));
        this.previousVectorSources = g;
      }
    );
  }
}
const dF = {
  0: 8,
  1: 9,
  2: 9,
  3: 10,
  4: 11,
  5: 12,
  6: 13,
  7: 14,
  8: 16,
  9: 17,
  10: 18,
  11: 19,
  12: 20,
  13: 21
};
class mF {
  bootstrap() {
    this.restore(), this.persist();
  }
  persistZoom() {
    const e = zl().getOlMap().getView(), n = () => {
      const a = e.getZoom();
      Cr.setValue(r2, a ? Math.ceil(a) : null);
    };
    n(), kb.listen(
      e,
      "change:resolution",
      Yw(n, 300)
    );
  }
  persistXY() {
    const e = zl().getOlMap().getView(), n = () => {
      const a = e.getCenter();
      Cr.setValue(n2, a ? Math.round(a[0]) : null), Cr.setValue(i2, a ? Math.round(a[1]) : null);
    };
    n(), kb.listen(
      e,
      OC.PROPERTYCHANGE,
      Yw(n, 300)
    );
  }
  persist() {
    this.persistXY(), this.persistZoom();
  }
  restore() {
    const e = zl().getOlMap().getView(), n = Cr.getValue(r2, Mf), a = Cr.getInitialVersion(), s = Cr.getValue(n2, Mf), h = Cr.getValue(i2, Mf), o = Cr.getValue(r5), m = mC(
      Y4,
      md
    );
    let g, b;
    n !== void 0 ? b = a === 3 ? Number(n) : dF[n] : b = 8, s != null && h != null ? a === 3 && o != null ? g = Pb([s, h], o, md) : g = a === 3 ? [s, h] : m([h, s], void 0, 2) : g = Pb(
      [6, 49.7],
      DT,
      md
    ), e.setCenter(g), e.setZoom(b);
  }
}
const yF = new mF();
function Gf(t, e) {
  const n = new t(e), a = zl(), s = wf("olMap");
  return va(() => {
    s.addControl(n), s.changed();
  }), Uu(() => {
    const h = a.getOlMap();
    h.removeControl(n), h.changed();
  }), {
    control: n
  };
}
const gF = /* @__PURE__ */ or({
  __name: "attribution-control",
  props: {
    className: { type: String, required: !1, default: "geoportailv3-attribution" },
    collapsed: { type: Boolean, required: !1, default: !1 },
    collapsible: { type: Boolean, required: !1, default: !1 }
  },
  setup(t) {
    return Gf(CC, t), (n, a) => Ye("v-if", !0);
  }
}), vF = /* @__PURE__ */ ur(gF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/attribution-control.vue"]]), _F = ["title"], xF = /* @__PURE__ */ or({
  __name: "location-control",
  props: {
    className: { type: String, required: !1, default: "location-button" },
    label: { type: String, required: !1, default: "\uE800" },
    tipLabel: { type: String, required: !1, default: "Location" }
  },
  setup(t) {
    const e = t, { t: n } = In(), a = Mr(null);
    function s() {
    }
    return va(
      () => Gf(OE, { ...e, target: a })
    ), (h, o) => (Ve(), it("div", {
      ref_key: "controlElement",
      ref: a,
      class: Pr(`tracker-off ${e.className} ${ae(ME)} ${ae(IE)}`)
    }, [
      Re("button", {
        title: ae(n)(e.tipLabel),
        onClick: s
      }, Gt(e.label), 9, _F)
    ], 2));
  }
}), bF = /* @__PURE__ */ ur(xF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/location-control.vue"]]), wF = ["title"], EF = /* @__PURE__ */ or({
  __name: "map-3d",
  props: {
    className: { type: String, required: !1, default: "map-3d-button" },
    label: { type: String, required: !1, default: "\uE057" },
    tipLabel: { type: String, required: !1, default: "3d" }
  },
  setup(t) {
    const e = t, n = Ai(), { t: a } = In(), s = Mr(null);
    va(
      () => Gf(OE, { ...e, target: s })
    );
    const h = () => {
      n.setIs3dActive(!n.is3dActive);
    };
    return (o, m) => (Ve(), it("div", {
      ref_key: "controlElement",
      ref: s,
      class: Pr(`${e.className} ${ae(ME)} ${ae(IE)} ${ae(n).is3dActive ? "active" : ""}`)
    }, [
      Re("button", {
        title: ae(a)(e.tipLabel),
        onClick: h
      }, Gt(e.label), 9, wF)
    ], 2));
  }
}), SF = /* @__PURE__ */ ur(EF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/map-3d.vue"]]), TF = /* @__PURE__ */ or({
  __name: "fullscreen-control",
  props: {
    className: { type: String, required: !1 },
    label: { type: String, required: !1, default: "\uE01C" },
    labelActive: { type: String, required: !1, default: "\uE02C" }
  },
  setup(t) {
    return Gf(AC, t), (n, a) => Ye("v-if", !0);
  }
}), MF = /* @__PURE__ */ ur(TF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/fullscreen-control.vue"]]), IF = /* @__PURE__ */ or({
  __name: "zoom-control",
  props: {
    className: { type: String, required: !1 },
    zoomInLabel: { type: String, required: !1, default: "\uE032" },
    zoomOutLabel: { type: String, required: !1, default: "\uE033" }
  },
  setup(t) {
    return Gf(PC, t), (n, a) => Ye("v-if", !0);
  }
}), OF = /* @__PURE__ */ ur(IF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/zoom-control.vue"]]);
class CF extends kC {
  constructor(n) {
    super(n);
    bi(this, "ol3dm");
  }
  handleZoomToExtent() {
    this.ol3dm && this.ol3dm.luxCameraExtentInRadians && this.ol3dm.is3dEnabled() || super.handleZoomToExtent();
  }
}
const AF = /* @__PURE__ */ or({
  __name: "zoom-to-extent-control",
  props: {
    className: { type: String, required: !1 },
    label: { type: String, required: !1, default: "\uE01B" },
    tipLabel: { type: String, required: !1 },
    extent: { type: null, required: !0 }
  },
  setup(t) {
    return Gf(CF, t), (n, a) => Ye("v-if", !0);
  }
}), PF = /* @__PURE__ */ ur(AF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map-controls/zoom-to-extent-control.vue"]]), kF = /* @__PURE__ */ or({
  __name: "map-container",
  props: {
    v4_standalone: { type: Boolean, required: !1, default: !1 }
  },
  setup(t) {
    const e = zl(), n = Mr(null), a = e.createMap(), s = [
      425152.9429259216,
      632446599999133e-8,
      914349.9239510496,
      6507914867875754e-9
    ];
    return va(() => {
      n.value && (new pF(a), yF.bootstrap(), a.setTarget(n.value), window.olMap = a);
    }), yS("olMap", a), (h, o) => (Ve(), it("div", {
      id: "map-container",
      ref_key: "mapContainer",
      ref: n,
      class: "h-full w-full bg-white absolute"
    }, [
      Ft(OF),
      Ft(PF, { extent: s }),
      Ft(MF),
      Ft(vF),
      t.v4_standalone ? (Ve(), on(SF, { key: 0 })) : Ye("v-if", !0),
      Ft(bF)
    ], 512));
  }
}), LF = /* @__PURE__ */ ur(kF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/map/map-container.vue"]]), DF = "fr", NF = !0, RF = !1, zF = !1, Pi = rh(
  "app",
  () => {
    const t = Mr(DF), e = Mr(NF), n = Mr(RF), a = Mr(zF), s = Mr(), h = Mr(), o = Mr(!1);
    function m(V) {
      t.value = V;
    }
    function g(V) {
      e.value = V, V || (a.value = !1, n.value = !1);
    }
    function b(V) {
      n.value = V, V && (a.value = !1);
    }
    function T(V) {
      a.value = V;
    }
    function M(V) {
      h.value = V;
    }
    function I(V) {
      s.value = V;
    }
    function P() {
      o.value = !0;
    }
    function z() {
      o.value = !1;
    }
    return {
      lang: t,
      layersOpen: e,
      myLayersTabOpen: n,
      themeGridOpen: a,
      mapId: s,
      styleEditorOpen: o,
      remoteLayersOpen: h,
      setLang: m,
      setLayersOpen: g,
      setMyLayersTabOpen: b,
      setThemeGridOpen: T,
      setRemoteLayersOpen: M,
      setMapId: I,
      openStyleEditorPanel: P,
      closeStyleEditorPanel: z
    };
  },
  {}
), Zg = {
  name: "blank",
  id: 0
};
function JM() {
  const t = Pi(), { mapId: e } = xn(t), n = Hc(), a = Ai(), s = ku(), h = lr(() => {
    var M;
    if (!e.value) {
      const I = (M = Ro().theme) == null ? void 0 : M.name;
      if (I)
        return os().bg_layer_theme_defaults[I] || g();
    }
    return g();
  });
  function o(M) {
    const I = n.findBgLayerById(M);
    m(I || null);
  }
  function m(M) {
    if (M) {
      if (M.type === "WMTS" || M.type === "BG WMTS")
        M.type = "BG WMTS";
      else if (M.type === "BG MVT")
        console.log(`passed through MVT layer ${M.name}`);
      else
        throw new Error(
          `Only WMTS and MVT BG layers are currently implemented (not ${M.type} for ${M.name})`
        );
      s.handleExclusionLayers(M), a.setBgLayer(s.initLayer(M));
    } else
      a.setBgLayer(null);
  }
  function g() {
    var M;
    return ((M = T().find((I) => I.is_default)) == null ? void 0 : M.id) || Zg.id;
  }
  function b() {
    return Zg.id;
  }
  function T() {
    return os().bg_layers;
  }
  return {
    setBgLayer: o,
    setMapBackground: m,
    getBgLayersFromConfig: T,
    getNullId: b,
    getDefaultSelectedId: g,
    defaultSelectedBgId: h
  };
}
const FF = ["title"], BF = /* @__PURE__ */ or({
  __name: "background-selector-item",
  props: {
    bgTitle: {
      type: String,
      default: ""
    },
    bgName: {
      type: String,
      default: ""
    }
  },
  setup(t) {
    const e = t, { t: n } = In(), a = lr(() => {
      const h = n(e.bgTitle), o = e.bgTitle.length > 0, m = `${n("Background layer:")} ${n(e.bgName)}`;
      return `${h}${o ? " - " : ""}${m}`;
    }), s = lr(
      () => `h-full w-full rounded-sm lux-bg-sel-icon
        lux-bg-sel-${e.bgName}
        bg-${e.bgName}_sm
        md:bg-${e.bgName}
        hd:bg-${e.bgName}_sm_hi
        hd_md:bg-${e.bgName}_hi`
    );
    return (h, o) => (Ve(), it("button", {
      title: ae(a),
      class: Pr(ae(s))
    }, null, 10, FF));
  }
}), rE = /* @__PURE__ */ ur(BF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/background-selector/background-selector-item.vue"]]), VF = {
  key: 0,
  class: "flex flex-row-reverse"
}, UF = /* @__PURE__ */ or({
  __name: "background-selector",
  props: {
    isOpen: {
      type: Boolean,
      default: !1
    }
  },
  setup(t) {
    const e = t, { t: n } = In(), a = JM(), s = Ai(), h = Ro(), { bgLayer: o, is3dMesh: m } = xn(s), g = Mr(e.isOpen), b = Mr([]), T = lr(
      () => {
        var z, V;
        return (V = (z = o.value) == null ? void 0 : z.id) != null ? V : a.getNullId();
      }
    ), M = lr(
      () => {
        var z, V;
        return (V = (z = b.value) == null ? void 0 : z.find((W) => W.id === T.value)) == null ? void 0 : V.name;
      }
    );
    Bn(
      () => h.bgLayers,
      (z) => {
        b.value = os().bg_layers.map(
          (V) => Object.assign(
            {
              id: V.id
            },
            z.find((W) => V.id === W.id),
            {
              name: V.icon_id
            }
          )
        );
      },
      { immediate: !0 }
    ), Bn(
      () => s.bgLayer,
      (z, V) => {
        const W = s.layers;
        V === void 0 && z === null && (W == null ? void 0 : W.length) === 0 && (a.setBgLayer(a.defaultSelectedBgId.value), z === null && Dg().addNotification(
          n(
            "Aucune couche n'\xE9tant d\xE9finie pour cette carte, une couche de fond a automatiquement \xE9t\xE9 ajout\xE9e.",
            { ns: "client" }
          )
        ));
      }
    );
    function I(z) {
      a.setBgLayer(z.id), g.value = !1;
    }
    function P() {
      g.value = !g.value;
    }
    return (z, V) => ae(m) ? Ye("v-if", !0) : (Ve(), it("div", VF, [
      Re("div", {
        class: Pr(["lux-bg-sel border border-black", g.value === !0 ? "hidden" : "block"])
      }, [
        Ft(rE, {
          "aria-expanded": g.value,
          "bg-title": "Select BG layer",
          "bg-name": ae(M),
          onClick: P
        }, null, 8, ["aria-expanded", "bg-name"])
      ], 2),
      Re("div", {
        class: Pr(g.value === !0 ? "flex flex-col md:flex-row" : "hidden")
      }, [
        (Ve(!0), it(cn, null, Ra(b.value, (W) => (Ve(), it("div", {
          key: W.id,
          class: Pr([
            "lux-bg-sel hover:bg-cyan-600",
            W.id === ae(T) ? "border-red-500 border-2" : "border-black border"
          ])
        }, [
          Ft(rE, {
            "bg-name": W.name,
            onClick: (X) => I(W)
          }, null, 8, ["bg-name", "onClick"])
        ], 2))), 128))
      ], 2)
    ]));
  }
}), jF = /* @__PURE__ */ ur(UF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/background-selector/background-selector.vue"]]), GF = /* @__PURE__ */ Re("div", { class: "fixed inset-0 bg-gray-900 opacity-40 z-[1050]" }, null, -1), qF = { class: "bg-white shadow-modal rounded-lg overflow-hidden w-[700px]" }, $F = { class: "relative flex flex-row justify-center p-4 border-b-[1px]" }, WF = { class: "text-xl" }, HF = /* @__PURE__ */ Re("span", { "aria-hidden": "true" }, "\xD7", -1), ZF = [
  HF
], XF = {
  key: 0,
  class: "p-[15px] border-t-[1px]"
}, KF = { class: "flex flex-row justify-end" }, YF = /* @__PURE__ */ or({
  __name: "modal-dialog",
  props: {
    footer: {
      type: Boolean,
      default: !0
    },
    maxHeight: {
      type: Boolean,
      default: !1
    },
    title: String
  },
  emits: ["close"],
  setup(t) {
    const { t: e } = In(), n = Mr();
    va(() => {
      n.value.focus();
    });
    const a = Fn(!0);
    function s() {
      a.value = !1;
    }
    return (h, o) => (Ve(), on(RS, { to: "body" }, [
      Ye(" backdrop "),
      GF,
      Ye(" modal "),
      Ft(bv, {
        appear: "",
        "enter-active-class": "duration-200 ease-out",
        "enter-from-class": "transform opacity-0 -translate-y-60",
        "enter-to-class": "opacity-100 translate-y-0",
        "leave-active-class": "duration-200 ease-in",
        "leave-from-class": "opacity-100 translate-y-0",
        "leave-to-class": "transform opacity-0 -translate-y-60",
        onAfterLeave: o[3] || (o[3] = (m) => h.$emit("close"))
      }, {
        default: Vd(() => [
          ae(a) ? (Ve(), it("div", {
            key: 0,
            role: "dialog",
            ref_key: "modal",
            ref: n,
            tabindex: "0",
            onKeydown: o[2] || (o[2] = Us((m) => s(), ["esc"])),
            class: "fixed inset-x-0 inset-y-8 flex items-start justify-center z-[1100] outline-none"
          }, [
            Re("div", qF, [
              Ye(" header (title)"),
              Re("div", $F, [
                Re("h4", WF, Gt(t.title), 1),
                Re("button", {
                  type: "button",
                  class: "absolute right-2 top-1 text-slate-400 text-[24px]",
                  "data-dismiss": "modal",
                  "aria-label": "Close",
                  onClick: o[0] || (o[0] = (m) => s())
                }, ZF)
              ]),
              Ye(" content slot "),
              Re("div", {
                class: Pr(["p-[15px] overflow-y-auto", t.maxHeight ? "max-h-96" : "max-h-full"])
              }, [
                IP(h.$slots, "content")
              ], 2),
              Ye(" footer (optional)"),
              t.footer ? (Ve(), it("div", XF, [
                Re("div", KF, [
                  Re("button", {
                    type: "button",
                    class: "lux-btn",
                    "data-dismiss": "modal",
                    onClick: o[1] || (o[1] = (m) => s())
                  }, Gt(ae(e)("Close", { ns: "client" })), 1)
                ])
              ])) : Ye("v-if", !0)
            ])
          ], 544)) : Ye("v-if", !0)
        ]),
        _: 3
      })
    ]));
  }
}), QM = /* @__PURE__ */ ur(YF, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/modal-dialog.vue"]]), Q1 = rh(
  "metadata",
  () => {
    const t = Mr();
    function e(a) {
      t.value = a;
    }
    function n() {
      t.value = void 0;
    }
    return {
      metadataId: t,
      setMetadataId: e,
      clearMetadataId: n
    };
  },
  {}
), JF = {
  class: "mb-px",
  key: "node.id"
}, QF = ["aria-expanded", "data-cy"], eB = { class: "leading-6" }, tB = ["aria-expanded", "data-cy"], rB = { class: "grow" }, nB = { class: "leading-6" }, iB = {
  key: 1,
  class: "flex text-tertiary pr-2"
}, oB = ["data-cy"], aB = { class: "ml-1 hover:underline" }, sB = /* @__PURE__ */ or({
  __name: "layer-tree-node",
  props: {
    node: { type: null, required: !0 }
  },
  emits: ["toggleLayer", "toggleParent"],
  setup(t, { emit: e }) {
    const n = t, { t: a } = In(), { setMetadataId: s } = Q1(), h = !!n.node.children, o = n.node.depth === 0, m = n.node.depth >= 10, g = lr(() => a(n.node.name, { ns: "client" }));
    function b(M) {
      e("toggleLayer", M);
    }
    function T(M) {
      e("toggleParent", M);
    }
    return (M, I) => {
      const P = TP("layer-tree-node", !0);
      return h ? (Ve(), it("div", JF, [
        Ye("    First level parents"),
        t.node.depth === 1 ? (Ve(), it("button", {
          key: 0,
          class: "group node-1 w-full text-left flex px-2 py-1.5 uppercase bg-tertiary",
          "aria-expanded": t.node.expanded,
          onClick: I[0] || (I[0] = (z) => T(t.node)),
          "data-cy": `parentLayerLabel-${t.node.id}`
        }, [
          Re("div", {
            class: Pr(["grow", t.node.expanded ? "text-white" : "text-secondary"])
          }, Gt(ae(g)), 3),
          Re("div", eB, [
            Re("div", {
              class: Pr(["fa fa-sharp fa-solid group-hover:text-white text-primary", t.node.expanded ? "fa-caret-up" : "fa-caret-down"])
            }, null, 2)
          ])
        ], 8, QF)) : t.node.depth > 1 && !m ? (Ve(), it(cn, { key: 1 }, [
          Ye("    Other parents"),
          Re("button", {
            class: Pr(["w-full text-left flex px-2 py-1.5 pl-2", t.node.expanded ? "text-tertiary" : "bg-white text-primary"]),
            "aria-expanded": t.node.expanded,
            onClick: I[1] || (I[1] = (z) => T(t.node)),
            "data-cy": `parentLayerLabel-${t.node.id}`
          }, [
            Re("div", rB, Gt(ae(g)), 1),
            Re("div", nB, [
              Re("div", {
                class: Pr(["fa-sharp fa-solid", t.node.expanded ? "fa-minus" : "fa-plus"])
              }, null, 2)
            ])
          ], 10, tB)
        ], 2112)) : Ye("v-if", !0),
        Ye("    Children"),
        m ? Ye("v-if", !0) : (Ve(), it("div", {
          key: 2,
          class: Pr(["bg-secondary", [
            { "pl-2": t.node.depth > 1 },
            { "lux-collapse": !o },
            { expanded: !o && t.node.expanded }
          ]])
        }, [
          (Ve(!0), it(cn, null, Ra(t.node.children, (z) => (Ve(), on(P, {
            key: z.id,
            node: z,
            onToggleParent: I[2] || (I[2] = (V) => T(V)),
            onToggleLayer: I[3] || (I[3] = (V) => b(V))
          }, null, 8, ["node"]))), 128))
        ], 2))
      ])) : (Ve(), it("div", iB, [
        Re("button", {
          class: "self-start before:text-[.85rem] before:transform before:translate-y-[.1rem] before:inline-block before:content-['\\f129'] fa-solid fa-fw fa-fh fa-info",
          onClick: I[4] || (I[4] = (z) => ae(s)(t.node.id))
        }),
        Re("button", {
          class: Pr(["w-full text-left", { "font-bold": t.node.checked }]),
          onClick: I[5] || (I[5] = (z) => b(t.node)),
          "data-cy": `layerLabel-${t.node.id}`
        }, [
          Re("i", {
            class: Pr(["fa-solid", t.node.checked ? "fa-check-square" : "fa-square"])
          }, null, 2),
          Re("span", aB, Gt(ae(g)), 1)
        ], 10, oB)
      ]));
    };
  }
}), l1 = /* @__PURE__ */ ur(sB, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-tree/layer-tree-node.vue"]]);
class lB {
  toggleNode(e, n, a) {
    var s;
    return (n == null ? void 0 : n.id) === e ? {
      ...n,
      [a]: !n[a]
    } : {
      ...n,
      children: (s = n.children) == null ? void 0 : s.map(
        (h) => this.toggleNode(e, h, a)
      )
    };
  }
  updateLayers(e, n) {
    const { id: a } = e;
    if (e.children)
      return {
        ...e,
        children: e.children.map((s) => this.updateLayers(s, n))
      };
    {
      const s = !!(n != null && n.find((h) => h.id === a));
      return {
        ...e,
        checked: s
      };
    }
  }
}
const Cf = new lB();
var Da = /* @__PURE__ */ ((t) => (t.WMS = "WMS", t.WMTS = "WMTS", t))(Da || {});
class t0 {
  constructor(e, n = 0, a = !1) {
    this.message = e, this.httpStatus = n, this.isCrossOriginRelated = a;
  }
}
let uB = 0;
function cB() {
  return uB++;
}
function hB(t, e, n) {
  return new Promise((a, s) => {
    const h = cB(), o = {
      requestId: h,
      taskName: t,
      params: n
    };
    e === null ? window.dispatchEvent(
      new CustomEvent("ogc-client.request", {
        detail: o
      })
    ) : e.postMessage(o);
    const m = ({ detail: g, data: b }) => {
      const T = g || b;
      T.requestId === h && (e === null ? window.removeEventListener("message", m) : e.removeEventListener("message", m), "error" in T ? s(T.error) : a(T.response));
    };
    e === null ? window.addEventListener("ogc-client.response", m) : e.addEventListener("message", m);
  });
}
function ex(t, e, n) {
  const a = typeof WorkerGlobalScope < "u", s = async ({ detail: h, data: o }) => {
    const m = h || o;
    if (m.taskName === t) {
      let g, b;
      try {
        g = await n(m.params);
      } catch (M) {
        b = M;
      }
      const T = {
        taskName: t,
        requestId: m.requestId,
        ...g && { response: g },
        ...b && { error: b }
      };
      a ? e.postMessage(T) : e.dispatchEvent(
        new CustomEvent("ogc-client.response", {
          detail: T
        })
      );
    }
  };
  a ? e.addEventListener("message", s) : e.addEventListener("ogc-client.request", s);
}
let r0;
function fB() {
  return r0 || (r0 = new Worker(URL.createObjectURL(new Blob([`function t(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function e(t,e,r,n,o,i,a){try{var c=t[i](a),u=c.value}catch(t){return void r(t)}c.done?e(u):Promise.resolve(u).then(n,o)}function r(t){return function(){var r=this,n=arguments;return new Promise((function(o,i){var a=t.apply(r,n);function c(t){e(a,o,i,c,u,"next",t)}function u(t){e(a,o,i,c,u,"throw",t)}c(void 0)}))}}function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}var o={exports:{}};!function(t){var e=function(t){var e,r=Object.prototype,o=r.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function s(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{s({},"")}catch(t){s=function(t,e,r){return t[e]=r}}function f(t,e,r,n){var o=e&&e.prototype instanceof m?e:m,i=Object.create(o.prototype),a=new j(n||[]);return i._invoke=function(t,e,r){var n=h;return function(o,i){if(n===v)throw new Error("Generator is already running");if(n===d){if("throw"===o)throw i;return G()}for(r.method=o,r.arg=i;;){var a=r.delegate;if(a){var c=k(a,r);if(c){if(c===y)continue;return c}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===h)throw n=d,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=v;var u=l(t,e,r);if("normal"===u.type){if(n=r.done?d:p,u.arg===y)continue;return{value:u.arg,done:r.done}}"throw"===u.type&&(n=d,r.method="throw",r.arg=u.arg)}}}(t,r,a),i}function l(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=f;var h="suspendedStart",p="suspendedYield",v="executing",d="completed",y={};function m(){}function g(){}function b(){}var S={};S[a]=function(){return this};var E=Object.getPrototypeOf,w=E&&E(E(C([])));w&&w!==r&&o.call(w,a)&&(S=w);var O=b.prototype=m.prototype=Object.create(S);function x(t){["next","throw","return"].forEach((function(e){s(t,e,(function(t){return this._invoke(e,t)}))}))}function P(t,e){function r(i,a,c,u){var s=l(t[i],t,a);if("throw"!==s.type){var f=s.arg,h=f.value;return h&&"object"===n(h)&&o.call(h,"__await")?e.resolve(h.__await).then((function(t){r("next",t,c,u)}),(function(t){r("throw",t,c,u)})):e.resolve(h).then((function(t){f.value=t,c(f)}),(function(t){return r("throw",t,c,u)}))}u(s.arg)}var i;this._invoke=function(t,n){function o(){return new e((function(e,o){r(t,n,e,o)}))}return i=i?i.then(o,o):o()}}function k(t,r){var n=t.iterator[r.method];if(n===e){if(r.delegate=null,"throw"===r.method){if(t.iterator.return&&(r.method="return",r.arg=e,k(t,r),"throw"===r.method))return y;r.method="throw",r.arg=new TypeError("The iterator does not provide a 'throw' method")}return y}var o=l(n,t.iterator,r.arg);if("throw"===o.type)return r.method="throw",r.arg=o.arg,r.delegate=null,y;var i=o.arg;return i?i.done?(r[t.resultName]=i.value,r.next=t.nextLoc,"return"!==r.method&&(r.method="next",r.arg=e),r.delegate=null,y):i:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function R(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function T(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function j(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(R,this),this.reset(!0)}function C(t){if(t){var r=t[a];if(r)return r.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,i=function r(){for(;++n<t.length;)if(o.call(t,n))return r.value=t[n],r.done=!1,r;return r.value=e,r.done=!0,r};return i.next=i}}return{next:G}}function G(){return{value:e,done:!0}}return g.prototype=O.constructor=b,b.constructor=g,g.displayName=s(b,u,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===g||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,b):(t.__proto__=b,s(t,u,"GeneratorFunction")),t.prototype=Object.create(O),t},t.awrap=function(t){return{__await:t}},x(P.prototype),P.prototype[c]=function(){return this},t.AsyncIterator=P,t.async=function(e,r,n,o,i){void 0===i&&(i=Promise);var a=new P(f(e,r,n,o),i);return t.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},x(O),s(O,u,"Generator"),O[a]=function(){return this},O.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=C,j.prototype={constructor:j,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(T),!t)for(var r in this)"t"===r.charAt(0)&&o.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=e)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var r=this;function n(n,o){return c.type="throw",c.arg=t,r.next=n,o&&(r.method="next",r.arg=e),!!o}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],c=a.completion;if("root"===a.tryLoc)return n("end");if(a.tryLoc<=this.prev){var u=o.call(a,"catchLoc"),s=o.call(a,"finallyLoc");if(u&&s){if(this.prev<a.catchLoc)return n(a.catchLoc,!0);if(this.prev<a.finallyLoc)return n(a.finallyLoc)}else if(u){if(this.prev<a.catchLoc)return n(a.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return n(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&o.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var i=n;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),T(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;T(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,r,n){return this.delegate={iterator:C(t),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=e),y}},t}(t.exports);try{regeneratorRuntime=e}catch(t){Function("r","regeneratorRuntime = r")(e)}}(o);var i=o.exports;function a(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?a(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(t,e,n){var o="undefined"!=typeof WorkerGlobalScope,a=function(){var a=r(i.mark((function r(a){var u,s,f,l,h,p;return i.wrap((function(r){for(;;)switch(r.prev=r.next){case 0:if(u=a.detail,s=a.data,(f=u||s).taskName!==t){r.next=14;break}return r.prev=3,r.next=6,n(f.params);case 6:l=r.sent,r.next=12;break;case 9:r.prev=9,r.t0=r.catch(3),h=r.t0;case 12:p=c(c({taskName:t,requestId:f.requestId},l&&{response:l}),h&&{error:h}),o?e.postMessage(p):e.dispatchEvent(new CustomEvent("ogc-client.response",{detail:p}));case 14:case"end":return r.stop()}}),r,null,[[3,9]])})));return function(t){return a.apply(this,arguments)}}();o?e.addEventListener("message",a):e.addEventListener("ogc-client.request",a)}function s(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function f(t){return function(t){if(Array.isArray(t))return s(t)}(t)||function(t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||function(t,e){if(t){if("string"==typeof t)return s(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?s(t,e):void 0}}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function l(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function h(t,e){return h=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},h(t,e)}function p(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&h(t,e)}function v(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function d(t){return d=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},d(t)}function y(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function m(t,e,r){return m=y()?Reflect.construct:function(t,e,r){var n=[null];n.push.apply(n,e);var o=new(Function.bind.apply(t,n));return r&&h(o,r.prototype),o},m.apply(null,arguments)}function g(t){var e="function"==typeof Map?new Map:void 0;return g=function(t){if(null===t||(r=t,-1===Function.toString.call(r).indexOf("[native code]")))return t;var r;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,n)}function n(){return m(t,arguments,d(this).constructor)}return n.prototype=Object.create(t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),h(n,t)},g(t)}function b(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function S(t,e,r){return e&&b(t.prototype,e),r&&b(t,r),t}var E=function(){function t(e){l(this,t),this.chars=f(e),this.charCount=this.chars.length,this.charIndex=0,this.charsToBytes=new Array(this.charCount),this.multiByteMode=!1,this.string=e;var r=this.chars,n=this.charCount,o=this.charsToBytes;if(n===e.length)for(var i=0;i<n;++i)o[i]=i;else{for(var a=0,c=0;c<n;++c)o[c]=a,a+=r[c].length;this.multiByteMode=!0}}return S(t,[{key:"isEnd",get:function(){return this.charIndex>=this.charCount}},{key:"_charLength",value:function(t){var e=t.length;return e<2||!this.multiByteMode?e:t.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,"_").length}},{key:"advance",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.charIndex=Math.min(this.charCount,this.charIndex+t)}},{key:"consume",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=this.peek(t);return this.advance(t),e}},{key:"consumeMatch",value:function(t){if(!t.sticky)throw new Error('\`regex\` must have a sticky flag ("y")');t.lastIndex=this.charsToBytes[this.charIndex];var e=t.exec(this.string);if(null===e)return"";var r=e[0];return this.advance(this._charLength(r)),r}},{key:"consumeMatchFn",value:function(t){for(var e=this.charIndex;!this.isEnd&&t(this.peek());)this.advance();return this.charIndex>e?this.string.slice(this.charsToBytes[e],this.charsToBytes[this.charIndex]):""}},{key:"consumeString",value:function(t){if(this.consumeStringFast(t))return t;if(!this.multiByteMode)return"";var e=t.length,r=this._charLength(t);return r!==e&&t===this.peek(r)?(this.advance(r),t):""}},{key:"consumeStringFast",value:function(t){if(this.peek()===t[0]){var e=t.length;if(1===e)return this.advance(),t;if(this.peek(e)===t)return this.advance(e),t}return""}},{key:"consumeUntilMatch",value:function(t){if(!t.global)throw new Error('\`regex\` must have a global flag ("g")');var e=this.charsToBytes[this.charIndex];t.lastIndex=e;var r=t.exec(this.string);if(null===r||r.index===e)return"";var n=this.string.slice(e,r.index);return this.advance(this._charLength(n)),n}},{key:"consumeUntilString",value:function(t){var e=this.charIndex,r=this.charsToBytes,n=this.string,o=r[e],i=n.indexOf(t,o);if(i<=0)return"";var a=n.slice(o,i);return this.advance(this._charLength(a)),a}},{key:"peek",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;if(this.charIndex>=this.charCount)return"";if(1===t)return this.chars[this.charIndex];var e=this.charsToBytes,r=this.charIndex;return this.string.slice(e[r],e[r+t])}},{key:"reset",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;this.charIndex=t>=0?Math.min(this.charCount,t):Math.max(0,this.charIndex+t)}}]),t}(),w=E,O={},x=Object.freeze(Object.assign(Object.create(null),{amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}));function P(t){if(k(t))return!0;var e=T(t);return 45===e||46===e||e>=48&&e<=57||183===e||e>=768&&e<=879||e>=8255&&e<=8256}function k(t){var e=T(t);return 58===e||95===e||e>=65&&e<=90||e>=97&&e<=122||e>=192&&e<=214||e>=216&&e<=246||e>=248&&e<=767||e>=880&&e<=893||e>=895&&e<=8191||e>=8204&&e<=8205||e>=8304&&e<=8591||e>=11264&&e<=12271||e>=12289&&e<=55295||e>=63744&&e<=64975||e>=65008&&e<=65533||e>=65536&&e<=983039}function R(t){var e=T(t);return 9===e||10===e||13===e||e>=32&&e<=55295||e>=57344&&e<=65533||e>=65536&&e<=1114111}function T(t){return t.codePointAt(0)||-1}O.predefinedEntities=x,O.isNameChar=P,O.isNameStartChar=k,O.isNotXmlChar=function(t){return!R(t)},O.isReferenceChar=function(t){return"#"===t||P(t)},O.isWhitespace=function(t){var e=T(t);return 32===e||9===e||10===e||13===e},O.isXmlChar=R;var j=function(){function t(){l(this,t),this.parent=null}return S(t,[{key:"document",get:function(){return this.parent?this.parent.document:null}},{key:"isRootNode",get:function(){return!!this.parent&&this.parent===this.document}},{key:"preserveWhitespace",get:function(){return Boolean(this.parent&&this.parent.preserveWhitespace)}},{key:"type",get:function(){return""}},{key:"toJSON",value:function(){var t={type:this.type};return this.isRootNode&&(t.isRootNode=!0),this.preserveWhitespace&&(t.preserveWhitespace=!0),t}}]),t}();j.TYPE_CDATA="cdata",j.TYPE_COMMENT="comment",j.TYPE_DOCUMENT="document",j.TYPE_ELEMENT="element",j.TYPE_PROCESSING_INSTRUCTION="pi",j.TYPE_TEXT="text";var C=j;function G(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var N=C,A=function(t){p(r,N);var e=G(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).text=n,t}return S(r,[{key:"type",get:function(){return N.TYPE_TEXT}},{key:"toJSON",value:function(){return Object.assign(N.prototype.toJSON.call(this),{text:this.text})}}]),r}(),F=A;function I(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var L=C,M=F,B=function(t){p(r,M);var e=I(r);function r(){return l(this,r),e.apply(this,arguments)}return S(r,[{key:"type",get:function(){return L.TYPE_CDATA}}]),r}(),_=B;function U(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var D=C,W=function(t){p(r,D);var e=U(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).content=n,t}return S(r,[{key:"type",get:function(){return D.TYPE_COMMENT}},{key:"toJSON",value:function(){return Object.assign(D.prototype.toJSON.call(this),{content:this.content})}}]),r}(),X=W;function Y(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var q=C,J=function(t){p(r,q);var e=Y(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Object.create(null),i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return l(this,r),(n=e.call(this)).name=t,n.attributes=o,n.children=i,n}return S(r,[{key:"isEmpty",get:function(){return 0===this.children.length}},{key:"preserveWhitespace",get:function(){for(var t=this;t instanceof r;){if("xml:space"in t.attributes)return"preserve"===t.attributes["xml:space"];t=t.parent}return!1}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return q.TYPE_ELEMENT}},{key:"toJSON",value:function(){return Object.assign(q.prototype.toJSON.call(this),{name:this.name,attributes:this.attributes,children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),V=J;function $(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var K=V,z=C,H=function(t){p(r,z);var e=$(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return l(this,r),(t=e.call(this)).children=n,t}return S(r,[{key:"document",get:function(){return this}},{key:"root",get:function(){return this.children.find((function(t){return t instanceof K}))||null}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return z.TYPE_DOCUMENT}},{key:"toJSON",value:function(){return Object.assign(z.prototype.toJSON.call(this),{children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),Q=H;function Z(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var tt=C,et=function(t){p(r,tt);var e=Z(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return l(this,r),(n=e.call(this)).name=t,n.content=o,n}return S(r,[{key:"type",get:function(){return tt.TYPE_PROCESSING_INSTRUCTION}},{key:"toJSON",value:function(){return Object.assign(tt.prototype.toJSON.call(this),{name:this.name,content:this.content})}}]),r}(),rt=et;function nt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return ot(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return ot(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function ot(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var it=w,at=O,ct=_,ut=X,st=Q,ft=V,lt=rt,ht=F,pt=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(l(this,t),this.document=new st,this.currentNode=this.document,this.options=r,this.scanner=new it(vt(e)),this.consumeProlog(),this.consumeElement()||this.error("Root element is missing or invalid");this.consumeMisc(););this.scanner.isEnd||this.error("Extra content at the end of the document")}return S(t,[{key:"addNode",value:function(t){t.parent=this.currentNode,this.currentNode.children.push(t)}},{key:"addText",value:function(t){var e=this.currentNode.children;if(e.length>0){var r=e[e.length-1];if(r instanceof ht)return void(r.text+=t)}this.addNode(new ht(t))}},{key:"consumeAttributeValue",value:function(){var t,e=this.scanner,r=e.peek();if('"'!==r&&"'"!==r)return!1;e.advance();var n=!1,o="",i='"'===r?new RegExp('[^"&<]+',"y"):new RegExp("[^'&<]+","y");t:for(;!e.isEnd;){switch((t=e.consumeMatch(i))&&(this.validateChars(t),o+=t.replace(/[\\t\\r\\n]/g," ")),e.peek()){case r:n=!0;break t;case"&":o+=this.consumeReference();continue;case"<":this.error("Unescaped \`<\` is not allowed in an attribute value");break;case"":this.error("Unclosed attribute")}}return n||this.error("Unclosed attribute"),e.advance(),o}},{key:"consumeCdataSection",value:function(){var t=this.scanner;if(!t.consumeStringFast("<![CDATA["))return!1;var e=t.consumeUntilString("]]>");return this.validateChars(e),t.consumeStringFast("]]>")||this.error("Unclosed CDATA section"),this.options.preserveCdata?this.addNode(new ct(e)):this.addText(e),!0}},{key:"consumeCharData",value:function(){var t=this.scanner,e=t.consumeUntilMatch(/<|&|]]>/g);return!!e&&(this.validateChars(e),"]"===t.peek()&&"]]>"===t.peek(3)&&this.error("Element content may not contain the CDATA section close delimiter \`]]>\`"),this.addText(e),!0)}},{key:"consumeComment",value:function(){var t=this.scanner;if(!t.consumeStringFast("\\x3c!--"))return!1;var e=t.consumeUntilString("--");return this.validateChars(e),t.consumeStringFast("--\\x3e")||("--"===t.peek(2)?this.error("The string \`--\` isn't allowed inside a comment"):this.error("Unclosed comment")),this.options.preserveComments&&this.addNode(new ut(e.trim())),!0}},{key:"consumeContentReference",value:function(){var t=this.consumeReference();return!!t&&(this.addText(t),!0)}},{key:"consumeDoctypeDeclaration",value:function(){var t=this.scanner;return!(!t.consumeStringFast("<!DOCTYPE")||!this.consumeWhitespace())&&(t.consumeMatch(new RegExp("[^[>]+","y")),t.consumeMatch(new RegExp("\\\\[[\\\\s\\\\S]+?\\\\][\\\\x20\\\\t\\\\r\\\\n]*>","y"))||t.consumeStringFast(">")||this.error("Unclosed doctype declaration"),!0)}},{key:"consumeElement",value:function(){var t=this.scanner,e=t.charIndex;if("<"!==t.peek())return!1;t.advance();var r=this.consumeName();if(!r)return t.reset(e),!1;for(var n=Object.create(null);this.consumeWhitespace();){var o=this.consumeName();if(o){var i=this.consumeEqual()&&this.consumeAttributeValue();!1===i&&this.error("Attribute value expected"),o in n&&this.error("Duplicate attribute: ".concat(o)),"xml:space"===o&&"default"!==i&&"preserve"!==i&&this.error('Value of the \`xml:space\` attribute must be "default" or "preserve"'),n[o]=i}}if(this.options.sortAttributes){for(var a=Object.keys(n).sort(),c=Object.create(null),u=0;u<a.length;++u){var s=a[u];c[s]=n[s]}n=c}var f=Boolean(t.consumeStringFast("/>")),l=new ft(r,n);if(l.parent=this.currentNode,!f){for(t.consumeStringFast(">")||this.error("Unclosed start tag for element \`".concat(r,"\`")),this.currentNode=l,this.consumeCharData();this.consumeElement()||this.consumeContentReference()||this.consumeCdataSection()||this.consumeProcessingInstruction()||this.consumeComment();)this.consumeCharData();var h,p=t.charIndex;t.consumeStringFast("</")&&(h=this.consumeName())&&h===r||(t.reset(p),this.error("Missing end tag for element ".concat(r))),this.consumeWhitespace(),t.consumeStringFast(">")||this.error("Unclosed end tag for element ".concat(r)),this.currentNode=l.parent}return this.addNode(l),!0}},{key:"consumeEqual",value:function(){return this.consumeWhitespace(),!!this.scanner.consumeStringFast("=")&&(this.consumeWhitespace(),!0)}},{key:"consumeMisc",value:function(){return this.consumeComment()||this.consumeProcessingInstruction()||this.consumeWhitespace()}},{key:"consumeName",value:function(){return at.isNameStartChar(this.scanner.peek())?this.scanner.consumeMatchFn(at.isNameChar):""}},{key:"consumeProcessingInstruction",value:function(){var t=this.scanner,e=t.charIndex;if(!t.consumeStringFast("<?"))return!1;var r=this.consumeName();if(r?"xml"===r.toLowerCase()&&(t.reset(e),this.error("XML declaration isn't allowed here")):this.error("Invalid processing instruction"),!this.consumeWhitespace()){if(t.consumeStringFast("?>"))return this.addNode(new lt(r)),!0;this.error("Whitespace is required after a processing instruction name")}var n=t.consumeUntilString("?>");return this.validateChars(n),t.consumeStringFast("?>")||this.error("Unterminated processing instruction"),this.addNode(new lt(r,n)),!0}},{key:"consumeProlog",value:function(){var t=this.scanner,e=t.charIndex;for(this.consumeXmlDeclaration();this.consumeMisc(););if(this.consumeDoctypeDeclaration())for(;this.consumeMisc(););return e<t.charIndex}},{key:"consumeReference",value:function(){var t=this.scanner;if("&"!==t.peek())return!1;t.advance();var e,r=t.consumeMatchFn(at.isReferenceChar);if(";"!==t.consume()&&this.error("Unterminated reference (a reference must end with \`;\`)"),"#"===r[0]){var o="x"===r[1]?parseInt(r.slice(2),16):parseInt(r.slice(1),10);isNaN(o)&&this.error("Invalid character reference"),e=String.fromCodePoint(o),at.isXmlChar(e)||this.error("Character reference resolves to an invalid character")}else if(void 0===(e=at.predefinedEntities[r])){var i=this.options,a=i.ignoreUndefinedEntities,c=i.resolveUndefinedEntity,u="&".concat(r,";");if(c){var s=c(u);if(null!=s){var f=n(s);if("string"!==f)throw new TypeError("\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ".concat(f));return s}}if(a)return u;t.reset(-u.length),this.error("Named entity isn't defined: ".concat(u))}return e}},{key:"consumeSystemLiteral",value:function(){var t=this.scanner,e=t.consumeStringFast('"')||t.consumeStringFast("'");if(!e)return!1;var r=t.consumeUntilString(e);return this.validateChars(r),t.consumeStringFast(e)||this.error("Missing end quote"),r}},{key:"consumeWhitespace",value:function(){return Boolean(this.scanner.consumeMatchFn(at.isWhitespace))}},{key:"consumeXmlDeclaration",value:function(){var t=this.scanner;if(!t.consumeStringFast("<?xml"))return!1;this.consumeWhitespace()||this.error("Invalid XML declaration");var e=Boolean(t.consumeStringFast("version"))&&this.consumeEqual()&&this.consumeSystemLiteral();if(!1===e?this.error("XML version is missing or invalid"):/^1\\.[0-9]+$/.test(e)||this.error("Invalid character in version number"),this.consumeWhitespace()){Boolean(t.consumeStringFast("encoding"))&&this.consumeEqual()&&this.consumeSystemLiteral()&&this.consumeWhitespace();var r=Boolean(t.consumeStringFast("standalone"))&&this.consumeEqual()&&this.consumeSystemLiteral();r&&("yes"!==r&&"no"!==r&&this.error('Only "yes" and "no" are permitted as values of \`standalone\`'),this.consumeWhitespace())}return t.consumeStringFast("?>")||this.error("Invalid or unclosed XML declaration"),!0}},{key:"error",value:function(t){for(var e=this.scanner,r=e.charIndex,n=e.string,o=1,i="",a=1,c=0;c<r;++c){var u=n[c];"\\n"===u?(o=1,i="",a+=1):(o+=1,i+=u)}var s=n.indexOf("\\n",r),f=0;(i+=-1===s?n.slice(r):n.slice(r,s)).length>50&&(o<40?i=i.slice(0,50):(f=o-20,i=i.slice(f,o+30)));var l=new Error("".concat(t," (line ").concat(a,", column ").concat(o,")\\n")+"  ".concat(i,"\\n")+" ".repeat(o-f+1)+"^\\n");throw Object.assign(l,{column:o,excerpt:i,line:a,pos:r}),l}},{key:"validateChars",value:function(t){var e,r=0,n=nt(t);try{for(n.s();!(e=n.n()).done;){var o=e.value;at.isNotXmlChar(o)&&(this.scanner.reset(-(f(t).length-r)),this.error("Invalid character")),r+=1}}catch(t){n.e(t)}finally{n.f()}}}]),t}();function vt(t){return"\\ufeff"===t[0]&&(t=t.slice(1)),t.replace(/\\r\\n?/g,"\\n")}var dt=pt,yt=_,mt=X,gt=Q,bt=V,St=C,Et=rt,wt=F;function Ot(t,e){return new dt(t,e).document}Ot.XmlCdata=yt,Ot.XmlComment=mt,Ot.XmlDocument=gt,Ot.XmlElement=bt,Ot.XmlNode=St,Ot.XmlProcessingInstruction=Et,Ot.XmlText=wt;var xt=Ot;function Pt(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var kt=function(t){p(r,g(Error));var e=Pt(r);function r(t){return l(this,r),e.call(this,t)}return r}();function Rt(t){return t.children[0]}function Tt(t){var e=t.indexOf(":");return e>-1?t.substr(e+1):t}function jt(t){return t.name||""}function Ct(t,e,r){var n=Tt(e);return t&&Array.isArray(t.children)?t.children.reduce((function t(e,o){return Tt(jt(o))===n&&e.push(o),r&&Array.isArray(o.children)?[].concat(f(e),f(o.children.reduce(t,[]))):e}),[]):[]}function Gt(t,e,r){return Ct(t,e,r)[0]||null}function Nt(t){return t&&Array.isArray(t.children)?f(t.children.filter((function(t){return"XmlElement"===t.constructor.name}))):[]}function At(t){var e=t&&Array.isArray(t.children)?t.children.find((function(t){return"text"===t.type})):null;return e?e.text:""}function Ft(t,e){return t&&t.attributes[e]||""}var It=function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];l(this,t),this.message=e,this.httpStatus=r,this.isCrossOriginRelated=n};function Lt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Mt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Mt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Mt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Bt=["utf-8","utf-16","iso-8859-1"];function _t(t,e){var r,n=e?function(t){var e=/charset=([^;]+)/.exec(t);return e?e[1]:null}(e):null,o=Lt(n?[n].concat(Bt):Bt);try{for(o.s();!(r=o.n()).done;){var i=r.value;try{return new TextDecoder(i,{fatal:!0}).decode(t)}catch(t){}}}catch(t){o.e(t)}finally{o.f()}return console.warn("XML document encoding could not be determined, falling back to ".concat("utf-8",".")),new TextDecoder("utf-8").decode(t)}function Ut(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Dt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Dt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Dt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Wt=new Map;function Xt(t){return function(t){if(Wt.has(t))return Wt.get(t);var e=fetch(t);return e.finally((function(){return Wt.delete(t)})),Wt.set(t,e),e}(t).catch((function(){return fetch(t,{method:"HEAD",mode:"no-cors"}).catch((function(t){throw new It("Fetching the document failed either due to network errors or unreachable host, error is: ".concat(t.message),0,!1)})).then((function(){throw new It("The document could not be fetched due to CORS limitations",0,!0)}))})).then(function(){var t=r(i.mark((function t(e){var r,n,o;return i.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(e.ok){t.next=5;break}return t.next=3,e.text();case 3:throw r=t.sent,new It("Received an error with code ".concat(e.status,": ").concat(r),e.status,!1);case 5:return t.next=7,e.arrayBuffer();case 7:return n=t.sent,o=e.headers.get("Content-Type"),t.abrupt("return",_t(n,o));case 10:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}()).then((function(t){return function(t){var e=null;try{e=xt(t)}catch(t){throw new kt(t.message)}return e}(t)}))}function Yt(t,e){var r=t.match(/(https?%3A%2F%2F[^/]+)$/);if(r){var n=r[1],o=Yt(decodeURIComponent(n),e);return t.replace(n,encodeURIComponent(o))}var i,a=new URL(t),c=Object.keys(e),u=c.map((function(t){return t.toLowerCase()})),s=[],f=Ut(a.searchParams.keys());try{for(f.s();!(i=f.n()).done;){var l=i.value;u.indexOf(l.toLowerCase())>-1&&s.push(l)}}catch(t){f.e(t)}finally{f.f()}return s.map((function(t){return a.searchParams.delete(t)})),c.forEach((function(t){return a.searchParams.set(t,!0===e[t]?"":e[t])})),a.toString()}var qt=["EPSG:4046","EPSG:4075","EPSG:4120","EPSG:4122","EPSG:4124","EPSG:4126","EPSG:4149","EPSG:4151","EPSG:4153","EPSG:4155","EPSG:4157","EPSG:4159","EPSG:4161","EPSG:4163","EPSG:4165","EPSG:4167","EPSG:4169","EPSG:4171","EPSG:4173","EPSG:4175","EPSG:4178","EPSG:4180","EPSG:4182","EPSG:4184","EPSG:4188","EPSG:4190","EPSG:4191","EPSG:4196","EPSG:4198","EPSG:4202","EPSG:4210","EPSG:4211","EPSG:4214","EPSG:4226","EPSG:4229","EPSG:4231","EPSG:4233","EPSG:4236","EPSG:4238","EPSG:4240","EPSG:4242","EPSG:4244","EPSG:4246","EPSG:4248","EPSG:4250","EPSG:4252","EPSG:4255","EPSG:4258","EPSG:4261","EPSG:4264","EPSG:4267","EPSG:4270","EPSG:4273","EPSG:4276","EPSG:4279","EPSG:4281","EPSG:4284","EPSG:4286","EPSG:4288","EPSG:4292","EPSG:4295","EPSG:4297","EPSG:4299","EPSG:4302","EPSG:4324","EPSG:4326"];function Jt(t){return qt.indexOf(Vt(t))>-1}function Vt(t){if(/^urn:(?:x-)?ogc:def:crs:epsg:/.test(t.toLowerCase())){var e=/([0-9]+)$/.exec(t)[1];return"EPSG:".concat(e)}return t}function $t(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function Kt(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?$t(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):$t(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function zt(t){return Rt(t).attributes.version}function Ht(t){var e=zt(t);return Ct(Gt(Rt(t),"Capability"),"Layer").map((function(t){return Qt(t,e)}))}function Qt(e,r){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a="1.3.0"===r?"CRS":"SRS",c=Ct(e,a).map(At),u=c.length>0?c:n,s=Ct(e,"Style").map(Zt),f=s.length>0?s:o;function l(t){return(Jt(Ft(t,a))&&"1.3.0"===r?["miny","minx","maxy","maxx"]:["minx","miny","maxx","maxy"]).map((function(e){return Ft(t,e)}))}var h=Gt(e,"Attribution"),p=null!==h?te(h):i,v=Ct(e,"Layer").map((function(t){return Qt(t,r,u,f,p)}));return Kt({name:At(Gt(e,"Name")),title:At(Gt(e,"Title")),abstract:At(Gt(e,"Abstract")),availableCrs:u,styles:f,attribution:p,boundingBoxes:Ct(e,"BoundingBox").reduce((function(e,r){return Kt(Kt({},e),{},t({},Ft(r,a),l(r)))}),{})},v.length&&{children:v})}function Zt(t){var e=Ft(Gt(Gt(t,"LegendURL"),"OnlineResource"),"xlink:href");return Kt({name:At(Gt(t,"Name")),title:At(Gt(t,"Title"))},e&&{legendUrl:e})}function te(t){var e=Ft(Gt(Gt(t,"LogoURL"),"OnlineResource"),"xlink:href"),r=Ft(Gt(t,"OnlineResource"),"xlink:href"),n=At(Gt(t,"Title"));return Kt(Kt(Kt({},n&&{title:n}),r&&{url:r}),e&&{logoUrl:e})}function ee(t){return Rt(t).attributes.version}function re(t){var e;if(ee(t).startsWith("1.0")){var r=Gt(Gt(Gt(Rt(t),"Capability"),"Request"),"GetFeature");e=Nt(Gt(r,"ResultFormat")).map(jt)}else{var n=Ct(Gt(Rt(t),"OperationsMetadata"),"Operation").find((function(t){return"GetFeature"===Ft(t,"name")})),o=Ct(n,"Parameter").find((function(t){return"outputFormat"===Ft(t,"name")}));e=Ct(o,"Value",!0).map(At)}return e}function ne(t){var e=ee(t),r=re(t);return Ct(Gt(Rt(t),"FeatureTypeList"),"FeatureType").map((function(t){return function(t,e,r){var n=e.startsWith("2.")?"CRS":"SRS",o=e.startsWith("1.0")?"SRS":"Default".concat(n);function i(){var e=Gt(t,"LatLongBoundingBox");return["minx","miny","maxx","maxy"].map((function(t){return Ft(e,t)})).map(parseFloat)}function a(){var e=Gt(t,"WGS84BoundingBox");return["LowerCorner","UpperCorner"].map((function(t){return Gt(e,t)})).map((function(t){return At(t).split(" ")})).reduce((function(t,e){return[].concat(f(t),f(e))})).map(parseFloat)}var c=e.startsWith("1.0")?[]:Ct(t,"Other".concat(n)).map(At).map(Vt),u=e.startsWith("1.0")?[]:Ct(Gt(t,"OutputFormats"),"Format").map(At);return{name:At(Gt(t,"Name")),title:At(Gt(t,"Title")),abstract:At(Gt(t,"Abstract")),defaultCrs:Vt(At(Gt(t,o))),otherCrs:c,outputFormats:u.length>0?u:r,latLonBoundingBox:e.startsWith("1.0")?i():a()}}(t,e,r)}))}function oe(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function ie(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?oe(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):oe(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ae(e,r,n){var o,i=Rt(e);if(n.startsWith("2.0"))o=Ct(i,"member").map((function(t){return Nt(t)[0]}));else{var a=Gt(i,"featureMembers");o=a?Nt(a):Ct(i,"featureMember").map((function(t){return Nt(t)[0]}))}var c="1.0.0"===n?"fid":"gml:id";function u(e){return Nt(e).filter((function(t){return Tt(jt(t))in r.properties})).reduce((function(e,n){var o=Tt(jt(n));return ie(ie({},e),{},t({},o,function(t,e){switch(r.properties[t]){case"integer":return parseInt(e);case"float":return parseFloat(e);case"boolean":return"true"===e;default:return e}}(o,At(n))))}),{})}return o.map((function(t){return{id:Ft(t,c),properties:u(t)}}))}function ce(e,r,n,o,i,a,c,u,s,f){var l="2.0.0"===r?"COUNT":"MAXFEATURES",h=t({SERVICE:"WFS",REQUEST:"GetFeature",VERSION:r},"2.0.0"===r?"TYPENAMES":"TYPENAME",n);if(void 0!==o&&(h.OUTPUTFORMAT=o),void 0!==a&&(h.PROPERTYNAME=a.join(",")),c?(h.RESULTTYPE="hits",h[l]="1"):void 0!==i&&(h[l]=i.toString(10)),u&&(h.SRSNAME=u),s){var p=s.join(",");h.BBOX=f?"".concat(p,",").concat(f):p}return Yt(e,h)}u("parseWmsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,r=Gt(Rt(e),"Service"),n=Ct(Gt(r,"KeywordList"),"Keyword").map(At).filter((function(t,e,r){return r.indexOf(t)===e})),{title:At(Gt(r,"Title")),name:At(Gt(r,"Name")),abstract:At(Gt(r,"Abstract")),fees:At(Gt(r,"Fees")),constraints:At(Gt(r,"AccessConstraints")),keywords:n}),layers:Ht(t),version:zt(t)};var e,r,n}))})),u("parseWfsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,n=ee(e),o=n.startsWith("1.0")?"Service":"ServiceIdentification",i=n.startsWith("1.0")?"Name":"ServiceType",a=Gt(Rt(e),o),r=n.startsWith("1.0")?At(Gt(a,"Keywords")).split(",").map((function(t){return t.trim()})):Ct(Gt(a,"Keywords"),"Keyword").map(At),{title:At(Gt(a,"Title")),name:At(Gt(a,i)),abstract:At(Gt(a,"Abstract")),fees:At(Gt(a,"Fees")),constraints:At(Gt(a,"AccessConstraints")),keywords:r,outputFormats:re(e)}),featureTypes:ne(t),version:ee(t)};var e,r,n,o,i,a}))})),u("queryWfsFeatureTypeDetails",self,(function(t){var e=t.url,r=t.serviceVersion,n=t.featureTypeFull;return Xt(ce(e,r,n.name,void 0,void 0,Object.keys(n.properties))).then((function(t){return{props:(e=ae(t,n,r),e.reduce((function(t,e){var r=function(r){var n=e.properties[r];r in t||(t[r]={uniqueValues:[]});var o=t[r].uniqueValues.find((function(t){return t.value===n}));o?o.count++:t[r].uniqueValues.push({value:n,count:1})};for(var n in e.properties)r(n);return t}),{}))};var e}))}));
`], { type: "application/javascript" })), {
    type: "module"
  })), r0;
}
function pB(t) {
  return hB("parseWmsCapabilities", fB(), {
    url: t
  });
}
const yu = "";
class dB {
  constructor(e) {
    this.chars = [...e], this.charCount = this.chars.length, this.charIndex = 0, this.charsToBytes = new Array(this.charCount), this.multiByteMode = !1, this.string = e;
    let { chars: n, charCount: a, charsToBytes: s } = this;
    if (a === e.length)
      for (let h = 0; h < a; ++h)
        s[h] = h;
    else {
      for (let h = 0, o = 0; o < a; ++o)
        s[o] = h, h += n[o].length;
      this.multiByteMode = !0;
    }
  }
  get isEnd() {
    return this.charIndex >= this.charCount;
  }
  _charLength(e) {
    let { length: n } = e;
    return n < 2 || !this.multiByteMode ? n : e.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length;
  }
  advance(e = 1) {
    this.charIndex = Math.min(this.charCount, this.charIndex + e);
  }
  consume(e = 1) {
    let n = this.peek(e);
    return this.advance(e), n;
  }
  consumeMatch(e) {
    if (!e.sticky)
      throw new Error('`regex` must have a sticky flag ("y")');
    e.lastIndex = this.charsToBytes[this.charIndex];
    let n = e.exec(this.string);
    if (n === null)
      return yu;
    let a = n[0];
    return this.advance(this._charLength(a)), a;
  }
  consumeMatchFn(e) {
    let n = this.charIndex;
    for (; !this.isEnd && e(this.peek()); )
      this.advance();
    return this.charIndex > n ? this.string.slice(this.charsToBytes[n], this.charsToBytes[this.charIndex]) : yu;
  }
  consumeString(e) {
    if (this.consumeStringFast(e))
      return e;
    if (!this.multiByteMode)
      return yu;
    let { length: n } = e, a = this._charLength(e);
    return a !== n && e === this.peek(a) ? (this.advance(a), e) : yu;
  }
  consumeStringFast(e) {
    if (this.peek() === e[0]) {
      let { length: n } = e;
      if (n === 1)
        return this.advance(), e;
      if (this.peek(n) === e)
        return this.advance(n), e;
    }
    return yu;
  }
  consumeUntilMatch(e) {
    if (!e.global)
      throw new Error('`regex` must have a global flag ("g")');
    let n = this.charsToBytes[this.charIndex];
    e.lastIndex = n;
    let a = e.exec(this.string);
    if (a === null || a.index === n)
      return yu;
    let s = this.string.slice(n, a.index);
    return this.advance(this._charLength(s)), s;
  }
  consumeUntilString(e) {
    let { charIndex: n, charsToBytes: a, string: s } = this, h = a[n], o = s.indexOf(e, h);
    if (o <= 0)
      return yu;
    let m = s.slice(h, o);
    return this.advance(this._charLength(m)), m;
  }
  peek(e = 1) {
    if (this.charIndex >= this.charCount)
      return yu;
    if (e === 1)
      return this.chars[this.charIndex];
    let { charsToBytes: n, charIndex: a } = this;
    return this.string.slice(n[a], n[a + e]);
  }
  reset(e = 0) {
    this.charIndex = e >= 0 ? Math.min(this.charCount, e) : Math.max(0, this.charIndex + e);
  }
}
var mB = dB, Gu = {};
const yB = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
  amp: "&",
  apos: "'",
  gt: ">",
  lt: "<",
  quot: '"'
}));
Gu.predefinedEntities = yB;
function eI(t) {
  if (tI(t))
    return !0;
  let e = kv(t);
  return e === 45 || e === 46 || e >= 48 && e <= 57 || e === 183 || e >= 768 && e <= 879 || e >= 8255 && e <= 8256;
}
Gu.isNameChar = eI;
function tI(t) {
  let e = kv(t);
  return e === 58 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 192 && e <= 214 || e >= 216 && e <= 246 || e >= 248 && e <= 767 || e >= 880 && e <= 893 || e >= 895 && e <= 8191 || e >= 8204 && e <= 8205 || e >= 8304 && e <= 8591 || e >= 11264 && e <= 12271 || e >= 12289 && e <= 55295 || e >= 63744 && e <= 64975 || e >= 65008 && e <= 65533 || e >= 65536 && e <= 983039;
}
Gu.isNameStartChar = tI;
function gB(t) {
  return !rI(t);
}
Gu.isNotXmlChar = gB;
function vB(t) {
  return t === "#" || eI(t);
}
Gu.isReferenceChar = vB;
function _B(t) {
  let e = kv(t);
  return e === 32 || e === 9 || e === 10 || e === 13;
}
Gu.isWhitespace = _B;
function rI(t) {
  let e = kv(t);
  return e === 9 || e === 10 || e === 13 || e >= 32 && e <= 55295 || e >= 57344 && e <= 65533 || e >= 65536 && e <= 1114111;
}
Gu.isXmlChar = rI;
function kv(t) {
  return t.codePointAt(0) || -1;
}
class ih {
  constructor() {
    this.parent = null;
  }
  get document() {
    return this.parent ? this.parent.document : null;
  }
  get isRootNode() {
    return this.parent ? this.parent === this.document : !1;
  }
  get preserveWhitespace() {
    return Boolean(this.parent && this.parent.preserveWhitespace);
  }
  get type() {
    return "";
  }
  toJSON() {
    let e = {
      type: this.type
    };
    return this.isRootNode && (e.isRootNode = !0), this.preserveWhitespace && (e.preserveWhitespace = !0), e;
  }
}
ih.TYPE_CDATA = "cdata";
ih.TYPE_COMMENT = "comment";
ih.TYPE_DOCUMENT = "document";
ih.TYPE_ELEMENT = "element";
ih.TYPE_PROCESSING_INSTRUCTION = "pi";
ih.TYPE_TEXT = "text";
var oh = ih;
const n0 = oh;
class xB extends n0 {
  constructor(e = "") {
    super(), this.text = e;
  }
  get type() {
    return n0.TYPE_TEXT;
  }
  toJSON() {
    return Object.assign(n0.prototype.toJSON.call(this), {
      text: this.text
    });
  }
}
var tx = xB;
const bB = oh, wB = tx;
class EB extends wB {
  get type() {
    return bB.TYPE_CDATA;
  }
}
var nI = EB;
const i0 = oh;
class SB extends i0 {
  constructor(e = "") {
    super(), this.content = e;
  }
  get type() {
    return i0.TYPE_COMMENT;
  }
  toJSON() {
    return Object.assign(i0.prototype.toJSON.call(this), {
      content: this.content
    });
  }
}
var iI = SB;
const o0 = oh;
class rx extends o0 {
  constructor(e, n = /* @__PURE__ */ Object.create(null), a = []) {
    super(), this.name = e, this.attributes = n, this.children = a;
  }
  get isEmpty() {
    return this.children.length === 0;
  }
  get preserveWhitespace() {
    let e = this;
    for (; e instanceof rx; ) {
      if ("xml:space" in e.attributes)
        return e.attributes["xml:space"] === "preserve";
      e = e.parent;
    }
    return !1;
  }
  get text() {
    return this.children.map((e) => "text" in e ? e.text : "").join("");
  }
  get type() {
    return o0.TYPE_ELEMENT;
  }
  toJSON() {
    return Object.assign(o0.prototype.toJSON.call(this), {
      name: this.name,
      attributes: this.attributes,
      children: this.children.map((e) => e.toJSON())
    });
  }
}
var nx = rx;
const TB = nx, a0 = oh;
class MB extends a0 {
  constructor(e = []) {
    super(), this.children = e;
  }
  get document() {
    return this;
  }
  get root() {
    return this.children.find((e) => e instanceof TB) || null;
  }
  get text() {
    return this.children.map((e) => "text" in e ? e.text : "").join("");
  }
  get type() {
    return a0.TYPE_DOCUMENT;
  }
  toJSON() {
    return Object.assign(a0.prototype.toJSON.call(this), {
      children: this.children.map((e) => e.toJSON())
    });
  }
}
var oI = MB;
const s0 = oh;
class IB extends s0 {
  constructor(e, n = "") {
    super(), this.name = e, this.content = n;
  }
  get type() {
    return s0.TYPE_PROCESSING_INSTRUCTION;
  }
  toJSON() {
    return Object.assign(s0.prototype.toJSON.call(this), {
      name: this.name,
      content: this.content
    });
  }
}
var aI = IB;
const OB = mB, Cc = Gu, CB = nI, AB = iI, PB = oI, kB = nx, nE = aI, iE = tx, l0 = "";
class LB {
  constructor(e, n = {}) {
    for (this.document = new PB(), this.currentNode = this.document, this.options = n, this.scanner = new OB(NB(e)), this.consumeProlog(), this.consumeElement() || this.error("Root element is missing or invalid"); this.consumeMisc(); )
      ;
    this.scanner.isEnd || this.error("Extra content at the end of the document");
  }
  addNode(e) {
    e.parent = this.currentNode, this.currentNode.children.push(e);
  }
  addText(e) {
    let { children: n } = this.currentNode;
    if (n.length > 0) {
      let a = n[n.length - 1];
      if (a instanceof iE) {
        a.text += e;
        return;
      }
    }
    this.addNode(new iE(e));
  }
  consumeAttributeValue() {
    let { scanner: e } = this, n = e.peek();
    if (n !== '"' && n !== "'")
      return !1;
    e.advance();
    let a, s = !1, h = l0, o = n === '"' ? /[^"&<]+/y : /[^'&<]+/y;
    e:
      for (; !e.isEnd; )
        switch (a = e.consumeMatch(o), a && (this.validateChars(a), h += a.replace(/[\t\r\n]/g, " ")), e.peek()) {
          case n:
            s = !0;
            break e;
          case "&":
            h += this.consumeReference();
            continue;
          case "<":
            this.error("Unescaped `<` is not allowed in an attribute value");
            break;
          case l0:
            this.error("Unclosed attribute");
            break;
        }
    return s || this.error("Unclosed attribute"), e.advance(), h;
  }
  consumeCdataSection() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<![CDATA["))
      return !1;
    let n = e.consumeUntilString("]]>");
    return this.validateChars(n), e.consumeStringFast("]]>") || this.error("Unclosed CDATA section"), this.options.preserveCdata ? this.addNode(new CB(n)) : this.addText(n), !0;
  }
  consumeCharData() {
    let { scanner: e } = this, n = e.consumeUntilMatch(/<|&|]]>/g);
    return n ? (this.validateChars(n), e.peek() === "]" && e.peek(3) === "]]>" && this.error("Element content may not contain the CDATA section close delimiter `]]>`"), this.addText(n), !0) : !1;
  }
  consumeComment() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<!--"))
      return !1;
    let n = e.consumeUntilString("--");
    return this.validateChars(n), e.consumeStringFast("-->") || (e.peek(2) === "--" ? this.error("The string `--` isn't allowed inside a comment") : this.error("Unclosed comment")), this.options.preserveComments && this.addNode(new AB(n.trim())), !0;
  }
  consumeContentReference() {
    let e = this.consumeReference();
    return e ? (this.addText(e), !0) : !1;
  }
  consumeDoctypeDeclaration() {
    let { scanner: e } = this;
    return !e.consumeStringFast("<!DOCTYPE") || !this.consumeWhitespace() ? !1 : (e.consumeMatch(/[^[>]+/y), e.consumeMatch(/\[[\s\S]+?\][\x20\t\r\n]*>/y) || e.consumeStringFast(">") || this.error("Unclosed doctype declaration"), !0);
  }
  consumeElement() {
    let { scanner: e } = this, n = e.charIndex;
    if (e.peek() !== "<")
      return !1;
    e.advance();
    let a = this.consumeName();
    if (!a)
      return e.reset(n), !1;
    let s = /* @__PURE__ */ Object.create(null);
    for (; this.consumeWhitespace(); ) {
      let m = this.consumeName();
      if (!m)
        continue;
      let g = this.consumeEqual() && this.consumeAttributeValue();
      g === !1 && this.error("Attribute value expected"), m in s && this.error(`Duplicate attribute: ${m}`), m === "xml:space" && g !== "default" && g !== "preserve" && this.error('Value of the `xml:space` attribute must be "default" or "preserve"'), s[m] = g;
    }
    if (this.options.sortAttributes) {
      let m = Object.keys(s).sort(), g = /* @__PURE__ */ Object.create(null);
      for (let b = 0; b < m.length; ++b) {
        let T = m[b];
        g[T] = s[T];
      }
      s = g;
    }
    let h = Boolean(e.consumeStringFast("/>")), o = new kB(a, s);
    if (o.parent = this.currentNode, !h) {
      for (e.consumeStringFast(">") || this.error(`Unclosed start tag for element \`${a}\``), this.currentNode = o, this.consumeCharData(); this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment(); )
        this.consumeCharData();
      let m = e.charIndex, g;
      (!e.consumeStringFast("</") || !(g = this.consumeName()) || g !== a) && (e.reset(m), this.error(`Missing end tag for element ${a}`)), this.consumeWhitespace(), e.consumeStringFast(">") || this.error(`Unclosed end tag for element ${a}`), this.currentNode = o.parent;
    }
    return this.addNode(o), !0;
  }
  consumeEqual() {
    return this.consumeWhitespace(), this.scanner.consumeStringFast("=") ? (this.consumeWhitespace(), !0) : !1;
  }
  consumeMisc() {
    return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();
  }
  consumeName() {
    return Cc.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(Cc.isNameChar) : l0;
  }
  consumeProcessingInstruction() {
    let { scanner: e } = this, n = e.charIndex;
    if (!e.consumeStringFast("<?"))
      return !1;
    let a = this.consumeName();
    if (a ? a.toLowerCase() === "xml" && (e.reset(n), this.error("XML declaration isn't allowed here")) : this.error("Invalid processing instruction"), !this.consumeWhitespace()) {
      if (e.consumeStringFast("?>"))
        return this.addNode(new nE(a)), !0;
      this.error("Whitespace is required after a processing instruction name");
    }
    let s = e.consumeUntilString("?>");
    return this.validateChars(s), e.consumeStringFast("?>") || this.error("Unterminated processing instruction"), this.addNode(new nE(a, s)), !0;
  }
  consumeProlog() {
    let { scanner: e } = this, n = e.charIndex;
    for (this.consumeXmlDeclaration(); this.consumeMisc(); )
      ;
    if (this.consumeDoctypeDeclaration())
      for (; this.consumeMisc(); )
        ;
    return n < e.charIndex;
  }
  consumeReference() {
    let { scanner: e } = this;
    if (e.peek() !== "&")
      return !1;
    e.advance();
    let n = e.consumeMatchFn(Cc.isReferenceChar);
    e.consume() !== ";" && this.error("Unterminated reference (a reference must end with `;`)");
    let a;
    if (n[0] === "#") {
      let s = n[1] === "x" ? parseInt(n.slice(2), 16) : parseInt(n.slice(1), 10);
      isNaN(s) && this.error("Invalid character reference"), a = String.fromCodePoint(s), Cc.isXmlChar(a) || this.error("Character reference resolves to an invalid character");
    } else if (a = Cc.predefinedEntities[n], a === void 0) {
      let {
        ignoreUndefinedEntities: s,
        resolveUndefinedEntity: h
      } = this.options, o = `&${n};`;
      if (h) {
        let m = h(o);
        if (m != null) {
          let g = typeof m;
          if (g !== "string")
            throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${g}`);
          return m;
        }
      }
      if (s)
        return o;
      e.reset(-o.length), this.error(`Named entity isn't defined: ${o}`);
    }
    return a;
  }
  consumeSystemLiteral() {
    let { scanner: e } = this, n = e.consumeStringFast('"') || e.consumeStringFast("'");
    if (!n)
      return !1;
    let a = e.consumeUntilString(n);
    return this.validateChars(a), e.consumeStringFast(n) || this.error("Missing end quote"), a;
  }
  consumeWhitespace() {
    return Boolean(this.scanner.consumeMatchFn(Cc.isWhitespace));
  }
  consumeXmlDeclaration() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<?xml"))
      return !1;
    this.consumeWhitespace() || this.error("Invalid XML declaration");
    let n = Boolean(e.consumeStringFast("version")) && this.consumeEqual() && this.consumeSystemLiteral();
    if (n === !1 ? this.error("XML version is missing or invalid") : /^1\.[0-9]+$/.test(n) || this.error("Invalid character in version number"), this.consumeWhitespace()) {
      Boolean(e.consumeStringFast("encoding")) && this.consumeEqual() && this.consumeSystemLiteral() && this.consumeWhitespace();
      let s = Boolean(e.consumeStringFast("standalone")) && this.consumeEqual() && this.consumeSystemLiteral();
      s && (s !== "yes" && s !== "no" && this.error('Only "yes" and "no" are permitted as values of `standalone`'), this.consumeWhitespace());
    }
    return e.consumeStringFast("?>") || this.error("Invalid or unclosed XML declaration"), !0;
  }
  error(e) {
    let { charIndex: n, string: a } = this.scanner, s = 1, h = "", o = 1;
    for (let T = 0; T < n; ++T) {
      let M = a[T];
      M === `
` ? (s = 1, h = "", o += 1) : (s += 1, h += M);
    }
    let m = a.indexOf(`
`, n);
    h += m === -1 ? a.slice(n) : a.slice(n, m);
    let g = 0;
    h.length > 50 && (s < 40 ? h = h.slice(0, 50) : (g = s - 20, h = h.slice(g, s + 30)));
    let b = new Error(
      `${e} (line ${o}, column ${s})
  ${h}
` + " ".repeat(s - g + 1) + `^
`
    );
    throw Object.assign(b, {
      column: s,
      excerpt: h,
      line: o,
      pos: n
    }), b;
  }
  validateChars(e) {
    let n = 0;
    for (let a of e)
      Cc.isNotXmlChar(a) && (this.scanner.reset(-([...e].length - n)), this.error("Invalid character")), n += 1;
  }
}
var DB = LB;
function NB(t) {
  return t[0] === "\uFEFF" && (t = t.slice(1)), t.replace(/\r\n?/g, `
`);
}
const RB = DB, zB = nI, FB = iI, BB = oI, VB = nx, UB = oh, jB = aI, GB = tx;
function qu(t, e) {
  return new RB(t, e).document;
}
qu.XmlCdata = zB;
qu.XmlComment = FB;
qu.XmlDocument = BB;
qu.XmlElement = VB;
qu.XmlNode = UB;
qu.XmlProcessingInstruction = jB;
qu.XmlText = GB;
var qB = qu;
class $B extends Error {
  constructor(e) {
    super(e);
  }
}
function WB(t) {
  let e = null;
  try {
    e = qB(t);
  } catch (n) {
    throw new $B(n.message);
  }
  return e;
}
function jl(t) {
  return t.children[0];
}
function Xg(t) {
  const e = t.indexOf(":");
  return e > -1 ? t.substr(e + 1) : t;
}
function Kg(t) {
  return t.name || "";
}
function Eo(t, e, n) {
  const a = Xg(e);
  function s(h, o) {
    return Xg(Kg(o)) === a && h.push(o), n && Array.isArray(o.children) ? [...h, ...o.children.reduce(s, [])] : h;
  }
  return t && Array.isArray(t.children) ? t.children.reduce(s, []) : [];
}
function wr(t, e, n) {
  return Eo(t, e, n)[0] || null;
}
function id(t) {
  return t && Array.isArray(t.children) ? [...t.children.filter((e) => e.constructor.name === "XmlElement")] : [];
}
function _n(t) {
  const e = t && Array.isArray(t.children) ? t.children.find((n) => n.type === "text") : null;
  return e ? e.text : "";
}
function Zs(t, e) {
  return t && t.attributes[e] || "";
}
const oE = ["utf-8", "utf-16", "iso-8859-1"], aE = "utf-8";
function HB(t) {
  const e = /charset=([^;]+)/.exec(t);
  return e ? e[1] : null;
}
function ZB(t, e) {
  const n = e ? HB(e) : null, a = n ? [n, ...oE] : oE;
  for (const s of a)
    try {
      return new TextDecoder(s, { fatal: !0 }).decode(t);
    } catch {
    }
  return console.warn(
    `XML document encoding could not be determined, falling back to ${aE}.`
  ), new TextDecoder(aE).decode(t);
}
const By = /* @__PURE__ */ new Map();
function XB(t) {
  if (By.has(t))
    return By.get(t);
  const e = fetch(t);
  return e.finally(() => By.delete(t)), By.set(t, e), e;
}
function ix(t) {
  return XB(t).catch(
    () => fetch(t, { method: "HEAD", mode: "no-cors" }).catch((e) => {
      throw new t0(
        `Fetching the document failed either due to network errors or unreachable host, error is: ${e.message}`,
        0,
        !1
      );
    }).then(() => {
      throw new t0(
        "The document could not be fetched due to CORS limitations",
        0,
        !0
      );
    })
  ).then(async (e) => {
    if (!e.ok) {
      const s = await e.text();
      throw new t0(
        `Received an error with code ${e.status}: ${s}`,
        e.status,
        !1
      );
    }
    const n = await e.arrayBuffer(), a = e.headers.get("Content-Type");
    return ZB(n, a);
  }).then((e) => WB(e));
}
function ox(t, e) {
  const n = t.match(/(https?%3A%2F%2F[^/]+)$/);
  if (n) {
    const m = n[1], g = ox(decodeURIComponent(m), e);
    return t.replace(m, encodeURIComponent(g));
  }
  const a = new URL(t), s = Object.keys(e), h = s.map((m) => m.toLowerCase()), o = [];
  for (const m of a.searchParams.keys())
    h.indexOf(m.toLowerCase()) > -1 && o.push(m);
  return o.map((m) => a.searchParams.delete(m)), s.forEach(
    (m) => a.searchParams.set(m, e[m] === !0 ? "" : e[m])
  ), a.toString();
}
let KB = 1e3 * 60 * 60;
function YB() {
  return KB;
}
const Fu = "caches" in self ? caches.open("ogc-client") : null;
async function JB(t, ...e) {
  if (!Fu)
    return;
  const n = "https://cache/" + e.join("/");
  await (await Fu).put(
    n,
    new Response(JSON.stringify(t), {
      headers: {
        "x-expiry": (Date.now() + YB()).toString(10)
      }
    })
  );
}
async function QB(...t) {
  if (!Fu)
    return !1;
  const e = "https://cache/" + t.join("/");
  return (await Fu).match(e).then((a) => !!a && parseInt(a.headers.get("x-expiry")) > Date.now());
}
async function e8(...t) {
  if (!Fu)
    return null;
  const e = "https://cache/" + t.join("/"), a = await (await Fu).match(e);
  return a ? a.clone().json() : null;
}
const Vy = /* @__PURE__ */ new Map();
async function t8(t, ...e) {
  if (await r8(), await QB(...e))
    return e8(...e);
  const n = e.join("#");
  if (Vy.has(n))
    return Vy.get(n);
  const a = t();
  a instanceof Promise && (a.then(() => Vy.delete(n)), Vy.set(n, a));
  const s = await a;
  return await JB(s, ...e), s;
}
async function r8() {
  if (!Fu)
    return;
  const t = await Fu, e = await t.keys();
  for (let n of e) {
    const a = await t.match(n);
    parseInt(a.headers.get("x-expiry")) <= Date.now() && await t.delete(n);
  }
}
function n8(t, e, n, a, s, h, o, m, g, b) {
  const T = e === "2.0.0" ? "TYPENAMES" : "TYPENAME", M = e === "2.0.0" ? "COUNT" : "MAXFEATURES", I = {
    SERVICE: "WFS",
    REQUEST: "GetFeature",
    VERSION: e,
    [T]: n
  };
  if (a !== void 0 && (I.OUTPUTFORMAT = a), h !== void 0 && (I.PROPERTYNAME = h.join(",")), o ? (I.RESULTTYPE = "hits", I[M] = "1") : s !== void 0 && (I[M] = s.toString(10)), m && (I.SRSNAME = m), g) {
    const P = g.join(",");
    I.BBOX = b ? `${P},${b}` : P;
  }
  return ox(t, I);
}
class i8 {
  constructor(e) {
    const n = ox(e, {
      SERVICE: "WMS",
      REQUEST: "GetCapabilities"
    });
    this._capabilitiesPromise = t8(
      () => pB(n),
      "WMS",
      "CAPABILITIES",
      n
    ).then(({ info: a, layers: s, version: h }) => {
      this._info = a, this._layers = s, this._version = h;
    }), this._info = null, this._layers = null, this._version = null;
  }
  isReady() {
    return this._capabilitiesPromise.then(() => this);
  }
  getServiceInfo() {
    return this._info;
  }
  getLayers() {
    function e(n) {
      return {
        title: n.title,
        name: n.name,
        abstract: n.abstract,
        ..."children" in n && {
          children: n.children.map(e)
        }
      };
    }
    return this._layers.map(e);
  }
  getLayerByName(e) {
    let n = null;
    function a(s) {
      if (n === null) {
        if (s.name === e) {
          n = s;
          return;
        }
        "children" in s && s.children.map(a);
      }
    }
    return this._layers.map(a), n;
  }
  getVersion() {
    return this._version;
  }
}
const o8 = [
  "EPSG:4046",
  "EPSG:4075",
  "EPSG:4120",
  "EPSG:4122",
  "EPSG:4124",
  "EPSG:4126",
  "EPSG:4149",
  "EPSG:4151",
  "EPSG:4153",
  "EPSG:4155",
  "EPSG:4157",
  "EPSG:4159",
  "EPSG:4161",
  "EPSG:4163",
  "EPSG:4165",
  "EPSG:4167",
  "EPSG:4169",
  "EPSG:4171",
  "EPSG:4173",
  "EPSG:4175",
  "EPSG:4178",
  "EPSG:4180",
  "EPSG:4182",
  "EPSG:4184",
  "EPSG:4188",
  "EPSG:4190",
  "EPSG:4191",
  "EPSG:4196",
  "EPSG:4198",
  "EPSG:4202",
  "EPSG:4210",
  "EPSG:4211",
  "EPSG:4214",
  "EPSG:4226",
  "EPSG:4229",
  "EPSG:4231",
  "EPSG:4233",
  "EPSG:4236",
  "EPSG:4238",
  "EPSG:4240",
  "EPSG:4242",
  "EPSG:4244",
  "EPSG:4246",
  "EPSG:4248",
  "EPSG:4250",
  "EPSG:4252",
  "EPSG:4255",
  "EPSG:4258",
  "EPSG:4261",
  "EPSG:4264",
  "EPSG:4267",
  "EPSG:4270",
  "EPSG:4273",
  "EPSG:4276",
  "EPSG:4279",
  "EPSG:4281",
  "EPSG:4284",
  "EPSG:4286",
  "EPSG:4288",
  "EPSG:4292",
  "EPSG:4295",
  "EPSG:4297",
  "EPSG:4299",
  "EPSG:4302",
  "EPSG:4324",
  "EPSG:4326"
];
function a8(t) {
  return o8.indexOf(u1(t)) > -1;
}
function u1(t) {
  return /^urn:(?:x-)?ogc:def:crs:epsg:/.test(t.toLowerCase()) ? `EPSG:${/([0-9]+)$/.exec(t)[1]}` : t;
}
function sI(t) {
  return jl(t).attributes.version;
}
function s8(t) {
  const e = sI(t), n = wr(
    jl(t),
    "Capability"
  );
  return Eo(n, "Layer").map(
    (a) => lI(a, e)
  );
}
function l8(t) {
  const e = wr(jl(t), "Service"), n = Eo(
    wr(e, "KeywordList"),
    "Keyword"
  ).map(_n).filter((a, s, h) => h.indexOf(a) === s);
  return {
    title: _n(wr(e, "Title")),
    name: _n(wr(e, "Name")),
    abstract: _n(wr(e, "Abstract")),
    fees: _n(wr(e, "Fees")),
    constraints: _n(wr(e, "AccessConstraints")),
    keywords: n
  };
}
function lI(t, e, n = [], a = [], s = null) {
  const h = e === "1.3.0" ? "CRS" : "SRS", o = Eo(t, h).map(_n), m = o.length > 0 ? o : n, g = Eo(t, "Style").map(
    u8
  ), b = g.length > 0 ? g : a;
  function T(z) {
    const V = Zs(z, h);
    return (a8(V) && e === "1.3.0" ? ["miny", "minx", "maxy", "maxx"] : ["minx", "miny", "maxx", "maxy"]).map((X) => Zs(z, X));
  }
  const M = wr(t, "Attribution"), I = M !== null ? c8(M) : s, P = Eo(t, "Layer").map(
    (z) => lI(z, e, m, b, I)
  );
  return {
    name: _n(wr(t, "Name")),
    title: _n(wr(t, "Title")),
    abstract: _n(wr(t, "Abstract")),
    availableCrs: m,
    styles: b,
    attribution: I,
    boundingBoxes: Eo(t, "BoundingBox").reduce(
      (z, V) => ({
        ...z,
        [Zs(V, h)]: T(V)
      }),
      {}
    ),
    ...P.length && { children: P }
  };
}
function u8(t) {
  const e = Zs(
    wr(wr(t, "LegendURL"), "OnlineResource"),
    "xlink:href"
  );
  return {
    name: _n(wr(t, "Name")),
    title: _n(wr(t, "Title")),
    ...e && { legendUrl: e }
  };
}
function c8(t) {
  const e = Zs(
    wr(
      wr(t, "LogoURL"),
      "OnlineResource"
    ),
    "xlink:href"
  ), n = Zs(
    wr(t, "OnlineResource"),
    "xlink:href"
  ), a = _n(wr(t, "Title"));
  return {
    ...a && { title: a },
    ...n && { url: n },
    ...e && { logoUrl: e }
  };
}
function Lv(t) {
  return jl(t).attributes.version;
}
function uI(t) {
  const e = Lv(t);
  let n;
  if (e.startsWith("1.0")) {
    const a = wr(
      wr(
        wr(jl(t), "Capability"),
        "Request"
      ),
      "GetFeature"
    );
    n = id(
      wr(a, "ResultFormat")
    ).map(Kg);
  } else {
    const a = wr(
      jl(t),
      "OperationsMetadata"
    ), s = Eo(a, "Operation").find(
      (o) => Zs(o, "name") === "GetFeature"
    ), h = Eo(s, "Parameter").find(
      (o) => Zs(o, "name") === "outputFormat"
    );
    n = Eo(h, "Value", !0).map(
      _n
    );
  }
  return n;
}
function h8(t) {
  const e = Lv(t), n = e.startsWith("1.0") ? "Service" : "ServiceIdentification", a = e.startsWith("1.0") ? "Name" : "ServiceType", s = wr(jl(t), n);
  let h;
  return e.startsWith("1.0") ? h = _n(wr(s, "Keywords")).split(",").map((o) => o.trim()) : h = Eo(
    wr(s, "Keywords"),
    "Keyword"
  ).map(_n), {
    title: _n(wr(s, "Title")),
    name: _n(wr(s, a)),
    abstract: _n(wr(s, "Abstract")),
    fees: _n(wr(s, "Fees")),
    constraints: _n(wr(s, "AccessConstraints")),
    keywords: h,
    outputFormats: uI(t)
  };
}
function f8(t) {
  const e = Lv(t), n = uI(t), a = wr(
    jl(t),
    "FeatureTypeList"
  );
  return Eo(a, "FeatureType").map(
    (s) => p8(s, e, n)
  );
}
function p8(t, e, n) {
  const a = e.startsWith("2.") ? "CRS" : "SRS", s = e.startsWith("1.0") ? "SRS" : `Default${a}`;
  function h() {
    const b = wr(t, "LatLongBoundingBox");
    return ["minx", "miny", "maxx", "maxy"].map((T) => Zs(b, T)).map(parseFloat);
  }
  function o() {
    const b = wr(t, "WGS84BoundingBox");
    return ["LowerCorner", "UpperCorner"].map((T) => wr(b, T)).map((T) => _n(T).split(" ")).reduce((T, M) => [...T, ...M]).map(parseFloat);
  }
  const m = e.startsWith("1.0") ? [] : Eo(t, `Other${a}`).map(_n).map(u1), g = e.startsWith("1.0") ? [] : Eo(
    wr(t, "OutputFormats"),
    "Format"
  ).map(_n);
  return {
    name: _n(wr(t, "Name")),
    title: _n(wr(t, "Title")),
    abstract: _n(wr(t, "Abstract")),
    defaultCrs: u1(
      _n(wr(t, s))
    ),
    otherCrs: m,
    outputFormats: g.length > 0 ? g : n,
    latLonBoundingBox: e.startsWith("1.0") ? h() : o()
  };
}
function d8(t, e, n) {
  const a = jl(t);
  let s;
  if (n.startsWith("2.0"))
    s = Eo(a, "member").map(
      (b) => id(b)[0]
    );
  else {
    const b = wr(a, "featureMembers");
    s = b ? id(b) : Eo(a, "featureMember").map(
      (T) => id(T)[0]
    );
  }
  const h = n === "1.0.0" ? "fid" : "gml:id";
  function o(b) {
    return b in e.properties;
  }
  function m(b, T) {
    switch (e.properties[b]) {
      case "integer":
        return parseInt(T);
      case "float":
        return parseFloat(T);
      case "boolean":
        return T === "true";
      default:
        return T;
    }
  }
  function g(b) {
    return id(b).filter((T) => o(Xg(Kg(T)))).reduce((T, M) => {
      const I = Xg(Kg(M));
      return {
        ...T,
        [I]: m(I, _n(M))
      };
    }, {});
  }
  return s.map((b) => ({
    id: Zs(b, h),
    properties: g(b)
  }));
}
function m8(t) {
  return t.reduce((e, n) => {
    for (const a in n.properties) {
      const s = n.properties[a];
      a in e || (e[a] = { uniqueValues: [] });
      const h = e[a].uniqueValues.find(
        (o) => o.value === s
      );
      h ? h.count++ : e[a].uniqueValues.push({ value: s, count: 1 });
    }
    return e;
  }, {});
}
ex(
  "parseWmsCapabilities",
  self,
  ({ url: t }) => ix(t).then((e) => ({
    info: l8(e),
    layers: s8(e),
    version: sI(e)
  }))
);
ex(
  "parseWfsCapabilities",
  self,
  ({ url: t }) => ix(t).then((e) => ({
    info: h8(e),
    featureTypes: f8(e),
    version: Lv(e)
  }))
);
ex(
  "queryWfsFeatureTypeDetails",
  self,
  ({ url: t, serviceVersion: e, featureTypeFull: n }) => {
    const a = n8(
      t,
      e,
      n.name,
      void 0,
      void 0,
      Object.keys(n.properties)
    );
    return ix(a).then((s) => ({
      props: m8(
        d8(s, n, e)
      )
    }));
  }
);
const y8 = () => [
  {
    url: "http://wmts1.geoportail.lu/opendata/service",
    label: "Open Data Webservices WMS"
  },
  {
    url: "http://ows.terrestris.de/osm-gray/service",
    label: "OpenStreetMap by Terrestris (Grey)"
  },
  {
    url: "http://ows.terrestris.de/osm/service",
    label: "OpenStreetMap by Terrestris (Color)"
  }
];
class g8 {
  constructor(e) {
    bi(this, "capabilitiesPromise");
    bi(this, "serviceInfo");
    bi(this, "layers");
    const n = new LC();
    let a = "&";
    e.indexOf("?") === -1 && (a = "?"), e.indexOf("Capabilities") === -1 && (e = e + a + "SERVICE=WMTS&REQUEST=GetCapabilities"), this.capabilitiesPromise = fetch(e).then((s) => s.text()).then((s) => {
      var o;
      const h = n.read(s);
      this.serviceInfo = this.mapServiceInfo(h.ServiceIdentification), this.layers = this.mapToRemoteLayers((o = h.Contents) == null ? void 0 : o.Layer);
    });
  }
  mapToRemoteLayers(e) {
    return [
      {
        type: Da.WMTS,
        children: e.map(
          (n) => ({
            type: Da.WMTS,
            abstract: n.Abstract,
            format: n.Format,
            name: n.Identifier,
            title: n.Title,
            tileMatrixSetLink: n.TileMatrixSetLink,
            wgs84BoundingBox: n.WGS84BoundingBox
          })
        )
      }
    ];
  }
  mapServiceInfo(e) {
    return {
      type: Da.WMTS,
      title: e.Title,
      abstract: e.Abstract,
      fees: e.Fees,
      constraints: e.AccessConstraints,
      serviceTypeVersion: e.ServiceTypeVersion
    };
  }
  isReady() {
    return this.capabilitiesPromise.then(() => this);
  }
  getLayerByName(e) {
    return this.layers[0].children.filter((n) => n.name === e)[0];
  }
  getLayers() {
    return this.layers;
  }
  getServiceInfo() {
    return this.serviceInfo;
  }
}
class v8 {
  async getRemoteEndpoint(e) {
    let n;
    return await this.getWmsEndpoint(e).isReady().catch(async () => {
      n = await this.getWmtsEndpoint(e).isReady();
    }) || n;
  }
  getWmsEndpoint(e) {
    return new i8(this.getProxyfiedUrl(e));
  }
  getWmtsEndpoint(e) {
    return new g8(this.getProxyfiedUrl(e));
  }
  getProxyfiedUrl(e) {
    return e.indexOf("httpsproxy") > 0 ? e : XM + "?url=" + encodeURIComponent(e);
  }
  async fetchRemoteWmsEndpoint() {
    return new Promise((e) => e(y8()));
  }
  isRemoteLayer(e) {
    return typeof e == "string" && (e.indexOf(Da.WMS) === 0 || e.indexOf(Da.WMTS) === 0);
  }
}
const Zc = new v8();
function _8(t, e) {
  var n, a;
  return t.children && !e.children || ((n = e.children) == null ? void 0 : n.length) === 0 ? 1 : e.children && !t.children || ((a = t.children) == null ? void 0 : a.length) === 0 ? -1 : 0;
}
function cI(t, e, n = 0) {
  const { name: a = "", type: s = Da.WMS, children: h } = t, o = `${s}||${e}||${a}`.split("-").join("%2D"), m = Ai();
  return {
    id: o,
    name: a,
    depth: n,
    children: h == null ? void 0 : h.sort(_8).map((g) => cI(g, e, n + 1)),
    checked: m.hasLayer(o),
    expanded: !1
  };
}
function x8(t) {
  const e = decodeURIComponent(t), [n, a, s] = e.split("||");
  return hI({
    id: e,
    url: Zc.getProxyfiedUrl(a),
    remoteLayer: { name: s, type: n }
  });
}
function hI({
  id: t,
  url: e,
  remoteLayer: n
}) {
  const { name: a = "", type: s = Da.WMS } = n;
  return {
    id: t,
    name: a,
    layers: a,
    url: e,
    type: s,
    imageType: ZM.PNG
  };
}
const b8 = { class: "relative text-center" }, w8 = ["placeholder", "value"], E8 = {
  key: 0,
  class: "text-center"
}, S8 = { class: "lux-label" }, T8 = {
  key: 1,
  class: "text-center"
}, M8 = { class: "lux-label" }, I8 = {
  key: 2,
  class: "text-center"
}, O8 = /* @__PURE__ */ Re("div", { class: "fa fa-refresh fa-spin" }, null, -1), C8 = {
  key: 3,
  class: "overflow-auto max-h-[calc(400px-36px)]"
}, A8 = /* @__PURE__ */ or({
  __name: "remote-layers",
  setup(t) {
    const { t: e } = In(), n = Ai(), a = ku(), s = Fn([]), h = Fn(), { remoteLayersOpen: o } = xn(Pi()), { setRemoteLayersOpen: m } = Pi();
    let g = !1, b, T, M;
    Na(I);
    function I() {
      h.value = h.value ? Cf.updateLayers(
        h.value,
        n.layers
      ) : void 0;
    }
    Zc.fetchRemoteWmsEndpoint().then((pe) => {
      s.value = pe.map(({ url: xe, label: Fe }) => ({
        label: Fe,
        value: xe
      }));
    });
    async function P(pe) {
      g = !0, M = await Zc.getRemoteEndpoint(pe).catch(() => alert(e("Impossible de contacter ce WMS", { ns: "client" }))), T = pe, g = !1;
    }
    async function z() {
      const pe = M, xe = pe == null ? void 0 : pe.getLayers();
      if (xe && xe[0]) {
        const Fe = cI(
          xe[0],
          T
        );
        h.value = Cf.updateLayers(Fe, n.layers);
      }
    }
    async function V(pe) {
      T = b = pe, await P(T), z();
    }
    function W(pe) {
      b = pe.target.value;
    }
    async function X() {
      await P(b), z();
    }
    function K(pe) {
      h.value = Cf.toggleNode(
        pe.id,
        h.value,
        "expanded"
      );
    }
    function se(pe) {
      const { id: xe, name: Fe } = pe, ze = M;
      if (pe.checked === !0)
        n.removeLayers(xe);
      else {
        const Pe = ze == null ? void 0 : ze.getLayerByName(Fe);
        if (Pe) {
          const Se = a.initLayer(
            hI({
              id: xe,
              url: Zc.getProxyfiedUrl(T),
              remoteLayer: Pe
            })
          );
          n.addLayers(Se);
        }
      }
    }
    return (pe, xe) => ae(o) ? (Ve(), on(QM, {
      key: 0,
      title: ae(e)("Add external data", { ns: "client" }),
      onClose: xe[0] || (xe[0] = (Fe) => ae(m)(!1))
    }, {
      content: Vd(() => {
        var Fe, ze;
        return [
          Re("div", b8, [
            Ft(LT, {
              class: "lux-remote-services-dropdown",
              options: ae(s),
              placeholder: ae(e)("Predefined wms", { ns: "client" }),
              onChange: V
            }, null, 8, ["options", "placeholder"]),
            Re("input", {
              class: "lux-input w-[300px]",
              type: "url",
              placeholder: ae(e)("Choose or write a WMS url", {
                ns: "client"
              }),
              value: ae(T) || "",
              onChange: W
            }, null, 40, w8),
            Re("button", {
              type: "button",
              class: "lux-btn",
              onClick: X
            }, Gt(ae(e)("Get the layers", { ns: "client" })), 1)
          ]),
          !ae(g) && ae(M) ? (Ve(), it("div", E8, [
            Re("span", S8, Gt(ae(e)("Description du service :", {
              ns: "client"
            })), 1),
            Mg(" " + Gt((Fe = ae(M).getServiceInfo()) == null ? void 0 : Fe.abstract), 1)
          ])) : Ye("v-if", !0),
          !ae(g) && ae(M) ? (Ve(), it("div", T8, [
            Re("span", M8, Gt(ae(e)("Access constraints :", {
              ns: "client"
            })), 1),
            Mg(" " + Gt((ze = ae(M).getServiceInfo()) == null ? void 0 : ze.constraints), 1)
          ])) : Ye("v-if", !0),
          ae(g) ? (Ve(), it("div", I8, [
            O8,
            Re("span", null, Gt(ae(e)("Chargement des informations", {
              ns: "client"
            })), 1)
          ])) : Ye("v-if", !0),
          ae(g) ? Ye("v-if", !0) : (Ve(), it("div", C8, [
            ae(h) ? (Ve(), on(l1, {
              key: 0,
              class: "block p-[10px] mb-[11px]",
              node: ae(h),
              onToggleParent: K,
              onToggleLayer: se
            }, null, 8, ["node"])) : Ye("v-if", !0)
          ]))
        ];
      }),
      _: 1
    }, 8, ["title"])) : Ye("v-if", !0);
  }
}), P8 = /* @__PURE__ */ ur(A8, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/remote-layers/remote-layers.vue"]]);
function k8(t, e = "fr-FR") {
  const n = new Date(t);
  return new Intl.DateTimeFormat(e).format(n);
}
const L8 = { class: "font-bold" }, D8 = { class: "col-span-2" }, N8 = /* @__PURE__ */ or({
  __name: "layer-metadata-item",
  props: {
    label: { type: String, required: !0 },
    value: { type: String, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Ve(), it(cn, null, [
      Re("span", L8, Gt(e.label), 1),
      Re("span", D8, Gt(e.value), 1)
    ], 64));
  }
}), Xp = /* @__PURE__ */ ur(N8, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-metadata/layer-metadata-item.vue"]]);
function R8(t) {
  return {
    fr: "fre",
    en: "eng",
    de: "ger",
    lb: "ltz"
  }[t.toLowerCase()];
}
function z8(t) {
  return new DOMParser().parseFromString(t, "text/html").body;
}
function F8(t) {
  const e = [];
  function n(a) {
    const s = a.split("|");
    s[3] === "WWW:LINK-1.0-http--link" && e.indexOf(s[2]) === -1 && e.push(s[2]);
  }
  return Array.isArray(t) ? t.forEach(n, t) : n(t), e;
}
function B8(t) {
  const n = (Array.isArray(t) ? t : [t]).filter((a) => a.split("|")[1] === "metadata");
  return {
    organisaton: n[0].split("|")[2],
    name: n[0].split("|")[5],
    unknown: n[0].split("|")[6],
    address: n[0].split("|")[7],
    email: n[0].split("|")[4]
  };
}
class fI {
}
class V8 extends fI {
  async getMetadata(e, n, a) {
    console.assert(e === Da.WMS);
    const s = Zc.getWmsEndpoint(n);
    await s.isReady();
    const h = s == null ? void 0 : s.getServiceInfo(), o = s == null ? void 0 : s.getLayerByName(a);
    return {
      title: o.title,
      description: o.abstract,
      keywords: h.keywords,
      accessConstraints: h.constraints,
      serviceDescription: h.abstract
    };
  }
}
const U8 = new V8();
class j8 extends fI {
  async getMetadata(e, n, a) {
    console.assert(e === Da.WMTS);
    const s = Zc.getWmtsEndpoint(n);
    await s.isReady();
    const h = s == null ? void 0 : s.getServiceInfo(), o = s == null ? void 0 : s.getLayerByName(a);
    return {
      title: o.title,
      description: o.abstract,
      accessConstraints: h.constraints,
      serviceDescription: h.abstract
    };
  }
}
const G8 = new j8();
class q8 {
  async getMetadata(e, n, a) {
    if (e === Da.WMS)
      return U8.getMetadata(e, n, a);
    if (e === Da.WMTS)
      return G8.getMetadata(e, n, a);
    throw new Error(`Unsupported service type: ${e}`);
  }
}
const $8 = new q8();
class W8 {
  constructor() {
    bi(this, "geonetworkBaseUrl", "https://geocatalogue.geoportail.lu/geonetwork/srv");
    bi(this, "legendBaseUrl", "https://map.geoportail.lu/legends/get_html");
    bi(this, "localMetadataBaseUrl", "https://map.geoportail.lu/getMetadata");
  }
  async getLayerMetadata(e, n) {
    const a = Hc(), s = a.findBgLayerById(+e) || a.findById(+e) || a.find3dLayerById(+e);
    if (s) {
      const h = s.metadata, o = h == null ? void 0 : h.metadata_id, m = o && await this.getLocalMetadata(
        this.localMetadataBaseUrl,
        o,
        n
      ), g = s.name, b = (h == null ? void 0 : h.legend_name) || "", T = s == null ? void 0 : s.id, M = b && await this.getLegendHtml(
        this.legendBaseUrl,
        b,
        T,
        n
      );
      return {
        ...m,
        title: g,
        hasLegend: !!M,
        ...M && { legendHtml: M }
      };
    } else {
      const [h, o, m] = String(e).split("%2D").join("-").split("||");
      return $8.getMetadata(
        h,
        o,
        m
      );
    }
  }
  getLocalMetadata(e, n, a) {
    return fetch(`${e}?lang=${a}&uid=${n}`).then(async (s) => {
      const h = (await s.json()).metadata;
      return {
        name: h.title,
        serviceDescription: h.serviceDescription,
        description: h.abstract,
        legalConstraints: h.legalConstraints,
        link: F8(h.link),
        revisionDate: h.revisionDate,
        keyword: h.keyword,
        responsibleParty: h.responsibleParty ? B8(h.responsibleParty) : void 0,
        metadataLink: `${this.geonetworkBaseUrl}/${R8(
          a
        )}/catalog.search#/metadata/${n}`,
        isError: !1
      };
    }).catch(() => ({ isError: !0 }));
  }
  getLegendHtml(e, n, a, s) {
    const h = {
      lang: s,
      ...n && { name: n },
      ...a && { id: a.toString() }
    };
    if (h.name && h.lang) {
      window.devicePixelRatio > 1 && (h.dpi = (window.devicePixelRatio * 96).toString());
      const o = `${e}?${new URLSearchParams(
        h
      ).toString()}`;
      return fetch(o).then(async (m) => {
        if (m.status >= 400 && m.status < 600)
          throw new Error("Server responded with error code");
        const g = await m.text();
        return g ? z8(g) : void 0;
      }).catch(() => {
      });
    }
  }
}
const sE = new W8(), H8 = { class: "grid gap-2 grid-cols-3 pt-3 text-[13px] font-arial break-words" }, Z8 = {
  key: 2,
  class: "col-span-3 grid gap-2 grid-cols-3"
}, X8 = { class: "font-bold" }, K8 = { class: "col-span-2" }, Y8 = ["title"], J8 = ["title"], Q8 = {
  key: 4,
  class: "col-span-3"
}, eV = { class: "font-bold" }, tV = { class: "col-span-2" }, rV = ["href"], nV = {
  key: 7,
  class: "col-span-3 grid gap-2 grid-cols-3"
}, iV = { class: "font-bold" }, oV = { class: "col-span-2" }, aV = { key: 0 }, sV = { key: 1 }, lV = { key: 2 }, uV = { key: 3 }, cV = { key: 4 }, hV = ["href"], fV = {
  key: 8,
  class: "grid gap-2 grid-cols-3 col-span-3"
}, pV = { class: "font-bold" }, dV = { class: "col-span-2" }, mV = ["href"], yV = {
  key: 9,
  class: "col-span-3"
}, gV = { key: 10 }, vV = { class: "text-xl" }, _V = {
  key: 11,
  class: "col-span-3"
}, xV = /* @__PURE__ */ or({
  __name: "layer-metadata",
  setup(t) {
    const e = Q1(), { metadataId: n } = xn(e), { t: a, i18next: s } = In(), h = Mr(), o = Mr(!0), m = 220;
    Bn(n, async (I) => {
      var P, z;
      h.value = I ? await sE.getLayerMetadata(I, s.language) : void 0, o.value = (((z = (P = h.value) == null ? void 0 : P.description) == null ? void 0 : z.length) || 0) < m;
    }), va(() => {
      s.on("languageChanged", async () => {
        n.value && (h.value = await sE.getLayerMetadata(
          n.value,
          s.language
        ));
      });
    });
    const g = lr(
      () => {
        var I, P, z;
        return o.value ? (I = h.value) == null ? void 0 : I.description : (z = (P = h.value) == null ? void 0 : P.description) == null ? void 0 : z.slice(0, m);
      }
    );
    function b() {
      o.value = !0;
    }
    function T() {
      o.value = !1;
    }
    function M() {
      e.clearMetadataId();
    }
    return (I, P) => {
      const z = SS("dompurify-html");
      return h.value ? (Ve(), on(QM, {
        key: 0,
        footer: !1,
        "max-height": !0,
        title: ae(a)(`${h.value.title}`, { ns: "client" }),
        onClose: M
      }, {
        content: Vd(() => {
          var V, W, X, K, se, pe, xe, Fe, ze, Pe, Se, Ie, Je, qe, at;
          return [
            Re("div", H8, [
              h.value.name ? (Ve(), on(Xp, {
                key: 0,
                label: ae(a)("Name"),
                value: h.value.name
              }, null, 8, ["label", "value"])) : Ye("v-if", !0),
              h.value.serviceDescription ? (Ve(), on(Xp, {
                key: 1,
                label: ae(a)("Description du Service"),
                value: h.value.serviceDescription
              }, null, 8, ["label", "value"])) : Ye("v-if", !0),
              h.value.description ? (Ve(), it("div", Z8, [
                Re("span", X8, Gt(ae(a)("Description")), 1),
                Re("span", K8, [
                  O0(Re("span", null, null, 512), [
                    [z, ae(g)]
                  ]),
                  o.value ? Ye("v-if", !0) : (Ve(), it("button", {
                    key: 0,
                    title: ae(a)("Display full description", {
                      ns: "client"
                    }),
                    onClick: b,
                    class: "text-secondary hover:underline"
                  }, " ... ", 8, Y8)),
                  o.value && (((V = ae(g)) == null ? void 0 : V.length) || 0) > m ? (Ve(), it("button", {
                    key: 1,
                    title: ae(a)("Hide full description", {
                      ns: "client"
                    }),
                    onClick: T,
                    class: "text-secondary hover:underline"
                  }, " - ", 8, J8)) : Ye("v-if", !0)
                ])
              ])) : Ye("v-if", !0),
              h.value.legalConstraints ? (Ve(), on(Xp, {
                key: 3,
                label: ae(a)("Contrainte d'utilisation"),
                value: h.value.legalConstraints
              }, null, 8, ["label", "value"])) : Ye("v-if", !0),
              ((W = h.value.link) == null ? void 0 : W.length) !== 0 ? (Ve(), it("div", Q8, [
                (Ve(!0), it(cn, null, Ra(h.value.link, (be) => (Ve(), it("div", {
                  class: "grid gap-2 grid-cols-3",
                  key: be
                }, [
                  Re("span", eV, Gt(ae(a)("Url vers la resource")), 1),
                  Re("span", tV, [
                    Re("a", {
                      class: "text-secondary hover:underline",
                      target: "_blank",
                      href: be
                    }, Gt(be), 9, rV)
                  ])
                ]))), 128))
              ])) : Ye("v-if", !0),
              h.value.revisionDate ? (Ve(), on(Xp, {
                key: 5,
                label: ae(a)("Revision date"),
                value: ae(k8)(h.value.revisionDate, ae(s).language)
              }, null, 8, ["label", "value"])) : Ye("v-if", !0),
              h.value.keyword ? (Ve(), on(Xp, {
                key: 6,
                label: ae(a)("Keywords"),
                value: (X = h.value.keyword) == null ? void 0 : X.join(",")
              }, null, 8, ["label", "value"])) : Ye("v-if", !0),
              h.value.responsibleParty ? (Ve(), it("div", nV, [
                Re("div", iV, Gt(ae(a)("Contact")), 1),
                Re("div", oV, [
                  (K = h.value.responsibleParty) != null && K.organisaton ? (Ve(), it("p", aV, Gt((se = h.value.responsibleParty) == null ? void 0 : se.organisaton), 1)) : Ye("v-if", !0),
                  (pe = h.value.responsibleParty) != null && pe.name ? (Ve(), it("p", sV, Gt((xe = h.value.responsibleParty) == null ? void 0 : xe.name), 1)) : Ye("v-if", !0),
                  (Fe = h.value.responsibleParty) != null && Fe.unknown ? (Ve(), it("p", lV, Gt((ze = h.value.responsibleParty) == null ? void 0 : ze.unknown), 1)) : Ye("v-if", !0),
                  (Pe = h.value.responsibleParty) != null && Pe.address ? (Ve(), it("p", uV, Gt((Se = h.value.responsibleParty) == null ? void 0 : Se.address), 1)) : Ye("v-if", !0),
                  (Ie = h.value.responsibleParty) != null && Ie.email ? (Ve(), it("p", cV, [
                    Re("a", {
                      class: "text-secondary hover:underline",
                      href: "mailto:" + ((Je = h.value.responsibleParty) == null ? void 0 : Je.email)
                    }, Gt((qe = h.value.responsibleParty) == null ? void 0 : qe.email), 9, hV)
                  ])) : Ye("v-if", !0)
                ])
              ])) : Ye("v-if", !0),
              h.value.metadataLink ? (Ve(), it("div", fV, [
                Re("span", pV, Gt(ae(a)("Link to the metadata")), 1),
                Re("span", dV, [
                  Re("a", {
                    class: "text-secondary hover:underline",
                    target: "_blank",
                    href: h.value.metadataLink
                  }, Gt(ae(a)("link")), 9, mV)
                ])
              ])) : Ye("v-if", !0),
              h.value.isError ? (Ve(), it("div", yV, Gt(ae(a)("The metadata is right now not available")), 1)) : Ye("v-if", !0),
              h.value.legendHtml ? (Ve(), it("div", gV, [
                Re("h4", vV, Gt(ae(a)("Legend")), 1),
                O0(Re("span", null, null, 512), [
                  [z, (at = h.value.legendHtml) == null ? void 0 : at.innerHTML]
                ])
              ])) : Ye("v-if", !0),
              h.value.hasLegend ? Ye("v-if", !0) : (Ve(), it("div", _V, Gt(ae(a)("The legend is not available for this layer")), 1))
            ])
          ];
        }),
        _: 1
      }, 8, ["title"])) : Ye("v-if", !0);
    };
  }
}), bV = /* @__PURE__ */ ur(xV, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-metadata/layer-metadata.vue"]]), wV = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM0AAAAoCAMAAABq645qAAACPVBMVEUAAABaW13////tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy5DjxTaAAAAvXRSTlMAAAABAgMEBQYHCAkKCwwNDg8QERESFBUWFxkaGx0eHyAhIiInKSosMTIzNTY5Ojs8PUFCQ0RERkpMTk9QU1RVVldaXmFjZWZmamtwcXJzdXd3eHl7fX+AgYKDhIaHiIiKi4yOj5CTlJWWl5iZmZqcnZ+goaKjpKanqKqqq6ywsbK0tbW4u7u8vb6/wMHExcbHysvMzM7P0NDS1NXa29zd3t/g4eTl5ujp6uvs7e7u8PLz9PX29/j5+vv8/f5cALqzAAAEcklEQVRo3u3Z+ZPUVBAH8O63LsLKijoIgotHFI+HgiKNeGC8MCqgUUFAJYjgAQ6HKMgGEQQiqChIPFh1iciiwPIEhvv49t/mD5lBORa2tHbLTO2rmqnUTCrJZ3r65ZuEjDHGGLrMWGcKMah7mh/7NP8PzXBqbqgfzdtPb7i/fjQPvq8r5jUVXNNIY4moYeL6+XNfn9Ov6LUZ2/Z7Pxo3YaZWTp/uLPw/reXYbqLRPz/38g+qJ/oTEV396IzmgmquXHZoIRHd/sTs31T1DqIBcyqHZjQWtTbf6nQiokHLVVWn7ju4euXGjsX9LtTAGgPAGGMzOPZSOGFYtmAXsO8skFkgZovQgi2QcZKyIGAAjJQtIgAB/5vRTc2IvbqSqOWNJQdUVdfe+/zitmsu2jeQ/GWMC43HacRhxhAWcJRyEgmYBSVYgROwgJkzeGVEDGEGotqnPaih1Xp63KSvVFVVtz0wt23AvMVda5AZY2FM7OWO/N2DwBMgESBiQZyABUgYSYQkYSBjhAh7QXN3Zfey7YdyzXh6aQpdu2fIpWsD30CykKOU4XPgmBPEnNcmC1jgIT9uCx9ZkOW1kQi9oBm6aMvO3KIVomUPES19/KIaoNo34uA8cUgtB4DzmQXCFoCFhbXgMtgC8DNGKMj7xnIKtj2toeGf55X5c9+ZRpo1lWjyq5c/33Avj+5obpz25miiwd+p6q4/2jfvIrqtrYlemF5MzZObTuhHCw6cUd2y/91ftj5DRJOn0JKniqm56jPtUNXDx44u6NywvaPzPqL+G5v3jCimhhqaX/vyi6VTxtzyYkVV9dSsRvrmnVXUI5oo7GkNEV2RH/igaRVV1Y8fOdE+tEc0tlzqBU1tND+7U1W18t51F8/QAFJrkUccL4VjABFb+MwoMyznszWzBZxfDT2SIbZgm0/TzBbIpLqcr8GwScJxfF4UiliAgGEZ1gKx8VK4bmuafmpdrqr6cFdXBJBSORPkp9A0ZI8hAi4jYQY8CEN8MDML2K/FBBdwKU80kOp3eSBirq7BkJJLstK5UShw+eYhDBGUYNPQeN3WTND2rd+r6oquNUZQ00A49gCEJQg8RhJD8j0DQX6IEBZYMLMAAANZrpHa8lkNBwjOi0Ion90KRIDIQEzsdVfzlurhT1X11F2XqE3qwfNQMiYLGYIYNgAQMcTltXHV3z9w1dAD/8LapH/XJt9eycWudG4U8lGrjYeSIAtMFlaD1SU1NxAR0cA9qrpqr6ruaOmybxLPREBojLEOzoMNkAXsO4YNYRnIpNo3WS30+EByXt+kttY3AEdAyGmZ4/TcKORCDgDhEAg5D0wO7vK1mbmwhajxA9XWkXTTh8dVj6wZX9gr6ZFL9eTm1nbVhUREdOs2Vb25sJqmRTuOq+r+rwfmgGEHVYcU+H7a8KNrdP6kYTXBJ6qPFVjT2DxwzD/msbWqE+vnrvqvevSeutGMUm0dXC+ahk3asb5unt+8cvLIqOvr52nU7Dv7nq31afo0/0mzrhiavwAx1n2SsZnMdgAAAABJRU5ErkJggg==";
class EV {
  bootstrap() {
    this.restore();
    let e;
    e = Na(() => {
      this.persist(), e && e();
    });
  }
  persist() {
    const e = Pi(), { lang: n } = xn(e);
    Bn(
      n,
      (a, s) => {
        s !== a && (Cr.setValue(Au, a), document.documentElement.setAttribute("lang", a));
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Cr.getValue(Au);
    if (e) {
      const { setLang: n } = Pi(), { i18next: a } = In();
      a.changeLanguage(e), n(e);
    }
  }
}
const SV = new EV(), TV = /* @__PURE__ */ or({
  __name: "language-selector",
  setup(t) {
    const { i18next: e, t: n } = In(), { setLang: a } = Pi(), { lang: s } = xn(Pi()), h = lr(
      () => ["en", "de", "fr", "lb"].map((g) => ({
        label: n(g),
        value: g,
        ariaLabel: n("Changer de langue : {{lang}}", { lang: g })
      }))
    ), o = n("Changer de langue");
    SV.bootstrap();
    function m(g) {
      e.changeLanguage(g), a(g);
    }
    return (g, b) => (Ve(), it("div", null, [
      Ft(LT, {
        class: "lux-navbar-dropdown lux-dropdown-inline text-white h-full",
        options: ae(h),
        placeholder: ae(o),
        modelValue: ae(s),
        "onUpdate:modelValue": b[0] || (b[0] = (T) => hn(s) ? s.value = T : null),
        onChange: m
      }, null, 8, ["options", "placeholder", "modelValue"])
    ]));
  }
}), MV = /* @__PURE__ */ ur(TV, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/nav-bars/language-selector.vue"]]);
class IV {
  setCurrentThemeColors(e) {
    const n = document.querySelector(":root");
    ["primary", "secondary", "tertiary"].forEach((s) => {
      const h = getComputedStyle(n).getPropertyValue(
        `--${e}-${s}`
      );
      n.style.setProperty(`--color-${s}`, h);
    });
  }
}
const OV = new IV(), CV = { class: "w-full h-14 flex bg-white shadow-header z-10 shrink-0" }, AV = /* @__PURE__ */ Re("div", { class: "flex-2 p-[5px]" }, [
  /* @__PURE__ */ Re("img", { src: wV })
], -1), PV = /* @__PURE__ */ Re("div", { class: "grow text-center" }, "search", -1), kV = { class: "h-full flex" }, LV = { class: "hidden lg:inline-block" }, DV = { class: "border-l-[1px] border-stone-300 h-full" }, NV = /* @__PURE__ */ or({
  __name: "header-bar",
  setup(t) {
    const { t: e } = In(), n = Pi(), { layersOpen: a, myLayersTabOpen: s, themeGridOpen: h } = xn(n), { setLayersOpen: o, setMyLayersTabOpen: m, setThemeGridOpen: g } = n, b = Ro(), { theme: T } = xn(b);
    Bn(
      T,
      (I) => {
        I && OV.setCurrentThemeColors(I.name);
      },
      { immediate: !0 }
    );
    function M() {
      a.value ? a.value && (h.value ? o(!1) : (s.value && m(!1), g(!0))) : (o(!0), s.value && m(!1), g(!0));
    }
    return (I, P) => {
      var z, V;
      return Ve(), it("header", CV, [
        AV,
        PV,
        Re("div", null, [
          Re("ul", kV, [
            Re("li", null, [
              Re("button", {
                class: Pr(["flex items-center before:font-icons before:text-3xl before:w-16 text-primary uppercase h-full mr-3", `before:content-${(z = ae(T)) == null ? void 0 : z.name}`]),
                onClick: M
              }, [
                Re("span", LV, Gt(ae(e)(`${(V = ae(T)) == null ? void 0 : V.name}`)), 1)
              ], 2)
            ]),
            Re("li", DV, [
              Ft(MV, { class: "flex-none h-full" })
            ])
          ])
        ])
      ]);
    };
  }
}), RV = /* @__PURE__ */ ur(NV, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/header/header-bar.vue"]]), zV = { class: "block text-[13px] sm:text-base uppercase" }, FV = /* @__PURE__ */ or({
  __name: "button-icon",
  props: {
    label: { type: String, required: !0 },
    icon: { type: String, required: !0 },
    active: { type: Boolean, required: !1 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Ve(), it("button", {
      class: Pr(["h-[42px] w-full sm:h-full sm:w-16 hover:text-white hover:bg-primary", e.active ? "bg-primary text-white" : ""])
    }, [
      Re("span", {
        class: Pr(["block text-[1.7rem] sm:text-[2rem] -mt-1.5 -mb-3 after:font-icons", e.active ? "lux-close-cross" : `after:content-${e.icon}`])
      }, null, 2),
      Re("span", zV, Gt(e.label), 1)
    ], 2));
  }
}), Pl = /* @__PURE__ */ ur(FV, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/footer/button-icon.vue"]]), BV = ["href"], VV = /* @__PURE__ */ or({
  __name: "button-link",
  props: {
    label: { type: String, required: !0 },
    link: { type: String, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Ve(), it("a", {
      class: "h-full flex flex-col justify-center px-[7px] uppercase hover:text-white hover:bg-primary",
      href: `${e.link}`,
      target: "_blank"
    }, Gt(n.$props.label), 9, BV));
  }
}), gu = /* @__PURE__ */ ur(VV, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/footer/button-link.vue"]]), UV = { class: "flex flex-col w-12 justify-between bg-white z-5 shrink-0 sm:flex-row sm:w-full sm:h-14 sm:shadow-footer" }, jV = { class: "flex flex-col w-full sm:w-80 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" }, GV = { class: "flex flex-col w-12 sm:w-64 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" }, qV = { class: "w-[466px] hidden sm:flex flex-row justify-end text-gray-500 whitespace-nowrap" }, $V = /* @__PURE__ */ or({
  __name: "footer-bar",
  setup(t) {
    const { t: e, i18next: n } = In(), { setLayersOpen: a } = Pi(), { layersOpen: s } = xn(Pi());
    return (h, o) => (Ve(), it("footer", UV, [
      Ye(" left buttons "),
      Re("ul", jV, [
        Re("li", null, [
          Ft(Pl, {
            label: ae(e)("Layers", { ns: "client" }),
            icon: "layers",
            active: ae(s),
            onClick: o[0] || (o[0] = () => ae(a)(!ae(s)))
          }, null, 8, ["label", "active"])
        ]),
        Ye(`TODOs in each button when implemented
        - remove class="text-gray-300"
        - add click handler that calls setLayersOpen(true) and opens tool (also via app store)
      `),
        Re("li", null, [
          Ft(Pl, {
            class: "text-gray-300",
            label: ae(e)("My Maps", { ns: "client" }),
            icon: "mymaps"
          }, null, 8, ["label"])
        ]),
        Re("li", null, [
          Ft(Pl, {
            class: "text-gray-300",
            label: ae(e)("Infos", { ns: "client" }),
            icon: "infos"
          }, null, 8, ["label"])
        ]),
        Re("li", null, [
          Ft(Pl, {
            class: "text-gray-300",
            label: ae(e)("Legends", { ns: "client" }),
            icon: "legends"
          }, null, 8, ["label"])
        ]),
        Re("li", null, [
          Ft(Pl, {
            class: "text-gray-300",
            label: ae(e)("Routing", { ns: "client" }),
            icon: "routing"
          }, null, 8, ["label"])
        ])
      ]),
      Ye(" center buttons "),
      Re("div", GV, [
        Ft(Pl, {
          class: "text-gray-300",
          label: ae(e)("Dessin", { ns: "client" }),
          icon: "draw"
        }, null, 8, ["label"]),
        Ft(Pl, {
          class: "text-gray-300 hidden sm:block",
          label: ae(e)("Mesurer", { ns: "client" }),
          icon: "measure"
        }, null, 8, ["label"]),
        Ft(Pl, {
          class: "text-gray-300 hidden sm:block",
          label: ae(e)("Imprimer", { ns: "client" }),
          icon: "print"
        }, null, 8, ["label"]),
        Ft(Pl, {
          class: "text-gray-300",
          label: ae(e)("Partager", { ns: "client" }),
          icon: "share"
        }, null, 8, ["label"])
      ]),
      Ye(" right buttons "),
      Re("div", qV, [
        Ft(gu, {
          class: "hidden lg:flex",
          label: ae(e)("What's new", { ns: "client" }),
          link: `https://geoportail.lu/${ae(n).language}/questions/whats-new/`
        }, null, 8, ["label", "link"]),
        Ye("TODO get geonetworkBaseUrl from config"),
        Ft(gu, {
          class: "hidden lg:flex",
          label: ae(e)("Geocatalogue", { ns: "client" }),
          link: ""
        }, null, 8, ["label"]),
        Ye("TODO handle feedback links (for different portals?)"),
        Ft(gu, {
          class: "hidden lg:flex",
          label: ae(e)("Feedback", { ns: "client" }),
          link: ""
        }, null, 8, ["label"]),
        Ft(gu, {
          class: "hidden lg:flex",
          label: ae(e)("A Propos", { ns: "client" }),
          link: `https://www.geoportail.lu/${ae(n).language}/propos/`
        }, null, 8, ["label", "link"]),
        Ft(gu, {
          class: "hidden lg:flex",
          label: ae(e)("Aide", { ns: "client" }),
          link: `https://www.geoportail.lu/${ae(n).language}/documentation/`
        }, null, 8, ["label", "link"]),
        Ft(gu, {
          class: "hidden lg:flex",
          label: ae(e)("Contact", { ns: "client" }),
          link: `https://www.geoportail.lu/${ae(n).language}/propos/contactez-nous/`
        }, null, 8, ["label", "link"]),
        Ft(gu, {
          label: ae(e)("Legalites", { ns: "client" }),
          link: `https://www.geoportail.lu/${ae(n).language}/propos/mentions-legales/`
        }, null, 8, ["label", "link"]),
        Ft(gu, {
          label: ae(e)("ACT", { ns: "client" }),
          link: "http://www.act.public.lu/"
        }, null, 8, ["label", "link"])
      ])
    ]));
  }
}), WV = /* @__PURE__ */ ur($V, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/footer/footer-bar.vue"]]), HV = { class: "flex flex-row flex-wrap pl-2.5" }, ZV = ["onClick"], XV = { class: "text-2xl absolute top-5" }, KV = /* @__PURE__ */ or({
  __name: "theme-grid",
  props: {
    themes: { type: Array, required: !0 }
  },
  setup(t) {
    const e = t, { t: n } = In();
    return (a, s) => (Ve(), it("div", HV, [
      (Ve(!0), it(cn, null, Ra(e.themes, (h) => (Ve(), it("button", {
        class: Pr(["relative shrink-0 h-[150px] w-1/2 px-2.5 text-start text-gray-100/40 uppercase hover:bg-[#ccc]", `bg-${h.name}-primary hover:text-${h.name}-primary`]),
        key: h.id,
        onClick: (o) => a.$emit("setTheme", h.name)
      }, [
        Re("div", XV, Gt(ae(n)(`${h.name}`)), 1),
        Re("div", {
          class: Pr(["text-6xl absolute bottom-1 after:font-icons", `after:content-${h.name}`])
        }, null, 2)
      ], 10, ZV))), 128))
    ]));
  }
}), YV = /* @__PURE__ */ ur(KV, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/theme-selector/theme-grid.vue"]]), JV = ["aria-expanded"], QV = { class: "py-0.5" }, eU = { class: "px-1 py-0.5 shrink-0 flex flex-row text-[12px] bg-secondary text-white" }, tU = { class: "py-[3px]" }, rU = { class: "flex flex-row flex-wrap ml-1 w-12" }, nU = /* @__PURE__ */ or({
  __name: "theme-selector-button",
  props: {
    themes: { type: Array, required: !0 },
    currentTheme: { type: null, required: !1 },
    isOpen: { type: Boolean, required: !1 }
  },
  setup(t) {
    const e = t, { t: n } = In(), a = lr(() => {
      var s;
      return ((s = e.themes) == null ? void 0 : s.slice(0, 8)) || [];
    });
    return (s, h) => {
      var o;
      return Ve(), it("button", {
        class: "w-full flex flex-row justify-between bg-tertiary text-white px-2 py-1.5 uppercase cursor-pointer hover:bg-white hover:text-primary",
        "aria-expanded": e.isOpen
      }, [
        Re("span", QV, Gt(ae(n)("Theme")) + ": " + Gt(ae(n)(`${(o = e.currentTheme) == null ? void 0 : o.name}`)), 1),
        Re("span", eU, [
          Re("span", tU, Gt(ae(n)("Changer")), 1),
          Re("span", rU, [
            (Ve(!0), it(cn, null, Ra(ae(a), (m) => (Ve(), it("div", {
              class: Pr(`h-2.5 w-2.5 m-px bg-${m.name}-primary`),
              key: m.id
            }, null, 2))), 128))
          ])
        ])
      ], 8, JV);
    };
  }
}), iU = /* @__PURE__ */ ur(nU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/theme-selector/theme-selector-button.vue"]]), oU = {
  key: 0,
  class: "absolute inset-x-0 top-14 bottom-0 mt-1 bg-primary overflow-y-auto overflow-x-hidden"
}, aU = /* @__PURE__ */ or({
  __name: "theme-selector",
  setup(t) {
    const e = Pi(), { setThemeGridOpen: n } = e, { themeGridOpen: a } = xn(e), s = Ro(), h = Hc(), { theme: o, themes: m } = xn(s), g = lr(
      () => {
        var M;
        return ((M = m.value) == null ? void 0 : M.filter(
          (I) => {
            var P;
            return ((P = I.metadata) == null ? void 0 : P.display_in_switcher) === !0;
          }
        )) || [];
      }
    );
    function b() {
      n(!a.value);
    }
    function T(M) {
      h.setTheme(M), b();
    }
    return (M, I) => (Ve(), it(cn, null, [
      Ft(iU, {
        onClick: b,
        themes: ae(g),
        currentTheme: ae(o),
        isOpen: ae(a)
      }, null, 8, ["themes", "currentTheme", "isOpen"]),
      ae(a) ? (Ve(), it("div", oU, [
        Ft(YV, {
          onSetTheme: T,
          themes: ae(g)
        }, null, 8, ["themes"])
      ])) : Ye("v-if", !0)
    ], 64));
  }
}), sU = /* @__PURE__ */ ur(aU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/theme-selector/theme-selector.vue"]]);
function c1(t, e = 0) {
  const { name: n, id: a, children: s, metadata: h } = t;
  return {
    name: n,
    id: a,
    depth: e,
    children: s == null ? void 0 : s.map((o) => c1(o, e + 1)),
    checked: !1,
    expanded: (h == null ? void 0 : h.is_expanded) || !1
  };
}
const lU = {
  key: 0,
  class: "mb-7"
}, uU = /* @__PURE__ */ or({
  __name: "catalog-tree",
  setup(t) {
    const e = Ai(), n = Ro(), a = ku(), s = Fn(), h = Fn(), o = lr(
      () => !e.is3dActive || e.is3dActive && !e.is3dMesh
    ), { layerTrees_3d: m } = xn(n);
    Na(g);
    function g() {
      var M;
      if (n.theme && e.layers) {
        const I = s.value && s.value.id === ((M = n.theme) == null ? void 0 : M.id) ? s.value : c1(n.theme);
        s.value = Cf.updateLayers(
          I,
          e.layers
        );
      }
    }
    Na(() => {
      if (m.value) {
        const M = h.value ? h.value : c1(m.value);
        h.value = Cf.updateLayers(
          M,
          e.layers3d
        );
      }
    });
    function b(M, I) {
      const P = I ? h : s;
      P.value = Cf.toggleNode(
        M.id,
        P.value,
        "expanded"
      );
    }
    function T(M, I) {
      a.toggleLayer(+M.id, !M.checked, I);
    }
    return (M, I) => (Ve(), it("div", null, [
      Ye(" 3D layers catalog, only displayed when 3D is active "),
      ae(h) && ae(e).is3dActive ? (Ve(), it("div", lU, [
        (Ve(), on(l1, {
          node: ae(h),
          key: ae(h).id,
          onToggleParent: I[0] || (I[0] = (P) => b(P, !0)),
          onToggleLayer: I[1] || (I[1] = (P) => T(P, !0))
        }, null, 8, ["node"]))
      ])) : Ye("v-if", !0),
      Ye(" Main catalog, displays by default and 3D terrain active "),
      ae(s) && ae(o) ? (Ve(), on(l1, {
        node: ae(s),
        key: ae(s).id,
        onToggleParent: I[2] || (I[2] = (P) => b(P, !1)),
        onToggleLayer: I[3] || (I[3] = (P) => T(P, !1))
      }, null, 8, ["node"])) : Ye("v-if", !0)
    ]));
  }
}), cU = /* @__PURE__ */ ur(uU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/catalog/catalog-tree.vue"]]), hU = /* @__PURE__ */ or({
  __name: "catalog-tab",
  setup(t) {
    const { themeGridOpen: e } = xn(Pi());
    return (n, a) => (Ve(), it(cn, null, [
      Ft(sU),
      ae(e) === !1 ? (Ve(), on(cU, {
        key: 0,
        class: "pt-5 absolute inset-x-2.5 bg-primary overflow-y-auto overflow-x-hidden"
      })) : Ye("v-if", !0)
    ], 64));
  }
}), fU = /* @__PURE__ */ ur(hU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/catalog/catalog-tab.vue"]]);
/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function lE(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Qs(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? lE(Object(n), !0).forEach(function(a) {
      pU(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : lE(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function cg(t) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? cg = function(e) {
    return typeof e;
  } : cg = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, cg(t);
}
function pU(t, e, n) {
  return e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Gl() {
  return Gl = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, Gl.apply(this, arguments);
}
function dU(t, e) {
  if (t == null)
    return {};
  var n = {}, a = Object.keys(t), s, h;
  for (h = 0; h < a.length; h++)
    s = a[h], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
function mU(t, e) {
  if (t == null)
    return {};
  var n = dU(t, e), a, s;
  if (Object.getOwnPropertySymbols) {
    var h = Object.getOwnPropertySymbols(t);
    for (s = 0; s < h.length; s++)
      a = h[s], !(e.indexOf(a) >= 0) && (!Object.prototype.propertyIsEnumerable.call(t, a) || (n[a] = t[a]));
  }
  return n;
}
var yU = "1.15.0";
function Fl(t) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(t);
}
var Wl = Fl(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), rm = Fl(/Edge/i), uE = Fl(/firefox/i), vd = Fl(/safari/i) && !Fl(/chrome/i) && !Fl(/android/i), pI = Fl(/iP(ad|od|hone)/i), dI = Fl(/chrome/i) && Fl(/android/i), mI = {
  capture: !1,
  passive: !1
};
function nn(t, e, n) {
  t.addEventListener(e, n, !Wl && mI);
}
function Kr(t, e, n) {
  t.removeEventListener(e, n, !Wl && mI);
}
function Yg(t, e) {
  if (!!e) {
    if (e[0] === ">" && (e = e.substring(1)), t)
      try {
        if (t.matches)
          return t.matches(e);
        if (t.msMatchesSelector)
          return t.msMatchesSelector(e);
        if (t.webkitMatchesSelector)
          return t.webkitMatchesSelector(e);
      } catch {
        return !1;
      }
    return !1;
  }
}
function gU(t) {
  return t.host && t !== document && t.host.nodeType ? t.host : t.parentNode;
}
function Fs(t, e, n, a) {
  if (t) {
    n = n || document;
    do {
      if (e != null && (e[0] === ">" ? t.parentNode === n && Yg(t, e) : Yg(t, e)) || a && t === n)
        return t;
      if (t === n)
        break;
    } while (t = gU(t));
  }
  return null;
}
var cE = /\s+/g;
function ha(t, e, n) {
  if (t && e)
    if (t.classList)
      t.classList[n ? "add" : "remove"](e);
    else {
      var a = (" " + t.className + " ").replace(cE, " ").replace(" " + e + " ", " ");
      t.className = (a + (n ? " " + e : "")).replace(cE, " ");
    }
}
function cr(t, e, n) {
  var a = t && t.style;
  if (a) {
    if (n === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(t, "") : t.currentStyle && (n = t.currentStyle), e === void 0 ? n : n[e];
    !(e in a) && e.indexOf("webkit") === -1 && (e = "-webkit-" + e), a[e] = n + (typeof n == "string" ? "" : "px");
  }
}
function Af(t, e) {
  var n = "";
  if (typeof t == "string")
    n = t;
  else
    do {
      var a = cr(t, "transform");
      a && a !== "none" && (n = a + " " + n);
    } while (!e && (t = t.parentNode));
  var s = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return s && new s(n);
}
function yI(t, e, n) {
  if (t) {
    var a = t.getElementsByTagName(e), s = 0, h = a.length;
    if (n)
      for (; s < h; s++)
        n(a[s], s);
    return a;
  }
  return [];
}
function Xs() {
  var t = document.scrollingElement;
  return t || document.documentElement;
}
function Ri(t, e, n, a, s) {
  if (!(!t.getBoundingClientRect && t !== window)) {
    var h, o, m, g, b, T, M;
    if (t !== window && t.parentNode && t !== Xs() ? (h = t.getBoundingClientRect(), o = h.top, m = h.left, g = h.bottom, b = h.right, T = h.height, M = h.width) : (o = 0, m = 0, g = window.innerHeight, b = window.innerWidth, T = window.innerHeight, M = window.innerWidth), (e || n) && t !== window && (s = s || t.parentNode, !Wl))
      do
        if (s && s.getBoundingClientRect && (cr(s, "transform") !== "none" || n && cr(s, "position") !== "static")) {
          var I = s.getBoundingClientRect();
          o -= I.top + parseInt(cr(s, "border-top-width")), m -= I.left + parseInt(cr(s, "border-left-width")), g = o + h.height, b = m + h.width;
          break;
        }
      while (s = s.parentNode);
    if (a && t !== window) {
      var P = Af(s || t), z = P && P.a, V = P && P.d;
      P && (o /= V, m /= z, M /= z, T /= V, g = o + T, b = m + M);
    }
    return {
      top: o,
      left: m,
      bottom: g,
      right: b,
      width: M,
      height: T
    };
  }
}
function hE(t, e, n) {
  for (var a = Mu(t, !0), s = Ri(t)[e]; a; ) {
    var h = Ri(a)[n], o = void 0;
    if (n === "top" || n === "left" ? o = s >= h : o = s <= h, !o)
      return a;
    if (a === Xs())
      break;
    a = Mu(a, !1);
  }
  return !1;
}
function Rf(t, e, n, a) {
  for (var s = 0, h = 0, o = t.children; h < o.length; ) {
    if (o[h].style.display !== "none" && o[h] !== sr.ghost && (a || o[h] !== sr.dragged) && Fs(o[h], n.draggable, t, !1)) {
      if (s === e)
        return o[h];
      s++;
    }
    h++;
  }
  return null;
}
function ax(t, e) {
  for (var n = t.lastElementChild; n && (n === sr.ghost || cr(n, "display") === "none" || e && !Yg(n, e)); )
    n = n.previousElementSibling;
  return n || null;
}
function Aa(t, e) {
  var n = 0;
  if (!t || !t.parentNode)
    return -1;
  for (; t = t.previousElementSibling; )
    t.nodeName.toUpperCase() !== "TEMPLATE" && t !== sr.clone && (!e || Yg(t, e)) && n++;
  return n;
}
function fE(t) {
  var e = 0, n = 0, a = Xs();
  if (t)
    do {
      var s = Af(t), h = s.a, o = s.d;
      e += t.scrollLeft * h, n += t.scrollTop * o;
    } while (t !== a && (t = t.parentNode));
  return [e, n];
}
function vU(t, e) {
  for (var n in t)
    if (!!t.hasOwnProperty(n)) {
      for (var a in e)
        if (e.hasOwnProperty(a) && e[a] === t[n][a])
          return Number(n);
    }
  return -1;
}
function Mu(t, e) {
  if (!t || !t.getBoundingClientRect)
    return Xs();
  var n = t, a = !1;
  do
    if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) {
      var s = cr(n);
      if (n.clientWidth < n.scrollWidth && (s.overflowX == "auto" || s.overflowX == "scroll") || n.clientHeight < n.scrollHeight && (s.overflowY == "auto" || s.overflowY == "scroll")) {
        if (!n.getBoundingClientRect || n === document.body)
          return Xs();
        if (a || e)
          return n;
        a = !0;
      }
    }
  while (n = n.parentNode);
  return Xs();
}
function _U(t, e) {
  if (t && e)
    for (var n in e)
      e.hasOwnProperty(n) && (t[n] = e[n]);
  return t;
}
function u0(t, e) {
  return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width);
}
var _d;
function gI(t, e) {
  return function() {
    if (!_d) {
      var n = arguments, a = this;
      n.length === 1 ? t.call(a, n[0]) : t.apply(a, n), _d = setTimeout(function() {
        _d = void 0;
      }, e);
    }
  };
}
function xU() {
  clearTimeout(_d), _d = void 0;
}
function vI(t, e, n) {
  t.scrollLeft += e, t.scrollTop += n;
}
function _I(t) {
  var e = window.Polymer, n = window.jQuery || window.Zepto;
  return e && e.dom ? e.dom(t).cloneNode(!0) : n ? n(t).clone(!0)[0] : t.cloneNode(!0);
}
var ma = "Sortable" + new Date().getTime();
function bU() {
  var t = [], e;
  return {
    captureAnimationState: function() {
      if (t = [], !!this.options.animation) {
        var a = [].slice.call(this.el.children);
        a.forEach(function(s) {
          if (!(cr(s, "display") === "none" || s === sr.ghost)) {
            t.push({
              target: s,
              rect: Ri(s)
            });
            var h = Qs({}, t[t.length - 1].rect);
            if (s.thisAnimationDuration) {
              var o = Af(s, !0);
              o && (h.top -= o.f, h.left -= o.e);
            }
            s.fromRect = h;
          }
        });
      }
    },
    addAnimationState: function(a) {
      t.push(a);
    },
    removeAnimationState: function(a) {
      t.splice(vU(t, {
        target: a
      }), 1);
    },
    animateAll: function(a) {
      var s = this;
      if (!this.options.animation) {
        clearTimeout(e), typeof a == "function" && a();
        return;
      }
      var h = !1, o = 0;
      t.forEach(function(m) {
        var g = 0, b = m.target, T = b.fromRect, M = Ri(b), I = b.prevFromRect, P = b.prevToRect, z = m.rect, V = Af(b, !0);
        V && (M.top -= V.f, M.left -= V.e), b.toRect = M, b.thisAnimationDuration && u0(I, M) && !u0(T, M) && (z.top - M.top) / (z.left - M.left) === (T.top - M.top) / (T.left - M.left) && (g = EU(z, I, P, s.options)), u0(M, T) || (b.prevFromRect = T, b.prevToRect = M, g || (g = s.options.animation), s.animate(b, z, M, g)), g && (h = !0, o = Math.max(o, g), clearTimeout(b.animationResetTimer), b.animationResetTimer = setTimeout(function() {
          b.animationTime = 0, b.prevFromRect = null, b.fromRect = null, b.prevToRect = null, b.thisAnimationDuration = null;
        }, g), b.thisAnimationDuration = g);
      }), clearTimeout(e), h ? e = setTimeout(function() {
        typeof a == "function" && a();
      }, o) : typeof a == "function" && a(), t = [];
    },
    animate: function(a, s, h, o) {
      if (o) {
        cr(a, "transition", ""), cr(a, "transform", "");
        var m = Af(this.el), g = m && m.a, b = m && m.d, T = (s.left - h.left) / (g || 1), M = (s.top - h.top) / (b || 1);
        a.animatingX = !!T, a.animatingY = !!M, cr(a, "transform", "translate3d(" + T + "px," + M + "px,0)"), this.forRepaintDummy = wU(a), cr(a, "transition", "transform " + o + "ms" + (this.options.easing ? " " + this.options.easing : "")), cr(a, "transform", "translate3d(0,0,0)"), typeof a.animated == "number" && clearTimeout(a.animated), a.animated = setTimeout(function() {
          cr(a, "transition", ""), cr(a, "transform", ""), a.animated = !1, a.animatingX = !1, a.animatingY = !1;
        }, o);
      }
    }
  };
}
function wU(t) {
  return t.offsetWidth;
}
function EU(t, e, n, a) {
  return Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) / Math.sqrt(Math.pow(e.top - n.top, 2) + Math.pow(e.left - n.left, 2)) * a.animation;
}
var sf = [], c0 = {
  initializeByDefault: !0
}, nm = {
  mount: function(e) {
    for (var n in c0)
      c0.hasOwnProperty(n) && !(n in e) && (e[n] = c0[n]);
    sf.forEach(function(a) {
      if (a.pluginName === e.pluginName)
        throw "Sortable: Cannot mount plugin ".concat(e.pluginName, " more than once");
    }), sf.push(e);
  },
  pluginEvent: function(e, n, a) {
    var s = this;
    this.eventCanceled = !1, a.cancel = function() {
      s.eventCanceled = !0;
    };
    var h = e + "Global";
    sf.forEach(function(o) {
      !n[o.pluginName] || (n[o.pluginName][h] && n[o.pluginName][h](Qs({
        sortable: n
      }, a)), n.options[o.pluginName] && n[o.pluginName][e] && n[o.pluginName][e](Qs({
        sortable: n
      }, a)));
    });
  },
  initializePlugins: function(e, n, a, s) {
    sf.forEach(function(m) {
      var g = m.pluginName;
      if (!(!e.options[g] && !m.initializeByDefault)) {
        var b = new m(e, n, e.options);
        b.sortable = e, b.options = e.options, e[g] = b, Gl(a, b.defaults);
      }
    });
    for (var h in e.options)
      if (!!e.options.hasOwnProperty(h)) {
        var o = this.modifyOption(e, h, e.options[h]);
        typeof o < "u" && (e.options[h] = o);
      }
  },
  getEventProperties: function(e, n) {
    var a = {};
    return sf.forEach(function(s) {
      typeof s.eventProperties == "function" && Gl(a, s.eventProperties.call(n[s.pluginName], e));
    }), a;
  },
  modifyOption: function(e, n, a) {
    var s;
    return sf.forEach(function(h) {
      !e[h.pluginName] || h.optionListeners && typeof h.optionListeners[n] == "function" && (s = h.optionListeners[n].call(e[h.pluginName], a));
    }), s;
  }
};
function SU(t) {
  var e = t.sortable, n = t.rootEl, a = t.name, s = t.targetEl, h = t.cloneEl, o = t.toEl, m = t.fromEl, g = t.oldIndex, b = t.newIndex, T = t.oldDraggableIndex, M = t.newDraggableIndex, I = t.originalEvent, P = t.putSortable, z = t.extraEventProperties;
  if (e = e || n && n[ma], !!e) {
    var V, W = e.options, X = "on" + a.charAt(0).toUpperCase() + a.substr(1);
    window.CustomEvent && !Wl && !rm ? V = new CustomEvent(a, {
      bubbles: !0,
      cancelable: !0
    }) : (V = document.createEvent("Event"), V.initEvent(a, !0, !0)), V.to = o || n, V.from = m || n, V.item = s || n, V.clone = h, V.oldIndex = g, V.newIndex = b, V.oldDraggableIndex = T, V.newDraggableIndex = M, V.originalEvent = I, V.pullMode = P ? P.lastPutMode : void 0;
    var K = Qs(Qs({}, z), nm.getEventProperties(a, e));
    for (var se in K)
      V[se] = K[se];
    n && n.dispatchEvent(V), W[X] && W[X].call(e, V);
  }
}
var TU = ["evt"], Jo = function(e, n) {
  var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = a.evt, h = mU(a, TU);
  nm.pluginEvent.bind(sr)(e, n, Qs({
    dragEl: St,
    parentEl: hi,
    ghostEl: Tr,
    rootEl: $n,
    nextEl: Rc,
    lastDownEl: hg,
    cloneEl: ri,
    cloneHidden: Tu,
    dragStarted: od,
    putSortable: no,
    activeSortable: sr.active,
    originalEvent: s,
    oldIndex: _f,
    oldDraggableIndex: xd,
    newIndex: fa,
    newDraggableIndex: bu,
    hideGhostForTarget: EI,
    unhideGhostForTarget: SI,
    cloneNowHidden: function() {
      Tu = !0;
    },
    cloneNowShown: function() {
      Tu = !1;
    },
    dispatchSortableEvent: function(m) {
      Lo({
        sortable: n,
        name: m,
        originalEvent: s
      });
    }
  }, h));
};
function Lo(t) {
  SU(Qs({
    putSortable: no,
    cloneEl: ri,
    targetEl: St,
    rootEl: $n,
    oldIndex: _f,
    oldDraggableIndex: xd,
    newIndex: fa,
    newDraggableIndex: bu
  }, t));
}
var St, hi, Tr, $n, Rc, hg, ri, Tu, _f, fa, xd, bu, Uy, no, hf = !1, Jg = !1, Qg = [], Ac, Ja, h0, f0, pE, dE, od, lf, bd, wd = !1, jy = !1, fg, go, p0 = [], h1 = !1, ev = [], Dv = typeof document < "u", Gy = pI, mE = rm || Wl ? "cssFloat" : "float", MU = Dv && !dI && !pI && "draggable" in document.createElement("div"), xI = function() {
  if (!!Dv) {
    if (Wl)
      return !1;
    var t = document.createElement("x");
    return t.style.cssText = "pointer-events:auto", t.style.pointerEvents === "auto";
  }
}(), bI = function(e, n) {
  var a = cr(e), s = parseInt(a.width) - parseInt(a.paddingLeft) - parseInt(a.paddingRight) - parseInt(a.borderLeftWidth) - parseInt(a.borderRightWidth), h = Rf(e, 0, n), o = Rf(e, 1, n), m = h && cr(h), g = o && cr(o), b = m && parseInt(m.marginLeft) + parseInt(m.marginRight) + Ri(h).width, T = g && parseInt(g.marginLeft) + parseInt(g.marginRight) + Ri(o).width;
  if (a.display === "flex")
    return a.flexDirection === "column" || a.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (a.display === "grid")
    return a.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (h && m.float && m.float !== "none") {
    var M = m.float === "left" ? "left" : "right";
    return o && (g.clear === "both" || g.clear === M) ? "vertical" : "horizontal";
  }
  return h && (m.display === "block" || m.display === "flex" || m.display === "table" || m.display === "grid" || b >= s && a[mE] === "none" || o && a[mE] === "none" && b + T > s) ? "vertical" : "horizontal";
}, IU = function(e, n, a) {
  var s = a ? e.left : e.top, h = a ? e.right : e.bottom, o = a ? e.width : e.height, m = a ? n.left : n.top, g = a ? n.right : n.bottom, b = a ? n.width : n.height;
  return s === m || h === g || s + o / 2 === m + b / 2;
}, OU = function(e, n) {
  var a;
  return Qg.some(function(s) {
    var h = s[ma].options.emptyInsertThreshold;
    if (!(!h || ax(s))) {
      var o = Ri(s), m = e >= o.left - h && e <= o.right + h, g = n >= o.top - h && n <= o.bottom + h;
      if (m && g)
        return a = s;
    }
  }), a;
}, wI = function(e) {
  function n(h, o) {
    return function(m, g, b, T) {
      var M = m.options.group.name && g.options.group.name && m.options.group.name === g.options.group.name;
      if (h == null && (o || M))
        return !0;
      if (h == null || h === !1)
        return !1;
      if (o && h === "clone")
        return h;
      if (typeof h == "function")
        return n(h(m, g, b, T), o)(m, g, b, T);
      var I = (o ? m : g).options.group.name;
      return h === !0 || typeof h == "string" && h === I || h.join && h.indexOf(I) > -1;
    };
  }
  var a = {}, s = e.group;
  (!s || cg(s) != "object") && (s = {
    name: s
  }), a.name = s.name, a.checkPull = n(s.pull, !0), a.checkPut = n(s.put), a.revertClone = s.revertClone, e.group = a;
}, EI = function() {
  !xI && Tr && cr(Tr, "display", "none");
}, SI = function() {
  !xI && Tr && cr(Tr, "display", "");
};
Dv && !dI && document.addEventListener("click", function(t) {
  if (Jg)
    return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), Jg = !1, !1;
}, !0);
var Pc = function(e) {
  if (St) {
    e = e.touches ? e.touches[0] : e;
    var n = OU(e.clientX, e.clientY);
    if (n) {
      var a = {};
      for (var s in e)
        e.hasOwnProperty(s) && (a[s] = e[s]);
      a.target = a.rootEl = n, a.preventDefault = void 0, a.stopPropagation = void 0, n[ma]._onDragOver(a);
    }
  }
}, CU = function(e) {
  St && St.parentNode[ma]._isOutsideThisEl(e.target);
};
function sr(t, e) {
  if (!(t && t.nodeType && t.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t));
  this.el = t, this.options = e = Gl({}, e), t[ma] = this;
  var n = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(t.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: !1,
    invertedSwapThreshold: null,
    removeCloneOnHide: !0,
    direction: function() {
      return bI(t, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(o, m) {
      o.setData("Text", m.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: sr.supportPointer !== !1 && "PointerEvent" in window && !vd,
    emptyInsertThreshold: 5
  };
  nm.initializePlugins(this, t, n);
  for (var a in n)
    !(a in e) && (e[a] = n[a]);
  wI(e);
  for (var s in this)
    s.charAt(0) === "_" && typeof this[s] == "function" && (this[s] = this[s].bind(this));
  this.nativeDraggable = e.forceFallback ? !1 : MU, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? nn(t, "pointerdown", this._onTapStart) : (nn(t, "mousedown", this._onTapStart), nn(t, "touchstart", this._onTapStart)), this.nativeDraggable && (nn(t, "dragover", this), nn(t, "dragenter", this)), Qg.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), Gl(this, bU());
}
sr.prototype = {
  constructor: sr,
  _isOutsideThisEl: function(e) {
    !this.el.contains(e) && e !== this.el && (lf = null);
  },
  _getDirection: function(e, n) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, e, n, St) : this.options.direction;
  },
  _onTapStart: function(e) {
    if (!!e.cancelable) {
      var n = this, a = this.el, s = this.options, h = s.preventOnFilter, o = e.type, m = e.touches && e.touches[0] || e.pointerType && e.pointerType === "touch" && e, g = (m || e).target, b = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || g, T = s.filter;
      if (zU(a), !St && !(/mousedown|pointerdown/.test(o) && e.button !== 0 || s.disabled) && !b.isContentEditable && !(!this.nativeDraggable && vd && g && g.tagName.toUpperCase() === "SELECT") && (g = Fs(g, s.draggable, a, !1), !(g && g.animated) && hg !== g)) {
        if (_f = Aa(g), xd = Aa(g, s.draggable), typeof T == "function") {
          if (T.call(this, e, g, this)) {
            Lo({
              sortable: n,
              rootEl: b,
              name: "filter",
              targetEl: g,
              toEl: a,
              fromEl: a
            }), Jo("filter", n, {
              evt: e
            }), h && e.cancelable && e.preventDefault();
            return;
          }
        } else if (T && (T = T.split(",").some(function(M) {
          if (M = Fs(b, M.trim(), a, !1), M)
            return Lo({
              sortable: n,
              rootEl: M,
              name: "filter",
              targetEl: g,
              fromEl: a,
              toEl: a
            }), Jo("filter", n, {
              evt: e
            }), !0;
        }), T)) {
          h && e.cancelable && e.preventDefault();
          return;
        }
        s.handle && !Fs(b, s.handle, a, !1) || this._prepareDragStart(e, m, g);
      }
    }
  },
  _prepareDragStart: function(e, n, a) {
    var s = this, h = s.el, o = s.options, m = h.ownerDocument, g;
    if (a && !St && a.parentNode === h) {
      var b = Ri(a);
      if ($n = h, St = a, hi = St.parentNode, Rc = St.nextSibling, hg = a, Uy = o.group, sr.dragged = St, Ac = {
        target: St,
        clientX: (n || e).clientX,
        clientY: (n || e).clientY
      }, pE = Ac.clientX - b.left, dE = Ac.clientY - b.top, this._lastX = (n || e).clientX, this._lastY = (n || e).clientY, St.style["will-change"] = "all", g = function() {
        if (Jo("delayEnded", s, {
          evt: e
        }), sr.eventCanceled) {
          s._onDrop();
          return;
        }
        s._disableDelayedDragEvents(), !uE && s.nativeDraggable && (St.draggable = !0), s._triggerDragStart(e, n), Lo({
          sortable: s,
          name: "choose",
          originalEvent: e
        }), ha(St, o.chosenClass, !0);
      }, o.ignore.split(",").forEach(function(T) {
        yI(St, T.trim(), d0);
      }), nn(m, "dragover", Pc), nn(m, "mousemove", Pc), nn(m, "touchmove", Pc), nn(m, "mouseup", s._onDrop), nn(m, "touchend", s._onDrop), nn(m, "touchcancel", s._onDrop), uE && this.nativeDraggable && (this.options.touchStartThreshold = 4, St.draggable = !0), Jo("delayStart", this, {
        evt: e
      }), o.delay && (!o.delayOnTouchOnly || n) && (!this.nativeDraggable || !(rm || Wl))) {
        if (sr.eventCanceled) {
          this._onDrop();
          return;
        }
        nn(m, "mouseup", s._disableDelayedDrag), nn(m, "touchend", s._disableDelayedDrag), nn(m, "touchcancel", s._disableDelayedDrag), nn(m, "mousemove", s._delayedDragTouchMoveHandler), nn(m, "touchmove", s._delayedDragTouchMoveHandler), o.supportPointer && nn(m, "pointermove", s._delayedDragTouchMoveHandler), s._dragStartTimer = setTimeout(g, o.delay);
      } else
        g();
    }
  },
  _delayedDragTouchMoveHandler: function(e) {
    var n = e.touches ? e.touches[0] : e;
    Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    St && d0(St), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var e = this.el.ownerDocument;
    Kr(e, "mouseup", this._disableDelayedDrag), Kr(e, "touchend", this._disableDelayedDrag), Kr(e, "touchcancel", this._disableDelayedDrag), Kr(e, "mousemove", this._delayedDragTouchMoveHandler), Kr(e, "touchmove", this._delayedDragTouchMoveHandler), Kr(e, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(e, n) {
    n = n || e.pointerType == "touch" && e, !this.nativeDraggable || n ? this.options.supportPointer ? nn(document, "pointermove", this._onTouchMove) : n ? nn(document, "touchmove", this._onTouchMove) : nn(document, "mousemove", this._onTouchMove) : (nn(St, "dragend", this), nn($n, "dragstart", this._onDragStart));
    try {
      document.selection ? pg(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(e, n) {
    if (hf = !1, $n && St) {
      Jo("dragStarted", this, {
        evt: n
      }), this.nativeDraggable && nn(document, "dragover", CU);
      var a = this.options;
      !e && ha(St, a.dragClass, !1), ha(St, a.ghostClass, !0), sr.active = this, e && this._appendGhost(), Lo({
        sortable: this,
        name: "start",
        originalEvent: n
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (Ja) {
      this._lastX = Ja.clientX, this._lastY = Ja.clientY, EI();
      for (var e = document.elementFromPoint(Ja.clientX, Ja.clientY), n = e; e && e.shadowRoot && (e = e.shadowRoot.elementFromPoint(Ja.clientX, Ja.clientY), e !== n); )
        n = e;
      if (St.parentNode[ma]._isOutsideThisEl(e), n)
        do {
          if (n[ma]) {
            var a = void 0;
            if (a = n[ma]._onDragOver({
              clientX: Ja.clientX,
              clientY: Ja.clientY,
              target: e,
              rootEl: n
            }), a && !this.options.dragoverBubble)
              break;
          }
          e = n;
        } while (n = n.parentNode);
      SI();
    }
  },
  _onTouchMove: function(e) {
    if (Ac) {
      var n = this.options, a = n.fallbackTolerance, s = n.fallbackOffset, h = e.touches ? e.touches[0] : e, o = Tr && Af(Tr, !0), m = Tr && o && o.a, g = Tr && o && o.d, b = Gy && go && fE(go), T = (h.clientX - Ac.clientX + s.x) / (m || 1) + (b ? b[0] - p0[0] : 0) / (m || 1), M = (h.clientY - Ac.clientY + s.y) / (g || 1) + (b ? b[1] - p0[1] : 0) / (g || 1);
      if (!sr.active && !hf) {
        if (a && Math.max(Math.abs(h.clientX - this._lastX), Math.abs(h.clientY - this._lastY)) < a)
          return;
        this._onDragStart(e, !0);
      }
      if (Tr) {
        o ? (o.e += T - (h0 || 0), o.f += M - (f0 || 0)) : o = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: T,
          f: M
        };
        var I = "matrix(".concat(o.a, ",").concat(o.b, ",").concat(o.c, ",").concat(o.d, ",").concat(o.e, ",").concat(o.f, ")");
        cr(Tr, "webkitTransform", I), cr(Tr, "mozTransform", I), cr(Tr, "msTransform", I), cr(Tr, "transform", I), h0 = T, f0 = M, Ja = h;
      }
      e.cancelable && e.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!Tr) {
      var e = this.options.fallbackOnBody ? document.body : $n, n = Ri(St, !0, Gy, !0, e), a = this.options;
      if (Gy) {
        for (go = e; cr(go, "position") === "static" && cr(go, "transform") === "none" && go !== document; )
          go = go.parentNode;
        go !== document.body && go !== document.documentElement ? (go === document && (go = Xs()), n.top += go.scrollTop, n.left += go.scrollLeft) : go = Xs(), p0 = fE(go);
      }
      Tr = St.cloneNode(!0), ha(Tr, a.ghostClass, !1), ha(Tr, a.fallbackClass, !0), ha(Tr, a.dragClass, !0), cr(Tr, "transition", ""), cr(Tr, "transform", ""), cr(Tr, "box-sizing", "border-box"), cr(Tr, "margin", 0), cr(Tr, "top", n.top), cr(Tr, "left", n.left), cr(Tr, "width", n.width), cr(Tr, "height", n.height), cr(Tr, "opacity", "0.8"), cr(Tr, "position", Gy ? "absolute" : "fixed"), cr(Tr, "zIndex", "100000"), cr(Tr, "pointerEvents", "none"), sr.ghost = Tr, e.appendChild(Tr), cr(Tr, "transform-origin", pE / parseInt(Tr.style.width) * 100 + "% " + dE / parseInt(Tr.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(e, n) {
    var a = this, s = e.dataTransfer, h = a.options;
    if (Jo("dragStart", this, {
      evt: e
    }), sr.eventCanceled) {
      this._onDrop();
      return;
    }
    Jo("setupClone", this), sr.eventCanceled || (ri = _I(St), ri.removeAttribute("id"), ri.draggable = !1, ri.style["will-change"] = "", this._hideClone(), ha(ri, this.options.chosenClass, !1), sr.clone = ri), a.cloneId = pg(function() {
      Jo("clone", a), !sr.eventCanceled && (a.options.removeCloneOnHide || $n.insertBefore(ri, St), a._hideClone(), Lo({
        sortable: a,
        name: "clone"
      }));
    }), !n && ha(St, h.dragClass, !0), n ? (Jg = !0, a._loopId = setInterval(a._emulateDragOver, 50)) : (Kr(document, "mouseup", a._onDrop), Kr(document, "touchend", a._onDrop), Kr(document, "touchcancel", a._onDrop), s && (s.effectAllowed = "move", h.setData && h.setData.call(a, s, St)), nn(document, "drop", a), cr(St, "transform", "translateZ(0)")), hf = !0, a._dragStartId = pg(a._dragStarted.bind(a, n, e)), nn(document, "selectstart", a), od = !0, vd && cr(document.body, "user-select", "none");
  },
  _onDragOver: function(e) {
    var n = this.el, a = e.target, s, h, o, m = this.options, g = m.group, b = sr.active, T = Uy === g, M = m.sort, I = no || b, P, z = this, V = !1;
    if (h1)
      return;
    function W(Pt, tr) {
      Jo(Pt, z, Qs({
        evt: e,
        isOwner: T,
        axis: P ? "vertical" : "horizontal",
        revert: o,
        dragRect: s,
        targetRect: h,
        canSort: M,
        fromSortable: I,
        target: a,
        completed: K,
        onMove: function(Rr, pr) {
          return qy($n, n, St, s, Rr, Ri(Rr), e, pr);
        },
        changed: se
      }, tr));
    }
    function X() {
      W("dragOverAnimationCapture"), z.captureAnimationState(), z !== I && I.captureAnimationState();
    }
    function K(Pt) {
      return W("dragOverCompleted", {
        insertion: Pt
      }), Pt && (T ? b._hideClone() : b._showClone(z), z !== I && (ha(St, no ? no.options.ghostClass : b.options.ghostClass, !1), ha(St, m.ghostClass, !0)), no !== z && z !== sr.active ? no = z : z === sr.active && no && (no = null), I === z && (z._ignoreWhileAnimating = a), z.animateAll(function() {
        W("dragOverAnimationComplete"), z._ignoreWhileAnimating = null;
      }), z !== I && (I.animateAll(), I._ignoreWhileAnimating = null)), (a === St && !St.animated || a === n && !a.animated) && (lf = null), !m.dragoverBubble && !e.rootEl && a !== document && (St.parentNode[ma]._isOutsideThisEl(e.target), !Pt && Pc(e)), !m.dragoverBubble && e.stopPropagation && e.stopPropagation(), V = !0;
    }
    function se() {
      fa = Aa(St), bu = Aa(St, m.draggable), Lo({
        sortable: z,
        name: "change",
        toEl: n,
        newIndex: fa,
        newDraggableIndex: bu,
        originalEvent: e
      });
    }
    if (e.preventDefault !== void 0 && e.cancelable && e.preventDefault(), a = Fs(a, m.draggable, n, !0), W("dragOver"), sr.eventCanceled)
      return V;
    if (St.contains(e.target) || a.animated && a.animatingX && a.animatingY || z._ignoreWhileAnimating === a)
      return K(!1);
    if (Jg = !1, b && !m.disabled && (T ? M || (o = hi !== $n) : no === this || (this.lastPutMode = Uy.checkPull(this, b, St, e)) && g.checkPut(this, b, St, e))) {
      if (P = this._getDirection(e, a) === "vertical", s = Ri(St), W("dragOverValid"), sr.eventCanceled)
        return V;
      if (o)
        return hi = $n, X(), this._hideClone(), W("revert"), sr.eventCanceled || (Rc ? $n.insertBefore(St, Rc) : $n.appendChild(St)), K(!0);
      var pe = ax(n, m.draggable);
      if (!pe || LU(e, P, this) && !pe.animated) {
        if (pe === St)
          return K(!1);
        if (pe && n === e.target && (a = pe), a && (h = Ri(a)), qy($n, n, St, s, a, h, e, !!a) !== !1)
          return X(), pe && pe.nextSibling ? n.insertBefore(St, pe.nextSibling) : n.appendChild(St), hi = n, se(), K(!0);
      } else if (pe && kU(e, P, this)) {
        var xe = Rf(n, 0, m, !0);
        if (xe === St)
          return K(!1);
        if (a = xe, h = Ri(a), qy($n, n, St, s, a, h, e, !1) !== !1)
          return X(), n.insertBefore(St, xe), hi = n, se(), K(!0);
      } else if (a.parentNode === n) {
        h = Ri(a);
        var Fe = 0, ze, Pe = St.parentNode !== n, Se = !IU(St.animated && St.toRect || s, a.animated && a.toRect || h, P), Ie = P ? "top" : "left", Je = hE(a, "top", "top") || hE(St, "top", "top"), qe = Je ? Je.scrollTop : void 0;
        lf !== a && (ze = h[Ie], wd = !1, jy = !Se && m.invertSwap || Pe), Fe = DU(e, a, h, P, Se ? 1 : m.swapThreshold, m.invertedSwapThreshold == null ? m.swapThreshold : m.invertedSwapThreshold, jy, lf === a);
        var at;
        if (Fe !== 0) {
          var be = Aa(St);
          do
            be -= Fe, at = hi.children[be];
          while (at && (cr(at, "display") === "none" || at === Tr));
        }
        if (Fe === 0 || at === a)
          return K(!1);
        lf = a, bd = Fe;
        var Ke = a.nextElementSibling, ht = !1;
        ht = Fe === 1;
        var vt = qy($n, n, St, s, a, h, e, ht);
        if (vt !== !1)
          return (vt === 1 || vt === -1) && (ht = vt === 1), h1 = !0, setTimeout(PU, 30), X(), ht && !Ke ? n.appendChild(St) : a.parentNode.insertBefore(St, ht ? Ke : a), Je && vI(Je, 0, qe - Je.scrollTop), hi = St.parentNode, ze !== void 0 && !jy && (fg = Math.abs(ze - Ri(a)[Ie])), se(), K(!0);
      }
      if (n.contains(St))
        return K(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    Kr(document, "mousemove", this._onTouchMove), Kr(document, "touchmove", this._onTouchMove), Kr(document, "pointermove", this._onTouchMove), Kr(document, "dragover", Pc), Kr(document, "mousemove", Pc), Kr(document, "touchmove", Pc);
  },
  _offUpEvents: function() {
    var e = this.el.ownerDocument;
    Kr(e, "mouseup", this._onDrop), Kr(e, "touchend", this._onDrop), Kr(e, "pointerup", this._onDrop), Kr(e, "touchcancel", this._onDrop), Kr(document, "selectstart", this);
  },
  _onDrop: function(e) {
    var n = this.el, a = this.options;
    if (fa = Aa(St), bu = Aa(St, a.draggable), Jo("drop", this, {
      evt: e
    }), hi = St && St.parentNode, fa = Aa(St), bu = Aa(St, a.draggable), sr.eventCanceled) {
      this._nulling();
      return;
    }
    hf = !1, jy = !1, wd = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), f1(this.cloneId), f1(this._dragStartId), this.nativeDraggable && (Kr(document, "drop", this), Kr(n, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), vd && cr(document.body, "user-select", ""), cr(St, "transform", ""), e && (od && (e.cancelable && e.preventDefault(), !a.dropBubble && e.stopPropagation()), Tr && Tr.parentNode && Tr.parentNode.removeChild(Tr), ($n === hi || no && no.lastPutMode !== "clone") && ri && ri.parentNode && ri.parentNode.removeChild(ri), St && (this.nativeDraggable && Kr(St, "dragend", this), d0(St), St.style["will-change"] = "", od && !hf && ha(St, no ? no.options.ghostClass : this.options.ghostClass, !1), ha(St, this.options.chosenClass, !1), Lo({
      sortable: this,
      name: "unchoose",
      toEl: hi,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: e
    }), $n !== hi ? (fa >= 0 && (Lo({
      rootEl: hi,
      name: "add",
      toEl: hi,
      fromEl: $n,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "remove",
      toEl: hi,
      originalEvent: e
    }), Lo({
      rootEl: hi,
      name: "sort",
      toEl: hi,
      fromEl: $n,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "sort",
      toEl: hi,
      originalEvent: e
    })), no && no.save()) : fa !== _f && fa >= 0 && (Lo({
      sortable: this,
      name: "update",
      toEl: hi,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "sort",
      toEl: hi,
      originalEvent: e
    })), sr.active && ((fa == null || fa === -1) && (fa = _f, bu = xd), Lo({
      sortable: this,
      name: "end",
      toEl: hi,
      originalEvent: e
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    Jo("nulling", this), $n = St = hi = Tr = Rc = ri = hg = Tu = Ac = Ja = od = fa = bu = _f = xd = lf = bd = no = Uy = sr.dragged = sr.ghost = sr.clone = sr.active = null, ev.forEach(function(e) {
      e.checked = !0;
    }), ev.length = h0 = f0 = 0;
  },
  handleEvent: function(e) {
    switch (e.type) {
      case "drop":
      case "dragend":
        this._onDrop(e);
        break;
      case "dragenter":
      case "dragover":
        St && (this._onDragOver(e), AU(e));
        break;
      case "selectstart":
        e.preventDefault();
        break;
    }
  },
  toArray: function() {
    for (var e = [], n, a = this.el.children, s = 0, h = a.length, o = this.options; s < h; s++)
      n = a[s], Fs(n, o.draggable, this.el, !1) && e.push(n.getAttribute(o.dataIdAttr) || RU(n));
    return e;
  },
  sort: function(e, n) {
    var a = {}, s = this.el;
    this.toArray().forEach(function(h, o) {
      var m = s.children[o];
      Fs(m, this.options.draggable, s, !1) && (a[h] = m);
    }, this), n && this.captureAnimationState(), e.forEach(function(h) {
      a[h] && (s.removeChild(a[h]), s.appendChild(a[h]));
    }), n && this.animateAll();
  },
  save: function() {
    var e = this.options.store;
    e && e.set && e.set(this);
  },
  closest: function(e, n) {
    return Fs(e, n || this.options.draggable, this.el, !1);
  },
  option: function(e, n) {
    var a = this.options;
    if (n === void 0)
      return a[e];
    var s = nm.modifyOption(this, e, n);
    typeof s < "u" ? a[e] = s : a[e] = n, e === "group" && wI(a);
  },
  destroy: function() {
    Jo("destroy", this);
    var e = this.el;
    e[ma] = null, Kr(e, "mousedown", this._onTapStart), Kr(e, "touchstart", this._onTapStart), Kr(e, "pointerdown", this._onTapStart), this.nativeDraggable && (Kr(e, "dragover", this), Kr(e, "dragenter", this)), Array.prototype.forEach.call(e.querySelectorAll("[draggable]"), function(n) {
      n.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), Qg.splice(Qg.indexOf(this.el), 1), this.el = e = null;
  },
  _hideClone: function() {
    if (!Tu) {
      if (Jo("hideClone", this), sr.eventCanceled)
        return;
      cr(ri, "display", "none"), this.options.removeCloneOnHide && ri.parentNode && ri.parentNode.removeChild(ri), Tu = !0;
    }
  },
  _showClone: function(e) {
    if (e.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (Tu) {
      if (Jo("showClone", this), sr.eventCanceled)
        return;
      St.parentNode == $n && !this.options.group.revertClone ? $n.insertBefore(ri, St) : Rc ? $n.insertBefore(ri, Rc) : $n.appendChild(ri), this.options.group.revertClone && this.animate(St, ri), cr(ri, "display", ""), Tu = !1;
    }
  }
};
function AU(t) {
  t.dataTransfer && (t.dataTransfer.dropEffect = "move"), t.cancelable && t.preventDefault();
}
function qy(t, e, n, a, s, h, o, m) {
  var g, b = t[ma], T = b.options.onMove, M;
  return window.CustomEvent && !Wl && !rm ? g = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (g = document.createEvent("Event"), g.initEvent("move", !0, !0)), g.to = e, g.from = t, g.dragged = n, g.draggedRect = a, g.related = s || e, g.relatedRect = h || Ri(e), g.willInsertAfter = m, g.originalEvent = o, t.dispatchEvent(g), T && (M = T.call(b, g, o)), M;
}
function d0(t) {
  t.draggable = !1;
}
function PU() {
  h1 = !1;
}
function kU(t, e, n) {
  var a = Ri(Rf(n.el, 0, n.options, !0)), s = 10;
  return e ? t.clientX < a.left - s || t.clientY < a.top && t.clientX < a.right : t.clientY < a.top - s || t.clientY < a.bottom && t.clientX < a.left;
}
function LU(t, e, n) {
  var a = Ri(ax(n.el, n.options.draggable)), s = 10;
  return e ? t.clientX > a.right + s || t.clientX <= a.right && t.clientY > a.bottom && t.clientX >= a.left : t.clientX > a.right && t.clientY > a.top || t.clientX <= a.right && t.clientY > a.bottom + s;
}
function DU(t, e, n, a, s, h, o, m) {
  var g = a ? t.clientY : t.clientX, b = a ? n.height : n.width, T = a ? n.top : n.left, M = a ? n.bottom : n.right, I = !1;
  if (!o) {
    if (m && fg < b * s) {
      if (!wd && (bd === 1 ? g > T + b * h / 2 : g < M - b * h / 2) && (wd = !0), wd)
        I = !0;
      else if (bd === 1 ? g < T + fg : g > M - fg)
        return -bd;
    } else if (g > T + b * (1 - s) / 2 && g < M - b * (1 - s) / 2)
      return NU(e);
  }
  return I = I || o, I && (g < T + b * h / 2 || g > M - b * h / 2) ? g > T + b / 2 ? 1 : -1 : 0;
}
function NU(t) {
  return Aa(St) < Aa(t) ? 1 : -1;
}
function RU(t) {
  for (var e = t.tagName + t.className + t.src + t.href + t.textContent, n = e.length, a = 0; n--; )
    a += e.charCodeAt(n);
  return a.toString(36);
}
function zU(t) {
  ev.length = 0;
  for (var e = t.getElementsByTagName("input"), n = e.length; n--; ) {
    var a = e[n];
    a.checked && ev.push(a);
  }
}
function pg(t) {
  return setTimeout(t, 0);
}
function f1(t) {
  return clearTimeout(t);
}
Dv && nn(document, "touchmove", function(t) {
  (sr.active || hf) && t.cancelable && t.preventDefault();
});
sr.utils = {
  on: nn,
  off: Kr,
  css: cr,
  find: yI,
  is: function(e, n) {
    return !!Fs(e, n, e, !1);
  },
  extend: _U,
  throttle: gI,
  closest: Fs,
  toggleClass: ha,
  clone: _I,
  index: Aa,
  nextTick: pg,
  cancelNextTick: f1,
  detectDirection: bI,
  getChild: Rf
};
sr.get = function(t) {
  return t[ma];
};
sr.mount = function() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  e[0].constructor === Array && (e = e[0]), e.forEach(function(a) {
    if (!a.prototype || !a.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(a));
    a.utils && (sr.utils = Qs(Qs({}, sr.utils), a.utils)), nm.mount(a);
  });
};
sr.create = function(t, e) {
  return new sr(t, e);
};
sr.version = yU;
var Ii = [], ad, p1, d1 = !1, m0, y0, tv, sd;
function FU() {
  function t() {
    this.defaults = {
      scroll: !0,
      forceAutoScrollFallback: !1,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var e in this)
      e.charAt(0) === "_" && typeof this[e] == "function" && (this[e] = this[e].bind(this));
  }
  return t.prototype = {
    dragStarted: function(n) {
      var a = n.originalEvent;
      this.sortable.nativeDraggable ? nn(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? nn(document, "pointermove", this._handleFallbackAutoScroll) : a.touches ? nn(document, "touchmove", this._handleFallbackAutoScroll) : nn(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(n) {
      var a = n.originalEvent;
      !this.options.dragOverBubble && !a.rootEl && this._handleAutoScroll(a);
    },
    drop: function() {
      this.sortable.nativeDraggable ? Kr(document, "dragover", this._handleAutoScroll) : (Kr(document, "pointermove", this._handleFallbackAutoScroll), Kr(document, "touchmove", this._handleFallbackAutoScroll), Kr(document, "mousemove", this._handleFallbackAutoScroll)), yE(), dg(), xU();
    },
    nulling: function() {
      tv = p1 = ad = d1 = sd = m0 = y0 = null, Ii.length = 0;
    },
    _handleFallbackAutoScroll: function(n) {
      this._handleAutoScroll(n, !0);
    },
    _handleAutoScroll: function(n, a) {
      var s = this, h = (n.touches ? n.touches[0] : n).clientX, o = (n.touches ? n.touches[0] : n).clientY, m = document.elementFromPoint(h, o);
      if (tv = n, a || this.options.forceAutoScrollFallback || rm || Wl || vd) {
        g0(n, this.options, m, a);
        var g = Mu(m, !0);
        d1 && (!sd || h !== m0 || o !== y0) && (sd && yE(), sd = setInterval(function() {
          var b = Mu(document.elementFromPoint(h, o), !0);
          b !== g && (g = b, dg()), g0(n, s.options, b, a);
        }, 10), m0 = h, y0 = o);
      } else {
        if (!this.options.bubbleScroll || Mu(m, !0) === Xs()) {
          dg();
          return;
        }
        g0(n, this.options, Mu(m, !1), !1);
      }
    }
  }, Gl(t, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function dg() {
  Ii.forEach(function(t) {
    clearInterval(t.pid);
  }), Ii = [];
}
function yE() {
  clearInterval(sd);
}
var g0 = gI(function(t, e, n, a) {
  if (!!e.scroll) {
    var s = (t.touches ? t.touches[0] : t).clientX, h = (t.touches ? t.touches[0] : t).clientY, o = e.scrollSensitivity, m = e.scrollSpeed, g = Xs(), b = !1, T;
    p1 !== n && (p1 = n, dg(), ad = e.scroll, T = e.scrollFn, ad === !0 && (ad = Mu(n, !0)));
    var M = 0, I = ad;
    do {
      var P = I, z = Ri(P), V = z.top, W = z.bottom, X = z.left, K = z.right, se = z.width, pe = z.height, xe = void 0, Fe = void 0, ze = P.scrollWidth, Pe = P.scrollHeight, Se = cr(P), Ie = P.scrollLeft, Je = P.scrollTop;
      P === g ? (xe = se < ze && (Se.overflowX === "auto" || Se.overflowX === "scroll" || Se.overflowX === "visible"), Fe = pe < Pe && (Se.overflowY === "auto" || Se.overflowY === "scroll" || Se.overflowY === "visible")) : (xe = se < ze && (Se.overflowX === "auto" || Se.overflowX === "scroll"), Fe = pe < Pe && (Se.overflowY === "auto" || Se.overflowY === "scroll"));
      var qe = xe && (Math.abs(K - s) <= o && Ie + se < ze) - (Math.abs(X - s) <= o && !!Ie), at = Fe && (Math.abs(W - h) <= o && Je + pe < Pe) - (Math.abs(V - h) <= o && !!Je);
      if (!Ii[M])
        for (var be = 0; be <= M; be++)
          Ii[be] || (Ii[be] = {});
      (Ii[M].vx != qe || Ii[M].vy != at || Ii[M].el !== P) && (Ii[M].el = P, Ii[M].vx = qe, Ii[M].vy = at, clearInterval(Ii[M].pid), (qe != 0 || at != 0) && (b = !0, Ii[M].pid = setInterval(function() {
        a && this.layer === 0 && sr.active._onTouchMove(tv);
        var Ke = Ii[this.layer].vy ? Ii[this.layer].vy * m : 0, ht = Ii[this.layer].vx ? Ii[this.layer].vx * m : 0;
        typeof T == "function" && T.call(sr.dragged.parentNode[ma], ht, Ke, t, tv, Ii[this.layer].el) !== "continue" || vI(Ii[this.layer].el, ht, Ke);
      }.bind({
        layer: M
      }), 24))), M++;
    } while (e.bubbleScroll && I !== g && (I = Mu(I, !1)));
    d1 = b;
  }
}, 30), TI = function(e) {
  var n = e.originalEvent, a = e.putSortable, s = e.dragEl, h = e.activeSortable, o = e.dispatchSortableEvent, m = e.hideGhostForTarget, g = e.unhideGhostForTarget;
  if (!!n) {
    var b = a || h;
    m();
    var T = n.changedTouches && n.changedTouches.length ? n.changedTouches[0] : n, M = document.elementFromPoint(T.clientX, T.clientY);
    g(), b && !b.el.contains(M) && (o("spill"), this.onSpill({
      dragEl: s,
      putSortable: a
    }));
  }
};
function sx() {
}
sx.prototype = {
  startIndex: null,
  dragStart: function(e) {
    var n = e.oldDraggableIndex;
    this.startIndex = n;
  },
  onSpill: function(e) {
    var n = e.dragEl, a = e.putSortable;
    this.sortable.captureAnimationState(), a && a.captureAnimationState();
    var s = Rf(this.sortable.el, this.startIndex, this.options);
    s ? this.sortable.el.insertBefore(n, s) : this.sortable.el.appendChild(n), this.sortable.animateAll(), a && a.animateAll();
  },
  drop: TI
};
Gl(sx, {
  pluginName: "revertOnSpill"
});
function lx() {
}
lx.prototype = {
  onSpill: function(e) {
    var n = e.dragEl, a = e.putSortable, s = a || this.sortable;
    s.captureAnimationState(), n.parentNode && n.parentNode.removeChild(n), s.animateAll();
  },
  drop: TI
};
Gl(lx, {
  pluginName: "removeOnSpill"
});
sr.mount(new FU());
sr.mount(lx, sx);
const MI = 0.5, BU = !1, rv = rh(
  "slider",
  () => {
    const t = Ai(), e = Mr(MI), n = Mr(BU), a = lr(
      () => [...t.layers].reverse()[0]
    );
    function s(o) {
      let m = o;
      o < 0.1 ? m = 0.1 : o > 0.9 && (m = 0.9), e.value = m;
    }
    function h(o) {
      n.value = o != null ? o : !n.value;
    }
    return {
      sliderActive: n,
      sliderRatio: e,
      sliderTopLayer: a,
      setRatio: s,
      toggleSlider: h
    };
  },
  {}
);
function ux(t, e) {
  const { t: n } = In();
  function a() {
    return n(t.name, { ns: "client" });
  }
  function s() {
    e == null || e.emit("clickInfo", t);
  }
  return {
    t: n,
    getLabel: a,
    onClickInfo: s
  };
}
const VU = { class: "lux-layer-manager-item mt-2.5" }, UU = ["title"], jU = { class: "flex-1 text-left cursor-default" }, GU = ["aria-label", "title"], qU = /* @__PURE__ */ or({
  __name: "layer-item-background",
  props: {
    showEditButton: { type: Boolean, required: !0 },
    layer: { type: null, required: !0 }
  },
  emits: ["clickEdit", "clickInfo"],
  setup(t, { emit: e }) {
    const n = t, { t: a, onClickInfo: s } = ux(n.layer, { emit: e }), h = lr(
      () => a('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: o()
      })
    );
    function o() {
      return a(n.layer.name, { ns: "client" });
    }
    return (m, g) => (Ve(), it("div", VU, [
      Re("button", {
        class: "fa fa-info w-3",
        title: ae(h),
        onClick: g[0] || (g[0] = (...b) => ae(s) && ae(s)(...b))
      }, null, 8, UU),
      Re("span", jU, Gt(o()), 1),
      t.showEditButton ? (Ve(), it("button", {
        key: 0,
        class: "fa fa-pencil",
        "aria-label": ae(a)("Open editor panel", { ns: "client" }),
        title: ae(a)("Open editor panel", { ns: "client" }),
        onClick: g[1] || (g[1] = (b) => m.$emit("clickEdit"))
      }, null, 8, GU)) : Ye("v-if", !0)
    ]));
  }
}), $U = /* @__PURE__ */ ur(qU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item-background.vue"]]), WU = ["id"], HU = ["aria-checked", "title"], ZU = ["id", "value", "aria-label"], XU = ["aria-checked", "aria-label"], KU = /* @__PURE__ */ or({
  __name: "layer-item-sub",
  props: {
    layer: { type: null, required: !0 },
    isOpen: { type: Boolean, required: !0 },
    isLayerComparatorOpen: { type: Boolean, required: !0 },
    displayLayerComparatorOpen: { type: Boolean, required: !0 }
  },
  emits: ["changeOpacity", "clickToggleLayerComparator"],
  setup(t, { emit: e }) {
    var M, I, P, z;
    const n = t, { t: a, getLabel: s } = ux(n.layer, { emit: e }), h = Fn(
      ((I = (M = n.layer) == null ? void 0 : M.opacity) != null ? I : 1) * 100
    ), o = Fn(
      ((z = (P = n.layer) == null ? void 0 : P.previousOpacity) != null ? z : h.value) * 100
    );
    function m() {
      h.value === 0 ? h.value = o.value : (o.value = h.value, h.value = 0), T();
    }
    function g(V) {
      V.target && (h.value = parseInt(V.target.value), T());
    }
    function b() {
      e("clickToggleLayerComparator", n.layer);
    }
    function T() {
      e("changeOpacity", n.layer, h.value);
    }
    return (V, W) => (Ve(), it("div", {
      class: Pr(["lux-layer-manager-item-content", t.isOpen ? "h-6" : "h-0"]),
      id: `layer-manager-item-content-${t.layer.id}`
    }, [
      Re("button", {
        class: Pr(["w-5 fa-solid", ae(h) === 0 ? "fa-eye-slash" : "fa-eye"]),
        role: "switch",
        "aria-checked": ae(h) === 0,
        title: ae(a)("Toggle layer opacity for {{layerName}}", {
          layerName: ae(a)(t.layer.name)
        }),
        onClick: m
      }, null, 10, HU),
      Re("input", {
        id: `${t.layer.id}-steps-range`,
        type: "range",
        min: "0",
        max: "100",
        value: ae(h),
        step: "25",
        onChange: g,
        class: "m-2.5 w-16 h-[5px] rounded-lg appearance-none cursor-pointer",
        "aria-label": ae(a)("Change opacity for {{ layerName }}", { layerName: ae(s)() })
      }, null, 40, ZU),
      t.displayLayerComparatorOpen ? (Ve(), it("button", {
        key: 0,
        role: "switch",
        class: Pr(["fa ml-auto text-sm cursor-pointer", t.isLayerComparatorOpen ? "fa-adjust" : "fa-circle"]),
        "aria-checked": t.isLayerComparatorOpen,
        "aria-label": ae(a)("Toggle layer comparator for {{ layerName }}", {
          layerName: ae(s)()
        }),
        onClick: b
      }, null, 10, XU)) : Ye("v-if", !0)
    ], 10, WU));
  }
}), YU = /* @__PURE__ */ ur(KU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item-sub.vue"]]), JU = ["min", "max", "value"], QU = /* @__PURE__ */ or({
  __name: "layer-time-datepicker",
  props: {
    minDateAllowed: { type: String, required: !1, default: "" },
    maxDateAllowed: { type: String, required: !1, default: "" },
    dateValue: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, a = lr(() => Q_(n.minDateAllowed)), s = lr(() => Q_(n.maxDateAllowed));
    function h(o) {
      e("change", o.target.value);
    }
    return (o, m) => (Ve(), it("input", {
      class: "lux-time-datepicker",
      type: "date",
      min: ae(a),
      max: ae(s),
      value: t.dateValue ? ae(Q_)(t.dateValue) : "",
      onChange: h
    }, null, 40, JU));
  }
}), m1 = /* @__PURE__ */ ur(QU, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker.vue"]]), ej = { class: "lux-time-slider w-full" }, tj = ["for"], rj = /* @__PURE__ */ or({
  __name: "layer-time-datepicker-value",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t) {
    const e = t, { t: n } = In(), a = Fn(
      e.layer.currentTimeMinValue
    );
    return (s, h) => {
      var o, m;
      return Ve(), it("div", ej, [
        Re("div", null, [
          Re("label", {
            for: `${t.layer.id}-time-slider-start`,
            class: "lux-time-slider-label"
          }, Gt(ae(n)("Date:")), 9, tj),
          Ft(m1, {
            id: `${t.layer.id}-time-slider-start`,
            "date-value": ae(a),
            "min-date-allowed": (o = e.layer.time) == null ? void 0 : o.minValue,
            "max-date-allowed": (m = e.layer.time) == null ? void 0 : m.maxValue,
            onChange: h[0] || (h[0] = (g) => s.$emit("changeTime", g))
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ])
      ]);
    };
  }
}), nj = /* @__PURE__ */ ur(rj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker-value.vue"]]), ij = { class: "lux-time-slider w-full" }, oj = ["for"], aj = ["for"], sj = /* @__PURE__ */ or({
  __name: "layer-time-datepicker-range",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    const n = t, { t: a } = In(), s = Fn(
      n.layer.currentTimeMinValue
    ), h = Fn(
      n.layer.currentTimeMaxValue
    );
    function o(g) {
      e("changeTime", g, n.layer.currentTimeMaxValue);
    }
    function m(g) {
      e("changeTime", n.layer.currentTimeMinValue, g);
    }
    return (g, b) => {
      var T, M, I, P;
      return Ve(), it("div", ij, [
        Ye(" Date START datepicker input "),
        Re("div", null, [
          Re("label", {
            for: `${t.layer.id}-time-slider-start`,
            class: "lux-time-slider-label"
          }, Gt(ae(a)("From:")), 9, oj),
          Ft(m1, {
            id: `${t.layer.id}-time-slider-start`,
            "date-value": ae(s),
            "min-date-allowed": (T = n.layer.time) == null ? void 0 : T.minValue,
            "max-date-allowed": (M = n.layer.time) == null ? void 0 : M.maxValue,
            onChange: o
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ]),
        Ye(" Date END datepicker input "),
        Re("div", null, [
          Re("label", {
            for: `${t.layer.id}-time-slider-end`,
            class: "lux-time-slider-label"
          }, Gt(ae(a)("To:")), 9, aj),
          Ft(m1, {
            id: `${t.layer.id}-time-slider-end`,
            "date-value": ae(h),
            "min-date-allowed": (I = n.layer.time) == null ? void 0 : I.minValue,
            "max-date-allowed": (P = n.layer.time) == null ? void 0 : P.maxValue,
            onChange: m
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ])
      ]);
    };
  }
}), lj = /* @__PURE__ */ ur(sj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker-range.vue"]]), uj = ["onKeydown", "aria-label", "title"], cj = /* @__PURE__ */ or({
  __name: "slider-range-thumb",
  props: {
    ariaLabel: { type: String, required: !1 },
    maxLimit: { type: Number, required: !1, default: 100 },
    minLimit: { type: Number, required: !1, default: 0 },
    selectedValue: { type: Number, required: !0 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, a = Mr(!1), s = Mr(), h = Mr(), o = lr(() => {
      var K;
      return ((K = s.value) == null ? void 0 : K.offsetWidth) || 0;
    }), m = lr(() => {
      var K;
      return ((K = h.value) == null ? void 0 : K.offsetWidth) || 40;
    }), g = Mr(n.selectedValue), b = lr(() => o.value * g.value / 100 - m.value / 2), T = lr(() => ({ left: `${b.value}px` }));
    Uu(() => {
      document.removeEventListener("mousemove", V), document.removeEventListener("mouseup", W);
    });
    function M(K) {
      g.value = Math.max(Math.min(K, 100), 0), e("change", g.value, a.value);
    }
    function I() {
      M(g.value - 1);
    }
    function P() {
      M(g.value + 1);
    }
    function z() {
      a.value = !0, document.addEventListener("mousemove", V), document.addEventListener("mouseup", W);
    }
    function V(K) {
      !a.value || M(X(K));
    }
    function W(K) {
      a.value = !1, M(X(K)), document.removeEventListener("mousemove", V), document.removeEventListener("mouseup", W);
    }
    function X(K) {
      var pe, xe;
      const se = (pe = s.value) != null && pe.offsetWidth ? (K.clientX - m.value * 2) * 100 / ((xe = s.value) == null ? void 0 : xe.offsetWidth) : 0;
      return Math.round(Math.max(Math.min(se, n.maxLimit), n.minLimit));
    }
    return (K, se) => (Ve(), it("div", {
      class: "w-full",
      role: "slider",
      ref_key: "elRefTrack",
      ref: s
    }, [
      Re("button", {
        class: Pr(["lux-slidebar-thumb", a.value ? "dragging" : ""]),
        ref_key: "elRefThumb",
        ref: h,
        style: Vu(ae(T)),
        onKeydown: [
          Us(P, ["space"]),
          Us(P, ["right"]),
          Us(I, ["left"]),
          Us(I, ["delete"])
        ],
        onMousedown: z,
        onMousemove: V,
        onMouseup: W,
        "aria-label": t.ariaLabel,
        title: t.ariaLabel
      }, null, 46, uj)
    ], 512));
  }
}), gE = /* @__PURE__ */ ur(cj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/slider-range/slider-range-thumb.vue"]]), hj = /* @__PURE__ */ Re("div", { class: "lux-slidebar-track-full" }, null, -1), fj = /* @__PURE__ */ or({
  __name: "slider-range-active-track",
  props: {
    selectedMinValue: { type: Number, required: !0 },
    selectedMaxValue: { type: Number, required: !1 }
  },
  setup(t) {
    const e = t, n = Mr(), a = Mr(), s = lr(
      () => n.value ? Math.round(
        n.value.offsetWidth * e.selectedMinValue / 100
      ) : 0
    ), h = lr(() => {
      var g, b;
      let m = 0;
      return e.selectedMaxValue !== void 0 && ((g = n.value) == null ? void 0 : g.offsetWidth) && (m = ((b = n.value) == null ? void 0 : b.offsetWidth) * e.selectedMaxValue / 100 - s.value), Math.round(m);
    }), o = lr(() => ({
      left: `${s.value}px`,
      width: `${h.value}px`
    }));
    return (m, g) => (Ve(), it("div", {
      ref_key: "elRefFullTrack",
      ref: n,
      class: "lux-slidebar-track"
    }, [
      t.selectedMaxValue !== void 0 ? (Ve(), it("div", {
        key: 0,
        ref_key: "elRefSelectionTrack",
        ref: a,
        class: "lux-slidebar-track-selection",
        style: Vu(ae(o))
      }, null, 4)) : Ye("v-if", !0),
      hj
    ], 512));
  }
}), pj = /* @__PURE__ */ ur(fj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/slider-range/slider-range-active-track.vue"]]), dj = { class: "lux-slidebar-fake" }, mj = /* @__PURE__ */ or({
  __name: "slider-range",
  props: {
    selectedMinValue: { type: Number, required: !0 },
    selectedMaxValue: { type: Number, required: !1 },
    ariaLabelMin: { type: String, required: !1 },
    ariaLabelMax: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t;
    function a(h, o) {
      e("change", h, n.selectedMaxValue, o);
    }
    function s(h, o) {
      e("change", n.selectedMinValue, h, o);
    }
    return (h, o) => (Ve(), it("div", dj, [
      Ye(" Draggable Max thumb button "),
      t.selectedMaxValue ? (Ve(), on(gE, {
        key: 0,
        ariaLabel: t.ariaLabelMax,
        minLimit: t.selectedMinValue,
        selectedValue: t.selectedMaxValue,
        onChange: s
      }, null, 8, ["ariaLabel", "minLimit", "selectedValue"])) : Ye("v-if", !0),
      Ye(" Draggable Min thumb button "),
      Ye(" put Min value after Max value, this is just for z-index grabbing "),
      Ft(gE, {
        ariaLabel: t.ariaLabelMin,
        maxLimit: t.selectedMaxValue,
        selectedValue: t.selectedMinValue,
        onChange: a
      }, null, 8, ["ariaLabel", "maxLimit", "selectedValue"]),
      Ye(" Selection highlight "),
      Ft(pj, {
        selectedMinValue: t.selectedMinValue,
        selectedMaxValue: t.selectedMaxValue
      }, null, 8, ["selectedMinValue", "selectedMaxValue"])
    ]));
  }
}), vE = /* @__PURE__ */ ur(mj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/common/slider-range/slider-range.vue"]]), yj = { class: "lux-time-slider w-full" }, gj = {
  key: 0,
  class: "lux-time-slider-value mr-1.5"
}, vj = {
  key: 1,
  class: "lux-time-slider-range mr-1.5"
}, _j = { class: "lux-time-displayed-dates" }, xj = {
  key: 0,
  class: "lux-time-start-date grow"
}, bj = {
  key: 1,
  class: "lux-time-slider-end-date grow text-right"
}, wj = /* @__PURE__ */ or({
  __name: "layer-time-slider",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    const n = t, { t: a } = In(), s = lr(V), h = lr(
      () => {
        var se, pe;
        return (se = n.layer.time) != null && se.minValue ? new Date((pe = n.layer.time) == null ? void 0 : pe.minValue).getTime() : 0;
      }
    ), o = lr(
      () => {
        var se, pe;
        return (se = n.layer.time) != null && se.maxValue ? new Date((pe = n.layer.time) == null ? void 0 : pe.maxValue).getTime() : 0;
      }
    ), m = lr(() => o.value - h.value), g = Mr(n.layer.currentTimeMaxValue), b = Mr(n.layer.currentTimeMinValue), T = lr(
      () => b.value ? new Date(b.value).getTime() : void 0
    ), M = lr(
      () => g.value ? new Date(g.value).getTime() : void 0
    ), I = lr(
      () => z(T.value)
    ), P = lr(
      () => z(M.value)
    );
    function z(se) {
      return se ? (se - h.value) / m.value * 100 : 0;
    }
    function V() {
      var Ie, Je;
      const se = n.layer.time, pe = [];
      if (!se)
        return;
      if (se.values)
        return se.values.map((qe) => new Date(qe).getTime());
      const xe = new Date(se.minValue), Fe = new Date((Ie = se.maxValue) != null ? Ie : Date.now()), ze = 1024, Pe = new Date(xe.getTime()), Se = (Je = se.interval) != null ? Je : jM;
      if (Pe.setFullYear(
        xe.getFullYear() + ze * Se[0]
      ), Pe.setMonth(
        xe.getMonth() + ze * Se[1],
        xe.getDate() + ze * Se[2]
      ), Pe.setSeconds(xe.getSeconds() + ze * Se[3]), Pe > Fe)
        for (let qe = 0; ; qe++) {
          const at = new Date(xe.getTime());
          if (at.setFullYear(xe.getFullYear() + qe * Se[0]), at.setMonth(
            xe.getMonth() + qe * Se[1],
            xe.getDate() + qe * Se[2]
          ), at.setSeconds(xe.getSeconds() + qe * Se[3]), at <= Fe)
            pe.push(at.getTime());
          else
            break;
        }
      return pe;
    }
    function W(se) {
      var Fe;
      const pe = se / 100 * (o.value - h.value) + h.value, xe = _6(pe, {
        minValue: h.value,
        maxValue: o.value,
        timeValueList: s.value,
        timeInterval: (Fe = n.layer.time) == null ? void 0 : Fe.interval
      });
      return a1(xe);
    }
    function X(se, pe) {
      const xe = W(se);
      if (b.value = xe, pe) {
        const Fe = W(pe);
        g.value = Fe;
      }
    }
    function K(se, pe, xe) {
      X(se, pe), xe || e("changeTime", b.value, g.value);
    }
    return (se, pe) => {
      var xe, Fe, ze, Pe, Se, Ie, Je;
      return Ve(), it("div", yj, [
        Ye(" Slider LayerTimeMode.VALUE "),
        ((xe = t.layer.time) == null ? void 0 : xe.mode) === ae(Dl).VALUE ? (Ve(), it("div", gj, [
          Ft(vE, {
            ariaLabelMin: `${ae(a)("Modifier la date de d\xE9but", { ns: "client" })}`,
            selectedMinValue: ae(I),
            onChange: K
          }, null, 8, ["ariaLabelMin", "selectedMinValue"])
        ])) : Ye("v-if", !0),
        Ye(" Slider LayerTimeMode.RANGE "),
        ((Fe = t.layer.time) == null ? void 0 : Fe.mode) === ae(Dl).RANGE ? (Ve(), it("div", vj, [
          Ft(vE, {
            ariaLabelMin: `${ae(a)("Modifier la date de d\xE9but", { ns: "client" })}`,
            ariaLabelMax: `${ae(a)("Modifier la date de fin", { ns: "client" })}`,
            selectedMinValue: ae(I),
            selectedMaxValue: ae(P),
            onChange: K
          }, null, 8, ["ariaLabelMin", "ariaLabelMax", "selectedMinValue", "selectedMaxValue"])
        ])) : Ye("v-if", !0),
        Ye(" Display localized time values "),
        Re("div", _j, [
          Ye(" Display localized time values Min value "),
          ((ze = t.layer.time) == null ? void 0 : ze.mode) === ae(Dl).RANGE || ((Pe = t.layer.time) == null ? void 0 : Pe.mode) === ae(Dl).VALUE ? (Ve(), it("div", xj, [
            Re("span", null, Gt(b.value ? ae(D2)(b.value, (Se = t.layer.time) == null ? void 0 : Se.resolution) : "-"), 1)
          ])) : Ye("v-if", !0),
          Ye(" Display localized time values Max value "),
          ((Ie = t.layer.time) == null ? void 0 : Ie.mode) === ae(Dl).RANGE ? (Ve(), it("div", bj, [
            Re("span", null, Gt(g.value ? ae(D2)(g.value, (Je = t.layer.time) == null ? void 0 : Je.resolution) : "-"), 1)
          ])) : Ye("v-if", !0)
        ])
      ]);
    };
  }
}), Ej = /* @__PURE__ */ ur(wj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-slider.vue"]]), Sj = /* @__PURE__ */ or({
  __name: "layer-time",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    function n(a, s) {
      e("changeTime", a, s);
    }
    return (a, s) => {
      var h, o, m, g, b;
      return Ve(), it(cn, null, [
        Ye(" Layer time: slider widget "),
        ((h = t.layer.time) == null ? void 0 : h.widget) === ae(ug).SLIDER ? (Ve(), on(Ej, {
          key: 0,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : Ye("v-if", !0),
        Ye(" Layer time: datepicker VALUE (one date) widget "),
        ((o = t.layer.time) == null ? void 0 : o.widget) === ae(ug).DATEPICKER && ((m = t.layer.time) == null ? void 0 : m.mode) === ae(Dl).VALUE ? (Ve(), on(nj, {
          key: 1,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : Ye("v-if", !0),
        Ye(' Layer time: datepicker RANGE ("from:" date - "to:" date) widget '),
        ((g = t.layer.time) == null ? void 0 : g.widget) === ae(ug).DATEPICKER && ((b = t.layer.time) == null ? void 0 : b.mode) === ae(Dl).RANGE ? (Ve(), on(lj, {
          key: 2,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : Ye("v-if", !0)
      ], 64);
    };
  }
}), Tj = /* @__PURE__ */ ur(Sj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time.vue"]]), Mj = { class: "lux-layer-manager-item relative" }, Ij = { class: "w-full flex flex-nowrap items-start gap-x-2" }, Oj = ["title"], Cj = ["aria-label", "title"], Aj = ["aria-expanded", "aria-controls", "data-cy"], Pj = { class: "grow" }, kj = ["title", "aria-label"], Lj = /* @__PURE__ */ or({
  __name: "layer-item",
  props: {
    is3d: { type: Boolean, required: !0 },
    layer: { type: null, required: !0 },
    draggableClassName: { type: String, required: !0 },
    isOpen: { type: Boolean, required: !0 },
    isLayerComparatorOpen: { type: Boolean, required: !0 },
    displayLayerComparatorOpen: { type: Boolean, required: !0 }
  },
  emits: ["clickInfo", "clickToggle", "clickToggleLayerComparator", "clickRemove", "changeOpacity", "changeTime"],
  setup(t, { emit: e }) {
    const n = t, { t: a, getLabel: s, onClickInfo: h } = ux(n.layer, { emit: e }), o = lr(
      () => a('Sort "{{layerName}}" in the list', {
        ns: "client",
        layerName: s()
      })
    ), m = lr(
      () => a('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: s()
      })
    ), g = lr(
      () => a('Remove layer "{{layerName}}"', {
        ns: "client",
        layerName: s()
      })
    );
    function b(T, M) {
      e("changeTime", T, M);
    }
    return (T, M) => (Ve(), it("div", Mj, [
      Re("div", Ij, [
        Re("button", {
          class: Pr(["fa-solid fa-bars cursor-move mt-1", t.draggableClassName]),
          title: ae(o)
        }, null, 10, Oj),
        Re("button", {
          class: "fa-solid fa-info mt-1",
          "aria-label": ae(m),
          title: ae(m),
          onClick: M[0] || (M[0] = (...I) => ae(h) && ae(h)(...I))
        }, null, 8, Cj),
        Re("button", {
          "aria-expanded": t.isOpen,
          "aria-controls": `layer-manager-item-content-${t.layer.id}`,
          "data-cy": `myLayerItemLabel-${t.layer.id}`,
          class: Pr([t.is3d ? "cursor-default" : "", "grow text-left break-words w-[70%] flex items-center"]),
          onClick: M[1] || (M[1] = (I) => T.$emit("clickToggle", t.layer))
        }, [
          Re("span", Pj, Gt(ae(s)()), 1),
          t.is3d ? Ye("v-if", !0) : (Ve(), it("span", {
            key: 0,
            class: Pr(["w-3.5 fa-solid", t.isOpen ? "fa-xmark" : "fa-ellipsis"]),
            "aria-hidden": "true"
          }, null, 2))
        ], 10, Aj),
        Re("button", {
          class: "mt-1 fa-solid fa-trash",
          title: ae(g),
          "aria-label": ae(g),
          onClick: M[2] || (M[2] = (I) => T.$emit("clickRemove", t.layer))
        }, null, 8, kj)
      ]),
      Ye(" Layer item sub content (opacity and toggle comparator) "),
      t.is3d ? Ye("v-if", !0) : (Ve(), on(YU, {
        key: 0,
        layer: t.layer,
        isOpen: t.isOpen,
        isLayerComparatorOpen: t.isLayerComparatorOpen,
        displayLayerComparatorOpen: t.displayLayerComparatorOpen,
        onClickToggleLayerComparator: M[3] || (M[3] = (I) => T.$emit("clickToggleLayerComparator", I)),
        onChangeOpacity: M[4] || (M[4] = (I, P) => T.$emit("changeOpacity", I, P))
      }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen"])),
      Ye(" Layer time: slider OR datepicker widgets "),
      t.layer.time ? (Ve(), on(Tj, {
        key: 1,
        layer: t.layer,
        onChangeTime: b
      }, null, 8, ["layer"])) : Ye("v-if", !0)
    ]));
  }
}), _E = /* @__PURE__ */ ur(Lj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item.vue"]]), Dj = {
  key: 0,
  class: "mb-4 sortable-layers-3d"
}, Nj = ["id"], Rj = { class: "sortable-layers" }, zj = ["id"], Fj = { class: "flex flex-row justify-center space-x-1 my-2" }, Bj = /* @__PURE__ */ or({
  __name: "layer-manager",
  emits: ["displayCatalog"],
  setup(t, { emit: e }) {
    const { t: n } = In(), { setMetadataId: a } = Q1(), s = Ai(), h = Pi(), o = Ff(), m = rv(), { bgLayer: g } = xn(s), { sliderActive: b } = xn(m), T = lr(() => [...s.layers].reverse()), M = lr(() => [...s.layers3d].reverse()), I = Fn(), P = "drag-handle", z = lr(
      () => o.isLayerStyleEditable(g.value)
    ), { setRemoteLayersOpen: V } = Pi();
    va(() => {
      const Pe = {
        dataIdAttr: "data-id",
        dragClass: "lux-sortable-drag",
        ghostClass: "lux-sortable-ghost",
        sort: !0,
        handle: `.${P}`
      }, Se = document.querySelector(".sortable-layers"), Ie = document.querySelector(".sortable-layers-3d");
      Se && sr.create(Se, {
        ...Pe,
        onSort: W
      }), Ie && sr.create(Ie, {
        ...Pe,
        onSort: X
      });
    });
    function W(Pe, Se) {
      const Ie = [...Pe.to.children].map((Je) => Number(Je.id)).reverse();
      s.reorderLayers(Ie, Se);
    }
    function X(Pe) {
      W(Pe, !0);
    }
    function K(Pe, Se) {
      s.setLayerOpacity(Pe.id, Se / 100);
    }
    function se(Pe, Se, Ie) {
      s.setLayerTime(Pe.id, Se, Ie);
    }
    function pe(Pe) {
      s.removeLayers(Pe.id);
    }
    function xe(Pe) {
      I.value = I.value !== Pe.id ? Pe.id : void 0;
    }
    function Fe() {
      h.openStyleEditorPanel();
    }
    function ze() {
      m.toggleSlider();
    }
    return (Pe, Se) => (Ve(), it("div", null, [
      ae(M).length > 0 ? (Ve(), it("ul", Dj, [
        (Ve(!0), it(cn, null, Ra(ae(M), (Ie, Je) => (Ve(), it("li", {
          key: Ie.id,
          id: Ie.id
        }, [
          Ft(_E, {
            is3d: !0,
            draggableClassName: P,
            layer: Ie,
            isOpen: ae(I) === Ie.id,
            isLayerComparatorOpen: ae(b),
            displayLayerComparatorOpen: Je === 0,
            onClickRemove: pe,
            onClickToggle: xe,
            onClickToggleLayerComparator: ze,
            onClickInfo: (qe) => ae(a)(Ie.id),
            onChangeOpacity: K,
            onChangeTime: (qe, at) => se(Ie, qe, at)
          }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen", "onClickInfo", "onChangeTime"])
        ], 8, Nj))), 128))
      ])) : Ye("v-if", !0),
      Re("ul", Rj, [
        (Ve(!0), it(cn, null, Ra(ae(T), (Ie, Je) => (Ve(), it("li", {
          key: Ie.id,
          id: Ie.id
        }, [
          Ft(_E, {
            is3d: !1,
            draggableClassName: P,
            layer: Ie,
            isOpen: ae(I) === Ie.id,
            isLayerComparatorOpen: ae(b),
            displayLayerComparatorOpen: Je === 0,
            onClickRemove: pe,
            onClickToggle: xe,
            onClickToggleLayerComparator: ze,
            onClickInfo: (qe) => ae(a)(Ie.id),
            onChangeOpacity: K,
            onChangeTime: (qe, at) => se(Ie, qe, at)
          }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen", "onClickInfo", "onChangeTime"])
        ], 8, zj))), 128))
      ]),
      Ft($U, {
        layer: ae(g) || ae(Zg),
        showEditButton: ae(z),
        onClickInfo: Se[0] || (Se[0] = () => ae(g) && ae(a)(ae(g).id)),
        onClickEdit: Fe
      }, null, 8, ["layer", "showEditButton"]),
      Re("div", Fj, [
        Re("button", {
          class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
          onClick: Se[1] || (Se[1] = (Ie) => e("displayCatalog"))
        }, Gt(ae(n)("+ Add layers", { ns: "client" })), 1),
        Re("button", {
          class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
          onClick: Se[2] || (Se[2] = (Ie) => ae(V)(!0))
        }, Gt(ae(n)("+ Add external Wms", { ns: "client" })), 1)
      ])
    ]));
  }
}), Vj = /* @__PURE__ */ ur(Bj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-manager/layer-manager.vue"]]), Uj = { class: "flex flex-col h-full pt-1.5" }, jj = { class: "h-16 shrink-0 flex justify-between lux-panel-title" }, Gj = ["aria-label"], qj = { class: "flex flex-row gap-2 h-10 text-2xl" }, $j = ["aria-expanded"], Wj = { key: 0 }, Hj = ["aria-expanded"], Zj = { class: "relative grow p-2.5 bg-primary overflow-auto" }, Xj = /* @__PURE__ */ or({
  __name: "layer-panel",
  setup(t) {
    const { t: e } = In(), n = Pi(), { setLayersOpen: a } = n, { myLayersTabOpen: s } = xn(n), { layers: h } = xn(Ai());
    function o() {
      n.setMyLayersTabOpen(!0);
    }
    function m() {
      n.setMyLayersTabOpen(!1);
    }
    return (g, b) => (Ve(), it("div", Uj, [
      Ye(" Panel title and close button "),
      Re("div", jj, [
        Re("h1", null, Gt(ae(e)("layers", { ns: "client" })), 1),
        Re("span", null, [
          Re("button", {
            onClick: b[0] || (b[0] = () => ae(a)(!1)),
            "aria-label": ae(e)("Close", { ns: "client" }),
            class: "fa-sharp fa-solid fa-close"
          }, null, 8, Gj)
        ])
      ]),
      Ye(" My Layers and Catalog tab labels "),
      Re("div", qj, [
        Re("button", {
          onClick: o,
          class: Pr(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", ae(s) ? "bg-primary" : "bg-tertiary"]),
          "aria-expanded": ae(s)
        }, [
          Mg(Gt(ae(e)("my_layers", { ns: "client" })) + " ", 1),
          ae(h).length ? (Ve(), it("span", Wj, "(" + Gt(ae(h).length) + ")", 1)) : Ye("v-if", !0)
        ], 10, $j),
        Re("button", {
          onClick: m,
          class: Pr(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", ae(s) ? "bg-tertiary" : "bg-primary"]),
          "aria-expanded": !ae(s)
        }, Gt(ae(e)("Catalog", { ns: "client" })), 11, Hj)
      ]),
      Ye(" Panel content (MyLayers and Catalog) "),
      Re("div", Zj, [
        ae(s) ? (Ve(), on(Vj, {
          key: 0,
          onDisplayCatalog: m
        })) : Ye("v-if", !0),
        ae(s) ? Ye("v-if", !0) : (Ve(), on(fU, { key: 1 }))
      ])
    ]));
  }
}), Kj = /* @__PURE__ */ ur(Xj, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/layer-panel/layer-panel.vue"]]);
class Yj {
  bootstrap() {
    let e;
    e = Na(() => {
      this.restore(), this.persist(), e && e();
    });
  }
  persist() {
    const e = rv();
    Bn(
      [() => e.sliderActive, () => e.sliderRatio],
      ([n, a], [s]) => {
        n !== s && Cr.setValue(J0, n), Cr.setValue(
          Q0,
          a
        );
      }
    );
  }
  restore() {
    const e = Cr.getValue(J0, $1), n = Cr.getValue(Q0, Mf), { toggleSlider: a, setRatio: s } = rv();
    typeof e < "u" && e !== null && (a(e), typeof n !== void 0 && n !== null && s(n != null ? n : MI));
  }
}
const Jj = new Yj(), Qj = ["onKeydown"], e9 = /* @__PURE__ */ Re("span", { class: "lux-slider-line" }, null, -1), t9 = /* @__PURE__ */ Re("span", { class: "lux-slider-arrows" }, [
  /* @__PURE__ */ Re("span"),
  /* @__PURE__ */ Re("span")
], -1), r9 = {
  key: 0,
  class: "lux-slider-layer-label"
}, n9 = /* @__PURE__ */ Re("i", { class: "fa fa-arrow-left mr-2" }, null, -1), i9 = /* @__PURE__ */ or({
  __name: "splitter-element",
  props: {
    sliderActive: { type: Boolean, required: !0 },
    sliderRatio: { type: Number, required: !0 },
    sliderTopLayer: { type: null, required: !0 },
    sliderOffset: { type: Number, required: !0 },
    containerOffset: { type: Number, required: !0 }
  },
  emits: ["moveSplitBar", "escSplitBar"],
  setup(t, { expose: e, emit: n }) {
    const a = t, s = 30, { t: h } = In(), o = Mr(null), m = lr(() => ({ left: `${a.sliderOffset}px` }));
    let g = !1;
    e({
      sliderElement: o
    });
    function b(W) {
      n("moveSplitBar", W + o.value.offsetWidth / 2);
    }
    function T() {
      g = !0, document.addEventListener("mousemove", M), document.addEventListener("mouseup", I);
    }
    function M(W) {
      !g || b(W.clientX - a.containerOffset);
    }
    function I() {
      g = !1, document.removeEventListener("mousemove", M), document.removeEventListener("mouseup", I);
    }
    function P() {
      b(o.value.offsetLeft + s);
    }
    function z() {
      b(o.value.offsetLeft - s);
    }
    function V() {
      n("escSplitBar");
    }
    return va(() => {
      var W;
      (W = o.value) == null || W.focus({ focusVisible: !0 });
    }), Uu(() => {
      document.removeEventListener("mousemove", M), document.removeEventListener("mouseup", I);
    }), (W, X) => (Ve(), it("button", {
      ref_key: "sliderElement",
      ref: o,
      onMousedown: T,
      onMousemove: M,
      onMouseup: I,
      onKeydown: [
        Us(P, ["space"]),
        Us(P, ["right"]),
        Us(z, ["left"]),
        Us(z, ["delete"]),
        Us(V, ["esc"])
      ],
      class: "left-[20px] absolute h-full w-[32px] block",
      style: Vu(ae(m)),
      role: "seperator",
      "aria-controls": "map-container"
    }, [
      e9,
      t9,
      t.sliderTopLayer ? (Ve(), it("span", r9, [
        n9,
        Re("span", null, Gt(ae(h)(t.sliderTopLayer.name)), 1)
      ])) : Ye("v-if", !0)
    ], 44, Qj));
  }
}), o9 = /* @__PURE__ */ ur(i9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/slider/splitter-element.vue"]]), a9 = /* @__PURE__ */ or({
  __name: "slider-comparator",
  setup(t) {
    const e = rv(), n = YM(), a = zl().olMap, s = Mr(null), { sliderActive: h, sliderRatio: o, sliderTopLayer: m } = xn(e), g = lr(
      () => {
        var X, K;
        return ((K = (X = s.value) == null ? void 0 : X.sliderElement) == null ? void 0 : K.offsetWidth) || 0;
      }
    ), b = lr(
      () => {
        var X, K;
        return a.value && s.value ? o.value * a.value.getSize()[0] - ((K = (X = s.value) == null ? void 0 : X.sliderElement) == null ? void 0 : K.offsetWidth) / 2 + a.value.getViewport().offsetLeft : 0;
      }
    );
    let T, M, I;
    Jj.bootstrap(), Bn([m, h], ([X, K], [se]) => {
      var pe;
      X && K ? (X !== se && z(), P()) : z(), (pe = a.value) == null || pe.render();
    }), Bn(b, () => {
      var X;
      (X = a.value) == null || X.render();
    });
    function P() {
      const X = n.getLayerFromCache(m.value);
      !X || (T = X.on(
        Lb.PRERENDER,
        function(K) {
          var Ie;
          const se = K.context, pe = (Ie = a.value) == null ? void 0 : Ie.getSize(), xe = b.value + g.value / 2, Fe = dy(K, [0, 0]), ze = dy(K, [xe, 0]), Pe = dy(K, [0, pe[1]]), Se = dy(K, [xe, pe[0]]);
          se.save(), se.beginPath(), se.moveTo(Fe[0], Fe[1]), se.lineTo(Pe[0], Pe[1]), se.lineTo(Se[0], Se[1]), se.lineTo(ze[0], ze[1]), se.closePath(), se.clip();
        }
      ), M = X.on(
        Lb.POSTRENDER,
        function(K) {
          K.context.restore();
        }
      ));
    }
    function z() {
      DC([T, M]);
    }
    function V(X) {
      var pe;
      const K = (pe = a.value) == null ? void 0 : pe.getSize(), se = X / K[0];
      e.setRatio(se);
    }
    function W() {
      e.toggleSlider();
    }
    return va(() => {
      var X, K;
      I = (K = (X = a.value) == null ? void 0 : X.getTargetElement()) == null ? void 0 : K.closest(".map-wrapper");
    }), Uu(() => {
      z();
    }), (X, K) => {
      var se;
      return ae(m) && ae(h) ? (Ve(), on(o9, {
        key: 0,
        ref_key: "splitterElement",
        ref: s,
        sliderActive: ae(h),
        sliderRatio: ae(o),
        sliderTopLayer: ae(m),
        sliderOffset: ae(b),
        containerOffset: ((se = ae(I)) == null ? void 0 : se.offsetLeft) || 0,
        onMoveSplitBar: V,
        onEscSplitBar: W
      }, null, 8, ["sliderActive", "sliderRatio", "sliderTopLayer", "sliderOffset", "containerOffset"])) : Ye("v-if", !0);
    };
  }
}), s9 = /* @__PURE__ */ ur(a9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/slider/slider-comparator.vue"]]), $y = "-", v0 = ",", xE = "--";
class l9 {
  constructor() {
    bi(this, "layersOpacitiesToNumbersV2", (e) => this.layersOpacitiesToNumbers(e, v0));
  }
  layerTimesToStrings(e) {
    return e ? e.split(xE) : [];
  }
  layerIdsToLayers(e) {
    const n = Hc(), a = ku();
    return (e ? e.split($y) : []).map((h) => {
      const o = Zc.isRemoteLayer(h) ? x8(h) : n.findById(parseInt(h, 10));
      return o ? a.initLayer(o) : void 0;
    });
  }
  layerNamesToLayersV2(e) {
    const n = Hc(), a = ku();
    return (e ? e.split(v0) : []).map((h) => {
      const o = n.findByName(h);
      return o ? a.initLayer(o) : void 0;
    });
  }
  layersOpacitiesToNumbers(e, n = $y) {
    return Q4(e, n);
  }
  layersVisibilitiesToBooleansV2(e) {
    return e5(e, v0);
  }
  layersToLayerIds(e) {
    return (e == null ? void 0 : e.map((n) => n.id).join($y)) || "";
  }
  layersToLayerOpacities(e) {
    return (e == null ? void 0 : e.map((n) => {
      var a;
      return (a = n.opacity) != null ? a : 1;
    }).join($y)) || "";
  }
  layersToLayerTimes(e) {
    return (e == null ? void 0 : e.map((n) => {
      var a;
      return (a = ku().getLayerCurrentTime(n)) != null ? a : "";
    }).join(xE)) || "";
  }
  bgLayerNameToBgLayer(e) {
    const n = Hc();
    return e ? n.findBgLayerByName(e) : null;
  }
  bgLayerToBgLayerName(e) {
    return (e == null ? void 0 : e.name) || Zg.name;
  }
}
const da = new l9(), u9 = "basemap_2015_global", c9 = "orthogr_2013_global", h9 = {
  webbasemap: "basemap_2015_global",
  "pixelmaps-color": "topogr_global",
  "pixelmaps-gray": "topo_bw_jpeg",
  streets: "streets_jpeg",
  voidlayer: "blank"
};
class f9 {
  bootstrap() {
    const e = Ro();
    let n;
    n = Na(() => {
      e.bgLayers.length > 0 && (this.restore(), this.persist(), n && n());
    });
  }
  persist() {
    const e = Ai(), { bgLayer: n } = xn(e);
    Bn(
      n,
      (a, s) => {
        s !== a && Cr.setValue(
          Qw,
          a,
          da.bgLayerToBgLayerName
        );
      },
      { immediate: !0 }
    );
  }
  restore() {
    const { setMapBackground: e } = JM(), n = this.getBgLayerFromStorage();
    e(n);
  }
  getBgLayerFromStorage() {
    const e = Cr.getInitialVersion(), n = Cr.getValue(Qw);
    return n ? e === 2 ? this.getBgLayerFromStorageV2(n) : da.bgLayerNameToBgLayer(n) : da.bgLayerNameToBgLayer(u9);
  }
  getBgLayerFromStorageV2(e) {
    const n = Cr.getValue(
      BT,
      Mf
    );
    let a = "";
    return e ? a = h9[e] : n === 0 && (a = c9), da.bgLayerNameToBgLayer(a);
  }
}
const p9 = new f9();
class d9 {
  bootstrap() {
    const e = Ro();
    let n;
    n = Na(() => {
      e.themes && (this.restore(), this.persist(), n && n());
    });
  }
  persist() {
    const e = Ai(), { layers: n } = xn(e);
    Bn(
      n,
      (a, s) => {
        s !== a && (Cr.setValue(
          Jw,
          a,
          da.layersToLayerIds
        ), Cr.setValue(
          e2,
          a,
          da.layersToLayerOpacities
        ), Cr.setValue(
          t2,
          a,
          da.layersToLayerTimes
        ));
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Cr.getInitialVersion(), n = Ai(), a = Cr.getValue(
      Jw,
      e === 2 ? da.layerNamesToLayersV2 : da.layerIdsToLayers
    );
    this.restoreLayersOpacities(a, e), this.restoreLayersTimes(a), e === 2 && (Cr.removeItem(BT), Cr.removeItem(n5), Cr.removeItem(o2), Cr.removeItem(a2)), n.addLayers(...(a == null ? void 0 : a.filter((s) => s)) || []);
  }
  restoreLayersOpacities(e, n) {
    const a = n === 2 ? this.getOpacitiesFromStorageV2() : this.getOpacitiesFromStorage();
    a.length && (e == null || e.forEach(
      (s, h) => {
        var o;
        return s && (s.opacity = (o = a[h]) != null ? o : 1);
      }
    ));
  }
  restoreLayersTimes(e) {
    const n = Cr.getValue(
      t2,
      da.layerTimesToStrings
    );
    n.length && (e == null || e.forEach(
      (a, s) => a && n[s] && this.restoreLayerTime(a, n[s])
    ));
  }
  restoreLayerTime(e, n) {
    const a = n.split("/");
    e.currentTimeMinValue = a[0], e.currentTimeMaxValue = a[1];
  }
  getOpacitiesFromStorage() {
    return Cr.getValue(
      e2,
      da.layersOpacitiesToNumbers
    );
  }
  getOpacitiesFromStorageV2() {
    const e = Cr.getValue(
      o2,
      da.layersOpacitiesToNumbersV2
    ), n = Cr.getValue(
      a2,
      da.layersVisibilitiesToBooleansV2
    );
    return e.map((a, s) => n[s] ? a : 0);
  }
}
const m9 = new d9();
class y9 {
  themeToThemeName(e) {
    return (e == null ? void 0 : e.name) || "";
  }
}
const g9 = new y9();
class v9 {
  bootstrap() {
    this.restore();
    let e;
    e = Na(() => {
      this.persist(), e && e();
    });
  }
  persist() {
    const e = Ro();
    Bn(
      () => e.theme,
      (n, a) => {
        a !== n && n && Cr.setValue(
          Nd,
          n,
          g9.themeToThemeName
        );
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Cr.getValue(Nd);
    if (e) {
      const { setTheme: n } = Ro();
      n(e);
    }
  }
}
const _9 = new v9();
class x9 {
  bootstrapLayersOpen() {
    this.restoreLayersOpen();
    let e;
    e = Na(() => {
      this.persistLayersOpen(), e && e();
    });
  }
  persistLayersOpen() {
    const e = Pi(), { layersOpen: n } = xn(e);
    Bn(
      n,
      (a, s) => {
        s !== a && Cr.setValue(Rg, a);
      },
      { immediate: !0 }
    );
  }
  restoreLayersOpen() {
    const e = Cr.getValue(Rg) !== "false", { setLayersOpen: n } = Pi();
    n(e);
  }
}
const b9 = new x9();
class w9 {
  bootstrap() {
    this.restore();
    let e;
    e = Na(() => {
      this.persist(), e && e();
    });
  }
  persist() {
  }
  restore() {
    const e = Cr.getValue(t5);
    Pi().setMapId(e);
  }
}
const E9 = new w9();
function y1(t) {
  return y1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, y1(t);
}
var II = [], S9 = II.forEach, T9 = II.slice;
function g1(t) {
  return S9.call(T9.call(arguments, 1), function(e) {
    if (e)
      for (var n in e)
        t[n] === void 0 && (t[n] = e[n]);
  }), t;
}
function OI() {
  return typeof XMLHttpRequest == "function" || (typeof XMLHttpRequest > "u" ? "undefined" : y1(XMLHttpRequest)) === "object";
}
function M9(t) {
  return !!t && typeof t.then == "function";
}
function I9(t) {
  return M9(t) ? t : Promise.resolve(t);
}
function O9(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var nv = { exports: {} }, Wy = { exports: {} }, bE;
function C9() {
  return bE || (bE = 1, function(t, e) {
    var n = typeof self < "u" ? self : js, a = function() {
      function h() {
        this.fetch = !1, this.DOMException = n.DOMException;
      }
      return h.prototype = n, new h();
    }();
    (function(h) {
      (function(o) {
        var m = {
          searchParams: "URLSearchParams" in h,
          iterable: "Symbol" in h && "iterator" in Symbol,
          blob: "FileReader" in h && "Blob" in h && function() {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          }(),
          formData: "FormData" in h,
          arrayBuffer: "ArrayBuffer" in h
        };
        function g(be) {
          return be && DataView.prototype.isPrototypeOf(be);
        }
        if (m.arrayBuffer)
          var b = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ], T = ArrayBuffer.isView || function(be) {
            return be && b.indexOf(Object.prototype.toString.call(be)) > -1;
          };
        function M(be) {
          if (typeof be != "string" && (be = String(be)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(be))
            throw new TypeError("Invalid character in header field name");
          return be.toLowerCase();
        }
        function I(be) {
          return typeof be != "string" && (be = String(be)), be;
        }
        function P(be) {
          var Ke = {
            next: function() {
              var ht = be.shift();
              return { done: ht === void 0, value: ht };
            }
          };
          return m.iterable && (Ke[Symbol.iterator] = function() {
            return Ke;
          }), Ke;
        }
        function z(be) {
          this.map = {}, be instanceof z ? be.forEach(function(Ke, ht) {
            this.append(ht, Ke);
          }, this) : Array.isArray(be) ? be.forEach(function(Ke) {
            this.append(Ke[0], Ke[1]);
          }, this) : be && Object.getOwnPropertyNames(be).forEach(function(Ke) {
            this.append(Ke, be[Ke]);
          }, this);
        }
        z.prototype.append = function(be, Ke) {
          be = M(be), Ke = I(Ke);
          var ht = this.map[be];
          this.map[be] = ht ? ht + ", " + Ke : Ke;
        }, z.prototype.delete = function(be) {
          delete this.map[M(be)];
        }, z.prototype.get = function(be) {
          return be = M(be), this.has(be) ? this.map[be] : null;
        }, z.prototype.has = function(be) {
          return this.map.hasOwnProperty(M(be));
        }, z.prototype.set = function(be, Ke) {
          this.map[M(be)] = I(Ke);
        }, z.prototype.forEach = function(be, Ke) {
          for (var ht in this.map)
            this.map.hasOwnProperty(ht) && be.call(Ke, this.map[ht], ht, this);
        }, z.prototype.keys = function() {
          var be = [];
          return this.forEach(function(Ke, ht) {
            be.push(ht);
          }), P(be);
        }, z.prototype.values = function() {
          var be = [];
          return this.forEach(function(Ke) {
            be.push(Ke);
          }), P(be);
        }, z.prototype.entries = function() {
          var be = [];
          return this.forEach(function(Ke, ht) {
            be.push([ht, Ke]);
          }), P(be);
        }, m.iterable && (z.prototype[Symbol.iterator] = z.prototype.entries);
        function V(be) {
          if (be.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
          be.bodyUsed = !0;
        }
        function W(be) {
          return new Promise(function(Ke, ht) {
            be.onload = function() {
              Ke(be.result);
            }, be.onerror = function() {
              ht(be.error);
            };
          });
        }
        function X(be) {
          var Ke = new FileReader(), ht = W(Ke);
          return Ke.readAsArrayBuffer(be), ht;
        }
        function K(be) {
          var Ke = new FileReader(), ht = W(Ke);
          return Ke.readAsText(be), ht;
        }
        function se(be) {
          for (var Ke = new Uint8Array(be), ht = new Array(Ke.length), vt = 0; vt < Ke.length; vt++)
            ht[vt] = String.fromCharCode(Ke[vt]);
          return ht.join("");
        }
        function pe(be) {
          if (be.slice)
            return be.slice(0);
          var Ke = new Uint8Array(be.byteLength);
          return Ke.set(new Uint8Array(be)), Ke.buffer;
        }
        function xe() {
          return this.bodyUsed = !1, this._initBody = function(be) {
            this._bodyInit = be, be ? typeof be == "string" ? this._bodyText = be : m.blob && Blob.prototype.isPrototypeOf(be) ? this._bodyBlob = be : m.formData && FormData.prototype.isPrototypeOf(be) ? this._bodyFormData = be : m.searchParams && URLSearchParams.prototype.isPrototypeOf(be) ? this._bodyText = be.toString() : m.arrayBuffer && m.blob && g(be) ? (this._bodyArrayBuffer = pe(be.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : m.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(be) || T(be)) ? this._bodyArrayBuffer = pe(be) : this._bodyText = be = Object.prototype.toString.call(be) : this._bodyText = "", this.headers.get("content-type") || (typeof be == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : m.searchParams && URLSearchParams.prototype.isPrototypeOf(be) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
          }, m.blob && (this.blob = function() {
            var be = V(this);
            if (be)
              return be;
            if (this._bodyBlob)
              return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]));
          }, this.arrayBuffer = function() {
            return this._bodyArrayBuffer ? V(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(X);
          }), this.text = function() {
            var be = V(this);
            if (be)
              return be;
            if (this._bodyBlob)
              return K(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(se(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }, m.formData && (this.formData = function() {
            return this.text().then(Se);
          }), this.json = function() {
            return this.text().then(JSON.parse);
          }, this;
        }
        var Fe = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function ze(be) {
          var Ke = be.toUpperCase();
          return Fe.indexOf(Ke) > -1 ? Ke : be;
        }
        function Pe(be, Ke) {
          Ke = Ke || {};
          var ht = Ke.body;
          if (be instanceof Pe) {
            if (be.bodyUsed)
              throw new TypeError("Already read");
            this.url = be.url, this.credentials = be.credentials, Ke.headers || (this.headers = new z(be.headers)), this.method = be.method, this.mode = be.mode, this.signal = be.signal, !ht && be._bodyInit != null && (ht = be._bodyInit, be.bodyUsed = !0);
          } else
            this.url = String(be);
          if (this.credentials = Ke.credentials || this.credentials || "same-origin", (Ke.headers || !this.headers) && (this.headers = new z(Ke.headers)), this.method = ze(Ke.method || this.method || "GET"), this.mode = Ke.mode || this.mode || null, this.signal = Ke.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && ht)
            throw new TypeError("Body not allowed for GET or HEAD requests");
          this._initBody(ht);
        }
        Pe.prototype.clone = function() {
          return new Pe(this, { body: this._bodyInit });
        };
        function Se(be) {
          var Ke = new FormData();
          return be.trim().split("&").forEach(function(ht) {
            if (ht) {
              var vt = ht.split("="), Pt = vt.shift().replace(/\+/g, " "), tr = vt.join("=").replace(/\+/g, " ");
              Ke.append(decodeURIComponent(Pt), decodeURIComponent(tr));
            }
          }), Ke;
        }
        function Ie(be) {
          var Ke = new z(), ht = be.replace(/\r?\n[\t ]+/g, " ");
          return ht.split(/\r?\n/).forEach(function(vt) {
            var Pt = vt.split(":"), tr = Pt.shift().trim();
            if (tr) {
              var Pn = Pt.join(":").trim();
              Ke.append(tr, Pn);
            }
          }), Ke;
        }
        xe.call(Pe.prototype);
        function Je(be, Ke) {
          Ke || (Ke = {}), this.type = "default", this.status = Ke.status === void 0 ? 200 : Ke.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in Ke ? Ke.statusText : "OK", this.headers = new z(Ke.headers), this.url = Ke.url || "", this._initBody(be);
        }
        xe.call(Je.prototype), Je.prototype.clone = function() {
          return new Je(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new z(this.headers),
            url: this.url
          });
        }, Je.error = function() {
          var be = new Je(null, { status: 0, statusText: "" });
          return be.type = "error", be;
        };
        var qe = [301, 302, 303, 307, 308];
        Je.redirect = function(be, Ke) {
          if (qe.indexOf(Ke) === -1)
            throw new RangeError("Invalid status code");
          return new Je(null, { status: Ke, headers: { location: be } });
        }, o.DOMException = h.DOMException;
        try {
          new o.DOMException();
        } catch {
          o.DOMException = function(Ke, ht) {
            this.message = Ke, this.name = ht;
            var vt = Error(Ke);
            this.stack = vt.stack;
          }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException;
        }
        function at(be, Ke) {
          return new Promise(function(ht, vt) {
            var Pt = new Pe(be, Ke);
            if (Pt.signal && Pt.signal.aborted)
              return vt(new o.DOMException("Aborted", "AbortError"));
            var tr = new XMLHttpRequest();
            function Pn() {
              tr.abort();
            }
            tr.onload = function() {
              var Rr = {
                status: tr.status,
                statusText: tr.statusText,
                headers: Ie(tr.getAllResponseHeaders() || "")
              };
              Rr.url = "responseURL" in tr ? tr.responseURL : Rr.headers.get("X-Request-URL");
              var pr = "response" in tr ? tr.response : tr.responseText;
              ht(new Je(pr, Rr));
            }, tr.onerror = function() {
              vt(new TypeError("Network request failed"));
            }, tr.ontimeout = function() {
              vt(new TypeError("Network request failed"));
            }, tr.onabort = function() {
              vt(new o.DOMException("Aborted", "AbortError"));
            }, tr.open(Pt.method, Pt.url, !0), Pt.credentials === "include" ? tr.withCredentials = !0 : Pt.credentials === "omit" && (tr.withCredentials = !1), "responseType" in tr && m.blob && (tr.responseType = "blob"), Pt.headers.forEach(function(Rr, pr) {
              tr.setRequestHeader(pr, Rr);
            }), Pt.signal && (Pt.signal.addEventListener("abort", Pn), tr.onreadystatechange = function() {
              tr.readyState === 4 && Pt.signal.removeEventListener("abort", Pn);
            }), tr.send(typeof Pt._bodyInit > "u" ? null : Pt._bodyInit);
          });
        }
        return at.polyfill = !0, h.fetch || (h.fetch = at, h.Headers = z, h.Request = Pe, h.Response = Je), o.Headers = z, o.Request = Pe, o.Response = Je, o.fetch = at, Object.defineProperty(o, "__esModule", { value: !0 }), o;
      })({});
    })(a), a.fetch.ponyfill = !0, delete a.fetch.polyfill;
    var s = a;
    e = s.fetch, e.default = s.fetch, e.fetch = s.fetch, e.Headers = s.Headers, e.Request = s.Request, e.Response = s.Response, t.exports = e;
  }(Wy, Wy.exports)), Wy.exports;
}
(function(t, e) {
  var n;
  if (typeof fetch == "function" && (typeof js < "u" && js.fetch ? n = js.fetch : typeof window < "u" && window.fetch ? n = window.fetch : n = fetch), typeof O9 < "u" && (typeof window > "u" || typeof window.document > "u")) {
    var a = n || C9();
    a.default && (a = a.default), e.default = a, t.exports = e.default;
  }
})(nv, nv.exports);
const CI = nv.exports, wE = /* @__PURE__ */ RC({
  __proto__: null,
  default: CI
}, [nv.exports]);
function iv(t) {
  return iv = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, iv(t);
}
var Bl;
typeof fetch == "function" && (typeof global < "u" && global.fetch ? Bl = global.fetch : typeof window < "u" && window.fetch ? Bl = window.fetch : Bl = fetch);
var Rd;
OI() && (typeof global < "u" && global.XMLHttpRequest ? Rd = global.XMLHttpRequest : typeof window < "u" && window.XMLHttpRequest && (Rd = window.XMLHttpRequest));
var ov;
typeof ActiveXObject == "function" && (typeof global < "u" && global.ActiveXObject ? ov = global.ActiveXObject : typeof window < "u" && window.ActiveXObject && (ov = window.ActiveXObject));
!Bl && wE && !Rd && !ov && (Bl = CI || wE);
typeof Bl != "function" && (Bl = void 0);
var v1 = function(e, n) {
  if (n && iv(n) === "object") {
    var a = "";
    for (var s in n)
      a += "&" + encodeURIComponent(s) + "=" + encodeURIComponent(n[s]);
    if (!a)
      return e;
    e = e + (e.indexOf("?") !== -1 ? "&" : "?") + a.slice(1);
  }
  return e;
}, EE = function(e, n, a) {
  Bl(e, n).then(function(s) {
    if (!s.ok)
      return a(s.statusText || "Error", {
        status: s.status
      });
    s.text().then(function(h) {
      a(null, {
        status: s.status,
        data: h
      });
    }).catch(a);
  }).catch(a);
}, SE = !1, A9 = function(e, n, a, s) {
  e.queryStringParams && (n = v1(n, e.queryStringParams));
  var h = g1({}, typeof e.customHeaders == "function" ? e.customHeaders() : e.customHeaders);
  a && (h["Content-Type"] = "application/json");
  var o = typeof e.requestOptions == "function" ? e.requestOptions(a) : e.requestOptions, m = g1({
    method: a ? "POST" : "GET",
    body: a ? e.stringify(a) : void 0,
    headers: h
  }, SE ? {} : o);
  try {
    EE(n, m, s);
  } catch (g) {
    if (!o || Object.keys(o).length === 0 || !g.message || g.message.indexOf("not implemented") < 0)
      return s(g);
    try {
      Object.keys(o).forEach(function(b) {
        delete m[b];
      }), EE(n, m, s), SE = !0;
    } catch (b) {
      s(b);
    }
  }
}, P9 = function(e, n, a, s) {
  a && iv(a) === "object" && (a = v1("", a).slice(1)), e.queryStringParams && (n = v1(n, e.queryStringParams));
  try {
    var h;
    Rd ? h = new Rd() : h = new ov("MSXML2.XMLHTTP.3.0"), h.open(a ? "POST" : "GET", n, 1), e.crossDomain || h.setRequestHeader("X-Requested-With", "XMLHttpRequest"), h.withCredentials = !!e.withCredentials, a && h.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), h.overrideMimeType && h.overrideMimeType("application/json");
    var o = e.customHeaders;
    if (o = typeof o == "function" ? o() : o, o)
      for (var m in o)
        h.setRequestHeader(m, o[m]);
    h.onreadystatechange = function() {
      h.readyState > 3 && s(h.status >= 400 ? h.statusText : null, {
        status: h.status,
        data: h.responseText
      });
    }, h.send(a);
  } catch (g) {
    console && console.log(g);
  }
}, k9 = function(e, n, a, s) {
  if (typeof a == "function" && (s = a, a = void 0), s = s || function() {
  }, Bl && n.indexOf("file:") !== 0)
    return A9(e, n, a, s);
  if (OI() || typeof ActiveXObject == "function")
    return P9(e, n, a, s);
  s(new Error("No fetch and no xhr implementation found!"));
};
function zd(t) {
  return zd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, zd(t);
}
function L9(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function TE(t, e) {
  for (var n = 0; n < e.length; n++) {
    var a = e[n];
    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, AI(a.key), a);
  }
}
function D9(t, e, n) {
  return e && TE(t.prototype, e), n && TE(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function N9(t, e, n) {
  return e = AI(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function AI(t) {
  var e = R9(t, "string");
  return zd(e) === "symbol" ? e : String(e);
}
function R9(t, e) {
  if (zd(t) !== "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var a = n.call(t, e || "default");
    if (zd(a) !== "object")
      return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var z9 = function() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    allowMultiLoading: !1,
    parse: function(n) {
      return JSON.parse(n);
    },
    stringify: JSON.stringify,
    parsePayload: function(n, a, s) {
      return N9({}, a, s || "");
    },
    request: k9,
    reloadInterval: typeof window < "u" ? !1 : 60 * 60 * 1e3,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: !1,
    withCredentials: !1,
    overrideMimeType: !1,
    requestOptions: {
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
}, PI = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    L9(this, t), this.services = e, this.options = n, this.allOptions = a, this.type = "backend", this.init(e, n, a);
  }
  return D9(t, [{
    key: "init",
    value: function(n) {
      var a = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = n, this.options = g1(s, this.options || {}, z9()), this.allOptions = h, this.services && this.options.reloadInterval && setInterval(function() {
        return a.reload();
      }, this.options.reloadInterval);
    }
  }, {
    key: "readMulti",
    value: function(n, a, s) {
      this._readAny(n, n, a, a, s);
    }
  }, {
    key: "read",
    value: function(n, a, s) {
      this._readAny([n], n, [a], a, s);
    }
  }, {
    key: "_readAny",
    value: function(n, a, s, h, o) {
      var m = this, g = this.options.loadPath;
      typeof this.options.loadPath == "function" && (g = this.options.loadPath(n, s)), g = I9(g), g.then(function(b) {
        if (!b)
          return o(null, {});
        var T = m.services.interpolator.interpolate(b, {
          lng: n.join("+"),
          ns: s.join("+")
        });
        m.loadUrl(T, o, a, h);
      });
    }
  }, {
    key: "loadUrl",
    value: function(n, a, s, h) {
      var o = this;
      this.options.request(this.options, n, void 0, function(m, g) {
        if (g && (g.status >= 500 && g.status < 600 || !g.status))
          return a("failed loading " + n + "; status code: " + g.status, !0);
        if (g && g.status >= 400 && g.status < 500)
          return a("failed loading " + n + "; status code: " + g.status, !1);
        if (!g && m && m.message && m.message.indexOf("Failed to fetch") > -1)
          return a("failed loading " + n + ": " + m.message, !0);
        if (m)
          return a(m, !1);
        var b, T;
        try {
          typeof g.data == "string" ? b = o.options.parse(g.data, s, h) : b = g.data;
        } catch {
          T = "failed parsing " + n + " to json";
        }
        if (T)
          return a(T, !1);
        a(null, b);
      });
    }
  }, {
    key: "create",
    value: function(n, a, s, h, o) {
      var m = this;
      if (!!this.options.addPath) {
        typeof n == "string" && (n = [n]);
        var g = this.options.parsePayload(a, s, h), b = 0, T = [], M = [];
        n.forEach(function(I) {
          var P = m.options.addPath;
          typeof m.options.addPath == "function" && (P = m.options.addPath(I, a));
          var z = m.services.interpolator.interpolate(P, {
            lng: I,
            ns: a
          });
          m.options.request(m.options, z, g, function(V, W) {
            b += 1, T.push(V), M.push(W), b === n.length && typeof o == "function" && o(T, M);
          });
        });
      }
    }
  }, {
    key: "reload",
    value: function() {
      var n = this, a = this.services, s = a.backendConnector, h = a.languageUtils, o = a.logger, m = s.language;
      if (!(m && m.toLowerCase() === "cimode")) {
        var g = [], b = function(M) {
          var I = h.toResolveHierarchy(M);
          I.forEach(function(P) {
            g.indexOf(P) < 0 && g.push(P);
          });
        };
        b(m), this.allOptions.preload && this.allOptions.preload.forEach(function(T) {
          return b(T);
        }), g.forEach(function(T) {
          n.allOptions.ns.forEach(function(M) {
            s.read(T, M, "read", null, null, function(I, P) {
              I && o.warn("loading namespace ".concat(M, " for language ").concat(T, " failed"), I), !I && P && o.log("loaded namespace ".concat(M, " for language ").concat(T), P), s.loaded("".concat(T, "|").concat(M), I, P);
            });
          });
        });
      }
    }
  }]), t;
}();
PI.type = "backend";
const F9 = /* @__PURE__ */ or({
  __name: "simple-style-item",
  props: {
    styleName: { type: String, required: !0 },
    colors: { type: Array, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Ve(!0), it(cn, null, Ra(e.colors, (s, h) => (Ve(), it("span", {
      key: `${t.styleName}-${h}`,
      class: "grow m-px",
      style: Vu(`background-color: ${s}`)
    }, " \xA0 ", 4))), 128));
  }
}), B9 = /* @__PURE__ */ ur(F9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/simple-style-item.vue"]]), V9 = { class: "text-white border-2 p-[10px] m-[10px]" }, U9 = { class: "text-center mb-3" }, j9 = ["title"], G9 = { class: "text-white" }, q9 = ["title", "onClick"], $9 = { class: "flex" }, W9 = /* @__PURE__ */ or({
  __name: "simple-style-selector",
  setup(t) {
    const { t: e } = In(), n = Hs(), a = Ff(), { bgStyle: s } = xn(n), h = os().simple_styles.road, o = Mr(h);
    Bn(
      s,
      (g) => o.value = a.checkSelection(
        g || [],
        h
      ),
      { immediate: !0 }
    );
    function m(g) {
      n.setSimpleStyle(g);
    }
    return (g, b) => (Ve(), it("div", V9, [
      Ye(" TODO: create clean container for simple and advanced style editors "),
      Re("h5", U9, Gt(ae(e)("Select a style", { ns: "client" })), 1),
      (Ve(!0), it(cn, null, Ra(o.value, (T) => (Ve(), it("div", {
        key: T.unlocalized_label,
        title: ae(e)(T.unlocalized_label, { ns: "client" }),
        class: Pr(`${T.selected ? "border-dotted" : "border-hidden"} border-2 p-px`)
      }, [
        Re("span", G9, Gt(ae(e)(T.unlocalized_label, { ns: "client" })) + " : ", 1),
        Re("button", {
          title: ae(e)("Select style: {{styleName}}", {
            styleName: ae(e)(T.unlocalized_label)
          }),
          onClick: (M) => m(T),
          class: "w-full"
        }, [
          Re("span", $9, [
            Ft(B9, {
              colors: T.colors,
              "style-name": T.unlocalized_label
            }, null, 8, ["colors", "style-name"])
          ])
        ], 8, q9)
      ], 10, j9))), 128))
    ]));
  }
}), H9 = /* @__PURE__ */ ur(W9, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/simple-style-selector.vue"]]);
function Z9(t) {
  const e = X9(t);
  return !e || !e.medium_style_class ? [] : os().medium_default_styles[e.medium_style_class];
}
function X9(t) {
  return os().bg_layers.find((e) => e.id == (t == null ? void 0 : t.id));
}
const K9 = { class: "flex w-full items-center" }, Y9 = {
  for: "colorId",
  class: "w-40"
}, J9 = { class: "grow" }, Q9 = ["value"], e7 = ["checked", "aria-label"], t7 = /* @__PURE__ */ or({
  __name: "medium-style-item",
  props: {
    style: { type: null, required: !0 },
    colorEditable: { type: Boolean, required: !0 }
  },
  emits: ["changeStyle"],
  setup(t, { emit: e }) {
    const n = t, { t: a } = In();
    function s(o) {
      if (o.target) {
        const m = {
          ...n.style,
          color: o.target.value
        };
        e("changeStyle", m);
      }
    }
    function h(o) {
      if (o) {
        const m = {
          ...n.style,
          visible: o.target.checked
        };
        e("changeStyle", m);
      }
    }
    return (o, m) => (Ve(), it("div", K9, [
      Re("label", Y9, Gt(ae(a)(t.style.label)), 1),
      Re("div", J9, [
        t.colorEditable && n.style.color ? (Ve(), it("input", {
          key: 0,
          id: "colorId",
          type: "color",
          class: "w-11 h-5 py-[1px] px-[2px]",
          value: n.style.color,
          onInput: s
        }, null, 40, Q9)) : Ye("v-if", !0)
      ]),
      Re("input", {
        type: "checkbox",
        class: "flex-none mr-3",
        checked: n.style.visible,
        onChange: h,
        "aria-label": ae(a)("Show or hide {{ thematicName }}", {
          thematicName: n.style.label
        })
      }, null, 40, e7)
    ]));
  }
}), r7 = /* @__PURE__ */ ur(t7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/medium-style-item.vue"]]), n7 = { class: "text-white border-2 p-[10px] m-[10px]" }, i7 = { class: "text-center mb-3" }, o7 = /* @__PURE__ */ or({
  __name: "medium-style-selector",
  props: {
    layer: { type: null, required: !0 }
  },
  setup(t) {
    const e = t, n = ["basemap_2015_global"], a = Hs(), { bgStyle: s } = xn(a), { t: h } = In(), o = lr(
      () => n.includes(e.layer.name)
    ), m = lr(
      () => s.value || Z9(e.layer)
    );
    function g(b, T) {
      s.value = m.value.map(
        (M, I) => I === b ? T : M
      ), a.disableExpertStyle();
    }
    return (b, T) => (Ve(), it("div", n7, [
      Re("h5", i7, Gt(ae(o) ? ae(h)("Select a colour for every theme") : ae(h)("Activate categories")), 1),
      (Ve(!0), it(cn, null, Ra(ae(m), (M, I) => (Ve(), on(r7, {
        key: M.label,
        style: Vu(M),
        onChangeStyle: (P) => g(I, P),
        colorEditable: ae(o)
      }, null, 8, ["style", "onChangeStyle", "colorEditable"]))), 128))
    ]));
  }
}), a7 = /* @__PURE__ */ ur(o7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/medium-style-selector.vue"]]);
var kI = { exports: {} };
(function(t, e) {
  (function(n, a) {
    a();
  })(js, function() {
    function n(b, T) {
      return typeof T > "u" ? T = { autoBom: !1 } : typeof T != "object" && (console.warn("Deprecated: Expected third argument to be a object"), T = { autoBom: !T }), T.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(b.type) ? new Blob(["\uFEFF", b], { type: b.type }) : b;
    }
    function a(b, T, M) {
      var I = new XMLHttpRequest();
      I.open("GET", b), I.responseType = "blob", I.onload = function() {
        g(I.response, T, M);
      }, I.onerror = function() {
        console.error("could not download file");
      }, I.send();
    }
    function s(b) {
      var T = new XMLHttpRequest();
      T.open("HEAD", b, !1);
      try {
        T.send();
      } catch {
      }
      return 200 <= T.status && 299 >= T.status;
    }
    function h(b) {
      try {
        b.dispatchEvent(new MouseEvent("click"));
      } catch {
        var T = document.createEvent("MouseEvents");
        T.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), b.dispatchEvent(T);
      }
    }
    var o = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof js == "object" && js.global === js ? js : void 0, m = o.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = o.saveAs || (typeof window != "object" || window !== o ? function() {
    } : "download" in HTMLAnchorElement.prototype && !m ? function(b, T, M) {
      var I = o.URL || o.webkitURL, P = document.createElement("a");
      T = T || b.name || "download", P.download = T, P.rel = "noopener", typeof b == "string" ? (P.href = b, P.origin === location.origin ? h(P) : s(P.href) ? a(b, T, M) : h(P, P.target = "_blank")) : (P.href = I.createObjectURL(b), setTimeout(function() {
        I.revokeObjectURL(P.href);
      }, 4e4), setTimeout(function() {
        h(P);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(b, T, M) {
      if (T = T || b.name || "download", typeof b != "string")
        navigator.msSaveOrOpenBlob(n(b, M), T);
      else if (s(b))
        a(b, T, M);
      else {
        var I = document.createElement("a");
        I.href = b, I.target = "_blank", setTimeout(function() {
          h(I);
        });
      }
    } : function(b, T, M, I) {
      if (I = I || open("", "_blank"), I && (I.document.title = I.document.body.innerText = "downloading..."), typeof b == "string")
        return a(b, T, M);
      var P = b.type === "application/octet-stream", z = /constructor/i.test(o.HTMLElement) || o.safari, V = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((V || P && z || m) && typeof FileReader < "u") {
        var W = new FileReader();
        W.onloadend = function() {
          var se = W.result;
          se = V ? se : se.replace(/^data:[^;]*;/, "data:attachment/file;"), I ? I.location.href = se : location = se, I = null;
        }, W.readAsDataURL(b);
      } else {
        var X = o.URL || o.webkitURL, K = X.createObjectURL(b);
        I ? I.location = K : location.href = K, I = null, setTimeout(function() {
          X.revokeObjectURL(K);
        }, 4e4);
      }
    });
    o.saveAs = g.saveAs = g, t.exports = g;
  });
})(kI);
const s7 = { class: "text-white border-2 p-[10px] m-[10px] flex flex-col" }, l7 = { class: "text-center mb-3" }, u7 = { class: "flex flex-row justify-center" }, c7 = { class: "absolute top-[70px] w-full text-center text-base" }, h7 = { class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] text-sm" }, f7 = {
  class: "'block z-[5] w-full h-full cursor-pointer after:absolute after:py-[15px] after:px-[15px] after:w-full after:text-center after:content-upload",
  for: "uploadMvtStyle"
}, p7 = { class: "absolute top-[70px] w-full text-center text-base" }, d7 = ["href"], m7 = /* @__PURE__ */ or({
  __name: "expert-style-selector",
  setup(t) {
    const e = Ai(), n = Hs(), a = Ff(), { appliedStyle: s } = xn(n), { t: h } = In();
    function o() {
      const b = s.value, T = JSON.stringify(b), M = new Blob([T], { type: "text/plain;charset=utf-8" }), I = "styles.json";
      kI.exports.saveAs(M, I);
    }
    function m(b) {
      const T = b.target.files;
      if ((T == null ? void 0 : T.length) !== 1)
        return;
      const M = T[0];
      new File([], "./text.txt").text().then((P) => console.log(P)), M.type === "application/json" && (M.text().then((P) => {
        n.enableExpertStyle(), s.value = JSON.parse(P);
      }), b.target.value = "");
    }
    function g() {
      return n.styleSerial === null ? a.getDefaultMapBoxStyleUrl(
        a.getVectorId(e.bgLayer)
      ) : `${n.registerUrls.get("get")}?id=${n.styleSerial}`;
    }
    return (b, T) => (Ve(), it("div", s7, [
      Re("h5", l7, Gt(ae(h)("Lancer \xE9diteur externe ou importer json")), 1),
      Re("div", u7, [
        Re("a", {
          href: "#",
          class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] z-5 text-sm after:absolute after:left-[20px] after:top-[10px] after:z-4 after:w-[3.6em] after:text-center after:content-download",
          onClick: T[0] || (T[0] = (M) => o())
        }, [
          Re("span", c7, Gt(ae(h)("Download style")), 1)
        ]),
        Re("div", h7, [
          Re("label", f7, [
            Re("span", p7, Gt(ae(h)("Upload style")), 1)
          ]),
          Re("input", {
            class: "invisible",
            type: "file",
            name: "uploadMvtStyle",
            id: "uploadMvtStyle",
            onChange: m
          }, null, 32)
        ])
      ]),
      Re("a", {
        href: `https://maputnik.github.io/editor/?style=${g()}`,
        target: "_blank",
        class: "lux-btn text-center"
      }, Gt(ae(h)("Open Maputnik editor")), 9, d7)
    ]));
  }
}), y7 = /* @__PURE__ */ ur(m7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/expert-style-selector.vue"]]), g7 = { key: 0 }, v7 = { class: "h-20 shrink-0 flex justify-between lux-panel-title" }, _7 = { key: 0 }, x7 = { key: 1 }, b7 = { key: 2 }, w7 = /* @__PURE__ */ or({
  __name: "style-selector",
  setup(t) {
    const { t: e } = In(), n = Ai(), a = Pi(), s = Hs(), { bgLayer: h } = xn(n), o = Ff(), m = lr(
      () => o.getStyleCapabilitiesFromLayer(h.value)
    );
    Bn(h, (I) => {
      o.isLayerStyleEditable(I) || a.closeStyleEditorPanel();
    });
    let g = Mr(!1), b = Mr(!1), T = Mr(!1);
    function M() {
      s.setStyle(null);
    }
    return (I, P) => ae(m).isEditable ? (Ve(), it("div", g7, [
      Re("button", {
        onClick: P[0] || (P[0] = () => ae(a).closeStyleEditorPanel())
      }, "X close"),
      Re("h2", v7, Gt(ae(e)("Style editor")), 1),
      ae(m).hasSimpleStyle ? (Ve(), it("div", _7, [
        Re("button", {
          onClick: P[1] || (P[1] = () => hn(g) ? g.value = !ae(g) : g = !ae(g))
        }, Gt(ae(e)("Choose a predefined style")), 1),
        Ft(H9, {
          class: Pr(ae(g) ? "" : "hidden")
        }, null, 8, ["class"])
      ])) : Ye("v-if", !0),
      ae(m).hasAdvancedStyle ? (Ve(), it("div", x7, [
        Re("button", {
          onClick: P[2] || (P[2] = () => hn(b) ? b.value = !ae(b) : b = !ae(b))
        }, Gt(ae(e)("Change main colours")), 1),
        ae(h) ? (Ve(), on(a7, {
          key: 0,
          class: Pr(ae(b) ? "" : "hidden"),
          layer: ae(h)
        }, null, 8, ["class", "layer"])) : Ye("v-if", !0)
      ])) : Ye("v-if", !0),
      ae(m).hasExpertStyle ? (Ve(), it("div", b7, [
        Re("button", {
          onClick: P[3] || (P[3] = () => hn(T) ? T.value = !ae(T) : T = !ae(T))
        }, Gt(ae(e)("Advanced settings")), 1),
        ae(h) ? (Ve(), on(y7, {
          key: 0,
          class: Pr(ae(T) ? "" : "hidden"),
          layer: ae(h)
        }, null, 8, ["class", "layer"])) : Ye("v-if", !0)
      ])) : Ye("v-if", !0),
      Re("button", {
        onClick: M,
        class: "lux-btn"
      }, Gt(ae(e)("Reset style", { ns: "client" })), 1)
    ])) : Ye("v-if", !0);
  }
}), E7 = /* @__PURE__ */ ur(w7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/components/style-selector/style-selector.vue"]]);
function LI(t, e, n) {
  n(t, e) && t instanceof NC && t.getLayers().forEach((s) => {
    LI(s, [...e, t], n);
  });
}
const S7 = { class: "h-screen flex flex-col overflow-hidden" }, T7 = { class: "flex grow" }, M7 = {
  key: 0,
  class: "w-full sm:w-80 bg-secondary z-10"
}, I7 = {
  key: 1,
  class: "w-80 bg-primary"
}, O7 = { class: "map-wrapper grow bg-blue-100 relative" }, C7 = { class: "absolute right-1 top-16" }, A7 = /* @__PURE__ */ or({
  __name: "App",
  setup(t) {
    E9.bootstrap(), m9.bootstrap(), _9.bootstrap(), b9.bootstrapLayersOpen(), GM.bootstrapStyle(), p9.bootstrap();
    const { layersOpen: e, styleEditorOpen: n } = xn(Pi());
    Bn(
      e,
      () => setTimeout(() => {
        a();
      }, 50)
    ), va(() => window.addEventListener("resize", a)), Uu(() => window.removeEventListener("resize", a));
    function a() {
      const s = zl().getOlMap();
      s.updateSize(), LI(s.getLayerGroup(), [], (h) => (h instanceof RT && h.getMapLibreMap().resize(), !0));
    }
    return (s, h) => (Ve(), it("div", S7, [
      Ft(RV),
      Re("main", T7, [
        Ye(" Layer panel "),
        ae(e) ? (Ve(), it("div", M7, [
          Ft(Kj)
        ])) : Ye("v-if", !0),
        Ye(" Style editor "),
        ae(n) ? (Ve(), it("div", I7, [
          Ft(E7)
        ])) : Ye("v-if", !0),
        Ye(" Map container and slider comparator "),
        Re("div", O7, [
          Ft(LF, { v4_standalone: !0 }),
          Ft(s9),
          Ft(P8),
          Ft(bV)
        ]),
        Ye(" Background selector "),
        Re("div", C7, [
          Ft(jF)
        ])
      ]),
      Ft(WV, { class: "fixed bottom-5 sm:static z-20" }),
      Ft(G4)
    ]));
  }
}), P7 = /* @__PURE__ */ ur(A7, [["__file", "/home/abernachot/Dev/Lux/luxembourg-geoportail/src/App.vue"]]);
L4();
ii.use(PI);
ii.init({
  lng: "fr",
  debug: !1,
  defaultNS: "client",
  supportedLngs: ["de", "en", "fr", "lb"],
  ns: ["client", "legends", "server", "tooltips"],
  fallbackLng: "fr",
  backend: {
    loadPath: "/static-ngeo/web-components/assets/locales/{{ns}}.{{lng}}.json"
  }
});
const cx = $k(P7);
cx.use(JL());
cx.use(x5, { i18next: ii });
cx.use(IL);
const nG = (t = {}, e = null) => D4(
  {
    setup: () => {
      const n = vv();
      Object.assign(n.appContext, e._context), Object.assign(n.provides, e._context.provides);
    },
    render: () => $S(t)
  },
  { shadowRoot: !1 }
);
export {
  G4 as AlertNotifications,
  P7 as App,
  jF as BackgroundSelector,
  LT as DropdownList,
  WV as FooterBar,
  RV as HeaderBar,
  x5 as I18NextVue,
  bV as LayerMetadata,
  Kj as LayerPanel,
  LF as MapContainer,
  RT as MapLibreLayer,
  P8 as RemoteLayers,
  s9 as SliderComparator,
  IL as VueDOMPurifyHTML,
  cx as app,
  PI as backend,
  nG as createElementInstance,
  JL as createPinia,
  D4 as defineCustomElement,
  ii as i18next,
  p9 as statePersistorBgLayerService,
  b9 as statePersistorLayersOpenService,
  m9 as statePersistorLayersService,
  E9 as statePersistorMyMapService,
  GM as statePersistorStyleService,
  _9 as statePersistorThemeService,
  xn as storeToRefs,
  OV as themeSelectorService,
  Pi as useAppStore,
  JM as useBackgroundLayer,
  ku as useLayers,
  zl as useMap,
  Ai as useMapStore,
  Ff as useMvtStyles,
  YM as useOpenLayers,
  Hs as useStyleStore,
  Ro as useThemeStore,
  Hc as useThemes,
  Bn as watch
};
