var lC = Object.defineProperty;
var uC = (t, e, n) => e in t ? lC(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var bi = (t, e, n) => (uC(t, typeof e != "symbol" ? e + "" : e, n), n);
import { get as Wy, transformExtent as cC, getTransform as hC, transform as Ob } from "ol/proj";
import { register as fC } from "ol/proj/proj4";
import pC from "ol/Map";
import dC from "ol/View";
import mC from "ol/layer/Image";
import yC from "ol/layer/Tile";
import { ImageWMS as gC, WMTS as vC } from "ol/source";
import _C from "ol/tilegrid/WMTS";
import { getTopLeft as xC } from "ol/extent.js";
import bC from "ol/layer/Layer";
import { toDegrees as wC } from "ol/math";
import { toLonLat as EC } from "ol/proj.js";
import * as Cb from "ol/events";
import SC from "ol/ObjectEventType";
import TC from "ol/control/Attribution";
import { CLASS_UNSELECTABLE as EE, CLASS_CONTROL as SE } from "ol/css";
import TE from "ol/control/Control";
import MC from "ol/control/FullScreen";
import IC from "ol/control/Zoom";
import OC from "ol/control/ZoomToExtent";
import CC from "ol/format/WMTSCapabilities.js";
import { getRenderPixel as py } from "ol/render";
import { unByKey as AC } from "ol/Observable";
import Ab from "ol/render/EventType";
import PC from "ol/layer/Group.js";
function kC(t, e) {
  for (var n = 0; n < e.length; n++) {
    const a = e[n];
    if (typeof a != "string" && !Array.isArray(a)) {
      for (const s in a)
        if (s !== "default" && !(s in t)) {
          const f = Object.getOwnPropertyDescriptor(a, s);
          f && Object.defineProperty(t, s, f.get ? f : {
            enumerable: !0,
            get: () => a[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
function zu(t, e) {
  const n = /* @__PURE__ */ Object.create(null), a = t.split(",");
  for (let s = 0; s < a.length; s++)
    n[a[s]] = !0;
  return e ? (s) => !!n[s.toLowerCase()] : (s) => !!n[s];
}
function Rf(t) {
  if (er(t)) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const a = t[n], s = Hn(a) ? RC(a) : Rf(a);
      if (s)
        for (const f in s)
          e[f] = s[f];
    }
    return e;
  } else {
    if (Hn(t))
      return t;
    if (fn(t))
      return t;
  }
}
const LC = /;(?![^(]*\))/g, DC = /:([^]+)/, NC = /\/\*.*?\*\//gs;
function RC(t) {
  const e = {};
  return t.replace(NC, "").split(LC).forEach((n) => {
    if (n) {
      const a = n.split(DC);
      a.length > 1 && (e[a[0].trim()] = a[1].trim());
    }
  }), e;
}
function Lr(t) {
  let e = "";
  if (Hn(t))
    e = t;
  else if (er(t))
    for (let n = 0; n < t.length; n++) {
      const a = Lr(t[n]);
      a && (e += a + " ");
    }
  else if (fn(t))
    for (const n in t)
      t[n] && (e += n + " ");
  return e.trim();
}
const zC = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", FC = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", BC = /* @__PURE__ */ zu(zC), VC = /* @__PURE__ */ zu(FC), UC = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", jC = /* @__PURE__ */ zu(UC);
function ME(t) {
  return !!t || t === "";
}
const Vt = (t) => Hn(t) ? t : t == null ? "" : er(t) || fn(t) && (t.toString === AE || !dr(t.toString)) ? JSON.stringify(t, IE, 2) : String(t), IE = (t, e) => e && e.__v_isRef ? IE(t, e.value) : zc(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce((n, [a, s]) => (n[`${a} =>`] = s, n), {})
} : CE(e) ? {
  [`Set(${e.size})`]: [...e.values()]
} : fn(e) && !er(e) && !PE(e) ? String(e) : e, wn = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, vf = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], ao = () => {
}, OE = () => !1, GC = /^on[^a-z]/, zd = (t) => GC.test(t), dg = (t) => t.startsWith("onUpdate:"), Wn = Object.assign, m1 = (t, e) => {
  const n = t.indexOf(e);
  n > -1 && t.splice(n, 1);
}, qC = Object.prototype.hasOwnProperty, Vr = (t, e) => qC.call(t, e), er = Array.isArray, zc = (t) => iv(t) === "[object Map]", CE = (t) => iv(t) === "[object Set]", dr = (t) => typeof t == "function", Hn = (t) => typeof t == "string", y1 = (t) => typeof t == "symbol", fn = (t) => t !== null && typeof t == "object", g1 = (t) => fn(t) && dr(t.then) && dr(t.catch), AE = Object.prototype.toString, iv = (t) => AE.call(t), v1 = (t) => iv(t).slice(8, -1), PE = (t) => iv(t) === "[object Object]", _1 = (t) => Hn(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Hy = /* @__PURE__ */ zu(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), $C = /* @__PURE__ */ zu("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), ov = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = t(n));
}, WC = /-(\w)/g, ya = ov((t) => t.replace(WC, (e, n) => n ? n.toUpperCase() : "")), HC = /\B([A-Z])/g, ta = ov((t) => t.replace(HC, "-$1").toLowerCase()), $c = ov((t) => t.charAt(0).toUpperCase() + t.slice(1)), Oc = ov((t) => t ? `on${$c(t)}` : ""), Ed = (t, e) => !Object.is(t, e), Vp = (t, e) => {
  for (let n = 0; n < t.length; n++)
    t[n](e);
}, mg = (t, e, n) => {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !1,
    value: n
  });
}, ZC = (t) => {
  const e = parseFloat(t);
  return isNaN(e) ? t : e;
}, g0 = (t) => {
  const e = Hn(t) ? Number(t) : NaN;
  return isNaN(e) ? t : e;
};
let Pb;
const kE = () => Pb || (Pb = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function yg(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
let pa;
class LE {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = pa, !e && pa && (this.index = (pa.scopes || (pa.scopes = [])).push(this) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const n = pa;
      try {
        return pa = this, e();
      } finally {
        pa = n;
      }
    } else
      process.env.NODE_ENV !== "production" && yg("cannot run an inactive effect scope.");
  }
  on() {
    pa = this;
  }
  off() {
    pa = this.parent;
  }
  stop(e) {
    if (this._active) {
      let n, a;
      for (n = 0, a = this.effects.length; n < a; n++)
        this.effects[n].stop();
      for (n = 0, a = this.cleanups.length; n < a; n++)
        this.cleanups[n]();
      if (this.scopes)
        for (n = 0, a = this.scopes.length; n < a; n++)
          this.scopes[n].stop(!0);
      if (!this.detached && this.parent && !e) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function DE(t) {
  return new LE(t);
}
function XC(t, e = pa) {
  e && e.active && e.effects.push(t);
}
function NE() {
  return pa;
}
function KC(t) {
  pa ? pa.cleanups.push(t) : process.env.NODE_ENV !== "production" && yg("onScopeDispose() is called when there is no active effect scope to be associated with.");
}
const Sd = (t) => {
  const e = new Set(t);
  return e.w = 0, e.n = 0, e;
}, RE = (t) => (t.w & Pu) > 0, zE = (t) => (t.n & Pu) > 0, YC = ({ deps: t }) => {
  if (t.length)
    for (let e = 0; e < t.length; e++)
      t[e].w |= Pu;
}, JC = (t) => {
  const { deps: e } = t;
  if (e.length) {
    let n = 0;
    for (let a = 0; a < e.length; a++) {
      const s = e[a];
      RE(s) && !zE(s) ? s.delete(t) : e[n++] = s, s.w &= ~Pu, s.n &= ~Pu;
    }
    e.length = n;
  }
}, gg = /* @__PURE__ */ new WeakMap();
let Kp = 0, Pu = 1;
const v0 = 30;
let No;
const Fc = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : ""), _0 = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class x1 {
  constructor(e, n = null, a) {
    this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, XC(this, a);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = No, n = Tu;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = No, No = this, Tu = !0, Pu = 1 << ++Kp, Kp <= v0 ? YC(this) : kb(this), this.fn();
    } finally {
      Kp <= v0 && JC(this), Pu = 1 << --Kp, No = this.parent, Tu = n, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    No === this ? this.deferStop = !0 : this.active && (kb(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function kb(t) {
  const { deps: e } = t;
  if (e.length) {
    for (let n = 0; n < e.length; n++)
      e[n].delete(t);
    e.length = 0;
  }
}
let Tu = !0;
const FE = [];
function Kc() {
  FE.push(Tu), Tu = !1;
}
function Yc() {
  const t = FE.pop();
  Tu = t === void 0 ? !0 : t;
}
function Bo(t, e, n) {
  if (Tu && No) {
    let a = gg.get(t);
    a || gg.set(t, a = /* @__PURE__ */ new Map());
    let s = a.get(n);
    s || a.set(n, s = Sd());
    const f = process.env.NODE_ENV !== "production" ? { effect: No, target: t, type: e, key: n } : void 0;
    x0(s, f);
  }
}
function x0(t, e) {
  let n = !1;
  Kp <= v0 ? zE(t) || (t.n |= Pu, n = !RE(t)) : n = !t.has(No), n && (t.add(No), No.deps.push(t), process.env.NODE_ENV !== "production" && No.onTrack && No.onTrack(Object.assign({ effect: No }, e)));
}
function Fl(t, e, n, a, s, f) {
  const o = gg.get(t);
  if (!o)
    return;
  let m = [];
  if (e === "clear")
    m = [...o.values()];
  else if (n === "length" && er(t)) {
    const b = Number(a);
    o.forEach((T, M) => {
      (M === "length" || M >= b) && m.push(T);
    });
  } else
    switch (n !== void 0 && m.push(o.get(n)), e) {
      case "add":
        er(t) ? _1(n) && m.push(o.get("length")) : (m.push(o.get(Fc)), zc(t) && m.push(o.get(_0)));
        break;
      case "delete":
        er(t) || (m.push(o.get(Fc)), zc(t) && m.push(o.get(_0)));
        break;
      case "set":
        zc(t) && m.push(o.get(Fc));
        break;
    }
  const g = process.env.NODE_ENV !== "production" ? { target: t, type: e, key: n, newValue: a, oldValue: s, oldTarget: f } : void 0;
  if (m.length === 1)
    m[0] && (process.env.NODE_ENV !== "production" ? cf(m[0], g) : cf(m[0]));
  else {
    const b = [];
    for (const T of m)
      T && b.push(...T);
    process.env.NODE_ENV !== "production" ? cf(Sd(b), g) : cf(Sd(b));
  }
}
function cf(t, e) {
  const n = er(t) ? t : [...t];
  for (const a of n)
    a.computed && Lb(a, e);
  for (const a of n)
    a.computed || Lb(a, e);
}
function Lb(t, e) {
  (t !== No || t.allowRecurse) && (process.env.NODE_ENV !== "production" && t.onTrigger && t.onTrigger(Wn({ effect: t }, e)), t.scheduler ? t.scheduler() : t.run());
}
function QC(t, e) {
  var n;
  return (n = gg.get(t)) === null || n === void 0 ? void 0 : n.get(e);
}
const eA = /* @__PURE__ */ zu("__proto__,__v_isRef,__isVue"), BE = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(y1)
), tA = /* @__PURE__ */ av(), rA = /* @__PURE__ */ av(!1, !0), nA = /* @__PURE__ */ av(!0), iA = /* @__PURE__ */ av(!0, !0), Db = /* @__PURE__ */ oA();
function oA() {
  const t = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    t[e] = function(...n) {
      const a = lr(this);
      for (let f = 0, o = this.length; f < o; f++)
        Bo(a, "get", f + "");
      const s = a[e](...n);
      return s === -1 || s === !1 ? a[e](...n.map(lr)) : s;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    t[e] = function(...n) {
      Kc();
      const a = lr(this)[e].apply(this, n);
      return Yc(), a;
    };
  }), t;
}
function aA(t) {
  const e = lr(this);
  return Bo(e, "has", t), e.hasOwnProperty(t);
}
function av(t = !1, e = !1) {
  return function(a, s, f) {
    if (s === "__v_isReactive")
      return !t;
    if (s === "__v_isReadonly")
      return t;
    if (s === "__v_isShallow")
      return e;
    if (s === "__v_raw" && f === (t ? e ? HE : WE : e ? $E : qE).get(a))
      return a;
    const o = er(a);
    if (!t) {
      if (o && Vr(Db, s))
        return Reflect.get(Db, s, f);
      if (s === "hasOwnProperty")
        return aA;
    }
    const m = Reflect.get(a, s, f);
    return (y1(s) ? BE.has(s) : eA(s)) || (t || Bo(a, "get", s), e) ? m : hn(m) ? o && _1(s) ? m : m.value : fn(m) ? t ? ZE(m) : uv(m) : m;
  };
}
const sA = /* @__PURE__ */ VE(), lA = /* @__PURE__ */ VE(!0);
function VE(t = !1) {
  return function(n, a, s, f) {
    let o = n[a];
    if (ku(o) && hn(o) && !hn(s))
      return !1;
    if (!t && (!vg(s) && !ku(s) && (o = lr(o), s = lr(s)), !er(n) && hn(o) && !hn(s)))
      return o.value = s, !0;
    const m = er(n) && _1(a) ? Number(a) < n.length : Vr(n, a), g = Reflect.set(n, a, s, f);
    return n === lr(f) && (m ? Ed(s, o) && Fl(n, "set", a, s, o) : Fl(n, "add", a, s)), g;
  };
}
function uA(t, e) {
  const n = Vr(t, e), a = t[e], s = Reflect.deleteProperty(t, e);
  return s && n && Fl(t, "delete", e, void 0, a), s;
}
function cA(t, e) {
  const n = Reflect.has(t, e);
  return (!y1(e) || !BE.has(e)) && Bo(t, "has", e), n;
}
function hA(t) {
  return Bo(t, "iterate", er(t) ? "length" : Fc), Reflect.ownKeys(t);
}
const UE = {
  get: tA,
  set: sA,
  deleteProperty: uA,
  has: cA,
  ownKeys: hA
}, jE = {
  get: nA,
  set(t, e) {
    return process.env.NODE_ENV !== "production" && yg(`Set operation on key "${String(e)}" failed: target is readonly.`, t), !0;
  },
  deleteProperty(t, e) {
    return process.env.NODE_ENV !== "production" && yg(`Delete operation on key "${String(e)}" failed: target is readonly.`, t), !0;
  }
}, fA = /* @__PURE__ */ Wn({}, UE, {
  get: rA,
  set: lA
}), pA = /* @__PURE__ */ Wn({}, jE, {
  get: iA
}), b1 = (t) => t, sv = (t) => Reflect.getPrototypeOf(t);
function dy(t, e, n = !1, a = !1) {
  t = t.__v_raw;
  const s = lr(t), f = lr(e);
  n || (e !== f && Bo(s, "get", e), Bo(s, "get", f));
  const { has: o } = sv(s), m = a ? b1 : n ? w1 : Td;
  if (o.call(s, e))
    return m(t.get(e));
  if (o.call(s, f))
    return m(t.get(f));
  t !== s && t.get(e);
}
function my(t, e = !1) {
  const n = this.__v_raw, a = lr(n), s = lr(t);
  return e || (t !== s && Bo(a, "has", t), Bo(a, "has", s)), t === s ? n.has(t) : n.has(t) || n.has(s);
}
function yy(t, e = !1) {
  return t = t.__v_raw, !e && Bo(lr(t), "iterate", Fc), Reflect.get(t, "size", t);
}
function Nb(t) {
  t = lr(t);
  const e = lr(this);
  return sv(e).has.call(e, t) || (e.add(t), Fl(e, "add", t, t)), this;
}
function Rb(t, e) {
  e = lr(e);
  const n = lr(this), { has: a, get: s } = sv(n);
  let f = a.call(n, t);
  f ? process.env.NODE_ENV !== "production" && GE(n, a, t) : (t = lr(t), f = a.call(n, t));
  const o = s.call(n, t);
  return n.set(t, e), f ? Ed(e, o) && Fl(n, "set", t, e, o) : Fl(n, "add", t, e), this;
}
function zb(t) {
  const e = lr(this), { has: n, get: a } = sv(e);
  let s = n.call(e, t);
  s ? process.env.NODE_ENV !== "production" && GE(e, n, t) : (t = lr(t), s = n.call(e, t));
  const f = a ? a.call(e, t) : void 0, o = e.delete(t);
  return s && Fl(e, "delete", t, void 0, f), o;
}
function Fb() {
  const t = lr(this), e = t.size !== 0, n = process.env.NODE_ENV !== "production" ? zc(t) ? new Map(t) : new Set(t) : void 0, a = t.clear();
  return e && Fl(t, "clear", void 0, void 0, n), a;
}
function gy(t, e) {
  return function(a, s) {
    const f = this, o = f.__v_raw, m = lr(o), g = e ? b1 : t ? w1 : Td;
    return !t && Bo(m, "iterate", Fc), o.forEach((b, T) => a.call(s, g(b), g(T), f));
  };
}
function vy(t, e, n) {
  return function(...a) {
    const s = this.__v_raw, f = lr(s), o = zc(f), m = t === "entries" || t === Symbol.iterator && o, g = t === "keys" && o, b = s[t](...a), T = n ? b1 : e ? w1 : Td;
    return !e && Bo(f, "iterate", g ? _0 : Fc), {
      next() {
        const { value: M, done: I } = b.next();
        return I ? { value: M, done: I } : {
          value: m ? [T(M[0]), T(M[1])] : T(M),
          done: I
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function uu(t) {
  return function(...e) {
    if (process.env.NODE_ENV !== "production") {
      const n = e[0] ? `on key "${e[0]}" ` : "";
      console.warn(`${$c(t)} operation ${n}failed: target is readonly.`, lr(this));
    }
    return t === "delete" ? !1 : this;
  };
}
function dA() {
  const t = {
    get(f) {
      return dy(this, f);
    },
    get size() {
      return yy(this);
    },
    has: my,
    add: Nb,
    set: Rb,
    delete: zb,
    clear: Fb,
    forEach: gy(!1, !1)
  }, e = {
    get(f) {
      return dy(this, f, !1, !0);
    },
    get size() {
      return yy(this);
    },
    has: my,
    add: Nb,
    set: Rb,
    delete: zb,
    clear: Fb,
    forEach: gy(!1, !0)
  }, n = {
    get(f) {
      return dy(this, f, !0);
    },
    get size() {
      return yy(this, !0);
    },
    has(f) {
      return my.call(this, f, !0);
    },
    add: uu("add"),
    set: uu("set"),
    delete: uu("delete"),
    clear: uu("clear"),
    forEach: gy(!0, !1)
  }, a = {
    get(f) {
      return dy(this, f, !0, !0);
    },
    get size() {
      return yy(this, !0);
    },
    has(f) {
      return my.call(this, f, !0);
    },
    add: uu("add"),
    set: uu("set"),
    delete: uu("delete"),
    clear: uu("clear"),
    forEach: gy(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((f) => {
    t[f] = vy(f, !1, !1), n[f] = vy(f, !0, !1), e[f] = vy(f, !1, !0), a[f] = vy(f, !0, !0);
  }), [
    t,
    n,
    e,
    a
  ];
}
const [mA, yA, gA, vA] = /* @__PURE__ */ dA();
function lv(t, e) {
  const n = e ? t ? vA : gA : t ? yA : mA;
  return (a, s, f) => s === "__v_isReactive" ? !t : s === "__v_isReadonly" ? t : s === "__v_raw" ? a : Reflect.get(Vr(n, s) && s in a ? n : a, s, f);
}
const _A = {
  get: /* @__PURE__ */ lv(!1, !1)
}, xA = {
  get: /* @__PURE__ */ lv(!1, !0)
}, bA = {
  get: /* @__PURE__ */ lv(!0, !1)
}, wA = {
  get: /* @__PURE__ */ lv(!0, !0)
};
function GE(t, e, n) {
  const a = lr(n);
  if (a !== n && e.call(t, a)) {
    const s = v1(t);
    console.warn(`Reactive ${s} contains both the raw and reactive versions of the same object${s === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const qE = /* @__PURE__ */ new WeakMap(), $E = /* @__PURE__ */ new WeakMap(), WE = /* @__PURE__ */ new WeakMap(), HE = /* @__PURE__ */ new WeakMap();
function EA(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function SA(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : EA(v1(t));
}
function uv(t) {
  return ku(t) ? t : cv(t, !1, UE, _A, qE);
}
function TA(t) {
  return cv(t, !1, fA, xA, $E);
}
function ZE(t) {
  return cv(t, !0, jE, bA, WE);
}
function hf(t) {
  return cv(t, !0, pA, wA, HE);
}
function cv(t, e, n, a, s) {
  if (!fn(t))
    return process.env.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(t)}`), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  const f = s.get(t);
  if (f)
    return f;
  const o = SA(t);
  if (o === 0)
    return t;
  const m = new Proxy(t, o === 2 ? a : n);
  return s.set(t, m), m;
}
function ss(t) {
  return ku(t) ? ss(t.__v_raw) : !!(t && t.__v_isReactive);
}
function ku(t) {
  return !!(t && t.__v_isReadonly);
}
function vg(t) {
  return !!(t && t.__v_isShallow);
}
function _g(t) {
  return ss(t) || ku(t);
}
function lr(t) {
  const e = t && t.__v_raw;
  return e ? lr(e) : t;
}
function ts(t) {
  return mg(t, "__v_skip", !0), t;
}
const Td = (t) => fn(t) ? uv(t) : t, w1 = (t) => fn(t) ? ZE(t) : t;
function XE(t) {
  Tu && No && (t = lr(t), process.env.NODE_ENV !== "production" ? x0(t.dep || (t.dep = Sd()), {
    target: t,
    type: "get",
    key: "value"
  }) : x0(t.dep || (t.dep = Sd())));
}
function KE(t, e) {
  t = lr(t);
  const n = t.dep;
  n && (process.env.NODE_ENV !== "production" ? cf(n, {
    target: t,
    type: "set",
    key: "value",
    newValue: e
  }) : cf(n));
}
function hn(t) {
  return !!(t && t.__v_isRef === !0);
}
function Hr(t) {
  return YE(t, !1);
}
function Fn(t) {
  return YE(t, !0);
}
function YE(t, e) {
  return hn(t) ? t : new MA(t, e);
}
class MA {
  constructor(e, n) {
    this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : lr(e), this._value = n ? e : Td(e);
  }
  get value() {
    return XE(this), this._value;
  }
  set value(e) {
    const n = this.__v_isShallow || vg(e) || ku(e);
    e = n ? e : lr(e), Ed(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : Td(e), KE(this, e));
  }
}
function le(t) {
  return hn(t) ? t.value : t;
}
const IA = {
  get: (t, e, n) => le(Reflect.get(t, e, n)),
  set: (t, e, n, a) => {
    const s = t[e];
    return hn(s) && !hn(n) ? (s.value = n, !0) : Reflect.set(t, e, n, a);
  }
};
function JE(t) {
  return ss(t) ? t : new Proxy(t, IA);
}
function Bb(t) {
  process.env.NODE_ENV !== "production" && !_g(t) && console.warn("toRefs() expects a reactive object but received a plain one.");
  const e = er(t) ? new Array(t.length) : {};
  for (const n in t)
    e[n] = ld(t, n);
  return e;
}
class OA {
  constructor(e, n, a) {
    this._object = e, this._key = n, this._defaultValue = a, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return QC(lr(this._object), this._key);
  }
}
function ld(t, e, n) {
  const a = t[e];
  return hn(a) ? a : new OA(t, e, n);
}
var QE;
class CA {
  constructor(e, n, a, s) {
    this._setter = n, this.dep = void 0, this.__v_isRef = !0, this[QE] = !1, this._dirty = !0, this.effect = new x1(e, () => {
      this._dirty || (this._dirty = !0, KE(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = a;
  }
  get value() {
    const e = lr(this);
    return XE(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
QE = "__v_isReadonly";
function AA(t, e, n = !1) {
  let a, s;
  const f = dr(t);
  f ? (a = t, s = process.env.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : ao) : (a = t.get, s = t.set);
  const o = new CA(a, s, f || !s, n);
  return process.env.NODE_ENV !== "production" && e && !n && (o.effect.onTrack = e.onTrack, o.effect.onTrigger = e.onTrigger), o;
}
const Bc = [];
function Zy(t) {
  Bc.push(t);
}
function Xy() {
  Bc.pop();
}
function at(t, ...e) {
  if (process.env.NODE_ENV === "production")
    return;
  Kc();
  const n = Bc.length ? Bc[Bc.length - 1].component : null, a = n && n.appContext.config.warnHandler, s = PA();
  if (a)
    Dl(a, n, 11, [
      t + e.join(""),
      n && n.proxy,
      s.map(({ vnode: f }) => `at <${vv(n, f.type)}>`).join(`
`),
      s
    ]);
  else {
    const f = [`[Vue warn]: ${t}`, ...e];
    s.length && f.push(`
`, ...kA(s)), console.warn(...f);
  }
  Yc();
}
function PA() {
  let t = Bc[Bc.length - 1];
  if (!t)
    return [];
  const e = [];
  for (; t; ) {
    const n = e[0];
    n && n.vnode === t ? n.recurseCount++ : e.push({
      vnode: t,
      recurseCount: 0
    });
    const a = t.component && t.component.parent;
    t = a && a.vnode;
  }
  return e;
}
function kA(t) {
  const e = [];
  return t.forEach((n, a) => {
    e.push(...a === 0 ? [] : [`
`], ...LA(n));
  }), e;
}
function LA({ vnode: t, recurseCount: e }) {
  const n = e > 0 ? `... (${e} recursive calls)` : "", a = t.component ? t.component.parent == null : !1, s = ` at <${vv(t.component, t.type, a)}`, f = ">" + n;
  return t.props ? [s, ...DA(t.props), f] : [s + f];
}
function DA(t) {
  const e = [], n = Object.keys(t);
  return n.slice(0, 3).forEach((a) => {
    e.push(...eS(a, t[a]));
  }), n.length > 3 && e.push(" ..."), e;
}
function eS(t, e, n) {
  return Hn(e) ? (e = JSON.stringify(e), n ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? n ? e : [`${t}=${e}`] : hn(e) ? (e = eS(t, lr(e.value), !0), n ? e : [`${t}=Ref<`, e, ">"]) : dr(e) ? [`${t}=fn${e.name ? `<${e.name}>` : ""}`] : (e = lr(e), n ? e : [`${t}=`, e]);
}
function NA(t, e) {
  process.env.NODE_ENV !== "production" && t !== void 0 && (typeof t != "number" ? at(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && at(`${e} is NaN - the duration expression might be incorrect.`));
}
const E1 = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function Dl(t, e, n, a) {
  let s;
  try {
    s = a ? t(...a) : t();
  } catch (f) {
    hv(f, e, n);
  }
  return s;
}
function La(t, e, n, a) {
  if (dr(t)) {
    const f = Dl(t, e, n, a);
    return f && g1(f) && f.catch((o) => {
      hv(o, e, n);
    }), f;
  }
  const s = [];
  for (let f = 0; f < t.length; f++)
    s.push(La(t[f], e, n, a));
  return s;
}
function hv(t, e, n, a = !0) {
  const s = e ? e.vnode : null;
  if (e) {
    let f = e.parent;
    const o = e.proxy, m = process.env.NODE_ENV !== "production" ? E1[n] : n;
    for (; f; ) {
      const b = f.ec;
      if (b) {
        for (let T = 0; T < b.length; T++)
          if (b[T](t, o, m) === !1)
            return;
      }
      f = f.parent;
    }
    const g = e.appContext.config.errorHandler;
    if (g) {
      Dl(g, null, 10, [t, o, m]);
      return;
    }
  }
  RA(t, n, s, a);
}
function RA(t, e, n, a = !0) {
  if (process.env.NODE_ENV !== "production") {
    const s = E1[e];
    if (n && Zy(n), at(`Unhandled error${s ? ` during execution of ${s}` : ""}`), n && Xy(), a)
      throw t;
    console.error(t);
  } else
    console.error(t);
}
let Md = !1, b0 = !1;
const xo = [];
let Bs = 0;
const _f = [];
let zs = null, yu = 0;
const tS = /* @__PURE__ */ Promise.resolve();
let S1 = null;
const zA = 100;
function xg(t) {
  const e = S1 || tS;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function FA(t) {
  let e = Bs + 1, n = xo.length;
  for (; e < n; ) {
    const a = e + n >>> 1;
    Id(xo[a]) < t ? e = a + 1 : n = a;
  }
  return e;
}
function fv(t) {
  (!xo.length || !xo.includes(t, Md && t.allowRecurse ? Bs + 1 : Bs)) && (t.id == null ? xo.push(t) : xo.splice(FA(t.id), 0, t), rS());
}
function rS() {
  !Md && !b0 && (b0 = !0, S1 = tS.then(oS));
}
function BA(t) {
  const e = xo.indexOf(t);
  e > Bs && xo.splice(e, 1);
}
function nS(t) {
  er(t) ? _f.push(...t) : (!zs || !zs.includes(t, t.allowRecurse ? yu + 1 : yu)) && _f.push(t), rS();
}
function Vb(t, e = Md ? Bs + 1 : 0) {
  for (process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()); e < xo.length; e++) {
    const n = xo[e];
    if (n && n.pre) {
      if (process.env.NODE_ENV !== "production" && T1(t, n))
        continue;
      xo.splice(e, 1), e--, n();
    }
  }
}
function iS(t) {
  if (_f.length) {
    const e = [...new Set(_f)];
    if (_f.length = 0, zs) {
      zs.push(...e);
      return;
    }
    for (zs = e, process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), zs.sort((n, a) => Id(n) - Id(a)), yu = 0; yu < zs.length; yu++)
      process.env.NODE_ENV !== "production" && T1(t, zs[yu]) || zs[yu]();
    zs = null, yu = 0;
  }
}
const Id = (t) => t.id == null ? 1 / 0 : t.id, VA = (t, e) => {
  const n = Id(t) - Id(e);
  if (n === 0) {
    if (t.pre && !e.pre)
      return -1;
    if (e.pre && !t.pre)
      return 1;
  }
  return n;
};
function oS(t) {
  b0 = !1, Md = !0, process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), xo.sort(VA);
  const e = process.env.NODE_ENV !== "production" ? (n) => T1(t, n) : ao;
  try {
    for (Bs = 0; Bs < xo.length; Bs++) {
      const n = xo[Bs];
      if (n && n.active !== !1) {
        if (process.env.NODE_ENV !== "production" && e(n))
          continue;
        Dl(n, null, 14);
      }
    }
  } finally {
    Bs = 0, xo.length = 0, iS(t), Md = !1, S1 = null, (xo.length || _f.length) && oS(t);
  }
}
function T1(t, e) {
  if (!t.has(e))
    t.set(e, 1);
  else {
    const n = t.get(e);
    if (n > zA) {
      const a = e.ownerInstance, s = a && k1(a.type);
      return at(`Maximum recursive updates exceeded${s ? ` in component <${s}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`), !0;
    } else
      t.set(e, n + 1);
  }
}
let Mu = !1;
const af = /* @__PURE__ */ new Set();
process.env.NODE_ENV !== "production" && (kE().__VUE_HMR_RUNTIME__ = {
  createRecord: T_(aS),
  rerender: T_(GA),
  reload: T_(qA)
});
const Wc = /* @__PURE__ */ new Map();
function UA(t) {
  const e = t.type.__hmrId;
  let n = Wc.get(e);
  n || (aS(e, t.type), n = Wc.get(e)), n.instances.add(t);
}
function jA(t) {
  Wc.get(t.type.__hmrId).instances.delete(t);
}
function aS(t, e) {
  return Wc.has(t) ? !1 : (Wc.set(t, {
    initialDef: ud(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function ud(t) {
  return VS(t) ? t.__vccOpts : t;
}
function GA(t, e) {
  const n = Wc.get(t);
  !n || (n.initialDef.render = e, [...n.instances].forEach((a) => {
    e && (a.render = e, ud(a.type).render = e), a.renderCache = [], Mu = !0, a.update(), Mu = !1;
  }));
}
function qA(t, e) {
  const n = Wc.get(t);
  if (!n)
    return;
  e = ud(e), Ub(n.initialDef, e);
  const a = [...n.instances];
  for (const s of a) {
    const f = ud(s.type);
    af.has(f) || (f !== n.initialDef && Ub(f, e), af.add(f)), s.appContext.optionsCache.delete(s.type), s.ceReload ? (af.add(f), s.ceReload(e.styles), af.delete(f)) : s.parent ? fv(s.parent.update) : s.appContext.reload ? s.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
  }
  nS(() => {
    for (const s of a)
      af.delete(ud(s.type));
  });
}
function Ub(t, e) {
  Wn(t, e);
  for (const n in t)
    n !== "__file" && !(n in e) && delete t[n];
}
function T_(t) {
  return (e, n) => {
    try {
      return t(e, n);
    } catch (a) {
      console.error(a), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.");
    }
  };
}
let Vs, Yp = [], w0 = !1;
function Fd(t, ...e) {
  Vs ? Vs.emit(t, ...e) : w0 || Yp.push({ event: t, args: e });
}
function sS(t, e) {
  var n, a;
  Vs = t, Vs ? (Vs.enabled = !0, Yp.forEach(({ event: s, args: f }) => Vs.emit(s, ...f)), Yp = []) : typeof window < "u" && window.HTMLElement && !(!((a = (n = window.navigator) === null || n === void 0 ? void 0 : n.userAgent) === null || a === void 0) && a.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((f) => {
    sS(f, e);
  }), setTimeout(() => {
    Vs || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, w0 = !0, Yp = []);
  }, 3e3)) : (w0 = !0, Yp = []);
}
function $A(t, e) {
  Fd("app:init", t, e, {
    Fragment: un,
    Text: Ud,
    Comment: Xi,
    Static: Ky
  });
}
function WA(t) {
  Fd("app:unmount", t);
}
const HA = /* @__PURE__ */ M1("component:added"), lS = /* @__PURE__ */ M1("component:updated"), ZA = /* @__PURE__ */ M1("component:removed"), XA = (t) => {
  Vs && typeof Vs.cleanupBuffer == "function" && !Vs.cleanupBuffer(t) && ZA(t);
};
function M1(t) {
  return (e) => {
    Fd(t, e.appContext.app, e.uid, e.parent ? e.parent.uid : void 0, e);
  };
}
const KA = /* @__PURE__ */ uS("perf:start"), YA = /* @__PURE__ */ uS("perf:end");
function uS(t) {
  return (e, n, a) => {
    Fd(t, e.appContext.app, e.uid, e, n, a);
  };
}
function JA(t, e, n) {
  Fd("component:emit", t.appContext.app, t, e, n);
}
function QA(t, e, ...n) {
  if (t.isUnmounted)
    return;
  const a = t.vnode.props || wn;
  if (process.env.NODE_ENV !== "production") {
    const { emitsOptions: T, propsOptions: [M] } = t;
    if (T)
      if (!(e in T))
        (!M || !(Oc(e) in M)) && at(`Component emitted event "${e}" but it is neither declared in the emits option nor as an "${Oc(e)}" prop.`);
      else {
        const I = T[e];
        dr(I) && (I(...n) || at(`Invalid event arguments: event validation failed for event "${e}".`));
      }
  }
  let s = n;
  const f = e.startsWith("update:"), o = f && e.slice(7);
  if (o && o in a) {
    const T = `${o === "modelValue" ? "model" : o}Modifiers`, { number: M, trim: I } = a[T] || wn;
    I && (s = n.map((A) => Hn(A) ? A.trim() : A)), M && (s = n.map(ZC));
  }
  if (process.env.NODE_ENV !== "production" && JA(t, e, s), process.env.NODE_ENV !== "production") {
    const T = e.toLowerCase();
    T !== e && a[Oc(T)] && at(`Event "${T}" is emitted in component ${vv(t, t.type)} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${ta(e)}" instead of "${e}".`);
  }
  let m, g = a[m = Oc(e)] || a[m = Oc(ya(e))];
  !g && f && (g = a[m = Oc(ta(e))]), g && La(g, t, 6, s);
  const b = a[m + "Once"];
  if (b) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[m])
      return;
    t.emitted[m] = !0, La(b, t, 6, s);
  }
}
function cS(t, e, n = !1) {
  const a = e.emitsCache, s = a.get(t);
  if (s !== void 0)
    return s;
  const f = t.emits;
  let o = {}, m = !1;
  if (!dr(t)) {
    const g = (b) => {
      const T = cS(b, e, !0);
      T && (m = !0, Wn(o, T));
    };
    !n && e.mixins.length && e.mixins.forEach(g), t.extends && g(t.extends), t.mixins && t.mixins.forEach(g);
  }
  return !f && !m ? (fn(t) && a.set(t, null), null) : (er(f) ? f.forEach((g) => o[g] = null) : Wn(o, f), fn(t) && a.set(t, o), o);
}
function pv(t, e) {
  return !t || !zd(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Vr(t, e[0].toLowerCase() + e.slice(1)) || Vr(t, ta(e)) || Vr(t, e));
}
let zi = null, hS = null;
function bg(t) {
  const e = zi;
  return zi = t, hS = t && t.type.__scopeId || null, e;
}
function Bd(t, e = zi, n) {
  if (!e || t._n)
    return t;
  const a = (...s) => {
    a._d && tw(-1);
    const f = bg(e);
    let o;
    try {
      o = t(...s);
    } finally {
      bg(f), a._d && tw(1);
    }
    return process.env.NODE_ENV !== "production" && lS(e), o;
  };
  return a._n = !0, a._c = !0, a._d = !0, a;
}
let E0 = !1;
function wg() {
  E0 = !0;
}
function M_(t) {
  const { type: e, vnode: n, proxy: a, withProxy: s, props: f, propsOptions: [o], slots: m, attrs: g, emit: b, render: T, renderCache: M, data: I, setupState: A, ctx: z, inheritAttrs: V } = t;
  let Z, X;
  const Y = bg(t);
  process.env.NODE_ENV !== "production" && (E0 = !1);
  try {
    if (n.shapeFlag & 4) {
      const Ie = s || a;
      Z = rs(T.call(Ie, Ie, M, f, A, I, z)), X = g;
    } else {
      const Ie = e;
      process.env.NODE_ENV !== "production" && g === f && wg(), Z = rs(Ie.length > 1 ? Ie(f, process.env.NODE_ENV !== "production" ? {
        get attrs() {
          return wg(), g;
        },
        slots: m,
        emit: b
      } : { attrs: g, slots: m, emit: b }) : Ie(f, null)), X = e.props ? g : tP(g);
    }
  } catch (Ie) {
    fd.length = 0, hv(Ie, t, 1), Z = Gt(Xi);
  }
  let de = Z, ye;
  if (process.env.NODE_ENV !== "production" && Z.patchFlag > 0 && Z.patchFlag & 2048 && ([de, ye] = eP(Z)), X && V !== !1) {
    const Ie = Object.keys(X), { shapeFlag: Be } = de;
    if (Ie.length) {
      if (Be & 7)
        o && Ie.some(dg) && (X = rP(X, o)), de = Xs(de, X);
      else if (process.env.NODE_ENV !== "production" && !E0 && de.type !== Xi) {
        const De = Object.keys(g), Re = [], Ee = [];
        for (let ze = 0, rt = De.length; ze < rt; ze++) {
          const Ze = De[ze];
          zd(Ze) ? dg(Ze) || Re.push(Ze[2].toLowerCase() + Ze.slice(3)) : Ee.push(Ze);
        }
        Ee.length && at(`Extraneous non-props attributes (${Ee.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`), Re.length && at(`Extraneous non-emits event listeners (${Re.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
      }
    }
  }
  return n.dirs && (process.env.NODE_ENV !== "production" && !jb(de) && at("Runtime directive used on component with non-element root node. The directives will not function as intended."), de = Xs(de), de.dirs = de.dirs ? de.dirs.concat(n.dirs) : n.dirs), n.transition && (process.env.NODE_ENV !== "production" && !jb(de) && at("Component inside <Transition> renders non-element root node that cannot be animated."), de.transition = n.transition), process.env.NODE_ENV !== "production" && ye ? ye(de) : Z = de, bg(Y), Z;
}
const eP = (t) => {
  const e = t.children, n = t.dynamicChildren, a = fS(e);
  if (!a)
    return [t, void 0];
  const s = e.indexOf(a), f = n ? n.indexOf(a) : -1, o = (m) => {
    e[s] = m, n && (f > -1 ? n[f] = m : m.patchFlag > 0 && (t.dynamicChildren = [...n, m]));
  };
  return [rs(a), o];
};
function fS(t) {
  let e;
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    if (Af(a)) {
      if (a.type !== Xi || a.children === "v-if") {
        if (e)
          return;
        e = a;
      }
    } else
      return;
  }
  return e;
}
const tP = (t) => {
  let e;
  for (const n in t)
    (n === "class" || n === "style" || zd(n)) && ((e || (e = {}))[n] = t[n]);
  return e;
}, rP = (t, e) => {
  const n = {};
  for (const a in t)
    (!dg(a) || !(a.slice(9) in e)) && (n[a] = t[a]);
  return n;
}, jb = (t) => t.shapeFlag & 7 || t.type === Xi;
function nP(t, e, n) {
  const { props: a, children: s, component: f } = t, { props: o, children: m, patchFlag: g } = e, b = f.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (s || m) && Mu || e.dirs || e.transition)
    return !0;
  if (n && g >= 0) {
    if (g & 1024)
      return !0;
    if (g & 16)
      return a ? Gb(a, o, b) : !!o;
    if (g & 8) {
      const T = e.dynamicProps;
      for (let M = 0; M < T.length; M++) {
        const I = T[M];
        if (o[I] !== a[I] && !pv(b, I))
          return !0;
      }
    }
  } else
    return (s || m) && (!m || !m.$stable) ? !0 : a === o ? !1 : a ? o ? Gb(a, o, b) : !0 : !!o;
  return !1;
}
function Gb(t, e, n) {
  const a = Object.keys(e);
  if (a.length !== Object.keys(t).length)
    return !0;
  for (let s = 0; s < a.length; s++) {
    const f = a[s];
    if (e[f] !== t[f] && !pv(n, f))
      return !0;
  }
  return !1;
}
function iP({ vnode: t, parent: e }, n) {
  for (; e && e.subTree === t; )
    (t = e.vnode).el = n, e = e.parent;
}
const oP = (t) => t.__isSuspense;
function aP(t, e) {
  e && e.pendingBranch ? er(t) ? e.effects.push(...t) : e.effects.push(t) : nS(t);
}
function pS(t, e) {
  if (!pi)
    process.env.NODE_ENV !== "production" && at("provide() can only be used inside setup().");
  else {
    let n = pi.provides;
    const a = pi.parent && pi.parent.provides;
    a === n && (n = pi.provides = Object.create(a)), n[t] = e;
  }
}
function xf(t, e, n = !1) {
  const a = pi || zi;
  if (a) {
    const s = a.parent == null ? a.vnode.appContext && a.vnode.appContext.provides : a.parent.provides;
    if (s && t in s)
      return s[t];
    if (arguments.length > 1)
      return n && dr(e) ? e.call(a.proxy) : e;
    process.env.NODE_ENV !== "production" && at(`injection "${String(t)}" not found.`);
  } else
    process.env.NODE_ENV !== "production" && at("inject() can only be used inside setup() or functional components.");
}
function Na(t, e) {
  return I1(t, null, e);
}
const _y = {};
function Bn(t, e, n) {
  return process.env.NODE_ENV !== "production" && !dr(e) && at("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), I1(t, e, n);
}
function I1(t, e, { immediate: n, deep: a, flush: s, onTrack: f, onTrigger: o } = wn) {
  process.env.NODE_ENV !== "production" && !e && (n !== void 0 && at('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), a !== void 0 && at('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));
  const m = (ye) => {
    at("Invalid watch source: ", ye, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.");
  }, g = NE() === (pi == null ? void 0 : pi.scope) ? pi : null;
  let b, T = !1, M = !1;
  if (hn(t) ? (b = () => t.value, T = vg(t)) : ss(t) ? (b = () => t, a = !0) : er(t) ? (M = !0, T = t.some((ye) => ss(ye) || vg(ye)), b = () => t.map((ye) => {
    if (hn(ye))
      return ye.value;
    if (ss(ye))
      return Rc(ye);
    if (dr(ye))
      return Dl(ye, g, 2);
    process.env.NODE_ENV !== "production" && m(ye);
  })) : dr(t) ? e ? b = () => Dl(t, g, 2) : b = () => {
    if (!(g && g.isUnmounted))
      return I && I(), La(t, g, 3, [A]);
  } : (b = ao, process.env.NODE_ENV !== "production" && m(t)), e && a) {
    const ye = b;
    b = () => Rc(ye());
  }
  let I, A = (ye) => {
    I = Y.onStop = () => {
      Dl(ye, g, 4);
    };
  }, z;
  if (Cd)
    if (A = ao, e ? n && La(e, g, 3, [
      b(),
      M ? [] : void 0,
      A
    ]) : b(), s === "sync") {
      const ye = mk();
      z = ye.__watcherHandles || (ye.__watcherHandles = []);
    } else
      return ao;
  let V = M ? new Array(t.length).fill(_y) : _y;
  const Z = () => {
    if (!!Y.active)
      if (e) {
        const ye = Y.run();
        (a || T || (M ? ye.some((Ie, Be) => Ed(Ie, V[Be])) : Ed(ye, V))) && (I && I(), La(e, g, 3, [
          ye,
          V === _y ? void 0 : M && V[0] === _y ? [] : V,
          A
        ]), V = ye);
      } else
        Y.run();
  };
  Z.allowRecurse = !!e;
  let X;
  s === "sync" ? X = Z : s === "post" ? X = () => ea(Z, g && g.suspense) : (Z.pre = !0, g && (Z.id = g.uid), X = () => fv(Z));
  const Y = new x1(b, X);
  process.env.NODE_ENV !== "production" && (Y.onTrack = f, Y.onTrigger = o), e ? n ? Z() : V = Y.run() : s === "post" ? ea(Y.run.bind(Y), g && g.suspense) : Y.run();
  const de = () => {
    Y.stop(), g && g.scope && m1(g.scope.effects, Y);
  };
  return z && z.push(de), de;
}
function sP(t, e, n) {
  const a = this.proxy, s = Hn(t) ? t.includes(".") ? dS(a, t) : () => a[t] : t.bind(a, a);
  let f;
  dr(e) ? f = e : (f = e.handler, n = e);
  const o = pi;
  Pf(this);
  const m = I1(s, f.bind(a), n);
  return o ? Pf(o) : Uc(), m;
}
function dS(t, e) {
  const n = e.split(".");
  return () => {
    let a = t;
    for (let s = 0; s < n.length && a; s++)
      a = a[n[s]];
    return a;
  };
}
function Rc(t, e) {
  if (!fn(t) || t.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(t)))
    return t;
  if (e.add(t), hn(t))
    Rc(t.value, e);
  else if (er(t))
    for (let n = 0; n < t.length; n++)
      Rc(t[n], e);
  else if (CE(t) || zc(t))
    t.forEach((n) => {
      Rc(n, e);
    });
  else if (PE(t))
    for (const n in t)
      Rc(t[n], e);
  return t;
}
function lP() {
  const t = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return va(() => {
    t.isMounted = !0;
  }), _S(() => {
    t.isUnmounting = !0;
  }), t;
}
const Ma = [Function, Array], uP = {
  name: "BaseTransition",
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Ma,
    onEnter: Ma,
    onAfterEnter: Ma,
    onEnterCancelled: Ma,
    onBeforeLeave: Ma,
    onLeave: Ma,
    onAfterLeave: Ma,
    onLeaveCancelled: Ma,
    onBeforeAppear: Ma,
    onAppear: Ma,
    onAfterAppear: Ma,
    onAppearCancelled: Ma
  },
  setup(t, { slots: e }) {
    const n = yv(), a = lP();
    let s;
    return () => {
      const f = e.default && gS(e.default(), !0);
      if (!f || !f.length)
        return;
      let o = f[0];
      if (f.length > 1) {
        let V = !1;
        for (const Z of f)
          if (Z.type !== Xi) {
            if (process.env.NODE_ENV !== "production" && V) {
              at("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
              break;
            }
            if (o = Z, V = !0, process.env.NODE_ENV === "production")
              break;
          }
      }
      const m = lr(t), { mode: g } = m;
      if (process.env.NODE_ENV !== "production" && g && g !== "in-out" && g !== "out-in" && g !== "default" && at(`invalid <transition> mode: ${g}`), a.isLeaving)
        return I_(o);
      const b = qb(o);
      if (!b)
        return I_(o);
      const T = S0(b, m, a, n);
      T0(b, T);
      const M = n.subTree, I = M && qb(M);
      let A = !1;
      const { getTransitionKey: z } = b.type;
      if (z) {
        const V = z();
        s === void 0 ? s = V : V !== s && (s = V, A = !0);
      }
      if (I && I.type !== Xi && (!Lc(b, I) || A)) {
        const V = S0(I, m, a, n);
        if (T0(I, V), g === "out-in")
          return a.isLeaving = !0, V.afterLeave = () => {
            a.isLeaving = !1, n.update.active !== !1 && n.update();
          }, I_(o);
        g === "in-out" && b.type !== Xi && (V.delayLeave = (Z, X, Y) => {
          const de = yS(a, I);
          de[String(I.key)] = I, Z._leaveCb = () => {
            X(), Z._leaveCb = void 0, delete T.delayedLeave;
          }, T.delayedLeave = Y;
        });
      }
      return o;
    };
  }
}, mS = uP;
function yS(t, e) {
  const { leavingVNodes: n } = t;
  let a = n.get(e.type);
  return a || (a = /* @__PURE__ */ Object.create(null), n.set(e.type, a)), a;
}
function S0(t, e, n, a) {
  const { appear: s, mode: f, persisted: o = !1, onBeforeEnter: m, onEnter: g, onAfterEnter: b, onEnterCancelled: T, onBeforeLeave: M, onLeave: I, onAfterLeave: A, onLeaveCancelled: z, onBeforeAppear: V, onAppear: Z, onAfterAppear: X, onAppearCancelled: Y } = e, de = String(t.key), ye = yS(n, t), Ie = (Re, Ee) => {
    Re && La(Re, a, 9, Ee);
  }, Be = (Re, Ee) => {
    const ze = Ee[1];
    Ie(Re, Ee), er(Re) ? Re.every((rt) => rt.length <= 1) && ze() : Re.length <= 1 && ze();
  }, De = {
    mode: f,
    persisted: o,
    beforeEnter(Re) {
      let Ee = m;
      if (!n.isMounted)
        if (s)
          Ee = V || m;
        else
          return;
      Re._leaveCb && Re._leaveCb(!0);
      const ze = ye[de];
      ze && Lc(t, ze) && ze.el._leaveCb && ze.el._leaveCb(), Ie(Ee, [Re]);
    },
    enter(Re) {
      let Ee = g, ze = b, rt = T;
      if (!n.isMounted)
        if (s)
          Ee = Z || g, ze = X || b, rt = Y || T;
        else
          return;
      let Ze = !1;
      const yt = Re._enterCb = (xe) => {
        Ze || (Ze = !0, xe ? Ie(rt, [Re]) : Ie(ze, [Re]), De.delayedLeave && De.delayedLeave(), Re._enterCb = void 0);
      };
      Ee ? Be(Ee, [Re, yt]) : yt();
    },
    leave(Re, Ee) {
      const ze = String(t.key);
      if (Re._enterCb && Re._enterCb(!0), n.isUnmounting)
        return Ee();
      Ie(M, [Re]);
      let rt = !1;
      const Ze = Re._leaveCb = (yt) => {
        rt || (rt = !0, Ee(), yt ? Ie(z, [Re]) : Ie(A, [Re]), Re._leaveCb = void 0, ye[ze] === t && delete ye[ze]);
      };
      ye[ze] = t, I ? Be(I, [Re, Ze]) : Ze();
    },
    clone(Re) {
      return S0(Re, e, n, a);
    }
  };
  return De;
}
function I_(t) {
  if (Vd(t))
    return t = Xs(t), t.children = null, t;
}
function qb(t) {
  return Vd(t) ? t.children ? t.children[0] : void 0 : t;
}
function T0(t, e) {
  t.shapeFlag & 6 && t.component ? T0(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
}
function gS(t, e = !1, n) {
  let a = [], s = 0;
  for (let f = 0; f < t.length; f++) {
    let o = t[f];
    const m = n == null ? o.key : String(n) + String(o.key != null ? o.key : f);
    o.type === un ? (o.patchFlag & 128 && s++, a = a.concat(gS(o.children, e, m))) : (e || o.type !== Xi) && a.push(m != null ? Xs(o, { key: m }) : o);
  }
  if (s > 1)
    for (let f = 0; f < a.length; f++)
      a[f].patchFlag = -2;
  return a;
}
function ur(t) {
  return dr(t) ? { setup: t, name: t.name } : t;
}
const cd = (t) => !!t.type.__asyncLoader, Vd = (t) => t.type.__isKeepAlive;
function cP(t, e) {
  vS(t, "a", e);
}
function hP(t, e) {
  vS(t, "da", e);
}
function vS(t, e, n = pi) {
  const a = t.__wdc || (t.__wdc = () => {
    let s = n;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return t();
  });
  if (dv(e, a, n), n) {
    let s = n.parent;
    for (; s && s.parent; )
      Vd(s.parent.vnode) && fP(a, e, n, s), s = s.parent;
  }
}
function fP(t, e, n, a) {
  const s = dv(e, t, a, !0);
  Jc(() => {
    m1(a[e], s);
  }, n);
}
function dv(t, e, n = pi, a = !1) {
  if (n) {
    const s = n[t] || (n[t] = []), f = e.__weh || (e.__weh = (...o) => {
      if (n.isUnmounted)
        return;
      Kc(), Pf(n);
      const m = La(e, n, t, o);
      return Uc(), Yc(), m;
    });
    return a ? s.unshift(f) : s.push(f), f;
  } else if (process.env.NODE_ENV !== "production") {
    const s = Oc(E1[t].replace(/ hook$/, ""));
    at(`${s} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const jl = (t) => (e, n = pi) => (!Cd || t === "sp") && dv(t, (...a) => e(...a), n), pP = jl("bm"), va = jl("m"), dP = jl("bu"), mP = jl("u"), _S = jl("bum"), Jc = jl("um"), yP = jl("sp"), gP = jl("rtg"), vP = jl("rtc");
function _P(t, e = pi) {
  dv("ec", t, e);
}
function xS(t) {
  $C(t) && at("Do not use built-in directive ids as custom directive id: " + t);
}
function $b(t, e) {
  const n = zi;
  if (n === null)
    return process.env.NODE_ENV !== "production" && at("withDirectives can only be used inside render functions."), t;
  const a = gv(n) || n.proxy, s = t.dirs || (t.dirs = []);
  for (let f = 0; f < e.length; f++) {
    let [o, m, g, b = wn] = e[f];
    o && (dr(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Rc(m), s.push({
      dir: o,
      instance: a,
      value: m,
      oldValue: void 0,
      arg: g,
      modifiers: b
    }));
  }
  return t;
}
function vc(t, e, n, a) {
  const s = t.dirs, f = e && e.dirs;
  for (let o = 0; o < s.length; o++) {
    const m = s[o];
    f && (m.oldValue = f[o].value);
    let g = m.dir[a];
    g && (Kc(), La(g, n, 8, [
      t.el,
      m,
      t,
      e
    ]), Yc());
  }
}
const M0 = "components", xP = "directives";
function bP(t, e) {
  return bS(M0, t, !0, e) || t;
}
const wP = Symbol();
function EP(t) {
  return bS(xP, t);
}
function bS(t, e, n = !0, a = !1) {
  const s = zi || pi;
  if (s) {
    const f = s.type;
    if (t === M0) {
      const m = k1(f, !1);
      if (m && (m === e || m === ya(e) || m === $c(ya(e))))
        return f;
    }
    const o = Wb(s[t] || f[t], e) || Wb(s.appContext[t], e);
    if (!o && a)
      return f;
    if (process.env.NODE_ENV !== "production" && n && !o) {
      const m = t === M0 ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      at(`Failed to resolve ${t.slice(0, -1)}: ${e}${m}`);
    }
    return o;
  } else
    process.env.NODE_ENV !== "production" && at(`resolve${$c(t.slice(0, -1))} can only be used in render() or setup().`);
}
function Wb(t, e) {
  return t && (t[e] || t[ya(e)] || t[$c(ya(e))]);
}
function Ra(t, e, n, a) {
  let s;
  const f = n && n[a];
  if (er(t) || Hn(t)) {
    s = new Array(t.length);
    for (let o = 0, m = t.length; o < m; o++)
      s[o] = e(t[o], o, void 0, f && f[o]);
  } else if (typeof t == "number") {
    process.env.NODE_ENV !== "production" && !Number.isInteger(t) && at(`The v-for range expect an integer value but got ${t}.`), s = new Array(t);
    for (let o = 0; o < t; o++)
      s[o] = e(o + 1, o, void 0, f && f[o]);
  } else if (fn(t))
    if (t[Symbol.iterator])
      s = Array.from(t, (o, m) => e(o, m, void 0, f && f[m]));
    else {
      const o = Object.keys(t);
      s = new Array(o.length);
      for (let m = 0, g = o.length; m < g; m++) {
        const b = o[m];
        s[m] = e(t[b], b, m, f && f[m]);
      }
    }
  else
    s = [];
  return n && (n[a] = s), s;
}
function SP(t, e, n = {}, a, s) {
  if (zi.isCE || zi.parent && cd(zi.parent) && zi.parent.isCE)
    return e !== "default" && (n.name = e), Gt("slot", n, a && a());
  let f = t[e];
  process.env.NODE_ENV !== "production" && f && f.length > 1 && (at("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."), f = () => []), f && f._c && (f._d = !1), Ue();
  const o = f && wS(f(n)), m = cn(un, {
    key: n.key || o && o.key || `_${e}`
  }, o || (a ? a() : []), o && t._ === 1 ? 64 : -2);
  return !s && m.scopeId && (m.slotScopeIds = [m.scopeId + "-s"]), f && f._c && (f._d = !0), m;
}
function wS(t) {
  return t.some((e) => Af(e) ? !(e.type === Xi || e.type === un && !wS(e.children)) : !0) ? t : null;
}
const I0 = (t) => t ? FS(t) ? gv(t) || t.proxy : I0(t.parent) : null, Vc = /* @__PURE__ */ Wn(/* @__PURE__ */ Object.create(null), {
  $: (t) => t,
  $el: (t) => t.vnode.el,
  $data: (t) => t.data,
  $props: (t) => process.env.NODE_ENV !== "production" ? hf(t.props) : t.props,
  $attrs: (t) => process.env.NODE_ENV !== "production" ? hf(t.attrs) : t.attrs,
  $slots: (t) => process.env.NODE_ENV !== "production" ? hf(t.slots) : t.slots,
  $refs: (t) => process.env.NODE_ENV !== "production" ? hf(t.refs) : t.refs,
  $parent: (t) => I0(t.parent),
  $root: (t) => I0(t.root),
  $emit: (t) => t.emit,
  $options: (t) => C1(t),
  $forceUpdate: (t) => t.f || (t.f = () => fv(t.update)),
  $nextTick: (t) => t.n || (t.n = xg.bind(t.proxy)),
  $watch: (t) => sP.bind(t)
}), O1 = (t) => t === "_" || t === "$", O_ = (t, e) => t !== wn && !t.__isScriptSetup && Vr(t, e), ES = {
  get({ _: t }, e) {
    const { ctx: n, setupState: a, data: s, props: f, accessCache: o, type: m, appContext: g } = t;
    if (process.env.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let b;
    if (e[0] !== "$") {
      const A = o[e];
      if (A !== void 0)
        switch (A) {
          case 1:
            return a[e];
          case 2:
            return s[e];
          case 4:
            return n[e];
          case 3:
            return f[e];
        }
      else {
        if (O_(a, e))
          return o[e] = 1, a[e];
        if (s !== wn && Vr(s, e))
          return o[e] = 2, s[e];
        if ((b = t.propsOptions[0]) && Vr(b, e))
          return o[e] = 3, f[e];
        if (n !== wn && Vr(n, e))
          return o[e] = 4, n[e];
        O0 && (o[e] = 0);
      }
    }
    const T = Vc[e];
    let M, I;
    if (T)
      return e === "$attrs" && (Bo(t, "get", e), process.env.NODE_ENV !== "production" && wg()), T(t);
    if ((M = m.__cssModules) && (M = M[e]))
      return M;
    if (n !== wn && Vr(n, e))
      return o[e] = 4, n[e];
    if (I = g.config.globalProperties, Vr(I, e))
      return I[e];
    process.env.NODE_ENV !== "production" && zi && (!Hn(e) || e.indexOf("__v") !== 0) && (s !== wn && O1(e[0]) && Vr(s, e) ? at(`Property ${JSON.stringify(e)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`) : t === zi && at(`Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`));
  },
  set({ _: t }, e, n) {
    const { data: a, setupState: s, ctx: f } = t;
    return O_(s, e) ? (s[e] = n, !0) : process.env.NODE_ENV !== "production" && s.__isScriptSetup && Vr(s, e) ? (at(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : a !== wn && Vr(a, e) ? (a[e] = n, !0) : Vr(t.props, e) ? (process.env.NODE_ENV !== "production" && at(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (process.env.NODE_ENV !== "production" && at(`Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`), !1) : (process.env.NODE_ENV !== "production" && e in t.appContext.config.globalProperties ? Object.defineProperty(f, e, {
      enumerable: !0,
      configurable: !0,
      value: n
    }) : f[e] = n, !0);
  },
  has({ _: { data: t, setupState: e, accessCache: n, ctx: a, appContext: s, propsOptions: f } }, o) {
    let m;
    return !!n[o] || t !== wn && Vr(t, o) || O_(e, o) || (m = f[0]) && Vr(m, o) || Vr(a, o) || Vr(Vc, o) || Vr(s.config.globalProperties, o);
  },
  defineProperty(t, e, n) {
    return n.get != null ? t._.accessCache[e] = 0 : Vr(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n);
  }
};
process.env.NODE_ENV !== "production" && (ES.ownKeys = (t) => (at("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."), Reflect.ownKeys(t)));
function TP(t) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => t
  }), Object.keys(Vc).forEach((n) => {
    Object.defineProperty(e, n, {
      configurable: !0,
      enumerable: !1,
      get: () => Vc[n](t),
      set: ao
    });
  }), e;
}
function MP(t) {
  const { ctx: e, propsOptions: [n] } = t;
  n && Object.keys(n).forEach((a) => {
    Object.defineProperty(e, a, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[a],
      set: ao
    });
  });
}
function IP(t) {
  const { ctx: e, setupState: n } = t;
  Object.keys(lr(n)).forEach((a) => {
    if (!n.__isScriptSetup) {
      if (O1(a[0])) {
        at(`setup() return property ${JSON.stringify(a)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(e, a, {
        enumerable: !0,
        configurable: !0,
        get: () => n[a],
        set: ao
      });
    }
  });
}
function OP() {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, n) => {
    t[n] ? at(`${e} property "${n}" is already defined in ${t[n]}.`) : t[n] = e;
  };
}
let O0 = !0;
function CP(t) {
  const e = C1(t), n = t.proxy, a = t.ctx;
  O0 = !1, e.beforeCreate && Hb(e.beforeCreate, t, "bc");
  const {
    data: s,
    computed: f,
    methods: o,
    watch: m,
    provide: g,
    inject: b,
    created: T,
    beforeMount: M,
    mounted: I,
    beforeUpdate: A,
    updated: z,
    activated: V,
    deactivated: Z,
    beforeDestroy: X,
    beforeUnmount: Y,
    destroyed: de,
    unmounted: ye,
    render: Ie,
    renderTracked: Be,
    renderTriggered: De,
    errorCaptured: Re,
    serverPrefetch: Ee,
    expose: ze,
    inheritAttrs: rt,
    components: Ze,
    directives: yt,
    filters: xe
  } = e, Ke = process.env.NODE_ENV !== "production" ? OP() : null;
  if (process.env.NODE_ENV !== "production") {
    const [vt] = t.propsOptions;
    if (vt)
      for (const Pt in vt)
        Ke("Props", Pt);
  }
  if (b && AP(b, a, Ke, t.appContext.config.unwrapInjectedRef), o)
    for (const vt in o) {
      const Pt = o[vt];
      dr(Pt) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(a, vt, {
        value: Pt.bind(n),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : a[vt] = Pt.bind(n), process.env.NODE_ENV !== "production" && Ke("Methods", vt)) : process.env.NODE_ENV !== "production" && at(`Method "${vt}" has type "${typeof Pt}" in the component definition. Did you reference the function correctly?`);
    }
  if (s) {
    process.env.NODE_ENV !== "production" && !dr(s) && at("The data option must be a function. Plain object usage is no longer supported.");
    const vt = s.call(n, n);
    if (process.env.NODE_ENV !== "production" && g1(vt) && at("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."), !fn(vt))
      process.env.NODE_ENV !== "production" && at("data() should return an object.");
    else if (t.data = uv(vt), process.env.NODE_ENV !== "production")
      for (const Pt in vt)
        Ke("Data", Pt), O1(Pt[0]) || Object.defineProperty(a, Pt, {
          configurable: !0,
          enumerable: !0,
          get: () => vt[Pt],
          set: ao
        });
  }
  if (O0 = !0, f)
    for (const vt in f) {
      const Pt = f[vt], tr = dr(Pt) ? Pt.bind(n, n) : dr(Pt.get) ? Pt.get.bind(n, n) : ao;
      process.env.NODE_ENV !== "production" && tr === ao && at(`Computed property "${vt}" has no getter.`);
      const Pn = !dr(Pt) && dr(Pt.set) ? Pt.set.bind(n) : process.env.NODE_ENV !== "production" ? () => {
        at(`Write operation failed: computed property "${vt}" is readonly.`);
      } : ao, Dr = Ur({
        get: tr,
        set: Pn
      });
      Object.defineProperty(a, vt, {
        enumerable: !0,
        configurable: !0,
        get: () => Dr.value,
        set: (hr) => Dr.value = hr
      }), process.env.NODE_ENV !== "production" && Ke("Computed", vt);
    }
  if (m)
    for (const vt in m)
      SS(m[vt], a, n, vt);
  if (g) {
    const vt = dr(g) ? g.call(n) : g;
    Reflect.ownKeys(vt).forEach((Pt) => {
      pS(Pt, vt[Pt]);
    });
  }
  T && Hb(T, t, "c");
  function ct(vt, Pt) {
    er(Pt) ? Pt.forEach((tr) => vt(tr.bind(n))) : Pt && vt(Pt.bind(n));
  }
  if (ct(pP, M), ct(va, I), ct(dP, A), ct(mP, z), ct(cP, V), ct(hP, Z), ct(_P, Re), ct(vP, Be), ct(gP, De), ct(_S, Y), ct(Jc, ye), ct(yP, Ee), er(ze))
    if (ze.length) {
      const vt = t.exposed || (t.exposed = {});
      ze.forEach((Pt) => {
        Object.defineProperty(vt, Pt, {
          get: () => n[Pt],
          set: (tr) => n[Pt] = tr
        });
      });
    } else
      t.exposed || (t.exposed = {});
  Ie && t.render === ao && (t.render = Ie), rt != null && (t.inheritAttrs = rt), Ze && (t.components = Ze), yt && (t.directives = yt);
}
function AP(t, e, n = ao, a = !1) {
  er(t) && (t = C0(t));
  for (const s in t) {
    const f = t[s];
    let o;
    fn(f) ? "default" in f ? o = xf(f.from || s, f.default, !0) : o = xf(f.from || s) : o = xf(f), hn(o) ? a ? Object.defineProperty(e, s, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (m) => o.value = m
    }) : (process.env.NODE_ENV !== "production" && at(`injected property "${s}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`), e[s] = o) : e[s] = o, process.env.NODE_ENV !== "production" && n("Inject", s);
  }
}
function Hb(t, e, n) {
  La(er(t) ? t.map((a) => a.bind(e.proxy)) : t.bind(e.proxy), e, n);
}
function SS(t, e, n, a) {
  const s = a.includes(".") ? dS(n, a) : () => n[a];
  if (Hn(t)) {
    const f = e[t];
    dr(f) ? Bn(s, f) : process.env.NODE_ENV !== "production" && at(`Invalid watch handler specified by key "${t}"`, f);
  } else if (dr(t))
    Bn(s, t.bind(n));
  else if (fn(t))
    if (er(t))
      t.forEach((f) => SS(f, e, n, a));
    else {
      const f = dr(t.handler) ? t.handler.bind(n) : e[t.handler];
      dr(f) ? Bn(s, f, t) : process.env.NODE_ENV !== "production" && at(`Invalid watch handler specified by key "${t.handler}"`, f);
    }
  else
    process.env.NODE_ENV !== "production" && at(`Invalid watch option: "${a}"`, t);
}
function C1(t) {
  const e = t.type, { mixins: n, extends: a } = e, { mixins: s, optionsCache: f, config: { optionMergeStrategies: o } } = t.appContext, m = f.get(e);
  let g;
  return m ? g = m : !s.length && !n && !a ? g = e : (g = {}, s.length && s.forEach((b) => Eg(g, b, o, !0)), Eg(g, e, o)), fn(e) && f.set(e, g), g;
}
function Eg(t, e, n, a = !1) {
  const { mixins: s, extends: f } = e;
  f && Eg(t, f, n, !0), s && s.forEach((o) => Eg(t, o, n, !0));
  for (const o in e)
    if (a && o === "expose")
      process.env.NODE_ENV !== "production" && at('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');
    else {
      const m = PP[o] || n && n[o];
      t[o] = m ? m(t[o], e[o]) : e[o];
    }
  return t;
}
const PP = {
  data: Zb,
  props: Cc,
  emits: Cc,
  methods: Cc,
  computed: Cc,
  beforeCreate: ko,
  created: ko,
  beforeMount: ko,
  mounted: ko,
  beforeUpdate: ko,
  updated: ko,
  beforeDestroy: ko,
  beforeUnmount: ko,
  destroyed: ko,
  unmounted: ko,
  activated: ko,
  deactivated: ko,
  errorCaptured: ko,
  serverPrefetch: ko,
  components: Cc,
  directives: Cc,
  watch: LP,
  provide: Zb,
  inject: kP
};
function Zb(t, e) {
  return e ? t ? function() {
    return Wn(dr(t) ? t.call(this, this) : t, dr(e) ? e.call(this, this) : e);
  } : e : t;
}
function kP(t, e) {
  return Cc(C0(t), C0(e));
}
function C0(t) {
  if (er(t)) {
    const e = {};
    for (let n = 0; n < t.length; n++)
      e[t[n]] = t[n];
    return e;
  }
  return t;
}
function ko(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function Cc(t, e) {
  return t ? Wn(Wn(/* @__PURE__ */ Object.create(null), t), e) : e;
}
function LP(t, e) {
  if (!t)
    return e;
  if (!e)
    return t;
  const n = Wn(/* @__PURE__ */ Object.create(null), t);
  for (const a in e)
    n[a] = ko(t[a], e[a]);
  return n;
}
function DP(t, e, n, a = !1) {
  const s = {}, f = {};
  mg(f, mv, 1), t.propsDefaults = /* @__PURE__ */ Object.create(null), TS(t, e, s, f);
  for (const o in t.propsOptions[0])
    o in s || (s[o] = void 0);
  process.env.NODE_ENV !== "production" && IS(e || {}, s, t), n ? t.props = a ? s : TA(s) : t.type.props ? t.props = s : t.props = f, t.attrs = f;
}
function NP(t) {
  for (; t; ) {
    if (t.type.__hmrId)
      return !0;
    t = t.parent;
  }
}
function RP(t, e, n, a) {
  const { props: s, attrs: f, vnode: { patchFlag: o } } = t, m = lr(s), [g] = t.propsOptions;
  let b = !1;
  if (!(process.env.NODE_ENV !== "production" && NP(t)) && (a || o > 0) && !(o & 16)) {
    if (o & 8) {
      const T = t.vnode.dynamicProps;
      for (let M = 0; M < T.length; M++) {
        let I = T[M];
        if (pv(t.emitsOptions, I))
          continue;
        const A = e[I];
        if (g)
          if (Vr(f, I))
            A !== f[I] && (f[I] = A, b = !0);
          else {
            const z = ya(I);
            s[z] = A0(g, m, z, A, t, !1);
          }
        else
          A !== f[I] && (f[I] = A, b = !0);
      }
    }
  } else {
    TS(t, e, s, f) && (b = !0);
    let T;
    for (const M in m)
      (!e || !Vr(e, M) && ((T = ta(M)) === M || !Vr(e, T))) && (g ? n && (n[M] !== void 0 || n[T] !== void 0) && (s[M] = A0(g, m, M, void 0, t, !0)) : delete s[M]);
    if (f !== m)
      for (const M in f)
        (!e || !Vr(e, M) && !0) && (delete f[M], b = !0);
  }
  b && Fl(t, "set", "$attrs"), process.env.NODE_ENV !== "production" && IS(e || {}, s, t);
}
function TS(t, e, n, a) {
  const [s, f] = t.propsOptions;
  let o = !1, m;
  if (e)
    for (let g in e) {
      if (Hy(g))
        continue;
      const b = e[g];
      let T;
      s && Vr(s, T = ya(g)) ? !f || !f.includes(T) ? n[T] = b : (m || (m = {}))[T] = b : pv(t.emitsOptions, g) || (!(g in a) || b !== a[g]) && (a[g] = b, o = !0);
    }
  if (f) {
    const g = lr(n), b = m || wn;
    for (let T = 0; T < f.length; T++) {
      const M = f[T];
      n[M] = A0(s, g, M, b[M], t, !Vr(b, M));
    }
  }
  return o;
}
function A0(t, e, n, a, s, f) {
  const o = t[n];
  if (o != null) {
    const m = Vr(o, "default");
    if (m && a === void 0) {
      const g = o.default;
      if (o.type !== Function && dr(g)) {
        const { propsDefaults: b } = s;
        n in b ? a = b[n] : (Pf(s), a = b[n] = g.call(null, e), Uc());
      } else
        a = g;
    }
    o[0] && (f && !m ? a = !1 : o[1] && (a === "" || a === ta(n)) && (a = !0));
  }
  return a;
}
function MS(t, e, n = !1) {
  const a = e.propsCache, s = a.get(t);
  if (s)
    return s;
  const f = t.props, o = {}, m = [];
  let g = !1;
  if (!dr(t)) {
    const T = (M) => {
      g = !0;
      const [I, A] = MS(M, e, !0);
      Wn(o, I), A && m.push(...A);
    };
    !n && e.mixins.length && e.mixins.forEach(T), t.extends && T(t.extends), t.mixins && t.mixins.forEach(T);
  }
  if (!f && !g)
    return fn(t) && a.set(t, vf), vf;
  if (er(f))
    for (let T = 0; T < f.length; T++) {
      process.env.NODE_ENV !== "production" && !Hn(f[T]) && at("props must be strings when using array syntax.", f[T]);
      const M = ya(f[T]);
      Xb(M) && (o[M] = wn);
    }
  else if (f) {
    process.env.NODE_ENV !== "production" && !fn(f) && at("invalid props options", f);
    for (const T in f) {
      const M = ya(T);
      if (Xb(M)) {
        const I = f[T], A = o[M] = er(I) || dr(I) ? { type: I } : Object.assign({}, I);
        if (A) {
          const z = Yb(Boolean, A.type), V = Yb(String, A.type);
          A[0] = z > -1, A[1] = V < 0 || z < V, (z > -1 || Vr(A, "default")) && m.push(M);
        }
      }
    }
  }
  const b = [o, m];
  return fn(t) && a.set(t, b), b;
}
function Xb(t) {
  return t[0] !== "$" ? !0 : (process.env.NODE_ENV !== "production" && at(`Invalid prop name: "${t}" is a reserved property.`), !1);
}
function P0(t) {
  const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : t === null ? "null" : "";
}
function Kb(t, e) {
  return P0(t) === P0(e);
}
function Yb(t, e) {
  return er(e) ? e.findIndex((n) => Kb(n, t)) : dr(e) && Kb(e, t) ? 0 : -1;
}
function IS(t, e, n) {
  const a = lr(e), s = n.propsOptions[0];
  for (const f in s) {
    let o = s[f];
    o != null && zP(f, a[f], o, !Vr(t, f) && !Vr(t, ta(f)));
  }
}
function zP(t, e, n, a) {
  const { type: s, required: f, validator: o } = n;
  if (f && a) {
    at('Missing required prop: "' + t + '"');
    return;
  }
  if (!(e == null && !n.required)) {
    if (s != null && s !== !0) {
      let m = !1;
      const g = er(s) ? s : [s], b = [];
      for (let T = 0; T < g.length && !m; T++) {
        const { valid: M, expectedType: I } = BP(e, g[T]);
        b.push(I || ""), m = M;
      }
      if (!m) {
        at(VP(t, e, b));
        return;
      }
    }
    o && !o(e) && at('Invalid prop: custom validator check failed for prop "' + t + '".');
  }
}
const FP = /* @__PURE__ */ zu("String,Number,Boolean,Function,Symbol,BigInt");
function BP(t, e) {
  let n;
  const a = P0(e);
  if (FP(a)) {
    const s = typeof t;
    n = s === a.toLowerCase(), !n && s === "object" && (n = t instanceof e);
  } else
    a === "Object" ? n = fn(t) : a === "Array" ? n = er(t) : a === "null" ? n = t === null : n = t instanceof e;
  return {
    valid: n,
    expectedType: a
  };
}
function VP(t, e, n) {
  let a = `Invalid prop: type check failed for prop "${t}". Expected ${n.map($c).join(" | ")}`;
  const s = n[0], f = v1(e), o = Jb(e, s), m = Jb(e, f);
  return n.length === 1 && Qb(s) && !UP(s, f) && (a += ` with value ${o}`), a += `, got ${f} `, Qb(f) && (a += `with value ${m}.`), a;
}
function Jb(t, e) {
  return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`;
}
function Qb(t) {
  return ["string", "number", "boolean"].some((n) => t.toLowerCase() === n);
}
function UP(...t) {
  return t.some((e) => e.toLowerCase() === "boolean");
}
const OS = (t) => t[0] === "_" || t === "$stable", A1 = (t) => er(t) ? t.map(rs) : [rs(t)], jP = (t, e, n) => {
  if (e._n)
    return e;
  const a = Bd((...s) => (process.env.NODE_ENV !== "production" && pi && at(`Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`), A1(e(...s))), n);
  return a._c = !1, a;
}, CS = (t, e, n) => {
  const a = t._ctx;
  for (const s in t) {
    if (OS(s))
      continue;
    const f = t[s];
    if (dr(f))
      e[s] = jP(s, f, a);
    else if (f != null) {
      process.env.NODE_ENV !== "production" && at(`Non-function value encountered for slot "${s}". Prefer function slots for better performance.`);
      const o = A1(f);
      e[s] = () => o;
    }
  }
}, AS = (t, e) => {
  process.env.NODE_ENV !== "production" && !Vd(t.vnode) && at("Non-function value encountered for default slot. Prefer function slots for better performance.");
  const n = A1(e);
  t.slots.default = () => n;
}, GP = (t, e) => {
  if (t.vnode.shapeFlag & 32) {
    const n = e._;
    n ? (t.slots = lr(e), mg(e, "_", n)) : CS(e, t.slots = {});
  } else
    t.slots = {}, e && AS(t, e);
  mg(t.slots, mv, 1);
}, qP = (t, e, n) => {
  const { vnode: a, slots: s } = t;
  let f = !0, o = wn;
  if (a.shapeFlag & 32) {
    const m = e._;
    m ? process.env.NODE_ENV !== "production" && Mu ? Wn(s, e) : n && m === 1 ? f = !1 : (Wn(s, e), !n && m === 1 && delete s._) : (f = !e.$stable, CS(e, s)), o = e;
  } else
    e && (AS(t, e), o = { default: 1 });
  if (f)
    for (const m in s)
      !OS(m) && !(m in o) && delete s[m];
};
function PS() {
  return {
    app: null,
    config: {
      isNativeTag: OE,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let $P = 0;
function WP(t, e) {
  return function(a, s = null) {
    dr(a) || (a = Object.assign({}, a)), s != null && !fn(s) && (process.env.NODE_ENV !== "production" && at("root props passed to app.mount() must be an object."), s = null);
    const f = PS(), o = /* @__PURE__ */ new Set();
    let m = !1;
    const g = f.app = {
      _uid: $P++,
      _component: a,
      _props: s,
      _container: null,
      _context: f,
      _instance: null,
      version: iw,
      get config() {
        return f.config;
      },
      set config(b) {
        process.env.NODE_ENV !== "production" && at("app.config cannot be replaced. Modify individual options instead.");
      },
      use(b, ...T) {
        return o.has(b) ? process.env.NODE_ENV !== "production" && at("Plugin has already been applied to target app.") : b && dr(b.install) ? (o.add(b), b.install(g, ...T)) : dr(b) ? (o.add(b), b(g, ...T)) : process.env.NODE_ENV !== "production" && at('A plugin must either be a function or an object with an "install" function.'), g;
      },
      mixin(b) {
        return f.mixins.includes(b) ? process.env.NODE_ENV !== "production" && at("Mixin has already been applied to target app" + (b.name ? `: ${b.name}` : "")) : f.mixins.push(b), g;
      },
      component(b, T) {
        return process.env.NODE_ENV !== "production" && D0(b, f.config), T ? (process.env.NODE_ENV !== "production" && f.components[b] && at(`Component "${b}" has already been registered in target app.`), f.components[b] = T, g) : f.components[b];
      },
      directive(b, T) {
        return process.env.NODE_ENV !== "production" && xS(b), T ? (process.env.NODE_ENV !== "production" && f.directives[b] && at(`Directive "${b}" has already been registered in target app.`), f.directives[b] = T, g) : f.directives[b];
      },
      mount(b, T, M) {
        if (m)
          process.env.NODE_ENV !== "production" && at("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
        else {
          process.env.NODE_ENV !== "production" && b.__vue_app__ && at("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");
          const I = Gt(a, s);
          return I.appContext = f, process.env.NODE_ENV !== "production" && (f.reload = () => {
            t(Xs(I), b, M);
          }), T && e ? e(I, b) : t(I, b, M), m = !0, g._container = b, b.__vue_app__ = g, process.env.NODE_ENV !== "production" && (g._instance = I.component, $A(g, iw)), gv(I.component) || I.component.proxy;
        }
      },
      unmount() {
        m ? (t(null, g._container), process.env.NODE_ENV !== "production" && (g._instance = null, WA(g)), delete g._container.__vue_app__) : process.env.NODE_ENV !== "production" && at("Cannot unmount an app that is not mounted.");
      },
      provide(b, T) {
        return process.env.NODE_ENV !== "production" && b in f.provides && at(`App already provides property with key "${String(b)}". It will be overwritten with the new value.`), f.provides[b] = T, g;
      }
    };
    return g;
  };
}
function k0(t, e, n, a, s = !1) {
  if (er(t)) {
    t.forEach((I, A) => k0(I, e && (er(e) ? e[A] : e), n, a, s));
    return;
  }
  if (cd(a) && !s)
    return;
  const f = a.shapeFlag & 4 ? gv(a.component) || a.component.proxy : a.el, o = s ? null : f, { i: m, r: g } = t;
  if (process.env.NODE_ENV !== "production" && !m) {
    at("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");
    return;
  }
  const b = e && e.r, T = m.refs === wn ? m.refs = {} : m.refs, M = m.setupState;
  if (b != null && b !== g && (Hn(b) ? (T[b] = null, Vr(M, b) && (M[b] = null)) : hn(b) && (b.value = null)), dr(g))
    Dl(g, m, 12, [o, T]);
  else {
    const I = Hn(g), A = hn(g);
    if (I || A) {
      const z = () => {
        if (t.f) {
          const V = I ? Vr(M, g) ? M[g] : T[g] : g.value;
          s ? er(V) && m1(V, f) : er(V) ? V.includes(f) || V.push(f) : I ? (T[g] = [f], Vr(M, g) && (M[g] = T[g])) : (g.value = [f], t.k && (T[t.k] = g.value));
        } else
          I ? (T[g] = o, Vr(M, g) && (M[g] = o)) : A ? (g.value = o, t.k && (T[t.k] = o)) : process.env.NODE_ENV !== "production" && at("Invalid template ref type:", g, `(${typeof g})`);
      };
      o ? (z.id = -1, ea(z, n)) : z();
    } else
      process.env.NODE_ENV !== "production" && at("Invalid template ref type:", g, `(${typeof g})`);
  }
}
let Up, xu;
function Pl(t, e) {
  t.appContext.config.performance && Sg() && xu.mark(`vue-${e}-${t.uid}`), process.env.NODE_ENV !== "production" && KA(t, e, Sg() ? xu.now() : Date.now());
}
function kl(t, e) {
  if (t.appContext.config.performance && Sg()) {
    const n = `vue-${e}-${t.uid}`, a = n + ":end";
    xu.mark(a), xu.measure(`<${vv(t, t.type)}> ${e}`, n, a), xu.clearMarks(n), xu.clearMarks(a);
  }
  process.env.NODE_ENV !== "production" && YA(t, e, Sg() ? xu.now() : Date.now());
}
function Sg() {
  return Up !== void 0 || (typeof window < "u" && window.performance ? (Up = !0, xu = window.performance) : Up = !1), Up;
}
function HP() {
  const t = [];
  if (process.env.NODE_ENV !== "production" && t.length) {
    const e = t.length > 1;
    console.warn(`Feature flag${e ? "s" : ""} ${t.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const ea = aP;
function ZP(t) {
  return XP(t);
}
function XP(t, e) {
  HP();
  const n = kE();
  n.__VUE__ = !0, process.env.NODE_ENV !== "production" && sS(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
  const { insert: a, remove: s, patchProp: f, createElement: o, createText: m, createComment: g, setText: b, setElementText: T, parentNode: M, nextSibling: I, setScopeId: A = ao, insertStaticContent: z } = t, V = (K, me, Le, qe = null, $e = null, et = null, dt = !1, Je = null, lt = process.env.NODE_ENV !== "production" && Mu ? !1 : !!me.dynamicChildren) => {
    if (K === me)
      return;
    K && !Lc(K, me) && (qe = Vn(K), Zn(K, $e, et, !0), K = null), me.patchFlag === -2 && (lt = !1, me.dynamicChildren = null);
    const { type: Ye, ref: It, shapeFlag: bt } = me;
    switch (Ye) {
      case Ud:
        Z(K, me, Le, qe);
        break;
      case Xi:
        X(K, me, Le, qe);
        break;
      case Ky:
        K == null ? Y(me, Le, qe, dt) : process.env.NODE_ENV !== "production" && de(K, me, Le, dt);
        break;
      case un:
        yt(K, me, Le, qe, $e, et, dt, Je, lt);
        break;
      default:
        bt & 1 ? Be(K, me, Le, qe, $e, et, dt, Je, lt) : bt & 6 ? xe(K, me, Le, qe, $e, et, dt, Je, lt) : bt & 64 || bt & 128 ? Ye.process(K, me, Le, qe, $e, et, dt, Je, lt, En) : process.env.NODE_ENV !== "production" && at("Invalid VNode type:", Ye, `(${typeof Ye})`);
    }
    It != null && $e && k0(It, K && K.ref, et, me || K, !me);
  }, Z = (K, me, Le, qe) => {
    if (K == null)
      a(me.el = m(me.children), Le, qe);
    else {
      const $e = me.el = K.el;
      me.children !== K.children && b($e, me.children);
    }
  }, X = (K, me, Le, qe) => {
    K == null ? a(me.el = g(me.children || ""), Le, qe) : me.el = K.el;
  }, Y = (K, me, Le, qe) => {
    [K.el, K.anchor] = z(K.children, me, Le, qe, K.el, K.anchor);
  }, de = (K, me, Le, qe) => {
    if (me.children !== K.children) {
      const $e = I(K.anchor);
      Ie(K), [me.el, me.anchor] = z(me.children, Le, $e, qe);
    } else
      me.el = K.el, me.anchor = K.anchor;
  }, ye = ({ el: K, anchor: me }, Le, qe) => {
    let $e;
    for (; K && K !== me; )
      $e = I(K), a(K, Le, qe), K = $e;
    a(me, Le, qe);
  }, Ie = ({ el: K, anchor: me }) => {
    let Le;
    for (; K && K !== me; )
      Le = I(K), s(K), K = Le;
    s(me);
  }, Be = (K, me, Le, qe, $e, et, dt, Je, lt) => {
    dt = dt || me.type === "svg", K == null ? De(me, Le, qe, $e, et, dt, Je, lt) : ze(K, me, $e, et, dt, Je, lt);
  }, De = (K, me, Le, qe, $e, et, dt, Je) => {
    let lt, Ye;
    const { type: It, props: bt, shapeFlag: kt, transition: Ut, dirs: fr } = K;
    if (lt = K.el = o(K.type, et, bt && bt.is, bt), kt & 8 ? T(lt, K.children) : kt & 16 && Ee(K.children, lt, null, qe, $e, et && It !== "foreignObject", dt, Je), fr && vc(K, null, qe, "created"), Re(lt, K, K.scopeId, dt, qe), bt) {
      for (const Ar in bt)
        Ar !== "value" && !Hy(Ar) && f(lt, Ar, null, bt[Ar], et, K.children, qe, $e, Cr);
      "value" in bt && f(lt, "value", null, bt.value), (Ye = bt.onVnodeBeforeMount) && Ns(Ye, qe, K);
    }
    process.env.NODE_ENV !== "production" && (Object.defineProperty(lt, "__vnode", {
      value: K,
      enumerable: !1
    }), Object.defineProperty(lt, "__vueParentComponent", {
      value: qe,
      enumerable: !1
    })), fr && vc(K, null, qe, "beforeMount");
    const Fr = (!$e || $e && !$e.pendingBranch) && Ut && !Ut.persisted;
    Fr && Ut.beforeEnter(lt), a(lt, me, Le), ((Ye = bt && bt.onVnodeMounted) || Fr || fr) && ea(() => {
      Ye && Ns(Ye, qe, K), Fr && Ut.enter(lt), fr && vc(K, null, qe, "mounted");
    }, $e);
  }, Re = (K, me, Le, qe, $e) => {
    if (Le && A(K, Le), qe)
      for (let et = 0; et < qe.length; et++)
        A(K, qe[et]);
    if ($e) {
      let et = $e.subTree;
      if (process.env.NODE_ENV !== "production" && et.patchFlag > 0 && et.patchFlag & 2048 && (et = fS(et.children) || et), me === et) {
        const dt = $e.vnode;
        Re(K, dt, dt.scopeId, dt.slotScopeIds, $e.parent);
      }
    }
  }, Ee = (K, me, Le, qe, $e, et, dt, Je, lt = 0) => {
    for (let Ye = lt; Ye < K.length; Ye++) {
      const It = K[Ye] = Je ? gu(K[Ye]) : rs(K[Ye]);
      V(null, It, me, Le, qe, $e, et, dt, Je);
    }
  }, ze = (K, me, Le, qe, $e, et, dt) => {
    const Je = me.el = K.el;
    let { patchFlag: lt, dynamicChildren: Ye, dirs: It } = me;
    lt |= K.patchFlag & 16;
    const bt = K.props || wn, kt = me.props || wn;
    let Ut;
    Le && _c(Le, !1), (Ut = kt.onVnodeBeforeUpdate) && Ns(Ut, Le, me, K), It && vc(me, K, Le, "beforeUpdate"), Le && _c(Le, !0), process.env.NODE_ENV !== "production" && Mu && (lt = 0, dt = !1, Ye = null);
    const fr = $e && me.type !== "foreignObject";
    if (Ye ? (rt(K.dynamicChildren, Ye, Je, Le, qe, fr, et), process.env.NODE_ENV !== "production" && Le && Le.type.__hmrId && hd(K, me)) : dt || tr(K, me, Je, null, Le, qe, fr, et, !1), lt > 0) {
      if (lt & 16)
        Ze(Je, me, bt, kt, Le, qe, $e);
      else if (lt & 2 && bt.class !== kt.class && f(Je, "class", null, kt.class, $e), lt & 4 && f(Je, "style", bt.style, kt.style, $e), lt & 8) {
        const Fr = me.dynamicProps;
        for (let Ar = 0; Ar < Fr.length; Ar++) {
          const Jr = Fr[Ar], Xn = bt[Jr], Bi = kt[Jr];
          (Bi !== Xn || Jr === "value") && f(Je, Jr, Xn, Bi, $e, K.children, Le, qe, Cr);
        }
      }
      lt & 1 && K.children !== me.children && T(Je, me.children);
    } else
      !dt && Ye == null && Ze(Je, me, bt, kt, Le, qe, $e);
    ((Ut = kt.onVnodeUpdated) || It) && ea(() => {
      Ut && Ns(Ut, Le, me, K), It && vc(me, K, Le, "updated");
    }, qe);
  }, rt = (K, me, Le, qe, $e, et, dt) => {
    for (let Je = 0; Je < me.length; Je++) {
      const lt = K[Je], Ye = me[Je], It = lt.el && (lt.type === un || !Lc(lt, Ye) || lt.shapeFlag & 70) ? M(lt.el) : Le;
      V(lt, Ye, It, null, qe, $e, et, dt, !0);
    }
  }, Ze = (K, me, Le, qe, $e, et, dt) => {
    if (Le !== qe) {
      if (Le !== wn)
        for (const Je in Le)
          !Hy(Je) && !(Je in qe) && f(K, Je, Le[Je], null, dt, me.children, $e, et, Cr);
      for (const Je in qe) {
        if (Hy(Je))
          continue;
        const lt = qe[Je], Ye = Le[Je];
        lt !== Ye && Je !== "value" && f(K, Je, Ye, lt, dt, me.children, $e, et, Cr);
      }
      "value" in qe && f(K, "value", Le.value, qe.value);
    }
  }, yt = (K, me, Le, qe, $e, et, dt, Je, lt) => {
    const Ye = me.el = K ? K.el : m(""), It = me.anchor = K ? K.anchor : m("");
    let { patchFlag: bt, dynamicChildren: kt, slotScopeIds: Ut } = me;
    process.env.NODE_ENV !== "production" && (Mu || bt & 2048) && (bt = 0, lt = !1, kt = null), Ut && (Je = Je ? Je.concat(Ut) : Ut), K == null ? (a(Ye, Le, qe), a(It, Le, qe), Ee(me.children, Le, It, $e, et, dt, Je, lt)) : bt > 0 && bt & 64 && kt && K.dynamicChildren ? (rt(K.dynamicChildren, kt, Le, $e, et, dt, Je), process.env.NODE_ENV !== "production" && $e && $e.type.__hmrId ? hd(K, me) : (me.key != null || $e && me === $e.subTree) && hd(K, me, !0)) : tr(K, me, Le, It, $e, et, dt, Je, lt);
  }, xe = (K, me, Le, qe, $e, et, dt, Je, lt) => {
    me.slotScopeIds = Je, K == null ? me.shapeFlag & 512 ? $e.ctx.activate(me, Le, qe, dt, lt) : Ke(me, Le, qe, $e, et, dt, lt) : ct(K, me, lt);
  }, Ke = (K, me, Le, qe, $e, et, dt) => {
    const Je = K.component = ak(K, qe, $e);
    if (process.env.NODE_ENV !== "production" && Je.type.__hmrId && UA(Je), process.env.NODE_ENV !== "production" && (Zy(K), Pl(Je, "mount")), Vd(K) && (Je.ctx.renderer = En), process.env.NODE_ENV !== "production" && Pl(Je, "init"), lk(Je), process.env.NODE_ENV !== "production" && kl(Je, "init"), Je.asyncDep) {
      if ($e && $e.registerDep(Je, vt), !K.el) {
        const lt = Je.subTree = Gt(Xi);
        X(null, lt, me, Le);
      }
      return;
    }
    vt(Je, K, me, Le, $e, et, dt), process.env.NODE_ENV !== "production" && (Xy(), kl(Je, "mount"));
  }, ct = (K, me, Le) => {
    const qe = me.component = K.component;
    if (nP(K, me, Le))
      if (qe.asyncDep && !qe.asyncResolved) {
        process.env.NODE_ENV !== "production" && Zy(me), Pt(qe, me, Le), process.env.NODE_ENV !== "production" && Xy();
        return;
      } else
        qe.next = me, BA(qe.update), qe.update();
    else
      me.el = K.el, qe.vnode = me;
  }, vt = (K, me, Le, qe, $e, et, dt) => {
    const Je = () => {
      if (K.isMounted) {
        let { next: It, bu: bt, u: kt, parent: Ut, vnode: fr } = K, Fr = It, Ar;
        process.env.NODE_ENV !== "production" && Zy(It || K.vnode), _c(K, !1), It ? (It.el = fr.el, Pt(K, It, dt)) : It = fr, bt && Vp(bt), (Ar = It.props && It.props.onVnodeBeforeUpdate) && Ns(Ar, Ut, It, fr), _c(K, !0), process.env.NODE_ENV !== "production" && Pl(K, "render");
        const Jr = M_(K);
        process.env.NODE_ENV !== "production" && kl(K, "render");
        const Xn = K.subTree;
        K.subTree = Jr, process.env.NODE_ENV !== "production" && Pl(K, "patch"), V(
          Xn,
          Jr,
          M(Xn.el),
          Vn(Xn),
          K,
          $e,
          et
        ), process.env.NODE_ENV !== "production" && kl(K, "patch"), It.el = Jr.el, Fr === null && iP(K, Jr.el), kt && ea(kt, $e), (Ar = It.props && It.props.onVnodeUpdated) && ea(() => Ns(Ar, Ut, It, fr), $e), process.env.NODE_ENV !== "production" && lS(K), process.env.NODE_ENV !== "production" && Xy();
      } else {
        let It;
        const { el: bt, props: kt } = me, { bm: Ut, m: fr, parent: Fr } = K, Ar = cd(me);
        if (_c(K, !1), Ut && Vp(Ut), !Ar && (It = kt && kt.onVnodeBeforeMount) && Ns(It, Fr, me), _c(K, !0), bt && Un) {
          const Jr = () => {
            process.env.NODE_ENV !== "production" && Pl(K, "render"), K.subTree = M_(K), process.env.NODE_ENV !== "production" && kl(K, "render"), process.env.NODE_ENV !== "production" && Pl(K, "hydrate"), Un(bt, K.subTree, K, $e, null), process.env.NODE_ENV !== "production" && kl(K, "hydrate");
          };
          Ar ? me.type.__asyncLoader().then(
            () => !K.isUnmounted && Jr()
          ) : Jr();
        } else {
          process.env.NODE_ENV !== "production" && Pl(K, "render");
          const Jr = K.subTree = M_(K);
          process.env.NODE_ENV !== "production" && kl(K, "render"), process.env.NODE_ENV !== "production" && Pl(K, "patch"), V(null, Jr, Le, qe, K, $e, et), process.env.NODE_ENV !== "production" && kl(K, "patch"), me.el = Jr.el;
        }
        if (fr && ea(fr, $e), !Ar && (It = kt && kt.onVnodeMounted)) {
          const Jr = me;
          ea(() => Ns(It, Fr, Jr), $e);
        }
        (me.shapeFlag & 256 || Fr && cd(Fr.vnode) && Fr.vnode.shapeFlag & 256) && K.a && ea(K.a, $e), K.isMounted = !0, process.env.NODE_ENV !== "production" && HA(K), me = Le = qe = null;
      }
    }, lt = K.effect = new x1(
      Je,
      () => fv(Ye),
      K.scope
    ), Ye = K.update = () => lt.run();
    Ye.id = K.uid, _c(K, !0), process.env.NODE_ENV !== "production" && (lt.onTrack = K.rtc ? (It) => Vp(K.rtc, It) : void 0, lt.onTrigger = K.rtg ? (It) => Vp(K.rtg, It) : void 0, Ye.ownerInstance = K), Ye();
  }, Pt = (K, me, Le) => {
    me.component = K;
    const qe = K.vnode.props;
    K.vnode = me, K.next = null, RP(K, me.props, qe, Le), qP(K, me.children, Le), Kc(), Vb(), Yc();
  }, tr = (K, me, Le, qe, $e, et, dt, Je, lt = !1) => {
    const Ye = K && K.children, It = K ? K.shapeFlag : 0, bt = me.children, { patchFlag: kt, shapeFlag: Ut } = me;
    if (kt > 0) {
      if (kt & 128) {
        Dr(Ye, bt, Le, qe, $e, et, dt, Je, lt);
        return;
      } else if (kt & 256) {
        Pn(Ye, bt, Le, qe, $e, et, dt, Je, lt);
        return;
      }
    }
    Ut & 8 ? (It & 16 && Cr(Ye, $e, et), bt !== Ye && T(Le, bt)) : It & 16 ? Ut & 16 ? Dr(Ye, bt, Le, qe, $e, et, dt, Je, lt) : Cr(Ye, $e, et, !0) : (It & 8 && T(Le, ""), Ut & 16 && Ee(bt, Le, qe, $e, et, dt, Je, lt));
  }, Pn = (K, me, Le, qe, $e, et, dt, Je, lt) => {
    K = K || vf, me = me || vf;
    const Ye = K.length, It = me.length, bt = Math.min(Ye, It);
    let kt;
    for (kt = 0; kt < bt; kt++) {
      const Ut = me[kt] = lt ? gu(me[kt]) : rs(me[kt]);
      V(K[kt], Ut, Le, null, $e, et, dt, Je, lt);
    }
    Ye > It ? Cr(K, $e, et, !0, !1, bt) : Ee(me, Le, qe, $e, et, dt, Je, lt, bt);
  }, Dr = (K, me, Le, qe, $e, et, dt, Je, lt) => {
    let Ye = 0;
    const It = me.length;
    let bt = K.length - 1, kt = It - 1;
    for (; Ye <= bt && Ye <= kt; ) {
      const Ut = K[Ye], fr = me[Ye] = lt ? gu(me[Ye]) : rs(me[Ye]);
      if (Lc(Ut, fr))
        V(Ut, fr, Le, null, $e, et, dt, Je, lt);
      else
        break;
      Ye++;
    }
    for (; Ye <= bt && Ye <= kt; ) {
      const Ut = K[bt], fr = me[kt] = lt ? gu(me[kt]) : rs(me[kt]);
      if (Lc(Ut, fr))
        V(Ut, fr, Le, null, $e, et, dt, Je, lt);
      else
        break;
      bt--, kt--;
    }
    if (Ye > bt) {
      if (Ye <= kt) {
        const Ut = kt + 1, fr = Ut < It ? me[Ut].el : qe;
        for (; Ye <= kt; )
          V(null, me[Ye] = lt ? gu(me[Ye]) : rs(me[Ye]), Le, fr, $e, et, dt, Je, lt), Ye++;
      }
    } else if (Ye > kt)
      for (; Ye <= bt; )
        Zn(K[Ye], $e, et, !0), Ye++;
    else {
      const Ut = Ye, fr = Ye, Fr = /* @__PURE__ */ new Map();
      for (Ye = fr; Ye <= kt; Ye++) {
        const Sn = me[Ye] = lt ? gu(me[Ye]) : rs(me[Ye]);
        Sn.key != null && (process.env.NODE_ENV !== "production" && Fr.has(Sn.key) && at("Duplicate keys found during update:", JSON.stringify(Sn.key), "Make sure keys are unique."), Fr.set(Sn.key, Ye));
      }
      let Ar, Jr = 0;
      const Xn = kt - fr + 1;
      let Bi = !1, so = 0;
      const Kn = new Array(Xn);
      for (Ye = 0; Ye < Xn; Ye++)
        Kn[Ye] = 0;
      for (Ye = Ut; Ye <= bt; Ye++) {
        const Sn = K[Ye];
        if (Jr >= Xn) {
          Zn(Sn, $e, et, !0);
          continue;
        }
        let ai;
        if (Sn.key != null)
          ai = Fr.get(Sn.key);
        else
          for (Ar = fr; Ar <= kt; Ar++)
            if (Kn[Ar - fr] === 0 && Lc(Sn, me[Ar])) {
              ai = Ar;
              break;
            }
        ai === void 0 ? Zn(Sn, $e, et, !0) : (Kn[ai - fr] = Ye + 1, ai >= so ? so = ai : Bi = !0, V(Sn, me[ai], Le, null, $e, et, dt, Je, lt), Jr++);
      }
      const ki = Bi ? KP(Kn) : vf;
      for (Ar = ki.length - 1, Ye = Xn - 1; Ye >= 0; Ye--) {
        const Sn = fr + Ye, ai = me[Sn], Fa = Sn + 1 < It ? me[Sn + 1].el : qe;
        Kn[Ye] === 0 ? V(null, ai, Le, Fa, $e, et, dt, Je, lt) : Bi && (Ar < 0 || Ye !== ki[Ar] ? hr(ai, Le, Fa, 2) : Ar--);
      }
    }
  }, hr = (K, me, Le, qe, $e = null) => {
    const { el: et, type: dt, transition: Je, children: lt, shapeFlag: Ye } = K;
    if (Ye & 6) {
      hr(K.component.subTree, me, Le, qe);
      return;
    }
    if (Ye & 128) {
      K.suspense.move(me, Le, qe);
      return;
    }
    if (Ye & 64) {
      dt.move(K, me, Le, En);
      return;
    }
    if (dt === un) {
      a(et, me, Le);
      for (let bt = 0; bt < lt.length; bt++)
        hr(lt[bt], me, Le, qe);
      a(K.anchor, me, Le);
      return;
    }
    if (dt === Ky) {
      ye(K, me, Le);
      return;
    }
    if (qe !== 2 && Ye & 1 && Je)
      if (qe === 0)
        Je.beforeEnter(et), a(et, me, Le), ea(() => Je.enter(et), $e);
      else {
        const { leave: bt, delayLeave: kt, afterLeave: Ut } = Je, fr = () => a(et, me, Le), Fr = () => {
          bt(et, () => {
            fr(), Ut && Ut();
          });
        };
        kt ? kt(et, fr, Fr) : Fr();
      }
    else
      a(et, me, Le);
  }, Zn = (K, me, Le, qe = !1, $e = !1) => {
    const { type: et, props: dt, ref: Je, children: lt, dynamicChildren: Ye, shapeFlag: It, patchFlag: bt, dirs: kt } = K;
    if (Je != null && k0(Je, null, Le, K, !0), It & 256) {
      me.ctx.deactivate(K);
      return;
    }
    const Ut = It & 1 && kt, fr = !cd(K);
    let Fr;
    if (fr && (Fr = dt && dt.onVnodeBeforeUnmount) && Ns(Fr, me, K), It & 6)
      Gr(K.component, Le, qe);
    else {
      if (It & 128) {
        K.suspense.unmount(Le, qe);
        return;
      }
      Ut && vc(K, null, me, "beforeUnmount"), It & 64 ? K.type.remove(K, me, Le, $e, En, qe) : Ye && (et !== un || bt > 0 && bt & 64) ? Cr(Ye, me, Le, !1, !0) : (et === un && bt & 384 || !$e && It & 16) && Cr(lt, me, Le), qe && Nr(K);
    }
    (fr && (Fr = dt && dt.onVnodeUnmounted) || Ut) && ea(() => {
      Fr && Ns(Fr, me, K), Ut && vc(K, null, me, "unmounted");
    }, Le);
  }, Nr = (K) => {
    const { type: me, el: Le, anchor: qe, transition: $e } = K;
    if (me === un) {
      process.env.NODE_ENV !== "production" && K.patchFlag > 0 && K.patchFlag & 2048 && $e && !$e.persisted ? K.children.forEach((dt) => {
        dt.type === Xi ? s(dt.el) : Nr(dt);
      }) : Fi(Le, qe);
      return;
    }
    if (me === Ky) {
      Ie(K);
      return;
    }
    const et = () => {
      s(Le), $e && !$e.persisted && $e.afterLeave && $e.afterLeave();
    };
    if (K.shapeFlag & 1 && $e && !$e.persisted) {
      const { leave: dt, delayLeave: Je } = $e, lt = () => dt(Le, et);
      Je ? Je(K.el, et, lt) : lt();
    } else
      et();
  }, Fi = (K, me) => {
    let Le;
    for (; K !== me; )
      Le = I(K), s(K), K = Le;
    s(me);
  }, Gr = (K, me, Le) => {
    process.env.NODE_ENV !== "production" && K.type.__hmrId && jA(K);
    const { bum: qe, scope: $e, update: et, subTree: dt, um: Je } = K;
    qe && Vp(qe), $e.stop(), et && (et.active = !1, Zn(dt, K, me, Le)), Je && ea(Je, me), ea(() => {
      K.isUnmounted = !0;
    }, me), me && me.pendingBranch && !me.isUnmounted && K.asyncDep && !K.asyncResolved && K.suspenseId === me.pendingId && (me.deps--, me.deps === 0 && me.resolve()), process.env.NODE_ENV !== "production" && XA(K);
  }, Cr = (K, me, Le, qe = !1, $e = !1, et = 0) => {
    for (let dt = et; dt < K.length; dt++)
      Zn(K[dt], me, Le, qe, $e);
  }, Vn = (K) => K.shapeFlag & 6 ? Vn(K.component.subTree) : K.shapeFlag & 128 ? K.suspense.next() : I(K.anchor || K.el), wr = (K, me, Le) => {
    K == null ? me._vnode && Zn(me._vnode, null, null, !0) : V(me._vnode || null, K, me, null, null, null, Le), Vb(), iS(), me._vnode = K;
  }, En = {
    p: V,
    um: Zn,
    m: hr,
    r: Nr,
    mt: Ke,
    mc: Ee,
    pc: tr,
    pbc: rt,
    n: Vn,
    o: t
  };
  let oi, Un;
  return e && ([oi, Un] = e(En)), {
    render: wr,
    hydrate: oi,
    createApp: WP(wr, oi)
  };
}
function _c({ effect: t, update: e }, n) {
  t.allowRecurse = e.allowRecurse = n;
}
function hd(t, e, n = !1) {
  const a = t.children, s = e.children;
  if (er(a) && er(s))
    for (let f = 0; f < a.length; f++) {
      const o = a[f];
      let m = s[f];
      m.shapeFlag & 1 && !m.dynamicChildren && ((m.patchFlag <= 0 || m.patchFlag === 32) && (m = s[f] = gu(s[f]), m.el = o.el), n || hd(o, m)), m.type === Ud && (m.el = o.el), process.env.NODE_ENV !== "production" && m.type === Xi && !m.el && (m.el = o.el);
    }
}
function KP(t) {
  const e = t.slice(), n = [0];
  let a, s, f, o, m;
  const g = t.length;
  for (a = 0; a < g; a++) {
    const b = t[a];
    if (b !== 0) {
      if (s = n[n.length - 1], t[s] < b) {
        e[a] = s, n.push(a);
        continue;
      }
      for (f = 0, o = n.length - 1; f < o; )
        m = f + o >> 1, t[n[m]] < b ? f = m + 1 : o = m;
      b < t[n[f]] && (f > 0 && (e[a] = n[f - 1]), n[f] = a);
    }
  }
  for (f = n.length, o = n[f - 1]; f-- > 0; )
    n[f] = o, o = e[o];
  return n;
}
const YP = (t) => t.__isTeleport, bf = (t) => t && (t.disabled || t.disabled === ""), ew = (t) => typeof SVGElement < "u" && t instanceof SVGElement, L0 = (t, e) => {
  const n = t && t.to;
  if (Hn(n))
    if (e) {
      const a = e(n);
      return a || process.env.NODE_ENV !== "production" && at(`Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`), a;
    } else
      return process.env.NODE_ENV !== "production" && at("Current renderer does not support string target for Teleports. (missing querySelector renderer option)"), null;
  else
    return process.env.NODE_ENV !== "production" && !n && !bf(t) && at(`Invalid Teleport target: ${n}`), n;
}, JP = {
  __isTeleport: !0,
  process(t, e, n, a, s, f, o, m, g, b) {
    const { mc: T, pc: M, pbc: I, o: { insert: A, querySelector: z, createText: V, createComment: Z } } = b, X = bf(e.props);
    let { shapeFlag: Y, children: de, dynamicChildren: ye } = e;
    if (process.env.NODE_ENV !== "production" && Mu && (g = !1, ye = null), t == null) {
      const Ie = e.el = process.env.NODE_ENV !== "production" ? Z("teleport start") : V(""), Be = e.anchor = process.env.NODE_ENV !== "production" ? Z("teleport end") : V("");
      A(Ie, n, a), A(Be, n, a);
      const De = e.target = L0(e.props, z), Re = e.targetAnchor = V("");
      De ? (A(Re, De), o = o || ew(De)) : process.env.NODE_ENV !== "production" && !X && at("Invalid Teleport target on mount:", De, `(${typeof De})`);
      const Ee = (ze, rt) => {
        Y & 16 && T(de, ze, rt, s, f, o, m, g);
      };
      X ? Ee(n, Be) : De && Ee(De, Re);
    } else {
      e.el = t.el;
      const Ie = e.anchor = t.anchor, Be = e.target = t.target, De = e.targetAnchor = t.targetAnchor, Re = bf(t.props), Ee = Re ? n : Be, ze = Re ? Ie : De;
      if (o = o || ew(Be), ye ? (I(t.dynamicChildren, ye, Ee, s, f, o, m), hd(t, e, !0)) : g || M(t, e, Ee, ze, s, f, o, m, !1), X)
        Re || xy(e, n, Ie, b, 1);
      else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
        const rt = e.target = L0(e.props, z);
        rt ? xy(e, rt, null, b, 0) : process.env.NODE_ENV !== "production" && at("Invalid Teleport target on update:", Be, `(${typeof Be})`);
      } else
        Re && xy(e, Be, De, b, 1);
    }
    LS(e);
  },
  remove(t, e, n, a, { um: s, o: { remove: f } }, o) {
    const { shapeFlag: m, children: g, anchor: b, targetAnchor: T, target: M, props: I } = t;
    if (M && f(T), (o || !bf(I)) && (f(b), m & 16))
      for (let A = 0; A < g.length; A++) {
        const z = g[A];
        s(z, e, n, !0, !!z.dynamicChildren);
      }
  },
  move: xy,
  hydrate: QP
};
function xy(t, e, n, { o: { insert: a }, m: s }, f = 2) {
  f === 0 && a(t.targetAnchor, e, n);
  const { el: o, anchor: m, shapeFlag: g, children: b, props: T } = t, M = f === 2;
  if (M && a(o, e, n), (!M || bf(T)) && g & 16)
    for (let I = 0; I < b.length; I++)
      s(b[I], e, n, 2);
  M && a(m, e, n);
}
function QP(t, e, n, a, s, f, { o: { nextSibling: o, parentNode: m, querySelector: g } }, b) {
  const T = e.target = L0(e.props, g);
  if (T) {
    const M = T._lpa || T.firstChild;
    if (e.shapeFlag & 16)
      if (bf(e.props))
        e.anchor = b(o(t), e, m(t), n, a, s, f), e.targetAnchor = M;
      else {
        e.anchor = o(t);
        let I = M;
        for (; I; )
          if (I = o(I), I && I.nodeType === 8 && I.data === "teleport anchor") {
            e.targetAnchor = I, T._lpa = e.targetAnchor && o(e.targetAnchor);
            break;
          }
        b(M, e, T, n, a, s, f);
      }
    LS(e);
  }
  return e.anchor && o(e.anchor);
}
const kS = JP;
function LS(t) {
  const e = t.ctx;
  if (e && e.ut) {
    let n = t.children[0].el;
    for (; n !== t.targetAnchor; )
      n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid), n = n.nextSibling;
    e.ut();
  }
}
const un = Symbol(process.env.NODE_ENV !== "production" ? "Fragment" : void 0), Ud = Symbol(process.env.NODE_ENV !== "production" ? "Text" : void 0), Xi = Symbol(process.env.NODE_ENV !== "production" ? "Comment" : void 0), Ky = Symbol(process.env.NODE_ENV !== "production" ? "Static" : void 0), fd = [];
let is = null;
function Ue(t = !1) {
  fd.push(is = t ? null : []);
}
function ek() {
  fd.pop(), is = fd[fd.length - 1] || null;
}
let Od = 1;
function tw(t) {
  Od += t;
}
function DS(t) {
  return t.dynamicChildren = Od > 0 ? is || vf : null, ek(), Od > 0 && is && is.push(t), t;
}
function st(t, e, n, a, s, f) {
  return DS(Ne(t, e, n, a, s, f, !0));
}
function cn(t, e, n, a, s) {
  return DS(Gt(t, e, n, a, s, !0));
}
function Af(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function Lc(t, e) {
  return process.env.NODE_ENV !== "production" && e.shapeFlag & 6 && af.has(e.type) ? (t.shapeFlag &= -257, e.shapeFlag &= -513, !1) : t.type === e.type && t.key === e.key;
}
const tk = (...t) => RS(...t), mv = "__vInternal", NS = ({ key: t }) => t != null ? t : null, Yy = ({ ref: t, ref_key: e, ref_for: n }) => t != null ? Hn(t) || hn(t) || dr(t) ? { i: zi, r: t, k: e, f: !!n } : t : null;
function Ne(t, e = null, n = null, a = 0, s = null, f = t === un ? 0 : 1, o = !1, m = !1) {
  const g = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && NS(e),
    ref: e && Yy(e),
    scopeId: hS,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: f,
    patchFlag: a,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: zi
  };
  return m ? (P1(g, n), f & 128 && t.normalize(g)) : n && (g.shapeFlag |= Hn(n) ? 8 : 16), process.env.NODE_ENV !== "production" && g.key !== g.key && at("VNode created with invalid key (NaN). VNode type:", g.type), Od > 0 && !o && is && (g.patchFlag > 0 || f & 6) && g.patchFlag !== 32 && is.push(g), g;
}
const Gt = process.env.NODE_ENV !== "production" ? tk : RS;
function RS(t, e = null, n = null, a = 0, s = null, f = !1) {
  if ((!t || t === wP) && (process.env.NODE_ENV !== "production" && !t && at(`Invalid vnode type when creating vnode: ${t}.`), t = Xi), Af(t)) {
    const m = Xs(t, e, !0);
    return n && P1(m, n), Od > 0 && !f && is && (m.shapeFlag & 6 ? is[is.indexOf(t)] = m : is.push(m)), m.patchFlag |= -2, m;
  }
  if (VS(t) && (t = t.__vccOpts), e) {
    e = rk(e);
    let { class: m, style: g } = e;
    m && !Hn(m) && (e.class = Lr(m)), fn(g) && (_g(g) && !er(g) && (g = Wn({}, g)), e.style = Rf(g));
  }
  const o = Hn(t) ? 1 : oP(t) ? 128 : YP(t) ? 64 : fn(t) ? 4 : dr(t) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && o & 4 && _g(t) && (t = lr(t), at("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `
Component that was made reactive: `, t)), Ne(t, e, n, a, s, o, f, !0);
}
function rk(t) {
  return t ? _g(t) || mv in t ? Wn({}, t) : t : null;
}
function Xs(t, e, n = !1) {
  const { props: a, ref: s, patchFlag: f, children: o } = t, m = e ? nk(a || {}, e) : a;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: m,
    key: m && NS(m),
    ref: e && e.ref ? n && s ? er(s) ? s.concat(Yy(e)) : [s, Yy(e)] : Yy(e) : s,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && f === -1 && er(o) ? o.map(zS) : o,
    target: t.target,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    patchFlag: e && t.type !== un ? f === -1 ? 16 : f | 16 : f,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: t.transition,
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && Xs(t.ssContent),
    ssFallback: t.ssFallback && Xs(t.ssFallback),
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
}
function zS(t) {
  const e = Xs(t);
  return er(t.children) && (e.children = t.children.map(zS)), e;
}
function Tg(t = " ", e = 0) {
  return Gt(Ud, null, t, e);
}
function it(t = "", e = !1) {
  return e ? (Ue(), cn(Xi, null, t)) : Gt(Xi, null, t);
}
function rs(t) {
  return t == null || typeof t == "boolean" ? Gt(Xi) : er(t) ? Gt(
    un,
    null,
    t.slice()
  ) : typeof t == "object" ? gu(t) : Gt(Ud, null, String(t));
}
function gu(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : Xs(t);
}
function P1(t, e) {
  let n = 0;
  const { shapeFlag: a } = t;
  if (e == null)
    e = null;
  else if (er(e))
    n = 16;
  else if (typeof e == "object")
    if (a & 65) {
      const s = e.default;
      s && (s._c && (s._d = !1), P1(t, s()), s._c && (s._d = !0));
      return;
    } else {
      n = 32;
      const s = e._;
      !s && !(mv in e) ? e._ctx = zi : s === 3 && zi && (zi.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
  else
    dr(e) ? (e = { default: e, _ctx: zi }, n = 32) : (e = String(e), a & 64 ? (n = 16, e = [Tg(e)]) : n = 8);
  t.children = e, t.shapeFlag |= n;
}
function nk(...t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    for (const s in a)
      if (s === "class")
        e.class !== a.class && (e.class = Lr([e.class, a.class]));
      else if (s === "style")
        e.style = Rf([e.style, a.style]);
      else if (zd(s)) {
        const f = e[s], o = a[s];
        o && f !== o && !(er(f) && f.includes(o)) && (e[s] = f ? [].concat(f, o) : o);
      } else
        s !== "" && (e[s] = a[s]);
  }
  return e;
}
function Ns(t, e, n, a = null) {
  La(t, e, 7, [
    n,
    a
  ]);
}
const ik = PS();
let ok = 0;
function ak(t, e, n) {
  const a = t.type, s = (e ? e.appContext : t.appContext) || ik, f = {
    uid: ok++,
    vnode: t,
    type: a,
    parent: e,
    appContext: s,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new LE(!0),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(s.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: MS(a, s),
    emitsOptions: cS(a, s),
    emit: null,
    emitted: null,
    propsDefaults: wn,
    inheritAttrs: a.inheritAttrs,
    ctx: wn,
    data: wn,
    props: wn,
    attrs: wn,
    slots: wn,
    refs: wn,
    setupState: wn,
    setupContext: null,
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return process.env.NODE_ENV !== "production" ? f.ctx = TP(f) : f.ctx = { _: f }, f.root = e ? e.root : f, f.emit = QA.bind(null, f), t.ce && t.ce(f), f;
}
let pi = null;
const yv = () => pi || zi, Pf = (t) => {
  pi = t, t.scope.on();
}, Uc = () => {
  pi && pi.scope.off(), pi = null;
}, sk = /* @__PURE__ */ zu("slot,component");
function D0(t, e) {
  const n = e.isNativeTag || OE;
  (sk(t) || n(t)) && at("Do not use built-in or reserved HTML elements as component id: " + t);
}
function FS(t) {
  return t.vnode.shapeFlag & 4;
}
let Cd = !1;
function lk(t, e = !1) {
  Cd = e;
  const { props: n, children: a } = t.vnode, s = FS(t);
  DP(t, n, s, e), GP(t, a);
  const f = s ? uk(t, e) : void 0;
  return Cd = !1, f;
}
function uk(t, e) {
  var n;
  const a = t.type;
  if (process.env.NODE_ENV !== "production") {
    if (a.name && D0(a.name, t.appContext.config), a.components) {
      const f = Object.keys(a.components);
      for (let o = 0; o < f.length; o++)
        D0(f[o], t.appContext.config);
    }
    if (a.directives) {
      const f = Object.keys(a.directives);
      for (let o = 0; o < f.length; o++)
        xS(f[o]);
    }
    a.compilerOptions && ck() && at('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.');
  }
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = ts(new Proxy(t.ctx, ES)), process.env.NODE_ENV !== "production" && MP(t);
  const { setup: s } = a;
  if (s) {
    const f = t.setupContext = s.length > 1 ? hk(t) : null;
    Pf(t), Kc();
    const o = Dl(s, t, 0, [process.env.NODE_ENV !== "production" ? hf(t.props) : t.props, f]);
    if (Yc(), Uc(), g1(o)) {
      if (o.then(Uc, Uc), e)
        return o.then((m) => {
          rw(t, m, e);
        }).catch((m) => {
          hv(m, t, 0);
        });
      if (t.asyncDep = o, process.env.NODE_ENV !== "production" && !t.suspense) {
        const m = (n = a.name) !== null && n !== void 0 ? n : "Anonymous";
        at(`Component <${m}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
      }
    } else
      rw(t, o, e);
  } else
    BS(t, e);
}
function rw(t, e, n) {
  dr(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : fn(e) ? (process.env.NODE_ENV !== "production" && Af(e) && at("setup() should not return VNodes directly - return a render function instead."), process.env.NODE_ENV !== "production" && (t.devtoolsRawSetupState = e), t.setupState = JE(e), process.env.NODE_ENV !== "production" && IP(t)) : process.env.NODE_ENV !== "production" && e !== void 0 && at(`setup() should return an object. Received: ${e === null ? "null" : typeof e}`), BS(t, n);
}
let N0;
const ck = () => !N0;
function BS(t, e, n) {
  const a = t.type;
  if (!t.render) {
    if (!e && N0 && !a.render) {
      const s = a.template || C1(t).template;
      if (s) {
        process.env.NODE_ENV !== "production" && Pl(t, "compile");
        const { isCustomElement: f, compilerOptions: o } = t.appContext.config, { delimiters: m, compilerOptions: g } = a, b = Wn(Wn({
          isCustomElement: f,
          delimiters: m
        }, o), g);
        a.render = N0(s, b), process.env.NODE_ENV !== "production" && kl(t, "compile");
      }
    }
    t.render = a.render || ao;
  }
  Pf(t), Kc(), CP(t), Yc(), Uc(), process.env.NODE_ENV !== "production" && !a.render && t.render === ao && !e && (a.template ? at('Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".') : at("Component is missing template or render function."));
}
function nw(t) {
  return new Proxy(t.attrs, process.env.NODE_ENV !== "production" ? {
    get(e, n) {
      return wg(), Bo(t, "get", "$attrs"), e[n];
    },
    set() {
      return at("setupContext.attrs is readonly."), !1;
    },
    deleteProperty() {
      return at("setupContext.attrs is readonly."), !1;
    }
  } : {
    get(e, n) {
      return Bo(t, "get", "$attrs"), e[n];
    }
  });
}
function hk(t) {
  const e = (a) => {
    if (process.env.NODE_ENV !== "production" && (t.exposed && at("expose() should be called only once per setup()."), a != null)) {
      let s = typeof a;
      s === "object" && (er(a) ? s = "array" : hn(a) && (s = "ref")), s !== "object" && at(`expose() should be passed a plain object, received ${s}.`);
    }
    t.exposed = a || {};
  };
  let n;
  return process.env.NODE_ENV !== "production" ? Object.freeze({
    get attrs() {
      return n || (n = nw(t));
    },
    get slots() {
      return hf(t.slots);
    },
    get emit() {
      return (a, ...s) => t.emit(a, ...s);
    },
    expose: e
  }) : {
    get attrs() {
      return n || (n = nw(t));
    },
    slots: t.slots,
    emit: t.emit,
    expose: e
  };
}
function gv(t) {
  if (t.exposed)
    return t.exposeProxy || (t.exposeProxy = new Proxy(JE(ts(t.exposed)), {
      get(e, n) {
        if (n in e)
          return e[n];
        if (n in Vc)
          return Vc[n](t);
      },
      has(e, n) {
        return n in e || n in Vc;
      }
    }));
}
const fk = /(?:^|[-_])(\w)/g, pk = (t) => t.replace(fk, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function k1(t, e = !0) {
  return dr(t) ? t.displayName || t.name : t.name || e && t.__name;
}
function vv(t, e, n = !1) {
  let a = k1(e);
  if (!a && e.__file) {
    const s = e.__file.match(/([^/\\]+)\.\w+$/);
    s && (a = s[1]);
  }
  if (!a && t && t.parent) {
    const s = (f) => {
      for (const o in f)
        if (f[o] === e)
          return o;
    };
    a = s(t.components || t.parent.type.components) || s(t.appContext.components);
  }
  return a ? pk(a) : n ? "App" : "Anonymous";
}
function VS(t) {
  return dr(t) && "__vccOpts" in t;
}
const Ur = (t, e) => AA(t, e, Cd);
function US(t, e, n) {
  const a = arguments.length;
  return a === 2 ? fn(e) && !er(e) ? Af(e) ? Gt(t, null, [e]) : Gt(t, e) : Gt(t, null, e) : (a > 3 ? n = Array.prototype.slice.call(arguments, 2) : a === 3 && Af(n) && (n = [n]), Gt(t, e, n));
}
const dk = Symbol(process.env.NODE_ENV !== "production" ? "ssrContext" : ""), mk = () => {
  {
    const t = xf(dk);
    return t || process.env.NODE_ENV !== "production" && at("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), t;
  }
};
function C_(t) {
  return !!(t && t.__v_isShallow);
}
function yk() {
  if (process.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const t = { style: "color:#3ba776" }, e = { style: "color:#0b1bc9" }, n = { style: "color:#b62e24" }, a = { style: "color:#9d288c" }, s = {
    header(M) {
      return fn(M) ? M.__isVue ? ["div", t, "VueInstance"] : hn(M) ? [
        "div",
        {},
        ["span", t, T(M)],
        "<",
        m(M.value),
        ">"
      ] : ss(M) ? [
        "div",
        {},
        ["span", t, C_(M) ? "ShallowReactive" : "Reactive"],
        "<",
        m(M),
        `>${ku(M) ? " (readonly)" : ""}`
      ] : ku(M) ? [
        "div",
        {},
        ["span", t, C_(M) ? "ShallowReadonly" : "Readonly"],
        "<",
        m(M),
        ">"
      ] : null : null;
    },
    hasBody(M) {
      return M && M.__isVue;
    },
    body(M) {
      if (M && M.__isVue)
        return [
          "div",
          {},
          ...f(M.$)
        ];
    }
  };
  function f(M) {
    const I = [];
    M.type.props && M.props && I.push(o("props", lr(M.props))), M.setupState !== wn && I.push(o("setup", M.setupState)), M.data !== wn && I.push(o("data", lr(M.data)));
    const A = g(M, "computed");
    A && I.push(o("computed", A));
    const z = g(M, "inject");
    return z && I.push(o("injected", z)), I.push([
      "div",
      {},
      [
        "span",
        {
          style: a.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: M }]
    ]), I;
  }
  function o(M, I) {
    return I = Wn({}, I), Object.keys(I).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        M
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(I).map((A) => [
          "div",
          {},
          ["span", a, A + ": "],
          m(I[A], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function m(M, I = !0) {
    return typeof M == "number" ? ["span", e, M] : typeof M == "string" ? ["span", n, JSON.stringify(M)] : typeof M == "boolean" ? ["span", a, M] : fn(M) ? ["object", { object: I ? lr(M) : M }] : ["span", n, String(M)];
  }
  function g(M, I) {
    const A = M.type;
    if (dr(A))
      return;
    const z = {};
    for (const V in M.ctx)
      b(A, V, I) && (z[V] = M.ctx[V]);
    return z;
  }
  function b(M, I, A) {
    const z = M[A];
    if (er(z) && z.includes(I) || fn(z) && I in z || M.extends && b(M.extends, I, A) || M.mixins && M.mixins.some((V) => b(V, I, A)))
      return !0;
  }
  function T(M) {
    return C_(M) ? "ShallowRef" : M.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(s) : window.devtoolsFormatters = [s];
}
const iw = "3.2.47", gk = "http://www.w3.org/2000/svg", Dc = typeof document < "u" ? document : null, ow = Dc && /* @__PURE__ */ Dc.createElement("template"), vk = {
  insert: (t, e, n) => {
    e.insertBefore(t, n || null);
  },
  remove: (t) => {
    const e = t.parentNode;
    e && e.removeChild(t);
  },
  createElement: (t, e, n, a) => {
    const s = e ? Dc.createElementNS(gk, t) : Dc.createElement(t, n ? { is: n } : void 0);
    return t === "select" && a && a.multiple != null && s.setAttribute("multiple", a.multiple), s;
  },
  createText: (t) => Dc.createTextNode(t),
  createComment: (t) => Dc.createComment(t),
  setText: (t, e) => {
    t.nodeValue = e;
  },
  setElementText: (t, e) => {
    t.textContent = e;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => Dc.querySelector(t),
  setScopeId(t, e) {
    t.setAttribute(e, "");
  },
  insertStaticContent(t, e, n, a, s, f) {
    const o = n ? n.previousSibling : e.lastChild;
    if (s && (s === f || s.nextSibling))
      for (; e.insertBefore(s.cloneNode(!0), n), !(s === f || !(s = s.nextSibling)); )
        ;
    else {
      ow.innerHTML = a ? `<svg>${t}</svg>` : t;
      const m = ow.content;
      if (a) {
        const g = m.firstChild;
        for (; g.firstChild; )
          m.appendChild(g.firstChild);
        m.removeChild(g);
      }
      e.insertBefore(m, n);
    }
    return [
      o ? o.nextSibling : e.firstChild,
      n ? n.previousSibling : e.lastChild
    ];
  }
};
function _k(t, e, n) {
  const a = t._vtc;
  a && (e = (e ? [e, ...a] : [...a]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e;
}
function xk(t, e, n) {
  const a = t.style, s = Hn(n);
  if (n && !s) {
    if (e && !Hn(e))
      for (const f in e)
        n[f] == null && R0(a, f, "");
    for (const f in n)
      R0(a, f, n[f]);
  } else {
    const f = a.display;
    s ? e !== n && (a.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (a.display = f);
  }
}
const bk = /[^\\];\s*$/, aw = /\s*!important$/;
function R0(t, e, n) {
  if (er(n))
    n.forEach((a) => R0(t, e, a));
  else if (n == null && (n = ""), process.env.NODE_ENV !== "production" && bk.test(n) && at(`Unexpected semicolon at the end of '${e}' style value: '${n}'`), e.startsWith("--"))
    t.setProperty(e, n);
  else {
    const a = wk(t, e);
    aw.test(n) ? t.setProperty(ta(a), n.replace(aw, ""), "important") : t[a] = n;
  }
}
const sw = ["Webkit", "Moz", "ms"], A_ = {};
function wk(t, e) {
  const n = A_[e];
  if (n)
    return n;
  let a = ya(e);
  if (a !== "filter" && a in t)
    return A_[e] = a;
  a = $c(a);
  for (let s = 0; s < sw.length; s++) {
    const f = sw[s] + a;
    if (f in t)
      return A_[e] = f;
  }
  return e;
}
const lw = "http://www.w3.org/1999/xlink";
function Ek(t, e, n, a, s) {
  if (a && e.startsWith("xlink:"))
    n == null ? t.removeAttributeNS(lw, e.slice(6, e.length)) : t.setAttributeNS(lw, e, n);
  else {
    const f = jC(e);
    n == null || f && !ME(n) ? t.removeAttribute(e) : t.setAttribute(e, f ? "" : n);
  }
}
function Sk(t, e, n, a, s, f, o) {
  if (e === "innerHTML" || e === "textContent") {
    a && o(a, s, f), t[e] = n == null ? "" : n;
    return;
  }
  if (e === "value" && t.tagName !== "PROGRESS" && !t.tagName.includes("-")) {
    t._value = n;
    const g = n == null ? "" : n;
    (t.value !== g || t.tagName === "OPTION") && (t.value = g), n == null && t.removeAttribute(e);
    return;
  }
  let m = !1;
  if (n === "" || n == null) {
    const g = typeof t[e];
    g === "boolean" ? n = ME(n) : n == null && g === "string" ? (n = "", m = !0) : g === "number" && (n = 0, m = !0);
  }
  try {
    t[e] = n;
  } catch (g) {
    process.env.NODE_ENV !== "production" && !m && at(`Failed setting prop "${e}" on <${t.tagName.toLowerCase()}>: value ${n} is invalid.`, g);
  }
  m && t.removeAttribute(e);
}
function Tk(t, e, n, a) {
  t.addEventListener(e, n, a);
}
function Mk(t, e, n, a) {
  t.removeEventListener(e, n, a);
}
function Ik(t, e, n, a, s = null) {
  const f = t._vei || (t._vei = {}), o = f[e];
  if (a && o)
    o.value = a;
  else {
    const [m, g] = Ok(e);
    if (a) {
      const b = f[e] = Pk(a, s);
      Tk(t, m, b, g);
    } else
      o && (Mk(t, m, o, g), f[e] = void 0);
  }
}
const uw = /(?:Once|Passive|Capture)$/;
function Ok(t) {
  let e;
  if (uw.test(t)) {
    e = {};
    let a;
    for (; a = t.match(uw); )
      t = t.slice(0, t.length - a[0].length), e[a[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : ta(t.slice(2)), e];
}
let P_ = 0;
const Ck = /* @__PURE__ */ Promise.resolve(), Ak = () => P_ || (Ck.then(() => P_ = 0), P_ = Date.now());
function Pk(t, e) {
  const n = (a) => {
    if (!a._vts)
      a._vts = Date.now();
    else if (a._vts <= n.attached)
      return;
    La(kk(a, n.value), e, 5, [a]);
  };
  return n.value = t, n.attached = Ak(), n;
}
function kk(t, e) {
  if (er(e)) {
    const n = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      n.call(t), t._stopped = !0;
    }, e.map((a) => (s) => !s._stopped && a && a(s));
  } else
    return e;
}
const cw = /^on[a-z]/, Lk = (t, e, n, a, s = !1, f, o, m, g) => {
  e === "class" ? _k(t, a, s) : e === "style" ? xk(t, n, a) : zd(e) ? dg(e) || Ik(t, e, n, a, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : Dk(t, e, a, s)) ? Sk(t, e, a, f, o, m, g) : (e === "true-value" ? t._trueValue = a : e === "false-value" && (t._falseValue = a), Ek(t, e, a, s));
};
function Dk(t, e, n, a) {
  return a ? !!(e === "innerHTML" || e === "textContent" || e in t && cw.test(e) && dr(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || cw.test(e) && Hn(n) ? !1 : e in t;
}
const cu = "transition", jp = "animation", _v = (t, { slots: e }) => US(mS, Nk(t), e);
_v.displayName = "Transition";
const jS = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
_v.props = /* @__PURE__ */ Wn({}, mS.props, jS);
const xc = (t, e = []) => {
  er(t) ? t.forEach((n) => n(...e)) : t && t(...e);
}, hw = (t) => t ? er(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;
function Nk(t) {
  const e = {};
  for (const Ze in t)
    Ze in jS || (e[Ze] = t[Ze]);
  if (t.css === !1)
    return e;
  const { name: n = "v", type: a, duration: s, enterFromClass: f = `${n}-enter-from`, enterActiveClass: o = `${n}-enter-active`, enterToClass: m = `${n}-enter-to`, appearFromClass: g = f, appearActiveClass: b = o, appearToClass: T = m, leaveFromClass: M = `${n}-leave-from`, leaveActiveClass: I = `${n}-leave-active`, leaveToClass: A = `${n}-leave-to` } = t, z = Rk(s), V = z && z[0], Z = z && z[1], { onBeforeEnter: X, onEnter: Y, onEnterCancelled: de, onLeave: ye, onLeaveCancelled: Ie, onBeforeAppear: Be = X, onAppear: De = Y, onAppearCancelled: Re = de } = e, Ee = (Ze, yt, xe) => {
    bc(Ze, yt ? T : m), bc(Ze, yt ? b : o), xe && xe();
  }, ze = (Ze, yt) => {
    Ze._isLeaving = !1, bc(Ze, M), bc(Ze, A), bc(Ze, I), yt && yt();
  }, rt = (Ze) => (yt, xe) => {
    const Ke = Ze ? De : Y, ct = () => Ee(yt, Ze, xe);
    xc(Ke, [yt, ct]), fw(() => {
      bc(yt, Ze ? g : f), hu(yt, Ze ? T : m), hw(Ke) || pw(yt, a, V, ct);
    });
  };
  return Wn(e, {
    onBeforeEnter(Ze) {
      xc(X, [Ze]), hu(Ze, f), hu(Ze, o);
    },
    onBeforeAppear(Ze) {
      xc(Be, [Ze]), hu(Ze, g), hu(Ze, b);
    },
    onEnter: rt(!1),
    onAppear: rt(!0),
    onLeave(Ze, yt) {
      Ze._isLeaving = !0;
      const xe = () => ze(Ze, yt);
      hu(Ze, M), Bk(), hu(Ze, I), fw(() => {
        !Ze._isLeaving || (bc(Ze, M), hu(Ze, A), hw(ye) || pw(Ze, a, Z, xe));
      }), xc(ye, [Ze, xe]);
    },
    onEnterCancelled(Ze) {
      Ee(Ze, !1), xc(de, [Ze]);
    },
    onAppearCancelled(Ze) {
      Ee(Ze, !0), xc(Re, [Ze]);
    },
    onLeaveCancelled(Ze) {
      ze(Ze), xc(Ie, [Ze]);
    }
  });
}
function Rk(t) {
  if (t == null)
    return null;
  if (fn(t))
    return [k_(t.enter), k_(t.leave)];
  {
    const e = k_(t);
    return [e, e];
  }
}
function k_(t) {
  const e = g0(t);
  return process.env.NODE_ENV !== "production" && NA(e, "<transition> explicit duration"), e;
}
function hu(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.add(n)), (t._vtc || (t._vtc = /* @__PURE__ */ new Set())).add(e);
}
function bc(t, e) {
  e.split(/\s+/).forEach((a) => a && t.classList.remove(a));
  const { _vtc: n } = t;
  n && (n.delete(e), n.size || (t._vtc = void 0));
}
function fw(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let zk = 0;
function pw(t, e, n, a) {
  const s = t._endId = ++zk, f = () => {
    s === t._endId && a();
  };
  if (n)
    return setTimeout(f, n);
  const { type: o, timeout: m, propCount: g } = Fk(t, e);
  if (!o)
    return a();
  const b = o + "end";
  let T = 0;
  const M = () => {
    t.removeEventListener(b, I), f();
  }, I = (A) => {
    A.target === t && ++T >= g && M();
  };
  setTimeout(() => {
    T < g && M();
  }, m + 1), t.addEventListener(b, I);
}
function Fk(t, e) {
  const n = window.getComputedStyle(t), a = (z) => (n[z] || "").split(", "), s = a(`${cu}Delay`), f = a(`${cu}Duration`), o = dw(s, f), m = a(`${jp}Delay`), g = a(`${jp}Duration`), b = dw(m, g);
  let T = null, M = 0, I = 0;
  e === cu ? o > 0 && (T = cu, M = o, I = f.length) : e === jp ? b > 0 && (T = jp, M = b, I = g.length) : (M = Math.max(o, b), T = M > 0 ? o > b ? cu : jp : null, I = T ? T === cu ? f.length : g.length : 0);
  const A = T === cu && /\b(transform|all)(,|$)/.test(a(`${cu}Property`).toString());
  return {
    type: T,
    timeout: M,
    propCount: I,
    hasTransform: A
  };
}
function dw(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((n, a) => mw(n) + mw(t[a])));
}
function mw(t) {
  return Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function Bk() {
  return document.body.offsetHeight;
}
const Vk = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, sf = (t, e) => (n) => {
  if (!("key" in n))
    return;
  const a = ta(n.key);
  if (e.some((s) => s === a || Vk[s] === a))
    return t(n);
}, Uk = /* @__PURE__ */ Wn({ patchProp: Lk }, vk);
let yw;
function GS() {
  return yw || (yw = ZP(Uk));
}
const gw = (...t) => {
  GS().render(...t);
}, jk = (...t) => {
  const e = GS().createApp(...t);
  process.env.NODE_ENV !== "production" && (Gk(e), qk(e));
  const { mount: n } = e;
  return e.mount = (a) => {
    const s = $k(a);
    if (!s)
      return;
    const f = e._component;
    !dr(f) && !f.render && !f.template && (f.template = s.innerHTML), s.innerHTML = "";
    const o = n(s, !1, s instanceof SVGElement);
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), o;
  }, e;
};
function Gk(t) {
  Object.defineProperty(t.config, "isNativeTag", {
    value: (e) => BC(e) || VC(e),
    writable: !1
  });
}
function qk(t) {
  {
    const e = t.config.isCustomElement;
    Object.defineProperty(t.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        at("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.");
      }
    });
    const n = t.config.compilerOptions, a = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom';
    Object.defineProperty(t.config, "compilerOptions", {
      get() {
        return at(a), n;
      },
      set() {
        at(a);
      }
    });
  }
}
function $k(t) {
  if (Hn(t)) {
    const e = document.querySelector(t);
    return process.env.NODE_ENV !== "production" && !e && at(`Failed to mount app: mount target selector "${t}" returned null.`), e;
  }
  return process.env.NODE_ENV !== "production" && window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && at('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'), t;
}
function Wk() {
  yk();
}
process.env.NODE_ENV !== "production" && Wk();
/*! @license DOMPurify 2.4.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.5/LICENSE */
function bu(t) {
  return bu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, bu(t);
}
function z0(t, e) {
  return z0 = Object.setPrototypeOf || function(a, s) {
    return a.__proto__ = s, a;
  }, z0(t, e);
}
function Hk() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Jy(t, e, n) {
  return Hk() ? Jy = Reflect.construct : Jy = function(s, f, o) {
    var m = [null];
    m.push.apply(m, f);
    var g = Function.bind.apply(s, m), b = new g();
    return o && z0(b, o.prototype), b;
  }, Jy.apply(null, arguments);
}
function Qa(t) {
  return Zk(t) || Xk(t) || Kk(t) || Yk();
}
function Zk(t) {
  if (Array.isArray(t))
    return F0(t);
}
function Xk(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function Kk(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return F0(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set")
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return F0(t, e);
  }
}
function F0(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, a = new Array(e); n < e; n++)
    a[n] = t[n];
  return a;
}
function Yk() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var Jk = Object.hasOwnProperty, vw = Object.setPrototypeOf, Qk = Object.isFrozen, eL = Object.getPrototypeOf, tL = Object.getOwnPropertyDescriptor, Vo = Object.freeze, cs = Object.seal, rL = Object.create, qS = typeof Reflect < "u" && Reflect, Mg = qS.apply, B0 = qS.construct;
Mg || (Mg = function(e, n, a) {
  return e.apply(n, a);
});
Vo || (Vo = function(e) {
  return e;
});
cs || (cs = function(e) {
  return e;
});
B0 || (B0 = function(e, n) {
  return Jy(e, Qa(n));
});
var nL = za(Array.prototype.forEach), _w = za(Array.prototype.pop), Gp = za(Array.prototype.push), Qy = za(String.prototype.toLowerCase), L_ = za(String.prototype.toString), iL = za(String.prototype.match), Za = za(String.prototype.replace), oL = za(String.prototype.indexOf), aL = za(String.prototype.trim), Ao = za(RegExp.prototype.test), D_ = sL(TypeError);
function za(t) {
  return function(e) {
    for (var n = arguments.length, a = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      a[s - 1] = arguments[s];
    return Mg(t, e, a);
  };
}
function sL(t) {
  return function() {
    for (var e = arguments.length, n = new Array(e), a = 0; a < e; a++)
      n[a] = arguments[a];
    return B0(t, n);
  };
}
function Or(t, e, n) {
  n = n || Qy, vw && vw(t, null);
  for (var a = e.length; a--; ) {
    var s = e[a];
    if (typeof s == "string") {
      var f = n(s);
      f !== s && (Qk(e) || (e[a] = f), s = f);
    }
    t[s] = !0;
  }
  return t;
}
function wc(t) {
  var e = rL(null), n;
  for (n in t)
    Mg(Jk, t, [n]) === !0 && (e[n] = t[n]);
  return e;
}
function by(t, e) {
  for (; t !== null; ) {
    var n = tL(t, e);
    if (n) {
      if (n.get)
        return za(n.get);
      if (typeof n.value == "function")
        return za(n.value);
    }
    t = eL(t);
  }
  function a(s) {
    return console.warn("fallback value for", s), null;
  }
  return a;
}
var xw = Vo(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), N_ = Vo(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), R_ = Vo(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), lL = Vo(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), z_ = Vo(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), uL = Vo(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), bw = Vo(["#text"]), ww = Vo(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), F_ = Vo(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Ew = Vo(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), wy = Vo(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), cL = cs(/\{\{[\w\W]*|[\w\W]*\}\}/gm), hL = cs(/<%[\w\W]*|[\w\W]*%>/gm), fL = cs(/\${[\w\W]*}/gm), pL = cs(/^data-[\-\w.\u00B7-\uFFFF]/), dL = cs(/^aria-[\-\w]+$/), mL = cs(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
), yL = cs(/^(?:\w+script|data):/i), gL = cs(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
), vL = cs(/^html$/i), _L = function() {
  return typeof window > "u" ? null : window;
}, xL = function(e, n) {
  if (bu(e) !== "object" || typeof e.createPolicy != "function")
    return null;
  var a = null, s = "data-tt-policy-suffix";
  n.currentScript && n.currentScript.hasAttribute(s) && (a = n.currentScript.getAttribute(s));
  var f = "dompurify" + (a ? "#" + a : "");
  try {
    return e.createPolicy(f, {
      createHTML: function(m) {
        return m;
      },
      createScriptURL: function(m) {
        return m;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + f + " could not be created."), null;
  }
};
function $S() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _L(), e = function(ce) {
    return $S(ce);
  };
  if (e.version = "2.4.5", e.removed = [], !t || !t.document || t.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var n = t.document, a = t.document, s = t.DocumentFragment, f = t.HTMLTemplateElement, o = t.Node, m = t.Element, g = t.NodeFilter, b = t.NamedNodeMap, T = b === void 0 ? t.NamedNodeMap || t.MozNamedAttrMap : b, M = t.HTMLFormElement, I = t.DOMParser, A = t.trustedTypes, z = m.prototype, V = by(z, "cloneNode"), Z = by(z, "nextSibling"), X = by(z, "childNodes"), Y = by(z, "parentNode");
  if (typeof f == "function") {
    var de = a.createElement("template");
    de.content && de.content.ownerDocument && (a = de.content.ownerDocument);
  }
  var ye = xL(A, n), Ie = ye ? ye.createHTML("") : "", Be = a, De = Be.implementation, Re = Be.createNodeIterator, Ee = Be.createDocumentFragment, ze = Be.getElementsByTagName, rt = n.importNode, Ze = {};
  try {
    Ze = wc(a).documentMode ? a.documentMode : {};
  } catch {
  }
  var yt = {};
  e.isSupported = typeof Y == "function" && De && typeof De.createHTMLDocument < "u" && Ze !== 9;
  var xe = cL, Ke = hL, ct = fL, vt = pL, Pt = dL, tr = yL, Pn = gL, Dr = mL, hr = null, Zn = Or({}, [].concat(Qa(xw), Qa(N_), Qa(R_), Qa(z_), Qa(bw))), Nr = null, Fi = Or({}, [].concat(Qa(ww), Qa(F_), Qa(Ew), Qa(wy))), Gr = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Cr = null, Vn = null, wr = !0, En = !0, oi = !1, Un = !0, K = !1, me = !1, Le = !1, qe = !1, $e = !1, et = !1, dt = !1, Je = !0, lt = !1, Ye = "user-content-", It = !0, bt = !1, kt = {}, Ut = null, fr = Or({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Fr = null, Ar = Or({}, ["audio", "video", "img", "source", "image", "track"]), Jr = null, Xn = Or({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Bi = "http://www.w3.org/1998/Math/MathML", so = "http://www.w3.org/2000/svg", Kn = "http://www.w3.org/1999/xhtml", ki = Kn, Sn = !1, ai = null, Fa = Or({}, [Bi, so, Kn], L_), Uo, Ba = ["application/xhtml+xml", "text/html"], na = "text/html", on, So = null, tl = a.createElement("form"), bn = function(ce) {
    return ce instanceof RegExp || ce instanceof Function;
  }, N = function(ce) {
    So && So === ce || ((!ce || bu(ce) !== "object") && (ce = {}), ce = wc(ce), Uo = Ba.indexOf(ce.PARSER_MEDIA_TYPE) === -1 ? Uo = na : Uo = ce.PARSER_MEDIA_TYPE, on = Uo === "application/xhtml+xml" ? L_ : Qy, hr = "ALLOWED_TAGS" in ce ? Or({}, ce.ALLOWED_TAGS, on) : Zn, Nr = "ALLOWED_ATTR" in ce ? Or({}, ce.ALLOWED_ATTR, on) : Fi, ai = "ALLOWED_NAMESPACES" in ce ? Or({}, ce.ALLOWED_NAMESPACES, L_) : Fa, Jr = "ADD_URI_SAFE_ATTR" in ce ? Or(
      wc(Xn),
      ce.ADD_URI_SAFE_ATTR,
      on
    ) : Xn, Fr = "ADD_DATA_URI_TAGS" in ce ? Or(
      wc(Ar),
      ce.ADD_DATA_URI_TAGS,
      on
    ) : Ar, Ut = "FORBID_CONTENTS" in ce ? Or({}, ce.FORBID_CONTENTS, on) : fr, Cr = "FORBID_TAGS" in ce ? Or({}, ce.FORBID_TAGS, on) : {}, Vn = "FORBID_ATTR" in ce ? Or({}, ce.FORBID_ATTR, on) : {}, kt = "USE_PROFILES" in ce ? ce.USE_PROFILES : !1, wr = ce.ALLOW_ARIA_ATTR !== !1, En = ce.ALLOW_DATA_ATTR !== !1, oi = ce.ALLOW_UNKNOWN_PROTOCOLS || !1, Un = ce.ALLOW_SELF_CLOSE_IN_ATTR !== !1, K = ce.SAFE_FOR_TEMPLATES || !1, me = ce.WHOLE_DOCUMENT || !1, $e = ce.RETURN_DOM || !1, et = ce.RETURN_DOM_FRAGMENT || !1, dt = ce.RETURN_TRUSTED_TYPE || !1, qe = ce.FORCE_BODY || !1, Je = ce.SANITIZE_DOM !== !1, lt = ce.SANITIZE_NAMED_PROPS || !1, It = ce.KEEP_CONTENT !== !1, bt = ce.IN_PLACE || !1, Dr = ce.ALLOWED_URI_REGEXP || Dr, ki = ce.NAMESPACE || Kn, Gr = ce.CUSTOM_ELEMENT_HANDLING || {}, ce.CUSTOM_ELEMENT_HANDLING && bn(ce.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Gr.tagNameCheck = ce.CUSTOM_ELEMENT_HANDLING.tagNameCheck), ce.CUSTOM_ELEMENT_HANDLING && bn(ce.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Gr.attributeNameCheck = ce.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), ce.CUSTOM_ELEMENT_HANDLING && typeof ce.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Gr.allowCustomizedBuiltInElements = ce.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), K && (En = !1), et && ($e = !0), kt && (hr = Or({}, Qa(bw)), Nr = [], kt.html === !0 && (Or(hr, xw), Or(Nr, ww)), kt.svg === !0 && (Or(hr, N_), Or(Nr, F_), Or(Nr, wy)), kt.svgFilters === !0 && (Or(hr, R_), Or(Nr, F_), Or(Nr, wy)), kt.mathMl === !0 && (Or(hr, z_), Or(Nr, Ew), Or(Nr, wy))), ce.ADD_TAGS && (hr === Zn && (hr = wc(hr)), Or(hr, ce.ADD_TAGS, on)), ce.ADD_ATTR && (Nr === Fi && (Nr = wc(Nr)), Or(Nr, ce.ADD_ATTR, on)), ce.ADD_URI_SAFE_ATTR && Or(Jr, ce.ADD_URI_SAFE_ATTR, on), ce.FORBID_CONTENTS && (Ut === fr && (Ut = wc(Ut)), Or(Ut, ce.FORBID_CONTENTS, on)), It && (hr["#text"] = !0), me && Or(hr, ["html", "head", "body"]), hr.table && (Or(hr, ["tbody"]), delete Cr.tbody), Vo && Vo(ce), So = ce);
  }, F = Or({}, ["mi", "mo", "mn", "ms", "mtext"]), U = Or({}, ["foreignobject", "desc", "title", "annotation-xml"]), H = Or({}, ["title", "style", "font", "a", "script"]), ee = Or({}, N_);
  Or(ee, R_), Or(ee, lL);
  var he = Or({}, z_);
  Or(he, uL);
  var fe = function(ce) {
    var we = Y(ce);
    (!we || !we.tagName) && (we = {
      namespaceURI: ki,
      tagName: "template"
    });
    var We = Qy(ce.tagName), jt = Qy(we.tagName);
    return ai[ce.namespaceURI] ? ce.namespaceURI === so ? we.namespaceURI === Kn ? We === "svg" : we.namespaceURI === Bi ? We === "svg" && (jt === "annotation-xml" || F[jt]) : Boolean(ee[We]) : ce.namespaceURI === Bi ? we.namespaceURI === Kn ? We === "math" : we.namespaceURI === so ? We === "math" && U[jt] : Boolean(he[We]) : ce.namespaceURI === Kn ? we.namespaceURI === so && !U[jt] || we.namespaceURI === Bi && !F[jt] ? !1 : !he[We] && (H[We] || !ee[We]) : !!(Uo === "application/xhtml+xml" && ai[ce.namespaceURI]) : !1;
  }, G = function(ce) {
    Gp(e.removed, {
      element: ce
    });
    try {
      ce.parentNode.removeChild(ce);
    } catch {
      try {
        ce.outerHTML = Ie;
      } catch {
        ce.remove();
      }
    }
  }, ie = function(ce, we) {
    try {
      Gp(e.removed, {
        attribute: we.getAttributeNode(ce),
        from: we
      });
    } catch {
      Gp(e.removed, {
        attribute: null,
        from: we
      });
    }
    if (we.removeAttribute(ce), ce === "is" && !Nr[ce])
      if ($e || et)
        try {
          G(we);
        } catch {
        }
      else
        try {
          we.setAttribute(ce, "");
        } catch {
        }
  }, ve = function(ce) {
    var we, We;
    if (qe)
      ce = "<remove></remove>" + ce;
    else {
      var jt = iL(ce, /^[\r\n\t ]+/);
      We = jt && jt[0];
    }
    Uo === "application/xhtml+xml" && ki === Kn && (ce = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + ce + "</body></html>");
    var Wt = ye ? ye.createHTML(ce) : ce;
    if (ki === Kn)
      try {
        we = new I().parseFromString(Wt, Uo);
      } catch {
      }
    if (!we || !we.documentElement) {
      we = De.createDocument(ki, "template", null);
      try {
        we.documentElement.innerHTML = Sn ? Ie : Wt;
      } catch {
      }
    }
    var Jt = we.body || we.documentElement;
    return ce && We && Jt.insertBefore(a.createTextNode(We), Jt.childNodes[0] || null), ki === Kn ? ze.call(we, me ? "html" : "body")[0] : me ? we.documentElement : Jt;
  }, Ge = function(ce) {
    return Re.call(
      ce.ownerDocument || ce,
      ce,
      g.SHOW_ELEMENT | g.SHOW_COMMENT | g.SHOW_TEXT,
      null,
      !1
    );
  }, He = function(ce) {
    return ce instanceof M && (typeof ce.nodeName != "string" || typeof ce.textContent != "string" || typeof ce.removeChild != "function" || !(ce.attributes instanceof T) || typeof ce.removeAttribute != "function" || typeof ce.setAttribute != "function" || typeof ce.namespaceURI != "string" || typeof ce.insertBefore != "function" || typeof ce.hasChildNodes != "function");
  }, Oe = function(ce) {
    return bu(o) === "object" ? ce instanceof o : ce && bu(ce) === "object" && typeof ce.nodeType == "number" && typeof ce.nodeName == "string";
  }, Ve = function(ce, we, We) {
    !yt[ce] || nL(yt[ce], function(jt) {
      jt.call(e, we, We, So);
    });
  }, Et = function(ce) {
    var we;
    if (Ve("beforeSanitizeElements", ce, null), He(ce) || Ao(/[\u0080-\uFFFF]/, ce.nodeName))
      return G(ce), !0;
    var We = on(ce.nodeName);
    if (Ve("uponSanitizeElement", ce, {
      tagName: We,
      allowedTags: hr
    }), ce.hasChildNodes() && !Oe(ce.firstElementChild) && (!Oe(ce.content) || !Oe(ce.content.firstElementChild)) && Ao(/<[/\w]/g, ce.innerHTML) && Ao(/<[/\w]/g, ce.textContent) || We === "select" && Ao(/<template/i, ce.innerHTML))
      return G(ce), !0;
    if (!hr[We] || Cr[We]) {
      if (!Cr[We] && Pe(We) && (Gr.tagNameCheck instanceof RegExp && Ao(Gr.tagNameCheck, We) || Gr.tagNameCheck instanceof Function && Gr.tagNameCheck(We)))
        return !1;
      if (It && !Ut[We]) {
        var jt = Y(ce) || ce.parentNode, Wt = X(ce) || ce.childNodes;
        if (Wt && jt)
          for (var Jt = Wt.length, Zt = Jt - 1; Zt >= 0; --Zt)
            jt.insertBefore(V(Wt[Zt], !0), Z(ce));
      }
      return G(ce), !0;
    }
    return ce instanceof m && !fe(ce) || (We === "noscript" || We === "noembed") && Ao(/<\/no(script|embed)/i, ce.innerHTML) ? (G(ce), !0) : (K && ce.nodeType === 3 && (we = ce.textContent, we = Za(we, xe, " "), we = Za(we, Ke, " "), we = Za(we, ct, " "), ce.textContent !== we && (Gp(e.removed, {
      element: ce.cloneNode()
    }), ce.textContent = we)), Ve("afterSanitizeElements", ce, null), !1);
  }, _t = function(ce, we, We) {
    if (Je && (we === "id" || we === "name") && (We in a || We in tl))
      return !1;
    if (!(En && !Vn[we] && Ao(vt, we))) {
      if (!(wr && Ao(Pt, we))) {
        if (!Nr[we] || Vn[we]) {
          if (!(Pe(ce) && (Gr.tagNameCheck instanceof RegExp && Ao(Gr.tagNameCheck, ce) || Gr.tagNameCheck instanceof Function && Gr.tagNameCheck(ce)) && (Gr.attributeNameCheck instanceof RegExp && Ao(Gr.attributeNameCheck, we) || Gr.attributeNameCheck instanceof Function && Gr.attributeNameCheck(we)) || we === "is" && Gr.allowCustomizedBuiltInElements && (Gr.tagNameCheck instanceof RegExp && Ao(Gr.tagNameCheck, We) || Gr.tagNameCheck instanceof Function && Gr.tagNameCheck(We))))
            return !1;
        } else if (!Jr[we]) {
          if (!Ao(Dr, Za(We, Pn, ""))) {
            if (!((we === "src" || we === "xlink:href" || we === "href") && ce !== "script" && oL(We, "data:") === 0 && Fr[ce])) {
              if (!(oi && !Ao(tr, Za(We, Pn, "")))) {
                if (We)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Pe = function(ce) {
    return ce.indexOf("-") > 0;
  }, ft = function(ce) {
    var we, We, jt, Wt;
    Ve("beforeSanitizeAttributes", ce, null);
    var Jt = ce.attributes;
    if (!!Jt) {
      var Zt = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: Nr
      };
      for (Wt = Jt.length; Wt--; ) {
        we = Jt[Wt];
        var Yn = we, Qt = Yn.name, pn = Yn.namespaceURI;
        if (We = Qt === "value" ? we.value : aL(we.value), jt = on(Qt), Zt.attrName = jt, Zt.attrValue = We, Zt.keepAttr = !0, Zt.forceKeepAttr = void 0, Ve("uponSanitizeAttribute", ce, Zt), We = Zt.attrValue, !Zt.forceKeepAttr && (ie(Qt, ce), !!Zt.keepAttr)) {
          if (!Un && Ao(/\/>/i, We)) {
            ie(Qt, ce);
            continue;
          }
          K && (We = Za(We, xe, " "), We = Za(We, Ke, " "), We = Za(We, ct, " "));
          var Br = on(ce.nodeName);
          if (!!_t(Br, jt, We)) {
            if (lt && (jt === "id" || jt === "name") && (ie(Qt, ce), We = Ye + We), ye && bu(A) === "object" && typeof A.getAttributeType == "function" && !pn)
              switch (A.getAttributeType(Br, jt)) {
                case "TrustedHTML":
                  We = ye.createHTML(We);
                  break;
                case "TrustedScriptURL":
                  We = ye.createScriptURL(We);
                  break;
              }
            try {
              pn ? ce.setAttributeNS(pn, Qt, We) : ce.setAttribute(Qt, We), _w(e.removed);
            } catch {
            }
          }
        }
      }
      Ve("afterSanitizeAttributes", ce, null);
    }
  }, ot = function ke(ce) {
    var we, We = Ge(ce);
    for (Ve("beforeSanitizeShadowDOM", ce, null); we = We.nextNode(); )
      Ve("uponSanitizeShadowNode", we, null), !Et(we) && (we.content instanceof s && ke(we.content), ft(we));
    Ve("afterSanitizeShadowDOM", ce, null);
  };
  return e.sanitize = function(ke) {
    var ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, we, We, jt, Wt, Jt;
    if (Sn = !ke, Sn && (ke = "<!-->"), typeof ke != "string" && !Oe(ke)) {
      if (typeof ke.toString != "function")
        throw D_("toString is not a function");
      if (ke = ke.toString(), typeof ke != "string")
        throw D_("dirty is not a string, aborting");
    }
    if (!e.isSupported) {
      if (bu(t.toStaticHTML) === "object" || typeof t.toStaticHTML == "function") {
        if (typeof ke == "string")
          return t.toStaticHTML(ke);
        if (Oe(ke))
          return t.toStaticHTML(ke.outerHTML);
      }
      return ke;
    }
    if (Le || N(ce), e.removed = [], typeof ke == "string" && (bt = !1), bt) {
      if (ke.nodeName) {
        var Zt = on(ke.nodeName);
        if (!hr[Zt] || Cr[Zt])
          throw D_("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (ke instanceof o)
      we = ve("<!---->"), We = we.ownerDocument.importNode(ke, !0), We.nodeType === 1 && We.nodeName === "BODY" || We.nodeName === "HTML" ? we = We : we.appendChild(We);
    else {
      if (!$e && !K && !me && ke.indexOf("<") === -1)
        return ye && dt ? ye.createHTML(ke) : ke;
      if (we = ve(ke), !we)
        return $e ? null : dt ? Ie : "";
    }
    we && qe && G(we.firstChild);
    for (var Yn = Ge(bt ? ke : we); jt = Yn.nextNode(); )
      jt.nodeType === 3 && jt === Wt || Et(jt) || (jt.content instanceof s && ot(jt.content), ft(jt), Wt = jt);
    if (Wt = null, bt)
      return ke;
    if ($e) {
      if (et)
        for (Jt = Ee.call(we.ownerDocument); we.firstChild; )
          Jt.appendChild(we.firstChild);
      else
        Jt = we;
      return (Nr.shadowroot || Nr.shadowrootmod) && (Jt = rt.call(n, Jt, !0)), Jt;
    }
    var Qt = me ? we.outerHTML : we.innerHTML;
    return me && hr["!doctype"] && we.ownerDocument && we.ownerDocument.doctype && we.ownerDocument.doctype.name && Ao(vL, we.ownerDocument.doctype.name) && (Qt = "<!DOCTYPE " + we.ownerDocument.doctype.name + `>
` + Qt), K && (Qt = Za(Qt, xe, " "), Qt = Za(Qt, Ke, " "), Qt = Za(Qt, ct, " ")), ye && dt ? ye.createHTML(Qt) : Qt;
  }, e.setConfig = function(ke) {
    N(ke), Le = !0;
  }, e.clearConfig = function() {
    So = null, Le = !1;
  }, e.isValidAttribute = function(ke, ce, we) {
    So || N({});
    var We = on(ke), jt = on(ce);
    return _t(We, jt, we);
  }, e.addHook = function(ke, ce) {
    typeof ce == "function" && (yt[ke] = yt[ke] || [], Gp(yt[ke], ce));
  }, e.removeHook = function(ke) {
    if (yt[ke])
      return _w(yt[ke]);
  }, e.removeHooks = function(ke) {
    yt[ke] && (yt[ke] = []);
  }, e.removeAllHooks = function() {
    yt = {};
  }, e;
}
var bL = $S(), WS = !1;
function Ey(t, e, n) {
  return Array.isArray(t) ? (t.length = Math.max(t.length, e), t.splice(e, 1, n), n) : (t[e] = n, n);
}
function B_(t, e) {
  if (Array.isArray(t)) {
    t.splice(e, 1);
    return;
  }
  delete t[e];
}
function wL(t, e) {
  var s;
  const n = (s = t.hooks) != null ? s : {};
  let a;
  for (a in n) {
    const f = n[a];
    f !== void 0 && e.addHook(a, f);
  }
}
function HS() {
  return bL();
}
function EL(t = {}, e = HS) {
  const n = e();
  wL(t, n);
  const a = function(s, f) {
    var M, I;
    const o = f.value;
    if (f.oldValue === o)
      return;
    const m = `${o}`, g = f.arg, b = t.namedConfigurations, T = (M = t.default) != null ? M : {};
    if (b && g !== void 0) {
      s.innerHTML = n.sanitize(
        m,
        (I = b[g]) != null ? I : T
      );
      return;
    }
    s.innerHTML = n.sanitize(
      m,
      T
    );
  };
  return {
    mounted: a,
    updated: a
  };
}
const SL = {
  install(t, e = {}, n = HS) {
    t.directive(
      "dompurify-html",
      EL(e, n)
    );
  }
};
function TL() {
  return ZS().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function ZS() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
}
const ML = typeof Proxy == "function", IL = "devtools-plugin:setup", OL = "plugin:settings:set";
let Yh, V0;
function CL() {
  var t;
  return Yh !== void 0 || (typeof window < "u" && window.performance ? (Yh = !0, V0 = window.performance) : typeof global < "u" && ((t = global.perf_hooks) === null || t === void 0 ? void 0 : t.performance) ? (Yh = !0, V0 = global.perf_hooks.performance) : Yh = !1), Yh;
}
function AL() {
  return CL() ? V0.now() : Date.now();
}
class PL {
  constructor(e, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e, this.hook = n;
    const a = {};
    if (e.settings)
      for (const o in e.settings) {
        const m = e.settings[o];
        a[o] = m.defaultValue;
      }
    const s = `__vue-devtools-plugin-settings__${e.id}`;
    let f = Object.assign({}, a);
    try {
      const o = localStorage.getItem(s), m = JSON.parse(o);
      Object.assign(f, m);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return f;
      },
      setSettings(o) {
        try {
          localStorage.setItem(s, JSON.stringify(o));
        } catch {
        }
        f = o;
      },
      now() {
        return AL();
      }
    }, n && n.on(OL, (o, m) => {
      o === this.plugin.id && this.fallbacks.setSettings(m);
    }), this.proxiedOn = new Proxy({}, {
      get: (o, m) => this.target ? this.target.on[m] : (...g) => {
        this.onQueue.push({
          method: m,
          args: g
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (o, m) => this.target ? this.target[m] : m === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(m) ? (...g) => (this.targetQueue.push({
        method: m,
        args: g,
        resolve: () => {
        }
      }), this.fallbacks[m](...g)) : (...g) => new Promise((b) => {
        this.targetQueue.push({
          method: m,
          args: g,
          resolve: b
        });
      })
    });
  }
  async setRealTarget(e) {
    this.target = e;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function XS(t, e) {
  const n = t, a = ZS(), s = TL(), f = ML && n.enableEarlyProxy;
  if (s && (a.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !f))
    s.emit(IL, t, e);
  else {
    const o = f ? new PL(n, s) : null;
    (a.__VUE_DEVTOOLS_PLUGINS__ = a.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: e,
      proxy: o
    }), o && e(o.proxiedTarget);
  }
}
/*!
  * pinia v2.0.33
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
let Jp;
const Ad = (t) => Jp = t, KS = process.env.NODE_ENV !== "production" ? Symbol("pinia") : Symbol();
function Hc(t) {
  return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
}
var qs;
(function(t) {
  t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
})(qs || (qs = {}));
const xv = typeof window < "u", pd = (process.env.NODE_ENV !== "production" || !1) && process.env.NODE_ENV !== "test" && xv, Sw = /* @__PURE__ */ (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : { HTMLElement: null })();
function kL(t, { autoBom: e = !1 } = {}) {
  return e && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], { type: t.type }) : t;
}
function L1(t, e, n) {
  const a = new XMLHttpRequest();
  a.open("GET", t), a.responseType = "blob", a.onload = function() {
    QS(a.response, e, n);
  }, a.onerror = function() {
    console.error("could not download file");
  }, a.send();
}
function YS(t) {
  const e = new XMLHttpRequest();
  e.open("HEAD", t, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function eg(t) {
  try {
    t.dispatchEvent(new MouseEvent("click"));
  } catch {
    const n = document.createEvent("MouseEvents");
    n.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), t.dispatchEvent(n);
  }
}
const tg = typeof navigator == "object" ? navigator : { userAgent: "" }, JS = /* @__PURE__ */ (() => /Macintosh/.test(tg.userAgent) && /AppleWebKit/.test(tg.userAgent) && !/Safari/.test(tg.userAgent))(), QS = xv ? typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !JS ? LL : "msSaveOrOpenBlob" in tg ? DL : NL : () => {
};
function LL(t, e = "download", n) {
  const a = document.createElement("a");
  a.download = e, a.rel = "noopener", typeof t == "string" ? (a.href = t, a.origin !== location.origin ? YS(a.href) ? L1(t, e, n) : (a.target = "_blank", eg(a)) : eg(a)) : (a.href = URL.createObjectURL(t), setTimeout(function() {
    URL.revokeObjectURL(a.href);
  }, 4e4), setTimeout(function() {
    eg(a);
  }, 0));
}
function DL(t, e = "download", n) {
  if (typeof t == "string")
    if (YS(t))
      L1(t, e, n);
    else {
      const a = document.createElement("a");
      a.href = t, a.target = "_blank", setTimeout(function() {
        eg(a);
      });
    }
  else
    navigator.msSaveOrOpenBlob(kL(t, n), e);
}
function NL(t, e, n, a) {
  if (a = a || open("", "_blank"), a && (a.document.title = a.document.body.innerText = "downloading..."), typeof t == "string")
    return L1(t, e, n);
  const s = t.type === "application/octet-stream", f = /constructor/i.test(String(Sw.HTMLElement)) || "safari" in Sw, o = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((o || s && f || JS) && typeof FileReader < "u") {
    const m = new FileReader();
    m.onloadend = function() {
      let g = m.result;
      if (typeof g != "string")
        throw a = null, new Error("Wrong reader.result type");
      g = o ? g : g.replace(/^data:[^;]*;/, "data:attachment/file;"), a ? a.location.href = g : location.assign(g), a = null;
    }, m.readAsDataURL(t);
  } else {
    const m = URL.createObjectURL(t);
    a ? a.location.assign(m) : location.href = m, a = null, setTimeout(function() {
      URL.revokeObjectURL(m);
    }, 4e4);
  }
}
function Zi(t, e) {
  const n = "\u{1F34D} " + t;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(n, e) : e === "error" ? console.error(n) : e === "warn" ? console.warn(n) : console.log(n);
}
function D1(t) {
  return "_a" in t && "install" in t;
}
function eT() {
  if (!("clipboard" in navigator))
    return Zi("Your browser doesn't support the Clipboard API", "error"), !0;
}
function tT(t) {
  return t instanceof Error && t.message.toLowerCase().includes("document is not focused") ? (Zi('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) : !1;
}
async function RL(t) {
  if (!eT())
    try {
      await navigator.clipboard.writeText(JSON.stringify(t.state.value)), Zi("Global state copied to clipboard.");
    } catch (e) {
      if (tT(e))
        return;
      Zi("Failed to serialize the state. Check the console for more details.", "error"), console.error(e);
    }
}
async function zL(t) {
  if (!eT())
    try {
      t.state.value = JSON.parse(await navigator.clipboard.readText()), Zi("Global state pasted from clipboard.");
    } catch (e) {
      if (tT(e))
        return;
      Zi("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(e);
    }
}
async function FL(t) {
  try {
    QS(new Blob([JSON.stringify(t.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (e) {
    Zi("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
let Il;
function BL() {
  Il || (Il = document.createElement("input"), Il.type = "file", Il.accept = ".json");
  function t() {
    return new Promise((e, n) => {
      Il.onchange = async () => {
        const a = Il.files;
        if (!a)
          return e(null);
        const s = a.item(0);
        return e(s ? { text: await s.text(), file: s } : null);
      }, Il.oncancel = () => e(null), Il.onerror = n, Il.click();
    });
  }
  return t;
}
async function VL(t) {
  try {
    const n = await (await BL())();
    if (!n)
      return;
    const { text: a, file: s } = n;
    t.state.value = JSON.parse(a), Zi(`Global state imported from "${s.name}".`);
  } catch (e) {
    Zi("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
function es(t) {
  return {
    _custom: {
      display: t
    }
  };
}
const rT = "\u{1F34D} Pinia (root)", U0 = "_root";
function UL(t) {
  return D1(t) ? {
    id: U0,
    label: rT
  } : {
    id: t.$id,
    label: t.$id
  };
}
function jL(t) {
  if (D1(t)) {
    const n = Array.from(t._s.keys()), a = t._s;
    return {
      state: n.map((f) => ({
        editable: !0,
        key: f,
        value: t.state.value[f]
      })),
      getters: n.filter((f) => a.get(f)._getters).map((f) => {
        const o = a.get(f);
        return {
          editable: !1,
          key: f,
          value: o._getters.reduce((m, g) => (m[g] = o[g], m), {})
        };
      })
    };
  }
  const e = {
    state: Object.keys(t.$state).map((n) => ({
      editable: !0,
      key: n,
      value: t.$state[n]
    }))
  };
  return t._getters && t._getters.length && (e.getters = t._getters.map((n) => ({
    editable: !1,
    key: n,
    value: t[n]
  }))), t._customProperties.size && (e.customProperties = Array.from(t._customProperties).map((n) => ({
    editable: !0,
    key: n,
    value: t[n]
  }))), e;
}
function GL(t) {
  return t ? Array.isArray(t) ? t.reduce((e, n) => (e.keys.push(n.key), e.operations.push(n.type), e.oldValue[n.key] = n.oldValue, e.newValue[n.key] = n.newValue, e), {
    oldValue: {},
    keys: [],
    operations: [],
    newValue: {}
  }) : {
    operation: es(t.type),
    key: es(t.key),
    oldValue: t.oldValue,
    newValue: t.newValue
  } : {};
}
function qL(t) {
  switch (t) {
    case qs.direct:
      return "mutation";
    case qs.patchFunction:
      return "$patch";
    case qs.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let ff = !0;
const rg = [], Ac = "pinia:mutations", vo = "pinia", { assign: $L } = Object, Ig = (t) => "\u{1F34D} " + t;
function WL(t, e) {
  XS({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: rg,
    app: t
  }, (n) => {
    typeof n.now != "function" && Zi("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), n.addTimelineLayer({
      id: Ac,
      label: "Pinia \u{1F34D}",
      color: 15064968
    }), n.addInspector({
      id: vo,
      label: "Pinia \u{1F34D}",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            RL(e);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: async () => {
            await zL(e), n.sendInspectorTree(vo), n.sendInspectorState(vo);
          },
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            FL(e);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: async () => {
            await VL(e), n.sendInspectorTree(vo), n.sendInspectorState(vo);
          },
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: "Reset the state (option store only)",
          action: (a) => {
            const s = e._s.get(a);
            s ? s._isOptionsAPI ? (s.$reset(), Zi(`Store "${a}" reset.`)) : Zi(`Cannot reset "${a}" store because it's a setup store.`, "warn") : Zi(`Cannot reset "${a}" store because it wasn't found.`, "warn");
          }
        }
      ]
    }), n.on.inspectComponent((a, s) => {
      const f = a.componentInstance && a.componentInstance.proxy;
      if (f && f._pStores) {
        const o = a.componentInstance.proxy._pStores;
        Object.values(o).forEach((m) => {
          a.instanceData.state.push({
            type: Ig(m.$id),
            key: "state",
            editable: !0,
            value: m._isOptionsAPI ? {
              _custom: {
                value: lr(m.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => m.$reset()
                  }
                ]
              }
            } : Object.keys(m.$state).reduce((g, b) => (g[b] = m.$state[b], g), {})
          }), m._getters && m._getters.length && a.instanceData.state.push({
            type: Ig(m.$id),
            key: "getters",
            editable: !1,
            value: m._getters.reduce((g, b) => {
              try {
                g[b] = m[b];
              } catch (T) {
                g[b] = T;
              }
              return g;
            }, {})
          });
        });
      }
    }), n.on.getInspectorTree((a) => {
      if (a.app === t && a.inspectorId === vo) {
        let s = [e];
        s = s.concat(Array.from(e._s.values())), a.rootNodes = (a.filter ? s.filter((f) => "$id" in f ? f.$id.toLowerCase().includes(a.filter.toLowerCase()) : rT.toLowerCase().includes(a.filter.toLowerCase())) : s).map(UL);
      }
    }), n.on.getInspectorState((a) => {
      if (a.app === t && a.inspectorId === vo) {
        const s = a.nodeId === U0 ? e : e._s.get(a.nodeId);
        if (!s)
          return;
        s && (a.state = jL(s));
      }
    }), n.on.editInspectorState((a, s) => {
      if (a.app === t && a.inspectorId === vo) {
        const f = a.nodeId === U0 ? e : e._s.get(a.nodeId);
        if (!f)
          return Zi(`store "${a.nodeId}" not found`, "error");
        const { path: o } = a;
        D1(f) ? o.unshift("state") : (o.length !== 1 || !f._customProperties.has(o[0]) || o[0] in f.$state) && o.unshift("$state"), ff = !1, a.set(f, o, a.state.value), ff = !0;
      }
    }), n.on.editComponentState((a) => {
      if (a.type.startsWith("\u{1F34D}")) {
        const s = a.type.replace(/^🍍\s*/, ""), f = e._s.get(s);
        if (!f)
          return Zi(`store "${s}" not found`, "error");
        const { path: o } = a;
        if (o[0] !== "state")
          return Zi(`Invalid path for store "${s}":
${o}
Only state can be modified.`);
        o[0] = "$state", ff = !1, a.set(f, o, a.state.value), ff = !0;
      }
    });
  });
}
function HL(t, e) {
  rg.includes(Ig(e.$id)) || rg.push(Ig(e.$id)), XS({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: rg,
    app: t,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: !0
      }
    }
  }, (n) => {
    const a = typeof n.now == "function" ? n.now.bind(n) : Date.now;
    e.$onAction(({ after: o, onError: m, name: g, args: b }) => {
      const T = nT++;
      n.addTimelineEvent({
        layerId: Ac,
        event: {
          time: a(),
          title: "\u{1F6EB} " + g,
          subtitle: "start",
          data: {
            store: es(e.$id),
            action: es(g),
            args: b
          },
          groupId: T
        }
      }), o((M) => {
        Nc = void 0, n.addTimelineEvent({
          layerId: Ac,
          event: {
            time: a(),
            title: "\u{1F6EC} " + g,
            subtitle: "end",
            data: {
              store: es(e.$id),
              action: es(g),
              args: b,
              result: M
            },
            groupId: T
          }
        });
      }), m((M) => {
        Nc = void 0, n.addTimelineEvent({
          layerId: Ac,
          event: {
            time: a(),
            logType: "error",
            title: "\u{1F4A5} " + g,
            subtitle: "end",
            data: {
              store: es(e.$id),
              action: es(g),
              args: b,
              error: M
            },
            groupId: T
          }
        });
      });
    }, !0), e._customProperties.forEach((o) => {
      Bn(() => le(e[o]), (m, g) => {
        n.notifyComponentUpdate(), n.sendInspectorState(vo), ff && n.addTimelineEvent({
          layerId: Ac,
          event: {
            time: a(),
            title: "Change",
            subtitle: o,
            data: {
              newValue: m,
              oldValue: g
            },
            groupId: Nc
          }
        });
      }, { deep: !0 });
    }), e.$subscribe(({ events: o, type: m }, g) => {
      if (n.notifyComponentUpdate(), n.sendInspectorState(vo), !ff)
        return;
      const b = {
        time: a(),
        title: qL(m),
        data: $L({ store: es(e.$id) }, GL(o)),
        groupId: Nc
      };
      Nc = void 0, m === qs.patchFunction ? b.subtitle = "\u2935\uFE0F" : m === qs.patchObject ? b.subtitle = "\u{1F9E9}" : o && !Array.isArray(o) && (b.subtitle = o.type), o && (b.data["rawEvent(s)"] = {
        _custom: {
          display: "DebuggerEvent",
          type: "object",
          tooltip: "raw DebuggerEvent[]",
          value: o
        }
      }), n.addTimelineEvent({
        layerId: Ac,
        event: b
      });
    }, { detached: !0, flush: "sync" });
    const s = e._hotUpdate;
    e._hotUpdate = ts((o) => {
      s(o), n.addTimelineEvent({
        layerId: Ac,
        event: {
          time: a(),
          title: "\u{1F525} " + e.$id,
          subtitle: "HMR update",
          data: {
            store: es(e.$id),
            info: es("HMR update")
          }
        }
      }), n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo);
    });
    const { $dispose: f } = e;
    e.$dispose = () => {
      f(), n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo), n.getSettings().logStoreChanges && Zi(`Disposed "${e.$id}" store \u{1F5D1}`);
    }, n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo), n.getSettings().logStoreChanges && Zi(`"${e.$id}" store installed \u{1F195}`);
  });
}
let nT = 0, Nc;
function Tw(t, e) {
  const n = e.reduce((a, s) => (a[s] = lr(t)[s], a), {});
  for (const a in n)
    t[a] = function() {
      const s = nT, f = new Proxy(t, {
        get(...o) {
          return Nc = s, Reflect.get(...o);
        },
        set(...o) {
          return Nc = s, Reflect.set(...o);
        }
      });
      return n[a].apply(f, arguments);
    };
}
function ZL({ app: t, store: e, options: n }) {
  if (!e.$id.startsWith("__hot:")) {
    if (n.state && (e._isOptionsAPI = !0), typeof n.state == "function") {
      Tw(
        e,
        Object.keys(n.actions)
      );
      const a = e._hotUpdate;
      lr(e)._hotUpdate = function(s) {
        a.apply(this, arguments), Tw(e, Object.keys(s._hmrPayload.actions));
      };
    }
    HL(
      t,
      e
    );
  }
}
function XL() {
  const t = DE(!0), e = t.run(() => Hr({}));
  let n = [], a = [];
  const s = ts({
    install(f) {
      Ad(s), s._a = f, f.provide(KS, s), f.config.globalProperties.$pinia = s, pd && WL(f, s), a.forEach((o) => n.push(o)), a = [];
    },
    use(f) {
      return !this._a && !WS ? a.push(f) : n.push(f), this;
    },
    _p: n,
    _a: null,
    _e: t,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return pd && typeof Proxy < "u" && s.use(ZL), s;
}
function iT(t, e) {
  for (const n in e) {
    const a = e[n];
    if (!(n in t))
      continue;
    const s = t[n];
    Hc(s) && Hc(a) && !hn(a) && !ss(a) ? t[n] = iT(s, a) : t[n] = a;
  }
  return t;
}
const oT = () => {
};
function Mw(t, e, n, a = oT) {
  t.push(e);
  const s = () => {
    const f = t.indexOf(e);
    f > -1 && (t.splice(f, 1), a());
  };
  return !n && NE() && KC(s), s;
}
function Jh(t, ...e) {
  t.slice().forEach((n) => {
    n(...e);
  });
}
function j0(t, e) {
  t instanceof Map && e instanceof Map && e.forEach((n, a) => t.set(a, n)), t instanceof Set && e instanceof Set && e.forEach(t.add, t);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const a = e[n], s = t[n];
    Hc(s) && Hc(a) && t.hasOwnProperty(n) && !hn(a) && !ss(a) ? t[n] = j0(s, a) : t[n] = a;
  }
  return t;
}
const KL = process.env.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : Symbol();
function YL(t) {
  return !Hc(t) || !t.hasOwnProperty(KL);
}
const { assign: Oa } = Object;
function Iw(t) {
  return !!(hn(t) && t.effect);
}
function Ow(t, e, n, a) {
  const { state: s, actions: f, getters: o } = e, m = n.state.value[t];
  let g;
  function b() {
    !m && (process.env.NODE_ENV === "production" || !a) && (n.state.value[t] = s ? s() : {});
    const T = process.env.NODE_ENV !== "production" && a ? Bb(Hr(s ? s() : {}).value) : Bb(n.state.value[t]);
    return Oa(T, f, Object.keys(o || {}).reduce((M, I) => (process.env.NODE_ENV !== "production" && I in T && console.warn(`[\u{1F34D}]: A getter cannot have the same name as another state property. Rename one of them. Found with "${I}" in store "${t}".`), M[I] = ts(Ur(() => {
      Ad(n);
      const A = n._s.get(t);
      return o[I].call(A, A);
    })), M), {}));
  }
  return g = G0(t, b, e, n, a, !0), g;
}
function G0(t, e, n = {}, a, s, f) {
  let o;
  const m = Oa({ actions: {} }, n);
  if (process.env.NODE_ENV !== "production" && !a._e.active)
    throw new Error("Pinia destroyed");
  const g = {
    deep: !0
  };
  process.env.NODE_ENV !== "production" && !WS && (g.onTrigger = (Ee) => {
    b ? A = Ee : b == !1 && !De._hotUpdating && (Array.isArray(A) ? A.push(Ee) : console.error("\u{1F34D} debuggerEvents should be an array. This is most likely an internal Pinia bug."));
  });
  let b, T, M = ts([]), I = ts([]), A;
  const z = a.state.value[t];
  !f && !z && (process.env.NODE_ENV === "production" || !s) && (a.state.value[t] = {});
  const V = Hr({});
  let Z;
  function X(Ee) {
    let ze;
    b = T = !1, process.env.NODE_ENV !== "production" && (A = []), typeof Ee == "function" ? (Ee(a.state.value[t]), ze = {
      type: qs.patchFunction,
      storeId: t,
      events: A
    }) : (j0(a.state.value[t], Ee), ze = {
      type: qs.patchObject,
      payload: Ee,
      storeId: t,
      events: A
    });
    const rt = Z = Symbol();
    xg().then(() => {
      Z === rt && (b = !0);
    }), T = !0, Jh(M, ze, a.state.value[t]);
  }
  const Y = f ? function() {
    const { state: ze } = n, rt = ze ? ze() : {};
    this.$patch((Ze) => {
      Oa(Ze, rt);
    });
  } : process.env.NODE_ENV !== "production" ? () => {
    throw new Error(`\u{1F34D}: Store "${t}" is built using the setup syntax and does not implement $reset().`);
  } : oT;
  function de() {
    o.stop(), M = [], I = [], a._s.delete(t);
  }
  function ye(Ee, ze) {
    return function() {
      Ad(a);
      const rt = Array.from(arguments), Ze = [], yt = [];
      function xe(vt) {
        Ze.push(vt);
      }
      function Ke(vt) {
        yt.push(vt);
      }
      Jh(I, {
        args: rt,
        name: Ee,
        store: De,
        after: xe,
        onError: Ke
      });
      let ct;
      try {
        ct = ze.apply(this && this.$id === t ? this : De, rt);
      } catch (vt) {
        throw Jh(yt, vt), vt;
      }
      return ct instanceof Promise ? ct.then((vt) => (Jh(Ze, vt), vt)).catch((vt) => (Jh(yt, vt), Promise.reject(vt))) : (Jh(Ze, ct), ct);
    };
  }
  const Ie = /* @__PURE__ */ ts({
    actions: {},
    getters: {},
    state: [],
    hotState: V
  }), Be = {
    _p: a,
    $id: t,
    $onAction: Mw.bind(null, I),
    $patch: X,
    $reset: Y,
    $subscribe(Ee, ze = {}) {
      const rt = Mw(M, Ee, ze.detached, () => Ze()), Ze = o.run(() => Bn(() => a.state.value[t], (yt) => {
        (ze.flush === "sync" ? T : b) && Ee({
          storeId: t,
          type: qs.direct,
          events: A
        }, yt);
      }, Oa({}, g, ze)));
      return rt;
    },
    $dispose: de
  }, De = uv(process.env.NODE_ENV !== "production" || pd ? Oa(
    {
      _hmrPayload: Ie,
      _customProperties: ts(/* @__PURE__ */ new Set())
    },
    Be
  ) : Be);
  a._s.set(t, De);
  const Re = a._e.run(() => (o = DE(), o.run(() => e())));
  for (const Ee in Re) {
    const ze = Re[Ee];
    if (hn(ze) && !Iw(ze) || ss(ze))
      process.env.NODE_ENV !== "production" && s ? Ey(V.value, Ee, ld(Re, Ee)) : f || (z && YL(ze) && (hn(ze) ? ze.value = z[Ee] : j0(ze, z[Ee])), a.state.value[t][Ee] = ze), process.env.NODE_ENV !== "production" && Ie.state.push(Ee);
    else if (typeof ze == "function") {
      const rt = process.env.NODE_ENV !== "production" && s ? ze : ye(Ee, ze);
      Re[Ee] = rt, process.env.NODE_ENV !== "production" && (Ie.actions[Ee] = ze), m.actions[Ee] = ze;
    } else
      process.env.NODE_ENV !== "production" && Iw(ze) && (Ie.getters[Ee] = f ? n.getters[Ee] : ze, xv && (Re._getters || (Re._getters = ts([]))).push(Ee));
  }
  if (Oa(De, Re), Oa(lr(De), Re), Object.defineProperty(De, "$state", {
    get: () => process.env.NODE_ENV !== "production" && s ? V.value : a.state.value[t],
    set: (Ee) => {
      if (process.env.NODE_ENV !== "production" && s)
        throw new Error("cannot set hotState");
      X((ze) => {
        Oa(ze, Ee);
      });
    }
  }), process.env.NODE_ENV !== "production" && (De._hotUpdate = ts((Ee) => {
    De._hotUpdating = !0, Ee._hmrPayload.state.forEach((ze) => {
      if (ze in De.$state) {
        const rt = Ee.$state[ze], Ze = De.$state[ze];
        typeof rt == "object" && Hc(rt) && Hc(Ze) ? iT(rt, Ze) : Ee.$state[ze] = Ze;
      }
      Ey(De, ze, ld(Ee.$state, ze));
    }), Object.keys(De.$state).forEach((ze) => {
      ze in Ee.$state || B_(De, ze);
    }), b = !1, T = !1, a.state.value[t] = ld(Ee._hmrPayload, "hotState"), T = !0, xg().then(() => {
      b = !0;
    });
    for (const ze in Ee._hmrPayload.actions) {
      const rt = Ee[ze];
      Ey(De, ze, ye(ze, rt));
    }
    for (const ze in Ee._hmrPayload.getters) {
      const rt = Ee._hmrPayload.getters[ze], Ze = f ? Ur(() => (Ad(a), rt.call(De, De))) : rt;
      Ey(De, ze, Ze);
    }
    Object.keys(De._hmrPayload.getters).forEach((ze) => {
      ze in Ee._hmrPayload.getters || B_(De, ze);
    }), Object.keys(De._hmrPayload.actions).forEach((ze) => {
      ze in Ee._hmrPayload.actions || B_(De, ze);
    }), De._hmrPayload = Ee._hmrPayload, De._getters = Ee._getters, De._hotUpdating = !1;
  })), pd) {
    const Ee = {
      writable: !0,
      configurable: !0,
      enumerable: !1
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((ze) => {
      Object.defineProperty(De, ze, Oa({ value: De[ze] }, Ee));
    });
  }
  return a._p.forEach((Ee) => {
    if (pd) {
      const ze = o.run(() => Ee({
        store: De,
        app: a._a,
        pinia: a,
        options: m
      }));
      Object.keys(ze || {}).forEach((rt) => De._customProperties.add(rt)), Oa(De, ze);
    } else
      Oa(De, o.run(() => Ee({
        store: De,
        app: a._a,
        pinia: a,
        options: m
      })));
  }), process.env.NODE_ENV !== "production" && De.$state && typeof De.$state == "object" && typeof De.$state.constructor == "function" && !De.$state.constructor.toString().includes("[native code]") && console.warn(`[\u{1F34D}]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${De.$id}".`), z && f && n.hydrate && n.hydrate(De.$state, z), b = !0, T = !0, De;
}
function Qc(t, e, n) {
  let a, s;
  const f = typeof e == "function";
  typeof t == "string" ? (a = t, s = f ? n : e) : (s = t, a = t.id);
  function o(m, g) {
    const b = yv();
    if (m = (process.env.NODE_ENV === "test" && Jp && Jp._testing ? null : m) || b && xf(KS, null), m && Ad(m), process.env.NODE_ENV !== "production" && !Jp)
      throw new Error(`[\u{1F34D}]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);
    m = Jp, m._s.has(a) || (f ? G0(a, e, s, m) : Ow(a, s, m), process.env.NODE_ENV !== "production" && (o._pinia = m));
    const T = m._s.get(a);
    if (process.env.NODE_ENV !== "production" && g) {
      const M = "__hot:" + a, I = f ? G0(M, e, s, m, !0) : Ow(M, Oa({}, s), m, !0);
      g._hotUpdate(I), delete m.state.value[M], m._s.delete(M);
    }
    if (process.env.NODE_ENV !== "production" && xv && b && b.proxy && !g) {
      const M = b.proxy, I = "_pStores" in M ? M._pStores : M._pStores = {};
      I[a] = T;
    }
    return T;
  }
  return o.$id = a, o;
}
function xn(t) {
  {
    t = lr(t);
    const e = {};
    for (const n in t) {
      const a = t[n];
      (hn(a) || ss(a)) && (e[n] = ld(t, n));
    }
    return e;
  }
}
function JL(t) {
  t("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), t.WGS84 = t["EPSG:4326"], t["EPSG:3785"] = t["EPSG:3857"], t.GOOGLE = t["EPSG:3857"], t["EPSG:900913"] = t["EPSG:3857"], t["EPSG:102113"] = t["EPSG:3857"];
}
var Zc = 1, Xc = 2, wf = 3, QL = 4, q0 = 5, Cw = 6378137, eD = 6356752314e-3, Aw = 0.0066943799901413165, dd = 484813681109536e-20, ht = Math.PI / 2, tD = 0.16666666666666666, rD = 0.04722222222222222, nD = 0.022156084656084655, Ct = 1e-10, io = 0.017453292519943295, js = 57.29577951308232, sn = Math.PI / 4, Pd = Math.PI * 2, wi = 3.14159265359, ra = {};
ra.greenwich = 0;
ra.lisbon = -9.131906111111;
ra.paris = 2.337229166667;
ra.bogota = -74.080916666667;
ra.madrid = -3.687938888889;
ra.rome = 12.452333333333;
ra.bern = 7.439583333333;
ra.jakarta = 106.807719444444;
ra.ferro = -17.666666666667;
ra.brussels = 4.367975;
ra.stockholm = 18.058277777778;
ra.athens = 23.7163375;
ra.oslo = 10.722916666667;
const iD = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var Pw = /[\s_\-\/\(\)]/g;
function Lu(t, e) {
  if (t[e])
    return t[e];
  for (var n = Object.keys(t), a = e.toLowerCase().replace(Pw, ""), s = -1, f, o; ++s < n.length; )
    if (f = n[s], o = f.toLowerCase().replace(Pw, ""), o === a)
      return t[f];
}
function $0(t) {
  var e = {}, n = t.split("+").map(function(m) {
    return m.trim();
  }).filter(function(m) {
    return m;
  }).reduce(function(m, g) {
    var b = g.split("=");
    return b.push(!0), m[b[0].toLowerCase()] = b[1], m;
  }, {}), a, s, f, o = {
    proj: "projName",
    datum: "datumCode",
    rf: function(m) {
      e.rf = parseFloat(m);
    },
    lat_0: function(m) {
      e.lat0 = m * io;
    },
    lat_1: function(m) {
      e.lat1 = m * io;
    },
    lat_2: function(m) {
      e.lat2 = m * io;
    },
    lat_ts: function(m) {
      e.lat_ts = m * io;
    },
    lon_0: function(m) {
      e.long0 = m * io;
    },
    lon_1: function(m) {
      e.long1 = m * io;
    },
    lon_2: function(m) {
      e.long2 = m * io;
    },
    alpha: function(m) {
      e.alpha = parseFloat(m) * io;
    },
    gamma: function(m) {
      e.rectified_grid_angle = parseFloat(m);
    },
    lonc: function(m) {
      e.longc = m * io;
    },
    x_0: function(m) {
      e.x0 = parseFloat(m);
    },
    y_0: function(m) {
      e.y0 = parseFloat(m);
    },
    k_0: function(m) {
      e.k0 = parseFloat(m);
    },
    k: function(m) {
      e.k0 = parseFloat(m);
    },
    a: function(m) {
      e.a = parseFloat(m);
    },
    b: function(m) {
      e.b = parseFloat(m);
    },
    r_a: function() {
      e.R_A = !0;
    },
    zone: function(m) {
      e.zone = parseInt(m, 10);
    },
    south: function() {
      e.utmSouth = !0;
    },
    towgs84: function(m) {
      e.datum_params = m.split(",").map(function(g) {
        return parseFloat(g);
      });
    },
    to_meter: function(m) {
      e.to_meter = parseFloat(m);
    },
    units: function(m) {
      e.units = m;
      var g = Lu(iD, m);
      g && (e.to_meter = g.to_meter);
    },
    from_greenwich: function(m) {
      e.from_greenwich = m * io;
    },
    pm: function(m) {
      var g = Lu(ra, m);
      e.from_greenwich = (g || parseFloat(m)) * io;
    },
    nadgrids: function(m) {
      m === "@null" ? e.datumCode = "none" : e.nadgrids = m;
    },
    axis: function(m) {
      var g = "ewnsud";
      m.length === 3 && g.indexOf(m.substr(0, 1)) !== -1 && g.indexOf(m.substr(1, 1)) !== -1 && g.indexOf(m.substr(2, 1)) !== -1 && (e.axis = m);
    },
    approx: function() {
      e.approx = !0;
    }
  };
  for (a in n)
    s = n[a], a in o ? (f = o[a], typeof f == "function" ? f(s) : e[f] = s) : e[a] = s;
  return typeof e.datumCode == "string" && e.datumCode !== "WGS84" && (e.datumCode = e.datumCode.toLowerCase()), e;
}
var kd = 1, aT = 2, sT = 3, Og = 4, lT = 5, N1 = -1, oD = /\s/, aD = /[A-Za-z]/, sD = /[A-Za-z84_]/, bv = /[,\]]/, uT = /[\d\.E\-\+]/;
function Gl(t) {
  if (typeof t != "string")
    throw new Error("not a string");
  this.text = t.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = kd;
}
Gl.prototype.readCharicter = function() {
  var t = this.text[this.place++];
  if (this.state !== Og)
    for (; oD.test(t); ) {
      if (this.place >= this.text.length)
        return;
      t = this.text[this.place++];
    }
  switch (this.state) {
    case kd:
      return this.neutral(t);
    case aT:
      return this.keyword(t);
    case Og:
      return this.quoted(t);
    case lT:
      return this.afterquote(t);
    case sT:
      return this.number(t);
    case N1:
      return;
  }
};
Gl.prototype.afterquote = function(t) {
  if (t === '"') {
    this.word += '"', this.state = Og;
    return;
  }
  if (bv.test(t)) {
    this.word = this.word.trim(), this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in afterquote yet, index ' + this.place);
};
Gl.prototype.afterItem = function(t) {
  if (t === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = kd;
    return;
  }
  if (t === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = kd, this.currentObject = this.stack.pop(), this.currentObject || (this.state = N1);
    return;
  }
};
Gl.prototype.number = function(t) {
  if (uT.test(t)) {
    this.word += t;
    return;
  }
  if (bv.test(t)) {
    this.word = parseFloat(this.word), this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in number yet, index ' + this.place);
};
Gl.prototype.quoted = function(t) {
  if (t === '"') {
    this.state = lT;
    return;
  }
  this.word += t;
};
Gl.prototype.keyword = function(t) {
  if (sD.test(t)) {
    this.word += t;
    return;
  }
  if (t === "[") {
    var e = [];
    e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, this.state = kd;
    return;
  }
  if (bv.test(t)) {
    this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in keyword yet, index ' + this.place);
};
Gl.prototype.neutral = function(t) {
  if (aD.test(t)) {
    this.word = t, this.state = aT;
    return;
  }
  if (t === '"') {
    this.word = "", this.state = Og;
    return;
  }
  if (uT.test(t)) {
    this.word = t, this.state = sT;
    return;
  }
  if (bv.test(t)) {
    this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in neutral yet, index ' + this.place);
};
Gl.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === N1)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function lD(t) {
  var e = new Gl(t);
  return e.output();
}
function kw(t, e, n) {
  Array.isArray(e) && (n.unshift(e), e = null);
  var a = e ? {} : t, s = n.reduce(function(f, o) {
    return pf(o, f), f;
  }, a);
  e && (t[e] = s);
}
function pf(t, e) {
  if (!Array.isArray(t)) {
    e[t] = !0;
    return;
  }
  var n = t.shift();
  if (n === "PARAMETER" && (n = t.shift()), t.length === 1) {
    if (Array.isArray(t[0])) {
      e[n] = {}, pf(t[0], e[n]);
      return;
    }
    e[n] = t[0];
    return;
  }
  if (!t.length) {
    e[n] = !0;
    return;
  }
  if (n === "TOWGS84") {
    e[n] = t;
    return;
  }
  if (n === "AXIS") {
    n in e || (e[n] = []), e[n].push(t);
    return;
  }
  Array.isArray(n) || (e[n] = {});
  var a;
  switch (n) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      e[n] = {
        name: t[0].toLowerCase(),
        convert: t[1]
      }, t.length === 3 && pf(t[2], e[n]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      e[n] = {
        name: t[0],
        a: t[1],
        rf: t[2]
      }, t.length === 4 && pf(t[3], e[n]);
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      t[0] = ["name", t[0]], kw(e, n, t);
      return;
    default:
      for (a = -1; ++a < t.length; )
        if (!Array.isArray(t[a]))
          return pf(t, e[n]);
      return kw(e, n, t);
  }
}
var uD = 0.017453292519943295;
function cD(t, e) {
  var n = e[0], a = e[1];
  !(n in t) && a in t && (t[n] = t[a], e.length === 3 && (t[n] = e[2](t[n])));
}
function Ol(t) {
  return t * uD;
}
function hD(t) {
  if (t.type === "GEOGCS" ? t.projName = "longlat" : t.type === "LOCAL_CS" ? (t.projName = "identity", t.local = !0) : typeof t.PROJECTION == "object" ? t.projName = Object.keys(t.PROJECTION)[0] : t.projName = t.PROJECTION, t.AXIS) {
    for (var e = "", n = 0, a = t.AXIS.length; n < a; ++n) {
      var s = [t.AXIS[n][0].toLowerCase(), t.AXIS[n][1].toLowerCase()];
      s[0].indexOf("north") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "north" ? e += "n" : s[0].indexOf("south") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "south" ? e += "s" : s[0].indexOf("east") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "east" ? e += "e" : (s[0].indexOf("west") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "west") && (e += "w");
    }
    e.length === 2 && (e += "u"), e.length === 3 && (t.axis = e);
  }
  t.UNIT && (t.units = t.UNIT.name.toLowerCase(), t.units === "metre" && (t.units = "meter"), t.UNIT.convert && (t.type === "GEOGCS" ? t.DATUM && t.DATUM.SPHEROID && (t.to_meter = t.UNIT.convert * t.DATUM.SPHEROID.a) : t.to_meter = t.UNIT.convert));
  var f = t.GEOGCS;
  t.type === "GEOGCS" && (f = t), f && (f.DATUM ? t.datumCode = f.DATUM.name.toLowerCase() : t.datumCode = f.name.toLowerCase(), t.datumCode.slice(0, 2) === "d_" && (t.datumCode = t.datumCode.slice(2)), (t.datumCode === "new_zealand_geodetic_datum_1949" || t.datumCode === "new_zealand_1949") && (t.datumCode = "nzgd49"), (t.datumCode === "wgs_1984" || t.datumCode === "world_geodetic_system_1984") && (t.PROJECTION === "Mercator_Auxiliary_Sphere" && (t.sphere = !0), t.datumCode = "wgs84"), t.datumCode.slice(-6) === "_ferro" && (t.datumCode = t.datumCode.slice(0, -6)), t.datumCode.slice(-8) === "_jakarta" && (t.datumCode = t.datumCode.slice(0, -8)), ~t.datumCode.indexOf("belge") && (t.datumCode = "rnb72"), f.DATUM && f.DATUM.SPHEROID && (t.ellps = f.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), t.ellps.toLowerCase().slice(0, 13) === "international" && (t.ellps = "intl"), t.a = f.DATUM.SPHEROID.a, t.rf = parseFloat(f.DATUM.SPHEROID.rf, 10)), f.DATUM && f.DATUM.TOWGS84 && (t.datum_params = f.DATUM.TOWGS84), ~t.datumCode.indexOf("osgb_1936") && (t.datumCode = "osgb36"), ~t.datumCode.indexOf("osni_1952") && (t.datumCode = "osni52"), (~t.datumCode.indexOf("tm65") || ~t.datumCode.indexOf("geodetic_datum_of_1965")) && (t.datumCode = "ire65"), t.datumCode === "ch1903+" && (t.datumCode = "ch1903"), ~t.datumCode.indexOf("israel") && (t.datumCode = "isr93")), t.b && !isFinite(t.b) && (t.b = t.a);
  function o(b) {
    var T = t.to_meter || 1;
    return b * T;
  }
  var m = function(b) {
    return cD(t, b);
  }, g = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", Ol],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", Ol],
    ["x0", "false_easting", o],
    ["y0", "false_northing", o],
    ["long0", "central_meridian", Ol],
    ["lat0", "latitude_of_origin", Ol],
    ["lat0", "standard_parallel_1", Ol],
    ["lat1", "standard_parallel_1", Ol],
    ["lat2", "standard_parallel_2", Ol],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", Ol],
    ["srsCode", "name"]
  ];
  g.forEach(m), !t.long0 && t.longc && (t.projName === "Albers_Conic_Equal_Area" || t.projName === "Lambert_Azimuthal_Equal_Area") && (t.long0 = t.longc), !t.lat_ts && t.lat1 && (t.projName === "Stereographic_South_Pole" || t.projName === "Polar Stereographic (variant B)") && (t.lat0 = Ol(t.lat1 > 0 ? 90 : -90), t.lat_ts = t.lat1);
}
function cT(t) {
  var e = lD(t), n = e.shift(), a = e.shift();
  e.unshift(["name", a]), e.unshift(["type", n]);
  var s = {};
  return pf(e, s), hD(s), s;
}
function Do(t) {
  var e = this;
  if (arguments.length === 2) {
    var n = arguments[1];
    typeof n == "string" ? n.charAt(0) === "+" ? Do[t] = $0(arguments[1]) : Do[t] = cT(arguments[1]) : Do[t] = n;
  } else if (arguments.length === 1) {
    if (Array.isArray(t))
      return t.map(function(a) {
        Array.isArray(a) ? Do.apply(e, a) : Do(a);
      });
    if (typeof t == "string") {
      if (t in Do)
        return Do[t];
    } else
      "EPSG" in t ? Do["EPSG:" + t.EPSG] = t : "ESRI" in t ? Do["ESRI:" + t.ESRI] = t : "IAU2000" in t ? Do["IAU2000:" + t.IAU2000] = t : console.log(t);
    return;
  }
}
JL(Do);
function fD(t) {
  return typeof t == "string";
}
function pD(t) {
  return t in Do;
}
var dD = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function mD(t) {
  return dD.some(function(e) {
    return t.indexOf(e) > -1;
  });
}
var yD = ["3857", "900913", "3785", "102113"];
function gD(t) {
  var e = Lu(t, "authority");
  if (!!e) {
    var n = Lu(e, "epsg");
    return n && yD.indexOf(n) > -1;
  }
}
function vD(t) {
  var e = Lu(t, "extension");
  if (!!e)
    return Lu(e, "proj4");
}
function _D(t) {
  return t[0] === "+";
}
function xD(t) {
  if (fD(t)) {
    if (pD(t))
      return Do[t];
    if (mD(t)) {
      var e = cT(t);
      if (gD(e))
        return Do["EPSG:3857"];
      var n = vD(e);
      return n ? $0(n) : e;
    }
    if (_D(t))
      return $0(t);
  } else
    return t;
}
function Lw(t, e) {
  t = t || {};
  var n, a;
  if (!e)
    return t;
  for (a in e)
    n = e[a], n !== void 0 && (t[a] = n);
  return t;
}
function Ks(t, e, n) {
  var a = t * e;
  return n / Math.sqrt(1 - a * a);
}
function jd(t) {
  return t < 0 ? -1 : 1;
}
function Bt(t) {
  return Math.abs(t) <= wi ? t : t - jd(t) * Pd;
}
function ls(t, e, n) {
  var a = t * n, s = 0.5 * t;
  return a = Math.pow((1 - a) / (1 + a), s), Math.tan(0.5 * (ht - e)) / a;
}
function Ld(t, e) {
  for (var n = 0.5 * t, a, s, f = ht - 2 * Math.atan(e), o = 0; o <= 15; o++)
    if (a = t * Math.sin(f), s = ht - 2 * Math.atan(e * Math.pow((1 - a) / (1 + a), n)) - f, f += s, Math.abs(s) <= 1e-10)
      return f;
  return -9999;
}
function bD() {
  var t = this.b / this.a;
  this.es = 1 - t * t, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = Ks(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function wD(t) {
  var e = t.x, n = t.y;
  if (n * js > 90 && n * js < -90 && e * js > 180 && e * js < -180)
    return null;
  var a, s;
  if (Math.abs(Math.abs(n) - ht) <= Ct)
    return null;
  if (this.sphere)
    a = this.x0 + this.a * this.k0 * Bt(e - this.long0), s = this.y0 + this.a * this.k0 * Math.log(Math.tan(sn + 0.5 * n));
  else {
    var f = Math.sin(n), o = ls(this.e, n, f);
    a = this.x0 + this.a * this.k0 * Bt(e - this.long0), s = this.y0 - this.a * this.k0 * Math.log(o);
  }
  return t.x = a, t.y = s, t;
}
function ED(t) {
  var e = t.x - this.x0, n = t.y - this.y0, a, s;
  if (this.sphere)
    s = ht - 2 * Math.atan(Math.exp(-n / (this.a * this.k0)));
  else {
    var f = Math.exp(-n / (this.a * this.k0));
    if (s = Ld(this.e, f), s === -9999)
      return null;
  }
  return a = Bt(this.long0 + e / (this.a * this.k0)), t.x = a, t.y = s, t;
}
var SD = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const TD = {
  init: bD,
  forward: wD,
  inverse: ED,
  names: SD
};
function MD() {
}
function Dw(t) {
  return t;
}
var ID = ["longlat", "identity"];
const OD = {
  init: MD,
  forward: Dw,
  inverse: Dw,
  names: ID
};
var CD = [TD, OD], ng = {}, Cg = [];
function hT(t, e) {
  var n = Cg.length;
  return t.names ? (Cg[n] = t, t.names.forEach(function(a) {
    ng[a.toLowerCase()] = n;
  }), this) : (console.log(e), !0);
}
function AD(t) {
  if (!t)
    return !1;
  var e = t.toLowerCase();
  if (typeof ng[e] < "u" && Cg[ng[e]])
    return Cg[ng[e]];
}
function PD() {
  CD.forEach(hT);
}
const kD = {
  start: PD,
  add: hT,
  get: AD
};
var vr = {};
vr.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
vr.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
vr.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
vr.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
vr.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
vr.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
vr.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
vr.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
vr.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
vr.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
vr.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
vr.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
vr.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
vr.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
vr.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
vr.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
vr.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
vr.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
vr.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
vr.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
vr.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
vr.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
vr.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
vr.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
vr.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
vr.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
vr.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
vr.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
vr.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
vr.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
vr.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
vr.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
vr.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
vr.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
vr.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
vr.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
vr.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
vr.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
vr.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
vr.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
vr.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var LD = vr.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
vr.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function DD(t, e, n, a) {
  var s = t * t, f = e * e, o = (s - f) / s, m = 0;
  a ? (t *= 1 - o * (tD + o * (rD + o * nD)), s = t * t, o = 0) : m = Math.sqrt(o);
  var g = (s - f) / f;
  return {
    es: o,
    e: m,
    ep2: g
  };
}
function ND(t, e, n, a, s) {
  if (!t) {
    var f = Lu(vr, a);
    f || (f = LD), t = f.a, e = f.b, n = f.rf;
  }
  return n && !e && (e = (1 - 1 / n) * t), (n === 0 || Math.abs(t - e) < Ct) && (s = !0, e = t), {
    a: t,
    b: e,
    rf: n,
    sphere: s
  };
}
var Ki = {};
Ki.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
Ki.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
Ki.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
Ki.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
Ki.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
Ki.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
Ki.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
Ki.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
Ki.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
Ki.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
Ki.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
Ki.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
Ki.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
Ki.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
Ki.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
Ki.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
Ki.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function RD(t, e, n, a, s, f, o) {
  var m = {};
  return t === void 0 || t === "none" ? m.datum_type = q0 : m.datum_type = QL, e && (m.datum_params = e.map(parseFloat), (m.datum_params[0] !== 0 || m.datum_params[1] !== 0 || m.datum_params[2] !== 0) && (m.datum_type = Zc), m.datum_params.length > 3 && (m.datum_params[3] !== 0 || m.datum_params[4] !== 0 || m.datum_params[5] !== 0 || m.datum_params[6] !== 0) && (m.datum_type = Xc, m.datum_params[3] *= dd, m.datum_params[4] *= dd, m.datum_params[5] *= dd, m.datum_params[6] = m.datum_params[6] / 1e6 + 1)), o && (m.datum_type = wf, m.grids = o), m.a = n, m.b = a, m.es = s, m.ep2 = f, m;
}
var fT = {};
function zD(t, e) {
  var n = new DataView(e), a = VD(n), s = UD(n, a);
  s.nSubgrids > 1 && console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
  var f = jD(n, s, a), o = { header: s, subgrids: f };
  return fT[t] = o, o;
}
function FD(t) {
  if (t === void 0)
    return null;
  var e = t.split(",");
  return e.map(BD);
}
function BD(t) {
  if (t.length === 0)
    return null;
  var e = t[0] === "@";
  return e && (t = t.slice(1)), t === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : {
    name: t,
    mandatory: !e,
    grid: fT[t] || null,
    isNull: !1
  };
}
function df(t) {
  return t / 3600 * Math.PI / 180;
}
function VD(t) {
  var e = t.getInt32(8, !1);
  return e === 11 ? !1 : (e = t.getInt32(8, !0), e !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function UD(t, e) {
  return {
    nFields: t.getInt32(8, e),
    nSubgridFields: t.getInt32(24, e),
    nSubgrids: t.getInt32(40, e),
    shiftType: W0(t, 56, 56 + 8).trim(),
    fromSemiMajorAxis: t.getFloat64(120, e),
    fromSemiMinorAxis: t.getFloat64(136, e),
    toSemiMajorAxis: t.getFloat64(152, e),
    toSemiMinorAxis: t.getFloat64(168, e)
  };
}
function W0(t, e, n) {
  return String.fromCharCode.apply(null, new Uint8Array(t.buffer.slice(e, n)));
}
function jD(t, e, n) {
  for (var a = 176, s = [], f = 0; f < e.nSubgrids; f++) {
    var o = qD(t, a, n), m = $D(t, a, o, n), g = Math.round(
      1 + (o.upperLongitude - o.lowerLongitude) / o.longitudeInterval
    ), b = Math.round(
      1 + (o.upperLatitude - o.lowerLatitude) / o.latitudeInterval
    );
    s.push({
      ll: [df(o.lowerLongitude), df(o.lowerLatitude)],
      del: [df(o.longitudeInterval), df(o.latitudeInterval)],
      lim: [g, b],
      count: o.gridNodeCount,
      cvs: GD(m)
    });
  }
  return s;
}
function GD(t) {
  return t.map(function(e) {
    return [df(e.longitudeShift), df(e.latitudeShift)];
  });
}
function qD(t, e, n) {
  return {
    name: W0(t, e + 8, e + 16).trim(),
    parent: W0(t, e + 24, e + 24 + 8).trim(),
    lowerLatitude: t.getFloat64(e + 72, n),
    upperLatitude: t.getFloat64(e + 88, n),
    lowerLongitude: t.getFloat64(e + 104, n),
    upperLongitude: t.getFloat64(e + 120, n),
    latitudeInterval: t.getFloat64(e + 136, n),
    longitudeInterval: t.getFloat64(e + 152, n),
    gridNodeCount: t.getInt32(e + 168, n)
  };
}
function $D(t, e, n, a) {
  for (var s = e + 176, f = 16, o = [], m = 0; m < n.gridNodeCount; m++) {
    var g = {
      latitudeShift: t.getFloat32(s + m * f, a),
      longitudeShift: t.getFloat32(s + m * f + 4, a),
      latitudeAccuracy: t.getFloat32(s + m * f + 8, a),
      longitudeAccuracy: t.getFloat32(s + m * f + 12, a)
    };
    o.push(g);
  }
  return o;
}
function $s(t, e) {
  if (!(this instanceof $s))
    return new $s(t);
  e = e || function(b) {
    if (b)
      throw b;
  };
  var n = xD(t);
  if (typeof n != "object") {
    e(t);
    return;
  }
  var a = $s.projections.get(n.projName);
  if (!a) {
    e(t);
    return;
  }
  if (n.datumCode && n.datumCode !== "none") {
    var s = Lu(Ki, n.datumCode);
    s && (n.datum_params = n.datum_params || (s.towgs84 ? s.towgs84.split(",") : null), n.ellps = s.ellipse, n.datumName = s.datumName ? s.datumName : n.datumCode);
  }
  n.k0 = n.k0 || 1, n.axis = n.axis || "enu", n.ellps = n.ellps || "wgs84", n.lat1 = n.lat1 || n.lat0;
  var f = ND(n.a, n.b, n.rf, n.ellps, n.sphere), o = DD(f.a, f.b, f.rf, n.R_A), m = FD(n.nadgrids), g = n.datum || RD(
    n.datumCode,
    n.datum_params,
    f.a,
    f.b,
    o.es,
    o.ep2,
    m
  );
  Lw(this, n), Lw(this, a), this.a = f.a, this.b = f.b, this.rf = f.rf, this.sphere = f.sphere, this.es = o.es, this.e = o.e, this.ep2 = o.ep2, this.datum = g, this.init(), e(null, this);
}
$s.projections = kD;
$s.projections.start();
function WD(t, e) {
  return t.datum_type !== e.datum_type || t.a !== e.a || Math.abs(t.es - e.es) > 5e-11 ? !1 : t.datum_type === Zc ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] : t.datum_type === Xc ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] && t.datum_params[3] === e.datum_params[3] && t.datum_params[4] === e.datum_params[4] && t.datum_params[5] === e.datum_params[5] && t.datum_params[6] === e.datum_params[6] : !0;
}
function pT(t, e, n) {
  var a = t.x, s = t.y, f = t.z ? t.z : 0, o, m, g, b;
  if (s < -ht && s > -1.001 * ht)
    s = -ht;
  else if (s > ht && s < 1.001 * ht)
    s = ht;
  else {
    if (s < -ht)
      return { x: -1 / 0, y: -1 / 0, z: t.z };
    if (s > ht)
      return { x: 1 / 0, y: 1 / 0, z: t.z };
  }
  return a > Math.PI && (a -= 2 * Math.PI), m = Math.sin(s), b = Math.cos(s), g = m * m, o = n / Math.sqrt(1 - e * g), {
    x: (o + f) * b * Math.cos(a),
    y: (o + f) * b * Math.sin(a),
    z: (o * (1 - e) + f) * m
  };
}
function dT(t, e, n, a) {
  var s = 1e-12, f = s * s, o = 30, m, g, b, T, M, I, A, z, V, Z, X, Y, de, ye = t.x, Ie = t.y, Be = t.z ? t.z : 0, De, Re, Ee;
  if (m = Math.sqrt(ye * ye + Ie * Ie), g = Math.sqrt(ye * ye + Ie * Ie + Be * Be), m / n < s) {
    if (De = 0, g / n < s)
      return Re = ht, Ee = -a, {
        x: t.x,
        y: t.y,
        z: t.z
      };
  } else
    De = Math.atan2(Ie, ye);
  b = Be / g, T = m / g, M = 1 / Math.sqrt(1 - e * (2 - e) * T * T), z = T * (1 - e) * M, V = b * M, de = 0;
  do
    de++, A = n / Math.sqrt(1 - e * V * V), Ee = m * z + Be * V - A * (1 - e * V * V), I = e * A / (A + Ee), M = 1 / Math.sqrt(1 - I * (2 - I) * T * T), Z = T * (1 - I) * M, X = b * M, Y = X * z - Z * V, z = Z, V = X;
  while (Y * Y > f && de < o);
  return Re = Math.atan(X / Math.abs(Z)), {
    x: De,
    y: Re,
    z: Ee
  };
}
function HD(t, e, n) {
  if (e === Zc)
    return {
      x: t.x + n[0],
      y: t.y + n[1],
      z: t.z + n[2]
    };
  if (e === Xc) {
    var a = n[0], s = n[1], f = n[2], o = n[3], m = n[4], g = n[5], b = n[6];
    return {
      x: b * (t.x - g * t.y + m * t.z) + a,
      y: b * (g * t.x + t.y - o * t.z) + s,
      z: b * (-m * t.x + o * t.y + t.z) + f
    };
  }
}
function ZD(t, e, n) {
  if (e === Zc)
    return {
      x: t.x - n[0],
      y: t.y - n[1],
      z: t.z - n[2]
    };
  if (e === Xc) {
    var a = n[0], s = n[1], f = n[2], o = n[3], m = n[4], g = n[5], b = n[6], T = (t.x - a) / b, M = (t.y - s) / b, I = (t.z - f) / b;
    return {
      x: T + g * M - m * I,
      y: -g * T + M + o * I,
      z: m * T - o * M + I
    };
  }
}
function Sy(t) {
  return t === Zc || t === Xc;
}
function XD(t, e, n) {
  if (WD(t, e) || t.datum_type === q0 || e.datum_type === q0)
    return n;
  var a = t.a, s = t.es;
  if (t.datum_type === wf) {
    var f = Nw(t, !1, n);
    if (f !== 0)
      return;
    a = Cw, s = Aw;
  }
  var o = e.a, m = e.b, g = e.es;
  if (e.datum_type === wf && (o = Cw, m = eD, g = Aw), s === g && a === o && !Sy(t.datum_type) && !Sy(e.datum_type))
    return n;
  if (n = pT(n, s, a), Sy(t.datum_type) && (n = HD(n, t.datum_type, t.datum_params)), Sy(e.datum_type) && (n = ZD(n, e.datum_type, e.datum_params)), n = dT(n, g, o, m), e.datum_type === wf) {
    var b = Nw(e, !0, n);
    if (b !== 0)
      return;
  }
  return n;
}
function Nw(t, e, n) {
  if (t.grids === null || t.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  for (var a = { x: -n.x, y: n.y }, s = { x: Number.NaN, y: Number.NaN }, f = [], o = 0; o < t.grids.length; o++) {
    var m = t.grids[o];
    if (f.push(m.name), m.isNull) {
      s = a;
      break;
    }
    if (m.mandatory, m.grid === null) {
      if (m.mandatory)
        return console.log("Unable to find mandatory grid '" + m.name + "'"), -1;
      continue;
    }
    var g = m.grid.subgrids[0], b = (Math.abs(g.del[1]) + Math.abs(g.del[0])) / 1e4, T = g.ll[0] - b, M = g.ll[1] - b, I = g.ll[0] + (g.lim[0] - 1) * g.del[0] + b, A = g.ll[1] + (g.lim[1] - 1) * g.del[1] + b;
    if (!(M > a.y || T > a.x || A < a.y || I < a.x) && (s = KD(a, e, g), !isNaN(s.x)))
      break;
  }
  return isNaN(s.x) ? (console.log("Failed to find a grid shift table for location '" + -a.x * js + " " + a.y * js + " tried: '" + f + "'"), -1) : (n.x = -s.x, n.y = s.y, 0);
}
function KD(t, e, n) {
  var a = { x: Number.NaN, y: Number.NaN };
  if (isNaN(t.x))
    return a;
  var s = { x: t.x, y: t.y };
  s.x -= n.ll[0], s.y -= n.ll[1], s.x = Bt(s.x - Math.PI) + Math.PI;
  var f = Rw(s, n);
  if (e) {
    if (isNaN(f.x))
      return a;
    f.x = s.x - f.x, f.y = s.y - f.y;
    var o = 9, m = 1e-12, g, b;
    do {
      if (b = Rw(f, n), isNaN(b.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      g = { x: s.x - (b.x + f.x), y: s.y - (b.y + f.y) }, f.x += g.x, f.y += g.y;
    } while (o-- && Math.abs(g.x) > m && Math.abs(g.y) > m);
    if (o < 0)
      return console.log("Inverse grid shift iterator failed to converge."), a;
    a.x = Bt(f.x + n.ll[0]), a.y = f.y + n.ll[1];
  } else
    isNaN(f.x) || (a.x = t.x + f.x, a.y = t.y + f.y);
  return a;
}
function Rw(t, e) {
  var n = { x: t.x / e.del[0], y: t.y / e.del[1] }, a = { x: Math.floor(n.x), y: Math.floor(n.y) }, s = { x: n.x - 1 * a.x, y: n.y - 1 * a.y }, f = { x: Number.NaN, y: Number.NaN }, o;
  if (a.x < 0 || a.x >= e.lim[0] || a.y < 0 || a.y >= e.lim[1])
    return f;
  o = a.y * e.lim[0] + a.x;
  var m = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o++;
  var g = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o += e.lim[0];
  var b = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o--;
  var T = { x: e.cvs[o][0], y: e.cvs[o][1] }, M = s.x * s.y, I = s.x * (1 - s.y), A = (1 - s.x) * (1 - s.y), z = (1 - s.x) * s.y;
  return f.x = A * m.x + I * g.x + z * T.x + M * b.x, f.y = A * m.y + I * g.y + z * T.y + M * b.y, f;
}
function zw(t, e, n) {
  var a = n.x, s = n.y, f = n.z || 0, o, m, g, b = {};
  for (g = 0; g < 3; g++)
    if (!(e && g === 2 && n.z === void 0))
      switch (g === 0 ? (o = a, "ew".indexOf(t.axis[g]) !== -1 ? m = "x" : m = "y") : g === 1 ? (o = s, "ns".indexOf(t.axis[g]) !== -1 ? m = "y" : m = "x") : (o = f, m = "z"), t.axis[g]) {
        case "e":
          b[m] = o;
          break;
        case "w":
          b[m] = -o;
          break;
        case "n":
          b[m] = o;
          break;
        case "s":
          b[m] = -o;
          break;
        case "u":
          n[m] !== void 0 && (b.z = o);
          break;
        case "d":
          n[m] !== void 0 && (b.z = -o);
          break;
        default:
          return null;
      }
  return b;
}
function mT(t) {
  var e = {
    x: t[0],
    y: t[1]
  };
  return t.length > 2 && (e.z = t[2]), t.length > 3 && (e.m = t[3]), e;
}
function YD(t) {
  Fw(t.x), Fw(t.y);
}
function Fw(t) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(t))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof t != "number" || t !== t || !isFinite(t))
    throw new TypeError("coordinates must be finite numbers");
}
function JD(t, e) {
  return (t.datum.datum_type === Zc || t.datum.datum_type === Xc || t.datum.datum_type === wf) && e.datumCode !== "WGS84" || (e.datum.datum_type === Zc || e.datum.datum_type === Xc || e.datum.datum_type === wf) && t.datumCode !== "WGS84";
}
function Ag(t, e, n, a) {
  var s;
  Array.isArray(n) ? n = mT(n) : n = {
    x: n.x,
    y: n.y,
    z: n.z,
    m: n.m
  };
  var f = n.z !== void 0;
  if (YD(n), t.datum && e.datum && JD(t, e) && (s = new $s("WGS84"), n = Ag(t, s, n, a), t = s), a && t.axis !== "enu" && (n = zw(t, !1, n)), t.projName === "longlat")
    n = {
      x: n.x * io,
      y: n.y * io,
      z: n.z || 0
    };
  else if (t.to_meter && (n = {
    x: n.x * t.to_meter,
    y: n.y * t.to_meter,
    z: n.z || 0
  }), n = t.inverse(n), !n)
    return;
  if (t.from_greenwich && (n.x += t.from_greenwich), n = XD(t.datum, e.datum, n), !!n)
    return e.from_greenwich && (n = {
      x: n.x - e.from_greenwich,
      y: n.y,
      z: n.z || 0
    }), e.projName === "longlat" ? n = {
      x: n.x * js,
      y: n.y * js,
      z: n.z || 0
    } : (n = e.forward(n), e.to_meter && (n = {
      x: n.x / e.to_meter,
      y: n.y / e.to_meter,
      z: n.z || 0
    })), a && e.axis !== "enu" ? zw(e, !0, n) : (f || delete n.z, n);
}
var Bw = $s("WGS84");
function V_(t, e, n, a) {
  var s, f, o;
  return Array.isArray(n) ? (s = Ag(t, e, n, a) || { x: NaN, y: NaN }, n.length > 2 ? typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent" ? typeof s.z == "number" ? [s.x, s.y, s.z].concat(n.splice(3)) : [s.x, s.y, n[2]].concat(n.splice(3)) : [s.x, s.y].concat(n.splice(2)) : [s.x, s.y]) : (f = Ag(t, e, n, a), o = Object.keys(n), o.length === 2 || o.forEach(function(m) {
    if (typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent") {
      if (m === "x" || m === "y" || m === "z")
        return;
    } else if (m === "x" || m === "y")
      return;
    f[m] = n[m];
  }), f);
}
function Vw(t) {
  return t instanceof $s ? t : t.oProj ? t.oProj : $s(t);
}
function wo(t, e, n) {
  t = Vw(t);
  var a = !1, s;
  return typeof e > "u" ? (e = t, t = Bw, a = !0) : (typeof e.x < "u" || Array.isArray(e)) && (n = e, e = t, t = Bw, a = !0), e = Vw(e), n ? V_(t, e, n) : (s = {
    forward: function(f, o) {
      return V_(t, e, f, o);
    },
    inverse: function(f, o) {
      return V_(e, t, f, o);
    }
  }, a && (s.oProj = e), s);
}
var Uw = 6, yT = "AJSAJS", gT = "AFAFAF", mf = 65, Qo = 73, Ca = 79, Qp = 86, ed = 90;
const QD = {
  forward: vT,
  inverse: eN,
  toPoint: _T
};
function vT(t, e) {
  return e = e || 5, nN(tN({
    lat: t[1],
    lon: t[0]
  }), e);
}
function eN(t) {
  var e = R1(bT(t.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
}
function _T(t) {
  var e = R1(bT(t.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function U_(t) {
  return t * (Math.PI / 180);
}
function jw(t) {
  return 180 * (t / Math.PI);
}
function tN(t) {
  var e = t.lat, n = t.lon, a = 6378137, s = 669438e-8, f = 0.9996, o, m, g, b, T, M, I, A = U_(e), z = U_(n), V, Z;
  Z = Math.floor((n + 180) / 6) + 1, n === 180 && (Z = 60), e >= 56 && e < 64 && n >= 3 && n < 12 && (Z = 32), e >= 72 && e < 84 && (n >= 0 && n < 9 ? Z = 31 : n >= 9 && n < 21 ? Z = 33 : n >= 21 && n < 33 ? Z = 35 : n >= 33 && n < 42 && (Z = 37)), o = (Z - 1) * 6 - 180 + 3, V = U_(o), m = s / (1 - s), g = a / Math.sqrt(1 - s * Math.sin(A) * Math.sin(A)), b = Math.tan(A) * Math.tan(A), T = m * Math.cos(A) * Math.cos(A), M = Math.cos(A) * (z - V), I = a * ((1 - s / 4 - 3 * s * s / 64 - 5 * s * s * s / 256) * A - (3 * s / 8 + 3 * s * s / 32 + 45 * s * s * s / 1024) * Math.sin(2 * A) + (15 * s * s / 256 + 45 * s * s * s / 1024) * Math.sin(4 * A) - 35 * s * s * s / 3072 * Math.sin(6 * A));
  var X = f * g * (M + (1 - b + T) * M * M * M / 6 + (5 - 18 * b + b * b + 72 * T - 58 * m) * M * M * M * M * M / 120) + 5e5, Y = f * (I + g * Math.tan(A) * (M * M / 2 + (5 - b + 9 * T + 4 * T * T) * M * M * M * M / 24 + (61 - 58 * b + b * b + 600 * T - 330 * m) * M * M * M * M * M * M / 720));
  return e < 0 && (Y += 1e7), {
    northing: Math.round(Y),
    easting: Math.round(X),
    zoneNumber: Z,
    zoneLetter: rN(e)
  };
}
function R1(t) {
  var e = t.northing, n = t.easting, a = t.zoneLetter, s = t.zoneNumber;
  if (s < 0 || s > 60)
    return null;
  var f = 0.9996, o = 6378137, m = 669438e-8, g, b = (1 - Math.sqrt(1 - m)) / (1 + Math.sqrt(1 - m)), T, M, I, A, z, V, Z, X, Y, de = n - 5e5, ye = e;
  a < "N" && (ye -= 1e7), Z = (s - 1) * 6 - 180 + 3, g = m / (1 - m), V = ye / f, X = V / (o * (1 - m / 4 - 3 * m * m / 64 - 5 * m * m * m / 256)), Y = X + (3 * b / 2 - 27 * b * b * b / 32) * Math.sin(2 * X) + (21 * b * b / 16 - 55 * b * b * b * b / 32) * Math.sin(4 * X) + 151 * b * b * b / 96 * Math.sin(6 * X), T = o / Math.sqrt(1 - m * Math.sin(Y) * Math.sin(Y)), M = Math.tan(Y) * Math.tan(Y), I = g * Math.cos(Y) * Math.cos(Y), A = o * (1 - m) / Math.pow(1 - m * Math.sin(Y) * Math.sin(Y), 1.5), z = de / (T * f);
  var Ie = Y - T * Math.tan(Y) / A * (z * z / 2 - (5 + 3 * M + 10 * I - 4 * I * I - 9 * g) * z * z * z * z / 24 + (61 + 90 * M + 298 * I + 45 * M * M - 252 * g - 3 * I * I) * z * z * z * z * z * z / 720);
  Ie = jw(Ie);
  var Be = (z - (1 + 2 * M + I) * z * z * z / 6 + (5 - 2 * I + 28 * M - 3 * I * I + 8 * g + 24 * M * M) * z * z * z * z * z / 120) / Math.cos(Y);
  Be = Z + jw(Be);
  var De;
  if (t.accuracy) {
    var Re = R1({
      northing: t.northing + t.accuracy,
      easting: t.easting + t.accuracy,
      zoneLetter: t.zoneLetter,
      zoneNumber: t.zoneNumber
    });
    De = {
      top: Re.lat,
      right: Re.lon,
      bottom: Ie,
      left: Be
    };
  } else
    De = {
      lat: Ie,
      lon: Be
    };
  return De;
}
function rN(t) {
  var e = "Z";
  return 84 >= t && t >= 72 ? e = "X" : 72 > t && t >= 64 ? e = "W" : 64 > t && t >= 56 ? e = "V" : 56 > t && t >= 48 ? e = "U" : 48 > t && t >= 40 ? e = "T" : 40 > t && t >= 32 ? e = "S" : 32 > t && t >= 24 ? e = "R" : 24 > t && t >= 16 ? e = "Q" : 16 > t && t >= 8 ? e = "P" : 8 > t && t >= 0 ? e = "N" : 0 > t && t >= -8 ? e = "M" : -8 > t && t >= -16 ? e = "L" : -16 > t && t >= -24 ? e = "K" : -24 > t && t >= -32 ? e = "J" : -32 > t && t >= -40 ? e = "H" : -40 > t && t >= -48 ? e = "G" : -48 > t && t >= -56 ? e = "F" : -56 > t && t >= -64 ? e = "E" : -64 > t && t >= -72 ? e = "D" : -72 > t && t >= -80 && (e = "C"), e;
}
function nN(t, e) {
  var n = "00000" + t.easting, a = "00000" + t.northing;
  return t.zoneNumber + t.zoneLetter + iN(t.easting, t.northing, t.zoneNumber) + n.substr(n.length - 5, e) + a.substr(a.length - 5, e);
}
function iN(t, e, n) {
  var a = xT(n), s = Math.floor(t / 1e5), f = Math.floor(e / 1e5) % 20;
  return oN(s, f, a);
}
function xT(t) {
  var e = t % Uw;
  return e === 0 && (e = Uw), e;
}
function oN(t, e, n) {
  var a = n - 1, s = yT.charCodeAt(a), f = gT.charCodeAt(a), o = s + t - 1, m = f + e, g = !1;
  o > ed && (o = o - ed + mf - 1, g = !0), (o === Qo || s < Qo && o > Qo || (o > Qo || s < Qo) && g) && o++, (o === Ca || s < Ca && o > Ca || (o > Ca || s < Ca) && g) && (o++, o === Qo && o++), o > ed && (o = o - ed + mf - 1), m > Qp ? (m = m - Qp + mf - 1, g = !0) : g = !1, (m === Qo || f < Qo && m > Qo || (m > Qo || f < Qo) && g) && m++, (m === Ca || f < Ca && m > Ca || (m > Ca || f < Ca) && g) && (m++, m === Qo && m++), m > Qp && (m = m - Qp + mf - 1);
  var b = String.fromCharCode(o) + String.fromCharCode(m);
  return b;
}
function bT(t) {
  if (t && t.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var e = t.length, n = null, a = "", s, f = 0; !/[A-Z]/.test(s = t.charAt(f)); ) {
    if (f >= 2)
      throw "MGRSPoint bad conversion from: " + t;
    a += s, f++;
  }
  var o = parseInt(a, 10);
  if (f === 0 || f + 3 > e)
    throw "MGRSPoint bad conversion from: " + t;
  var m = t.charAt(f++);
  if (m <= "A" || m === "B" || m === "Y" || m >= "Z" || m === "I" || m === "O")
    throw "MGRSPoint zone letter " + m + " not handled: " + t;
  n = t.substring(f, f += 2);
  for (var g = xT(o), b = aN(n.charAt(0), g), T = sN(n.charAt(1), g); T < lN(m); )
    T += 2e6;
  var M = e - f;
  if (M % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + t;
  var I = M / 2, A = 0, z = 0, V, Z, X, Y, de;
  return I > 0 && (V = 1e5 / Math.pow(10, I), Z = t.substring(f, f + I), A = parseFloat(Z) * V, X = t.substring(f + I), z = parseFloat(X) * V), Y = A + b, de = z + T, {
    easting: Y,
    northing: de,
    zoneLetter: m,
    zoneNumber: o,
    accuracy: V
  };
}
function aN(t, e) {
  for (var n = yT.charCodeAt(e - 1), a = 1e5, s = !1; n !== t.charCodeAt(0); ) {
    if (n++, n === Qo && n++, n === Ca && n++, n > ed) {
      if (s)
        throw "Bad character: " + t;
      n = mf, s = !0;
    }
    a += 1e5;
  }
  return a;
}
function sN(t, e) {
  if (t > "V")
    throw "MGRSPoint given invalid Northing " + t;
  for (var n = gT.charCodeAt(e - 1), a = 0, s = !1; n !== t.charCodeAt(0); ) {
    if (n++, n === Qo && n++, n === Ca && n++, n > Qp) {
      if (s)
        throw "Bad character: " + t;
      n = mf, s = !0;
    }
    a += 1e5;
  }
  return a;
}
function lN(t) {
  var e;
  switch (t) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0)
    return e;
  throw "Invalid zone letter: " + t;
}
function kf(t, e, n) {
  if (!(this instanceof kf))
    return new kf(t, e, n);
  if (Array.isArray(t))
    this.x = t[0], this.y = t[1], this.z = t[2] || 0;
  else if (typeof t == "object")
    this.x = t.x, this.y = t.y, this.z = t.z || 0;
  else if (typeof t == "string" && typeof e > "u") {
    var a = t.split(",");
    this.x = parseFloat(a[0], 10), this.y = parseFloat(a[1], 10), this.z = parseFloat(a[2], 10) || 0;
  } else
    this.x = t, this.y = e, this.z = n || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
kf.fromMGRS = function(t) {
  return new kf(_T(t));
};
kf.prototype.toMGRS = function(t) {
  return vT([this.x, this.y], t);
};
var uN = 1, cN = 0.25, Gw = 0.046875, qw = 0.01953125, $w = 0.01068115234375, hN = 0.75, fN = 0.46875, pN = 0.013020833333333334, dN = 0.007120768229166667, mN = 0.3645833333333333, yN = 0.005696614583333333, gN = 0.3076171875;
function wT(t) {
  var e = [];
  e[0] = uN - t * (cN + t * (Gw + t * (qw + t * $w))), e[1] = t * (hN - t * (Gw + t * (qw + t * $w)));
  var n = t * t;
  return e[2] = n * (fN - t * (pN + t * dN)), n *= t, e[3] = n * (mN - t * yN), e[4] = n * t * gN, e;
}
function wv(t, e, n, a) {
  return n *= e, e *= e, a[0] * t - n * (a[1] + e * (a[2] + e * (a[3] + e * a[4])));
}
var vN = 20;
function ET(t, e, n) {
  for (var a = 1 / (1 - e), s = t, f = vN; f; --f) {
    var o = Math.sin(s), m = 1 - e * o * o;
    if (m = (wv(s, o, Math.cos(s), n) - t) * (m * Math.sqrt(m)) * a, s -= m, Math.abs(m) < Ct)
      return s;
  }
  return s;
}
function _N() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = wT(this.es), this.ml0 = wv(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function xN(t) {
  var e = t.x, n = t.y, a = Bt(e - this.long0), s, f, o, m = Math.sin(n), g = Math.cos(n);
  if (this.es) {
    var T = g * a, M = Math.pow(T, 2), I = this.ep2 * Math.pow(g, 2), A = Math.pow(I, 2), z = Math.abs(g) > Ct ? Math.tan(n) : 0, V = Math.pow(z, 2), Z = Math.pow(V, 2);
    s = 1 - this.es * Math.pow(m, 2), T = T / Math.sqrt(s);
    var X = wv(n, m, g, this.en);
    f = this.a * (this.k0 * T * (1 + M / 6 * (1 - V + I + M / 20 * (5 - 18 * V + Z + 14 * I - 58 * V * I + M / 42 * (61 + 179 * Z - Z * V - 479 * V))))) + this.x0, o = this.a * (this.k0 * (X - this.ml0 + m * a * T / 2 * (1 + M / 12 * (5 - V + 9 * I + 4 * A + M / 30 * (61 + Z - 58 * V + 270 * I - 330 * V * I + M / 56 * (1385 + 543 * Z - Z * V - 3111 * V)))))) + this.y0;
  } else {
    var b = g * Math.sin(a);
    if (Math.abs(Math.abs(b) - 1) < Ct)
      return 93;
    if (f = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0, o = g * Math.cos(a) / Math.sqrt(1 - Math.pow(b, 2)), b = Math.abs(o), b >= 1) {
      if (b - 1 > Ct)
        return 93;
      o = 0;
    } else
      o = Math.acos(o);
    n < 0 && (o = -o), o = this.a * this.k0 * (o - this.lat0) + this.y0;
  }
  return t.x = f, t.y = o, t;
}
function bN(t) {
  var e, n, a, s, f = (t.x - this.x0) * (1 / this.a), o = (t.y - this.y0) * (1 / this.a);
  if (this.es)
    if (e = this.ml0 + o / this.k0, n = ET(e, this.es, this.en), Math.abs(n) < ht) {
      var M = Math.sin(n), I = Math.cos(n), A = Math.abs(I) > Ct ? Math.tan(n) : 0, z = this.ep2 * Math.pow(I, 2), V = Math.pow(z, 2), Z = Math.pow(A, 2), X = Math.pow(Z, 2);
      e = 1 - this.es * Math.pow(M, 2);
      var Y = f * Math.sqrt(e) / this.k0, de = Math.pow(Y, 2);
      e = e * A, a = n - e * de / (1 - this.es) * 0.5 * (1 - de / 12 * (5 + 3 * Z - 9 * z * Z + z - 4 * V - de / 30 * (61 + 90 * Z - 252 * z * Z + 45 * X + 46 * z - de / 56 * (1385 + 3633 * Z + 4095 * X + 1574 * X * Z)))), s = Bt(this.long0 + Y * (1 - de / 6 * (1 + 2 * Z + z - de / 20 * (5 + 28 * Z + 24 * X + 8 * z * Z + 6 * z - de / 42 * (61 + 662 * Z + 1320 * X + 720 * X * Z)))) / I);
    } else
      a = ht * jd(o), s = 0;
  else {
    var m = Math.exp(f / this.k0), g = 0.5 * (m - 1 / m), b = this.lat0 + o / this.k0, T = Math.cos(b);
    e = Math.sqrt((1 - Math.pow(T, 2)) / (1 + Math.pow(g, 2))), a = Math.asin(e), o < 0 && (a = -a), g === 0 && T === 0 ? s = 0 : s = Bt(Math.atan2(g, T) + this.long0);
  }
  return t.x = s, t.y = a, t;
}
var wN = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const ig = {
  init: _N,
  forward: xN,
  inverse: bN,
  names: wN
};
function ST(t) {
  var e = Math.exp(t);
  return e = (e - 1 / e) / 2, e;
}
function ns(t, e) {
  t = Math.abs(t), e = Math.abs(e);
  var n = Math.max(t, e), a = Math.min(t, e) / (n || 1);
  return n * Math.sqrt(1 + Math.pow(a, 2));
}
function EN(t) {
  var e = 1 + t, n = e - 1;
  return n === 0 ? t : t * Math.log(e) / n;
}
function SN(t) {
  var e = Math.abs(t);
  return e = EN(e * (1 + e / (ns(1, e) + 1))), t < 0 ? -e : e;
}
function z1(t, e) {
  for (var n = 2 * Math.cos(2 * e), a = t.length - 1, s = t[a], f = 0, o; --a >= 0; )
    o = -f + n * s + t[a], f = s, s = o;
  return e + o * Math.sin(2 * e);
}
function TN(t, e) {
  for (var n = 2 * Math.cos(e), a = t.length - 1, s = t[a], f = 0, o; --a >= 0; )
    o = -f + n * s + t[a], f = s, s = o;
  return Math.sin(e) * o;
}
function MN(t) {
  var e = Math.exp(t);
  return e = (e + 1 / e) / 2, e;
}
function TT(t, e, n) {
  for (var a = Math.sin(e), s = Math.cos(e), f = ST(n), o = MN(n), m = 2 * s * o, g = -2 * a * f, b = t.length - 1, T = t[b], M = 0, I = 0, A = 0, z, V; --b >= 0; )
    z = I, V = M, I = T, M = A, T = -z + m * I - g * M + t[b], A = -V + g * I + m * M;
  return m = a * o, g = s * f, [m * T - g * A, m * A + g * T];
}
function IN() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (ig.init.apply(this), this.forward = ig.forward, this.inverse = ig.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var t = this.es / (1 + Math.sqrt(1 - this.es)), e = t / (2 - t), n = e;
  this.cgb[0] = e * (2 + e * (-2 / 3 + e * (-2 + e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675)))))), this.cbg[0] = e * (-2 + e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725)))))), n = n * e, this.cgb[1] = n * (7 / 3 + e * (-8 / 5 + e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))))), this.cbg[1] = n * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), n = n * e, this.cgb[2] = n * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = n * (-26 / 15 + e * (34 / 21 + e * (8 / 5 + e * (-12686 / 2835)))), n = n * e, this.cgb[3] = n * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = n * (1237 / 630 + e * (-12 / 5 + e * (-24832 / 14175))), n = n * e, this.cgb[4] = n * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = n * (-734 / 315 + e * (109598 / 31185)), n = n * e, this.cgb[5] = n * (601676 / 22275), this.cbg[5] = n * (444337 / 155925), n = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + n * (1 / 4 + n * (1 / 64 + n / 256))), this.utg[0] = e * (-0.5 + e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800)))))), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = n * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = n * (13 / 48 + e * (-3 / 5 + e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))))), n = n * e, this.utg[2] = n * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = n * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), n = n * e, this.utg[3] = n * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = n * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), n = n * e, this.utg[4] = n * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = n * (34729 / 80640 + e * (-3418889 / 1995840)), n = n * e, this.utg[5] = n * (-20648693 / 638668800), this.gtu[5] = n * (212378941 / 319334400);
  var a = z1(this.cbg, this.lat0);
  this.Zb = -this.Qn * (a + TN(this.gtu, 2 * a));
}
function ON(t) {
  var e = Bt(t.x - this.long0), n = t.y;
  n = z1(this.cbg, n);
  var a = Math.sin(n), s = Math.cos(n), f = Math.sin(e), o = Math.cos(e);
  n = Math.atan2(a, o * s), e = Math.atan2(f * s, ns(a, s * o)), e = SN(Math.tan(e));
  var m = TT(this.gtu, 2 * n, 2 * e);
  n = n + m[0], e = e + m[1];
  var g, b;
  return Math.abs(e) <= 2.623395162778 ? (g = this.a * (this.Qn * e) + this.x0, b = this.a * (this.Qn * n + this.Zb) + this.y0) : (g = 1 / 0, b = 1 / 0), t.x = g, t.y = b, t;
}
function CN(t) {
  var e = (t.x - this.x0) * (1 / this.a), n = (t.y - this.y0) * (1 / this.a);
  n = (n - this.Zb) / this.Qn, e = e / this.Qn;
  var a, s;
  if (Math.abs(e) <= 2.623395162778) {
    var f = TT(this.utg, 2 * n, 2 * e);
    n = n + f[0], e = e + f[1], e = Math.atan(ST(e));
    var o = Math.sin(n), m = Math.cos(n), g = Math.sin(e), b = Math.cos(e);
    n = Math.atan2(o * b, ns(g, b * m)), e = Math.atan2(g, b * m), a = Bt(e + this.long0), s = z1(this.cgb, n);
  } else
    a = 1 / 0, s = 1 / 0;
  return t.x = a, t.y = s, t;
}
var AN = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
const og = {
  init: IN,
  forward: ON,
  inverse: CN,
  names: AN
};
function PN(t, e) {
  if (t === void 0) {
    if (t = Math.floor((Bt(e) + Math.PI) * 30 / Math.PI) + 1, t < 0)
      return 0;
    if (t > 60)
      return 60;
  }
  return t;
}
var kN = "etmerc";
function LN() {
  var t = PN(this.zone, this.long0);
  if (t === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(t) - 183) * io, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, og.init.apply(this), this.forward = og.forward, this.inverse = og.inverse;
}
var DN = ["Universal Transverse Mercator System", "utm"];
const NN = {
  init: LN,
  names: DN,
  dependsOn: kN
};
function F1(t, e) {
  return Math.pow((1 - t) / (1 + t), e);
}
var RN = 20;
function zN() {
  var t = Math.sin(this.lat0), e = Math.cos(this.lat0);
  e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(t / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + sn) / (Math.pow(Math.tan(0.5 * this.lat0 + sn), this.C) * F1(this.e * t, this.ratexp));
}
function FN(t) {
  var e = t.x, n = t.y;
  return t.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * n + sn), this.C) * F1(this.e * Math.sin(n), this.ratexp)) - ht, t.x = this.C * e, t;
}
function BN(t) {
  for (var e = 1e-14, n = t.x / this.C, a = t.y, s = Math.pow(Math.tan(0.5 * a + sn) / this.K, 1 / this.C), f = RN; f > 0 && (a = 2 * Math.atan(s * F1(this.e * Math.sin(t.y), -0.5 * this.e)) - ht, !(Math.abs(a - t.y) < e)); --f)
    t.y = a;
  return f ? (t.x = n, t.y = a, t) : null;
}
var VN = ["gauss"];
const B1 = {
  init: zN,
  forward: FN,
  inverse: BN,
  names: VN
};
function UN() {
  B1.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function jN(t) {
  var e, n, a, s;
  return t.x = Bt(t.x - this.long0), B1.forward.apply(this, [t]), e = Math.sin(t.y), n = Math.cos(t.y), a = Math.cos(t.x), s = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * n * a), t.x = s * n * Math.sin(t.x), t.y = s * (this.cosc0 * e - this.sinc0 * n * a), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
}
function GN(t) {
  var e, n, a, s, f;
  if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, f = Math.sqrt(t.x * t.x + t.y * t.y)) {
    var o = 2 * Math.atan2(f, this.R2);
    e = Math.sin(o), n = Math.cos(o), s = Math.asin(n * this.sinc0 + t.y * e * this.cosc0 / f), a = Math.atan2(t.x * e, f * this.cosc0 * n - t.y * this.sinc0 * e);
  } else
    s = this.phic0, a = 0;
  return t.x = a, t.y = s, B1.inverse.apply(this, [t]), t.x = Bt(t.x + this.long0), t;
}
var qN = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const $N = {
  init: UN,
  forward: jN,
  inverse: GN,
  names: qN
};
function WN(t, e, n) {
  return e *= n, Math.tan(0.5 * (ht + t)) * Math.pow((1 - e) / (1 + e), 0.5 * n);
}
function HN() {
  this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Ct && (this.k0 = 0.5 * (1 + jd(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= Ct && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Ct && (this.k0 = 0.5 * this.cons * Ks(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / ls(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = Ks(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - ht, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function ZN(t) {
  var e = t.x, n = t.y, a = Math.sin(n), s = Math.cos(n), f, o, m, g, b, T, M = Bt(e - this.long0);
  return Math.abs(Math.abs(e - this.long0) - Math.PI) <= Ct && Math.abs(n + this.lat0) <= Ct ? (t.x = NaN, t.y = NaN, t) : this.sphere ? (f = 2 * this.k0 / (1 + this.sinlat0 * a + this.coslat0 * s * Math.cos(M)), t.x = this.a * f * s * Math.sin(M) + this.x0, t.y = this.a * f * (this.coslat0 * a - this.sinlat0 * s * Math.cos(M)) + this.y0, t) : (o = 2 * Math.atan(this.ssfn_(n, a, this.e)) - ht, g = Math.cos(o), m = Math.sin(o), Math.abs(this.coslat0) <= Ct ? (b = ls(this.e, n * this.con, this.con * a), T = 2 * this.a * this.k0 * b / this.cons, t.x = this.x0 + T * Math.sin(e - this.long0), t.y = this.y0 - this.con * T * Math.cos(e - this.long0), t) : (Math.abs(this.sinlat0) < Ct ? (f = 2 * this.a * this.k0 / (1 + g * Math.cos(M)), t.y = f * m) : (f = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * m + this.cosX0 * g * Math.cos(M))), t.y = f * (this.cosX0 * m - this.sinX0 * g * Math.cos(M)) + this.y0), t.x = f * g * Math.sin(M) + this.x0, t));
}
function XN(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n, a, s, f, o = Math.sqrt(t.x * t.x + t.y * t.y);
  if (this.sphere) {
    var m = 2 * Math.atan(o / (2 * this.a * this.k0));
    return e = this.long0, n = this.lat0, o <= Ct ? (t.x = e, t.y = n, t) : (n = Math.asin(Math.cos(m) * this.sinlat0 + t.y * Math.sin(m) * this.coslat0 / o), Math.abs(this.coslat0) < Ct ? this.lat0 > 0 ? e = Bt(this.long0 + Math.atan2(t.x, -1 * t.y)) : e = Bt(this.long0 + Math.atan2(t.x, t.y)) : e = Bt(this.long0 + Math.atan2(t.x * Math.sin(m), o * this.coslat0 * Math.cos(m) - t.y * this.sinlat0 * Math.sin(m))), t.x = e, t.y = n, t);
  } else if (Math.abs(this.coslat0) <= Ct) {
    if (o <= Ct)
      return n = this.lat0, e = this.long0, t.x = e, t.y = n, t;
    t.x *= this.con, t.y *= this.con, a = o * this.cons / (2 * this.a * this.k0), n = this.con * Ld(this.e, a), e = this.con * Bt(this.con * this.long0 + Math.atan2(t.x, -1 * t.y));
  } else
    s = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, o <= Ct ? f = this.X0 : (f = Math.asin(Math.cos(s) * this.sinX0 + t.y * Math.sin(s) * this.cosX0 / o), e = Bt(this.long0 + Math.atan2(t.x * Math.sin(s), o * this.cosX0 * Math.cos(s) - t.y * this.sinX0 * Math.sin(s)))), n = -1 * Ld(this.e, Math.tan(0.5 * (ht + f)));
  return t.x = e, t.y = n, t;
}
var KN = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
const YN = {
  init: HN,
  forward: ZN,
  inverse: XN,
  names: KN,
  ssfn_: WN
};
function JN() {
  var t = this.lat0;
  this.lambda0 = this.long0;
  var e = Math.sin(t), n = this.a, a = this.rf, s = 1 / a, f = 2 * s - Math.pow(s, 2), o = this.e = Math.sqrt(f);
  this.R = this.k0 * n * Math.sqrt(1 - f) / (1 - f * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + f / (1 - f) * Math.pow(Math.cos(t), 4)), this.b0 = Math.asin(e / this.alpha);
  var m = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), g = Math.log(Math.tan(Math.PI / 4 + t / 2)), b = Math.log((1 + o * e) / (1 - o * e));
  this.K = m - this.alpha * g + this.alpha * o / 2 * b;
}
function QN(t) {
  var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)), n = this.e / 2 * Math.log((1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))), a = -this.alpha * (e + n) + this.K, s = 2 * (Math.atan(Math.exp(a)) - Math.PI / 4), f = this.alpha * (t.x - this.lambda0), o = Math.atan(Math.sin(f) / (Math.sin(this.b0) * Math.tan(s) + Math.cos(this.b0) * Math.cos(f))), m = Math.asin(Math.cos(this.b0) * Math.sin(s) - Math.sin(this.b0) * Math.cos(s) * Math.cos(f));
  return t.y = this.R / 2 * Math.log((1 + Math.sin(m)) / (1 - Math.sin(m))) + this.y0, t.x = this.R * o + this.x0, t;
}
function e3(t) {
  for (var e = t.x - this.x0, n = t.y - this.y0, a = e / this.R, s = 2 * (Math.atan(Math.exp(n / this.R)) - Math.PI / 4), f = Math.asin(Math.cos(this.b0) * Math.sin(s) + Math.sin(this.b0) * Math.cos(s) * Math.cos(a)), o = Math.atan(Math.sin(a) / (Math.cos(this.b0) * Math.cos(a) - Math.sin(this.b0) * Math.tan(s))), m = this.lambda0 + o / this.alpha, g = 0, b = f, T = -1e3, M = 0; Math.abs(b - T) > 1e-7; ) {
    if (++M > 20)
      return;
    g = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + f / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(b)) / 2)), T = b, b = 2 * Math.atan(Math.exp(g)) - Math.PI / 2;
  }
  return t.x = m, t.y = b, t;
}
var t3 = ["somerc"];
const r3 = {
  init: JN,
  forward: QN,
  inverse: e3,
  names: t3
};
var lf = 1e-7;
function n3(t) {
  var e = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], n = typeof t.PROJECTION == "object" ? Object.keys(t.PROJECTION)[0] : t.PROJECTION;
  return "no_uoff" in t || "no_off" in t || e.indexOf(n) !== -1;
}
function i3() {
  var t, e, n, a, s, f, o, m, g, b, T = 0, M, I = 0, A = 0, z = 0, V = 0, Z = 0, X = 0;
  this.no_off = n3(this), this.no_rot = "no_rot" in this;
  var Y = !1;
  "alpha" in this && (Y = !0);
  var de = !1;
  if ("rectified_grid_angle" in this && (de = !0), Y && (X = this.alpha), de && (T = this.rectified_grid_angle * io), Y || de)
    I = this.longc;
  else if (A = this.long1, V = this.lat1, z = this.long2, Z = this.lat2, Math.abs(V - Z) <= lf || (t = Math.abs(V)) <= lf || Math.abs(t - ht) <= lf || Math.abs(Math.abs(this.lat0) - ht) <= lf || Math.abs(Math.abs(Z) - ht) <= lf)
    throw new Error();
  var ye = 1 - this.es;
  e = Math.sqrt(ye), Math.abs(this.lat0) > Ct ? (m = Math.sin(this.lat0), n = Math.cos(this.lat0), t = 1 - this.es * m * m, this.B = n * n, this.B = Math.sqrt(1 + this.es * this.B * this.B / ye), this.A = this.B * this.k0 * e / t, a = this.B * e / (n * Math.sqrt(t)), s = a * a - 1, s <= 0 ? s = 0 : (s = Math.sqrt(s), this.lat0 < 0 && (s = -s)), this.E = s += a, this.E *= Math.pow(ls(this.e, this.lat0, m), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = a = s = 1), Y || de ? (Y ? (M = Math.asin(Math.sin(X) / a), de || (T = X)) : (M = T, X = Math.asin(a * Math.sin(M))), this.lam0 = I - Math.asin(0.5 * (s - 1 / s) * Math.tan(M)) / this.B) : (f = Math.pow(ls(this.e, V, Math.sin(V)), this.B), o = Math.pow(ls(this.e, Z, Math.sin(Z)), this.B), s = this.E / f, g = (o - f) / (o + f), b = this.E * this.E, b = (b - o * f) / (b + o * f), t = A - z, t < -Math.pi ? z -= Pd : t > Math.pi && (z += Pd), this.lam0 = Bt(0.5 * (A + z) - Math.atan(b * Math.tan(0.5 * this.B * (A - z)) / g) / this.B), M = Math.atan(2 * Math.sin(this.B * Bt(A - this.lam0)) / (s - 1 / s)), T = X = Math.asin(a * Math.sin(M))), this.singam = Math.sin(M), this.cosgam = Math.cos(M), this.sinrot = Math.sin(T), this.cosrot = Math.cos(T), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(a * a - 1) / Math.cos(X))), this.lat0 < 0 && (this.u_0 = -this.u_0)), s = 0.5 * M, this.v_pole_n = this.ArB * Math.log(Math.tan(sn - s)), this.v_pole_s = this.ArB * Math.log(Math.tan(sn + s));
}
function o3(t) {
  var e = {}, n, a, s, f, o, m, g, b;
  if (t.x = t.x - this.lam0, Math.abs(Math.abs(t.y) - ht) > Ct) {
    if (o = this.E / Math.pow(ls(this.e, t.y, Math.sin(t.y)), this.B), m = 1 / o, n = 0.5 * (o - m), a = 0.5 * (o + m), f = Math.sin(this.B * t.x), s = (n * this.singam - f * this.cosgam) / a, Math.abs(Math.abs(s) - 1) < Ct)
      throw new Error();
    b = 0.5 * this.ArB * Math.log((1 - s) / (1 + s)), m = Math.cos(this.B * t.x), Math.abs(m) < lf ? g = this.A * t.x : g = this.ArB * Math.atan2(n * this.cosgam + f * this.singam, m);
  } else
    b = t.y > 0 ? this.v_pole_n : this.v_pole_s, g = this.ArB * t.y;
  return this.no_rot ? (e.x = g, e.y = b) : (g -= this.u_0, e.x = b * this.cosrot + g * this.sinrot, e.y = g * this.cosrot - b * this.sinrot), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function a3(t) {
  var e, n, a, s, f, o, m, g = {};
  if (t.x = (t.x - this.x0) * (1 / this.a), t.y = (t.y - this.y0) * (1 / this.a), this.no_rot ? (n = t.y, e = t.x) : (n = t.x * this.cosrot - t.y * this.sinrot, e = t.y * this.cosrot + t.x * this.sinrot + this.u_0), a = Math.exp(-this.BrA * n), s = 0.5 * (a - 1 / a), f = 0.5 * (a + 1 / a), o = Math.sin(this.BrA * e), m = (o * this.cosgam + s * this.singam) / f, Math.abs(Math.abs(m) - 1) < Ct)
    g.x = 0, g.y = m < 0 ? -ht : ht;
  else {
    if (g.y = this.E / Math.sqrt((1 + m) / (1 - m)), g.y = Ld(this.e, Math.pow(g.y, 1 / this.B)), g.y === 1 / 0)
      throw new Error();
    g.x = -this.rB * Math.atan2(s * this.cosgam - o * this.singam, Math.cos(this.BrA * e));
  }
  return g.x += this.lam0, g;
}
var s3 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const l3 = {
  init: i3,
  forward: o3,
  inverse: a3,
  names: s3
};
function u3() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < Ct)) {
    var t = this.b / this.a;
    this.e = Math.sqrt(1 - t * t);
    var e = Math.sin(this.lat1), n = Math.cos(this.lat1), a = Ks(this.e, e, n), s = ls(this.e, this.lat1, e), f = Math.sin(this.lat2), o = Math.cos(this.lat2), m = Ks(this.e, f, o), g = ls(this.e, this.lat2, f), b = ls(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > Ct ? this.ns = Math.log(a / m) / Math.log(s / g) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = a / (this.ns * Math.pow(s, this.ns)), this.rh = this.a * this.f0 * Math.pow(b, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function c3(t) {
  var e = t.x, n = t.y;
  Math.abs(2 * Math.abs(n) - Math.PI) <= Ct && (n = jd(n) * (ht - 2 * Ct));
  var a = Math.abs(Math.abs(n) - ht), s, f;
  if (a > Ct)
    s = ls(this.e, n, Math.sin(n)), f = this.a * this.f0 * Math.pow(s, this.ns);
  else {
    if (a = n * this.ns, a <= 0)
      return null;
    f = 0;
  }
  var o = this.ns * Bt(e - this.long0);
  return t.x = this.k0 * (f * Math.sin(o)) + this.x0, t.y = this.k0 * (this.rh - f * Math.cos(o)) + this.y0, t;
}
function h3(t) {
  var e, n, a, s, f, o = (t.x - this.x0) / this.k0, m = this.rh - (t.y - this.y0) / this.k0;
  this.ns > 0 ? (e = Math.sqrt(o * o + m * m), n = 1) : (e = -Math.sqrt(o * o + m * m), n = -1);
  var g = 0;
  if (e !== 0 && (g = Math.atan2(n * o, n * m)), e !== 0 || this.ns > 0) {
    if (n = 1 / this.ns, a = Math.pow(e / (this.a * this.f0), n), s = Ld(this.e, a), s === -9999)
      return null;
  } else
    s = -ht;
  return f = Bt(g / this.ns + this.long0), t.x = f, t.y = s, t;
}
var f3 = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const p3 = {
  init: u3,
  forward: c3,
  inverse: h3,
  names: f3
};
function d3() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function m3(t) {
  var e, n, a, s, f, o, m, g = t.x, b = t.y, T = Bt(g - this.long0);
  return e = Math.pow((1 + this.e * Math.sin(b)) / (1 - this.e * Math.sin(b)), this.alfa * this.e / 2), n = 2 * (Math.atan(this.k * Math.pow(Math.tan(b / 2 + this.s45), this.alfa) / e) - this.s45), a = -T * this.alfa, s = Math.asin(Math.cos(this.ad) * Math.sin(n) + Math.sin(this.ad) * Math.cos(n) * Math.cos(a)), f = Math.asin(Math.cos(n) * Math.sin(a) / Math.cos(s)), o = this.n * f, m = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n), t.y = m * Math.cos(o) / 1, t.x = m * Math.sin(o) / 1, this.czech || (t.y *= -1, t.x *= -1), t;
}
function y3(t) {
  var e, n, a, s, f, o, m, g, b = t.x;
  t.x = t.y, t.y = b, this.czech || (t.y *= -1, t.x *= -1), o = Math.sqrt(t.x * t.x + t.y * t.y), f = Math.atan2(t.y, t.x), s = f / Math.sin(this.s0), a = 2 * (Math.atan(Math.pow(this.ro0 / o, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(a) - Math.sin(this.ad) * Math.cos(a) * Math.cos(s)), n = Math.asin(Math.cos(a) * Math.sin(s) / Math.cos(e)), t.x = this.long0 - n / this.alfa, m = e, g = 0;
  var T = 0;
  do
    t.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(m)) / (1 - this.e * Math.sin(m)), this.e / 2)) - this.s45), Math.abs(m - t.y) < 1e-10 && (g = 1), m = t.y, T += 1;
  while (g === 0 && T < 15);
  return T >= 15 ? null : t;
}
var g3 = ["Krovak", "krovak"];
const v3 = {
  init: d3,
  forward: m3,
  inverse: y3,
  names: g3
};
function zo(t, e, n, a, s) {
  return t * s - e * Math.sin(2 * s) + n * Math.sin(4 * s) - a * Math.sin(6 * s);
}
function Gd(t) {
  return 1 - 0.25 * t * (1 + t / 16 * (3 + 1.25 * t));
}
function qd(t) {
  return 0.375 * t * (1 + 0.25 * t * (1 + 0.46875 * t));
}
function $d(t) {
  return 0.05859375 * t * t * (1 + 0.75 * t);
}
function Wd(t) {
  return t * t * t * (35 / 3072);
}
function Lf(t, e, n) {
  var a = e * n;
  return t / Math.sqrt(1 - a * a);
}
function zf(t) {
  return Math.abs(t) < ht ? t : t - jd(t) * Math.PI;
}
function Pg(t, e, n, a, s) {
  var f, o;
  f = t / e;
  for (var m = 0; m < 15; m++)
    if (o = (t - (e * f - n * Math.sin(2 * f) + a * Math.sin(4 * f) - s * Math.sin(6 * f))) / (e - 2 * n * Math.cos(2 * f) + 4 * a * Math.cos(4 * f) - 6 * s * Math.cos(6 * f)), f += o, Math.abs(o) <= 1e-10)
      return f;
  return NaN;
}
function _3() {
  this.sphere || (this.e0 = Gd(this.es), this.e1 = qd(this.es), this.e2 = $d(this.es), this.e3 = Wd(this.es), this.ml0 = this.a * zo(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function x3(t) {
  var e, n, a = t.x, s = t.y;
  if (a = Bt(a - this.long0), this.sphere)
    e = this.a * Math.asin(Math.cos(s) * Math.sin(a)), n = this.a * (Math.atan2(Math.tan(s), Math.cos(a)) - this.lat0);
  else {
    var f = Math.sin(s), o = Math.cos(s), m = Lf(this.a, this.e, f), g = Math.tan(s) * Math.tan(s), b = a * Math.cos(s), T = b * b, M = this.es * o * o / (1 - this.es), I = this.a * zo(this.e0, this.e1, this.e2, this.e3, s);
    e = m * b * (1 - T * g * (1 / 6 - (8 - g + 8 * M) * T / 120)), n = I - this.ml0 + m * f / o * T * (0.5 + (5 - g + 6 * M) * T / 24);
  }
  return t.x = e + this.x0, t.y = n + this.y0, t;
}
function b3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = t.x / this.a, n = t.y / this.a, a, s;
  if (this.sphere) {
    var f = n + this.lat0;
    a = Math.asin(Math.sin(f) * Math.cos(e)), s = Math.atan2(Math.tan(e), Math.cos(f));
  } else {
    var o = this.ml0 / this.a + n, m = Pg(o, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(m) - ht) <= Ct)
      return t.x = this.long0, t.y = ht, n < 0 && (t.y *= -1), t;
    var g = Lf(this.a, this.e, Math.sin(m)), b = g * g * g / this.a / this.a * (1 - this.es), T = Math.pow(Math.tan(m), 2), M = e * this.a / g, I = M * M;
    a = m - g * Math.tan(m) / b * M * M * (0.5 - (1 + 3 * T) * M * M / 24), s = M * (1 - I * (T / 3 + (1 + 3 * T) * T * I / 15)) / Math.cos(m);
  }
  return t.x = Bt(s + this.long0), t.y = zf(a), t;
}
var w3 = ["Cassini", "Cassini_Soldner", "cass"];
const E3 = {
  init: _3,
  forward: x3,
  inverse: b3,
  names: w3
};
function Iu(t, e) {
  var n;
  return t > 1e-7 ? (n = t * e, (1 - t * t) * (e / (1 - n * n) - 0.5 / t * Math.log((1 - n) / (1 + n)))) : 2 * e;
}
var S3 = 1, T3 = 2, M3 = 3, I3 = 4;
function O3() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - ht) < Ct ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(t) < Ct ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
    var e;
    switch (this.qp = Iu(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = z3(this.es), this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = Iu(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function C3(t) {
  var e, n, a, s, f, o, m, g, b, T, M = t.x, I = t.y;
  if (M = Bt(M - this.long0), this.sphere) {
    if (f = Math.sin(I), T = Math.cos(I), a = Math.cos(M), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (n = this.mode === this.EQUIT ? 1 + T * a : 1 + this.sinph0 * f + this.cosph0 * T * a, n <= Ct)
        return null;
      n = Math.sqrt(2 / n), e = n * T * Math.sin(M), n *= this.mode === this.EQUIT ? f : this.cosph0 * f - this.sinph0 * T * a;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (a = -a), Math.abs(I + this.lat0) < Ct)
        return null;
      n = sn - I * 0.5, n = 2 * (this.mode === this.S_POLE ? Math.cos(n) : Math.sin(n)), e = n * Math.sin(M), n *= a;
    }
  } else {
    switch (m = 0, g = 0, b = 0, a = Math.cos(M), s = Math.sin(M), f = Math.sin(I), o = Iu(this.e, f), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (m = o / this.qp, g = Math.sqrt(1 - m * m)), this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * m + this.cosb1 * g * a;
        break;
      case this.EQUIT:
        b = 1 + g * a;
        break;
      case this.N_POLE:
        b = ht + I, o = this.qp - o;
        break;
      case this.S_POLE:
        b = I - ht, o = this.qp + o;
        break;
    }
    if (Math.abs(b) < Ct)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b), this.mode === this.OBLIQ ? n = this.ymf * b * (this.cosb1 * m - this.sinb1 * g * a) : n = (b = Math.sqrt(2 / (1 + g * a))) * m * this.ymf, e = this.xmf * b * g * s;
        break;
      case this.N_POLE:
      case this.S_POLE:
        o >= 0 ? (e = (b = Math.sqrt(o)) * s, n = a * (this.mode === this.S_POLE ? b : -b)) : e = n = 0;
        break;
    }
  }
  return t.x = this.a * e + this.x0, t.y = this.a * n + this.y0, t;
}
function A3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = t.x / this.a, n = t.y / this.a, a, s, f, o, m, g, b;
  if (this.sphere) {
    var T = 0, M, I = 0;
    if (M = Math.sqrt(e * e + n * n), s = M * 0.5, s > 1)
      return null;
    switch (s = 2 * Math.asin(s), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (I = Math.sin(s), T = Math.cos(s)), this.mode) {
      case this.EQUIT:
        s = Math.abs(M) <= Ct ? 0 : Math.asin(n * I / M), e *= I, n = T * M;
        break;
      case this.OBLIQ:
        s = Math.abs(M) <= Ct ? this.lat0 : Math.asin(T * this.sinph0 + n * I * this.cosph0 / M), e *= I * this.cosph0, n = (T - Math.sin(s) * this.sinph0) * M;
        break;
      case this.N_POLE:
        n = -n, s = ht - s;
        break;
      case this.S_POLE:
        s -= ht;
        break;
    }
    a = n === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(e, n);
  } else {
    if (b = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (e /= this.dd, n *= this.dd, g = Math.sqrt(e * e + n * n), g < Ct)
        return t.x = this.long0, t.y = this.lat0, t;
      o = 2 * Math.asin(0.5 * g / this.rq), f = Math.cos(o), e *= o = Math.sin(o), this.mode === this.OBLIQ ? (b = f * this.sinb1 + n * o * this.cosb1 / g, m = this.qp * b, n = g * this.cosb1 * f - n * this.sinb1 * o) : (b = n * o / g, m = this.qp * b, n = g * f);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), m = e * e + n * n, !m)
        return t.x = this.long0, t.y = this.lat0, t;
      b = 1 - m / this.qp, this.mode === this.S_POLE && (b = -b);
    }
    a = Math.atan2(e, n), s = F3(Math.asin(b), this.apa);
  }
  return t.x = Bt(this.long0 + a), t.y = s, t;
}
var P3 = 0.3333333333333333, k3 = 0.17222222222222222, L3 = 0.10257936507936508, D3 = 0.06388888888888888, N3 = 0.0664021164021164, R3 = 0.016415012942191543;
function z3(t) {
  var e, n = [];
  return n[0] = t * P3, e = t * t, n[0] += e * k3, n[1] = e * D3, e *= t, n[0] += e * L3, n[1] += e * N3, n[2] = e * R3, n;
}
function F3(t, e) {
  var n = t + t;
  return t + e[0] * Math.sin(n) + e[1] * Math.sin(n + n) + e[2] * Math.sin(n + n + n);
}
var B3 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const V3 = {
  init: O3,
  forward: C3,
  inverse: A3,
  names: B3,
  S_POLE: S3,
  N_POLE: T3,
  EQUIT: M3,
  OBLIQ: I3
};
function Du(t) {
  return Math.abs(t) > 1 && (t = t > 1 ? 1 : -1), Math.asin(t);
}
function U3() {
  Math.abs(this.lat1 + this.lat2) < Ct || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = Ks(this.e3, this.sin_po, this.cos_po), this.qs1 = Iu(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = Ks(this.e3, this.sin_po, this.cos_po), this.qs2 = Iu(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Iu(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > Ct ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function j3(t) {
  var e = t.x, n = t.y;
  this.sin_phi = Math.sin(n), this.cos_phi = Math.cos(n);
  var a = Iu(this.e3, this.sin_phi), s = this.a * Math.sqrt(this.c - this.ns0 * a) / this.ns0, f = this.ns0 * Bt(e - this.long0), o = s * Math.sin(f) + this.x0, m = this.rh - s * Math.cos(f) + this.y0;
  return t.x = o, t.y = m, t;
}
function G3(t) {
  var e, n, a, s, f, o;
  return t.x -= this.x0, t.y = this.rh - t.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(t.x * t.x + t.y * t.y), a = 1) : (e = -Math.sqrt(t.x * t.x + t.y * t.y), a = -1), s = 0, e !== 0 && (s = Math.atan2(a * t.x, a * t.y)), a = e * this.ns0 / this.a, this.sphere ? o = Math.asin((this.c - a * a) / (2 * this.ns0)) : (n = (this.c - a * a) / this.ns0, o = this.phi1z(this.e3, n)), f = Bt(s / this.ns0 + this.long0), t.x = f, t.y = o, t;
}
function q3(t, e) {
  var n, a, s, f, o, m = Du(0.5 * e);
  if (t < Ct)
    return m;
  for (var g = t * t, b = 1; b <= 25; b++)
    if (n = Math.sin(m), a = Math.cos(m), s = t * n, f = 1 - s * s, o = 0.5 * f * f / a * (e / (1 - g) - n / f + 0.5 / t * Math.log((1 - s) / (1 + s))), m = m + o, Math.abs(o) <= 1e-7)
      return m;
  return null;
}
var $3 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const W3 = {
  init: U3,
  forward: j3,
  inverse: G3,
  names: $3,
  phi1z: q3
};
function H3() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function Z3(t) {
  var e, n, a, s, f, o, m, g, b = t.x, T = t.y;
  return a = Bt(b - this.long0), e = Math.sin(T), n = Math.cos(T), s = Math.cos(a), o = this.sin_p14 * e + this.cos_p14 * n * s, f = 1, o > 0 || Math.abs(o) <= Ct ? (m = this.x0 + this.a * f * n * Math.sin(a) / o, g = this.y0 + this.a * f * (this.cos_p14 * e - this.sin_p14 * n * s) / o) : (m = this.x0 + this.infinity_dist * n * Math.sin(a), g = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * n * s)), t.x = m, t.y = g, t;
}
function X3(t) {
  var e, n, a, s, f, o;
  return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, (e = Math.sqrt(t.x * t.x + t.y * t.y)) ? (s = Math.atan2(e, this.rc), n = Math.sin(s), a = Math.cos(s), o = Du(a * this.sin_p14 + t.y * n * this.cos_p14 / e), f = Math.atan2(t.x * n, e * this.cos_p14 * a - t.y * this.sin_p14 * n), f = Bt(this.long0 + f)) : (o = this.phic0, f = 0), t.x = f, t.y = o, t;
}
var K3 = ["gnom"];
const Y3 = {
  init: H3,
  forward: Z3,
  inverse: X3,
  names: K3
};
function J3(t, e) {
  var n = 1 - (1 - t * t) / (2 * t) * Math.log((1 - t) / (1 + t));
  if (Math.abs(Math.abs(e) - n) < 1e-6)
    return e < 0 ? -1 * ht : ht;
  for (var a = Math.asin(0.5 * e), s, f, o, m, g = 0; g < 30; g++)
    if (f = Math.sin(a), o = Math.cos(a), m = t * f, s = Math.pow(1 - m * m, 2) / (2 * o) * (e / (1 - t * t) - f / (1 - m * m) + 0.5 / t * Math.log((1 - m) / (1 + m))), a += s, Math.abs(s) <= 1e-10)
      return a;
  return NaN;
}
function Q3() {
  this.sphere || (this.k0 = Ks(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function eR(t) {
  var e = t.x, n = t.y, a, s, f = Bt(e - this.long0);
  if (this.sphere)
    a = this.x0 + this.a * f * Math.cos(this.lat_ts), s = this.y0 + this.a * Math.sin(n) / Math.cos(this.lat_ts);
  else {
    var o = Iu(this.e, Math.sin(n));
    a = this.x0 + this.a * this.k0 * f, s = this.y0 + this.a * o * 0.5 / this.k0;
  }
  return t.x = a, t.y = s, t;
}
function tR(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n;
  return this.sphere ? (e = Bt(this.long0 + t.x / this.a / Math.cos(this.lat_ts)), n = Math.asin(t.y / this.a * Math.cos(this.lat_ts))) : (n = J3(this.e, 2 * t.y * this.k0 / this.a), e = Bt(this.long0 + t.x / (this.a * this.k0))), t.x = e, t.y = n, t;
}
var rR = ["cea"];
const nR = {
  init: Q3,
  forward: eR,
  inverse: tR,
  names: rR
};
function iR() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function oR(t) {
  var e = t.x, n = t.y, a = Bt(e - this.long0), s = zf(n - this.lat0);
  return t.x = this.x0 + this.a * a * this.rc, t.y = this.y0 + this.a * s, t;
}
function aR(t) {
  var e = t.x, n = t.y;
  return t.x = Bt(this.long0 + (e - this.x0) / (this.a * this.rc)), t.y = zf(this.lat0 + (n - this.y0) / this.a), t;
}
var sR = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const lR = {
  init: iR,
  forward: oR,
  inverse: aR,
  names: sR
};
var Ww = 20;
function uR() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Gd(this.es), this.e1 = qd(this.es), this.e2 = $d(this.es), this.e3 = Wd(this.es), this.ml0 = this.a * zo(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function cR(t) {
  var e = t.x, n = t.y, a, s, f, o = Bt(e - this.long0);
  if (f = o * Math.sin(n), this.sphere)
    Math.abs(n) <= Ct ? (a = this.a * o, s = -1 * this.a * this.lat0) : (a = this.a * Math.sin(f) / Math.tan(n), s = this.a * (zf(n - this.lat0) + (1 - Math.cos(f)) / Math.tan(n)));
  else if (Math.abs(n) <= Ct)
    a = this.a * o, s = -1 * this.ml0;
  else {
    var m = Lf(this.a, this.e, Math.sin(n)) / Math.tan(n);
    a = m * Math.sin(f), s = this.a * zo(this.e0, this.e1, this.e2, this.e3, n) - this.ml0 + m * (1 - Math.cos(f));
  }
  return t.x = a + this.x0, t.y = s + this.y0, t;
}
function hR(t) {
  var e, n, a, s, f, o, m, g, b;
  if (a = t.x - this.x0, s = t.y - this.y0, this.sphere)
    if (Math.abs(s + this.a * this.lat0) <= Ct)
      e = Bt(a / this.a + this.long0), n = 0;
    else {
      o = this.lat0 + s / this.a, m = a * a / this.a / this.a + o * o, g = o;
      var T;
      for (f = Ww; f; --f)
        if (T = Math.tan(g), b = -1 * (o * (g * T + 1) - g - 0.5 * (g * g + m) * T) / ((g - o) / T - 1), g += b, Math.abs(b) <= Ct) {
          n = g;
          break;
        }
      e = Bt(this.long0 + Math.asin(a * Math.tan(g) / this.a) / Math.sin(n));
    }
  else if (Math.abs(s + this.ml0) <= Ct)
    n = 0, e = Bt(this.long0 + a / this.a);
  else {
    o = (this.ml0 + s) / this.a, m = a * a / this.a / this.a + o * o, g = o;
    var M, I, A, z, V;
    for (f = Ww; f; --f)
      if (V = this.e * Math.sin(g), M = Math.sqrt(1 - V * V) * Math.tan(g), I = this.a * zo(this.e0, this.e1, this.e2, this.e3, g), A = this.e0 - 2 * this.e1 * Math.cos(2 * g) + 4 * this.e2 * Math.cos(4 * g) - 6 * this.e3 * Math.cos(6 * g), z = I / this.a, b = (o * (M * z + 1) - z - 0.5 * M * (z * z + m)) / (this.es * Math.sin(2 * g) * (z * z + m - 2 * o * z) / (4 * M) + (o - z) * (M * A - 2 / Math.sin(2 * g)) - A), g -= b, Math.abs(b) <= Ct) {
        n = g;
        break;
      }
    M = Math.sqrt(1 - this.es * Math.pow(Math.sin(n), 2)) * Math.tan(n), e = Bt(this.long0 + Math.asin(a * M / this.a) / Math.sin(n));
  }
  return t.x = e, t.y = n, t;
}
var fR = ["Polyconic", "poly"];
const pR = {
  init: uR,
  forward: cR,
  inverse: hR,
  names: fR
};
function dR() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function mR(t) {
  var e, n = t.x, a = t.y, s = a - this.lat0, f = n - this.long0, o = s / dd * 1e-5, m = f, g = 1, b = 0;
  for (e = 1; e <= 10; e++)
    g = g * o, b = b + this.A[e] * g;
  var T = b, M = m, I = 1, A = 0, z, V, Z = 0, X = 0;
  for (e = 1; e <= 6; e++)
    z = I * T - A * M, V = A * T + I * M, I = z, A = V, Z = Z + this.B_re[e] * I - this.B_im[e] * A, X = X + this.B_im[e] * I + this.B_re[e] * A;
  return t.x = X * this.a + this.x0, t.y = Z * this.a + this.y0, t;
}
function yR(t) {
  var e, n = t.x, a = t.y, s = n - this.x0, f = a - this.y0, o = f / this.a, m = s / this.a, g = 1, b = 0, T, M, I = 0, A = 0;
  for (e = 1; e <= 6; e++)
    T = g * o - b * m, M = b * o + g * m, g = T, b = M, I = I + this.C_re[e] * g - this.C_im[e] * b, A = A + this.C_im[e] * g + this.C_re[e] * b;
  for (var z = 0; z < this.iterations; z++) {
    var V = I, Z = A, X, Y, de = o, ye = m;
    for (e = 2; e <= 6; e++)
      X = V * I - Z * A, Y = Z * I + V * A, V = X, Z = Y, de = de + (e - 1) * (this.B_re[e] * V - this.B_im[e] * Z), ye = ye + (e - 1) * (this.B_im[e] * V + this.B_re[e] * Z);
    V = 1, Z = 0;
    var Ie = this.B_re[1], Be = this.B_im[1];
    for (e = 2; e <= 6; e++)
      X = V * I - Z * A, Y = Z * I + V * A, V = X, Z = Y, Ie = Ie + e * (this.B_re[e] * V - this.B_im[e] * Z), Be = Be + e * (this.B_im[e] * V + this.B_re[e] * Z);
    var De = Ie * Ie + Be * Be;
    I = (de * Ie + ye * Be) / De, A = (ye * Ie - de * Be) / De;
  }
  var Re = I, Ee = A, ze = 1, rt = 0;
  for (e = 1; e <= 9; e++)
    ze = ze * Re, rt = rt + this.D[e] * ze;
  var Ze = this.lat0 + rt * dd * 1e5, yt = this.long0 + Ee;
  return t.x = yt, t.y = Ze, t;
}
var gR = ["New_Zealand_Map_Grid", "nzmg"];
const vR = {
  init: dR,
  forward: mR,
  inverse: yR,
  names: gR
};
function _R() {
}
function xR(t) {
  var e = t.x, n = t.y, a = Bt(e - this.long0), s = this.x0 + this.a * a, f = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + n / 2.5)) * 1.25;
  return t.x = s, t.y = f, t;
}
function bR(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = Bt(this.long0 + t.x / this.a), n = 2.5 * (Math.atan(Math.exp(0.8 * t.y / this.a)) - Math.PI / 4);
  return t.x = e, t.y = n, t;
}
var wR = ["Miller_Cylindrical", "mill"];
const ER = {
  init: _R,
  forward: xR,
  inverse: bR,
  names: wR
};
var SR = 20;
function TR() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = wT(this.es);
}
function MR(t) {
  var e, n, a = t.x, s = t.y;
  if (a = Bt(a - this.long0), this.sphere) {
    if (!this.m)
      s = this.n !== 1 ? Math.asin(this.n * Math.sin(s)) : s;
    else
      for (var f = this.n * Math.sin(s), o = SR; o; --o) {
        var m = (this.m * s + Math.sin(s) - f) / (this.m + Math.cos(s));
        if (s -= m, Math.abs(m) < Ct)
          break;
      }
    e = this.a * this.C_x * a * (this.m + Math.cos(s)), n = this.a * this.C_y * s;
  } else {
    var g = Math.sin(s), b = Math.cos(s);
    n = this.a * wv(s, g, b, this.en), e = this.a * a * b / Math.sqrt(1 - this.es * g * g);
  }
  return t.x = e, t.y = n, t;
}
function IR(t) {
  var e, n, a, s;
  return t.x -= this.x0, a = t.x / this.a, t.y -= this.y0, e = t.y / this.a, this.sphere ? (e /= this.C_y, a = a / (this.C_x * (this.m + Math.cos(e))), this.m ? e = Du((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = Du(Math.sin(e) / this.n)), a = Bt(a + this.long0), e = zf(e)) : (e = ET(t.y / this.a, this.es, this.en), s = Math.abs(e), s < ht ? (s = Math.sin(e), n = this.long0 + t.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(e)), a = Bt(n)) : s - Ct < ht && (a = this.long0)), t.x = a, t.y = e, t;
}
var OR = ["Sinusoidal", "sinu"];
const CR = {
  init: TR,
  forward: MR,
  inverse: IR,
  names: OR
};
function AR() {
}
function PR(t) {
  for (var e = t.x, n = t.y, a = Bt(e - this.long0), s = n, f = Math.PI * Math.sin(n); ; ) {
    var o = -(s + Math.sin(s) - f) / (1 + Math.cos(s));
    if (s += o, Math.abs(o) < Ct)
      break;
  }
  s /= 2, Math.PI / 2 - Math.abs(n) < Ct && (a = 0);
  var m = 0.900316316158 * this.a * a * Math.cos(s) + this.x0, g = 1.4142135623731 * this.a * Math.sin(s) + this.y0;
  return t.x = m, t.y = g, t;
}
function kR(t) {
  var e, n;
  t.x -= this.x0, t.y -= this.y0, n = t.y / (1.4142135623731 * this.a), Math.abs(n) > 0.999999999999 && (n = 0.999999999999), e = Math.asin(n);
  var a = Bt(this.long0 + t.x / (0.900316316158 * this.a * Math.cos(e)));
  a < -Math.PI && (a = -Math.PI), a > Math.PI && (a = Math.PI), n = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(n) > 1 && (n = 1);
  var s = Math.asin(n);
  return t.x = a, t.y = s, t;
}
var LR = ["Mollweide", "moll"];
const DR = {
  init: AR,
  forward: PR,
  inverse: kR,
  names: LR
};
function NR() {
  Math.abs(this.lat1 + this.lat2) < Ct || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Gd(this.es), this.e1 = qd(this.es), this.e2 = $d(this.es), this.e3 = Wd(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = Ks(this.e, this.sinphi, this.cosphi), this.ml1 = zo(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < Ct ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = Ks(this.e, this.sinphi, this.cosphi), this.ml2 = zo(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = zo(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function RR(t) {
  var e = t.x, n = t.y, a;
  if (this.sphere)
    a = this.a * (this.g - n);
  else {
    var s = zo(this.e0, this.e1, this.e2, this.e3, n);
    a = this.a * (this.g - s);
  }
  var f = this.ns * Bt(e - this.long0), o = this.x0 + a * Math.sin(f), m = this.y0 + this.rh - a * Math.cos(f);
  return t.x = o, t.y = m, t;
}
function zR(t) {
  t.x -= this.x0, t.y = this.rh - t.y + this.y0;
  var e, n, a, s;
  this.ns >= 0 ? (n = Math.sqrt(t.x * t.x + t.y * t.y), e = 1) : (n = -Math.sqrt(t.x * t.x + t.y * t.y), e = -1);
  var f = 0;
  if (n !== 0 && (f = Math.atan2(e * t.x, e * t.y)), this.sphere)
    return s = Bt(this.long0 + f / this.ns), a = zf(this.g - n / this.a), t.x = s, t.y = a, t;
  var o = this.g - n / this.a;
  return a = Pg(o, this.e0, this.e1, this.e2, this.e3), s = Bt(this.long0 + f / this.ns), t.x = s, t.y = a, t;
}
var FR = ["Equidistant_Conic", "eqdc"];
const BR = {
  init: NR,
  forward: RR,
  inverse: zR,
  names: FR
};
function VR() {
  this.R = this.a;
}
function UR(t) {
  var e = t.x, n = t.y, a = Bt(e - this.long0), s, f;
  Math.abs(n) <= Ct && (s = this.x0 + this.R * a, f = this.y0);
  var o = Du(2 * Math.abs(n / Math.PI));
  (Math.abs(a) <= Ct || Math.abs(Math.abs(n) - ht) <= Ct) && (s = this.x0, n >= 0 ? f = this.y0 + Math.PI * this.R * Math.tan(0.5 * o) : f = this.y0 + Math.PI * this.R * -Math.tan(0.5 * o));
  var m = 0.5 * Math.abs(Math.PI / a - a / Math.PI), g = m * m, b = Math.sin(o), T = Math.cos(o), M = T / (b + T - 1), I = M * M, A = M * (2 / b - 1), z = A * A, V = Math.PI * this.R * (m * (M - z) + Math.sqrt(g * (M - z) * (M - z) - (z + g) * (I - z))) / (z + g);
  a < 0 && (V = -V), s = this.x0 + V;
  var Z = g + M;
  return V = Math.PI * this.R * (A * Z - m * Math.sqrt((z + g) * (g + 1) - Z * Z)) / (z + g), n >= 0 ? f = this.y0 + V : f = this.y0 - V, t.x = s, t.y = f, t;
}
function jR(t) {
  var e, n, a, s, f, o, m, g, b, T, M, I, A;
  return t.x -= this.x0, t.y -= this.y0, M = Math.PI * this.R, a = t.x / M, s = t.y / M, f = a * a + s * s, o = -Math.abs(s) * (1 + f), m = o - 2 * s * s + a * a, g = -2 * o + 1 + 2 * s * s + f * f, A = s * s / g + (2 * m * m * m / g / g / g - 9 * o * m / g / g) / 27, b = (o - m * m / 3 / g) / g, T = 2 * Math.sqrt(-b / 3), M = 3 * A / b / T, Math.abs(M) > 1 && (M >= 0 ? M = 1 : M = -1), I = Math.acos(M) / 3, t.y >= 0 ? n = (-T * Math.cos(I + Math.PI / 3) - m / 3 / g) * Math.PI : n = -(-T * Math.cos(I + Math.PI / 3) - m / 3 / g) * Math.PI, Math.abs(a) < Ct ? e = this.long0 : e = Bt(this.long0 + Math.PI * (f - 1 + Math.sqrt(1 + 2 * (a * a - s * s) + f * f)) / 2 / a), t.x = e, t.y = n, t;
}
var GR = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const qR = {
  init: VR,
  forward: UR,
  inverse: jR,
  names: GR
};
function $R() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}
function WR(t) {
  var e = t.x, n = t.y, a = Math.sin(t.y), s = Math.cos(t.y), f = Bt(e - this.long0), o, m, g, b, T, M, I, A, z, V, Z, X, Y, de, ye, Ie, Be, De, Re, Ee, ze, rt, Ze;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= Ct ? (t.x = this.x0 + this.a * (ht - n) * Math.sin(f), t.y = this.y0 - this.a * (ht - n) * Math.cos(f), t) : Math.abs(this.sin_p12 + 1) <= Ct ? (t.x = this.x0 + this.a * (ht + n) * Math.sin(f), t.y = this.y0 + this.a * (ht + n) * Math.cos(f), t) : (De = this.sin_p12 * a + this.cos_p12 * s * Math.cos(f), Ie = Math.acos(De), Be = Ie ? Ie / Math.sin(Ie) : 1, t.x = this.x0 + this.a * Be * s * Math.sin(f), t.y = this.y0 + this.a * Be * (this.cos_p12 * a - this.sin_p12 * s * Math.cos(f)), t) : (o = Gd(this.es), m = qd(this.es), g = $d(this.es), b = Wd(this.es), Math.abs(this.sin_p12 - 1) <= Ct ? (T = this.a * zo(o, m, g, b, ht), M = this.a * zo(o, m, g, b, n), t.x = this.x0 + (T - M) * Math.sin(f), t.y = this.y0 - (T - M) * Math.cos(f), t) : Math.abs(this.sin_p12 + 1) <= Ct ? (T = this.a * zo(o, m, g, b, ht), M = this.a * zo(o, m, g, b, n), t.x = this.x0 + (T + M) * Math.sin(f), t.y = this.y0 + (T + M) * Math.cos(f), t) : (I = a / s, A = Lf(this.a, this.e, this.sin_p12), z = Lf(this.a, this.e, a), V = Math.atan((1 - this.es) * I + this.es * A * this.sin_p12 / (z * s)), Z = Math.atan2(Math.sin(f), this.cos_p12 * Math.tan(V) - this.sin_p12 * Math.cos(f)), Z === 0 ? Re = Math.asin(this.cos_p12 * Math.sin(V) - this.sin_p12 * Math.cos(V)) : Math.abs(Math.abs(Z) - Math.PI) <= Ct ? Re = -Math.asin(this.cos_p12 * Math.sin(V) - this.sin_p12 * Math.cos(V)) : Re = Math.asin(Math.sin(f) * Math.cos(V) / Math.sin(Z)), X = this.e * this.sin_p12 / Math.sqrt(1 - this.es), Y = this.e * this.cos_p12 * Math.cos(Z) / Math.sqrt(1 - this.es), de = X * Y, ye = Y * Y, Ee = Re * Re, ze = Ee * Re, rt = ze * Re, Ze = rt * Re, Ie = A * Re * (1 - Ee * ye * (1 - ye) / 6 + ze / 8 * de * (1 - 2 * ye) + rt / 120 * (ye * (4 - 7 * ye) - 3 * X * X * (1 - 7 * ye)) - Ze / 48 * de), t.x = this.x0 + Ie * Math.sin(Z), t.y = this.y0 + Ie * Math.cos(Z), t));
}
function HR(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n, a, s, f, o, m, g, b, T, M, I, A, z, V, Z, X, Y, de, ye, Ie, Be, De, Re;
  return this.sphere ? (e = Math.sqrt(t.x * t.x + t.y * t.y), e > 2 * ht * this.a ? void 0 : (n = e / this.a, a = Math.sin(n), s = Math.cos(n), f = this.long0, Math.abs(e) <= Ct ? o = this.lat0 : (o = Du(s * this.sin_p12 + t.y * a * this.cos_p12 / e), m = Math.abs(this.lat0) - ht, Math.abs(m) <= Ct ? this.lat0 >= 0 ? f = Bt(this.long0 + Math.atan2(t.x, -t.y)) : f = Bt(this.long0 - Math.atan2(-t.x, t.y)) : f = Bt(this.long0 + Math.atan2(t.x * a, e * this.cos_p12 * s - t.y * this.sin_p12 * a))), t.x = f, t.y = o, t)) : (g = Gd(this.es), b = qd(this.es), T = $d(this.es), M = Wd(this.es), Math.abs(this.sin_p12 - 1) <= Ct ? (I = this.a * zo(g, b, T, M, ht), e = Math.sqrt(t.x * t.x + t.y * t.y), A = I - e, o = Pg(A / this.a, g, b, T, M), f = Bt(this.long0 + Math.atan2(t.x, -1 * t.y)), t.x = f, t.y = o, t) : Math.abs(this.sin_p12 + 1) <= Ct ? (I = this.a * zo(g, b, T, M, ht), e = Math.sqrt(t.x * t.x + t.y * t.y), A = e - I, o = Pg(A / this.a, g, b, T, M), f = Bt(this.long0 + Math.atan2(t.x, t.y)), t.x = f, t.y = o, t) : (e = Math.sqrt(t.x * t.x + t.y * t.y), Z = Math.atan2(t.x, t.y), z = Lf(this.a, this.e, this.sin_p12), X = Math.cos(Z), Y = this.e * this.cos_p12 * X, de = -Y * Y / (1 - this.es), ye = 3 * this.es * (1 - de) * this.sin_p12 * this.cos_p12 * X / (1 - this.es), Ie = e / z, Be = Ie - de * (1 + de) * Math.pow(Ie, 3) / 6 - ye * (1 + 3 * de) * Math.pow(Ie, 4) / 24, De = 1 - de * Be * Be / 2 - Ie * Be * Be * Be / 6, V = Math.asin(this.sin_p12 * Math.cos(Be) + this.cos_p12 * Math.sin(Be) * X), f = Bt(this.long0 + Math.asin(Math.sin(Z) * Math.sin(Be) / Math.cos(V))), Re = Math.sin(V), o = Math.atan2((Re - this.es * De * this.sin_p12) * Math.tan(V), Re * (1 - this.es)), t.x = f, t.y = o, t));
}
var ZR = ["Azimuthal_Equidistant", "aeqd"];
const XR = {
  init: $R,
  forward: WR,
  inverse: HR,
  names: ZR
};
function KR() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function YR(t) {
  var e, n, a, s, f, o, m, g, b = t.x, T = t.y;
  return a = Bt(b - this.long0), e = Math.sin(T), n = Math.cos(T), s = Math.cos(a), o = this.sin_p14 * e + this.cos_p14 * n * s, f = 1, (o > 0 || Math.abs(o) <= Ct) && (m = this.a * f * n * Math.sin(a), g = this.y0 + this.a * f * (this.cos_p14 * e - this.sin_p14 * n * s)), t.x = m, t.y = g, t;
}
function JR(t) {
  var e, n, a, s, f, o, m;
  return t.x -= this.x0, t.y -= this.y0, e = Math.sqrt(t.x * t.x + t.y * t.y), n = Du(e / this.a), a = Math.sin(n), s = Math.cos(n), o = this.long0, Math.abs(e) <= Ct ? (m = this.lat0, t.x = o, t.y = m, t) : (m = Du(s * this.sin_p14 + t.y * a * this.cos_p14 / e), f = Math.abs(this.lat0) - ht, Math.abs(f) <= Ct ? (this.lat0 >= 0 ? o = Bt(this.long0 + Math.atan2(t.x, -t.y)) : o = Bt(this.long0 - Math.atan2(-t.x, t.y)), t.x = o, t.y = m, t) : (o = Bt(this.long0 + Math.atan2(t.x * a, e * this.cos_p14 * s - t.y * this.sin_p14 * a)), t.x = o, t.y = m, t));
}
var QR = ["ortho"];
const e4 = {
  init: KR,
  forward: YR,
  inverse: JR,
  names: QR
};
var ni = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, ln = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function t4() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= ht - sn / 2 ? this.face = ni.TOP : this.lat0 <= -(ht - sn / 2) ? this.face = ni.BOTTOM : Math.abs(this.long0) <= sn ? this.face = ni.FRONT : Math.abs(this.long0) <= ht + sn ? this.face = this.long0 > 0 ? ni.RIGHT : ni.LEFT : this.face = ni.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function r4(t) {
  var e = { x: 0, y: 0 }, n, a, s, f, o, m, g = { value: 0 };
  if (t.x -= this.long0, this.es !== 0 ? n = Math.atan(this.one_minus_f_squared * Math.tan(t.y)) : n = t.y, a = t.x, this.face === ni.TOP)
    f = ht - n, a >= sn && a <= ht + sn ? (g.value = ln.AREA_0, s = a - ht) : a > ht + sn || a <= -(ht + sn) ? (g.value = ln.AREA_1, s = a > 0 ? a - wi : a + wi) : a > -(ht + sn) && a <= -sn ? (g.value = ln.AREA_2, s = a + ht) : (g.value = ln.AREA_3, s = a);
  else if (this.face === ni.BOTTOM)
    f = ht + n, a >= sn && a <= ht + sn ? (g.value = ln.AREA_0, s = -a + ht) : a < sn && a >= -sn ? (g.value = ln.AREA_1, s = -a) : a < -sn && a >= -(ht + sn) ? (g.value = ln.AREA_2, s = -a - ht) : (g.value = ln.AREA_3, s = a > 0 ? -a + wi : -a - wi);
  else {
    var b, T, M, I, A, z, V;
    this.face === ni.RIGHT ? a = Ef(a, +ht) : this.face === ni.BACK ? a = Ef(a, +wi) : this.face === ni.LEFT && (a = Ef(a, -ht)), I = Math.sin(n), A = Math.cos(n), z = Math.sin(a), V = Math.cos(a), b = A * V, T = A * z, M = I, this.face === ni.FRONT ? (f = Math.acos(b), s = Ty(f, M, T, g)) : this.face === ni.RIGHT ? (f = Math.acos(T), s = Ty(f, M, -b, g)) : this.face === ni.BACK ? (f = Math.acos(-b), s = Ty(f, M, -T, g)) : this.face === ni.LEFT ? (f = Math.acos(-T), s = Ty(f, M, b, g)) : (f = s = 0, g.value = ln.AREA_0);
  }
  return m = Math.atan(12 / wi * (s + Math.acos(Math.sin(s) * Math.cos(sn)) - ht)), o = Math.sqrt((1 - Math.cos(f)) / (Math.cos(m) * Math.cos(m)) / (1 - Math.cos(Math.atan(1 / Math.cos(s))))), g.value === ln.AREA_1 ? m += ht : g.value === ln.AREA_2 ? m += wi : g.value === ln.AREA_3 && (m += 1.5 * wi), e.x = o * Math.cos(m), e.y = o * Math.sin(m), e.x = e.x * this.a + this.x0, e.y = e.y * this.a + this.y0, t.x = e.x, t.y = e.y, t;
}
function n4(t) {
  var e = { lam: 0, phi: 0 }, n, a, s, f, o, m, g, b, T, M = { value: 0 };
  if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, a = Math.atan(Math.sqrt(t.x * t.x + t.y * t.y)), n = Math.atan2(t.y, t.x), t.x >= 0 && t.x >= Math.abs(t.y) ? M.value = ln.AREA_0 : t.y >= 0 && t.y >= Math.abs(t.x) ? (M.value = ln.AREA_1, n -= ht) : t.x < 0 && -t.x >= Math.abs(t.y) ? (M.value = ln.AREA_2, n = n < 0 ? n + wi : n - wi) : (M.value = ln.AREA_3, n += ht), T = wi / 12 * Math.tan(n), o = Math.sin(T) / (Math.cos(T) - 1 / Math.sqrt(2)), m = Math.atan(o), s = Math.cos(n), f = Math.tan(a), g = 1 - s * s * f * f * (1 - Math.cos(Math.atan(1 / Math.cos(m)))), g < -1 ? g = -1 : g > 1 && (g = 1), this.face === ni.TOP)
    b = Math.acos(g), e.phi = ht - b, M.value === ln.AREA_0 ? e.lam = m + ht : M.value === ln.AREA_1 ? e.lam = m < 0 ? m + wi : m - wi : M.value === ln.AREA_2 ? e.lam = m - ht : e.lam = m;
  else if (this.face === ni.BOTTOM)
    b = Math.acos(g), e.phi = b - ht, M.value === ln.AREA_0 ? e.lam = -m + ht : M.value === ln.AREA_1 ? e.lam = -m : M.value === ln.AREA_2 ? e.lam = -m - ht : e.lam = m < 0 ? -m - wi : -m + wi;
  else {
    var I, A, z;
    I = g, T = I * I, T >= 1 ? z = 0 : z = Math.sqrt(1 - T) * Math.sin(m), T += z * z, T >= 1 ? A = 0 : A = Math.sqrt(1 - T), M.value === ln.AREA_1 ? (T = A, A = -z, z = T) : M.value === ln.AREA_2 ? (A = -A, z = -z) : M.value === ln.AREA_3 && (T = A, A = z, z = -T), this.face === ni.RIGHT ? (T = I, I = -A, A = T) : this.face === ni.BACK ? (I = -I, A = -A) : this.face === ni.LEFT && (T = I, I = A, A = -T), e.phi = Math.acos(-z) - ht, e.lam = Math.atan2(A, I), this.face === ni.RIGHT ? e.lam = Ef(e.lam, -ht) : this.face === ni.BACK ? e.lam = Ef(e.lam, -wi) : this.face === ni.LEFT && (e.lam = Ef(e.lam, +ht));
  }
  if (this.es !== 0) {
    var V, Z, X;
    V = e.phi < 0 ? 1 : 0, Z = Math.tan(e.phi), X = this.b / Math.sqrt(Z * Z + this.one_minus_f_squared), e.phi = Math.atan(Math.sqrt(this.a * this.a - X * X) / (this.one_minus_f * X)), V && (e.phi = -e.phi);
  }
  return e.lam += this.long0, t.x = e.lam, t.y = e.phi, t;
}
function Ty(t, e, n, a) {
  var s;
  return t < Ct ? (a.value = ln.AREA_0, s = 0) : (s = Math.atan2(e, n), Math.abs(s) <= sn ? a.value = ln.AREA_0 : s > sn && s <= ht + sn ? (a.value = ln.AREA_1, s -= ht) : s > ht + sn || s <= -(ht + sn) ? (a.value = ln.AREA_2, s = s >= 0 ? s - wi : s + wi) : (a.value = ln.AREA_3, s += ht)), s;
}
function Ef(t, e) {
  var n = t + e;
  return n < -wi ? n += Pd : n > +wi && (n -= Pd), n;
}
var i4 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const o4 = {
  init: t4,
  forward: r4,
  inverse: n4,
  names: i4
};
var H0 = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], td = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], MT = 0.8487, IT = 1.3523, OT = js / 5, a4 = 1 / OT, yf = 18, kg = function(t, e) {
  return t[0] + e * (t[1] + e * (t[2] + e * t[3]));
}, s4 = function(t, e) {
  return t[1] + e * (2 * t[2] + e * 3 * t[3]);
};
function l4(t, e, n, a) {
  for (var s = e; a; --a) {
    var f = t(s);
    if (s -= f, Math.abs(f) < n)
      break;
  }
  return s;
}
function u4() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function c4(t) {
  var e = Bt(t.x - this.long0), n = Math.abs(t.y), a = Math.floor(n * OT);
  a < 0 ? a = 0 : a >= yf && (a = yf - 1), n = js * (n - a4 * a);
  var s = {
    x: kg(H0[a], n) * e,
    y: kg(td[a], n)
  };
  return t.y < 0 && (s.y = -s.y), s.x = s.x * this.a * MT + this.x0, s.y = s.y * this.a * IT + this.y0, s;
}
function h4(t) {
  var e = {
    x: (t.x - this.x0) / (this.a * MT),
    y: Math.abs(t.y - this.y0) / (this.a * IT)
  };
  if (e.y >= 1)
    e.x /= H0[yf][0], e.y = t.y < 0 ? -ht : ht;
  else {
    var n = Math.floor(e.y * yf);
    for (n < 0 ? n = 0 : n >= yf && (n = yf - 1); ; )
      if (td[n][0] > e.y)
        --n;
      else if (td[n + 1][0] <= e.y)
        ++n;
      else
        break;
    var a = td[n], s = 5 * (e.y - a[0]) / (td[n + 1][0] - a[0]);
    s = l4(function(f) {
      return (kg(a, f) - e.y) / s4(a, f);
    }, s, Ct, 100), e.x /= kg(H0[n], s), e.y = (5 * n + s) * io, t.y < 0 && (e.y = -e.y);
  }
  return e.x = Bt(e.x + this.long0), e;
}
var f4 = ["Robinson", "robin"];
const p4 = {
  init: u4,
  forward: c4,
  inverse: h4,
  names: f4
};
function d4() {
  this.name = "geocent";
}
function m4(t) {
  var e = pT(t, this.es, this.a);
  return e;
}
function y4(t) {
  var e = dT(t, this.es, this.a, this.b);
  return e;
}
var g4 = ["Geocentric", "geocentric", "geocent", "Geocent"];
const v4 = {
  init: d4,
  forward: m4,
  inverse: y4,
  names: g4
};
var _o = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, qp = {
  h: { def: 1e5, num: !0 },
  azi: { def: 0, num: !0, degrees: !0 },
  tilt: { def: 0, num: !0, degrees: !0 },
  long0: { def: 0, num: !0 },
  lat0: { def: 0, num: !0 }
};
function _4() {
  if (Object.keys(qp).forEach(function(n) {
    if (typeof this[n] > "u")
      this[n] = qp[n].def;
    else {
      if (qp[n].num && isNaN(this[n]))
        throw new Error("Invalid parameter value, must be numeric " + n + " = " + this[n]);
      qp[n].num && (this[n] = parseFloat(this[n]));
    }
    qp[n].degrees && (this[n] = this[n] * io);
  }.bind(this)), Math.abs(Math.abs(this.lat0) - ht) < Ct ? this.mode = this.lat0 < 0 ? _o.S_POLE : _o.N_POLE : Math.abs(this.lat0) < Ct ? this.mode = _o.EQUIT : (this.mode = _o.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var t = this.tilt, e = this.azi;
  this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(t), this.sw = Math.sin(t);
}
function x4(t) {
  t.x -= this.long0;
  var e = Math.sin(t.y), n = Math.cos(t.y), a = Math.cos(t.x), s, f;
  switch (this.mode) {
    case _o.OBLIQ:
      f = this.sinph0 * e + this.cosph0 * n * a;
      break;
    case _o.EQUIT:
      f = n * a;
      break;
    case _o.S_POLE:
      f = -e;
      break;
    case _o.N_POLE:
      f = e;
      break;
  }
  switch (f = this.pn1 / (this.p - f), s = f * n * Math.sin(t.x), this.mode) {
    case _o.OBLIQ:
      f *= this.cosph0 * e - this.sinph0 * n * a;
      break;
    case _o.EQUIT:
      f *= e;
      break;
    case _o.N_POLE:
      f *= -(n * a);
      break;
    case _o.S_POLE:
      f *= n * a;
      break;
  }
  var o, m;
  return o = f * this.cg + s * this.sg, m = 1 / (o * this.sw * this.h1 + this.cw), s = (s * this.cg - f * this.sg) * this.cw * m, f = o * m, t.x = s * this.a, t.y = f * this.a, t;
}
function b4(t) {
  t.x /= this.a, t.y /= this.a;
  var e = { x: t.x, y: t.y }, n, a, s;
  s = 1 / (this.pn1 - t.y * this.sw), n = this.pn1 * t.x * s, a = this.pn1 * t.y * this.cw * s, t.x = n * this.cg + a * this.sg, t.y = a * this.cg - n * this.sg;
  var f = ns(t.x, t.y);
  if (Math.abs(f) < Ct)
    e.x = 0, e.y = t.y;
  else {
    var o, m;
    switch (m = 1 - f * f * this.pfact, m = (this.p - Math.sqrt(m)) / (this.pn1 / f + f / this.pn1), o = Math.sqrt(1 - m * m), this.mode) {
      case _o.OBLIQ:
        e.y = Math.asin(o * this.sinph0 + t.y * m * this.cosph0 / f), t.y = (o - this.sinph0 * Math.sin(e.y)) * f, t.x *= m * this.cosph0;
        break;
      case _o.EQUIT:
        e.y = Math.asin(t.y * m / f), t.y = o * f, t.x *= m;
        break;
      case _o.N_POLE:
        e.y = Math.asin(o), t.y = -t.y;
        break;
      case _o.S_POLE:
        e.y = -Math.asin(o);
        break;
    }
    e.x = Math.atan2(t.x, t.y);
  }
  return t.x = e.x + this.long0, t.y = e.y, t;
}
var w4 = ["Tilted_Perspective", "tpers"];
const E4 = {
  init: _4,
  forward: x4,
  inverse: b4,
  names: w4
};
function S4() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var t = 1 - this.es, e = 1 / t;
    this.radius_p = Math.sqrt(t), this.radius_p2 = t, this.radius_p_inv2 = e, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function T4(t) {
  var e = t.x, n = t.y, a, s, f, o;
  if (e = e - this.long0, this.shape === "ellipse") {
    n = Math.atan(this.radius_p2 * Math.tan(n));
    var m = this.radius_p / ns(this.radius_p * Math.cos(n), Math.sin(n));
    if (s = m * Math.cos(e) * Math.cos(n), f = m * Math.sin(e) * Math.cos(n), o = m * Math.sin(n), (this.radius_g - s) * s - f * f - o * o * this.radius_p_inv2 < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    a = this.radius_g - s, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(f / ns(o, a)), t.y = this.radius_g_1 * Math.atan(o / a)) : (t.x = this.radius_g_1 * Math.atan(f / a), t.y = this.radius_g_1 * Math.atan(o / ns(f, a)));
  } else
    this.shape === "sphere" && (a = Math.cos(n), s = Math.cos(e) * a, f = Math.sin(e) * a, o = Math.sin(n), a = this.radius_g - s, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(f / ns(o, a)), t.y = this.radius_g_1 * Math.atan(o / a)) : (t.x = this.radius_g_1 * Math.atan(f / a), t.y = this.radius_g_1 * Math.atan(o / ns(f, a))));
  return t.x = t.x * this.a, t.y = t.y * this.a, t;
}
function M4(t) {
  var e = -1, n = 0, a = 0, s, f, o, m;
  if (t.x = t.x / this.a, t.y = t.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (a = Math.tan(t.y / this.radius_g_1), n = Math.tan(t.x / this.radius_g_1) * ns(1, a)) : (n = Math.tan(t.x / this.radius_g_1), a = Math.tan(t.y / this.radius_g_1) * ns(1, n));
    var g = a / this.radius_p;
    if (s = n * n + g * g + e * e, f = 2 * this.radius_g * e, o = f * f - 4 * s * this.C, o < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    m = (-f - Math.sqrt(o)) / (2 * s), e = this.radius_g + m * e, n *= m, a *= m, t.x = Math.atan2(n, e), t.y = Math.atan(a * Math.cos(t.x) / e), t.y = Math.atan(this.radius_p_inv2 * Math.tan(t.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (a = Math.tan(t.y / this.radius_g_1), n = Math.tan(t.x / this.radius_g_1) * Math.sqrt(1 + a * a)) : (n = Math.tan(t.x / this.radius_g_1), a = Math.tan(t.y / this.radius_g_1) * Math.sqrt(1 + n * n)), s = n * n + a * a + e * e, f = 2 * this.radius_g * e, o = f * f - 4 * s * this.C, o < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    m = (-f - Math.sqrt(o)) / (2 * s), e = this.radius_g + m * e, n *= m, a *= m, t.x = Math.atan2(n, e), t.y = Math.atan(a * Math.cos(t.x) / e);
  }
  return t.x = t.x + this.long0, t;
}
var I4 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const O4 = {
  init: S4,
  forward: T4,
  inverse: M4,
  names: I4
};
function C4(t) {
  t.Proj.projections.add(ig), t.Proj.projections.add(og), t.Proj.projections.add(NN), t.Proj.projections.add($N), t.Proj.projections.add(YN), t.Proj.projections.add(r3), t.Proj.projections.add(l3), t.Proj.projections.add(p3), t.Proj.projections.add(v3), t.Proj.projections.add(E3), t.Proj.projections.add(V3), t.Proj.projections.add(W3), t.Proj.projections.add(Y3), t.Proj.projections.add(nR), t.Proj.projections.add(lR), t.Proj.projections.add(pR), t.Proj.projections.add(vR), t.Proj.projections.add(ER), t.Proj.projections.add(CR), t.Proj.projections.add(DR), t.Proj.projections.add(BR), t.Proj.projections.add(qR), t.Proj.projections.add(XR), t.Proj.projections.add(e4), t.Proj.projections.add(o4), t.Proj.projections.add(p4), t.Proj.projections.add(v4), t.Proj.projections.add(E4), t.Proj.projections.add(O4);
}
wo.defaultDatum = "WGS84";
wo.Proj = $s;
wo.WGS84 = new wo.Proj("WGS84");
wo.Point = kf;
wo.toPoint = mT;
wo.defs = Do;
wo.nadgrid = zD;
wo.transform = Ag;
wo.mgrs = QD;
wo.version = "__VERSION__";
C4(wo);
function A4() {
  var t, e, n;
  wo.defs("EPSG:32632", "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs"), wo.defs("EPSG:32631", "+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs"), wo.defs(
    "EPSG:2169",
    "+proj=tmerc +lat_0=49.83333333333334 +lon_0=6.166666666666667 +k=1 +x_0=80000 +y_0=100000 +ellps=intl +towgs84=-189.681,18.3463,-42.7695,-0.33746,-3.09264,2.53861,0.4598 +units=m +no_defs"
  ), fC(wo), (t = Wy("EPSG:32632")) == null || t.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]), (e = Wy("EPSG:32631")) == null || e.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]), (n = Wy("EPSG:2169")) == null || n.setExtent([
    48225.17,
    56225.6,
    105842.04,
    139616.4
  ]);
}
function P4(t, e, n) {
  const a = ur(t);
  class s extends V1 {
    constructor(o) {
      super(a, o, e, n);
    }
  }
  return bi(s, "def", a), s;
}
const k4 = typeof HTMLElement < "u" ? HTMLElement : class {
};
class V1 extends k4 {
  constructor(n, a = {}, s = {}, f) {
    super();
    bi(this, "_instance", null);
    bi(this, "_connected", !1);
    bi(this, "_resolved", !1);
    bi(this, "_numberProps", null);
    bi(this, "_styles");
    bi(this, "_slots");
    this._def = n, this._props = a, this._config = s, this._config = Wn(
      {
        shadowRoot: !0
      },
      this._config
    ), this._config.shadowRoot ? this.shadowRoot && f ? f(this._createVNode(), this.shadowRoot) : (this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def)) : f && f(this._createVNode(), this._root);
  }
  get _root() {
    return this._config.shadowRoot ? this.shadowRoot : this;
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, xg(() => {
      this._connected || (gw(null, this._root), this._instance = null);
    });
  }
  _resolveDef() {
    this._resolved = !0;
    for (let s = 0; s < this.attributes.length; s++)
      this._setAttr(this.attributes[s].name);
    new MutationObserver((s) => {
      for (const f of s)
        this._setAttr(f.attributeName);
    }).observe(this, { attributes: !0 });
    const n = (s, f = !1) => {
      const { props: o, styles: m } = s;
      let g;
      if (o && !er(o))
        for (const b in o) {
          const T = o[b];
          (T === Number || T && T.type === Number) && (b in this._props && (this._props[b] = g0(this._props[b])), (g || (g = /* @__PURE__ */ Object.create(null)))[ya(b)] = !0);
        }
      this._numberProps = g, f && this._resolveProps(s), this._applyStyles(m), this._update();
    }, a = this._def.__asyncLoader;
    a ? a().then((s) => n(s, !0)) : n(this._def);
  }
  _resolveProps(n) {
    const { props: a } = n, s = er(a) ? a : Object.keys(a || {});
    for (const f of Object.keys(this))
      f[0] !== "_" && s.includes(f) && this._setProp(f, this[f], !0, !1);
    for (const f of s.map(ya))
      Object.defineProperty(this, f, {
        get() {
          return this._getProp(f);
        },
        set(o) {
          this._setProp(f, o);
        }
      });
  }
  _setAttr(n) {
    let a = this.getAttribute(n);
    const s = ya(n);
    this._numberProps && this._numberProps[s] && (a = g0(a)), this._setProp(s, a, !1);
  }
  _getProp(n) {
    return this._props[n];
  }
  _setProp(n, a, s = !0, f = !0) {
    a !== this._props[n] && (this._props[n] = a, f && this._instance && this._update(), s && (a === !0 ? this.setAttribute(ta(n), "") : typeof a == "string" || typeof a == "number" ? this.setAttribute(ta(n), a + "") : a || this.removeAttribute(ta(n))));
  }
  _update() {
    gw(this._createVNode(), this._root);
  }
  _createVNode() {
    const n = Gt(this._def, Wn({}, this._props));
    return this._instance || (n.ce = (a) => {
      this._instance = a, a.isCE = !0;
      const s = (o, m) => {
        this.dispatchEvent(
          new CustomEvent(o, {
            detail: m
          })
        );
      };
      a.emit = (o, ...m) => {
        s(o, m), ta(o) !== o && s(ta(o), m);
      };
      let f = this;
      for (; f = f && (f.parentNode || f.host); )
        if (f instanceof V1) {
          a.parent = f._instance, a.provides = f._instance.provides;
          break;
        }
    }), n;
  }
  _applyStyles(n) {
    n && n.forEach((a) => {
      const s = document.createElement("style");
      s.textContent = a, this._root.appendChild(s);
    });
  }
}
var U1 = /* @__PURE__ */ ((t) => (t.INFO = "alert-info", t.WARNING = "alert-warning", t.ERROR = "alert-danger", t))(U1 || {});
const L4 = U1.INFO, D4 = 7e3, N4 = 4e3, CT = Qc(
  "alert-notifications",
  () => {
    const t = Hr([]);
    function e(a, s = L4, f) {
      const o = {
        message: a,
        type: s,
        duration: f != null ? f : s === U1.WARNING ? N4 : D4
      };
      t.value.push(o);
    }
    function n(a) {
      t.value.splice(a, 1);
    }
    return {
      notifications: t,
      addNotification: e,
      removeNotification: n
    };
  },
  {}
), R4 = /* @__PURE__ */ ur({
  __name: "notification-item",
  props: {
    notification: { type: null, required: !0 }
  },
  emits: ["close"],
  setup(t) {
    const e = t, n = Fn(!0);
    function a(s, f) {
      setTimeout(() => {
        n.value = !1;
      }, e.notification.duration), f();
    }
    return (s, f) => (Ue(), cn(_v, {
      name: "fade-out",
      appear: "",
      "leave-active-class": "duration-200 ease-in",
      "leave-from-class": "opacity-100",
      "leave-to-class": "transform opacity-0",
      onEnter: a,
      onAfterLeave: f[0] || (f[0] = (o) => s.$emit("close"))
    }, {
      default: Bd(() => [
        le(n) ? (Ue(), st("div", {
          key: 0,
          class: Lr(["lux-alert", `lux-${e.notification.type}`]),
          role: "alert"
        }, Vt(e.notification.message), 3)) : it("v-if", !0)
      ]),
      _: 1
    }));
  }
}), mr = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [a, s] of e)
    n[a] = s;
  return n;
}, z4 = /* @__PURE__ */ mr(R4, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/alert-notifications/notification-item.vue"]]), F4 = {
  key: 0,
  class: "lux-notifications fixed w-[500px] top-10 left-1/2 ml-[-250px] z-50"
}, B4 = /* @__PURE__ */ ur({
  __name: "alert-notifications",
  setup(t) {
    const e = CT(), { notifications: n } = xn(e);
    function a(s) {
      e.removeNotification(s);
    }
    return (s, f) => (Ue(), cn(kS, { to: "body" }, [
      le(n).length ? (Ue(), st("div", F4, [
        (Ue(!0), st(un, null, Ra(le(n), (o, m) => (Ue(), cn(z4, {
          key: m,
          notification: o,
          onClose: () => a(m)
        }, null, 8, ["notification", "onClose"]))), 128))
      ])) : it("v-if", !0)
    ]));
  }
}), V4 = /* @__PURE__ */ mr(B4, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/alert-notifications/alert-notifications.vue"]]), U4 = { class: "lux-dropdown" }, j4 = { class: "h-full" }, G4 = ["aria-expanded"], q4 = /* @__PURE__ */ Ne("span", { class: "lux-caret" }, null, -1), $4 = { class: "lux-dropdown-wrapper" }, W4 = ["aria-label", "data-value"], H4 = /* @__PURE__ */ ur({
  __name: "dropdown-list",
  props: {
    placeholder: { type: String, required: !0 },
    options: { type: Array, required: !0, default: () => [{ label: "Default label", value: "Default value" }] },
    modelValue: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, a = Fn(!1), s = Fn();
    function f(b) {
      a.value = b === void 0 ? !a.value : b;
    }
    function o(b) {
      b.stopImmediatePropagation(), f();
    }
    function m(b) {
      s.value = b.target.dataset.value, e("change", s.value);
    }
    function g() {
      f(!1);
    }
    return va(() => document.addEventListener("click", g)), Jc(() => document.removeEventListener("click", g)), (b, T) => {
      var M, I;
      return Ue(), st("div", U4, [
        Ne("div", j4, [
          Ne("button", {
            type: "button",
            class: Lr(["lux-btn lux-dropdown-btn", le(a) ? "expanded" : ""]),
            "aria-expanded": le(a),
            "aria-haspopup": "true",
            onClick: o
          }, [
            Ne("span", null, Vt((I = n.placeholder) != null ? I : (M = n.options[0]) == null ? void 0 : M.label), 1),
            q4
          ], 10, G4)
        ]),
        Ne("div", $4, [
          Ne("ul", {
            class: Lr(["lux-dropdown-list", le(a) ? "" : "hidden"]),
            tabindex: "-1"
          }, [
            (Ue(!0), st(un, null, Ra(n.options, (A) => (Ue(), st("li", {
              key: A.value,
              class: Lr(t.modelValue === A.value ? "selected" : "")
            }, [
              Ne("button", {
                class: "lux-dropdown-list-item",
                "aria-label": A.ariaLabel,
                "data-value": A.value,
                onClick: m
              }, Vt(A.label), 9, W4)
            ], 2))), 128))
          ], 2)
        ])
      ]);
    };
  }
}), AT = /* @__PURE__ */ mr(H4, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/common/dropdown-list.vue"]]), md = "EPSG:3857", PT = "EPSG:4326", Z4 = "EPSG:2169";
let j_;
const Hw = Fn();
function Nl() {
  function t() {
    return j_;
  }
  function e() {
    return Hw.value = j_ = new pC({
      view: new dC({
        zoom: 10,
        center: [682439, 6379152],
        multiWorld: !0
      }),
      controls: []
    }), j_;
  }
  function n(T, M) {
    return T.id === M.id;
  }
  function a(T, M) {
    return T === M;
  }
  function s(T, M) {
    var I;
    return (I = T.layers) == null ? void 0 : I.some((A) => n(A, M));
  }
  function f(T, M) {
    var A;
    const I = (A = T == null ? void 0 : T.layers) == null ? void 0 : A.find((z) => n(z, M));
    return !a(I, M);
  }
  function o(T, M) {
    return !(M === null || !("layers" in T) || !("layers" in M) || typeof M.layers > "u" || typeof T.layers > "u" || T.layers === M.layers);
  }
  function m(T, M) {
    return !("layers" in T) || typeof T.layers > "u" ? [] : M === null || !("layers" in M) ? T.layers.map((I, A) => ({ layer: I, position: A })) : T.layers === M.layers ? [] : T.layers.reduce(
      (I, A, z) => s(M, A) ? I : [
        ...I,
        {
          layer: A,
          position: z
        }
      ],
      []
    );
  }
  function g(T, M) {
    return o(T, M) ? M.layers.reduce(
      (I, A) => s(T, A) ? I : [...I, A],
      []
    ) : [];
  }
  function b(T, M) {
    return o(T, M) ? T.layers.reduce(
      (I, A) => f(M, A) ? [...I, A] : I,
      []
    ) : [];
  }
  return {
    olMap: Hw,
    getOlMap: t,
    createMap: e,
    equalsLayer: n,
    hasLayer: s,
    layerHasChanged: f,
    contextHasChanged: o,
    getAddedLayers: m,
    getRemovedLayers: g,
    getMutatedLayers: b
  };
}
var Us = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, kT = { exports: {} };
(function(t, e) {
  (function(n, a) {
    t.exports = a();
  })(Us, function() {
    var n, a, s;
    function f(o, m) {
      if (!n)
        n = m;
      else if (!a)
        a = m;
      else {
        var g = "var sharedChunk = {}; (" + n + ")(sharedChunk); (" + a + ")(sharedChunk);", b = {};
        n(b), s = m(b), typeof window < "u" && (s.workerUrl = window.URL.createObjectURL(new Blob([g], { type: "text/javascript" })));
      }
    }
    return f(["exports"], function(o) {
      function m(r, i) {
        return r(i = { exports: {} }, i.exports), i.exports;
      }
      var g = b;
      function b(r, i, l, p) {
        this.cx = 3 * r, this.bx = 3 * (l - r) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (p - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r, this.p1y = p, this.p2x = l, this.p2y = p;
      }
      b.prototype.sampleCurveX = function(r) {
        return ((this.ax * r + this.bx) * r + this.cx) * r;
      }, b.prototype.sampleCurveY = function(r) {
        return ((this.ay * r + this.by) * r + this.cy) * r;
      }, b.prototype.sampleCurveDerivativeX = function(r) {
        return (3 * this.ax * r + 2 * this.bx) * r + this.cx;
      }, b.prototype.solveCurveX = function(r, i) {
        var l, p, y, v, x;
        for (i === void 0 && (i = 1e-6), y = r, x = 0; x < 8; x++) {
          if (v = this.sampleCurveX(y) - r, Math.abs(v) < i)
            return y;
          var S = this.sampleCurveDerivativeX(y);
          if (Math.abs(S) < 1e-6)
            break;
          y -= v / S;
        }
        if ((y = r) < (l = 0))
          return l;
        if (y > (p = 1))
          return p;
        for (; l < p; ) {
          if (v = this.sampleCurveX(y), Math.abs(v - r) < i)
            return y;
          r > v ? l = y : p = y, y = 0.5 * (p - l) + l;
        }
        return y;
      }, b.prototype.solve = function(r, i) {
        return this.sampleCurveY(this.solveCurveX(r, i));
      };
      var T = M;
      function M(r, i) {
        this.x = r, this.y = i;
      }
      M.prototype = { clone: function() {
        return new M(this.x, this.y);
      }, add: function(r) {
        return this.clone()._add(r);
      }, sub: function(r) {
        return this.clone()._sub(r);
      }, multByPoint: function(r) {
        return this.clone()._multByPoint(r);
      }, divByPoint: function(r) {
        return this.clone()._divByPoint(r);
      }, mult: function(r) {
        return this.clone()._mult(r);
      }, div: function(r) {
        return this.clone()._div(r);
      }, rotate: function(r) {
        return this.clone()._rotate(r);
      }, rotateAround: function(r, i) {
        return this.clone()._rotateAround(r, i);
      }, matMult: function(r) {
        return this.clone()._matMult(r);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(r) {
        return this.x === r.x && this.y === r.y;
      }, dist: function(r) {
        return Math.sqrt(this.distSqr(r));
      }, distSqr: function(r) {
        var i = r.x - this.x, l = r.y - this.y;
        return i * i + l * l;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(r) {
        return Math.atan2(this.y - r.y, this.x - r.x);
      }, angleWith: function(r) {
        return this.angleWithSep(r.x, r.y);
      }, angleWithSep: function(r, i) {
        return Math.atan2(this.x * i - this.y * r, this.x * r + this.y * i);
      }, _matMult: function(r) {
        var i = r[2] * this.x + r[3] * this.y;
        return this.x = r[0] * this.x + r[1] * this.y, this.y = i, this;
      }, _add: function(r) {
        return this.x += r.x, this.y += r.y, this;
      }, _sub: function(r) {
        return this.x -= r.x, this.y -= r.y, this;
      }, _mult: function(r) {
        return this.x *= r, this.y *= r, this;
      }, _div: function(r) {
        return this.x /= r, this.y /= r, this;
      }, _multByPoint: function(r) {
        return this.x *= r.x, this.y *= r.y, this;
      }, _divByPoint: function(r) {
        return this.x /= r.x, this.y /= r.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var r = this.y;
        return this.y = this.x, this.x = -r, this;
      }, _rotate: function(r) {
        var i = Math.cos(r), l = Math.sin(r), p = l * this.x + i * this.y;
        return this.x = i * this.x - l * this.y, this.y = p, this;
      }, _rotateAround: function(r, i) {
        var l = Math.cos(r), p = Math.sin(r), y = i.y + p * (this.x - i.x) + l * (this.y - i.y);
        return this.x = i.x + l * (this.x - i.x) - p * (this.y - i.y), this.y = y, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, M.convert = function(r) {
        return r instanceof M ? r : Array.isArray(r) ? new M(r[0], r[1]) : r;
      };
      var I = typeof self < "u" ? self : {}, A = Math.pow(2, 53) - 1;
      function z(r, i, l, p) {
        var y = new g(r, i, l, p);
        return function(v) {
          return y.solve(v);
        };
      }
      var V = z(0.25, 0.1, 0.25, 1);
      function Z(r, i, l) {
        return Math.min(l, Math.max(i, r));
      }
      function X(r, i, l) {
        var p = l - i, y = ((r - i) % p + p) % p + i;
        return y === i ? l : y;
      }
      function Y(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        for (var p = 0, y = i; p < y.length; p += 1) {
          var v = y[p];
          for (var x in v)
            r[x] = v[x];
        }
        return r;
      }
      var de = 1;
      function ye() {
        return de++;
      }
      function Ie() {
        return function r(i) {
          return i ? (i ^ 16 * Math.random() >> i / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, r);
        }();
      }
      function Be(r) {
        return !!r && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(r);
      }
      function De(r, i) {
        r.forEach(function(l) {
          i[l] && (i[l] = i[l].bind(i));
        });
      }
      function Re(r, i) {
        return r.indexOf(i, r.length - i.length) !== -1;
      }
      function Ee(r, i, l) {
        var p = {};
        for (var y in r)
          p[y] = i.call(l || this, r[y], y, r);
        return p;
      }
      function ze(r, i, l) {
        var p = {};
        for (var y in r)
          i.call(l || this, r[y], y, r) && (p[y] = r[y]);
        return p;
      }
      function rt(r) {
        return Array.isArray(r) ? r.map(rt) : typeof r == "object" && r ? Ee(r, rt) : r;
      }
      var Ze = {};
      function yt(r) {
        Ze[r] || (typeof console < "u" && console.warn(r), Ze[r] = !0);
      }
      function xe(r, i, l) {
        return (l.y - r.y) * (i.x - r.x) > (i.y - r.y) * (l.x - r.x);
      }
      function Ke(r) {
        for (var i = 0, l = 0, p = r.length, y = p - 1, v = void 0, x = void 0; l < p; y = l++)
          i += ((x = r[y]).x - (v = r[l]).x) * (v.y + x.y);
        return i;
      }
      function ct() {
        return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
      }
      function vt(r) {
        var i = {};
        if (r.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, function(p, y, v, x) {
          var S = v || x;
          return i[y] = !S || S.toLowerCase(), "";
        }), i["max-age"]) {
          var l = parseInt(i["max-age"], 10);
          isNaN(l) ? delete i["max-age"] : i["max-age"] = l;
        }
        return i;
      }
      var Pt = null;
      function tr(r) {
        if (Pt == null) {
          var i = r.navigator ? r.navigator.userAgent : null;
          Pt = !!r.safari || !(!i || !(/\b(iPad|iPhone|iPod)\b/.test(i) || i.match("Safari") && !i.match("Chrome")));
        }
        return Pt;
      }
      function Pn(r) {
        try {
          var i = I[r];
          return i.setItem("_mapbox_test_", 1), i.removeItem("_mapbox_test_"), !0;
        } catch {
          return !1;
        }
      }
      var Dr, hr, Zn, Nr, Fi = I.performance && I.performance.now ? I.performance.now.bind(I.performance) : Date.now.bind(Date), Gr = I.requestAnimationFrame || I.mozRequestAnimationFrame || I.webkitRequestAnimationFrame || I.msRequestAnimationFrame, Cr = I.cancelAnimationFrame || I.mozCancelAnimationFrame || I.webkitCancelAnimationFrame || I.msCancelAnimationFrame, Vn = { now: Fi, frame: function(r) {
        var i = Gr(r);
        return { cancel: function() {
          return Cr(i);
        } };
      }, getImageData: function(r, i) {
        i === void 0 && (i = 0);
        var l = I.document.createElement("canvas"), p = l.getContext("2d");
        if (!p)
          throw new Error("failed to create canvas 2d context");
        return l.width = r.width, l.height = r.height, p.drawImage(r, 0, 0, r.width, r.height), p.getImageData(-i, -i, r.width + 2 * i, r.height + 2 * i);
      }, resolveURL: function(r) {
        return Dr || (Dr = I.document.createElement("a")), Dr.href = r, Dr.href;
      }, hardwareConcurrency: I.navigator && I.navigator.hardwareConcurrency || 4, get devicePixelRatio() {
        return I.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!I.matchMedia && (hr == null && (hr = I.matchMedia("(prefers-reduced-motion: reduce)")), hr.matches);
      } }, wr = { API_URL: "https://api.mapbox.com", get EVENTS_URL() {
        return this.API_URL ? this.API_URL.indexOf("https://api.mapbox.cn") === 0 ? "https://events.mapbox.cn/events/v2" : this.API_URL.indexOf("https://api.mapbox.com") === 0 ? "https://events.mapbox.com/events/v2" : null : null;
      }, FEEDBACK_URL: "https://apps.mapbox.com/feedback", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, En = { supported: !1, testSupport: function(r) {
        !oi && Nr && (Un ? K(r) : Zn = r);
      } }, oi = !1, Un = !1;
      function K(r) {
        var i = r.createTexture();
        r.bindTexture(r.TEXTURE_2D, i);
        try {
          if (r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, Nr), r.isContextLost())
            return;
          En.supported = !0;
        } catch {
        }
        r.deleteTexture(i), oi = !0;
      }
      I.document && ((Nr = I.document.createElement("img")).onload = function() {
        Zn && K(Zn), Zn = null, Un = !0;
      }, Nr.onerror = function() {
        oi = !0, Zn = null;
      }, Nr.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      var me = "01", Le = function(r, i) {
        this._transformRequestFn = r, this._customAccessToken = i, this._createSkuToken();
      };
      function qe(r) {
        return r.indexOf("mapbox:") === 0;
      }
      Le.prototype._createSkuToken = function() {
        var r = function() {
          for (var i = "", l = 0; l < 10; l++)
            i += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
          return { token: ["1", me, i].join(""), tokenExpiresAt: Date.now() + 432e5 };
        }();
        this._skuToken = r.token, this._skuTokenExpiresAt = r.tokenExpiresAt;
      }, Le.prototype._isSkuTokenExpired = function() {
        return Date.now() > this._skuTokenExpiresAt;
      }, Le.prototype.transformRequest = function(r, i) {
        return this._transformRequestFn && this._transformRequestFn(r, i) || { url: r };
      }, Le.prototype.normalizeStyleURL = function(r, i) {
        if (!qe(r))
          return r;
        var l = Je(r);
        return l.path = "/styles/v1" + l.path, this._makeAPIURL(l, this._customAccessToken || i);
      }, Le.prototype.normalizeGlyphsURL = function(r, i) {
        if (!qe(r))
          return r;
        var l = Je(r);
        return l.path = "/fonts/v1" + l.path, this._makeAPIURL(l, this._customAccessToken || i);
      }, Le.prototype.normalizeSourceURL = function(r, i) {
        if (!qe(r))
          return r;
        var l = Je(r);
        return l.path = "/v4/" + l.authority + ".json", l.params.push("secure"), this._makeAPIURL(l, this._customAccessToken || i);
      }, Le.prototype.normalizeSpriteURL = function(r, i, l, p) {
        var y = Je(r);
        return qe(r) ? (y.path = "/styles/v1" + y.path + "/sprite" + i + l, this._makeAPIURL(y, this._customAccessToken || p)) : (y.path += "" + i + l, lt(y));
      }, Le.prototype.normalizeTileURL = function(r, i) {
        if (this._isSkuTokenExpired() && this._createSkuToken(), r && !qe(r))
          return r;
        var l = Je(r);
        l.path = l.path.replace(/(\.(png|jpg)\d*)(?=$)/, (Vn.devicePixelRatio >= 2 || i === 512 ? "@2x" : "") + (En.supported ? ".webp" : "$1")), l.path = l.path.replace(/^.+\/v4\//, "/"), l.path = "/v4" + l.path;
        var p = this._customAccessToken || function(y) {
          for (var v = 0, x = y; v < x.length; v += 1) {
            var S = x[v].match(/^access_token=(.*)$/);
            if (S)
              return S[1];
          }
          return null;
        }(l.params) || wr.ACCESS_TOKEN;
        return wr.REQUIRE_ACCESS_TOKEN && p && this._skuToken && l.params.push("sku=" + this._skuToken), this._makeAPIURL(l, p);
      }, Le.prototype.canonicalizeTileURL = function(r, i) {
        var l = Je(r);
        if (!l.path.match(/(^\/v4\/)/) || !l.path.match(/\.[\w]+$/))
          return r;
        var p = "mapbox://tiles/";
        p += l.path.replace("/v4/", "");
        var y = l.params;
        return i && (y = y.filter(function(v) {
          return !v.match(/^access_token=/);
        })), y.length && (p += "?" + y.join("&")), p;
      }, Le.prototype.canonicalizeTileset = function(r, i) {
        for (var l = !!i && qe(i), p = [], y = 0, v = r.tiles || []; y < v.length; y += 1) {
          var x = v[y];
          et(x) ? p.push(this.canonicalizeTileURL(x, l)) : p.push(x);
        }
        return p;
      }, Le.prototype._makeAPIURL = function(r, i) {
        var l = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", p = Je(wr.API_URL);
        if (r.protocol = p.protocol, r.authority = p.authority, r.protocol === "http") {
          var y = r.params.indexOf("secure");
          y >= 0 && r.params.splice(y, 1);
        }
        if (p.path !== "/" && (r.path = "" + p.path + r.path), !wr.REQUIRE_ACCESS_TOKEN)
          return lt(r);
        if (!(i = i || wr.ACCESS_TOKEN))
          throw new Error("An API access token is required to use Mapbox GL. " + l);
        if (i[0] === "s")
          throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + l);
        return r.params = r.params.filter(function(v) {
          return v.indexOf("access_token") === -1;
        }), r.params.push("access_token=" + i), lt(r);
      };
      var $e = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
      function et(r) {
        return $e.test(r);
      }
      var dt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function Je(r) {
        var i = r.match(dt);
        if (!i)
          throw new Error("Unable to parse URL object");
        return { protocol: i[1], authority: i[2], path: i[3] || "/", params: i[4] ? i[4].split("&") : [] };
      }
      function lt(r) {
        var i = r.params.length ? "?" + r.params.join("&") : "";
        return r.protocol + "://" + r.authority + r.path + i;
      }
      function Ye(r) {
        if (!r)
          return null;
        var i = r.split(".");
        if (!i || i.length !== 3)
          return null;
        try {
          return JSON.parse(decodeURIComponent(I.atob(i[1]).split("").map(function(l) {
            return "%" + ("00" + l.charCodeAt(0).toString(16)).slice(-2);
          }).join("")));
        } catch {
          return null;
        }
      }
      var It = function(r) {
        this.type = r, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
      };
      It.prototype.getStorageKey = function(r) {
        var i, l = Ye(wr.ACCESS_TOKEN);
        return i = l && l.u ? I.btoa(encodeURIComponent(l.u).replace(/%([0-9A-F]{2})/g, function(p, y) {
          return String.fromCharCode(Number("0x" + y));
        })) : wr.ACCESS_TOKEN || "", r ? "mapbox.eventData." + r + ":" + i : "mapbox.eventData:" + i;
      }, It.prototype.fetchEventData = function() {
        var r = Pn("localStorage"), i = this.getStorageKey(), l = this.getStorageKey("uuid");
        if (r)
          try {
            var p = I.localStorage.getItem(i);
            p && (this.eventData = JSON.parse(p));
            var y = I.localStorage.getItem(l);
            y && (this.anonId = y);
          } catch {
            yt("Unable to read from LocalStorage");
          }
      }, It.prototype.saveEventData = function() {
        var r = Pn("localStorage"), i = this.getStorageKey(), l = this.getStorageKey("uuid");
        if (r)
          try {
            I.localStorage.setItem(l, this.anonId), Object.keys(this.eventData).length >= 1 && I.localStorage.setItem(i, JSON.stringify(this.eventData));
          } catch {
            yt("Unable to write to LocalStorage");
          }
      }, It.prototype.processRequests = function(r) {
      }, It.prototype.postEvent = function(r, i, l, p) {
        var y = this;
        if (wr.EVENTS_URL) {
          var v = Je(wr.EVENTS_URL);
          v.params.push("access_token=" + (p || wr.ACCESS_TOKEN || ""));
          var x = { event: this.type, created: new Date(r).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: "1.13.3", skuId: me, userId: this.anonId }, S = i ? Y(x, i) : x, C = { url: lt(v), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([S]) };
          this.pendingRequest = bn(C, function(P) {
            y.pendingRequest = null, l(P), y.saveEventData(), y.processRequests(p);
          });
        }
      }, It.prototype.queueRequest = function(r, i) {
        this.queue.push(r), this.processRequests(i);
      };
      var bt, kt, Ut = function(r) {
        function i() {
          r.call(this, "map.load"), this.success = {}, this.skuToken = "";
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.postMapLoadEvent = function(l, p, y, v) {
          this.skuToken = y;
          var x = !(!v && !wr.ACCESS_TOKEN), S = Array.isArray(l) && l.some(function(C) {
            return qe(C) || et(C);
          });
          wr.EVENTS_URL && x && S && this.queueRequest({ id: p, timestamp: Date.now() }, v);
        }, i.prototype.processRequests = function(l) {
          var p = this;
          if (!this.pendingRequest && this.queue.length !== 0) {
            var y = this.queue.shift(), v = y.id, x = y.timestamp;
            v && this.success[v] || (this.anonId || this.fetchEventData(), Be(this.anonId) || (this.anonId = Ie()), this.postEvent(x, { skuToken: this.skuToken }, function(S) {
              S || v && (p.success[v] = !0);
            }, l));
          }
        }, i;
      }(It), fr = new (function(r) {
        function i(l) {
          r.call(this, "appUserTurnstile"), this._customAccessToken = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.postTurnstileEvent = function(l, p) {
          wr.EVENTS_URL && wr.ACCESS_TOKEN && Array.isArray(l) && l.some(function(y) {
            return qe(y) || et(y);
          }) && this.queueRequest(Date.now(), p);
        }, i.prototype.processRequests = function(l) {
          var p = this;
          if (!this.pendingRequest && this.queue.length !== 0) {
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            var y = Ye(wr.ACCESS_TOKEN), v = y ? y.u : wr.ACCESS_TOKEN, x = v !== this.eventData.tokenU;
            Be(this.anonId) || (this.anonId = Ie(), x = !0);
            var S = this.queue.shift();
            if (this.eventData.lastSuccess) {
              var C = new Date(this.eventData.lastSuccess), P = new Date(S), L = (S - this.eventData.lastSuccess) / 864e5;
              x = x || L >= 1 || L < -1 || C.getDate() !== P.getDate();
            } else
              x = !0;
            if (!x)
              return this.processRequests();
            this.postEvent(S, { "enabled.telemetry": !1 }, function(D) {
              D || (p.eventData.lastSuccess = S, p.eventData.tokenU = v);
            }, l);
          }
        }, i;
      }(It))(), Fr = fr.postTurnstileEvent.bind(fr), Ar = new Ut(), Jr = Ar.postMapLoadEvent.bind(Ar), Xn = 500, Bi = 50;
      function so() {
        I.caches && !bt && (bt = I.caches.open("mapbox-tiles"));
      }
      function Kn(r) {
        var i = r.indexOf("?");
        return i < 0 ? r : r.slice(0, i);
      }
      var ki, Sn = 1 / 0;
      function ai() {
        return ki == null && (ki = I.OffscreenCanvas && new I.OffscreenCanvas(1, 1).getContext("2d") && typeof I.createImageBitmap == "function"), ki;
      }
      var Fa = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
      typeof Object.freeze == "function" && Object.freeze(Fa);
      var Uo = function(r) {
        function i(l, p, y) {
          p === 401 && et(y) && (l += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), r.call(this, l), this.status = p, this.url = y, this.name = this.constructor.name, this.message = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.toString = function() {
          return this.name + ": " + this.message + " (" + this.status + "): " + this.url;
        }, i;
      }(Error), Ba = ct() ? function() {
        return self.worker && self.worker.referrer;
      } : function() {
        return (I.location.protocol === "blob:" ? I.parent : I).location.href;
      }, na, on, So = function(r, i) {
        if (!(/^file:/.test(l = r.url) || /^file:/.test(Ba()) && !/^\w+:/.test(l))) {
          if (I.fetch && I.Request && I.AbortController && I.Request.prototype.hasOwnProperty("signal"))
            return function(p, y) {
              var v, x = new I.AbortController(), S = new I.Request(p.url, { method: p.method || "GET", body: p.body, credentials: p.credentials, headers: p.headers, referrer: Ba(), signal: x.signal }), C = !1, P = !1, L = (v = S.url).indexOf("sku=") > 0 && et(v);
              p.type === "json" && S.headers.set("Accept", "application/json");
              var D = function(j, Q, te) {
                if (!P) {
                  if (j && j.message !== "SecurityError" && yt(j), Q && te)
                    return B(Q);
                  var ue = Date.now();
                  I.fetch(S).then(function(oe) {
                    if (oe.ok) {
                      var ge = L ? oe.clone() : null;
                      return B(oe, ge, ue);
                    }
                    return y(new Uo(oe.statusText, oe.status, p.url));
                  }).catch(function(oe) {
                    oe.code !== 20 && y(new Error(oe.message));
                  });
                }
              }, B = function(j, Q, te) {
                (p.type === "arrayBuffer" ? j.arrayBuffer() : p.type === "json" ? j.json() : j.text()).then(function(ue) {
                  P || (Q && te && function(oe, ge, be) {
                    if (so(), bt) {
                      var Se = { status: ge.status, statusText: ge.statusText, headers: new I.Headers() };
                      ge.headers.forEach(function(Fe, Xe) {
                        return Se.headers.set(Xe, Fe);
                      });
                      var Me = vt(ge.headers.get("Cache-Control") || "");
                      Me["no-store"] || (Me["max-age"] && Se.headers.set("Expires", new Date(be + 1e3 * Me["max-age"]).toUTCString()), new Date(Se.headers.get("Expires")).getTime() - be < 42e4 || function(Fe, Xe) {
                        if (kt === void 0)
                          try {
                            new Response(new ReadableStream()), kt = !0;
                          } catch {
                            kt = !1;
                          }
                        kt ? Xe(Fe.body) : Fe.blob().then(Xe);
                      }(ge, function(Fe) {
                        var Xe = new I.Response(Fe, Se);
                        so(), bt && bt.then(function(nt) {
                          return nt.put(Kn(oe.url), Xe);
                        }).catch(function(nt) {
                          return yt(nt.message);
                        });
                      }));
                    }
                  }(S, Q, te), C = !0, y(null, ue, j.headers.get("Cache-Control"), j.headers.get("Expires")));
                }).catch(function(ue) {
                  P || y(new Error(ue.message));
                });
              };
              return L ? function(j, Q) {
                if (so(), !bt)
                  return Q(null);
                var te = Kn(j.url);
                bt.then(function(ue) {
                  ue.match(te).then(function(oe) {
                    var ge = function(be) {
                      if (!be)
                        return !1;
                      var Se = new Date(be.headers.get("Expires") || 0), Me = vt(be.headers.get("Cache-Control") || "");
                      return Se > Date.now() && !Me["no-cache"];
                    }(oe);
                    ue.delete(te), ge && ue.put(te, oe.clone()), Q(null, oe, ge);
                  }).catch(Q);
                }).catch(Q);
              }(S, D) : D(null, null), { cancel: function() {
                P = !0, C || x.abort();
              } };
            }(r, i);
          if (ct() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", r, i, void 0, !0);
        }
        var l;
        return function(p, y) {
          var v = new I.XMLHttpRequest();
          for (var x in v.open(p.method || "GET", p.url, !0), p.type === "arrayBuffer" && (v.responseType = "arraybuffer"), p.headers)
            v.setRequestHeader(x, p.headers[x]);
          return p.type === "json" && (v.responseType = "text", v.setRequestHeader("Accept", "application/json")), v.withCredentials = p.credentials === "include", v.onerror = function() {
            y(new Error(v.statusText));
          }, v.onload = function() {
            if ((v.status >= 200 && v.status < 300 || v.status === 0) && v.response !== null) {
              var S = v.response;
              if (p.type === "json")
                try {
                  S = JSON.parse(v.response);
                } catch (C) {
                  return y(C);
                }
              y(null, S, v.getResponseHeader("Cache-Control"), v.getResponseHeader("Expires"));
            } else
              y(new Uo(v.statusText, v.status, p.url));
          }, v.send(p.body), { cancel: function() {
            return v.abort();
          } };
        }(r, i);
      }, tl = function(r, i) {
        return So(Y(r, { type: "arrayBuffer" }), i);
      }, bn = function(r, i) {
        return So(Y(r, { method: "POST" }), i);
      }, N = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      na = [], on = 0;
      var F = function(r, i) {
        if (En.supported && (r.headers || (r.headers = {}), r.headers.accept = "image/webp,*/*"), on >= wr.MAX_PARALLEL_IMAGE_REQUESTS) {
          var l = { requestParameters: r, callback: i, cancelled: !1, cancel: function() {
            this.cancelled = !0;
          } };
          return na.push(l), l;
        }
        on++;
        var p = !1, y = function() {
          if (!p)
            for (p = !0, on--; na.length && on < wr.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              var x = na.shift();
              x.cancelled || (x.cancel = F(x.requestParameters, x.callback).cancel);
            }
        }, v = tl(r, function(x, S, C, P) {
          y(), x ? i(x) : S && (ai() ? function(L, D) {
            var B = new I.Blob([new Uint8Array(L)], { type: "image/png" });
            I.createImageBitmap(B).then(function(j) {
              D(null, j);
            }).catch(function(j) {
              D(new Error("Could not load image because of " + j.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            });
          }(S, i) : function(L, D, B, j) {
            var Q = new I.Image(), te = I.URL;
            Q.onload = function() {
              D(null, Q), te.revokeObjectURL(Q.src), Q.onload = null, I.requestAnimationFrame(function() {
                Q.src = N;
              });
            }, Q.onerror = function() {
              return D(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            };
            var ue = new I.Blob([new Uint8Array(L)], { type: "image/png" });
            Q.cacheControl = B, Q.expires = j, Q.src = L.byteLength ? te.createObjectURL(ue) : N;
          }(S, i, C, P));
        });
        return { cancel: function() {
          v.cancel(), y();
        } };
      };
      function U(r, i, l) {
        l[r] && l[r].indexOf(i) !== -1 || (l[r] = l[r] || [], l[r].push(i));
      }
      function H(r, i, l) {
        if (l && l[r]) {
          var p = l[r].indexOf(i);
          p !== -1 && l[r].splice(p, 1);
        }
      }
      var ee = function(r, i) {
        i === void 0 && (i = {}), Y(this, i), this.type = r;
      }, he = function(r) {
        function i(l, p) {
          p === void 0 && (p = {}), r.call(this, "error", Y({ error: l }, p));
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(ee), fe = function() {
      };
      fe.prototype.on = function(r, i) {
        return this._listeners = this._listeners || {}, U(r, i, this._listeners), this;
      }, fe.prototype.off = function(r, i) {
        return H(r, i, this._listeners), H(r, i, this._oneTimeListeners), this;
      }, fe.prototype.once = function(r, i) {
        return this._oneTimeListeners = this._oneTimeListeners || {}, U(r, i, this._oneTimeListeners), this;
      }, fe.prototype.fire = function(r, i) {
        typeof r == "string" && (r = new ee(r, i || {}));
        var l = r.type;
        if (this.listens(l)) {
          r.target = this;
          for (var p = 0, y = this._listeners && this._listeners[l] ? this._listeners[l].slice() : []; p < y.length; p += 1)
            y[p].call(this, r);
          for (var v = 0, x = this._oneTimeListeners && this._oneTimeListeners[l] ? this._oneTimeListeners[l].slice() : []; v < x.length; v += 1) {
            var S = x[v];
            H(l, S, this._oneTimeListeners), S.call(this, r);
          }
          var C = this._eventedParent;
          C && (Y(r, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), C.fire(r));
        } else
          r instanceof he && console.error(r.error);
        return this;
      }, fe.prototype.listens = function(r) {
        return this._listeners && this._listeners[r] && this._listeners[r].length > 0 || this._oneTimeListeners && this._oneTimeListeners[r] && this._oneTimeListeners[r].length > 0 || this._eventedParent && this._eventedParent.listens(r);
      }, fe.prototype.setEventedParent = function(r, i) {
        return this._eventedParent = r, this._eventedParentData = i, this;
      };
      var G = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }, ie = function(r, i, l, p) {
        this.message = (r ? r + ": " : "") + l, p && (this.identifier = p), i != null && i.__line__ && (this.line = i.__line__);
      };
      function ve(r) {
        var i = r.value;
        return i ? [new ie(r.key, i, "constants have been deprecated as of v8")] : [];
      }
      function Ge(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        for (var p = 0, y = i; p < y.length; p += 1) {
          var v = y[p];
          for (var x in v)
            r[x] = v[x];
        }
        return r;
      }
      function He(r) {
        return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
      }
      function Oe(r) {
        if (Array.isArray(r))
          return r.map(Oe);
        if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
          var i = {};
          for (var l in r)
            i[l] = Oe(r[l]);
          return i;
        }
        return He(r);
      }
      var Ve = function(r) {
        function i(l, p) {
          r.call(this, p), this.message = p, this.key = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(Error), Et = function(r, i) {
        i === void 0 && (i = []), this.parent = r, this.bindings = {};
        for (var l = 0, p = i; l < p.length; l += 1) {
          var y = p[l];
          this.bindings[y[0]] = y[1];
        }
      };
      Et.prototype.concat = function(r) {
        return new Et(this, r);
      }, Et.prototype.get = function(r) {
        if (this.bindings[r])
          return this.bindings[r];
        if (this.parent)
          return this.parent.get(r);
        throw new Error(r + " not found in scope.");
      }, Et.prototype.has = function(r) {
        return !!this.bindings[r] || !!this.parent && this.parent.has(r);
      };
      var _t = { kind: "null" }, Pe = { kind: "number" }, ft = { kind: "string" }, ot = { kind: "boolean" }, ke = { kind: "color" }, ce = { kind: "object" }, we = { kind: "value" }, We = { kind: "collator" }, jt = { kind: "formatted" }, Wt = { kind: "resolvedImage" };
      function Jt(r, i) {
        return { kind: "array", itemType: r, N: i };
      }
      function Zt(r) {
        if (r.kind === "array") {
          var i = Zt(r.itemType);
          return typeof r.N == "number" ? "array<" + i + ", " + r.N + ">" : r.itemType.kind === "value" ? "array" : "array<" + i + ">";
        }
        return r.kind;
      }
      var Yn = [_t, Pe, ft, ot, ke, jt, ce, Jt(we), Wt];
      function Qt(r, i) {
        if (i.kind === "error")
          return null;
        if (r.kind === "array") {
          if (i.kind === "array" && (i.N === 0 && i.itemType.kind === "value" || !Qt(r.itemType, i.itemType)) && (typeof r.N != "number" || r.N === i.N))
            return null;
        } else {
          if (r.kind === i.kind)
            return null;
          if (r.kind === "value") {
            for (var l = 0, p = Yn; l < p.length; l += 1)
              if (!Qt(p[l], i))
                return null;
          }
        }
        return "Expected " + Zt(r) + " but found " + Zt(i) + " instead.";
      }
      function pn(r, i) {
        return i.some(function(l) {
          return l.kind === r.kind;
        });
      }
      function Br(r, i) {
        return i.some(function(l) {
          return l === "null" ? r === null : l === "array" ? Array.isArray(r) : l === "object" ? r && !Array.isArray(r) && typeof r == "object" : l === typeof r;
        });
      }
      var yr = m(function(r, i) {
        var l = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function p(S) {
          return (S = Math.round(S)) < 0 ? 0 : S > 255 ? 255 : S;
        }
        function y(S) {
          return p(S[S.length - 1] === "%" ? parseFloat(S) / 100 * 255 : parseInt(S));
        }
        function v(S) {
          return (C = S[S.length - 1] === "%" ? parseFloat(S) / 100 : parseFloat(S)) < 0 ? 0 : C > 1 ? 1 : C;
          var C;
        }
        function x(S, C, P) {
          return P < 0 ? P += 1 : P > 1 && (P -= 1), 6 * P < 1 ? S + (C - S) * P * 6 : 2 * P < 1 ? C : 3 * P < 2 ? S + (C - S) * (2 / 3 - P) * 6 : S;
        }
        try {
          i.parseCSSColor = function(S) {
            var C, P = S.replace(/ /g, "").toLowerCase();
            if (P in l)
              return l[P].slice();
            if (P[0] === "#")
              return P.length === 4 ? (C = parseInt(P.substr(1), 16)) >= 0 && C <= 4095 ? [(3840 & C) >> 4 | (3840 & C) >> 8, 240 & C | (240 & C) >> 4, 15 & C | (15 & C) << 4, 1] : null : P.length === 7 && (C = parseInt(P.substr(1), 16)) >= 0 && C <= 16777215 ? [(16711680 & C) >> 16, (65280 & C) >> 8, 255 & C, 1] : null;
            var L = P.indexOf("("), D = P.indexOf(")");
            if (L !== -1 && D + 1 === P.length) {
              var B = P.substr(0, L), j = P.substr(L + 1, D - (L + 1)).split(","), Q = 1;
              switch (B) {
                case "rgba":
                  if (j.length !== 4)
                    return null;
                  Q = v(j.pop());
                case "rgb":
                  return j.length !== 3 ? null : [y(j[0]), y(j[1]), y(j[2]), Q];
                case "hsla":
                  if (j.length !== 4)
                    return null;
                  Q = v(j.pop());
                case "hsl":
                  if (j.length !== 3)
                    return null;
                  var te = (parseFloat(j[0]) % 360 + 360) % 360 / 360, ue = v(j[1]), oe = v(j[2]), ge = oe <= 0.5 ? oe * (ue + 1) : oe + ue - oe * ue, be = 2 * oe - ge;
                  return [p(255 * x(be, ge, te + 1 / 3)), p(255 * x(be, ge, te)), p(255 * x(be, ge, te - 1 / 3)), Q];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch {
        }
      }).parseCSSColor, Rr = function(r, i, l, p) {
        p === void 0 && (p = 1), this.r = r, this.g = i, this.b = l, this.a = p;
      };
      Rr.parse = function(r) {
        if (r) {
          if (r instanceof Rr)
            return r;
          if (typeof r == "string") {
            var i = yr(r);
            if (i)
              return new Rr(i[0] / 255 * i[3], i[1] / 255 * i[3], i[2] / 255 * i[3], i[3]);
          }
        }
      }, Rr.prototype.toString = function() {
        var r = this.toArray(), i = r[1], l = r[2], p = r[3];
        return "rgba(" + Math.round(r[0]) + "," + Math.round(i) + "," + Math.round(l) + "," + p + ")";
      }, Rr.prototype.toArray = function() {
        var r = this.a;
        return r === 0 ? [0, 0, 0, 0] : [255 * this.r / r, 255 * this.g / r, 255 * this.b / r, r];
      }, Rr.black = new Rr(0, 0, 0, 1), Rr.white = new Rr(1, 1, 1, 1), Rr.transparent = new Rr(0, 0, 0, 0), Rr.red = new Rr(1, 0, 0, 1);
      var Yi = function(r, i, l) {
        this.sensitivity = r ? i ? "variant" : "case" : i ? "accent" : "base", this.locale = l, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
      };
      Yi.prototype.compare = function(r, i) {
        return this.collator.compare(r, i);
      }, Yi.prototype.resolvedLocale = function() {
        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
      };
      var Uu = function(r, i, l, p, y) {
        this.text = r, this.image = i, this.scale = l, this.fontStack = p, this.textColor = y;
      }, di = function(r) {
        this.sections = r;
      };
      di.fromString = function(r) {
        return new di([new Uu(r, null, null, null, null)]);
      }, di.prototype.isEmpty = function() {
        return this.sections.length === 0 || !this.sections.some(function(r) {
          return r.text.length !== 0 || r.image && r.image.name.length !== 0;
        });
      }, di.factory = function(r) {
        return r instanceof di ? r : di.fromString(r);
      }, di.prototype.toString = function() {
        return this.sections.length === 0 ? "" : this.sections.map(function(r) {
          return r.text;
        }).join("");
      }, di.prototype.serialize = function() {
        for (var r = ["format"], i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          if (p.image)
            r.push(["image", p.image.name]);
          else {
            r.push(p.text);
            var y = {};
            p.fontStack && (y["text-font"] = ["literal", p.fontStack.split(",")]), p.scale && (y["font-scale"] = p.scale), p.textColor && (y["text-color"] = ["rgba"].concat(p.textColor.toArray())), r.push(y);
          }
        }
        return r;
      };
      var Ji = function(r) {
        this.name = r.name, this.available = r.available;
      };
      function qf(r, i, l, p) {
        return typeof r == "number" && r >= 0 && r <= 255 && typeof i == "number" && i >= 0 && i <= 255 && typeof l == "number" && l >= 0 && l <= 255 ? p === void 0 || typeof p == "number" && p >= 0 && p <= 1 ? null : "Invalid rgba value [" + [r, i, l, p].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + (typeof p == "number" ? [r, i, l, p] : [r, i, l]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
      }
      function ju(r) {
        if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof Rr || r instanceof Yi || r instanceof di || r instanceof Ji)
          return !0;
        if (Array.isArray(r)) {
          for (var i = 0, l = r; i < l.length; i += 1)
            if (!ju(l[i]))
              return !1;
          return !0;
        }
        if (typeof r == "object") {
          for (var p in r)
            if (!ju(r[p]))
              return !1;
          return !0;
        }
        return !1;
      }
      function kn(r) {
        if (r === null)
          return _t;
        if (typeof r == "string")
          return ft;
        if (typeof r == "boolean")
          return ot;
        if (typeof r == "number")
          return Pe;
        if (r instanceof Rr)
          return ke;
        if (r instanceof Yi)
          return We;
        if (r instanceof di)
          return jt;
        if (r instanceof Ji)
          return Wt;
        if (Array.isArray(r)) {
          for (var i, l = r.length, p = 0, y = r; p < y.length; p += 1) {
            var v = kn(y[p]);
            if (i) {
              if (i === v)
                continue;
              i = we;
              break;
            }
            i = v;
          }
          return Jt(i || we, l);
        }
        return ce;
      }
      function Gu(r) {
        var i = typeof r;
        return r === null ? "" : i === "string" || i === "number" || i === "boolean" ? String(r) : r instanceof Rr || r instanceof di || r instanceof Ji ? r.toString() : JSON.stringify(r);
      }
      Ji.prototype.toString = function() {
        return this.name;
      }, Ji.fromString = function(r) {
        return r ? new Ji({ name: r, available: !1 }) : null;
      }, Ji.prototype.serialize = function() {
        return ["image", this.name];
      };
      var Vi = function(r, i) {
        this.type = r, this.value = i;
      };
      Vi.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("'literal' expression requires exactly one argument, but found " + (r.length - 1) + " instead.");
        if (!ju(r[1]))
          return i.error("invalid value");
        var l = r[1], p = kn(l), y = i.expectedType;
        return p.kind !== "array" || p.N !== 0 || !y || y.kind !== "array" || typeof y.N == "number" && y.N !== 0 || (p = y), new Vi(p, l);
      }, Vi.prototype.evaluate = function() {
        return this.value;
      }, Vi.prototype.eachChild = function() {
      }, Vi.prototype.outputDefined = function() {
        return !0;
      }, Vi.prototype.serialize = function() {
        return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof Rr ? ["rgba"].concat(this.value.toArray()) : this.value instanceof di ? this.value.serialize() : this.value;
      };
      var mi = function(r) {
        this.name = "ExpressionEvaluationError", this.message = r;
      };
      mi.prototype.toJSON = function() {
        return this.message;
      };
      var jo = { string: ft, number: Pe, boolean: ot, object: ce }, dn = function(r, i) {
        this.type = r, this.args = i;
      };
      dn.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l, p = 1, y = r[0];
        if (y === "array") {
          var v, x;
          if (r.length > 2) {
            var S = r[1];
            if (typeof S != "string" || !(S in jo) || S === "object")
              return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
            v = jo[S], p++;
          } else
            v = we;
          if (r.length > 3) {
            if (r[2] !== null && (typeof r[2] != "number" || r[2] < 0 || r[2] !== Math.floor(r[2])))
              return i.error('The length argument to "array" must be a positive integer literal', 2);
            x = r[2], p++;
          }
          l = Jt(v, x);
        } else
          l = jo[y];
        for (var C = []; p < r.length; p++) {
          var P = i.parse(r[p], p, we);
          if (!P)
            return null;
          C.push(P);
        }
        return new dn(l, C);
      }, dn.prototype.evaluate = function(r) {
        for (var i = 0; i < this.args.length; i++) {
          var l = this.args[i].evaluate(r);
          if (!Qt(this.type, kn(l)))
            return l;
          if (i === this.args.length - 1)
            throw new mi("Expected value to be of type " + Zt(this.type) + ", but found " + Zt(kn(l)) + " instead.");
        }
        return null;
      }, dn.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, dn.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, dn.prototype.serialize = function() {
        var r = this.type, i = [r.kind];
        if (r.kind === "array") {
          var l = r.itemType;
          if (l.kind === "string" || l.kind === "number" || l.kind === "boolean") {
            i.push(l.kind);
            var p = r.N;
            (typeof p == "number" || this.args.length > 1) && i.push(p);
          }
        }
        return i.concat(this.args.map(function(y) {
          return y.serialize();
        }));
      };
      var ia = function(r) {
        this.type = jt, this.sections = r;
      };
      ia.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l = r[1];
        if (!Array.isArray(l) && typeof l == "object")
          return i.error("First argument must be an image or text section.");
        for (var p = [], y = !1, v = 1; v <= r.length - 1; ++v) {
          var x = r[v];
          if (y && typeof x == "object" && !Array.isArray(x)) {
            y = !1;
            var S = null;
            if (x["font-scale"] && !(S = i.parse(x["font-scale"], 1, Pe)))
              return null;
            var C = null;
            if (x["text-font"] && !(C = i.parse(x["text-font"], 1, Jt(ft))))
              return null;
            var P = null;
            if (x["text-color"] && !(P = i.parse(x["text-color"], 1, ke)))
              return null;
            var L = p[p.length - 1];
            L.scale = S, L.font = C, L.textColor = P;
          } else {
            var D = i.parse(r[v], 1, we);
            if (!D)
              return null;
            var B = D.type.kind;
            if (B !== "string" && B !== "value" && B !== "null" && B !== "resolvedImage")
              return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
            y = !0, p.push({ content: D, scale: null, font: null, textColor: null });
          }
        }
        return new ia(p);
      }, ia.prototype.evaluate = function(r) {
        return new di(this.sections.map(function(i) {
          var l = i.content.evaluate(r);
          return kn(l) === Wt ? new Uu("", l, null, null, null) : new Uu(Gu(l), null, i.scale ? i.scale.evaluate(r) : null, i.font ? i.font.evaluate(r).join(",") : null, i.textColor ? i.textColor.evaluate(r) : null);
        }));
      }, ia.prototype.eachChild = function(r) {
        for (var i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          r(p.content), p.scale && r(p.scale), p.font && r(p.font), p.textColor && r(p.textColor);
        }
      }, ia.prototype.outputDefined = function() {
        return !1;
      }, ia.prototype.serialize = function() {
        for (var r = ["format"], i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          r.push(p.content.serialize());
          var y = {};
          p.scale && (y["font-scale"] = p.scale.serialize()), p.font && (y["text-font"] = p.font.serialize()), p.textColor && (y["text-color"] = p.textColor.serialize()), r.push(y);
        }
        return r;
      };
      var To = function(r) {
        this.type = Wt, this.input = r;
      };
      To.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected two arguments.");
        var l = i.parse(r[1], 1, ft);
        return l ? new To(l) : i.error("No image name provided.");
      }, To.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r), l = Ji.fromString(i);
        return l && r.availableImages && (l.available = r.availableImages.indexOf(i) > -1), l;
      }, To.prototype.eachChild = function(r) {
        r(this.input);
      }, To.prototype.outputDefined = function() {
        return !1;
      }, To.prototype.serialize = function() {
        return ["image", this.input.serialize()];
      };
      var nm = { "to-boolean": ot, "to-color": ke, "to-number": Pe, "to-string": ft }, Go = function(r, i) {
        this.type = r, this.args = i;
      };
      Go.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l = r[0];
        if ((l === "to-boolean" || l === "to-string") && r.length !== 2)
          return i.error("Expected one argument.");
        for (var p = nm[l], y = [], v = 1; v < r.length; v++) {
          var x = i.parse(r[v], v, we);
          if (!x)
            return null;
          y.push(x);
        }
        return new Go(p, y);
      }, Go.prototype.evaluate = function(r) {
        if (this.type.kind === "boolean")
          return Boolean(this.args[0].evaluate(r));
        if (this.type.kind === "color") {
          for (var i, l, p = 0, y = this.args; p < y.length; p += 1) {
            if (l = null, (i = y[p].evaluate(r)) instanceof Rr)
              return i;
            if (typeof i == "string") {
              var v = r.parseColor(i);
              if (v)
                return v;
            } else if (Array.isArray(i) && !(l = i.length < 3 || i.length > 4 ? "Invalid rbga value " + JSON.stringify(i) + ": expected an array containing either three or four numeric values." : qf(i[0], i[1], i[2], i[3])))
              return new Rr(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
          }
          throw new mi(l || "Could not parse color from value '" + (typeof i == "string" ? i : String(JSON.stringify(i))) + "'");
        }
        if (this.type.kind === "number") {
          for (var x = null, S = 0, C = this.args; S < C.length; S += 1) {
            if ((x = C[S].evaluate(r)) === null)
              return 0;
            var P = Number(x);
            if (!isNaN(P))
              return P;
          }
          throw new mi("Could not convert " + JSON.stringify(x) + " to number.");
        }
        return this.type.kind === "formatted" ? di.fromString(Gu(this.args[0].evaluate(r))) : this.type.kind === "resolvedImage" ? Ji.fromString(Gu(this.args[0].evaluate(r))) : Gu(this.args[0].evaluate(r));
      }, Go.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, Go.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, Go.prototype.serialize = function() {
        if (this.type.kind === "formatted")
          return new ia([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
        if (this.type.kind === "resolvedImage")
          return new To(this.args[0]).serialize();
        var r = ["to-" + this.type.kind];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var Lv = ["Unknown", "Point", "LineString", "Polygon"], Va = function() {
        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
      };
      Va.prototype.id = function() {
        return this.feature && "id" in this.feature ? this.feature.id : null;
      }, Va.prototype.geometryType = function() {
        return this.feature ? typeof this.feature.type == "number" ? Lv[this.feature.type] : this.feature.type : null;
      }, Va.prototype.geometry = function() {
        return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
      }, Va.prototype.canonicalID = function() {
        return this.canonical;
      }, Va.prototype.properties = function() {
        return this.feature && this.feature.properties || {};
      }, Va.prototype.parseColor = function(r) {
        var i = this._parseColorCache[r];
        return i || (i = this._parseColorCache[r] = Rr.parse(r)), i;
      };
      var Ei = function(r, i, l, p) {
        this.name = r, this.type = i, this._evaluate = l, this.args = p;
      };
      Ei.prototype.evaluate = function(r) {
        return this._evaluate(r, this.args);
      }, Ei.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, Ei.prototype.outputDefined = function() {
        return !1;
      }, Ei.prototype.serialize = function() {
        return [this.name].concat(this.args.map(function(r) {
          return r.serialize();
        }));
      }, Ei.parse = function(r, i) {
        var l, p = r[0], y = Ei.definitions[p];
        if (!y)
          return i.error('Unknown expression "' + p + '". If you wanted a literal array, use ["literal", [...]].', 0);
        for (var v = Array.isArray(y) ? y[0] : y.type, x = Array.isArray(y) ? [[y[1], y[2]]] : y.overloads, S = x.filter(function(Nt) {
          var mt = Nt[0];
          return !Array.isArray(mt) || mt.length === r.length - 1;
        }), C = null, P = 0, L = S; P < L.length; P += 1) {
          var D = L[P], B = D[0], j = D[1];
          C = new ms(i.registry, i.path, null, i.scope);
          for (var Q = [], te = !1, ue = 1; ue < r.length; ue++) {
            var oe = r[ue], ge = Array.isArray(B) ? B[ue - 1] : B.type, be = C.parse(oe, 1 + Q.length, ge);
            if (!be) {
              te = !0;
              break;
            }
            Q.push(be);
          }
          if (!te)
            if (Array.isArray(B) && B.length !== Q.length)
              C.error("Expected " + B.length + " arguments, but found " + Q.length + " instead.");
            else {
              for (var Se = 0; Se < Q.length; Se++) {
                var Me = Array.isArray(B) ? B[Se] : B.type, Fe = Q[Se];
                C.concat(Se + 1).checkSubtype(Me, Fe.type);
              }
              if (C.errors.length === 0)
                return new Ei(p, v, j, Q);
            }
        }
        if (S.length === 1)
          (l = i.errors).push.apply(l, C.errors);
        else {
          for (var Xe = (S.length ? S : x).map(function(Nt) {
            var mt;
            return mt = Nt[0], Array.isArray(mt) ? "(" + mt.map(Zt).join(", ") + ")" : "(" + Zt(mt.type) + "...)";
          }).join(" | "), nt = [], At = 1; At < r.length; At++) {
            var pt = i.parse(r[At], 1 + nt.length);
            if (!pt)
              return null;
            nt.push(Zt(pt.type));
          }
          i.error("Expected arguments of type " + Xe + ", but found (" + nt.join(", ") + ") instead.");
        }
        return null;
      }, Ei.register = function(r, i) {
        for (var l in Ei.definitions = i, i)
          r[l] = Ei;
      };
      var _a = function(r, i, l) {
        this.type = We, this.locale = l, this.caseSensitive = r, this.diacriticSensitive = i;
      };
      function Ui(r, i) {
        r[0] = Math.min(r[0], i[0]), r[1] = Math.min(r[1], i[1]), r[2] = Math.max(r[2], i[0]), r[3] = Math.max(r[3], i[1]);
      }
      function rl(r, i) {
        return !(r[0] <= i[0] || r[2] >= i[2] || r[1] <= i[1] || r[3] >= i[3]);
      }
      function Dv(r, i) {
        var l = (180 + r[0]) / 360, p = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r[1] * Math.PI / 360))) / 360, y = Math.pow(2, i.z);
        return [Math.round(l * y * 8192), Math.round(p * y * 8192)];
      }
      function Nv(r, i, l) {
        return i[1] > r[1] != l[1] > r[1] && r[0] < (l[0] - i[0]) * (r[1] - i[1]) / (l[1] - i[1]) + i[0];
      }
      function $f(r, i) {
        for (var l, p, y, v, x, S, C, P = !1, L = 0, D = i.length; L < D; L++)
          for (var B = i[L], j = 0, Q = B.length; j < Q - 1; j++) {
            if ((v = (l = r)[0] - (p = B[j])[0]) * (C = l[1] - (y = B[j + 1])[1]) - (S = l[0] - y[0]) * (x = l[1] - p[1]) == 0 && v * S <= 0 && x * C <= 0)
              return !1;
            Nv(r, B[j], B[j + 1]) && (P = !P);
          }
        return P;
      }
      function Rv(r, i) {
        for (var l = 0; l < i.length; l++)
          if ($f(r, i[l]))
            return !0;
        return !1;
      }
      function im(r, i, l, p) {
        var y = p[0] - l[0], v = p[1] - l[1], x = (r[0] - l[0]) * v - y * (r[1] - l[1]), S = (i[0] - l[0]) * v - y * (i[1] - l[1]);
        return x > 0 && S < 0 || x < 0 && S > 0;
      }
      function zv(r, i, l) {
        for (var p = 0, y = l; p < y.length; p += 1)
          for (var v = y[p], x = 0; x < v.length - 1; ++x)
            if ((D = [(L = v[x + 1])[0] - (P = v[x])[0], L[1] - P[1]])[0] * (B = [(C = i)[0] - (S = r)[0], C[1] - S[1]])[1] - D[1] * B[0] != 0 && im(S, C, P, L) && im(P, L, S, C))
              return !0;
        var S, C, P, L, D, B;
        return !1;
      }
      function om(r, i) {
        for (var l = 0; l < r.length; ++l)
          if (!$f(r[l], i))
            return !1;
        for (var p = 0; p < r.length - 1; ++p)
          if (zv(r[p], r[p + 1], i))
            return !1;
        return !0;
      }
      function am(r, i) {
        for (var l = 0; l < i.length; l++)
          if (om(r, i[l]))
            return !0;
        return !1;
      }
      function $l(r, i, l) {
        for (var p = [], y = 0; y < r.length; y++) {
          for (var v = [], x = 0; x < r[y].length; x++) {
            var S = Dv(r[y][x], l);
            Ui(i, S), v.push(S);
          }
          p.push(v);
        }
        return p;
      }
      function Wf(r, i, l) {
        for (var p = [], y = 0; y < r.length; y++) {
          var v = $l(r[y], i, l);
          p.push(v);
        }
        return p;
      }
      function qu(r, i, l, p) {
        if (r[0] < l[0] || r[0] > l[2]) {
          var y = 0.5 * p, v = r[0] - l[0] > y ? -p : l[0] - r[0] > y ? p : 0;
          v === 0 && (v = r[0] - l[2] > y ? -p : l[2] - r[0] > y ? p : 0), r[0] += v;
        }
        Ui(i, r);
      }
      function sm(r, i, l, p) {
        for (var y = 8192 * Math.pow(2, p.z), v = [8192 * p.x, 8192 * p.y], x = [], S = 0, C = r; S < C.length; S += 1)
          for (var P = 0, L = C[S]; P < L.length; P += 1) {
            var D = L[P], B = [D.x + v[0], D.y + v[1]];
            qu(B, i, l, y), x.push(B);
          }
        return x;
      }
      function nh(r, i, l, p) {
        for (var y, v = 8192 * Math.pow(2, p.z), x = [8192 * p.x, 8192 * p.y], S = [], C = 0, P = r; C < P.length; C += 1) {
          for (var L = [], D = 0, B = P[C]; D < B.length; D += 1) {
            var j = B[D], Q = [j.x + x[0], j.y + x[1]];
            Ui(i, Q), L.push(Q);
          }
          S.push(L);
        }
        if (i[2] - i[0] <= v / 2) {
          (y = i)[0] = y[1] = 1 / 0, y[2] = y[3] = -1 / 0;
          for (var te = 0, ue = S; te < ue.length; te += 1)
            for (var oe = 0, ge = ue[te]; oe < ge.length; oe += 1)
              qu(ge[oe], i, l, v);
        }
        return S;
      }
      _a.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected one argument.");
        var l = r[1];
        if (typeof l != "object" || Array.isArray(l))
          return i.error("Collator options argument must be an object.");
        var p = i.parse(l["case-sensitive"] !== void 0 && l["case-sensitive"], 1, ot);
        if (!p)
          return null;
        var y = i.parse(l["diacritic-sensitive"] !== void 0 && l["diacritic-sensitive"], 1, ot);
        if (!y)
          return null;
        var v = null;
        return l.locale && !(v = i.parse(l.locale, 1, ft)) ? null : new _a(p, y, v);
      }, _a.prototype.evaluate = function(r) {
        return new Yi(this.caseSensitive.evaluate(r), this.diacriticSensitive.evaluate(r), this.locale ? this.locale.evaluate(r) : null);
      }, _a.prototype.eachChild = function(r) {
        r(this.caseSensitive), r(this.diacriticSensitive), this.locale && r(this.locale);
      }, _a.prototype.outputDefined = function() {
        return !1;
      }, _a.prototype.serialize = function() {
        var r = {};
        return r["case-sensitive"] = this.caseSensitive.serialize(), r["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (r.locale = this.locale.serialize()), ["collator", r];
      };
      var qo = function(r, i) {
        this.type = ot, this.geojson = r, this.geometries = i;
      };
      function fs(r) {
        if (r instanceof Ei && (r.name === "get" && r.args.length === 1 || r.name === "feature-state" || r.name === "has" && r.args.length === 1 || r.name === "properties" || r.name === "geometry-type" || r.name === "id" || /^filter-/.test(r.name)) || r instanceof qo)
          return !1;
        var i = !0;
        return r.eachChild(function(l) {
          i && !fs(l) && (i = !1);
        }), i;
      }
      function ps(r) {
        if (r instanceof Ei && r.name === "feature-state")
          return !1;
        var i = !0;
        return r.eachChild(function(l) {
          i && !ps(l) && (i = !1);
        }), i;
      }
      function nl(r, i) {
        if (r instanceof Ei && i.indexOf(r.name) >= 0)
          return !1;
        var l = !0;
        return r.eachChild(function(p) {
          l && !nl(p, i) && (l = !1);
        }), l;
      }
      qo.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("'within' expression requires exactly one argument, but found " + (r.length - 1) + " instead.");
        if (ju(r[1])) {
          var l = r[1];
          if (l.type === "FeatureCollection")
            for (var p = 0; p < l.features.length; ++p) {
              var y = l.features[p].geometry.type;
              if (y === "Polygon" || y === "MultiPolygon")
                return new qo(l, l.features[p].geometry);
            }
          else if (l.type === "Feature") {
            var v = l.geometry.type;
            if (v === "Polygon" || v === "MultiPolygon")
              return new qo(l, l.geometry);
          } else if (l.type === "Polygon" || l.type === "MultiPolygon")
            return new qo(l, l);
        }
        return i.error("'within' expression requires valid geojson object that contains polygon geometry type.");
      }, qo.prototype.evaluate = function(r) {
        if (r.geometry() != null && r.canonicalID() != null) {
          if (r.geometryType() === "Point")
            return function(i, l) {
              var p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = i.canonicalID();
              if (l.type === "Polygon") {
                var x = $l(l.coordinates, y, v), S = sm(i.geometry(), p, y, v);
                if (!rl(p, y))
                  return !1;
                for (var C = 0, P = S; C < P.length; C += 1)
                  if (!$f(P[C], x))
                    return !1;
              }
              if (l.type === "MultiPolygon") {
                var L = Wf(l.coordinates, y, v), D = sm(i.geometry(), p, y, v);
                if (!rl(p, y))
                  return !1;
                for (var B = 0, j = D; B < j.length; B += 1)
                  if (!Rv(j[B], L))
                    return !1;
              }
              return !0;
            }(r, this.geometries);
          if (r.geometryType() === "LineString")
            return function(i, l) {
              var p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = i.canonicalID();
              if (l.type === "Polygon") {
                var x = $l(l.coordinates, y, v), S = nh(i.geometry(), p, y, v);
                if (!rl(p, y))
                  return !1;
                for (var C = 0, P = S; C < P.length; C += 1)
                  if (!om(P[C], x))
                    return !1;
              }
              if (l.type === "MultiPolygon") {
                var L = Wf(l.coordinates, y, v), D = nh(i.geometry(), p, y, v);
                if (!rl(p, y))
                  return !1;
                for (var B = 0, j = D; B < j.length; B += 1)
                  if (!am(j[B], L))
                    return !1;
              }
              return !0;
            }(r, this.geometries);
        }
        return !1;
      }, qo.prototype.eachChild = function() {
      }, qo.prototype.outputDefined = function() {
        return !0;
      }, qo.prototype.serialize = function() {
        return ["within", this.geojson];
      };
      var ds = function(r, i) {
        this.type = i.type, this.name = r, this.boundExpression = i;
      };
      ds.parse = function(r, i) {
        if (r.length !== 2 || typeof r[1] != "string")
          return i.error("'var' expression requires exactly one string literal argument.");
        var l = r[1];
        return i.scope.has(l) ? new ds(l, i.scope.get(l)) : i.error('Unknown variable "' + l + '". Make sure "' + l + '" has been bound in an enclosing "let" expression before using it.', 1);
      }, ds.prototype.evaluate = function(r) {
        return this.boundExpression.evaluate(r);
      }, ds.prototype.eachChild = function() {
      }, ds.prototype.outputDefined = function() {
        return !1;
      }, ds.prototype.serialize = function() {
        return ["var", this.name];
      };
      var ms = function(r, i, l, p, y) {
        i === void 0 && (i = []), p === void 0 && (p = new Et()), y === void 0 && (y = []), this.registry = r, this.path = i, this.key = i.map(function(v) {
          return "[" + v + "]";
        }).join(""), this.scope = p, this.errors = y, this.expectedType = l;
      };
      function ih(r, i) {
        for (var l, p = r.length - 1, y = 0, v = p, x = 0; y <= v; )
          if ((l = r[x = Math.floor((y + v) / 2)]) <= i) {
            if (x === p || i < r[x + 1])
              return x;
            y = x + 1;
          } else {
            if (!(l > i))
              throw new mi("Input is not a number.");
            v = x - 1;
          }
        return 0;
      }
      ms.prototype.parse = function(r, i, l, p, y) {
        return y === void 0 && (y = {}), i ? this.concat(i, l, p)._parse(r, y) : this._parse(r, y);
      }, ms.prototype._parse = function(r, i) {
        function l(P, L, D) {
          return D === "assert" ? new dn(L, [P]) : D === "coerce" ? new Go(L, [P]) : P;
        }
        if (r !== null && typeof r != "string" && typeof r != "boolean" && typeof r != "number" || (r = ["literal", r]), Array.isArray(r)) {
          if (r.length === 0)
            return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
          var p = r[0];
          if (typeof p != "string")
            return this.error("Expression name must be a string, but found " + typeof p + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null;
          var y = this.registry[p];
          if (y) {
            var v = y.parse(r, this);
            if (!v)
              return null;
            if (this.expectedType) {
              var x = this.expectedType, S = v.type;
              if (x.kind !== "string" && x.kind !== "number" && x.kind !== "boolean" && x.kind !== "object" && x.kind !== "array" || S.kind !== "value")
                if (x.kind !== "color" && x.kind !== "formatted" && x.kind !== "resolvedImage" || S.kind !== "value" && S.kind !== "string") {
                  if (this.checkSubtype(x, S))
                    return null;
                } else
                  v = l(v, x, i.typeAnnotation || "coerce");
              else
                v = l(v, x, i.typeAnnotation || "assert");
            }
            if (!(v instanceof Vi) && v.type.kind !== "resolvedImage" && function P(L) {
              if (L instanceof ds)
                return P(L.boundExpression);
              if (L instanceof Ei && L.name === "error" || L instanceof _a || L instanceof qo)
                return !1;
              var D = L instanceof Go || L instanceof dn, B = !0;
              return L.eachChild(function(j) {
                B = D ? B && P(j) : B && j instanceof Vi;
              }), !!B && fs(L) && nl(L, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
            }(v)) {
              var C = new Va();
              try {
                v = new Vi(v.type, v.evaluate(C));
              } catch (P) {
                return this.error(P.message), null;
              }
            }
            return v;
          }
          return this.error('Unknown expression "' + p + '". If you wanted a literal array, use ["literal", [...]].', 0);
        }
        return this.error(r === void 0 ? "'undefined' value invalid. Use null instead." : typeof r == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found " + typeof r + " instead.");
      }, ms.prototype.concat = function(r, i, l) {
        var p = typeof r == "number" ? this.path.concat(r) : this.path, y = l ? this.scope.concat(l) : this.scope;
        return new ms(this.registry, p, i || null, y, this.errors);
      }, ms.prototype.error = function(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        var p = "" + this.key + i.map(function(y) {
          return "[" + y + "]";
        }).join("");
        this.errors.push(new Ve(p, r));
      }, ms.prototype.checkSubtype = function(r, i) {
        var l = Qt(r, i);
        return l && this.error(l), l;
      };
      var lo = function(r, i, l) {
        this.type = r, this.input = i, this.labels = [], this.outputs = [];
        for (var p = 0, y = l; p < y.length; p += 1) {
          var v = y[p], x = v[1];
          this.labels.push(v[0]), this.outputs.push(x);
        }
      };
      function jn(r, i, l) {
        return r * (1 - l) + i * l;
      }
      lo.parse = function(r, i) {
        if (r.length - 1 < 4)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if ((r.length - 1) % 2 != 0)
          return i.error("Expected an even number of arguments.");
        var l = i.parse(r[1], 1, Pe);
        if (!l)
          return null;
        var p = [], y = null;
        i.expectedType && i.expectedType.kind !== "value" && (y = i.expectedType);
        for (var v = 1; v < r.length; v += 2) {
          var x = v === 1 ? -1 / 0 : r[v], S = r[v + 1], C = v, P = v + 1;
          if (typeof x != "number")
            return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', C);
          if (p.length && p[p.length - 1][0] >= x)
            return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', C);
          var L = i.parse(S, P, y);
          if (!L)
            return null;
          y = y || L.type, p.push([x, L]);
        }
        return new lo(y, l, p);
      }, lo.prototype.evaluate = function(r) {
        var i = this.labels, l = this.outputs;
        if (i.length === 1)
          return l[0].evaluate(r);
        var p = this.input.evaluate(r);
        if (p <= i[0])
          return l[0].evaluate(r);
        var y = i.length;
        return p >= i[y - 1] ? l[y - 1].evaluate(r) : l[ih(i, p)].evaluate(r);
      }, lo.prototype.eachChild = function(r) {
        r(this.input);
        for (var i = 0, l = this.outputs; i < l.length; i += 1)
          r(l[i]);
      }, lo.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        });
      }, lo.prototype.serialize = function() {
        for (var r = ["step", this.input.serialize()], i = 0; i < this.labels.length; i++)
          i > 0 && r.push(this.labels[i]), r.push(this.outputs[i].serialize());
        return r;
      };
      var Wl = Object.freeze({ __proto__: null, number: jn, color: function(r, i, l) {
        return new Rr(jn(r.r, i.r, l), jn(r.g, i.g, l), jn(r.b, i.b, l), jn(r.a, i.a, l));
      }, array: function(r, i, l) {
        return r.map(function(p, y) {
          return jn(p, i[y], l);
        });
      } }), lm = 6 / 29 * 3 * (6 / 29), Fv = Math.PI / 180, Bv = 180 / Math.PI;
      function Hf(r) {
        return r > 0.008856451679035631 ? Math.pow(r, 1 / 3) : r / lm + 4 / 29;
      }
      function Zf(r) {
        return r > 6 / 29 ? r * r * r : lm * (r - 4 / 29);
      }
      function Xf(r) {
        return 255 * (r <= 31308e-7 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055);
      }
      function Kf(r) {
        return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      }
      function um(r) {
        var i = Kf(r.r), l = Kf(r.g), p = Kf(r.b), y = Hf((0.4124564 * i + 0.3575761 * l + 0.1804375 * p) / 0.95047), v = Hf((0.2126729 * i + 0.7151522 * l + 0.072175 * p) / 1);
        return { l: 116 * v - 16, a: 500 * (y - v), b: 200 * (v - Hf((0.0193339 * i + 0.119192 * l + 0.9503041 * p) / 1.08883)), alpha: r.a };
      }
      function cm(r) {
        var i = (r.l + 16) / 116, l = isNaN(r.a) ? i : i + r.a / 500, p = isNaN(r.b) ? i : i - r.b / 200;
        return i = 1 * Zf(i), l = 0.95047 * Zf(l), p = 1.08883 * Zf(p), new Rr(Xf(3.2404542 * l - 1.5371385 * i - 0.4985314 * p), Xf(-0.969266 * l + 1.8760108 * i + 0.041556 * p), Xf(0.0556434 * l - 0.2040259 * i + 1.0572252 * p), r.alpha);
      }
      function Vv(r, i, l) {
        var p = i - r;
        return r + l * (p > 180 || p < -180 ? p - 360 * Math.round(p / 360) : p);
      }
      var $u = { forward: um, reverse: cm, interpolate: function(r, i, l) {
        return { l: jn(r.l, i.l, l), a: jn(r.a, i.a, l), b: jn(r.b, i.b, l), alpha: jn(r.alpha, i.alpha, l) };
      } }, Wu = { forward: function(r) {
        var i = um(r), l = i.l, p = i.a, y = i.b, v = Math.atan2(y, p) * Bv;
        return { h: v < 0 ? v + 360 : v, c: Math.sqrt(p * p + y * y), l, alpha: r.a };
      }, reverse: function(r) {
        var i = r.h * Fv, l = r.c;
        return cm({ l: r.l, a: Math.cos(i) * l, b: Math.sin(i) * l, alpha: r.alpha });
      }, interpolate: function(r, i, l) {
        return { h: Vv(r.h, i.h, l), c: jn(r.c, i.c, l), l: jn(r.l, i.l, l), alpha: jn(r.alpha, i.alpha, l) };
      } }, hm = Object.freeze({ __proto__: null, lab: $u, hcl: Wu }), Si = function(r, i, l, p, y) {
        this.type = r, this.operator = i, this.interpolation = l, this.input = p, this.labels = [], this.outputs = [];
        for (var v = 0, x = y; v < x.length; v += 1) {
          var S = x[v], C = S[1];
          this.labels.push(S[0]), this.outputs.push(C);
        }
      };
      function Yf(r, i, l, p) {
        var y = p - l, v = r - l;
        return y === 0 ? 0 : i === 1 ? v / y : (Math.pow(i, v) - 1) / (Math.pow(i, y) - 1);
      }
      Si.interpolationFactor = function(r, i, l, p) {
        var y = 0;
        if (r.name === "exponential")
          y = Yf(i, r.base, l, p);
        else if (r.name === "linear")
          y = Yf(i, 1, l, p);
        else if (r.name === "cubic-bezier") {
          var v = r.controlPoints;
          y = new g(v[0], v[1], v[2], v[3]).solve(Yf(i, 1, l, p));
        }
        return y;
      }, Si.parse = function(r, i) {
        var l = r[0], p = r[1], y = r[2], v = r.slice(3);
        if (!Array.isArray(p) || p.length === 0)
          return i.error("Expected an interpolation type expression.", 1);
        if (p[0] === "linear")
          p = { name: "linear" };
        else if (p[0] === "exponential") {
          var x = p[1];
          if (typeof x != "number")
            return i.error("Exponential interpolation requires a numeric base.", 1, 1);
          p = { name: "exponential", base: x };
        } else {
          if (p[0] !== "cubic-bezier")
            return i.error("Unknown interpolation type " + String(p[0]), 1, 0);
          var S = p.slice(1);
          if (S.length !== 4 || S.some(function(ue) {
            return typeof ue != "number" || ue < 0 || ue > 1;
          }))
            return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
          p = { name: "cubic-bezier", controlPoints: S };
        }
        if (r.length - 1 < 4)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if ((r.length - 1) % 2 != 0)
          return i.error("Expected an even number of arguments.");
        if (!(y = i.parse(y, 2, Pe)))
          return null;
        var C = [], P = null;
        l === "interpolate-hcl" || l === "interpolate-lab" ? P = ke : i.expectedType && i.expectedType.kind !== "value" && (P = i.expectedType);
        for (var L = 0; L < v.length; L += 2) {
          var D = v[L], B = v[L + 1], j = L + 3, Q = L + 4;
          if (typeof D != "number")
            return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', j);
          if (C.length && C[C.length - 1][0] >= D)
            return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', j);
          var te = i.parse(B, Q, P);
          if (!te)
            return null;
          P = P || te.type, C.push([D, te]);
        }
        return P.kind === "number" || P.kind === "color" || P.kind === "array" && P.itemType.kind === "number" && typeof P.N == "number" ? new Si(P, l, p, y, C) : i.error("Type " + Zt(P) + " is not interpolatable.");
      }, Si.prototype.evaluate = function(r) {
        var i = this.labels, l = this.outputs;
        if (i.length === 1)
          return l[0].evaluate(r);
        var p = this.input.evaluate(r);
        if (p <= i[0])
          return l[0].evaluate(r);
        var y = i.length;
        if (p >= i[y - 1])
          return l[y - 1].evaluate(r);
        var v = ih(i, p), x = Si.interpolationFactor(this.interpolation, p, i[v], i[v + 1]), S = l[v].evaluate(r), C = l[v + 1].evaluate(r);
        return this.operator === "interpolate" ? Wl[this.type.kind.toLowerCase()](S, C, x) : this.operator === "interpolate-hcl" ? Wu.reverse(Wu.interpolate(Wu.forward(S), Wu.forward(C), x)) : $u.reverse($u.interpolate($u.forward(S), $u.forward(C), x));
      }, Si.prototype.eachChild = function(r) {
        r(this.input);
        for (var i = 0, l = this.outputs; i < l.length; i += 1)
          r(l[i]);
      }, Si.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        });
      }, Si.prototype.serialize = function() {
        var r;
        r = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
        for (var i = [this.operator, r, this.input.serialize()], l = 0; l < this.labels.length; l++)
          i.push(this.labels[l], this.outputs[l].serialize());
        return i;
      };
      var ys = function(r, i) {
        this.type = r, this.args = i;
      };
      ys.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expectected at least one argument.");
        var l = null, p = i.expectedType;
        p && p.kind !== "value" && (l = p);
        for (var y = [], v = 0, x = r.slice(1); v < x.length; v += 1) {
          var S = i.parse(x[v], 1 + y.length, l, void 0, { typeAnnotation: "omit" });
          if (!S)
            return null;
          l = l || S.type, y.push(S);
        }
        var C = p && y.some(function(P) {
          return Qt(p, P.type);
        });
        return new ys(C ? we : l, y);
      }, ys.prototype.evaluate = function(r) {
        for (var i, l = null, p = 0, y = 0, v = this.args; y < v.length && (p++, (l = v[y].evaluate(r)) && l instanceof Ji && !l.available && (i || (i = l.name), l = null, p === this.args.length && (l = i)), l === null); y += 1)
          ;
        return l;
      }, ys.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, ys.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, ys.prototype.serialize = function() {
        var r = ["coalesce"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var gs = function(r, i) {
        this.type = i.type, this.bindings = [].concat(r), this.result = i;
      };
      gs.prototype.evaluate = function(r) {
        return this.result.evaluate(r);
      }, gs.prototype.eachChild = function(r) {
        for (var i = 0, l = this.bindings; i < l.length; i += 1)
          r(l[i][1]);
        r(this.result);
      }, gs.parse = function(r, i) {
        if (r.length < 4)
          return i.error("Expected at least 3 arguments, but found " + (r.length - 1) + " instead.");
        for (var l = [], p = 1; p < r.length - 1; p += 2) {
          var y = r[p];
          if (typeof y != "string")
            return i.error("Expected string, but found " + typeof y + " instead.", p);
          if (/[^a-zA-Z0-9_]/.test(y))
            return i.error("Variable names must contain only alphanumeric characters or '_'.", p);
          var v = i.parse(r[p + 1], p + 1);
          if (!v)
            return null;
          l.push([y, v]);
        }
        var x = i.parse(r[r.length - 1], r.length - 1, i.expectedType, l);
        return x ? new gs(l, x) : null;
      }, gs.prototype.outputDefined = function() {
        return this.result.outputDefined();
      }, gs.prototype.serialize = function() {
        for (var r = ["let"], i = 0, l = this.bindings; i < l.length; i += 1) {
          var p = l[i];
          r.push(p[0], p[1].serialize());
        }
        return r.push(this.result.serialize()), r;
      };
      var il = function(r, i, l) {
        this.type = r, this.index = i, this.input = l;
      };
      il.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected 2 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Pe), p = i.parse(r[2], 2, Jt(i.expectedType || we));
        return l && p ? new il(p.type.itemType, l, p) : null;
      }, il.prototype.evaluate = function(r) {
        var i = this.index.evaluate(r), l = this.input.evaluate(r);
        if (i < 0)
          throw new mi("Array index out of bounds: " + i + " < 0.");
        if (i >= l.length)
          throw new mi("Array index out of bounds: " + i + " > " + (l.length - 1) + ".");
        if (i !== Math.floor(i))
          throw new mi("Array index must be an integer, but found " + i + " instead.");
        return l[i];
      }, il.prototype.eachChild = function(r) {
        r(this.index), r(this.input);
      }, il.prototype.outputDefined = function() {
        return !1;
      }, il.prototype.serialize = function() {
        return ["at", this.index.serialize(), this.input.serialize()];
      };
      var ol = function(r, i) {
        this.type = ot, this.needle = r, this.haystack = i;
      };
      ol.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected 2 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, we), p = i.parse(r[2], 2, we);
        return l && p ? pn(l.type, [ot, ft, Pe, _t, we]) ? new ol(l, p) : i.error("Expected first argument to be of type boolean, string, number or null, but found " + Zt(l.type) + " instead") : null;
      }, ol.prototype.evaluate = function(r) {
        var i = this.needle.evaluate(r), l = this.haystack.evaluate(r);
        if (!l)
          return !1;
        if (!Br(i, ["boolean", "string", "number", "null"]))
          throw new mi("Expected first argument to be of type boolean, string, number or null, but found " + Zt(kn(i)) + " instead.");
        if (!Br(l, ["string", "array"]))
          throw new mi("Expected second argument to be of type array or string, but found " + Zt(kn(l)) + " instead.");
        return l.indexOf(i) >= 0;
      }, ol.prototype.eachChild = function(r) {
        r(this.needle), r(this.haystack);
      }, ol.prototype.outputDefined = function() {
        return !0;
      }, ol.prototype.serialize = function() {
        return ["in", this.needle.serialize(), this.haystack.serialize()];
      };
      var vs = function(r, i, l) {
        this.type = Pe, this.needle = r, this.haystack = i, this.fromIndex = l;
      };
      vs.parse = function(r, i) {
        if (r.length <= 2 || r.length >= 5)
          return i.error("Expected 3 or 4 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, we), p = i.parse(r[2], 2, we);
        if (!l || !p)
          return null;
        if (!pn(l.type, [ot, ft, Pe, _t, we]))
          return i.error("Expected first argument to be of type boolean, string, number or null, but found " + Zt(l.type) + " instead");
        if (r.length === 4) {
          var y = i.parse(r[3], 3, Pe);
          return y ? new vs(l, p, y) : null;
        }
        return new vs(l, p);
      }, vs.prototype.evaluate = function(r) {
        var i = this.needle.evaluate(r), l = this.haystack.evaluate(r);
        if (!Br(i, ["boolean", "string", "number", "null"]))
          throw new mi("Expected first argument to be of type boolean, string, number or null, but found " + Zt(kn(i)) + " instead.");
        if (!Br(l, ["string", "array"]))
          throw new mi("Expected second argument to be of type array or string, but found " + Zt(kn(l)) + " instead.");
        if (this.fromIndex) {
          var p = this.fromIndex.evaluate(r);
          return l.indexOf(i, p);
        }
        return l.indexOf(i);
      }, vs.prototype.eachChild = function(r) {
        r(this.needle), r(this.haystack), this.fromIndex && r(this.fromIndex);
      }, vs.prototype.outputDefined = function() {
        return !1;
      }, vs.prototype.serialize = function() {
        if (this.fromIndex != null && this.fromIndex !== void 0) {
          var r = this.fromIndex.serialize();
          return ["index-of", this.needle.serialize(), this.haystack.serialize(), r];
        }
        return ["index-of", this.needle.serialize(), this.haystack.serialize()];
      };
      var al = function(r, i, l, p, y, v) {
        this.inputType = r, this.type = i, this.input = l, this.cases = p, this.outputs = y, this.otherwise = v;
      };
      al.parse = function(r, i) {
        if (r.length < 5)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if (r.length % 2 != 1)
          return i.error("Expected an even number of arguments.");
        var l, p;
        i.expectedType && i.expectedType.kind !== "value" && (p = i.expectedType);
        for (var y = {}, v = [], x = 2; x < r.length - 1; x += 2) {
          var S = r[x], C = r[x + 1];
          Array.isArray(S) || (S = [S]);
          var P = i.concat(x);
          if (S.length === 0)
            return P.error("Expected at least one branch label.");
          for (var L = 0, D = S; L < D.length; L += 1) {
            var B = D[L];
            if (typeof B != "number" && typeof B != "string")
              return P.error("Branch labels must be numbers or strings.");
            if (typeof B == "number" && Math.abs(B) > Number.MAX_SAFE_INTEGER)
              return P.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
            if (typeof B == "number" && Math.floor(B) !== B)
              return P.error("Numeric branch labels must be integer values.");
            if (l) {
              if (P.checkSubtype(l, kn(B)))
                return null;
            } else
              l = kn(B);
            if (y[String(B)] !== void 0)
              return P.error("Branch labels must be unique.");
            y[String(B)] = v.length;
          }
          var j = i.parse(C, x, p);
          if (!j)
            return null;
          p = p || j.type, v.push(j);
        }
        var Q = i.parse(r[1], 1, we);
        if (!Q)
          return null;
        var te = i.parse(r[r.length - 1], r.length - 1, p);
        return te ? Q.type.kind !== "value" && i.concat(1).checkSubtype(l, Q.type) ? null : new al(l, p, Q, y, v, te) : null;
      }, al.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r);
        return (kn(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(r);
      }, al.prototype.eachChild = function(r) {
        r(this.input), this.outputs.forEach(r), r(this.otherwise);
      }, al.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        }) && this.otherwise.outputDefined();
      }, al.prototype.serialize = function() {
        for (var r = this, i = ["match", this.input.serialize()], l = [], p = {}, y = 0, v = Object.keys(this.cases).sort(); y < v.length; y += 1) {
          var x = v[y];
          (D = p[this.cases[x]]) === void 0 ? (p[this.cases[x]] = l.length, l.push([this.cases[x], [x]])) : l[D][1].push(x);
        }
        for (var S = function(j) {
          return r.inputType.kind === "number" ? Number(j) : j;
        }, C = 0, P = l; C < P.length; C += 1) {
          var L = P[C], D = L[0], B = L[1];
          i.push(B.length === 1 ? S(B[0]) : B.map(S)), i.push(this.outputs[outputIndex$1].serialize());
        }
        return i.push(this.otherwise.serialize()), i;
      };
      var sl = function(r, i, l) {
        this.type = r, this.branches = i, this.otherwise = l;
      };
      sl.parse = function(r, i) {
        if (r.length < 4)
          return i.error("Expected at least 3 arguments, but found only " + (r.length - 1) + ".");
        if (r.length % 2 != 0)
          return i.error("Expected an odd number of arguments.");
        var l;
        i.expectedType && i.expectedType.kind !== "value" && (l = i.expectedType);
        for (var p = [], y = 1; y < r.length - 1; y += 2) {
          var v = i.parse(r[y], y, ot);
          if (!v)
            return null;
          var x = i.parse(r[y + 1], y + 1, l);
          if (!x)
            return null;
          p.push([v, x]), l = l || x.type;
        }
        var S = i.parse(r[r.length - 1], r.length - 1, l);
        return S ? new sl(l, p, S) : null;
      }, sl.prototype.evaluate = function(r) {
        for (var i = 0, l = this.branches; i < l.length; i += 1) {
          var p = l[i], y = p[1];
          if (p[0].evaluate(r))
            return y.evaluate(r);
        }
        return this.otherwise.evaluate(r);
      }, sl.prototype.eachChild = function(r) {
        for (var i = 0, l = this.branches; i < l.length; i += 1) {
          var p = l[i], y = p[1];
          r(p[0]), r(y);
        }
        r(this.otherwise);
      }, sl.prototype.outputDefined = function() {
        return this.branches.every(function(r) {
          return r[1].outputDefined();
        }) && this.otherwise.outputDefined();
      }, sl.prototype.serialize = function() {
        var r = ["case"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var _s = function(r, i, l, p) {
        this.type = r, this.input = i, this.beginIndex = l, this.endIndex = p;
      };
      function fm(r, i) {
        return r === "==" || r === "!=" ? i.kind === "boolean" || i.kind === "string" || i.kind === "number" || i.kind === "null" || i.kind === "value" : i.kind === "string" || i.kind === "number" || i.kind === "value";
      }
      function pm(r, i, l, p) {
        return p.compare(i, l) === 0;
      }
      function Zr(r, i, l) {
        var p = r !== "==" && r !== "!=";
        return function() {
          function y(v, x, S) {
            this.type = ot, this.lhs = v, this.rhs = x, this.collator = S, this.hasUntypedArgument = v.type.kind === "value" || x.type.kind === "value";
          }
          return y.parse = function(v, x) {
            if (v.length !== 3 && v.length !== 4)
              return x.error("Expected two or three arguments.");
            var S = v[0], C = x.parse(v[1], 1, we);
            if (!C)
              return null;
            if (!fm(S, C.type))
              return x.concat(1).error('"' + S + `" comparisons are not supported for type '` + Zt(C.type) + "'.");
            var P = x.parse(v[2], 2, we);
            if (!P)
              return null;
            if (!fm(S, P.type))
              return x.concat(2).error('"' + S + `" comparisons are not supported for type '` + Zt(P.type) + "'.");
            if (C.type.kind !== P.type.kind && C.type.kind !== "value" && P.type.kind !== "value")
              return x.error("Cannot compare types '" + Zt(C.type) + "' and '" + Zt(P.type) + "'.");
            p && (C.type.kind === "value" && P.type.kind !== "value" ? C = new dn(P.type, [C]) : C.type.kind !== "value" && P.type.kind === "value" && (P = new dn(C.type, [P])));
            var L = null;
            if (v.length === 4) {
              if (C.type.kind !== "string" && P.type.kind !== "string" && C.type.kind !== "value" && P.type.kind !== "value")
                return x.error("Cannot use collator to compare non-string types.");
              if (!(L = x.parse(v[3], 3, We)))
                return null;
            }
            return new y(C, P, L);
          }, y.prototype.evaluate = function(v) {
            var x = this.lhs.evaluate(v), S = this.rhs.evaluate(v);
            if (p && this.hasUntypedArgument) {
              var C = kn(x), P = kn(S);
              if (C.kind !== P.kind || C.kind !== "string" && C.kind !== "number")
                throw new mi('Expected arguments for "' + r + '" to be (string, string) or (number, number), but found (' + C.kind + ", " + P.kind + ") instead.");
            }
            if (this.collator && !p && this.hasUntypedArgument) {
              var L = kn(x), D = kn(S);
              if (L.kind !== "string" || D.kind !== "string")
                return i(v, x, S);
            }
            return this.collator ? l(v, x, S, this.collator.evaluate(v)) : i(v, x, S);
          }, y.prototype.eachChild = function(v) {
            v(this.lhs), v(this.rhs), this.collator && v(this.collator);
          }, y.prototype.outputDefined = function() {
            return !0;
          }, y.prototype.serialize = function() {
            var v = [r];
            return this.eachChild(function(x) {
              v.push(x.serialize());
            }), v;
          }, y;
        }();
      }
      _s.parse = function(r, i) {
        if (r.length <= 2 || r.length >= 5)
          return i.error("Expected 3 or 4 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, we), p = i.parse(r[2], 2, Pe);
        if (!l || !p)
          return null;
        if (!pn(l.type, [Jt(we), ft, we]))
          return i.error("Expected first argument to be of type array or string, but found " + Zt(l.type) + " instead");
        if (r.length === 4) {
          var y = i.parse(r[3], 3, Pe);
          return y ? new _s(l.type, l, p, y) : null;
        }
        return new _s(l.type, l, p);
      }, _s.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r), l = this.beginIndex.evaluate(r);
        if (!Br(i, ["string", "array"]))
          throw new mi("Expected first argument to be of type array or string, but found " + Zt(kn(i)) + " instead.");
        if (this.endIndex) {
          var p = this.endIndex.evaluate(r);
          return i.slice(l, p);
        }
        return i.slice(l);
      }, _s.prototype.eachChild = function(r) {
        r(this.input), r(this.beginIndex), this.endIndex && r(this.endIndex);
      }, _s.prototype.outputDefined = function() {
        return !1;
      }, _s.prototype.serialize = function() {
        if (this.endIndex != null && this.endIndex !== void 0) {
          var r = this.endIndex.serialize();
          return ["slice", this.input.serialize(), this.beginIndex.serialize(), r];
        }
        return ["slice", this.input.serialize(), this.beginIndex.serialize()];
      };
      var Uv = Zr("==", function(r, i, l) {
        return i === l;
      }, pm), oh = Zr("!=", function(r, i, l) {
        return i !== l;
      }, function(r, i, l, p) {
        return !pm(0, i, l, p);
      }), dm = Zr("<", function(r, i, l) {
        return i < l;
      }, function(r, i, l, p) {
        return p.compare(i, l) < 0;
      }), mm = Zr(">", function(r, i, l) {
        return i > l;
      }, function(r, i, l, p) {
        return p.compare(i, l) > 0;
      }), ym = Zr("<=", function(r, i, l) {
        return i <= l;
      }, function(r, i, l, p) {
        return p.compare(i, l) <= 0;
      }), gm = Zr(">=", function(r, i, l) {
        return i >= l;
      }, function(r, i, l, p) {
        return p.compare(i, l) >= 0;
      }), ll = function(r, i, l, p, y) {
        this.type = ft, this.number = r, this.locale = i, this.currency = l, this.minFractionDigits = p, this.maxFractionDigits = y;
      };
      ll.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected two arguments.");
        var l = i.parse(r[1], 1, Pe);
        if (!l)
          return null;
        var p = r[2];
        if (typeof p != "object" || Array.isArray(p))
          return i.error("NumberFormat options argument must be an object.");
        var y = null;
        if (p.locale && !(y = i.parse(p.locale, 1, ft)))
          return null;
        var v = null;
        if (p.currency && !(v = i.parse(p.currency, 1, ft)))
          return null;
        var x = null;
        if (p["min-fraction-digits"] && !(x = i.parse(p["min-fraction-digits"], 1, Pe)))
          return null;
        var S = null;
        return p["max-fraction-digits"] && !(S = i.parse(p["max-fraction-digits"], 1, Pe)) ? null : new ll(l, y, v, x, S);
      }, ll.prototype.evaluate = function(r) {
        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(r) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(r) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(r) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(r) : void 0 }).format(this.number.evaluate(r));
      }, ll.prototype.eachChild = function(r) {
        r(this.number), this.locale && r(this.locale), this.currency && r(this.currency), this.minFractionDigits && r(this.minFractionDigits), this.maxFractionDigits && r(this.maxFractionDigits);
      }, ll.prototype.outputDefined = function() {
        return !1;
      }, ll.prototype.serialize = function() {
        var r = {};
        return this.locale && (r.locale = this.locale.serialize()), this.currency && (r.currency = this.currency.serialize()), this.minFractionDigits && (r["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (r["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), r];
      };
      var xs = function(r) {
        this.type = Pe, this.input = r;
      };
      xs.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected 1 argument, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1);
        return l ? l.type.kind !== "array" && l.type.kind !== "string" && l.type.kind !== "value" ? i.error("Expected argument of type string or array, but found " + Zt(l.type) + " instead.") : new xs(l) : null;
      }, xs.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r);
        if (typeof i == "string" || Array.isArray(i))
          return i.length;
        throw new mi("Expected value to be of type string or array, but found " + Zt(kn(i)) + " instead.");
      }, xs.prototype.eachChild = function(r) {
        r(this.input);
      }, xs.prototype.outputDefined = function() {
        return !1;
      }, xs.prototype.serialize = function() {
        var r = ["length"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var ul = { "==": Uv, "!=": oh, ">": mm, "<": dm, ">=": gm, "<=": ym, array: dn, at: il, boolean: dn, case: sl, coalesce: ys, collator: _a, format: ia, image: To, in: ol, "index-of": vs, interpolate: Si, "interpolate-hcl": Si, "interpolate-lab": Si, length: xs, let: gs, literal: Vi, match: al, number: dn, "number-format": ll, object: dn, slice: _s, step: lo, string: dn, "to-boolean": Go, "to-color": Go, "to-number": Go, "to-string": Go, var: ds, within: qo };
      function vm(r, i) {
        var l = i[0], p = i[1], y = i[2], v = i[3];
        l = l.evaluate(r), p = p.evaluate(r), y = y.evaluate(r);
        var x = v ? v.evaluate(r) : 1, S = qf(l, p, y, x);
        if (S)
          throw new mi(S);
        return new Rr(l / 255 * x, p / 255 * x, y / 255 * x, x);
      }
      function _m(r, i) {
        return r in i;
      }
      function Jf(r, i) {
        var l = i[r];
        return l === void 0 ? null : l;
      }
      function cl(r) {
        return { type: r };
      }
      function xm(r) {
        return { result: "success", value: r };
      }
      function hl(r) {
        return { result: "error", value: r };
      }
      function fl(r) {
        return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven";
      }
      function bm(r) {
        return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
      }
      function Hu(r) {
        return !!r.expression && r.expression.interpolated;
      }
      function Qr(r) {
        return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
      }
      function ah(r) {
        return typeof r == "object" && r !== null && !Array.isArray(r);
      }
      function jv(r) {
        return r;
      }
      function Hl(r, i, l) {
        return r !== void 0 ? r : i !== void 0 ? i : l !== void 0 ? l : void 0;
      }
      function wm(r, i, l, p, y) {
        return Hl(typeof l === y ? p[l] : void 0, r.default, i.default);
      }
      function Gv(r, i, l) {
        if (Qr(l) !== "number")
          return Hl(r.default, i.default);
        var p = r.stops.length;
        if (p === 1 || l <= r.stops[0][0])
          return r.stops[0][1];
        if (l >= r.stops[p - 1][0])
          return r.stops[p - 1][1];
        var y = ih(r.stops.map(function(v) {
          return v[0];
        }), l);
        return r.stops[y][1];
      }
      function Em(r, i, l) {
        var p = r.base !== void 0 ? r.base : 1;
        if (Qr(l) !== "number")
          return Hl(r.default, i.default);
        var y = r.stops.length;
        if (y === 1 || l <= r.stops[0][0])
          return r.stops[0][1];
        if (l >= r.stops[y - 1][0])
          return r.stops[y - 1][1];
        var v = ih(r.stops.map(function(D) {
          return D[0];
        }), l), x = function(D, B, j, Q) {
          var te = Q - j, ue = D - j;
          return te === 0 ? 0 : B === 1 ? ue / te : (Math.pow(B, ue) - 1) / (Math.pow(B, te) - 1);
        }(l, p, r.stops[v][0], r.stops[v + 1][0]), S = r.stops[v][1], C = r.stops[v + 1][1], P = Wl[i.type] || jv;
        if (r.colorSpace && r.colorSpace !== "rgb") {
          var L = hm[r.colorSpace];
          P = function(D, B) {
            return L.reverse(L.interpolate(L.forward(D), L.forward(B), x));
          };
        }
        return typeof S.evaluate == "function" ? { evaluate: function() {
          for (var D = [], B = arguments.length; B--; )
            D[B] = arguments[B];
          var j = S.evaluate.apply(void 0, D), Q = C.evaluate.apply(void 0, D);
          if (j !== void 0 && Q !== void 0)
            return P(j, Q, x);
        } } : P(S, C, x);
      }
      function sh(r, i, l) {
        return i.type === "color" ? l = Rr.parse(l) : i.type === "formatted" ? l = di.fromString(l.toString()) : i.type === "resolvedImage" ? l = Ji.fromString(l.toString()) : Qr(l) === i.type || i.type === "enum" && i.values[l] || (l = void 0), Hl(l, r.default, i.default);
      }
      Ei.register(ul, { error: [{ kind: "error" }, [ft], function(r, i) {
        throw new mi(i[0].evaluate(r));
      }], typeof: [ft, [we], function(r, i) {
        return Zt(kn(i[0].evaluate(r)));
      }], "to-rgba": [Jt(Pe, 4), [ke], function(r, i) {
        return i[0].evaluate(r).toArray();
      }], rgb: [ke, [Pe, Pe, Pe], vm], rgba: [ke, [Pe, Pe, Pe, Pe], vm], has: { type: ot, overloads: [[[ft], function(r, i) {
        return _m(i[0].evaluate(r), r.properties());
      }], [[ft, ce], function(r, i) {
        var l = i[1];
        return _m(i[0].evaluate(r), l.evaluate(r));
      }]] }, get: { type: we, overloads: [[[ft], function(r, i) {
        return Jf(i[0].evaluate(r), r.properties());
      }], [[ft, ce], function(r, i) {
        var l = i[1];
        return Jf(i[0].evaluate(r), l.evaluate(r));
      }]] }, "feature-state": [we, [ft], function(r, i) {
        return Jf(i[0].evaluate(r), r.featureState || {});
      }], properties: [ce, [], function(r) {
        return r.properties();
      }], "geometry-type": [ft, [], function(r) {
        return r.geometryType();
      }], id: [we, [], function(r) {
        return r.id();
      }], zoom: [Pe, [], function(r) {
        return r.globals.zoom;
      }], "heatmap-density": [Pe, [], function(r) {
        return r.globals.heatmapDensity || 0;
      }], "line-progress": [Pe, [], function(r) {
        return r.globals.lineProgress || 0;
      }], accumulated: [we, [], function(r) {
        return r.globals.accumulated === void 0 ? null : r.globals.accumulated;
      }], "+": [Pe, cl(Pe), function(r, i) {
        for (var l = 0, p = 0, y = i; p < y.length; p += 1)
          l += y[p].evaluate(r);
        return l;
      }], "*": [Pe, cl(Pe), function(r, i) {
        for (var l = 1, p = 0, y = i; p < y.length; p += 1)
          l *= y[p].evaluate(r);
        return l;
      }], "-": { type: Pe, overloads: [[[Pe, Pe], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) - l.evaluate(r);
      }], [[Pe], function(r, i) {
        return -i[0].evaluate(r);
      }]] }, "/": [Pe, [Pe, Pe], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) / l.evaluate(r);
      }], "%": [Pe, [Pe, Pe], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) % l.evaluate(r);
      }], ln2: [Pe, [], function() {
        return Math.LN2;
      }], pi: [Pe, [], function() {
        return Math.PI;
      }], e: [Pe, [], function() {
        return Math.E;
      }], "^": [Pe, [Pe, Pe], function(r, i) {
        var l = i[1];
        return Math.pow(i[0].evaluate(r), l.evaluate(r));
      }], sqrt: [Pe, [Pe], function(r, i) {
        return Math.sqrt(i[0].evaluate(r));
      }], log10: [Pe, [Pe], function(r, i) {
        return Math.log(i[0].evaluate(r)) / Math.LN10;
      }], ln: [Pe, [Pe], function(r, i) {
        return Math.log(i[0].evaluate(r));
      }], log2: [Pe, [Pe], function(r, i) {
        return Math.log(i[0].evaluate(r)) / Math.LN2;
      }], sin: [Pe, [Pe], function(r, i) {
        return Math.sin(i[0].evaluate(r));
      }], cos: [Pe, [Pe], function(r, i) {
        return Math.cos(i[0].evaluate(r));
      }], tan: [Pe, [Pe], function(r, i) {
        return Math.tan(i[0].evaluate(r));
      }], asin: [Pe, [Pe], function(r, i) {
        return Math.asin(i[0].evaluate(r));
      }], acos: [Pe, [Pe], function(r, i) {
        return Math.acos(i[0].evaluate(r));
      }], atan: [Pe, [Pe], function(r, i) {
        return Math.atan(i[0].evaluate(r));
      }], min: [Pe, cl(Pe), function(r, i) {
        return Math.min.apply(Math, i.map(function(l) {
          return l.evaluate(r);
        }));
      }], max: [Pe, cl(Pe), function(r, i) {
        return Math.max.apply(Math, i.map(function(l) {
          return l.evaluate(r);
        }));
      }], abs: [Pe, [Pe], function(r, i) {
        return Math.abs(i[0].evaluate(r));
      }], round: [Pe, [Pe], function(r, i) {
        var l = i[0].evaluate(r);
        return l < 0 ? -Math.round(-l) : Math.round(l);
      }], floor: [Pe, [Pe], function(r, i) {
        return Math.floor(i[0].evaluate(r));
      }], ceil: [Pe, [Pe], function(r, i) {
        return Math.ceil(i[0].evaluate(r));
      }], "filter-==": [ot, [ft, we], function(r, i) {
        var l = i[0], p = i[1];
        return r.properties()[l.value] === p.value;
      }], "filter-id-==": [ot, [we], function(r, i) {
        var l = i[0];
        return r.id() === l.value;
      }], "filter-type-==": [ot, [ft], function(r, i) {
        var l = i[0];
        return r.geometryType() === l.value;
      }], "filter-<": [ot, [ft, we], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y < v;
      }], "filter-id-<": [ot, [we], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p < y;
      }], "filter->": [ot, [ft, we], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y > v;
      }], "filter-id->": [ot, [we], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p > y;
      }], "filter-<=": [ot, [ft, we], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y <= v;
      }], "filter-id-<=": [ot, [we], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p <= y;
      }], "filter->=": [ot, [ft, we], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y >= v;
      }], "filter-id->=": [ot, [we], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p >= y;
      }], "filter-has": [ot, [we], function(r, i) {
        return i[0].value in r.properties();
      }], "filter-has-id": [ot, [], function(r) {
        return r.id() !== null && r.id() !== void 0;
      }], "filter-type-in": [ot, [Jt(ft)], function(r, i) {
        return i[0].value.indexOf(r.geometryType()) >= 0;
      }], "filter-id-in": [ot, [Jt(we)], function(r, i) {
        return i[0].value.indexOf(r.id()) >= 0;
      }], "filter-in-small": [ot, [ft, Jt(we)], function(r, i) {
        var l = i[0];
        return i[1].value.indexOf(r.properties()[l.value]) >= 0;
      }], "filter-in-large": [ot, [ft, Jt(we)], function(r, i) {
        var l = i[0], p = i[1];
        return function(y, v, x, S) {
          for (; x <= S; ) {
            var C = x + S >> 1;
            if (v[C] === y)
              return !0;
            v[C] > y ? S = C - 1 : x = C + 1;
          }
          return !1;
        }(r.properties()[l.value], p.value, 0, p.value.length - 1);
      }], all: { type: ot, overloads: [[[ot, ot], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) && l.evaluate(r);
      }], [cl(ot), function(r, i) {
        for (var l = 0, p = i; l < p.length; l += 1)
          if (!p[l].evaluate(r))
            return !1;
        return !0;
      }]] }, any: { type: ot, overloads: [[[ot, ot], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) || l.evaluate(r);
      }], [cl(ot), function(r, i) {
        for (var l = 0, p = i; l < p.length; l += 1)
          if (p[l].evaluate(r))
            return !0;
        return !1;
      }]] }, "!": [ot, [ot], function(r, i) {
        return !i[0].evaluate(r);
      }], "is-supported-script": [ot, [ft], function(r, i) {
        var l = r.globals && r.globals.isSupportedScript;
        return !l || l(i[0].evaluate(r));
      }], upcase: [ft, [ft], function(r, i) {
        return i[0].evaluate(r).toUpperCase();
      }], downcase: [ft, [ft], function(r, i) {
        return i[0].evaluate(r).toLowerCase();
      }], concat: [ft, cl(we), function(r, i) {
        return i.map(function(l) {
          return Gu(l.evaluate(r));
        }).join("");
      }], "resolved-locale": [ft, [We], function(r, i) {
        return i[0].evaluate(r).resolvedLocale();
      }] });
      var Zl = function(r, i) {
        this.expression = r, this._warningHistory = {}, this._evaluator = new Va(), this._defaultValue = i ? function(l) {
          return l.type === "color" && ah(l.default) ? new Rr(0, 0, 0, 0) : l.type === "color" ? Rr.parse(l.default) || null : l.default === void 0 ? null : l.default;
        }(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null;
      };
      function Zu(r) {
        return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in ul;
      }
      function lh(r, i) {
        var l = new ms(ul, [], i ? function(y) {
          var v = { color: ke, string: ft, number: Pe, enum: ft, boolean: ot, formatted: jt, resolvedImage: Wt };
          return y.type === "array" ? Jt(v[y.value] || we, y.length) : v[y.type];
        }(i) : void 0), p = l.parse(r, void 0, void 0, void 0, i && i.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return p ? xm(new Zl(p, i)) : hl(l.errors);
      }
      Zl.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._evaluator.globals = r, this._evaluator.feature = i, this._evaluator.featureState = l, this._evaluator.canonical = p, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = v, this.expression.evaluate(this._evaluator);
      }, Zl.prototype.evaluate = function(r, i, l, p, y, v) {
        this._evaluator.globals = r, this._evaluator.feature = i || null, this._evaluator.featureState = l || null, this._evaluator.canonical = p, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = v || null;
        try {
          var x = this.expression.evaluate(this._evaluator);
          if (x == null || typeof x == "number" && x != x)
            return this._defaultValue;
          if (this._enumValues && !(x in this._enumValues))
            throw new mi("Expected value to be one of " + Object.keys(this._enumValues).map(function(S) {
              return JSON.stringify(S);
            }).join(", ") + ", but found " + JSON.stringify(x) + " instead.");
          return x;
        } catch (S) {
          return this._warningHistory[S.message] || (this._warningHistory[S.message] = !0, typeof console < "u" && console.warn(S.message)), this._defaultValue;
        }
      };
      var Xu = function(r, i) {
        this.kind = r, this._styleExpression = i, this.isStateDependent = r !== "constant" && !ps(i.expression);
      };
      Xu.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluateWithoutErrorHandling(r, i, l, p, y, v);
      }, Xu.prototype.evaluate = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluate(r, i, l, p, y, v);
      };
      var Xl = function(r, i, l, p) {
        this.kind = r, this.zoomStops = l, this._styleExpression = i, this.isStateDependent = r !== "camera" && !ps(i.expression), this.interpolationType = p;
      };
      function Sm(r, i) {
        if ((r = lh(r, i)).result === "error")
          return r;
        var l = r.value.expression, p = fs(l);
        if (!p && !fl(i))
          return hl([new Ve("", "data expressions not supported")]);
        var y = nl(l, ["zoom"]);
        if (!y && !bm(i))
          return hl([new Ve("", "zoom expressions not supported")]);
        var v = function x(S) {
          var C = null;
          if (S instanceof gs)
            C = x(S.result);
          else if (S instanceof ys)
            for (var P = 0, L = S.args; P < L.length && !(C = x(L[P])); P += 1)
              ;
          else
            (S instanceof lo || S instanceof Si) && S.input instanceof Ei && S.input.name === "zoom" && (C = S);
          return C instanceof Ve || S.eachChild(function(D) {
            var B = x(D);
            B instanceof Ve ? C = B : !C && B ? C = new Ve("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : C && B && C !== B && (C = new Ve("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), C;
        }(l);
        return v || y ? v instanceof Ve ? hl([v]) : v instanceof Si && !Hu(i) ? hl([new Ve("", '"interpolate" expressions cannot be used with this property')]) : xm(v ? new Xl(p ? "camera" : "composite", r.value, v.labels, v instanceof Si ? v.interpolation : void 0) : new Xu(p ? "constant" : "source", r.value)) : hl([new Ve("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      Xl.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluateWithoutErrorHandling(r, i, l, p, y, v);
      }, Xl.prototype.evaluate = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluate(r, i, l, p, y, v);
      }, Xl.prototype.interpolationFactor = function(r, i, l) {
        return this.interpolationType ? Si.interpolationFactor(this.interpolationType, r, i, l) : 0;
      };
      var Kl = function(r, i) {
        this._parameters = r, this._specification = i, Ge(this, function l(p, y) {
          var v, x, S, C = y.type === "color", P = p.stops && typeof p.stops[0][0] == "object", L = P || !(P || p.property !== void 0), D = p.type || (Hu(y) ? "exponential" : "interval");
          if (C && ((p = Ge({}, p)).stops && (p.stops = p.stops.map(function(pt) {
            return [pt[0], Rr.parse(pt[1])];
          })), p.default = Rr.parse(p.default ? p.default : y.default)), p.colorSpace && p.colorSpace !== "rgb" && !hm[p.colorSpace])
            throw new Error("Unknown color space: " + p.colorSpace);
          if (D === "exponential")
            v = Em;
          else if (D === "interval")
            v = Gv;
          else if (D === "categorical") {
            v = wm, x = /* @__PURE__ */ Object.create(null);
            for (var B = 0, j = p.stops; B < j.length; B += 1) {
              var Q = j[B];
              x[Q[0]] = Q[1];
            }
            S = typeof p.stops[0][0];
          } else {
            if (D !== "identity")
              throw new Error('Unknown function type "' + D + '"');
            v = sh;
          }
          if (P) {
            for (var te = {}, ue = [], oe = 0; oe < p.stops.length; oe++) {
              var ge = p.stops[oe], be = ge[0].zoom;
              te[be] === void 0 && (te[be] = { zoom: be, type: p.type, property: p.property, default: p.default, stops: [] }, ue.push(be)), te[be].stops.push([ge[0].value, ge[1]]);
            }
            for (var Se = [], Me = 0, Fe = ue; Me < Fe.length; Me += 1) {
              var Xe = Fe[Me];
              Se.push([te[Xe].zoom, l(te[Xe], y)]);
            }
            var nt = { name: "linear" };
            return { kind: "composite", interpolationType: nt, interpolationFactor: Si.interpolationFactor.bind(void 0, nt), zoomStops: Se.map(function(pt) {
              return pt[0];
            }), evaluate: function(pt, Nt) {
              var mt = pt.zoom;
              return Em({ stops: Se, base: p.base }, y, mt).evaluate(mt, Nt);
            } };
          }
          if (L) {
            var At = D === "exponential" ? { name: "exponential", base: p.base !== void 0 ? p.base : 1 } : null;
            return { kind: "camera", interpolationType: At, interpolationFactor: Si.interpolationFactor.bind(void 0, At), zoomStops: p.stops.map(function(pt) {
              return pt[0];
            }), evaluate: function(pt) {
              return v(p, y, pt.zoom, x, S);
            } };
          }
          return { kind: "source", evaluate: function(pt, Nt) {
            var mt = Nt && Nt.properties ? Nt.properties[p.property] : void 0;
            return mt === void 0 ? Hl(p.default, y.default) : v(p, y, mt, x, S);
          } };
        }(this._parameters, this._specification));
      };
      function oa(r) {
        var i = r.key, l = r.value, p = r.valueSpec || {}, y = r.objectElementValidators || {}, v = r.style, x = r.styleSpec, S = [], C = Qr(l);
        if (C !== "object")
          return [new ie(i, l, "object expected, " + C + " found")];
        for (var P in l) {
          var L = P.split(".")[0], D = p[L] || p["*"], B = void 0;
          if (y[L])
            B = y[L];
          else if (p[L])
            B = _r;
          else if (y["*"])
            B = y["*"];
          else {
            if (!p["*"]) {
              S.push(new ie(i, l[P], 'unknown property "' + P + '"'));
              continue;
            }
            B = _r;
          }
          S = S.concat(B({ key: (i && i + ".") + P, value: l[P], valueSpec: D, style: v, styleSpec: x, object: l, objectKey: P }, l));
        }
        for (var j in p)
          y[j] || p[j].required && p[j].default === void 0 && l[j] === void 0 && S.push(new ie(i, l, 'missing required property "' + j + '"'));
        return S;
      }
      function Tm(r) {
        var i = r.value, l = r.valueSpec, p = r.style, y = r.styleSpec, v = r.key, x = r.arrayElementValidator || _r;
        if (Qr(i) !== "array")
          return [new ie(v, i, "array expected, " + Qr(i) + " found")];
        if (l.length && i.length !== l.length)
          return [new ie(v, i, "array length " + l.length + " expected, length " + i.length + " found")];
        if (l["min-length"] && i.length < l["min-length"])
          return [new ie(v, i, "array length at least " + l["min-length"] + " expected, length " + i.length + " found")];
        var S = { type: l.value, values: l.values };
        y.$version < 7 && (S.function = l.function), Qr(l.value) === "object" && (S = l.value);
        for (var C = [], P = 0; P < i.length; P++)
          C = C.concat(x({ array: i, arrayIndex: P, value: i[P], valueSpec: S, style: p, styleSpec: y, key: v + "[" + P + "]" }));
        return C;
      }
      function Mm(r) {
        var i = r.key, l = r.value, p = r.valueSpec, y = Qr(l);
        return y === "number" && l != l && (y = "NaN"), y !== "number" ? [new ie(i, l, "number expected, " + y + " found")] : "minimum" in p && l < p.minimum ? [new ie(i, l, l + " is less than the minimum value " + p.minimum)] : "maximum" in p && l > p.maximum ? [new ie(i, l, l + " is greater than the maximum value " + p.maximum)] : [];
      }
      function Im(r) {
        var i, l, p, y = r.valueSpec, v = He(r.value.type), x = {}, S = v !== "categorical" && r.value.property === void 0, C = !S, P = Qr(r.value.stops) === "array" && Qr(r.value.stops[0]) === "array" && Qr(r.value.stops[0][0]) === "object", L = oa({ key: r.key, value: r.value, valueSpec: r.styleSpec.function, style: r.style, styleSpec: r.styleSpec, objectElementValidators: { stops: function(j) {
          if (v === "identity")
            return [new ie(j.key, j.value, 'identity function may not have a "stops" property')];
          var Q = [], te = j.value;
          return Q = Q.concat(Tm({ key: j.key, value: te, valueSpec: j.valueSpec, style: j.style, styleSpec: j.styleSpec, arrayElementValidator: D })), Qr(te) === "array" && te.length === 0 && Q.push(new ie(j.key, te, "array must have at least one stop")), Q;
        }, default: function(j) {
          return _r({ key: j.key, value: j.value, valueSpec: y, style: j.style, styleSpec: j.styleSpec });
        } } });
        return v === "identity" && S && L.push(new ie(r.key, r.value, 'missing required property "property"')), v === "identity" || r.value.stops || L.push(new ie(r.key, r.value, 'missing required property "stops"')), v === "exponential" && r.valueSpec.expression && !Hu(r.valueSpec) && L.push(new ie(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (C && !fl(r.valueSpec) ? L.push(new ie(r.key, r.value, "property functions not supported")) : S && !bm(r.valueSpec) && L.push(new ie(r.key, r.value, "zoom functions not supported"))), v !== "categorical" && !P || r.value.property !== void 0 || L.push(new ie(r.key, r.value, '"property" property is required')), L;
        function D(j) {
          var Q = [], te = j.value, ue = j.key;
          if (Qr(te) !== "array")
            return [new ie(ue, te, "array expected, " + Qr(te) + " found")];
          if (te.length !== 2)
            return [new ie(ue, te, "array length 2 expected, length " + te.length + " found")];
          if (P) {
            if (Qr(te[0]) !== "object")
              return [new ie(ue, te, "object expected, " + Qr(te[0]) + " found")];
            if (te[0].zoom === void 0)
              return [new ie(ue, te, "object stop key must have zoom")];
            if (te[0].value === void 0)
              return [new ie(ue, te, "object stop key must have value")];
            if (p && p > He(te[0].zoom))
              return [new ie(ue, te[0].zoom, "stop zoom values must appear in ascending order")];
            He(te[0].zoom) !== p && (p = He(te[0].zoom), l = void 0, x = {}), Q = Q.concat(oa({ key: ue + "[0]", value: te[0], valueSpec: { zoom: {} }, style: j.style, styleSpec: j.styleSpec, objectElementValidators: { zoom: Mm, value: B } }));
          } else
            Q = Q.concat(B({ key: ue + "[0]", value: te[0], valueSpec: {}, style: j.style, styleSpec: j.styleSpec }, te));
          return Zu(Oe(te[1])) ? Q.concat([new ie(ue + "[1]", te[1], "expressions are not allowed in function stops.")]) : Q.concat(_r({ key: ue + "[1]", value: te[1], valueSpec: y, style: j.style, styleSpec: j.styleSpec }));
        }
        function B(j, Q) {
          var te = Qr(j.value), ue = He(j.value), oe = j.value !== null ? j.value : Q;
          if (i) {
            if (te !== i)
              return [new ie(j.key, oe, te + " stop domain type must match previous stop domain type " + i)];
          } else
            i = te;
          if (te !== "number" && te !== "string" && te !== "boolean")
            return [new ie(j.key, oe, "stop domain value must be a number, string, or boolean")];
          if (te !== "number" && v !== "categorical") {
            var ge = "number expected, " + te + " found";
            return fl(y) && v === void 0 && (ge += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ie(j.key, oe, ge)];
          }
          return v !== "categorical" || te !== "number" || isFinite(ue) && Math.floor(ue) === ue ? v !== "categorical" && te === "number" && l !== void 0 && ue < l ? [new ie(j.key, oe, "stop domain values must appear in ascending order")] : (l = ue, v === "categorical" && ue in x ? [new ie(j.key, oe, "stop domain values must be unique")] : (x[ue] = !0, [])) : [new ie(j.key, oe, "integer expected, found " + ue)];
        }
      }
      function pl(r) {
        var i = (r.expressionContext === "property" ? Sm : lh)(Oe(r.value), r.valueSpec);
        if (i.result === "error")
          return i.value.map(function(p) {
            return new ie("" + r.key + p.key, r.value, p.message);
          });
        var l = i.value.expression || i.value._styleExpression.expression;
        if (r.expressionContext === "property" && r.propertyKey === "text-font" && !l.outputDefined())
          return [new ie(r.key, r.value, 'Invalid data expression for "' + r.propertyKey + '". Output values must be contained as literals within the expression.')];
        if (r.expressionContext === "property" && r.propertyType === "layout" && !ps(l))
          return [new ie(r.key, r.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (r.expressionContext === "filter" && !ps(l))
          return [new ie(r.key, r.value, '"feature-state" data expressions are not supported with filters.')];
        if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
          if (!nl(l, ["zoom", "feature-state"]))
            return [new ie(r.key, r.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (r.expressionContext === "cluster-initial" && !fs(l))
            return [new ie(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Ku(r) {
        var i = r.key, l = r.value, p = r.valueSpec, y = [];
        return Array.isArray(p.values) ? p.values.indexOf(He(l)) === -1 && y.push(new ie(i, l, "expected one of [" + p.values.join(", ") + "], " + JSON.stringify(l) + " found")) : Object.keys(p.values).indexOf(He(l)) === -1 && y.push(new ie(i, l, "expected one of [" + Object.keys(p.values).join(", ") + "], " + JSON.stringify(l) + " found")), y;
      }
      function uh(r) {
        if (r === !0 || r === !1)
          return !0;
        if (!Array.isArray(r) || r.length === 0)
          return !1;
        switch (r[0]) {
          case "has":
            return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
          case "in":
            return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
          case "any":
          case "all":
            for (var i = 0, l = r.slice(1); i < l.length; i += 1) {
              var p = l[i];
              if (!uh(p) && typeof p != "boolean")
                return !1;
            }
            return !0;
          default:
            return !0;
        }
      }
      Kl.deserialize = function(r) {
        return new Kl(r._parameters, r._specification);
      }, Kl.serialize = function(r) {
        return { _parameters: r._parameters, _specification: r._specification };
      };
      var Qf = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function ch(r) {
        if (r == null)
          return { filter: function() {
            return !0;
          }, needGeometry: !1 };
        uh(r) || (r = hh(r));
        var i = lh(r, Qf);
        if (i.result === "error")
          throw new Error(i.value.map(function(l) {
            return l.key + ": " + l.message;
          }).join(", "));
        return { filter: function(l, p, y) {
          return i.value.evaluate(l, p, {}, y);
        }, needGeometry: function l(p) {
          if (!Array.isArray(p))
            return !1;
          if (p[0] === "within")
            return !0;
          for (var y = 1; y < p.length; y++)
            if (l(p[y]))
              return !0;
          return !1;
        }(r) };
      }
      function qv(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function hh(r) {
        if (!r)
          return !0;
        var i, l = r[0];
        return r.length <= 1 ? l !== "any" : l === "==" ? ep(r[1], r[2], "==") : l === "!=" ? fh(ep(r[1], r[2], "==")) : l === "<" || l === ">" || l === "<=" || l === ">=" ? ep(r[1], r[2], l) : l === "any" ? (i = r.slice(1), ["any"].concat(i.map(hh))) : l === "all" ? ["all"].concat(r.slice(1).map(hh)) : l === "none" ? ["all"].concat(r.slice(1).map(hh).map(fh)) : l === "in" ? Om(r[1], r.slice(2)) : l === "!in" ? fh(Om(r[1], r.slice(2))) : l === "has" ? Cm(r[1]) : l === "!has" ? fh(Cm(r[1])) : l !== "within" || r;
      }
      function ep(r, i, l) {
        switch (r) {
          case "$type":
            return ["filter-type-" + l, i];
          case "$id":
            return ["filter-id-" + l, i];
          default:
            return ["filter-" + l, r, i];
        }
      }
      function Om(r, i) {
        if (i.length === 0)
          return !1;
        switch (r) {
          case "$type":
            return ["filter-type-in", ["literal", i]];
          case "$id":
            return ["filter-id-in", ["literal", i]];
          default:
            return i.length > 200 && !i.some(function(l) {
              return typeof l != typeof i[0];
            }) ? ["filter-in-large", r, ["literal", i.sort(qv)]] : ["filter-in-small", r, ["literal", i]];
        }
      }
      function Cm(r) {
        switch (r) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", r];
        }
      }
      function fh(r) {
        return ["!", r];
      }
      function tp(r) {
        return uh(Oe(r.value)) ? pl(Ge({}, r, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : function i(l) {
          var p = l.value, y = l.key;
          if (Qr(p) !== "array")
            return [new ie(y, p, "array expected, " + Qr(p) + " found")];
          var v, x = l.styleSpec, S = [];
          if (p.length < 1)
            return [new ie(y, p, "filter array must have at least 1 element")];
          switch (S = S.concat(Ku({ key: y + "[0]", value: p[0], valueSpec: x.filter_operator, style: l.style, styleSpec: l.styleSpec })), He(p[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              p.length >= 2 && He(p[1]) === "$type" && S.push(new ie(y, p, '"$type" cannot be use with operator "' + p[0] + '"'));
            case "==":
            case "!=":
              p.length !== 3 && S.push(new ie(y, p, 'filter array for operator "' + p[0] + '" must have 3 elements'));
            case "in":
            case "!in":
              p.length >= 2 && (v = Qr(p[1])) !== "string" && S.push(new ie(y + "[1]", p[1], "string expected, " + v + " found"));
              for (var C = 2; C < p.length; C++)
                v = Qr(p[C]), He(p[1]) === "$type" ? S = S.concat(Ku({ key: y + "[" + C + "]", value: p[C], valueSpec: x.geometry_type, style: l.style, styleSpec: l.styleSpec })) : v !== "string" && v !== "number" && v !== "boolean" && S.push(new ie(y + "[" + C + "]", p[C], "string, number, or boolean expected, " + v + " found"));
              break;
            case "any":
            case "all":
            case "none":
              for (var P = 1; P < p.length; P++)
                S = S.concat(i({ key: y + "[" + P + "]", value: p[P], style: l.style, styleSpec: l.styleSpec }));
              break;
            case "has":
            case "!has":
              v = Qr(p[1]), p.length !== 2 ? S.push(new ie(y, p, 'filter array for "' + p[0] + '" operator must have 2 elements')) : v !== "string" && S.push(new ie(y + "[1]", p[1], "string expected, " + v + " found"));
              break;
            case "within":
              v = Qr(p[1]), p.length !== 2 ? S.push(new ie(y, p, 'filter array for "' + p[0] + '" operator must have 2 elements')) : v !== "object" && S.push(new ie(y + "[1]", p[1], "object expected, " + v + " found"));
          }
          return S;
        }(r);
      }
      function rp(r, i) {
        var l = r.key, p = r.style, y = r.styleSpec, v = r.value, x = r.objectKey, S = y[i + "_" + r.layerType];
        if (!S)
          return [];
        var C = x.match(/^(.*)-transition$/);
        if (i === "paint" && C && S[C[1]] && S[C[1]].transition)
          return _r({ key: l, value: v, valueSpec: y.transition, style: p, styleSpec: y });
        var P, L = r.valueSpec || S[x];
        if (!L)
          return [new ie(l, v, 'unknown property "' + x + '"')];
        if (Qr(v) === "string" && fl(L) && !L.tokens && (P = /^{([^}]+)}$/.exec(v)))
          return [new ie(l, v, '"' + x + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(P[1]) + " }`.")];
        var D = [];
        return r.layerType === "symbol" && (x === "text-field" && p && !p.glyphs && D.push(new ie(l, v, 'use of "text-field" requires a style "glyphs" property')), x === "text-font" && ah(Oe(v)) && He(v.type) === "identity" && D.push(new ie(l, v, '"text-font" does not support identity functions'))), D.concat(_r({ key: r.key, value: v, valueSpec: L, style: p, styleSpec: y, expressionContext: "property", propertyType: i, propertyKey: x }));
      }
      function np(r) {
        return rp(r, "paint");
      }
      function Yu(r) {
        return rp(r, "layout");
      }
      function Am(r) {
        var i = [], l = r.value, p = r.key, y = r.style, v = r.styleSpec;
        l.type || l.ref || i.push(new ie(p, l, 'either "type" or "ref" is required'));
        var x, S = He(l.type), C = He(l.ref);
        if (l.id)
          for (var P = He(l.id), L = 0; L < r.arrayIndex; L++) {
            var D = y.layers[L];
            He(D.id) === P && i.push(new ie(p, l.id, 'duplicate layer id "' + l.id + '", previously used at line ' + D.id.__line__));
          }
        if ("ref" in l)
          ["type", "source", "source-layer", "filter", "layout"].forEach(function(Q) {
            Q in l && i.push(new ie(p, l[Q], '"' + Q + '" is prohibited for ref layers'));
          }), y.layers.forEach(function(Q) {
            He(Q.id) === C && (x = Q);
          }), x ? x.ref ? i.push(new ie(p, l.ref, "ref cannot reference another ref layer")) : S = He(x.type) : i.push(new ie(p, l.ref, 'ref layer "' + C + '" not found'));
        else if (S !== "background")
          if (l.source) {
            var B = y.sources && y.sources[l.source], j = B && He(B.type);
            B ? j === "vector" && S === "raster" ? i.push(new ie(p, l.source, 'layer "' + l.id + '" requires a raster source')) : j === "raster" && S !== "raster" ? i.push(new ie(p, l.source, 'layer "' + l.id + '" requires a vector source')) : j !== "vector" || l["source-layer"] ? j === "raster-dem" && S !== "hillshade" ? i.push(new ie(p, l.source, "raster-dem source can only be used with layer type 'hillshade'.")) : S !== "line" || !l.paint || !l.paint["line-gradient"] || j === "geojson" && B.lineMetrics || i.push(new ie(p, l, 'layer "' + l.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : i.push(new ie(p, l, 'layer "' + l.id + '" must specify a "source-layer"')) : i.push(new ie(p, l.source, 'source "' + l.source + '" not found'));
          } else
            i.push(new ie(p, l, 'missing required property "source"'));
        return i = i.concat(oa({ key: p, value: l, valueSpec: v.layer, style: r.style, styleSpec: r.styleSpec, objectElementValidators: { "*": function() {
          return [];
        }, type: function() {
          return _r({ key: p + ".type", value: l.type, valueSpec: v.layer.type, style: r.style, styleSpec: r.styleSpec, object: l, objectKey: "type" });
        }, filter: tp, layout: function(Q) {
          return oa({ layer: l, key: Q.key, value: Q.value, style: Q.style, styleSpec: Q.styleSpec, objectElementValidators: { "*": function(te) {
            return Yu(Ge({ layerType: S }, te));
          } } });
        }, paint: function(Q) {
          return oa({ layer: l, key: Q.key, value: Q.value, style: Q.style, styleSpec: Q.styleSpec, objectElementValidators: { "*": function(te) {
            return np(Ge({ layerType: S }, te));
          } } });
        } } }));
      }
      function dl(r) {
        var i = r.value, l = r.key, p = Qr(i);
        return p !== "string" ? [new ie(l, i, "string expected, " + p + " found")] : [];
      }
      var mn = { promoteId: function(r) {
        var i = r.key, l = r.value;
        if (Qr(l) === "string")
          return dl({ key: i, value: l });
        var p = [];
        for (var y in l)
          p.push.apply(p, dl({ key: i + "." + y, value: l[y] }));
        return p;
      } };
      function ph(r) {
        var i = r.value, l = r.key, p = r.styleSpec, y = r.style;
        if (!i.type)
          return [new ie(l, i, '"type" is required')];
        var v, x = He(i.type);
        switch (x) {
          case "vector":
          case "raster":
          case "raster-dem":
            return oa({ key: l, value: i, valueSpec: p["source_" + x.replace("-", "_")], style: r.style, styleSpec: p, objectElementValidators: mn });
          case "geojson":
            if (v = oa({ key: l, value: i, valueSpec: p.source_geojson, style: y, styleSpec: p, objectElementValidators: mn }), i.cluster)
              for (var S in i.clusterProperties) {
                var C = i.clusterProperties[S], P = C[0], L = typeof P == "string" ? [P, ["accumulated"], ["get", S]] : P;
                v.push.apply(v, pl({ key: l + "." + S + ".map", value: C[1], expressionContext: "cluster-map" })), v.push.apply(v, pl({ key: l + "." + S + ".reduce", value: L, expressionContext: "cluster-reduce" }));
              }
            return v;
          case "video":
            return oa({ key: l, value: i, valueSpec: p.source_video, style: y, styleSpec: p });
          case "image":
            return oa({ key: l, value: i, valueSpec: p.source_image, style: y, styleSpec: p });
          case "canvas":
            return [new ie(l, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return Ku({ key: l + ".type", value: i.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: y, styleSpec: p });
        }
      }
      function ml(r) {
        var i = r.value, l = r.styleSpec, p = l.light, y = r.style, v = [], x = Qr(i);
        if (i === void 0)
          return v;
        if (x !== "object")
          return v.concat([new ie("light", i, "object expected, " + x + " found")]);
        for (var S in i) {
          var C = S.match(/^(.*)-transition$/);
          v = v.concat(C && p[C[1]] && p[C[1]].transition ? _r({ key: S, value: i[S], valueSpec: l.transition, style: y, styleSpec: l }) : p[S] ? _r({ key: S, value: i[S], valueSpec: p[S], style: y, styleSpec: l }) : [new ie(S, i[S], 'unknown property "' + S + '"')]);
        }
        return v;
      }
      var bs = { "*": function() {
        return [];
      }, array: Tm, boolean: function(r) {
        var i = r.value, l = r.key, p = Qr(i);
        return p !== "boolean" ? [new ie(l, i, "boolean expected, " + p + " found")] : [];
      }, number: Mm, color: function(r) {
        var i = r.key, l = r.value, p = Qr(l);
        return p !== "string" ? [new ie(i, l, "color expected, " + p + " found")] : yr(l) === null ? [new ie(i, l, 'color expected, "' + l + '" found')] : [];
      }, constants: ve, enum: Ku, filter: tp, function: Im, layer: Am, object: oa, source: ph, light: ml, string: dl, formatted: function(r) {
        return dl(r).length === 0 ? [] : pl(r);
      }, resolvedImage: function(r) {
        return dl(r).length === 0 ? [] : pl(r);
      } };
      function _r(r) {
        var i = r.value, l = r.valueSpec, p = r.styleSpec;
        return l.expression && ah(He(i)) ? Im(r) : l.expression && Zu(Oe(i)) ? pl(r) : l.type && bs[l.type] ? bs[l.type](r) : oa(Ge({}, r, { valueSpec: l.type ? p[l.type] : l }));
      }
      function en(r) {
        var i = r.value, l = r.key, p = dl(r);
        return p.length || (i.indexOf("{fontstack}") === -1 && p.push(new ie(l, i, '"glyphs" url must include a "{fontstack}" token')), i.indexOf("{range}") === -1 && p.push(new ie(l, i, '"glyphs" url must include a "{range}" token'))), p;
      }
      function Mo(r, i) {
        i === void 0 && (i = G);
        var l = [];
        return l = l.concat(_r({ key: "", value: r, valueSpec: i.$root, styleSpec: i, style: r, objectElementValidators: { glyphs: en, "*": function() {
          return [];
        } } })), r.constants && (l = l.concat(ve({ key: "constants", value: r.constants, style: r, styleSpec: i }))), Ju(l);
      }
      function Ju(r) {
        return [].concat(r).sort(function(i, l) {
          return i.line - l.line;
        });
      }
      function Yl(r) {
        return function() {
          for (var i = [], l = arguments.length; l--; )
            i[l] = arguments[l];
          return Ju(r.apply(this, i));
        };
      }
      Mo.source = Yl(ph), Mo.light = Yl(ml), Mo.layer = Yl(Am), Mo.filter = Yl(tp), Mo.paintProperty = Yl(np), Mo.layoutProperty = Yl(Yu);
      var Qu = Mo, $v = Qu.light, Wv = Qu.paintProperty, ec = Qu.layoutProperty;
      function tc(r, i) {
        var l = !1;
        if (i && i.length)
          for (var p = 0, y = i; p < y.length; p += 1)
            r.fire(new he(new Error(y[p].message))), l = !0;
        return l;
      }
      var Ua = Jn;
      function Jn(r, i, l) {
        var p = this.cells = [];
        if (r instanceof ArrayBuffer) {
          this.arrayBuffer = r;
          var y = new Int32Array(this.arrayBuffer);
          r = y[0], this.d = (i = y[1]) + 2 * (l = y[2]);
          for (var v = 0; v < this.d * this.d; v++) {
            var x = y[3 + v], S = y[3 + v + 1];
            p.push(x === S ? null : y.subarray(x, S));
          }
          var C = y[3 + p.length + 1];
          this.keys = y.subarray(y[3 + p.length], C), this.bboxes = y.subarray(C), this.insert = this._insertReadonly;
        } else {
          this.d = i + 2 * l;
          for (var P = 0; P < this.d * this.d; P++)
            p.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = i, this.extent = r, this.padding = l, this.scale = i / r, this.uid = 0;
        var L = l / i * r;
        this.min = -L, this.max = r + L;
      }
      Jn.prototype.insert = function(r, i, l, p, y) {
        this._forEachCell(i, l, p, y, this._insertCell, this.uid++), this.keys.push(r), this.bboxes.push(i), this.bboxes.push(l), this.bboxes.push(p), this.bboxes.push(y);
      }, Jn.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, Jn.prototype._insertCell = function(r, i, l, p, y, v) {
        this.cells[y].push(v);
      }, Jn.prototype.query = function(r, i, l, p, y) {
        var v = this.min, x = this.max;
        if (r <= v && i <= v && x <= l && x <= p && !y)
          return Array.prototype.slice.call(this.keys);
        var S = [];
        return this._forEachCell(r, i, l, p, this._queryCell, S, {}, y), S;
      }, Jn.prototype._queryCell = function(r, i, l, p, y, v, x, S) {
        var C = this.cells[y];
        if (C !== null)
          for (var P = this.keys, L = this.bboxes, D = 0; D < C.length; D++) {
            var B = C[D];
            if (x[B] === void 0) {
              var j = 4 * B;
              (S ? S(L[j + 0], L[j + 1], L[j + 2], L[j + 3]) : r <= L[j + 2] && i <= L[j + 3] && l >= L[j + 0] && p >= L[j + 1]) ? (x[B] = !0, v.push(P[B])) : x[B] = !1;
            }
          }
      }, Jn.prototype._forEachCell = function(r, i, l, p, y, v, x, S) {
        for (var C = this._convertToCellCoord(r), P = this._convertToCellCoord(i), L = this._convertToCellCoord(l), D = this._convertToCellCoord(p), B = C; B <= L; B++)
          for (var j = P; j <= D; j++) {
            var Q = this.d * j + B;
            if ((!S || S(this._convertFromCellCoord(B), this._convertFromCellCoord(j), this._convertFromCellCoord(B + 1), this._convertFromCellCoord(j + 1))) && y.call(this, r, i, l, p, Q, v, x, S))
              return;
          }
      }, Jn.prototype._convertFromCellCoord = function(r) {
        return (r - this.padding) / this.scale;
      }, Jn.prototype._convertToCellCoord = function(r) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(r * this.scale) + this.padding));
      }, Jn.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer)
          return this.arrayBuffer;
        for (var r = this.cells, i = 3 + this.cells.length + 1 + 1, l = 0, p = 0; p < this.cells.length; p++)
          l += this.cells[p].length;
        var y = new Int32Array(i + l + this.keys.length + this.bboxes.length);
        y[0] = this.extent, y[1] = this.n, y[2] = this.padding;
        for (var v = i, x = 0; x < r.length; x++) {
          var S = r[x];
          y[3 + x] = v, y.set(S, v), v += S.length;
        }
        return y[3 + r.length] = v, y.set(this.keys, v), y[3 + r.length + 1] = v += this.keys.length, y.set(this.bboxes, v), v += this.bboxes.length, y.buffer;
      };
      var rc = I.ImageData, Pm = I.ImageBitmap, Gn = {};
      function wt(r, i, l) {
        l === void 0 && (l = {}), Object.defineProperty(i, "_classRegistryKey", { value: r, writeable: !1 }), Gn[r] = { klass: i, omit: l.omit || [], shallow: l.shallow || [] };
      }
      for (var uo in wt("Object", Object), Ua.serialize = function(r, i) {
        var l = r.toArrayBuffer();
        return i && i.push(l), { buffer: l };
      }, Ua.deserialize = function(r) {
        return new Ua(r.buffer);
      }, wt("Grid", Ua), wt("Color", Rr), wt("Error", Error), wt("ResolvedImage", Ji), wt("StylePropertyFunction", Kl), wt("StyleExpression", Zl, { omit: ["_evaluator"] }), wt("ZoomDependentExpression", Xl), wt("ZoomConstantExpression", Xu), wt("CompoundExpression", Ei, { omit: ["_evaluate"] }), ul)
        ul[uo]._classRegistryKey || wt("Expression_" + uo, ul[uo]);
      function dh(r) {
        return r && typeof ArrayBuffer < "u" && (r instanceof ArrayBuffer || r.constructor && r.constructor.name === "ArrayBuffer");
      }
      function Jl(r) {
        return Pm && r instanceof Pm;
      }
      function aa(r, i) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp)
          return r;
        if (dh(r) || Jl(r))
          return i && i.push(r), r;
        if (ArrayBuffer.isView(r)) {
          var l = r;
          return i && i.push(l.buffer), l;
        }
        if (r instanceof rc)
          return i && i.push(r.data.buffer), r;
        if (Array.isArray(r)) {
          for (var p = [], y = 0, v = r; y < v.length; y += 1)
            p.push(aa(v[y], i));
          return p;
        }
        if (typeof r == "object") {
          var x = r.constructor, S = x._classRegistryKey;
          if (!S)
            throw new Error("can't serialize object of unregistered class");
          var C = x.serialize ? x.serialize(r, i) : {};
          if (!x.serialize) {
            for (var P in r)
              if (r.hasOwnProperty(P) && !(Gn[S].omit.indexOf(P) >= 0)) {
                var L = r[P];
                C[P] = Gn[S].shallow.indexOf(P) >= 0 ? L : aa(L, i);
              }
            r instanceof Error && (C.message = r.message);
          }
          if (C.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return S !== "Object" && (C.$name = S), C;
        }
        throw new Error("can't serialize object of type " + typeof r);
      }
      function co(r) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp || dh(r) || Jl(r) || ArrayBuffer.isView(r) || r instanceof rc)
          return r;
        if (Array.isArray(r))
          return r.map(co);
        if (typeof r == "object") {
          var i = r.$name || "Object", l = Gn[i].klass;
          if (!l)
            throw new Error("can't deserialize unregistered class " + i);
          if (l.deserialize)
            return l.deserialize(r);
          for (var p = Object.create(l.prototype), y = 0, v = Object.keys(r); y < v.length; y += 1) {
            var x = v[y];
            if (x !== "$name") {
              var S = r[x];
              p[x] = Gn[i].shallow.indexOf(x) >= 0 ? S : co(S);
            }
          }
          return p;
        }
        throw new Error("can't deserialize object of type " + typeof r);
      }
      var ip = function() {
        this.first = !0;
      };
      ip.prototype.update = function(r, i) {
        var l = Math.floor(r);
        return this.first ? (this.first = !1, this.lastIntegerZoom = l, this.lastIntegerZoomTime = 0, this.lastZoom = r, this.lastFloorZoom = l, !0) : (this.lastFloorZoom > l ? (this.lastIntegerZoom = l + 1, this.lastIntegerZoomTime = i) : this.lastFloorZoom < l && (this.lastIntegerZoom = l, this.lastIntegerZoomTime = i), r !== this.lastZoom && (this.lastZoom = r, this.lastFloorZoom = l, !0));
      };
      var ut = { "Latin-1 Supplement": function(r) {
        return r >= 128 && r <= 255;
      }, Arabic: function(r) {
        return r >= 1536 && r <= 1791;
      }, "Arabic Supplement": function(r) {
        return r >= 1872 && r <= 1919;
      }, "Arabic Extended-A": function(r) {
        return r >= 2208 && r <= 2303;
      }, "Hangul Jamo": function(r) {
        return r >= 4352 && r <= 4607;
      }, "Unified Canadian Aboriginal Syllabics": function(r) {
        return r >= 5120 && r <= 5759;
      }, Khmer: function(r) {
        return r >= 6016 && r <= 6143;
      }, "Unified Canadian Aboriginal Syllabics Extended": function(r) {
        return r >= 6320 && r <= 6399;
      }, "General Punctuation": function(r) {
        return r >= 8192 && r <= 8303;
      }, "Letterlike Symbols": function(r) {
        return r >= 8448 && r <= 8527;
      }, "Number Forms": function(r) {
        return r >= 8528 && r <= 8591;
      }, "Miscellaneous Technical": function(r) {
        return r >= 8960 && r <= 9215;
      }, "Control Pictures": function(r) {
        return r >= 9216 && r <= 9279;
      }, "Optical Character Recognition": function(r) {
        return r >= 9280 && r <= 9311;
      }, "Enclosed Alphanumerics": function(r) {
        return r >= 9312 && r <= 9471;
      }, "Geometric Shapes": function(r) {
        return r >= 9632 && r <= 9727;
      }, "Miscellaneous Symbols": function(r) {
        return r >= 9728 && r <= 9983;
      }, "Miscellaneous Symbols and Arrows": function(r) {
        return r >= 11008 && r <= 11263;
      }, "CJK Radicals Supplement": function(r) {
        return r >= 11904 && r <= 12031;
      }, "Kangxi Radicals": function(r) {
        return r >= 12032 && r <= 12255;
      }, "Ideographic Description Characters": function(r) {
        return r >= 12272 && r <= 12287;
      }, "CJK Symbols and Punctuation": function(r) {
        return r >= 12288 && r <= 12351;
      }, Hiragana: function(r) {
        return r >= 12352 && r <= 12447;
      }, Katakana: function(r) {
        return r >= 12448 && r <= 12543;
      }, Bopomofo: function(r) {
        return r >= 12544 && r <= 12591;
      }, "Hangul Compatibility Jamo": function(r) {
        return r >= 12592 && r <= 12687;
      }, Kanbun: function(r) {
        return r >= 12688 && r <= 12703;
      }, "Bopomofo Extended": function(r) {
        return r >= 12704 && r <= 12735;
      }, "CJK Strokes": function(r) {
        return r >= 12736 && r <= 12783;
      }, "Katakana Phonetic Extensions": function(r) {
        return r >= 12784 && r <= 12799;
      }, "Enclosed CJK Letters and Months": function(r) {
        return r >= 12800 && r <= 13055;
      }, "CJK Compatibility": function(r) {
        return r >= 13056 && r <= 13311;
      }, "CJK Unified Ideographs Extension A": function(r) {
        return r >= 13312 && r <= 19903;
      }, "Yijing Hexagram Symbols": function(r) {
        return r >= 19904 && r <= 19967;
      }, "CJK Unified Ideographs": function(r) {
        return r >= 19968 && r <= 40959;
      }, "Yi Syllables": function(r) {
        return r >= 40960 && r <= 42127;
      }, "Yi Radicals": function(r) {
        return r >= 42128 && r <= 42191;
      }, "Hangul Jamo Extended-A": function(r) {
        return r >= 43360 && r <= 43391;
      }, "Hangul Syllables": function(r) {
        return r >= 44032 && r <= 55215;
      }, "Hangul Jamo Extended-B": function(r) {
        return r >= 55216 && r <= 55295;
      }, "Private Use Area": function(r) {
        return r >= 57344 && r <= 63743;
      }, "CJK Compatibility Ideographs": function(r) {
        return r >= 63744 && r <= 64255;
      }, "Arabic Presentation Forms-A": function(r) {
        return r >= 64336 && r <= 65023;
      }, "Vertical Forms": function(r) {
        return r >= 65040 && r <= 65055;
      }, "CJK Compatibility Forms": function(r) {
        return r >= 65072 && r <= 65103;
      }, "Small Form Variants": function(r) {
        return r >= 65104 && r <= 65135;
      }, "Arabic Presentation Forms-B": function(r) {
        return r >= 65136 && r <= 65279;
      }, "Halfwidth and Fullwidth Forms": function(r) {
        return r >= 65280 && r <= 65519;
      } };
      function op(r) {
        for (var i = 0, l = r; i < l.length; i += 1)
          if (mh(l[i].charCodeAt(0)))
            return !0;
        return !1;
      }
      function mh(r) {
        return !(r !== 746 && r !== 747 && (r < 4352 || !(ut["Bopomofo Extended"](r) || ut.Bopomofo(r) || ut["CJK Compatibility Forms"](r) && !(r >= 65097 && r <= 65103) || ut["CJK Compatibility Ideographs"](r) || ut["CJK Compatibility"](r) || ut["CJK Radicals Supplement"](r) || ut["CJK Strokes"](r) || !(!ut["CJK Symbols and Punctuation"](r) || r >= 12296 && r <= 12305 || r >= 12308 && r <= 12319 || r === 12336) || ut["CJK Unified Ideographs Extension A"](r) || ut["CJK Unified Ideographs"](r) || ut["Enclosed CJK Letters and Months"](r) || ut["Hangul Compatibility Jamo"](r) || ut["Hangul Jamo Extended-A"](r) || ut["Hangul Jamo Extended-B"](r) || ut["Hangul Jamo"](r) || ut["Hangul Syllables"](r) || ut.Hiragana(r) || ut["Ideographic Description Characters"](r) || ut.Kanbun(r) || ut["Kangxi Radicals"](r) || ut["Katakana Phonetic Extensions"](r) || ut.Katakana(r) && r !== 12540 || !(!ut["Halfwidth and Fullwidth Forms"](r) || r === 65288 || r === 65289 || r === 65293 || r >= 65306 && r <= 65310 || r === 65339 || r === 65341 || r === 65343 || r >= 65371 && r <= 65503 || r === 65507 || r >= 65512 && r <= 65519) || !(!ut["Small Form Variants"](r) || r >= 65112 && r <= 65118 || r >= 65123 && r <= 65126) || ut["Unified Canadian Aboriginal Syllabics"](r) || ut["Unified Canadian Aboriginal Syllabics Extended"](r) || ut["Vertical Forms"](r) || ut["Yijing Hexagram Symbols"](r) || ut["Yi Syllables"](r) || ut["Yi Radicals"](r))));
      }
      function ap(r) {
        return !(mh(r) || function(i) {
          return !!(ut["Latin-1 Supplement"](i) && (i === 167 || i === 169 || i === 174 || i === 177 || i === 188 || i === 189 || i === 190 || i === 215 || i === 247) || ut["General Punctuation"](i) && (i === 8214 || i === 8224 || i === 8225 || i === 8240 || i === 8241 || i === 8251 || i === 8252 || i === 8258 || i === 8263 || i === 8264 || i === 8265 || i === 8273) || ut["Letterlike Symbols"](i) || ut["Number Forms"](i) || ut["Miscellaneous Technical"](i) && (i >= 8960 && i <= 8967 || i >= 8972 && i <= 8991 || i >= 8996 && i <= 9e3 || i === 9003 || i >= 9085 && i <= 9114 || i >= 9150 && i <= 9165 || i === 9167 || i >= 9169 && i <= 9179 || i >= 9186 && i <= 9215) || ut["Control Pictures"](i) && i !== 9251 || ut["Optical Character Recognition"](i) || ut["Enclosed Alphanumerics"](i) || ut["Geometric Shapes"](i) || ut["Miscellaneous Symbols"](i) && !(i >= 9754 && i <= 9759) || ut["Miscellaneous Symbols and Arrows"](i) && (i >= 11026 && i <= 11055 || i >= 11088 && i <= 11097 || i >= 11192 && i <= 11243) || ut["CJK Symbols and Punctuation"](i) || ut.Katakana(i) || ut["Private Use Area"](i) || ut["CJK Compatibility Forms"](i) || ut["Small Form Variants"](i) || ut["Halfwidth and Fullwidth Forms"](i) || i === 8734 || i === 8756 || i === 8757 || i >= 9984 && i <= 10087 || i >= 10102 && i <= 10131 || i === 65532 || i === 65533);
        }(r));
      }
      function $o(r) {
        return r >= 1424 && r <= 2303 || ut["Arabic Presentation Forms-A"](r) || ut["Arabic Presentation Forms-B"](r);
      }
      function ho(r, i) {
        return !(!i && $o(r) || r >= 2304 && r <= 3583 || r >= 3840 && r <= 4255 || ut.Khmer(r));
      }
      function yh(r) {
        for (var i = 0, l = r; i < l.length; i += 1)
          if ($o(l[i].charCodeAt(0)))
            return !0;
        return !1;
      }
      var gh = null, fo = "unavailable", ja = null, km = function(r) {
        r && typeof r == "string" && r.indexOf("NetworkError") > -1 && (fo = "error"), gh && gh(r);
      };
      function nc() {
        sp.fire(new ee("pluginStateChange", { pluginStatus: fo, pluginURL: ja }));
      }
      var sp = new fe(), lp = function() {
        return fo;
      }, sa = function() {
        if (fo !== "deferred" || !ja)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        fo = "loading", nc(), ja && tl({ url: ja }, function(r) {
          r ? km(r) : (fo = "loaded", nc());
        });
      }, Io = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function() {
        return fo === "loaded" || Io.applyArabicShaping != null;
      }, isLoading: function() {
        return fo === "loading";
      }, setState: function(r) {
        fo = r.pluginStatus, ja = r.pluginURL;
      }, isParsed: function() {
        return Io.applyArabicShaping != null && Io.processBidirectionalText != null && Io.processStyledBidirectionalText != null;
      }, getPluginURL: function() {
        return ja;
      } }, pr = function(r, i) {
        this.zoom = r, i ? (this.now = i.now, this.fadeDuration = i.fadeDuration, this.zoomHistory = i.zoomHistory, this.transition = i.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ip(), this.transition = {});
      };
      pr.prototype.isSupportedScript = function(r) {
        return function(i, l) {
          for (var p = 0, y = i; p < y.length; p += 1)
            if (!ho(y[p].charCodeAt(0), l))
              return !1;
          return !0;
        }(r, Io.isLoaded());
      }, pr.prototype.crossFadingFactor = function() {
        return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
      }, pr.prototype.getCrossfadeParameters = function() {
        var r = this.zoom, i = r - Math.floor(r), l = this.crossFadingFactor();
        return r > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: i + (1 - i) * l } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - l) * i };
      };
      var xa = function(r, i) {
        this.property = r, this.value = i, this.expression = function(l, p) {
          if (ah(l))
            return new Kl(l, p);
          if (Zu(l)) {
            var y = Sm(l, p);
            if (y.result === "error")
              throw new Error(y.value.map(function(x) {
                return x.key + ": " + x.message;
              }).join(", "));
            return y.value;
          }
          var v = l;
          return typeof l == "string" && p.type === "color" && (v = Rr.parse(l)), { kind: "constant", evaluate: function() {
            return v;
          } };
        }(i === void 0 ? r.specification.default : i, r.specification);
      };
      xa.prototype.isDataDriven = function() {
        return this.expression.kind === "source" || this.expression.kind === "composite";
      }, xa.prototype.possiblyEvaluate = function(r, i, l) {
        return this.property.possiblyEvaluate(this, r, i, l);
      };
      var Wo = function(r) {
        this.property = r, this.value = new xa(r, void 0);
      };
      Wo.prototype.transitioned = function(r, i) {
        return new yl(this.property, this.value, i, Y({}, r.transition, this.transition), r.now);
      }, Wo.prototype.untransitioned = function() {
        return new yl(this.property, this.value, null, {}, 0);
      };
      var Ti = function(r) {
        this._properties = r, this._values = Object.create(r.defaultTransitionablePropertyValues);
      };
      Ti.prototype.getValue = function(r) {
        return rt(this._values[r].value.value);
      }, Ti.prototype.setValue = function(r, i) {
        this._values.hasOwnProperty(r) || (this._values[r] = new Wo(this._values[r].property)), this._values[r].value = new xa(this._values[r].property, i === null ? void 0 : rt(i));
      }, Ti.prototype.getTransition = function(r) {
        return rt(this._values[r].transition);
      }, Ti.prototype.setTransition = function(r, i) {
        this._values.hasOwnProperty(r) || (this._values[r] = new Wo(this._values[r].property)), this._values[r].transition = rt(i) || void 0;
      }, Ti.prototype.serialize = function() {
        for (var r = {}, i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i], y = this.getValue(p);
          y !== void 0 && (r[p] = y);
          var v = this.getTransition(p);
          v !== void 0 && (r[p + "-transition"] = v);
        }
        return r;
      }, Ti.prototype.transitioned = function(r, i) {
        for (var l = new ws(this._properties), p = 0, y = Object.keys(this._values); p < y.length; p += 1) {
          var v = y[p];
          l._values[v] = this._values[v].transitioned(r, i._values[v]);
        }
        return l;
      }, Ti.prototype.untransitioned = function() {
        for (var r = new ws(this._properties), i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i];
          r._values[p] = this._values[p].untransitioned();
        }
        return r;
      };
      var yl = function(r, i, l, p, y) {
        this.property = r, this.value = i, this.begin = y + p.delay || 0, this.end = this.begin + p.duration || 0, r.specification.transition && (p.delay || p.duration) && (this.prior = l);
      };
      yl.prototype.possiblyEvaluate = function(r, i, l) {
        var p = r.now || 0, y = this.value.possiblyEvaluate(r, i, l), v = this.prior;
        if (v) {
          if (p > this.end)
            return this.prior = null, y;
          if (this.value.isDataDriven())
            return this.prior = null, y;
          if (p < this.begin)
            return v.possiblyEvaluate(r, i, l);
          var x = (p - this.begin) / (this.end - this.begin);
          return this.property.interpolate(v.possiblyEvaluate(r, i, l), y, function(S) {
            if (S <= 0)
              return 0;
            if (S >= 1)
              return 1;
            var C = S * S, P = C * S;
            return 4 * (S < 0.5 ? P : 3 * (S - C) + P - 0.75);
          }(x));
        }
        return y;
      };
      var ws = function(r) {
        this._properties = r, this._values = Object.create(r.defaultTransitioningPropertyValues);
      };
      ws.prototype.possiblyEvaluate = function(r, i, l) {
        for (var p = new ic(this._properties), y = 0, v = Object.keys(this._values); y < v.length; y += 1) {
          var x = v[y];
          p._values[x] = this._values[x].possiblyEvaluate(r, i, l);
        }
        return p;
      }, ws.prototype.hasTransition = function() {
        for (var r = 0, i = Object.keys(this._values); r < i.length; r += 1)
          if (this._values[i[r]].prior)
            return !0;
        return !1;
      };
      var la = function(r) {
        this._properties = r, this._values = Object.create(r.defaultPropertyValues);
      };
      la.prototype.getValue = function(r) {
        return rt(this._values[r].value);
      }, la.prototype.setValue = function(r, i) {
        this._values[r] = new xa(this._values[r].property, i === null ? void 0 : rt(i));
      }, la.prototype.serialize = function() {
        for (var r = {}, i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i], y = this.getValue(p);
          y !== void 0 && (r[p] = y);
        }
        return r;
      }, la.prototype.possiblyEvaluate = function(r, i, l) {
        for (var p = new ic(this._properties), y = 0, v = Object.keys(this._values); y < v.length; y += 1) {
          var x = v[y];
          p._values[x] = this._values[x].possiblyEvaluate(r, i, l);
        }
        return p;
      };
      var ji = function(r, i, l) {
        this.property = r, this.value = i, this.parameters = l;
      };
      ji.prototype.isConstant = function() {
        return this.value.kind === "constant";
      }, ji.prototype.constantOr = function(r) {
        return this.value.kind === "constant" ? this.value.value : r;
      }, ji.prototype.evaluate = function(r, i, l, p) {
        return this.property.evaluate(this.value, this.parameters, r, i, l, p);
      };
      var ic = function(r) {
        this._properties = r, this._values = Object.create(r.defaultPossiblyEvaluatedValues);
      };
      ic.prototype.get = function(r) {
        return this._values[r];
      };
      var Lt = function(r) {
        this.specification = r;
      };
      Lt.prototype.possiblyEvaluate = function(r, i) {
        return r.expression.evaluate(i);
      }, Lt.prototype.interpolate = function(r, i, l) {
        var p = Wl[this.specification.type];
        return p ? p(r, i, l) : r;
      };
      var Tt = function(r, i) {
        this.specification = r, this.overrides = i;
      };
      Tt.prototype.possiblyEvaluate = function(r, i, l, p) {
        return new ji(this, r.expression.kind === "constant" || r.expression.kind === "camera" ? { kind: "constant", value: r.expression.evaluate(i, null, {}, l, p) } : r.expression, i);
      }, Tt.prototype.interpolate = function(r, i, l) {
        if (r.value.kind !== "constant" || i.value.kind !== "constant")
          return r;
        if (r.value.value === void 0 || i.value.value === void 0)
          return new ji(this, { kind: "constant", value: void 0 }, r.parameters);
        var p = Wl[this.specification.type];
        return p ? new ji(this, { kind: "constant", value: p(r.value.value, i.value.value, l) }, r.parameters) : r;
      }, Tt.prototype.evaluate = function(r, i, l, p, y, v) {
        return r.kind === "constant" ? r.value : r.evaluate(i, l, p, y, v);
      };
      var vh = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.possiblyEvaluate = function(l, p, y, v) {
          if (l.value === void 0)
            return new ji(this, { kind: "constant", value: void 0 }, p);
          if (l.expression.kind === "constant") {
            var x = l.expression.evaluate(p, null, {}, y, v), S = l.property.specification.type === "resolvedImage" && typeof x != "string" ? x.name : x, C = this._calculate(S, S, S, p);
            return new ji(this, { kind: "constant", value: C }, p);
          }
          if (l.expression.kind === "camera") {
            var P = this._calculate(l.expression.evaluate({ zoom: p.zoom - 1 }), l.expression.evaluate({ zoom: p.zoom }), l.expression.evaluate({ zoom: p.zoom + 1 }), p);
            return new ji(this, { kind: "constant", value: P }, p);
          }
          return new ji(this, l.expression, p);
        }, i.prototype.evaluate = function(l, p, y, v, x, S) {
          if (l.kind === "source") {
            var C = l.evaluate(p, y, v, x, S);
            return this._calculate(C, C, C, p);
          }
          return l.kind === "composite" ? this._calculate(l.evaluate({ zoom: Math.floor(p.zoom) - 1 }, y, v), l.evaluate({ zoom: Math.floor(p.zoom) }, y, v), l.evaluate({ zoom: Math.floor(p.zoom) + 1 }, y, v), p) : l.value;
        }, i.prototype._calculate = function(l, p, y, v) {
          return v.zoom > v.zoomHistory.lastIntegerZoom ? { from: l, to: p } : { from: y, to: p };
        }, i.prototype.interpolate = function(l) {
          return l;
        }, i;
      }(Tt), Gi = function(r) {
        this.specification = r;
      };
      Gi.prototype.possiblyEvaluate = function(r, i, l, p) {
        if (r.value !== void 0) {
          if (r.expression.kind === "constant") {
            var y = r.expression.evaluate(i, null, {}, l, p);
            return this._calculate(y, y, y, i);
          }
          return this._calculate(r.expression.evaluate(new pr(Math.floor(i.zoom - 1), i)), r.expression.evaluate(new pr(Math.floor(i.zoom), i)), r.expression.evaluate(new pr(Math.floor(i.zoom + 1), i)), i);
        }
      }, Gi.prototype._calculate = function(r, i, l, p) {
        return p.zoom > p.zoomHistory.lastIntegerZoom ? { from: r, to: i } : { from: l, to: i };
      }, Gi.prototype.interpolate = function(r) {
        return r;
      };
      var ua = function(r) {
        this.specification = r;
      };
      ua.prototype.possiblyEvaluate = function(r, i, l, p) {
        return !!r.expression.evaluate(i, null, {}, l, p);
      }, ua.prototype.interpolate = function() {
        return !1;
      };
      var Mi = function(r) {
        for (var i in this.properties = r, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], r) {
          var l = r[i];
          l.specification.overridable && this.overridableProperties.push(i);
          var p = this.defaultPropertyValues[i] = new xa(l, void 0), y = this.defaultTransitionablePropertyValues[i] = new Wo(l);
          this.defaultTransitioningPropertyValues[i] = y.untransitioned(), this.defaultPossiblyEvaluatedValues[i] = p.possiblyEvaluate({});
        }
      };
      wt("DataDrivenProperty", Tt), wt("DataConstantProperty", Lt), wt("CrossFadedDataDrivenProperty", vh), wt("CrossFadedProperty", Gi), wt("ColorRampProperty", ua);
      var ba = function(r) {
        function i(l, p) {
          if (r.call(this), this.id = l.id, this.type = l.type, this._featureFilter = { filter: function() {
            return !0;
          }, needGeometry: !1 }, l.type !== "custom" && (this.metadata = (l = l).metadata, this.minzoom = l.minzoom, this.maxzoom = l.maxzoom, l.type !== "background" && (this.source = l.source, this.sourceLayer = l["source-layer"], this.filter = l.filter), p.layout && (this._unevaluatedLayout = new la(p.layout)), p.paint)) {
            for (var y in this._transitionablePaint = new Ti(p.paint), l.paint)
              this.setPaintProperty(y, l.paint[y], { validate: !1 });
            for (var v in l.layout)
              this.setLayoutProperty(v, l.layout[v], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new ic(p.paint);
          }
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getCrossfadeParameters = function() {
          return this._crossfadeParameters;
        }, i.prototype.getLayoutProperty = function(l) {
          return l === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(l);
        }, i.prototype.setLayoutProperty = function(l, p, y) {
          y === void 0 && (y = {}), p != null && this._validate(ec, "layers." + this.id + ".layout." + l, l, p, y) || (l !== "visibility" ? this._unevaluatedLayout.setValue(l, p) : this.visibility = p);
        }, i.prototype.getPaintProperty = function(l) {
          return Re(l, "-transition") ? this._transitionablePaint.getTransition(l.slice(0, -11)) : this._transitionablePaint.getValue(l);
        }, i.prototype.setPaintProperty = function(l, p, y) {
          if (y === void 0 && (y = {}), p != null && this._validate(Wv, "layers." + this.id + ".paint." + l, l, p, y))
            return !1;
          if (Re(l, "-transition"))
            return this._transitionablePaint.setTransition(l.slice(0, -11), p || void 0), !1;
          var v = this._transitionablePaint._values[l], x = v.property.specification["property-type"] === "cross-faded-data-driven", S = v.value.isDataDriven(), C = v.value;
          this._transitionablePaint.setValue(l, p), this._handleSpecialPaintPropertyUpdate(l);
          var P = this._transitionablePaint._values[l].value;
          return P.isDataDriven() || S || x || this._handleOverridablePaintPropertyUpdate(l, C, P);
        }, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
        }, i.prototype._handleOverridablePaintPropertyUpdate = function(l, p, y) {
          return !1;
        }, i.prototype.isHidden = function(l) {
          return !!(this.minzoom && l < this.minzoom) || !!(this.maxzoom && l >= this.maxzoom) || this.visibility === "none";
        }, i.prototype.updateTransitions = function(l) {
          this._transitioningPaint = this._transitionablePaint.transitioned(l, this._transitioningPaint);
        }, i.prototype.hasTransition = function() {
          return this._transitioningPaint.hasTransition();
        }, i.prototype.recalculate = function(l, p) {
          l.getCrossfadeParameters && (this._crossfadeParameters = l.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(l, void 0, p)), this.paint = this._transitioningPaint.possiblyEvaluate(l, void 0, p);
        }, i.prototype.serialize = function() {
          var l = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (l.layout = l.layout || {}, l.layout.visibility = this.visibility), ze(l, function(p, y) {
            return !(p === void 0 || y === "layout" && !Object.keys(p).length || y === "paint" && !Object.keys(p).length);
          });
        }, i.prototype._validate = function(l, p, y, v, x) {
          return x === void 0 && (x = {}), (!x || x.validate !== !1) && tc(this, l.call(Qu, { key: p, layerType: this.type, objectKey: y, value: v, styleSpec: G, style: { glyphs: !0, sprite: !0 } }));
        }, i.prototype.is3D = function() {
          return !1;
        }, i.prototype.isTileClipped = function() {
          return !1;
        }, i.prototype.hasOffscreenPass = function() {
          return !1;
        }, i.prototype.resize = function() {
        }, i.prototype.isStateDependent = function() {
          for (var l in this.paint._values) {
            var p = this.paint.get(l);
            if (p instanceof ji && fl(p.property.specification) && (p.value.kind === "source" || p.value.kind === "composite") && p.value.isStateDependent)
              return !0;
          }
          return !1;
        }, i;
      }(fe), up = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, _h = function(r, i) {
        this._structArray = r, this._pos1 = i * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
      }, jr = function() {
        this.isTransferred = !1, this.capacity = -1, this.resize(0);
      };
      function yi(r, i) {
        i === void 0 && (i = 1);
        var l = 0, p = 0;
        return { members: r.map(function(y) {
          var v = up[y.type].BYTES_PER_ELEMENT, x = l = Lm(l, Math.max(i, v)), S = y.components || 1;
          return p = Math.max(p, v), l += v * S, { name: y.name, type: y.type, components: S, offset: x };
        }), size: Lm(l, Math.max(p, i)), alignment: i };
      }
      function Lm(r, i) {
        return Math.ceil(r / i) * i;
      }
      jr.serialize = function(r, i) {
        return r._trim(), i && (r.isTransferred = !0, i.push(r.arrayBuffer)), { length: r.length, arrayBuffer: r.arrayBuffer };
      }, jr.deserialize = function(r) {
        var i = Object.create(this.prototype);
        return i.arrayBuffer = r.arrayBuffer, i.length = r.length, i.capacity = r.arrayBuffer.byteLength / i.bytesPerElement, i._refreshViews(), i;
      }, jr.prototype._trim = function() {
        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
      }, jr.prototype.clear = function() {
        this.length = 0;
      }, jr.prototype.resize = function(r) {
        this.reserve(r), this.length = r;
      }, jr.prototype.reserve = function(r) {
        if (r > this.capacity) {
          this.capacity = Math.max(r, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
          var i = this.uint8;
          this._refreshViews(), i && this.uint8.set(i);
        }
      }, jr.prototype._refreshViews = function() {
        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
      };
      var gl = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.int16[v + 0] = p, this.int16[v + 1] = y, l;
        }, i;
      }(jr);
      gl.prototype.bytesPerElement = 4, wt("StructArrayLayout2i4", gl);
      var cp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 4 * l;
          return this.int16[S + 0] = p, this.int16[S + 1] = y, this.int16[S + 2] = v, this.int16[S + 3] = x, l;
        }, i;
      }(jr);
      cp.prototype.bytesPerElement = 8, wt("StructArrayLayout4i8", cp);
      var Ga = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var P = 6 * l;
          return this.int16[P + 0] = p, this.int16[P + 1] = y, this.int16[P + 2] = v, this.int16[P + 3] = x, this.int16[P + 4] = S, this.int16[P + 5] = C, l;
        }, i;
      }(jr);
      Ga.prototype.bytesPerElement = 12, wt("StructArrayLayout2i4i12", Ga);
      var po = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var P = 4 * l, L = 8 * l;
          return this.int16[P + 0] = p, this.int16[P + 1] = y, this.uint8[L + 4] = v, this.uint8[L + 5] = x, this.uint8[L + 6] = S, this.uint8[L + 7] = C, l;
        }, i;
      }(jr);
      po.prototype.bytesPerElement = 8, wt("StructArrayLayout2i4ub8", po);
      var Ql = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.float32[v + 0] = p, this.float32[v + 1] = y, l;
        }, i;
      }(jr);
      Ql.prototype.bytesPerElement = 8, wt("StructArrayLayout2f8", Ql);
      var wa = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, P, L, D) {
          var B = this.length;
          return this.resize(B + 1), this.emplace(B, l, p, y, v, x, S, C, P, L, D);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, P, L, D, B) {
          var j = 10 * l;
          return this.uint16[j + 0] = p, this.uint16[j + 1] = y, this.uint16[j + 2] = v, this.uint16[j + 3] = x, this.uint16[j + 4] = S, this.uint16[j + 5] = C, this.uint16[j + 6] = P, this.uint16[j + 7] = L, this.uint16[j + 8] = D, this.uint16[j + 9] = B, l;
        }, i;
      }(jr);
      wa.prototype.bytesPerElement = 20, wt("StructArrayLayout10ui20", wa);
      var xh = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, P, L, D, B, j) {
          var Q = this.length;
          return this.resize(Q + 1), this.emplace(Q, l, p, y, v, x, S, C, P, L, D, B, j);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, P, L, D, B, j, Q) {
          var te = 12 * l;
          return this.int16[te + 0] = p, this.int16[te + 1] = y, this.int16[te + 2] = v, this.int16[te + 3] = x, this.uint16[te + 4] = S, this.uint16[te + 5] = C, this.uint16[te + 6] = P, this.uint16[te + 7] = L, this.int16[te + 8] = D, this.int16[te + 9] = B, this.int16[te + 10] = j, this.int16[te + 11] = Q, l;
        }, i;
      }(jr);
      xh.prototype.bytesPerElement = 24, wt("StructArrayLayout4i4ui4i24", xh);
      var eu = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.float32[x + 0] = p, this.float32[x + 1] = y, this.float32[x + 2] = v, l;
        }, i;
      }(jr);
      eu.prototype.bytesPerElement = 12, wt("StructArrayLayout3f12", eu);
      var oc = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.uint32[1 * l + 0] = p, l;
        }, i;
      }(jr);
      oc.prototype.bytesPerElement = 4, wt("StructArrayLayout1ul4", oc);
      var hp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, P, L) {
          var D = this.length;
          return this.resize(D + 1), this.emplace(D, l, p, y, v, x, S, C, P, L);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, P, L, D) {
          var B = 10 * l, j = 5 * l;
          return this.int16[B + 0] = p, this.int16[B + 1] = y, this.int16[B + 2] = v, this.int16[B + 3] = x, this.int16[B + 4] = S, this.int16[B + 5] = C, this.uint32[j + 3] = P, this.uint16[B + 8] = L, this.uint16[B + 9] = D, l;
        }, i;
      }(jr);
      hp.prototype.bytesPerElement = 20, wt("StructArrayLayout6i1ul2ui20", hp);
      var tu = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var P = 6 * l;
          return this.int16[P + 0] = p, this.int16[P + 1] = y, this.int16[P + 2] = v, this.int16[P + 3] = x, this.int16[P + 4] = S, this.int16[P + 5] = C, l;
        }, i;
      }(jr);
      tu.prototype.bytesPerElement = 12, wt("StructArrayLayout2i2i2i12", tu);
      var vl = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x) {
          var S = this.length;
          return this.resize(S + 1), this.emplace(S, l, p, y, v, x);
        }, i.prototype.emplace = function(l, p, y, v, x, S) {
          var C = 4 * l, P = 8 * l;
          return this.float32[C + 0] = p, this.float32[C + 1] = y, this.float32[C + 2] = v, this.int16[P + 6] = x, this.int16[P + 7] = S, l;
        }, i;
      }(jr);
      vl.prototype.bytesPerElement = 16, wt("StructArrayLayout2f1f2i16", vl);
      var fp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 12 * l, C = 3 * l;
          return this.uint8[S + 0] = p, this.uint8[S + 1] = y, this.float32[C + 1] = v, this.float32[C + 2] = x, l;
        }, i;
      }(jr);
      fp.prototype.bytesPerElement = 12, wt("StructArrayLayout2ub2f12", fp);
      var Es = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.uint16[x + 0] = p, this.uint16[x + 1] = y, this.uint16[x + 2] = v, l;
        }, i;
      }(jr);
      Es.prototype.bytesPerElement = 6, wt("StructArrayLayout3ui6", Es);
      var Ss = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, P, L, D, B, j, Q, te, ue, oe, ge) {
          var be = this.length;
          return this.resize(be + 1), this.emplace(be, l, p, y, v, x, S, C, P, L, D, B, j, Q, te, ue, oe, ge);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, P, L, D, B, j, Q, te, ue, oe, ge, be) {
          var Se = 24 * l, Me = 12 * l, Fe = 48 * l;
          return this.int16[Se + 0] = p, this.int16[Se + 1] = y, this.uint16[Se + 2] = v, this.uint16[Se + 3] = x, this.uint32[Me + 2] = S, this.uint32[Me + 3] = C, this.uint32[Me + 4] = P, this.uint16[Se + 10] = L, this.uint16[Se + 11] = D, this.uint16[Se + 12] = B, this.float32[Me + 7] = j, this.float32[Me + 8] = Q, this.uint8[Fe + 36] = te, this.uint8[Fe + 37] = ue, this.uint8[Fe + 38] = oe, this.uint32[Me + 10] = ge, this.int16[Se + 22] = be, l;
        }, i;
      }(jr);
      Ss.prototype.bytesPerElement = 48, wt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ss);
      var bh = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, P, L, D, B, j, Q, te, ue, oe, ge, be, Se, Me, Fe, Xe, nt, At, pt, Nt, mt, or) {
          var $t = this.length;
          return this.resize($t + 1), this.emplace($t, l, p, y, v, x, S, C, P, L, D, B, j, Q, te, ue, oe, ge, be, Se, Me, Fe, Xe, nt, At, pt, Nt, mt, or);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, P, L, D, B, j, Q, te, ue, oe, ge, be, Se, Me, Fe, Xe, nt, At, pt, Nt, mt, or, $t) {
          var Mt = 34 * l, cr = 17 * l;
          return this.int16[Mt + 0] = p, this.int16[Mt + 1] = y, this.int16[Mt + 2] = v, this.int16[Mt + 3] = x, this.int16[Mt + 4] = S, this.int16[Mt + 5] = C, this.int16[Mt + 6] = P, this.int16[Mt + 7] = L, this.uint16[Mt + 8] = D, this.uint16[Mt + 9] = B, this.uint16[Mt + 10] = j, this.uint16[Mt + 11] = Q, this.uint16[Mt + 12] = te, this.uint16[Mt + 13] = ue, this.uint16[Mt + 14] = oe, this.uint16[Mt + 15] = ge, this.uint16[Mt + 16] = be, this.uint16[Mt + 17] = Se, this.uint16[Mt + 18] = Me, this.uint16[Mt + 19] = Fe, this.uint16[Mt + 20] = Xe, this.uint16[Mt + 21] = nt, this.uint16[Mt + 22] = At, this.uint32[cr + 12] = pt, this.float32[cr + 13] = Nt, this.float32[cr + 14] = mt, this.float32[cr + 15] = or, this.float32[cr + 16] = $t, l;
        }, i;
      }(jr);
      bh.prototype.bytesPerElement = 68, wt("StructArrayLayout8i15ui1ul4f68", bh);
      var Ts = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.float32[1 * l + 0] = p, l;
        }, i;
      }(jr);
      Ts.prototype.bytesPerElement = 4, wt("StructArrayLayout1f4", Ts);
      var Ho = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.int16[x + 0] = p, this.int16[x + 1] = y, this.int16[x + 2] = v, l;
        }, i;
      }(jr);
      Ho.prototype.bytesPerElement = 6, wt("StructArrayLayout3i6", Ho);
      var pp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 4 * l;
          return this.uint32[2 * l + 0] = p, this.uint16[x + 2] = y, this.uint16[x + 3] = v, l;
        }, i;
      }(jr);
      pp.prototype.bytesPerElement = 8, wt("StructArrayLayout1ul2ui8", pp);
      var ac = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.uint16[v + 0] = p, this.uint16[v + 1] = y, l;
        }, i;
      }(jr);
      ac.prototype.bytesPerElement = 4, wt("StructArrayLayout2ui4", ac);
      var dp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.uint16[1 * l + 0] = p, l;
        }, i;
      }(jr);
      dp.prototype.bytesPerElement = 2, wt("StructArrayLayout1ui2", dp);
      var wh = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 4 * l;
          return this.float32[S + 0] = p, this.float32[S + 1] = y, this.float32[S + 2] = v, this.float32[S + 3] = x, l;
        }, i;
      }(jr);
      wh.prototype.bytesPerElement = 16, wt("StructArrayLayout4f16", wh);
      var u = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorPointX: { configurable: !0 }, anchorPointY: { configurable: !0 }, x1: { configurable: !0 }, y1: { configurable: !0 }, x2: { configurable: !0 }, y2: { configurable: !0 }, featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 }, anchorPoint: { configurable: !0 } };
        return l.anchorPointX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorPointY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.x1.get = function() {
          return this._structArray.int16[this._pos2 + 2];
        }, l.y1.get = function() {
          return this._structArray.int16[this._pos2 + 3];
        }, l.x2.get = function() {
          return this._structArray.int16[this._pos2 + 4];
        }, l.y2.get = function() {
          return this._structArray.int16[this._pos2 + 5];
        }, l.featureIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 3];
        }, l.sourceLayerIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 8];
        }, l.bucketIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 9];
        }, l.anchorPoint.get = function() {
          return new T(this.anchorPointX, this.anchorPointY);
        }, Object.defineProperties(i.prototype, l), i;
      }(_h);
      u.prototype.size = 20;
      var h = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new u(this, l);
        }, i;
      }(hp);
      wt("CollisionBoxArray", h);
      var c = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, glyphStartIndex: { configurable: !0 }, numGlyphs: { configurable: !0 }, vertexStartIndex: { configurable: !0 }, lineStartIndex: { configurable: !0 }, lineLength: { configurable: !0 }, segment: { configurable: !0 }, lowerSize: { configurable: !0 }, upperSize: { configurable: !0 }, lineOffsetX: { configurable: !0 }, lineOffsetY: { configurable: !0 }, writingMode: { configurable: !0 }, placedOrientation: { configurable: !0 }, hidden: { configurable: !0 }, crossTileID: { configurable: !0 }, associatedIconIndex: { configurable: !0 } };
        return l.anchorX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.glyphStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 2];
        }, l.numGlyphs.get = function() {
          return this._structArray.uint16[this._pos2 + 3];
        }, l.vertexStartIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 2];
        }, l.lineStartIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 3];
        }, l.lineLength.get = function() {
          return this._structArray.uint32[this._pos4 + 4];
        }, l.segment.get = function() {
          return this._structArray.uint16[this._pos2 + 10];
        }, l.lowerSize.get = function() {
          return this._structArray.uint16[this._pos2 + 11];
        }, l.upperSize.get = function() {
          return this._structArray.uint16[this._pos2 + 12];
        }, l.lineOffsetX.get = function() {
          return this._structArray.float32[this._pos4 + 7];
        }, l.lineOffsetY.get = function() {
          return this._structArray.float32[this._pos4 + 8];
        }, l.writingMode.get = function() {
          return this._structArray.uint8[this._pos1 + 36];
        }, l.placedOrientation.get = function() {
          return this._structArray.uint8[this._pos1 + 37];
        }, l.placedOrientation.set = function(p) {
          this._structArray.uint8[this._pos1 + 37] = p;
        }, l.hidden.get = function() {
          return this._structArray.uint8[this._pos1 + 38];
        }, l.hidden.set = function(p) {
          this._structArray.uint8[this._pos1 + 38] = p;
        }, l.crossTileID.get = function() {
          return this._structArray.uint32[this._pos4 + 10];
        }, l.crossTileID.set = function(p) {
          this._structArray.uint32[this._pos4 + 10] = p;
        }, l.associatedIconIndex.get = function() {
          return this._structArray.int16[this._pos2 + 22];
        }, Object.defineProperties(i.prototype, l), i;
      }(_h);
      c.prototype.size = 48;
      var d = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new c(this, l);
        }, i;
      }(Ss);
      wt("PlacedSymbolArray", d);
      var _ = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, rightJustifiedTextSymbolIndex: { configurable: !0 }, centerJustifiedTextSymbolIndex: { configurable: !0 }, leftJustifiedTextSymbolIndex: { configurable: !0 }, verticalPlacedTextSymbolIndex: { configurable: !0 }, placedIconSymbolIndex: { configurable: !0 }, verticalPlacedIconSymbolIndex: { configurable: !0 }, key: { configurable: !0 }, textBoxStartIndex: { configurable: !0 }, textBoxEndIndex: { configurable: !0 }, verticalTextBoxStartIndex: { configurable: !0 }, verticalTextBoxEndIndex: { configurable: !0 }, iconBoxStartIndex: { configurable: !0 }, iconBoxEndIndex: { configurable: !0 }, verticalIconBoxStartIndex: { configurable: !0 }, verticalIconBoxEndIndex: { configurable: !0 }, featureIndex: { configurable: !0 }, numHorizontalGlyphVertices: { configurable: !0 }, numVerticalGlyphVertices: { configurable: !0 }, numIconVertices: { configurable: !0 }, numVerticalIconVertices: { configurable: !0 }, useRuntimeCollisionCircles: { configurable: !0 }, crossTileID: { configurable: !0 }, textBoxScale: { configurable: !0 }, textOffset0: { configurable: !0 }, textOffset1: { configurable: !0 }, collisionCircleDiameter: { configurable: !0 } };
        return l.anchorX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.rightJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 2];
        }, l.centerJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 3];
        }, l.leftJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 4];
        }, l.verticalPlacedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 5];
        }, l.placedIconSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 6];
        }, l.verticalPlacedIconSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 7];
        }, l.key.get = function() {
          return this._structArray.uint16[this._pos2 + 8];
        }, l.textBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 9];
        }, l.textBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 10];
        }, l.verticalTextBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 11];
        }, l.verticalTextBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 12];
        }, l.iconBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 13];
        }, l.iconBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 14];
        }, l.verticalIconBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 15];
        }, l.verticalIconBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 16];
        }, l.featureIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 17];
        }, l.numHorizontalGlyphVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 18];
        }, l.numVerticalGlyphVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 19];
        }, l.numIconVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 20];
        }, l.numVerticalIconVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 21];
        }, l.useRuntimeCollisionCircles.get = function() {
          return this._structArray.uint16[this._pos2 + 22];
        }, l.crossTileID.get = function() {
          return this._structArray.uint32[this._pos4 + 12];
        }, l.crossTileID.set = function(p) {
          this._structArray.uint32[this._pos4 + 12] = p;
        }, l.textBoxScale.get = function() {
          return this._structArray.float32[this._pos4 + 13];
        }, l.textOffset0.get = function() {
          return this._structArray.float32[this._pos4 + 14];
        }, l.textOffset1.get = function() {
          return this._structArray.float32[this._pos4 + 15];
        }, l.collisionCircleDiameter.get = function() {
          return this._structArray.float32[this._pos4 + 16];
        }, Object.defineProperties(i.prototype, l), i;
      }(_h);
      _.prototype.size = 68;
      var w = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new _(this, l);
        }, i;
      }(bh);
      wt("SymbolInstanceArray", w);
      var E = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getoffsetX = function(l) {
          return this.float32[1 * l + 0];
        }, i;
      }(Ts);
      wt("GlyphOffsetArray", E);
      var O = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getx = function(l) {
          return this.int16[3 * l + 0];
        }, i.prototype.gety = function(l) {
          return this.int16[3 * l + 1];
        }, i.prototype.gettileUnitDistanceFromAnchor = function(l) {
          return this.int16[3 * l + 2];
        }, i;
      }(Ho);
      wt("SymbolLineVertexArray", O);
      var k = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 } };
        return l.featureIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 0];
        }, l.sourceLayerIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 2];
        }, l.bucketIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 3];
        }, Object.defineProperties(i.prototype, l), i;
      }(_h);
      k.prototype.size = 8;
      var R = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new k(this, l);
        }, i;
      }(pp);
      wt("FeatureIndexArray", R);
      var q = yi([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, $ = function(r) {
        r === void 0 && (r = []), this.segments = r;
      };
      function W(r, i) {
        return 256 * (r = Z(Math.floor(r), 0, 255)) + Z(Math.floor(i), 0, 255);
      }
      $.prototype.prepareSegment = function(r, i, l, p) {
        var y = this.segments[this.segments.length - 1];
        return r > $.MAX_VERTEX_ARRAY_LENGTH && yt("Max vertices per segment is " + $.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + r), (!y || y.vertexLength + r > $.MAX_VERTEX_ARRAY_LENGTH || y.sortKey !== p) && (y = { vertexOffset: i.length, primitiveOffset: l.length, vertexLength: 0, primitiveLength: 0 }, p !== void 0 && (y.sortKey = p), this.segments.push(y)), y;
      }, $.prototype.get = function() {
        return this.segments;
      }, $.prototype.destroy = function() {
        for (var r = 0, i = this.segments; r < i.length; r += 1) {
          var l = i[r];
          for (var p in l.vaos)
            l.vaos[p].destroy();
        }
      }, $.simpleSegment = function(r, i, l, p) {
        return new $([{ vertexOffset: r, primitiveOffset: i, vertexLength: l, primitiveLength: p, vaos: {}, sortKey: 0 }]);
      }, $.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, wt("SegmentVector", $);
      var ne = yi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), re = m(function(r) {
        r.exports = function(i, l) {
          var p, y, v, x, S, C, P, L;
          for (y = i.length - (p = 3 & i.length), v = l, S = 3432918353, C = 461845907, L = 0; L < y; )
            P = 255 & i.charCodeAt(L) | (255 & i.charCodeAt(++L)) << 8 | (255 & i.charCodeAt(++L)) << 16 | (255 & i.charCodeAt(++L)) << 24, ++L, v = 27492 + (65535 & (x = 5 * (65535 & (v = (v ^= P = (65535 & (P = (P = (65535 & P) * S + (((P >>> 16) * S & 65535) << 16) & 4294967295) << 15 | P >>> 17)) * C + (((P >>> 16) * C & 65535) << 16) & 4294967295) << 13 | v >>> 19)) + ((5 * (v >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (x >>> 16) & 65535) << 16);
          switch (P = 0, p) {
            case 3:
              P ^= (255 & i.charCodeAt(L + 2)) << 16;
            case 2:
              P ^= (255 & i.charCodeAt(L + 1)) << 8;
            case 1:
              v ^= P = (65535 & (P = (P = (65535 & (P ^= 255 & i.charCodeAt(L))) * S + (((P >>> 16) * S & 65535) << 16) & 4294967295) << 15 | P >>> 17)) * C + (((P >>> 16) * C & 65535) << 16) & 4294967295;
          }
          return v ^= i.length, v = 2246822507 * (65535 & (v ^= v >>> 16)) + ((2246822507 * (v >>> 16) & 65535) << 16) & 4294967295, v = 3266489909 * (65535 & (v ^= v >>> 13)) + ((3266489909 * (v >>> 16) & 65535) << 16) & 4294967295, (v ^= v >>> 16) >>> 0;
        };
      }), se = m(function(r) {
        r.exports = function(i, l) {
          for (var p, y = i.length, v = l ^ y, x = 0; y >= 4; )
            p = 1540483477 * (65535 & (p = 255 & i.charCodeAt(x) | (255 & i.charCodeAt(++x)) << 8 | (255 & i.charCodeAt(++x)) << 16 | (255 & i.charCodeAt(++x)) << 24)) + ((1540483477 * (p >>> 16) & 65535) << 16), v = 1540483477 * (65535 & v) + ((1540483477 * (v >>> 16) & 65535) << 16) ^ (p = 1540483477 * (65535 & (p ^= p >>> 24)) + ((1540483477 * (p >>> 16) & 65535) << 16)), y -= 4, ++x;
          switch (y) {
            case 3:
              v ^= (255 & i.charCodeAt(x + 2)) << 16;
            case 2:
              v ^= (255 & i.charCodeAt(x + 1)) << 8;
            case 1:
              v = 1540483477 * (65535 & (v ^= 255 & i.charCodeAt(x))) + ((1540483477 * (v >>> 16) & 65535) << 16);
          }
          return v = 1540483477 * (65535 & (v ^= v >>> 13)) + ((1540483477 * (v >>> 16) & 65535) << 16), (v ^= v >>> 15) >>> 0;
        };
      }), J = re, ae = se;
      J.murmur3 = re, J.murmur2 = ae;
      var pe = function() {
        this.ids = [], this.positions = [], this.indexed = !1;
      };
      pe.prototype.add = function(r, i, l, p) {
        this.ids.push(Ce(r)), this.positions.push(i, l, p);
      }, pe.prototype.getPositions = function(r) {
        for (var i = Ce(r), l = 0, p = this.ids.length - 1; l < p; ) {
          var y = l + p >> 1;
          this.ids[y] >= i ? p = y : l = y + 1;
        }
        for (var v = []; this.ids[l] === i; )
          v.push({ index: this.positions[3 * l], start: this.positions[3 * l + 1], end: this.positions[3 * l + 2] }), l++;
        return v;
      }, pe.serialize = function(r, i) {
        var l = new Float64Array(r.ids), p = new Uint32Array(r.positions);
        return function y(v, x, S, C) {
          for (; S < C; ) {
            for (var P = v[S + C >> 1], L = S - 1, D = C + 1; ; ) {
              do
                L++;
              while (v[L] < P);
              do
                D--;
              while (v[D] > P);
              if (L >= D)
                break;
              Te(v, L, D), Te(x, 3 * L, 3 * D), Te(x, 3 * L + 1, 3 * D + 1), Te(x, 3 * L + 2, 3 * D + 2);
            }
            D - S < C - D ? (y(v, x, S, D), S = D + 1) : (y(v, x, D + 1, C), C = D);
          }
        }(l, p, 0, l.length - 1), i && i.push(l.buffer, p.buffer), { ids: l, positions: p };
      }, pe.deserialize = function(r) {
        var i = new pe();
        return i.ids = r.ids, i.positions = r.positions, i.indexed = !0, i;
      };
      var _e = Math.pow(2, 53) - 1;
      function Ce(r) {
        var i = +r;
        return !isNaN(i) && i <= _e ? i : J(String(r));
      }
      function Te(r, i, l) {
        var p = r[i];
        r[i] = r[l], r[l] = p;
      }
      wt("FeaturePositionMap", pe);
      var Ae = function(r, i) {
        this.gl = r.gl, this.location = i;
      }, je = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          this.current !== l && (this.current = l, this.gl.uniform1i(this.location, l));
        }, i;
      }(Ae), tt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          this.current !== l && (this.current = l, this.gl.uniform1f(this.location, l));
        }, i;
      }(Ae), Qe = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] || (this.current = l, this.gl.uniform2f(this.location, l[0], l[1]));
        }, i;
      }(Ae), gt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] && l[2] === this.current[2] || (this.current = l, this.gl.uniform3f(this.location, l[0], l[1], l[2]));
        }, i;
      }(Ae), Dt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0, 0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] && l[2] === this.current[2] && l[3] === this.current[3] || (this.current = l, this.gl.uniform4f(this.location, l[0], l[1], l[2], l[3]));
        }, i;
      }(Ae), Ft = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = Rr.transparent;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l.r === this.current.r && l.g === this.current.g && l.b === this.current.b && l.a === this.current.a || (this.current = l, this.gl.uniform4f(this.location, l.r, l.g, l.b, l.a));
        }, i;
      }(Ae), zt = new Float32Array(16), Tr = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = zt;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          if (l[12] !== this.current[12] || l[0] !== this.current[0])
            return this.current = l, void this.gl.uniformMatrix4fv(this.location, !1, l);
          for (var p = 1; p < 16; p++)
            if (l[p] !== this.current[p]) {
              this.current = l, this.gl.uniformMatrix4fv(this.location, !1, l);
              break;
            }
        }, i;
      }(Ae);
      function xt(r) {
        return [W(255 * r.r, 255 * r.g), W(255 * r.b, 255 * r.a)];
      }
      var Yt = function(r, i, l) {
        this.value = r, this.uniformNames = i.map(function(p) {
          return "u_" + p;
        }), this.type = l;
      };
      Yt.prototype.setUniform = function(r, i, l) {
        r.set(l.constantOr(this.value));
      }, Yt.prototype.getBinding = function(r, i, l) {
        return this.type === "color" ? new Ft(r, i) : new tt(r, i);
      };
      var ir = function(r, i) {
        this.uniformNames = i.map(function(l) {
          return "u_" + l;
        }), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
      };
      ir.prototype.setConstantPatternPositions = function(r, i) {
        this.pixelRatioFrom = i.pixelRatio, this.pixelRatioTo = r.pixelRatio, this.patternFrom = i.tlbr, this.patternTo = r.tlbr;
      }, ir.prototype.setUniform = function(r, i, l, p) {
        var y = p === "u_pattern_to" ? this.patternTo : p === "u_pattern_from" ? this.patternFrom : p === "u_pixel_ratio_to" ? this.pixelRatioTo : p === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
        y && r.set(y);
      }, ir.prototype.getBinding = function(r, i, l) {
        return l.substr(0, 9) === "u_pattern" ? new Dt(r, i) : new tt(r, i);
      };
      var Kt = function(r, i, l, p) {
        this.expression = r, this.type = l, this.maxValue = 0, this.paintVertexAttributes = i.map(function(y) {
          return { name: "a_" + y, type: "Float32", components: l === "color" ? 2 : 1, offset: 0 };
        }), this.paintVertexArray = new p();
      };
      Kt.prototype.populatePaintArray = function(r, i, l, p, y) {
        var v = this.paintVertexArray.length, x = this.expression.evaluate(new pr(0), i, {}, p, [], y);
        this.paintVertexArray.resize(r), this._setPaintValue(v, r, x);
      }, Kt.prototype.updatePaintArray = function(r, i, l, p) {
        var y = this.expression.evaluate({ zoom: 0 }, l, p);
        this._setPaintValue(r, i, y);
      }, Kt.prototype._setPaintValue = function(r, i, l) {
        if (this.type === "color")
          for (var p = xt(l), y = r; y < i; y++)
            this.paintVertexArray.emplace(y, p[0], p[1]);
        else {
          for (var v = r; v < i; v++)
            this.paintVertexArray.emplace(v, l);
          this.maxValue = Math.max(this.maxValue, Math.abs(l));
        }
      }, Kt.prototype.upload = function(r) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = r.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }, Kt.prototype.destroy = function() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      };
      var Xt = function(r, i, l, p, y, v) {
        this.expression = r, this.uniformNames = i.map(function(x) {
          return "u_" + x + "_t";
        }), this.type = l, this.useIntegerZoom = p, this.zoom = y, this.maxValue = 0, this.paintVertexAttributes = i.map(function(x) {
          return { name: "a_" + x, type: "Float32", components: l === "color" ? 4 : 2, offset: 0 };
        }), this.paintVertexArray = new v();
      };
      Xt.prototype.populatePaintArray = function(r, i, l, p, y) {
        var v = this.expression.evaluate(new pr(this.zoom), i, {}, p, [], y), x = this.expression.evaluate(new pr(this.zoom + 1), i, {}, p, [], y), S = this.paintVertexArray.length;
        this.paintVertexArray.resize(r), this._setPaintValue(S, r, v, x);
      }, Xt.prototype.updatePaintArray = function(r, i, l, p) {
        var y = this.expression.evaluate({ zoom: this.zoom }, l, p), v = this.expression.evaluate({ zoom: this.zoom + 1 }, l, p);
        this._setPaintValue(r, i, y, v);
      }, Xt.prototype._setPaintValue = function(r, i, l, p) {
        if (this.type === "color")
          for (var y = xt(l), v = xt(p), x = r; x < i; x++)
            this.paintVertexArray.emplace(x, y[0], y[1], v[0], v[1]);
        else {
          for (var S = r; S < i; S++)
            this.paintVertexArray.emplace(S, l, p);
          this.maxValue = Math.max(this.maxValue, Math.abs(l), Math.abs(p));
        }
      }, Xt.prototype.upload = function(r) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = r.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }, Xt.prototype.destroy = function() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }, Xt.prototype.setUniform = function(r, i) {
        var l = this.useIntegerZoom ? Math.floor(i.zoom) : i.zoom, p = Z(this.expression.interpolationFactor(l, this.zoom, this.zoom + 1), 0, 1);
        r.set(p);
      }, Xt.prototype.getBinding = function(r, i, l) {
        return new tt(r, i);
      };
      var nr = function(r, i, l, p, y, v) {
        this.expression = r, this.type = i, this.useIntegerZoom = l, this.zoom = p, this.layerId = v, this.zoomInPaintVertexArray = new y(), this.zoomOutPaintVertexArray = new y();
      };
      nr.prototype.populatePaintArray = function(r, i, l) {
        var p = this.zoomInPaintVertexArray.length;
        this.zoomInPaintVertexArray.resize(r), this.zoomOutPaintVertexArray.resize(r), this._setPaintValues(p, r, i.patterns && i.patterns[this.layerId], l);
      }, nr.prototype.updatePaintArray = function(r, i, l, p, y) {
        this._setPaintValues(r, i, l.patterns && l.patterns[this.layerId], y);
      }, nr.prototype._setPaintValues = function(r, i, l, p) {
        if (p && l) {
          var y = p[l.min], v = p[l.mid], x = p[l.max];
          if (y && v && x)
            for (var S = r; S < i; S++)
              this.zoomInPaintVertexArray.emplace(S, v.tl[0], v.tl[1], v.br[0], v.br[1], y.tl[0], y.tl[1], y.br[0], y.br[1], v.pixelRatio, y.pixelRatio), this.zoomOutPaintVertexArray.emplace(S, v.tl[0], v.tl[1], v.br[0], v.br[1], x.tl[0], x.tl[1], x.br[0], x.br[1], v.pixelRatio, x.pixelRatio);
        }
      }, nr.prototype.upload = function(r) {
        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = r.createVertexBuffer(this.zoomInPaintVertexArray, ne.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = r.createVertexBuffer(this.zoomOutPaintVertexArray, ne.members, this.expression.isStateDependent));
      }, nr.prototype.destroy = function() {
        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
      };
      var Ht = function(r, i, l) {
        this.binders = {}, this._buffers = [];
        var p = [];
        for (var y in r.paint._values)
          if (l(y)) {
            var v = r.paint.get(y);
            if (v instanceof ji && fl(v.property.specification)) {
              var x = si(y, r.type), S = v.value, C = v.property.specification.type, P = v.property.useIntegerZoom, L = v.property.specification["property-type"], D = L === "cross-faded" || L === "cross-faded-data-driven";
              if (S.kind === "constant")
                this.binders[y] = D ? new ir(S.value, x) : new Yt(S.value, x, C), p.push("/u_" + y);
              else if (S.kind === "source" || D) {
                var B = In(y, C, "source");
                this.binders[y] = D ? new nr(S, C, P, i, B, r.id) : new Kt(S, x, C, B), p.push("/a_" + y);
              } else {
                var j = In(y, C, "composite");
                this.binders[y] = new Xt(S, x, C, P, i, j), p.push("/z_" + y);
              }
            }
          }
        this.cacheKey = p.sort().join("");
      };
      Ht.prototype.getMaxValue = function(r) {
        var i = this.binders[r];
        return i instanceof Kt || i instanceof Xt ? i.maxValue : 0;
      }, Ht.prototype.populatePaintArrays = function(r, i, l, p, y) {
        for (var v in this.binders) {
          var x = this.binders[v];
          (x instanceof Kt || x instanceof Xt || x instanceof nr) && x.populatePaintArray(r, i, l, p, y);
        }
      }, Ht.prototype.setConstantPatternPositions = function(r, i) {
        for (var l in this.binders) {
          var p = this.binders[l];
          p instanceof ir && p.setConstantPatternPositions(r, i);
        }
      }, Ht.prototype.updatePaintArrays = function(r, i, l, p, y) {
        var v = !1;
        for (var x in r)
          for (var S = 0, C = i.getPositions(x); S < C.length; S += 1) {
            var P = C[S], L = l.feature(P.index);
            for (var D in this.binders) {
              var B = this.binders[D];
              if ((B instanceof Kt || B instanceof Xt || B instanceof nr) && B.expression.isStateDependent === !0) {
                var j = p.paint.get(D);
                B.expression = j.value, B.updatePaintArray(P.start, P.end, L, r[x], y), v = !0;
              }
            }
          }
        return v;
      }, Ht.prototype.defines = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          (l instanceof Yt || l instanceof ir) && r.push.apply(r, l.uniformNames.map(function(p) {
            return "#define HAS_UNIFORM_" + p;
          }));
        }
        return r;
      }, Ht.prototype.getBinderAttributes = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          if (l instanceof Kt || l instanceof Xt)
            for (var p = 0; p < l.paintVertexAttributes.length; p++)
              r.push(l.paintVertexAttributes[p].name);
          else if (l instanceof nr)
            for (var y = 0; y < ne.members.length; y++)
              r.push(ne.members[y].name);
        }
        return r;
      }, Ht.prototype.getBinderUniforms = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          if (l instanceof Yt || l instanceof ir || l instanceof Xt)
            for (var p = 0, y = l.uniformNames; p < y.length; p += 1)
              r.push(y[p]);
        }
        return r;
      }, Ht.prototype.getPaintVertexBuffers = function() {
        return this._buffers;
      }, Ht.prototype.getUniforms = function(r, i) {
        var l = [];
        for (var p in this.binders) {
          var y = this.binders[p];
          if (y instanceof Yt || y instanceof ir || y instanceof Xt)
            for (var v = 0, x = y.uniformNames; v < x.length; v += 1) {
              var S = x[v];
              if (i[S]) {
                var C = y.getBinding(r, i[S], S);
                l.push({ name: S, property: p, binding: C });
              }
            }
        }
        return l;
      }, Ht.prototype.setUniforms = function(r, i, l, p) {
        for (var y = 0, v = i; y < v.length; y += 1) {
          var x = v[y], S = x.name, C = x.property;
          this.binders[C].setUniform(x.binding, p, l.get(C), S);
        }
      }, Ht.prototype.updatePaintBuffers = function(r) {
        for (var i in this._buffers = [], this.binders) {
          var l = this.binders[i];
          if (r && l instanceof nr) {
            var p = r.fromScale === 2 ? l.zoomInPaintVertexBuffer : l.zoomOutPaintVertexBuffer;
            p && this._buffers.push(p);
          } else
            (l instanceof Kt || l instanceof Xt) && l.paintVertexBuffer && this._buffers.push(l.paintVertexBuffer);
        }
      }, Ht.prototype.upload = function(r) {
        for (var i in this.binders) {
          var l = this.binders[i];
          (l instanceof Kt || l instanceof Xt || l instanceof nr) && l.upload(r);
        }
        this.updatePaintBuffers();
      }, Ht.prototype.destroy = function() {
        for (var r in this.binders) {
          var i = this.binders[r];
          (i instanceof Kt || i instanceof Xt || i instanceof nr) && i.destroy();
        }
      };
      var qt = function(r, i, l) {
        l === void 0 && (l = function() {
          return !0;
        }), this.programConfigurations = {};
        for (var p = 0, y = r; p < y.length; p += 1) {
          var v = y[p];
          this.programConfigurations[v.id] = new Ht(v, i, l);
        }
        this.needsUpload = !1, this._featureMap = new pe(), this._bufferOffset = 0;
      };
      function si(r, i) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[r] || [r.replace(i + "-", "").replace(/-/g, "_")];
      }
      function In(r, i, l) {
        var p = { color: { source: Ql, composite: wh }, number: { source: Ts, composite: Ql } }, y = function(v) {
          return { "line-pattern": { source: wa, composite: wa }, "fill-pattern": { source: wa, composite: wa }, "fill-extrusion-pattern": { source: wa, composite: wa } }[v];
        }(r);
        return y && y[l] || p[i][l];
      }
      qt.prototype.populatePaintArrays = function(r, i, l, p, y, v) {
        for (var x in this.programConfigurations)
          this.programConfigurations[x].populatePaintArrays(r, i, p, y, v);
        i.id !== void 0 && this._featureMap.add(i.id, l, this._bufferOffset, r), this._bufferOffset = r, this.needsUpload = !0;
      }, qt.prototype.updatePaintArrays = function(r, i, l, p) {
        for (var y = 0, v = l; y < v.length; y += 1) {
          var x = v[y];
          this.needsUpload = this.programConfigurations[x.id].updatePaintArrays(r, this._featureMap, i, x, p) || this.needsUpload;
        }
      }, qt.prototype.get = function(r) {
        return this.programConfigurations[r];
      }, qt.prototype.upload = function(r) {
        if (this.needsUpload) {
          for (var i in this.programConfigurations)
            this.programConfigurations[i].upload(r);
          this.needsUpload = !1;
        }
      }, qt.prototype.destroy = function() {
        for (var r in this.programConfigurations)
          this.programConfigurations[r].destroy();
      }, wt("ConstantBinder", Yt), wt("CrossFadedConstantBinder", ir), wt("SourceExpressionBinder", Kt), wt("CrossFadedCompositeBinder", nr), wt("CompositeExpressionBinder", Xt), wt("ProgramConfiguration", Ht, { omit: ["_buffers"] }), wt("ProgramConfigurationSet", qt);
      var Li = Math.pow(2, 14) - 1, gi = -Li - 1;
      function Tn(r) {
        for (var i = 8192 / r.extent, l = r.loadGeometry(), p = 0; p < l.length; p++)
          for (var y = l[p], v = 0; v < y.length; v++) {
            var x = y[v], S = Math.round(x.x * i), C = Math.round(x.y * i);
            x.x = Z(S, gi, Li), x.y = Z(C, gi, Li), (S < x.x || S > x.x + 1 || C < x.y || C > x.y + 1) && yt("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        return l;
      }
      function Ln(r, i) {
        return { type: r.type, id: r.id, properties: r.properties, geometry: i ? Tn(r) : [] };
      }
      function mo(r, i, l, p, y) {
        r.emplaceBack(2 * i + (p + 1) / 2, 2 * l + (y + 1) / 2);
      }
      var qi = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.layoutVertexArray = new gl(), this.indexArray = new Es(), this.segments = new $(), this.programConfigurations = new qt(r.layers, r.zoom), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      function Ms(r, i) {
        for (var l = 0; l < r.length; l++)
          if (Ea(i, r[l]))
            return !0;
        for (var p = 0; p < i.length; p++)
          if (Ea(r, i[p]))
            return !0;
        return !!sc(r, i);
      }
      function Qi(r, i, l) {
        return !!Ea(r, i) || !!Is(i, r, l);
      }
      function ca(r, i) {
        if (r.length === 1)
          return lc(i, r[0]);
        for (var l = 0; l < i.length; l++)
          for (var p = i[l], y = 0; y < p.length; y++)
            if (Ea(r, p[y]))
              return !0;
        for (var v = 0; v < r.length; v++)
          if (lc(i, r[v]))
            return !0;
        for (var x = 0; x < i.length; x++)
          if (sc(r, i[x]))
            return !0;
        return !1;
      }
      function Zo(r, i, l) {
        if (r.length > 1) {
          if (sc(r, i))
            return !0;
          for (var p = 0; p < i.length; p++)
            if (Is(i[p], r, l))
              return !0;
        }
        for (var y = 0; y < r.length; y++)
          if (Is(r[y], i, l))
            return !0;
        return !1;
      }
      function sc(r, i) {
        if (r.length === 0 || i.length === 0)
          return !1;
        for (var l = 0; l < r.length - 1; l++)
          for (var p = r[l], y = r[l + 1], v = 0; v < i.length - 1; v++)
            if (ru(p, y, i[v], i[v + 1]))
              return !0;
        return !1;
      }
      function ru(r, i, l, p) {
        return xe(r, l, p) !== xe(i, l, p) && xe(r, i, l) !== xe(r, i, p);
      }
      function Is(r, i, l) {
        var p = l * l;
        if (i.length === 1)
          return r.distSqr(i[0]) < p;
        for (var y = 1; y < i.length; y++)
          if (nu(r, i[y - 1], i[y]) < p)
            return !0;
        return !1;
      }
      function nu(r, i, l) {
        var p = i.distSqr(l);
        if (p === 0)
          return r.distSqr(i);
        var y = ((r.x - i.x) * (l.x - i.x) + (r.y - i.y) * (l.y - i.y)) / p;
        return r.distSqr(y < 0 ? i : y > 1 ? l : l.sub(i)._mult(y)._add(i));
      }
      function lc(r, i) {
        for (var l, p, y, v = !1, x = 0; x < r.length; x++)
          for (var S = 0, C = (l = r[x]).length - 1; S < l.length; C = S++)
            (p = l[S]).y > i.y != (y = l[C]).y > i.y && i.x < (y.x - p.x) * (i.y - p.y) / (y.y - p.y) + p.x && (v = !v);
        return v;
      }
      function Ea(r, i) {
        for (var l = !1, p = 0, y = r.length - 1; p < r.length; y = p++) {
          var v = r[p], x = r[y];
          v.y > i.y != x.y > i.y && i.x < (x.x - v.x) * (i.y - v.y) / (x.y - v.y) + v.x && (l = !l);
        }
        return l;
      }
      function uc(r, i, l) {
        var p = l[0], y = l[2];
        if (r.x < p.x && i.x < p.x || r.x > y.x && i.x > y.x || r.y < p.y && i.y < p.y || r.y > y.y && i.y > y.y)
          return !1;
        var v = xe(r, i, l[0]);
        return v !== xe(r, i, l[1]) || v !== xe(r, i, l[2]) || v !== xe(r, i, l[3]);
      }
      function Sa(r, i, l) {
        var p = i.paint.get(r).value;
        return p.kind === "constant" ? p.value : l.programConfigurations.get(i.id).getMaxValue(r);
      }
      function li(r) {
        return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
      }
      function qa(r, i, l, p, y) {
        if (!i[0] && !i[1])
          return r;
        var v = T.convert(i)._mult(y);
        l === "viewport" && v._rotate(-p);
        for (var x = [], S = 0; S < r.length; S++)
          x.push(r[S].sub(v));
        return x;
      }
      qi.prototype.populate = function(r, i, l) {
        var p = this.layers[0], y = [], v = null;
        p.type === "circle" && (v = p.layout.get("circle-sort-key"));
        for (var x = 0, S = r; x < S.length; x += 1) {
          var C = S[x], P = C.feature, L = C.id, D = C.index, B = C.sourceLayerIndex, j = this.layers[0]._featureFilter.needGeometry, Q = Ln(P, j);
          if (this.layers[0]._featureFilter.filter(new pr(this.zoom), Q, l)) {
            var te = v ? v.evaluate(Q, {}, l) : void 0, ue = { id: L, properties: P.properties, type: P.type, sourceLayerIndex: B, index: D, geometry: j ? Q.geometry : Tn(P), patterns: {}, sortKey: te };
            y.push(ue);
          }
        }
        v && y.sort(function(nt, At) {
          return nt.sortKey - At.sortKey;
        });
        for (var oe = 0, ge = y; oe < ge.length; oe += 1) {
          var be = ge[oe], Se = be.geometry, Me = be.index, Fe = be.sourceLayerIndex, Xe = r[Me].feature;
          this.addFeature(be, Se, Me, l), i.featureIndex.insert(Xe, Se, Me, Fe, this.index);
        }
      }, qi.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, qi.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, qi.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, qi.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, q), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, qi.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, qi.prototype.addFeature = function(r, i, l, p) {
        for (var y = 0, v = i; y < v.length; y += 1)
          for (var x = 0, S = v[y]; x < S.length; x += 1) {
            var C = S[x], P = C.x, L = C.y;
            if (!(P < 0 || P >= 8192 || L < 0 || L >= 8192)) {
              var D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, r.sortKey), B = D.vertexLength;
              mo(this.layoutVertexArray, P, L, -1, -1), mo(this.layoutVertexArray, P, L, 1, -1), mo(this.layoutVertexArray, P, L, 1, 1), mo(this.layoutVertexArray, P, L, -1, 1), this.indexArray.emplaceBack(B, B + 1, B + 2), this.indexArray.emplaceBack(B, B + 3, B + 2), D.vertexLength += 4, D.primitiveLength += 2;
            }
          }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, {}, p);
      }, wt("CircleBucket", qi, { omit: ["layers"] });
      var Os = new Mi({ "circle-sort-key": new Tt(G.layout_circle["circle-sort-key"]) }), _l = { paint: new Mi({ "circle-radius": new Tt(G.paint_circle["circle-radius"]), "circle-color": new Tt(G.paint_circle["circle-color"]), "circle-blur": new Tt(G.paint_circle["circle-blur"]), "circle-opacity": new Tt(G.paint_circle["circle-opacity"]), "circle-translate": new Lt(G.paint_circle["circle-translate"]), "circle-translate-anchor": new Lt(G.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Lt(G.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Lt(G.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Tt(G.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Tt(G.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Tt(G.paint_circle["circle-stroke-opacity"]) }), layout: Os }, zr = typeof Float32Array < "u" ? Float32Array : Array;
      function Oo(r) {
        return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
      }
      function eo(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3], S = i[4], C = i[5], P = i[6], L = i[7], D = i[8], B = i[9], j = i[10], Q = i[11], te = i[12], ue = i[13], oe = i[14], ge = i[15], be = l[0], Se = l[1], Me = l[2], Fe = l[3];
        return r[0] = be * p + Se * S + Me * D + Fe * te, r[1] = be * y + Se * C + Me * B + Fe * ue, r[2] = be * v + Se * P + Me * j + Fe * oe, r[3] = be * x + Se * L + Me * Q + Fe * ge, r[4] = (be = l[4]) * p + (Se = l[5]) * S + (Me = l[6]) * D + (Fe = l[7]) * te, r[5] = be * y + Se * C + Me * B + Fe * ue, r[6] = be * v + Se * P + Me * j + Fe * oe, r[7] = be * x + Se * L + Me * Q + Fe * ge, r[8] = (be = l[8]) * p + (Se = l[9]) * S + (Me = l[10]) * D + (Fe = l[11]) * te, r[9] = be * y + Se * C + Me * B + Fe * ue, r[10] = be * v + Se * P + Me * j + Fe * oe, r[11] = be * x + Se * L + Me * Q + Fe * ge, r[12] = (be = l[12]) * p + (Se = l[13]) * S + (Me = l[14]) * D + (Fe = l[15]) * te, r[13] = be * y + Se * C + Me * B + Fe * ue, r[14] = be * v + Se * P + Me * j + Fe * oe, r[15] = be * x + Se * L + Me * Q + Fe * ge, r;
      }
      Math.hypot || (Math.hypot = function() {
        for (var r = arguments, i = 0, l = arguments.length; l--; )
          i += r[l] * r[l];
        return Math.sqrt(i);
      });
      var xl, Hv = eo;
      function Eh(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3];
        return r[0] = l[0] * p + l[4] * y + l[8] * v + l[12] * x, r[1] = l[1] * p + l[5] * y + l[9] * v + l[13] * x, r[2] = l[2] * p + l[6] * y + l[10] * v + l[14] * x, r[3] = l[3] * p + l[7] * y + l[11] * v + l[15] * x, r;
      }
      xl = new zr(3), zr != Float32Array && (xl[0] = 0, xl[1] = 0, xl[2] = 0), function() {
        var r = new zr(4);
        zr != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0);
      }();
      var Zv = (function() {
        var r = new zr(2);
        zr != Float32Array && (r[0] = 0, r[1] = 0);
      }(), function(r) {
        function i(l) {
          r.call(this, l, _l);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new qi(l);
        }, i.prototype.queryRadius = function(l) {
          var p = l;
          return Sa("circle-radius", this, p) + Sa("circle-stroke-width", this, p) + li(this.paint.get("circle-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C, P) {
          for (var L = qa(l, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), S.angle, C), D = this.paint.get("circle-radius").evaluate(p, y) + this.paint.get("circle-stroke-width").evaluate(p, y), B = this.paint.get("circle-pitch-alignment") === "map", j = B ? L : function(Xe, nt) {
            return Xe.map(function(At) {
              return cc(At, nt);
            });
          }(L, P), Q = B ? D * C : D, te = 0, ue = v; te < ue.length; te += 1)
            for (var oe = 0, ge = ue[te]; oe < ge.length; oe += 1) {
              var be = ge[oe], Se = B ? be : cc(be, P), Me = Q, Fe = Eh([], [be.x, be.y, 0, 1], P);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Me *= Fe[3] / S.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Me *= S.cameraToCenterDistance / Fe[3]), Qi(j, Se, Me))
                return !0;
            }
          return !1;
        }, i;
      }(ba));
      function cc(r, i) {
        var l = Eh([], [r.x, r.y, 0, 1], i);
        return new T(l[0] / l[3], l[1] / l[3]);
      }
      var Dm = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(qi);
      function iu(r, i, l, p) {
        var y = i.width, v = i.height;
        if (p) {
          if (p instanceof Uint8ClampedArray)
            p = new Uint8Array(p.buffer);
          else if (p.length !== y * v * l)
            throw new RangeError("mismatched image size");
        } else
          p = new Uint8Array(y * v * l);
        return r.width = y, r.height = v, r.data = p, r;
      }
      function Sh(r, i, l) {
        var p = i.width, y = i.height;
        if (p !== r.width || y !== r.height) {
          var v = iu({}, { width: p, height: y }, l);
          Xv(r, v, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r.width, p), height: Math.min(r.height, y) }, l), r.width = p, r.height = y, r.data = v.data;
        }
      }
      function Xv(r, i, l, p, y, v) {
        if (y.width === 0 || y.height === 0)
          return i;
        if (y.width > r.width || y.height > r.height || l.x > r.width - y.width || l.y > r.height - y.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (y.width > i.width || y.height > i.height || p.x > i.width - y.width || p.y > i.height - y.height)
          throw new RangeError("out of range destination coordinates for image copy");
        for (var x = r.data, S = i.data, C = 0; C < y.height; C++)
          for (var P = ((l.y + C) * r.width + l.x) * v, L = ((p.y + C) * i.width + p.x) * v, D = 0; D < y.width * v; D++)
            S[L + D] = x[P + D];
        return i;
      }
      wt("HeatmapBucket", Dm, { omit: ["layers"] });
      var hc = function(r, i) {
        iu(this, r, 1, i);
      };
      hc.prototype.resize = function(r) {
        Sh(this, r, 1);
      }, hc.prototype.clone = function() {
        return new hc({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }, hc.copy = function(r, i, l, p, y) {
        Xv(r, i, l, p, y, 1);
      };
      var yo = function(r, i) {
        iu(this, r, 4, i);
      };
      yo.prototype.resize = function(r) {
        Sh(this, r, 4);
      }, yo.prototype.replace = function(r, i) {
        i ? this.data.set(r) : this.data = r instanceof Uint8ClampedArray ? new Uint8Array(r.buffer) : r;
      }, yo.prototype.clone = function() {
        return new yo({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }, yo.copy = function(r, i, l, p, y) {
        Xv(r, i, l, p, y, 4);
      }, wt("AlphaImage", hc), wt("RGBAImage", yo);
      var AI = { paint: new Mi({ "heatmap-radius": new Tt(G.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Tt(G.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Lt(G.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ua(G.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Lt(G.paint_heatmap["heatmap-opacity"]) }) };
      function lx(r) {
        var i = {}, l = r.resolution || 256, p = r.clips ? r.clips.length : 1, y = r.image || new yo({ width: l, height: p }), v = function(Q, te, ue) {
          i[r.evaluationKey] = ue;
          var oe = r.expression.evaluate(i);
          y.data[Q + te + 0] = Math.floor(255 * oe.r / oe.a), y.data[Q + te + 1] = Math.floor(255 * oe.g / oe.a), y.data[Q + te + 2] = Math.floor(255 * oe.b / oe.a), y.data[Q + te + 3] = Math.floor(255 * oe.a);
        };
        if (r.clips)
          for (var x = 0, S = 0; x < p; ++x, S += 4 * l)
            for (var C = 0, P = 0; C < l; C++, P += 4) {
              var L = C / (l - 1), D = r.clips[x];
              v(S, P, D.start * (1 - L) + D.end * L);
            }
        else
          for (var B = 0, j = 0; B < l; B++, j += 4)
            v(0, j, B / (l - 1));
        return y;
      }
      var PI = function(r) {
        function i(l) {
          r.call(this, l, AI), this._updateColorRamp();
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new Dm(l);
        }, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
          l === "heatmap-color" && this._updateColorRamp();
        }, i.prototype._updateColorRamp = function() {
          this.colorRamp = lx({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }, i.prototype.resize = function() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }, i.prototype.queryRadius = function() {
          return 0;
        }, i.prototype.queryIntersectsFeature = function() {
          return !1;
        }, i.prototype.hasOffscreenPass = function() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }, i;
      }(ba), kI = { paint: new Mi({ "hillshade-illumination-direction": new Lt(G.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Lt(G.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Lt(G.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Lt(G.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Lt(G.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Lt(G.paint_hillshade["hillshade-accent-color"]) }) }, LI = function(r) {
        function i(l) {
          r.call(this, l, kI);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.hasOffscreenPass = function() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }, i;
      }(ba), DI = yi([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, Kv = Nm, NI = Nm;
      function Nm(r, i, l) {
        l = l || 2;
        var p, y, v, x, S, C, P, L = i && i.length, D = L ? i[0] * l : r.length, B = ux(r, 0, D, l, !0), j = [];
        if (!B || B.next === B.prev)
          return j;
        if (L && (B = function(te, ue, oe, ge) {
          var be, Se, Me, Fe = [];
          for (be = 0, Se = ue.length; be < Se; be++)
            (Me = ux(te, ue[be] * ge, be < Se - 1 ? ue[be + 1] * ge : te.length, ge, !1)) === Me.next && (Me.steiner = !0), Fe.push(GI(Me));
          for (Fe.sort(VI), be = 0; be < Fe.length; be++)
            UI(Fe[be], oe), oe = ou(oe, oe.next);
          return oe;
        }(r, i, B, l)), r.length > 80 * l) {
          p = v = r[0], y = x = r[1];
          for (var Q = l; Q < D; Q += l)
            (S = r[Q]) < p && (p = S), (C = r[Q + 1]) < y && (y = C), S > v && (v = S), C > x && (x = C);
          P = (P = Math.max(v - p, x - y)) !== 0 ? 1 / P : 0;
        }
        return mp(B, j, l, p, y, P), j;
      }
      function ux(r, i, l, p, y) {
        var v, x;
        if (y === Qv(r, i, l, p) > 0)
          for (v = i; v < l; v += p)
            x = fx(v, r[v], r[v + 1], x);
        else
          for (v = l - p; v >= i; v -= p)
            x = fx(v, r[v], r[v + 1], x);
        return x && Rm(x, x.next) && (gp(x), x = x.next), x;
      }
      function ou(r, i) {
        if (!r)
          return r;
        i || (i = r);
        var l, p = r;
        do
          if (l = !1, p.steiner || !Rm(p, p.next) && Qn(p.prev, p, p.next) !== 0)
            p = p.next;
          else {
            if (gp(p), (p = i = p.prev) === p.next)
              break;
            l = !0;
          }
        while (l || p !== i);
        return i;
      }
      function mp(r, i, l, p, y, v, x) {
        if (r) {
          !x && v && function(L, D, B, j) {
            var Q = L;
            do
              Q.z === null && (Q.z = Yv(Q.x, Q.y, D, B, j)), Q.prevZ = Q.prev, Q.nextZ = Q.next, Q = Q.next;
            while (Q !== L);
            Q.prevZ.nextZ = null, Q.prevZ = null, function(te) {
              var ue, oe, ge, be, Se, Me, Fe, Xe, nt = 1;
              do {
                for (oe = te, te = null, Se = null, Me = 0; oe; ) {
                  for (Me++, ge = oe, Fe = 0, ue = 0; ue < nt && (Fe++, ge = ge.nextZ); ue++)
                    ;
                  for (Xe = nt; Fe > 0 || Xe > 0 && ge; )
                    Fe !== 0 && (Xe === 0 || !ge || oe.z <= ge.z) ? (be = oe, oe = oe.nextZ, Fe--) : (be = ge, ge = ge.nextZ, Xe--), Se ? Se.nextZ = be : te = be, be.prevZ = Se, Se = be;
                  oe = ge;
                }
                Se.nextZ = null, nt *= 2;
              } while (Me > 1);
            }(Q);
          }(r, p, y, v);
          for (var S, C, P = r; r.prev !== r.next; )
            if (S = r.prev, C = r.next, v ? zI(r, p, y, v) : RI(r))
              i.push(S.i / l), i.push(r.i / l), i.push(C.i / l), gp(r), r = C.next, P = C.next;
            else if ((r = C) === P) {
              x ? x === 1 ? mp(r = FI(ou(r), i, l), i, l, p, y, v, 2) : x === 2 && BI(r, i, l, p, y, v) : mp(ou(r), i, l, p, y, v, 1);
              break;
            }
        }
      }
      function RI(r) {
        var i = r.prev, l = r, p = r.next;
        if (Qn(i, l, p) >= 0)
          return !1;
        for (var y = r.next.next; y !== r.prev; ) {
          if (Th(i.x, i.y, l.x, l.y, p.x, p.y, y.x, y.y) && Qn(y.prev, y, y.next) >= 0)
            return !1;
          y = y.next;
        }
        return !0;
      }
      function zI(r, i, l, p) {
        var y = r.prev, v = r, x = r.next;
        if (Qn(y, v, x) >= 0)
          return !1;
        for (var S = y.x > v.x ? y.x > x.x ? y.x : x.x : v.x > x.x ? v.x : x.x, C = y.y > v.y ? y.y > x.y ? y.y : x.y : v.y > x.y ? v.y : x.y, P = Yv(y.x < v.x ? y.x < x.x ? y.x : x.x : v.x < x.x ? v.x : x.x, y.y < v.y ? y.y < x.y ? y.y : x.y : v.y < x.y ? v.y : x.y, i, l, p), L = Yv(S, C, i, l, p), D = r.prevZ, B = r.nextZ; D && D.z >= P && B && B.z <= L; ) {
          if (D !== r.prev && D !== r.next && Th(y.x, y.y, v.x, v.y, x.x, x.y, D.x, D.y) && Qn(D.prev, D, D.next) >= 0 || (D = D.prevZ, B !== r.prev && B !== r.next && Th(y.x, y.y, v.x, v.y, x.x, x.y, B.x, B.y) && Qn(B.prev, B, B.next) >= 0))
            return !1;
          B = B.nextZ;
        }
        for (; D && D.z >= P; ) {
          if (D !== r.prev && D !== r.next && Th(y.x, y.y, v.x, v.y, x.x, x.y, D.x, D.y) && Qn(D.prev, D, D.next) >= 0)
            return !1;
          D = D.prevZ;
        }
        for (; B && B.z <= L; ) {
          if (B !== r.prev && B !== r.next && Th(y.x, y.y, v.x, v.y, x.x, x.y, B.x, B.y) && Qn(B.prev, B, B.next) >= 0)
            return !1;
          B = B.nextZ;
        }
        return !0;
      }
      function FI(r, i, l) {
        var p = r;
        do {
          var y = p.prev, v = p.next.next;
          !Rm(y, v) && cx(y, p, p.next, v) && yp(y, v) && yp(v, y) && (i.push(y.i / l), i.push(p.i / l), i.push(v.i / l), gp(p), gp(p.next), p = r = v), p = p.next;
        } while (p !== r);
        return ou(p);
      }
      function BI(r, i, l, p, y, v) {
        var x = r;
        do {
          for (var S = x.next.next; S !== x.prev; ) {
            if (x.i !== S.i && qI(x, S)) {
              var C = hx(x, S);
              return x = ou(x, x.next), C = ou(C, C.next), mp(x, i, l, p, y, v), void mp(C, i, l, p, y, v);
            }
            S = S.next;
          }
          x = x.next;
        } while (x !== r);
      }
      function VI(r, i) {
        return r.x - i.x;
      }
      function UI(r, i) {
        if (i = function(p, y) {
          var v, x = y, S = p.x, C = p.y, P = -1 / 0;
          do {
            if (C <= x.y && C >= x.next.y && x.next.y !== x.y) {
              var L = x.x + (C - x.y) * (x.next.x - x.x) / (x.next.y - x.y);
              if (L <= S && L > P) {
                if (P = L, L === S) {
                  if (C === x.y)
                    return x;
                  if (C === x.next.y)
                    return x.next;
                }
                v = x.x < x.next.x ? x : x.next;
              }
            }
            x = x.next;
          } while (x !== y);
          if (!v)
            return null;
          if (S === P)
            return v;
          var D, B = v, j = v.x, Q = v.y, te = 1 / 0;
          x = v;
          do
            S >= x.x && x.x >= j && S !== x.x && Th(C < Q ? S : P, C, j, Q, C < Q ? P : S, C, x.x, x.y) && (D = Math.abs(C - x.y) / (S - x.x), yp(x, p) && (D < te || D === te && (x.x > v.x || x.x === v.x && jI(v, x))) && (v = x, te = D)), x = x.next;
          while (x !== B);
          return v;
        }(r, i)) {
          var l = hx(i, r);
          ou(i, i.next), ou(l, l.next);
        }
      }
      function jI(r, i) {
        return Qn(r.prev, r, i.prev) < 0 && Qn(i.next, r, r.next) < 0;
      }
      function Yv(r, i, l, p, y) {
        return (r = 1431655765 & ((r = 858993459 & ((r = 252645135 & ((r = 16711935 & ((r = 32767 * (r - l) * y) | r << 8)) | r << 4)) | r << 2)) | r << 1)) | (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = 32767 * (i - p) * y) | i << 8)) | i << 4)) | i << 2)) | i << 1)) << 1;
      }
      function GI(r) {
        var i = r, l = r;
        do
          (i.x < l.x || i.x === l.x && i.y < l.y) && (l = i), i = i.next;
        while (i !== r);
        return l;
      }
      function Th(r, i, l, p, y, v, x, S) {
        return (y - x) * (i - S) - (r - x) * (v - S) >= 0 && (r - x) * (p - S) - (l - x) * (i - S) >= 0 && (l - x) * (v - S) - (y - x) * (p - S) >= 0;
      }
      function qI(r, i) {
        return r.next.i !== i.i && r.prev.i !== i.i && !function(l, p) {
          var y = l;
          do {
            if (y.i !== l.i && y.next.i !== l.i && y.i !== p.i && y.next.i !== p.i && cx(y, y.next, l, p))
              return !0;
            y = y.next;
          } while (y !== l);
          return !1;
        }(r, i) && (yp(r, i) && yp(i, r) && function(l, p) {
          var y = l, v = !1, x = (l.x + p.x) / 2, S = (l.y + p.y) / 2;
          do
            y.y > S != y.next.y > S && y.next.y !== y.y && x < (y.next.x - y.x) * (S - y.y) / (y.next.y - y.y) + y.x && (v = !v), y = y.next;
          while (y !== l);
          return v;
        }(r, i) && (Qn(r.prev, r, i.prev) || Qn(r, i.prev, i)) || Rm(r, i) && Qn(r.prev, r, r.next) > 0 && Qn(i.prev, i, i.next) > 0);
      }
      function Qn(r, i, l) {
        return (i.y - r.y) * (l.x - i.x) - (i.x - r.x) * (l.y - i.y);
      }
      function Rm(r, i) {
        return r.x === i.x && r.y === i.y;
      }
      function cx(r, i, l, p) {
        var y = Fm(Qn(r, i, l)), v = Fm(Qn(r, i, p)), x = Fm(Qn(l, p, r)), S = Fm(Qn(l, p, i));
        return y !== v && x !== S || !(y !== 0 || !zm(r, l, i)) || !(v !== 0 || !zm(r, p, i)) || !(x !== 0 || !zm(l, r, p)) || !(S !== 0 || !zm(l, i, p));
      }
      function zm(r, i, l) {
        return i.x <= Math.max(r.x, l.x) && i.x >= Math.min(r.x, l.x) && i.y <= Math.max(r.y, l.y) && i.y >= Math.min(r.y, l.y);
      }
      function Fm(r) {
        return r > 0 ? 1 : r < 0 ? -1 : 0;
      }
      function yp(r, i) {
        return Qn(r.prev, r, r.next) < 0 ? Qn(r, i, r.next) >= 0 && Qn(r, r.prev, i) >= 0 : Qn(r, i, r.prev) < 0 || Qn(r, r.next, i) < 0;
      }
      function hx(r, i) {
        var l = new Jv(r.i, r.x, r.y), p = new Jv(i.i, i.x, i.y), y = r.next, v = i.prev;
        return r.next = i, i.prev = r, l.next = y, y.prev = l, p.next = l, l.prev = p, v.next = p, p.prev = v, p;
      }
      function fx(r, i, l, p) {
        var y = new Jv(r, i, l);
        return p ? (y.next = p.next, y.prev = p, p.next.prev = y, p.next = y) : (y.prev = y, y.next = y), y;
      }
      function gp(r) {
        r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
      }
      function Jv(r, i, l) {
        this.i = r, this.x = i, this.y = l, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
      }
      function Qv(r, i, l, p) {
        for (var y = 0, v = i, x = l - p; v < l; v += p)
          y += (r[x] - r[v]) * (r[v + 1] + r[x + 1]), x = v;
        return y;
      }
      function $I(r, i, l, p, y) {
        (function v(x, S, C, P, L) {
          for (; P > C; ) {
            if (P - C > 600) {
              var D = P - C + 1, B = S - C + 1, j = Math.log(D), Q = 0.5 * Math.exp(2 * j / 3), te = 0.5 * Math.sqrt(j * Q * (D - Q) / D) * (B - D / 2 < 0 ? -1 : 1);
              v(x, S, Math.max(C, Math.floor(S - B * Q / D + te)), Math.min(P, Math.floor(S + (D - B) * Q / D + te)), L);
            }
            var ue = x[S], oe = C, ge = P;
            for (vp(x, C, S), L(x[P], ue) > 0 && vp(x, C, P); oe < ge; ) {
              for (vp(x, oe, ge), oe++, ge--; L(x[oe], ue) < 0; )
                oe++;
              for (; L(x[ge], ue) > 0; )
                ge--;
            }
            L(x[C], ue) === 0 ? vp(x, C, ge) : vp(x, ++ge, P), ge <= S && (C = ge + 1), S <= ge && (P = ge - 1);
          }
        })(r, i, l || 0, p || r.length - 1, y || WI);
      }
      function vp(r, i, l) {
        var p = r[i];
        r[i] = r[l], r[l] = p;
      }
      function WI(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function e_(r, i) {
        var l = r.length;
        if (l <= 1)
          return [r];
        for (var p, y, v = [], x = 0; x < l; x++) {
          var S = Ke(r[x]);
          S !== 0 && (r[x].area = Math.abs(S), y === void 0 && (y = S < 0), y === S < 0 ? (p && v.push(p), p = [r[x]]) : p.push(r[x]));
        }
        if (p && v.push(p), i > 1)
          for (var C = 0; C < v.length; C++)
            v[C].length <= i || ($I(v[C], i, 1, v[C].length - 1, HI), v[C] = v[C].slice(0, i));
        return v;
      }
      function HI(r, i) {
        return i.area - r.area;
      }
      function t_(r, i, l) {
        for (var p = l.patternDependencies, y = !1, v = 0, x = i; v < x.length; v += 1) {
          var S = x[v].paint.get(r + "-pattern");
          S.isConstant() || (y = !0);
          var C = S.constantOr(null);
          C && (y = !0, p[C.to] = !0, p[C.from] = !0);
        }
        return y;
      }
      function r_(r, i, l, p, y) {
        for (var v = y.patternDependencies, x = 0, S = i; x < S.length; x += 1) {
          var C = S[x], P = C.paint.get(r + "-pattern").value;
          if (P.kind !== "constant") {
            var L = P.evaluate({ zoom: p - 1 }, l, {}, y.availableImages), D = P.evaluate({ zoom: p }, l, {}, y.availableImages), B = P.evaluate({ zoom: p + 1 }, l, {}, y.availableImages);
            D = D && D.name ? D.name : D, B = B && B.name ? B.name : B, v[L = L && L.name ? L.name : L] = !0, v[D] = !0, v[B] = !0, l.patterns[C.id] = { min: L, mid: D, max: B };
          }
        }
        return l;
      }
      Nm.deviation = function(r, i, l, p) {
        var y = i && i.length, v = Math.abs(Qv(r, 0, y ? i[0] * l : r.length, l));
        if (y)
          for (var x = 0, S = i.length; x < S; x++)
            v -= Math.abs(Qv(r, i[x] * l, x < S - 1 ? i[x + 1] * l : r.length, l));
        var C = 0;
        for (x = 0; x < p.length; x += 3) {
          var P = p[x] * l, L = p[x + 1] * l, D = p[x + 2] * l;
          C += Math.abs((r[P] - r[D]) * (r[L + 1] - r[P + 1]) - (r[P] - r[L]) * (r[D + 1] - r[P + 1]));
        }
        return v === 0 && C === 0 ? 0 : Math.abs((C - v) / v);
      }, Nm.flatten = function(r) {
        for (var i = r[0][0].length, l = { vertices: [], holes: [], dimensions: i }, p = 0, y = 0; y < r.length; y++) {
          for (var v = 0; v < r[y].length; v++)
            for (var x = 0; x < i; x++)
              l.vertices.push(r[y][v][x]);
          y > 0 && l.holes.push(p += r[y - 1].length);
        }
        return l;
      }, Kv.default = NI;
      var $a = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new gl(), this.indexArray = new Es(), this.indexArray2 = new ac(), this.programConfigurations = new qt(r.layers, r.zoom), this.segments = new $(), this.segments2 = new $(), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      $a.prototype.populate = function(r, i, l) {
        this.hasPattern = t_("fill", this.layers, i);
        for (var p = this.layers[0].layout.get("fill-sort-key"), y = [], v = 0, x = r; v < x.length; v += 1) {
          var S = x[v], C = S.feature, P = S.id, L = S.index, D = S.sourceLayerIndex, B = this.layers[0]._featureFilter.needGeometry, j = Ln(C, B);
          if (this.layers[0]._featureFilter.filter(new pr(this.zoom), j, l)) {
            var Q = p ? p.evaluate(j, {}, l, i.availableImages) : void 0, te = { id: P, properties: C.properties, type: C.type, sourceLayerIndex: D, index: L, geometry: B ? j.geometry : Tn(C), patterns: {}, sortKey: Q };
            y.push(te);
          }
        }
        p && y.sort(function(Xe, nt) {
          return Xe.sortKey - nt.sortKey;
        });
        for (var ue = 0, oe = y; ue < oe.length; ue += 1) {
          var ge = oe[ue], be = ge.geometry, Se = ge.index, Me = ge.sourceLayerIndex;
          if (this.hasPattern) {
            var Fe = r_("fill", this.layers, ge, this.zoom, i);
            this.patternFeatures.push(Fe);
          } else
            this.addFeature(ge, be, Se, l, {});
          i.featureIndex.insert(r[Se].feature, be, Se, Me, this.index);
        }
      }, $a.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, $a.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.patternFeatures; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, $a.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, $a.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, $a.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, DI), this.indexBuffer = r.createIndexBuffer(this.indexArray), this.indexBuffer2 = r.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, $a.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
      }, $a.prototype.addFeature = function(r, i, l, p, y) {
        for (var v = 0, x = e_(i, 500); v < x.length; v += 1) {
          for (var S = x[v], C = 0, P = 0, L = S; P < L.length; P += 1)
            C += L[P].length;
          for (var D = this.segments.prepareSegment(C, this.layoutVertexArray, this.indexArray), B = D.vertexLength, j = [], Q = [], te = 0, ue = S; te < ue.length; te += 1) {
            var oe = ue[te];
            if (oe.length !== 0) {
              oe !== S[0] && Q.push(j.length / 2);
              var ge = this.segments2.prepareSegment(oe.length, this.layoutVertexArray, this.indexArray2), be = ge.vertexLength;
              this.layoutVertexArray.emplaceBack(oe[0].x, oe[0].y), this.indexArray2.emplaceBack(be + oe.length - 1, be), j.push(oe[0].x), j.push(oe[0].y);
              for (var Se = 1; Se < oe.length; Se++)
                this.layoutVertexArray.emplaceBack(oe[Se].x, oe[Se].y), this.indexArray2.emplaceBack(be + Se - 1, be + Se), j.push(oe[Se].x), j.push(oe[Se].y);
              ge.vertexLength += oe.length, ge.primitiveLength += oe.length;
            }
          }
          for (var Me = Kv(j, Q), Fe = 0; Fe < Me.length; Fe += 3)
            this.indexArray.emplaceBack(B + Me[Fe], B + Me[Fe + 1], B + Me[Fe + 2]);
          D.vertexLength += C, D.primitiveLength += Me.length / 3;
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, wt("FillBucket", $a, { omit: ["layers", "patternFeatures"] });
      var ZI = new Mi({ "fill-sort-key": new Tt(G.layout_fill["fill-sort-key"]) }), XI = { paint: new Mi({ "fill-antialias": new Lt(G.paint_fill["fill-antialias"]), "fill-opacity": new Tt(G.paint_fill["fill-opacity"]), "fill-color": new Tt(G.paint_fill["fill-color"]), "fill-outline-color": new Tt(G.paint_fill["fill-outline-color"]), "fill-translate": new Lt(G.paint_fill["fill-translate"]), "fill-translate-anchor": new Lt(G.paint_fill["fill-translate-anchor"]), "fill-pattern": new vh(G.paint_fill["fill-pattern"]) }), layout: ZI }, KI = function(r) {
        function i(l) {
          r.call(this, l, XI);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.recalculate = function(l, p) {
          r.prototype.recalculate.call(this, l, p);
          var y = this.paint._values["fill-outline-color"];
          y.value.kind === "constant" && y.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }, i.prototype.createBucket = function(l) {
          return new $a(l);
        }, i.prototype.queryRadius = function() {
          return li(this.paint.get("fill-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C) {
          return ca(qa(l, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), S.angle, C), v);
        }, i.prototype.isTileClipped = function() {
          return !0;
        }, i;
      }(ba), YI = yi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4).members, px = Mh;
      function Mh(r, i, l, p, y) {
        this.properties = {}, this.extent = l, this.type = 0, this._pbf = r, this._geometry = -1, this._keys = p, this._values = y, r.readFields(JI, this, i);
      }
      function JI(r, i, l) {
        r == 1 ? i.id = l.readVarint() : r == 2 ? function(p, y) {
          for (var v = p.readVarint() + p.pos; p.pos < v; ) {
            var x = y._keys[p.readVarint()], S = y._values[p.readVarint()];
            y.properties[x] = S;
          }
        }(l, i) : r == 3 ? i.type = l.readVarint() : r == 4 && (i._geometry = l.pos);
      }
      function QI(r) {
        for (var i, l, p = 0, y = 0, v = r.length, x = v - 1; y < v; x = y++)
          p += ((l = r[x]).x - (i = r[y]).x) * (i.y + l.y);
        return p;
      }
      Mh.types = ["Unknown", "Point", "LineString", "Polygon"], Mh.prototype.loadGeometry = function() {
        var r = this._pbf;
        r.pos = this._geometry;
        for (var i, l = r.readVarint() + r.pos, p = 1, y = 0, v = 0, x = 0, S = []; r.pos < l; ) {
          if (y <= 0) {
            var C = r.readVarint();
            p = 7 & C, y = C >> 3;
          }
          if (y--, p === 1 || p === 2)
            v += r.readSVarint(), x += r.readSVarint(), p === 1 && (i && S.push(i), i = []), i.push(new T(v, x));
          else {
            if (p !== 7)
              throw new Error("unknown command " + p);
            i && i.push(i[0].clone());
          }
        }
        return i && S.push(i), S;
      }, Mh.prototype.bbox = function() {
        var r = this._pbf;
        r.pos = this._geometry;
        for (var i = r.readVarint() + r.pos, l = 1, p = 0, y = 0, v = 0, x = 1 / 0, S = -1 / 0, C = 1 / 0, P = -1 / 0; r.pos < i; ) {
          if (p <= 0) {
            var L = r.readVarint();
            l = 7 & L, p = L >> 3;
          }
          if (p--, l === 1 || l === 2)
            (y += r.readSVarint()) < x && (x = y), y > S && (S = y), (v += r.readSVarint()) < C && (C = v), v > P && (P = v);
          else if (l !== 7)
            throw new Error("unknown command " + l);
        }
        return [x, C, S, P];
      }, Mh.prototype.toGeoJSON = function(r, i, l) {
        var p, y, v = this.extent * Math.pow(2, l), x = this.extent * r, S = this.extent * i, C = this.loadGeometry(), P = Mh.types[this.type];
        function L(j) {
          for (var Q = 0; Q < j.length; Q++) {
            var te = j[Q];
            j[Q] = [360 * (te.x + x) / v - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (te.y + S) / v) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var D = [];
            for (p = 0; p < C.length; p++)
              D[p] = C[p][0];
            L(C = D);
            break;
          case 2:
            for (p = 0; p < C.length; p++)
              L(C[p]);
            break;
          case 3:
            for (C = function(j) {
              var Q = j.length;
              if (Q <= 1)
                return [j];
              for (var te, ue, oe = [], ge = 0; ge < Q; ge++) {
                var be = QI(j[ge]);
                be !== 0 && (ue === void 0 && (ue = be < 0), ue === be < 0 ? (te && oe.push(te), te = [j[ge]]) : te.push(j[ge]));
              }
              return te && oe.push(te), oe;
            }(C), p = 0; p < C.length; p++)
              for (y = 0; y < C[p].length; y++)
                L(C[p][y]);
        }
        C.length === 1 ? C = C[0] : P = "Multi" + P;
        var B = { type: "Feature", geometry: { type: P, coordinates: C }, properties: this.properties };
        return "id" in this && (B.id = this.id), B;
      };
      var dx = mx;
      function mx(r, i) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = r, this._keys = [], this._values = [], this._features = [], r.readFields(eO, this, i), this.length = this._features.length;
      }
      function eO(r, i, l) {
        r === 15 ? i.version = l.readVarint() : r === 1 ? i.name = l.readString() : r === 5 ? i.extent = l.readVarint() : r === 2 ? i._features.push(l.pos) : r === 3 ? i._keys.push(l.readString()) : r === 4 && i._values.push(function(p) {
          for (var y = null, v = p.readVarint() + p.pos; p.pos < v; ) {
            var x = p.readVarint() >> 3;
            y = x === 1 ? p.readString() : x === 2 ? p.readFloat() : x === 3 ? p.readDouble() : x === 4 ? p.readVarint64() : x === 5 ? p.readVarint() : x === 6 ? p.readSVarint() : x === 7 ? p.readBoolean() : null;
          }
          return y;
        }(l));
      }
      function tO(r, i, l) {
        if (r === 3) {
          var p = new dx(l, l.readVarint() + l.pos);
          p.length && (i[p.name] = p);
        }
      }
      mx.prototype.feature = function(r) {
        if (r < 0 || r >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[r];
        var i = this._pbf.readVarint() + this._pbf.pos;
        return new px(this._pbf, i, this.extent, this._keys, this._values);
      };
      var Ih = { VectorTile: function(r, i) {
        this.layers = r.readFields(tO, {}, i);
      }, VectorTileFeature: px, VectorTileLayer: dx }, rO = Ih.VectorTileFeature.types, n_ = Math.pow(2, 13);
      function _p(r, i, l, p, y, v, x, S) {
        r.emplaceBack(i, l, 2 * Math.floor(p * n_) + x, y * n_ * 2, v * n_ * 2, Math.round(S));
      }
      var Wa = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.layoutVertexArray = new Ga(), this.indexArray = new Es(), this.programConfigurations = new qt(r.layers, r.zoom), this.segments = new $(), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      function nO(r, i) {
        return r.x === i.x && (r.x < 0 || r.x > 8192) || r.y === i.y && (r.y < 0 || r.y > 8192);
      }
      Wa.prototype.populate = function(r, i, l) {
        this.features = [], this.hasPattern = t_("fill-extrusion", this.layers, i);
        for (var p = 0, y = r; p < y.length; p += 1) {
          var v = y[p], x = v.feature, S = v.id, C = v.index, P = v.sourceLayerIndex, L = this.layers[0]._featureFilter.needGeometry, D = Ln(x, L);
          if (this.layers[0]._featureFilter.filter(new pr(this.zoom), D, l)) {
            var B = { id: S, sourceLayerIndex: P, index: C, geometry: L ? D.geometry : Tn(x), properties: x.properties, type: x.type, patterns: {} };
            this.hasPattern ? this.features.push(r_("fill-extrusion", this.layers, B, this.zoom, i)) : this.addFeature(B, B.geometry, C, l, {}), i.featureIndex.insert(x, B.geometry, C, P, this.index, !0);
          }
        }
      }, Wa.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.features; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, Wa.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, Wa.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, Wa.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, Wa.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, YI), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, Wa.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, Wa.prototype.addFeature = function(r, i, l, p, y) {
        for (var v = 0, x = e_(i, 500); v < x.length; v += 1) {
          for (var S = x[v], C = 0, P = 0, L = S; P < L.length; P += 1)
            C += L[P].length;
          for (var D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), B = 0, j = S; B < j.length; B += 1) {
            var Q = j[B];
            if (Q.length !== 0 && !((cr = Q).every(function(rr) {
              return rr.x < 0;
            }) || cr.every(function(rr) {
              return rr.x > 8192;
            }) || cr.every(function(rr) {
              return rr.y < 0;
            }) || cr.every(function(rr) {
              return rr.y > 8192;
            })))
              for (var te = 0, ue = 0; ue < Q.length; ue++) {
                var oe = Q[ue];
                if (ue >= 1) {
                  var ge = Q[ue - 1];
                  if (!nO(oe, ge)) {
                    D.vertexLength + 4 > $.MAX_VERTEX_ARRAY_LENGTH && (D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    var be = oe.sub(ge)._perp()._unit(), Se = ge.dist(oe);
                    te + Se > 32768 && (te = 0), _p(this.layoutVertexArray, oe.x, oe.y, be.x, be.y, 0, 0, te), _p(this.layoutVertexArray, oe.x, oe.y, be.x, be.y, 0, 1, te), _p(this.layoutVertexArray, ge.x, ge.y, be.x, be.y, 0, 0, te += Se), _p(this.layoutVertexArray, ge.x, ge.y, be.x, be.y, 0, 1, te);
                    var Me = D.vertexLength;
                    this.indexArray.emplaceBack(Me, Me + 2, Me + 1), this.indexArray.emplaceBack(Me + 1, Me + 2, Me + 3), D.vertexLength += 4, D.primitiveLength += 2;
                  }
                }
              }
          }
          if (D.vertexLength + C > $.MAX_VERTEX_ARRAY_LENGTH && (D = this.segments.prepareSegment(C, this.layoutVertexArray, this.indexArray)), rO[r.type] === "Polygon") {
            for (var Fe = [], Xe = [], nt = D.vertexLength, At = 0, pt = S; At < pt.length; At += 1) {
              var Nt = pt[At];
              if (Nt.length !== 0) {
                Nt !== S[0] && Xe.push(Fe.length / 2);
                for (var mt = 0; mt < Nt.length; mt++) {
                  var or = Nt[mt];
                  _p(this.layoutVertexArray, or.x, or.y, 0, 0, 1, 1, 0), Fe.push(or.x), Fe.push(or.y);
                }
              }
            }
            for (var $t = Kv(Fe, Xe), Mt = 0; Mt < $t.length; Mt += 3)
              this.indexArray.emplaceBack(nt + $t[Mt], nt + $t[Mt + 2], nt + $t[Mt + 1]);
            D.primitiveLength += $t.length / 3, D.vertexLength += C;
          }
        }
        var cr;
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, wt("FillExtrusionBucket", Wa, { omit: ["layers", "features"] });
      var iO = { paint: new Mi({ "fill-extrusion-opacity": new Lt(G["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Tt(G["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Lt(G["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Lt(G["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new vh(G["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Tt(G["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Tt(G["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Lt(G["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) }, oO = function(r) {
        function i(l) {
          r.call(this, l, iO);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new Wa(l);
        }, i.prototype.queryRadius = function() {
          return li(this.paint.get("fill-extrusion-translate"));
        }, i.prototype.is3D = function() {
          return !0;
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C, P) {
          var L = qa(l, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), S.angle, C), D = this.paint.get("fill-extrusion-height").evaluate(p, y), B = this.paint.get("fill-extrusion-base").evaluate(p, y), j = function(te, ue, oe, ge) {
            for (var be = [], Se = 0, Me = te; Se < Me.length; Se += 1) {
              var Fe = Me[Se], Xe = [Fe.x, Fe.y, 0, 1];
              Eh(Xe, Xe, ue), be.push(new T(Xe[0] / Xe[3], Xe[1] / Xe[3]));
            }
            return be;
          }(L, P), Q = function(te, ue, oe, ge) {
            for (var be = [], Se = [], Me = ge[8] * ue, Fe = ge[9] * ue, Xe = ge[10] * ue, nt = ge[11] * ue, At = ge[8] * oe, pt = ge[9] * oe, Nt = ge[10] * oe, mt = ge[11] * oe, or = 0, $t = te; or < $t.length; or += 1) {
              for (var Mt = [], cr = [], rr = 0, Er = $t[or]; rr < Er.length; rr += 1) {
                var Rt = Er[rr], Pr = Rt.x, gn = Rt.y, On = ge[0] * Pr + ge[4] * gn + ge[12], Mn = ge[1] * Pr + ge[5] * gn + ge[13], vn = ge[2] * Pr + ge[6] * gn + ge[14], Cn = ge[3] * Pr + ge[7] * gn + ge[15], ui = vn + Xe, ci = Cn + nt, Wi = On + At, _i = Mn + pt, Hi = vn + Nt, Dn = Cn + mt, xi = new T((On + Me) / ci, (Mn + Fe) / ci);
                xi.z = ui / ci, Mt.push(xi);
                var gr = new T(Wi / Dn, _i / Dn);
                gr.z = Hi / Dn, cr.push(gr);
              }
              be.push(Mt), Se.push(cr);
            }
            return [be, Se];
          }(v, B, D, P);
          return function(te, ue, oe) {
            var ge = 1 / 0;
            ca(oe, ue) && (ge = yx(oe, ue[0]));
            for (var be = 0; be < ue.length; be++)
              for (var Se = ue[be], Me = te[be], Fe = 0; Fe < Se.length - 1; Fe++) {
                var Xe = Se[Fe], nt = [Xe, Se[Fe + 1], Me[Fe + 1], Me[Fe], Xe];
                Ms(oe, nt) && (ge = Math.min(ge, yx(oe, nt)));
              }
            return ge !== 1 / 0 && ge;
          }(Q[0], Q[1], j);
        }, i;
      }(ba);
      function xp(r, i) {
        return r.x * i.x + r.y * i.y;
      }
      function yx(r, i) {
        if (r.length === 1) {
          for (var l, p = 0, y = i[p++]; !l || y.equals(l); )
            if (!(l = i[p++]))
              return 1 / 0;
          for (; p < i.length; p++) {
            var v = i[p], x = r[0], S = l.sub(y), C = v.sub(y), P = x.sub(y), L = xp(S, S), D = xp(S, C), B = xp(C, C), j = xp(P, S), Q = xp(P, C), te = L * B - D * D, ue = (B * j - D * Q) / te, oe = (L * Q - D * j) / te, ge = y.z * (1 - ue - oe) + l.z * ue + v.z * oe;
            if (isFinite(ge))
              return ge;
          }
          return 1 / 0;
        }
        for (var be = 1 / 0, Se = 0, Me = i; Se < Me.length; Se += 1)
          be = Math.min(be, Me[Se].z);
        return be;
      }
      var aO = yi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4).members, sO = yi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]).members, lO = Ih.VectorTileFeature.types, uO = Math.cos(Math.PI / 180 * 37.5), gx = Math.pow(2, 14) / 0.5, to = function(r) {
        var i = this;
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(l) {
          return l.id;
        }), this.index = r.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(function(l) {
          i.gradients[l.id] = {};
        }), this.layoutVertexArray = new po(), this.layoutVertexArray2 = new Ql(), this.indexArray = new Es(), this.programConfigurations = new qt(r.layers, r.zoom), this.segments = new $(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(function(l) {
          return l.isStateDependent();
        }).map(function(l) {
          return l.id;
        });
      };
      to.prototype.populate = function(r, i, l) {
        this.hasPattern = t_("line", this.layers, i);
        for (var p = this.layers[0].layout.get("line-sort-key"), y = [], v = 0, x = r; v < x.length; v += 1) {
          var S = x[v], C = S.feature, P = S.id, L = S.index, D = S.sourceLayerIndex, B = this.layers[0]._featureFilter.needGeometry, j = Ln(C, B);
          if (this.layers[0]._featureFilter.filter(new pr(this.zoom), j, l)) {
            var Q = p ? p.evaluate(j, {}, l) : void 0, te = { id: P, properties: C.properties, type: C.type, sourceLayerIndex: D, index: L, geometry: B ? j.geometry : Tn(C), patterns: {}, sortKey: Q };
            y.push(te);
          }
        }
        p && y.sort(function(Xe, nt) {
          return Xe.sortKey - nt.sortKey;
        });
        for (var ue = 0, oe = y; ue < oe.length; ue += 1) {
          var ge = oe[ue], be = ge.geometry, Se = ge.index, Me = ge.sourceLayerIndex;
          if (this.hasPattern) {
            var Fe = r_("line", this.layers, ge, this.zoom, i);
            this.patternFeatures.push(Fe);
          } else
            this.addFeature(ge, be, Se, l, {});
          i.featureIndex.insert(r[Se].feature, be, Se, Me, this.index);
        }
      }, to.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, to.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.patternFeatures; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, to.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, to.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, to.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = r.createVertexBuffer(this.layoutVertexArray2, sO)), this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, aO), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, to.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, to.prototype.lineFeatureClips = function(r) {
        if (r.properties && r.properties.hasOwnProperty("mapbox_clip_start") && r.properties.hasOwnProperty("mapbox_clip_end"))
          return { start: +r.properties.mapbox_clip_start, end: +r.properties.mapbox_clip_end };
      }, to.prototype.addFeature = function(r, i, l, p, y) {
        var v = this.layers[0].layout, x = v.get("line-join").evaluate(r, {}), S = v.get("line-cap"), C = v.get("line-miter-limit"), P = v.get("line-round-limit");
        this.lineClips = this.lineFeatureClips(r);
        for (var L = 0, D = i; L < D.length; L += 1)
          this.addLine(D[L], r, x, S, C, P);
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, to.prototype.addLine = function(r, i, l, p, y, v) {
        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
          this.lineClipsArray.push(this.lineClips);
          for (var x = 0; x < r.length - 1; x++)
            this.totalDistance += r[x].dist(r[x + 1]);
          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
        }
        for (var S = lO[i.type] === "Polygon", C = r.length; C >= 2 && r[C - 1].equals(r[C - 2]); )
          C--;
        for (var P = 0; P < C - 1 && r[P].equals(r[P + 1]); )
          P++;
        if (!(C < (S ? 3 : 2))) {
          l === "bevel" && (y = 1.05);
          var L, D = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, B = this.segments.prepareSegment(10 * C, this.layoutVertexArray, this.indexArray), j = void 0, Q = void 0, te = void 0, ue = void 0;
          this.e1 = this.e2 = -1, S && (ue = r[P].sub(L = r[C - 2])._unit()._perp());
          for (var oe = P; oe < C; oe++)
            if (!(Q = oe === C - 1 ? S ? r[P + 1] : void 0 : r[oe + 1]) || !r[oe].equals(Q)) {
              ue && (te = ue), L && (j = L), L = r[oe], ue = Q ? Q.sub(L)._unit()._perp() : te;
              var ge = (te = te || ue).add(ue);
              ge.x === 0 && ge.y === 0 || ge._unit();
              var be = te.x * ue.x + te.y * ue.y, Se = ge.x * ue.x + ge.y * ue.y, Me = Se !== 0 ? 1 / Se : 1 / 0, Fe = 2 * Math.sqrt(2 - 2 * Se), Xe = Se < uO && j && Q, nt = te.x * ue.y - te.y * ue.x > 0;
              if (Xe && oe > P) {
                var At = L.dist(j);
                if (At > 2 * D) {
                  var pt = L.sub(L.sub(j)._mult(D / At)._round());
                  this.updateDistance(j, pt), this.addCurrentVertex(pt, te, 0, 0, B), j = pt;
                }
              }
              var Nt = j && Q, mt = Nt ? l : S ? "butt" : p;
              if (Nt && mt === "round" && (Me < v ? mt = "miter" : Me <= 2 && (mt = "fakeround")), mt === "miter" && Me > y && (mt = "bevel"), mt === "bevel" && (Me > 2 && (mt = "flipbevel"), Me < y && (mt = "miter")), j && this.updateDistance(j, L), mt === "miter")
                ge._mult(Me), this.addCurrentVertex(L, ge, 0, 0, B);
              else if (mt === "flipbevel") {
                if (Me > 100)
                  ge = ue.mult(-1);
                else {
                  var or = Me * te.add(ue).mag() / te.sub(ue).mag();
                  ge._perp()._mult(or * (nt ? -1 : 1));
                }
                this.addCurrentVertex(L, ge, 0, 0, B), this.addCurrentVertex(L, ge.mult(-1), 0, 0, B);
              } else if (mt === "bevel" || mt === "fakeround") {
                var $t = -Math.sqrt(Me * Me - 1), Mt = nt ? $t : 0, cr = nt ? 0 : $t;
                if (j && this.addCurrentVertex(L, te, Mt, cr, B), mt === "fakeround")
                  for (var rr = Math.round(180 * Fe / Math.PI / 20), Er = 1; Er < rr; Er++) {
                    var Rt = Er / rr;
                    if (Rt !== 0.5) {
                      var Pr = Rt - 0.5;
                      Rt += Rt * Pr * (Rt - 1) * ((1.0904 + be * (be * (3.55645 - 1.43519 * be) - 3.2452)) * Pr * Pr + (0.848013 + be * (0.215638 * be - 1.06021)));
                    }
                    var gn = ue.sub(te)._mult(Rt)._add(te)._unit()._mult(nt ? -1 : 1);
                    this.addHalfVertex(L, gn.x, gn.y, !1, nt, 0, B);
                  }
                Q && this.addCurrentVertex(L, ue, -Mt, -cr, B);
              } else if (mt === "butt")
                this.addCurrentVertex(L, ge, 0, 0, B);
              else if (mt === "square") {
                var On = j ? 1 : -1;
                this.addCurrentVertex(L, ge, On, On, B);
              } else
                mt === "round" && (j && (this.addCurrentVertex(L, te, 0, 0, B), this.addCurrentVertex(L, te, 1, 1, B, !0)), Q && (this.addCurrentVertex(L, ue, -1, -1, B, !0), this.addCurrentVertex(L, ue, 0, 0, B)));
              if (Xe && oe < C - 1) {
                var Mn = L.dist(Q);
                if (Mn > 2 * D) {
                  var vn = L.add(Q.sub(L)._mult(D / Mn)._round());
                  this.updateDistance(L, vn), this.addCurrentVertex(vn, ue, 0, 0, B), L = vn;
                }
              }
            }
        }
      }, to.prototype.addCurrentVertex = function(r, i, l, p, y, v) {
        v === void 0 && (v = !1);
        var x = i.y * p - i.x, S = -i.y - i.x * p;
        this.addHalfVertex(r, i.x + i.y * l, i.y - i.x * l, v, !1, l, y), this.addHalfVertex(r, x, S, v, !0, -p, y), this.distance > gx / 2 && this.totalDistance === 0 && (this.distance = 0, this.addCurrentVertex(r, i, l, p, y, v));
      }, to.prototype.addHalfVertex = function(r, i, l, p, y, v, x) {
        var S = 0.5 * (this.lineClips ? this.scaledDistance * (gx - 1) : this.scaledDistance);
        this.layoutVertexArray.emplaceBack((r.x << 1) + (p ? 1 : 0), (r.y << 1) + (y ? 1 : 0), Math.round(63 * i) + 128, Math.round(63 * l) + 128, 1 + (v === 0 ? 0 : v < 0 ? -1 : 1) | (63 & S) << 2, S >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
        var C = x.vertexLength++;
        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, C), x.primitiveLength++), y ? this.e2 = C : this.e1 = C;
      }, to.prototype.updateScaledDistance = function() {
        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
      }, to.prototype.updateDistance = function(r, i) {
        this.distance += r.dist(i), this.updateScaledDistance();
      }, wt("LineBucket", to, { omit: ["layers", "patternFeatures"] });
      var cO = new Mi({ "line-cap": new Lt(G.layout_line["line-cap"]), "line-join": new Tt(G.layout_line["line-join"]), "line-miter-limit": new Lt(G.layout_line["line-miter-limit"]), "line-round-limit": new Lt(G.layout_line["line-round-limit"]), "line-sort-key": new Tt(G.layout_line["line-sort-key"]) }), vx = { paint: new Mi({ "line-opacity": new Tt(G.paint_line["line-opacity"]), "line-color": new Tt(G.paint_line["line-color"]), "line-translate": new Lt(G.paint_line["line-translate"]), "line-translate-anchor": new Lt(G.paint_line["line-translate-anchor"]), "line-width": new Tt(G.paint_line["line-width"]), "line-gap-width": new Tt(G.paint_line["line-gap-width"]), "line-offset": new Tt(G.paint_line["line-offset"]), "line-blur": new Tt(G.paint_line["line-blur"]), "line-dasharray": new Gi(G.paint_line["line-dasharray"]), "line-pattern": new vh(G.paint_line["line-pattern"]), "line-gradient": new ua(G.paint_line["line-gradient"]) }), layout: cO }, _x = new (function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.possiblyEvaluate = function(l, p) {
          return p = new pr(Math.floor(p.zoom), { now: p.now, fadeDuration: p.fadeDuration, zoomHistory: p.zoomHistory, transition: p.transition }), r.prototype.possiblyEvaluate.call(this, l, p);
        }, i.prototype.evaluate = function(l, p, y, v) {
          return p = Y({}, p, { zoom: Math.floor(p.zoom) }), r.prototype.evaluate.call(this, l, p, y, v);
        }, i;
      }(Tt))(vx.paint.properties["line-width"].specification);
      _x.useIntegerZoom = !0;
      var hO = function(r) {
        function i(l) {
          r.call(this, l, vx), this.gradientVersion = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
          l === "line-gradient" && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof lo, this.gradientVersion = (this.gradientVersion + 1) % A);
        }, i.prototype.gradientExpression = function() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }, i.prototype.recalculate = function(l, p) {
          r.prototype.recalculate.call(this, l, p), this.paint._values["line-floorwidth"] = _x.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, l);
        }, i.prototype.createBucket = function(l) {
          return new to(l);
        }, i.prototype.queryRadius = function(l) {
          var p = l, y = xx(Sa("line-width", this, p), Sa("line-gap-width", this, p)), v = Sa("line-offset", this, p);
          return y / 2 + Math.abs(v) + li(this.paint.get("line-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C) {
          var P = qa(l, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), S.angle, C), L = C / 2 * xx(this.paint.get("line-width").evaluate(p, y), this.paint.get("line-gap-width").evaluate(p, y)), D = this.paint.get("line-offset").evaluate(p, y);
          return D && (v = function(B, j) {
            for (var Q = [], te = new T(0, 0), ue = 0; ue < B.length; ue++) {
              for (var oe = B[ue], ge = [], be = 0; be < oe.length; be++) {
                var Se = oe[be], Me = oe[be + 1], Fe = be === 0 ? te : Se.sub(oe[be - 1])._unit()._perp(), Xe = be === oe.length - 1 ? te : Me.sub(Se)._unit()._perp(), nt = Fe._add(Xe)._unit();
                nt._mult(1 / (nt.x * Xe.x + nt.y * Xe.y)), ge.push(nt._mult(j)._add(Se));
              }
              Q.push(ge);
            }
            return Q;
          }(v, D * C)), function(B, j, Q) {
            for (var te = 0; te < j.length; te++) {
              var ue = j[te];
              if (B.length >= 3) {
                for (var oe = 0; oe < ue.length; oe++)
                  if (Ea(B, ue[oe]))
                    return !0;
              }
              if (Zo(B, ue, Q))
                return !0;
            }
            return !1;
          }(P, v, L);
        }, i.prototype.isTileClipped = function() {
          return !0;
        }, i;
      }(ba);
      function xx(r, i) {
        return i > 0 ? i + 2 * r : r;
      }
      var fO = yi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), pO = yi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), dO = (yi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), yi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }])), bx = (yi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]), yi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), mO = yi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function yO(r, i, l) {
        return r.sections.forEach(function(p) {
          p.text = function(y, v, x) {
            var S = v.layout.get("text-transform").evaluate(x, {});
            return S === "uppercase" ? y = y.toLocaleUpperCase() : S === "lowercase" && (y = y.toLocaleLowerCase()), Io.applyArabicShaping && (y = Io.applyArabicShaping(y)), y;
          }(p.text, i, l);
        }), r;
      }
      yi([{ name: "triangle", components: 3, type: "Uint16" }]), yi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), yi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), yi([{ type: "Float32", name: "offsetX" }]), yi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
      var bp = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" }, wx = function(r, i, l, p, y) {
        var v, x, S = 8 * y - p - 1, C = (1 << S) - 1, P = C >> 1, L = -7, D = l ? y - 1 : 0, B = l ? -1 : 1, j = r[i + D];
        for (D += B, v = j & (1 << -L) - 1, j >>= -L, L += S; L > 0; v = 256 * v + r[i + D], D += B, L -= 8)
          ;
        for (x = v & (1 << -L) - 1, v >>= -L, L += p; L > 0; x = 256 * x + r[i + D], D += B, L -= 8)
          ;
        if (v === 0)
          v = 1 - P;
        else {
          if (v === C)
            return x ? NaN : 1 / 0 * (j ? -1 : 1);
          x += Math.pow(2, p), v -= P;
        }
        return (j ? -1 : 1) * x * Math.pow(2, v - p);
      }, Ex = function(r, i, l, p, y, v) {
        var x, S, C, P = 8 * v - y - 1, L = (1 << P) - 1, D = L >> 1, B = y === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, j = p ? 0 : v - 1, Q = p ? 1 : -1, te = i < 0 || i === 0 && 1 / i < 0 ? 1 : 0;
        for (i = Math.abs(i), isNaN(i) || i === 1 / 0 ? (S = isNaN(i) ? 1 : 0, x = L) : (x = Math.floor(Math.log(i) / Math.LN2), i * (C = Math.pow(2, -x)) < 1 && (x--, C *= 2), (i += x + D >= 1 ? B / C : B * Math.pow(2, 1 - D)) * C >= 2 && (x++, C /= 2), x + D >= L ? (S = 0, x = L) : x + D >= 1 ? (S = (i * C - 1) * Math.pow(2, y), x += D) : (S = i * Math.pow(2, D - 1) * Math.pow(2, y), x = 0)); y >= 8; r[l + j] = 255 & S, j += Q, S /= 256, y -= 8)
          ;
        for (x = x << y | S, P += y; P > 0; r[l + j] = 255 & x, j += Q, x /= 256, P -= 8)
          ;
        r[l + j - Q] |= 128 * te;
      }, Bm = tn;
      function tn(r) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(r) ? r : new Uint8Array(r || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      tn.Varint = 0, tn.Fixed64 = 1, tn.Bytes = 2, tn.Fixed32 = 5;
      var Sx = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
      function bl(r) {
        return r.type === tn.Bytes ? r.readVarint() + r.pos : r.pos + 1;
      }
      function Oh(r, i, l) {
        return l ? 4294967296 * i + (r >>> 0) : 4294967296 * (i >>> 0) + (r >>> 0);
      }
      function Tx(r, i, l) {
        var p = i <= 16383 ? 1 : i <= 2097151 ? 2 : i <= 268435455 ? 3 : Math.floor(Math.log(i) / (7 * Math.LN2));
        l.realloc(p);
        for (var y = l.pos - 1; y >= r; y--)
          l.buf[y + p] = l.buf[y];
      }
      function gO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeVarint(r[l]);
      }
      function vO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSVarint(r[l]);
      }
      function _O(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFloat(r[l]);
      }
      function xO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeDouble(r[l]);
      }
      function bO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeBoolean(r[l]);
      }
      function wO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFixed32(r[l]);
      }
      function EO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSFixed32(r[l]);
      }
      function SO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFixed64(r[l]);
      }
      function TO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSFixed64(r[l]);
      }
      function Vm(r, i) {
        return (r[i] | r[i + 1] << 8 | r[i + 2] << 16) + 16777216 * r[i + 3];
      }
      function Ch(r, i, l) {
        r[l] = i, r[l + 1] = i >>> 8, r[l + 2] = i >>> 16, r[l + 3] = i >>> 24;
      }
      function Mx(r, i) {
        return (r[i] | r[i + 1] << 8 | r[i + 2] << 16) + (r[i + 3] << 24);
      }
      function MO(r, i, l) {
        r === 1 && l.readMessage(IO, i);
      }
      function IO(r, i, l) {
        if (r === 3) {
          var p = l.readMessage(OO, {}), y = p.width, v = p.height, x = p.left, S = p.top, C = p.advance;
          i.push({ id: p.id, bitmap: new hc({ width: y + 6, height: v + 6 }, p.bitmap), metrics: { width: y, height: v, left: x, top: S, advance: C } });
        }
      }
      function OO(r, i, l) {
        r === 1 ? i.id = l.readVarint() : r === 2 ? i.bitmap = l.readBytes() : r === 3 ? i.width = l.readVarint() : r === 4 ? i.height = l.readVarint() : r === 5 ? i.left = l.readSVarint() : r === 6 ? i.top = l.readSVarint() : r === 7 && (i.advance = l.readVarint());
      }
      function Ix(r) {
        for (var i = 0, l = 0, p = 0, y = r; p < y.length; p += 1) {
          var v = y[p];
          i += v.w * v.h, l = Math.max(l, v.w);
        }
        r.sort(function(te, ue) {
          return ue.h - te.h;
        });
        for (var x = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(i / 0.95)), l), h: 1 / 0 }], S = 0, C = 0, P = 0, L = r; P < L.length; P += 1)
          for (var D = L[P], B = x.length - 1; B >= 0; B--) {
            var j = x[B];
            if (!(D.w > j.w || D.h > j.h)) {
              if (D.x = j.x, D.y = j.y, C = Math.max(C, D.y + D.h), S = Math.max(S, D.x + D.w), D.w === j.w && D.h === j.h) {
                var Q = x.pop();
                B < x.length && (x[B] = Q);
              } else
                D.h === j.h ? (j.x += D.w, j.w -= D.w) : D.w === j.w ? (j.y += D.h, j.h -= D.h) : (x.push({ x: j.x + D.w, y: j.y, w: j.w - D.w, h: D.h }), j.y += D.h, j.h -= D.h);
              break;
            }
          }
        return { w: S, h: C, fill: i / (S * C) || 0 };
      }
      tn.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(r, i, l) {
        for (l = l || this.length; this.pos < l; ) {
          var p = this.readVarint(), y = p >> 3, v = this.pos;
          this.type = 7 & p, r(y, i, this), this.pos === v && this.skip(p);
        }
        return i;
      }, readMessage: function(r, i) {
        return this.readFields(r, i, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var r = Vm(this.buf, this.pos);
        return this.pos += 4, r;
      }, readSFixed32: function() {
        var r = Mx(this.buf, this.pos);
        return this.pos += 4, r;
      }, readFixed64: function() {
        var r = Vm(this.buf, this.pos) + 4294967296 * Vm(this.buf, this.pos + 4);
        return this.pos += 8, r;
      }, readSFixed64: function() {
        var r = Vm(this.buf, this.pos) + 4294967296 * Mx(this.buf, this.pos + 4);
        return this.pos += 8, r;
      }, readFloat: function() {
        var r = wx(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, r;
      }, readDouble: function() {
        var r = wx(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, r;
      }, readVarint: function(r) {
        var i, l, p = this.buf;
        return i = 127 & (l = p[this.pos++]), l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 7, l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 14, l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 21, l < 128 ? i : function(y, v, x) {
          var S, C, P = x.buf;
          if (S = (112 & (C = P[x.pos++])) >> 4, C < 128 || (S |= (127 & (C = P[x.pos++])) << 3, C < 128) || (S |= (127 & (C = P[x.pos++])) << 10, C < 128) || (S |= (127 & (C = P[x.pos++])) << 17, C < 128) || (S |= (127 & (C = P[x.pos++])) << 24, C < 128) || (S |= (1 & (C = P[x.pos++])) << 31, C < 128))
            return Oh(y, S, v);
          throw new Error("Expected varint not more than 10 bytes");
        }(i |= (15 & (l = p[this.pos])) << 28, r, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var r = this.readVarint();
        return r % 2 == 1 ? (r + 1) / -2 : r / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var r = this.readVarint() + this.pos, i = this.pos;
        return this.pos = r, r - i >= 12 && Sx ? function(l, p, y) {
          return Sx.decode(l.subarray(p, y));
        }(this.buf, i, r) : function(l, p, y) {
          for (var v = "", x = p; x < y; ) {
            var S, C, P, L = l[x], D = null, B = L > 239 ? 4 : L > 223 ? 3 : L > 191 ? 2 : 1;
            if (x + B > y)
              break;
            B === 1 ? L < 128 && (D = L) : B === 2 ? (192 & (S = l[x + 1])) == 128 && (D = (31 & L) << 6 | 63 & S) <= 127 && (D = null) : B === 3 ? (C = l[x + 2], (192 & (S = l[x + 1])) == 128 && (192 & C) == 128 && ((D = (15 & L) << 12 | (63 & S) << 6 | 63 & C) <= 2047 || D >= 55296 && D <= 57343) && (D = null)) : B === 4 && (C = l[x + 2], P = l[x + 3], (192 & (S = l[x + 1])) == 128 && (192 & C) == 128 && (192 & P) == 128 && ((D = (15 & L) << 18 | (63 & S) << 12 | (63 & C) << 6 | 63 & P) <= 65535 || D >= 1114112) && (D = null)), D === null ? (D = 65533, B = 1) : D > 65535 && (D -= 65536, v += String.fromCharCode(D >>> 10 & 1023 | 55296), D = 56320 | 1023 & D), v += String.fromCharCode(D), x += B;
          }
          return v;
        }(this.buf, i, r);
      }, readBytes: function() {
        var r = this.readVarint() + this.pos, i = this.buf.subarray(this.pos, r);
        return this.pos = r, i;
      }, readPackedVarint: function(r, i) {
        if (this.type !== tn.Bytes)
          return r.push(this.readVarint(i));
        var l = bl(this);
        for (r = r || []; this.pos < l; )
          r.push(this.readVarint(i));
        return r;
      }, readPackedSVarint: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSVarint());
        var i = bl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSVarint());
        return r;
      }, readPackedBoolean: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readBoolean());
        var i = bl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readBoolean());
        return r;
      }, readPackedFloat: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFloat());
        var i = bl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFloat());
        return r;
      }, readPackedDouble: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readDouble());
        var i = bl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readDouble());
        return r;
      }, readPackedFixed32: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFixed32());
        var i = bl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFixed32());
        return r;
      }, readPackedSFixed32: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSFixed32());
        var i = bl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSFixed32());
        return r;
      }, readPackedFixed64: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFixed64());
        var i = bl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFixed64());
        return r;
      }, readPackedSFixed64: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSFixed64());
        var i = bl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSFixed64());
        return r;
      }, skip: function(r) {
        var i = 7 & r;
        if (i === tn.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (i === tn.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (i === tn.Fixed32)
          this.pos += 4;
        else {
          if (i !== tn.Fixed64)
            throw new Error("Unimplemented type: " + i);
          this.pos += 8;
        }
      }, writeTag: function(r, i) {
        this.writeVarint(r << 3 | i);
      }, realloc: function(r) {
        for (var i = this.length || 16; i < this.pos + r; )
          i *= 2;
        if (i !== this.length) {
          var l = new Uint8Array(i);
          l.set(this.buf), this.buf = l, this.length = i;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(r) {
        this.realloc(4), Ch(this.buf, r, this.pos), this.pos += 4;
      }, writeSFixed32: function(r) {
        this.realloc(4), Ch(this.buf, r, this.pos), this.pos += 4;
      }, writeFixed64: function(r) {
        this.realloc(8), Ch(this.buf, -1 & r, this.pos), Ch(this.buf, Math.floor(r * (1 / 4294967296)), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(r) {
        this.realloc(8), Ch(this.buf, -1 & r, this.pos), Ch(this.buf, Math.floor(r * (1 / 4294967296)), this.pos + 4), this.pos += 8;
      }, writeVarint: function(r) {
        (r = +r || 0) > 268435455 || r < 0 ? function(i, l) {
          var p, y;
          if (i >= 0 ? (p = i % 4294967296 | 0, y = i / 4294967296 | 0) : (y = ~(-i / 4294967296), 4294967295 ^ (p = ~(-i % 4294967296)) ? p = p + 1 | 0 : (p = 0, y = y + 1 | 0)), i >= 18446744073709552e3 || i < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          l.realloc(10), function(v, x, S) {
            S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, S.buf[S.pos] = 127 & (v >>>= 7);
          }(p, 0, l), function(v, x) {
            var S = (7 & v) << 4;
            x.buf[x.pos++] |= S | ((v >>>= 3) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v)))));
          }(y, l);
        }(r, this) : (this.realloc(4), this.buf[this.pos++] = 127 & r | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = r >>> 7 & 127))));
      }, writeSVarint: function(r) {
        this.writeVarint(r < 0 ? 2 * -r - 1 : 2 * r);
      }, writeBoolean: function(r) {
        this.writeVarint(Boolean(r));
      }, writeString: function(r) {
        r = String(r), this.realloc(4 * r.length), this.pos++;
        var i = this.pos;
        this.pos = function(p, y, v) {
          for (var x, S, C = 0; C < y.length; C++) {
            if ((x = y.charCodeAt(C)) > 55295 && x < 57344) {
              if (!S) {
                x > 56319 || C + 1 === y.length ? (p[v++] = 239, p[v++] = 191, p[v++] = 189) : S = x;
                continue;
              }
              if (x < 56320) {
                p[v++] = 239, p[v++] = 191, p[v++] = 189, S = x;
                continue;
              }
              x = S - 55296 << 10 | x - 56320 | 65536, S = null;
            } else
              S && (p[v++] = 239, p[v++] = 191, p[v++] = 189, S = null);
            x < 128 ? p[v++] = x : (x < 2048 ? p[v++] = x >> 6 | 192 : (x < 65536 ? p[v++] = x >> 12 | 224 : (p[v++] = x >> 18 | 240, p[v++] = x >> 12 & 63 | 128), p[v++] = x >> 6 & 63 | 128), p[v++] = 63 & x | 128);
          }
          return v;
        }(this.buf, r, this.pos);
        var l = this.pos - i;
        l >= 128 && Tx(i, l, this), this.pos = i - 1, this.writeVarint(l), this.pos += l;
      }, writeFloat: function(r) {
        this.realloc(4), Ex(this.buf, r, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(r) {
        this.realloc(8), Ex(this.buf, r, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(r) {
        var i = r.length;
        this.writeVarint(i), this.realloc(i);
        for (var l = 0; l < i; l++)
          this.buf[this.pos++] = r[l];
      }, writeRawMessage: function(r, i) {
        this.pos++;
        var l = this.pos;
        r(i, this);
        var p = this.pos - l;
        p >= 128 && Tx(l, p, this), this.pos = l - 1, this.writeVarint(p), this.pos += p;
      }, writeMessage: function(r, i, l) {
        this.writeTag(r, tn.Bytes), this.writeRawMessage(i, l);
      }, writePackedVarint: function(r, i) {
        i.length && this.writeMessage(r, gO, i);
      }, writePackedSVarint: function(r, i) {
        i.length && this.writeMessage(r, vO, i);
      }, writePackedBoolean: function(r, i) {
        i.length && this.writeMessage(r, bO, i);
      }, writePackedFloat: function(r, i) {
        i.length && this.writeMessage(r, _O, i);
      }, writePackedDouble: function(r, i) {
        i.length && this.writeMessage(r, xO, i);
      }, writePackedFixed32: function(r, i) {
        i.length && this.writeMessage(r, wO, i);
      }, writePackedSFixed32: function(r, i) {
        i.length && this.writeMessage(r, EO, i);
      }, writePackedFixed64: function(r, i) {
        i.length && this.writeMessage(r, SO, i);
      }, writePackedSFixed64: function(r, i) {
        i.length && this.writeMessage(r, TO, i);
      }, writeBytesField: function(r, i) {
        this.writeTag(r, tn.Bytes), this.writeBytes(i);
      }, writeFixed32Field: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeFixed32(i);
      }, writeSFixed32Field: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeSFixed32(i);
      }, writeFixed64Field: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeFixed64(i);
      }, writeSFixed64Field: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeSFixed64(i);
      }, writeVarintField: function(r, i) {
        this.writeTag(r, tn.Varint), this.writeVarint(i);
      }, writeSVarintField: function(r, i) {
        this.writeTag(r, tn.Varint), this.writeSVarint(i);
      }, writeStringField: function(r, i) {
        this.writeTag(r, tn.Bytes), this.writeString(i);
      }, writeFloatField: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeFloat(i);
      }, writeDoubleField: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeDouble(i);
      }, writeBooleanField: function(r, i) {
        this.writeVarintField(r, Boolean(i));
      } };
      var Um = function(r, i) {
        var l = i.pixelRatio, p = i.version, y = i.stretchX, v = i.stretchY, x = i.content;
        this.paddedRect = r, this.pixelRatio = l, this.stretchX = y, this.stretchY = v, this.content = x, this.version = p;
      }, wp = { tl: { configurable: !0 }, br: { configurable: !0 }, tlbr: { configurable: !0 }, displaySize: { configurable: !0 } };
      wp.tl.get = function() {
        return [this.paddedRect.x + 1, this.paddedRect.y + 1];
      }, wp.br.get = function() {
        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
      }, wp.tlbr.get = function() {
        return this.tl.concat(this.br);
      }, wp.displaySize.get = function() {
        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
      }, Object.defineProperties(Um.prototype, wp);
      var Ep = function(r, i) {
        var l = {}, p = {};
        this.haveRenderCallbacks = [];
        var y = [];
        this.addImages(r, l, y), this.addImages(i, p, y);
        var v = Ix(y), x = new yo({ width: v.w || 1, height: v.h || 1 });
        for (var S in r) {
          var C = r[S], P = l[S].paddedRect;
          yo.copy(C.data, x, { x: 0, y: 0 }, { x: P.x + 1, y: P.y + 1 }, C.data);
        }
        for (var L in i) {
          var D = i[L], B = p[L].paddedRect, j = B.x + 1, Q = B.y + 1, te = D.data.width, ue = D.data.height;
          yo.copy(D.data, x, { x: 0, y: 0 }, { x: j, y: Q }, D.data), yo.copy(D.data, x, { x: 0, y: ue - 1 }, { x: j, y: Q - 1 }, { width: te, height: 1 }), yo.copy(D.data, x, { x: 0, y: 0 }, { x: j, y: Q + ue }, { width: te, height: 1 }), yo.copy(D.data, x, { x: te - 1, y: 0 }, { x: j - 1, y: Q }, { width: 1, height: ue }), yo.copy(D.data, x, { x: 0, y: 0 }, { x: j + te, y: Q }, { width: 1, height: ue });
        }
        this.image = x, this.iconPositions = l, this.patternPositions = p;
      };
      Ep.prototype.addImages = function(r, i, l) {
        for (var p in r) {
          var y = r[p], v = { x: 0, y: 0, w: y.data.width + 2, h: y.data.height + 2 };
          l.push(v), i[p] = new Um(v, y), y.hasRenderCallback && this.haveRenderCallbacks.push(p);
        }
      }, Ep.prototype.patchUpdatedImages = function(r, i) {
        for (var l in r.dispatchRenderCallbacks(this.haveRenderCallbacks), r.updatedImages)
          this.patchUpdatedImage(this.iconPositions[l], r.getImage(l), i), this.patchUpdatedImage(this.patternPositions[l], r.getImage(l), i);
      }, Ep.prototype.patchUpdatedImage = function(r, i, l) {
        if (r && i && r.version !== i.version) {
          r.version = i.version;
          var p = r.tl;
          l.update(i.data, void 0, { x: p[0], y: p[1] });
        }
      }, wt("ImagePosition", Um), wt("ImageAtlas", Ep);
      var Xo = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, Ah = function() {
        this.scale = 1, this.fontStack = "", this.imageName = null;
      };
      Ah.forText = function(r, i) {
        var l = new Ah();
        return l.scale = r || 1, l.fontStack = i, l;
      }, Ah.forImage = function(r) {
        var i = new Ah();
        return i.imageName = r, i;
      };
      var $i = function() {
        this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
      };
      function jm(r, i, l, p, y, v, x, S, C, P, L, D, B, j, Q, te) {
        var ue, oe = $i.fromFeature(r, y);
        D === Xo.vertical && oe.verticalizePunctuation();
        var ge = Io.processBidirectionalText, be = Io.processStyledBidirectionalText;
        if (ge && oe.sections.length === 1) {
          ue = [];
          for (var Se = 0, Me = ge(oe.toString(), i_(oe, P, v, i, p, j, Q)); Se < Me.length; Se += 1) {
            var Fe = Me[Se], Xe = new $i();
            Xe.text = Fe, Xe.sections = oe.sections;
            for (var nt = 0; nt < Fe.length; nt++)
              Xe.sectionIndex.push(0);
            ue.push(Xe);
          }
        } else if (be) {
          ue = [];
          for (var At = 0, pt = be(oe.text, oe.sectionIndex, i_(oe, P, v, i, p, j, Q)); At < pt.length; At += 1) {
            var Nt = pt[At], mt = new $i();
            mt.text = Nt[0], mt.sectionIndex = Nt[1], mt.sections = oe.sections, ue.push(mt);
          }
        } else
          ue = function(Mt, cr) {
            for (var rr = [], Er = Mt.text, Rt = 0, Pr = 0, gn = cr; Pr < gn.length; Pr += 1) {
              var On = gn[Pr];
              rr.push(Mt.substring(Rt, On)), Rt = On;
            }
            return Rt < Er.length && rr.push(Mt.substring(Rt, Er.length)), rr;
          }(oe, i_(oe, P, v, i, p, j, Q));
        var or = [], $t = { positionedLines: or, text: oe.toString(), top: L[1], bottom: L[1], left: L[0], right: L[0], writingMode: D, iconsInText: !1, verticalizable: !1 };
        return function(Mt, cr, rr, Er, Rt, Pr, gn, On, Mn, vn, Cn, ui) {
          for (var ci = 0, Wi = -17, _i = 0, Hi = 0, Dn = On === "right" ? 1 : On === "left" ? 0 : 0.5, xi = 0, gr = 0, Xr = Rt; gr < Xr.length; gr += 1) {
            var qr = Xr[gr];
            qr.trim();
            var Mr = qr.getMaxScale(), ro = 24 * (Mr - 1), Di = { positionedGlyphs: [], lineOffset: 0 };
            Mt.positionedLines[xi] = Di;
            var an = Di.positionedGlyphs, qn = 0;
            if (qr.length()) {
              for (var Ni = 0; Ni < qr.length(); Ni++) {
                var kr = qr.getSection(Ni), Cs = qr.getSectionIndex(Ni), Ko = qr.getCharCode(Ni), As = 0, Nn = null, Ps = null, Ta = null, Fh = 24, mc = !(Mn === Xo.horizontal || !Cn && !mh(Ko) || Cn && (Gm[Ko] || (Tl = Ko, ut.Arabic(Tl) || ut["Arabic Supplement"](Tl) || ut["Arabic Extended-A"](Tl) || ut["Arabic Presentation Forms-A"](Tl) || ut["Arabic Presentation Forms-B"](Tl))));
                if (kr.imageName) {
                  var Bh = Er[kr.imageName];
                  if (!Bh)
                    continue;
                  Ta = kr.imageName, Mt.iconsInText = Mt.iconsInText || !0, Ps = Bh.paddedRect;
                  var Sl = Bh.displaySize;
                  kr.scale = 24 * kr.scale / ui, As = ro + (24 - Sl[1] * kr.scale), Fh = (Nn = { width: Sl[0], height: Sl[1], left: 1, top: -3, advance: mc ? Sl[1] : Sl[0] }).advance;
                  var Vh = mc ? Sl[0] * kr.scale - 24 * Mr : Sl[1] * kr.scale - 24 * Mr;
                  Vh > 0 && Vh > qn && (qn = Vh);
                } else {
                  var Jm = rr[kr.fontStack], Uh = Jm && Jm[Ko];
                  if (Uh && Uh.rect)
                    Ps = Uh.rect, Nn = Uh.metrics;
                  else {
                    var Mp = cr[kr.fontStack], Qm = Mp && Mp[Ko];
                    if (!Qm)
                      continue;
                    Nn = Qm.metrics;
                  }
                  As = 24 * (Mr - kr.scale);
                }
                mc ? (Mt.verticalizable = !0, an.push({ glyph: Ko, imageName: Ta, x: ci, y: Wi + As, vertical: mc, scale: kr.scale, fontStack: kr.fontStack, sectionIndex: Cs, metrics: Nn, rect: Ps }), ci += Fh * kr.scale + vn) : (an.push({ glyph: Ko, imageName: Ta, x: ci, y: Wi + As, vertical: mc, scale: kr.scale, fontStack: kr.fontStack, sectionIndex: Cs, metrics: Nn, rect: Ps }), ci += Nn.advance * kr.scale + vn);
              }
              an.length !== 0 && (_i = Math.max(ci - vn, _i), AO(an, 0, an.length - 1, Dn, qn)), ci = 0;
              var ey = Pr * Mr + qn;
              Di.lineOffset = Math.max(qn, ro), Wi += ey, Hi = Math.max(ey, Hi), ++xi;
            } else
              Wi += Pr, ++xi;
          }
          var Tl, Ip = Wi - -17, jh = o_(gn), su = jh.horizontalAlign, Gh = jh.verticalAlign;
          (function(ty, ry, Op, Cp, ny, Ap, Pp, kp, iy) {
            var qh, oy = (ry - Op) * ny;
            qh = Ap !== Pp ? -kp * Cp - -17 : (-Cp * iy + 0.5) * Pp;
            for (var $h = 0, Lp = ty; $h < Lp.length; $h += 1)
              for (var yc = 0, Dp = Lp[$h].positionedGlyphs; yc < Dp.length; yc += 1) {
                var Wh = Dp[yc];
                Wh.x += oy, Wh.y += qh;
              }
          })(Mt.positionedLines, Dn, su, Gh, _i, Hi, Pr, Ip, Rt.length), Mt.top += -Gh * Ip, Mt.bottom = Mt.top + Ip, Mt.left += -su * _i, Mt.right = Mt.left + _i;
        }($t, i, l, p, ue, x, S, C, D, P, B, te), !function(Mt) {
          for (var cr = 0, rr = Mt; cr < rr.length; cr += 1)
            if (rr[cr].positionedGlyphs.length !== 0)
              return !1;
          return !0;
        }(or) && $t;
      }
      $i.fromFeature = function(r, i) {
        for (var l = new $i(), p = 0; p < r.sections.length; p++) {
          var y = r.sections[p];
          y.image ? l.addImageSection(y) : l.addTextSection(y, i);
        }
        return l;
      }, $i.prototype.length = function() {
        return this.text.length;
      }, $i.prototype.getSection = function(r) {
        return this.sections[this.sectionIndex[r]];
      }, $i.prototype.getSectionIndex = function(r) {
        return this.sectionIndex[r];
      }, $i.prototype.getCharCode = function(r) {
        return this.text.charCodeAt(r);
      }, $i.prototype.verticalizePunctuation = function() {
        this.text = function(r) {
          for (var i = "", l = 0; l < r.length; l++) {
            var p = r.charCodeAt(l + 1) || null, y = r.charCodeAt(l - 1) || null;
            i += p && ap(p) && !bp[r[l + 1]] || y && ap(y) && !bp[r[l - 1]] || !bp[r[l]] ? r[l] : bp[r[l]];
          }
          return i;
        }(this.text);
      }, $i.prototype.trim = function() {
        for (var r = 0, i = 0; i < this.text.length && Gm[this.text.charCodeAt(i)]; i++)
          r++;
        for (var l = this.text.length, p = this.text.length - 1; p >= 0 && p >= r && Gm[this.text.charCodeAt(p)]; p--)
          l--;
        this.text = this.text.substring(r, l), this.sectionIndex = this.sectionIndex.slice(r, l);
      }, $i.prototype.substring = function(r, i) {
        var l = new $i();
        return l.text = this.text.substring(r, i), l.sectionIndex = this.sectionIndex.slice(r, i), l.sections = this.sections, l;
      }, $i.prototype.toString = function() {
        return this.text;
      }, $i.prototype.getMaxScale = function() {
        var r = this;
        return this.sectionIndex.reduce(function(i, l) {
          return Math.max(i, r.sections[l].scale);
        }, 0);
      }, $i.prototype.addTextSection = function(r, i) {
        this.text += r.text, this.sections.push(Ah.forText(r.scale, r.fontStack || i));
        for (var l = this.sections.length - 1, p = 0; p < r.text.length; ++p)
          this.sectionIndex.push(l);
      }, $i.prototype.addImageSection = function(r) {
        var i = r.image ? r.image.name : "";
        if (i.length !== 0) {
          var l = this.getNextImageSectionCharCode();
          l ? (this.text += String.fromCharCode(l), this.sections.push(Ah.forImage(i)), this.sectionIndex.push(this.sections.length - 1)) : yt("Reached maximum number of images 6401");
        } else
          yt("Can't add FormattedSection with an empty image.");
      }, $i.prototype.getNextImageSectionCharCode = function() {
        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
      };
      var Gm = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Co = {};
      function Ox(r, i, l, p, y, v) {
        if (i.imageName) {
          var x = p[i.imageName];
          return x ? x.displaySize[0] * i.scale * 24 / v + y : 0;
        }
        var S = l[i.fontStack], C = S && S[r];
        return C ? C.metrics.advance * i.scale + y : 0;
      }
      function Cx(r, i, l, p) {
        var y = Math.pow(r - i, 2);
        return p ? r < i ? y / 2 : 2 * y : y + Math.abs(l) * l;
      }
      function CO(r, i, l) {
        var p = 0;
        return r === 10 && (p -= 1e4), l && (p += 150), r !== 40 && r !== 65288 || (p += 50), i !== 41 && i !== 65289 || (p += 50), p;
      }
      function Ax(r, i, l, p, y, v) {
        for (var x = null, S = Cx(i, l, y, v), C = 0, P = p; C < P.length; C += 1) {
          var L = P[C], D = Cx(i - L.x, l, y, v) + L.badness;
          D <= S && (x = L, S = D);
        }
        return { index: r, x: i, priorBreak: x, badness: S };
      }
      function i_(r, i, l, p, y, v, x) {
        if (v !== "point")
          return [];
        if (!r)
          return [];
        for (var S, C = [], P = function(ue, oe, ge, be, Se, Me) {
          for (var Fe = 0, Xe = 0; Xe < ue.length(); Xe++) {
            var nt = ue.getSection(Xe);
            Fe += Ox(ue.getCharCode(Xe), nt, be, Se, oe, Me);
          }
          return Fe / Math.max(1, Math.ceil(Fe / ge));
        }(r, i, l, p, y, x), L = r.text.indexOf("\u200B") >= 0, D = 0, B = 0; B < r.length(); B++) {
          var j = r.getSection(B), Q = r.getCharCode(B);
          if (Gm[Q] || (D += Ox(Q, j, p, y, i, x)), B < r.length() - 1) {
            var te = !((S = Q) < 11904 || !(ut["Bopomofo Extended"](S) || ut.Bopomofo(S) || ut["CJK Compatibility Forms"](S) || ut["CJK Compatibility Ideographs"](S) || ut["CJK Compatibility"](S) || ut["CJK Radicals Supplement"](S) || ut["CJK Strokes"](S) || ut["CJK Symbols and Punctuation"](S) || ut["CJK Unified Ideographs Extension A"](S) || ut["CJK Unified Ideographs"](S) || ut["Enclosed CJK Letters and Months"](S) || ut["Halfwidth and Fullwidth Forms"](S) || ut.Hiragana(S) || ut["Ideographic Description Characters"](S) || ut["Kangxi Radicals"](S) || ut["Katakana Phonetic Extensions"](S) || ut.Katakana(S) || ut["Vertical Forms"](S) || ut["Yi Radicals"](S) || ut["Yi Syllables"](S)));
            (Co[Q] || te || j.imageName) && C.push(Ax(B + 1, D, P, C, CO(Q, r.getCharCode(B + 1), te && L), !1));
          }
        }
        return function ue(oe) {
          return oe ? ue(oe.priorBreak).concat(oe.index) : [];
        }(Ax(r.length(), D, P, C, 0, !0));
      }
      function o_(r) {
        var i = 0.5, l = 0.5;
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            i = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            i = 0;
        }
        switch (r) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            l = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            l = 0;
        }
        return { horizontalAlign: i, verticalAlign: l };
      }
      function AO(r, i, l, p, y) {
        if (p || y)
          for (var v = r[l], x = (r[l].x + v.metrics.advance * v.scale) * p, S = i; S <= l; S++)
            r[S].x -= x, r[S].y += y;
      }
      function Px(r, i, l, p, y, v) {
        var x, S = r.image;
        if (S.content) {
          var C = S.content, P = S.pixelRatio || 1;
          x = [C[0] / P, C[1] / P, S.displaySize[0] - C[2] / P, S.displaySize[1] - C[3] / P];
        }
        var L, D, B, j, Q = i.left * v, te = i.right * v;
        l === "width" || l === "both" ? (j = y[0] + Q - p[3], D = y[0] + te + p[1]) : D = (j = y[0] + (Q + te - S.displaySize[0]) / 2) + S.displaySize[0];
        var ue = i.top * v, oe = i.bottom * v;
        return l === "height" || l === "both" ? (L = y[1] + ue - p[0], B = y[1] + oe + p[2]) : B = (L = y[1] + (ue + oe - S.displaySize[1]) / 2) + S.displaySize[1], { image: S, top: L, right: D, bottom: B, left: j, collisionPadding: x };
      }
      Co[10] = !0, Co[32] = !0, Co[38] = !0, Co[40] = !0, Co[41] = !0, Co[43] = !0, Co[45] = !0, Co[47] = !0, Co[173] = !0, Co[183] = !0, Co[8203] = !0, Co[8208] = !0, Co[8211] = !0, Co[8231] = !0;
      var Ph = function(r) {
        function i(l, p, y, v) {
          r.call(this, l, p), this.angle = y, v !== void 0 && (this.segment = v);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.clone = function() {
          return new i(this.x, this.y, this.angle, this.segment);
        }, i;
      }(T);
      function a_(r, i) {
        var l = i.expression;
        if (l.kind === "constant")
          return { kind: "constant", layoutSize: l.evaluate(new pr(r + 1)) };
        if (l.kind === "source")
          return { kind: "source" };
        for (var p = l.zoomStops, y = l.interpolationType, v = 0; v < p.length && p[v] <= r; )
          v++;
        for (var x = v = Math.max(0, v - 1); x < p.length && p[x] < r + 1; )
          x++;
        x = Math.min(p.length - 1, x);
        var S = p[v], C = p[x];
        return l.kind === "composite" ? { kind: "composite", minZoom: S, maxZoom: C, interpolationType: y } : { kind: "camera", minZoom: S, maxZoom: C, minSize: l.evaluate(new pr(S)), maxSize: l.evaluate(new pr(C)), interpolationType: y };
      }
      function kx(r, i, l) {
        var p = i.uSize, y = l.lowerSize;
        return r.kind === "source" ? y / 128 : r.kind === "composite" ? jn(y / 128, l.upperSize / 128, i.uSizeT) : p;
      }
      function Lx(r, i) {
        var l = 0, p = 0;
        if (r.kind === "constant")
          p = r.layoutSize;
        else if (r.kind !== "source") {
          var y = r.interpolationType, v = y ? Z(Si.interpolationFactor(y, i, r.minZoom, r.maxZoom), 0, 1) : 0;
          r.kind === "camera" ? p = jn(r.minSize, r.maxSize, v) : l = v;
        }
        return { uSizeT: l, uSize: p };
      }
      wt("Anchor", Ph);
      var PO = Object.freeze({ __proto__: null, getSizeData: a_, evaluateSizeForFeature: kx, evaluateSizeForZoom: Lx, SIZE_PACK_FACTOR: 128 });
      function Dx(r, i, l, p, y) {
        if (i.segment === void 0)
          return !0;
        for (var v = i, x = i.segment + 1, S = 0; S > -l / 2; ) {
          if (--x < 0)
            return !1;
          S -= r[x].dist(v), v = r[x];
        }
        S += r[x].dist(r[x + 1]), x++;
        for (var C = [], P = 0; S < l / 2; ) {
          var L = r[x], D = r[x + 1];
          if (!D)
            return !1;
          var B = r[x - 1].angleTo(L) - L.angleTo(D);
          for (B = Math.abs((B + 3 * Math.PI) % (2 * Math.PI) - Math.PI), C.push({ distance: S, angleDelta: B }), P += B; S - C[0].distance > p; )
            P -= C.shift().angleDelta;
          if (P > y)
            return !1;
          x++, S += L.dist(D);
        }
        return !0;
      }
      function Nx(r) {
        for (var i = 0, l = 0; l < r.length - 1; l++)
          i += r[l].dist(r[l + 1]);
        return i;
      }
      function Rx(r, i, l) {
        return r ? 0.6 * i * l : 0;
      }
      function zx(r, i) {
        return Math.max(r ? r.right - r.left : 0, i ? i.right - i.left : 0);
      }
      function kO(r, i, l, p, y, v) {
        for (var x = Rx(l, y, v), S = zx(l, p) * v, C = 0, P = Nx(r) / 2, L = 0; L < r.length - 1; L++) {
          var D = r[L], B = r[L + 1], j = D.dist(B);
          if (C + j > P) {
            var Q = (P - C) / j, te = jn(D.x, B.x, Q), ue = jn(D.y, B.y, Q), oe = new Ph(te, ue, B.angleTo(D), L);
            return oe._round(), !x || Dx(r, oe, S, x, i) ? oe : void 0;
          }
          C += j;
        }
      }
      function LO(r, i, l, p, y, v, x, S, C) {
        var P = Rx(p, v, x), L = zx(p, y), D = L * x, B = r[0].x === 0 || r[0].x === C || r[0].y === 0 || r[0].y === C;
        return i - D < i / 4 && (i = D + i / 4), function j(Q, te, ue, oe, ge, be, Se, Me, Fe) {
          for (var Xe = be / 2, nt = Nx(Q), At = 0, pt = te - ue, Nt = [], mt = 0; mt < Q.length - 1; mt++) {
            for (var or = Q[mt], $t = Q[mt + 1], Mt = or.dist($t), cr = $t.angleTo(or); pt + ue < At + Mt; ) {
              var rr = ((pt += ue) - At) / Mt, Er = jn(or.x, $t.x, rr), Rt = jn(or.y, $t.y, rr);
              if (Er >= 0 && Er < Fe && Rt >= 0 && Rt < Fe && pt - Xe >= 0 && pt + Xe <= nt) {
                var Pr = new Ph(Er, Rt, cr, mt);
                Pr._round(), oe && !Dx(Q, Pr, be, oe, ge) || Nt.push(Pr);
              }
            }
            At += Mt;
          }
          return Me || Nt.length || Se || (Nt = j(Q, At / 2, ue, oe, ge, be, Se, !0, Fe)), Nt;
        }(r, B ? i / 2 * S % i : (L / 2 + 2 * v) * x * S % i, i, P, l, D, B, !1, C);
      }
      function Fx(r, i, l, p, y) {
        for (var v = [], x = 0; x < r.length; x++)
          for (var S = r[x], C = void 0, P = 0; P < S.length - 1; P++) {
            var L = S[P], D = S[P + 1];
            L.x < i && D.x < i || (L.x < i ? L = new T(i, L.y + (i - L.x) / (D.x - L.x) * (D.y - L.y))._round() : D.x < i && (D = new T(i, L.y + (i - L.x) / (D.x - L.x) * (D.y - L.y))._round()), L.y < l && D.y < l || (L.y < l ? L = new T(L.x + (l - L.y) / (D.y - L.y) * (D.x - L.x), l)._round() : D.y < l && (D = new T(L.x + (l - L.y) / (D.y - L.y) * (D.x - L.x), l)._round()), L.x >= p && D.x >= p || (L.x >= p ? L = new T(p, L.y + (p - L.x) / (D.x - L.x) * (D.y - L.y))._round() : D.x >= p && (D = new T(p, L.y + (p - L.x) / (D.x - L.x) * (D.y - L.y))._round()), L.y >= y && D.y >= y || (L.y >= y ? L = new T(L.x + (y - L.y) / (D.y - L.y) * (D.x - L.x), y)._round() : D.y >= y && (D = new T(L.x + (y - L.y) / (D.y - L.y) * (D.x - L.x), y)._round()), C && L.equals(C[C.length - 1]) || v.push(C = [L]), C.push(D)))));
          }
        return v;
      }
      function Bx(r, i, l, p) {
        var y = [], v = r.image, x = v.pixelRatio, S = v.paddedRect.w - 2, C = v.paddedRect.h - 2, P = r.right - r.left, L = r.bottom - r.top, D = v.stretchX || [[0, S]], B = v.stretchY || [[0, C]], j = function(Er, Rt) {
          return Er + Rt[1] - Rt[0];
        }, Q = D.reduce(j, 0), te = B.reduce(j, 0), ue = S - Q, oe = C - te, ge = 0, be = Q, Se = 0, Me = te, Fe = 0, Xe = ue, nt = 0, At = oe;
        if (v.content && p) {
          var pt = v.content;
          ge = qm(D, 0, pt[0]), Se = qm(B, 0, pt[1]), be = qm(D, pt[0], pt[2]), Me = qm(B, pt[1], pt[3]), Fe = pt[0] - ge, nt = pt[1] - Se, Xe = pt[2] - pt[0] - be, At = pt[3] - pt[1] - Me;
        }
        var Nt = function(Er, Rt, Pr, gn) {
          var On = $m(Er.stretch - ge, be, P, r.left), Mn = Wm(Er.fixed - Fe, Xe, Er.stretch, Q), vn = $m(Rt.stretch - Se, Me, L, r.top), Cn = Wm(Rt.fixed - nt, At, Rt.stretch, te), ui = $m(Pr.stretch - ge, be, P, r.left), ci = Wm(Pr.fixed - Fe, Xe, Pr.stretch, Q), Wi = $m(gn.stretch - Se, Me, L, r.top), _i = Wm(gn.fixed - nt, At, gn.stretch, te), Hi = new T(On, vn), Dn = new T(ui, vn), xi = new T(ui, Wi), gr = new T(On, Wi), Xr = new T(Mn / x, Cn / x), qr = new T(ci / x, _i / x), Mr = i * Math.PI / 180;
          if (Mr) {
            var ro = Math.sin(Mr), Di = Math.cos(Mr), an = [Di, -ro, ro, Di];
            Hi._matMult(an), Dn._matMult(an), gr._matMult(an), xi._matMult(an);
          }
          var qn = Er.stretch + Er.fixed, Ni = Rt.stretch + Rt.fixed;
          return { tl: Hi, tr: Dn, bl: gr, br: xi, tex: { x: v.paddedRect.x + 1 + qn, y: v.paddedRect.y + 1 + Ni, w: Pr.stretch + Pr.fixed - qn, h: gn.stretch + gn.fixed - Ni }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Xr, pixelOffsetBR: qr, minFontScaleX: Xe / x / P, minFontScaleY: At / x / L, isSDF: l };
        };
        if (p && (v.stretchX || v.stretchY))
          for (var mt = Vx(D, ue, Q), or = Vx(B, oe, te), $t = 0; $t < mt.length - 1; $t++)
            for (var Mt = mt[$t], cr = mt[$t + 1], rr = 0; rr < or.length - 1; rr++)
              y.push(Nt(Mt, or[rr], cr, or[rr + 1]));
        else
          y.push(Nt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: S + 1 }, { fixed: 0, stretch: C + 1 }));
        return y;
      }
      function qm(r, i, l) {
        for (var p = 0, y = 0, v = r; y < v.length; y += 1) {
          var x = v[y];
          p += Math.max(i, Math.min(l, x[1])) - Math.max(i, Math.min(l, x[0]));
        }
        return p;
      }
      function Vx(r, i, l) {
        for (var p = [{ fixed: -1, stretch: 0 }], y = 0, v = r; y < v.length; y += 1) {
          var x = v[y], S = x[0], C = x[1], P = p[p.length - 1];
          p.push({ fixed: S - P.stretch, stretch: P.stretch }), p.push({ fixed: S - P.stretch, stretch: P.stretch + (C - S) });
        }
        return p.push({ fixed: i + 1, stretch: l }), p;
      }
      function $m(r, i, l, p) {
        return r / i * l + p;
      }
      function Wm(r, i, l, p) {
        return r - i * l / p;
      }
      var Hm = function(r, i, l, p, y, v, x, S, C, P) {
        if (this.boxStartIndex = r.length, C) {
          var L = v.top, D = v.bottom, B = v.collisionPadding;
          B && (L -= B[1], D += B[3]);
          var j = D - L;
          j > 0 && (j = Math.max(10, j), this.circleDiameter = j);
        } else {
          var Q = v.top * x - S, te = v.bottom * x + S, ue = v.left * x - S, oe = v.right * x + S, ge = v.collisionPadding;
          if (ge && (ue -= ge[0] * x, Q -= ge[1] * x, oe += ge[2] * x, te += ge[3] * x), P) {
            var be = new T(ue, Q), Se = new T(oe, Q), Me = new T(ue, te), Fe = new T(oe, te), Xe = P * Math.PI / 180;
            be._rotate(Xe), Se._rotate(Xe), Me._rotate(Xe), Fe._rotate(Xe), ue = Math.min(be.x, Se.x, Me.x, Fe.x), oe = Math.max(be.x, Se.x, Me.x, Fe.x), Q = Math.min(be.y, Se.y, Me.y, Fe.y), te = Math.max(be.y, Se.y, Me.y, Fe.y);
          }
          r.emplaceBack(i.x, i.y, ue, Q, oe, te, l, p, y);
        }
        this.boxEndIndex = r.length;
      }, kh = function(r, i) {
        if (r === void 0 && (r = []), i === void 0 && (i = DO), this.data = r, this.length = this.data.length, this.compare = i, this.length > 0)
          for (var l = (this.length >> 1) - 1; l >= 0; l--)
            this._down(l);
      };
      function DO(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function NO(r, i, l) {
        i === void 0 && (i = 1), l === void 0 && (l = !1);
        for (var p = 1 / 0, y = 1 / 0, v = -1 / 0, x = -1 / 0, S = r[0], C = 0; C < S.length; C++) {
          var P = S[C];
          (!C || P.x < p) && (p = P.x), (!C || P.y < y) && (y = P.y), (!C || P.x > v) && (v = P.x), (!C || P.y > x) && (x = P.y);
        }
        var L = Math.min(v - p, x - y), D = L / 2, B = new kh([], RO);
        if (L === 0)
          return new T(p, y);
        for (var j = p; j < v; j += L)
          for (var Q = y; Q < x; Q += L)
            B.push(new Lh(j + D, Q + D, D, r));
        for (var te = function(ge) {
          for (var be = 0, Se = 0, Me = 0, Fe = ge[0], Xe = 0, nt = Fe.length, At = nt - 1; Xe < nt; At = Xe++) {
            var pt = Fe[Xe], Nt = Fe[At], mt = pt.x * Nt.y - Nt.x * pt.y;
            Se += (pt.x + Nt.x) * mt, Me += (pt.y + Nt.y) * mt, be += 3 * mt;
          }
          return new Lh(Se / be, Me / be, 0, ge);
        }(r), ue = B.length; B.length; ) {
          var oe = B.pop();
          (oe.d > te.d || !te.d) && (te = oe, l && console.log("found best %d after %d probes", Math.round(1e4 * oe.d) / 1e4, ue)), oe.max - te.d <= i || (B.push(new Lh(oe.p.x - (D = oe.h / 2), oe.p.y - D, D, r)), B.push(new Lh(oe.p.x + D, oe.p.y - D, D, r)), B.push(new Lh(oe.p.x - D, oe.p.y + D, D, r)), B.push(new Lh(oe.p.x + D, oe.p.y + D, D, r)), ue += 4);
        }
        return l && (console.log("num probes: " + ue), console.log("best distance: " + te.d)), te.p;
      }
      function RO(r, i) {
        return i.max - r.max;
      }
      function Lh(r, i, l, p) {
        this.p = new T(r, i), this.h = l, this.d = function(y, v) {
          for (var x = !1, S = 1 / 0, C = 0; C < v.length; C++)
            for (var P = v[C], L = 0, D = P.length, B = D - 1; L < D; B = L++) {
              var j = P[L], Q = P[B];
              j.y > y.y != Q.y > y.y && y.x < (Q.x - j.x) * (y.y - j.y) / (Q.y - j.y) + j.x && (x = !x), S = Math.min(S, nu(y, j, Q));
            }
          return (x ? 1 : -1) * Math.sqrt(S);
        }(this.p, p), this.max = this.d + this.h * Math.SQRT2;
      }
      kh.prototype.push = function(r) {
        this.data.push(r), this.length++, this._up(this.length - 1);
      }, kh.prototype.pop = function() {
        if (this.length !== 0) {
          var r = this.data[0], i = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = i, this._down(0)), r;
        }
      }, kh.prototype.peek = function() {
        return this.data[0];
      }, kh.prototype._up = function(r) {
        for (var i = this.data, l = this.compare, p = i[r]; r > 0; ) {
          var y = r - 1 >> 1, v = i[y];
          if (l(p, v) >= 0)
            break;
          i[r] = v, r = y;
        }
        i[r] = p;
      }, kh.prototype._down = function(r) {
        for (var i = this.data, l = this.compare, p = this.length >> 1, y = i[r]; r < p; ) {
          var v = 1 + (r << 1), x = i[v], S = v + 1;
          if (S < this.length && l(i[S], x) < 0 && (v = S, x = i[S]), l(x, y) >= 0)
            break;
          i[r] = x, r = v;
        }
        i[r] = y;
      };
      var s_ = Number.POSITIVE_INFINITY;
      function Ux(r, i) {
        return i[1] !== s_ ? function(l, p, y) {
          var v = 0, x = 0;
          switch (p = Math.abs(p), y = Math.abs(y), l) {
            case "top-right":
            case "top-left":
            case "top":
              x = y - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              x = 7 - y;
          }
          switch (l) {
            case "top-right":
            case "bottom-right":
            case "right":
              v = -p;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              v = p;
          }
          return [v, x];
        }(r, i[0], i[1]) : function(l, p) {
          var y = 0, v = 0;
          p < 0 && (p = 0);
          var x = p / Math.sqrt(2);
          switch (l) {
            case "top-right":
            case "top-left":
              v = x - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              v = 7 - x;
              break;
            case "bottom":
              v = 7 - p;
              break;
            case "top":
              v = p - 7;
          }
          switch (l) {
            case "top-right":
            case "bottom-right":
              y = -x;
              break;
            case "top-left":
            case "bottom-left":
              y = x;
              break;
            case "left":
              y = p;
              break;
            case "right":
              y = -p;
          }
          return [y, v];
        }(r, i[0]);
      }
      function l_(r) {
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function jx(r, i, l, p, y, v, x, S, C, P, L, D, B, j, Q) {
        var te = function(Se, Me, Fe, Xe, nt, At, pt, Nt) {
          for (var mt = Xe.layout.get("text-rotate").evaluate(At, {}) * Math.PI / 180, or = [], $t = 0, Mt = Me.positionedLines; $t < Mt.length; $t += 1)
            for (var cr = Mt[$t], rr = 0, Er = cr.positionedGlyphs; rr < Er.length; rr += 1) {
              var Rt = Er[rr];
              if (Rt.rect) {
                var Pr = Rt.rect || {}, gn = 4, On = !0, Mn = 1, vn = 0, Cn = (nt || Nt) && Rt.vertical, ui = Rt.metrics.advance * Rt.scale / 2;
                if (Nt && Me.verticalizable && (vn = cr.lineOffset / 2 - (Rt.imageName ? -(24 - Rt.metrics.width * Rt.scale) / 2 : 24 * (Rt.scale - 1))), Rt.imageName) {
                  var ci = pt[Rt.imageName];
                  On = ci.sdf, gn = 1 / (Mn = ci.pixelRatio);
                }
                var Wi = nt ? [Rt.x + ui, Rt.y] : [0, 0], _i = nt ? [0, 0] : [Rt.x + ui + Fe[0], Rt.y + Fe[1] - vn], Hi = [0, 0];
                Cn && (Hi = _i, _i = [0, 0]);
                var Dn = (Rt.metrics.left - gn) * Rt.scale - ui + _i[0], xi = (-Rt.metrics.top - gn) * Rt.scale + _i[1], gr = Dn + Pr.w * Rt.scale / Mn, Xr = xi + Pr.h * Rt.scale / Mn, qr = new T(Dn, xi), Mr = new T(gr, xi), ro = new T(Dn, Xr), Di = new T(gr, Xr);
                if (Cn) {
                  var an = new T(-ui, ui - -17), qn = -Math.PI / 2, Ni = 12 - ui, kr = new T(22 - Ni, -(Rt.imageName ? Ni : 0)), Cs = new (Function.prototype.bind.apply(T, [null].concat(Hi)))();
                  qr._rotateAround(qn, an)._add(kr)._add(Cs), Mr._rotateAround(qn, an)._add(kr)._add(Cs), ro._rotateAround(qn, an)._add(kr)._add(Cs), Di._rotateAround(qn, an)._add(kr)._add(Cs);
                }
                if (mt) {
                  var Ko = Math.sin(mt), As = Math.cos(mt), Nn = [As, -Ko, Ko, As];
                  qr._matMult(Nn), Mr._matMult(Nn), ro._matMult(Nn), Di._matMult(Nn);
                }
                var Ps = new T(0, 0), Ta = new T(0, 0);
                or.push({ tl: qr, tr: Mr, bl: ro, br: Di, tex: Pr, writingMode: Me.writingMode, glyphOffset: Wi, sectionIndex: Rt.sectionIndex, isSDF: On, pixelOffsetTL: Ps, pixelOffsetBR: Ta, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
          return or;
        }(0, l, S, y, v, x, p, r.allowVerticalPlacement), ue = r.textSizeData, oe = null;
        ue.kind === "source" ? (oe = [128 * y.layout.get("text-size").evaluate(x, {})])[0] > 32640 && yt(r.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".') : ue.kind === "composite" && ((oe = [128 * j.compositeTextSizes[0].evaluate(x, {}, Q), 128 * j.compositeTextSizes[1].evaluate(x, {}, Q)])[0] > 32640 || oe[1] > 32640) && yt(r.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".'), r.addSymbols(r.text, te, oe, S, v, x, P, i, C.lineStartIndex, C.lineLength, B, Q);
        for (var ge = 0, be = L; ge < be.length; ge += 1)
          D[be[ge]] = r.text.placedSymbolArray.length - 1;
        return 4 * te.length;
      }
      function Gx(r) {
        for (var i in r)
          return r[i];
        return null;
      }
      function zO(r, i, l, p) {
        var y = r.compareText;
        if (i in y) {
          for (var v = y[i], x = v.length - 1; x >= 0; x--)
            if (p.dist(v[x]) < l)
              return !0;
        } else
          y[i] = [];
        return y[i].push(p), !1;
      }
      var FO = Ih.VectorTileFeature.types, BO = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Zm(r, i, l, p, y, v, x, S, C, P, L, D, B) {
        var j = S ? Math.min(32640, Math.round(S[0])) : 0, Q = S ? Math.min(32640, Math.round(S[1])) : 0;
        r.emplaceBack(i, l, Math.round(32 * p), Math.round(32 * y), v, x, (j << 1) + (C ? 1 : 0), Q, 16 * P, 16 * L, 256 * D, 256 * B);
      }
      function u_(r, i, l) {
        r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l);
      }
      function VO(r) {
        for (var i = 0, l = r.sections; i < l.length; i += 1)
          if (yh(l[i].text))
            return !0;
        return !1;
      }
      var Dh = function(r) {
        this.layoutVertexArray = new xh(), this.indexArray = new Es(), this.programConfigurations = r, this.segments = new $(), this.dynamicLayoutVertexArray = new eu(), this.opacityVertexArray = new oc(), this.placedSymbolArray = new d();
      };
      Dh.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
      }, Dh.prototype.upload = function(r, i, l, p) {
        this.isEmpty() || (l && (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, fO.members), this.indexBuffer = r.createIndexBuffer(this.indexArray, i), this.dynamicLayoutVertexBuffer = r.createVertexBuffer(this.dynamicLayoutVertexArray, pO.members, !0), this.opacityVertexBuffer = r.createVertexBuffer(this.opacityVertexArray, BO, !0), this.opacityVertexBuffer.itemSize = 1), (l || p) && this.programConfigurations.upload(r));
      }, Dh.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
      }, wt("SymbolBuffers", Dh);
      var Sp = function(r, i, l) {
        this.layoutVertexArray = new r(), this.layoutAttributes = i, this.indexArray = new l(), this.segments = new $(), this.collisionVertexArray = new fp();
      };
      Sp.prototype.upload = function(r) {
        this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = r.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = r.createVertexBuffer(this.collisionVertexArray, dO.members, !0);
      }, Sp.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
      }, wt("CollisionBuffers", Sp);
      var $r = function(r) {
        this.collisionBoxArray = r.collisionBoxArray, this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(v) {
          return v.id;
        }), this.index = r.index, this.pixelRatio = r.pixelRatio, this.sourceLayerIndex = r.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Oo([]), this.placementViewportMatrix = Oo([]);
        var i = this.layers[0]._unevaluatedLayout._values;
        this.textSizeData = a_(this.zoom, i["text-size"]), this.iconSizeData = a_(this.zoom, i["icon-size"]);
        var l = this.layers[0].layout, p = l.get("symbol-sort-key"), y = l.get("symbol-z-order");
        this.canOverlap = l.get("text-allow-overlap") || l.get("icon-allow-overlap") || l.get("text-ignore-placement") || l.get("icon-ignore-placement"), this.sortFeaturesByKey = y !== "viewport-y" && p.constantOr(1) !== void 0, this.sortFeaturesByY = (y === "viewport-y" || y === "auto" && !this.sortFeaturesByKey) && this.canOverlap, l.get("symbol-placement") === "point" && (this.writingModes = l.get("text-writing-mode").map(function(v) {
          return Xo[v];
        })), this.stateDependentLayerIds = this.layers.filter(function(v) {
          return v.isStateDependent();
        }).map(function(v) {
          return v.id;
        }), this.sourceID = r.sourceID;
      };
      $r.prototype.createArrays = function() {
        this.text = new Dh(new qt(this.layers, this.zoom, function(r) {
          return /^text/.test(r);
        })), this.icon = new Dh(new qt(this.layers, this.zoom, function(r) {
          return /^icon/.test(r);
        })), this.glyphOffsetArray = new E(), this.lineVertexArray = new O(), this.symbolInstances = new w();
      }, $r.prototype.calculateGlyphDependencies = function(r, i, l, p, y) {
        for (var v = 0; v < r.length; v++)
          if (i[r.charCodeAt(v)] = !0, (l || p) && y) {
            var x = bp[r.charAt(v)];
            x && (i[x.charCodeAt(0)] = !0);
          }
      }, $r.prototype.populate = function(r, i, l) {
        var p = this.layers[0], y = p.layout, v = y.get("text-font"), x = y.get("text-field"), S = y.get("icon-image"), C = (x.value.kind !== "constant" || x.value.value instanceof di && !x.value.value.isEmpty() || x.value.value.toString().length > 0) && (v.value.kind !== "constant" || v.value.value.length > 0), P = S.value.kind !== "constant" || !!S.value.value || Object.keys(S.parameters).length > 0, L = y.get("symbol-sort-key");
        if (this.features = [], C || P) {
          for (var D = i.iconDependencies, B = i.glyphDependencies, j = i.availableImages, Q = new pr(this.zoom), te = 0, ue = r; te < ue.length; te += 1) {
            var oe = ue[te], ge = oe.feature, be = oe.id, Se = oe.index, Me = oe.sourceLayerIndex, Fe = p._featureFilter.needGeometry, Xe = Ln(ge, Fe);
            if (p._featureFilter.filter(Q, Xe, l)) {
              Fe || (Xe.geometry = Tn(ge));
              var nt = void 0;
              if (C) {
                var At = p.getValueAndResolveTokens("text-field", Xe, l, j), pt = di.factory(At);
                VO(pt) && (this.hasRTLText = !0), (!this.hasRTLText || lp() === "unavailable" || this.hasRTLText && Io.isParsed()) && (nt = yO(pt, p, Xe));
              }
              var Nt = void 0;
              if (P) {
                var mt = p.getValueAndResolveTokens("icon-image", Xe, l, j);
                Nt = mt instanceof Ji ? mt : Ji.fromString(mt);
              }
              if (nt || Nt) {
                var or = this.sortFeaturesByKey ? L.evaluate(Xe, {}, l) : void 0;
                if (this.features.push({ id: be, text: nt, icon: Nt, index: Se, sourceLayerIndex: Me, geometry: Xe.geometry, properties: ge.properties, type: FO[ge.type], sortKey: or }), Nt && (D[Nt.name] = !0), nt) {
                  var $t = v.evaluate(Xe, {}, l).join(","), Mt = y.get("text-rotation-alignment") === "map" && y.get("symbol-placement") !== "point";
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Xo.vertical) >= 0;
                  for (var cr = 0, rr = nt.sections; cr < rr.length; cr += 1) {
                    var Er = rr[cr];
                    if (Er.image)
                      D[Er.image.name] = !0;
                    else {
                      var Rt = op(nt.toString()), Pr = Er.fontStack || $t, gn = B[Pr] = B[Pr] || {};
                      this.calculateGlyphDependencies(Er.text, gn, Mt, this.allowVerticalPlacement, Rt);
                    }
                  }
                }
              }
            }
          }
          y.get("symbol-placement") === "line" && (this.features = function(On) {
            var Mn = {}, vn = {}, Cn = [], ui = 0;
            function ci(an) {
              Cn.push(On[an]), ui++;
            }
            function Wi(an, qn, Ni) {
              var kr = vn[an];
              return delete vn[an], vn[qn] = kr, Cn[kr].geometry[0].pop(), Cn[kr].geometry[0] = Cn[kr].geometry[0].concat(Ni[0]), kr;
            }
            function _i(an, qn, Ni) {
              var kr = Mn[qn];
              return delete Mn[qn], Mn[an] = kr, Cn[kr].geometry[0].shift(), Cn[kr].geometry[0] = Ni[0].concat(Cn[kr].geometry[0]), kr;
            }
            function Hi(an, qn, Ni) {
              var kr = Ni ? qn[0][qn[0].length - 1] : qn[0][0];
              return an + ":" + kr.x + ":" + kr.y;
            }
            for (var Dn = 0; Dn < On.length; Dn++) {
              var xi = On[Dn], gr = xi.geometry, Xr = xi.text ? xi.text.toString() : null;
              if (Xr) {
                var qr = Hi(Xr, gr), Mr = Hi(Xr, gr, !0);
                if (qr in vn && Mr in Mn && vn[qr] !== Mn[Mr]) {
                  var ro = _i(qr, Mr, gr), Di = Wi(qr, Mr, Cn[ro].geometry);
                  delete Mn[qr], delete vn[Mr], vn[Hi(Xr, Cn[Di].geometry, !0)] = Di, Cn[ro].geometry = null;
                } else
                  qr in vn ? Wi(qr, Mr, gr) : Mr in Mn ? _i(qr, Mr, gr) : (ci(Dn), Mn[qr] = ui - 1, vn[Mr] = ui - 1);
              } else
                ci(Dn);
            }
            return Cn.filter(function(an) {
              return an.geometry;
            });
          }(this.features)), this.sortFeaturesByKey && this.features.sort(function(On, Mn) {
            return On.sortKey - Mn.sortKey;
          });
        }
      }, $r.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(r, i, this.layers, l), this.icon.programConfigurations.updatePaintArrays(r, i, this.layers, l));
      }, $r.prototype.isEmpty = function() {
        return this.symbolInstances.length === 0 && !this.hasRTLText;
      }, $r.prototype.uploadPending = function() {
        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
      }, $r.prototype.upload = function(r) {
        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(r), this.iconCollisionBox.upload(r)), this.text.upload(r, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(r, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
      }, $r.prototype.destroyDebugData = function() {
        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
      }, $r.prototype.destroy = function() {
        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
      }, $r.prototype.addToLineVertexArray = function(r, i) {
        var l = this.lineVertexArray.length;
        if (r.segment !== void 0) {
          for (var p = r.dist(i[r.segment + 1]), y = r.dist(i[r.segment]), v = {}, x = r.segment + 1; x < i.length; x++)
            v[x] = { x: i[x].x, y: i[x].y, tileUnitDistanceFromAnchor: p }, x < i.length - 1 && (p += i[x + 1].dist(i[x]));
          for (var S = r.segment || 0; S >= 0; S--)
            v[S] = { x: i[S].x, y: i[S].y, tileUnitDistanceFromAnchor: y }, S > 0 && (y += i[S - 1].dist(i[S]));
          for (var C = 0; C < i.length; C++) {
            var P = v[C];
            this.lineVertexArray.emplaceBack(P.x, P.y, P.tileUnitDistanceFromAnchor);
          }
        }
        return { lineStartIndex: l, lineLength: this.lineVertexArray.length - l };
      }, $r.prototype.addSymbols = function(r, i, l, p, y, v, x, S, C, P, L, D) {
        for (var B = r.indexArray, j = r.layoutVertexArray, Q = r.segments.prepareSegment(4 * i.length, j, B, this.canOverlap ? v.sortKey : void 0), te = this.glyphOffsetArray.length, ue = Q.vertexLength, oe = this.allowVerticalPlacement && x === Xo.vertical ? Math.PI / 2 : 0, ge = v.text && v.text.sections, be = 0; be < i.length; be++) {
          var Se = i[be], Me = Se.tl, Fe = Se.tr, Xe = Se.bl, nt = Se.br, At = Se.tex, pt = Se.pixelOffsetTL, Nt = Se.pixelOffsetBR, mt = Se.minFontScaleX, or = Se.minFontScaleY, $t = Se.glyphOffset, Mt = Se.isSDF, cr = Se.sectionIndex, rr = Q.vertexLength, Er = $t[1];
          Zm(j, S.x, S.y, Me.x, Er + Me.y, At.x, At.y, l, Mt, pt.x, pt.y, mt, or), Zm(j, S.x, S.y, Fe.x, Er + Fe.y, At.x + At.w, At.y, l, Mt, Nt.x, pt.y, mt, or), Zm(j, S.x, S.y, Xe.x, Er + Xe.y, At.x, At.y + At.h, l, Mt, pt.x, Nt.y, mt, or), Zm(j, S.x, S.y, nt.x, Er + nt.y, At.x + At.w, At.y + At.h, l, Mt, Nt.x, Nt.y, mt, or), u_(r.dynamicLayoutVertexArray, S, oe), B.emplaceBack(rr, rr + 1, rr + 2), B.emplaceBack(rr + 1, rr + 2, rr + 3), Q.vertexLength += 4, Q.primitiveLength += 2, this.glyphOffsetArray.emplaceBack($t[0]), be !== i.length - 1 && cr === i[be + 1].sectionIndex || r.programConfigurations.populatePaintArrays(j.length, v, v.index, {}, D, ge && ge[cr]);
        }
        r.placedSymbolArray.emplaceBack(S.x, S.y, te, this.glyphOffsetArray.length - te, ue, C, P, S.segment, l ? l[0] : 0, l ? l[1] : 0, p[0], p[1], x, 0, !1, 0, L);
      }, $r.prototype._addCollisionDebugVertex = function(r, i, l, p, y, v) {
        return i.emplaceBack(0, 0), r.emplaceBack(l.x, l.y, p, y, Math.round(v.x), Math.round(v.y));
      }, $r.prototype.addCollisionDebugVertices = function(r, i, l, p, y, v, x) {
        var S = y.segments.prepareSegment(4, y.layoutVertexArray, y.indexArray), C = S.vertexLength, P = y.layoutVertexArray, L = y.collisionVertexArray, D = x.anchorX, B = x.anchorY;
        this._addCollisionDebugVertex(P, L, v, D, B, new T(r, i)), this._addCollisionDebugVertex(P, L, v, D, B, new T(l, i)), this._addCollisionDebugVertex(P, L, v, D, B, new T(l, p)), this._addCollisionDebugVertex(P, L, v, D, B, new T(r, p)), S.vertexLength += 4;
        var j = y.indexArray;
        j.emplaceBack(C, C + 1), j.emplaceBack(C + 1, C + 2), j.emplaceBack(C + 2, C + 3), j.emplaceBack(C + 3, C), S.primitiveLength += 4;
      }, $r.prototype.addDebugCollisionBoxes = function(r, i, l, p) {
        for (var y = r; y < i; y++) {
          var v = this.collisionBoxArray.get(y);
          this.addCollisionDebugVertices(v.x1, v.y1, v.x2, v.y2, p ? this.textCollisionBox : this.iconCollisionBox, v.anchorPoint, l);
        }
      }, $r.prototype.generateCollisionDebugBuffers = function() {
        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Sp(tu, bx.members, ac), this.iconCollisionBox = new Sp(tu, bx.members, ac);
        for (var r = 0; r < this.symbolInstances.length; r++) {
          var i = this.symbolInstances.get(r);
          this.addDebugCollisionBoxes(i.textBoxStartIndex, i.textBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.iconBoxStartIndex, i.iconBoxEndIndex, i, !1), this.addDebugCollisionBoxes(i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex, i, !1);
        }
      }, $r.prototype._deserializeCollisionBoxesForSymbol = function(r, i, l, p, y, v, x, S, C) {
        for (var P = {}, L = i; L < l; L++) {
          var D = r.get(L);
          P.textBox = { x1: D.x1, y1: D.y1, x2: D.x2, y2: D.y2, anchorPointX: D.anchorPointX, anchorPointY: D.anchorPointY }, P.textFeatureIndex = D.featureIndex;
          break;
        }
        for (var B = p; B < y; B++) {
          var j = r.get(B);
          P.verticalTextBox = { x1: j.x1, y1: j.y1, x2: j.x2, y2: j.y2, anchorPointX: j.anchorPointX, anchorPointY: j.anchorPointY }, P.verticalTextFeatureIndex = j.featureIndex;
          break;
        }
        for (var Q = v; Q < x; Q++) {
          var te = r.get(Q);
          P.iconBox = { x1: te.x1, y1: te.y1, x2: te.x2, y2: te.y2, anchorPointX: te.anchorPointX, anchorPointY: te.anchorPointY }, P.iconFeatureIndex = te.featureIndex;
          break;
        }
        for (var ue = S; ue < C; ue++) {
          var oe = r.get(ue);
          P.verticalIconBox = { x1: oe.x1, y1: oe.y1, x2: oe.x2, y2: oe.y2, anchorPointX: oe.anchorPointX, anchorPointY: oe.anchorPointY }, P.verticalIconFeatureIndex = oe.featureIndex;
          break;
        }
        return P;
      }, $r.prototype.deserializeCollisionBoxes = function(r) {
        this.collisionArrays = [];
        for (var i = 0; i < this.symbolInstances.length; i++) {
          var l = this.symbolInstances.get(i);
          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(r, l.textBoxStartIndex, l.textBoxEndIndex, l.verticalTextBoxStartIndex, l.verticalTextBoxEndIndex, l.iconBoxStartIndex, l.iconBoxEndIndex, l.verticalIconBoxStartIndex, l.verticalIconBoxEndIndex));
        }
      }, $r.prototype.hasTextData = function() {
        return this.text.segments.get().length > 0;
      }, $r.prototype.hasIconData = function() {
        return this.icon.segments.get().length > 0;
      }, $r.prototype.hasDebugData = function() {
        return this.textCollisionBox && this.iconCollisionBox;
      }, $r.prototype.hasTextCollisionBoxData = function() {
        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
      }, $r.prototype.hasIconCollisionBoxData = function() {
        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
      }, $r.prototype.addIndicesForPlacedSymbol = function(r, i) {
        for (var l = r.placedSymbolArray.get(i), p = l.vertexStartIndex + 4 * l.numGlyphs, y = l.vertexStartIndex; y < p; y += 4)
          r.indexArray.emplaceBack(y, y + 1, y + 2), r.indexArray.emplaceBack(y + 1, y + 2, y + 3);
      }, $r.prototype.getSortedSymbolIndexes = function(r) {
        if (this.sortedAngle === r && this.symbolInstanceIndexes !== void 0)
          return this.symbolInstanceIndexes;
        for (var i = Math.sin(r), l = Math.cos(r), p = [], y = [], v = [], x = 0; x < this.symbolInstances.length; ++x) {
          v.push(x);
          var S = this.symbolInstances.get(x);
          p.push(0 | Math.round(i * S.anchorX + l * S.anchorY)), y.push(S.featureIndex);
        }
        return v.sort(function(C, P) {
          return p[C] - p[P] || y[P] - y[C];
        }), v;
      }, $r.prototype.addToSortKeyRanges = function(r, i) {
        var l = this.sortKeyRanges[this.sortKeyRanges.length - 1];
        l && l.sortKey === i ? l.symbolInstanceEnd = r + 1 : this.sortKeyRanges.push({ sortKey: i, symbolInstanceStart: r, symbolInstanceEnd: r + 1 });
      }, $r.prototype.sortFeatures = function(r) {
        var i = this;
        if (this.sortFeaturesByY && this.sortedAngle !== r && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(r), this.sortedAngle = r, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
          for (var l = 0, p = this.symbolInstanceIndexes; l < p.length; l += 1) {
            var y = this.symbolInstances.get(p[l]);
            this.featureSortOrder.push(y.featureIndex), [y.rightJustifiedTextSymbolIndex, y.centerJustifiedTextSymbolIndex, y.leftJustifiedTextSymbolIndex].forEach(function(v, x, S) {
              v >= 0 && S.indexOf(v) === x && i.addIndicesForPlacedSymbol(i.text, v);
            }), y.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, y.verticalPlacedTextSymbolIndex), y.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, y.placedIconSymbolIndex), y.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, y.verticalPlacedIconSymbolIndex);
          }
          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
        }
      }, wt("SymbolBucket", $r, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), $r.MAX_GLYPHS = 65535, $r.addDynamicAttributes = u_;
      var UO = new Mi({ "symbol-placement": new Lt(G.layout_symbol["symbol-placement"]), "symbol-spacing": new Lt(G.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Lt(G.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Tt(G.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Lt(G.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Lt(G.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Lt(G.layout_symbol["icon-ignore-placement"]), "icon-optional": new Lt(G.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Lt(G.layout_symbol["icon-rotation-alignment"]), "icon-size": new Tt(G.layout_symbol["icon-size"]), "icon-text-fit": new Lt(G.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Lt(G.layout_symbol["icon-text-fit-padding"]), "icon-image": new Tt(G.layout_symbol["icon-image"]), "icon-rotate": new Tt(G.layout_symbol["icon-rotate"]), "icon-padding": new Lt(G.layout_symbol["icon-padding"]), "icon-keep-upright": new Lt(G.layout_symbol["icon-keep-upright"]), "icon-offset": new Tt(G.layout_symbol["icon-offset"]), "icon-anchor": new Tt(G.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Lt(G.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Lt(G.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Lt(G.layout_symbol["text-rotation-alignment"]), "text-field": new Tt(G.layout_symbol["text-field"]), "text-font": new Tt(G.layout_symbol["text-font"]), "text-size": new Tt(G.layout_symbol["text-size"]), "text-max-width": new Tt(G.layout_symbol["text-max-width"]), "text-line-height": new Lt(G.layout_symbol["text-line-height"]), "text-letter-spacing": new Tt(G.layout_symbol["text-letter-spacing"]), "text-justify": new Tt(G.layout_symbol["text-justify"]), "text-radial-offset": new Tt(G.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Lt(G.layout_symbol["text-variable-anchor"]), "text-anchor": new Tt(G.layout_symbol["text-anchor"]), "text-max-angle": new Lt(G.layout_symbol["text-max-angle"]), "text-writing-mode": new Lt(G.layout_symbol["text-writing-mode"]), "text-rotate": new Tt(G.layout_symbol["text-rotate"]), "text-padding": new Lt(G.layout_symbol["text-padding"]), "text-keep-upright": new Lt(G.layout_symbol["text-keep-upright"]), "text-transform": new Tt(G.layout_symbol["text-transform"]), "text-offset": new Tt(G.layout_symbol["text-offset"]), "text-allow-overlap": new Lt(G.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Lt(G.layout_symbol["text-ignore-placement"]), "text-optional": new Lt(G.layout_symbol["text-optional"]) }), c_ = { paint: new Mi({ "icon-opacity": new Tt(G.paint_symbol["icon-opacity"]), "icon-color": new Tt(G.paint_symbol["icon-color"]), "icon-halo-color": new Tt(G.paint_symbol["icon-halo-color"]), "icon-halo-width": new Tt(G.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Tt(G.paint_symbol["icon-halo-blur"]), "icon-translate": new Lt(G.paint_symbol["icon-translate"]), "icon-translate-anchor": new Lt(G.paint_symbol["icon-translate-anchor"]), "text-opacity": new Tt(G.paint_symbol["text-opacity"]), "text-color": new Tt(G.paint_symbol["text-color"], { runtimeType: ke, getOverride: function(r) {
        return r.textColor;
      }, hasOverride: function(r) {
        return !!r.textColor;
      } }), "text-halo-color": new Tt(G.paint_symbol["text-halo-color"]), "text-halo-width": new Tt(G.paint_symbol["text-halo-width"]), "text-halo-blur": new Tt(G.paint_symbol["text-halo-blur"]), "text-translate": new Lt(G.paint_symbol["text-translate"]), "text-translate-anchor": new Lt(G.paint_symbol["text-translate-anchor"]) }), layout: UO }, Nh = function(r) {
        this.type = r.property.overrides ? r.property.overrides.runtimeType : _t, this.defaultValue = r;
      };
      Nh.prototype.evaluate = function(r) {
        if (r.formattedSection) {
          var i = this.defaultValue.property.overrides;
          if (i && i.hasOverride(r.formattedSection))
            return i.getOverride(r.formattedSection);
        }
        return r.feature && r.featureState ? this.defaultValue.evaluate(r.feature, r.featureState) : this.defaultValue.property.specification.default;
      }, Nh.prototype.eachChild = function(r) {
        this.defaultValue.isConstant() || r(this.defaultValue.value._styleExpression.expression);
      }, Nh.prototype.outputDefined = function() {
        return !1;
      }, Nh.prototype.serialize = function() {
        return null;
      }, wt("FormatSectionOverride", Nh, { omit: ["defaultValue"] });
      var jO = function(r) {
        function i(l) {
          r.call(this, l, c_);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.recalculate = function(l, p) {
          if (r.prototype.recalculate.call(this, l, p), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            var y = this.layout.get("text-writing-mode");
            if (y) {
              for (var v = [], x = 0, S = y; x < S.length; x += 1) {
                var C = S[x];
                v.indexOf(C) < 0 && v.push(C);
              }
              this.layout._values["text-writing-mode"] = v;
            } else
              this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }, i.prototype.getValueAndResolveTokens = function(l, p, y, v) {
          var x = this.layout.get(l).evaluate(p, {}, y, v), S = this._unevaluatedLayout._values[l];
          return S.isDataDriven() || Zu(S.value) || !x ? x : function(C, P) {
            return P.replace(/{([^{}]+)}/g, function(L, D) {
              return D in C ? String(C[D]) : "";
            });
          }(p.properties, x);
        }, i.prototype.createBucket = function(l) {
          return new $r(l);
        }, i.prototype.queryRadius = function() {
          return 0;
        }, i.prototype.queryIntersectsFeature = function() {
          return !1;
        }, i.prototype._setPaintOverrides = function() {
          for (var l = 0, p = c_.paint.overridableProperties; l < p.length; l += 1) {
            var y = p[l];
            if (i.hasPaintOverride(this.layout, y)) {
              var v, x = this.paint.get(y), S = new Nh(x), C = new Zl(S, x.property.specification);
              v = x.value.kind === "constant" || x.value.kind === "source" ? new Xu("source", C) : new Xl("composite", C, x.value.zoomStops, x.value._interpolationType), this.paint._values[y] = new ji(x.property, v, x.parameters);
            }
          }
        }, i.prototype._handleOverridablePaintPropertyUpdate = function(l, p, y) {
          return !(!this.layout || p.isDataDriven() || y.isDataDriven()) && i.hasPaintOverride(this.layout, l);
        }, i.hasPaintOverride = function(l, p) {
          var y = l.get("text-field"), v = c_.paint.properties[p], x = !1, S = function(L) {
            for (var D = 0, B = L; D < B.length; D += 1)
              if (v.overrides && v.overrides.hasOverride(B[D]))
                return void (x = !0);
          };
          if (y.value.kind === "constant" && y.value.value instanceof di)
            S(y.value.value.sections);
          else if (y.value.kind === "source") {
            var C = function(L) {
              x || (L instanceof Vi && kn(L.value) === jt ? S(L.value.sections) : L instanceof ia ? S(L.sections) : L.eachChild(C));
            }, P = y.value;
            P._styleExpression && C(P._styleExpression.expression);
          }
          return x;
        }, i;
      }(ba), GO = { paint: new Mi({ "background-color": new Lt(G.paint_background["background-color"]), "background-pattern": new Gi(G.paint_background["background-pattern"]), "background-opacity": new Lt(G.paint_background["background-opacity"]) }) }, qO = function(r) {
        function i(l) {
          r.call(this, l, GO);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(ba), $O = { paint: new Mi({ "raster-opacity": new Lt(G.paint_raster["raster-opacity"]), "raster-hue-rotate": new Lt(G.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Lt(G.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Lt(G.paint_raster["raster-brightness-max"]), "raster-saturation": new Lt(G.paint_raster["raster-saturation"]), "raster-contrast": new Lt(G.paint_raster["raster-contrast"]), "raster-resampling": new Lt(G.paint_raster["raster-resampling"]), "raster-fade-duration": new Lt(G.paint_raster["raster-fade-duration"]) }) }, WO = function(r) {
        function i(l) {
          r.call(this, l, $O);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(ba), HO = function(r) {
        function i(l) {
          r.call(this, l, {}), this.implementation = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.is3D = function() {
          return this.implementation.renderingMode === "3d";
        }, i.prototype.hasOffscreenPass = function() {
          return this.implementation.prerender !== void 0;
        }, i.prototype.recalculate = function() {
        }, i.prototype.updateTransitions = function() {
        }, i.prototype.hasTransition = function() {
        }, i.prototype.serialize = function() {
        }, i.prototype.onAdd = function(l) {
          this.implementation.onAdd && this.implementation.onAdd(l, l.painter.context.gl);
        }, i.prototype.onRemove = function(l) {
          this.implementation.onRemove && this.implementation.onRemove(l, l.painter.context.gl);
        }, i;
      }(ba), ZO = { circle: Zv, heatmap: PI, hillshade: LI, fill: KI, "fill-extrusion": oO, line: hO, symbol: jO, background: qO, raster: WO }, qx = I.HTMLImageElement, $x = I.HTMLCanvasElement, Wx = I.HTMLVideoElement, Hx = I.ImageData, Xm = I.ImageBitmap, fc = function(r, i, l, p) {
        this.context = r, this.format = l, this.texture = r.gl.createTexture(), this.update(i, p);
      };
      fc.prototype.update = function(r, i, l) {
        var p = r.width, y = r.height, v = !(this.size && this.size[0] === p && this.size[1] === y || l), x = this.context, S = x.gl;
        if (this.useMipmap = Boolean(i && i.useMipmap), S.bindTexture(S.TEXTURE_2D, this.texture), x.pixelStoreUnpackFlipY.set(!1), x.pixelStoreUnpack.set(1), x.pixelStoreUnpackPremultiplyAlpha.set(this.format === S.RGBA && (!i || i.premultiply !== !1)), v)
          this.size = [p, y], r instanceof qx || r instanceof $x || r instanceof Wx || r instanceof Hx || Xm && r instanceof Xm ? S.texImage2D(S.TEXTURE_2D, 0, this.format, this.format, S.UNSIGNED_BYTE, r) : S.texImage2D(S.TEXTURE_2D, 0, this.format, p, y, 0, this.format, S.UNSIGNED_BYTE, r.data);
        else {
          var C = l || { x: 0, y: 0 }, P = C.x, L = C.y;
          r instanceof qx || r instanceof $x || r instanceof Wx || r instanceof Hx || Xm && r instanceof Xm ? S.texSubImage2D(S.TEXTURE_2D, 0, P, L, S.RGBA, S.UNSIGNED_BYTE, r) : S.texSubImage2D(S.TEXTURE_2D, 0, P, L, p, y, S.RGBA, S.UNSIGNED_BYTE, r.data);
        }
        this.useMipmap && this.isSizePowerOfTwo() && S.generateMipmap(S.TEXTURE_2D);
      }, fc.prototype.bind = function(r, i, l) {
        var p = this.context.gl;
        p.bindTexture(p.TEXTURE_2D, this.texture), l !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (l = p.LINEAR), r !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, r), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, l || r), this.filter = r), i !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, i), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, i), this.wrap = i);
      }, fc.prototype.isSizePowerOfTwo = function() {
        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
      }, fc.prototype.destroy = function() {
        this.context.gl.deleteTexture(this.texture), this.texture = null;
      };
      var h_ = function(r) {
        var i = this;
        this._callback = r, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function() {
          i._triggered = !1, i._callback();
        });
      };
      h_.prototype.trigger = function() {
        var r = this;
        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(function() {
          r._triggered = !1, r._callback();
        }, 0));
      }, h_.prototype.remove = function() {
        delete this._channel, this._callback = function() {
        };
      };
      var Rh = function(r, i, l) {
        this.target = r, this.parent = i, this.mapId = l, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, De(["receive", "process"], this), this.invoker = new h_(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = ct() ? r : I;
      };
      function Zx(r, i, l) {
        var p = 2 * Math.PI * 6378137 / 256 / Math.pow(2, l);
        return [r * p - 2 * Math.PI * 6378137 / 2, i * p - 2 * Math.PI * 6378137 / 2];
      }
      Rh.prototype.send = function(r, i, l, p, y) {
        var v = this;
        y === void 0 && (y = !1);
        var x = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
        l && (this.callbacks[x] = l);
        var S = tr(this.globalScope) ? void 0 : [];
        return this.target.postMessage({ id: x, type: r, hasCallback: !!l, targetMapId: p, mustQueue: y, sourceMapId: this.mapId, data: aa(i, S) }, S), { cancel: function() {
          l && delete v.callbacks[x], v.target.postMessage({ id: x, type: "<cancel>", targetMapId: p, sourceMapId: v.mapId });
        } };
      }, Rh.prototype.receive = function(r) {
        var i = r.data, l = i.id;
        if (l && (!i.targetMapId || this.mapId === i.targetMapId))
          if (i.type === "<cancel>") {
            delete this.tasks[l];
            var p = this.cancelCallbacks[l];
            delete this.cancelCallbacks[l], p && p();
          } else
            ct() || i.mustQueue ? (this.tasks[l] = i, this.taskQueue.push(l), this.invoker.trigger()) : this.processTask(l, i);
      }, Rh.prototype.process = function() {
        if (this.taskQueue.length) {
          var r = this.taskQueue.shift(), i = this.tasks[r];
          delete this.tasks[r], this.taskQueue.length && this.invoker.trigger(), i && this.processTask(r, i);
        }
      }, Rh.prototype.processTask = function(r, i) {
        var l = this;
        if (i.type === "<response>") {
          var p = this.callbacks[r];
          delete this.callbacks[r], p && (i.error ? p(co(i.error)) : p(null, co(i.data)));
        } else {
          var y = !1, v = tr(this.globalScope) ? void 0 : [], x = i.hasCallback ? function(L, D) {
            y = !0, delete l.cancelCallbacks[r], l.target.postMessage({ id: r, type: "<response>", sourceMapId: l.mapId, error: L ? aa(L) : null, data: aa(D, v) }, v);
          } : function(L) {
            y = !0;
          }, S = null, C = co(i.data);
          if (this.parent[i.type])
            S = this.parent[i.type](i.sourceMapId, C, x);
          else if (this.parent.getWorkerSource) {
            var P = i.type.split(".");
            S = this.parent.getWorkerSource(i.sourceMapId, P[0], C.source)[P[1]](C, x);
          } else
            x(new Error("Could not find function " + i.type));
          !y && S && S.cancel && (this.cancelCallbacks[r] = S.cancel);
        }
      }, Rh.prototype.remove = function() {
        this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);
      };
      var ei = function(r, i) {
        r && (i ? this.setSouthWest(r).setNorthEast(i) : r.length === 4 ? this.setSouthWest([r[0], r[1]]).setNorthEast([r[2], r[3]]) : this.setSouthWest(r[0]).setNorthEast(r[1]));
      };
      ei.prototype.setNorthEast = function(r) {
        return this._ne = r instanceof yn ? new yn(r.lng, r.lat) : yn.convert(r), this;
      }, ei.prototype.setSouthWest = function(r) {
        return this._sw = r instanceof yn ? new yn(r.lng, r.lat) : yn.convert(r), this;
      }, ei.prototype.extend = function(r) {
        var i, l, p = this._sw, y = this._ne;
        if (r instanceof yn)
          i = r, l = r;
        else {
          if (!(r instanceof ei))
            return Array.isArray(r) ? r.length === 4 || r.every(Array.isArray) ? this.extend(ei.convert(r)) : this.extend(yn.convert(r)) : this;
          if (l = r._ne, !(i = r._sw) || !l)
            return this;
        }
        return p || y ? (p.lng = Math.min(i.lng, p.lng), p.lat = Math.min(i.lat, p.lat), y.lng = Math.max(l.lng, y.lng), y.lat = Math.max(l.lat, y.lat)) : (this._sw = new yn(i.lng, i.lat), this._ne = new yn(l.lng, l.lat)), this;
      }, ei.prototype.getCenter = function() {
        return new yn((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
      }, ei.prototype.getSouthWest = function() {
        return this._sw;
      }, ei.prototype.getNorthEast = function() {
        return this._ne;
      }, ei.prototype.getNorthWest = function() {
        return new yn(this.getWest(), this.getNorth());
      }, ei.prototype.getSouthEast = function() {
        return new yn(this.getEast(), this.getSouth());
      }, ei.prototype.getWest = function() {
        return this._sw.lng;
      }, ei.prototype.getSouth = function() {
        return this._sw.lat;
      }, ei.prototype.getEast = function() {
        return this._ne.lng;
      }, ei.prototype.getNorth = function() {
        return this._ne.lat;
      }, ei.prototype.toArray = function() {
        return [this._sw.toArray(), this._ne.toArray()];
      }, ei.prototype.toString = function() {
        return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";
      }, ei.prototype.isEmpty = function() {
        return !(this._sw && this._ne);
      }, ei.prototype.contains = function(r) {
        var i = yn.convert(r), l = i.lng, p = i.lat, y = this._sw.lng <= l && l <= this._ne.lng;
        return this._sw.lng > this._ne.lng && (y = this._sw.lng >= l && l >= this._ne.lng), this._sw.lat <= p && p <= this._ne.lat && y;
      }, ei.convert = function(r) {
        return !r || r instanceof ei ? r : new ei(r);
      };
      var yn = function(r, i) {
        if (isNaN(r) || isNaN(i))
          throw new Error("Invalid LngLat object: (" + r + ", " + i + ")");
        if (this.lng = +r, this.lat = +i, this.lat > 90 || this.lat < -90)
          throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
      };
      yn.prototype.wrap = function() {
        return new yn(X(this.lng, -180, 180), this.lat);
      }, yn.prototype.toArray = function() {
        return [this.lng, this.lat];
      }, yn.prototype.toString = function() {
        return "LngLat(" + this.lng + ", " + this.lat + ")";
      }, yn.prototype.distanceTo = function(r) {
        var i = Math.PI / 180, l = this.lat * i, p = r.lat * i, y = Math.sin(l) * Math.sin(p) + Math.cos(l) * Math.cos(p) * Math.cos((r.lng - this.lng) * i);
        return 63710088e-1 * Math.acos(Math.min(y, 1));
      }, yn.prototype.toBounds = function(r) {
        r === void 0 && (r = 0);
        var i = 360 * r / 40075017, l = i / Math.cos(Math.PI / 180 * this.lat);
        return new ei(new yn(this.lng - l, this.lat - i), new yn(this.lng + l, this.lat + i));
      }, yn.convert = function(r) {
        if (r instanceof yn)
          return r;
        if (Array.isArray(r) && (r.length === 2 || r.length === 3))
          return new yn(Number(r[0]), Number(r[1]));
        if (!Array.isArray(r) && typeof r == "object" && r !== null)
          return new yn(Number("lng" in r ? r.lng : r.lon), Number(r.lat));
        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
      };
      var Xx = 2 * Math.PI * 63710088e-1;
      function Kx(r) {
        return Xx * Math.cos(r * Math.PI / 180);
      }
      function Yx(r) {
        return (180 + r) / 360;
      }
      function Jx(r) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
      }
      function Qx(r, i) {
        return r / Kx(i);
      }
      function f_(r) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90;
      }
      var pc = function(r, i, l) {
        l === void 0 && (l = 0), this.x = +r, this.y = +i, this.z = +l;
      };
      pc.fromLngLat = function(r, i) {
        i === void 0 && (i = 0);
        var l = yn.convert(r);
        return new pc(Yx(l.lng), Jx(l.lat), Qx(i, l.lat));
      }, pc.prototype.toLngLat = function() {
        return new yn(360 * this.x - 180, f_(this.y));
      }, pc.prototype.toAltitude = function() {
        return this.z * Kx(f_(this.y));
      }, pc.prototype.meterInMercatorCoordinateUnits = function() {
        return 1 / Xx * (r = f_(this.y), 1 / Math.cos(r * Math.PI / 180));
        var r;
      };
      var dc = function(r, i, l) {
        this.z = r, this.x = i, this.y = l, this.key = Tp(0, r, r, i, l);
      };
      dc.prototype.equals = function(r) {
        return this.z === r.z && this.x === r.x && this.y === r.y;
      }, dc.prototype.url = function(r, i) {
        var l, p, y, v, x, S = (p = this.y, y = this.z, v = Zx(256 * (l = this.x), 256 * (p = Math.pow(2, y) - p - 1), y), x = Zx(256 * (l + 1), 256 * (p + 1), y), v[0] + "," + v[1] + "," + x[0] + "," + x[1]), C = function(P, L, D) {
          for (var B, j = "", Q = P; Q > 0; Q--)
            j += (L & (B = 1 << Q - 1) ? 1 : 0) + (D & B ? 2 : 0);
          return j;
        }(this.z, this.x, this.y);
        return r[(this.x + this.y) % r.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String(i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", C).replace("{bbox-epsg-3857}", S);
      }, dc.prototype.getTilePoint = function(r) {
        var i = Math.pow(2, this.z);
        return new T(8192 * (r.x * i - this.x), 8192 * (r.y * i - this.y));
      }, dc.prototype.toString = function() {
        return this.z + "/" + this.x + "/" + this.y;
      };
      var eb = function(r, i) {
        this.wrap = r, this.canonical = i, this.key = Tp(r, i.z, i.z, i.x, i.y);
      }, ti = function(r, i, l, p, y) {
        this.overscaledZ = r, this.wrap = i, this.canonical = new dc(l, +p, +y), this.key = Tp(i, r, l, p, y);
      };
      function Tp(r, i, l, p, y) {
        (r *= 2) < 0 && (r = -1 * r - 1);
        var v = 1 << l;
        return (v * v * r + v * y + p).toString(36) + l.toString(36) + i.toString(36);
      }
      ti.prototype.equals = function(r) {
        return this.overscaledZ === r.overscaledZ && this.wrap === r.wrap && this.canonical.equals(r.canonical);
      }, ti.prototype.scaledTo = function(r) {
        var i = this.canonical.z - r;
        return r > this.canonical.z ? new ti(r, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ti(r, this.wrap, r, this.canonical.x >> i, this.canonical.y >> i);
      }, ti.prototype.calculateScaledKey = function(r, i) {
        var l = this.canonical.z - r;
        return r > this.canonical.z ? Tp(this.wrap * +i, r, this.canonical.z, this.canonical.x, this.canonical.y) : Tp(this.wrap * +i, r, r, this.canonical.x >> l, this.canonical.y >> l);
      }, ti.prototype.isChildOf = function(r) {
        if (r.wrap !== this.wrap)
          return !1;
        var i = this.canonical.z - r.canonical.z;
        return r.overscaledZ === 0 || r.overscaledZ < this.overscaledZ && r.canonical.x === this.canonical.x >> i && r.canonical.y === this.canonical.y >> i;
      }, ti.prototype.children = function(r) {
        if (this.overscaledZ >= r)
          return [new ti(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
        var i = this.canonical.z + 1, l = 2 * this.canonical.x, p = 2 * this.canonical.y;
        return [new ti(i, this.wrap, i, l, p), new ti(i, this.wrap, i, l + 1, p), new ti(i, this.wrap, i, l, p + 1), new ti(i, this.wrap, i, l + 1, p + 1)];
      }, ti.prototype.isLessThan = function(r) {
        return this.wrap < r.wrap || !(this.wrap > r.wrap) && (this.overscaledZ < r.overscaledZ || !(this.overscaledZ > r.overscaledZ) && (this.canonical.x < r.canonical.x || !(this.canonical.x > r.canonical.x) && this.canonical.y < r.canonical.y));
      }, ti.prototype.wrapped = function() {
        return new ti(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
      }, ti.prototype.unwrapTo = function(r) {
        return new ti(this.overscaledZ, r, this.canonical.z, this.canonical.x, this.canonical.y);
      }, ti.prototype.overscaleFactor = function() {
        return Math.pow(2, this.overscaledZ - this.canonical.z);
      }, ti.prototype.toUnwrapped = function() {
        return new eb(this.wrap, this.canonical);
      }, ti.prototype.toString = function() {
        return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;
      }, ti.prototype.getTilePoint = function(r) {
        return this.canonical.getTilePoint(new pc(r.x - this.wrap, r.y));
      }, wt("CanonicalTileID", dc), wt("OverscaledTileID", ti, { omit: ["posMatrix"] });
      var wl = function(r, i, l) {
        if (this.uid = r, i.height !== i.width)
          throw new RangeError("DEM tiles must be square");
        if (l && l !== "mapbox" && l !== "terrarium")
          return yt('"' + l + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');
        this.stride = i.height;
        var p = this.dim = i.height - 2;
        this.data = new Uint32Array(i.data.buffer), this.encoding = l || "mapbox";
        for (var y = 0; y < p; y++)
          this.data[this._idx(-1, y)] = this.data[this._idx(0, y)], this.data[this._idx(p, y)] = this.data[this._idx(p - 1, y)], this.data[this._idx(y, -1)] = this.data[this._idx(y, 0)], this.data[this._idx(y, p)] = this.data[this._idx(y, p - 1)];
        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(p, -1)] = this.data[this._idx(p - 1, 0)], this.data[this._idx(-1, p)] = this.data[this._idx(0, p - 1)], this.data[this._idx(p, p)] = this.data[this._idx(p - 1, p - 1)];
      };
      wl.prototype.get = function(r, i) {
        var l = new Uint8Array(this.data.buffer), p = 4 * this._idx(r, i);
        return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(l[p], l[p + 1], l[p + 2]);
      }, wl.prototype.getUnpackVector = function() {
        return this.encoding === "terrarium" ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
      }, wl.prototype._idx = function(r, i) {
        if (r < -1 || r >= this.dim + 1 || i < -1 || i >= this.dim + 1)
          throw new RangeError("out of range source coordinates for DEM data");
        return (i + 1) * this.stride + (r + 1);
      }, wl.prototype._unpackMapbox = function(r, i, l) {
        return (256 * r * 256 + 256 * i + l) / 10 - 1e4;
      }, wl.prototype._unpackTerrarium = function(r, i, l) {
        return 256 * r + i + l / 256 - 32768;
      }, wl.prototype.getPixels = function() {
        return new yo({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
      }, wl.prototype.backfillBorder = function(r, i, l) {
        if (this.dim !== r.dim)
          throw new Error("dem dimension mismatch");
        var p = i * this.dim, y = i * this.dim + this.dim, v = l * this.dim, x = l * this.dim + this.dim;
        switch (i) {
          case -1:
            p = y - 1;
            break;
          case 1:
            y = p + 1;
        }
        switch (l) {
          case -1:
            v = x - 1;
            break;
          case 1:
            x = v + 1;
        }
        for (var S = -i * this.dim, C = -l * this.dim, P = v; P < x; P++)
          for (var L = p; L < y; L++)
            this.data[this._idx(L, P)] = r.data[this._idx(L + S, P + C)];
      }, wt("DEMData", wl);
      var Km = function(r) {
        this._stringToNumber = {}, this._numberToString = [];
        for (var i = 0; i < r.length; i++) {
          var l = r[i];
          this._stringToNumber[l] = i, this._numberToString[i] = l;
        }
      };
      Km.prototype.encode = function(r) {
        return this._stringToNumber[r];
      }, Km.prototype.decode = function(r) {
        return this._numberToString[r];
      };
      var Ym = function(r, i, l, p, y) {
        this.type = "Feature", this._vectorTileFeature = r, r._z = i, r._x = l, r._y = p, this.properties = r.properties, this.id = y;
      }, p_ = { geometry: { configurable: !0 } };
      p_.geometry.get = function() {
        return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
      }, p_.geometry.set = function(r) {
        this._geometry = r;
      }, Ym.prototype.toJSON = function() {
        var r = { geometry: this.geometry };
        for (var i in this)
          i !== "_geometry" && i !== "_vectorTileFeature" && (r[i] = this[i]);
        return r;
      }, Object.defineProperties(Ym.prototype, p_);
      var zh = function() {
        this.state = {}, this.stateChanges = {}, this.deletedStates = {};
      };
      zh.prototype.updateState = function(r, i, l) {
        var p = String(i);
        if (this.stateChanges[r] = this.stateChanges[r] || {}, this.stateChanges[r][p] = this.stateChanges[r][p] || {}, Y(this.stateChanges[r][p], l), this.deletedStates[r] === null)
          for (var y in this.deletedStates[r] = {}, this.state[r])
            y !== p && (this.deletedStates[r][y] = null);
        else if (this.deletedStates[r] && this.deletedStates[r][p] === null)
          for (var v in this.deletedStates[r][p] = {}, this.state[r][p])
            l[v] || (this.deletedStates[r][p][v] = null);
        else
          for (var x in l)
            this.deletedStates[r] && this.deletedStates[r][p] && this.deletedStates[r][p][x] === null && delete this.deletedStates[r][p][x];
      }, zh.prototype.removeFeatureState = function(r, i, l) {
        if (this.deletedStates[r] !== null) {
          var p = String(i);
          if (this.deletedStates[r] = this.deletedStates[r] || {}, l && i !== void 0)
            this.deletedStates[r][p] !== null && (this.deletedStates[r][p] = this.deletedStates[r][p] || {}, this.deletedStates[r][p][l] = null);
          else if (i !== void 0)
            if (this.stateChanges[r] && this.stateChanges[r][p])
              for (l in this.deletedStates[r][p] = {}, this.stateChanges[r][p])
                this.deletedStates[r][p][l] = null;
            else
              this.deletedStates[r][p] = null;
          else
            this.deletedStates[r] = null;
        }
      }, zh.prototype.getState = function(r, i) {
        var l = String(i), p = Y({}, (this.state[r] || {})[l], (this.stateChanges[r] || {})[l]);
        if (this.deletedStates[r] === null)
          return {};
        if (this.deletedStates[r]) {
          var y = this.deletedStates[r][i];
          if (y === null)
            return {};
          for (var v in y)
            delete p[v];
        }
        return p;
      }, zh.prototype.initializeTileState = function(r, i) {
        r.setFeatureState(this.state, i);
      }, zh.prototype.coalesceChanges = function(r, i) {
        var l = {};
        for (var p in this.stateChanges) {
          this.state[p] = this.state[p] || {};
          var y = {};
          for (var v in this.stateChanges[p])
            this.state[p][v] || (this.state[p][v] = {}), Y(this.state[p][v], this.stateChanges[p][v]), y[v] = this.state[p][v];
          l[p] = y;
        }
        for (var x in this.deletedStates) {
          this.state[x] = this.state[x] || {};
          var S = {};
          if (this.deletedStates[x] === null)
            for (var C in this.state[x])
              S[C] = {}, this.state[x][C] = {};
          else
            for (var P in this.deletedStates[x]) {
              if (this.deletedStates[x][P] === null)
                this.state[x][P] = {};
              else
                for (var L = 0, D = Object.keys(this.deletedStates[x][P]); L < D.length; L += 1)
                  delete this.state[x][P][D[L]];
              S[P] = this.state[x][P];
            }
          l[x] = l[x] || {}, Y(l[x], S);
        }
        if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(l).length !== 0)
          for (var B in r)
            r[B].setFeatureState(l, i);
      };
      var El = function(r, i) {
        this.tileID = r, this.x = r.canonical.x, this.y = r.canonical.y, this.z = r.canonical.z, this.grid = new Ua(8192, 16, 0), this.grid3D = new Ua(8192, 16, 0), this.featureIndexArray = new R(), this.promoteId = i;
      };
      function tb(r, i, l, p, y) {
        return Ee(r, function(v, x) {
          var S = i instanceof ic ? i.get(x) : null;
          return S && S.evaluate ? S.evaluate(l, p, y) : S;
        });
      }
      function rb(r) {
        for (var i = 1 / 0, l = 1 / 0, p = -1 / 0, y = -1 / 0, v = 0, x = r; v < x.length; v += 1) {
          var S = x[v];
          i = Math.min(i, S.x), l = Math.min(l, S.y), p = Math.max(p, S.x), y = Math.max(y, S.y);
        }
        return { minX: i, minY: l, maxX: p, maxY: y };
      }
      function XO(r, i) {
        return i - r;
      }
      El.prototype.insert = function(r, i, l, p, y, v) {
        var x = this.featureIndexArray.length;
        this.featureIndexArray.emplaceBack(l, p, y);
        for (var S = v ? this.grid3D : this.grid, C = 0; C < i.length; C++) {
          for (var P = i[C], L = [1 / 0, 1 / 0, -1 / 0, -1 / 0], D = 0; D < P.length; D++) {
            var B = P[D];
            L[0] = Math.min(L[0], B.x), L[1] = Math.min(L[1], B.y), L[2] = Math.max(L[2], B.x), L[3] = Math.max(L[3], B.y);
          }
          L[0] < 8192 && L[1] < 8192 && L[2] >= 0 && L[3] >= 0 && S.insert(x, L[0], L[1], L[2], L[3]);
        }
      }, El.prototype.loadVTLayers = function() {
        return this.vtLayers || (this.vtLayers = new Ih.VectorTile(new Bm(this.rawTileData)).layers, this.sourceLayerCoder = new Km(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
      }, El.prototype.query = function(r, i, l, p) {
        var y = this;
        this.loadVTLayers();
        for (var v = r.params || {}, x = 8192 / r.tileSize / r.scale, S = ch(v.filter), C = r.queryGeometry, P = r.queryPadding * x, L = rb(C), D = this.grid.query(L.minX - P, L.minY - P, L.maxX + P, L.maxY + P), B = rb(r.cameraQueryGeometry), j = this.grid3D.query(B.minX - P, B.minY - P, B.maxX + P, B.maxY + P, function(Se, Me, Fe, Xe) {
          return function(nt, At, pt, Nt, mt) {
            for (var or = 0, $t = nt; or < $t.length; or += 1) {
              var Mt = $t[or];
              if (At <= Mt.x && pt <= Mt.y && Nt >= Mt.x && mt >= Mt.y)
                return !0;
            }
            var cr = [new T(At, pt), new T(At, mt), new T(Nt, mt), new T(Nt, pt)];
            if (nt.length > 2) {
              for (var rr = 0, Er = cr; rr < Er.length; rr += 1)
                if (Ea(nt, Er[rr]))
                  return !0;
            }
            for (var Rt = 0; Rt < nt.length - 1; Rt++)
              if (uc(nt[Rt], nt[Rt + 1], cr))
                return !0;
            return !1;
          }(r.cameraQueryGeometry, Se - P, Me - P, Fe + P, Xe + P);
        }), Q = 0, te = j; Q < te.length; Q += 1)
          D.push(te[Q]);
        D.sort(XO);
        for (var ue, oe = {}, ge = function(Se) {
          var Me = D[Se];
          if (Me !== ue) {
            ue = Me;
            var Fe = y.featureIndexArray.get(Me), Xe = null;
            y.loadMatchingFeature(oe, Fe.bucketIndex, Fe.sourceLayerIndex, Fe.featureIndex, S, v.layers, v.availableImages, i, l, p, function(nt, At, pt) {
              return Xe || (Xe = Tn(nt)), At.queryIntersectsFeature(C, nt, pt, Xe, y.z, r.transform, x, r.pixelPosMatrix);
            });
          }
        }, be = 0; be < D.length; be++)
          ge(be);
        return oe;
      }, El.prototype.loadMatchingFeature = function(r, i, l, p, y, v, x, S, C, P, L) {
        var D = this.bucketLayerIDs[i];
        if (!v || function(nt, At) {
          for (var pt = 0; pt < nt.length; pt++)
            if (At.indexOf(nt[pt]) >= 0)
              return !0;
          return !1;
        }(v, D)) {
          var B = this.sourceLayerCoder.decode(l), j = this.vtLayers[B].feature(p);
          if (y.needGeometry) {
            var Q = Ln(j, !0);
            if (!y.filter(new pr(this.tileID.overscaledZ), Q, this.tileID.canonical))
              return;
          } else if (!y.filter(new pr(this.tileID.overscaledZ), j))
            return;
          for (var te = this.getId(j, B), ue = 0; ue < D.length; ue++) {
            var oe = D[ue];
            if (!(v && v.indexOf(oe) < 0)) {
              var ge = S[oe];
              if (ge) {
                var be = {};
                te !== void 0 && P && (be = P.getState(ge.sourceLayer || "_geojsonTileLayer", te));
                var Se = Y({}, C[oe]);
                Se.paint = tb(Se.paint, ge.paint, j, be, x), Se.layout = tb(Se.layout, ge.layout, j, be, x);
                var Me = !L || L(j, ge, be);
                if (Me) {
                  var Fe = new Ym(j, this.z, this.x, this.y, te);
                  Fe.layer = Se;
                  var Xe = r[oe];
                  Xe === void 0 && (Xe = r[oe] = []), Xe.push({ featureIndex: p, feature: Fe, intersectionZ: Me });
                }
              }
            }
          }
        }
      }, El.prototype.lookupSymbolFeatures = function(r, i, l, p, y, v, x, S) {
        var C = {};
        this.loadVTLayers();
        for (var P = ch(y), L = 0, D = r; L < D.length; L += 1)
          this.loadMatchingFeature(C, l, p, D[L], P, v, x, S, i);
        return C;
      }, El.prototype.hasLayer = function(r) {
        for (var i = 0, l = this.bucketLayerIDs; i < l.length; i += 1)
          for (var p = 0, y = l[i]; p < y.length; p += 1)
            if (r === y[p])
              return !0;
        return !1;
      }, El.prototype.getId = function(r, i) {
        var l = r.id;
        return this.promoteId && typeof (l = r.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[i]]) == "boolean" && (l = Number(l)), l;
      }, wt("FeatureIndex", El, { omit: ["rawTileData", "sourceLayerCoder"] });
      var vi = function(r, i) {
        this.tileID = r, this.uid = ye(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
      };
      vi.prototype.registerFadeDuration = function(r) {
        var i = r + this.timeAdded;
        i < Vn.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);
      }, vi.prototype.wasRequested = function() {
        return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
      }, vi.prototype.loadVectorData = function(r, i, l) {
        if (this.hasData() && this.unloadVectorData(), this.state = "loaded", r) {
          for (var p in r.featureIndex && (this.latestFeatureIndex = r.featureIndex, r.rawTileData ? (this.latestRawTileData = r.rawTileData, this.latestFeatureIndex.rawTileData = r.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = r.collisionBoxArray, this.buckets = function(P, L) {
            var D = {};
            if (!L)
              return D;
            for (var B = function() {
              var te = Q[j], ue = te.layerIds.map(function(be) {
                return L.getLayer(be);
              }).filter(Boolean);
              if (ue.length !== 0) {
                te.layers = ue, te.stateDependentLayerIds && (te.stateDependentLayers = te.stateDependentLayerIds.map(function(be) {
                  return ue.filter(function(Se) {
                    return Se.id === be;
                  })[0];
                }));
                for (var oe = 0, ge = ue; oe < ge.length; oe += 1)
                  D[ge[oe].id] = te;
              }
            }, j = 0, Q = P; j < Q.length; j += 1)
              B();
            return D;
          }(r.buckets, i.style), this.hasSymbolBuckets = !1, this.buckets) {
            var y = this.buckets[p];
            if (y instanceof $r) {
              if (this.hasSymbolBuckets = !0, !l)
                break;
              y.justReloaded = !0;
            }
          }
          if (this.hasRTLText = !1, this.hasSymbolBuckets)
            for (var v in this.buckets) {
              var x = this.buckets[v];
              if (x instanceof $r && x.hasRTLText) {
                this.hasRTLText = !0, Io.isLoading() || Io.isLoaded() || lp() !== "deferred" || sa();
                break;
              }
            }
          for (var S in this.queryPadding = 0, this.buckets) {
            var C = this.buckets[S];
            this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(S).queryRadius(C));
          }
          r.imageAtlas && (this.imageAtlas = r.imageAtlas), r.glyphAtlasImage && (this.glyphAtlasImage = r.glyphAtlasImage);
        } else
          this.collisionBoxArray = new h();
      }, vi.prototype.unloadVectorData = function() {
        for (var r in this.buckets)
          this.buckets[r].destroy();
        this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
      }, vi.prototype.getBucket = function(r) {
        return this.buckets[r.id];
      }, vi.prototype.upload = function(r) {
        for (var i in this.buckets) {
          var l = this.buckets[i];
          l.uploadPending() && l.upload(r);
        }
        var p = r.gl;
        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new fc(r, this.imageAtlas.image, p.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new fc(r, this.glyphAtlasImage, p.ALPHA), this.glyphAtlasImage = null);
      }, vi.prototype.prepare = function(r) {
        this.imageAtlas && this.imageAtlas.patchUpdatedImages(r, this.imageAtlasTexture);
      }, vi.prototype.queryRenderedFeatures = function(r, i, l, p, y, v, x, S, C, P) {
        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: p, cameraQueryGeometry: y, scale: v, tileSize: this.tileSize, pixelPosMatrix: P, transform: S, params: x, queryPadding: this.queryPadding * C }, r, i, l) : {};
      }, vi.prototype.querySourceFeatures = function(r, i) {
        var l = this.latestFeatureIndex;
        if (l && l.rawTileData) {
          var p = l.loadVTLayers(), y = i ? i.sourceLayer : "", v = p._geojsonTileLayer || p[y];
          if (v)
            for (var x = ch(i && i.filter), S = this.tileID.canonical, C = S.z, P = S.x, L = S.y, D = { z: C, x: P, y: L }, B = 0; B < v.length; B++) {
              var j = v.feature(B);
              if (x.needGeometry) {
                var Q = Ln(j, !0);
                if (!x.filter(new pr(this.tileID.overscaledZ), Q, this.tileID.canonical))
                  continue;
              } else if (!x.filter(new pr(this.tileID.overscaledZ), j))
                continue;
              var te = l.getId(j, y), ue = new Ym(j, C, P, L, te);
              ue.tile = D, r.push(ue);
            }
        }
      }, vi.prototype.hasData = function() {
        return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
      }, vi.prototype.patternsLoaded = function() {
        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
      }, vi.prototype.setExpiryData = function(r) {
        var i = this.expirationTime;
        if (r.cacheControl) {
          var l = vt(r.cacheControl);
          l["max-age"] && (this.expirationTime = Date.now() + 1e3 * l["max-age"]);
        } else
          r.expires && (this.expirationTime = new Date(r.expires).getTime());
        if (this.expirationTime) {
          var p = Date.now(), y = !1;
          if (this.expirationTime > p)
            y = !1;
          else if (i)
            if (this.expirationTime < i)
              y = !0;
            else {
              var v = this.expirationTime - i;
              v ? this.expirationTime = p + Math.max(v, 3e4) : y = !0;
            }
          else
            y = !0;
          y ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
        }
      }, vi.prototype.getExpiryTimeout = function() {
        if (this.expirationTime)
          return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
      }, vi.prototype.setFeatureState = function(r, i) {
        if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && Object.keys(r).length !== 0) {
          var l = this.latestFeatureIndex.loadVTLayers();
          for (var p in this.buckets)
            if (i.style.hasLayer(p)) {
              var y = this.buckets[p], v = y.layers[0].sourceLayer || "_geojsonTileLayer", x = l[v], S = r[v];
              if (x && S && Object.keys(S).length !== 0) {
                y.update(S, x, this.imageAtlas && this.imageAtlas.patternPositions || {});
                var C = i && i.style && i.style.getLayer(p);
                C && (this.queryPadding = Math.max(this.queryPadding, C.queryRadius(y)));
              }
            }
        }
      }, vi.prototype.holdingForFade = function() {
        return this.symbolFadeHoldUntil !== void 0;
      }, vi.prototype.symbolFadeFinished = function() {
        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Vn.now();
      }, vi.prototype.clearFadeHold = function() {
        this.symbolFadeHoldUntil = void 0;
      }, vi.prototype.setHoldDuration = function(r) {
        this.symbolFadeHoldUntil = Vn.now() + r;
      }, vi.prototype.setDependencies = function(r, i) {
        for (var l = {}, p = 0, y = i; p < y.length; p += 1)
          l[y[p]] = !0;
        this.dependencies[r] = l;
      }, vi.prototype.hasDependency = function(r, i) {
        for (var l = 0, p = r; l < p.length; l += 1) {
          var y = this.dependencies[p[l]];
          if (y) {
            for (var v = 0, x = i; v < x.length; v += 1)
              if (y[x[v]])
                return !0;
          }
        }
        return !1;
      };
      var au = I.performance, nb = function(r) {
        this._marks = { start: [r.url, "start"].join("#"), end: [r.url, "end"].join("#"), measure: r.url.toString() }, au.mark(this._marks.start);
      };
      nb.prototype.finish = function() {
        au.mark(this._marks.end);
        var r = au.getEntriesByName(this._marks.measure);
        return r.length === 0 && (au.measure(this._marks.measure, this._marks.start, this._marks.end), r = au.getEntriesByName(this._marks.measure), au.clearMarks(this._marks.start), au.clearMarks(this._marks.end), au.clearMeasures(this._marks.measure)), r;
      }, o.Actor = Rh, o.AlphaImage = hc, o.CanonicalTileID = dc, o.CollisionBoxArray = h, o.Color = Rr, o.DEMData = wl, o.DataConstantProperty = Lt, o.DictionaryCoder = Km, o.EXTENT = 8192, o.ErrorEvent = he, o.EvaluationParameters = pr, o.Event = ee, o.Evented = fe, o.FeatureIndex = El, o.FillBucket = $a, o.FillExtrusionBucket = Wa, o.ImageAtlas = Ep, o.ImagePosition = Um, o.LineBucket = to, o.LngLat = yn, o.LngLatBounds = ei, o.MercatorCoordinate = pc, o.ONE_EM = 24, o.OverscaledTileID = ti, o.Point = T, o.Point$1 = T, o.Properties = Mi, o.Protobuf = Bm, o.RGBAImage = yo, o.RequestManager = Le, o.RequestPerformance = nb, o.ResourceType = Fa, o.SegmentVector = $, o.SourceFeatureState = zh, o.StructArrayLayout1ui2 = dp, o.StructArrayLayout2f1f2i16 = vl, o.StructArrayLayout2i4 = gl, o.StructArrayLayout3ui6 = Es, o.StructArrayLayout4i8 = cp, o.SymbolBucket = $r, o.Texture = fc, o.Tile = vi, o.Transitionable = Ti, o.Uniform1f = tt, o.Uniform1i = je, o.Uniform2f = Qe, o.Uniform3f = gt, o.Uniform4f = Dt, o.UniformColor = Ft, o.UniformMatrix4f = Tr, o.UnwrappedTileID = eb, o.ValidationError = ie, o.WritingMode = Xo, o.ZoomHistory = ip, o.add = function(r, i, l) {
        return r[0] = i[0] + l[0], r[1] = i[1] + l[1], r[2] = i[2] + l[2], r;
      }, o.addDynamicAttributes = u_, o.asyncAll = function(r, i, l) {
        if (!r.length)
          return l(null, []);
        var p = r.length, y = new Array(r.length), v = null;
        r.forEach(function(x, S) {
          i(x, function(C, P) {
            C && (v = C), y[S] = P, --p == 0 && l(v, y);
          });
        });
      }, o.bezier = z, o.bindAll = De, o.browser = Vn, o.cacheEntryPossiblyAdded = function(r) {
        ++Sn > Bi && (r.getActor().send("enforceCacheSizeLimit", Xn), Sn = 0);
      }, o.clamp = Z, o.clearTileCache = function(r) {
        var i = I.caches.delete("mapbox-tiles");
        r && i.catch(r).then(function() {
          return r();
        });
      }, o.clipLine = Fx, o.clone = function(r) {
        var i = new zr(16);
        return i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], i[4] = r[4], i[5] = r[5], i[6] = r[6], i[7] = r[7], i[8] = r[8], i[9] = r[9], i[10] = r[10], i[11] = r[11], i[12] = r[12], i[13] = r[13], i[14] = r[14], i[15] = r[15], i;
      }, o.clone$1 = rt, o.clone$2 = function(r) {
        var i = new zr(3);
        return i[0] = r[0], i[1] = r[1], i[2] = r[2], i;
      }, o.collisionCircleLayout = mO, o.config = wr, o.create = function() {
        var r = new zr(16);
        return zr != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;
      }, o.create$1 = function() {
        var r = new zr(9);
        return zr != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
      }, o.create$2 = function() {
        var r = new zr(4);
        return zr != Float32Array && (r[1] = 0, r[2] = 0), r[0] = 1, r[3] = 1, r;
      }, o.createCommonjsModule = m, o.createExpression = lh, o.createLayout = yi, o.createStyleLayer = function(r) {
        return r.type === "custom" ? new HO(r) : new ZO[r.type](r);
      }, o.cross = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = l[0], S = l[1], C = l[2];
        return r[0] = y * C - v * S, r[1] = v * x - p * C, r[2] = p * S - y * x, r;
      }, o.deepEqual = function r(i, l) {
        if (Array.isArray(i)) {
          if (!Array.isArray(l) || i.length !== l.length)
            return !1;
          for (var p = 0; p < i.length; p++)
            if (!r(i[p], l[p]))
              return !1;
          return !0;
        }
        if (typeof i == "object" && i !== null && l !== null) {
          if (typeof l != "object" || Object.keys(i).length !== Object.keys(l).length)
            return !1;
          for (var y in i)
            if (!r(i[y], l[y]))
              return !1;
          return !0;
        }
        return i === l;
      }, o.dot = function(r, i) {
        return r[0] * i[0] + r[1] * i[1] + r[2] * i[2];
      }, o.dot$1 = function(r, i) {
        return r[0] * i[0] + r[1] * i[1] + r[2] * i[2] + r[3] * i[3];
      }, o.ease = V, o.emitValidationErrors = tc, o.endsWith = Re, o.enforceCacheSizeLimit = function(r) {
        so(), bt && bt.then(function(i) {
          i.keys().then(function(l) {
            for (var p = 0; p < l.length - r; p++)
              i.delete(l[p]);
          });
        });
      }, o.evaluateSizeForFeature = kx, o.evaluateSizeForZoom = Lx, o.evaluateVariableOffset = Ux, o.evented = sp, o.extend = Y, o.featureFilter = ch, o.filterObject = ze, o.fromRotation = function(r, i) {
        var l = Math.sin(i), p = Math.cos(i);
        return r[0] = p, r[1] = l, r[2] = 0, r[3] = -l, r[4] = p, r[5] = 0, r[6] = 0, r[7] = 0, r[8] = 1, r;
      }, o.getAnchorAlignment = o_, o.getAnchorJustification = l_, o.getArrayBuffer = tl, o.getImage = F, o.getJSON = function(r, i) {
        return So(Y(r, { type: "json" }), i);
      }, o.getRTLTextPluginStatus = lp, o.getReferrer = Ba, o.getVideo = function(r, i) {
        var l, p, y = I.document.createElement("video");
        y.muted = !0, y.onloadstart = function() {
          i(null, y);
        };
        for (var v = 0; v < r.length; v++) {
          var x = I.document.createElement("source");
          l = r[v], p = void 0, (p = I.document.createElement("a")).href = l, (p.protocol !== I.document.location.protocol || p.host !== I.document.location.host) && (y.crossOrigin = "Anonymous"), x.src = r[v], y.appendChild(x);
        }
        return { cancel: function() {
        } };
      }, o.identity = Oo, o.invert = function(r, i) {
        var l = i[0], p = i[1], y = i[2], v = i[3], x = i[4], S = i[5], C = i[6], P = i[7], L = i[8], D = i[9], B = i[10], j = i[11], Q = i[12], te = i[13], ue = i[14], oe = i[15], ge = l * S - p * x, be = l * C - y * x, Se = l * P - v * x, Me = p * C - y * S, Fe = p * P - v * S, Xe = y * P - v * C, nt = L * te - D * Q, At = L * ue - B * Q, pt = L * oe - j * Q, Nt = D * ue - B * te, mt = D * oe - j * te, or = B * oe - j * ue, $t = ge * or - be * mt + Se * Nt + Me * pt - Fe * At + Xe * nt;
        return $t ? (r[0] = (S * or - C * mt + P * Nt) * ($t = 1 / $t), r[1] = (y * mt - p * or - v * Nt) * $t, r[2] = (te * Xe - ue * Fe + oe * Me) * $t, r[3] = (B * Fe - D * Xe - j * Me) * $t, r[4] = (C * pt - x * or - P * At) * $t, r[5] = (l * or - y * pt + v * At) * $t, r[6] = (ue * Se - Q * Xe - oe * be) * $t, r[7] = (L * Xe - B * Se + j * be) * $t, r[8] = (x * mt - S * pt + P * nt) * $t, r[9] = (p * pt - l * mt - v * nt) * $t, r[10] = (Q * Fe - te * Se + oe * ge) * $t, r[11] = (D * Se - L * Fe - j * ge) * $t, r[12] = (S * At - x * Nt - C * nt) * $t, r[13] = (l * Nt - p * At + y * nt) * $t, r[14] = (te * be - Q * Me - ue * ge) * $t, r[15] = (L * Me - D * be + B * ge) * $t, r) : null;
      }, o.isChar = ut, o.isMapboxURL = qe, o.keysDifference = function(r, i) {
        var l = [];
        for (var p in r)
          p in i || l.push(p);
        return l;
      }, o.makeRequest = So, o.mapObject = Ee, o.mercatorXfromLng = Yx, o.mercatorYfromLat = Jx, o.mercatorZfromAltitude = Qx, o.mul = Hv, o.multiply = eo, o.mvt = Ih, o.nextPowerOfTwo = function(r) {
        return r <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
      }, o.normalize = function(r, i) {
        var l = i[0], p = i[1], y = i[2], v = l * l + p * p + y * y;
        return v > 0 && (v = 1 / Math.sqrt(v)), r[0] = i[0] * v, r[1] = i[1] * v, r[2] = i[2] * v, r;
      }, o.number = jn, o.offscreenCanvasSupported = ai, o.ortho = function(r, i, l, p, y, v, x) {
        var S = 1 / (i - l), C = 1 / (p - y), P = 1 / (v - x);
        return r[0] = -2 * S, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * C, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * P, r[11] = 0, r[12] = (i + l) * S, r[13] = (y + p) * C, r[14] = (x + v) * P, r[15] = 1, r;
      }, o.parseGlyphPBF = function(r) {
        return new Bm(r).readFields(MO, []);
      }, o.pbf = Bm, o.performSymbolLayout = function(r, i, l, p, y, v, x) {
        r.createArrays(), r.tilePixelRatio = 8192 / (512 * r.overscaling), r.compareText = {}, r.iconsNeedLinear = !1;
        var S = r.layers[0].layout, C = r.layers[0]._unevaluatedLayout._values, P = {};
        if (r.textSizeData.kind === "composite") {
          var L = r.textSizeData, D = L.maxZoom;
          P.compositeTextSizes = [C["text-size"].possiblyEvaluate(new pr(L.minZoom), x), C["text-size"].possiblyEvaluate(new pr(D), x)];
        }
        if (r.iconSizeData.kind === "composite") {
          var B = r.iconSizeData, j = B.maxZoom;
          P.compositeIconSizes = [C["icon-size"].possiblyEvaluate(new pr(B.minZoom), x), C["icon-size"].possiblyEvaluate(new pr(j), x)];
        }
        P.layoutTextSize = C["text-size"].possiblyEvaluate(new pr(r.zoom + 1), x), P.layoutIconSize = C["icon-size"].possiblyEvaluate(new pr(r.zoom + 1), x), P.textMaxSize = C["text-size"].possiblyEvaluate(new pr(18));
        for (var Q = 24 * S.get("text-line-height"), te = S.get("text-rotation-alignment") === "map" && S.get("symbol-placement") !== "point", ue = S.get("text-keep-upright"), oe = S.get("text-size"), ge = function() {
          var Me = Se[be], Fe = S.get("text-font").evaluate(Me, {}, x).join(","), Xe = oe.evaluate(Me, {}, x), nt = P.layoutTextSize.evaluate(Me, {}, x), At = P.layoutIconSize.evaluate(Me, {}, x), pt = { horizontal: {}, vertical: void 0 }, Nt = Me.text, mt = [0, 0];
          if (Nt) {
            var or = Nt.toString(), $t = 24 * S.get("text-letter-spacing").evaluate(Me, {}, x), Mt = function(gr) {
              for (var Xr = 0, qr = gr; Xr < qr.length; Xr += 1)
                if (Mr = qr[Xr].charCodeAt(0), ut.Arabic(Mr) || ut["Arabic Supplement"](Mr) || ut["Arabic Extended-A"](Mr) || ut["Arabic Presentation Forms-A"](Mr) || ut["Arabic Presentation Forms-B"](Mr))
                  return !1;
              var Mr;
              return !0;
            }(or) ? $t : 0, cr = S.get("text-anchor").evaluate(Me, {}, x), rr = S.get("text-variable-anchor");
            if (!rr) {
              var Er = S.get("text-radial-offset").evaluate(Me, {}, x);
              mt = Er ? Ux(cr, [24 * Er, s_]) : S.get("text-offset").evaluate(Me, {}, x).map(function(gr) {
                return 24 * gr;
              });
            }
            var Rt = te ? "center" : S.get("text-justify").evaluate(Me, {}, x), Pr = S.get("symbol-placement"), gn = Pr === "point" ? 24 * S.get("text-max-width").evaluate(Me, {}, x) : 0, On = function() {
              r.allowVerticalPlacement && op(or) && (pt.vertical = jm(Nt, i, l, y, Fe, gn, Q, cr, "left", Mt, mt, Xo.vertical, !0, Pr, nt, Xe));
            };
            if (!te && rr) {
              for (var Mn = Rt === "auto" ? rr.map(function(gr) {
                return l_(gr);
              }) : [Rt], vn = !1, Cn = 0; Cn < Mn.length; Cn++) {
                var ui = Mn[Cn];
                if (!pt.horizontal[ui])
                  if (vn)
                    pt.horizontal[ui] = pt.horizontal[0];
                  else {
                    var ci = jm(Nt, i, l, y, Fe, gn, Q, "center", ui, Mt, mt, Xo.horizontal, !1, Pr, nt, Xe);
                    ci && (pt.horizontal[ui] = ci, vn = ci.positionedLines.length === 1);
                  }
              }
              On();
            } else {
              Rt === "auto" && (Rt = l_(cr));
              var Wi = jm(Nt, i, l, y, Fe, gn, Q, cr, Rt, Mt, mt, Xo.horizontal, !1, Pr, nt, Xe);
              Wi && (pt.horizontal[Rt] = Wi), On(), op(or) && te && ue && (pt.vertical = jm(Nt, i, l, y, Fe, gn, Q, cr, Rt, Mt, mt, Xo.vertical, !1, Pr, nt, Xe));
            }
          }
          var _i = void 0, Hi = !1;
          if (Me.icon && Me.icon.name) {
            var Dn = p[Me.icon.name];
            Dn && (_i = function(gr, Xr, qr) {
              var Mr = o_(qr), ro = Xr[0] - gr.displaySize[0] * Mr.horizontalAlign, Di = Xr[1] - gr.displaySize[1] * Mr.verticalAlign;
              return { image: gr, top: Di, bottom: Di + gr.displaySize[1], left: ro, right: ro + gr.displaySize[0] };
            }(y[Me.icon.name], S.get("icon-offset").evaluate(Me, {}, x), S.get("icon-anchor").evaluate(Me, {}, x)), Hi = Dn.sdf, r.sdfIcons === void 0 ? r.sdfIcons = Dn.sdf : r.sdfIcons !== Dn.sdf && yt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Dn.pixelRatio !== r.pixelRatio || S.get("icon-rotate").constantOr(1) !== 0) && (r.iconsNeedLinear = !0));
          }
          var xi = Gx(pt.horizontal) || pt.vertical;
          r.iconsInText = !!xi && xi.iconsInText, (xi || _i) && function(gr, Xr, qr, Mr, ro, Di, an, qn, Ni, kr, Cs) {
            var Ko = Di.textMaxSize.evaluate(Xr, {});
            Ko === void 0 && (Ko = an);
            var As, Nn = gr.layers[0].layout, Ps = Nn.get("icon-offset").evaluate(Xr, {}, Cs), Ta = Gx(qr.horizontal), Fh = an / 24, mc = gr.tilePixelRatio * Fh, Bh = gr.tilePixelRatio * Ko / 24, Sl = gr.tilePixelRatio * qn, Vh = gr.tilePixelRatio * Nn.get("symbol-spacing"), Jm = Nn.get("text-padding") * gr.tilePixelRatio, Uh = Nn.get("icon-padding") * gr.tilePixelRatio, Mp = Nn.get("text-max-angle") / 180 * Math.PI, Qm = Nn.get("text-rotation-alignment") === "map" && Nn.get("symbol-placement") !== "point", ey = Nn.get("icon-rotation-alignment") === "map" && Nn.get("symbol-placement") !== "point", Tl = Nn.get("symbol-placement"), Ip = Vh / 2, jh = Nn.get("icon-text-fit");
            Mr && jh !== "none" && (gr.allowVerticalPlacement && qr.vertical && (As = Px(Mr, qr.vertical, jh, Nn.get("icon-text-fit-padding"), Ps, Fh)), Ta && (Mr = Px(Mr, Ta, jh, Nn.get("icon-text-fit-padding"), Ps, Fh)));
            var su = function(KO, Np) {
              Np.x < 0 || Np.x >= 8192 || Np.y < 0 || Np.y >= 8192 || function(Rn, Ha, YO, lu, g_, ab, ay, ks, sy, Rp, ly, uy, v_, sb, zp, lb, ub, cb, hb, fb, Yo, cy, pb, Ls, JO) {
                var db, gc, Hh, Zh, Xh, Kh = Rn.addToLineVertexArray(Ha, YO), mb = 0, yb = 0, gb = 0, vb = 0, __ = -1, x_ = -1, Ml = {}, _b = J(""), b_ = 0, w_ = 0;
                if (ks._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? (b_ = (db = ks.layout.get("text-offset").evaluate(Yo, {}, Ls).map(function(Bp) {
                  return 24 * Bp;
                }))[0], w_ = db[1]) : (b_ = 24 * ks.layout.get("text-radial-offset").evaluate(Yo, {}, Ls), w_ = s_), Rn.allowVerticalPlacement && lu.vertical) {
                  var xb = ks.layout.get("text-rotate").evaluate(Yo, {}, Ls) + 90;
                  Zh = new Hm(sy, Ha, Rp, ly, uy, lu.vertical, v_, sb, zp, xb), ay && (Xh = new Hm(sy, Ha, Rp, ly, uy, ay, ub, cb, zp, xb));
                }
                if (g_) {
                  var E_ = ks.layout.get("icon-rotate").evaluate(Yo, {}), bb = ks.layout.get("icon-text-fit") !== "none", wb = Bx(g_, E_, pb, bb), S_ = ay ? Bx(ay, E_, pb, bb) : void 0;
                  Hh = new Hm(sy, Ha, Rp, ly, uy, g_, ub, cb, !1, E_), mb = 4 * wb.length;
                  var Eb = Rn.iconSizeData, Fp = null;
                  Eb.kind === "source" ? (Fp = [128 * ks.layout.get("icon-size").evaluate(Yo, {})])[0] > 32640 && yt(Rn.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".') : Eb.kind === "composite" && ((Fp = [128 * cy.compositeIconSizes[0].evaluate(Yo, {}, Ls), 128 * cy.compositeIconSizes[1].evaluate(Yo, {}, Ls)])[0] > 32640 || Fp[1] > 32640) && yt(Rn.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".'), Rn.addSymbols(Rn.icon, wb, Fp, fb, hb, Yo, !1, Ha, Kh.lineStartIndex, Kh.lineLength, -1, Ls), __ = Rn.icon.placedSymbolArray.length - 1, S_ && (yb = 4 * S_.length, Rn.addSymbols(Rn.icon, S_, Fp, fb, hb, Yo, Xo.vertical, Ha, Kh.lineStartIndex, Kh.lineLength, -1, Ls), x_ = Rn.icon.placedSymbolArray.length - 1);
                }
                for (var Sb in lu.horizontal) {
                  var hy = lu.horizontal[Sb];
                  if (!gc) {
                    _b = J(hy.text);
                    var QO = ks.layout.get("text-rotate").evaluate(Yo, {}, Ls);
                    gc = new Hm(sy, Ha, Rp, ly, uy, hy, v_, sb, zp, QO);
                  }
                  var Tb = hy.positionedLines.length === 1;
                  if (gb += jx(Rn, Ha, hy, ab, ks, zp, Yo, lb, Kh, lu.vertical ? Xo.horizontal : Xo.horizontalOnly, Tb ? Object.keys(lu.horizontal) : [Sb], Ml, __, cy, Ls), Tb)
                    break;
                }
                lu.vertical && (vb += jx(Rn, Ha, lu.vertical, ab, ks, zp, Yo, lb, Kh, Xo.vertical, ["vertical"], Ml, x_, cy, Ls));
                var eC = gc ? gc.boxStartIndex : Rn.collisionBoxArray.length, tC = gc ? gc.boxEndIndex : Rn.collisionBoxArray.length, rC = Zh ? Zh.boxStartIndex : Rn.collisionBoxArray.length, nC = Zh ? Zh.boxEndIndex : Rn.collisionBoxArray.length, iC = Hh ? Hh.boxStartIndex : Rn.collisionBoxArray.length, oC = Hh ? Hh.boxEndIndex : Rn.collisionBoxArray.length, aC = Xh ? Xh.boxStartIndex : Rn.collisionBoxArray.length, sC = Xh ? Xh.boxEndIndex : Rn.collisionBoxArray.length, Ds = -1, fy = function(Bp, Ib) {
                  return Bp && Bp.circleDiameter ? Math.max(Bp.circleDiameter, Ib) : Ib;
                };
                Ds = fy(gc, Ds), Ds = fy(Zh, Ds), Ds = fy(Hh, Ds);
                var Mb = (Ds = fy(Xh, Ds)) > -1 ? 1 : 0;
                Mb && (Ds *= JO / 24), Rn.glyphOffsetArray.length >= $r.MAX_GLYPHS && yt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Yo.sortKey !== void 0 && Rn.addToSortKeyRanges(Rn.symbolInstances.length, Yo.sortKey), Rn.symbolInstances.emplaceBack(Ha.x, Ha.y, Ml.right >= 0 ? Ml.right : -1, Ml.center >= 0 ? Ml.center : -1, Ml.left >= 0 ? Ml.left : -1, Ml.vertical || -1, __, x_, _b, eC, tC, rC, nC, iC, oC, aC, sC, Rp, gb, vb, mb, yb, Mb, 0, v_, b_, w_, Ds);
              }(gr, Np, KO, qr, Mr, ro, As, gr.layers[0], gr.collisionBoxArray, Xr.index, Xr.sourceLayerIndex, gr.index, mc, Jm, Qm, Ni, Sl, Uh, ey, Ps, Xr, Di, kr, Cs, an);
            };
            if (Tl === "line")
              for (var Gh = 0, ty = Fx(Xr.geometry, 0, 0, 8192, 8192); Gh < ty.length; Gh += 1)
                for (var ry = ty[Gh], Op = 0, Cp = LO(ry, Vh, Mp, qr.vertical || Ta, Mr, 24, Bh, gr.overscaling, 8192); Op < Cp.length; Op += 1) {
                  var ny = Cp[Op];
                  Ta && zO(gr, Ta.text, Ip, ny) || su(ry, ny);
                }
            else if (Tl === "line-center")
              for (var Ap = 0, Pp = Xr.geometry; Ap < Pp.length; Ap += 1) {
                var kp = Pp[Ap];
                if (kp.length > 1) {
                  var iy = kO(kp, Mp, qr.vertical || Ta, Mr, 24, Bh);
                  iy && su(kp, iy);
                }
              }
            else if (Xr.type === "Polygon")
              for (var qh = 0, oy = e_(Xr.geometry, 0); qh < oy.length; qh += 1) {
                var $h = oy[qh], Lp = NO($h, 16);
                su($h[0], new Ph(Lp.x, Lp.y, 0));
              }
            else if (Xr.type === "LineString")
              for (var yc = 0, Dp = Xr.geometry; yc < Dp.length; yc += 1) {
                var Wh = Dp[yc];
                su(Wh, new Ph(Wh[0].x, Wh[0].y, 0));
              }
            else if (Xr.type === "Point")
              for (var d_ = 0, ib = Xr.geometry; d_ < ib.length; d_ += 1)
                for (var m_ = 0, ob = ib[d_]; m_ < ob.length; m_ += 1) {
                  var y_ = ob[m_];
                  su([y_], new Ph(y_.x, y_.y, 0));
                }
          }(r, Me, pt, _i, p, P, nt, At, mt, Hi, x);
        }, be = 0, Se = r.features; be < Se.length; be += 1)
          ge();
        v && r.generateCollisionDebugBuffers();
      }, o.perspective = function(r, i, l, p, y) {
        var v, x = 1 / Math.tan(i / 2);
        return r[0] = x / l, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = x, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, y != null && y !== 1 / 0 ? (r[10] = (y + p) * (v = 1 / (p - y)), r[14] = 2 * y * p * v) : (r[10] = -1, r[14] = -2 * p), r;
      }, o.pick = function(r, i) {
        for (var l = {}, p = 0; p < i.length; p++) {
          var y = i[p];
          y in r && (l[y] = r[y]);
        }
        return l;
      }, o.plugin = Io, o.polygonIntersectsPolygon = Ms, o.postMapLoadEvent = Jr, o.postTurnstileEvent = Fr, o.potpack = Ix, o.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], o.register = wt, o.registerForPluginStateChange = function(r) {
        return r({ pluginStatus: fo, pluginURL: ja }), sp.on("pluginStateChange", r), r;
      }, o.renderColorRamp = lx, o.rotate = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3], S = Math.sin(l), C = Math.cos(l);
        return r[0] = p * C + v * S, r[1] = y * C + x * S, r[2] = p * -S + v * C, r[3] = y * -S + x * C, r;
      }, o.rotateX = function(r, i, l) {
        var p = Math.sin(l), y = Math.cos(l), v = i[4], x = i[5], S = i[6], C = i[7], P = i[8], L = i[9], D = i[10], B = i[11];
        return i !== r && (r[0] = i[0], r[1] = i[1], r[2] = i[2], r[3] = i[3], r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15]), r[4] = v * y + P * p, r[5] = x * y + L * p, r[6] = S * y + D * p, r[7] = C * y + B * p, r[8] = P * y - v * p, r[9] = L * y - x * p, r[10] = D * y - S * p, r[11] = B * y - C * p, r;
      }, o.rotateZ = function(r, i, l) {
        var p = Math.sin(l), y = Math.cos(l), v = i[0], x = i[1], S = i[2], C = i[3], P = i[4], L = i[5], D = i[6], B = i[7];
        return i !== r && (r[8] = i[8], r[9] = i[9], r[10] = i[10], r[11] = i[11], r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15]), r[0] = v * y + P * p, r[1] = x * y + L * p, r[2] = S * y + D * p, r[3] = C * y + B * p, r[4] = P * y - v * p, r[5] = L * y - x * p, r[6] = D * y - S * p, r[7] = B * y - C * p, r;
      }, o.scale = function(r, i, l) {
        var p = l[0], y = l[1], v = l[2];
        return r[0] = i[0] * p, r[1] = i[1] * p, r[2] = i[2] * p, r[3] = i[3] * p, r[4] = i[4] * y, r[5] = i[5] * y, r[6] = i[6] * y, r[7] = i[7] * y, r[8] = i[8] * v, r[9] = i[9] * v, r[10] = i[10] * v, r[11] = i[11] * v, r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15], r;
      }, o.scale$1 = function(r, i, l) {
        return r[0] = i[0] * l, r[1] = i[1] * l, r[2] = i[2] * l, r[3] = i[3] * l, r;
      }, o.scale$2 = function(r, i, l) {
        return r[0] = i[0] * l, r[1] = i[1] * l, r[2] = i[2] * l, r;
      }, o.setCacheLimits = function(r, i) {
        Xn = r, Bi = i;
      }, o.setRTLTextPlugin = function(r, i, l) {
        if (l === void 0 && (l = !1), fo === "deferred" || fo === "loading" || fo === "loaded")
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        ja = Vn.resolveURL(r), fo = "deferred", gh = i, nc(), l || sa();
      }, o.sphericalToCartesian = function(r) {
        var i = r[0], l = r[1], p = r[2];
        return l += 90, l *= Math.PI / 180, p *= Math.PI / 180, { x: i * Math.cos(l) * Math.sin(p), y: i * Math.sin(l) * Math.sin(p), z: i * Math.cos(p) };
      }, o.sqrLen = function(r) {
        var i = r[0], l = r[1];
        return i * i + l * l;
      }, o.styleSpec = G, o.sub = function(r, i, l) {
        return r[0] = i[0] - l[0], r[1] = i[1] - l[1], r[2] = i[2] - l[2], r;
      }, o.symbolSize = PO, o.transformMat3 = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2];
        return r[0] = p * l[0] + y * l[3] + v * l[6], r[1] = p * l[1] + y * l[4] + v * l[7], r[2] = p * l[2] + y * l[5] + v * l[8], r;
      }, o.transformMat4 = Eh, o.translate = function(r, i, l) {
        var p, y, v, x, S, C, P, L, D, B, j, Q, te = l[0], ue = l[1], oe = l[2];
        return i === r ? (r[12] = i[0] * te + i[4] * ue + i[8] * oe + i[12], r[13] = i[1] * te + i[5] * ue + i[9] * oe + i[13], r[14] = i[2] * te + i[6] * ue + i[10] * oe + i[14], r[15] = i[3] * te + i[7] * ue + i[11] * oe + i[15]) : (y = i[1], v = i[2], x = i[3], S = i[4], C = i[5], P = i[6], L = i[7], D = i[8], B = i[9], j = i[10], Q = i[11], r[0] = p = i[0], r[1] = y, r[2] = v, r[3] = x, r[4] = S, r[5] = C, r[6] = P, r[7] = L, r[8] = D, r[9] = B, r[10] = j, r[11] = Q, r[12] = p * te + S * ue + D * oe + i[12], r[13] = y * te + C * ue + B * oe + i[13], r[14] = v * te + P * ue + j * oe + i[14], r[15] = x * te + L * ue + Q * oe + i[15]), r;
      }, o.triggerPluginCompletionEvent = km, o.uniqueId = ye, o.validateCustomStyleLayer = function(r) {
        var i = [], l = r.id;
        return l === void 0 && i.push({ message: "layers." + l + ': missing required property "id"' }), r.render === void 0 && i.push({ message: "layers." + l + ': missing required method "render"' }), r.renderingMode && r.renderingMode !== "2d" && r.renderingMode !== "3d" && i.push({ message: "layers." + l + ': property "renderingMode" must be either "2d" or "3d"' }), i;
      }, o.validateLight = $v, o.validateStyle = Qu, o.values = function(r) {
        var i = [];
        for (var l in r)
          i.push(r[l]);
        return i;
      }, o.vectorTile = Ih, o.version = "1.13.3", o.warnOnce = yt, o.webpSupported = En, o.window = I, o.wrap = X;
    }), f(["./shared"], function(o) {
      function m(N) {
        var F = typeof N;
        if (F === "number" || F === "boolean" || F === "string" || N == null)
          return JSON.stringify(N);
        if (Array.isArray(N)) {
          for (var U = "[", H = 0, ee = N; H < ee.length; H += 1)
            U += m(ee[H]) + ",";
          return U + "]";
        }
        for (var he = Object.keys(N).sort(), fe = "{", G = 0; G < he.length; G++)
          fe += JSON.stringify(he[G]) + ":" + m(N[he[G]]) + ",";
        return fe + "}";
      }
      function g(N) {
        for (var F = "", U = 0, H = o.refProperties; U < H.length; U += 1)
          F += "/" + m(N[H[U]]);
        return F;
      }
      var b = function(N) {
        this.keyCache = {}, N && this.replace(N);
      };
      b.prototype.replace = function(N) {
        this._layerConfigs = {}, this._layers = {}, this.update(N, []);
      }, b.prototype.update = function(N, F) {
        for (var U = this, H = 0, ee = N; H < ee.length; H += 1) {
          var he = ee[H];
          this._layerConfigs[he.id] = he;
          var fe = this._layers[he.id] = o.createStyleLayer(he);
          fe._featureFilter = o.featureFilter(fe.filter), this.keyCache[he.id] && delete this.keyCache[he.id];
        }
        for (var G = 0, ie = F; G < ie.length; G += 1) {
          var ve = ie[G];
          delete this.keyCache[ve], delete this._layerConfigs[ve], delete this._layers[ve];
        }
        this.familiesBySource = {};
        for (var Ge = 0, He = function(ot, ke) {
          for (var ce = {}, we = 0; we < ot.length; we++) {
            var We = ke && ke[ot[we].id] || g(ot[we]);
            ke && (ke[ot[we].id] = We);
            var jt = ce[We];
            jt || (jt = ce[We] = []), jt.push(ot[we]);
          }
          var Wt = [];
          for (var Jt in ce)
            Wt.push(ce[Jt]);
          return Wt;
        }(o.values(this._layerConfigs), this.keyCache); Ge < He.length; Ge += 1) {
          var Oe = He[Ge].map(function(ot) {
            return U._layers[ot.id];
          }), Ve = Oe[0];
          if (Ve.visibility !== "none") {
            var Et = Ve.source || "", _t = this.familiesBySource[Et];
            _t || (_t = this.familiesBySource[Et] = {});
            var Pe = Ve.sourceLayer || "_geojsonTileLayer", ft = _t[Pe];
            ft || (ft = _t[Pe] = []), ft.push(Oe);
          }
        }
      };
      var T = function(N) {
        var F = {}, U = [];
        for (var H in N) {
          var ee = N[H], he = F[H] = {};
          for (var fe in ee) {
            var G = ee[+fe];
            if (G && G.bitmap.width !== 0 && G.bitmap.height !== 0) {
              var ie = { x: 0, y: 0, w: G.bitmap.width + 2, h: G.bitmap.height + 2 };
              U.push(ie), he[fe] = { rect: ie, metrics: G.metrics };
            }
          }
        }
        var ve = o.potpack(U), Ge = new o.AlphaImage({ width: ve.w || 1, height: ve.h || 1 });
        for (var He in N) {
          var Oe = N[He];
          for (var Ve in Oe) {
            var Et = Oe[+Ve];
            if (Et && Et.bitmap.width !== 0 && Et.bitmap.height !== 0) {
              var _t = F[He][Ve].rect;
              o.AlphaImage.copy(Et.bitmap, Ge, { x: 0, y: 0 }, { x: _t.x + 1, y: _t.y + 1 }, Et.bitmap);
            }
          }
        }
        this.image = Ge, this.positions = F;
      };
      o.register("GlyphAtlas", T);
      var M = function(N) {
        this.tileID = new o.OverscaledTileID(N.tileID.overscaledZ, N.tileID.wrap, N.tileID.canonical.z, N.tileID.canonical.x, N.tileID.canonical.y), this.uid = N.uid, this.zoom = N.zoom, this.pixelRatio = N.pixelRatio, this.tileSize = N.tileSize, this.source = N.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = N.showCollisionBoxes, this.collectResourceTiming = !!N.collectResourceTiming, this.returnDependencies = !!N.returnDependencies, this.promoteId = N.promoteId;
      };
      function I(N, F, U) {
        for (var H = new o.EvaluationParameters(F), ee = 0, he = N; ee < he.length; ee += 1)
          he[ee].recalculate(H, U);
      }
      function A(N, F) {
        var U = o.getArrayBuffer(N.request, function(H, ee, he, fe) {
          H ? F(H) : ee && F(null, { vectorTile: new o.vectorTile.VectorTile(new o.pbf(ee)), rawData: ee, cacheControl: he, expires: fe });
        });
        return function() {
          U.cancel(), F();
        };
      }
      M.prototype.parse = function(N, F, U, H, ee) {
        var he = this;
        this.status = "parsing", this.data = N, this.collisionBoxArray = new o.CollisionBoxArray();
        var fe = new o.DictionaryCoder(Object.keys(N.layers).sort()), G = new o.FeatureIndex(this.tileID, this.promoteId);
        G.bucketLayerIDs = [];
        var ie, ve, Ge, He, Oe = {}, Ve = { featureIndex: G, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: U }, Et = F.familiesBySource[this.source];
        for (var _t in Et) {
          var Pe = N.layers[_t];
          if (Pe) {
            Pe.version === 1 && o.warnOnce('Vector tile source "' + this.source + '" layer "' + _t + '" does not use vector tile spec v2 and therefore may have some rendering errors.');
            for (var ft = fe.encode(_t), ot = [], ke = 0; ke < Pe.length; ke++) {
              var ce = Pe.feature(ke), we = G.getId(ce, _t);
              ot.push({ feature: ce, id: we, index: ke, sourceLayerIndex: ft });
            }
            for (var We = 0, jt = Et[_t]; We < jt.length; We += 1) {
              var Wt = jt[We], Jt = Wt[0];
              Jt.minzoom && this.zoom < Math.floor(Jt.minzoom) || Jt.maxzoom && this.zoom >= Jt.maxzoom || Jt.visibility !== "none" && (I(Wt, this.zoom, U), (Oe[Jt.id] = Jt.createBucket({ index: G.bucketLayerIDs.length, layers: Wt, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: ft, sourceID: this.source })).populate(ot, Ve, this.tileID.canonical), G.bucketLayerIDs.push(Wt.map(function(Br) {
                return Br.id;
              })));
            }
          }
        }
        var Zt = o.mapObject(Ve.glyphDependencies, function(Br) {
          return Object.keys(Br).map(Number);
        });
        Object.keys(Zt).length ? H.send("getGlyphs", { uid: this.uid, stacks: Zt }, function(Br, yr) {
          ie || (ie = Br, ve = yr, pn.call(he));
        }) : ve = {};
        var Yn = Object.keys(Ve.iconDependencies);
        Yn.length ? H.send("getImages", { icons: Yn, source: this.source, tileID: this.tileID, type: "icons" }, function(Br, yr) {
          ie || (ie = Br, Ge = yr, pn.call(he));
        }) : Ge = {};
        var Qt = Object.keys(Ve.patternDependencies);
        function pn() {
          if (ie)
            return ee(ie);
          if (ve && Ge && He) {
            var Br = new T(ve), yr = new o.ImageAtlas(Ge, He);
            for (var Rr in Oe) {
              var Yi = Oe[Rr];
              Yi instanceof o.SymbolBucket ? (I(Yi.layers, this.zoom, U), o.performSymbolLayout(Yi, ve, Br.positions, Ge, yr.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : Yi.hasPattern && (Yi instanceof o.LineBucket || Yi instanceof o.FillBucket || Yi instanceof o.FillExtrusionBucket) && (I(Yi.layers, this.zoom, U), Yi.addFeatures(Ve, this.tileID.canonical, yr.patternPositions));
            }
            this.status = "done", ee(null, { buckets: o.values(Oe).filter(function(Uu) {
              return !Uu.isEmpty();
            }), featureIndex: G, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Br.image, imageAtlas: yr, glyphMap: this.returnDependencies ? ve : null, iconMap: this.returnDependencies ? Ge : null, glyphPositions: this.returnDependencies ? Br.positions : null });
          }
        }
        Qt.length ? H.send("getImages", { icons: Qt, source: this.source, tileID: this.tileID, type: "patterns" }, function(Br, yr) {
          ie || (ie = Br, He = yr, pn.call(he));
        }) : He = {}, pn.call(this);
      };
      var z = function(N, F, U, H) {
        this.actor = N, this.layerIndex = F, this.availableImages = U, this.loadVectorData = H || A, this.loading = {}, this.loaded = {};
      };
      z.prototype.loadTile = function(N, F) {
        var U = this, H = N.uid;
        this.loading || (this.loading = {});
        var ee = !!(N && N.request && N.request.collectResourceTiming) && new o.RequestPerformance(N.request), he = this.loading[H] = new M(N);
        he.abort = this.loadVectorData(N, function(fe, G) {
          if (delete U.loading[H], fe || !G)
            return he.status = "done", U.loaded[H] = he, F(fe);
          var ie = G.rawData, ve = {};
          G.expires && (ve.expires = G.expires), G.cacheControl && (ve.cacheControl = G.cacheControl);
          var Ge = {};
          if (ee) {
            var He = ee.finish();
            He && (Ge.resourceTiming = JSON.parse(JSON.stringify(He)));
          }
          he.vectorTile = G.vectorTile, he.parse(G.vectorTile, U.layerIndex, U.availableImages, U.actor, function(Oe, Ve) {
            if (Oe || !Ve)
              return F(Oe);
            F(null, o.extend({ rawTileData: ie.slice(0) }, Ve, ve, Ge));
          }), U.loaded = U.loaded || {}, U.loaded[H] = he;
        });
      }, z.prototype.reloadTile = function(N, F) {
        var U = this, H = this.loaded, ee = N.uid, he = this;
        if (H && H[ee]) {
          var fe = H[ee];
          fe.showCollisionBoxes = N.showCollisionBoxes;
          var G = function(ie, ve) {
            var Ge = fe.reloadCallback;
            Ge && (delete fe.reloadCallback, fe.parse(fe.vectorTile, he.layerIndex, U.availableImages, he.actor, Ge)), F(ie, ve);
          };
          fe.status === "parsing" ? fe.reloadCallback = G : fe.status === "done" && (fe.vectorTile ? fe.parse(fe.vectorTile, this.layerIndex, this.availableImages, this.actor, G) : G());
        }
      }, z.prototype.abortTile = function(N, F) {
        var U = this.loading, H = N.uid;
        U && U[H] && U[H].abort && (U[H].abort(), delete U[H]), F();
      }, z.prototype.removeTile = function(N, F) {
        var U = this.loaded, H = N.uid;
        U && U[H] && delete U[H], F();
      };
      var V = o.window.ImageBitmap, Z = function() {
        this.loaded = {};
      };
      function X(N, F) {
        if (N.length !== 0) {
          Y(N[0], F);
          for (var U = 1; U < N.length; U++)
            Y(N[U], !F);
        }
      }
      function Y(N, F) {
        for (var U = 0, H = 0, ee = 0, he = N.length, fe = he - 1; ee < he; fe = ee++) {
          var G = (N[ee][0] - N[fe][0]) * (N[fe][1] + N[ee][1]), ie = U + G;
          H += Math.abs(U) >= Math.abs(G) ? U - ie + G : G - ie + U, U = ie;
        }
        U + H >= 0 != !!F && N.reverse();
      }
      Z.prototype.loadTile = function(N, F) {
        var U = N.uid, H = N.encoding, ee = N.rawImageData, he = V && ee instanceof V ? this.getImageData(ee) : ee, fe = new o.DEMData(U, he, H);
        this.loaded = this.loaded || {}, this.loaded[U] = fe, F(null, fe);
      }, Z.prototype.getImageData = function(N) {
        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(N.width, N.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = N.width, this.offscreenCanvas.height = N.height, this.offscreenCanvasContext.drawImage(N, 0, 0, N.width, N.height);
        var F = this.offscreenCanvasContext.getImageData(-1, -1, N.width + 2, N.height + 2);
        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new o.RGBAImage({ width: F.width, height: F.height }, F.data);
      }, Z.prototype.removeTile = function(N) {
        var F = this.loaded, U = N.uid;
        F && F[U] && delete F[U];
      };
      var de = o.vectorTile.VectorTileFeature.prototype.toGeoJSON, ye = function(N) {
        this._feature = N, this.extent = o.EXTENT, this.type = N.type, this.properties = N.tags, "id" in N && !isNaN(N.id) && (this.id = parseInt(N.id, 10));
      };
      ye.prototype.loadGeometry = function() {
        if (this._feature.type === 1) {
          for (var N = [], F = 0, U = this._feature.geometry; F < U.length; F += 1) {
            var H = U[F];
            N.push([new o.Point$1(H[0], H[1])]);
          }
          return N;
        }
        for (var ee = [], he = 0, fe = this._feature.geometry; he < fe.length; he += 1) {
          for (var G = [], ie = 0, ve = fe[he]; ie < ve.length; ie += 1) {
            var Ge = ve[ie];
            G.push(new o.Point$1(Ge[0], Ge[1]));
          }
          ee.push(G);
        }
        return ee;
      }, ye.prototype.toGeoJSON = function(N, F, U) {
        return de.call(this, N, F, U);
      };
      var Ie = function(N) {
        this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = o.EXTENT, this.length = N.length, this._features = N;
      };
      Ie.prototype.feature = function(N) {
        return new ye(this._features[N]);
      };
      var Be = o.vectorTile.VectorTileFeature, De = Re;
      function Re(N, F) {
        this.options = F || {}, this.features = N, this.length = N.length;
      }
      function Ee(N, F) {
        this.id = typeof N.id == "number" ? N.id : void 0, this.type = N.type, this.rawGeometry = N.type === 1 ? [N.geometry] : N.geometry, this.properties = N.tags, this.extent = F || 4096;
      }
      Re.prototype.feature = function(N) {
        return new Ee(this.features[N], this.options.extent);
      }, Ee.prototype.loadGeometry = function() {
        var N = this.rawGeometry;
        this.geometry = [];
        for (var F = 0; F < N.length; F++) {
          for (var U = N[F], H = [], ee = 0; ee < U.length; ee++)
            H.push(new o.Point$1(U[ee][0], U[ee][1]));
          this.geometry.push(H);
        }
        return this.geometry;
      }, Ee.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var N = this.geometry, F = 1 / 0, U = -1 / 0, H = 1 / 0, ee = -1 / 0, he = 0; he < N.length; he++)
          for (var fe = N[he], G = 0; G < fe.length; G++) {
            var ie = fe[G];
            F = Math.min(F, ie.x), U = Math.max(U, ie.x), H = Math.min(H, ie.y), ee = Math.max(ee, ie.y);
          }
        return [F, H, U, ee];
      }, Ee.prototype.toGeoJSON = Be.prototype.toGeoJSON;
      var ze = Ze, rt = De;
      function Ze(N) {
        var F = new o.pbf();
        return function(U, H) {
          for (var ee in U.layers)
            H.writeMessage(3, yt, U.layers[ee]);
        }(N, F), F.finish();
      }
      function yt(N, F) {
        var U;
        F.writeVarintField(15, N.version || 1), F.writeStringField(1, N.name || ""), F.writeVarintField(5, N.extent || 4096);
        var H = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (U = 0; U < N.length; U++)
          H.feature = N.feature(U), F.writeMessage(2, xe, H);
        var ee = H.keys;
        for (U = 0; U < ee.length; U++)
          F.writeStringField(3, ee[U]);
        var he = H.values;
        for (U = 0; U < he.length; U++)
          F.writeMessage(4, tr, he[U]);
      }
      function xe(N, F) {
        var U = N.feature;
        U.id !== void 0 && F.writeVarintField(1, U.id), F.writeMessage(2, Ke, N), F.writeVarintField(3, U.type), F.writeMessage(4, Pt, U);
      }
      function Ke(N, F) {
        var U = N.feature, H = N.keys, ee = N.values, he = N.keycache, fe = N.valuecache;
        for (var G in U.properties) {
          var ie = he[G];
          ie === void 0 && (H.push(G), he[G] = ie = H.length - 1), F.writeVarint(ie);
          var ve = U.properties[G], Ge = typeof ve;
          Ge !== "string" && Ge !== "boolean" && Ge !== "number" && (ve = JSON.stringify(ve));
          var He = Ge + ":" + ve, Oe = fe[He];
          Oe === void 0 && (ee.push(ve), fe[He] = Oe = ee.length - 1), F.writeVarint(Oe);
        }
      }
      function ct(N, F) {
        return (F << 3) + (7 & N);
      }
      function vt(N) {
        return N << 1 ^ N >> 31;
      }
      function Pt(N, F) {
        for (var U = N.loadGeometry(), H = N.type, ee = 0, he = 0, fe = U.length, G = 0; G < fe; G++) {
          var ie = U[G], ve = 1;
          H === 1 && (ve = ie.length), F.writeVarint(ct(1, ve));
          for (var Ge = H === 3 ? ie.length - 1 : ie.length, He = 0; He < Ge; He++) {
            He === 1 && H !== 1 && F.writeVarint(ct(2, Ge - 1));
            var Oe = ie[He].x - ee, Ve = ie[He].y - he;
            F.writeVarint(vt(Oe)), F.writeVarint(vt(Ve)), ee += Oe, he += Ve;
          }
          H === 3 && F.writeVarint(ct(7, 1));
        }
      }
      function tr(N, F) {
        var U = typeof N;
        U === "string" ? F.writeStringField(1, N) : U === "boolean" ? F.writeBooleanField(7, N) : U === "number" && (N % 1 != 0 ? F.writeDoubleField(3, N) : N < 0 ? F.writeSVarintField(6, N) : F.writeVarintField(5, N));
      }
      function Pn(N, F, U, H) {
        Dr(N, U, H), Dr(F, 2 * U, 2 * H), Dr(F, 2 * U + 1, 2 * H + 1);
      }
      function Dr(N, F, U) {
        var H = N[F];
        N[F] = N[U], N[U] = H;
      }
      function hr(N, F, U, H) {
        var ee = N - U, he = F - H;
        return ee * ee + he * he;
      }
      ze.fromVectorTileJs = Ze, ze.fromGeojsonVt = function(N, F) {
        F = F || {};
        var U = {};
        for (var H in N)
          U[H] = new De(N[H].features, F), U[H].name = H, U[H].version = F.version, U[H].extent = F.extent;
        return Ze({ layers: U });
      }, ze.GeoJSONWrapper = rt;
      var Zn = function(N) {
        return N[0];
      }, Nr = function(N) {
        return N[1];
      }, Fi = function(N, F, U, H, ee) {
        F === void 0 && (F = Zn), U === void 0 && (U = Nr), H === void 0 && (H = 64), ee === void 0 && (ee = Float64Array), this.nodeSize = H, this.points = N;
        for (var he = N.length < 65536 ? Uint16Array : Uint32Array, fe = this.ids = new he(N.length), G = this.coords = new ee(2 * N.length), ie = 0; ie < N.length; ie++)
          fe[ie] = ie, G[2 * ie] = F(N[ie]), G[2 * ie + 1] = U(N[ie]);
        (function ve(Ge, He, Oe, Ve, Et, _t) {
          if (!(Et - Ve <= Oe)) {
            var Pe = Ve + Et >> 1;
            (function ft(ot, ke, ce, we, We, jt) {
              for (; We > we; ) {
                if (We - we > 600) {
                  var Wt = We - we + 1, Jt = ce - we + 1, Zt = Math.log(Wt), Yn = 0.5 * Math.exp(2 * Zt / 3), Qt = 0.5 * Math.sqrt(Zt * Yn * (Wt - Yn) / Wt) * (Jt - Wt / 2 < 0 ? -1 : 1);
                  ft(ot, ke, ce, Math.max(we, Math.floor(ce - Jt * Yn / Wt + Qt)), Math.min(We, Math.floor(ce + (Wt - Jt) * Yn / Wt + Qt)), jt);
                }
                var pn = ke[2 * ce + jt], Br = we, yr = We;
                for (Pn(ot, ke, we, ce), ke[2 * We + jt] > pn && Pn(ot, ke, we, We); Br < yr; ) {
                  for (Pn(ot, ke, Br, yr), Br++, yr--; ke[2 * Br + jt] < pn; )
                    Br++;
                  for (; ke[2 * yr + jt] > pn; )
                    yr--;
                }
                ke[2 * we + jt] === pn ? Pn(ot, ke, we, yr) : Pn(ot, ke, ++yr, We), yr <= ce && (we = yr + 1), ce <= yr && (We = yr - 1);
              }
            })(Ge, He, Pe, Ve, Et, _t % 2), ve(Ge, He, Oe, Ve, Pe - 1, _t + 1), ve(Ge, He, Oe, Pe + 1, Et, _t + 1);
          }
        })(fe, G, H, 0, fe.length - 1, 0);
      };
      Fi.prototype.range = function(N, F, U, H) {
        return function(ee, he, fe, G, ie, ve, Ge) {
          for (var He, Oe, Ve = [0, ee.length - 1, 0], Et = []; Ve.length; ) {
            var _t = Ve.pop(), Pe = Ve.pop(), ft = Ve.pop();
            if (Pe - ft <= Ge)
              for (var ot = ft; ot <= Pe; ot++)
                Oe = he[2 * ot + 1], (He = he[2 * ot]) >= fe && He <= ie && Oe >= G && Oe <= ve && Et.push(ee[ot]);
            else {
              var ke = Math.floor((ft + Pe) / 2);
              Oe = he[2 * ke + 1], (He = he[2 * ke]) >= fe && He <= ie && Oe >= G && Oe <= ve && Et.push(ee[ke]);
              var ce = (_t + 1) % 2;
              (_t === 0 ? fe <= He : G <= Oe) && (Ve.push(ft), Ve.push(ke - 1), Ve.push(ce)), (_t === 0 ? ie >= He : ve >= Oe) && (Ve.push(ke + 1), Ve.push(Pe), Ve.push(ce));
            }
          }
          return Et;
        }(this.ids, this.coords, N, F, U, H, this.nodeSize);
      }, Fi.prototype.within = function(N, F, U) {
        return function(H, ee, he, fe, G, ie) {
          for (var ve = [0, H.length - 1, 0], Ge = [], He = G * G; ve.length; ) {
            var Oe = ve.pop(), Ve = ve.pop(), Et = ve.pop();
            if (Ve - Et <= ie)
              for (var _t = Et; _t <= Ve; _t++)
                hr(ee[2 * _t], ee[2 * _t + 1], he, fe) <= He && Ge.push(H[_t]);
            else {
              var Pe = Math.floor((Et + Ve) / 2), ft = ee[2 * Pe], ot = ee[2 * Pe + 1];
              hr(ft, ot, he, fe) <= He && Ge.push(H[Pe]);
              var ke = (Oe + 1) % 2;
              (Oe === 0 ? he - G <= ft : fe - G <= ot) && (ve.push(Et), ve.push(Pe - 1), ve.push(ke)), (Oe === 0 ? he + G >= ft : fe + G >= ot) && (ve.push(Pe + 1), ve.push(Ve), ve.push(ke));
            }
          }
          return Ge;
        }(this.ids, this.coords, N, F, U, this.nodeSize);
      };
      var Gr = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: function(N) {
        return N;
      } }, Cr = function(N) {
        this.options = me(Object.create(Gr), N), this.trees = new Array(this.options.maxZoom + 1);
      };
      function Vn(N, F, U, H, ee) {
        return { x: N, y: F, zoom: 1 / 0, id: U, parentId: -1, numPoints: H, properties: ee };
      }
      function wr(N, F) {
        var U = N.geometry.coordinates, H = U[1];
        return { x: Un(U[0]), y: K(H), zoom: 1 / 0, index: F, parentId: -1 };
      }
      function En(N) {
        return { type: "Feature", id: N.id, properties: oi(N), geometry: { type: "Point", coordinates: [(H = N.x, 360 * (H - 0.5)), (F = N.y, U = (180 - 360 * F) * Math.PI / 180, 360 * Math.atan(Math.exp(U)) / Math.PI - 90)] } };
        var F, U, H;
      }
      function oi(N) {
        var F = N.numPoints, U = F >= 1e4 ? Math.round(F / 1e3) + "k" : F >= 1e3 ? Math.round(F / 100) / 10 + "k" : F;
        return me(me({}, N.properties), { cluster: !0, cluster_id: N.id, point_count: F, point_count_abbreviated: U });
      }
      function Un(N) {
        return N / 360 + 0.5;
      }
      function K(N) {
        var F = Math.sin(N * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + F) / (1 - F)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function me(N, F) {
        for (var U in F)
          N[U] = F[U];
        return N;
      }
      function Le(N) {
        return N.x;
      }
      function qe(N) {
        return N.y;
      }
      function $e(N, F, U, H, ee, he) {
        var fe = ee - U, G = he - H;
        if (fe !== 0 || G !== 0) {
          var ie = ((N - U) * fe + (F - H) * G) / (fe * fe + G * G);
          ie > 1 ? (U = ee, H = he) : ie > 0 && (U += fe * ie, H += G * ie);
        }
        return (fe = N - U) * fe + (G = F - H) * G;
      }
      function et(N, F, U, H) {
        var ee = { id: N === void 0 ? null : N, type: F, geometry: U, tags: H, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(he) {
          var fe = he.geometry, G = he.type;
          if (G === "Point" || G === "MultiPoint" || G === "LineString")
            dt(he, fe);
          else if (G === "Polygon" || G === "MultiLineString")
            for (var ie = 0; ie < fe.length; ie++)
              dt(he, fe[ie]);
          else if (G === "MultiPolygon")
            for (ie = 0; ie < fe.length; ie++)
              for (var ve = 0; ve < fe[ie].length; ve++)
                dt(he, fe[ie][ve]);
        }(ee), ee;
      }
      function dt(N, F) {
        for (var U = 0; U < F.length; U += 3)
          N.minX = Math.min(N.minX, F[U]), N.minY = Math.min(N.minY, F[U + 1]), N.maxX = Math.max(N.maxX, F[U]), N.maxY = Math.max(N.maxY, F[U + 1]);
      }
      function Je(N, F, U, H) {
        if (F.geometry) {
          var ee = F.geometry.coordinates, he = F.geometry.type, fe = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2), G = [], ie = F.id;
          if (U.promoteId ? ie = F.properties[U.promoteId] : U.generateId && (ie = H || 0), he === "Point")
            lt(ee, G);
          else if (he === "MultiPoint")
            for (var ve = 0; ve < ee.length; ve++)
              lt(ee[ve], G);
          else if (he === "LineString")
            Ye(ee, G, fe, !1);
          else if (he === "MultiLineString") {
            if (U.lineMetrics) {
              for (ve = 0; ve < ee.length; ve++)
                Ye(ee[ve], G = [], fe, !1), N.push(et(ie, "LineString", G, F.properties));
              return;
            }
            It(ee, G, fe, !1);
          } else if (he === "Polygon")
            It(ee, G, fe, !0);
          else {
            if (he !== "MultiPolygon") {
              if (he === "GeometryCollection") {
                for (ve = 0; ve < F.geometry.geometries.length; ve++)
                  Je(N, { id: ie, geometry: F.geometry.geometries[ve], properties: F.properties }, U, H);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (ve = 0; ve < ee.length; ve++) {
              var Ge = [];
              It(ee[ve], Ge, fe, !0), G.push(Ge);
            }
          }
          N.push(et(ie, he, G, F.properties));
        }
      }
      function lt(N, F) {
        F.push(bt(N[0])), F.push(kt(N[1])), F.push(0);
      }
      function Ye(N, F, U, H) {
        for (var ee, he, fe = 0, G = 0; G < N.length; G++) {
          var ie = bt(N[G][0]), ve = kt(N[G][1]);
          F.push(ie), F.push(ve), F.push(0), G > 0 && (fe += H ? (ee * ve - ie * he) / 2 : Math.sqrt(Math.pow(ie - ee, 2) + Math.pow(ve - he, 2))), ee = ie, he = ve;
        }
        var Ge = F.length - 3;
        F[2] = 1, function He(Oe, Ve, Et, _t) {
          for (var Pe, ft = _t, ot = Et - Ve >> 1, ke = Et - Ve, ce = Oe[Ve], we = Oe[Ve + 1], We = Oe[Et], jt = Oe[Et + 1], Wt = Ve + 3; Wt < Et; Wt += 3) {
            var Jt = $e(Oe[Wt], Oe[Wt + 1], ce, we, We, jt);
            if (Jt > ft)
              Pe = Wt, ft = Jt;
            else if (Jt === ft) {
              var Zt = Math.abs(Wt - ot);
              Zt < ke && (Pe = Wt, ke = Zt);
            }
          }
          ft > _t && (Pe - Ve > 3 && He(Oe, Ve, Pe, _t), Oe[Pe + 2] = ft, Et - Pe > 3 && He(Oe, Pe, Et, _t));
        }(F, 0, Ge, U), F[Ge + 2] = 1, F.size = Math.abs(fe), F.start = 0, F.end = F.size;
      }
      function It(N, F, U, H) {
        for (var ee = 0; ee < N.length; ee++) {
          var he = [];
          Ye(N[ee], he, U, H), F.push(he);
        }
      }
      function bt(N) {
        return N / 360 + 0.5;
      }
      function kt(N) {
        var F = Math.sin(N * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + F) / (1 - F)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function Ut(N, F, U, H, ee, he, fe, G) {
        if (H /= F, he >= (U /= F) && fe < H)
          return N;
        if (fe < U || he >= H)
          return null;
        for (var ie = [], ve = 0; ve < N.length; ve++) {
          var Ge = N[ve], He = Ge.geometry, Oe = Ge.type, Ve = ee === 0 ? Ge.minX : Ge.minY, Et = ee === 0 ? Ge.maxX : Ge.maxY;
          if (Ve >= U && Et < H)
            ie.push(Ge);
          else if (!(Et < U || Ve >= H)) {
            var _t = [];
            if (Oe === "Point" || Oe === "MultiPoint")
              fr(He, _t, U, H, ee);
            else if (Oe === "LineString")
              Fr(He, _t, U, H, ee, !1, G.lineMetrics);
            else if (Oe === "MultiLineString")
              Jr(He, _t, U, H, ee, !1);
            else if (Oe === "Polygon")
              Jr(He, _t, U, H, ee, !0);
            else if (Oe === "MultiPolygon")
              for (var Pe = 0; Pe < He.length; Pe++) {
                var ft = [];
                Jr(He[Pe], ft, U, H, ee, !0), ft.length && _t.push(ft);
              }
            if (_t.length) {
              if (G.lineMetrics && Oe === "LineString") {
                for (Pe = 0; Pe < _t.length; Pe++)
                  ie.push(et(Ge.id, Oe, _t[Pe], Ge.tags));
                continue;
              }
              Oe !== "LineString" && Oe !== "MultiLineString" || (_t.length === 1 ? (Oe = "LineString", _t = _t[0]) : Oe = "MultiLineString"), Oe !== "Point" && Oe !== "MultiPoint" || (Oe = _t.length === 3 ? "Point" : "MultiPoint"), ie.push(et(Ge.id, Oe, _t, Ge.tags));
            }
          }
        }
        return ie.length ? ie : null;
      }
      function fr(N, F, U, H, ee) {
        for (var he = 0; he < N.length; he += 3) {
          var fe = N[he + ee];
          fe >= U && fe <= H && (F.push(N[he]), F.push(N[he + 1]), F.push(N[he + 2]));
        }
      }
      function Fr(N, F, U, H, ee, he, fe) {
        for (var G, ie, ve = Ar(N), Ge = ee === 0 ? Bi : so, He = N.start, Oe = 0; Oe < N.length - 3; Oe += 3) {
          var Ve = N[Oe], Et = N[Oe + 1], _t = N[Oe + 2], Pe = N[Oe + 3], ft = N[Oe + 4], ot = ee === 0 ? Ve : Et, ke = ee === 0 ? Pe : ft, ce = !1;
          fe && (G = Math.sqrt(Math.pow(Ve - Pe, 2) + Math.pow(Et - ft, 2))), ot < U ? ke > U && (ie = Ge(ve, Ve, Et, Pe, ft, U), fe && (ve.start = He + G * ie)) : ot > H ? ke < H && (ie = Ge(ve, Ve, Et, Pe, ft, H), fe && (ve.start = He + G * ie)) : Xn(ve, Ve, Et, _t), ke < U && ot >= U && (ie = Ge(ve, Ve, Et, Pe, ft, U), ce = !0), ke > H && ot <= H && (ie = Ge(ve, Ve, Et, Pe, ft, H), ce = !0), !he && ce && (fe && (ve.end = He + G * ie), F.push(ve), ve = Ar(N)), fe && (He += G);
        }
        var we = N.length - 3;
        Ve = N[we], Et = N[we + 1], _t = N[we + 2], (ot = ee === 0 ? Ve : Et) >= U && ot <= H && Xn(ve, Ve, Et, _t), we = ve.length - 3, he && we >= 3 && (ve[we] !== ve[0] || ve[we + 1] !== ve[1]) && Xn(ve, ve[0], ve[1], ve[2]), ve.length && F.push(ve);
      }
      function Ar(N) {
        var F = [];
        return F.size = N.size, F.start = N.start, F.end = N.end, F;
      }
      function Jr(N, F, U, H, ee, he) {
        for (var fe = 0; fe < N.length; fe++)
          Fr(N[fe], F, U, H, ee, he, !1);
      }
      function Xn(N, F, U, H) {
        N.push(F), N.push(U), N.push(H);
      }
      function Bi(N, F, U, H, ee, he) {
        var fe = (he - F) / (H - F);
        return N.push(he), N.push(U + (ee - U) * fe), N.push(1), fe;
      }
      function so(N, F, U, H, ee, he) {
        var fe = (he - U) / (ee - U);
        return N.push(F + (H - F) * fe), N.push(he), N.push(1), fe;
      }
      function Kn(N, F) {
        for (var U = [], H = 0; H < N.length; H++) {
          var ee, he = N[H], fe = he.type;
          if (fe === "Point" || fe === "MultiPoint" || fe === "LineString")
            ee = ki(he.geometry, F);
          else if (fe === "MultiLineString" || fe === "Polygon") {
            ee = [];
            for (var G = 0; G < he.geometry.length; G++)
              ee.push(ki(he.geometry[G], F));
          } else if (fe === "MultiPolygon")
            for (ee = [], G = 0; G < he.geometry.length; G++) {
              for (var ie = [], ve = 0; ve < he.geometry[G].length; ve++)
                ie.push(ki(he.geometry[G][ve], F));
              ee.push(ie);
            }
          U.push(et(he.id, fe, ee, he.tags));
        }
        return U;
      }
      function ki(N, F) {
        var U = [];
        U.size = N.size, N.start !== void 0 && (U.start = N.start, U.end = N.end);
        for (var H = 0; H < N.length; H += 3)
          U.push(N[H] + F, N[H + 1], N[H + 2]);
        return U;
      }
      function Sn(N, F) {
        if (N.transformed)
          return N;
        var U, H, ee, he = 1 << N.z, fe = N.x, G = N.y;
        for (U = 0; U < N.features.length; U++) {
          var ie = N.features[U], ve = ie.geometry, Ge = ie.type;
          if (ie.geometry = [], Ge === 1)
            for (H = 0; H < ve.length; H += 2)
              ie.geometry.push(ai(ve[H], ve[H + 1], F, he, fe, G));
          else
            for (H = 0; H < ve.length; H++) {
              var He = [];
              for (ee = 0; ee < ve[H].length; ee += 2)
                He.push(ai(ve[H][ee], ve[H][ee + 1], F, he, fe, G));
              ie.geometry.push(He);
            }
        }
        return N.transformed = !0, N;
      }
      function ai(N, F, U, H, ee, he) {
        return [Math.round(U * (N * H - ee)), Math.round(U * (F * H - he))];
      }
      function Fa(N, F, U, H, ee) {
        for (var he = F === ee.maxZoom ? 0 : ee.tolerance / ((1 << F) * ee.extent), fe = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: U, y: H, z: F, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, G = 0; G < N.length; G++) {
          fe.numFeatures++, Uo(fe, N[G], he, ee);
          var ie = N[G].minX, ve = N[G].minY, Ge = N[G].maxX, He = N[G].maxY;
          ie < fe.minX && (fe.minX = ie), ve < fe.minY && (fe.minY = ve), Ge > fe.maxX && (fe.maxX = Ge), He > fe.maxY && (fe.maxY = He);
        }
        return fe;
      }
      function Uo(N, F, U, H) {
        var ee = F.geometry, he = F.type, fe = [];
        if (he === "Point" || he === "MultiPoint")
          for (var G = 0; G < ee.length; G += 3)
            fe.push(ee[G]), fe.push(ee[G + 1]), N.numPoints++, N.numSimplified++;
        else if (he === "LineString")
          Ba(fe, ee, N, U, !1, !1);
        else if (he === "MultiLineString" || he === "Polygon")
          for (G = 0; G < ee.length; G++)
            Ba(fe, ee[G], N, U, he === "Polygon", G === 0);
        else if (he === "MultiPolygon")
          for (var ie = 0; ie < ee.length; ie++) {
            var ve = ee[ie];
            for (G = 0; G < ve.length; G++)
              Ba(fe, ve[G], N, U, !0, G === 0);
          }
        if (fe.length) {
          var Ge = F.tags || null;
          if (he === "LineString" && H.lineMetrics) {
            for (var He in Ge = {}, F.tags)
              Ge[He] = F.tags[He];
            Ge.mapbox_clip_start = ee.start / ee.size, Ge.mapbox_clip_end = ee.end / ee.size;
          }
          var Oe = { geometry: fe, type: he === "Polygon" || he === "MultiPolygon" ? 3 : he === "LineString" || he === "MultiLineString" ? 2 : 1, tags: Ge };
          F.id !== null && (Oe.id = F.id), N.features.push(Oe);
        }
      }
      function Ba(N, F, U, H, ee, he) {
        var fe = H * H;
        if (H > 0 && F.size < (ee ? fe : H))
          U.numPoints += F.length / 3;
        else {
          for (var G = [], ie = 0; ie < F.length; ie += 3)
            (H === 0 || F[ie + 2] > fe) && (U.numSimplified++, G.push(F[ie]), G.push(F[ie + 1])), U.numPoints++;
          ee && function(ve, Ge) {
            for (var He = 0, Oe = 0, Ve = ve.length, Et = Ve - 2; Oe < Ve; Et = Oe, Oe += 2)
              He += (ve[Oe] - ve[Et]) * (ve[Oe + 1] + ve[Et + 1]);
            if (He > 0 === Ge)
              for (Oe = 0, Ve = ve.length; Oe < Ve / 2; Oe += 2) {
                var _t = ve[Oe], Pe = ve[Oe + 1];
                ve[Oe] = ve[Ve - 2 - Oe], ve[Oe + 1] = ve[Ve - 1 - Oe], ve[Ve - 2 - Oe] = _t, ve[Ve - 1 - Oe] = Pe;
              }
          }(G, he), N.push(G);
        }
      }
      function na(N, F) {
        var U = (F = this.options = function(ee, he) {
          for (var fe in he)
            ee[fe] = he[fe];
          return ee;
        }(Object.create(this.options), F)).debug;
        if (U && console.time("preprocess data"), F.maxZoom < 0 || F.maxZoom > 24)
          throw new Error("maxZoom should be in the 0-24 range");
        if (F.promoteId && F.generateId)
          throw new Error("promoteId and generateId cannot be used together.");
        var H = function(ee, he) {
          var fe = [];
          if (ee.type === "FeatureCollection")
            for (var G = 0; G < ee.features.length; G++)
              Je(fe, ee.features[G], he, G);
          else
            Je(fe, ee.type === "Feature" ? ee : { geometry: ee }, he);
          return fe;
        }(N, F);
        this.tiles = {}, this.tileCoords = [], U && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", F.indexMaxZoom, F.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (H = function(ee, he) {
          var fe = he.buffer / he.extent, G = ee, ie = Ut(ee, 1, -1 - fe, fe, 0, -1, 2, he), ve = Ut(ee, 1, 1 - fe, 2 + fe, 0, -1, 2, he);
          return (ie || ve) && (G = Ut(ee, 1, -fe, 1 + fe, 0, -1, 2, he) || [], ie && (G = Kn(ie, 1).concat(G)), ve && (G = G.concat(Kn(ve, -1)))), G;
        }(H, F)).length && this.splitTile(H, 0, 0, 0), U && (H.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function on(N, F, U) {
        return 32 * ((1 << N) * U + F) + N;
      }
      function So(N, F) {
        var U = N.tileID.canonical;
        if (!this._geoJSONIndex)
          return F(null, null);
        var H = this._geoJSONIndex.getTile(U.z, U.x, U.y);
        if (!H)
          return F(null, null);
        var ee = new Ie(H.features), he = ze(ee);
        he.byteOffset === 0 && he.byteLength === he.buffer.byteLength || (he = new Uint8Array(he)), F(null, { vectorTile: ee, rawData: he.buffer });
      }
      Cr.prototype.load = function(N) {
        var F = this.options, U = F.log, H = F.minZoom, ee = F.maxZoom, he = F.nodeSize;
        U && console.time("total time");
        var fe = "prepare " + N.length + " points";
        U && console.time(fe), this.points = N;
        for (var G = [], ie = 0; ie < N.length; ie++)
          N[ie].geometry && G.push(wr(N[ie], ie));
        this.trees[ee + 1] = new Fi(G, Le, qe, he, Float32Array), U && console.timeEnd(fe);
        for (var ve = ee; ve >= H; ve--) {
          var Ge = +Date.now();
          G = this._cluster(G, ve), this.trees[ve] = new Fi(G, Le, qe, he, Float32Array), U && console.log("z%d: %d clusters in %dms", ve, G.length, +Date.now() - Ge);
        }
        return U && console.timeEnd("total time"), this;
      }, Cr.prototype.getClusters = function(N, F) {
        var U = ((N[0] + 180) % 360 + 360) % 360 - 180, H = Math.max(-90, Math.min(90, N[1])), ee = N[2] === 180 ? 180 : ((N[2] + 180) % 360 + 360) % 360 - 180, he = Math.max(-90, Math.min(90, N[3]));
        if (N[2] - N[0] >= 360)
          U = -180, ee = 180;
        else if (U > ee) {
          var fe = this.getClusters([U, H, 180, he], F), G = this.getClusters([-180, H, ee, he], F);
          return fe.concat(G);
        }
        for (var ie = this.trees[this._limitZoom(F)], ve = [], Ge = 0, He = ie.range(Un(U), K(he), Un(ee), K(H)); Ge < He.length; Ge += 1) {
          var Oe = ie.points[He[Ge]];
          ve.push(Oe.numPoints ? En(Oe) : this.points[Oe.index]);
        }
        return ve;
      }, Cr.prototype.getChildren = function(N) {
        var F = this._getOriginId(N), U = this._getOriginZoom(N), H = "No cluster with the specified id.", ee = this.trees[U];
        if (!ee)
          throw new Error(H);
        var he = ee.points[F];
        if (!he)
          throw new Error(H);
        for (var fe = this.options.radius / (this.options.extent * Math.pow(2, U - 1)), G = [], ie = 0, ve = ee.within(he.x, he.y, fe); ie < ve.length; ie += 1) {
          var Ge = ee.points[ve[ie]];
          Ge.parentId === N && G.push(Ge.numPoints ? En(Ge) : this.points[Ge.index]);
        }
        if (G.length === 0)
          throw new Error(H);
        return G;
      }, Cr.prototype.getLeaves = function(N, F, U) {
        var H = [];
        return this._appendLeaves(H, N, F = F || 10, U = U || 0, 0), H;
      }, Cr.prototype.getTile = function(N, F, U) {
        var H = this.trees[this._limitZoom(N)], ee = Math.pow(2, N), he = this.options, fe = he.radius / he.extent, G = (U - fe) / ee, ie = (U + 1 + fe) / ee, ve = { features: [] };
        return this._addTileFeatures(H.range((F - fe) / ee, G, (F + 1 + fe) / ee, ie), H.points, F, U, ee, ve), F === 0 && this._addTileFeatures(H.range(1 - fe / ee, G, 1, ie), H.points, ee, U, ee, ve), F === ee - 1 && this._addTileFeatures(H.range(0, G, fe / ee, ie), H.points, -1, U, ee, ve), ve.features.length ? ve : null;
      }, Cr.prototype.getClusterExpansionZoom = function(N) {
        for (var F = this._getOriginZoom(N) - 1; F <= this.options.maxZoom; ) {
          var U = this.getChildren(N);
          if (F++, U.length !== 1)
            break;
          N = U[0].properties.cluster_id;
        }
        return F;
      }, Cr.prototype._appendLeaves = function(N, F, U, H, ee) {
        for (var he = 0, fe = this.getChildren(F); he < fe.length; he += 1) {
          var G = fe[he], ie = G.properties;
          if (ie && ie.cluster ? ee + ie.point_count <= H ? ee += ie.point_count : ee = this._appendLeaves(N, ie.cluster_id, U, H, ee) : ee < H ? ee++ : N.push(G), N.length === U)
            break;
        }
        return ee;
      }, Cr.prototype._addTileFeatures = function(N, F, U, H, ee, he) {
        for (var fe = 0, G = N; fe < G.length; fe += 1) {
          var ie = F[G[fe]], ve = ie.numPoints, Ge = { type: 1, geometry: [[Math.round(this.options.extent * (ie.x * ee - U)), Math.round(this.options.extent * (ie.y * ee - H))]], tags: ve ? oi(ie) : this.points[ie.index].properties }, He = void 0;
          ve ? He = ie.id : this.options.generateId ? He = ie.index : this.points[ie.index].id && (He = this.points[ie.index].id), He !== void 0 && (Ge.id = He), he.features.push(Ge);
        }
      }, Cr.prototype._limitZoom = function(N) {
        return Math.max(this.options.minZoom, Math.min(+N, this.options.maxZoom + 1));
      }, Cr.prototype._cluster = function(N, F) {
        for (var U = [], H = this.options, ee = H.reduce, he = H.minPoints, fe = H.radius / (H.extent * Math.pow(2, F)), G = 0; G < N.length; G++) {
          var ie = N[G];
          if (!(ie.zoom <= F)) {
            ie.zoom = F;
            for (var ve = this.trees[F + 1], Ge = ve.within(ie.x, ie.y, fe), He = ie.numPoints || 1, Oe = He, Ve = 0, Et = Ge; Ve < Et.length; Ve += 1) {
              var _t = ve.points[Et[Ve]];
              _t.zoom > F && (Oe += _t.numPoints || 1);
            }
            if (Oe >= he) {
              for (var Pe = ie.x * He, ft = ie.y * He, ot = ee && He > 1 ? this._map(ie, !0) : null, ke = (G << 5) + (F + 1) + this.points.length, ce = 0, we = Ge; ce < we.length; ce += 1) {
                var We = ve.points[we[ce]];
                if (!(We.zoom <= F)) {
                  We.zoom = F;
                  var jt = We.numPoints || 1;
                  Pe += We.x * jt, ft += We.y * jt, We.parentId = ke, ee && (ot || (ot = this._map(ie, !0)), ee(ot, this._map(We)));
                }
              }
              ie.parentId = ke, U.push(Vn(Pe / Oe, ft / Oe, ke, Oe, ot));
            } else if (U.push(ie), Oe > 1)
              for (var Wt = 0, Jt = Ge; Wt < Jt.length; Wt += 1) {
                var Zt = ve.points[Jt[Wt]];
                Zt.zoom <= F || (Zt.zoom = F, U.push(Zt));
              }
          }
        }
        return U;
      }, Cr.prototype._getOriginId = function(N) {
        return N - this.points.length >> 5;
      }, Cr.prototype._getOriginZoom = function(N) {
        return (N - this.points.length) % 32;
      }, Cr.prototype._map = function(N, F) {
        if (N.numPoints)
          return F ? me({}, N.properties) : N.properties;
        var U = this.points[N.index].properties, H = this.options.map(U);
        return F && H === U ? me({}, H) : H;
      }, na.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, na.prototype.splitTile = function(N, F, U, H, ee, he, fe) {
        for (var G = [N, F, U, H], ie = this.options, ve = ie.debug; G.length; ) {
          H = G.pop(), U = G.pop(), F = G.pop(), N = G.pop();
          var Ge = 1 << F, He = on(F, U, H), Oe = this.tiles[He];
          if (!Oe && (ve > 1 && console.time("creation"), Oe = this.tiles[He] = Fa(N, F, U, H, ie), this.tileCoords.push({ z: F, x: U, y: H }), ve)) {
            ve > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", F, U, H, Oe.numFeatures, Oe.numPoints, Oe.numSimplified), console.timeEnd("creation"));
            var Ve = "z" + F;
            this.stats[Ve] = (this.stats[Ve] || 0) + 1, this.total++;
          }
          if (Oe.source = N, ee) {
            if (F === ie.maxZoom || F === ee)
              continue;
            var Et = 1 << ee - F;
            if (U !== Math.floor(he / Et) || H !== Math.floor(fe / Et))
              continue;
          } else if (F === ie.indexMaxZoom || Oe.numPoints <= ie.indexMaxPoints)
            continue;
          if (Oe.source = null, N.length !== 0) {
            ve > 1 && console.time("clipping");
            var _t, Pe, ft, ot, ke, ce, we = 0.5 * ie.buffer / ie.extent, We = 0.5 - we, jt = 0.5 + we, Wt = 1 + we;
            _t = Pe = ft = ot = null, ke = Ut(N, Ge, U - we, U + jt, 0, Oe.minX, Oe.maxX, ie), ce = Ut(N, Ge, U + We, U + Wt, 0, Oe.minX, Oe.maxX, ie), N = null, ke && (_t = Ut(ke, Ge, H - we, H + jt, 1, Oe.minY, Oe.maxY, ie), Pe = Ut(ke, Ge, H + We, H + Wt, 1, Oe.minY, Oe.maxY, ie), ke = null), ce && (ft = Ut(ce, Ge, H - we, H + jt, 1, Oe.minY, Oe.maxY, ie), ot = Ut(ce, Ge, H + We, H + Wt, 1, Oe.minY, Oe.maxY, ie), ce = null), ve > 1 && console.timeEnd("clipping"), G.push(_t || [], F + 1, 2 * U, 2 * H), G.push(Pe || [], F + 1, 2 * U, 2 * H + 1), G.push(ft || [], F + 1, 2 * U + 1, 2 * H), G.push(ot || [], F + 1, 2 * U + 1, 2 * H + 1);
          }
        }
      }, na.prototype.getTile = function(N, F, U) {
        var H = this.options, ee = H.extent, he = H.debug;
        if (N < 0 || N > 24)
          return null;
        var fe = 1 << N, G = on(N, F = (F % fe + fe) % fe, U);
        if (this.tiles[G])
          return Sn(this.tiles[G], ee);
        he > 1 && console.log("drilling down to z%d-%d-%d", N, F, U);
        for (var ie, ve = N, Ge = F, He = U; !ie && ve > 0; )
          ve--, Ge = Math.floor(Ge / 2), He = Math.floor(He / 2), ie = this.tiles[on(ve, Ge, He)];
        return ie && ie.source ? (he > 1 && console.log("found parent tile z%d-%d-%d", ve, Ge, He), he > 1 && console.time("drilling down"), this.splitTile(ie.source, ve, Ge, He, N, F, U), he > 1 && console.timeEnd("drilling down"), this.tiles[G] ? Sn(this.tiles[G], ee) : null) : null;
      };
      var tl = function(N) {
        function F(U, H, ee, he) {
          N.call(this, U, H, ee, So), he && (this.loadGeoJSON = he);
        }
        return N && (F.__proto__ = N), (F.prototype = Object.create(N && N.prototype)).constructor = F, F.prototype.loadData = function(U, H) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), this._pendingCallback = H, this._pendingLoadDataParams = U, this._state && this._state !== "Idle" ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());
        }, F.prototype._loadData = function() {
          var U = this;
          if (this._pendingCallback && this._pendingLoadDataParams) {
            var H = this._pendingCallback, ee = this._pendingLoadDataParams;
            delete this._pendingCallback, delete this._pendingLoadDataParams;
            var he = !!(ee && ee.request && ee.request.collectResourceTiming) && new o.RequestPerformance(ee.request);
            this.loadGeoJSON(ee, function(fe, G) {
              if (fe || !G)
                return H(fe);
              if (typeof G != "object")
                return H(new Error("Input data given to '" + ee.source + "' is not a valid GeoJSON object."));
              (function Oe(Ve, Et) {
                var _t, Pe = Ve && Ve.type;
                if (Pe === "FeatureCollection")
                  for (_t = 0; _t < Ve.features.length; _t++)
                    Oe(Ve.features[_t], Et);
                else if (Pe === "GeometryCollection")
                  for (_t = 0; _t < Ve.geometries.length; _t++)
                    Oe(Ve.geometries[_t], Et);
                else if (Pe === "Feature")
                  Oe(Ve.geometry, Et);
                else if (Pe === "Polygon")
                  X(Ve.coordinates, Et);
                else if (Pe === "MultiPolygon")
                  for (_t = 0; _t < Ve.coordinates.length; _t++)
                    X(Ve.coordinates[_t], Et);
                return Ve;
              })(G, !0);
              try {
                if (ee.filter) {
                  var ie = o.createExpression(ee.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                  if (ie.result === "error")
                    throw new Error(ie.value.map(function(Oe) {
                      return Oe.key + ": " + Oe.message;
                    }).join(", "));
                  var ve = G.features.filter(function(Oe) {
                    return ie.value.evaluate({ zoom: 0 }, Oe);
                  });
                  G = { type: "FeatureCollection", features: ve };
                }
                U._geoJSONIndex = ee.cluster ? new Cr(function(Oe) {
                  var Ve = Oe.superclusterOptions, Et = Oe.clusterProperties;
                  if (!Et || !Ve)
                    return Ve;
                  for (var _t = {}, Pe = {}, ft = { accumulated: null, zoom: 0 }, ot = { properties: null }, ke = Object.keys(Et), ce = 0, we = ke; ce < we.length; ce += 1) {
                    var We = we[ce], jt = Et[We], Wt = jt[0], Jt = o.createExpression(jt[1]), Zt = o.createExpression(typeof Wt == "string" ? [Wt, ["accumulated"], ["get", We]] : Wt);
                    _t[We] = Jt.value, Pe[We] = Zt.value;
                  }
                  return Ve.map = function(Yn) {
                    ot.properties = Yn;
                    for (var Qt = {}, pn = 0, Br = ke; pn < Br.length; pn += 1) {
                      var yr = Br[pn];
                      Qt[yr] = _t[yr].evaluate(ft, ot);
                    }
                    return Qt;
                  }, Ve.reduce = function(Yn, Qt) {
                    ot.properties = Qt;
                    for (var pn = 0, Br = ke; pn < Br.length; pn += 1) {
                      var yr = Br[pn];
                      ft.accumulated = Yn[yr], Yn[yr] = Pe[yr].evaluate(ft, ot);
                    }
                  }, Ve;
                }(ee)).load(G.features) : function(Oe, Ve) {
                  return new na(Oe, Ve);
                }(G, ee.geojsonVtOptions);
              } catch (Oe) {
                return H(Oe);
              }
              U.loaded = {};
              var Ge = {};
              if (he) {
                var He = he.finish();
                He && (Ge.resourceTiming = {}, Ge.resourceTiming[ee.source] = JSON.parse(JSON.stringify(He)));
              }
              H(null, Ge);
            });
          }
        }, F.prototype.coalesce = function() {
          this._state === "Coalescing" ? this._state = "Idle" : this._state === "NeedsLoadData" && (this._state = "Coalescing", this._loadData());
        }, F.prototype.reloadTile = function(U, H) {
          var ee = this.loaded;
          return ee && ee[U.uid] ? N.prototype.reloadTile.call(this, U, H) : this.loadTile(U, H);
        }, F.prototype.loadGeoJSON = function(U, H) {
          if (U.request)
            o.getJSON(U.request, H);
          else {
            if (typeof U.data != "string")
              return H(new Error("Input data given to '" + U.source + "' is not a valid GeoJSON object."));
            try {
              return H(null, JSON.parse(U.data));
            } catch {
              return H(new Error("Input data given to '" + U.source + "' is not a valid GeoJSON object."));
            }
          }
        }, F.prototype.removeSource = function(U, H) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), H();
        }, F.prototype.getClusterExpansionZoom = function(U, H) {
          try {
            H(null, this._geoJSONIndex.getClusterExpansionZoom(U.clusterId));
          } catch (ee) {
            H(ee);
          }
        }, F.prototype.getClusterChildren = function(U, H) {
          try {
            H(null, this._geoJSONIndex.getChildren(U.clusterId));
          } catch (ee) {
            H(ee);
          }
        }, F.prototype.getClusterLeaves = function(U, H) {
          try {
            H(null, this._geoJSONIndex.getLeaves(U.clusterId, U.limit, U.offset));
          } catch (ee) {
            H(ee);
          }
        }, F;
      }(z), bn = function(N) {
        var F = this;
        this.self = N, this.actor = new o.Actor(N, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: z, geojson: tl }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function(U, H) {
          if (F.workerSourceTypes[U])
            throw new Error('Worker source with name "' + U + '" already registered.');
          F.workerSourceTypes[U] = H;
        }, this.self.registerRTLTextPlugin = function(U) {
          if (o.plugin.isParsed())
            throw new Error("RTL text plugin already registered.");
          o.plugin.applyArabicShaping = U.applyArabicShaping, o.plugin.processBidirectionalText = U.processBidirectionalText, o.plugin.processStyledBidirectionalText = U.processStyledBidirectionalText;
        };
      };
      return bn.prototype.setReferrer = function(N, F) {
        this.referrer = F;
      }, bn.prototype.setImages = function(N, F, U) {
        for (var H in this.availableImages[N] = F, this.workerSources[N]) {
          var ee = this.workerSources[N][H];
          for (var he in ee)
            ee[he].availableImages = F;
        }
        U();
      }, bn.prototype.setLayers = function(N, F, U) {
        this.getLayerIndex(N).replace(F), U();
      }, bn.prototype.updateLayers = function(N, F, U) {
        this.getLayerIndex(N).update(F.layers, F.removedIds), U();
      }, bn.prototype.loadTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).loadTile(F, U);
      }, bn.prototype.loadDEMTile = function(N, F, U) {
        this.getDEMWorkerSource(N, F.source).loadTile(F, U);
      }, bn.prototype.reloadTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).reloadTile(F, U);
      }, bn.prototype.abortTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).abortTile(F, U);
      }, bn.prototype.removeTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).removeTile(F, U);
      }, bn.prototype.removeDEMTile = function(N, F) {
        this.getDEMWorkerSource(N, F.source).removeTile(F);
      }, bn.prototype.removeSource = function(N, F, U) {
        if (this.workerSources[N] && this.workerSources[N][F.type] && this.workerSources[N][F.type][F.source]) {
          var H = this.workerSources[N][F.type][F.source];
          delete this.workerSources[N][F.type][F.source], H.removeSource !== void 0 ? H.removeSource(F, U) : U();
        }
      }, bn.prototype.loadWorkerSource = function(N, F, U) {
        try {
          this.self.importScripts(F.url), U();
        } catch (H) {
          U(H.toString());
        }
      }, bn.prototype.syncRTLPluginState = function(N, F, U) {
        try {
          o.plugin.setState(F);
          var H = o.plugin.getPluginURL();
          if (o.plugin.isLoaded() && !o.plugin.isParsed() && H != null) {
            this.self.importScripts(H);
            var ee = o.plugin.isParsed();
            U(ee ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + H), ee);
          }
        } catch (he) {
          U(he.toString());
        }
      }, bn.prototype.getAvailableImages = function(N) {
        var F = this.availableImages[N];
        return F || (F = []), F;
      }, bn.prototype.getLayerIndex = function(N) {
        var F = this.layerIndexes[N];
        return F || (F = this.layerIndexes[N] = new b()), F;
      }, bn.prototype.getWorkerSource = function(N, F, U) {
        var H = this;
        return this.workerSources[N] || (this.workerSources[N] = {}), this.workerSources[N][F] || (this.workerSources[N][F] = {}), this.workerSources[N][F][U] || (this.workerSources[N][F][U] = new this.workerSourceTypes[F]({ send: function(ee, he, fe) {
          H.actor.send(ee, he, fe, N);
        } }, this.getLayerIndex(N), this.getAvailableImages(N))), this.workerSources[N][F][U];
      }, bn.prototype.getDEMWorkerSource = function(N, F) {
        return this.demWorkerSources[N] || (this.demWorkerSources[N] = {}), this.demWorkerSources[N][F] || (this.demWorkerSources[N][F] = new Z()), this.demWorkerSources[N][F];
      }, bn.prototype.enforceCacheSizeLimit = function(N, F) {
        o.enforceCacheSizeLimit(F);
      }, typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope && (self.worker = new bn(self)), bn;
    }), f(["./shared"], function(o) {
      var m = o.createCommonjsModule(function(u) {
        function h(_) {
          return !c(_);
        }
        function c(_) {
          return typeof window > "u" || typeof document > "u" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return !1;
            var E, O, k = new Blob([""], { type: "text/javascript" }), R = URL.createObjectURL(k);
            try {
              O = new Worker(R), E = !0;
            } catch {
              E = !1;
            }
            return O && O.terminate(), URL.revokeObjectURL(R), E;
          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
            var E = document.createElement("canvas");
            E.width = E.height = 1;
            var O = E.getContext("2d");
            if (!O)
              return !1;
            var k = O.getImageData(0, 0, 1, 1);
            return k && k.width === E.width;
          }() ? (d[w = _ && _.failIfMajorPerformanceCaveat] === void 0 && (d[w] = function(E) {
            var O = function(R) {
              var q = document.createElement("canvas"), $ = Object.create(h.webGLContextAttributes);
              return $.failIfMajorPerformanceCaveat = R, q.probablySupportsContext ? q.probablySupportsContext("webgl", $) || q.probablySupportsContext("experimental-webgl", $) : q.supportsContext ? q.supportsContext("webgl", $) || q.supportsContext("experimental-webgl", $) : q.getContext("webgl", $) || q.getContext("experimental-webgl", $);
            }(E);
            if (!O)
              return !1;
            var k = O.createShader(O.VERTEX_SHADER);
            return !(!k || O.isContextLost()) && (O.shaderSource(k, "void main() {}"), O.compileShader(k), O.getShaderParameter(k, O.COMPILE_STATUS) === !0);
          }(w)), d[w] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          var w;
        }
        u.exports ? u.exports = h : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = h, window.mapboxgl.notSupportedReason = c);
        var d = {};
        h.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };
      }), g = { create: function(u, h, c) {
        var d = o.window.document.createElement(u);
        return h !== void 0 && (d.className = h), c && c.appendChild(d), d;
      }, createNS: function(u, h) {
        return o.window.document.createElementNS(u, h);
      } }, b = o.window.document && o.window.document.documentElement.style;
      function T(u) {
        if (!b)
          return u[0];
        for (var h = 0; h < u.length; h++)
          if (u[h] in b)
            return u[h];
        return u[0];
      }
      var M, I = T(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);
      g.disableDrag = function() {
        b && I && (M = b[I], b[I] = "none");
      }, g.enableDrag = function() {
        b && I && (b[I] = M);
      };
      var A = T(["transform", "WebkitTransform"]);
      g.setTransform = function(u, h) {
        u.style[A] = h;
      };
      var z = !1;
      try {
        var V = Object.defineProperty({}, "passive", { get: function() {
          z = !0;
        } });
        o.window.addEventListener("test", V, V), o.window.removeEventListener("test", V, V);
      } catch {
        z = !1;
      }
      g.addEventListener = function(u, h, c, d) {
        d === void 0 && (d = {}), u.addEventListener(h, c, "passive" in d && z ? d : d.capture);
      }, g.removeEventListener = function(u, h, c, d) {
        d === void 0 && (d = {}), u.removeEventListener(h, c, "passive" in d && z ? d : d.capture);
      };
      var Z = function(u) {
        u.preventDefault(), u.stopPropagation(), o.window.removeEventListener("click", Z, !0);
      };
      function X(u) {
        var h = u.userImage;
        return !!(h && h.render && h.render()) && (u.data.replace(new Uint8Array(h.data.buffer)), !0);
      }
      g.suppressClick = function() {
        o.window.addEventListener("click", Z, !0), o.window.setTimeout(function() {
          o.window.removeEventListener("click", Z, !0);
        }, 0);
      }, g.mousePos = function(u, h) {
        var c = u.getBoundingClientRect();
        return new o.Point(h.clientX - c.left - u.clientLeft, h.clientY - c.top - u.clientTop);
      }, g.touchPos = function(u, h) {
        for (var c = u.getBoundingClientRect(), d = [], _ = 0; _ < h.length; _++)
          d.push(new o.Point(h[_].clientX - c.left - u.clientLeft, h[_].clientY - c.top - u.clientTop));
        return d;
      }, g.mouseButton = function(u) {
        return o.window.InstallTrigger !== void 0 && u.button === 2 && u.ctrlKey && o.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : u.button;
      }, g.remove = function(u) {
        u.parentNode && u.parentNode.removeChild(u);
      };
      var Y = function(u) {
        function h() {
          u.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.RGBAImage({ width: 1, height: 1 }), this.dirty = !0;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.isLoaded = function() {
          return this.loaded;
        }, h.prototype.setLoaded = function(c) {
          if (this.loaded !== c && (this.loaded = c, c)) {
            for (var d = 0, _ = this.requestors; d < _.length; d += 1) {
              var w = _[d];
              this._notify(w.ids, w.callback);
            }
            this.requestors = [];
          }
        }, h.prototype.getImage = function(c) {
          return this.images[c];
        }, h.prototype.addImage = function(c, d) {
          this._validate(c, d) && (this.images[c] = d);
        }, h.prototype._validate = function(c, d) {
          var _ = !0;
          return this._validateStretch(d.stretchX, d.data && d.data.width) || (this.fire(new o.ErrorEvent(new Error('Image "' + c + '" has invalid "stretchX" value'))), _ = !1), this._validateStretch(d.stretchY, d.data && d.data.height) || (this.fire(new o.ErrorEvent(new Error('Image "' + c + '" has invalid "stretchY" value'))), _ = !1), this._validateContent(d.content, d) || (this.fire(new o.ErrorEvent(new Error('Image "' + c + '" has invalid "content" value'))), _ = !1), _;
        }, h.prototype._validateStretch = function(c, d) {
          if (!c)
            return !0;
          for (var _ = 0, w = 0, E = c; w < E.length; w += 1) {
            var O = E[w];
            if (O[0] < _ || O[1] < O[0] || d < O[1])
              return !1;
            _ = O[1];
          }
          return !0;
        }, h.prototype._validateContent = function(c, d) {
          return !(c && (c.length !== 4 || c[0] < 0 || d.data.width < c[0] || c[1] < 0 || d.data.height < c[1] || c[2] < 0 || d.data.width < c[2] || c[3] < 0 || d.data.height < c[3] || c[2] < c[0] || c[3] < c[1]));
        }, h.prototype.updateImage = function(c, d) {
          d.version = this.images[c].version + 1, this.images[c] = d, this.updatedImages[c] = !0;
        }, h.prototype.removeImage = function(c) {
          var d = this.images[c];
          delete this.images[c], delete this.patterns[c], d.userImage && d.userImage.onRemove && d.userImage.onRemove();
        }, h.prototype.listImages = function() {
          return Object.keys(this.images);
        }, h.prototype.getImages = function(c, d) {
          var _ = !0;
          if (!this.isLoaded())
            for (var w = 0, E = c; w < E.length; w += 1)
              this.images[E[w]] || (_ = !1);
          this.isLoaded() || _ ? this._notify(c, d) : this.requestors.push({ ids: c, callback: d });
        }, h.prototype._notify = function(c, d) {
          for (var _ = {}, w = 0, E = c; w < E.length; w += 1) {
            var O = E[w];
            this.images[O] || this.fire(new o.Event("styleimagemissing", { id: O }));
            var k = this.images[O];
            k ? _[O] = { data: k.data.clone(), pixelRatio: k.pixelRatio, sdf: k.sdf, version: k.version, stretchX: k.stretchX, stretchY: k.stretchY, content: k.content, hasRenderCallback: Boolean(k.userImage && k.userImage.render) } : o.warnOnce('Image "' + O + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');
          }
          d(null, _);
        }, h.prototype.getPixelSize = function() {
          var c = this.atlasImage;
          return { width: c.width, height: c.height };
        }, h.prototype.getPattern = function(c) {
          var d = this.patterns[c], _ = this.getImage(c);
          if (!_)
            return null;
          if (d && d.position.version === _.version)
            return d.position;
          if (d)
            d.position.version = _.version;
          else {
            var w = { w: _.data.width + 2, h: _.data.height + 2, x: 0, y: 0 }, E = new o.ImagePosition(w, _);
            this.patterns[c] = { bin: w, position: E };
          }
          return this._updatePatternAtlas(), this.patterns[c].position;
        }, h.prototype.bind = function(c) {
          var d = c.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new o.Texture(c, this.atlasImage, d.RGBA), this.atlasTexture.bind(d.LINEAR, d.CLAMP_TO_EDGE);
        }, h.prototype._updatePatternAtlas = function() {
          var c = [];
          for (var d in this.patterns)
            c.push(this.patterns[d].bin);
          var _ = o.potpack(c), w = _.w, E = _.h, O = this.atlasImage;
          for (var k in O.resize({ width: w || 1, height: E || 1 }), this.patterns) {
            var R = this.patterns[k].bin, q = R.x + 1, $ = R.y + 1, W = this.images[k].data, ne = W.width, re = W.height;
            o.RGBAImage.copy(W, O, { x: 0, y: 0 }, { x: q, y: $ }, { width: ne, height: re }), o.RGBAImage.copy(W, O, { x: 0, y: re - 1 }, { x: q, y: $ - 1 }, { width: ne, height: 1 }), o.RGBAImage.copy(W, O, { x: 0, y: 0 }, { x: q, y: $ + re }, { width: ne, height: 1 }), o.RGBAImage.copy(W, O, { x: ne - 1, y: 0 }, { x: q - 1, y: $ }, { width: 1, height: re }), o.RGBAImage.copy(W, O, { x: 0, y: 0 }, { x: q + ne, y: $ }, { width: 1, height: re });
          }
          this.dirty = !0;
        }, h.prototype.beginFrame = function() {
          this.callbackDispatchedThisFrame = {};
        }, h.prototype.dispatchRenderCallbacks = function(c) {
          for (var d = 0, _ = c; d < _.length; d += 1) {
            var w = _[d];
            if (!this.callbackDispatchedThisFrame[w]) {
              this.callbackDispatchedThisFrame[w] = !0;
              var E = this.images[w];
              X(E) && this.updateImage(w, E);
            }
          }
        }, h;
      }(o.Evented), de = Be, ye = Be, Ie = 1e20;
      function Be(u, h, c, d, _, w) {
        this.fontSize = u || 24, this.buffer = h === void 0 ? 3 : h, this.cutoff = d || 0.25, this.fontFamily = _ || "sans-serif", this.fontWeight = w || "normal", this.radius = c || 8;
        var E = this.size = this.fontSize + 2 * this.buffer;
        this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = E, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(E * E), this.gridInner = new Float64Array(E * E), this.f = new Float64Array(E), this.d = new Float64Array(E), this.z = new Float64Array(E + 1), this.v = new Int16Array(E), this.middle = Math.round(E / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
      }
      function De(u, h, c, d, _, w, E) {
        for (var O = 0; O < h; O++) {
          for (var k = 0; k < c; k++)
            d[k] = u[k * h + O];
          for (Re(d, _, w, E, c), k = 0; k < c; k++)
            u[k * h + O] = _[k];
        }
        for (k = 0; k < c; k++) {
          for (O = 0; O < h; O++)
            d[O] = u[k * h + O];
          for (Re(d, _, w, E, h), O = 0; O < h; O++)
            u[k * h + O] = Math.sqrt(_[O]);
        }
      }
      function Re(u, h, c, d, _) {
        c[0] = 0, d[0] = -Ie, d[1] = +Ie;
        for (var w = 1, E = 0; w < _; w++) {
          for (var O = (u[w] + w * w - (u[c[E]] + c[E] * c[E])) / (2 * w - 2 * c[E]); O <= d[E]; )
            E--, O = (u[w] + w * w - (u[c[E]] + c[E] * c[E])) / (2 * w - 2 * c[E]);
          c[++E] = w, d[E] = O, d[E + 1] = +Ie;
        }
        for (w = 0, E = 0; w < _; w++) {
          for (; d[E + 1] < w; )
            E++;
          h[w] = (w - c[E]) * (w - c[E]) + u[c[E]];
        }
      }
      Be.prototype.draw = function(u) {
        this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(u, this.buffer, this.middle);
        for (var h = this.ctx.getImageData(0, 0, this.size, this.size), c = new Uint8ClampedArray(this.size * this.size), d = 0; d < this.size * this.size; d++) {
          var _ = h.data[4 * d + 3] / 255;
          this.gridOuter[d] = _ === 1 ? 0 : _ === 0 ? Ie : Math.pow(Math.max(0, 0.5 - _), 2), this.gridInner[d] = _ === 1 ? Ie : _ === 0 ? 0 : Math.pow(Math.max(0, _ - 0.5), 2);
        }
        for (De(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), De(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), d = 0; d < this.size * this.size; d++)
          c[d] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[d] - this.gridInner[d]) / this.radius + this.cutoff))));
        return c;
      }, de.default = ye;
      var Ee = function(u, h) {
        this.requestManager = u, this.localIdeographFontFamily = h, this.entries = {};
      };
      Ee.prototype.setURL = function(u) {
        this.url = u;
      }, Ee.prototype.getGlyphs = function(u, h) {
        var c = this, d = [];
        for (var _ in u)
          for (var w = 0, E = u[_]; w < E.length; w += 1)
            d.push({ stack: _, id: E[w] });
        o.asyncAll(d, function(O, k) {
          var R = O.stack, q = O.id, $ = c.entries[R];
          $ || ($ = c.entries[R] = { glyphs: {}, requests: {}, ranges: {} });
          var W = $.glyphs[q];
          if (W === void 0) {
            if (W = c._tinySDF($, R, q))
              return $.glyphs[q] = W, void k(null, { stack: R, id: q, glyph: W });
            var ne = Math.floor(q / 256);
            if (256 * ne > 65535)
              k(new Error("glyphs > 65535 not supported"));
            else if ($.ranges[ne])
              k(null, { stack: R, id: q, glyph: W });
            else {
              var re = $.requests[ne];
              re || (re = $.requests[ne] = [], Ee.loadGlyphRange(R, ne, c.url, c.requestManager, function(se, J) {
                if (J) {
                  for (var ae in J)
                    c._doesCharSupportLocalGlyph(+ae) || ($.glyphs[+ae] = J[+ae]);
                  $.ranges[ne] = !0;
                }
                for (var pe = 0, _e = re; pe < _e.length; pe += 1)
                  (0, _e[pe])(se, J);
                delete $.requests[ne];
              })), re.push(function(se, J) {
                se ? k(se) : J && k(null, { stack: R, id: q, glyph: J[q] || null });
              });
            }
          } else
            k(null, { stack: R, id: q, glyph: W });
        }, function(O, k) {
          if (O)
            h(O);
          else if (k) {
            for (var R = {}, q = 0, $ = k; q < $.length; q += 1) {
              var W = $[q], ne = W.stack, re = W.id, se = W.glyph;
              (R[ne] || (R[ne] = {}))[re] = se && { id: se.id, bitmap: se.bitmap.clone(), metrics: se.metrics };
            }
            h(null, R);
          }
        });
      }, Ee.prototype._doesCharSupportLocalGlyph = function(u) {
        return !!this.localIdeographFontFamily && (o.isChar["CJK Unified Ideographs"](u) || o.isChar["Hangul Syllables"](u) || o.isChar.Hiragana(u) || o.isChar.Katakana(u));
      }, Ee.prototype._tinySDF = function(u, h, c) {
        var d = this.localIdeographFontFamily;
        if (d && this._doesCharSupportLocalGlyph(c)) {
          var _ = u.tinySDF;
          if (!_) {
            var w = "400";
            /bold/i.test(h) ? w = "900" : /medium/i.test(h) ? w = "500" : /light/i.test(h) && (w = "200"), _ = u.tinySDF = new Ee.TinySDF(24, 3, 8, 0.25, d, w);
          }
          return { id: c, bitmap: new o.AlphaImage({ width: 30, height: 30 }, _.draw(String.fromCharCode(c))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } };
        }
      }, Ee.loadGlyphRange = function(u, h, c, d, _) {
        var w = 256 * h, E = w + 255, O = d.transformRequest(d.normalizeGlyphsURL(c).replace("{fontstack}", u).replace("{range}", w + "-" + E), o.ResourceType.Glyphs);
        o.getArrayBuffer(O, function(k, R) {
          if (k)
            _(k);
          else if (R) {
            for (var q = {}, $ = 0, W = o.parseGlyphPBF(R); $ < W.length; $ += 1) {
              var ne = W[$];
              q[ne.id] = ne;
            }
            _(null, q);
          }
        });
      }, Ee.TinySDF = de;
      var ze = function() {
        this.specification = o.styleSpec.light.position;
      };
      ze.prototype.possiblyEvaluate = function(u, h) {
        return o.sphericalToCartesian(u.expression.evaluate(h));
      }, ze.prototype.interpolate = function(u, h, c) {
        return { x: o.number(u.x, h.x, c), y: o.number(u.y, h.y, c), z: o.number(u.z, h.z, c) };
      };
      var rt = new o.Properties({ anchor: new o.DataConstantProperty(o.styleSpec.light.anchor), position: new ze(), color: new o.DataConstantProperty(o.styleSpec.light.color), intensity: new o.DataConstantProperty(o.styleSpec.light.intensity) }), Ze = function(u) {
        function h(c) {
          u.call(this), this._transitionable = new o.Transitionable(rt), this.setLight(c), this._transitioning = this._transitionable.untransitioned();
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getLight = function() {
          return this._transitionable.serialize();
        }, h.prototype.setLight = function(c, d) {
          if (d === void 0 && (d = {}), !this._validate(o.validateLight, c, d))
            for (var _ in c) {
              var w = c[_];
              o.endsWith(_, "-transition") ? this._transitionable.setTransition(_.slice(0, -11), w) : this._transitionable.setValue(_, w);
            }
        }, h.prototype.updateTransitions = function(c) {
          this._transitioning = this._transitionable.transitioned(c, this._transitioning);
        }, h.prototype.hasTransition = function() {
          return this._transitioning.hasTransition();
        }, h.prototype.recalculate = function(c) {
          this.properties = this._transitioning.possiblyEvaluate(c);
        }, h.prototype._validate = function(c, d, _) {
          return (!_ || _.validate !== !1) && o.emitValidationErrors(this, c.call(o.validateStyle, o.extend({ value: d, style: { glyphs: !0, sprite: !0 }, styleSpec: o.styleSpec })));
        }, h;
      }(o.Evented), yt = function(u, h) {
        this.width = u, this.height = h, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
      };
      yt.prototype.getDash = function(u, h) {
        var c = u.join(",") + String(h);
        return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(u, h)), this.dashEntry[c];
      }, yt.prototype.getDashRanges = function(u, h, c) {
        var d = [], _ = u.length % 2 == 1 ? -u[u.length - 1] * c : 0, w = u[0] * c, E = !0;
        d.push({ left: _, right: w, isDash: E, zeroLength: u[0] === 0 });
        for (var O = u[0], k = 1; k < u.length; k++) {
          var R = u[k];
          d.push({ left: _ = O * c, right: w = (O += R) * c, isDash: E = !E, zeroLength: R === 0 });
        }
        return d;
      }, yt.prototype.addRoundDash = function(u, h, c) {
        for (var d = h / 2, _ = -c; _ <= c; _++)
          for (var w = this.width * (this.nextRow + c + _), E = 0, O = u[E], k = 0; k < this.width; k++) {
            k / O.right > 1 && (O = u[++E]);
            var R = Math.abs(k - O.left), q = Math.abs(k - O.right), $ = Math.min(R, q), W = void 0, ne = _ / c * (d + 1);
            if (O.isDash) {
              var re = d - Math.abs(ne);
              W = Math.sqrt($ * $ + re * re);
            } else
              W = d - Math.sqrt($ * $ + ne * ne);
            this.data[w + k] = Math.max(0, Math.min(255, W + 128));
          }
      }, yt.prototype.addRegularDash = function(u) {
        for (var h = u.length - 1; h >= 0; --h) {
          var c = u[h], d = u[h + 1];
          c.zeroLength ? u.splice(h, 1) : d && d.isDash === c.isDash && (d.left = c.left, u.splice(h, 1));
        }
        var _ = u[0], w = u[u.length - 1];
        _.isDash === w.isDash && (_.left = w.left - this.width, w.right = _.right + this.width);
        for (var E = this.width * this.nextRow, O = 0, k = u[O], R = 0; R < this.width; R++) {
          R / k.right > 1 && (k = u[++O]);
          var q = Math.abs(R - k.left), $ = Math.abs(R - k.right), W = Math.min(q, $);
          this.data[E + R] = Math.max(0, Math.min(255, (k.isDash ? W : -W) + 128));
        }
      }, yt.prototype.addDash = function(u, h) {
        var c = h ? 7 : 0, d = 2 * c + 1;
        if (this.nextRow + d > this.height)
          return o.warnOnce("LineAtlas out of space"), null;
        for (var _ = 0, w = 0; w < u.length; w++)
          _ += u[w];
        if (_ !== 0) {
          var E = this.width / _, O = this.getDashRanges(u, this.width, E);
          h ? this.addRoundDash(O, E, c) : this.addRegularDash(O);
        }
        var k = { y: (this.nextRow + c + 0.5) / this.height, height: 2 * c / this.height, width: _ };
        return this.nextRow += d, this.dirty = !0, k;
      }, yt.prototype.bind = function(u) {
        var h = u.gl;
        this.texture ? (h.bindTexture(h.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, h.texSubImage2D(h.TEXTURE_2D, 0, 0, 0, this.width, this.height, h.ALPHA, h.UNSIGNED_BYTE, this.data))) : (this.texture = h.createTexture(), h.bindTexture(h.TEXTURE_2D, this.texture), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR), h.texImage2D(h.TEXTURE_2D, 0, h.ALPHA, this.width, this.height, 0, h.ALPHA, h.UNSIGNED_BYTE, this.data));
      };
      var xe = function u(h, c) {
        this.workerPool = h, this.actors = [], this.currentActor = 0, this.id = o.uniqueId();
        for (var d = this.workerPool.acquire(this.id), _ = 0; _ < d.length; _++) {
          var w = new u.Actor(d[_], c, this.id);
          w.name = "Worker " + _, this.actors.push(w);
        }
      };
      function Ke(u, h, c) {
        var d = function(_, w) {
          if (_)
            return c(_);
          if (w) {
            var E = o.pick(o.extend(w, u), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            w.vector_layers && (E.vectorLayers = w.vector_layers, E.vectorLayerIds = E.vectorLayers.map(function(O) {
              return O.id;
            })), E.tiles = h.canonicalizeTileset(E, u.url), c(null, E);
          }
        };
        return u.url ? o.getJSON(h.transformRequest(h.normalizeSourceURL(u.url), o.ResourceType.Source), d) : o.browser.frame(function() {
          return d(null, u);
        });
      }
      xe.prototype.broadcast = function(u, h, c) {
        o.asyncAll(this.actors, function(d, _) {
          d.send(u, h, _);
        }, c = c || function() {
        });
      }, xe.prototype.getActor = function() {
        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
      }, xe.prototype.remove = function() {
        this.actors.forEach(function(u) {
          u.remove();
        }), this.actors = [], this.workerPool.release(this.id);
      }, xe.Actor = o.Actor;
      var ct = function(u, h, c) {
        this.bounds = o.LngLatBounds.convert(this.validateBounds(u)), this.minzoom = h || 0, this.maxzoom = c || 24;
      };
      ct.prototype.validateBounds = function(u) {
        return Array.isArray(u) && u.length === 4 ? [Math.max(-180, u[0]), Math.max(-90, u[1]), Math.min(180, u[2]), Math.min(90, u[3])] : [-180, -90, 180, 90];
      }, ct.prototype.contains = function(u) {
        var h = Math.pow(2, u.z), c = Math.floor(o.mercatorXfromLng(this.bounds.getWest()) * h), d = Math.floor(o.mercatorYfromLat(this.bounds.getNorth()) * h), _ = Math.ceil(o.mercatorXfromLng(this.bounds.getEast()) * h), w = Math.ceil(o.mercatorYfromLat(this.bounds.getSouth()) * h);
        return u.x >= c && u.x < _ && u.y >= d && u.y < w;
      };
      var vt = function(u) {
        function h(c, d, _, w) {
          if (u.call(this), this.id = c, this.dispatcher = _, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.extend(this, o.pick(d, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.extend({ type: "vector" }, d), this._collectResourceTiming = d.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(w);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function() {
          var c = this;
          this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = Ke(this._options, this.map._requestManager, function(d, _) {
            c._tileJSONRequest = null, c._loaded = !0, d ? c.fire(new o.ErrorEvent(d)) : _ && (o.extend(c, _), _.bounds && (c.tileBounds = new ct(_.bounds, c.minzoom, c.maxzoom)), o.postTurnstileEvent(_.tiles, c.map._requestManager._customAccessToken), o.postMapLoadEvent(_.tiles, c.map._getMapId(), c.map._requestManager._skuToken, c.map._requestManager._customAccessToken), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }, h.prototype.loaded = function() {
          return this._loaded;
        }, h.prototype.hasTile = function(c) {
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }, h.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, h.prototype.setSourceProperty = function(c) {
          this._tileJSONRequest && this._tileJSONRequest.cancel(), c(), this.map.style.sourceCaches[this.id].clearTiles(), this.load();
        }, h.prototype.setTiles = function(c) {
          var d = this;
          return this.setSourceProperty(function() {
            d._options.tiles = c;
          }), this;
        }, h.prototype.setUrl = function(c) {
          var d = this;
          return this.setSourceProperty(function() {
            d.url = c, d._options.url = c;
          }), this;
        }, h.prototype.onRemove = function() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }, h.prototype.serialize = function() {
          return o.extend({}, this._options);
        }, h.prototype.loadTile = function(c, d) {
          var _ = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme)), w = { request: this.map._requestManager.transformRequest(_, o.ResourceType.Tile), uid: c.uid, tileID: c.tileID, zoom: c.tileID.overscaledZ, tileSize: this.tileSize * c.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: o.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
          function E(O, k) {
            return delete c.request, c.aborted ? d(null) : O && O.status !== 404 ? d(O) : (k && k.resourceTiming && (c.resourceTiming = k.resourceTiming), this.map._refreshExpiredTiles && k && c.setExpiryData(k), c.loadVectorData(k, this.map.painter), o.cacheEntryPossiblyAdded(this.dispatcher), d(null), void (c.reloadCallback && (this.loadTile(c, c.reloadCallback), c.reloadCallback = null)));
          }
          w.request.collectResourceTiming = this._collectResourceTiming, c.actor && c.state !== "expired" ? c.state === "loading" ? c.reloadCallback = d : c.request = c.actor.send("reloadTile", w, E.bind(this)) : (c.actor = this.dispatcher.getActor(), c.request = c.actor.send("loadTile", w, E.bind(this)));
        }, h.prototype.abortTile = function(c) {
          c.request && (c.request.cancel(), delete c.request), c.actor && c.actor.send("abortTile", { uid: c.uid, type: this.type, source: this.id }, void 0);
        }, h.prototype.unloadTile = function(c) {
          c.unloadVectorData(), c.actor && c.actor.send("removeTile", { uid: c.uid, type: this.type, source: this.id }, void 0);
        }, h.prototype.hasTransition = function() {
          return !1;
        }, h;
      }(o.Evented), Pt = function(u) {
        function h(c, d, _, w) {
          u.call(this), this.id = c, this.dispatcher = _, this.setEventedParent(w), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.extend({ type: "raster" }, d), o.extend(this, o.pick(d, ["url", "scheme", "tileSize"]));
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function() {
          var c = this;
          this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = Ke(this._options, this.map._requestManager, function(d, _) {
            c._tileJSONRequest = null, c._loaded = !0, d ? c.fire(new o.ErrorEvent(d)) : _ && (o.extend(c, _), _.bounds && (c.tileBounds = new ct(_.bounds, c.minzoom, c.maxzoom)), o.postTurnstileEvent(_.tiles), o.postMapLoadEvent(_.tiles, c.map._getMapId(), c.map._requestManager._skuToken), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }, h.prototype.loaded = function() {
          return this._loaded;
        }, h.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, h.prototype.onRemove = function() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }, h.prototype.serialize = function() {
          return o.extend({}, this._options);
        }, h.prototype.hasTile = function(c) {
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }, h.prototype.loadTile = function(c, d) {
          var _ = this, w = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
          c.request = o.getImage(this.map._requestManager.transformRequest(w, o.ResourceType.Tile), function(E, O) {
            if (delete c.request, c.aborted)
              c.state = "unloaded", d(null);
            else if (E)
              c.state = "errored", d(E);
            else if (O) {
              _.map._refreshExpiredTiles && c.setExpiryData(O), delete O.cacheControl, delete O.expires;
              var k = _.map.painter.context, R = k.gl;
              c.texture = _.map.painter.getTileTexture(O.width), c.texture ? c.texture.update(O, { useMipmap: !0 }) : (c.texture = new o.Texture(k, O, R.RGBA, { useMipmap: !0 }), c.texture.bind(R.LINEAR, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), k.extTextureFilterAnisotropic && R.texParameterf(R.TEXTURE_2D, k.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, k.extTextureFilterAnisotropicMax)), c.state = "loaded", o.cacheEntryPossiblyAdded(_.dispatcher), d(null);
            }
          });
        }, h.prototype.abortTile = function(c, d) {
          c.request && (c.request.cancel(), delete c.request), d();
        }, h.prototype.unloadTile = function(c, d) {
          c.texture && this.map.painter.saveTileTexture(c.texture), d();
        }, h.prototype.hasTransition = function() {
          return !1;
        }, h;
      }(o.Evented), tr = function(u) {
        function h(c, d, _, w) {
          u.call(this, c, d, _, w), this.type = "raster-dem", this.maxzoom = 22, this._options = o.extend({ type: "raster-dem" }, d), this.encoding = d.encoding || "mapbox";
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.serialize = function() {
          return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
        }, h.prototype.loadTile = function(c, d) {
          var _ = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
          function w(E, O) {
            E && (c.state = "errored", d(E)), O && (c.dem = O, c.needsHillshadePrepare = !0, c.state = "loaded", d(null));
          }
          c.request = o.getImage(this.map._requestManager.transformRequest(_, o.ResourceType.Tile), function(E, O) {
            if (delete c.request, c.aborted)
              c.state = "unloaded", d(null);
            else if (E)
              c.state = "errored", d(E);
            else if (O) {
              this.map._refreshExpiredTiles && c.setExpiryData(O), delete O.cacheControl, delete O.expires;
              var k = o.window.ImageBitmap && O instanceof o.window.ImageBitmap && o.offscreenCanvasSupported() ? O : o.browser.getImageData(O, 1), R = { uid: c.uid, coord: c.tileID, source: this.id, rawImageData: k, encoding: this.encoding };
              c.actor && c.state !== "expired" || (c.actor = this.dispatcher.getActor(), c.actor.send("loadDEMTile", R, w.bind(this)));
            }
          }.bind(this)), c.neighboringTiles = this._getNeighboringTiles(c.tileID);
        }, h.prototype._getNeighboringTiles = function(c) {
          var d = c.canonical, _ = Math.pow(2, d.z), w = (d.x - 1 + _) % _, E = d.x === 0 ? c.wrap - 1 : c.wrap, O = (d.x + 1 + _) % _, k = d.x + 1 === _ ? c.wrap + 1 : c.wrap, R = {};
          return R[new o.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y).key] = { backfilled: !1 }, d.y > 0 && (R[new o.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y - 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, c.wrap, d.z, d.x, d.y - 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y - 1).key] = { backfilled: !1 }), d.y + 1 < _ && (R[new o.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y + 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, c.wrap, d.z, d.x, d.y + 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y + 1).key] = { backfilled: !1 }), R;
        }, h.prototype.unloadTile = function(c) {
          c.demTexture && this.map.painter.saveTileTexture(c.demTexture), c.fbo && (c.fbo.destroy(), delete c.fbo), c.dem && delete c.dem, delete c.neighboringTiles, c.state = "unloaded", c.actor && c.actor.send("removeDEMTile", { uid: c.uid, source: this.id });
        }, h;
      }(Pt), Pn = function(u) {
        function h(c, d, _, w) {
          u.call(this), this.id = c, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._loaded = !1, this.actor = _.getActor(), this.setEventedParent(w), this._data = d.data, this._options = o.extend({}, d), this._collectResourceTiming = d.collectResourceTiming, this._resourceTiming = [], d.maxzoom !== void 0 && (this.maxzoom = d.maxzoom), d.type && (this.type = d.type), d.attribution && (this.attribution = d.attribution), this.promoteId = d.promoteId;
          var E = o.EXTENT / this.tileSize;
          this.workerOptions = o.extend({ source: this.id, cluster: d.cluster || !1, geojsonVtOptions: { buffer: (d.buffer !== void 0 ? d.buffer : 128) * E, tolerance: (d.tolerance !== void 0 ? d.tolerance : 0.375) * E, extent: o.EXTENT, maxZoom: this.maxzoom, lineMetrics: d.lineMetrics || !1, generateId: d.generateId || !1 }, superclusterOptions: { maxZoom: d.clusterMaxZoom !== void 0 ? Math.min(d.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, minPoints: Math.max(2, d.clusterMinPoints || 2), extent: o.EXTENT, radius: (d.clusterRadius || 50) * E, log: !1, generateId: d.generateId || !1 }, clusterProperties: d.clusterProperties, filter: d.filter }, d.workerOptions);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function() {
          var c = this;
          this.fire(new o.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(d) {
            if (d)
              c.fire(new o.ErrorEvent(d));
            else {
              var _ = { dataType: "source", sourceDataType: "metadata" };
              c._collectResourceTiming && c._resourceTiming && c._resourceTiming.length > 0 && (_.resourceTiming = c._resourceTiming, c._resourceTiming = []), c.fire(new o.Event("data", _));
            }
          });
        }, h.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, h.prototype.setData = function(c) {
          var d = this;
          return this._data = c, this.fire(new o.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(_) {
            if (_)
              d.fire(new o.ErrorEvent(_));
            else {
              var w = { dataType: "source", sourceDataType: "content" };
              d._collectResourceTiming && d._resourceTiming && d._resourceTiming.length > 0 && (w.resourceTiming = d._resourceTiming, d._resourceTiming = []), d.fire(new o.Event("data", w));
            }
          }), this;
        }, h.prototype.getClusterExpansionZoom = function(c, d) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: c, source: this.id }, d), this;
        }, h.prototype.getClusterChildren = function(c, d) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: c, source: this.id }, d), this;
        }, h.prototype.getClusterLeaves = function(c, d, _, w) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: c, limit: d, offset: _ }, w), this;
        }, h.prototype._updateWorkerData = function(c) {
          var d = this;
          this._loaded = !1;
          var _ = o.extend({}, this.workerOptions), w = this._data;
          typeof w == "string" ? (_.request = this.map._requestManager.transformRequest(o.browser.resolveURL(w), o.ResourceType.Source), _.request.collectResourceTiming = this._collectResourceTiming) : _.data = JSON.stringify(w), this.actor.send(this.type + ".loadData", _, function(E, O) {
            d._removed || O && O.abandoned || (d._loaded = !0, O && O.resourceTiming && O.resourceTiming[d.id] && (d._resourceTiming = O.resourceTiming[d.id].slice(0)), d.actor.send(d.type + ".coalesce", { source: _.source }, null), c(E));
          });
        }, h.prototype.loaded = function() {
          return this._loaded;
        }, h.prototype.loadTile = function(c, d) {
          var _ = this, w = c.actor ? "reloadTile" : "loadTile";
          c.actor = this.actor, c.request = this.actor.send(w, { type: this.type, uid: c.uid, tileID: c.tileID, zoom: c.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: o.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, function(E, O) {
            return delete c.request, c.unloadVectorData(), c.aborted ? d(null) : E ? d(E) : (c.loadVectorData(O, _.map.painter, w === "reloadTile"), d(null));
          });
        }, h.prototype.abortTile = function(c) {
          c.request && (c.request.cancel(), delete c.request), c.aborted = !0;
        }, h.prototype.unloadTile = function(c) {
          c.unloadVectorData(), this.actor.send("removeTile", { uid: c.uid, type: this.type, source: this.id });
        }, h.prototype.onRemove = function() {
          this._removed = !0, this.actor.send("removeSource", { type: this.type, source: this.id });
        }, h.prototype.serialize = function() {
          return o.extend({}, this._options, { type: this.type, data: this._data });
        }, h.prototype.hasTransition = function() {
          return !1;
        }, h;
      }(o.Evented), Dr = o.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]), hr = function(u) {
        function h(c, d, _, w) {
          u.call(this), this.id = c, this.dispatcher = _, this.coordinates = d.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(w), this.options = d;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function(c, d) {
          var _ = this;
          this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this.url = this.options.url, o.getImage(this.map._requestManager.transformRequest(this.url, o.ResourceType.Image), function(w, E) {
            _._loaded = !0, w ? _.fire(new o.ErrorEvent(w)) : E && (_.image = E, c && (_.coordinates = c), d && d(), _._finishLoading());
          });
        }, h.prototype.loaded = function() {
          return this._loaded;
        }, h.prototype.updateImage = function(c) {
          var d = this;
          return this.image && c.url ? (this.options.url = c.url, this.load(c.coordinates, function() {
            d.texture = null;
          }), this) : this;
        }, h.prototype._finishLoading = function() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })));
        }, h.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, h.prototype.setCoordinates = function(c) {
          var d = this;
          this.coordinates = c;
          var _ = c.map(o.MercatorCoordinate.fromLngLat);
          this.tileID = function(E) {
            for (var O = 1 / 0, k = 1 / 0, R = -1 / 0, q = -1 / 0, $ = 0, W = E; $ < W.length; $ += 1) {
              var ne = W[$];
              O = Math.min(O, ne.x), k = Math.min(k, ne.y), R = Math.max(R, ne.x), q = Math.max(q, ne.y);
            }
            var re = Math.max(R - O, q - k), se = Math.max(0, Math.floor(-Math.log(re) / Math.LN2)), J = Math.pow(2, se);
            return new o.CanonicalTileID(se, Math.floor((O + R) / 2 * J), Math.floor((k + q) / 2 * J));
          }(_), this.minzoom = this.maxzoom = this.tileID.z;
          var w = _.map(function(E) {
            return d.tileID.getTilePoint(E)._round();
          });
          return this._boundsArray = new o.StructArrayLayout4i8(), this._boundsArray.emplaceBack(w[0].x, w[0].y, 0, 0), this._boundsArray.emplaceBack(w[1].x, w[1].y, o.EXTENT, 0), this._boundsArray.emplaceBack(w[3].x, w[3].y, 0, o.EXTENT), this._boundsArray.emplaceBack(w[2].x, w[2].y, o.EXTENT, o.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })), this;
        }, h.prototype.prepare = function() {
          if (Object.keys(this.tiles).length !== 0 && this.image) {
            var c = this.map.painter.context, d = c.gl;
            for (var _ in this.boundsBuffer || (this.boundsBuffer = c.createVertexBuffer(this._boundsArray, Dr.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new o.Texture(c, this.image, d.RGBA), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE)), this.tiles) {
              var w = this.tiles[_];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture);
            }
          }
        }, h.prototype.loadTile = function(c, d) {
          this.tileID && this.tileID.equals(c.tileID.canonical) ? (this.tiles[String(c.tileID.wrap)] = c, c.buckets = {}, d(null)) : (c.state = "errored", d(null));
        }, h.prototype.serialize = function() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }, h.prototype.hasTransition = function() {
          return !1;
        }, h;
      }(o.Evented), Zn = function(u) {
        function h(c, d, _, w) {
          u.call(this, c, d, _, w), this.roundZoom = !0, this.type = "video", this.options = d;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function() {
          var c = this;
          this._loaded = !1;
          var d = this.options;
          this.urls = [];
          for (var _ = 0, w = d.urls; _ < w.length; _ += 1)
            this.urls.push(this.map._requestManager.transformRequest(w[_], o.ResourceType.Source).url);
          o.getVideo(this.urls, function(E, O) {
            c._loaded = !0, E ? c.fire(new o.ErrorEvent(E)) : O && (c.video = O, c.video.loop = !0, c.video.setAttribute("playsinline", ""), c.video.addEventListener("playing", function() {
              c.map.triggerRepaint();
            }), c.map && c.video.play(), c._finishLoading());
          });
        }, h.prototype.pause = function() {
          this.video && this.video.pause();
        }, h.prototype.play = function() {
          this.video && this.video.play();
        }, h.prototype.seek = function(c) {
          if (this.video) {
            var d = this.video.seekable;
            c < d.start(0) || c > d.end(0) ? this.fire(new o.ErrorEvent(new o.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + d.start(0) + " and " + d.end(0) + "-second mark."))) : this.video.currentTime = c;
          }
        }, h.prototype.getVideo = function() {
          return this.video;
        }, h.prototype.onAdd = function(c) {
          this.map || (this.map = c, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }, h.prototype.prepare = function() {
          if (!(Object.keys(this.tiles).length === 0 || this.video.readyState < 2)) {
            var c = this.map.painter.context, d = c.gl;
            for (var _ in this.boundsBuffer || (this.boundsBuffer = c.createVertexBuffer(this._boundsArray, Dr.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE), d.texSubImage2D(d.TEXTURE_2D, 0, 0, 0, d.RGBA, d.UNSIGNED_BYTE, this.video)) : (this.texture = new o.Texture(c, this.video, d.RGBA), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE)), this.tiles) {
              var w = this.tiles[_];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture);
            }
          }
        }, h.prototype.serialize = function() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }, h.prototype.hasTransition = function() {
          return this.video && !this.video.paused;
        }, h;
      }(hr), Nr = function(u) {
        function h(c, d, _, w) {
          u.call(this, c, d, _, w), d.coordinates ? Array.isArray(d.coordinates) && d.coordinates.length === 4 && !d.coordinates.some(function(E) {
            return !Array.isArray(E) || E.length !== 2 || E.some(function(O) {
              return typeof O != "number";
            });
          }) || this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, 'missing required property "coordinates"'))), d.animate && typeof d.animate != "boolean" && this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, 'optional "animate" property must be a boolean value'))), d.canvas ? typeof d.canvas == "string" || d.canvas instanceof o.window.HTMLCanvasElement || this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, 'missing required property "canvas"'))), this.options = d, this.animate = d.animate === void 0 || d.animate;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function() {
          this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof o.window.HTMLCanvasElement ? this.options.canvas : o.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = !0, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = !1);
          }, this._finishLoading());
        }, h.prototype.getCanvas = function() {
          return this.canvas;
        }, h.prototype.onAdd = function(c) {
          this.map = c, this.load(), this.canvas && this.animate && this.play();
        }, h.prototype.onRemove = function() {
          this.pause();
        }, h.prototype.prepare = function() {
          var c = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, c = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, c = !0), !this._hasInvalidDimensions() && Object.keys(this.tiles).length !== 0) {
            var d = this.map.painter.context, _ = d.gl;
            for (var w in this.boundsBuffer || (this.boundsBuffer = d.createVertexBuffer(this._boundsArray, Dr.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (c || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new o.Texture(d, this.canvas, _.RGBA, { premultiply: !0 }), this.tiles) {
              var E = this.tiles[w];
              E.state !== "loaded" && (E.state = "loaded", E.texture = this.texture);
            }
          }
        }, h.prototype.serialize = function() {
          return { type: "canvas", coordinates: this.coordinates };
        }, h.prototype.hasTransition = function() {
          return this._playing;
        }, h.prototype._hasInvalidDimensions = function() {
          for (var c = 0, d = [this.canvas.width, this.canvas.height]; c < d.length; c += 1) {
            var _ = d[c];
            if (isNaN(_) || _ <= 0)
              return !0;
          }
          return !1;
        }, h;
      }(hr), Fi = { vector: vt, raster: Pt, "raster-dem": tr, geojson: Pn, video: Zn, image: hr, canvas: Nr };
      function Gr(u, h) {
        var c = o.identity([]);
        return o.translate(c, c, [1, 1, 0]), o.scale(c, c, [0.5 * u.width, 0.5 * u.height, 1]), o.multiply(c, c, u.calculatePosMatrix(h.toUnwrapped()));
      }
      function Cr(u, h, c, d, _, w) {
        var E = function(se, J, ae) {
          if (se)
            for (var pe = 0, _e = se; pe < _e.length; pe += 1) {
              var Ce = J[_e[pe]];
              if (Ce && Ce.source === ae && Ce.type === "fill-extrusion")
                return !0;
            }
          else
            for (var Te in J) {
              var Ae = J[Te];
              if (Ae.source === ae && Ae.type === "fill-extrusion")
                return !0;
            }
          return !1;
        }(_ && _.layers, h, u.id), O = w.maxPitchScaleFactor(), k = u.tilesIn(d, O, E);
        k.sort(Vn);
        for (var R = [], q = 0, $ = k; q < $.length; q += 1) {
          var W = $[q];
          R.push({ wrappedTileID: W.tileID.wrapped().key, queryResults: W.tile.queryRenderedFeatures(h, c, u._state, W.queryGeometry, W.cameraQueryGeometry, W.scale, _, w, O, Gr(u.transform, W.tileID)) });
        }
        var ne = function(se) {
          for (var J = {}, ae = {}, pe = 0, _e = se; pe < _e.length; pe += 1) {
            var Ce = _e[pe], Te = Ce.queryResults, Ae = Ce.wrappedTileID, je = ae[Ae] = ae[Ae] || {};
            for (var tt in Te)
              for (var Qe = Te[tt], gt = je[tt] = je[tt] || {}, Dt = J[tt] = J[tt] || [], Ft = 0, zt = Qe; Ft < zt.length; Ft += 1) {
                var Tr = zt[Ft];
                gt[Tr.featureIndex] || (gt[Tr.featureIndex] = !0, Dt.push(Tr));
              }
          }
          return J;
        }(R);
        for (var re in ne)
          ne[re].forEach(function(se) {
            var J = se.feature, ae = u.getFeatureState(J.layer["source-layer"], J.id);
            J.source = J.layer.source, J.layer["source-layer"] && (J.sourceLayer = J.layer["source-layer"]), J.state = ae;
          });
        return ne;
      }
      function Vn(u, h) {
        var c = u.tileID, d = h.tileID;
        return c.overscaledZ - d.overscaledZ || c.canonical.y - d.canonical.y || c.wrap - d.wrap || c.canonical.x - d.canonical.x;
      }
      var wr = function(u, h) {
        this.max = u, this.onRemove = h, this.reset();
      };
      wr.prototype.reset = function() {
        for (var u in this.data)
          for (var h = 0, c = this.data[u]; h < c.length; h += 1) {
            var d = c[h];
            d.timeout && clearTimeout(d.timeout), this.onRemove(d.value);
          }
        return this.data = {}, this.order = [], this;
      }, wr.prototype.add = function(u, h, c) {
        var d = this, _ = u.wrapped().key;
        this.data[_] === void 0 && (this.data[_] = []);
        var w = { value: h, timeout: void 0 };
        if (c !== void 0 && (w.timeout = setTimeout(function() {
          d.remove(u, w);
        }, c)), this.data[_].push(w), this.order.push(_), this.order.length > this.max) {
          var E = this._getAndRemoveByKey(this.order[0]);
          E && this.onRemove(E);
        }
        return this;
      }, wr.prototype.has = function(u) {
        return u.wrapped().key in this.data;
      }, wr.prototype.getAndRemove = function(u) {
        return this.has(u) ? this._getAndRemoveByKey(u.wrapped().key) : null;
      }, wr.prototype._getAndRemoveByKey = function(u) {
        var h = this.data[u].shift();
        return h.timeout && clearTimeout(h.timeout), this.data[u].length === 0 && delete this.data[u], this.order.splice(this.order.indexOf(u), 1), h.value;
      }, wr.prototype.getByKey = function(u) {
        var h = this.data[u];
        return h ? h[0].value : null;
      }, wr.prototype.get = function(u) {
        return this.has(u) ? this.data[u.wrapped().key][0].value : null;
      }, wr.prototype.remove = function(u, h) {
        if (!this.has(u))
          return this;
        var c = u.wrapped().key, d = h === void 0 ? 0 : this.data[c].indexOf(h), _ = this.data[c][d];
        return this.data[c].splice(d, 1), _.timeout && clearTimeout(_.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(_.value), this.order.splice(this.order.indexOf(c), 1), this;
      }, wr.prototype.setMaxSize = function(u) {
        for (this.max = u; this.order.length > this.max; ) {
          var h = this._getAndRemoveByKey(this.order[0]);
          h && this.onRemove(h);
        }
        return this;
      }, wr.prototype.filter = function(u) {
        var h = [];
        for (var c in this.data)
          for (var d = 0, _ = this.data[c]; d < _.length; d += 1) {
            var w = _[d];
            u(w.value) || h.push(w);
          }
        for (var E = 0, O = h; E < O.length; E += 1) {
          var k = O[E];
          this.remove(k.value.tileID, k);
        }
      };
      var En = function(u, h, c) {
        this.context = u;
        var d = u.gl;
        this.buffer = d.createBuffer(), this.dynamicDraw = Boolean(c), this.context.unbindVAO(), u.bindElementBuffer.set(this.buffer), d.bufferData(d.ELEMENT_ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete h.arrayBuffer;
      };
      En.prototype.bind = function() {
        this.context.bindElementBuffer.set(this.buffer);
      }, En.prototype.updateData = function(u) {
        var h = this.context.gl;
        this.context.unbindVAO(), this.bind(), h.bufferSubData(h.ELEMENT_ARRAY_BUFFER, 0, u.arrayBuffer);
      }, En.prototype.destroy = function() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      };
      var oi = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, Un = function(u, h, c, d) {
        this.length = h.length, this.attributes = c, this.itemSize = h.bytesPerElement, this.dynamicDraw = d, this.context = u;
        var _ = u.gl;
        this.buffer = _.createBuffer(), u.bindVertexBuffer.set(this.buffer), _.bufferData(_.ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete h.arrayBuffer;
      };
      Un.prototype.bind = function() {
        this.context.bindVertexBuffer.set(this.buffer);
      }, Un.prototype.updateData = function(u) {
        var h = this.context.gl;
        this.bind(), h.bufferSubData(h.ARRAY_BUFFER, 0, u.arrayBuffer);
      }, Un.prototype.enableAttributes = function(u, h) {
        for (var c = 0; c < this.attributes.length; c++) {
          var d = h.attributes[this.attributes[c].name];
          d !== void 0 && u.enableVertexAttribArray(d);
        }
      }, Un.prototype.setVertexAttribPointers = function(u, h, c) {
        for (var d = 0; d < this.attributes.length; d++) {
          var _ = this.attributes[d], w = h.attributes[_.name];
          w !== void 0 && u.vertexAttribPointer(w, _.components, u[oi[_.type]], !1, this.itemSize, _.offset + this.itemSize * (c || 0));
        }
      }, Un.prototype.destroy = function() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      };
      var K = function(u) {
        this.gl = u.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
      };
      K.prototype.get = function() {
        return this.current;
      }, K.prototype.set = function(u) {
      }, K.prototype.getDefault = function() {
        return this.default;
      }, K.prototype.setDefault = function() {
        this.set(this.default);
      };
      var me = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return o.Color.transparent;
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c.r !== d.r || c.g !== d.g || c.b !== d.b || c.a !== d.a || this.dirty) && (this.gl.clearColor(c.r, c.g, c.b, c.a), this.current = c, this.dirty = !1);
        }, h;
      }(K), Le = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return 1;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.clearDepth(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), qe = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return 0;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.clearStencil(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), $e = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return [!0, !0, !0, !0];
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || c[3] !== d[3] || this.dirty) && (this.gl.colorMask(c[0], c[1], c[2], c[3]), this.current = c, this.dirty = !1);
        }, h;
      }(K), et = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !0;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.depthMask(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), dt = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return 255;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.stencilMask(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), Je = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c.func !== d.func || c.ref !== d.ref || c.mask !== d.mask || this.dirty) && (this.gl.stencilFunc(c.func, c.ref, c.mask), this.current = c, this.dirty = !1);
        }, h;
      }(K), lt = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          var c = this.gl;
          return [c.KEEP, c.KEEP, c.KEEP];
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || this.dirty) && (this.gl.stencilOp(c[0], c[1], c[2]), this.current = c, this.dirty = !1);
        }, h;
      }(K), Ye = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.STENCIL_TEST) : d.disable(d.STENCIL_TEST), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), It = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return [0, 1];
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || this.dirty) && (this.gl.depthRange(c[0], c[1]), this.current = c, this.dirty = !1);
        }, h;
      }(K), bt = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.DEPTH_TEST) : d.disable(d.DEPTH_TEST), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), kt = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return this.gl.LESS;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.depthFunc(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), Ut = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.BLEND) : d.disable(d.BLEND), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), fr = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          var c = this.gl;
          return [c.ONE, c.ZERO];
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || this.dirty) && (this.gl.blendFunc(c[0], c[1]), this.current = c, this.dirty = !1);
        }, h;
      }(K), Fr = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return o.Color.transparent;
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c.r !== d.r || c.g !== d.g || c.b !== d.b || c.a !== d.a || this.dirty) && (this.gl.blendColor(c.r, c.g, c.b, c.a), this.current = c, this.dirty = !1);
        }, h;
      }(K), Ar = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return this.gl.FUNC_ADD;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.blendEquation(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), Jr = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.CULL_FACE) : d.disable(d.CULL_FACE), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), Xn = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return this.gl.BACK;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.cullFace(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), Bi = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return this.gl.CCW;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.frontFace(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), so = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.useProgram(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), Kn = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return this.gl.TEXTURE0;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.activeTexture(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), ki = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          var c = this.gl;
          return [0, 0, c.drawingBufferWidth, c.drawingBufferHeight];
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || c[3] !== d[3] || this.dirty) && (this.gl.viewport(c[0], c[1], c[2], c[3]), this.current = c, this.dirty = !1);
        }, h;
      }(K), Sn = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindFramebuffer(d.FRAMEBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), ai = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindRenderbuffer(d.RENDERBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), Fa = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindTexture(d.TEXTURE_2D, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), Uo = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindBuffer(d.ARRAY_BUFFER, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), Ba = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          var d = this.gl;
          d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, c), this.current = c, this.dirty = !1;
        }, h;
      }(K), na = function(u) {
        function h(c) {
          u.call(this, c), this.vao = c.extVertexArrayObject;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          this.vao && (c !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), on = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return 4;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_ALIGNMENT, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), So = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), tl = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), bn = function(u) {
        function h(c, d) {
          u.call(this, c), this.context = c, this.parent = d;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h;
      }(K), N = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.setDirty = function() {
          this.dirty = !0;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            this.context.bindFramebuffer.set(this.parent);
            var d = this.gl;
            d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, c, 0), this.current = c, this.dirty = !1;
          }
        }, h;
      }(bn), F = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            this.context.bindFramebuffer.set(this.parent);
            var d = this.gl;
            d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.RENDERBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(bn), U = function(u, h, c, d) {
        this.context = u, this.width = h, this.height = c;
        var _ = this.framebuffer = u.gl.createFramebuffer();
        this.colorAttachment = new N(u, _), d && (this.depthAttachment = new F(u, _));
      };
      U.prototype.destroy = function() {
        var u = this.context.gl, h = this.colorAttachment.get();
        if (h && u.deleteTexture(h), this.depthAttachment) {
          var c = this.depthAttachment.get();
          c && u.deleteRenderbuffer(c);
        }
        u.deleteFramebuffer(this.framebuffer);
      };
      var H = function(u, h, c) {
        this.func = u, this.mask = h, this.range = c;
      };
      H.ReadOnly = !1, H.ReadWrite = !0, H.disabled = new H(519, H.ReadOnly, [0, 1]);
      var ee = function(u, h, c, d, _, w) {
        this.test = u, this.ref = h, this.mask = c, this.fail = d, this.depthFail = _, this.pass = w;
      };
      ee.disabled = new ee({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
      var he = function(u, h, c) {
        this.blendFunction = u, this.blendColor = h, this.mask = c;
      };
      he.disabled = new he(he.Replace = [1, 0], o.Color.transparent, [!1, !1, !1, !1]), he.unblended = new he(he.Replace, o.Color.transparent, [!0, !0, !0, !0]), he.alphaBlended = new he([1, 771], o.Color.transparent, [!0, !0, !0, !0]);
      var fe = function(u, h, c) {
        this.enable = u, this.mode = h, this.frontFace = c;
      };
      fe.disabled = new fe(!1, 1029, 2305), fe.backCCW = new fe(!0, 1029, 2305);
      var G = function(u) {
        this.gl = u, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new me(this), this.clearDepth = new Le(this), this.clearStencil = new qe(this), this.colorMask = new $e(this), this.depthMask = new et(this), this.stencilMask = new dt(this), this.stencilFunc = new Je(this), this.stencilOp = new lt(this), this.stencilTest = new Ye(this), this.depthRange = new It(this), this.depthTest = new bt(this), this.depthFunc = new kt(this), this.blend = new Ut(this), this.blendFunc = new fr(this), this.blendColor = new Fr(this), this.blendEquation = new Ar(this), this.cullFace = new Jr(this), this.cullFaceSide = new Xn(this), this.frontFace = new Bi(this), this.program = new so(this), this.activeTexture = new Kn(this), this.viewport = new ki(this), this.bindFramebuffer = new Sn(this), this.bindRenderbuffer = new ai(this), this.bindTexture = new Fa(this), this.bindVertexBuffer = new Uo(this), this.bindElementBuffer = new Ba(this), this.bindVertexArrayOES = this.extVertexArrayObject && new na(this), this.pixelStoreUnpack = new on(this), this.pixelStoreUnpackPremultiplyAlpha = new So(this), this.pixelStoreUnpackFlipY = new tl(this), this.extTextureFilterAnisotropic = u.getExtension("EXT_texture_filter_anisotropic") || u.getExtension("MOZ_EXT_texture_filter_anisotropic") || u.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = u.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = u.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (u.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = u.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = u.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = u.getParameter(u.MAX_TEXTURE_SIZE);
      };
      G.prototype.setDefault = function() {
        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
      }, G.prototype.setDirty = function() {
        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
      }, G.prototype.createIndexBuffer = function(u, h) {
        return new En(this, u, h);
      }, G.prototype.createVertexBuffer = function(u, h, c) {
        return new Un(this, u, h, c);
      }, G.prototype.createRenderbuffer = function(u, h, c) {
        var d = this.gl, _ = d.createRenderbuffer();
        return this.bindRenderbuffer.set(_), d.renderbufferStorage(d.RENDERBUFFER, u, h, c), this.bindRenderbuffer.set(null), _;
      }, G.prototype.createFramebuffer = function(u, h, c) {
        return new U(this, u, h, c);
      }, G.prototype.clear = function(u) {
        var h = u.color, c = u.depth, d = this.gl, _ = 0;
        h && (_ |= d.COLOR_BUFFER_BIT, this.clearColor.set(h), this.colorMask.set([!0, !0, !0, !0])), c !== void 0 && (_ |= d.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(c), this.depthMask.set(!0)), d.clear(_);
      }, G.prototype.setCullFace = function(u) {
        u.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(u.mode), this.frontFace.set(u.frontFace));
      }, G.prototype.setDepthMode = function(u) {
        u.func !== this.gl.ALWAYS || u.mask ? (this.depthTest.set(!0), this.depthFunc.set(u.func), this.depthMask.set(u.mask), this.depthRange.set(u.range)) : this.depthTest.set(!1);
      }, G.prototype.setStencilMode = function(u) {
        u.test.func !== this.gl.ALWAYS || u.mask ? (this.stencilTest.set(!0), this.stencilMask.set(u.mask), this.stencilOp.set([u.fail, u.depthFail, u.pass]), this.stencilFunc.set({ func: u.test.func, ref: u.ref, mask: u.test.mask })) : this.stencilTest.set(!1);
      }, G.prototype.setColorMode = function(u) {
        o.deepEqual(u.blendFunction, he.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(u.blendFunction), this.blendColor.set(u.blendColor)), this.colorMask.set(u.mask);
      }, G.prototype.unbindVAO = function() {
        this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
      };
      var ie = function(u) {
        function h(c, d, _) {
          var w = this;
          u.call(this), this.id = c, this.dispatcher = _, this.on("data", function(E) {
            E.dataType === "source" && E.sourceDataType === "metadata" && (w._sourceLoaded = !0), w._sourceLoaded && !w._paused && E.dataType === "source" && E.sourceDataType === "content" && (w.reload(), w.transform && w.update(w.transform));
          }), this.on("error", function() {
            w._sourceErrored = !0;
          }), this._source = function(E, O, k, R) {
            var q = new Fi[O.type](E, O, k, R);
            if (q.id !== E)
              throw new Error("Expected Source id to be " + E + " instead of " + q.id);
            return o.bindAll(["load", "abort", "unload", "serialize", "prepare"], q), q;
          }(c, d, _, this), this._tiles = {}, this._cache = new wr(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new o.SourceFeatureState();
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.onAdd = function(c) {
          this.map = c, this._maxTileCacheSize = c ? c._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(c);
        }, h.prototype.onRemove = function(c) {
          this._source && this._source.onRemove && this._source.onRemove(c);
        }, h.prototype.loaded = function() {
          if (this._sourceErrored)
            return !0;
          if (!this._sourceLoaded || !this._source.loaded())
            return !1;
          for (var c in this._tiles) {
            var d = this._tiles[c];
            if (d.state !== "loaded" && d.state !== "errored")
              return !1;
          }
          return !0;
        }, h.prototype.getSource = function() {
          return this._source;
        }, h.prototype.pause = function() {
          this._paused = !0;
        }, h.prototype.resume = function() {
          if (this._paused) {
            var c = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, c && this.reload(), this.transform && this.update(this.transform);
          }
        }, h.prototype._loadTile = function(c, d) {
          return this._source.loadTile(c, d);
        }, h.prototype._unloadTile = function(c) {
          if (this._source.unloadTile)
            return this._source.unloadTile(c, function() {
            });
        }, h.prototype._abortTile = function(c) {
          if (this._source.abortTile)
            return this._source.abortTile(c, function() {
            });
        }, h.prototype.serialize = function() {
          return this._source.serialize();
        }, h.prototype.prepare = function(c) {
          for (var d in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {
            var _ = this._tiles[d];
            _.upload(c), _.prepare(this.map.style.imageManager);
          }
        }, h.prototype.getIds = function() {
          return o.values(this._tiles).map(function(c) {
            return c.tileID;
          }).sort(ve).map(function(c) {
            return c.key;
          });
        }, h.prototype.getRenderableIds = function(c) {
          var d = this, _ = [];
          for (var w in this._tiles)
            this._isIdRenderable(w, c) && _.push(this._tiles[w]);
          return c ? _.sort(function(E, O) {
            var k = E.tileID, R = O.tileID, q = new o.Point(k.canonical.x, k.canonical.y)._rotate(d.transform.angle), $ = new o.Point(R.canonical.x, R.canonical.y)._rotate(d.transform.angle);
            return k.overscaledZ - R.overscaledZ || $.y - q.y || $.x - q.x;
          }).map(function(E) {
            return E.tileID.key;
          }) : _.map(function(E) {
            return E.tileID;
          }).sort(ve).map(function(E) {
            return E.key;
          });
        }, h.prototype.hasRenderableParent = function(c) {
          var d = this.findLoadedParent(c, 0);
          return !!d && this._isIdRenderable(d.tileID.key);
        }, h.prototype._isIdRenderable = function(c, d) {
          return this._tiles[c] && this._tiles[c].hasData() && !this._coveredTiles[c] && (d || !this._tiles[c].holdingForFade());
        }, h.prototype.reload = function() {
          if (this._paused)
            this._shouldReloadOnResume = !0;
          else
            for (var c in this._cache.reset(), this._tiles)
              this._tiles[c].state !== "errored" && this._reloadTile(c, "reloading");
        }, h.prototype._reloadTile = function(c, d) {
          var _ = this._tiles[c];
          _ && (_.state !== "loading" && (_.state = d), this._loadTile(_, this._tileLoaded.bind(this, _, c, d)));
        }, h.prototype._tileLoaded = function(c, d, _, w) {
          if (w)
            return c.state = "errored", void (w.status !== 404 ? this._source.fire(new o.ErrorEvent(w, { tile: c })) : this.update(this.transform));
          c.timeAdded = o.browser.now(), _ === "expired" && (c.refreshedUponExpiration = !0), this._setTileReloadTimer(d, c), this.getSource().type === "raster-dem" && c.dem && this._backfillDEM(c), this._state.initializeTileState(c, this.map ? this.map.painter : null), this._source.fire(new o.Event("data", { dataType: "source", tile: c, coord: c.tileID }));
        }, h.prototype._backfillDEM = function(c) {
          for (var d = this.getRenderableIds(), _ = 0; _ < d.length; _++) {
            var w = d[_];
            if (c.neighboringTiles && c.neighboringTiles[w]) {
              var E = this.getTileByID(w);
              O(c, E), O(E, c);
            }
          }
          function O(k, R) {
            k.needsHillshadePrepare = !0;
            var q = R.tileID.canonical.x - k.tileID.canonical.x, $ = R.tileID.canonical.y - k.tileID.canonical.y, W = Math.pow(2, k.tileID.canonical.z), ne = R.tileID.key;
            q === 0 && $ === 0 || Math.abs($) > 1 || (Math.abs(q) > 1 && (Math.abs(q + W) === 1 ? q += W : Math.abs(q - W) === 1 && (q -= W)), R.dem && k.dem && (k.dem.backfillBorder(R.dem, q, $), k.neighboringTiles && k.neighboringTiles[ne] && (k.neighboringTiles[ne].backfilled = !0)));
          }
        }, h.prototype.getTile = function(c) {
          return this.getTileByID(c.key);
        }, h.prototype.getTileByID = function(c) {
          return this._tiles[c];
        }, h.prototype._retainLoadedChildren = function(c, d, _, w) {
          for (var E in this._tiles) {
            var O = this._tiles[E];
            if (!(w[E] || !O.hasData() || O.tileID.overscaledZ <= d || O.tileID.overscaledZ > _)) {
              for (var k = O.tileID; O && O.tileID.overscaledZ > d + 1; ) {
                var R = O.tileID.scaledTo(O.tileID.overscaledZ - 1);
                (O = this._tiles[R.key]) && O.hasData() && (k = R);
              }
              for (var q = k; q.overscaledZ > d; )
                if (c[(q = q.scaledTo(q.overscaledZ - 1)).key]) {
                  w[k.key] = k;
                  break;
                }
            }
          }
        }, h.prototype.findLoadedParent = function(c, d) {
          if (c.key in this._loadedParentTiles) {
            var _ = this._loadedParentTiles[c.key];
            return _ && _.tileID.overscaledZ >= d ? _ : null;
          }
          for (var w = c.overscaledZ - 1; w >= d; w--) {
            var E = c.scaledTo(w), O = this._getLoadedTile(E);
            if (O)
              return O;
          }
        }, h.prototype._getLoadedTile = function(c) {
          var d = this._tiles[c.key];
          return d && d.hasData() ? d : this._cache.getByKey(c.wrapped().key);
        }, h.prototype.updateCacheSize = function(c) {
          var d = Math.ceil(c.width / this._source.tileSize) + 1, _ = Math.ceil(c.height / this._source.tileSize) + 1, w = Math.floor(d * _ * 5), E = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, w) : w;
          this._cache.setMaxSize(E);
        }, h.prototype.handleWrapJump = function(c) {
          var d = Math.round((c - (this._prevLng === void 0 ? c : this._prevLng)) / 360);
          if (this._prevLng = c, d) {
            var _ = {};
            for (var w in this._tiles) {
              var E = this._tiles[w];
              E.tileID = E.tileID.unwrapTo(E.tileID.wrap + d), _[E.tileID.key] = E;
            }
            for (var O in this._tiles = _, this._timers)
              clearTimeout(this._timers[O]), delete this._timers[O];
            for (var k in this._tiles)
              this._setTileReloadTimer(k, this._tiles[k]);
          }
        }, h.prototype.update = function(c) {
          var d = this;
          if (this.transform = c, this._sourceLoaded && !this._paused) {
            var _;
            this.updateCacheSize(c), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? _ = c.getVisibleUnwrappedCoordinates(this._source.tileID).map(function(je) {
              return new o.OverscaledTileID(je.canonical.z, je.wrap, je.canonical.z, je.canonical.x, je.canonical.y);
            }) : (_ = c.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (_ = _.filter(function(je) {
              return d._source.hasTile(je);
            }))) : _ = [];
            var w = c.coveringZoomLevel(this._source), E = Math.max(w - h.maxOverzooming, this._source.minzoom), O = Math.max(w + h.maxUnderzooming, this._source.minzoom), k = this._updateRetainedTiles(_, w);
            if (Ge(this._source.type)) {
              for (var R = {}, q = {}, $ = 0, W = Object.keys(k); $ < W.length; $ += 1) {
                var ne = W[$], re = k[ne], se = this._tiles[ne];
                if (se && !(se.fadeEndTime && se.fadeEndTime <= o.browser.now())) {
                  var J = this.findLoadedParent(re, E);
                  J && (this._addTile(J.tileID), R[J.tileID.key] = J.tileID), q[ne] = re;
                }
              }
              for (var ae in this._retainLoadedChildren(q, w, O, k), R)
                k[ae] || (this._coveredTiles[ae] = !0, k[ae] = R[ae]);
            }
            for (var pe in k)
              this._tiles[pe].clearFadeHold();
            for (var _e = 0, Ce = o.keysDifference(this._tiles, k); _e < Ce.length; _e += 1) {
              var Te = Ce[_e], Ae = this._tiles[Te];
              Ae.hasSymbolBuckets && !Ae.holdingForFade() ? Ae.setHoldDuration(this.map._fadeDuration) : Ae.hasSymbolBuckets && !Ae.symbolFadeFinished() || this._removeTile(Te);
            }
            this._updateLoadedParentTileCache();
          }
        }, h.prototype.releaseSymbolFadeTiles = function() {
          for (var c in this._tiles)
            this._tiles[c].holdingForFade() && this._removeTile(c);
        }, h.prototype._updateRetainedTiles = function(c, d) {
          for (var _ = {}, w = {}, E = Math.max(d - h.maxOverzooming, this._source.minzoom), O = Math.max(d + h.maxUnderzooming, this._source.minzoom), k = {}, R = 0, q = c; R < q.length; R += 1) {
            var $ = q[R], W = this._addTile($);
            _[$.key] = $, W.hasData() || d < this._source.maxzoom && (k[$.key] = $);
          }
          this._retainLoadedChildren(k, d, O, _);
          for (var ne = 0, re = c; ne < re.length; ne += 1) {
            var se = re[ne], J = this._tiles[se.key];
            if (!J.hasData()) {
              if (d + 1 > this._source.maxzoom) {
                var ae = se.children(this._source.maxzoom)[0], pe = this.getTile(ae);
                if (pe && pe.hasData()) {
                  _[ae.key] = ae;
                  continue;
                }
              } else {
                var _e = se.children(this._source.maxzoom);
                if (_[_e[0].key] && _[_e[1].key] && _[_e[2].key] && _[_e[3].key])
                  continue;
              }
              for (var Ce = J.wasRequested(), Te = se.overscaledZ - 1; Te >= E; --Te) {
                var Ae = se.scaledTo(Te);
                if (w[Ae.key] || (w[Ae.key] = !0, !(J = this.getTile(Ae)) && Ce && (J = this._addTile(Ae)), J && (_[Ae.key] = Ae, Ce = J.wasRequested(), J.hasData())))
                  break;
              }
            }
          }
          return _;
        }, h.prototype._updateLoadedParentTileCache = function() {
          for (var c in this._loadedParentTiles = {}, this._tiles) {
            for (var d = [], _ = void 0, w = this._tiles[c].tileID; w.overscaledZ > 0; ) {
              if (w.key in this._loadedParentTiles) {
                _ = this._loadedParentTiles[w.key];
                break;
              }
              d.push(w.key);
              var E = w.scaledTo(w.overscaledZ - 1);
              if (_ = this._getLoadedTile(E))
                break;
              w = E;
            }
            for (var O = 0, k = d; O < k.length; O += 1)
              this._loadedParentTiles[k[O]] = _;
          }
        }, h.prototype._addTile = function(c) {
          var d = this._tiles[c.key];
          if (d)
            return d;
          (d = this._cache.getAndRemove(c)) && (this._setTileReloadTimer(c.key, d), d.tileID = c, this._state.initializeTileState(d, this.map ? this.map.painter : null), this._cacheTimers[c.key] && (clearTimeout(this._cacheTimers[c.key]), delete this._cacheTimers[c.key], this._setTileReloadTimer(c.key, d)));
          var _ = Boolean(d);
          return _ || (d = new o.Tile(c, this._source.tileSize * c.overscaleFactor()), this._loadTile(d, this._tileLoaded.bind(this, d, c.key, d.state))), d ? (d.uses++, this._tiles[c.key] = d, _ || this._source.fire(new o.Event("dataloading", { tile: d, coord: d.tileID, dataType: "source" })), d) : null;
        }, h.prototype._setTileReloadTimer = function(c, d) {
          var _ = this;
          c in this._timers && (clearTimeout(this._timers[c]), delete this._timers[c]);
          var w = d.getExpiryTimeout();
          w && (this._timers[c] = setTimeout(function() {
            _._reloadTile(c, "expired"), delete _._timers[c];
          }, w));
        }, h.prototype._removeTile = function(c) {
          var d = this._tiles[c];
          d && (d.uses--, delete this._tiles[c], this._timers[c] && (clearTimeout(this._timers[c]), delete this._timers[c]), d.uses > 0 || (d.hasData() && d.state !== "reloading" ? this._cache.add(d.tileID, d, d.getExpiryTimeout()) : (d.aborted = !0, this._abortTile(d), this._unloadTile(d))));
        }, h.prototype.clearTiles = function() {
          for (var c in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles)
            this._removeTile(c);
          this._cache.reset();
        }, h.prototype.tilesIn = function(c, d, _) {
          var w = this, E = [], O = this.transform;
          if (!O)
            return E;
          for (var k = _ ? O.getCameraQueryGeometry(c) : c, R = c.map(function(Te) {
            return O.pointCoordinate(Te);
          }), q = k.map(function(Te) {
            return O.pointCoordinate(Te);
          }), $ = this.getIds(), W = 1 / 0, ne = 1 / 0, re = -1 / 0, se = -1 / 0, J = 0, ae = q; J < ae.length; J += 1) {
            var pe = ae[J];
            W = Math.min(W, pe.x), ne = Math.min(ne, pe.y), re = Math.max(re, pe.x), se = Math.max(se, pe.y);
          }
          for (var _e = function(Te) {
            var Ae = w._tiles[$[Te]];
            if (!Ae.holdingForFade()) {
              var je = Ae.tileID, tt = Math.pow(2, O.zoom - Ae.tileID.overscaledZ), Qe = d * Ae.queryPadding * o.EXTENT / Ae.tileSize / tt, gt = [je.getTilePoint(new o.MercatorCoordinate(W, ne)), je.getTilePoint(new o.MercatorCoordinate(re, se))];
              if (gt[0].x - Qe < o.EXTENT && gt[0].y - Qe < o.EXTENT && gt[1].x + Qe >= 0 && gt[1].y + Qe >= 0) {
                var Dt = R.map(function(zt) {
                  return je.getTilePoint(zt);
                }), Ft = q.map(function(zt) {
                  return je.getTilePoint(zt);
                });
                E.push({ tile: Ae, tileID: je, queryGeometry: Dt, cameraQueryGeometry: Ft, scale: tt });
              }
            }
          }, Ce = 0; Ce < $.length; Ce++)
            _e(Ce);
          return E;
        }, h.prototype.getVisibleCoordinates = function(c) {
          for (var d = this, _ = this.getRenderableIds(c).map(function(k) {
            return d._tiles[k].tileID;
          }), w = 0, E = _; w < E.length; w += 1) {
            var O = E[w];
            O.posMatrix = this.transform.calculatePosMatrix(O.toUnwrapped());
          }
          return _;
        }, h.prototype.hasTransition = function() {
          if (this._source.hasTransition())
            return !0;
          if (Ge(this._source.type))
            for (var c in this._tiles) {
              var d = this._tiles[c];
              if (d.fadeEndTime !== void 0 && d.fadeEndTime >= o.browser.now())
                return !0;
            }
          return !1;
        }, h.prototype.setFeatureState = function(c, d, _) {
          this._state.updateState(c = c || "_geojsonTileLayer", d, _);
        }, h.prototype.removeFeatureState = function(c, d, _) {
          this._state.removeFeatureState(c = c || "_geojsonTileLayer", d, _);
        }, h.prototype.getFeatureState = function(c, d) {
          return this._state.getState(c = c || "_geojsonTileLayer", d);
        }, h.prototype.setDependencies = function(c, d, _) {
          var w = this._tiles[c];
          w && w.setDependencies(d, _);
        }, h.prototype.reloadTilesForDependencies = function(c, d) {
          for (var _ in this._tiles)
            this._tiles[_].hasDependency(c, d) && this._reloadTile(_, "reloading");
          this._cache.filter(function(w) {
            return !w.hasDependency(c, d);
          });
        }, h;
      }(o.Evented);
      function ve(u, h) {
        var c = Math.abs(2 * u.wrap) - +(u.wrap < 0), d = Math.abs(2 * h.wrap) - +(h.wrap < 0);
        return u.overscaledZ - h.overscaledZ || d - c || h.canonical.y - u.canonical.y || h.canonical.x - u.canonical.x;
      }
      function Ge(u) {
        return u === "raster" || u === "image" || u === "video";
      }
      function He() {
        return new o.window.Worker(wh.workerUrl);
      }
      ie.maxOverzooming = 10, ie.maxUnderzooming = 3;
      var Oe = "mapboxgl_preloaded_worker_pool", Ve = function() {
        this.active = {};
      };
      Ve.prototype.acquire = function(u) {
        if (!this.workers)
          for (this.workers = []; this.workers.length < Ve.workerCount; )
            this.workers.push(new He());
        return this.active[u] = !0, this.workers.slice();
      }, Ve.prototype.release = function(u) {
        delete this.active[u], this.numActive() === 0 && (this.workers.forEach(function(h) {
          h.terminate();
        }), this.workers = null);
      }, Ve.prototype.isPreloaded = function() {
        return !!this.active[Oe];
      }, Ve.prototype.numActive = function() {
        return Object.keys(this.active).length;
      };
      var Et, _t = Math.floor(o.browser.hardwareConcurrency / 2);
      function Pe() {
        return Et || (Et = new Ve()), Et;
      }
      function ft(u, h) {
        var c = {};
        for (var d in u)
          d !== "ref" && (c[d] = u[d]);
        return o.refProperties.forEach(function(_) {
          _ in h && (c[_] = h[_]);
        }), c;
      }
      function ot(u) {
        u = u.slice();
        for (var h = /* @__PURE__ */ Object.create(null), c = 0; c < u.length; c++)
          h[u[c].id] = u[c];
        for (var d = 0; d < u.length; d++)
          "ref" in u[d] && (u[d] = ft(u[d], h[u[d].ref]));
        return u;
      }
      Ve.workerCount = Math.max(Math.min(_t, 6), 1);
      var ke = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
      function ce(u, h, c) {
        c.push({ command: ke.addSource, args: [u, h[u]] });
      }
      function we(u, h, c) {
        h.push({ command: ke.removeSource, args: [u] }), c[u] = !0;
      }
      function We(u, h, c, d) {
        we(u, c, d), ce(u, h, c);
      }
      function jt(u, h, c) {
        var d;
        for (d in u[c])
          if (u[c].hasOwnProperty(d) && d !== "data" && !o.deepEqual(u[c][d], h[c][d]))
            return !1;
        for (d in h[c])
          if (h[c].hasOwnProperty(d) && d !== "data" && !o.deepEqual(u[c][d], h[c][d]))
            return !1;
        return !0;
      }
      function Wt(u, h, c, d, _, w) {
        var E;
        for (E in h = h || {}, u = u || {})
          u.hasOwnProperty(E) && (o.deepEqual(u[E], h[E]) || c.push({ command: w, args: [d, E, h[E], _] }));
        for (E in h)
          h.hasOwnProperty(E) && !u.hasOwnProperty(E) && (o.deepEqual(u[E], h[E]) || c.push({ command: w, args: [d, E, h[E], _] }));
      }
      function Jt(u) {
        return u.id;
      }
      function Zt(u, h) {
        return u[h.id] = h, u;
      }
      var Yn = function(u, h) {
        this.reset(u, h);
      };
      Yn.prototype.reset = function(u, h) {
        this.points = u || [], this._distances = [0];
        for (var c = 1; c < this.points.length; c++)
          this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(h || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
      }, Yn.prototype.lerp = function(u) {
        if (this.points.length === 1)
          return this.points[0];
        u = o.clamp(u, 0, 1);
        for (var h = 1, c = this._distances[h], d = u * this.paddedLength + this.padding; c < d && h < this._distances.length; )
          c = this._distances[++h];
        var _ = h - 1, w = this._distances[_], E = c - w, O = E > 0 ? (d - w) / E : 0;
        return this.points[_].mult(1 - O).add(this.points[h].mult(O));
      };
      var Qt = function(u, h, c) {
        var d = this.boxCells = [], _ = this.circleCells = [];
        this.xCellCount = Math.ceil(u / c), this.yCellCount = Math.ceil(h / c);
        for (var w = 0; w < this.xCellCount * this.yCellCount; w++)
          d.push([]), _.push([]);
        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = u, this.height = h, this.xScale = this.xCellCount / u, this.yScale = this.yCellCount / h, this.boxUid = 0, this.circleUid = 0;
      };
      function pn(u, h, c, d, _) {
        var w = o.create();
        return h ? (o.scale(w, w, [1 / _, 1 / _, 1]), c || o.rotateZ(w, w, d.angle)) : o.multiply(w, d.labelPlaneMatrix, u), w;
      }
      function Br(u, h, c, d, _) {
        if (h) {
          var w = o.clone(u);
          return o.scale(w, w, [_, _, 1]), c || o.rotateZ(w, w, -d.angle), w;
        }
        return d.glCoordMatrix;
      }
      function yr(u, h) {
        var c = [u.x, u.y, 0, 1];
        mi(c, c, h);
        var d = c[3];
        return { point: new o.Point(c[0] / d, c[1] / d), signedDistanceFromCamera: d };
      }
      function Rr(u, h) {
        return 0.5 + u / h * 0.5;
      }
      function Yi(u, h) {
        var c = u[0] / u[3], d = u[1] / u[3];
        return c >= -h[0] && c <= h[0] && d >= -h[1] && d <= h[1];
      }
      function Uu(u, h, c, d, _, w, E, O) {
        var k = d ? u.textSizeData : u.iconSizeData, R = o.evaluateSizeForZoom(k, c.transform.zoom), q = [256 / c.width * 2 + 1, 256 / c.height * 2 + 1], $ = d ? u.text.dynamicLayoutVertexArray : u.icon.dynamicLayoutVertexArray;
        $.clear();
        for (var W = u.lineVertexArray, ne = d ? u.text.placedSymbolArray : u.icon.placedSymbolArray, re = c.transform.width / c.transform.height, se = !1, J = 0; J < ne.length; J++) {
          var ae = ne.get(J);
          if (ae.hidden || ae.writingMode === o.WritingMode.vertical && !se)
            Vi(ae.numGlyphs, $);
          else {
            se = !1;
            var pe = [ae.anchorX, ae.anchorY, 0, 1];
            if (o.transformMat4(pe, pe, h), Yi(pe, q)) {
              var _e = Rr(c.transform.cameraToCenterDistance, pe[3]), Ce = o.evaluateSizeForFeature(k, R, ae), Te = E ? Ce / _e : Ce * _e, Ae = new o.Point(ae.anchorX, ae.anchorY), je = yr(Ae, _).point, tt = {}, Qe = qf(ae, Te, !1, O, h, _, w, u.glyphOffsetArray, W, $, je, Ae, tt, re);
              se = Qe.useVertical, (Qe.notEnoughRoom || se || Qe.needsFlipping && qf(ae, Te, !0, O, h, _, w, u.glyphOffsetArray, W, $, je, Ae, tt, re).notEnoughRoom) && Vi(ae.numGlyphs, $);
            } else
              Vi(ae.numGlyphs, $);
          }
        }
        d ? u.text.dynamicLayoutVertexBuffer.updateData($) : u.icon.dynamicLayoutVertexBuffer.updateData($);
      }
      function di(u, h, c, d, _, w, E, O, k, R, q) {
        var $ = O.glyphStartIndex + O.numGlyphs, W = O.lineStartIndex, ne = O.lineStartIndex + O.lineLength, re = h.getoffsetX(O.glyphStartIndex), se = h.getoffsetX($ - 1), J = kn(u * re, c, d, _, w, E, O.segment, W, ne, k, R, q);
        if (!J)
          return null;
        var ae = kn(u * se, c, d, _, w, E, O.segment, W, ne, k, R, q);
        return ae ? { first: J, last: ae } : null;
      }
      function Ji(u, h, c, d) {
        return u === o.WritingMode.horizontal && Math.abs(c.y - h.y) > Math.abs(c.x - h.x) * d ? { useVertical: !0 } : (u === o.WritingMode.vertical ? h.y < c.y : h.x > c.x) ? { needsFlipping: !0 } : null;
      }
      function qf(u, h, c, d, _, w, E, O, k, R, q, $, W, ne) {
        var re, se = h / 24, J = u.lineOffsetX * se, ae = u.lineOffsetY * se;
        if (u.numGlyphs > 1) {
          var pe = u.glyphStartIndex + u.numGlyphs, _e = u.lineStartIndex, Ce = u.lineStartIndex + u.lineLength, Te = di(se, O, J, ae, c, q, $, u, k, w, W);
          if (!Te)
            return { notEnoughRoom: !0 };
          var Ae = yr(Te.first.point, E).point, je = yr(Te.last.point, E).point;
          if (d && !c) {
            var tt = Ji(u.writingMode, Ae, je, ne);
            if (tt)
              return tt;
          }
          re = [Te.first];
          for (var Qe = u.glyphStartIndex + 1; Qe < pe - 1; Qe++)
            re.push(kn(se * O.getoffsetX(Qe), J, ae, c, q, $, u.segment, _e, Ce, k, w, W));
          re.push(Te.last);
        } else {
          if (d && !c) {
            var gt = yr($, _).point, Dt = u.lineStartIndex + u.segment + 1, Ft = new o.Point(k.getx(Dt), k.gety(Dt)), zt = yr(Ft, _), Tr = zt.signedDistanceFromCamera > 0 ? zt.point : ju($, Ft, gt, 1, _), xt = Ji(u.writingMode, gt, Tr, ne);
            if (xt)
              return xt;
          }
          var Yt = kn(se * O.getoffsetX(u.glyphStartIndex), J, ae, c, q, $, u.segment, u.lineStartIndex, u.lineStartIndex + u.lineLength, k, w, W);
          if (!Yt)
            return { notEnoughRoom: !0 };
          re = [Yt];
        }
        for (var ir = 0, Kt = re; ir < Kt.length; ir += 1) {
          var Xt = Kt[ir];
          o.addDynamicAttributes(R, Xt.point, Xt.angle);
        }
        return {};
      }
      function ju(u, h, c, d, _) {
        var w = yr(u.add(u.sub(h)._unit()), _).point, E = c.sub(w);
        return c.add(E._mult(d / E.mag()));
      }
      function kn(u, h, c, d, _, w, E, O, k, R, q, $) {
        var W = d ? u - h : u + h, ne = W > 0 ? 1 : -1, re = 0;
        d && (ne *= -1, re = Math.PI), ne < 0 && (re += Math.PI);
        for (var se = ne > 0 ? O + E : O + E + 1, J = _, ae = _, pe = 0, _e = 0, Ce = Math.abs(W), Te = []; pe + _e <= Ce; ) {
          if ((se += ne) < O || se >= k)
            return null;
          if (ae = J, Te.push(J), (J = $[se]) === void 0) {
            var Ae = new o.Point(R.getx(se), R.gety(se)), je = yr(Ae, q);
            if (je.signedDistanceFromCamera > 0)
              J = $[se] = je.point;
            else {
              var tt = se - ne;
              J = ju(pe === 0 ? w : new o.Point(R.getx(tt), R.gety(tt)), Ae, ae, Ce - pe + 1, q);
            }
          }
          pe += _e, _e = ae.dist(J);
        }
        var Qe = (Ce - pe) / _e, gt = J.sub(ae), Dt = gt.mult(Qe)._add(ae);
        Dt._add(gt._unit()._perp()._mult(c * ne));
        var Ft = re + Math.atan2(J.y - ae.y, J.x - ae.x);
        return Te.push(Dt), { point: Dt, angle: Ft, path: Te };
      }
      Qt.prototype.keysLength = function() {
        return this.boxKeys.length + this.circleKeys.length;
      }, Qt.prototype.insert = function(u, h, c, d, _) {
        this._forEachCell(h, c, d, _, this._insertBoxCell, this.boxUid++), this.boxKeys.push(u), this.bboxes.push(h), this.bboxes.push(c), this.bboxes.push(d), this.bboxes.push(_);
      }, Qt.prototype.insertCircle = function(u, h, c, d) {
        this._forEachCell(h - d, c - d, h + d, c + d, this._insertCircleCell, this.circleUid++), this.circleKeys.push(u), this.circles.push(h), this.circles.push(c), this.circles.push(d);
      }, Qt.prototype._insertBoxCell = function(u, h, c, d, _, w) {
        this.boxCells[_].push(w);
      }, Qt.prototype._insertCircleCell = function(u, h, c, d, _, w) {
        this.circleCells[_].push(w);
      }, Qt.prototype._query = function(u, h, c, d, _, w) {
        if (c < 0 || u > this.width || d < 0 || h > this.height)
          return !_ && [];
        var E = [];
        if (u <= 0 && h <= 0 && this.width <= c && this.height <= d) {
          if (_)
            return !0;
          for (var O = 0; O < this.boxKeys.length; O++)
            E.push({ key: this.boxKeys[O], x1: this.bboxes[4 * O], y1: this.bboxes[4 * O + 1], x2: this.bboxes[4 * O + 2], y2: this.bboxes[4 * O + 3] });
          for (var k = 0; k < this.circleKeys.length; k++) {
            var R = this.circles[3 * k], q = this.circles[3 * k + 1], $ = this.circles[3 * k + 2];
            E.push({ key: this.circleKeys[k], x1: R - $, y1: q - $, x2: R + $, y2: q + $ });
          }
          return w ? E.filter(w) : E;
        }
        return this._forEachCell(u, h, c, d, this._queryCell, E, { hitTest: _, seenUids: { box: {}, circle: {} } }, w), _ ? E.length > 0 : E;
      }, Qt.prototype._queryCircle = function(u, h, c, d, _) {
        var w = u - c, E = u + c, O = h - c, k = h + c;
        if (E < 0 || w > this.width || k < 0 || O > this.height)
          return !d && [];
        var R = [];
        return this._forEachCell(w, O, E, k, this._queryCellCircle, R, { hitTest: d, circle: { x: u, y: h, radius: c }, seenUids: { box: {}, circle: {} } }, _), d ? R.length > 0 : R;
      }, Qt.prototype.query = function(u, h, c, d, _) {
        return this._query(u, h, c, d, !1, _);
      }, Qt.prototype.hitTest = function(u, h, c, d, _) {
        return this._query(u, h, c, d, !0, _);
      }, Qt.prototype.hitTestCircle = function(u, h, c, d) {
        return this._queryCircle(u, h, c, !0, d);
      }, Qt.prototype._queryCell = function(u, h, c, d, _, w, E, O) {
        var k = E.seenUids, R = this.boxCells[_];
        if (R !== null)
          for (var q = this.bboxes, $ = 0, W = R; $ < W.length; $ += 1) {
            var ne = W[$];
            if (!k.box[ne]) {
              k.box[ne] = !0;
              var re = 4 * ne;
              if (u <= q[re + 2] && h <= q[re + 3] && c >= q[re + 0] && d >= q[re + 1] && (!O || O(this.boxKeys[ne]))) {
                if (E.hitTest)
                  return w.push(!0), !0;
                w.push({ key: this.boxKeys[ne], x1: q[re], y1: q[re + 1], x2: q[re + 2], y2: q[re + 3] });
              }
            }
          }
        var se = this.circleCells[_];
        if (se !== null)
          for (var J = this.circles, ae = 0, pe = se; ae < pe.length; ae += 1) {
            var _e = pe[ae];
            if (!k.circle[_e]) {
              k.circle[_e] = !0;
              var Ce = 3 * _e;
              if (this._circleAndRectCollide(J[Ce], J[Ce + 1], J[Ce + 2], u, h, c, d) && (!O || O(this.circleKeys[_e]))) {
                if (E.hitTest)
                  return w.push(!0), !0;
                var Te = J[Ce], Ae = J[Ce + 1], je = J[Ce + 2];
                w.push({ key: this.circleKeys[_e], x1: Te - je, y1: Ae - je, x2: Te + je, y2: Ae + je });
              }
            }
          }
      }, Qt.prototype._queryCellCircle = function(u, h, c, d, _, w, E, O) {
        var k = E.circle, R = E.seenUids, q = this.boxCells[_];
        if (q !== null)
          for (var $ = this.bboxes, W = 0, ne = q; W < ne.length; W += 1) {
            var re = ne[W];
            if (!R.box[re]) {
              R.box[re] = !0;
              var se = 4 * re;
              if (this._circleAndRectCollide(k.x, k.y, k.radius, $[se + 0], $[se + 1], $[se + 2], $[se + 3]) && (!O || O(this.boxKeys[re])))
                return w.push(!0), !0;
            }
          }
        var J = this.circleCells[_];
        if (J !== null)
          for (var ae = this.circles, pe = 0, _e = J; pe < _e.length; pe += 1) {
            var Ce = _e[pe];
            if (!R.circle[Ce]) {
              R.circle[Ce] = !0;
              var Te = 3 * Ce;
              if (this._circlesCollide(ae[Te], ae[Te + 1], ae[Te + 2], k.x, k.y, k.radius) && (!O || O(this.circleKeys[Ce])))
                return w.push(!0), !0;
            }
          }
      }, Qt.prototype._forEachCell = function(u, h, c, d, _, w, E, O) {
        for (var k = this._convertToXCellCoord(u), R = this._convertToYCellCoord(h), q = this._convertToXCellCoord(c), $ = this._convertToYCellCoord(d), W = k; W <= q; W++)
          for (var ne = R; ne <= $; ne++)
            if (_.call(this, u, h, c, d, this.xCellCount * ne + W, w, E, O))
              return;
      }, Qt.prototype._convertToXCellCoord = function(u) {
        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(u * this.xScale)));
      }, Qt.prototype._convertToYCellCoord = function(u) {
        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(u * this.yScale)));
      }, Qt.prototype._circlesCollide = function(u, h, c, d, _, w) {
        var E = d - u, O = _ - h, k = c + w;
        return k * k > E * E + O * O;
      }, Qt.prototype._circleAndRectCollide = function(u, h, c, d, _, w, E) {
        var O = (w - d) / 2, k = Math.abs(u - (d + O));
        if (k > O + c)
          return !1;
        var R = (E - _) / 2, q = Math.abs(h - (_ + R));
        if (q > R + c)
          return !1;
        if (k <= O || q <= R)
          return !0;
        var $ = k - O, W = q - R;
        return $ * $ + W * W <= c * c;
      };
      var Gu = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function Vi(u, h) {
        for (var c = 0; c < u; c++) {
          var d = h.length;
          h.resize(d + 4), h.float32.set(Gu, 3 * d);
        }
      }
      function mi(u, h, c) {
        var d = h[0], _ = h[1];
        return u[0] = c[0] * d + c[4] * _ + c[12], u[1] = c[1] * d + c[5] * _ + c[13], u[3] = c[3] * d + c[7] * _ + c[15], u;
      }
      var jo = function(u, h, c) {
        h === void 0 && (h = new Qt(u.width + 200, u.height + 200, 25)), c === void 0 && (c = new Qt(u.width + 200, u.height + 200, 25)), this.transform = u, this.grid = h, this.ignoredGrid = c, this.pitchfactor = Math.cos(u._pitch) * u.cameraToCenterDistance, this.screenRightBoundary = u.width + 100, this.screenBottomBoundary = u.height + 100, this.gridRightBoundary = u.width + 200, this.gridBottomBoundary = u.height + 200;
      };
      function dn(u, h, c) {
        return h * (o.EXTENT / (u.tileSize * Math.pow(2, c - u.tileID.overscaledZ)));
      }
      jo.prototype.placeCollisionBox = function(u, h, c, d, _) {
        var w = this.projectAndGetPerspectiveRatio(d, u.anchorPointX, u.anchorPointY), E = c * w.perspectiveRatio, O = u.x1 * E + w.point.x, k = u.y1 * E + w.point.y, R = u.x2 * E + w.point.x, q = u.y2 * E + w.point.y;
        return !this.isInsideGrid(O, k, R, q) || !h && this.grid.hitTest(O, k, R, q, _) ? { box: [], offscreen: !1 } : { box: [O, k, R, q], offscreen: this.isOffscreen(O, k, R, q) };
      }, jo.prototype.placeCollisionCircles = function(u, h, c, d, _, w, E, O, k, R, q, $, W) {
        var ne = [], re = new o.Point(h.anchorX, h.anchorY), se = yr(re, w), J = Rr(this.transform.cameraToCenterDistance, se.signedDistanceFromCamera), ae = (R ? _ / J : _ * J) / o.ONE_EM, pe = yr(re, E).point, _e = di(ae, d, h.lineOffsetX * ae, h.lineOffsetY * ae, !1, pe, re, h, c, E, {}), Ce = !1, Te = !1, Ae = !0;
        if (_e) {
          for (var je = 0.5 * $ * J + W, tt = new o.Point(-100, -100), Qe = new o.Point(this.screenRightBoundary, this.screenBottomBoundary), gt = new Yn(), Dt = _e.first, Ft = _e.last, zt = [], Tr = Dt.path.length - 1; Tr >= 1; Tr--)
            zt.push(Dt.path[Tr]);
          for (var xt = 1; xt < Ft.path.length; xt++)
            zt.push(Ft.path[xt]);
          var Yt = 2.5 * je;
          if (O) {
            var ir = zt.map(function(Zo) {
              return yr(Zo, O);
            });
            zt = ir.some(function(Zo) {
              return Zo.signedDistanceFromCamera <= 0;
            }) ? [] : ir.map(function(Zo) {
              return Zo.point;
            });
          }
          var Kt = [];
          if (zt.length > 0) {
            for (var Xt = zt[0].clone(), nr = zt[0].clone(), Ht = 1; Ht < zt.length; Ht++)
              Xt.x = Math.min(Xt.x, zt[Ht].x), Xt.y = Math.min(Xt.y, zt[Ht].y), nr.x = Math.max(nr.x, zt[Ht].x), nr.y = Math.max(nr.y, zt[Ht].y);
            Kt = Xt.x >= tt.x && nr.x <= Qe.x && Xt.y >= tt.y && nr.y <= Qe.y ? [zt] : nr.x < tt.x || Xt.x > Qe.x || nr.y < tt.y || Xt.y > Qe.y ? [] : o.clipLine([zt], tt.x, tt.y, Qe.x, Qe.y);
          }
          for (var qt = 0, si = Kt; qt < si.length; qt += 1) {
            var In;
            gt.reset(si[qt], 0.25 * je), In = gt.length <= 0.5 * je ? 1 : Math.ceil(gt.paddedLength / Yt) + 1;
            for (var Li = 0; Li < In; Li++) {
              var gi = Li / Math.max(In - 1, 1), Tn = gt.lerp(gi), Ln = Tn.x + 100, mo = Tn.y + 100;
              ne.push(Ln, mo, je, 0);
              var qi = Ln - je, Ms = mo - je, Qi = Ln + je, ca = mo + je;
              if (Ae = Ae && this.isOffscreen(qi, Ms, Qi, ca), Te = Te || this.isInsideGrid(qi, Ms, Qi, ca), !u && this.grid.hitTestCircle(Ln, mo, je, q) && (Ce = !0, !k))
                return { circles: [], offscreen: !1, collisionDetected: Ce };
            }
          }
        }
        return { circles: !k && Ce || !Te ? [] : ne, offscreen: Ae, collisionDetected: Ce };
      }, jo.prototype.queryRenderedSymbols = function(u) {
        if (u.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
          return {};
        for (var h = [], c = 1 / 0, d = 1 / 0, _ = -1 / 0, w = -1 / 0, E = 0, O = u; E < O.length; E += 1) {
          var k = O[E], R = new o.Point(k.x + 100, k.y + 100);
          c = Math.min(c, R.x), d = Math.min(d, R.y), _ = Math.max(_, R.x), w = Math.max(w, R.y), h.push(R);
        }
        for (var q = {}, $ = {}, W = 0, ne = this.grid.query(c, d, _, w).concat(this.ignoredGrid.query(c, d, _, w)); W < ne.length; W += 1) {
          var re = ne[W], se = re.key;
          if (q[se.bucketInstanceId] === void 0 && (q[se.bucketInstanceId] = {}), !q[se.bucketInstanceId][se.featureIndex]) {
            var J = [new o.Point(re.x1, re.y1), new o.Point(re.x2, re.y1), new o.Point(re.x2, re.y2), new o.Point(re.x1, re.y2)];
            o.polygonIntersectsPolygon(h, J) && (q[se.bucketInstanceId][se.featureIndex] = !0, $[se.bucketInstanceId] === void 0 && ($[se.bucketInstanceId] = []), $[se.bucketInstanceId].push(se.featureIndex));
          }
        }
        return $;
      }, jo.prototype.insertCollisionBox = function(u, h, c, d, _) {
        (h ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: c, featureIndex: d, collisionGroupID: _ }, u[0], u[1], u[2], u[3]);
      }, jo.prototype.insertCollisionCircles = function(u, h, c, d, _) {
        for (var w = h ? this.ignoredGrid : this.grid, E = { bucketInstanceId: c, featureIndex: d, collisionGroupID: _ }, O = 0; O < u.length; O += 4)
          w.insertCircle(E, u[O], u[O + 1], u[O + 2]);
      }, jo.prototype.projectAndGetPerspectiveRatio = function(u, h, c) {
        var d = [h, c, 0, 1];
        return mi(d, d, u), { point: new o.Point((d[0] / d[3] + 1) / 2 * this.transform.width + 100, (-d[1] / d[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / d[3] * 0.5 };
      }, jo.prototype.isOffscreen = function(u, h, c, d) {
        return c < 100 || u >= this.screenRightBoundary || d < 100 || h > this.screenBottomBoundary;
      }, jo.prototype.isInsideGrid = function(u, h, c, d) {
        return c >= 0 && u < this.gridRightBoundary && d >= 0 && h < this.gridBottomBoundary;
      }, jo.prototype.getViewportMatrix = function() {
        var u = o.identity([]);
        return o.translate(u, u, [-100, -100, 0]), u;
      };
      var ia = function(u, h, c, d) {
        this.opacity = u ? Math.max(0, Math.min(1, u.opacity + (u.placed ? h : -h))) : d && c ? 1 : 0, this.placed = c;
      };
      ia.prototype.isHidden = function() {
        return this.opacity === 0 && !this.placed;
      };
      var To = function(u, h, c, d, _) {
        this.text = new ia(u ? u.text : null, h, c, _), this.icon = new ia(u ? u.icon : null, h, d, _);
      };
      To.prototype.isHidden = function() {
        return this.text.isHidden() && this.icon.isHidden();
      };
      var nm = function(u, h, c) {
        this.text = u, this.icon = h, this.skipFade = c;
      }, Go = function() {
        this.invProjMatrix = o.create(), this.viewportMatrix = o.create(), this.circles = [];
      }, Lv = function(u, h, c, d, _) {
        this.bucketInstanceId = u, this.featureIndex = h, this.sourceLayerIndex = c, this.bucketIndex = d, this.tileID = _;
      }, Va = function(u) {
        this.crossSourceCollisions = u, this.maxGroupID = 0, this.collisionGroups = {};
      };
      function Ei(u, h, c, d, _) {
        var w = o.getAnchorAlignment(u), E = -(w.horizontalAlign - 0.5) * h, O = -(w.verticalAlign - 0.5) * c, k = o.evaluateVariableOffset(u, d);
        return new o.Point(E + k[0] * _, O + k[1] * _);
      }
      function _a(u, h, c, d, _, w) {
        var E = u.x1, O = u.x2, k = u.y1, R = u.y2, q = u.anchorPointX, $ = u.anchorPointY, W = new o.Point(h, c);
        return d && W._rotate(_ ? w : -w), { x1: E + W.x, y1: k + W.y, x2: O + W.x, y2: R + W.y, anchorPointX: q, anchorPointY: $ };
      }
      Va.prototype.get = function(u) {
        if (this.crossSourceCollisions)
          return { ID: 0, predicate: null };
        if (!this.collisionGroups[u]) {
          var h = ++this.maxGroupID;
          this.collisionGroups[u] = { ID: h, predicate: function(c) {
            return c.collisionGroupID === h;
          } };
        }
        return this.collisionGroups[u];
      };
      var Ui = function(u, h, c, d) {
        this.transform = u.clone(), this.collisionIndex = new jo(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = h, this.retainedQueryData = {}, this.collisionGroups = new Va(c), this.collisionCircleArrays = {}, this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {};
      };
      function rl(u, h, c, d, _) {
        u.emplaceBack(h ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(h ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(h ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(h ? 1 : 0, c ? 1 : 0, d || 0, _ || 0);
      }
      Ui.prototype.getBucketParts = function(u, h, c, d) {
        var _ = c.getBucket(h), w = c.latestFeatureIndex;
        if (_ && w && h.id === _.layerIds[0]) {
          var E = c.collisionBoxArray, O = _.layers[0].layout, k = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), R = c.tileSize / o.EXTENT, q = this.transform.calculatePosMatrix(c.tileID.toUnwrapped()), $ = O.get("text-pitch-alignment") === "map", W = O.get("text-rotation-alignment") === "map", ne = dn(c, 1, this.transform.zoom), re = pn(q, $, W, this.transform, ne), se = null;
          if ($) {
            var J = Br(q, $, W, this.transform, ne);
            se = o.multiply([], this.transform.labelPlaneMatrix, J);
          }
          this.retainedQueryData[_.bucketInstanceId] = new Lv(_.bucketInstanceId, w, _.sourceLayerIndex, _.index, c.tileID);
          var ae = { bucket: _, layout: O, posMatrix: q, textLabelPlaneMatrix: re, labelToScreenMatrix: se, scale: k, textPixelRatio: R, holdingForFade: c.holdingForFade(), collisionBoxArray: E, partiallyEvaluatedTextSize: o.evaluateSizeForZoom(_.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(_.sourceID) };
          if (d)
            for (var pe = 0, _e = _.sortKeyRanges; pe < _e.length; pe += 1) {
              var Ce = _e[pe];
              u.push({ sortKey: Ce.sortKey, symbolInstanceStart: Ce.symbolInstanceStart, symbolInstanceEnd: Ce.symbolInstanceEnd, parameters: ae });
            }
          else
            u.push({ symbolInstanceStart: 0, symbolInstanceEnd: _.symbolInstances.length, parameters: ae });
        }
      }, Ui.prototype.attemptAnchorPlacement = function(u, h, c, d, _, w, E, O, k, R, q, $, W, ne, re) {
        var se, J = [$.textOffset0, $.textOffset1], ae = Ei(u, c, d, J, _), pe = this.collisionIndex.placeCollisionBox(_a(h, ae.x, ae.y, w, E, this.transform.angle), q, O, k, R.predicate);
        if (!re || this.collisionIndex.placeCollisionBox(_a(re, ae.x, ae.y, w, E, this.transform.angle), q, O, k, R.predicate).box.length !== 0)
          return pe.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[$.crossTileID] && this.prevPlacement.placements[$.crossTileID] && this.prevPlacement.placements[$.crossTileID].text && (se = this.prevPlacement.variableOffsets[$.crossTileID].anchor), this.variableOffsets[$.crossTileID] = { textOffset: J, width: c, height: d, anchor: u, textBoxScale: _, prevAnchor: se }, this.markUsedJustification(W, u, $, ne), W.allowVerticalPlacement && (this.markUsedOrientation(W, ne, $), this.placedOrientations[$.crossTileID] = ne), { shift: ae, placedGlyphBoxes: pe }) : void 0;
      }, Ui.prototype.placeLayerBucketPart = function(u, h, c) {
        var d = this, _ = u.parameters, w = _.bucket, E = _.layout, O = _.posMatrix, k = _.textLabelPlaneMatrix, R = _.labelToScreenMatrix, q = _.textPixelRatio, $ = _.holdingForFade, W = _.collisionBoxArray, ne = _.partiallyEvaluatedTextSize, re = _.collisionGroup, se = E.get("text-optional"), J = E.get("icon-optional"), ae = E.get("text-allow-overlap"), pe = E.get("icon-allow-overlap"), _e = E.get("text-rotation-alignment") === "map", Ce = E.get("text-pitch-alignment") === "map", Te = E.get("icon-text-fit") !== "none", Ae = E.get("symbol-z-order") === "viewport-y", je = ae && (pe || !w.hasIconData() || J), tt = pe && (ae || !w.hasTextData() || se);
        !w.collisionArrays && W && w.deserializeCollisionBoxes(W);
        var Qe = function(xt, Yt) {
          if (!h[xt.crossTileID])
            if ($)
              d.placements[xt.crossTileID] = new nm(!1, !1, !1);
            else {
              var ir, Kt = !1, Xt = !1, nr = !0, Ht = null, qt = { box: null, offscreen: null }, si = { box: null, offscreen: null }, In = null, Li = null, gi = 0, Tn = 0, Ln = 0;
              Yt.textFeatureIndex ? gi = Yt.textFeatureIndex : xt.useRuntimeCollisionCircles && (gi = xt.featureIndex), Yt.verticalTextFeatureIndex && (Tn = Yt.verticalTextFeatureIndex);
              var mo = Yt.textBox;
              if (mo) {
                var qi = function(zr) {
                  var Oo = o.WritingMode.horizontal;
                  if (w.allowVerticalPlacement && !zr && d.prevPlacement) {
                    var eo = d.prevPlacement.placedOrientations[xt.crossTileID];
                    eo && (d.placedOrientations[xt.crossTileID] = eo, d.markUsedOrientation(w, Oo = eo, xt));
                  }
                  return Oo;
                }, Ms = function(zr, Oo) {
                  if (w.allowVerticalPlacement && xt.numVerticalGlyphVertices > 0 && Yt.verticalTextBox)
                    for (var eo = 0, xl = w.writingModes; eo < xl.length && (xl[eo] === o.WritingMode.vertical ? (qt = Oo(), si = qt) : qt = zr(), !(qt && qt.box && qt.box.length)); eo += 1)
                      ;
                  else
                    qt = zr();
                };
                if (E.get("text-variable-anchor")) {
                  var Qi = E.get("text-variable-anchor");
                  if (d.prevPlacement && d.prevPlacement.variableOffsets[xt.crossTileID]) {
                    var ca = d.prevPlacement.variableOffsets[xt.crossTileID];
                    Qi.indexOf(ca.anchor) > 0 && (Qi = Qi.filter(function(zr) {
                      return zr !== ca.anchor;
                    })).unshift(ca.anchor);
                  }
                  var Zo = function(zr, Oo, eo) {
                    for (var xl = zr.x2 - zr.x1, Hv = zr.y2 - zr.y1, Eh = xt.textBoxScale, Zv = Te && !pe ? Oo : null, cc = { box: [], offscreen: !1 }, Dm = ae ? 2 * Qi.length : Qi.length, iu = 0; iu < Dm; ++iu) {
                      var Sh = d.attemptAnchorPlacement(Qi[iu % Qi.length], zr, xl, Hv, Eh, _e, Ce, q, O, re, iu >= Qi.length, xt, w, eo, Zv);
                      if (Sh && (cc = Sh.placedGlyphBoxes) && cc.box && cc.box.length) {
                        Kt = !0, Ht = Sh.shift;
                        break;
                      }
                    }
                    return cc;
                  };
                  Ms(function() {
                    return Zo(mo, Yt.iconBox, o.WritingMode.horizontal);
                  }, function() {
                    var zr = Yt.verticalTextBox;
                    return w.allowVerticalPlacement && !(qt && qt.box && qt.box.length) && xt.numVerticalGlyphVertices > 0 && zr ? Zo(zr, Yt.verticalIconBox, o.WritingMode.vertical) : { box: null, offscreen: null };
                  }), qt && (Kt = qt.box, nr = qt.offscreen);
                  var sc = qi(qt && qt.box);
                  if (!Kt && d.prevPlacement) {
                    var ru = d.prevPlacement.variableOffsets[xt.crossTileID];
                    ru && (d.variableOffsets[xt.crossTileID] = ru, d.markUsedJustification(w, ru.anchor, xt, sc));
                  }
                } else {
                  var Is = function(zr, Oo) {
                    var eo = d.collisionIndex.placeCollisionBox(zr, ae, q, O, re.predicate);
                    return eo && eo.box && eo.box.length && (d.markUsedOrientation(w, Oo, xt), d.placedOrientations[xt.crossTileID] = Oo), eo;
                  };
                  Ms(function() {
                    return Is(mo, o.WritingMode.horizontal);
                  }, function() {
                    var zr = Yt.verticalTextBox;
                    return w.allowVerticalPlacement && xt.numVerticalGlyphVertices > 0 && zr ? Is(zr, o.WritingMode.vertical) : { box: null, offscreen: null };
                  }), qi(qt && qt.box && qt.box.length);
                }
              }
              if (Kt = (ir = qt) && ir.box && ir.box.length > 0, nr = ir && ir.offscreen, xt.useRuntimeCollisionCircles) {
                var nu = w.text.placedSymbolArray.get(xt.centerJustifiedTextSymbolIndex), lc = o.evaluateSizeForFeature(w.textSizeData, ne, nu), Ea = E.get("text-padding");
                In = d.collisionIndex.placeCollisionCircles(ae, nu, w.lineVertexArray, w.glyphOffsetArray, lc, O, k, R, c, Ce, re.predicate, xt.collisionCircleDiameter, Ea), Kt = ae || In.circles.length > 0 && !In.collisionDetected, nr = nr && In.offscreen;
              }
              if (Yt.iconFeatureIndex && (Ln = Yt.iconFeatureIndex), Yt.iconBox) {
                var uc = function(zr) {
                  var Oo = Te && Ht ? _a(zr, Ht.x, Ht.y, _e, Ce, d.transform.angle) : zr;
                  return d.collisionIndex.placeCollisionBox(Oo, pe, q, O, re.predicate);
                };
                Xt = si && si.box && si.box.length && Yt.verticalIconBox ? (Li = uc(Yt.verticalIconBox)).box.length > 0 : (Li = uc(Yt.iconBox)).box.length > 0, nr = nr && Li.offscreen;
              }
              var Sa = se || xt.numHorizontalGlyphVertices === 0 && xt.numVerticalGlyphVertices === 0, li = J || xt.numIconVertices === 0;
              if (Sa || li ? li ? Sa || (Xt = Xt && Kt) : Kt = Xt && Kt : Xt = Kt = Xt && Kt, Kt && ir && ir.box && d.collisionIndex.insertCollisionBox(ir.box, E.get("text-ignore-placement"), w.bucketInstanceId, si && si.box && Tn ? Tn : gi, re.ID), Xt && Li && d.collisionIndex.insertCollisionBox(Li.box, E.get("icon-ignore-placement"), w.bucketInstanceId, Ln, re.ID), In && (Kt && d.collisionIndex.insertCollisionCircles(In.circles, E.get("text-ignore-placement"), w.bucketInstanceId, gi, re.ID), c)) {
                var qa = w.bucketInstanceId, Os = d.collisionCircleArrays[qa];
                Os === void 0 && (Os = d.collisionCircleArrays[qa] = new Go());
                for (var _l = 0; _l < In.circles.length; _l += 4)
                  Os.circles.push(In.circles[_l + 0]), Os.circles.push(In.circles[_l + 1]), Os.circles.push(In.circles[_l + 2]), Os.circles.push(In.collisionDetected ? 1 : 0);
              }
              d.placements[xt.crossTileID] = new nm(Kt || je, Xt || tt, nr || w.justReloaded), h[xt.crossTileID] = !0;
            }
        };
        if (Ae)
          for (var gt = w.getSortedSymbolIndexes(this.transform.angle), Dt = gt.length - 1; Dt >= 0; --Dt) {
            var Ft = gt[Dt];
            Qe(w.symbolInstances.get(Ft), w.collisionArrays[Ft]);
          }
        else
          for (var zt = u.symbolInstanceStart; zt < u.symbolInstanceEnd; zt++)
            Qe(w.symbolInstances.get(zt), w.collisionArrays[zt]);
        if (c && w.bucketInstanceId in this.collisionCircleArrays) {
          var Tr = this.collisionCircleArrays[w.bucketInstanceId];
          o.invert(Tr.invProjMatrix, O), Tr.viewportMatrix = this.collisionIndex.getViewportMatrix();
        }
        w.justReloaded = !1;
      }, Ui.prototype.markUsedJustification = function(u, h, c, d) {
        var _;
        _ = d === o.WritingMode.vertical ? c.verticalPlacedTextSymbolIndex : { left: c.leftJustifiedTextSymbolIndex, center: c.centerJustifiedTextSymbolIndex, right: c.rightJustifiedTextSymbolIndex }[o.getAnchorJustification(h)];
        for (var w = 0, E = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex]; w < E.length; w += 1) {
          var O = E[w];
          O >= 0 && (u.text.placedSymbolArray.get(O).crossTileID = _ >= 0 && O !== _ ? 0 : c.crossTileID);
        }
      }, Ui.prototype.markUsedOrientation = function(u, h, c) {
        for (var d = h === o.WritingMode.horizontal || h === o.WritingMode.horizontalOnly ? h : 0, _ = h === o.WritingMode.vertical ? h : 0, w = 0, E = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex]; w < E.length; w += 1)
          u.text.placedSymbolArray.get(E[w]).placedOrientation = d;
        c.verticalPlacedTextSymbolIndex && (u.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = _);
      }, Ui.prototype.commit = function(u) {
        this.commitTime = u, this.zoomAtLastRecencyCheck = this.transform.zoom;
        var h = this.prevPlacement, c = !1;
        this.prevZoomAdjustment = h ? h.zoomAdjustment(this.transform.zoom) : 0;
        var d = h ? h.symbolFadeChange(u) : 1, _ = h ? h.opacities : {}, w = h ? h.variableOffsets : {}, E = h ? h.placedOrientations : {};
        for (var O in this.placements) {
          var k = this.placements[O], R = _[O];
          R ? (this.opacities[O] = new To(R, d, k.text, k.icon), c = c || k.text !== R.text.placed || k.icon !== R.icon.placed) : (this.opacities[O] = new To(null, d, k.text, k.icon, k.skipFade), c = c || k.text || k.icon);
        }
        for (var q in _) {
          var $ = _[q];
          if (!this.opacities[q]) {
            var W = new To($, d, !1, !1);
            W.isHidden() || (this.opacities[q] = W, c = c || $.text.placed || $.icon.placed);
          }
        }
        for (var ne in w)
          this.variableOffsets[ne] || !this.opacities[ne] || this.opacities[ne].isHidden() || (this.variableOffsets[ne] = w[ne]);
        for (var re in E)
          this.placedOrientations[re] || !this.opacities[re] || this.opacities[re].isHidden() || (this.placedOrientations[re] = E[re]);
        c ? this.lastPlacementChangeTime = u : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = h ? h.lastPlacementChangeTime : u);
      }, Ui.prototype.updateLayerOpacities = function(u, h) {
        for (var c = {}, d = 0, _ = h; d < _.length; d += 1) {
          var w = _[d], E = w.getBucket(u);
          E && w.latestFeatureIndex && u.id === E.layerIds[0] && this.updateBucketOpacities(E, c, w.collisionBoxArray);
        }
      }, Ui.prototype.updateBucketOpacities = function(u, h, c) {
        var d = this;
        u.hasTextData() && u.text.opacityVertexArray.clear(), u.hasIconData() && u.icon.opacityVertexArray.clear(), u.hasIconCollisionBoxData() && u.iconCollisionBox.collisionVertexArray.clear(), u.hasTextCollisionBoxData() && u.textCollisionBox.collisionVertexArray.clear();
        var _ = u.layers[0].layout, w = new To(null, 0, !1, !1, !0), E = _.get("text-allow-overlap"), O = _.get("icon-allow-overlap"), k = _.get("text-variable-anchor"), R = _.get("text-rotation-alignment") === "map", q = _.get("text-pitch-alignment") === "map", $ = _.get("icon-text-fit") !== "none", W = new To(null, 0, E && (O || !u.hasIconData() || _.get("icon-optional")), O && (E || !u.hasTextData() || _.get("text-optional")), !0);
        !u.collisionArrays && c && (u.hasIconCollisionBoxData() || u.hasTextCollisionBoxData()) && u.deserializeCollisionBoxes(c);
        for (var ne = function(ae, pe, _e) {
          for (var Ce = 0; Ce < pe / 4; Ce++)
            ae.opacityVertexArray.emplaceBack(_e);
        }, re = function(ae) {
          var pe = u.symbolInstances.get(ae), _e = pe.numHorizontalGlyphVertices, Ce = pe.numVerticalGlyphVertices, Te = pe.crossTileID, Ae = d.opacities[Te];
          h[Te] ? Ae = w : Ae || (d.opacities[Te] = Ae = W), h[Te] = !0;
          var je = pe.numIconVertices > 0, tt = d.placedOrientations[pe.crossTileID], Qe = tt === o.WritingMode.vertical, gt = tt === o.WritingMode.horizontal || tt === o.WritingMode.horizontalOnly;
          if (_e > 0 || Ce > 0) {
            var Dt = am(Ae.text);
            ne(u.text, _e, Qe ? $l : Dt), ne(u.text, Ce, gt ? $l : Dt);
            var Ft = Ae.text.isHidden();
            [pe.rightJustifiedTextSymbolIndex, pe.centerJustifiedTextSymbolIndex, pe.leftJustifiedTextSymbolIndex].forEach(function(qt) {
              qt >= 0 && (u.text.placedSymbolArray.get(qt).hidden = Ft || Qe ? 1 : 0);
            }), pe.verticalPlacedTextSymbolIndex >= 0 && (u.text.placedSymbolArray.get(pe.verticalPlacedTextSymbolIndex).hidden = Ft || gt ? 1 : 0);
            var zt = d.variableOffsets[pe.crossTileID];
            zt && d.markUsedJustification(u, zt.anchor, pe, tt);
            var Tr = d.placedOrientations[pe.crossTileID];
            Tr && (d.markUsedJustification(u, "left", pe, Tr), d.markUsedOrientation(u, Tr, pe));
          }
          if (je) {
            var xt = am(Ae.icon), Yt = !($ && pe.verticalPlacedIconSymbolIndex && Qe);
            pe.placedIconSymbolIndex >= 0 && (ne(u.icon, pe.numIconVertices, Yt ? xt : $l), u.icon.placedSymbolArray.get(pe.placedIconSymbolIndex).hidden = Ae.icon.isHidden()), pe.verticalPlacedIconSymbolIndex >= 0 && (ne(u.icon, pe.numVerticalIconVertices, Yt ? $l : xt), u.icon.placedSymbolArray.get(pe.verticalPlacedIconSymbolIndex).hidden = Ae.icon.isHidden());
          }
          if (u.hasIconCollisionBoxData() || u.hasTextCollisionBoxData()) {
            var ir = u.collisionArrays[ae];
            if (ir) {
              var Kt = new o.Point(0, 0);
              if (ir.textBox || ir.verticalTextBox) {
                var Xt = !0;
                if (k) {
                  var nr = d.variableOffsets[Te];
                  nr ? (Kt = Ei(nr.anchor, nr.width, nr.height, nr.textOffset, nr.textBoxScale), R && Kt._rotate(q ? d.transform.angle : -d.transform.angle)) : Xt = !1;
                }
                ir.textBox && rl(u.textCollisionBox.collisionVertexArray, Ae.text.placed, !Xt || Qe, Kt.x, Kt.y), ir.verticalTextBox && rl(u.textCollisionBox.collisionVertexArray, Ae.text.placed, !Xt || gt, Kt.x, Kt.y);
              }
              var Ht = Boolean(!gt && ir.verticalIconBox);
              ir.iconBox && rl(u.iconCollisionBox.collisionVertexArray, Ae.icon.placed, Ht, $ ? Kt.x : 0, $ ? Kt.y : 0), ir.verticalIconBox && rl(u.iconCollisionBox.collisionVertexArray, Ae.icon.placed, !Ht, $ ? Kt.x : 0, $ ? Kt.y : 0);
            }
          }
        }, se = 0; se < u.symbolInstances.length; se++)
          re(se);
        if (u.sortFeatures(this.transform.angle), this.retainedQueryData[u.bucketInstanceId] && (this.retainedQueryData[u.bucketInstanceId].featureSortOrder = u.featureSortOrder), u.hasTextData() && u.text.opacityVertexBuffer && u.text.opacityVertexBuffer.updateData(u.text.opacityVertexArray), u.hasIconData() && u.icon.opacityVertexBuffer && u.icon.opacityVertexBuffer.updateData(u.icon.opacityVertexArray), u.hasIconCollisionBoxData() && u.iconCollisionBox.collisionVertexBuffer && u.iconCollisionBox.collisionVertexBuffer.updateData(u.iconCollisionBox.collisionVertexArray), u.hasTextCollisionBoxData() && u.textCollisionBox.collisionVertexBuffer && u.textCollisionBox.collisionVertexBuffer.updateData(u.textCollisionBox.collisionVertexArray), u.bucketInstanceId in this.collisionCircleArrays) {
          var J = this.collisionCircleArrays[u.bucketInstanceId];
          u.placementInvProjMatrix = J.invProjMatrix, u.placementViewportMatrix = J.viewportMatrix, u.collisionCircleArray = J.circles, delete this.collisionCircleArrays[u.bucketInstanceId];
        }
      }, Ui.prototype.symbolFadeChange = function(u) {
        return this.fadeDuration === 0 ? 1 : (u - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
      }, Ui.prototype.zoomAdjustment = function(u) {
        return Math.max(0, (this.transform.zoom - u) / 1.5);
      }, Ui.prototype.hasTransitions = function(u) {
        return this.stale || u - this.lastPlacementChangeTime < this.fadeDuration;
      }, Ui.prototype.stillRecent = function(u, h) {
        var c = this.zoomAtLastRecencyCheck === h ? 1 - this.zoomAdjustment(h) : 1;
        return this.zoomAtLastRecencyCheck = h, this.commitTime + this.fadeDuration * c > u;
      }, Ui.prototype.setStale = function() {
        this.stale = !0;
      };
      var Dv = Math.pow(2, 25), Nv = Math.pow(2, 24), $f = Math.pow(2, 17), Rv = Math.pow(2, 16), im = Math.pow(2, 9), zv = Math.pow(2, 8), om = Math.pow(2, 1);
      function am(u) {
        if (u.opacity === 0 && !u.placed)
          return 0;
        if (u.opacity === 1 && u.placed)
          return 4294967295;
        var h = u.placed ? 1 : 0, c = Math.floor(127 * u.opacity);
        return c * Dv + h * Nv + c * $f + h * Rv + c * im + h * zv + c * om + h;
      }
      var $l = 0, Wf = function(u) {
        this._sortAcrossTiles = u.layout.get("symbol-z-order") !== "viewport-y" && u.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
      };
      Wf.prototype.continuePlacement = function(u, h, c, d, _) {
        for (var w = this._bucketParts; this._currentTileIndex < u.length; )
          if (h.getBucketParts(w, d, u[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, _())
            return !0;
        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, w.sort(function(E, O) {
          return E.sortKey - O.sortKey;
        })); this._currentPartIndex < w.length; )
          if (h.placeLayerBucketPart(w[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, _())
            return !0;
        return !1;
      };
      var qu = function(u, h, c, d, _, w, E) {
        this.placement = new Ui(u, _, w, E), this._currentPlacementIndex = h.length - 1, this._forceFullPlacement = c, this._showCollisionBoxes = d, this._done = !1;
      };
      qu.prototype.isDone = function() {
        return this._done;
      }, qu.prototype.continuePlacement = function(u, h, c) {
        for (var d = this, _ = o.browser.now(), w = function() {
          var k = o.browser.now() - _;
          return !d._forceFullPlacement && k > 2;
        }; this._currentPlacementIndex >= 0; ) {
          var E = h[u[this._currentPlacementIndex]], O = this.placement.collisionIndex.transform.zoom;
          if (E.type === "symbol" && (!E.minzoom || E.minzoom <= O) && (!E.maxzoom || E.maxzoom > O)) {
            if (this._inProgressLayer || (this._inProgressLayer = new Wf(E)), this._inProgressLayer.continuePlacement(c[E.source], this.placement, this._showCollisionBoxes, E, w))
              return;
            delete this._inProgressLayer;
          }
          this._currentPlacementIndex--;
        }
        this._done = !0;
      }, qu.prototype.commit = function(u) {
        return this.placement.commit(u), this.placement;
      };
      var sm = 512 / o.EXTENT / 2, nh = function(u, h, c) {
        this.tileID = u, this.indexedSymbolInstances = {}, this.bucketInstanceId = c;
        for (var d = 0; d < h.length; d++) {
          var _ = h.get(d), w = _.key;
          this.indexedSymbolInstances[w] || (this.indexedSymbolInstances[w] = []), this.indexedSymbolInstances[w].push({ crossTileID: _.crossTileID, coord: this.getScaledCoordinates(_, u) });
        }
      };
      nh.prototype.getScaledCoordinates = function(u, h) {
        var c = sm / Math.pow(2, h.canonical.z - this.tileID.canonical.z);
        return { x: Math.floor((h.canonical.x * o.EXTENT + u.anchorX) * c), y: Math.floor((h.canonical.y * o.EXTENT + u.anchorY) * c) };
      }, nh.prototype.findMatches = function(u, h, c) {
        for (var d = this.tileID.canonical.z < h.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - h.canonical.z), _ = 0; _ < u.length; _++) {
          var w = u.get(_);
          if (!w.crossTileID) {
            var E = this.indexedSymbolInstances[w.key];
            if (E)
              for (var O = this.getScaledCoordinates(w, h), k = 0, R = E; k < R.length; k += 1) {
                var q = R[k];
                if (Math.abs(q.coord.x - O.x) <= d && Math.abs(q.coord.y - O.y) <= d && !c[q.crossTileID]) {
                  c[q.crossTileID] = !0, w.crossTileID = q.crossTileID;
                  break;
                }
              }
          }
        }
      };
      var qo = function() {
        this.maxCrossTileID = 0;
      };
      qo.prototype.generate = function() {
        return ++this.maxCrossTileID;
      };
      var fs = function() {
        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
      };
      fs.prototype.handleWrapJump = function(u) {
        var h = Math.round((u - this.lng) / 360);
        if (h !== 0)
          for (var c in this.indexes) {
            var d = this.indexes[c], _ = {};
            for (var w in d) {
              var E = d[w];
              E.tileID = E.tileID.unwrapTo(E.tileID.wrap + h), _[E.tileID.key] = E;
            }
            this.indexes[c] = _;
          }
        this.lng = u;
      }, fs.prototype.addBucket = function(u, h, c) {
        if (this.indexes[u.overscaledZ] && this.indexes[u.overscaledZ][u.key]) {
          if (this.indexes[u.overscaledZ][u.key].bucketInstanceId === h.bucketInstanceId)
            return !1;
          this.removeBucketCrossTileIDs(u.overscaledZ, this.indexes[u.overscaledZ][u.key]);
        }
        for (var d = 0; d < h.symbolInstances.length; d++)
          h.symbolInstances.get(d).crossTileID = 0;
        this.usedCrossTileIDs[u.overscaledZ] || (this.usedCrossTileIDs[u.overscaledZ] = {});
        var _ = this.usedCrossTileIDs[u.overscaledZ];
        for (var w in this.indexes) {
          var E = this.indexes[w];
          if (Number(w) > u.overscaledZ)
            for (var O in E) {
              var k = E[O];
              k.tileID.isChildOf(u) && k.findMatches(h.symbolInstances, u, _);
            }
          else {
            var R = E[u.scaledTo(Number(w)).key];
            R && R.findMatches(h.symbolInstances, u, _);
          }
        }
        for (var q = 0; q < h.symbolInstances.length; q++) {
          var $ = h.symbolInstances.get(q);
          $.crossTileID || ($.crossTileID = c.generate(), _[$.crossTileID] = !0);
        }
        return this.indexes[u.overscaledZ] === void 0 && (this.indexes[u.overscaledZ] = {}), this.indexes[u.overscaledZ][u.key] = new nh(u, h.symbolInstances, h.bucketInstanceId), !0;
      }, fs.prototype.removeBucketCrossTileIDs = function(u, h) {
        for (var c in h.indexedSymbolInstances)
          for (var d = 0, _ = h.indexedSymbolInstances[c]; d < _.length; d += 1)
            delete this.usedCrossTileIDs[u][_[d].crossTileID];
      }, fs.prototype.removeStaleBuckets = function(u) {
        var h = !1;
        for (var c in this.indexes) {
          var d = this.indexes[c];
          for (var _ in d)
            u[d[_].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, d[_]), delete d[_], h = !0);
        }
        return h;
      };
      var ps = function() {
        this.layerIndexes = {}, this.crossTileIDs = new qo(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
      };
      ps.prototype.addLayer = function(u, h, c) {
        var d = this.layerIndexes[u.id];
        d === void 0 && (d = this.layerIndexes[u.id] = new fs());
        var _ = !1, w = {};
        d.handleWrapJump(c);
        for (var E = 0, O = h; E < O.length; E += 1) {
          var k = O[E], R = k.getBucket(u);
          R && u.id === R.layerIds[0] && (R.bucketInstanceId || (R.bucketInstanceId = ++this.maxBucketInstanceId), d.addBucket(k.tileID, R, this.crossTileIDs) && (_ = !0), w[R.bucketInstanceId] = !0);
        }
        return d.removeStaleBuckets(w) && (_ = !0), _;
      }, ps.prototype.pruneUnusedLayers = function(u) {
        var h = {};
        for (var c in u.forEach(function(d) {
          h[d] = !0;
        }), this.layerIndexes)
          h[c] || delete this.layerIndexes[c];
      };
      var nl = function(u, h) {
        return o.emitValidationErrors(u, h && h.filter(function(c) {
          return c.identifier !== "source.canvas";
        }));
      }, ds = o.pick(ke, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), ms = o.pick(ke, ["setCenter", "setZoom", "setBearing", "setPitch"]), ih = function() {
        var u = {}, h = o.styleSpec.$version;
        for (var c in o.styleSpec.$root) {
          var d, _ = o.styleSpec.$root[c];
          _.required && (d = c === "version" ? h : _.type === "array" ? [] : {}) != null && (u[c] = d);
        }
        return u;
      }(), lo = function(u) {
        function h(c, d) {
          var _ = this;
          d === void 0 && (d = {}), u.call(this), this.map = c, this.dispatcher = new xe(Pe(), this), this.imageManager = new Y(), this.imageManager.setEventedParent(this), this.glyphManager = new Ee(c._requestManager, d.localIdeographFontFamily), this.lineAtlas = new yt(256, 512), this.crossTileSymbolIndex = new ps(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", o.getReferrer());
          var w = this;
          this._rtlTextPluginCallback = h.registerForPluginStateChange(function(E) {
            w.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: E.pluginStatus, pluginURL: E.pluginURL }, function(O, k) {
              if (o.triggerPluginCompletionEvent(O), k && k.every(function(q) {
                return q;
              }))
                for (var R in w.sourceCaches)
                  w.sourceCaches[R].reload();
            });
          }), this.on("data", function(E) {
            if (E.dataType === "source" && E.sourceDataType === "metadata") {
              var O = _.sourceCaches[E.sourceId];
              if (O) {
                var k = O.getSource();
                if (k && k.vectorLayerIds)
                  for (var R in _._layers) {
                    var q = _._layers[R];
                    q.source === k.id && _._validateLayer(q);
                  }
              }
            }
          });
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.loadURL = function(c, d) {
          var _ = this;
          d === void 0 && (d = {}), this.fire(new o.Event("dataloading", { dataType: "style" }));
          var w = typeof d.validate == "boolean" ? d.validate : !o.isMapboxURL(c);
          c = this.map._requestManager.normalizeStyleURL(c, d.accessToken);
          var E = this.map._requestManager.transformRequest(c, o.ResourceType.Style);
          this._request = o.getJSON(E, function(O, k) {
            _._request = null, O ? _.fire(new o.ErrorEvent(O)) : k && _._load(k, w);
          });
        }, h.prototype.loadJSON = function(c, d) {
          var _ = this;
          d === void 0 && (d = {}), this.fire(new o.Event("dataloading", { dataType: "style" })), this._request = o.browser.frame(function() {
            _._request = null, _._load(c, d.validate !== !1);
          });
        }, h.prototype.loadEmpty = function() {
          this.fire(new o.Event("dataloading", { dataType: "style" })), this._load(ih, !1);
        }, h.prototype._load = function(c, d) {
          if (!d || !nl(this, o.validateStyle(c))) {
            for (var _ in this._loaded = !0, this.stylesheet = c, c.sources)
              this.addSource(_, c.sources[_], { validate: !1 });
            c.sprite ? this._loadSprite(c.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(c.glyphs);
            var w = ot(this.stylesheet.layers);
            this._order = w.map(function(R) {
              return R.id;
            }), this._layers = {}, this._serializedLayers = {};
            for (var E = 0, O = w; E < O.length; E += 1) {
              var k = O[E];
              (k = o.createStyleLayer(k)).setEventedParent(this, { layer: { id: k.id } }), this._layers[k.id] = k, this._serializedLayers[k.id] = k.serialize();
            }
            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new Ze(this.stylesheet.light), this.fire(new o.Event("data", { dataType: "style" })), this.fire(new o.Event("style.load"));
          }
        }, h.prototype._loadSprite = function(c) {
          var d = this;
          this._spriteRequest = function(_, w, E) {
            var O, k, R, q = o.browser.devicePixelRatio > 1 ? "@2x" : "", $ = o.getJSON(w.transformRequest(w.normalizeSpriteURL(_, q, ".json"), o.ResourceType.SpriteJSON), function(re, se) {
              $ = null, R || (R = re, O = se, ne());
            }), W = o.getImage(w.transformRequest(w.normalizeSpriteURL(_, q, ".png"), o.ResourceType.SpriteImage), function(re, se) {
              W = null, R || (R = re, k = se, ne());
            });
            function ne() {
              if (R)
                E(R);
              else if (O && k) {
                var re = o.browser.getImageData(k), se = {};
                for (var J in O) {
                  var ae = O[J], pe = ae.width, _e = ae.height, Ce = ae.x, Te = ae.y, Ae = ae.sdf, je = ae.pixelRatio, tt = ae.stretchX, Qe = ae.stretchY, gt = ae.content, Dt = new o.RGBAImage({ width: pe, height: _e });
                  o.RGBAImage.copy(re, Dt, { x: Ce, y: Te }, { x: 0, y: 0 }, { width: pe, height: _e }), se[J] = { data: Dt, pixelRatio: je, sdf: Ae, stretchX: tt, stretchY: Qe, content: gt };
                }
                E(null, se);
              }
            }
            return { cancel: function() {
              $ && ($.cancel(), $ = null), W && (W.cancel(), W = null);
            } };
          }(c, this.map._requestManager, function(_, w) {
            if (d._spriteRequest = null, _)
              d.fire(new o.ErrorEvent(_));
            else if (w)
              for (var E in w)
                d.imageManager.addImage(E, w[E]);
            d.imageManager.setLoaded(!0), d._availableImages = d.imageManager.listImages(), d.dispatcher.broadcast("setImages", d._availableImages), d.fire(new o.Event("data", { dataType: "style" }));
          });
        }, h.prototype._validateLayer = function(c) {
          var d = this.sourceCaches[c.source];
          if (d) {
            var _ = c.sourceLayer;
            if (_) {
              var w = d.getSource();
              (w.type === "geojson" || w.vectorLayerIds && w.vectorLayerIds.indexOf(_) === -1) && this.fire(new o.ErrorEvent(new Error('Source layer "' + _ + '" does not exist on source "' + w.id + '" as specified by style layer "' + c.id + '"')));
            }
          }
        }, h.prototype.loaded = function() {
          if (!this._loaded || Object.keys(this._updatedSources).length)
            return !1;
          for (var c in this.sourceCaches)
            if (!this.sourceCaches[c].loaded())
              return !1;
          return !!this.imageManager.isLoaded();
        }, h.prototype._serializeLayers = function(c) {
          for (var d = [], _ = 0, w = c; _ < w.length; _ += 1) {
            var E = this._layers[w[_]];
            E.type !== "custom" && d.push(E.serialize());
          }
          return d;
        }, h.prototype.hasTransitions = function() {
          if (this.light && this.light.hasTransition())
            return !0;
          for (var c in this.sourceCaches)
            if (this.sourceCaches[c].hasTransition())
              return !0;
          for (var d in this._layers)
            if (this._layers[d].hasTransition())
              return !0;
          return !1;
        }, h.prototype._checkLoaded = function() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }, h.prototype.update = function(c) {
          if (this._loaded) {
            var d = this._changed;
            if (this._changed) {
              var _ = Object.keys(this._updatedLayers), w = Object.keys(this._removedLayers);
              for (var E in (_.length || w.length) && this._updateWorkerLayers(_, w), this._updatedSources) {
                var O = this._updatedSources[E];
                O === "reload" ? this._reloadSource(E) : O === "clear" && this._clearSource(E);
              }
              for (var k in this._updateTilesForChangedImages(), this._updatedPaintProps)
                this._layers[k].updateTransitions(c);
              this.light.updateTransitions(c), this._resetUpdates();
            }
            var R = {};
            for (var q in this.sourceCaches) {
              var $ = this.sourceCaches[q];
              R[q] = $.used, $.used = !1;
            }
            for (var W = 0, ne = this._order; W < ne.length; W += 1) {
              var re = this._layers[ne[W]];
              re.recalculate(c, this._availableImages), !re.isHidden(c.zoom) && re.source && (this.sourceCaches[re.source].used = !0);
            }
            for (var se in R) {
              var J = this.sourceCaches[se];
              R[se] !== J.used && J.fire(new o.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: se }));
            }
            this.light.recalculate(c), this.z = c.zoom, d && this.fire(new o.Event("data", { dataType: "style" }));
          }
        }, h.prototype._updateTilesForChangedImages = function() {
          var c = Object.keys(this._changedImages);
          if (c.length) {
            for (var d in this.sourceCaches)
              this.sourceCaches[d].reloadTilesForDependencies(["icons", "patterns"], c);
            this._changedImages = {};
          }
        }, h.prototype._updateWorkerLayers = function(c, d) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(c), removedIds: d });
        }, h.prototype._resetUpdates = function() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
        }, h.prototype.setState = function(c) {
          var d = this;
          if (this._checkLoaded(), nl(this, o.validateStyle(c)))
            return !1;
          (c = o.clone$1(c)).layers = ot(c.layers);
          var _ = function(E, O) {
            if (!E)
              return [{ command: ke.setStyle, args: [O] }];
            var k = [];
            try {
              if (!o.deepEqual(E.version, O.version))
                return [{ command: ke.setStyle, args: [O] }];
              o.deepEqual(E.center, O.center) || k.push({ command: ke.setCenter, args: [O.center] }), o.deepEqual(E.zoom, O.zoom) || k.push({ command: ke.setZoom, args: [O.zoom] }), o.deepEqual(E.bearing, O.bearing) || k.push({ command: ke.setBearing, args: [O.bearing] }), o.deepEqual(E.pitch, O.pitch) || k.push({ command: ke.setPitch, args: [O.pitch] }), o.deepEqual(E.sprite, O.sprite) || k.push({ command: ke.setSprite, args: [O.sprite] }), o.deepEqual(E.glyphs, O.glyphs) || k.push({ command: ke.setGlyphs, args: [O.glyphs] }), o.deepEqual(E.transition, O.transition) || k.push({ command: ke.setTransition, args: [O.transition] }), o.deepEqual(E.light, O.light) || k.push({ command: ke.setLight, args: [O.light] });
              var R = {}, q = [];
              (function(W, ne, re, se) {
                var J;
                for (J in ne = ne || {}, W = W || {})
                  W.hasOwnProperty(J) && (ne.hasOwnProperty(J) || we(J, re, se));
                for (J in ne)
                  ne.hasOwnProperty(J) && (W.hasOwnProperty(J) ? o.deepEqual(W[J], ne[J]) || (W[J].type === "geojson" && ne[J].type === "geojson" && jt(W, ne, J) ? re.push({ command: ke.setGeoJSONSourceData, args: [J, ne[J].data] }) : We(J, ne, re, se)) : ce(J, ne, re));
              })(E.sources, O.sources, q, R);
              var $ = [];
              E.layers && E.layers.forEach(function(W) {
                R[W.source] ? k.push({ command: ke.removeLayer, args: [W.id] }) : $.push(W);
              }), k = k.concat(q), function(W, ne, re) {
                ne = ne || [];
                var se, J, ae, pe, _e, Ce, Te, Ae = (W = W || []).map(Jt), je = ne.map(Jt), tt = W.reduce(Zt, {}), Qe = ne.reduce(Zt, {}), gt = Ae.slice(), Dt = /* @__PURE__ */ Object.create(null);
                for (se = 0, J = 0; se < Ae.length; se++)
                  Qe.hasOwnProperty(ae = Ae[se]) ? J++ : (re.push({ command: ke.removeLayer, args: [ae] }), gt.splice(gt.indexOf(ae, J), 1));
                for (se = 0, J = 0; se < je.length; se++)
                  gt[gt.length - 1 - se] !== (ae = je[je.length - 1 - se]) && (tt.hasOwnProperty(ae) ? (re.push({ command: ke.removeLayer, args: [ae] }), gt.splice(gt.lastIndexOf(ae, gt.length - J), 1)) : J++, re.push({ command: ke.addLayer, args: [Qe[ae], Ce = gt[gt.length - se]] }), gt.splice(gt.length - se, 0, ae), Dt[ae] = !0);
                for (se = 0; se < je.length; se++)
                  if (pe = tt[ae = je[se]], _e = Qe[ae], !Dt[ae] && !o.deepEqual(pe, _e))
                    if (o.deepEqual(pe.source, _e.source) && o.deepEqual(pe["source-layer"], _e["source-layer"]) && o.deepEqual(pe.type, _e.type)) {
                      for (Te in Wt(pe.layout, _e.layout, re, ae, null, ke.setLayoutProperty), Wt(pe.paint, _e.paint, re, ae, null, ke.setPaintProperty), o.deepEqual(pe.filter, _e.filter) || re.push({ command: ke.setFilter, args: [ae, _e.filter] }), o.deepEqual(pe.minzoom, _e.minzoom) && o.deepEqual(pe.maxzoom, _e.maxzoom) || re.push({ command: ke.setLayerZoomRange, args: [ae, _e.minzoom, _e.maxzoom] }), pe)
                        pe.hasOwnProperty(Te) && Te !== "layout" && Te !== "paint" && Te !== "filter" && Te !== "metadata" && Te !== "minzoom" && Te !== "maxzoom" && (Te.indexOf("paint.") === 0 ? Wt(pe[Te], _e[Te], re, ae, Te.slice(6), ke.setPaintProperty) : o.deepEqual(pe[Te], _e[Te]) || re.push({ command: ke.setLayerProperty, args: [ae, Te, _e[Te]] }));
                      for (Te in _e)
                        _e.hasOwnProperty(Te) && !pe.hasOwnProperty(Te) && Te !== "layout" && Te !== "paint" && Te !== "filter" && Te !== "metadata" && Te !== "minzoom" && Te !== "maxzoom" && (Te.indexOf("paint.") === 0 ? Wt(pe[Te], _e[Te], re, ae, Te.slice(6), ke.setPaintProperty) : o.deepEqual(pe[Te], _e[Te]) || re.push({ command: ke.setLayerProperty, args: [ae, Te, _e[Te]] }));
                    } else
                      re.push({ command: ke.removeLayer, args: [ae] }), Ce = gt[gt.lastIndexOf(ae) + 1], re.push({ command: ke.addLayer, args: [_e, Ce] });
              }($, O.layers, k);
            } catch (W) {
              console.warn("Unable to compute style diff:", W), k = [{ command: ke.setStyle, args: [O] }];
            }
            return k;
          }(this.serialize(), c).filter(function(E) {
            return !(E.command in ms);
          });
          if (_.length === 0)
            return !1;
          var w = _.filter(function(E) {
            return !(E.command in ds);
          });
          if (w.length > 0)
            throw new Error("Unimplemented: " + w.map(function(E) {
              return E.command;
            }).join(", ") + ".");
          return _.forEach(function(E) {
            E.command !== "setTransition" && d[E.command].apply(d, E.args);
          }), this.stylesheet = c, !0;
        }, h.prototype.addImage = function(c, d) {
          if (this.getImage(c))
            return this.fire(new o.ErrorEvent(new Error("An image with this name already exists.")));
          this.imageManager.addImage(c, d), this._afterImageUpdated(c);
        }, h.prototype.updateImage = function(c, d) {
          this.imageManager.updateImage(c, d);
        }, h.prototype.getImage = function(c) {
          return this.imageManager.getImage(c);
        }, h.prototype.removeImage = function(c) {
          if (!this.getImage(c))
            return this.fire(new o.ErrorEvent(new Error("No image with this name exists.")));
          this.imageManager.removeImage(c), this._afterImageUpdated(c);
        }, h.prototype._afterImageUpdated = function(c) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[c] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new o.Event("data", { dataType: "style" }));
        }, h.prototype.listImages = function() {
          return this._checkLoaded(), this.imageManager.listImages();
        }, h.prototype.addSource = function(c, d, _) {
          var w = this;
          if (_ === void 0 && (_ = {}), this._checkLoaded(), this.sourceCaches[c] !== void 0)
            throw new Error("There is already a source with this ID");
          if (!d.type)
            throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(d).join(", ") + ".");
          if (!(["vector", "raster", "geojson", "video", "image"].indexOf(d.type) >= 0 && this._validate(o.validateStyle.source, "sources." + c, d, null, _))) {
            this.map && this.map._collectResourceTiming && (d.collectResourceTiming = !0);
            var E = this.sourceCaches[c] = new ie(c, d, this.dispatcher);
            E.style = this, E.setEventedParent(this, function() {
              return { isSourceLoaded: w.loaded(), source: E.serialize(), sourceId: c };
            }), E.onAdd(this.map), this._changed = !0;
          }
        }, h.prototype.removeSource = function(c) {
          if (this._checkLoaded(), this.sourceCaches[c] === void 0)
            throw new Error("There is no source with this ID");
          for (var d in this._layers)
            if (this._layers[d].source === c)
              return this.fire(new o.ErrorEvent(new Error('Source "' + c + '" cannot be removed while layer "' + d + '" is using it.')));
          var _ = this.sourceCaches[c];
          delete this.sourceCaches[c], delete this._updatedSources[c], _.fire(new o.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: c })), _.setEventedParent(null), _.clearTiles(), _.onRemove && _.onRemove(this.map), this._changed = !0;
        }, h.prototype.setGeoJSONSourceData = function(c, d) {
          this._checkLoaded(), this.sourceCaches[c].getSource().setData(d), this._changed = !0;
        }, h.prototype.getSource = function(c) {
          return this.sourceCaches[c] && this.sourceCaches[c].getSource();
        }, h.prototype.addLayer = function(c, d, _) {
          _ === void 0 && (_ = {}), this._checkLoaded();
          var w = c.id;
          if (this.getLayer(w))
            this.fire(new o.ErrorEvent(new Error('Layer with id "' + w + '" already exists on this map')));
          else {
            var E;
            if (c.type === "custom") {
              if (nl(this, o.validateCustomStyleLayer(c)))
                return;
              E = o.createStyleLayer(c);
            } else {
              if (typeof c.source == "object" && (this.addSource(w, c.source), c = o.clone$1(c), c = o.extend(c, { source: w })), this._validate(o.validateStyle.layer, "layers." + w, c, { arrayIndex: -1 }, _))
                return;
              E = o.createStyleLayer(c), this._validateLayer(E), E.setEventedParent(this, { layer: { id: w } }), this._serializedLayers[E.id] = E.serialize();
            }
            var O = d ? this._order.indexOf(d) : this._order.length;
            if (d && O === -1)
              this.fire(new o.ErrorEvent(new Error('Layer with id "' + d + '" does not exist on this map.')));
            else {
              if (this._order.splice(O, 0, w), this._layerOrderChanged = !0, this._layers[w] = E, this._removedLayers[w] && E.source && E.type !== "custom") {
                var k = this._removedLayers[w];
                delete this._removedLayers[w], k.type !== E.type ? this._updatedSources[E.source] = "clear" : (this._updatedSources[E.source] = "reload", this.sourceCaches[E.source].pause());
              }
              this._updateLayer(E), E.onAdd && E.onAdd(this.map);
            }
          }
        }, h.prototype.moveLayer = function(c, d) {
          if (this._checkLoaded(), this._changed = !0, this._layers[c]) {
            if (c !== d) {
              var _ = this._order.indexOf(c);
              this._order.splice(_, 1);
              var w = d ? this._order.indexOf(d) : this._order.length;
              d && w === -1 ? this.fire(new o.ErrorEvent(new Error('Layer with id "' + d + '" does not exist on this map.'))) : (this._order.splice(w, 0, c), this._layerOrderChanged = !0);
            }
          } else
            this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be moved.")));
        }, h.prototype.removeLayer = function(c) {
          this._checkLoaded();
          var d = this._layers[c];
          if (d) {
            d.setEventedParent(null);
            var _ = this._order.indexOf(c);
            this._order.splice(_, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[c] = d, delete this._layers[c], delete this._serializedLayers[c], delete this._updatedLayers[c], delete this._updatedPaintProps[c], d.onRemove && d.onRemove(this.map);
          } else
            this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be removed.")));
        }, h.prototype.getLayer = function(c) {
          return this._layers[c];
        }, h.prototype.hasLayer = function(c) {
          return c in this._layers;
        }, h.prototype.setLayerZoomRange = function(c, d, _) {
          this._checkLoaded();
          var w = this.getLayer(c);
          w ? w.minzoom === d && w.maxzoom === _ || (d != null && (w.minzoom = d), _ != null && (w.maxzoom = _), this._updateLayer(w)) : this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot have zoom extent.")));
        }, h.prototype.setFilter = function(c, d, _) {
          _ === void 0 && (_ = {}), this._checkLoaded();
          var w = this.getLayer(c);
          if (w) {
            if (!o.deepEqual(w.filter, d))
              return d == null ? (w.filter = void 0, void this._updateLayer(w)) : void (this._validate(o.validateStyle.filter, "layers." + w.id + ".filter", d, null, _) || (w.filter = o.clone$1(d), this._updateLayer(w)));
          } else
            this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be filtered.")));
        }, h.prototype.getFilter = function(c) {
          return o.clone$1(this.getLayer(c).filter);
        }, h.prototype.setLayoutProperty = function(c, d, _, w) {
          w === void 0 && (w = {}), this._checkLoaded();
          var E = this.getLayer(c);
          E ? o.deepEqual(E.getLayoutProperty(d), _) || (E.setLayoutProperty(d, _, w), this._updateLayer(E)) : this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be styled.")));
        }, h.prototype.getLayoutProperty = function(c, d) {
          var _ = this.getLayer(c);
          if (_)
            return _.getLayoutProperty(d);
          this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style.")));
        }, h.prototype.setPaintProperty = function(c, d, _, w) {
          w === void 0 && (w = {}), this._checkLoaded();
          var E = this.getLayer(c);
          E ? o.deepEqual(E.getPaintProperty(d), _) || (E.setPaintProperty(d, _, w) && this._updateLayer(E), this._changed = !0, this._updatedPaintProps[c] = !0) : this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be styled.")));
        }, h.prototype.getPaintProperty = function(c, d) {
          return this.getLayer(c).getPaintProperty(d);
        }, h.prototype.setFeatureState = function(c, d) {
          this._checkLoaded();
          var _ = c.source, w = c.sourceLayer, E = this.sourceCaches[_];
          if (E !== void 0) {
            var O = E.getSource().type;
            O === "geojson" && w ? this.fire(new o.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : O !== "vector" || w ? (c.id === void 0 && this.fire(new o.ErrorEvent(new Error("The feature id parameter must be provided."))), E.setFeatureState(w, c.id, d)) : this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new o.ErrorEvent(new Error("The source '" + _ + "' does not exist in the map's style.")));
        }, h.prototype.removeFeatureState = function(c, d) {
          this._checkLoaded();
          var _ = c.source, w = this.sourceCaches[_];
          if (w !== void 0) {
            var E = w.getSource().type, O = E === "vector" ? c.sourceLayer : void 0;
            E !== "vector" || O ? d && typeof c.id != "string" && typeof c.id != "number" ? this.fire(new o.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : w.removeFeatureState(O, c.id, d) : this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new o.ErrorEvent(new Error("The source '" + _ + "' does not exist in the map's style.")));
        }, h.prototype.getFeatureState = function(c) {
          this._checkLoaded();
          var d = c.source, _ = c.sourceLayer, w = this.sourceCaches[d];
          if (w !== void 0) {
            if (w.getSource().type !== "vector" || _)
              return c.id === void 0 && this.fire(new o.ErrorEvent(new Error("The feature id parameter must be provided."))), w.getFeatureState(_, c.id);
            this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new o.ErrorEvent(new Error("The source '" + d + "' does not exist in the map's style.")));
        }, h.prototype.getTransition = function() {
          return o.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }, h.prototype.serialize = function() {
          return o.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: o.mapObject(this.sourceCaches, function(c) {
            return c.serialize();
          }), layers: this._serializeLayers(this._order) }, function(c) {
            return c !== void 0;
          });
        }, h.prototype._updateLayer = function(c) {
          this._updatedLayers[c.id] = !0, c.source && !this._updatedSources[c.source] && this.sourceCaches[c.source].getSource().type !== "raster" && (this._updatedSources[c.source] = "reload", this.sourceCaches[c.source].pause()), this._changed = !0;
        }, h.prototype._flattenAndSortRenderedFeatures = function(c) {
          for (var d = this, _ = function(tt) {
            return d._layers[tt].type === "fill-extrusion";
          }, w = {}, E = [], O = this._order.length - 1; O >= 0; O--) {
            var k = this._order[O];
            if (_(k)) {
              w[k] = O;
              for (var R = 0, q = c; R < q.length; R += 1) {
                var $ = q[R][k];
                if ($)
                  for (var W = 0, ne = $; W < ne.length; W += 1)
                    E.push(ne[W]);
              }
            }
          }
          E.sort(function(tt, Qe) {
            return Qe.intersectionZ - tt.intersectionZ;
          });
          for (var re = [], se = this._order.length - 1; se >= 0; se--) {
            var J = this._order[se];
            if (_(J))
              for (var ae = E.length - 1; ae >= 0; ae--) {
                var pe = E[ae].feature;
                if (w[pe.layer.id] < se)
                  break;
                re.push(pe), E.pop();
              }
            else
              for (var _e = 0, Ce = c; _e < Ce.length; _e += 1) {
                var Te = Ce[_e][J];
                if (Te)
                  for (var Ae = 0, je = Te; Ae < je.length; Ae += 1)
                    re.push(je[Ae].feature);
              }
          }
          return re;
        }, h.prototype.queryRenderedFeatures = function(c, d, _) {
          d && d.filter && this._validate(o.validateStyle.filter, "queryRenderedFeatures.filter", d.filter, null, d);
          var w = {};
          if (d && d.layers) {
            if (!Array.isArray(d.layers))
              return this.fire(new o.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
            for (var E = 0, O = d.layers; E < O.length; E += 1) {
              var k = O[E], R = this._layers[k];
              if (!R)
                return this.fire(new o.ErrorEvent(new Error("The layer '" + k + "' does not exist in the map's style and cannot be queried for features."))), [];
              w[R.source] = !0;
            }
          }
          var q = [];
          for (var $ in d.availableImages = this._availableImages, this.sourceCaches)
            d.layers && !w[$] || q.push(Cr(this.sourceCaches[$], this._layers, this._serializedLayers, c, d, _));
          return this.placement && q.push(function(W, ne, re, se, J, ae, pe) {
            for (var _e = {}, Ce = ae.queryRenderedSymbols(se), Te = [], Ae = 0, je = Object.keys(Ce).map(Number); Ae < je.length; Ae += 1)
              Te.push(pe[je[Ae]]);
            Te.sort(Vn);
            for (var tt = function() {
              var zt = gt[Qe], Tr = zt.featureIndex.lookupSymbolFeatures(Ce[zt.bucketInstanceId], ne, zt.bucketIndex, zt.sourceLayerIndex, J.filter, J.layers, J.availableImages, W);
              for (var xt in Tr) {
                var Yt = _e[xt] = _e[xt] || [], ir = Tr[xt];
                ir.sort(function(nr, Ht) {
                  var qt = zt.featureSortOrder;
                  if (qt) {
                    var si = qt.indexOf(nr.featureIndex);
                    return qt.indexOf(Ht.featureIndex) - si;
                  }
                  return Ht.featureIndex - nr.featureIndex;
                });
                for (var Kt = 0, Xt = ir; Kt < Xt.length; Kt += 1)
                  Yt.push(Xt[Kt]);
              }
            }, Qe = 0, gt = Te; Qe < gt.length; Qe += 1)
              tt();
            var Dt = function(zt) {
              _e[zt].forEach(function(Tr) {
                var xt = Tr.feature, Yt = re[W[zt].source].getFeatureState(xt.layer["source-layer"], xt.id);
                xt.source = xt.layer.source, xt.layer["source-layer"] && (xt.sourceLayer = xt.layer["source-layer"]), xt.state = Yt;
              });
            };
            for (var Ft in _e)
              Dt(Ft);
            return _e;
          }(this._layers, this._serializedLayers, this.sourceCaches, c, d, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(q);
        }, h.prototype.querySourceFeatures = function(c, d) {
          d && d.filter && this._validate(o.validateStyle.filter, "querySourceFeatures.filter", d.filter, null, d);
          var _ = this.sourceCaches[c];
          return _ ? function(w, E) {
            for (var O = w.getRenderableIds().map(function(ne) {
              return w.getTileByID(ne);
            }), k = [], R = {}, q = 0; q < O.length; q++) {
              var $ = O[q], W = $.tileID.canonical.key;
              R[W] || (R[W] = !0, $.querySourceFeatures(k, E));
            }
            return k;
          }(_, d) : [];
        }, h.prototype.addSourceType = function(c, d, _) {
          return h.getSourceType(c) ? _(new Error('A source type called "' + c + '" already exists.')) : (h.setSourceType(c, d), d.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: c, url: d.workerSourceURL }, _) : _(null, null));
        }, h.prototype.getLight = function() {
          return this.light.getLight();
        }, h.prototype.setLight = function(c, d) {
          d === void 0 && (d = {}), this._checkLoaded();
          var _ = this.light.getLight(), w = !1;
          for (var E in c)
            if (!o.deepEqual(c[E], _[E])) {
              w = !0;
              break;
            }
          if (w) {
            var O = { now: o.browser.now(), transition: o.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(c, d), this.light.updateTransitions(O);
          }
        }, h.prototype._validate = function(c, d, _, w, E) {
          return E === void 0 && (E = {}), (!E || E.validate !== !1) && nl(this, c.call(o.validateStyle, o.extend({ key: d, style: this.serialize(), value: _, styleSpec: o.styleSpec }, w)));
        }, h.prototype._remove = function() {
          for (var c in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), o.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers)
            this._layers[c].setEventedParent(null);
          for (var d in this.sourceCaches)
            this.sourceCaches[d].clearTiles(), this.sourceCaches[d].setEventedParent(null);
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
        }, h.prototype._clearSource = function(c) {
          this.sourceCaches[c].clearTiles();
        }, h.prototype._reloadSource = function(c) {
          this.sourceCaches[c].resume(), this.sourceCaches[c].reload();
        }, h.prototype._updateSources = function(c) {
          for (var d in this.sourceCaches)
            this.sourceCaches[d].update(c);
        }, h.prototype._generateCollisionBoxes = function() {
          for (var c in this.sourceCaches)
            this._reloadSource(c);
        }, h.prototype._updatePlacement = function(c, d, _, w, E) {
          E === void 0 && (E = !1);
          for (var O = !1, k = !1, R = {}, q = 0, $ = this._order; q < $.length; q += 1) {
            var W = this._layers[$[q]];
            if (W.type === "symbol") {
              if (!R[W.source]) {
                var ne = this.sourceCaches[W.source];
                R[W.source] = ne.getRenderableIds(!0).map(function(pe) {
                  return ne.getTileByID(pe);
                }).sort(function(pe, _e) {
                  return _e.tileID.overscaledZ - pe.tileID.overscaledZ || (pe.tileID.isLessThan(_e.tileID) ? -1 : 1);
                });
              }
              var re = this.crossTileSymbolIndex.addLayer(W, R[W.source], c.center.lng);
              O = O || re;
            }
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((E = E || this._layerOrderChanged || _ === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(o.browser.now(), c.zoom)) && (this.pauseablePlacement = new qu(c, this._order, E, d, _, w, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, R), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(o.browser.now()), k = !0), O && this.pauseablePlacement.placement.setStale()), k || O)
            for (var se = 0, J = this._order; se < J.length; se += 1) {
              var ae = this._layers[J[se]];
              ae.type === "symbol" && this.placement.updateLayerOpacities(ae, R[ae.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(o.browser.now());
        }, h.prototype._releaseSymbolFadeTiles = function() {
          for (var c in this.sourceCaches)
            this.sourceCaches[c].releaseSymbolFadeTiles();
        }, h.prototype.getImages = function(c, d, _) {
          this.imageManager.getImages(d.icons, _), this._updateTilesForChangedImages();
          var w = this.sourceCaches[d.source];
          w && w.setDependencies(d.tileID.key, d.type, d.icons);
        }, h.prototype.getGlyphs = function(c, d, _) {
          this.glyphManager.getGlyphs(d.stacks, _);
        }, h.prototype.getResource = function(c, d, _) {
          return o.makeRequest(d, _);
        }, h;
      }(o.Evented);
      lo.getSourceType = function(u) {
        return Fi[u];
      }, lo.setSourceType = function(u, h) {
        Fi[u] = h;
      }, lo.registerForPluginStateChange = o.registerForPluginStateChange;
      var jn = o.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), Wl = Zr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}`), lm = Zr(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Fv = Zr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), Bv = Zr(`varying vec3 v_data;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), Hf = Zr("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Zf = Zr(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`), Xf = Zr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), Kf = Zr("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), um = Zr("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), cm = Zr("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"), Vv = Zr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), $u = Zr(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), Wu = Zr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), hm = Zr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), Si = Zr(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), Yf = Zr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), ys = Zr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), gs = Zr(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), il = Zr(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`), ol = Zr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`), vs = Zr(`uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), al = Zr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), sl = Zr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), _s = Zr(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}`), fm = Zr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), pm = Zr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`);
      function Zr(u, h) {
        var c = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, d = h.match(/attribute ([\w]+) ([\w]+)/g), _ = u.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), E = w ? w.concat(_) : _, O = {};
        return { fragmentSource: u = u.replace(c, function(k, R, q, $, W) {
          return O[W] = !0, R === "define" ? `
#ifndef HAS_UNIFORM_u_` + W + `
varying ` + q + " " + $ + " " + W + `;
#else
uniform ` + q + " " + $ + " u_" + W + `;
#endif
` : `
#ifdef HAS_UNIFORM_u_` + W + `
    ` + q + " " + $ + " " + W + " = u_" + W + `;
#endif
`;
        }), vertexSource: h = h.replace(c, function(k, R, q, $, W) {
          var ne = $ === "float" ? "vec2" : "vec4", re = W.match(/color/) ? "color" : ne;
          return O[W] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_` + W + `
uniform lowp float u_` + W + `_t;
attribute ` + q + " " + ne + " a_" + W + `;
varying ` + q + " " + $ + " " + W + `;
#else
uniform ` + q + " " + $ + " u_" + W + `;
#endif
` : re === "vec4" ? `
#ifndef HAS_UNIFORM_u_` + W + `
    ` + W + " = a_" + W + `;
#else
    ` + q + " " + $ + " " + W + " = u_" + W + `;
#endif
` : `
#ifndef HAS_UNIFORM_u_` + W + `
    ` + W + " = unpack_mix_" + re + "(a_" + W + ", u_" + W + `_t);
#else
    ` + q + " " + $ + " " + W + " = u_" + W + `;
#endif
` : R === "define" ? `
#ifndef HAS_UNIFORM_u_` + W + `
uniform lowp float u_` + W + `_t;
attribute ` + q + " " + ne + " a_" + W + `;
#else
uniform ` + q + " " + $ + " u_" + W + `;
#endif
` : re === "vec4" ? `
#ifndef HAS_UNIFORM_u_` + W + `
    ` + q + " " + $ + " " + W + " = a_" + W + `;
#else
    ` + q + " " + $ + " " + W + " = u_" + W + `;
#endif
` : `
#ifndef HAS_UNIFORM_u_` + W + `
    ` + q + " " + $ + " " + W + " = unpack_mix_" + re + "(a_" + W + ", u_" + W + `_t);
#else
    ` + q + " " + $ + " " + W + " = u_" + W + `;
#endif
`;
        }), staticAttributes: d, staticUniforms: E };
      }
      var Uv = Object.freeze({ __proto__: null, prelude: Wl, background: lm, backgroundPattern: Fv, circle: Bv, clippingMask: Hf, heatmap: Zf, heatmapTexture: Xf, collisionBox: Kf, collisionCircle: um, debug: cm, fill: Vv, fillOutline: $u, fillOutlinePattern: Wu, fillPattern: hm, fillExtrusion: Si, fillExtrusionPattern: Yf, hillshadePrepare: ys, hillshade: gs, line: il, lineGradient: ol, linePattern: vs, lineSDF: al, raster: sl, symbolIcon: _s, symbolSDF: fm, symbolTextAndIcon: pm }), oh = function() {
        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
      };
      function dm(u) {
        for (var h = [], c = 0; c < u.length; c++)
          if (u[c] !== null) {
            var d = u[c].split(" ");
            h.push(d.pop());
          }
        return h;
      }
      oh.prototype.bind = function(u, h, c, d, _, w, E, O) {
        this.context = u;
        for (var k = this.boundPaintVertexBuffers.length !== d.length, R = 0; !k && R < d.length; R++)
          this.boundPaintVertexBuffers[R] !== d[R] && (k = !0);
        u.extVertexArrayObject && this.vao && this.boundProgram === h && this.boundLayoutVertexBuffer === c && !k && this.boundIndexBuffer === _ && this.boundVertexOffset === w && this.boundDynamicVertexBuffer === E && this.boundDynamicVertexBuffer2 === O ? (u.bindVertexArrayOES.set(this.vao), E && E.bind(), _ && _.dynamicDraw && _.bind(), O && O.bind()) : this.freshBind(h, c, d, _, w, E, O);
      }, oh.prototype.freshBind = function(u, h, c, d, _, w, E) {
        var O, k = u.numAttributes, R = this.context, q = R.gl;
        if (R.extVertexArrayObject)
          this.vao && this.destroy(), this.vao = R.extVertexArrayObject.createVertexArrayOES(), R.bindVertexArrayOES.set(this.vao), O = 0, this.boundProgram = u, this.boundLayoutVertexBuffer = h, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = d, this.boundVertexOffset = _, this.boundDynamicVertexBuffer = w, this.boundDynamicVertexBuffer2 = E;
        else {
          O = R.currentNumAttributes || 0;
          for (var $ = k; $ < O; $++)
            q.disableVertexAttribArray($);
        }
        h.enableAttributes(q, u);
        for (var W = 0, ne = c; W < ne.length; W += 1)
          ne[W].enableAttributes(q, u);
        w && w.enableAttributes(q, u), E && E.enableAttributes(q, u), h.bind(), h.setVertexAttribPointers(q, u, _);
        for (var re = 0, se = c; re < se.length; re += 1) {
          var J = se[re];
          J.bind(), J.setVertexAttribPointers(q, u, _);
        }
        w && (w.bind(), w.setVertexAttribPointers(q, u, _)), d && d.bind(), E && (E.bind(), E.setVertexAttribPointers(q, u, _)), R.currentNumAttributes = k;
      }, oh.prototype.destroy = function() {
        this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
      };
      var mm = function(u, h, c, d, _, w) {
        var E = u.gl;
        this.program = E.createProgram();
        for (var O = dm(c.staticAttributes), k = d ? d.getBinderAttributes() : [], R = O.concat(k), q = c.staticUniforms ? dm(c.staticUniforms) : [], $ = d ? d.getBinderUniforms() : [], W = [], ne = 0, re = q.concat($); ne < re.length; ne += 1) {
          var se = re[ne];
          W.indexOf(se) < 0 && W.push(se);
        }
        var J = d ? d.defines() : [];
        w && J.push("#define OVERDRAW_INSPECTOR;");
        var ae = J.concat(Wl.fragmentSource, c.fragmentSource).join(`
`), pe = J.concat(Wl.vertexSource, c.vertexSource).join(`
`), _e = E.createShader(E.FRAGMENT_SHADER);
        if (E.isContextLost())
          this.failedToCreate = !0;
        else {
          E.shaderSource(_e, ae), E.compileShader(_e), E.attachShader(this.program, _e);
          var Ce = E.createShader(E.VERTEX_SHADER);
          if (E.isContextLost())
            this.failedToCreate = !0;
          else {
            E.shaderSource(Ce, pe), E.compileShader(Ce), E.attachShader(this.program, Ce), this.attributes = {};
            var Te = {};
            this.numAttributes = R.length;
            for (var Ae = 0; Ae < this.numAttributes; Ae++)
              R[Ae] && (E.bindAttribLocation(this.program, Ae, R[Ae]), this.attributes[R[Ae]] = Ae);
            E.linkProgram(this.program), E.deleteShader(Ce), E.deleteShader(_e);
            for (var je = 0; je < W.length; je++) {
              var tt = W[je];
              if (tt && !Te[tt]) {
                var Qe = E.getUniformLocation(this.program, tt);
                Qe && (Te[tt] = Qe);
              }
            }
            this.fixedUniforms = _(u, Te), this.binderUniforms = d ? d.getUniforms(u, Te) : [];
          }
        }
      };
      function ym(u, h, c) {
        var d = 1 / dn(c, 1, h.transform.tileZoom), _ = Math.pow(2, c.tileID.overscaledZ), w = c.tileSize * Math.pow(2, h.transform.tileZoom) / _, E = w * (c.tileID.canonical.x + c.tileID.wrap * _), O = w * c.tileID.canonical.y;
        return { u_image: 0, u_texsize: c.imageAtlasTexture.size, u_scale: [d, u.fromScale, u.toScale], u_fade: u.t, u_pixel_coord_upper: [E >> 16, O >> 16], u_pixel_coord_lower: [65535 & E, 65535 & O] };
      }
      mm.prototype.draw = function(u, h, c, d, _, w, E, O, k, R, q, $, W, ne, re, se) {
        var J, ae = u.gl;
        if (!this.failedToCreate) {
          for (var pe in u.program.set(this.program), u.setDepthMode(c), u.setStencilMode(d), u.setColorMode(_), u.setCullFace(w), this.fixedUniforms)
            this.fixedUniforms[pe].set(E[pe]);
          ne && ne.setUniforms(u, this.binderUniforms, $, { zoom: W });
          for (var _e = (J = {}, J[ae.LINES] = 2, J[ae.TRIANGLES] = 3, J[ae.LINE_STRIP] = 1, J)[h], Ce = 0, Te = q.get(); Ce < Te.length; Ce += 1) {
            var Ae = Te[Ce], je = Ae.vaos || (Ae.vaos = {});
            (je[O] || (je[O] = new oh())).bind(u, this, k, ne ? ne.getPaintVertexBuffers() : [], R, Ae.vertexOffset, re, se), ae.drawElements(h, Ae.primitiveLength * _e, ae.UNSIGNED_SHORT, Ae.primitiveOffset * _e * 2);
          }
        }
      };
      var gm = function(u, h, c, d) {
        var _ = h.style.light, w = _.properties.get("position"), E = [w.x, w.y, w.z], O = o.create$1();
        _.properties.get("anchor") === "viewport" && o.fromRotation(O, -h.transform.angle), o.transformMat3(E, E, O);
        var k = _.properties.get("color");
        return { u_matrix: u, u_lightpos: E, u_lightintensity: _.properties.get("intensity"), u_lightcolor: [k.r, k.g, k.b], u_vertical_gradient: +c, u_opacity: d };
      }, ll = function(u, h, c, d, _, w, E) {
        return o.extend(gm(u, h, c, d), ym(w, h, E), { u_height_factor: -Math.pow(2, _.overscaledZ) / E.tileSize / 8 });
      }, xs = function(u) {
        return { u_matrix: u };
      }, ul = function(u, h, c, d) {
        return o.extend(xs(u), ym(c, h, d));
      }, vm = function(u, h) {
        return { u_matrix: u, u_world: h };
      }, _m = function(u, h, c, d, _) {
        return o.extend(ul(u, h, c, d), { u_world: _ });
      }, Jf = function(u, h, c, d) {
        var _, w, E = u.transform;
        if (d.paint.get("circle-pitch-alignment") === "map") {
          var O = dn(c, 1, E.zoom);
          _ = !0, w = [O, O];
        } else
          _ = !1, w = E.pixelsToGLUnits;
        return { u_camera_to_center_distance: E.cameraToCenterDistance, u_scale_with_map: +(d.paint.get("circle-pitch-scale") === "map"), u_matrix: u.translatePosMatrix(h.posMatrix, c, d.paint.get("circle-translate"), d.paint.get("circle-translate-anchor")), u_pitch_with_map: +_, u_device_pixel_ratio: o.browser.devicePixelRatio, u_extrude_scale: w };
      }, cl = function(u, h, c) {
        var d = dn(c, 1, h.zoom), _ = Math.pow(2, h.zoom - c.tileID.overscaledZ), w = c.tileID.overscaleFactor();
        return { u_matrix: u, u_camera_to_center_distance: h.cameraToCenterDistance, u_pixels_to_tile_units: d, u_extrude_scale: [h.pixelsToGLUnits[0] / (d * _), h.pixelsToGLUnits[1] / (d * _)], u_overscale_factor: w };
      }, xm = function(u, h, c) {
        return { u_matrix: u, u_inv_matrix: h, u_camera_to_center_distance: c.cameraToCenterDistance, u_viewport_size: [c.width, c.height] };
      }, hl = function(u, h, c) {
        return c === void 0 && (c = 1), { u_matrix: u, u_color: h, u_overlay: 0, u_overlay_scale: c };
      }, fl = function(u) {
        return { u_matrix: u };
      }, bm = function(u, h, c, d) {
        return { u_matrix: u, u_extrude_scale: dn(h, 1, c), u_intensity: d };
      }, Hu = function(u, h, c) {
        var d = u.transform;
        return { u_matrix: wm(u, h, c), u_ratio: 1 / dn(h, 1, d.zoom), u_device_pixel_ratio: o.browser.devicePixelRatio, u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]] };
      }, Qr = function(u, h, c, d) {
        return o.extend(Hu(u, h, c), { u_image: 0, u_image_height: d });
      }, ah = function(u, h, c, d) {
        var _ = u.transform, w = Hl(h, _);
        return { u_matrix: wm(u, h, c), u_texsize: h.imageAtlasTexture.size, u_ratio: 1 / dn(h, 1, _.zoom), u_device_pixel_ratio: o.browser.devicePixelRatio, u_image: 0, u_scale: [w, d.fromScale, d.toScale], u_fade: d.t, u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]] };
      }, jv = function(u, h, c, d, _) {
        var w = u.lineAtlas, E = Hl(h, u.transform), O = c.layout.get("line-cap") === "round", k = w.getDash(d.from, O), R = w.getDash(d.to, O), q = k.width * _.fromScale, $ = R.width * _.toScale;
        return o.extend(Hu(u, h, c), { u_patternscale_a: [E / q, -k.height / 2], u_patternscale_b: [E / $, -R.height / 2], u_sdfgamma: w.width / (256 * Math.min(q, $) * o.browser.devicePixelRatio) / 2, u_image: 0, u_tex_y_a: k.y, u_tex_y_b: R.y, u_mix: _.t });
      };
      function Hl(u, h) {
        return 1 / dn(u, 1, h.tileZoom);
      }
      function wm(u, h, c) {
        return u.translatePosMatrix(h.tileID.posMatrix, h, c.paint.get("line-translate"), c.paint.get("line-translate-anchor"));
      }
      var Gv = function(u, h, c, d, _) {
        return { u_matrix: u, u_tl_parent: h, u_scale_parent: c, u_buffer_scale: 1, u_fade_t: d.mix, u_opacity: d.opacity * _.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: _.paint.get("raster-brightness-min"), u_brightness_high: _.paint.get("raster-brightness-max"), u_saturation_factor: (E = _.paint.get("raster-saturation"), E > 0 ? 1 - 1 / (1.001 - E) : -E), u_contrast_factor: (w = _.paint.get("raster-contrast"), w > 0 ? 1 / (1 - w) : 1 + w), u_spin_weights: Em(_.paint.get("raster-hue-rotate")) };
        var w, E;
      };
      function Em(u) {
        u *= Math.PI / 180;
        var h = Math.sin(u), c = Math.cos(u);
        return [(2 * c + 1) / 3, (-Math.sqrt(3) * h - c + 1) / 3, (Math.sqrt(3) * h - c + 1) / 3];
      }
      var sh, Zl = function(u, h, c, d, _, w, E, O, k, R) {
        var q = _.transform;
        return { u_is_size_zoom_constant: +(u === "constant" || u === "source"), u_is_size_feature_constant: +(u === "constant" || u === "camera"), u_size_t: h ? h.uSizeT : 0, u_size: h ? h.uSize : 0, u_camera_to_center_distance: q.cameraToCenterDistance, u_pitch: q.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +c, u_aspect_ratio: q.width / q.height, u_fade_change: _.options.fadeDuration ? _.symbolFadeChange : 1, u_matrix: w, u_label_plane_matrix: E, u_coord_matrix: O, u_is_text: +k, u_pitch_with_map: +d, u_texsize: R, u_texture: 0 };
      }, Zu = function(u, h, c, d, _, w, E, O, k, R, q) {
        var $ = _.transform;
        return o.extend(Zl(u, h, c, d, _, w, E, O, k, R), { u_gamma_scale: d ? Math.cos($._pitch) * $.cameraToCenterDistance : 1, u_device_pixel_ratio: o.browser.devicePixelRatio, u_is_halo: +q });
      }, lh = function(u, h, c, d, _, w, E, O, k, R) {
        return o.extend(Zu(u, h, c, d, _, w, E, O, !0, k, !0), { u_texsize_icon: R, u_texture_icon: 1 });
      }, Xu = function(u, h, c) {
        return { u_matrix: u, u_opacity: h, u_color: c };
      }, Xl = function(u, h, c, d, _, w) {
        return o.extend(function(E, O, k, R) {
          var q = k.imageManager.getPattern(E.from.toString()), $ = k.imageManager.getPattern(E.to.toString()), W = k.imageManager.getPixelSize(), ne = W.width, re = W.height, se = Math.pow(2, R.tileID.overscaledZ), J = R.tileSize * Math.pow(2, k.transform.tileZoom) / se, ae = J * (R.tileID.canonical.x + R.tileID.wrap * se), pe = J * R.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: q.tl, u_pattern_br_a: q.br, u_pattern_tl_b: $.tl, u_pattern_br_b: $.br, u_texsize: [ne, re], u_mix: O.t, u_pattern_size_a: q.displaySize, u_pattern_size_b: $.displaySize, u_scale_a: O.fromScale, u_scale_b: O.toScale, u_tile_units_to_pixels: 1 / dn(R, 1, k.transform.tileZoom), u_pixel_coord_upper: [ae >> 16, pe >> 16], u_pixel_coord_lower: [65535 & ae, 65535 & pe] };
        }(d, w, c, _), { u_matrix: u, u_opacity: h });
      }, Sm = { fillExtrusion: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_lightpos: new o.Uniform3f(u, h.u_lightpos), u_lightintensity: new o.Uniform1f(u, h.u_lightintensity), u_lightcolor: new o.Uniform3f(u, h.u_lightcolor), u_vertical_gradient: new o.Uniform1f(u, h.u_vertical_gradient), u_opacity: new o.Uniform1f(u, h.u_opacity) };
      }, fillExtrusionPattern: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_lightpos: new o.Uniform3f(u, h.u_lightpos), u_lightintensity: new o.Uniform1f(u, h.u_lightintensity), u_lightcolor: new o.Uniform3f(u, h.u_lightcolor), u_vertical_gradient: new o.Uniform1f(u, h.u_vertical_gradient), u_height_factor: new o.Uniform1f(u, h.u_height_factor), u_image: new o.Uniform1i(u, h.u_image), u_texsize: new o.Uniform2f(u, h.u_texsize), u_pixel_coord_upper: new o.Uniform2f(u, h.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, h.u_pixel_coord_lower), u_scale: new o.Uniform3f(u, h.u_scale), u_fade: new o.Uniform1f(u, h.u_fade), u_opacity: new o.Uniform1f(u, h.u_opacity) };
      }, fill: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix) };
      }, fillPattern: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_image: new o.Uniform1i(u, h.u_image), u_texsize: new o.Uniform2f(u, h.u_texsize), u_pixel_coord_upper: new o.Uniform2f(u, h.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, h.u_pixel_coord_lower), u_scale: new o.Uniform3f(u, h.u_scale), u_fade: new o.Uniform1f(u, h.u_fade) };
      }, fillOutline: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_world: new o.Uniform2f(u, h.u_world) };
      }, fillOutlinePattern: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_world: new o.Uniform2f(u, h.u_world), u_image: new o.Uniform1i(u, h.u_image), u_texsize: new o.Uniform2f(u, h.u_texsize), u_pixel_coord_upper: new o.Uniform2f(u, h.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, h.u_pixel_coord_lower), u_scale: new o.Uniform3f(u, h.u_scale), u_fade: new o.Uniform1f(u, h.u_fade) };
      }, circle: function(u, h) {
        return { u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_scale_with_map: new o.Uniform1i(u, h.u_scale_with_map), u_pitch_with_map: new o.Uniform1i(u, h.u_pitch_with_map), u_extrude_scale: new o.Uniform2f(u, h.u_extrude_scale), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_matrix: new o.UniformMatrix4f(u, h.u_matrix) };
      }, collisionBox: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_pixels_to_tile_units: new o.Uniform1f(u, h.u_pixels_to_tile_units), u_extrude_scale: new o.Uniform2f(u, h.u_extrude_scale), u_overscale_factor: new o.Uniform1f(u, h.u_overscale_factor) };
      }, collisionCircle: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_inv_matrix: new o.UniformMatrix4f(u, h.u_inv_matrix), u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_viewport_size: new o.Uniform2f(u, h.u_viewport_size) };
      }, debug: function(u, h) {
        return { u_color: new o.UniformColor(u, h.u_color), u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_overlay: new o.Uniform1i(u, h.u_overlay), u_overlay_scale: new o.Uniform1f(u, h.u_overlay_scale) };
      }, clippingMask: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix) };
      }, heatmap: function(u, h) {
        return { u_extrude_scale: new o.Uniform1f(u, h.u_extrude_scale), u_intensity: new o.Uniform1f(u, h.u_intensity), u_matrix: new o.UniformMatrix4f(u, h.u_matrix) };
      }, heatmapTexture: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_world: new o.Uniform2f(u, h.u_world), u_image: new o.Uniform1i(u, h.u_image), u_color_ramp: new o.Uniform1i(u, h.u_color_ramp), u_opacity: new o.Uniform1f(u, h.u_opacity) };
      }, hillshade: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_image: new o.Uniform1i(u, h.u_image), u_latrange: new o.Uniform2f(u, h.u_latrange), u_light: new o.Uniform2f(u, h.u_light), u_shadow: new o.UniformColor(u, h.u_shadow), u_highlight: new o.UniformColor(u, h.u_highlight), u_accent: new o.UniformColor(u, h.u_accent) };
      }, hillshadePrepare: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_image: new o.Uniform1i(u, h.u_image), u_dimension: new o.Uniform2f(u, h.u_dimension), u_zoom: new o.Uniform1f(u, h.u_zoom), u_unpack: new o.Uniform4f(u, h.u_unpack) };
      }, line: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_ratio: new o.Uniform1f(u, h.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(u, h.u_units_to_pixels) };
      }, lineGradient: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_ratio: new o.Uniform1f(u, h.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(u, h.u_units_to_pixels), u_image: new o.Uniform1i(u, h.u_image), u_image_height: new o.Uniform1f(u, h.u_image_height) };
      }, linePattern: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_texsize: new o.Uniform2f(u, h.u_texsize), u_ratio: new o.Uniform1f(u, h.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_image: new o.Uniform1i(u, h.u_image), u_units_to_pixels: new o.Uniform2f(u, h.u_units_to_pixels), u_scale: new o.Uniform3f(u, h.u_scale), u_fade: new o.Uniform1f(u, h.u_fade) };
      }, lineSDF: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_ratio: new o.Uniform1f(u, h.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(u, h.u_units_to_pixels), u_patternscale_a: new o.Uniform2f(u, h.u_patternscale_a), u_patternscale_b: new o.Uniform2f(u, h.u_patternscale_b), u_sdfgamma: new o.Uniform1f(u, h.u_sdfgamma), u_image: new o.Uniform1i(u, h.u_image), u_tex_y_a: new o.Uniform1f(u, h.u_tex_y_a), u_tex_y_b: new o.Uniform1f(u, h.u_tex_y_b), u_mix: new o.Uniform1f(u, h.u_mix) };
      }, raster: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_tl_parent: new o.Uniform2f(u, h.u_tl_parent), u_scale_parent: new o.Uniform1f(u, h.u_scale_parent), u_buffer_scale: new o.Uniform1f(u, h.u_buffer_scale), u_fade_t: new o.Uniform1f(u, h.u_fade_t), u_opacity: new o.Uniform1f(u, h.u_opacity), u_image0: new o.Uniform1i(u, h.u_image0), u_image1: new o.Uniform1i(u, h.u_image1), u_brightness_low: new o.Uniform1f(u, h.u_brightness_low), u_brightness_high: new o.Uniform1f(u, h.u_brightness_high), u_saturation_factor: new o.Uniform1f(u, h.u_saturation_factor), u_contrast_factor: new o.Uniform1f(u, h.u_contrast_factor), u_spin_weights: new o.Uniform3f(u, h.u_spin_weights) };
      }, symbolIcon: function(u, h) {
        return { u_is_size_zoom_constant: new o.Uniform1i(u, h.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(u, h.u_is_size_feature_constant), u_size_t: new o.Uniform1f(u, h.u_size_t), u_size: new o.Uniform1f(u, h.u_size), u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_pitch: new o.Uniform1f(u, h.u_pitch), u_rotate_symbol: new o.Uniform1i(u, h.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(u, h.u_aspect_ratio), u_fade_change: new o.Uniform1f(u, h.u_fade_change), u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(u, h.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(u, h.u_coord_matrix), u_is_text: new o.Uniform1i(u, h.u_is_text), u_pitch_with_map: new o.Uniform1i(u, h.u_pitch_with_map), u_texsize: new o.Uniform2f(u, h.u_texsize), u_texture: new o.Uniform1i(u, h.u_texture) };
      }, symbolSDF: function(u, h) {
        return { u_is_size_zoom_constant: new o.Uniform1i(u, h.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(u, h.u_is_size_feature_constant), u_size_t: new o.Uniform1f(u, h.u_size_t), u_size: new o.Uniform1f(u, h.u_size), u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_pitch: new o.Uniform1f(u, h.u_pitch), u_rotate_symbol: new o.Uniform1i(u, h.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(u, h.u_aspect_ratio), u_fade_change: new o.Uniform1f(u, h.u_fade_change), u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(u, h.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(u, h.u_coord_matrix), u_is_text: new o.Uniform1i(u, h.u_is_text), u_pitch_with_map: new o.Uniform1i(u, h.u_pitch_with_map), u_texsize: new o.Uniform2f(u, h.u_texsize), u_texture: new o.Uniform1i(u, h.u_texture), u_gamma_scale: new o.Uniform1f(u, h.u_gamma_scale), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_is_halo: new o.Uniform1i(u, h.u_is_halo) };
      }, symbolTextAndIcon: function(u, h) {
        return { u_is_size_zoom_constant: new o.Uniform1i(u, h.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(u, h.u_is_size_feature_constant), u_size_t: new o.Uniform1f(u, h.u_size_t), u_size: new o.Uniform1f(u, h.u_size), u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_pitch: new o.Uniform1f(u, h.u_pitch), u_rotate_symbol: new o.Uniform1i(u, h.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(u, h.u_aspect_ratio), u_fade_change: new o.Uniform1f(u, h.u_fade_change), u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(u, h.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(u, h.u_coord_matrix), u_is_text: new o.Uniform1i(u, h.u_is_text), u_pitch_with_map: new o.Uniform1i(u, h.u_pitch_with_map), u_texsize: new o.Uniform2f(u, h.u_texsize), u_texsize_icon: new o.Uniform2f(u, h.u_texsize_icon), u_texture: new o.Uniform1i(u, h.u_texture), u_texture_icon: new o.Uniform1i(u, h.u_texture_icon), u_gamma_scale: new o.Uniform1f(u, h.u_gamma_scale), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_is_halo: new o.Uniform1i(u, h.u_is_halo) };
      }, background: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_opacity: new o.Uniform1f(u, h.u_opacity), u_color: new o.UniformColor(u, h.u_color) };
      }, backgroundPattern: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_opacity: new o.Uniform1f(u, h.u_opacity), u_image: new o.Uniform1i(u, h.u_image), u_pattern_tl_a: new o.Uniform2f(u, h.u_pattern_tl_a), u_pattern_br_a: new o.Uniform2f(u, h.u_pattern_br_a), u_pattern_tl_b: new o.Uniform2f(u, h.u_pattern_tl_b), u_pattern_br_b: new o.Uniform2f(u, h.u_pattern_br_b), u_texsize: new o.Uniform2f(u, h.u_texsize), u_mix: new o.Uniform1f(u, h.u_mix), u_pattern_size_a: new o.Uniform2f(u, h.u_pattern_size_a), u_pattern_size_b: new o.Uniform2f(u, h.u_pattern_size_b), u_scale_a: new o.Uniform1f(u, h.u_scale_a), u_scale_b: new o.Uniform1f(u, h.u_scale_b), u_pixel_coord_upper: new o.Uniform2f(u, h.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, h.u_pixel_coord_lower), u_tile_units_to_pixels: new o.Uniform1f(u, h.u_tile_units_to_pixels) };
      } };
      function Kl(u, h, c, d, _, w, E) {
        for (var O = u.context, k = O.gl, R = u.useProgram("collisionBox"), q = [], $ = 0, W = 0, ne = 0; ne < d.length; ne++) {
          var re = d[ne], se = h.getTile(re), J = se.getBucket(c);
          if (J) {
            var ae = re.posMatrix;
            _[0] === 0 && _[1] === 0 || (ae = u.translatePosMatrix(re.posMatrix, se, _, w));
            var pe = E ? J.textCollisionBox : J.iconCollisionBox, _e = J.collisionCircleArray;
            if (_e.length > 0) {
              var Ce = o.create(), Te = ae;
              o.mul(Ce, J.placementInvProjMatrix, u.transform.glCoordMatrix), o.mul(Ce, Ce, J.placementViewportMatrix), q.push({ circleArray: _e, circleOffset: W, transform: Te, invTransform: Ce }), W = $ += _e.length / 4;
            }
            pe && R.draw(O, k.LINES, H.disabled, ee.disabled, u.colorModeForRenderPass(), fe.disabled, cl(ae, u.transform, se), c.id, pe.layoutVertexBuffer, pe.indexBuffer, pe.segments, null, u.transform.zoom, null, null, pe.collisionVertexBuffer);
          }
        }
        if (E && q.length) {
          var Ae = u.useProgram("collisionCircle"), je = new o.StructArrayLayout2f1f2i16();
          je.resize(4 * $), je._trim();
          for (var tt = 0, Qe = 0, gt = q; Qe < gt.length; Qe += 1)
            for (var Dt = gt[Qe], Ft = 0; Ft < Dt.circleArray.length / 4; Ft++) {
              var zt = 4 * Ft, Tr = Dt.circleArray[zt + 0], xt = Dt.circleArray[zt + 1], Yt = Dt.circleArray[zt + 2], ir = Dt.circleArray[zt + 3];
              je.emplace(tt++, Tr, xt, Yt, ir, 0), je.emplace(tt++, Tr, xt, Yt, ir, 1), je.emplace(tt++, Tr, xt, Yt, ir, 2), je.emplace(tt++, Tr, xt, Yt, ir, 3);
            }
          (!sh || sh.length < 2 * $) && (sh = function(In) {
            var Li = 2 * In, gi = new o.StructArrayLayout3ui6();
            gi.resize(Li), gi._trim();
            for (var Tn = 0; Tn < Li; Tn++) {
              var Ln = 6 * Tn;
              gi.uint16[Ln + 0] = 4 * Tn + 0, gi.uint16[Ln + 1] = 4 * Tn + 1, gi.uint16[Ln + 2] = 4 * Tn + 2, gi.uint16[Ln + 3] = 4 * Tn + 2, gi.uint16[Ln + 4] = 4 * Tn + 3, gi.uint16[Ln + 5] = 4 * Tn + 0;
            }
            return gi;
          }($));
          for (var Kt = O.createIndexBuffer(sh, !0), Xt = O.createVertexBuffer(je, o.collisionCircleLayout.members, !0), nr = 0, Ht = q; nr < Ht.length; nr += 1) {
            var qt = Ht[nr], si = xm(qt.transform, qt.invTransform, u.transform);
            Ae.draw(O, k.TRIANGLES, H.disabled, ee.disabled, u.colorModeForRenderPass(), fe.disabled, si, c.id, Xt, Kt, o.SegmentVector.simpleSegment(0, 2 * qt.circleOffset, qt.circleArray.length, qt.circleArray.length / 2), null, u.transform.zoom, null, null, null);
          }
          Xt.destroy(), Kt.destroy();
        }
      }
      var oa = o.identity(new Float32Array(16));
      function Tm(u, h, c, d, _, w) {
        var E = o.getAnchorAlignment(u), O = -(E.horizontalAlign - 0.5) * h, k = -(E.verticalAlign - 0.5) * c, R = o.evaluateVariableOffset(u, d);
        return new o.Point((O / _ + R[0]) * w, (k / _ + R[1]) * w);
      }
      function Mm(u, h, c, d, _, w, E, O, k, R, q) {
        var $ = u.text.placedSymbolArray, W = u.text.dynamicLayoutVertexArray, ne = u.icon.dynamicLayoutVertexArray, re = {};
        W.clear();
        for (var se = 0; se < $.length; se++) {
          var J = $.get(se), ae = J.hidden || !J.crossTileID || u.allowVerticalPlacement && !J.placedOrientation ? null : d[J.crossTileID];
          if (ae) {
            var pe = new o.Point(J.anchorX, J.anchorY), _e = yr(pe, c ? O : E), Ce = Rr(w.cameraToCenterDistance, _e.signedDistanceFromCamera), Te = _.evaluateSizeForFeature(u.textSizeData, R, J) * Ce / o.ONE_EM;
            c && (Te *= u.tilePixelRatio / k);
            for (var Ae = Tm(ae.anchor, ae.width, ae.height, ae.textOffset, ae.textBoxScale, Te), je = c ? yr(pe.add(Ae), E).point : _e.point.add(h ? Ae.rotate(-w.angle) : Ae), tt = u.allowVerticalPlacement && J.placedOrientation === o.WritingMode.vertical ? Math.PI / 2 : 0, Qe = 0; Qe < J.numGlyphs; Qe++)
              o.addDynamicAttributes(W, je, tt);
            q && J.associatedIconIndex >= 0 && (re[J.associatedIconIndex] = { shiftedAnchor: je, angle: tt });
          } else
            Vi(J.numGlyphs, W);
        }
        if (q) {
          ne.clear();
          for (var gt = u.icon.placedSymbolArray, Dt = 0; Dt < gt.length; Dt++) {
            var Ft = gt.get(Dt);
            if (Ft.hidden)
              Vi(Ft.numGlyphs, ne);
            else {
              var zt = re[Dt];
              if (zt)
                for (var Tr = 0; Tr < Ft.numGlyphs; Tr++)
                  o.addDynamicAttributes(ne, zt.shiftedAnchor, zt.angle);
              else
                Vi(Ft.numGlyphs, ne);
            }
          }
          u.icon.dynamicLayoutVertexBuffer.updateData(ne);
        }
        u.text.dynamicLayoutVertexBuffer.updateData(W);
      }
      function Im(u, h, c) {
        return c.iconsInText && h ? "symbolTextAndIcon" : u ? "symbolSDF" : "symbolIcon";
      }
      function pl(u, h, c, d, _, w, E, O, k, R, q, $) {
        for (var W = u.context, ne = W.gl, re = u.transform, se = O === "map", J = k === "map", ae = se && c.layout.get("symbol-placement") !== "point", pe = se && !J && !ae, _e = c.layout.get("symbol-sort-key").constantOr(1) !== void 0, Ce = !1, Te = u.depthModeForSublayer(0, H.ReadOnly), Ae = c.layout.get("text-variable-anchor"), je = [], tt = 0, Qe = d; tt < Qe.length; tt += 1) {
          var gt = Qe[tt], Dt = h.getTile(gt), Ft = Dt.getBucket(c);
          if (Ft) {
            var zt = _ ? Ft.text : Ft.icon;
            if (zt && zt.segments.get().length) {
              var Tr = zt.programConfigurations.get(c.id), xt = _ || Ft.sdfIcons, Yt = _ ? Ft.textSizeData : Ft.iconSizeData, ir = J || re.pitch !== 0, Kt = u.useProgram(Im(xt, _, Ft), Tr), Xt = o.evaluateSizeForZoom(Yt, re.zoom), nr = void 0, Ht = [0, 0], qt = void 0, si = void 0, In = null, Li = void 0;
              if (_)
                qt = Dt.glyphAtlasTexture, si = ne.LINEAR, nr = Dt.glyphAtlasTexture.size, Ft.iconsInText && (Ht = Dt.imageAtlasTexture.size, In = Dt.imageAtlasTexture, Li = ir || u.options.rotating || u.options.zooming || Yt.kind === "composite" || Yt.kind === "camera" ? ne.LINEAR : ne.NEAREST);
              else {
                var gi = c.layout.get("icon-size").constantOr(0) !== 1 || Ft.iconsNeedLinear;
                qt = Dt.imageAtlasTexture, si = xt || u.options.rotating || u.options.zooming || gi || ir ? ne.LINEAR : ne.NEAREST, nr = Dt.imageAtlasTexture.size;
              }
              var Tn = dn(Dt, 1, u.transform.zoom), Ln = pn(gt.posMatrix, J, se, u.transform, Tn), mo = Br(gt.posMatrix, J, se, u.transform, Tn), qi = Ae && Ft.hasTextData(), Ms = c.layout.get("icon-text-fit") !== "none" && qi && Ft.hasIconData();
              ae && Uu(Ft, gt.posMatrix, u, _, Ln, mo, J, R);
              var Qi = u.translatePosMatrix(gt.posMatrix, Dt, w, E), ca = ae || _ && Ae || Ms ? oa : Ln, Zo = u.translatePosMatrix(mo, Dt, w, E, !0), sc = xt && c.paint.get(_ ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, ru = { program: Kt, buffers: zt, uniformValues: xt ? Ft.iconsInText ? lh(Yt.kind, Xt, pe, J, u, Qi, ca, Zo, nr, Ht) : Zu(Yt.kind, Xt, pe, J, u, Qi, ca, Zo, _, nr, !0) : Zl(Yt.kind, Xt, pe, J, u, Qi, ca, Zo, _, nr), atlasTexture: qt, atlasTextureIcon: In, atlasInterpolation: si, atlasInterpolationIcon: Li, isSDF: xt, hasHalo: sc };
              if (_e && Ft.canOverlap) {
                Ce = !0;
                for (var Is = 0, nu = zt.segments.get(); Is < nu.length; Is += 1) {
                  var lc = nu[Is];
                  je.push({ segments: new o.SegmentVector([lc]), sortKey: lc.sortKey, state: ru });
                }
              } else
                je.push({ segments: zt.segments, sortKey: 0, state: ru });
            }
          }
        }
        Ce && je.sort(function(Os, _l) {
          return Os.sortKey - _l.sortKey;
        });
        for (var Ea = 0, uc = je; Ea < uc.length; Ea += 1) {
          var Sa = uc[Ea], li = Sa.state;
          if (W.activeTexture.set(ne.TEXTURE0), li.atlasTexture.bind(li.atlasInterpolation, ne.CLAMP_TO_EDGE), li.atlasTextureIcon && (W.activeTexture.set(ne.TEXTURE1), li.atlasTextureIcon && li.atlasTextureIcon.bind(li.atlasInterpolationIcon, ne.CLAMP_TO_EDGE)), li.isSDF) {
            var qa = li.uniformValues;
            li.hasHalo && (qa.u_is_halo = 1, Ku(li.buffers, Sa.segments, c, u, li.program, Te, q, $, qa)), qa.u_is_halo = 0;
          }
          Ku(li.buffers, Sa.segments, c, u, li.program, Te, q, $, li.uniformValues);
        }
      }
      function Ku(u, h, c, d, _, w, E, O, k) {
        var R = d.context;
        _.draw(R, R.gl.TRIANGLES, w, E, O, fe.disabled, k, c.id, u.layoutVertexBuffer, u.indexBuffer, h, c.paint, d.transform.zoom, u.programConfigurations.get(c.id), u.dynamicLayoutVertexBuffer, u.opacityVertexBuffer);
      }
      function uh(u, h, c, d, _, w, E) {
        var O, k, R, q, $, W = u.context.gl, ne = c.paint.get("fill-pattern"), re = ne && ne.constantOr(1), se = c.getCrossfadeParameters();
        E ? (k = re && !c.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", O = W.LINES) : (k = re ? "fillPattern" : "fill", O = W.TRIANGLES);
        for (var J = 0, ae = d; J < ae.length; J += 1) {
          var pe = ae[J], _e = h.getTile(pe);
          if (!re || _e.patternsLoaded()) {
            var Ce = _e.getBucket(c);
            if (Ce) {
              var Te = Ce.programConfigurations.get(c.id), Ae = u.useProgram(k, Te);
              re && (u.context.activeTexture.set(W.TEXTURE0), _e.imageAtlasTexture.bind(W.LINEAR, W.CLAMP_TO_EDGE), Te.updatePaintBuffers(se));
              var je = ne.constantOr(null);
              if (je && _e.imageAtlas) {
                var tt = _e.imageAtlas, Qe = tt.patternPositions[je.to.toString()], gt = tt.patternPositions[je.from.toString()];
                Qe && gt && Te.setConstantPatternPositions(Qe, gt);
              }
              var Dt = u.translatePosMatrix(pe.posMatrix, _e, c.paint.get("fill-translate"), c.paint.get("fill-translate-anchor"));
              if (E) {
                q = Ce.indexBuffer2, $ = Ce.segments2;
                var Ft = [W.drawingBufferWidth, W.drawingBufferHeight];
                R = k === "fillOutlinePattern" && re ? _m(Dt, u, se, _e, Ft) : vm(Dt, Ft);
              } else
                q = Ce.indexBuffer, $ = Ce.segments, R = re ? ul(Dt, u, se, _e) : xs(Dt);
              Ae.draw(u.context, O, _, u.stencilModeForClipping(pe), w, fe.disabled, R, c.id, Ce.layoutVertexBuffer, q, $, c.paint, u.transform.zoom, Te);
            }
          }
        }
      }
      function Qf(u, h, c, d, _, w, E) {
        for (var O = u.context, k = O.gl, R = c.paint.get("fill-extrusion-pattern"), q = R.constantOr(1), $ = c.getCrossfadeParameters(), W = c.paint.get("fill-extrusion-opacity"), ne = 0, re = d; ne < re.length; ne += 1) {
          var se = re[ne], J = h.getTile(se), ae = J.getBucket(c);
          if (ae) {
            var pe = ae.programConfigurations.get(c.id), _e = u.useProgram(q ? "fillExtrusionPattern" : "fillExtrusion", pe);
            q && (u.context.activeTexture.set(k.TEXTURE0), J.imageAtlasTexture.bind(k.LINEAR, k.CLAMP_TO_EDGE), pe.updatePaintBuffers($));
            var Ce = R.constantOr(null);
            if (Ce && J.imageAtlas) {
              var Te = J.imageAtlas, Ae = Te.patternPositions[Ce.to.toString()], je = Te.patternPositions[Ce.from.toString()];
              Ae && je && pe.setConstantPatternPositions(Ae, je);
            }
            var tt = u.translatePosMatrix(se.posMatrix, J, c.paint.get("fill-extrusion-translate"), c.paint.get("fill-extrusion-translate-anchor")), Qe = c.paint.get("fill-extrusion-vertical-gradient"), gt = q ? ll(tt, u, Qe, W, se, $, J) : gm(tt, u, Qe, W);
            _e.draw(O, O.gl.TRIANGLES, _, w, E, fe.backCCW, gt, c.id, ae.layoutVertexBuffer, ae.indexBuffer, ae.segments, c.paint, u.transform.zoom, pe);
          }
        }
      }
      function ch(u, h, c, d, _, w) {
        var E = u.context, O = E.gl, k = h.fbo;
        if (k) {
          var R = u.useProgram("hillshade");
          E.activeTexture.set(O.TEXTURE0), O.bindTexture(O.TEXTURE_2D, k.colorAttachment.get());
          var q = function($, W, ne) {
            var re = ne.paint.get("hillshade-shadow-color"), se = ne.paint.get("hillshade-highlight-color"), J = ne.paint.get("hillshade-accent-color"), ae = ne.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            ne.paint.get("hillshade-illumination-anchor") === "viewport" && (ae -= $.transform.angle);
            var pe, _e, Ce, Te = !$.options.moving;
            return { u_matrix: $.transform.calculatePosMatrix(W.tileID.toUnwrapped(), Te), u_image: 0, u_latrange: (pe = W.tileID, _e = Math.pow(2, pe.canonical.z), Ce = pe.canonical.y, [new o.MercatorCoordinate(0, Ce / _e).toLngLat().lat, new o.MercatorCoordinate(0, (Ce + 1) / _e).toLngLat().lat]), u_light: [ne.paint.get("hillshade-exaggeration"), ae], u_shadow: re, u_highlight: se, u_accent: J };
          }(u, h, c);
          R.draw(E, O.TRIANGLES, d, _, w, fe.disabled, q, c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments);
        }
      }
      function qv(u, h, c, d, _, w) {
        var E = u.context, O = E.gl, k = h.dem;
        if (k && k.data) {
          var R = k.dim, q = k.stride, $ = k.getPixels();
          if (E.activeTexture.set(O.TEXTURE1), E.pixelStoreUnpackPremultiplyAlpha.set(!1), h.demTexture = h.demTexture || u.getTileTexture(q), h.demTexture) {
            var W = h.demTexture;
            W.update($, { premultiply: !1 }), W.bind(O.NEAREST, O.CLAMP_TO_EDGE);
          } else
            h.demTexture = new o.Texture(E, $, O.RGBA, { premultiply: !1 }), h.demTexture.bind(O.NEAREST, O.CLAMP_TO_EDGE);
          E.activeTexture.set(O.TEXTURE0);
          var ne = h.fbo;
          if (!ne) {
            var re = new o.Texture(E, { width: R, height: R, data: null }, O.RGBA);
            re.bind(O.LINEAR, O.CLAMP_TO_EDGE), (ne = h.fbo = E.createFramebuffer(R, R, !0)).colorAttachment.set(re.texture);
          }
          E.bindFramebuffer.set(ne.framebuffer), E.viewport.set([0, 0, R, R]), u.useProgram("hillshadePrepare").draw(E, O.TRIANGLES, d, _, w, fe.disabled, function(se, J) {
            var ae = J.stride, pe = o.create();
            return o.ortho(pe, 0, o.EXTENT, -o.EXTENT, 0, 0, 1), o.translate(pe, pe, [0, -o.EXTENT, 0]), { u_matrix: pe, u_image: 1, u_dimension: [ae, ae], u_zoom: se.overscaledZ, u_unpack: J.getUnpackVector() };
          }(h.tileID, k), c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments), h.needsHillshadePrepare = !1;
        }
      }
      function hh(u, h, c, d, _) {
        var w = d.paint.get("raster-fade-duration");
        if (w > 0) {
          var E = o.browser.now(), O = (E - u.timeAdded) / w, k = h ? (E - h.timeAdded) / w : -1, R = c.getSource(), q = _.coveringZoomLevel({ tileSize: R.tileSize, roundZoom: R.roundZoom }), $ = !h || Math.abs(h.tileID.overscaledZ - q) > Math.abs(u.tileID.overscaledZ - q), W = $ && u.refreshedUponExpiration ? 1 : o.clamp($ ? O : 1 - k, 0, 1);
          return u.refreshedUponExpiration && O >= 1 && (u.refreshedUponExpiration = !1), h ? { opacity: 1, mix: 1 - W } : { opacity: W, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      var ep = new o.Color(1, 0, 0, 1), Om = new o.Color(0, 1, 0, 1), Cm = new o.Color(0, 0, 1, 1), fh = new o.Color(1, 0, 1, 1), tp = new o.Color(0, 1, 1, 1);
      function rp(u, h, c, d) {
        Yu(u, 0, h + c / 2, u.transform.width, c, d);
      }
      function np(u, h, c, d) {
        Yu(u, h - c / 2, 0, c, u.transform.height, d);
      }
      function Yu(u, h, c, d, _, w) {
        var E = u.context, O = E.gl;
        O.enable(O.SCISSOR_TEST), O.scissor(h * o.browser.devicePixelRatio, c * o.browser.devicePixelRatio, d * o.browser.devicePixelRatio, _ * o.browser.devicePixelRatio), E.clear({ color: w }), O.disable(O.SCISSOR_TEST);
      }
      function Am(u, h, c) {
        var d = u.context, _ = d.gl, w = c.posMatrix, E = u.useProgram("debug"), O = H.disabled, k = ee.disabled, R = u.colorModeForRenderPass();
        d.activeTexture.set(_.TEXTURE0), u.emptyTexture.bind(_.LINEAR, _.CLAMP_TO_EDGE), E.draw(d, _.LINE_STRIP, O, k, R, fe.disabled, hl(w, o.Color.red), "$debug", u.debugBuffer, u.tileBorderIndexBuffer, u.debugSegments);
        var q = h.getTileByID(c.key).latestRawTileData, $ = Math.floor((q && q.byteLength || 0) / 1024), W = h.getTile(c).tileSize, ne = 512 / Math.min(W, 512) * (c.overscaledZ / u.transform.zoom) * 0.5, re = c.canonical.toString();
        c.overscaledZ !== c.canonical.z && (re += " => " + c.overscaledZ), function(se, J) {
          se.initDebugOverlayCanvas();
          var ae = se.debugOverlayCanvas, pe = se.context.gl, _e = se.debugOverlayCanvas.getContext("2d");
          _e.clearRect(0, 0, ae.width, ae.height), _e.shadowColor = "white", _e.shadowBlur = 2, _e.lineWidth = 1.5, _e.strokeStyle = "white", _e.textBaseline = "top", _e.font = "bold 36px Open Sans, sans-serif", _e.fillText(J, 5, 5), _e.strokeText(J, 5, 5), se.debugOverlayTexture.update(ae), se.debugOverlayTexture.bind(pe.LINEAR, pe.CLAMP_TO_EDGE);
        }(u, re + " " + $ + "kb"), E.draw(d, _.TRIANGLES, O, k, he.alphaBlended, fe.disabled, hl(w, o.Color.transparent, ne), "$debug", u.debugBuffer, u.quadTriangleIndexBuffer, u.debugSegments);
      }
      var dl = { symbol: function(u, h, c, d, _) {
        if (u.renderPass === "translucent") {
          var w = ee.disabled, E = u.colorModeForRenderPass();
          c.layout.get("text-variable-anchor") && function(O, k, R, q, $, W, ne) {
            for (var re = k.transform, se = $ === "map", J = W === "map", ae = 0, pe = O; ae < pe.length; ae += 1) {
              var _e = pe[ae], Ce = q.getTile(_e), Te = Ce.getBucket(R);
              if (Te && Te.text && Te.text.segments.get().length) {
                var Ae = o.evaluateSizeForZoom(Te.textSizeData, re.zoom), je = dn(Ce, 1, k.transform.zoom), tt = pn(_e.posMatrix, J, se, k.transform, je), Qe = R.layout.get("icon-text-fit") !== "none" && Te.hasIconData();
                if (Ae) {
                  var gt = Math.pow(2, re.zoom - Ce.tileID.overscaledZ);
                  Mm(Te, se, J, ne, o.symbolSize, re, tt, _e.posMatrix, gt, Ae, Qe);
                }
              }
            }
          }(d, u, c, h, c.layout.get("text-rotation-alignment"), c.layout.get("text-pitch-alignment"), _), c.paint.get("icon-opacity").constantOr(1) !== 0 && pl(u, h, c, d, !1, c.paint.get("icon-translate"), c.paint.get("icon-translate-anchor"), c.layout.get("icon-rotation-alignment"), c.layout.get("icon-pitch-alignment"), c.layout.get("icon-keep-upright"), w, E), c.paint.get("text-opacity").constantOr(1) !== 0 && pl(u, h, c, d, !0, c.paint.get("text-translate"), c.paint.get("text-translate-anchor"), c.layout.get("text-rotation-alignment"), c.layout.get("text-pitch-alignment"), c.layout.get("text-keep-upright"), w, E), h.map.showCollisionBoxes && (Kl(u, h, c, d, c.paint.get("text-translate"), c.paint.get("text-translate-anchor"), !0), Kl(u, h, c, d, c.paint.get("icon-translate"), c.paint.get("icon-translate-anchor"), !1));
        }
      }, circle: function(u, h, c, d) {
        if (u.renderPass === "translucent") {
          var _ = c.paint.get("circle-opacity"), w = c.paint.get("circle-stroke-width"), E = c.paint.get("circle-stroke-opacity"), O = c.layout.get("circle-sort-key").constantOr(1) !== void 0;
          if (_.constantOr(1) !== 0 || w.constantOr(1) !== 0 && E.constantOr(1) !== 0) {
            for (var k = u.context, R = k.gl, q = u.depthModeForSublayer(0, H.ReadOnly), $ = ee.disabled, W = u.colorModeForRenderPass(), ne = [], re = 0; re < d.length; re++) {
              var se = d[re], J = h.getTile(se), ae = J.getBucket(c);
              if (ae) {
                var pe = ae.programConfigurations.get(c.id), _e = { programConfiguration: pe, program: u.useProgram("circle", pe), layoutVertexBuffer: ae.layoutVertexBuffer, indexBuffer: ae.indexBuffer, uniformValues: Jf(u, se, J, c) };
                if (O)
                  for (var Ce = 0, Te = ae.segments.get(); Ce < Te.length; Ce += 1) {
                    var Ae = Te[Ce];
                    ne.push({ segments: new o.SegmentVector([Ae]), sortKey: Ae.sortKey, state: _e });
                  }
                else
                  ne.push({ segments: ae.segments, sortKey: 0, state: _e });
              }
            }
            O && ne.sort(function(Dt, Ft) {
              return Dt.sortKey - Ft.sortKey;
            });
            for (var je = 0, tt = ne; je < tt.length; je += 1) {
              var Qe = tt[je], gt = Qe.state;
              gt.program.draw(k, R.TRIANGLES, q, $, W, fe.disabled, gt.uniformValues, c.id, gt.layoutVertexBuffer, gt.indexBuffer, Qe.segments, c.paint, u.transform.zoom, gt.programConfiguration);
            }
          }
        }
      }, heatmap: function(u, h, c, d) {
        if (c.paint.get("heatmap-opacity") !== 0)
          if (u.renderPass === "offscreen") {
            var _ = u.context, w = _.gl, E = ee.disabled, O = new he([w.ONE, w.ONE], o.Color.transparent, [!0, !0, !0, !0]);
            (function(ne, re, se) {
              var J = ne.gl;
              ne.activeTexture.set(J.TEXTURE1), ne.viewport.set([0, 0, re.width / 4, re.height / 4]);
              var ae = se.heatmapFbo;
              if (ae)
                J.bindTexture(J.TEXTURE_2D, ae.colorAttachment.get()), ne.bindFramebuffer.set(ae.framebuffer);
              else {
                var pe = J.createTexture();
                J.bindTexture(J.TEXTURE_2D, pe), J.texParameteri(J.TEXTURE_2D, J.TEXTURE_WRAP_S, J.CLAMP_TO_EDGE), J.texParameteri(J.TEXTURE_2D, J.TEXTURE_WRAP_T, J.CLAMP_TO_EDGE), J.texParameteri(J.TEXTURE_2D, J.TEXTURE_MIN_FILTER, J.LINEAR), J.texParameteri(J.TEXTURE_2D, J.TEXTURE_MAG_FILTER, J.LINEAR), ae = se.heatmapFbo = ne.createFramebuffer(re.width / 4, re.height / 4, !1), function(_e, Ce, Te, Ae) {
                  var je = _e.gl;
                  je.texImage2D(je.TEXTURE_2D, 0, je.RGBA, Ce.width / 4, Ce.height / 4, 0, je.RGBA, _e.extRenderToTextureHalfFloat ? _e.extTextureHalfFloat.HALF_FLOAT_OES : je.UNSIGNED_BYTE, null), Ae.colorAttachment.set(Te);
                }(ne, re, pe, ae);
              }
            })(_, u, c), _.clear({ color: o.Color.transparent });
            for (var k = 0; k < d.length; k++) {
              var R = d[k];
              if (!h.hasRenderableParent(R)) {
                var q = h.getTile(R), $ = q.getBucket(c);
                if ($) {
                  var W = $.programConfigurations.get(c.id);
                  u.useProgram("heatmap", W).draw(_, w.TRIANGLES, H.disabled, E, O, fe.disabled, bm(R.posMatrix, q, u.transform.zoom, c.paint.get("heatmap-intensity")), c.id, $.layoutVertexBuffer, $.indexBuffer, $.segments, c.paint, u.transform.zoom, W);
                }
              }
            }
            _.viewport.set([0, 0, u.width, u.height]);
          } else
            u.renderPass === "translucent" && (u.context.setColorMode(u.colorModeForRenderPass()), function(ne, re) {
              var se = ne.context, J = se.gl, ae = re.heatmapFbo;
              if (ae) {
                se.activeTexture.set(J.TEXTURE0), J.bindTexture(J.TEXTURE_2D, ae.colorAttachment.get()), se.activeTexture.set(J.TEXTURE1);
                var pe = re.colorRampTexture;
                pe || (pe = re.colorRampTexture = new o.Texture(se, re.colorRamp, J.RGBA)), pe.bind(J.LINEAR, J.CLAMP_TO_EDGE), ne.useProgram("heatmapTexture").draw(se, J.TRIANGLES, H.disabled, ee.disabled, ne.colorModeForRenderPass(), fe.disabled, function(_e, Ce, Te, Ae) {
                  var je = o.create();
                  o.ortho(je, 0, _e.width, _e.height, 0, 0, 1);
                  var tt = _e.context.gl;
                  return { u_matrix: je, u_world: [tt.drawingBufferWidth, tt.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: Ce.paint.get("heatmap-opacity") };
                }(ne, re), re.id, ne.viewportBuffer, ne.quadTriangleIndexBuffer, ne.viewportSegments, re.paint, ne.transform.zoom);
              }
            }(u, c));
      }, line: function(u, h, c, d) {
        if (u.renderPass === "translucent") {
          var _ = c.paint.get("line-opacity"), w = c.paint.get("line-width");
          if (_.constantOr(1) !== 0 && w.constantOr(1) !== 0)
            for (var E = u.depthModeForSublayer(0, H.ReadOnly), O = u.colorModeForRenderPass(), k = c.paint.get("line-dasharray"), R = c.paint.get("line-pattern"), q = R.constantOr(1), $ = c.paint.get("line-gradient"), W = c.getCrossfadeParameters(), ne = q ? "linePattern" : k ? "lineSDF" : $ ? "lineGradient" : "line", re = u.context, se = re.gl, J = !0, ae = 0, pe = d; ae < pe.length; ae += 1) {
              var _e = pe[ae], Ce = h.getTile(_e);
              if (!q || Ce.patternsLoaded()) {
                var Te = Ce.getBucket(c);
                if (Te) {
                  var Ae = Te.programConfigurations.get(c.id), je = u.context.program.get(), tt = u.useProgram(ne, Ae), Qe = J || tt.program !== je, gt = R.constantOr(null);
                  if (gt && Ce.imageAtlas) {
                    var Dt = Ce.imageAtlas, Ft = Dt.patternPositions[gt.to.toString()], zt = Dt.patternPositions[gt.from.toString()];
                    Ft && zt && Ae.setConstantPatternPositions(Ft, zt);
                  }
                  var Tr = q ? ah(u, Ce, c, W) : k ? jv(u, Ce, c, k, W) : $ ? Qr(u, Ce, c, Te.lineClipsArray.length) : Hu(u, Ce, c);
                  if (q)
                    re.activeTexture.set(se.TEXTURE0), Ce.imageAtlasTexture.bind(se.LINEAR, se.CLAMP_TO_EDGE), Ae.updatePaintBuffers(W);
                  else if (k && (Qe || u.lineAtlas.dirty))
                    re.activeTexture.set(se.TEXTURE0), u.lineAtlas.bind(re);
                  else if ($) {
                    var xt = Te.gradients[c.id], Yt = xt.texture;
                    if (c.gradientVersion !== xt.version) {
                      var ir = 256;
                      if (c.stepInterpolant) {
                        var Kt = h.getSource().maxzoom, Xt = _e.canonical.z === Kt ? Math.ceil(1 << u.transform.maxZoom - _e.canonical.z) : 1;
                        ir = o.clamp(o.nextPowerOfTwo(Te.maxLineLength / o.EXTENT * 1024 * Xt), 256, re.maxTextureSize);
                      }
                      xt.gradient = o.renderColorRamp({ expression: c.gradientExpression(), evaluationKey: "lineProgress", resolution: ir, image: xt.gradient || void 0, clips: Te.lineClipsArray }), xt.texture ? xt.texture.update(xt.gradient) : xt.texture = new o.Texture(re, xt.gradient, se.RGBA), xt.version = c.gradientVersion, Yt = xt.texture;
                    }
                    re.activeTexture.set(se.TEXTURE0), Yt.bind(c.stepInterpolant ? se.NEAREST : se.LINEAR, se.CLAMP_TO_EDGE);
                  }
                  tt.draw(re, se.TRIANGLES, E, u.stencilModeForClipping(_e), O, fe.disabled, Tr, c.id, Te.layoutVertexBuffer, Te.indexBuffer, Te.segments, c.paint, u.transform.zoom, Ae, Te.layoutVertexBuffer2), J = !1;
                }
              }
            }
        }
      }, fill: function(u, h, c, d) {
        var _ = c.paint.get("fill-color"), w = c.paint.get("fill-opacity");
        if (w.constantOr(1) !== 0) {
          var E = u.colorModeForRenderPass(), O = c.paint.get("fill-pattern"), k = u.opaquePassEnabledForLayer() && !O.constantOr(1) && _.constantOr(o.Color.transparent).a === 1 && w.constantOr(0) === 1 ? "opaque" : "translucent";
          if (u.renderPass === k) {
            var R = u.depthModeForSublayer(1, u.renderPass === "opaque" ? H.ReadWrite : H.ReadOnly);
            uh(u, h, c, d, R, E, !1);
          }
          if (u.renderPass === "translucent" && c.paint.get("fill-antialias")) {
            var q = u.depthModeForSublayer(c.getPaintProperty("fill-outline-color") ? 2 : 0, H.ReadOnly);
            uh(u, h, c, d, q, E, !0);
          }
        }
      }, "fill-extrusion": function(u, h, c, d) {
        var _ = c.paint.get("fill-extrusion-opacity");
        if (_ !== 0 && u.renderPass === "translucent") {
          var w = new H(u.context.gl.LEQUAL, H.ReadWrite, u.depthRangeFor3D);
          if (_ !== 1 || c.paint.get("fill-extrusion-pattern").constantOr(1))
            Qf(u, h, c, d, w, ee.disabled, he.disabled), Qf(u, h, c, d, w, u.stencilModeFor3D(), u.colorModeForRenderPass());
          else {
            var E = u.colorModeForRenderPass();
            Qf(u, h, c, d, w, ee.disabled, E);
          }
        }
      }, hillshade: function(u, h, c, d) {
        if (u.renderPass === "offscreen" || u.renderPass === "translucent") {
          for (var _ = u.context, w = u.depthModeForSublayer(0, H.ReadOnly), E = u.colorModeForRenderPass(), O = u.renderPass === "translucent" ? u.stencilConfigForOverlap(d) : [{}, d], k = O[0], R = 0, q = O[1]; R < q.length; R += 1) {
            var $ = q[R], W = h.getTile($);
            W.needsHillshadePrepare && u.renderPass === "offscreen" ? qv(u, W, c, w, ee.disabled, E) : u.renderPass === "translucent" && ch(u, W, c, w, k[$.overscaledZ], E);
          }
          _.viewport.set([0, 0, u.width, u.height]);
        }
      }, raster: function(u, h, c, d) {
        if (u.renderPass === "translucent" && c.paint.get("raster-opacity") !== 0 && d.length)
          for (var _ = u.context, w = _.gl, E = h.getSource(), O = u.useProgram("raster"), k = u.colorModeForRenderPass(), R = E instanceof hr ? [{}, d] : u.stencilConfigForOverlap(d), q = R[0], $ = R[1], W = $[$.length - 1].overscaledZ, ne = !u.options.moving, re = 0, se = $; re < se.length; re += 1) {
            var J = se[re], ae = u.depthModeForSublayer(J.overscaledZ - W, c.paint.get("raster-opacity") === 1 ? H.ReadWrite : H.ReadOnly, w.LESS), pe = h.getTile(J), _e = u.transform.calculatePosMatrix(J.toUnwrapped(), ne);
            pe.registerFadeDuration(c.paint.get("raster-fade-duration"));
            var Ce = h.findLoadedParent(J, 0), Te = hh(pe, Ce, h, c, u.transform), Ae = void 0, je = void 0, tt = c.paint.get("raster-resampling") === "nearest" ? w.NEAREST : w.LINEAR;
            _.activeTexture.set(w.TEXTURE0), pe.texture.bind(tt, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST), _.activeTexture.set(w.TEXTURE1), Ce ? (Ce.texture.bind(tt, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST), Ae = Math.pow(2, Ce.tileID.overscaledZ - pe.tileID.overscaledZ), je = [pe.tileID.canonical.x * Ae % 1, pe.tileID.canonical.y * Ae % 1]) : pe.texture.bind(tt, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST);
            var Qe = Gv(_e, je || [0, 0], Ae || 1, Te, c);
            E instanceof hr ? O.draw(_, w.TRIANGLES, ae, ee.disabled, k, fe.disabled, Qe, c.id, E.boundsBuffer, u.quadTriangleIndexBuffer, E.boundsSegments) : O.draw(_, w.TRIANGLES, ae, q[J.overscaledZ], k, fe.disabled, Qe, c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments);
          }
      }, background: function(u, h, c) {
        var d = c.paint.get("background-color"), _ = c.paint.get("background-opacity");
        if (_ !== 0) {
          var w = u.context, E = w.gl, O = u.transform, k = O.tileSize, R = c.paint.get("background-pattern");
          if (!u.isPatternMissing(R)) {
            var q = !R && d.a === 1 && _ === 1 && u.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (u.renderPass === q) {
              var $ = ee.disabled, W = u.depthModeForSublayer(0, q === "opaque" ? H.ReadWrite : H.ReadOnly), ne = u.colorModeForRenderPass(), re = u.useProgram(R ? "backgroundPattern" : "background"), se = O.coveringTiles({ tileSize: k });
              R && (w.activeTexture.set(E.TEXTURE0), u.imageManager.bind(u.context));
              for (var J = c.getCrossfadeParameters(), ae = 0, pe = se; ae < pe.length; ae += 1) {
                var _e = pe[ae], Ce = u.transform.calculatePosMatrix(_e.toUnwrapped()), Te = R ? Xl(Ce, _, u, R, { tileID: _e, tileSize: k }, J) : Xu(Ce, _, d);
                re.draw(w, E.TRIANGLES, W, $, ne, fe.disabled, Te, c.id, u.tileExtentBuffer, u.quadTriangleIndexBuffer, u.tileExtentSegments);
              }
            }
          }
        }
      }, debug: function(u, h, c) {
        for (var d = 0; d < c.length; d++)
          Am(u, h, c[d]);
      }, custom: function(u, h, c) {
        var d = u.context, _ = c.implementation;
        if (u.renderPass === "offscreen") {
          var w = _.prerender;
          w && (u.setCustomLayerDefaults(), d.setColorMode(u.colorModeForRenderPass()), w.call(_, d.gl, u.transform.customLayerMatrix()), d.setDirty(), u.setBaseState());
        } else if (u.renderPass === "translucent") {
          u.setCustomLayerDefaults(), d.setColorMode(u.colorModeForRenderPass()), d.setStencilMode(ee.disabled);
          var E = _.renderingMode === "3d" ? new H(u.context.gl.LEQUAL, H.ReadWrite, u.depthRangeFor3D) : u.depthModeForSublayer(0, H.ReadOnly);
          d.setDepthMode(E), _.render(d.gl, u.transform.customLayerMatrix()), d.setDirty(), u.setBaseState(), d.bindFramebuffer.set(null);
        }
      } }, mn = function(u, h) {
        this.context = new G(u), this.transform = h, this._tileTextures = {}, this.setup(), this.numSublayers = ie.maxUnderzooming + ie.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new ps(), this.gpuTimers = {};
      };
      mn.prototype.resize = function(u, h) {
        if (this.width = u * o.browser.devicePixelRatio, this.height = h * o.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
          for (var c = 0, d = this.style._order; c < d.length; c += 1)
            this.style._layers[d[c]].resize();
      }, mn.prototype.setup = function() {
        var u = this.context, h = new o.StructArrayLayout2i4();
        h.emplaceBack(0, 0), h.emplaceBack(o.EXTENT, 0), h.emplaceBack(0, o.EXTENT), h.emplaceBack(o.EXTENT, o.EXTENT), this.tileExtentBuffer = u.createVertexBuffer(h, jn.members), this.tileExtentSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
        var c = new o.StructArrayLayout2i4();
        c.emplaceBack(0, 0), c.emplaceBack(o.EXTENT, 0), c.emplaceBack(0, o.EXTENT), c.emplaceBack(o.EXTENT, o.EXTENT), this.debugBuffer = u.createVertexBuffer(c, jn.members), this.debugSegments = o.SegmentVector.simpleSegment(0, 0, 4, 5);
        var d = new o.StructArrayLayout4i8();
        d.emplaceBack(0, 0, 0, 0), d.emplaceBack(o.EXTENT, 0, o.EXTENT, 0), d.emplaceBack(0, o.EXTENT, 0, o.EXTENT), d.emplaceBack(o.EXTENT, o.EXTENT, o.EXTENT, o.EXTENT), this.rasterBoundsBuffer = u.createVertexBuffer(d, Dr.members), this.rasterBoundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
        var _ = new o.StructArrayLayout2i4();
        _.emplaceBack(0, 0), _.emplaceBack(1, 0), _.emplaceBack(0, 1), _.emplaceBack(1, 1), this.viewportBuffer = u.createVertexBuffer(_, jn.members), this.viewportSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
        var w = new o.StructArrayLayout1ui2();
        w.emplaceBack(0), w.emplaceBack(1), w.emplaceBack(3), w.emplaceBack(2), w.emplaceBack(0), this.tileBorderIndexBuffer = u.createIndexBuffer(w);
        var E = new o.StructArrayLayout3ui6();
        E.emplaceBack(0, 1, 2), E.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = u.createIndexBuffer(E), this.emptyTexture = new o.Texture(u, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, u.gl.RGBA);
        var O = this.context.gl;
        this.stencilClearMode = new ee({ func: O.ALWAYS, mask: 0 }, 0, 255, O.ZERO, O.ZERO, O.ZERO);
      }, mn.prototype.clearStencil = function() {
        var u = this.context, h = u.gl;
        this.nextStencilID = 1, this.currentStencilSource = void 0;
        var c = o.create();
        o.ortho(c, 0, this.width, this.height, 0, 0, 1), o.scale(c, c, [h.drawingBufferWidth, h.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(u, h.TRIANGLES, H.disabled, this.stencilClearMode, he.disabled, fe.disabled, fl(c), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
      }, mn.prototype._renderTileClippingMasks = function(u, h) {
        if (this.currentStencilSource !== u.source && u.isTileClipped() && h && h.length) {
          this.currentStencilSource = u.source;
          var c = this.context, d = c.gl;
          this.nextStencilID + h.length > 256 && this.clearStencil(), c.setColorMode(he.disabled), c.setDepthMode(H.disabled);
          var _ = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (var w = 0, E = h; w < E.length; w += 1) {
            var O = E[w], k = this._tileClippingMaskIDs[O.key] = this.nextStencilID++;
            _.draw(c, d.TRIANGLES, H.disabled, new ee({ func: d.ALWAYS, mask: 0 }, k, 255, d.KEEP, d.KEEP, d.REPLACE), he.disabled, fe.disabled, fl(O.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
      }, mn.prototype.stencilModeFor3D = function() {
        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
        var u = this.nextStencilID++, h = this.context.gl;
        return new ee({ func: h.NOTEQUAL, mask: 255 }, u, 255, h.KEEP, h.KEEP, h.REPLACE);
      }, mn.prototype.stencilModeForClipping = function(u) {
        var h = this.context.gl;
        return new ee({ func: h.EQUAL, mask: 255 }, this._tileClippingMaskIDs[u.key], 0, h.KEEP, h.KEEP, h.REPLACE);
      }, mn.prototype.stencilConfigForOverlap = function(u) {
        var h, c = this.context.gl, d = u.sort(function(k, R) {
          return R.overscaledZ - k.overscaledZ;
        }), _ = d[d.length - 1].overscaledZ, w = d[0].overscaledZ - _ + 1;
        if (w > 1) {
          this.currentStencilSource = void 0, this.nextStencilID + w > 256 && this.clearStencil();
          for (var E = {}, O = 0; O < w; O++)
            E[O + _] = new ee({ func: c.GEQUAL, mask: 255 }, O + this.nextStencilID, 255, c.KEEP, c.KEEP, c.REPLACE);
          return this.nextStencilID += w, [E, d];
        }
        return [(h = {}, h[_] = ee.disabled, h), d];
      }, mn.prototype.colorModeForRenderPass = function() {
        var u = this.context.gl;
        return this._showOverdrawInspector ? new he([u.CONSTANT_COLOR, u.ONE], new o.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? he.unblended : he.alphaBlended;
      }, mn.prototype.depthModeForSublayer = function(u, h, c) {
        if (!this.opaquePassEnabledForLayer())
          return H.disabled;
        var d = 1 - ((1 + this.currentLayer) * this.numSublayers + u) * this.depthEpsilon;
        return new H(c || this.context.gl.LEQUAL, h, [d, d]);
      }, mn.prototype.opaquePassEnabledForLayer = function() {
        return this.currentLayer < this.opaquePassCutoff;
      }, mn.prototype.render = function(u, h) {
        var c = this;
        this.style = u, this.options = h, this.lineAtlas = u.lineAtlas, this.imageManager = u.imageManager, this.glyphManager = u.glyphManager, this.symbolFadeChange = u.placement.symbolFadeChange(o.browser.now()), this.imageManager.beginFrame();
        var d = this.style._order, _ = this.style.sourceCaches;
        for (var w in _) {
          var E = _[w];
          E.used && E.prepare(this.context);
        }
        var O, k, R = {}, q = {}, $ = {};
        for (var W in _) {
          var ne = _[W];
          R[W] = ne.getVisibleCoordinates(), q[W] = R[W].slice().reverse(), $[W] = ne.getVisibleCoordinates(!0).reverse();
        }
        this.opaquePassCutoff = 1 / 0;
        for (var re = 0; re < d.length; re++)
          if (this.style._layers[d[re]].is3D()) {
            this.opaquePassCutoff = re;
            break;
          }
        this.renderPass = "offscreen";
        for (var se = 0, J = d; se < J.length; se += 1) {
          var ae = this.style._layers[J[se]];
          if (ae.hasOffscreenPass() && !ae.isHidden(this.transform.zoom)) {
            var pe = q[ae.source];
            (ae.type === "custom" || pe.length) && this.renderLayer(this, _[ae.source], ae, pe);
          }
        }
        for (this.context.bindFramebuffer.set(null), this.context.clear({ color: h.showOverdrawInspector ? o.Color.black : o.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = h.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (u._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
          var _e = this.style._layers[d[this.currentLayer]], Ce = _[_e.source], Te = R[_e.source];
          this._renderTileClippingMasks(_e, Te), this.renderLayer(this, Ce, _e, Te);
        }
        for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
          var Ae = this.style._layers[d[this.currentLayer]], je = _[Ae.source], tt = (Ae.type === "symbol" ? $ : q)[Ae.source];
          this._renderTileClippingMasks(Ae, R[Ae.source]), this.renderLayer(this, je, Ae, tt);
        }
        this.options.showTileBoundaries && (o.values(this.style._layers).forEach(function(Qe) {
          Qe.source && !Qe.isHidden(c.transform.zoom) && (Qe.source !== (k && k.id) && (k = c.style.sourceCaches[Qe.source]), (!O || O.getSource().maxzoom < k.getSource().maxzoom) && (O = k));
        }), O && dl.debug(this, O, O.getVisibleCoordinates())), this.options.showPadding && function(Qe) {
          var gt = Qe.transform.padding;
          rp(Qe, Qe.transform.height - (gt.top || 0), 3, ep), rp(Qe, gt.bottom || 0, 3, Om), np(Qe, gt.left || 0, 3, Cm), np(Qe, Qe.transform.width - (gt.right || 0), 3, fh);
          var Dt = Qe.transform.centerPoint;
          (function(Ft, zt, Tr, xt) {
            Yu(Ft, zt - 1, Tr - 10, 2, 20, xt), Yu(Ft, zt - 10, Tr - 1, 20, 2, xt);
          })(Qe, Dt.x, Qe.transform.height - Dt.y, tp);
        }(this), this.context.setDefault();
      }, mn.prototype.renderLayer = function(u, h, c, d) {
        c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "custom" || d.length) && (this.id = c.id, this.gpuTimingStart(c), dl[c.type](u, h, c, d, this.style.placement.variableOffsets), this.gpuTimingEnd());
      }, mn.prototype.gpuTimingStart = function(u) {
        if (this.options.gpuTiming) {
          var h = this.context.extTimerQuery, c = this.gpuTimers[u.id];
          c || (c = this.gpuTimers[u.id] = { calls: 0, cpuTime: 0, query: h.createQueryEXT() }), c.calls++, h.beginQueryEXT(h.TIME_ELAPSED_EXT, c.query);
        }
      }, mn.prototype.gpuTimingEnd = function() {
        if (this.options.gpuTiming) {
          var u = this.context.extTimerQuery;
          u.endQueryEXT(u.TIME_ELAPSED_EXT);
        }
      }, mn.prototype.collectGpuTimers = function() {
        var u = this.gpuTimers;
        return this.gpuTimers = {}, u;
      }, mn.prototype.queryGpuTimers = function(u) {
        var h = {};
        for (var c in u) {
          var d = u[c], _ = this.context.extTimerQuery, w = _.getQueryObjectEXT(d.query, _.QUERY_RESULT_EXT) / 1e6;
          _.deleteQueryEXT(d.query), h[c] = w;
        }
        return h;
      }, mn.prototype.translatePosMatrix = function(u, h, c, d, _) {
        if (!c[0] && !c[1])
          return u;
        var w = _ ? d === "map" ? this.transform.angle : 0 : d === "viewport" ? -this.transform.angle : 0;
        if (w) {
          var E = Math.sin(w), O = Math.cos(w);
          c = [c[0] * O - c[1] * E, c[0] * E + c[1] * O];
        }
        var k = [_ ? c[0] : dn(h, c[0], this.transform.zoom), _ ? c[1] : dn(h, c[1], this.transform.zoom), 0], R = new Float32Array(16);
        return o.translate(R, u, k), R;
      }, mn.prototype.saveTileTexture = function(u) {
        var h = this._tileTextures[u.size[0]];
        h ? h.push(u) : this._tileTextures[u.size[0]] = [u];
      }, mn.prototype.getTileTexture = function(u) {
        var h = this._tileTextures[u];
        return h && h.length > 0 ? h.pop() : null;
      }, mn.prototype.isPatternMissing = function(u) {
        if (!u)
          return !1;
        if (!u.from || !u.to)
          return !0;
        var h = this.imageManager.getPattern(u.from.toString()), c = this.imageManager.getPattern(u.to.toString());
        return !h || !c;
      }, mn.prototype.useProgram = function(u, h) {
        this.cache = this.cache || {};
        var c = "" + u + (h ? h.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "");
        return this.cache[c] || (this.cache[c] = new mm(this.context, u, Uv[u], h, Sm[u], this._showOverdrawInspector)), this.cache[c];
      }, mn.prototype.setCustomLayerDefaults = function() {
        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
      }, mn.prototype.setBaseState = function() {
        var u = this.context.gl;
        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(u.FUNC_ADD);
      }, mn.prototype.initDebugOverlayCanvas = function() {
        this.debugOverlayCanvas == null && (this.debugOverlayCanvas = o.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new o.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
      }, mn.prototype.destroy = function() {
        this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
      };
      var ph = function(u, h) {
        this.points = u, this.planes = h;
      };
      ph.fromInvProjectionMatrix = function(u, h, c) {
        var d = Math.pow(2, c), _ = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(function(E) {
          return o.transformMat4([], E, u);
        }).map(function(E) {
          return o.scale$1([], E, 1 / E[3] / h * d);
        }), w = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(function(E) {
          var O = o.sub([], _[E[0]], _[E[1]]), k = o.sub([], _[E[2]], _[E[1]]), R = o.normalize([], o.cross([], O, k)), q = -o.dot(R, _[E[1]]);
          return R.concat(q);
        });
        return new ph(_, w);
      };
      var ml = function(u, h) {
        this.min = u, this.max = h, this.center = o.scale$2([], o.add([], this.min, this.max), 0.5);
      };
      ml.prototype.quadrant = function(u) {
        for (var h = [u % 2 == 0, u < 2], c = o.clone$2(this.min), d = o.clone$2(this.max), _ = 0; _ < h.length; _++)
          c[_] = h[_] ? this.min[_] : this.center[_], d[_] = h[_] ? this.center[_] : this.max[_];
        return d[2] = this.max[2], new ml(c, d);
      }, ml.prototype.distanceX = function(u) {
        return Math.max(Math.min(this.max[0], u[0]), this.min[0]) - u[0];
      }, ml.prototype.distanceY = function(u) {
        return Math.max(Math.min(this.max[1], u[1]), this.min[1]) - u[1];
      }, ml.prototype.intersects = function(u) {
        for (var h = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], c = !0, d = 0; d < u.planes.length; d++) {
          for (var _ = u.planes[d], w = 0, E = 0; E < h.length; E++)
            w += o.dot$1(_, h[E]) >= 0;
          if (w === 0)
            return 0;
          w !== h.length && (c = !1);
        }
        if (c)
          return 2;
        for (var O = 0; O < 3; O++) {
          for (var k = Number.MAX_VALUE, R = -Number.MAX_VALUE, q = 0; q < u.points.length; q++) {
            var $ = u.points[q][O] - this.min[O];
            k = Math.min(k, $), R = Math.max(R, $);
          }
          if (R < 0 || k > this.max[O] - this.min[O])
            return 0;
        }
        return 1;
      };
      var bs = function(u, h, c, d) {
        if (u === void 0 && (u = 0), h === void 0 && (h = 0), c === void 0 && (c = 0), d === void 0 && (d = 0), isNaN(u) || u < 0 || isNaN(h) || h < 0 || isNaN(c) || c < 0 || isNaN(d) || d < 0)
          throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
        this.top = u, this.bottom = h, this.left = c, this.right = d;
      };
      bs.prototype.interpolate = function(u, h, c) {
        return h.top != null && u.top != null && (this.top = o.number(u.top, h.top, c)), h.bottom != null && u.bottom != null && (this.bottom = o.number(u.bottom, h.bottom, c)), h.left != null && u.left != null && (this.left = o.number(u.left, h.left, c)), h.right != null && u.right != null && (this.right = o.number(u.right, h.right, c)), this;
      }, bs.prototype.getCenter = function(u, h) {
        var c = o.clamp((this.left + u - this.right) / 2, 0, u), d = o.clamp((this.top + h - this.bottom) / 2, 0, h);
        return new o.Point(c, d);
      }, bs.prototype.equals = function(u) {
        return this.top === u.top && this.bottom === u.bottom && this.left === u.left && this.right === u.right;
      }, bs.prototype.clone = function() {
        return new bs(this.top, this.bottom, this.left, this.right);
      }, bs.prototype.toJSON = function() {
        return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
      };
      var _r = function(u, h, c, d, _) {
        this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = _ === void 0 || _, this._minZoom = u || 0, this._maxZoom = h || 22, this._minPitch = c == null ? 0 : c, this._maxPitch = d == null ? 60 : d, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new o.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new bs(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
      }, en = { minZoom: { configurable: !0 }, maxZoom: { configurable: !0 }, minPitch: { configurable: !0 }, maxPitch: { configurable: !0 }, renderWorldCopies: { configurable: !0 }, worldSize: { configurable: !0 }, centerOffset: { configurable: !0 }, size: { configurable: !0 }, bearing: { configurable: !0 }, pitch: { configurable: !0 }, fov: { configurable: !0 }, zoom: { configurable: !0 }, center: { configurable: !0 }, padding: { configurable: !0 }, centerPoint: { configurable: !0 }, unmodified: { configurable: !0 }, point: { configurable: !0 } };
      _r.prototype.clone = function() {
        var u = new _r(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
        return u.tileSize = this.tileSize, u.latRange = this.latRange, u.width = this.width, u.height = this.height, u._center = this._center, u.zoom = this.zoom, u.angle = this.angle, u._fov = this._fov, u._pitch = this._pitch, u._unmodified = this._unmodified, u._edgeInsets = this._edgeInsets.clone(), u._calcMatrices(), u;
      }, en.minZoom.get = function() {
        return this._minZoom;
      }, en.minZoom.set = function(u) {
        this._minZoom !== u && (this._minZoom = u, this.zoom = Math.max(this.zoom, u));
      }, en.maxZoom.get = function() {
        return this._maxZoom;
      }, en.maxZoom.set = function(u) {
        this._maxZoom !== u && (this._maxZoom = u, this.zoom = Math.min(this.zoom, u));
      }, en.minPitch.get = function() {
        return this._minPitch;
      }, en.minPitch.set = function(u) {
        this._minPitch !== u && (this._minPitch = u, this.pitch = Math.max(this.pitch, u));
      }, en.maxPitch.get = function() {
        return this._maxPitch;
      }, en.maxPitch.set = function(u) {
        this._maxPitch !== u && (this._maxPitch = u, this.pitch = Math.min(this.pitch, u));
      }, en.renderWorldCopies.get = function() {
        return this._renderWorldCopies;
      }, en.renderWorldCopies.set = function(u) {
        u === void 0 ? u = !0 : u === null && (u = !1), this._renderWorldCopies = u;
      }, en.worldSize.get = function() {
        return this.tileSize * this.scale;
      }, en.centerOffset.get = function() {
        return this.centerPoint._sub(this.size._div(2));
      }, en.size.get = function() {
        return new o.Point(this.width, this.height);
      }, en.bearing.get = function() {
        return -this.angle / Math.PI * 180;
      }, en.bearing.set = function(u) {
        var h = -o.wrap(u, -180, 180) * Math.PI / 180;
        this.angle !== h && (this._unmodified = !1, this.angle = h, this._calcMatrices(), this.rotationMatrix = o.create$2(), o.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
      }, en.pitch.get = function() {
        return this._pitch / Math.PI * 180;
      }, en.pitch.set = function(u) {
        var h = o.clamp(u, this.minPitch, this.maxPitch) / 180 * Math.PI;
        this._pitch !== h && (this._unmodified = !1, this._pitch = h, this._calcMatrices());
      }, en.fov.get = function() {
        return this._fov / Math.PI * 180;
      }, en.fov.set = function(u) {
        u = Math.max(0.01, Math.min(60, u)), this._fov !== u && (this._unmodified = !1, this._fov = u / 180 * Math.PI, this._calcMatrices());
      }, en.zoom.get = function() {
        return this._zoom;
      }, en.zoom.set = function(u) {
        var h = Math.min(Math.max(u, this.minZoom), this.maxZoom);
        this._zoom !== h && (this._unmodified = !1, this._zoom = h, this.scale = this.zoomScale(h), this.tileZoom = Math.floor(h), this.zoomFraction = h - this.tileZoom, this._constrain(), this._calcMatrices());
      }, en.center.get = function() {
        return this._center;
      }, en.center.set = function(u) {
        u.lat === this._center.lat && u.lng === this._center.lng || (this._unmodified = !1, this._center = u, this._constrain(), this._calcMatrices());
      }, en.padding.get = function() {
        return this._edgeInsets.toJSON();
      }, en.padding.set = function(u) {
        this._edgeInsets.equals(u) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, u, 1), this._calcMatrices());
      }, en.centerPoint.get = function() {
        return this._edgeInsets.getCenter(this.width, this.height);
      }, _r.prototype.isPaddingEqual = function(u) {
        return this._edgeInsets.equals(u);
      }, _r.prototype.interpolatePadding = function(u, h, c) {
        this._unmodified = !1, this._edgeInsets.interpolate(u, h, c), this._constrain(), this._calcMatrices();
      }, _r.prototype.coveringZoomLevel = function(u) {
        var h = (u.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / u.tileSize));
        return Math.max(0, h);
      }, _r.prototype.getVisibleUnwrappedCoordinates = function(u) {
        var h = [new o.UnwrappedTileID(0, u)];
        if (this._renderWorldCopies)
          for (var c = this.pointCoordinate(new o.Point(0, 0)), d = this.pointCoordinate(new o.Point(this.width, 0)), _ = this.pointCoordinate(new o.Point(this.width, this.height)), w = this.pointCoordinate(new o.Point(0, this.height)), E = Math.floor(Math.min(c.x, d.x, _.x, w.x)), O = Math.floor(Math.max(c.x, d.x, _.x, w.x)), k = E - 1; k <= O + 1; k++)
            k !== 0 && h.push(new o.UnwrappedTileID(k, u));
        return h;
      }, _r.prototype.coveringTiles = function(u) {
        var h = this.coveringZoomLevel(u), c = h;
        if (u.minzoom !== void 0 && h < u.minzoom)
          return [];
        u.maxzoom !== void 0 && h > u.maxzoom && (h = u.maxzoom);
        var d = o.MercatorCoordinate.fromLngLat(this.center), _ = Math.pow(2, h), w = [_ * d.x, _ * d.y, 0], E = ph.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, h), O = u.minzoom || 0;
        this.pitch <= 60 && this._edgeInsets.top < 0.1 && (O = h);
        var k = function(Qe) {
          return { aabb: new ml([Qe * _, 0, 0], [(Qe + 1) * _, _, 0]), zoom: 0, x: 0, y: 0, wrap: Qe, fullyVisible: !1 };
        }, R = [], q = [], $ = h, W = u.reparseOverscaled ? c : h;
        if (this._renderWorldCopies)
          for (var ne = 1; ne <= 3; ne++)
            R.push(k(-ne)), R.push(k(ne));
        for (R.push(k(0)); R.length > 0; ) {
          var re = R.pop(), se = re.x, J = re.y, ae = re.fullyVisible;
          if (!ae) {
            var pe = re.aabb.intersects(E);
            if (pe === 0)
              continue;
            ae = pe === 2;
          }
          var _e = re.aabb.distanceX(w), Ce = re.aabb.distanceY(w), Te = Math.max(Math.abs(_e), Math.abs(Ce));
          if (re.zoom === $ || Te > 3 + (1 << $ - re.zoom) - 2 && re.zoom >= O)
            q.push({ tileID: new o.OverscaledTileID(re.zoom === $ ? W : re.zoom, re.wrap, re.zoom, se, J), distanceSq: o.sqrLen([w[0] - 0.5 - se, w[1] - 0.5 - J]) });
          else
            for (var Ae = 0; Ae < 4; Ae++) {
              var je = (se << 1) + Ae % 2, tt = (J << 1) + (Ae >> 1);
              R.push({ aabb: re.aabb.quadrant(Ae), zoom: re.zoom + 1, x: je, y: tt, wrap: re.wrap, fullyVisible: ae });
            }
        }
        return q.sort(function(Qe, gt) {
          return Qe.distanceSq - gt.distanceSq;
        }).map(function(Qe) {
          return Qe.tileID;
        });
      }, _r.prototype.resize = function(u, h) {
        this.width = u, this.height = h, this.pixelsToGLUnits = [2 / u, -2 / h], this._constrain(), this._calcMatrices();
      }, en.unmodified.get = function() {
        return this._unmodified;
      }, _r.prototype.zoomScale = function(u) {
        return Math.pow(2, u);
      }, _r.prototype.scaleZoom = function(u) {
        return Math.log(u) / Math.LN2;
      }, _r.prototype.project = function(u) {
        var h = o.clamp(u.lat, -this.maxValidLatitude, this.maxValidLatitude);
        return new o.Point(o.mercatorXfromLng(u.lng) * this.worldSize, o.mercatorYfromLat(h) * this.worldSize);
      }, _r.prototype.unproject = function(u) {
        return new o.MercatorCoordinate(u.x / this.worldSize, u.y / this.worldSize).toLngLat();
      }, en.point.get = function() {
        return this.project(this.center);
      }, _r.prototype.setLocationAtPoint = function(u, h) {
        var c = this.pointCoordinate(h), d = this.pointCoordinate(this.centerPoint), _ = this.locationCoordinate(u), w = new o.MercatorCoordinate(_.x - (c.x - d.x), _.y - (c.y - d.y));
        this.center = this.coordinateLocation(w), this._renderWorldCopies && (this.center = this.center.wrap());
      }, _r.prototype.locationPoint = function(u) {
        return this.coordinatePoint(this.locationCoordinate(u));
      }, _r.prototype.pointLocation = function(u) {
        return this.coordinateLocation(this.pointCoordinate(u));
      }, _r.prototype.locationCoordinate = function(u) {
        return o.MercatorCoordinate.fromLngLat(u);
      }, _r.prototype.coordinateLocation = function(u) {
        return u.toLngLat();
      }, _r.prototype.pointCoordinate = function(u) {
        var h = [u.x, u.y, 0, 1], c = [u.x, u.y, 1, 1];
        o.transformMat4(h, h, this.pixelMatrixInverse), o.transformMat4(c, c, this.pixelMatrixInverse);
        var d = h[3], _ = c[3], w = h[1] / d, E = c[1] / _, O = h[2] / d, k = c[2] / _, R = O === k ? 0 : (0 - O) / (k - O);
        return new o.MercatorCoordinate(o.number(h[0] / d, c[0] / _, R) / this.worldSize, o.number(w, E, R) / this.worldSize);
      }, _r.prototype.coordinatePoint = function(u) {
        var h = [u.x * this.worldSize, u.y * this.worldSize, 0, 1];
        return o.transformMat4(h, h, this.pixelMatrix), new o.Point(h[0] / h[3], h[1] / h[3]);
      }, _r.prototype.getBounds = function() {
        return new o.LngLatBounds().extend(this.pointLocation(new o.Point(0, 0))).extend(this.pointLocation(new o.Point(this.width, 0))).extend(this.pointLocation(new o.Point(this.width, this.height))).extend(this.pointLocation(new o.Point(0, this.height)));
      }, _r.prototype.getMaxBounds = function() {
        return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new o.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
      }, _r.prototype.setMaxBounds = function(u) {
        u ? (this.lngRange = [u.getWest(), u.getEast()], this.latRange = [u.getSouth(), u.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
      }, _r.prototype.calculatePosMatrix = function(u, h) {
        h === void 0 && (h = !1);
        var c = u.key, d = h ? this._alignedPosMatrixCache : this._posMatrixCache;
        if (d[c])
          return d[c];
        var _ = u.canonical, w = this.worldSize / this.zoomScale(_.z), E = _.x + Math.pow(2, _.z) * u.wrap, O = o.identity(new Float64Array(16));
        return o.translate(O, O, [E * w, _.y * w, 0]), o.scale(O, O, [w / o.EXTENT, w / o.EXTENT, 1]), o.multiply(O, h ? this.alignedProjMatrix : this.projMatrix, O), d[c] = new Float32Array(O), d[c];
      }, _r.prototype.customLayerMatrix = function() {
        return this.mercatorMatrix.slice();
      }, _r.prototype._constrain = function() {
        if (this.center && this.width && this.height && !this._constraining) {
          this._constraining = !0;
          var u, h, c, d, _ = -90, w = 90, E = -180, O = 180, k = this.size, R = this._unmodified;
          if (this.latRange) {
            var q = this.latRange;
            _ = o.mercatorYfromLat(q[1]) * this.worldSize, u = (w = o.mercatorYfromLat(q[0]) * this.worldSize) - _ < k.y ? k.y / (w - _) : 0;
          }
          if (this.lngRange) {
            var $ = this.lngRange;
            E = o.mercatorXfromLng($[0]) * this.worldSize, h = (O = o.mercatorXfromLng($[1]) * this.worldSize) - E < k.x ? k.x / (O - E) : 0;
          }
          var W = this.point, ne = Math.max(h || 0, u || 0);
          if (ne)
            return this.center = this.unproject(new o.Point(h ? (O + E) / 2 : W.x, u ? (w + _) / 2 : W.y)), this.zoom += this.scaleZoom(ne), this._unmodified = R, void (this._constraining = !1);
          if (this.latRange) {
            var re = W.y, se = k.y / 2;
            re - se < _ && (d = _ + se), re + se > w && (d = w - se);
          }
          if (this.lngRange) {
            var J = W.x, ae = k.x / 2;
            J - ae < E && (c = E + ae), J + ae > O && (c = O - ae);
          }
          c === void 0 && d === void 0 || (this.center = this.unproject(new o.Point(c !== void 0 ? c : W.x, d !== void 0 ? d : W.y))), this._unmodified = R, this._constraining = !1;
        }
      }, _r.prototype._calcMatrices = function() {
        if (this.height) {
          var u = this.centerOffset;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
          var h = Math.PI / 2 + this._pitch, c = this._fov * (0.5 + u.y / this.height), d = Math.sin(c) * this.cameraToCenterDistance / Math.sin(o.clamp(Math.PI - h - c, 0.01, Math.PI - 0.01)), _ = this.point, w = _.x, E = _.y, O = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * d + this.cameraToCenterDistance), k = this.height / 50, R = new Float64Array(16);
          o.perspective(R, this._fov, this.width / this.height, k, O), R[8] = 2 * -u.x / this.width, R[9] = 2 * u.y / this.height, o.scale(R, R, [1, -1, 1]), o.translate(R, R, [0, 0, -this.cameraToCenterDistance]), o.rotateX(R, R, this._pitch), o.rotateZ(R, R, this.angle), o.translate(R, R, [-w, -E, 0]), this.mercatorMatrix = o.scale([], R, [this.worldSize, this.worldSize, this.worldSize]), o.scale(R, R, [1, 1, o.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = R, this.invProjMatrix = o.invert([], this.projMatrix);
          var q = this.width % 2 / 2, $ = this.height % 2 / 2, W = Math.cos(this.angle), ne = Math.sin(this.angle), re = w - Math.round(w) + W * q + ne * $, se = E - Math.round(E) + W * $ + ne * q, J = new Float64Array(R);
          if (o.translate(J, J, [re > 0.5 ? re - 1 : re, se > 0.5 ? se - 1 : se, 0]), this.alignedProjMatrix = J, R = o.create(), o.scale(R, R, [this.width / 2, -this.height / 2, 1]), o.translate(R, R, [1, -1, 0]), this.labelPlaneMatrix = R, R = o.create(), o.scale(R, R, [1, -1, 1]), o.translate(R, R, [-1, -1, 0]), o.scale(R, R, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = R, this.pixelMatrix = o.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(R = o.invert(new Float64Array(16), this.pixelMatrix)))
            throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = R, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }
      }, _r.prototype.maxPitchScaleFactor = function() {
        if (!this.pixelMatrixInverse)
          return 1;
        var u = this.pointCoordinate(new o.Point(0, 0)), h = [u.x * this.worldSize, u.y * this.worldSize, 0, 1];
        return o.transformMat4(h, h, this.pixelMatrix)[3] / this.cameraToCenterDistance;
      }, _r.prototype.getCameraPoint = function() {
        var u = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
        return this.centerPoint.add(new o.Point(0, u));
      }, _r.prototype.getCameraQueryGeometry = function(u) {
        var h = this.getCameraPoint();
        if (u.length === 1)
          return [u[0], h];
        for (var c = h.x, d = h.y, _ = h.x, w = h.y, E = 0, O = u; E < O.length; E += 1) {
          var k = O[E];
          c = Math.min(c, k.x), d = Math.min(d, k.y), _ = Math.max(_, k.x), w = Math.max(w, k.y);
        }
        return [new o.Point(c, d), new o.Point(_, d), new o.Point(_, w), new o.Point(c, w), new o.Point(c, d)];
      }, Object.defineProperties(_r.prototype, en);
      var Mo = function(u) {
        var h, c, d, _;
        this._hashName = u && encodeURIComponent(u), o.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (h = this._updateHashUnthrottled.bind(this), c = !1, d = null, _ = function() {
          d = null, c && (h(), d = setTimeout(_, 300), c = !1);
        }, function() {
          return c = !0, d || _(), d;
        });
      };
      Mo.prototype.addTo = function(u) {
        return this._map = u, o.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
      }, Mo.prototype.remove = function() {
        return o.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
      }, Mo.prototype.getHashString = function(u) {
        var h = this._map.getCenter(), c = Math.round(100 * this._map.getZoom()) / 100, d = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), _ = Math.pow(10, d), w = Math.round(h.lng * _) / _, E = Math.round(h.lat * _) / _, O = this._map.getBearing(), k = this._map.getPitch(), R = "";
        if (R += u ? "/" + w + "/" + E + "/" + c : c + "/" + E + "/" + w, (O || k) && (R += "/" + Math.round(10 * O) / 10), k && (R += "/" + Math.round(k)), this._hashName) {
          var q = this._hashName, $ = !1, W = o.window.location.hash.slice(1).split("&").map(function(ne) {
            var re = ne.split("=")[0];
            return re === q ? ($ = !0, re + "=" + R) : ne;
          }).filter(function(ne) {
            return ne;
          });
          return $ || W.push(q + "=" + R), "#" + W.join("&");
        }
        return "#" + R;
      }, Mo.prototype._getCurrentHash = function() {
        var u, h = this, c = o.window.location.hash.replace("#", "");
        return this._hashName ? (c.split("&").map(function(d) {
          return d.split("=");
        }).forEach(function(d) {
          d[0] === h._hashName && (u = d);
        }), (u && u[1] || "").split("/")) : c.split("/");
      }, Mo.prototype._onHashChange = function() {
        var u = this._getCurrentHash();
        if (u.length >= 3 && !u.some(function(c) {
          return isNaN(c);
        })) {
          var h = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(u[3] || 0) : this._map.getBearing();
          return this._map.jumpTo({ center: [+u[2], +u[1]], zoom: +u[0], bearing: h, pitch: +(u[4] || 0) }), !0;
        }
        return !1;
      }, Mo.prototype._updateHashUnthrottled = function() {
        var u = o.window.location.href.replace(/(#.+)?$/, this.getHashString());
        try {
          o.window.history.replaceState(o.window.history.state, null, u);
        } catch {
        }
      };
      var Ju = { linearity: 0.3, easing: o.bezier(0, 0, 0.3, 1) }, Yl = o.extend({ deceleration: 2500, maxSpeed: 1400 }, Ju), Qu = o.extend({ deceleration: 20, maxSpeed: 1400 }, Ju), $v = o.extend({ deceleration: 1e3, maxSpeed: 360 }, Ju), Wv = o.extend({ deceleration: 1e3, maxSpeed: 90 }, Ju), ec = function(u) {
        this._map = u, this.clear();
      };
      function tc(u, h) {
        (!u.duration || u.duration < h.duration) && (u.duration = h.duration, u.easing = h.easing);
      }
      function Ua(u, h, c) {
        var d = c.maxSpeed, _ = c.linearity, w = c.deceleration, E = o.clamp(u * _ / (h / 1e3), -d, d), O = Math.abs(E) / (w * _);
        return { easing: c.easing, duration: 1e3 * O, amount: E * (O / 2) };
      }
      ec.prototype.clear = function() {
        this._inertiaBuffer = [];
      }, ec.prototype.record = function(u) {
        this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: o.browser.now(), settings: u });
      }, ec.prototype._drainInertiaBuffer = function() {
        for (var u = this._inertiaBuffer, h = o.browser.now(); u.length > 0 && h - u[0].time > 160; )
          u.shift();
      }, ec.prototype._onMoveEnd = function(u) {
        if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {
          for (var h = { zoom: 0, bearing: 0, pitch: 0, pan: new o.Point(0, 0), pinchAround: void 0, around: void 0 }, c = 0, d = this._inertiaBuffer; c < d.length; c += 1) {
            var _ = d[c].settings;
            h.zoom += _.zoomDelta || 0, h.bearing += _.bearingDelta || 0, h.pitch += _.pitchDelta || 0, _.panDelta && h.pan._add(_.panDelta), _.around && (h.around = _.around), _.pinchAround && (h.pinchAround = _.pinchAround);
          }
          var w = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, E = {};
          if (h.pan.mag()) {
            var O = Ua(h.pan.mag(), w, o.extend({}, Yl, u || {}));
            E.offset = h.pan.mult(O.amount / h.pan.mag()), E.center = this._map.transform.center, tc(E, O);
          }
          if (h.zoom) {
            var k = Ua(h.zoom, w, Qu);
            E.zoom = this._map.transform.zoom + k.amount, tc(E, k);
          }
          if (h.bearing) {
            var R = Ua(h.bearing, w, $v);
            E.bearing = this._map.transform.bearing + o.clamp(R.amount, -179, 179), tc(E, R);
          }
          if (h.pitch) {
            var q = Ua(h.pitch, w, Wv);
            E.pitch = this._map.transform.pitch + q.amount, tc(E, q);
          }
          if (E.zoom || E.bearing) {
            var $ = h.pinchAround === void 0 ? h.around : h.pinchAround;
            E.around = $ ? this._map.unproject($) : this._map.getCenter();
          }
          return this.clear(), o.extend(E, { noMoveStart: !0 });
        }
      };
      var Jn = function(u) {
        function h(d, _, w, E) {
          E === void 0 && (E = {});
          var O = g.mousePos(_.getCanvasContainer(), w), k = _.unproject(O);
          u.call(this, d, o.extend({ point: O, lngLat: k, originalEvent: w }, E)), this._defaultPrevented = !1, this.target = _;
        }
        u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h;
        var c = { defaultPrevented: { configurable: !0 } };
        return h.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(h.prototype, c), h;
      }(o.Event), rc = function(u) {
        function h(d, _, w) {
          var E = d === "touchend" ? w.changedTouches : w.touches, O = g.touchPos(_.getCanvasContainer(), E), k = O.map(function($) {
            return _.unproject($);
          }), R = O.reduce(function($, W, ne, re) {
            return $.add(W.div(re.length));
          }, new o.Point(0, 0)), q = _.unproject(R);
          u.call(this, d, { points: O, point: R, lngLats: k, lngLat: q, originalEvent: w }), this._defaultPrevented = !1;
        }
        u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h;
        var c = { defaultPrevented: { configurable: !0 } };
        return h.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(h.prototype, c), h;
      }(o.Event), Pm = function(u) {
        function h(d, _, w) {
          u.call(this, d, { originalEvent: w }), this._defaultPrevented = !1;
        }
        u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h;
        var c = { defaultPrevented: { configurable: !0 } };
        return h.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(h.prototype, c), h;
      }(o.Event), Gn = function(u, h) {
        this._map = u, this._clickTolerance = h.clickTolerance;
      };
      Gn.prototype.reset = function() {
        delete this._mousedownPos;
      }, Gn.prototype.wheel = function(u) {
        return this._firePreventable(new Pm(u.type, this._map, u));
      }, Gn.prototype.mousedown = function(u, h) {
        return this._mousedownPos = h, this._firePreventable(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseup = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.click = function(u, h) {
        this._mousedownPos && this._mousedownPos.dist(h) >= this._clickTolerance || this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.dblclick = function(u) {
        return this._firePreventable(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseover = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseout = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.touchstart = function(u) {
        return this._firePreventable(new rc(u.type, this._map, u));
      }, Gn.prototype.touchmove = function(u) {
        this._map.fire(new rc(u.type, this._map, u));
      }, Gn.prototype.touchend = function(u) {
        this._map.fire(new rc(u.type, this._map, u));
      }, Gn.prototype.touchcancel = function(u) {
        this._map.fire(new rc(u.type, this._map, u));
      }, Gn.prototype._firePreventable = function(u) {
        if (this._map.fire(u), u.defaultPrevented)
          return {};
      }, Gn.prototype.isEnabled = function() {
        return !0;
      }, Gn.prototype.isActive = function() {
        return !1;
      }, Gn.prototype.enable = function() {
      }, Gn.prototype.disable = function() {
      };
      var wt = function(u) {
        this._map = u;
      };
      wt.prototype.reset = function() {
        this._delayContextMenu = !1, delete this._contextMenuEvent;
      }, wt.prototype.mousemove = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, wt.prototype.mousedown = function() {
        this._delayContextMenu = !0;
      }, wt.prototype.mouseup = function() {
        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Jn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
      }, wt.prototype.contextmenu = function(u) {
        this._delayContextMenu ? this._contextMenuEvent = u : this._map.fire(new Jn(u.type, this._map, u)), this._map.listens("contextmenu") && u.preventDefault();
      }, wt.prototype.isEnabled = function() {
        return !0;
      }, wt.prototype.isActive = function() {
        return !1;
      }, wt.prototype.enable = function() {
      }, wt.prototype.disable = function() {
      };
      var uo = function(u, h) {
        this._map = u, this._el = u.getCanvasContainer(), this._container = u.getContainer(), this._clickTolerance = h.clickTolerance || 1;
      };
      function dh(u, h) {
        for (var c = {}, d = 0; d < u.length; d++)
          c[u[d].identifier] = h[d];
        return c;
      }
      uo.prototype.isEnabled = function() {
        return !!this._enabled;
      }, uo.prototype.isActive = function() {
        return !!this._active;
      }, uo.prototype.enable = function() {
        this.isEnabled() || (this._enabled = !0);
      }, uo.prototype.disable = function() {
        this.isEnabled() && (this._enabled = !1);
      }, uo.prototype.mousedown = function(u, h) {
        this.isEnabled() && u.shiftKey && u.button === 0 && (g.disableDrag(), this._startPos = this._lastPos = h, this._active = !0);
      }, uo.prototype.mousemoveWindow = function(u, h) {
        if (this._active) {
          var c = h;
          if (!(this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance)) {
            var d = this._startPos;
            this._lastPos = c, this._box || (this._box = g.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", u));
            var _ = Math.min(d.x, c.x), w = Math.max(d.x, c.x), E = Math.min(d.y, c.y), O = Math.max(d.y, c.y);
            g.setTransform(this._box, "translate(" + _ + "px," + E + "px)"), this._box.style.width = w - _ + "px", this._box.style.height = O - E + "px";
          }
        }
      }, uo.prototype.mouseupWindow = function(u, h) {
        var c = this;
        if (this._active && u.button === 0) {
          var d = this._startPos, _ = h;
          if (this.reset(), g.suppressClick(), d.x !== _.x || d.y !== _.y)
            return this._map.fire(new o.Event("boxzoomend", { originalEvent: u })), { cameraAnimation: function(w) {
              return w.fitScreenCoordinates(d, _, c._map.getBearing(), { linear: !0 });
            } };
          this._fireEvent("boxzoomcancel", u);
        }
      }, uo.prototype.keydown = function(u) {
        this._active && u.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", u));
      }, uo.prototype.blur = function() {
        this.reset();
      }, uo.prototype.reset = function() {
        this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (g.remove(this._box), this._box = null), g.enableDrag(), delete this._startPos, delete this._lastPos;
      }, uo.prototype._fireEvent = function(u, h) {
        return this._map.fire(new o.Event(u, { originalEvent: h }));
      };
      var Jl = function(u) {
        this.reset(), this.numTouches = u.numTouches;
      };
      Jl.prototype.reset = function() {
        delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
      }, Jl.prototype.touchstart = function(u, h, c) {
        (this.centroid || c.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = u.timeStamp), c.length === this.numTouches && (this.centroid = function(d) {
          for (var _ = new o.Point(0, 0), w = 0, E = d; w < E.length; w += 1)
            _._add(E[w]);
          return _.div(d.length);
        }(h), this.touches = dh(c, h)));
      }, Jl.prototype.touchmove = function(u, h, c) {
        if (!this.aborted && this.centroid) {
          var d = dh(c, h);
          for (var _ in this.touches) {
            var w = d[_];
            (!w || w.dist(this.touches[_]) > 30) && (this.aborted = !0);
          }
        }
      }, Jl.prototype.touchend = function(u, h, c) {
        if ((!this.centroid || u.timeStamp - this.startTime > 500) && (this.aborted = !0), c.length === 0) {
          var d = !this.aborted && this.centroid;
          if (this.reset(), d)
            return d;
        }
      };
      var aa = function(u) {
        this.singleTap = new Jl(u), this.numTaps = u.numTaps, this.reset();
      };
      aa.prototype.reset = function() {
        this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
      }, aa.prototype.touchstart = function(u, h, c) {
        this.singleTap.touchstart(u, h, c);
      }, aa.prototype.touchmove = function(u, h, c) {
        this.singleTap.touchmove(u, h, c);
      }, aa.prototype.touchend = function(u, h, c) {
        var d = this.singleTap.touchend(u, h, c);
        if (d) {
          var _ = u.timeStamp - this.lastTime < 500, w = !this.lastTap || this.lastTap.dist(d) < 30;
          if (_ && w || this.reset(), this.count++, this.lastTime = u.timeStamp, this.lastTap = d, this.count === this.numTaps)
            return this.reset(), d;
        }
      };
      var co = function() {
        this._zoomIn = new aa({ numTouches: 1, numTaps: 2 }), this._zoomOut = new aa({ numTouches: 2, numTaps: 1 }), this.reset();
      };
      co.prototype.reset = function() {
        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
      }, co.prototype.touchstart = function(u, h, c) {
        this._zoomIn.touchstart(u, h, c), this._zoomOut.touchstart(u, h, c);
      }, co.prototype.touchmove = function(u, h, c) {
        this._zoomIn.touchmove(u, h, c), this._zoomOut.touchmove(u, h, c);
      }, co.prototype.touchend = function(u, h, c) {
        var d = this, _ = this._zoomIn.touchend(u, h, c), w = this._zoomOut.touchend(u, h, c);
        return _ ? (this._active = !0, u.preventDefault(), setTimeout(function() {
          return d.reset();
        }, 0), { cameraAnimation: function(E) {
          return E.easeTo({ duration: 300, zoom: E.getZoom() + 1, around: E.unproject(_) }, { originalEvent: u });
        } }) : w ? (this._active = !0, u.preventDefault(), setTimeout(function() {
          return d.reset();
        }, 0), { cameraAnimation: function(E) {
          return E.easeTo({ duration: 300, zoom: E.getZoom() - 1, around: E.unproject(w) }, { originalEvent: u });
        } }) : void 0;
      }, co.prototype.touchcancel = function() {
        this.reset();
      }, co.prototype.enable = function() {
        this._enabled = !0;
      }, co.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, co.prototype.isEnabled = function() {
        return this._enabled;
      }, co.prototype.isActive = function() {
        return this._active;
      };
      var ip = { 0: 1, 2: 2 }, ut = function(u) {
        this.reset(), this._clickTolerance = u.clickTolerance || 1;
      };
      ut.prototype.blur = function() {
        this.reset();
      }, ut.prototype.reset = function() {
        this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;
      }, ut.prototype._correctButton = function(u, h) {
        return !1;
      }, ut.prototype._move = function(u, h) {
        return {};
      }, ut.prototype.mousedown = function(u, h) {
        if (!this._lastPoint) {
          var c = g.mouseButton(u);
          this._correctButton(u, c) && (this._lastPoint = h, this._eventButton = c);
        }
      }, ut.prototype.mousemoveWindow = function(u, h) {
        var c = this._lastPoint;
        if (c) {
          if (u.preventDefault(), function(d, _) {
            var w = ip[_];
            return d.buttons === void 0 || (d.buttons & w) !== w;
          }(u, this._eventButton))
            this.reset();
          else if (this._moved || !(h.dist(c) < this._clickTolerance))
            return this._moved = !0, this._lastPoint = h, this._move(c, h);
        }
      }, ut.prototype.mouseupWindow = function(u) {
        this._lastPoint && g.mouseButton(u) === this._eventButton && (this._moved && g.suppressClick(), this.reset());
      }, ut.prototype.enable = function() {
        this._enabled = !0;
      }, ut.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, ut.prototype.isEnabled = function() {
        return this._enabled;
      }, ut.prototype.isActive = function() {
        return this._active;
      };
      var op = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.mousedown = function(c, d) {
          u.prototype.mousedown.call(this, c, d), this._lastPoint && (this._active = !0);
        }, h.prototype._correctButton = function(c, d) {
          return d === 0 && !c.ctrlKey;
        }, h.prototype._move = function(c, d) {
          return { around: d, panDelta: d.sub(c) };
        }, h;
      }(ut), mh = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype._correctButton = function(c, d) {
          return d === 0 && c.ctrlKey || d === 2;
        }, h.prototype._move = function(c, d) {
          var _ = 0.8 * (d.x - c.x);
          if (_)
            return this._active = !0, { bearingDelta: _ };
        }, h.prototype.contextmenu = function(c) {
          c.preventDefault();
        }, h;
      }(ut), ap = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype._correctButton = function(c, d) {
          return d === 0 && c.ctrlKey || d === 2;
        }, h.prototype._move = function(c, d) {
          var _ = -0.5 * (d.y - c.y);
          if (_)
            return this._active = !0, { pitchDelta: _ };
        }, h.prototype.contextmenu = function(c) {
          c.preventDefault();
        }, h;
      }(ut), $o = function(u) {
        this._minTouches = 1, this._clickTolerance = u.clickTolerance || 1, this.reset();
      };
      $o.prototype.reset = function() {
        this._active = !1, this._touches = {}, this._sum = new o.Point(0, 0);
      }, $o.prototype.touchstart = function(u, h, c) {
        return this._calculateTransform(u, h, c);
      }, $o.prototype.touchmove = function(u, h, c) {
        if (this._active && !(c.length < this._minTouches))
          return u.preventDefault(), this._calculateTransform(u, h, c);
      }, $o.prototype.touchend = function(u, h, c) {
        this._calculateTransform(u, h, c), this._active && c.length < this._minTouches && this.reset();
      }, $o.prototype.touchcancel = function() {
        this.reset();
      }, $o.prototype._calculateTransform = function(u, h, c) {
        c.length > 0 && (this._active = !0);
        var d = dh(c, h), _ = new o.Point(0, 0), w = new o.Point(0, 0), E = 0;
        for (var O in d) {
          var k = d[O], R = this._touches[O];
          R && (_._add(k), w._add(k.sub(R)), E++, d[O] = k);
        }
        if (this._touches = d, !(E < this._minTouches) && w.mag()) {
          var q = w.div(E);
          if (this._sum._add(q), !(this._sum.mag() < this._clickTolerance))
            return { around: _.div(E), panDelta: q };
        }
      }, $o.prototype.enable = function() {
        this._enabled = !0;
      }, $o.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, $o.prototype.isEnabled = function() {
        return this._enabled;
      }, $o.prototype.isActive = function() {
        return this._active;
      };
      var ho = function() {
        this.reset();
      };
      function yh(u, h, c) {
        for (var d = 0; d < u.length; d++)
          if (u[d].identifier === c)
            return h[d];
      }
      function gh(u, h) {
        return Math.log(u / h) / Math.LN2;
      }
      ho.prototype.reset = function() {
        this._active = !1, delete this._firstTwoTouches;
      }, ho.prototype._start = function(u) {
      }, ho.prototype._move = function(u, h, c) {
        return {};
      }, ho.prototype.touchstart = function(u, h, c) {
        this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([h[0], h[1]]));
      }, ho.prototype.touchmove = function(u, h, c) {
        if (this._firstTwoTouches) {
          u.preventDefault();
          var d = this._firstTwoTouches, _ = d[1], w = yh(c, h, d[0]), E = yh(c, h, _);
          if (w && E) {
            var O = this._aroundCenter ? null : w.add(E).div(2);
            return this._move([w, E], O, u);
          }
        }
      }, ho.prototype.touchend = function(u, h, c) {
        if (this._firstTwoTouches) {
          var d = this._firstTwoTouches, _ = d[1], w = yh(c, h, d[0]), E = yh(c, h, _);
          w && E || (this._active && g.suppressClick(), this.reset());
        }
      }, ho.prototype.touchcancel = function() {
        this.reset();
      }, ho.prototype.enable = function(u) {
        this._enabled = !0, this._aroundCenter = !!u && u.around === "center";
      }, ho.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, ho.prototype.isEnabled = function() {
        return this._enabled;
      }, ho.prototype.isActive = function() {
        return this._active;
      };
      var fo = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.reset = function() {
          u.prototype.reset.call(this), delete this._distance, delete this._startDistance;
        }, h.prototype._start = function(c) {
          this._startDistance = this._distance = c[0].dist(c[1]);
        }, h.prototype._move = function(c, d) {
          var _ = this._distance;
          if (this._distance = c[0].dist(c[1]), this._active || !(Math.abs(gh(this._distance, this._startDistance)) < 0.1))
            return this._active = !0, { zoomDelta: gh(this._distance, _), pinchAround: d };
        }, h;
      }(ho);
      function ja(u, h) {
        return 180 * u.angleWith(h) / Math.PI;
      }
      var km = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.reset = function() {
          u.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector;
        }, h.prototype._start = function(c) {
          this._startVector = this._vector = c[0].sub(c[1]), this._minDiameter = c[0].dist(c[1]);
        }, h.prototype._move = function(c, d) {
          var _ = this._vector;
          if (this._vector = c[0].sub(c[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = !0, { bearingDelta: ja(this._vector, _), pinchAround: d };
        }, h.prototype._isBelowThreshold = function(c) {
          this._minDiameter = Math.min(this._minDiameter, c.mag());
          var d = 25 / (Math.PI * this._minDiameter) * 360, _ = ja(c, this._startVector);
          return Math.abs(_) < d;
        }, h;
      }(ho);
      function nc(u) {
        return Math.abs(u.y) > Math.abs(u.x);
      }
      var sp = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.reset = function() {
          u.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }, h.prototype._start = function(c) {
          this._lastPoints = c, nc(c[0].sub(c[1])) && (this._valid = !1);
        }, h.prototype._move = function(c, d, _) {
          var w = c[0].sub(this._lastPoints[0]), E = c[1].sub(this._lastPoints[1]);
          if (this._valid = this.gestureBeginsVertically(w, E, _.timeStamp), this._valid)
            return this._lastPoints = c, this._active = !0, { pitchDelta: (w.y + E.y) / 2 * -0.5 };
        }, h.prototype.gestureBeginsVertically = function(c, d, _) {
          if (this._valid !== void 0)
            return this._valid;
          var w = c.mag() >= 2, E = d.mag() >= 2;
          if (w || E) {
            if (!w || !E)
              return this._firstMove === void 0 && (this._firstMove = _), _ - this._firstMove < 100 && void 0;
            var O = c.y > 0 == d.y > 0;
            return nc(c) && nc(d) && O;
          }
        }, h;
      }(ho), lp = { panStep: 100, bearingStep: 15, pitchStep: 10 }, sa = function() {
        var u = lp;
        this._panStep = u.panStep, this._bearingStep = u.bearingStep, this._pitchStep = u.pitchStep, this._rotationDisabled = !1;
      };
      function Io(u) {
        return u * (2 - u);
      }
      sa.prototype.blur = function() {
        this.reset();
      }, sa.prototype.reset = function() {
        this._active = !1;
      }, sa.prototype.keydown = function(u) {
        var h = this;
        if (!(u.altKey || u.ctrlKey || u.metaKey)) {
          var c = 0, d = 0, _ = 0, w = 0, E = 0;
          switch (u.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              c = 1;
              break;
            case 189:
            case 109:
            case 173:
              c = -1;
              break;
            case 37:
              u.shiftKey ? d = -1 : (u.preventDefault(), w = -1);
              break;
            case 39:
              u.shiftKey ? d = 1 : (u.preventDefault(), w = 1);
              break;
            case 38:
              u.shiftKey ? _ = 1 : (u.preventDefault(), E = -1);
              break;
            case 40:
              u.shiftKey ? _ = -1 : (u.preventDefault(), E = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (d = 0, _ = 0), { cameraAnimation: function(O) {
            var k = O.getZoom();
            O.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Io, zoom: c ? Math.round(k) + c * (u.shiftKey ? 2 : 1) : k, bearing: O.getBearing() + d * h._bearingStep, pitch: O.getPitch() + _ * h._pitchStep, offset: [-w * h._panStep, -E * h._panStep], center: O.getCenter() }, { originalEvent: u });
          } };
        }
      }, sa.prototype.enable = function() {
        this._enabled = !0;
      }, sa.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, sa.prototype.isEnabled = function() {
        return this._enabled;
      }, sa.prototype.isActive = function() {
        return this._active;
      }, sa.prototype.disableRotation = function() {
        this._rotationDisabled = !0;
      }, sa.prototype.enableRotation = function() {
        this._rotationDisabled = !1;
      };
      var pr = function(u, h) {
        this._map = u, this._el = u.getCanvasContainer(), this._handler = h, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 1 / 450, o.bindAll(["_onTimeout"], this);
      };
      pr.prototype.setZoomRate = function(u) {
        this._defaultZoomRate = u;
      }, pr.prototype.setWheelZoomRate = function(u) {
        this._wheelZoomRate = u;
      }, pr.prototype.isEnabled = function() {
        return !!this._enabled;
      }, pr.prototype.isActive = function() {
        return !!this._active || this._finishTimeout !== void 0;
      }, pr.prototype.isZooming = function() {
        return !!this._zooming;
      }, pr.prototype.enable = function(u) {
        this.isEnabled() || (this._enabled = !0, this._aroundCenter = u && u.around === "center");
      }, pr.prototype.disable = function() {
        this.isEnabled() && (this._enabled = !1);
      }, pr.prototype.wheel = function(u) {
        if (this.isEnabled()) {
          var h = u.deltaMode === o.window.WheelEvent.DOM_DELTA_LINE ? 40 * u.deltaY : u.deltaY, c = o.browser.now(), d = c - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = c, h !== 0 && h % 4.000244140625 == 0 ? this._type = "wheel" : h !== 0 && Math.abs(h) < 4 ? this._type = "trackpad" : d > 400 ? (this._type = null, this._lastValue = h, this._timeout = setTimeout(this._onTimeout, 40, u)) : this._type || (this._type = Math.abs(d * h) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, h += this._lastValue)), u.shiftKey && h && (h /= 4), this._type && (this._lastWheelEvent = u, this._delta -= h, this._active || this._start(u)), u.preventDefault();
        }
      }, pr.prototype._onTimeout = function(u) {
        this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(u);
      }, pr.prototype._start = function(u) {
        if (this._delta) {
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          var h = g.mousePos(this._el, u);
          this._around = o.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(h)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
        }
      }, pr.prototype.renderFrame = function() {
        var u = this;
        if (this._frameId && (this._frameId = null, this.isActive())) {
          var h = this._map.transform;
          if (this._delta !== 0) {
            var c = this._type === "wheel" && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, d = 2 / (1 + Math.exp(-Math.abs(this._delta * c)));
            this._delta < 0 && d !== 0 && (d = 1 / d);
            var _ = typeof this._targetZoom == "number" ? h.zoomScale(this._targetZoom) : h.scale;
            this._targetZoom = Math.min(h.maxZoom, Math.max(h.minZoom, h.scaleZoom(_ * d))), this._type === "wheel" && (this._startZoom = h.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          var w, E = typeof this._targetZoom == "number" ? this._targetZoom : h.zoom, O = this._startZoom, k = this._easing, R = !1;
          if (this._type === "wheel" && O && k) {
            var q = Math.min((o.browser.now() - this._lastWheelEventTime) / 200, 1), $ = k(q);
            w = o.number(O, E, $), q < 1 ? this._frameId || (this._frameId = !0) : R = !0;
          } else
            w = E, R = !0;
          return this._active = !0, R && (this._active = !1, this._finishTimeout = setTimeout(function() {
            u._zooming = !1, u._handler._triggerRenderFrame(), delete u._targetZoom, delete u._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !R, zoomDelta: w - h.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
      }, pr.prototype._smoothOutEasing = function(u) {
        var h = o.ease;
        if (this._prevEase) {
          var c = this._prevEase, d = (o.browser.now() - c.start) / c.duration, _ = c.easing(d + 0.01) - c.easing(d), w = 0.27 / Math.sqrt(_ * _ + 1e-4) * 0.01, E = Math.sqrt(0.0729 - w * w);
          h = o.bezier(w, E, 0.25, 1);
        }
        return this._prevEase = { start: o.browser.now(), duration: u, easing: h }, h;
      }, pr.prototype.blur = function() {
        this.reset();
      }, pr.prototype.reset = function() {
        this._active = !1;
      };
      var xa = function(u, h) {
        this._clickZoom = u, this._tapZoom = h;
      };
      xa.prototype.enable = function() {
        this._clickZoom.enable(), this._tapZoom.enable();
      }, xa.prototype.disable = function() {
        this._clickZoom.disable(), this._tapZoom.disable();
      }, xa.prototype.isEnabled = function() {
        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
      }, xa.prototype.isActive = function() {
        return this._clickZoom.isActive() || this._tapZoom.isActive();
      };
      var Wo = function() {
        this.reset();
      };
      Wo.prototype.reset = function() {
        this._active = !1;
      }, Wo.prototype.blur = function() {
        this.reset();
      }, Wo.prototype.dblclick = function(u, h) {
        return u.preventDefault(), { cameraAnimation: function(c) {
          c.easeTo({ duration: 300, zoom: c.getZoom() + (u.shiftKey ? -1 : 1), around: c.unproject(h) }, { originalEvent: u });
        } };
      }, Wo.prototype.enable = function() {
        this._enabled = !0;
      }, Wo.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, Wo.prototype.isEnabled = function() {
        return this._enabled;
      }, Wo.prototype.isActive = function() {
        return this._active;
      };
      var Ti = function() {
        this._tap = new aa({ numTouches: 1, numTaps: 1 }), this.reset();
      };
      Ti.prototype.reset = function() {
        this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
      }, Ti.prototype.touchstart = function(u, h, c) {
        this._swipePoint || (this._tapTime && u.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? c.length > 0 && (this._swipePoint = h[0], this._swipeTouch = c[0].identifier) : this._tap.touchstart(u, h, c));
      }, Ti.prototype.touchmove = function(u, h, c) {
        if (this._tapTime) {
          if (this._swipePoint) {
            if (c[0].identifier !== this._swipeTouch)
              return;
            var d = h[0], _ = d.y - this._swipePoint.y;
            return this._swipePoint = d, u.preventDefault(), this._active = !0, { zoomDelta: _ / 128 };
          }
        } else
          this._tap.touchmove(u, h, c);
      }, Ti.prototype.touchend = function(u, h, c) {
        this._tapTime ? this._swipePoint && c.length === 0 && this.reset() : this._tap.touchend(u, h, c) && (this._tapTime = u.timeStamp);
      }, Ti.prototype.touchcancel = function() {
        this.reset();
      }, Ti.prototype.enable = function() {
        this._enabled = !0;
      }, Ti.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, Ti.prototype.isEnabled = function() {
        return this._enabled;
      }, Ti.prototype.isActive = function() {
        return this._active;
      };
      var yl = function(u, h, c) {
        this._el = u, this._mousePan = h, this._touchPan = c;
      };
      yl.prototype.enable = function(u) {
        this._inertiaOptions = u || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
      }, yl.prototype.disable = function() {
        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
      }, yl.prototype.isEnabled = function() {
        return this._mousePan.isEnabled() && this._touchPan.isEnabled();
      }, yl.prototype.isActive = function() {
        return this._mousePan.isActive() || this._touchPan.isActive();
      };
      var ws = function(u, h, c) {
        this._pitchWithRotate = u.pitchWithRotate, this._mouseRotate = h, this._mousePitch = c;
      };
      ws.prototype.enable = function() {
        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
      }, ws.prototype.disable = function() {
        this._mouseRotate.disable(), this._mousePitch.disable();
      }, ws.prototype.isEnabled = function() {
        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
      }, ws.prototype.isActive = function() {
        return this._mouseRotate.isActive() || this._mousePitch.isActive();
      };
      var la = function(u, h, c, d) {
        this._el = u, this._touchZoom = h, this._touchRotate = c, this._tapDragZoom = d, this._rotationDisabled = !1, this._enabled = !0;
      };
      la.prototype.enable = function(u) {
        this._touchZoom.enable(u), this._rotationDisabled || this._touchRotate.enable(u), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
      }, la.prototype.disable = function() {
        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
      }, la.prototype.isEnabled = function() {
        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
      }, la.prototype.isActive = function() {
        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
      }, la.prototype.disableRotation = function() {
        this._rotationDisabled = !0, this._touchRotate.disable();
      }, la.prototype.enableRotation = function() {
        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
      };
      var ji = function(u) {
        return u.zoom || u.drag || u.pitch || u.rotate;
      }, ic = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h;
      }(o.Event);
      function Lt(u) {
        return u.panDelta && u.panDelta.mag() || u.zoomDelta || u.bearingDelta || u.pitchDelta;
      }
      var Tt = function(u, h) {
        this._map = u, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ec(u), this._bearingSnap = h.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(h), o.bindAll(["handleEvent", "handleWindowEvent"], this);
        var c = this._el;
        this._listeners = [[c, "touchstart", { passive: !0 }], [c, "touchmove", { passive: !1 }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [o.window.document, "mousemove", { capture: !0 }], [o.window.document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: !1 }], [c, "keyup", void 0], [c, "wheel", { passive: !1 }], [c, "contextmenu", void 0], [o.window, "blur", void 0]];
        for (var d = 0, _ = this._listeners; d < _.length; d += 1) {
          var w = _[d], E = w[0];
          g.addEventListener(E, w[1], E === o.window.document ? this.handleWindowEvent : this.handleEvent, w[2]);
        }
      };
      Tt.prototype.destroy = function() {
        for (var u = 0, h = this._listeners; u < h.length; u += 1) {
          var c = h[u], d = c[0];
          g.removeEventListener(d, c[1], d === o.window.document ? this.handleWindowEvent : this.handleEvent, c[2]);
        }
      }, Tt.prototype._addDefaultHandlers = function(u) {
        var h = this._map, c = h.getCanvasContainer();
        this._add("mapEvent", new Gn(h, u));
        var d = h.boxZoom = new uo(h, u);
        this._add("boxZoom", d);
        var _ = new co(), w = new Wo();
        h.doubleClickZoom = new xa(w, _), this._add("tapZoom", _), this._add("clickZoom", w);
        var E = new Ti();
        this._add("tapDragZoom", E);
        var O = h.touchPitch = new sp();
        this._add("touchPitch", O);
        var k = new mh(u), R = new ap(u);
        h.dragRotate = new ws(u, k, R), this._add("mouseRotate", k, ["mousePitch"]), this._add("mousePitch", R, ["mouseRotate"]);
        var q = new op(u), $ = new $o(u);
        h.dragPan = new yl(c, q, $), this._add("mousePan", q), this._add("touchPan", $, ["touchZoom", "touchRotate"]);
        var W = new km(), ne = new fo();
        h.touchZoomRotate = new la(c, ne, W, E), this._add("touchRotate", W, ["touchPan", "touchZoom"]), this._add("touchZoom", ne, ["touchPan", "touchRotate"]);
        var re = h.scrollZoom = new pr(h, this);
        this._add("scrollZoom", re, ["mousePan"]);
        var se = h.keyboard = new sa();
        this._add("keyboard", se), this._add("blockableMapEvent", new wt(h));
        for (var J = 0, ae = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; J < ae.length; J += 1) {
          var pe = ae[J];
          u.interactive && u[pe] && h[pe].enable(u[pe]);
        }
      }, Tt.prototype._add = function(u, h, c) {
        this._handlers.push({ handlerName: u, handler: h, allowed: c }), this._handlersById[u] = h;
      }, Tt.prototype.stop = function(u) {
        if (!this._updatingCamera) {
          for (var h = 0, c = this._handlers; h < c.length; h += 1)
            c[h].handler.reset();
          this._inertia.clear(), this._fireEvents({}, {}, u), this._changes = [];
        }
      }, Tt.prototype.isActive = function() {
        for (var u = 0, h = this._handlers; u < h.length; u += 1)
          if (h[u].handler.isActive())
            return !0;
        return !1;
      }, Tt.prototype.isZooming = function() {
        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
      }, Tt.prototype.isRotating = function() {
        return !!this._eventsInProgress.rotate;
      }, Tt.prototype.isMoving = function() {
        return Boolean(ji(this._eventsInProgress)) || this.isZooming();
      }, Tt.prototype._blockedByActive = function(u, h, c) {
        for (var d in u)
          if (d !== c && (!h || h.indexOf(d) < 0))
            return !0;
        return !1;
      }, Tt.prototype.handleWindowEvent = function(u) {
        this.handleEvent(u, u.type + "Window");
      }, Tt.prototype._getMapTouches = function(u) {
        for (var h = [], c = 0, d = u; c < d.length; c += 1) {
          var _ = d[c];
          this._el.contains(_.target) && h.push(_);
        }
        return h;
      }, Tt.prototype.handleEvent = function(u, h) {
        this._updatingCamera = !0;
        for (var c = u.type === "renderFrame" ? void 0 : u, d = { needsRenderFrame: !1 }, _ = {}, w = {}, E = u.touches ? this._getMapTouches(u.touches) : void 0, O = E ? g.touchPos(this._el, E) : g.mousePos(this._el, u), k = 0, R = this._handlers; k < R.length; k += 1) {
          var q = R[k], $ = q.handlerName, W = q.handler, ne = q.allowed;
          if (W.isEnabled()) {
            var re = void 0;
            this._blockedByActive(w, ne, $) ? W.reset() : W[h || u.type] && (re = W[h || u.type](u, O, E), this.mergeHandlerResult(d, _, re, $, c), re && re.needsRenderFrame && this._triggerRenderFrame()), (re || W.isActive()) && (w[$] = W);
          }
        }
        var se = {};
        for (var J in this._previousActiveHandlers)
          w[J] || (se[J] = c);
        this._previousActiveHandlers = w, (Object.keys(se).length || Lt(d)) && (this._changes.push([d, _, se]), this._triggerRenderFrame()), (Object.keys(w).length || Lt(d)) && this._map._stop(!0), this._updatingCamera = !1;
        var ae = d.cameraAnimation;
        ae && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], ae(this._map));
      }, Tt.prototype.mergeHandlerResult = function(u, h, c, d, _) {
        if (c) {
          o.extend(u, c);
          var w = { handlerName: d, originalEvent: c.originalEvent || _ };
          c.zoomDelta !== void 0 && (h.zoom = w), c.panDelta !== void 0 && (h.drag = w), c.pitchDelta !== void 0 && (h.pitch = w), c.bearingDelta !== void 0 && (h.rotate = w);
        }
      }, Tt.prototype._applyChanges = function() {
        for (var u = {}, h = {}, c = {}, d = 0, _ = this._changes; d < _.length; d += 1) {
          var w = _[d], E = w[0], O = w[1], k = w[2];
          E.panDelta && (u.panDelta = (u.panDelta || new o.Point(0, 0))._add(E.panDelta)), E.zoomDelta && (u.zoomDelta = (u.zoomDelta || 0) + E.zoomDelta), E.bearingDelta && (u.bearingDelta = (u.bearingDelta || 0) + E.bearingDelta), E.pitchDelta && (u.pitchDelta = (u.pitchDelta || 0) + E.pitchDelta), E.around !== void 0 && (u.around = E.around), E.pinchAround !== void 0 && (u.pinchAround = E.pinchAround), E.noInertia && (u.noInertia = E.noInertia), o.extend(h, O), o.extend(c, k);
        }
        this._updateMapTransform(u, h, c), this._changes = [];
      }, Tt.prototype._updateMapTransform = function(u, h, c) {
        var d = this._map, _ = d.transform;
        if (!Lt(u))
          return this._fireEvents(h, c, !0);
        var w = u.panDelta, E = u.zoomDelta, O = u.bearingDelta, k = u.pitchDelta, R = u.around, q = u.pinchAround;
        q !== void 0 && (R = q), d._stop(!0), R = R || d.transform.centerPoint;
        var $ = _.pointLocation(w ? R.sub(w) : R);
        O && (_.bearing += O), k && (_.pitch += k), E && (_.zoom += E), _.setLocationAtPoint($, R), this._map._update(), u.noInertia || this._inertia.record(u), this._fireEvents(h, c, !0);
      }, Tt.prototype._fireEvents = function(u, h, c) {
        var d = this, _ = ji(this._eventsInProgress), w = ji(u), E = {};
        for (var O in u)
          this._eventsInProgress[O] || (E[O + "start"] = u[O].originalEvent), this._eventsInProgress[O] = u[O];
        for (var k in !_ && w && this._fireEvent("movestart", w.originalEvent), E)
          this._fireEvent(k, E[k]);
        for (var R in w && this._fireEvent("move", w.originalEvent), u)
          this._fireEvent(R, u[R].originalEvent);
        var q, $ = {};
        for (var W in this._eventsInProgress) {
          var ne = this._eventsInProgress[W], re = ne.handlerName, se = ne.originalEvent;
          this._handlersById[re].isActive() || (delete this._eventsInProgress[W], $[W + "end"] = q = h[re] || se);
        }
        for (var J in $)
          this._fireEvent(J, $[J]);
        var ae = ji(this._eventsInProgress);
        if (c && (_ || w) && !ae) {
          this._updatingCamera = !0;
          var pe = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), _e = function(Ce) {
            return Ce !== 0 && -d._bearingSnap < Ce && Ce < d._bearingSnap;
          };
          pe ? (_e(pe.bearing || this._map.getBearing()) && (pe.bearing = 0), this._map.easeTo(pe, { originalEvent: q })) : (this._map.fire(new o.Event("moveend", { originalEvent: q })), _e(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
        }
      }, Tt.prototype._fireEvent = function(u, h) {
        this._map.fire(new o.Event(u, h ? { originalEvent: h } : {}));
      }, Tt.prototype._requestFrame = function() {
        var u = this;
        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(function(h) {
          delete u._frameId, u.handleEvent(new ic("renderFrame", { timeStamp: h })), u._applyChanges();
        });
      }, Tt.prototype._triggerRenderFrame = function() {
        this._frameId === void 0 && (this._frameId = this._requestFrame());
      };
      var vh = function(u) {
        function h(c, d) {
          u.call(this), this._moving = !1, this._zooming = !1, this.transform = c, this._bearingSnap = d.bearingSnap, o.bindAll(["_renderFrameCallback"], this);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getCenter = function() {
          return new o.LngLat(this.transform.center.lng, this.transform.center.lat);
        }, h.prototype.setCenter = function(c, d) {
          return this.jumpTo({ center: c }, d);
        }, h.prototype.panBy = function(c, d, _) {
          return c = o.Point.convert(c).mult(-1), this.panTo(this.transform.center, o.extend({ offset: c }, d), _);
        }, h.prototype.panTo = function(c, d, _) {
          return this.easeTo(o.extend({ center: c }, d), _);
        }, h.prototype.getZoom = function() {
          return this.transform.zoom;
        }, h.prototype.setZoom = function(c, d) {
          return this.jumpTo({ zoom: c }, d), this;
        }, h.prototype.zoomTo = function(c, d, _) {
          return this.easeTo(o.extend({ zoom: c }, d), _);
        }, h.prototype.zoomIn = function(c, d) {
          return this.zoomTo(this.getZoom() + 1, c, d), this;
        }, h.prototype.zoomOut = function(c, d) {
          return this.zoomTo(this.getZoom() - 1, c, d), this;
        }, h.prototype.getBearing = function() {
          return this.transform.bearing;
        }, h.prototype.setBearing = function(c, d) {
          return this.jumpTo({ bearing: c }, d), this;
        }, h.prototype.getPadding = function() {
          return this.transform.padding;
        }, h.prototype.setPadding = function(c, d) {
          return this.jumpTo({ padding: c }, d), this;
        }, h.prototype.rotateTo = function(c, d, _) {
          return this.easeTo(o.extend({ bearing: c }, d), _);
        }, h.prototype.resetNorth = function(c, d) {
          return this.rotateTo(0, o.extend({ duration: 1e3 }, c), d), this;
        }, h.prototype.resetNorthPitch = function(c, d) {
          return this.easeTo(o.extend({ bearing: 0, pitch: 0, duration: 1e3 }, c), d), this;
        }, h.prototype.snapToNorth = function(c, d) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(c, d) : this;
        }, h.prototype.getPitch = function() {
          return this.transform.pitch;
        }, h.prototype.setPitch = function(c, d) {
          return this.jumpTo({ pitch: c }, d), this;
        }, h.prototype.cameraForBounds = function(c, d) {
          c = o.LngLatBounds.convert(c);
          var _ = d && d.bearing || 0;
          return this._cameraForBoxAndBearing(c.getNorthWest(), c.getSouthEast(), _, d);
        }, h.prototype._cameraForBoxAndBearing = function(c, d, _, w) {
          var E = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (w = o.extend({ padding: E, offset: [0, 0], maxZoom: this.transform.maxZoom }, w)).padding == "number") {
            var O = w.padding;
            w.padding = { top: O, bottom: O, right: O, left: O };
          }
          w.padding = o.extend(E, w.padding);
          var k = this.transform, R = k.padding, q = k.project(o.LngLat.convert(c)), $ = k.project(o.LngLat.convert(d)), W = q.rotate(-_ * Math.PI / 180), ne = $.rotate(-_ * Math.PI / 180), re = new o.Point(Math.max(W.x, ne.x), Math.max(W.y, ne.y)), se = new o.Point(Math.min(W.x, ne.x), Math.min(W.y, ne.y)), J = re.sub(se), ae = (k.width - (R.left + R.right + w.padding.left + w.padding.right)) / J.x, pe = (k.height - (R.top + R.bottom + w.padding.top + w.padding.bottom)) / J.y;
          if (!(pe < 0 || ae < 0)) {
            var _e = Math.min(k.scaleZoom(k.scale * Math.min(ae, pe)), w.maxZoom), Ce = typeof w.offset.x == "number" ? new o.Point(w.offset.x, w.offset.y) : o.Point.convert(w.offset), Te = new o.Point((w.padding.left - w.padding.right) / 2, (w.padding.top - w.padding.bottom) / 2).rotate(_ * Math.PI / 180), Ae = Ce.add(Te).mult(k.scale / k.zoomScale(_e));
            return { center: k.unproject(q.add($).div(2).sub(Ae)), zoom: _e, bearing: _ };
          }
          o.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }, h.prototype.fitBounds = function(c, d, _) {
          return this._fitInternal(this.cameraForBounds(c, d), d, _);
        }, h.prototype.fitScreenCoordinates = function(c, d, _, w, E) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(o.Point.convert(c)), this.transform.pointLocation(o.Point.convert(d)), _, w), w, E);
        }, h.prototype._fitInternal = function(c, d, _) {
          return c ? (delete (d = o.extend(c, d)).padding, d.linear ? this.easeTo(d, _) : this.flyTo(d, _)) : this;
        }, h.prototype.jumpTo = function(c, d) {
          this.stop();
          var _ = this.transform, w = !1, E = !1, O = !1;
          return "zoom" in c && _.zoom !== +c.zoom && (w = !0, _.zoom = +c.zoom), c.center !== void 0 && (_.center = o.LngLat.convert(c.center)), "bearing" in c && _.bearing !== +c.bearing && (E = !0, _.bearing = +c.bearing), "pitch" in c && _.pitch !== +c.pitch && (O = !0, _.pitch = +c.pitch), c.padding == null || _.isPaddingEqual(c.padding) || (_.padding = c.padding), this.fire(new o.Event("movestart", d)).fire(new o.Event("move", d)), w && this.fire(new o.Event("zoomstart", d)).fire(new o.Event("zoom", d)).fire(new o.Event("zoomend", d)), E && this.fire(new o.Event("rotatestart", d)).fire(new o.Event("rotate", d)).fire(new o.Event("rotateend", d)), O && this.fire(new o.Event("pitchstart", d)).fire(new o.Event("pitch", d)).fire(new o.Event("pitchend", d)), this.fire(new o.Event("moveend", d));
        }, h.prototype.easeTo = function(c, d) {
          var _ = this;
          this._stop(!1, c.easeId), ((c = o.extend({ offset: [0, 0], duration: 500, easing: o.ease }, c)).animate === !1 || !c.essential && o.browser.prefersReducedMotion) && (c.duration = 0);
          var w = this.transform, E = this.getZoom(), O = this.getBearing(), k = this.getPitch(), R = this.getPadding(), q = "zoom" in c ? +c.zoom : E, $ = "bearing" in c ? this._normalizeBearing(c.bearing, O) : O, W = "pitch" in c ? +c.pitch : k, ne = "padding" in c ? c.padding : w.padding, re = o.Point.convert(c.offset), se = w.centerPoint.add(re), J = w.pointLocation(se), ae = o.LngLat.convert(c.center || J);
          this._normalizeCenter(ae);
          var pe, _e, Ce = w.project(J), Te = w.project(ae).sub(Ce), Ae = w.zoomScale(q - E);
          c.around && (pe = o.LngLat.convert(c.around), _e = w.locationPoint(pe));
          var je = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || q !== E, this._rotating = this._rotating || O !== $, this._pitching = this._pitching || W !== k, this._padding = !w.isPaddingEqual(ne), this._easeId = c.easeId, this._prepareEase(d, c.noMoveStart, je), this._ease(function(tt) {
            if (_._zooming && (w.zoom = o.number(E, q, tt)), _._rotating && (w.bearing = o.number(O, $, tt)), _._pitching && (w.pitch = o.number(k, W, tt)), _._padding && (w.interpolatePadding(R, ne, tt), se = w.centerPoint.add(re)), pe)
              w.setLocationAtPoint(pe, _e);
            else {
              var Qe = w.zoomScale(w.zoom - E), gt = q > E ? Math.min(2, Ae) : Math.max(0.5, Ae), Dt = Math.pow(gt, 1 - tt), Ft = w.unproject(Ce.add(Te.mult(tt * Dt)).mult(Qe));
              w.setLocationAtPoint(w.renderWorldCopies ? Ft.wrap() : Ft, se);
            }
            _._fireMoveEvents(d);
          }, function(tt) {
            _._afterEase(d, tt);
          }, c), this;
        }, h.prototype._prepareEase = function(c, d, _) {
          _ === void 0 && (_ = {}), this._moving = !0, d || _.moving || this.fire(new o.Event("movestart", c)), this._zooming && !_.zooming && this.fire(new o.Event("zoomstart", c)), this._rotating && !_.rotating && this.fire(new o.Event("rotatestart", c)), this._pitching && !_.pitching && this.fire(new o.Event("pitchstart", c));
        }, h.prototype._fireMoveEvents = function(c) {
          this.fire(new o.Event("move", c)), this._zooming && this.fire(new o.Event("zoom", c)), this._rotating && this.fire(new o.Event("rotate", c)), this._pitching && this.fire(new o.Event("pitch", c));
        }, h.prototype._afterEase = function(c, d) {
          if (!this._easeId || !d || this._easeId !== d) {
            delete this._easeId;
            var _ = this._zooming, w = this._rotating, E = this._pitching;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, _ && this.fire(new o.Event("zoomend", c)), w && this.fire(new o.Event("rotateend", c)), E && this.fire(new o.Event("pitchend", c)), this.fire(new o.Event("moveend", c));
          }
        }, h.prototype.flyTo = function(c, d) {
          var _ = this;
          if (!c.essential && o.browser.prefersReducedMotion) {
            var w = o.pick(c, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(w, d);
          }
          this.stop(), c = o.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: o.ease }, c);
          var E = this.transform, O = this.getZoom(), k = this.getBearing(), R = this.getPitch(), q = this.getPadding(), $ = "zoom" in c ? o.clamp(+c.zoom, E.minZoom, E.maxZoom) : O, W = "bearing" in c ? this._normalizeBearing(c.bearing, k) : k, ne = "pitch" in c ? +c.pitch : R, re = "padding" in c ? c.padding : E.padding, se = E.zoomScale($ - O), J = o.Point.convert(c.offset), ae = E.centerPoint.add(J), pe = E.pointLocation(ae), _e = o.LngLat.convert(c.center || pe);
          this._normalizeCenter(_e);
          var Ce = E.project(pe), Te = E.project(_e).sub(Ce), Ae = c.curve, je = Math.max(E.width, E.height), tt = je / se, Qe = Te.mag();
          if ("minZoom" in c) {
            var gt = o.clamp(Math.min(c.minZoom, O, $), E.minZoom, E.maxZoom), Dt = je / E.zoomScale(gt - O);
            Ae = Math.sqrt(Dt / Qe * 2);
          }
          var Ft = Ae * Ae;
          function zt(Ht) {
            var qt = (tt * tt - je * je + (Ht ? -1 : 1) * Ft * Ft * Qe * Qe) / (2 * (Ht ? tt : je) * Ft * Qe);
            return Math.log(Math.sqrt(qt * qt + 1) - qt);
          }
          function Tr(Ht) {
            return (Math.exp(Ht) - Math.exp(-Ht)) / 2;
          }
          function xt(Ht) {
            return (Math.exp(Ht) + Math.exp(-Ht)) / 2;
          }
          var Yt = zt(0), ir = function(Ht) {
            return xt(Yt) / xt(Yt + Ae * Ht);
          }, Kt = function(Ht) {
            return je * ((xt(Yt) * (Tr(qt = Yt + Ae * Ht) / xt(qt)) - Tr(Yt)) / Ft) / Qe;
            var qt;
          }, Xt = (zt(1) - Yt) / Ae;
          if (Math.abs(Qe) < 1e-6 || !isFinite(Xt)) {
            if (Math.abs(je - tt) < 1e-6)
              return this.easeTo(c, d);
            var nr = tt < je ? -1 : 1;
            Xt = Math.abs(Math.log(tt / je)) / Ae, Kt = function() {
              return 0;
            }, ir = function(Ht) {
              return Math.exp(nr * Ae * Ht);
            };
          }
          return c.duration = "duration" in c ? +c.duration : 1e3 * Xt / ("screenSpeed" in c ? +c.screenSpeed / Ae : +c.speed), c.maxDuration && c.duration > c.maxDuration && (c.duration = 0), this._zooming = !0, this._rotating = k !== W, this._pitching = ne !== R, this._padding = !E.isPaddingEqual(re), this._prepareEase(d, !1), this._ease(function(Ht) {
            var qt = Ht * Xt, si = 1 / ir(qt);
            E.zoom = Ht === 1 ? $ : O + E.scaleZoom(si), _._rotating && (E.bearing = o.number(k, W, Ht)), _._pitching && (E.pitch = o.number(R, ne, Ht)), _._padding && (E.interpolatePadding(q, re, Ht), ae = E.centerPoint.add(J));
            var In = Ht === 1 ? _e : E.unproject(Ce.add(Te.mult(Kt(qt))).mult(si));
            E.setLocationAtPoint(E.renderWorldCopies ? In.wrap() : In, ae), _._fireMoveEvents(d);
          }, function() {
            return _._afterEase(d);
          }, c), this;
        }, h.prototype.isEasing = function() {
          return !!this._easeFrameId;
        }, h.prototype.stop = function() {
          return this._stop();
        }, h.prototype._stop = function(c, d) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            var _ = this._onEaseEnd;
            delete this._onEaseEnd, _.call(this, d);
          }
          if (!c) {
            var w = this.handlers;
            w && w.stop(!1);
          }
          return this;
        }, h.prototype._ease = function(c, d, _) {
          _.animate === !1 || _.duration === 0 ? (c(1), d()) : (this._easeStart = o.browser.now(), this._easeOptions = _, this._onEaseFrame = c, this._onEaseEnd = d, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }, h.prototype._renderFrameCallback = function() {
          var c = Math.min((o.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
          this._onEaseFrame(this._easeOptions.easing(c)), c < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }, h.prototype._normalizeBearing = function(c, d) {
          c = o.wrap(c, -180, 180);
          var _ = Math.abs(c - d);
          return Math.abs(c - 360 - d) < _ && (c -= 360), Math.abs(c + 360 - d) < _ && (c += 360), c;
        }, h.prototype._normalizeCenter = function(c) {
          var d = this.transform;
          if (d.renderWorldCopies && !d.lngRange) {
            var _ = c.lng - d.center.lng;
            c.lng += _ > 180 ? -360 : _ < -180 ? 360 : 0;
          }
        }, h;
      }(o.Evented), Gi = function(u) {
        u === void 0 && (u = {}), this.options = u, o.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
      };
      Gi.prototype.getDefaultPosition = function() {
        return "bottom-right";
      }, Gi.prototype.onAdd = function(u) {
        var h = this.options && this.options.compact;
        return this._map = u, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = g.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = g.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), h && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), h === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
      }, Gi.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
      }, Gi.prototype._setElementTitle = function(u, h) {
        var c = this._map._getUIString("AttributionControl." + h);
        u.title = c, u.setAttribute("aria-label", c);
      }, Gi.prototype._toggleAttribution = function() {
        this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));
      }, Gi.prototype._updateEditLink = function() {
        var u = this._editLink;
        u || (u = this._editLink = this._container.querySelector(".mapbox-improve-map"));
        var h = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || o.config.ACCESS_TOKEN }];
        if (u) {
          var c = h.reduce(function(d, _, w) {
            return _.value && (d += _.key + "=" + _.value + (w < h.length - 1 ? "&" : "")), d;
          }, "?");
          u.href = o.config.FEEDBACK_URL + "/" + c + (this._map._hash ? this._map._hash.getHashString(!0) : ""), u.rel = "noopener nofollow", this._setElementTitle(u, "MapFeedback");
        }
      }, Gi.prototype._updateData = function(u) {
        !u || u.sourceDataType !== "metadata" && u.sourceDataType !== "visibility" && u.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
      }, Gi.prototype._updateAttributions = function() {
        if (this._map.style) {
          var u = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? u = u.concat(this.options.customAttribution.map(function(O) {
            return typeof O != "string" ? "" : O;
          })) : typeof this.options.customAttribution == "string" && u.push(this.options.customAttribution)), this._map.style.stylesheet) {
            var h = this._map.style.stylesheet;
            this.styleOwner = h.owner, this.styleId = h.id;
          }
          var c = this._map.style.sourceCaches;
          for (var d in c) {
            var _ = c[d];
            if (_.used) {
              var w = _.getSource();
              w.attribution && u.indexOf(w.attribution) < 0 && u.push(w.attribution);
            }
          }
          u.sort(function(O, k) {
            return O.length - k.length;
          });
          var E = (u = u.filter(function(O, k) {
            for (var R = k + 1; R < u.length; R++)
              if (u[R].indexOf(O) >= 0)
                return !1;
            return !0;
          })).join(" | ");
          E !== this._attribHTML && (this._attribHTML = E, u.length ? (this._innerContainer.innerHTML = E, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
      }, Gi.prototype._updateCompact = function() {
        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
      };
      var ua = function() {
        o.bindAll(["_updateLogo"], this), o.bindAll(["_updateCompact"], this);
      };
      ua.prototype.onAdd = function(u) {
        this._map = u, this._container = g.create("div", "mapboxgl-ctrl");
        var h = g.create("a", "mapboxgl-ctrl-logo");
        return h.target = "_blank", h.rel = "noopener nofollow", h.href = "https://www.mapbox.com/", h.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), h.setAttribute("rel", "noopener nofollow"), this._container.appendChild(h), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
      }, ua.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
      }, ua.prototype.getDefaultPosition = function() {
        return "bottom-left";
      }, ua.prototype._updateLogo = function(u) {
        u && u.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
      }, ua.prototype._logoRequired = function() {
        if (this._map.style) {
          var u = this._map.style.sourceCaches;
          for (var h in u)
            if (u[h].getSource().mapbox_logo)
              return !0;
          return !1;
        }
      }, ua.prototype._updateCompact = function() {
        var u = this._container.children;
        if (u.length) {
          var h = u[0];
          this._map.getCanvasContainer().offsetWidth < 250 ? h.classList.add("mapboxgl-compact") : h.classList.remove("mapboxgl-compact");
        }
      };
      var Mi = function() {
        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
      };
      Mi.prototype.add = function(u) {
        var h = ++this._id;
        return this._queue.push({ callback: u, id: h, cancelled: !1 }), h;
      }, Mi.prototype.remove = function(u) {
        for (var h = this._currentlyRunning, c = 0, d = h ? this._queue.concat(h) : this._queue; c < d.length; c += 1) {
          var _ = d[c];
          if (_.id === u)
            return void (_.cancelled = !0);
        }
      }, Mi.prototype.run = function(u) {
        u === void 0 && (u = 0);
        var h = this._currentlyRunning = this._queue;
        this._queue = [];
        for (var c = 0, d = h; c < d.length; c += 1) {
          var _ = d[c];
          if (!_.cancelled && (_.callback(u), this._cleared))
            break;
        }
        this._cleared = !1, this._currentlyRunning = !1;
      }, Mi.prototype.clear = function() {
        this._currentlyRunning && (this._cleared = !0), this._queue = [];
      };
      var ba = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, up = o.window.HTMLImageElement, _h = o.window.HTMLElement, jr = o.window.ImageBitmap, yi = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: !0 }, Lm = function(u) {
        function h(d) {
          var _ = this;
          if ((d = o.extend({}, yi, d)).minZoom != null && d.maxZoom != null && d.minZoom > d.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (d.minPitch != null && d.maxPitch != null && d.minPitch > d.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (d.minPitch != null && d.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (d.maxPitch != null && d.maxPitch > 60)
            throw new Error("maxPitch must be less than or equal to 60");
          var w = new _r(d.minZoom, d.maxZoom, d.minPitch, d.maxPitch, d.renderWorldCopies);
          if (u.call(this, w, d), this._interactive = d.interactive, this._maxTileCacheSize = d.maxTileCacheSize, this._failIfMajorPerformanceCaveat = d.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = d.preserveDrawingBuffer, this._antialias = d.antialias, this._trackResize = d.trackResize, this._bearingSnap = d.bearingSnap, this._refreshExpiredTiles = d.refreshExpiredTiles, this._fadeDuration = d.fadeDuration, this._crossSourceCollisions = d.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = d.collectResourceTiming, this._renderTaskQueue = new Mi(), this._controls = [], this._mapId = o.uniqueId(), this._locale = o.extend({}, ba, d.locale), this._clickTolerance = d.clickTolerance, this._requestManager = new o.RequestManager(d.transformRequest, d.accessToken), typeof d.container == "string") {
            if (this._container = o.window.document.getElementById(d.container), !this._container)
              throw new Error("Container '" + d.container + "' not found.");
          } else {
            if (!(d.container instanceof _h))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = d.container;
          }
          if (d.maxBounds && this.setMaxBounds(d.maxBounds), o.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)
            throw new Error("Failed to initialize WebGL.");
          this.on("move", function() {
            return _._update(!1);
          }), this.on("moveend", function() {
            return _._update(!1);
          }), this.on("zoom", function() {
            return _._update(!0);
          }), o.window !== void 0 && (o.window.addEventListener("online", this._onWindowOnline, !1), o.window.addEventListener("resize", this._onWindowResize, !1), o.window.addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new Tt(this, d), this._hash = d.hash && new Mo(typeof d.hash == "string" && d.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: d.center, zoom: d.zoom, bearing: d.bearing, pitch: d.pitch }), d.bounds && (this.resize(), this.fitBounds(d.bounds, o.extend({}, d.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = d.localIdeographFontFamily, d.style && this.setStyle(d.style, { localIdeographFontFamily: d.localIdeographFontFamily }), d.attributionControl && this.addControl(new Gi({ customAttribution: d.customAttribution })), this.addControl(new ua(), d.logoPosition), this.on("style.load", function() {
            _.transform.unmodified && _.jumpTo(_.style.stylesheet);
          }), this.on("data", function(E) {
            _._update(E.dataType === "style"), _.fire(new o.Event(E.dataType + "data", E));
          }), this.on("dataloading", function(E) {
            _.fire(new o.Event(E.dataType + "dataloading", E));
          });
        }
        u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h;
        var c = { showTileBoundaries: { configurable: !0 }, showPadding: { configurable: !0 }, showCollisionBoxes: { configurable: !0 }, showOverdrawInspector: { configurable: !0 }, repaint: { configurable: !0 }, vertices: { configurable: !0 }, version: { configurable: !0 } };
        return h.prototype._getMapId = function() {
          return this._mapId;
        }, h.prototype.addControl = function(d, _) {
          if (_ === void 0 && (_ = d.getDefaultPosition ? d.getDefaultPosition() : "top-right"), !d || !d.onAdd)
            return this.fire(new o.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          var w = d.onAdd(this);
          this._controls.push(d);
          var E = this._controlPositions[_];
          return _.indexOf("bottom") !== -1 ? E.insertBefore(w, E.firstChild) : E.appendChild(w), this;
        }, h.prototype.removeControl = function(d) {
          if (!d || !d.onRemove)
            return this.fire(new o.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          var _ = this._controls.indexOf(d);
          return _ > -1 && this._controls.splice(_, 1), d.onRemove(this), this;
        }, h.prototype.hasControl = function(d) {
          return this._controls.indexOf(d) > -1;
        }, h.prototype.resize = function(d) {
          var _ = this._containerDimensions(), w = _[0], E = _[1];
          if (w === this.transform.width && E === this.transform.height)
            return this;
          this._resizeCanvas(w, E), this.transform.resize(w, E), this.painter.resize(w, E);
          var O = !this._moving;
          return O && this.fire(new o.Event("movestart", d)).fire(new o.Event("move", d)), this.fire(new o.Event("resize", d)), O && this.fire(new o.Event("moveend", d)), this;
        }, h.prototype.getBounds = function() {
          return this.transform.getBounds();
        }, h.prototype.getMaxBounds = function() {
          return this.transform.getMaxBounds();
        }, h.prototype.setMaxBounds = function(d) {
          return this.transform.setMaxBounds(o.LngLatBounds.convert(d)), this._update();
        }, h.prototype.setMinZoom = function(d) {
          if ((d = d == null ? -2 : d) >= -2 && d <= this.transform.maxZoom)
            return this.transform.minZoom = d, this._update(), this.getZoom() < d && this.setZoom(d), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }, h.prototype.getMinZoom = function() {
          return this.transform.minZoom;
        }, h.prototype.setMaxZoom = function(d) {
          if ((d = d == null ? 22 : d) >= this.transform.minZoom)
            return this.transform.maxZoom = d, this._update(), this.getZoom() > d && this.setZoom(d), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }, h.prototype.getMaxZoom = function() {
          return this.transform.maxZoom;
        }, h.prototype.setMinPitch = function(d) {
          if ((d = d == null ? 0 : d) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (d >= 0 && d <= this.transform.maxPitch)
            return this.transform.minPitch = d, this._update(), this.getPitch() < d && this.setPitch(d), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }, h.prototype.getMinPitch = function() {
          return this.transform.minPitch;
        }, h.prototype.setMaxPitch = function(d) {
          if ((d = d == null ? 60 : d) > 60)
            throw new Error("maxPitch must be less than or equal to 60");
          if (d >= this.transform.minPitch)
            return this.transform.maxPitch = d, this._update(), this.getPitch() > d && this.setPitch(d), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }, h.prototype.getMaxPitch = function() {
          return this.transform.maxPitch;
        }, h.prototype.getRenderWorldCopies = function() {
          return this.transform.renderWorldCopies;
        }, h.prototype.setRenderWorldCopies = function(d) {
          return this.transform.renderWorldCopies = d, this._update();
        }, h.prototype.project = function(d) {
          return this.transform.locationPoint(o.LngLat.convert(d));
        }, h.prototype.unproject = function(d) {
          return this.transform.pointLocation(o.Point.convert(d));
        }, h.prototype.isMoving = function() {
          return this._moving || this.handlers.isMoving();
        }, h.prototype.isZooming = function() {
          return this._zooming || this.handlers.isZooming();
        }, h.prototype.isRotating = function() {
          return this._rotating || this.handlers.isRotating();
        }, h.prototype._createDelegatedListener = function(d, _, w) {
          var E, O = this;
          if (d === "mouseenter" || d === "mouseover") {
            var k = !1;
            return { layer: _, listener: w, delegates: { mousemove: function(q) {
              var $ = O.getLayer(_) ? O.queryRenderedFeatures(q.point, { layers: [_] }) : [];
              $.length ? k || (k = !0, w.call(O, new Jn(d, O, q.originalEvent, { features: $ }))) : k = !1;
            }, mouseout: function() {
              k = !1;
            } } };
          }
          if (d === "mouseleave" || d === "mouseout") {
            var R = !1;
            return { layer: _, listener: w, delegates: { mousemove: function(q) {
              (O.getLayer(_) ? O.queryRenderedFeatures(q.point, { layers: [_] }) : []).length ? R = !0 : R && (R = !1, w.call(O, new Jn(d, O, q.originalEvent)));
            }, mouseout: function(q) {
              R && (R = !1, w.call(O, new Jn(d, O, q.originalEvent)));
            } } };
          }
          return { layer: _, listener: w, delegates: (E = {}, E[d] = function(q) {
            var $ = O.getLayer(_) ? O.queryRenderedFeatures(q.point, { layers: [_] }) : [];
            $.length && (q.features = $, w.call(O, q), delete q.features);
          }, E) };
        }, h.prototype.on = function(d, _, w) {
          if (w === void 0)
            return u.prototype.on.call(this, d, _);
          var E = this._createDelegatedListener(d, _, w);
          for (var O in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[d] = this._delegatedListeners[d] || [], this._delegatedListeners[d].push(E), E.delegates)
            this.on(O, E.delegates[O]);
          return this;
        }, h.prototype.once = function(d, _, w) {
          if (w === void 0)
            return u.prototype.once.call(this, d, _);
          var E = this._createDelegatedListener(d, _, w);
          for (var O in E.delegates)
            this.once(O, E.delegates[O]);
          return this;
        }, h.prototype.off = function(d, _, w) {
          var E = this;
          return w === void 0 ? u.prototype.off.call(this, d, _) : (this._delegatedListeners && this._delegatedListeners[d] && function(O) {
            for (var k = O[d], R = 0; R < k.length; R++) {
              var q = k[R];
              if (q.layer === _ && q.listener === w) {
                for (var $ in q.delegates)
                  E.off($, q.delegates[$]);
                return k.splice(R, 1), E;
              }
            }
          }(this._delegatedListeners), this);
        }, h.prototype.queryRenderedFeatures = function(d, _) {
          if (!this.style)
            return [];
          var w;
          if (_ !== void 0 || d === void 0 || d instanceof o.Point || Array.isArray(d) || (_ = d, d = void 0), _ = _ || {}, (d = d || [[0, 0], [this.transform.width, this.transform.height]]) instanceof o.Point || typeof d[0] == "number")
            w = [o.Point.convert(d)];
          else {
            var E = o.Point.convert(d[0]), O = o.Point.convert(d[1]);
            w = [E, new o.Point(O.x, E.y), O, new o.Point(E.x, O.y), E];
          }
          return this.style.queryRenderedFeatures(w, _, this.transform);
        }, h.prototype.querySourceFeatures = function(d, _) {
          return this.style.querySourceFeatures(d, _);
        }, h.prototype.setStyle = function(d, _) {
          return (_ = o.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, _)).diff !== !1 && _.localIdeographFontFamily === this._localIdeographFontFamily && this.style && d ? (this._diffStyle(d, _), this) : (this._localIdeographFontFamily = _.localIdeographFontFamily, this._updateStyle(d, _));
        }, h.prototype._getUIString = function(d) {
          var _ = this._locale[d];
          if (_ == null)
            throw new Error("Missing UI string '" + d + "'");
          return _;
        }, h.prototype._updateStyle = function(d, _) {
          return this.style && (this.style.setEventedParent(null), this.style._remove()), d ? (this.style = new lo(this, _ || {}), this.style.setEventedParent(this, { style: this.style }), typeof d == "string" ? this.style.loadURL(d) : this.style.loadJSON(d), this) : (delete this.style, this);
        }, h.prototype._lazyInitEmptyStyle = function() {
          this.style || (this.style = new lo(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }, h.prototype._diffStyle = function(d, _) {
          var w = this;
          if (typeof d == "string") {
            var E = this._requestManager.normalizeStyleURL(d), O = this._requestManager.transformRequest(E, o.ResourceType.Style);
            o.getJSON(O, function(k, R) {
              k ? w.fire(new o.ErrorEvent(k)) : R && w._updateDiff(R, _);
            });
          } else
            typeof d == "object" && this._updateDiff(d, _);
        }, h.prototype._updateDiff = function(d, _) {
          try {
            this.style.setState(d) && this._update(!0);
          } catch (w) {
            o.warnOnce("Unable to perform style diff: " + (w.message || w.error || w) + ".  Rebuilding the style from scratch."), this._updateStyle(d, _);
          }
        }, h.prototype.getStyle = function() {
          if (this.style)
            return this.style.serialize();
        }, h.prototype.isStyleLoaded = function() {
          return this.style ? this.style.loaded() : o.warnOnce("There is no style added to the map.");
        }, h.prototype.addSource = function(d, _) {
          return this._lazyInitEmptyStyle(), this.style.addSource(d, _), this._update(!0);
        }, h.prototype.isSourceLoaded = function(d) {
          var _ = this.style && this.style.sourceCaches[d];
          if (_ !== void 0)
            return _.loaded();
          this.fire(new o.ErrorEvent(new Error("There is no source with ID '" + d + "'")));
        }, h.prototype.areTilesLoaded = function() {
          var d = this.style && this.style.sourceCaches;
          for (var _ in d) {
            var w = d[_]._tiles;
            for (var E in w) {
              var O = w[E];
              if (O.state !== "loaded" && O.state !== "errored")
                return !1;
            }
          }
          return !0;
        }, h.prototype.addSourceType = function(d, _, w) {
          return this._lazyInitEmptyStyle(), this.style.addSourceType(d, _, w);
        }, h.prototype.removeSource = function(d) {
          return this.style.removeSource(d), this._update(!0);
        }, h.prototype.getSource = function(d) {
          return this.style.getSource(d);
        }, h.prototype.addImage = function(d, _, w) {
          w === void 0 && (w = {});
          var E = w.pixelRatio;
          E === void 0 && (E = 1);
          var O = w.sdf;
          O === void 0 && (O = !1);
          var k = w.stretchX, R = w.stretchY, q = w.content;
          if (this._lazyInitEmptyStyle(), _ instanceof up || jr && _ instanceof jr) {
            var $ = o.browser.getImageData(_);
            this.style.addImage(d, { data: new o.RGBAImage({ width: $.width, height: $.height }, $.data), pixelRatio: E, stretchX: k, stretchY: R, content: q, sdf: O, version: 0 });
          } else {
            if (_.width === void 0 || _.height === void 0)
              return this.fire(new o.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            var W = _;
            this.style.addImage(d, { data: new o.RGBAImage({ width: _.width, height: _.height }, new Uint8Array(_.data)), pixelRatio: E, stretchX: k, stretchY: R, content: q, sdf: O, version: 0, userImage: W }), W.onAdd && W.onAdd(this, d);
          }
        }, h.prototype.updateImage = function(d, _) {
          var w = this.style.getImage(d);
          if (!w)
            return this.fire(new o.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          var E = _ instanceof up || jr && _ instanceof jr ? o.browser.getImageData(_) : _, O = E.width, k = E.height, R = E.data;
          return O === void 0 || k === void 0 ? this.fire(new o.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : O !== w.data.width || k !== w.data.height ? this.fire(new o.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (w.data.replace(R, !(_ instanceof up || jr && _ instanceof jr)), void this.style.updateImage(d, w));
        }, h.prototype.hasImage = function(d) {
          return d ? !!this.style.getImage(d) : (this.fire(new o.ErrorEvent(new Error("Missing required image id"))), !1);
        }, h.prototype.removeImage = function(d) {
          this.style.removeImage(d);
        }, h.prototype.loadImage = function(d, _) {
          o.getImage(this._requestManager.transformRequest(d, o.ResourceType.Image), _);
        }, h.prototype.listImages = function() {
          return this.style.listImages();
        }, h.prototype.addLayer = function(d, _) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(d, _), this._update(!0);
        }, h.prototype.moveLayer = function(d, _) {
          return this.style.moveLayer(d, _), this._update(!0);
        }, h.prototype.removeLayer = function(d) {
          return this.style.removeLayer(d), this._update(!0);
        }, h.prototype.getLayer = function(d) {
          return this.style.getLayer(d);
        }, h.prototype.setLayerZoomRange = function(d, _, w) {
          return this.style.setLayerZoomRange(d, _, w), this._update(!0);
        }, h.prototype.setFilter = function(d, _, w) {
          return w === void 0 && (w = {}), this.style.setFilter(d, _, w), this._update(!0);
        }, h.prototype.getFilter = function(d) {
          return this.style.getFilter(d);
        }, h.prototype.setPaintProperty = function(d, _, w, E) {
          return E === void 0 && (E = {}), this.style.setPaintProperty(d, _, w, E), this._update(!0);
        }, h.prototype.getPaintProperty = function(d, _) {
          return this.style.getPaintProperty(d, _);
        }, h.prototype.setLayoutProperty = function(d, _, w, E) {
          return E === void 0 && (E = {}), this.style.setLayoutProperty(d, _, w, E), this._update(!0);
        }, h.prototype.getLayoutProperty = function(d, _) {
          return this.style.getLayoutProperty(d, _);
        }, h.prototype.setLight = function(d, _) {
          return _ === void 0 && (_ = {}), this._lazyInitEmptyStyle(), this.style.setLight(d, _), this._update(!0);
        }, h.prototype.getLight = function() {
          return this.style.getLight();
        }, h.prototype.setFeatureState = function(d, _) {
          return this.style.setFeatureState(d, _), this._update();
        }, h.prototype.removeFeatureState = function(d, _) {
          return this.style.removeFeatureState(d, _), this._update();
        }, h.prototype.getFeatureState = function(d) {
          return this.style.getFeatureState(d);
        }, h.prototype.getContainer = function() {
          return this._container;
        }, h.prototype.getCanvasContainer = function() {
          return this._canvasContainer;
        }, h.prototype.getCanvas = function() {
          return this._canvas;
        }, h.prototype._containerDimensions = function() {
          var d = 0, _ = 0;
          return this._container && (d = this._container.clientWidth || 400, _ = this._container.clientHeight || 300), [d, _];
        }, h.prototype._detectMissingCSS = function() {
          o.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && o.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }, h.prototype._setupContainer = function() {
          var d = this._container;
          d.classList.add("mapboxgl-map"), (this._missingCSSCanary = g.create("div", "mapboxgl-canary", d)).style.visibility = "hidden", this._detectMissingCSS();
          var _ = this._canvasContainer = g.create("div", "mapboxgl-canvas-container", d);
          this._interactive && _.classList.add("mapboxgl-interactive"), this._canvas = g.create("canvas", "mapboxgl-canvas", _), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
          var w = this._containerDimensions();
          this._resizeCanvas(w[0], w[1]);
          var E = this._controlContainer = g.create("div", "mapboxgl-control-container", d), O = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function(k) {
            O[k] = g.create("div", "mapboxgl-ctrl-" + k, E);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }, h.prototype._resizeCanvas = function(d, _) {
          var w = o.browser.devicePixelRatio || 1;
          this._canvas.width = w * d, this._canvas.height = w * _, this._canvas.style.width = d + "px", this._canvas.style.height = _ + "px";
        }, h.prototype._setupPainter = function() {
          var d = o.extend({}, m.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), _ = this._canvas.getContext("webgl", d) || this._canvas.getContext("experimental-webgl", d);
          _ ? (this.painter = new mn(_, this.transform), o.webpSupported.testSupport(_)) : this.fire(new o.ErrorEvent(new Error("Failed to initialize WebGL")));
        }, h.prototype._contextLost = function(d) {
          d.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new o.Event("webglcontextlost", { originalEvent: d }));
        }, h.prototype._contextRestored = function(d) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new o.Event("webglcontextrestored", { originalEvent: d }));
        }, h.prototype._onMapScroll = function(d) {
          if (d.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
        }, h.prototype.loaded = function() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }, h.prototype._update = function(d) {
          return this.style ? (this._styleDirty = this._styleDirty || d, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }, h.prototype._requestRenderFrame = function(d) {
          return this._update(), this._renderTaskQueue.add(d);
        }, h.prototype._cancelRenderFrame = function(d) {
          this._renderTaskQueue.remove(d);
        }, h.prototype._render = function(d) {
          var _, w = this, E = 0, O = this.painter.context.extTimerQuery;
          if (this.listens("gpu-timing-frame") && (_ = O.createQueryEXT(), O.beginQueryEXT(O.TIME_ELAPSED_EXT, _), E = o.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(d), !this._removed) {
            var k = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              var R = this.transform.zoom, q = o.browser.now();
              this.style.zoomHistory.update(R, q);
              var $ = new o.EvaluationParameters(R, { now: q, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), W = $.crossFadingFactor();
              W === 1 && W === this._crossFadingFactor || (k = !0, this._crossFadingFactor = W), this.style.update($);
            }
            if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new o.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new o.Event("load"))), this.style && (this.style.hasTransitions() || k) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
              var ne = o.browser.now() - E;
              O.endQueryEXT(O.TIME_ELAPSED_EXT, _), setTimeout(function() {
                var J = O.getQueryObjectEXT(_, O.QUERY_RESULT_EXT) / 1e6;
                O.deleteQueryEXT(_), w.fire(new o.Event("gpu-timing-frame", { cpuTime: ne, gpuTime: J }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              var re = this.painter.collectGpuTimers();
              setTimeout(function() {
                var J = w.painter.queryGpuTimers(re);
                w.fire(new o.Event("gpu-timing-layer", { layerTimes: J }));
              }, 50);
            }
            var se = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return se || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.Event("idle")), !this._loaded || this._fullyLoaded || se || (this._fullyLoaded = !0), this;
          }
        }, h.prototype.remove = function() {
          this._hash && this._hash.remove();
          for (var d = 0, _ = this._controls; d < _.length; d += 1)
            _[d].onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), o.window !== void 0 && (o.window.removeEventListener("resize", this._onWindowResize, !1), o.window.removeEventListener("orientationchange", this._onWindowResize, !1), o.window.removeEventListener("online", this._onWindowOnline, !1));
          var w = this.painter.context.gl.getExtension("WEBGL_lose_context");
          w && w.loseContext(), gl(this._canvasContainer), gl(this._controlContainer), gl(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this._removed = !0, this.fire(new o.Event("remove"));
        }, h.prototype.triggerRepaint = function() {
          var d = this;
          this.style && !this._frame && (this._frame = o.browser.frame(function(_) {
            d._frame = null, d._render(_);
          }));
        }, h.prototype._onWindowOnline = function() {
          this._update();
        }, h.prototype._onWindowResize = function(d) {
          this._trackResize && this.resize({ originalEvent: d })._update();
        }, c.showTileBoundaries.get = function() {
          return !!this._showTileBoundaries;
        }, c.showTileBoundaries.set = function(d) {
          this._showTileBoundaries !== d && (this._showTileBoundaries = d, this._update());
        }, c.showPadding.get = function() {
          return !!this._showPadding;
        }, c.showPadding.set = function(d) {
          this._showPadding !== d && (this._showPadding = d, this._update());
        }, c.showCollisionBoxes.get = function() {
          return !!this._showCollisionBoxes;
        }, c.showCollisionBoxes.set = function(d) {
          this._showCollisionBoxes !== d && (this._showCollisionBoxes = d, d ? this.style._generateCollisionBoxes() : this._update());
        }, c.showOverdrawInspector.get = function() {
          return !!this._showOverdrawInspector;
        }, c.showOverdrawInspector.set = function(d) {
          this._showOverdrawInspector !== d && (this._showOverdrawInspector = d, this._update());
        }, c.repaint.get = function() {
          return !!this._repaint;
        }, c.repaint.set = function(d) {
          this._repaint !== d && (this._repaint = d, this.triggerRepaint());
        }, c.vertices.get = function() {
          return !!this._vertices;
        }, c.vertices.set = function(d) {
          this._vertices = d, this._update();
        }, h.prototype._setCacheLimits = function(d, _) {
          o.setCacheLimits(d, _);
        }, c.version.get = function() {
          return o.version;
        }, Object.defineProperties(h.prototype, c), h;
      }(vh);
      function gl(u) {
        u.parentNode && u.parentNode.removeChild(u);
      }
      var cp = { showCompass: !0, showZoom: !0, visualizePitch: !1 }, Ga = function(u) {
        var h = this;
        this.options = o.extend({}, cp, u), this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", function(c) {
          return c.preventDefault();
        }), this.options.showZoom && (o.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", function(c) {
          return h._map.zoomIn({}, { originalEvent: c });
        }), g.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", !0), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", function(c) {
          return h._map.zoomOut({}, { originalEvent: c });
        }), g.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", !0)), this.options.showCompass && (o.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", function(c) {
          h.options.visualizePitch ? h._map.resetNorthPitch({}, { originalEvent: c }) : h._map.resetNorth({}, { originalEvent: c });
        }), this._compassIcon = g.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", !0));
      };
      Ga.prototype._updateZoomButtons = function() {
        var u = this._map.getZoom(), h = u === this._map.getMaxZoom(), c = u === this._map.getMinZoom();
        this._zoomInButton.disabled = h, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", h.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
      }, Ga.prototype._rotateCompassArrow = function() {
        var u = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";
        this._compassIcon.style.transform = u;
      }, Ga.prototype.onAdd = function(u) {
        return this._map = u, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new po(this._map, this._compass, this.options.visualizePitch)), this._container;
      }, Ga.prototype.onRemove = function() {
        g.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
      }, Ga.prototype._createButton = function(u, h) {
        var c = g.create("button", u, this._container);
        return c.type = "button", c.addEventListener("click", h), c;
      }, Ga.prototype._setButtonTitle = function(u, h) {
        var c = this._map._getUIString("NavigationControl." + h);
        u.title = c, u.setAttribute("aria-label", c);
      };
      var po = function(u, h, c) {
        c === void 0 && (c = !1), this._clickTolerance = 10, this.element = h, this.mouseRotate = new mh({ clickTolerance: u.dragRotate._mouseRotate._clickTolerance }), this.map = u, c && (this.mousePitch = new ap({ clickTolerance: u.dragRotate._mousePitch._clickTolerance })), o.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), g.addEventListener(h, "mousedown", this.mousedown), g.addEventListener(h, "touchstart", this.touchstart, { passive: !1 }), g.addEventListener(h, "touchmove", this.touchmove), g.addEventListener(h, "touchend", this.touchend), g.addEventListener(h, "touchcancel", this.reset);
      };
      function Ql(u, h, c) {
        if (u = new o.LngLat(u.lng, u.lat), h) {
          var d = new o.LngLat(u.lng - 360, u.lat), _ = new o.LngLat(u.lng + 360, u.lat), w = c.locationPoint(u).distSqr(h);
          c.locationPoint(d).distSqr(h) < w ? u = d : c.locationPoint(_).distSqr(h) < w && (u = _);
        }
        for (; Math.abs(u.lng - c.center.lng) > 180; ) {
          var E = c.locationPoint(u);
          if (E.x >= 0 && E.y >= 0 && E.x <= c.width && E.y <= c.height)
            break;
          u.lng > c.center.lng ? u.lng -= 360 : u.lng += 360;
        }
        return u;
      }
      po.prototype.down = function(u, h) {
        this.mouseRotate.mousedown(u, h), this.mousePitch && this.mousePitch.mousedown(u, h), g.disableDrag();
      }, po.prototype.move = function(u, h) {
        var c = this.map, d = this.mouseRotate.mousemoveWindow(u, h);
        if (d && d.bearingDelta && c.setBearing(c.getBearing() + d.bearingDelta), this.mousePitch) {
          var _ = this.mousePitch.mousemoveWindow(u, h);
          _ && _.pitchDelta && c.setPitch(c.getPitch() + _.pitchDelta);
        }
      }, po.prototype.off = function() {
        var u = this.element;
        g.removeEventListener(u, "mousedown", this.mousedown), g.removeEventListener(u, "touchstart", this.touchstart, { passive: !1 }), g.removeEventListener(u, "touchmove", this.touchmove), g.removeEventListener(u, "touchend", this.touchend), g.removeEventListener(u, "touchcancel", this.reset), this.offTemp();
      }, po.prototype.offTemp = function() {
        g.enableDrag(), g.removeEventListener(o.window, "mousemove", this.mousemove), g.removeEventListener(o.window, "mouseup", this.mouseup);
      }, po.prototype.mousedown = function(u) {
        this.down(o.extend({}, u, { ctrlKey: !0, preventDefault: function() {
          return u.preventDefault();
        } }), g.mousePos(this.element, u)), g.addEventListener(o.window, "mousemove", this.mousemove), g.addEventListener(o.window, "mouseup", this.mouseup);
      }, po.prototype.mousemove = function(u) {
        this.move(u, g.mousePos(this.element, u));
      }, po.prototype.mouseup = function(u) {
        this.mouseRotate.mouseupWindow(u), this.mousePitch && this.mousePitch.mouseupWindow(u), this.offTemp();
      }, po.prototype.touchstart = function(u) {
        u.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = g.touchPos(this.element, u.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: function() {
          return u.preventDefault();
        } }, this._startPos));
      }, po.prototype.touchmove = function(u) {
        u.targetTouches.length !== 1 ? this.reset() : (this._lastPos = g.touchPos(this.element, u.targetTouches)[0], this.move({ preventDefault: function() {
          return u.preventDefault();
        } }, this._lastPos));
      }, po.prototype.touchend = function(u) {
        u.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
      }, po.prototype.reset = function() {
        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
      };
      var wa = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function xh(u, h, c) {
        var d = u.classList;
        for (var _ in wa)
          d.remove("mapboxgl-" + c + "-anchor-" + _);
        d.add("mapboxgl-" + c + "-anchor-" + h);
      }
      var eu, oc = function(u) {
        function h(c, d) {
          if (u.call(this), (c instanceof o.window.HTMLElement || d) && (c = o.extend({ element: c }, d)), o.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = c && c.anchor || "center", this._color = c && c.color || "#3FB1CE", this._scale = c && c.scale || 1, this._draggable = c && c.draggable || !1, this._clickTolerance = c && c.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = c && c.rotation || 0, this._rotationAlignment = c && c.rotationAlignment || "auto", this._pitchAlignment = c && c.pitchAlignment && c.pitchAlignment !== "auto" ? c.pitchAlignment : this._rotationAlignment, c && c.element)
            this._element = c.element, this._offset = o.Point.convert(c && c.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = g.create("div"), this._element.setAttribute("aria-label", "Map marker");
            var _ = g.createNS("http://www.w3.org/2000/svg", "svg");
            _.setAttributeNS(null, "display", "block"), _.setAttributeNS(null, "height", "41px"), _.setAttributeNS(null, "width", "27px"), _.setAttributeNS(null, "viewBox", "0 0 27 41");
            var w = g.createNS("http://www.w3.org/2000/svg", "g");
            w.setAttributeNS(null, "stroke", "none"), w.setAttributeNS(null, "stroke-width", "1"), w.setAttributeNS(null, "fill", "none"), w.setAttributeNS(null, "fill-rule", "evenodd");
            var E = g.createNS("http://www.w3.org/2000/svg", "g");
            E.setAttributeNS(null, "fill-rule", "nonzero");
            var O = g.createNS("http://www.w3.org/2000/svg", "g");
            O.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), O.setAttributeNS(null, "fill", "#000000");
            for (var k = 0, R = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; k < R.length; k += 1) {
              var q = R[k], $ = g.createNS("http://www.w3.org/2000/svg", "ellipse");
              $.setAttributeNS(null, "opacity", "0.04"), $.setAttributeNS(null, "cx", "10.5"), $.setAttributeNS(null, "cy", "5.80029008"), $.setAttributeNS(null, "rx", q.rx), $.setAttributeNS(null, "ry", q.ry), O.appendChild($);
            }
            var W = g.createNS("http://www.w3.org/2000/svg", "g");
            W.setAttributeNS(null, "fill", this._color);
            var ne = g.createNS("http://www.w3.org/2000/svg", "path");
            ne.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), W.appendChild(ne);
            var re = g.createNS("http://www.w3.org/2000/svg", "g");
            re.setAttributeNS(null, "opacity", "0.25"), re.setAttributeNS(null, "fill", "#000000");
            var se = g.createNS("http://www.w3.org/2000/svg", "path");
            se.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), re.appendChild(se);
            var J = g.createNS("http://www.w3.org/2000/svg", "g");
            J.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), J.setAttributeNS(null, "fill", "#FFFFFF");
            var ae = g.createNS("http://www.w3.org/2000/svg", "g");
            ae.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            var pe = g.createNS("http://www.w3.org/2000/svg", "circle");
            pe.setAttributeNS(null, "fill", "#000000"), pe.setAttributeNS(null, "opacity", "0.25"), pe.setAttributeNS(null, "cx", "5.5"), pe.setAttributeNS(null, "cy", "5.5"), pe.setAttributeNS(null, "r", "5.4999962");
            var _e = g.createNS("http://www.w3.org/2000/svg", "circle");
            _e.setAttributeNS(null, "fill", "#FFFFFF"), _e.setAttributeNS(null, "cx", "5.5"), _e.setAttributeNS(null, "cy", "5.5"), _e.setAttributeNS(null, "r", "5.4999962"), ae.appendChild(pe), ae.appendChild(_e), E.appendChild(O), E.appendChild(W), E.appendChild(re), E.appendChild(J), E.appendChild(ae), _.appendChild(E), _.setAttributeNS(null, "height", 41 * this._scale + "px"), _.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(_), this._offset = o.Point.convert(c && c.offset || [0, -14]);
          }
          this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", function(Ce) {
            Ce.preventDefault();
          }), this._element.addEventListener("mousedown", function(Ce) {
            Ce.preventDefault();
          }), xh(this._element, this._anchor, "marker"), this._popup = null;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.addTo = function(c) {
          return this.remove(), this._map = c, c.getCanvasContainer().appendChild(this._element), c.on("move", this._update), c.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }, h.prototype.remove = function() {
          return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), g.remove(this._element), this._popup && this._popup.remove(), this;
        }, h.prototype.getLngLat = function() {
          return this._lngLat;
        }, h.prototype.setLngLat = function(c) {
          return this._lngLat = o.LngLat.convert(c), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }, h.prototype.getElement = function() {
          return this._element;
        }, h.prototype.setPopup = function(c) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), c) {
            if (!("offset" in c.options)) {
              var d = Math.sqrt(Math.pow(13.5, 2) / 2);
              c.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [d, -1 * (24.6 + d)], "bottom-right": [-d, -1 * (24.6 + d)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset;
            }
            this._popup = c, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }, h.prototype._onKeyPress = function(c) {
          var d = c.code, _ = c.charCode || c.keyCode;
          d !== "Space" && d !== "Enter" && _ !== 32 && _ !== 13 || this.togglePopup();
        }, h.prototype._onMapClick = function(c) {
          var d = c.originalEvent.target, _ = this._element;
          this._popup && (d === _ || _.contains(d)) && this.togglePopup();
        }, h.prototype.getPopup = function() {
          return this._popup;
        }, h.prototype.togglePopup = function() {
          var c = this._popup;
          return c ? (c.isOpen() ? c.remove() : c.addTo(this._map), this) : this;
        }, h.prototype._update = function(c) {
          if (this._map) {
            this._map.transform.renderWorldCopies && (this._lngLat = Ql(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
            var d = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? d = "rotateZ(" + this._rotation + "deg)" : this._rotationAlignment === "map" && (d = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");
            var _ = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? _ = "rotateX(0deg)" : this._pitchAlignment === "map" && (_ = "rotateX(" + this._map.getPitch() + "deg)"), c && c.type !== "moveend" || (this._pos = this._pos.round()), g.setTransform(this._element, wa[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + _ + " " + d);
          }
        }, h.prototype.getOffset = function() {
          return this._offset;
        }, h.prototype.setOffset = function(c) {
          return this._offset = o.Point.convert(c), this._update(), this;
        }, h.prototype._onMove = function(c) {
          if (!this._isDragging) {
            var d = this._clickTolerance || this._map._clickTolerance;
            this._isDragging = c.point.dist(this._pointerdownPos) >= d;
          }
          this._isDragging && (this._pos = c.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.Event("dragstart"))), this.fire(new o.Event("drag")));
        }, h.prototype._onUp = function() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.Event("dragend")), this._state = "inactive";
        }, h.prototype._addDragHandler = function(c) {
          this._element.contains(c.originalEvent.target) && (c.preventDefault(), this._positionDelta = c.point.sub(this._pos).add(this._offset), this._pointerdownPos = c.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
        }, h.prototype.setDraggable = function(c) {
          return this._draggable = !!c, this._map && (c ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }, h.prototype.isDraggable = function() {
          return this._draggable;
        }, h.prototype.setRotation = function(c) {
          return this._rotation = c || 0, this._update(), this;
        }, h.prototype.getRotation = function() {
          return this._rotation;
        }, h.prototype.setRotationAlignment = function(c) {
          return this._rotationAlignment = c || "auto", this._update(), this;
        }, h.prototype.getRotationAlignment = function() {
          return this._rotationAlignment;
        }, h.prototype.setPitchAlignment = function(c) {
          return this._pitchAlignment = c && c !== "auto" ? c : this._rotationAlignment, this._update(), this;
        }, h.prototype.getPitchAlignment = function() {
          return this._pitchAlignment;
        }, h;
      }(o.Evented), hp = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 }, tu = 0, vl = !1, fp = function(u) {
        function h(c) {
          u.call(this), this.options = o.extend({}, hp, c), o.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.onAdd = function(c) {
          var d;
          return this._map = c, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), d = this._setupUI, eu !== void 0 ? d(eu) : o.window.navigator.permissions !== void 0 ? o.window.navigator.permissions.query({ name: "geolocation" }).then(function(_) {
            d(eu = _.state !== "denied");
          }) : d(eu = !!o.window.navigator.geolocation), this._container;
        }, h.prototype.onRemove = function() {
          this._geolocationWatchID !== void 0 && (o.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), g.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, tu = 0, vl = !1;
        }, h.prototype._isOutOfMapMaxBounds = function(c) {
          var d = this._map.getMaxBounds(), _ = c.coords;
          return d && (_.longitude < d.getWest() || _.longitude > d.getEast() || _.latitude < d.getSouth() || _.latitude > d.getNorth());
        }, h.prototype._setErrorState = function() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }, h.prototype._onSuccess = function(c) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(c))
              return this._setErrorState(), this.fire(new o.Event("outofmaxbounds", c)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = c, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(c), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(c), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new o.Event("geolocate", c)), this._finish();
          }
        }, h.prototype._updateCamera = function(c) {
          var d = new o.LngLat(c.coords.longitude, c.coords.latitude), _ = c.coords.accuracy, w = this._map.getBearing(), E = o.extend({ bearing: w }, this.options.fitBoundsOptions);
          this._map.fitBounds(d.toBounds(_), E, { geolocateSource: !0 });
        }, h.prototype._updateMarker = function(c) {
          if (c) {
            var d = new o.LngLat(c.coords.longitude, c.coords.latitude);
            this._accuracyCircleMarker.setLngLat(d).addTo(this._map), this._userLocationDotMarker.setLngLat(d).addTo(this._map), this._accuracy = c.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }, h.prototype._updateCircleRadius = function() {
          var c = this._map._container.clientHeight / 2, d = this._map.unproject([0, c]), _ = this._map.unproject([1, c]), w = d.distanceTo(_), E = Math.ceil(2 * this._accuracy / w);
          this._circleElement.style.width = E + "px", this._circleElement.style.height = E + "px";
        }, h.prototype._onZoom = function() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }, h.prototype._onError = function(c) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (c.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                var d = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = d, this._geolocateButton.setAttribute("aria-label", d), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (c.code === 3 && vl)
                  return;
                this._setErrorState();
              }
            this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new o.Event("error", c)), this._finish();
          }
        }, h.prototype._finish = function() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }, h.prototype._setupUI = function(c) {
          var d = this;
          if (this._container.addEventListener("contextmenu", function(E) {
            return E.preventDefault();
          }), this._geolocateButton = g.create("button", "mapboxgl-ctrl-geolocate", this._container), g.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", !0), this._geolocateButton.type = "button", c === !1) {
            o.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
            var _ = this._map._getUIString("GeolocateControl.LocationNotAvailable");
            this._geolocateButton.disabled = !0, this._geolocateButton.title = _, this._geolocateButton.setAttribute("aria-label", _);
          } else {
            var w = this._map._getUIString("GeolocateControl.FindMyLocation");
            this._geolocateButton.title = w, this._geolocateButton.setAttribute("aria-label", w);
          }
          this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = g.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new oc(this._dotElement), this._circleElement = g.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new oc({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", function(E) {
            E.geolocateSource || d._watchState !== "ACTIVE_LOCK" || E.originalEvent && E.originalEvent.type === "resize" || (d._watchState = "BACKGROUND", d._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), d._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), d.fire(new o.Event("trackuserlocationend")));
          });
        }, h.prototype.trigger = function() {
          if (!this._setup)
            return o.warnOnce("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new o.Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                tu--, vl = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new o.Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.Event("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
              this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              var c;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++tu > 1 ? (c = { maximumAge: 6e5, timeout: 0 }, vl = !0) : (c = this.options.positionOptions, vl = !1), this._geolocationWatchID = o.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, c);
            }
          } else
            o.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }, h.prototype._clearWatch = function() {
          o.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }, h;
      }(o.Evented), Es = { maxWidth: 100, unit: "metric" }, Ss = function(u) {
        this.options = o.extend({}, Es, u), o.bindAll(["_onMove", "setUnit"], this);
      };
      function bh(u, h, c) {
        var d = c && c.maxWidth || 100, _ = u._container.clientHeight / 2, w = u.unproject([0, _]), E = u.unproject([d, _]), O = w.distanceTo(E);
        if (c && c.unit === "imperial") {
          var k = 3.2808 * O;
          k > 5280 ? Ts(h, d, k / 5280, u._getUIString("ScaleControl.Miles")) : Ts(h, d, k, u._getUIString("ScaleControl.Feet"));
        } else
          c && c.unit === "nautical" ? Ts(h, d, O / 1852, u._getUIString("ScaleControl.NauticalMiles")) : O >= 1e3 ? Ts(h, d, O / 1e3, u._getUIString("ScaleControl.Kilometers")) : Ts(h, d, O, u._getUIString("ScaleControl.Meters"));
      }
      function Ts(u, h, c, d) {
        var _, w, E, O = (_ = c, (w = Math.pow(10, ("" + Math.floor(_)).length - 1)) * (E = (E = _ / w) >= 10 ? 10 : E >= 5 ? 5 : E >= 3 ? 3 : E >= 2 ? 2 : E >= 1 ? 1 : function(k) {
          var R = Math.pow(10, Math.ceil(-Math.log(k) / Math.LN10));
          return Math.round(k * R) / R;
        }(E)));
        u.style.width = h * (O / c) + "px", u.innerHTML = O + "&nbsp;" + d;
      }
      Ss.prototype.getDefaultPosition = function() {
        return "bottom-left";
      }, Ss.prototype._onMove = function() {
        bh(this._map, this._container, this.options);
      }, Ss.prototype.onAdd = function(u) {
        return this._map = u, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", u.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
      }, Ss.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
      }, Ss.prototype.setUnit = function(u) {
        this.options.unit = u, bh(this._map, this._container, this.options);
      };
      var Ho = function(u) {
        this._fullscreen = !1, u && u.container && (u.container instanceof o.window.HTMLElement ? this._container = u.container : o.warnOnce("Full screen control 'container' must be a DOM element.")), o.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in o.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in o.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in o.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in o.window.document && (this._fullscreenchange = "MSFullscreenChange");
      };
      Ho.prototype.onAdd = function(u) {
        return this._map = u, this._container || (this._container = this._map.getContainer()), this._controlContainer = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", o.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
      }, Ho.prototype.onRemove = function() {
        g.remove(this._controlContainer), this._map = null, o.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
      }, Ho.prototype._checkFullscreenSupport = function() {
        return !!(o.window.document.fullscreenEnabled || o.window.document.mozFullScreenEnabled || o.window.document.msFullscreenEnabled || o.window.document.webkitFullscreenEnabled);
      }, Ho.prototype._setupUI = function() {
        var u = this._fullscreenButton = g.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
        g.create("span", "mapboxgl-ctrl-icon", u).setAttribute("aria-hidden", !0), u.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), o.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
      }, Ho.prototype._updateTitle = function() {
        var u = this._getTitle();
        this._fullscreenButton.setAttribute("aria-label", u), this._fullscreenButton.title = u;
      }, Ho.prototype._getTitle = function() {
        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
      }, Ho.prototype._isFullscreen = function() {
        return this._fullscreen;
      }, Ho.prototype._changeIcon = function() {
        (o.window.document.fullscreenElement || o.window.document.mozFullScreenElement || o.window.document.webkitFullscreenElement || o.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
      }, Ho.prototype._onClickFullscreen = function() {
        this._isFullscreen() ? o.window.document.exitFullscreen ? o.window.document.exitFullscreen() : o.window.document.mozCancelFullScreen ? o.window.document.mozCancelFullScreen() : o.window.document.msExitFullscreen ? o.window.document.msExitFullscreen() : o.window.document.webkitCancelFullScreen && o.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
      };
      var pp = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, ac = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), dp = function(u) {
        function h(c) {
          u.call(this), this.options = o.extend(Object.create(pp), c), o.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.addTo = function(c) {
          return this._map && this.remove(), this._map = c, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.Event("open")), this;
        }, h.prototype.isOpen = function() {
          return !!this._map;
        }, h.prototype.remove = function() {
          return this._content && g.remove(this._content), this._container && (g.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new o.Event("close")), this;
        }, h.prototype.getLngLat = function() {
          return this._lngLat;
        }, h.prototype.setLngLat = function(c) {
          return this._lngLat = o.LngLat.convert(c), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }, h.prototype.trackPointer = function() {
          return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }, h.prototype.getElement = function() {
          return this._container;
        }, h.prototype.setText = function(c) {
          return this.setDOMContent(o.window.document.createTextNode(c));
        }, h.prototype.setHTML = function(c) {
          var d, _ = o.window.document.createDocumentFragment(), w = o.window.document.createElement("body");
          for (w.innerHTML = c; d = w.firstChild; )
            _.appendChild(d);
          return this.setDOMContent(_);
        }, h.prototype.getMaxWidth = function() {
          return this._container && this._container.style.maxWidth;
        }, h.prototype.setMaxWidth = function(c) {
          return this.options.maxWidth = c, this._update(), this;
        }, h.prototype.setDOMContent = function(c) {
          if (this._content)
            for (; this._content.hasChildNodes(); )
              this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else
            this._content = g.create("div", "mapboxgl-popup-content", this._container);
          return this._content.appendChild(c), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }, h.prototype.addClassName = function(c) {
          this._container && this._container.classList.add(c);
        }, h.prototype.removeClassName = function(c) {
          this._container && this._container.classList.remove(c);
        }, h.prototype.setOffset = function(c) {
          return this.options.offset = c, this._update(), this;
        }, h.prototype.toggleClassName = function(c) {
          if (this._container)
            return this._container.classList.toggle(c);
        }, h.prototype._createCloseButton = function() {
          this.options.closeButton && (this._closeButton = g.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }, h.prototype._onMouseUp = function(c) {
          this._update(c.point);
        }, h.prototype._onMouseMove = function(c) {
          this._update(c.point);
        }, h.prototype._onDrag = function(c) {
          this._update(c.point);
        }, h.prototype._update = function(c) {
          var d = this;
          if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = g.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = g.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function($) {
            return d._container.classList.add($);
          }), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Ql(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || c)) {
            var _ = this._pos = this._trackPointer && c ? c : this._map.project(this._lngLat), w = this.options.anchor, E = function $(W) {
              if (W) {
                if (typeof W == "number") {
                  var ne = Math.round(Math.sqrt(0.5 * Math.pow(W, 2)));
                  return { center: new o.Point(0, 0), top: new o.Point(0, W), "top-left": new o.Point(ne, ne), "top-right": new o.Point(-ne, ne), bottom: new o.Point(0, -W), "bottom-left": new o.Point(ne, -ne), "bottom-right": new o.Point(-ne, -ne), left: new o.Point(W, 0), right: new o.Point(-W, 0) };
                }
                if (W instanceof o.Point || Array.isArray(W)) {
                  var re = o.Point.convert(W);
                  return { center: re, top: re, "top-left": re, "top-right": re, bottom: re, "bottom-left": re, "bottom-right": re, left: re, right: re };
                }
                return { center: o.Point.convert(W.center || [0, 0]), top: o.Point.convert(W.top || [0, 0]), "top-left": o.Point.convert(W["top-left"] || [0, 0]), "top-right": o.Point.convert(W["top-right"] || [0, 0]), bottom: o.Point.convert(W.bottom || [0, 0]), "bottom-left": o.Point.convert(W["bottom-left"] || [0, 0]), "bottom-right": o.Point.convert(W["bottom-right"] || [0, 0]), left: o.Point.convert(W.left || [0, 0]), right: o.Point.convert(W.right || [0, 0]) };
              }
              return $(new o.Point(0, 0));
            }(this.options.offset);
            if (!w) {
              var O, k = this._container.offsetWidth, R = this._container.offsetHeight;
              O = _.y + E.bottom.y < R ? ["top"] : _.y > this._map.transform.height - R ? ["bottom"] : [], _.x < k / 2 ? O.push("left") : _.x > this._map.transform.width - k / 2 && O.push("right"), w = O.length === 0 ? "bottom" : O.join("-");
            }
            var q = _.add(E[w]).round();
            g.setTransform(this._container, wa[w] + " translate(" + q.x + "px," + q.y + "px)"), xh(this._container, w, "popup");
          }
        }, h.prototype._focusFirstElement = function() {
          if (this.options.focusAfterOpen && this._container) {
            var c = this._container.querySelector(ac);
            c && c.focus();
          }
        }, h.prototype._onClose = function() {
          this.remove();
        }, h;
      }(o.Evented), wh = { version: o.version, supported: m, setRTLTextPlugin: o.setRTLTextPlugin, getRTLTextPluginStatus: o.getRTLTextPluginStatus, Map: Lm, NavigationControl: Ga, GeolocateControl: fp, AttributionControl: Gi, ScaleControl: Ss, FullscreenControl: Ho, Popup: dp, Marker: oc, Style: lo, LngLat: o.LngLat, LngLatBounds: o.LngLatBounds, Point: o.Point, MercatorCoordinate: o.MercatorCoordinate, Evented: o.Evented, config: o.config, prewarm: function() {
        Pe().acquire(Oe);
      }, clearPrewarmedResources: function() {
        var u = Et;
        u && (u.isPreloaded() && u.numActive() === 1 ? (u.release(Oe), Et = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get accessToken() {
        return o.config.ACCESS_TOKEN;
      }, set accessToken(u) {
        o.config.ACCESS_TOKEN = u;
      }, get baseApiUrl() {
        return o.config.API_URL;
      }, set baseApiUrl(u) {
        o.config.API_URL = u;
      }, get workerCount() {
        return Ve.workerCount;
      }, set workerCount(u) {
        Ve.workerCount = u;
      }, get maxParallelImageRequests() {
        return o.config.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(u) {
        o.config.MAX_PARALLEL_IMAGE_REQUESTS = u;
      }, clearStorage: function(u) {
        o.clearTileCache(u);
      }, workerUrl: "" };
      return wh;
    }), s;
  });
})(kT);
const Zw = kT.exports;
class LT extends bC {
  constructor(e) {
    const n = Object.assign({}, e);
    delete n.accessToken, delete n.style, delete n.container, delete n.xyz, super(n), this.set("xyz", e.maplibreOptions.xyz), this.set("xyz_custom", e.maplibreOptions.xyz_custom), this.xyz_ = e.xyz, e.accessToken && (Zw.accessToken = e.accessToken), this.map_ = new Zw.Map({
      container: e.maplibreOptions.container,
      style: e.maplibreOptions.style,
      attributionControl: !1,
      interactive: !1
    }), this.maplibreMap = this.map_;
  }
  getMapBoxMap() {
    return this.map_;
  }
  getMapLibreMap() {
    return this.map_;
  }
  render(e) {
    const n = this.map_.getCanvas(), a = e.viewState;
    n.style.position = "absolute";
    const s = this.getVisible();
    n.style.display = s ? "block" : "none";
    const f = this.getOpacity().toString();
    f !== n.style.opacity && (n.style.opacity = f);
    const o = a.rotation;
    return o && this.map_.rotateTo(wC(-o), {
      animate: !1
    }), this.map_.jumpTo({
      center: EC(a.center),
      zoom: a.zoom - 1,
      animate: !1
    }), this.map_._frame && (this.map_._frame.cancel(), this.map_._frame = null), this.map_._render(), n;
  }
  setLayerVisibility(e, n) {
    this.map_.setLayoutProperty(
      e,
      "visibility",
      n ? "visible" : "none"
    );
  }
  getStyle() {
    return this.map_.getStyle();
  }
  getXYZ() {
    return this.get("xyz");
  }
}
const $p = /* @__PURE__ */ new Map();
class X4 {
  styleSerialToStyle(e) {
    return e ? JSON.parse(decodeURIComponent(e)) || [] : [];
  }
  styleLocalStorageToStyle(e) {
    return e ? JSON.parse(e).medium || [] : [];
  }
  styleToSerial(e) {
    return e && e.length > 0 ? JSON.stringify(e) : "";
  }
  styleToLocalStorage(e) {
    return e && e.length > 0 ? JSON.stringify({ medium: e }) : "";
  }
}
const My = new X4();
function Xw(t, e) {
  let n;
  return (...a) => {
    clearTimeout(n), n = setTimeout(() => {
      t.apply(a);
    }, e);
  };
}
function Sf(t) {
  return (t == null ? void 0 : t.trim()) && !isNaN(Number(t)) ? Number(t) : void 0;
}
function K4(t, e) {
  return (t == null ? void 0 : t.split(e).map(
    (n) => n !== null && !isNaN(Number(n)) ? parseFloat(n) : void 0
  )) || [];
}
function Y4(t, e) {
  return (t == null ? void 0 : t.split(e).map(j1)) || [];
}
function j1(t) {
  return (t == null ? void 0 : t.trim()) === "true" ? !0 : (t == null ? void 0 : t.trim()) === "false" ? !1 : void 0;
}
function DT() {
  return window.matchMedia(
    "(-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2), (min-resolution: 192dpi)"
  ).matches;
}
const Hd = "ipv6", Zd = "applogin", Xd = "localforage", Tf = "debug", Lg = "fid", Ou = "lang", Dg = "layersOpen", Ng = "address", Z0 = "version", J4 = "map_id", Kw = "layers", Yw = "bgLayer", Jw = "opacities", Dd = "theme", Qw = "time", e2 = "zoom", Q4 = "SRS", t2 = "X", r2 = "Y", Rg = "serial", NT = [
  "basemap_2015_global",
  "topogr_global",
  "topo_bw_jpeg"
], X0 = "lc", K0 = "sliderRatio", RT = "bgOpacity", e5 = "layers_indices", n2 = "layers_opacity", i2 = "layers_visibility";
var oo = /* @__PURE__ */ ((t) => (t[t.localStorage = 0] = "localStorage", t[t.permalink = 1] = "permalink", t[t.permalinkAsPath = 2] = "permalinkAsPath", t[t.permalinkAndLocalStorage = 3] = "permalinkAndLocalStorage", t))(oo || {});
class zT {
}
class zg extends zT {
  static processRules(e) {
    return zg.ruleUseLocalStorage(e) ? oo.localStorage : oo.permalink;
  }
  static processRulesForKey(e, n) {
    if (e === Dd && {}.VITE_DEPLOY_GHPAGES !== "true")
      return oo.permalinkAsPath;
    if (NT.includes(e))
      return oo.localStorage;
    if (e === Rg)
      return oo.permalink;
    if (e === Dg)
      return oo.localStorage;
  }
  static ruleUseLocalStorage(e) {
    return [t5, r5, n5].reduce(
      (n, a) => n || a(e),
      !1
    );
  }
}
const t5 = (t) => Object.keys(t).length === 0, r5 = (t) => Object.keys(t).length === 1 && (t.hasOwnProperty(Hd) || t.hasOwnProperty(Zd) || t.hasOwnProperty(Xd)), n5 = (t) => Object.keys(t).length === 3 && t.hasOwnProperty(Hd) && t.hasOwnProperty(Zd) && t.hasOwnProperty(Xd);
class Fg extends zT {
  static processRules() {
    return oo.permalinkAndLocalStorage;
  }
  static processRulesForKey(e, n) {
    if (Fg.ruleUsePermalink(e))
      return oo.permalink;
    if (e === Dg || NT.includes(e))
      return oo.localStorage;
    if (e === Rg)
      return oo.permalink;
    if (e === Dd)
      return oo.permalinkAsPath;
  }
  static ruleUsePermalink(e) {
    return [
      i5,
      o5,
      a5
    ].reduce(
      (n, a) => n || a(e),
      !1
    );
  }
}
const i5 = (t) => t === X0 || t === K0, o5 = (t) => t === Z0, a5 = (t) => t === Dd && {}.VITE_DEPLOY_GHPAGES === "true";
class FT {
  constructor() {
    bi(this, "snappedUrl");
    this.snappedUrl = new URL(window.location.toString());
  }
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(e) {
    throw new Error("Method key() not implemented. " + e);
  }
  getSnappedUrl() {
    return this.snappedUrl;
  }
  getSnappedParamsAsObj() {
    return this.getSnappedParams().reduce(
      (e, n) => {
        const [a, s] = n.split("=");
        return { ...e, [a]: s };
      },
      {}
    );
  }
  getSnappedParams() {
    return this.getSnappedUrl().search.replace("?", "").split("&").filter((e) => e.split("=")[1]);
  }
  setItem(e, n) {
    const a = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    a.set(encodeURIComponent(e), encodeURIComponent(n));
    try {
      window.history.replaceState(null, "", "?" + a.toString());
    } catch {
    }
  }
  getItem(e) {
    const n = this.getSnappedUrl().searchParams.get(e);
    return n !== null ? decodeURIComponent(n) : n;
  }
  removeItem(e) {
    const n = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    n.delete(e);
    try {
      window.history.replaceState(null, "", "?" + n.toString());
    } catch {
    }
  }
  encodeQueryParam(e, n) {
    return `${encodeURIComponent(e)}=${encodeURIComponent(n)}`;
  }
}
const G_ = new FT();
class s5 extends FT {
  getItem(e) {
    const n = this.getSnappedUrl().pathname.split("/"), a = n.findIndex((s) => s === e);
    return n[a + 1];
  }
  setItem(e, n) {
    const a = new URL(window.location.toString()).search, s = `/${e}/${n}${a}`;
    try {
      window.history.replaceState(null, "", s);
    } catch {
    }
  }
}
const l5 = new s5();
class u5 {
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(e) {
    throw new Error("Method key() not implemented. " + e);
  }
  removeItem(e) {
    const n = this.getWriteStorages(e);
    n == null || n.map(
      (a) => a.removeItem(e)
    );
  }
  setItem(e, n) {
    this.setValue(e, n);
  }
  getItem(e) {
    return this.getValue(e);
  }
  get paramKeys() {
    return G_.getSnappedParamsAsObj();
  }
  getValue(e) {
    var s;
    const n = (s = this.correspondingStorages(
      zg.processRules(this.paramKeys)
    )) == null ? void 0 : s.pop(), a = this.storageForKey(e, zg, n);
    return a ? a.getItem(e) : null;
  }
  setValue(e, n) {
    const a = this.getWriteStorages(e);
    a == null || a.map(
      (s) => s.setItem(e, n)
    );
  }
  getWriteStorages(e) {
    const n = this.correspondingStorages(
      Fg.processRules()
    ), a = this.storageForKey(e, Fg);
    return a ? [a] : n;
  }
  storageForKey(e, n, a) {
    var f;
    const s = (f = this.correspondingStorages(
      n.processRulesForKey(e, this.paramKeys)
    )) == null ? void 0 : f.pop();
    return s != null ? s : a;
  }
  correspondingStorages(e) {
    if (e === oo.permalinkAndLocalStorage)
      return [G_, localStorage];
    if (e === oo.localStorage)
      return [localStorage];
    if (e === oo.permalink)
      return [G_];
    if (e === oo.permalinkAsPath)
      return [l5];
  }
}
const Iy = new u5();
function c5(t) {
  return h5(t) || f5(t) || p5(t) || d5(t);
}
const h5 = (t) => Object.keys(t).length === 0, f5 = (t) => {
  const e = Object.keys(t);
  return Object.keys(t).length === 1 && [
    Hd,
    Zd,
    Xd,
    Lg,
    Ou,
    Ng,
    Tf
  ].some((n) => e.indexOf(n) !== -1);
}, p5 = (t) => {
  const e = Object.keys(t), n = (s) => e.indexOf(s) !== -1, a = [
    [Zd, Xd],
    [Tf, Lg],
    [Ou, Lg],
    [Tf, Ou],
    [Tf, Ng],
    [Ou, Ng]
  ];
  return Object.keys(t).length === 2 && a.reduce(
    (s, f) => s || f.every(n),
    !1
  );
}, d5 = (t) => {
  const e = Object.keys(t), n = (o) => e.indexOf(o) !== -1, a = [Hd, Zd, Xd].every(
    n
  ), s = [Tf, Lg, Ou].every(n), f = [Tf, Ng, Ou].every(n);
  return Object.keys(t).length === 3 && (a || s || f);
};
class m5 {
  constructor() {
    bi(this, "intialVersion");
    const e = Iy.paramKeys, n = this.getValue(Z0, Sf);
    this.intialVersion = n ? Math.max(2, Math.min(n, 3)) : c5(e) ? 3 : 2, this.setValue(Z0, 3);
  }
  getInitialVersion() {
    return this.intialVersion;
  }
  mapToEntity(e, n) {
    return n ? n(e) : e;
  }
  mapToStorage(e, n) {
    return n ? n(e) : String(e);
  }
  getValue(e, n) {
    return this.mapToEntity(Iy.getValue(e), n);
  }
  setValue(e, n, a) {
    Iy.setValue(e, this.mapToStorage(n, a));
  }
  removeItem(e) {
    Iy.removeItem(e);
  }
}
const Ir = new m5(), y5 = [
  "line",
  "fill",
  "symbol",
  "fill-extrusion",
  "background",
  "hillshade"
], os = () => ({
  bg_layers: [
    {
      icon_id: "route",
      vector_id: "roadmap",
      simple_style_class: "road",
      medium_style_class: "road",
      expert_style_class: "maputnik",
      id: 556,
      is_default: !0
    },
    {
      icon_id: "topo",
      vector_id: "topomap",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 529
    },
    {
      icon_id: "topo_bw",
      vector_id: "topomap_gray",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 502
    },
    {
      icon_id: "ortho",
      id: 530
    },
    {
      icon_id: "hybrid",
      id: 501
    },
    {
      icon_id: "blank",
      id: 0
    }
  ],
  bg_layer_theme_defaults: {
    tourisme: 502
  },
  simple_styles: {
    road: [
      {
        unlocalized_label: "Light grey",
        hillshade: !1,
        colors: [
          "#ffffff",
          "#ffffff",
          "#d6e0d7",
          "#e1e1e1",
          "#cccccc",
          "#f2f2f2"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Dark grey",
        hillshade: !1,
        colors: [
          "#808080",
          "#808080",
          "#494b4a",
          "#505052",
          "#232426",
          "#454545"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Dark sand",
        hillshade: !1,
        colors: [
          "#9e9375",
          "#9e9375",
          "#6b6249",
          "#403928",
          "#b8aa84",
          "#1a1814"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Kids",
        hillshade: !1,
        colors: [
          "#f9c50d",
          "#ffffff",
          "#839836",
          "#d6d3ce",
          "#2a5ba8",
          "#eeeeee"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Light mauve",
        hillshade: !1,
        colors: [
          "#f3edf5",
          "#f3edf5",
          "#9d7da8",
          "#caa9d1",
          "#613b5c",
          "#e5d3e6"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Light Blue",
        hillshade: !1,
        colors: [
          "#dceaf5",
          "#dceaf5",
          "#5598cf",
          "#81b7e3",
          "#3b576e",
          "#b6cde0"
        ],
        selected: !1
      }
    ]
  },
  medium_default_styles: {
    road: [
      {
        label: "Roads primary",
        color: "#f7f7f7",
        lines: [
          "lu_road_trunk_primary",
          "lu_bridge_major",
          "lu_tunnel_major",
          "lu_road_major_motorway"
        ],
        visible: !0
      },
      {
        label: "Roads secondary",
        color: "#f7f7f7",
        lines: [
          "lu_road_minor",
          "lu_road_secondary_tertiary",
          "lu_bridge_minor",
          "lu_road_path",
          "lu_bridge_path",
          "lu_bridge_railway case",
          "lu_bridge_path case"
        ],
        visible: !0
      },
      {
        label: "Vegetation",
        color: "#B8D293",
        opacity: "1",
        fills: [
          "lu_landcover_wood",
          "lu_landcover_grass",
          "lu_landuse_stadium",
          "lu_landuse_cemetery"
        ],
        visible: !0
      },
      {
        label: "Buildings",
        color: "#D6AA85",
        opacity: "1",
        fillExtrusions: ["lu_building-3d_public", "lu_building-3d"],
        fills: ["lu_building", "lu_building_public"],
        lines: ["lu_bridge_railway", "lu_railway", "lu_tunnel_railway"],
        visible: !0
      },
      {
        label: "Water",
        color: "#94c1e1",
        lines: [
          "lu_waterway",
          "lu_waterway_tunnel",
          "lu_waterway_intermittent"
        ],
        fills: ["lu_water"],
        visible: !0
      },
      {
        label: "Background",
        color: "#e7e7e7",
        backgrounds: ["background"],
        visible: !0
      },
      {
        label: "Hillshade",
        hillshades: ["hillshade"],
        visible: !0
      }
    ],
    topo: [
      {
        label: "Primary Names",
        symbols: [
          "lu_place-label_other",
          "lu_place-label_city",
          "lu_place-label_canton",
          "lu_country-label-other",
          "lu_country-label",
          "place_label_other",
          "place_label_city",
          "country_label-other",
          "country_label"
        ],
        visible: !0
      },
      {
        label: "Secondary Names",
        symbols: [
          "lu_place-label_isolated",
          "lu_place-label_locality_forest",
          "lu_place-label_locality_lieudit"
        ],
        visible: !0
      },
      {
        label: "Transport",
        lines: [
          "lu_tunnel_track-casing",
          "lu_tunnel_major_motorway-casing",
          "lu_tunnel_railway_transit",
          "lu_tunnel_railway",
          "lu_tunnel_railway-hatching",
          "lu_tunnel_path",
          "lu_tunnel_track",
          "lu_tunnel_minor",
          "lu_tunnel_major_motorway",
          "lu_tunnel_secondary_tertiary",
          "lu_tunnel_trunk_primary",
          "lu_road_track-casing",
          "lu_road_minor-casing",
          "lu_road_major_motorway-casing",
          "lu_road_secondary_tertiary-casing",
          "lu_road_trunk_primary-casing",
          "lu_road_pier",
          "lu_road_path",
          "lu_road_track",
          "lu_road_minor",
          "lu_road_major_motorway",
          "lu_road_secondary_tertiary",
          "lu_road_trunk_primary",
          "lu_tram",
          "lu_tram-hatching",
          "lu_railway_transit",
          "lu_railway",
          "lu_railway-hatching",
          "lu_bridge_railway-casing",
          "lu_bridge_track-casing",
          "lu_bridge_path-casing",
          "lu_bridge_minor-casing",
          "lu_bridge_major_motorway-casing",
          "lu_bridge_secondary_tertiary-casing",
          "lu_bridge_trunk_primary-casing",
          "lu_bridge_railway",
          "lu_bridge_path",
          "lu_bridge_track",
          "lu_bridge_minor",
          "lu_bridge_major_motorway",
          "lu_bridge_secondary_tertiary",
          "lu_bridge_trunk_primary",
          "tunnel_track-casing",
          "tunnel_major_motorway-casing",
          "tunnel_railway_transit",
          "tunnel_railway_transit-hatching",
          "tunnel_railway",
          "tunnel_railway-hatching",
          "tunnel_path",
          "tunnel_track",
          "tunnel_minor",
          "tunnel_major_motorway",
          "tunnel_secondary_tertiary",
          "tunnel_trunk_primary",
          "road_track-casing",
          "road_minor-casing",
          "road_major_motorway-casing",
          "road_secondary_tertiary-casing",
          "road_trunk_primary-casing",
          "road_pier",
          "road_path",
          "road_track",
          "road_minor",
          "road_major_motorway",
          "road_secondary_tertiary",
          "road_trunk_primary",
          "railway-transit",
          "railway-transit-hatching",
          "railway",
          "railway-hatching",
          "bridge_railway-casing",
          "bridge_path-casing",
          "bridge_track_casing",
          "bridge_minor-casing",
          "bridge_major_motorway-casing",
          "bridge_secondary_tertiary-casing",
          "bridge_trunk_primary-casing",
          "bridge_railway",
          "bridge_path",
          "bridge_track",
          "bridge_minor",
          "bridge_major_motorway",
          "bridge_secondary_tertiary",
          "bridge_trunk_primary"
        ],
        symbols: [
          "lu_road_major-label",
          "lu_motorway-shield",
          "lu_road-shield"
        ],
        visible: !0
      },
      {
        label: "Vegetation",
        fills: [
          "lu_landuse_stadium",
          "lu_landuse_cemetery",
          "lu_landuse_gras",
          "lu_landuse_park",
          "lu_landuse_park-outline",
          "lu_landuse_vineyard",
          "lu_landuse_orchard",
          "lu_landuse_wood",
          "landcover_grass",
          "landcover_wood"
        ],
        visible: !0
      },
      {
        label: "Electricity",
        fills: ["lu_power_station", "lu_power_pylone"],
        lines: ["lu_power_line", "lu_power_station-outline"],
        symbols: ["lu_power_station-label", "lu_eolienne"],
        visible: !0
      },
      {
        label: "Contours and Height Points",
        lines: [
          "lu_contour-100",
          "lu_contour-50",
          "lu_contour-20",
          "lu_contour-10",
          "lu_contour"
        ],
        symbols: [
          "lu_contour-label-100",
          "lu_contour-label-20",
          "lu_apex-label"
        ],
        visible: !0
      },
      {
        label: "Hillshade",
        hillshades: ["lu_hillshade"],
        visible: !0
      }
    ]
  },
  http_bg_server: "wmts{1-2}",
  https_bg_server: "wmts{3-4}",
  bg_wmts_server_path: "mapproxy_4_v3/wmts/{Layer}",
  bg_wmts_tile_template: "{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}",
  bg_layer_projection: "EPSG:3857",
  olcs_extent: [5.31, 49.38, 6.64, 50.21],
  olcs_extent_projection: "EPSG:3857",
  bg_layer_resolutions: [
    156543.033928,
    78271.516964,
    39135.758482,
    19567.879241,
    9783.9396205,
    4891.96981025,
    2445.98490513,
    1222.99245256,
    611.496226281,
    305.748113141,
    152.87405657,
    76.4370282852,
    38.2185141426,
    19.1092570713,
    9.55462853565,
    4.77731426782,
    2.38865713391,
    1.19432856696,
    0.597164283478,
    0.298582141739,
    0.1492910708695,
    0.07464553543475
  ],
  bg_matrix_ids: [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "20",
    "21"
  ]
});
function Ff() {
  function t(V) {
    const Z = new URLSearchParams(document.location.search), X = Z.get("embeddedserver"), Y = Z.get("embeddedserverprotocol") || "http";
    return (X ? `${Y}://${X}` : "https://vectortiles.geoportail.lu") + `/styles/${V}/style.json`;
  }
  function e(V) {
    return `https://vectortiles.geoportail.lu/styles/${V}/{z}/{x}/{y}.png`;
  }
  function n(V) {
    return /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/gi.test(V);
  }
  const a = Ws();
  function s(V, Z) {
    if (V == null)
      return;
    const X = /* @__PURE__ */ new Map();
    a.bgVectorSources.forEach((Y, de) => {
      if (de === V.id) {
        const ye = { ...Y, xyz_custom: Z };
        X.set(de, ye);
      } else
        X.set(de, Y);
    }), a.setBgVectorSources(X);
  }
  function f(V, Z, X = !1) {
    const Y = "", de = t(Z), ye = e(Z), Ie = {
      label: V,
      defaultMapBoxStyle: de,
      defaultMapBoxStyleXYZ: ye,
      xyz: ye,
      xyz_custom: Y,
      style: de
    }, Be = new URLSearchParams(window.location.search).get("serial"), De = new URLSearchParams(window.location.search).get(
      "serialLayer"
    );
    if (Be)
      n(Be) && console.log(De);
    else if (!X)
      return Promise.resolve(Ie);
    return Promise.resolve(Ie);
  }
  function o(V) {
    const Z = os().medium_default_styles.road;
    if (V) {
      V.colors.forEach((Y, de) => {
        Z[de].color = Y;
      });
      const X = Z.findIndex(
        (Y) => Y.label === "Hillshade"
      );
      Z[X].visible = V.hillshade;
    }
    return Z;
  }
  function m(V, Z, X) {
    if (!V || !Z.get(V.id))
      return;
    const Y = JSON.parse(
      JSON.stringify(Z.get(V.id))
    );
    if (!!Y && !(!Y || !Y.layers))
      return X && X.forEach((de) => {
        Y == null || Y.layers.forEach((ye, Ie) => {
          for (const Be of y5)
            if ((de[`${Be}s`] || []).includes(ye.id)) {
              const Re = Object.assign(
                {},
                Y.layers[Ie].paint
              );
              de.color && (Re[`${Be}-color`] = de.color, Re[`${Be}-opacity`] = 1, Y.layers[Ie].paint = Re), Y.layers[Ie].layout = Object.assign(
                {},
                Y.layers[Ie].layout,
                { visibility: de.visible ? "visible" : "none" }
              );
            }
        });
      }), Y;
  }
  function g(V, Z) {
    if (V === null)
      return Promise.resolve();
    {
      const X = `${Z.get("delete")}?id=${V}`;
      return fetch(X).catch(() => "");
    }
  }
  function b(V, Z, X) {
    return g(Z, X).then(() => {
      const Y = new FormData(), de = JSON.stringify(V), ye = new Blob([de], { type: "application/json" });
      Y.append("style", ye, "style.json");
      const Ie = {
        method: "POST",
        body: Y
      };
      return fetch(X.get("upload") || "", Ie).then((Be) => Be.json()).then((Be) => Be.id);
    });
  }
  function T(V, Z) {
    if (!Z)
      return;
    const X = V.maplibreMap;
    !X || (X.loaded() ? X.setStyle(Z) : new Promise((Y) => X.once("data", Y)).then(
      () => X.setStyle(Z)
    ));
  }
  function M(V) {
    const Z = os().bg_layers.find(
      (X) => X.id == (V == null ? void 0 : V.id)
    );
    return Z == null ? void 0 : Z.vector_id;
  }
  function I(V) {
    const Z = os().bg_layers.find(
      (X) => X.id == (V == null ? void 0 : V.id)
    );
    return (Z == null ? void 0 : Z.vector_id) !== void 0;
  }
  function A(V) {
    const Z = os().bg_layers.find(
      (X) => X.id == (V == null ? void 0 : V.id)
    );
    return {
      isEditable: (Z == null ? void 0 : Z.vector_id) !== void 0,
      hasSimpleStyle: (Z == null ? void 0 : Z.simple_style_class) !== void 0,
      hasAdvancedStyle: (Z == null ? void 0 : Z.medium_style_class) !== void 0,
      hasExpertStyle: (Z == null ? void 0 : Z.expert_style_class) !== void 0
    };
  }
  function z(V, Z) {
    return Z.map(
      (X) => Object.assign(X, {
        selected: X.colors.every(
          (Y, de) => {
            var ye;
            return ((ye = V[de]) == null ? void 0 : ye.color) === Y;
          }
        )
      })
    );
  }
  return {
    getDefaultMapBoxStyleUrl: t,
    getDefaultMapBoxStyleXYZ: e,
    setConfigForLayer: f,
    getRoadStyleFromSimpleStyle: o,
    applyDefaultStyle: m,
    applyConsolidatedStyle: T,
    getVectorId: M,
    setCustomStyleSerial: s,
    unregisterStyle: g,
    registerStyle: b,
    checkSelection: z,
    isLayerStyleEditable: I,
    getStyleCapabilitiesFromLayer: A
  };
}
const Ws = Qc(
  "style",
  () => {
    const t = Ff(), e = Fn(), n = Fn(/* @__PURE__ */ new Map()), a = Fn(
      /* @__PURE__ */ new Map()
    ), s = Fn(!1), f = Fn(null), o = Fn(), m = Fn(
      /* @__PURE__ */ new Map([
        ["get", "/getvtstyle"],
        ["upload", "/uploadvtstyle"],
        ["delete", "/deletevtstyle"]
      ])
    ), g = [];
    os().bg_layers.forEach((X) => {
      if (X.vector_id) {
        const Y = t.setConfigForLayer(
          X.icon_id,
          X.vector_id
        );
        g.push(
          Y.then((de) => ({ id: X.id, config: de }))
        );
      }
    }), Promise.all(g).then((X) => {
      const Y = /* @__PURE__ */ new Map();
      X.forEach((de) => Y.set(de.id, de.config)), n.value = Y;
    });
    function b(X, Y) {
      m.value.set(X, Y);
    }
    function T(X) {
      n.value = X;
    }
    function M(X) {
      const Y = /* @__PURE__ */ new Map();
      a.value.forEach((de, ye) => {
        ye !== X && Y.set(ye, de);
      }), a.value = Y;
    }
    function I(X, Y) {
      const de = /* @__PURE__ */ new Map();
      a.value.forEach(
        (ye, Ie) => de.set(Ie, ye)
      ), de.set(X, Y), a.value = de;
    }
    function A(X) {
      e.value = t.getRoadStyleFromSimpleStyle(X), V();
    }
    function z(X) {
      e.value = X, V();
    }
    function V() {
      s.value = !1;
    }
    function Z() {
      s.value = !0;
    }
    return {
      bgStyle: e,
      bgVectorSources: n,
      bgVectorBaseStyles: a,
      isExpertStyleActive: s,
      appliedStyle: o,
      removeBaseStyle: M,
      setBaseStyle: I,
      setBgVectorSources: T,
      setRegisterUrl: b,
      setSimpleStyle: A,
      setStyle: z,
      disableExpertStyle: V,
      enableExpertStyle: Z,
      styleSerial: f,
      registerUrls: m
    };
  },
  {}
);
function g5(t, {
  i18next: e,
  rerenderOn: n = ["languageChanged", "loaded", "added", "removed"]
}) {
  const a = e.t.bind(e), s = Hr(new Date()), f = () => s.value = new Date(), o = () => s.value;
  n.forEach((T) => {
    var M;
    switch (T) {
      case "added":
      case "removed":
        (M = e.store) == null || M.on(T, f);
        break;
      default:
        e.on(T, f);
        break;
    }
  }), t.component("i18next", v5), t.mixin({
    beforeCreate() {
      var T, M;
      const I = this.$options;
      if (!I.__i18n && !I.i18nOptions) {
        this.__translate = void 0;
        return;
      }
      const A = this.$options.name, z = (Math.random() * 10 ** 8 | 0).toString(), V = [A, z].filter((Ie) => !!Ie).join("-");
      this.__bundles = [];
      const Z = (Ie) => {
        Object.entries(Ie).forEach(([Be, De]) => {
          e.addResourceBundle(Be, V, De, !0, !1), this.__bundles.push([Be, V]);
        });
      };
      (T = I.__i18n) == null || T.forEach((Ie) => {
        Z(JSON.parse(Ie));
      });
      let { lng: X, ns: Y, keyPrefix: de } = b(I, Z);
      (M = this.__bundles) != null && M.length && (Y = [V].concat(Y != null ? Y : []));
      const ye = m(X, Y);
      this.__translate = (Ie, Be) => !de || g(Ie) ? ye(Ie, Be) : ye(de + "." + Ie, Be);
    },
    unmounted() {
      var T;
      (T = this.__bundles) == null || T.forEach(([M, I]) => e.removeResourceBundle(M, I));
    }
  }), t.config.globalProperties.$t = function(T, M) {
    var I;
    return o(), e.isInitialized ? ((I = this == null ? void 0 : this.__translate) != null ? I : a)(T, M) : T;
  }, t.config.globalProperties.$i18next = new Proxy(e, {
    get(T, M) {
      return o(), Reflect.get(T, M);
    }
  });
  function m(T, M) {
    return T ? e.getFixedT(T, M) : M ? e.getFixedT(null, M) : a;
  }
  function g(T) {
    const M = e.options.nsSeparator;
    return typeof M == "string" && T.includes(M);
  }
  function b(T, M) {
    let I, A, z;
    if (T.i18nOptions) {
      let V, Z;
      ({
        lng: I,
        namespaces: Z = e.options.defaultNS,
        keyPrefix: z,
        messages: V
      } = T.i18nOptions), V && M(V), A = typeof Z == "string" ? [Z] : Z, A && e.loadNamespaces(A);
    }
    return { lng: I, ns: A, keyPrefix: z };
  }
}
function An() {
  const t = yv();
  if (!t)
    throw new Error("i18next-vue: No Vue instance in context. Make sure to register the i18next-vue plugin using app.use(...).");
  const e = t.appContext.config.globalProperties;
  return {
    i18next: e.$i18next,
    t: e.$t.bind(t.proxy)
  };
}
var o2 = new RegExp("{\\s*([a-z0-9\\-]+)\\s*}", "gi"), v5 = ur({
  props: {
    translation: {
      type: String,
      required: !0
    }
  },
  setup(t, { slots: e }) {
    return () => {
      const n = t.translation, a = [];
      let s, f = 0;
      for (; (s = o2.exec(n)) !== null; ) {
        a.push(n.substring(f, s.index));
        const o = e[s[1]];
        o ? a.push(...o()) : a.push(s[0]), f = o2.lastIndex;
      }
      return a.push(n.substring(f)), a;
    };
  }
});
class eh extends Error {
}
class _5 extends eh {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class x5 extends eh {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class b5 extends eh {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class rd extends eh {
}
class BT extends eh {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class Pa extends eh {
}
class fu extends eh {
  constructor() {
    super("Zone is an abstract class");
  }
}
const Ot = "numeric", hs = "short", ga = "long", Bg = {
  year: Ot,
  month: Ot,
  day: Ot
}, VT = {
  year: Ot,
  month: hs,
  day: Ot
}, w5 = {
  year: Ot,
  month: hs,
  day: Ot,
  weekday: hs
}, UT = {
  year: Ot,
  month: ga,
  day: Ot
}, jT = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga
}, GT = {
  hour: Ot,
  minute: Ot
}, qT = {
  hour: Ot,
  minute: Ot,
  second: Ot
}, $T = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: hs
}, WT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: ga
}, HT = {
  hour: Ot,
  minute: Ot,
  hourCycle: "h23"
}, ZT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23"
}, XT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23",
  timeZoneName: hs
}, KT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23",
  timeZoneName: ga
}, YT = {
  year: Ot,
  month: Ot,
  day: Ot,
  hour: Ot,
  minute: Ot
}, JT = {
  year: Ot,
  month: Ot,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot
}, QT = {
  year: Ot,
  month: hs,
  day: Ot,
  hour: Ot,
  minute: Ot
}, eM = {
  year: Ot,
  month: hs,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot
}, E5 = {
  year: Ot,
  month: hs,
  day: Ot,
  weekday: hs,
  hour: Ot,
  minute: Ot
}, tM = {
  year: Ot,
  month: ga,
  day: Ot,
  hour: Ot,
  minute: Ot,
  timeZoneName: hs
}, rM = {
  year: Ot,
  month: ga,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: hs
}, nM = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga,
  hour: Ot,
  minute: Ot,
  timeZoneName: ga
}, iM = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga,
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: ga
};
class Kd {
  get type() {
    throw new fu();
  }
  get name() {
    throw new fu();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new fu();
  }
  offsetName(e, n) {
    throw new fu();
  }
  formatOffset(e, n) {
    throw new fu();
  }
  offset(e) {
    throw new fu();
  }
  equals(e) {
    throw new fu();
  }
  get isValid() {
    throw new fu();
  }
}
let q_ = null;
class Ev extends Kd {
  static get instance() {
    return q_ === null && (q_ = new Ev()), q_;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: n, locale: a }) {
    return aM(e, n, a);
  }
  formatOffset(e, n) {
    return gd(this.offset(e), n);
  }
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  equals(e) {
    return e.type === "system";
  }
  get isValid() {
    return !0;
  }
}
let ag = {};
function S5(t) {
  return ag[t] || (ag[t] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: t,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), ag[t];
}
const T5 = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function M5(t, e) {
  const n = t.format(e).replace(/\u200E/g, ""), a = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n), [, s, f, o, m, g, b, T] = a;
  return [o, s, f, m, g, b, T];
}
function I5(t, e) {
  const n = t.formatToParts(e), a = [];
  for (let s = 0; s < n.length; s++) {
    const { type: f, value: o } = n[s], m = T5[f];
    f === "era" ? a[m] = o : Wr(m) || (a[m] = parseInt(o, 10));
  }
  return a;
}
let Oy = {};
class Bl extends Kd {
  static create(e) {
    return Oy[e] || (Oy[e] = new Bl(e)), Oy[e];
  }
  static resetCache() {
    Oy = {}, ag = {};
  }
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  static isValidZone(e) {
    if (!e)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = Bl.isValidZone(e);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: n, locale: a }) {
    return aM(e, n, a, this.name);
  }
  formatOffset(e, n) {
    return gd(this.offset(e), n);
  }
  offset(e) {
    const n = new Date(e);
    if (isNaN(n))
      return NaN;
    const a = S5(this.name);
    let [s, f, o, m, g, b, T] = a.formatToParts ? I5(a, n) : M5(a, n);
    m === "BC" && (s = -Math.abs(s) + 1);
    const I = Tv({
      year: s,
      month: f,
      day: o,
      hour: g === 24 ? 0 : g,
      minute: b,
      second: T,
      millisecond: 0
    });
    let A = +n;
    const z = A % 1e3;
    return A -= z >= 0 ? z : 1e3 + z, (I - A) / (60 * 1e3);
  }
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
}
let a2 = {};
function O5(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let a = a2[n];
  return a || (a = new Intl.ListFormat(t, e), a2[n] = a), a;
}
let Y0 = {};
function J0(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let a = Y0[n];
  return a || (a = new Intl.DateTimeFormat(t, e), Y0[n] = a), a;
}
let Q0 = {};
function C5(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let a = Q0[n];
  return a || (a = new Intl.NumberFormat(t, e), Q0[n] = a), a;
}
let e1 = {};
function A5(t, e = {}) {
  const { base: n, ...a } = e, s = JSON.stringify([t, a]);
  let f = e1[s];
  return f || (f = new Intl.RelativeTimeFormat(t, e), e1[s] = f), f;
}
let nd = null;
function P5() {
  return nd || (nd = new Intl.DateTimeFormat().resolvedOptions().locale, nd);
}
function k5(t) {
  const e = t.indexOf("-x-");
  e !== -1 && (t = t.substring(0, e));
  const n = t.indexOf("-u-");
  if (n === -1)
    return [t];
  {
    let a, s;
    try {
      a = J0(t).resolvedOptions(), s = t;
    } catch {
      const g = t.substring(0, n);
      a = J0(g).resolvedOptions(), s = g;
    }
    const { numberingSystem: f, calendar: o } = a;
    return [s, f, o];
  }
}
function L5(t, e, n) {
  return (n || e) && (t.includes("-u-") || (t += "-u"), n && (t += `-ca-${n}`), e && (t += `-nu-${e}`)), t;
}
function D5(t) {
  const e = [];
  for (let n = 1; n <= 12; n++) {
    const a = xr.utc(2009, n, 1);
    e.push(t(a));
  }
  return e;
}
function N5(t) {
  const e = [];
  for (let n = 1; n <= 7; n++) {
    const a = xr.utc(2016, 11, 13 + n);
    e.push(t(a));
  }
  return e;
}
function Cy(t, e, n, a) {
  const s = t.listingMode();
  return s === "error" ? null : s === "en" ? n(e) : a(e);
}
function R5(t) {
  return t.numberingSystem && t.numberingSystem !== "latn" ? !1 : t.numberingSystem === "latn" || !t.locale || t.locale.startsWith("en") || new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem === "latn";
}
class z5 {
  constructor(e, n, a) {
    this.padTo = a.padTo || 0, this.floor = a.floor || !1;
    const { padTo: s, floor: f, ...o } = a;
    if (!n || Object.keys(o).length > 0) {
      const m = { useGrouping: !1, ...a };
      a.padTo > 0 && (m.minimumIntegerDigits = a.padTo), this.inf = C5(e, m);
    }
  }
  format(e) {
    if (this.inf) {
      const n = this.floor ? Math.floor(e) : e;
      return this.inf.format(n);
    } else {
      const n = this.floor ? Math.floor(e) : q1(e, 3);
      return Ci(n, this.padTo);
    }
  }
}
class F5 {
  constructor(e, n, a) {
    this.opts = a, this.originalZone = void 0;
    let s;
    if (this.opts.timeZone)
      this.dt = e;
    else if (e.zone.type === "fixed") {
      const o = -1 * (e.offset / 60), m = o >= 0 ? `Etc/GMT+${o}` : `Etc/GMT${o}`;
      e.offset !== 0 && Bl.create(m).valid ? (s = m, this.dt = e) : (s = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    } else
      e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, s = e.zone.name) : (s = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    const f = { ...this.opts };
    f.timeZone = f.timeZone || s, this.dtf = J0(n, f);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? e.map((n) => {
      if (n.type === "timeZoneName") {
        const a = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...n,
          value: a
        };
      } else
        return n;
    }) : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class B5 {
  constructor(e, n, a) {
    this.opts = { style: "long", ...a }, !n && oM() && (this.rtf = A5(e, a));
  }
  format(e, n) {
    return this.rtf ? this.rtf.format(e, n) : nz(n, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, n) {
    return this.rtf ? this.rtf.formatToParts(e, n) : [];
  }
}
class zn {
  static fromOpts(e) {
    return zn.create(e.locale, e.numberingSystem, e.outputCalendar, e.defaultToEN);
  }
  static create(e, n, a, s = !1) {
    const f = e || Oi.defaultLocale, o = f || (s ? "en-US" : P5()), m = n || Oi.defaultNumberingSystem, g = a || Oi.defaultOutputCalendar;
    return new zn(o, m, g, f);
  }
  static resetCache() {
    nd = null, Y0 = {}, Q0 = {}, e1 = {};
  }
  static fromObject({ locale: e, numberingSystem: n, outputCalendar: a } = {}) {
    return zn.create(e, n, a);
  }
  constructor(e, n, a, s) {
    const [f, o, m] = k5(e);
    this.locale = f, this.numberingSystem = n || o || null, this.outputCalendar = a || m || null, this.intl = L5(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = s, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = R5(this)), this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish(), n = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && n ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : zn.create(
      e.locale || this.specifiedLocale,
      e.numberingSystem || this.numberingSystem,
      e.outputCalendar || this.outputCalendar,
      e.defaultToEN || !1
    );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, n = !1) {
    return Cy(this, e, uM, () => {
      const a = n ? { month: e, day: "numeric" } : { month: e }, s = n ? "format" : "standalone";
      return this.monthsCache[s][e] || (this.monthsCache[s][e] = D5((f) => this.extract(f, a, "month"))), this.monthsCache[s][e];
    });
  }
  weekdays(e, n = !1) {
    return Cy(this, e, fM, () => {
      const a = n ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, s = n ? "format" : "standalone";
      return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = N5(
        (f) => this.extract(f, a, "weekday")
      )), this.weekdaysCache[s][e];
    });
  }
  meridiems() {
    return Cy(
      this,
      void 0,
      () => pM,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [xr.utc(2016, 11, 13, 9), xr.utc(2016, 11, 13, 19)].map(
            (n) => this.extract(n, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return Cy(this, e, dM, () => {
      const n = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [xr.utc(-40, 1, 1), xr.utc(2017, 1, 1)].map(
        (a) => this.extract(a, n, "era")
      )), this.eraCache[e];
    });
  }
  extract(e, n, a) {
    const s = this.dtFormatter(e, n), f = s.formatToParts(), o = f.find((m) => m.type.toLowerCase() === a);
    return o ? o.value : null;
  }
  numberFormatter(e = {}) {
    return new z5(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, n = {}) {
    return new F5(e, this.intl, n);
  }
  relFormatter(e = {}) {
    return new B5(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return O5(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
}
let $_ = null;
class Fo extends Kd {
  static get utcInstance() {
    return $_ === null && ($_ = new Fo(0)), $_;
  }
  static instance(e) {
    return e === 0 ? Fo.utcInstance : new Fo(e);
  }
  static parseSpecifier(e) {
    if (e) {
      const n = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (n)
        return new Fo(Mv(n[1], n[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${gd(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${gd(-this.fixed, "narrow")}`;
  }
  offsetName() {
    return this.name;
  }
  formatOffset(e, n) {
    return gd(this.fixed, n);
  }
  get isUniversal() {
    return !0;
  }
  offset() {
    return this.fixed;
  }
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  get isValid() {
    return !0;
  }
}
class V5 extends Kd {
  constructor(e) {
    super(), this.zoneName = e;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return !1;
  }
  get isValid() {
    return !1;
  }
}
function wu(t, e) {
  if (Wr(t) || t === null)
    return e;
  if (t instanceof Kd)
    return t;
  if (U5(t)) {
    const n = t.toLowerCase();
    return n === "default" ? e : n === "local" || n === "system" ? Ev.instance : n === "utc" || n === "gmt" ? Fo.utcInstance : Fo.parseSpecifier(n) || Bl.create(t);
  } else
    return jc(t) ? Fo.instance(t) : typeof t == "object" && "offset" in t && typeof t.offset == "function" ? t : new V5(t);
}
let s2 = () => Date.now(), l2 = "system", u2 = null, c2 = null, h2 = null, f2 = 60, p2;
class Oi {
  static get now() {
    return s2;
  }
  static set now(e) {
    s2 = e;
  }
  static set defaultZone(e) {
    l2 = e;
  }
  static get defaultZone() {
    return wu(l2, Ev.instance);
  }
  static get defaultLocale() {
    return u2;
  }
  static set defaultLocale(e) {
    u2 = e;
  }
  static get defaultNumberingSystem() {
    return c2;
  }
  static set defaultNumberingSystem(e) {
    c2 = e;
  }
  static get defaultOutputCalendar() {
    return h2;
  }
  static set defaultOutputCalendar(e) {
    h2 = e;
  }
  static get twoDigitCutoffYear() {
    return f2;
  }
  static set twoDigitCutoffYear(e) {
    f2 = e % 100;
  }
  static get throwOnInvalid() {
    return p2;
  }
  static set throwOnInvalid(e) {
    p2 = e;
  }
  static resetCaches() {
    zn.resetCache(), Bl.resetCache();
  }
}
function Wr(t) {
  return typeof t > "u";
}
function jc(t) {
  return typeof t == "number";
}
function Sv(t) {
  return typeof t == "number" && t % 1 === 0;
}
function U5(t) {
  return typeof t == "string";
}
function j5(t) {
  return Object.prototype.toString.call(t) === "[object Date]";
}
function oM() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function G5(t) {
  return Array.isArray(t) ? t : [t];
}
function d2(t, e, n) {
  if (t.length !== 0)
    return t.reduce((a, s) => {
      const f = [e(s), s];
      return a && n(a[0], f[0]) === a[0] ? a : f;
    }, null)[1];
}
function q5(t, e) {
  return e.reduce((n, a) => (n[a] = t[a], n), {});
}
function Df(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function Ll(t, e, n) {
  return Sv(t) && t >= e && t <= n;
}
function $5(t, e) {
  return t - e * Math.floor(t / e);
}
function Ci(t, e = 2) {
  const n = t < 0;
  let a;
  return n ? a = "-" + ("" + -t).padStart(e, "0") : a = ("" + t).padStart(e, "0"), a;
}
function vu(t) {
  if (!(Wr(t) || t === null || t === ""))
    return parseInt(t, 10);
}
function Ec(t) {
  if (!(Wr(t) || t === null || t === ""))
    return parseFloat(t);
}
function G1(t) {
  if (!(Wr(t) || t === null || t === "")) {
    const e = parseFloat("0." + t) * 1e3;
    return Math.floor(e);
  }
}
function W5(t) {
  return t > 0 ? Math.floor(t) : Math.ceil(t);
}
function q1(t, e, n = !1) {
  const a = 10 ** e;
  return (n ? Math.trunc : Math.round)(t * a) / a;
}
function Yd(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function yd(t) {
  return Yd(t) ? 366 : 365;
}
function Vg(t, e) {
  const n = $5(e - 1, 12) + 1, a = t + (e - n) / 12;
  return n === 2 ? Yd(a) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1];
}
function Tv(t) {
  let e = Date.UTC(
    t.year,
    t.month - 1,
    t.day,
    t.hour,
    t.minute,
    t.second,
    t.millisecond
  );
  return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(t.year, t.month - 1, t.day)), +e;
}
function Ug(t) {
  const e = (t + Math.floor(t / 4) - Math.floor(t / 100) + Math.floor(t / 400)) % 7, n = t - 1, a = (n + Math.floor(n / 4) - Math.floor(n / 100) + Math.floor(n / 400)) % 7;
  return e === 4 || a === 3 ? 53 : 52;
}
function t1(t) {
  return t > 99 ? t : t > Oi.twoDigitCutoffYear ? 1900 + t : 2e3 + t;
}
function aM(t, e, n, a = null) {
  const s = new Date(t), f = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  a && (f.timeZone = a);
  const o = { timeZoneName: e, ...f }, m = new Intl.DateTimeFormat(n, o).formatToParts(s).find((g) => g.type.toLowerCase() === "timezonename");
  return m ? m.value : null;
}
function Mv(t, e) {
  let n = parseInt(t, 10);
  Number.isNaN(n) && (n = 0);
  const a = parseInt(e, 10) || 0, s = n < 0 || Object.is(n, -0) ? -a : a;
  return n * 60 + s;
}
function sM(t) {
  const e = Number(t);
  if (typeof t == "boolean" || t === "" || Number.isNaN(e))
    throw new Pa(`Invalid unit value ${t}`);
  return e;
}
function jg(t, e) {
  const n = {};
  for (const a in t)
    if (Df(t, a)) {
      const s = t[a];
      if (s == null)
        continue;
      n[e(a)] = sM(s);
    }
  return n;
}
function gd(t, e) {
  const n = Math.trunc(Math.abs(t / 60)), a = Math.trunc(Math.abs(t % 60)), s = t >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${s}${Ci(n, 2)}:${Ci(a, 2)}`;
    case "narrow":
      return `${s}${n}${a > 0 ? `:${a}` : ""}`;
    case "techie":
      return `${s}${Ci(n, 2)}${Ci(a, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function Iv(t) {
  return q5(t, ["hour", "minute", "second", "millisecond"]);
}
const H5 = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], lM = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], Z5 = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function uM(t) {
  switch (t) {
    case "narrow":
      return [...Z5];
    case "short":
      return [...lM];
    case "long":
      return [...H5];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const cM = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], hM = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], X5 = ["M", "T", "W", "T", "F", "S", "S"];
function fM(t) {
  switch (t) {
    case "narrow":
      return [...X5];
    case "short":
      return [...hM];
    case "long":
      return [...cM];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const pM = ["AM", "PM"], K5 = ["Before Christ", "Anno Domini"], Y5 = ["BC", "AD"], J5 = ["B", "A"];
function dM(t) {
  switch (t) {
    case "narrow":
      return [...J5];
    case "short":
      return [...Y5];
    case "long":
      return [...K5];
    default:
      return null;
  }
}
function Q5(t) {
  return pM[t.hour < 12 ? 0 : 1];
}
function ez(t, e) {
  return fM(e)[t.weekday - 1];
}
function tz(t, e) {
  return uM(e)[t.month - 1];
}
function rz(t, e) {
  return dM(e)[t.year < 0 ? 0 : 1];
}
function nz(t, e, n = "always", a = !1) {
  const s = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, f = ["hours", "minutes", "seconds"].indexOf(t) === -1;
  if (n === "auto" && f) {
    const M = t === "days";
    switch (e) {
      case 1:
        return M ? "tomorrow" : `next ${s[t][0]}`;
      case -1:
        return M ? "yesterday" : `last ${s[t][0]}`;
      case 0:
        return M ? "today" : `this ${s[t][0]}`;
    }
  }
  const o = Object.is(e, -0) || e < 0, m = Math.abs(e), g = m === 1, b = s[t], T = a ? g ? b[1] : b[2] || b[1] : g ? s[t][0] : t;
  return o ? `${m} ${T} ago` : `in ${m} ${T}`;
}
function m2(t, e) {
  let n = "";
  for (const a of t)
    a.literal ? n += a.val : n += e(a.val);
  return n;
}
const iz = {
  D: Bg,
  DD: VT,
  DDD: UT,
  DDDD: jT,
  t: GT,
  tt: qT,
  ttt: $T,
  tttt: WT,
  T: HT,
  TT: ZT,
  TTT: XT,
  TTTT: KT,
  f: YT,
  ff: QT,
  fff: tM,
  ffff: nM,
  F: JT,
  FF: eM,
  FFF: rM,
  FFFF: iM
};
class bo {
  static create(e, n = {}) {
    return new bo(e, n);
  }
  static parseFormat(e) {
    let n = null, a = "", s = !1;
    const f = [];
    for (let o = 0; o < e.length; o++) {
      const m = e.charAt(o);
      m === "'" ? (a.length > 0 && f.push({ literal: s || /^\s+$/.test(a), val: a }), n = null, a = "", s = !s) : s || m === n ? a += m : (a.length > 0 && f.push({ literal: /^\s+$/.test(a), val: a }), a = m, n = m);
    }
    return a.length > 0 && f.push({ literal: s || /^\s+$/.test(a), val: a }), f;
  }
  static macroTokenToFormatOpts(e) {
    return iz[e];
  }
  constructor(e, n) {
    this.opts = n, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, n) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...n }).format();
  }
  dtFormatter(e, n = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...n });
  }
  formatDateTime(e, n) {
    return this.dtFormatter(e, n).format();
  }
  formatDateTimeParts(e, n) {
    return this.dtFormatter(e, n).formatToParts();
  }
  formatInterval(e, n) {
    return this.dtFormatter(e.start, n).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, n) {
    return this.dtFormatter(e, n).resolvedOptions();
  }
  num(e, n = 0) {
    if (this.opts.forceSimple)
      return Ci(e, n);
    const a = { ...this.opts };
    return n > 0 && (a.padTo = n), this.loc.numberFormatter(a).format(e);
  }
  formatDateTimeFromString(e, n) {
    const a = this.loc.listingMode() === "en", s = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", f = (A, z) => this.loc.extract(e, A, z), o = (A) => e.isOffsetFixed && e.offset === 0 && A.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, A.format) : "", m = () => a ? Q5(e) : f({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), g = (A, z) => a ? tz(e, A) : f(z ? { month: A } : { month: A, day: "numeric" }, "month"), b = (A, z) => a ? ez(e, A) : f(
      z ? { weekday: A } : { weekday: A, month: "long", day: "numeric" },
      "weekday"
    ), T = (A) => {
      const z = bo.macroTokenToFormatOpts(A);
      return z ? this.formatWithSystemDefault(e, z) : A;
    }, M = (A) => a ? rz(e, A) : f({ era: A }, "era"), I = (A) => {
      switch (A) {
        case "S":
          return this.num(e.millisecond);
        case "u":
        case "SSS":
          return this.num(e.millisecond, 3);
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        case "Z":
          return o({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return o({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return o({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return e.zoneName;
        case "a":
          return m();
        case "d":
          return s ? f({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return s ? f({ day: "2-digit" }, "day") : this.num(e.day, 2);
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return b("short", !0);
        case "cccc":
          return b("long", !0);
        case "ccccc":
          return b("narrow", !0);
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return b("short", !1);
        case "EEEE":
          return b("long", !1);
        case "EEEEE":
          return b("narrow", !1);
        case "L":
          return s ? f({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return s ? f({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return g("short", !0);
        case "LLLL":
          return g("long", !0);
        case "LLLLL":
          return g("narrow", !0);
        case "M":
          return s ? f({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return s ? f({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return g("short", !1);
        case "MMMM":
          return g("long", !1);
        case "MMMMM":
          return g("narrow", !1);
        case "y":
          return s ? f({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return s ? f({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return s ? f({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return s ? f({ year: "numeric" }, "year") : this.num(e.year, 6);
        case "G":
          return M("short");
        case "GG":
          return M("long");
        case "GGGGG":
          return M("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return T(A);
      }
    };
    return m2(bo.parseFormat(n), I);
  }
  formatDurationFromString(e, n) {
    const a = (g) => {
      switch (g[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, s = (g) => (b) => {
      const T = a(b);
      return T ? this.num(g.get(T), b.length) : b;
    }, f = bo.parseFormat(n), o = f.reduce(
      (g, { literal: b, val: T }) => b ? g : g.concat(T),
      []
    ), m = e.shiftTo(...o.map(a).filter((g) => g));
    return m2(f, s(m));
  }
}
class as {
  constructor(e, n) {
    this.reason = e, this.explanation = n;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const mM = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function Bf(...t) {
  const e = t.reduce((n, a) => n + a.source, "");
  return RegExp(`^${e}$`);
}
function Vf(...t) {
  return (e) => t.reduce(
    ([n, a, s], f) => {
      const [o, m, g] = f(e, s);
      return [{ ...n, ...o }, m || a, g];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function Uf(t, ...e) {
  if (t == null)
    return [null, null];
  for (const [n, a] of e) {
    const s = n.exec(t);
    if (s)
      return a(s);
  }
  return [null, null];
}
function yM(...t) {
  return (e, n) => {
    const a = {};
    let s;
    for (s = 0; s < t.length; s++)
      a[t[s]] = vu(e[n + s]);
    return [a, null, n + s];
  };
}
const gM = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, oz = `(?:${gM.source}?(?:\\[(${mM.source})\\])?)?`, $1 = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, vM = RegExp(`${$1.source}${oz}`), W1 = RegExp(`(?:T${vM.source})?`), az = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, sz = /(\d{4})-?W(\d\d)(?:-?(\d))?/, lz = /(\d{4})-?(\d{3})/, uz = yM("weekYear", "weekNumber", "weekDay"), cz = yM("year", "ordinal"), hz = /(\d{4})-(\d\d)-(\d\d)/, _M = RegExp(
  `${$1.source} ?(?:${gM.source}|(${mM.source}))?`
), fz = RegExp(`(?: ${_M.source})?`);
function Mf(t, e, n) {
  const a = t[e];
  return Wr(a) ? n : vu(a);
}
function pz(t, e) {
  return [{
    year: Mf(t, e),
    month: Mf(t, e + 1, 1),
    day: Mf(t, e + 2, 1)
  }, null, e + 3];
}
function jf(t, e) {
  return [{
    hours: Mf(t, e, 0),
    minutes: Mf(t, e + 1, 0),
    seconds: Mf(t, e + 2, 0),
    milliseconds: G1(t[e + 3])
  }, null, e + 4];
}
function Jd(t, e) {
  const n = !t[e] && !t[e + 1], a = Mv(t[e + 1], t[e + 2]), s = n ? null : Fo.instance(a);
  return [{}, s, e + 3];
}
function Qd(t, e) {
  const n = t[e] ? Bl.create(t[e]) : null;
  return [{}, n, e + 1];
}
const dz = RegExp(`^T?${$1.source}$`), mz = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function yz(t) {
  const [e, n, a, s, f, o, m, g, b] = t, T = e[0] === "-", M = g && g[0] === "-", I = (A, z = !1) => A !== void 0 && (z || A && T) ? -A : A;
  return [
    {
      years: I(Ec(n)),
      months: I(Ec(a)),
      weeks: I(Ec(s)),
      days: I(Ec(f)),
      hours: I(Ec(o)),
      minutes: I(Ec(m)),
      seconds: I(Ec(g), g === "-0"),
      milliseconds: I(G1(b), M)
    }
  ];
}
const gz = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function H1(t, e, n, a, s, f, o) {
  const m = {
    year: e.length === 2 ? t1(vu(e)) : vu(e),
    month: lM.indexOf(n) + 1,
    day: vu(a),
    hour: vu(s),
    minute: vu(f)
  };
  return o && (m.second = vu(o)), t && (m.weekday = t.length > 3 ? cM.indexOf(t) + 1 : hM.indexOf(t) + 1), m;
}
const vz = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function _z(t) {
  const [
    ,
    e,
    n,
    a,
    s,
    f,
    o,
    m,
    g,
    b,
    T,
    M
  ] = t, I = H1(e, s, a, n, f, o, m);
  let A;
  return g ? A = gz[g] : b ? A = 0 : A = Mv(T, M), [I, new Fo(A)];
}
function xz(t) {
  return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const bz = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, wz = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Ez = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function y2(t) {
  const [, e, n, a, s, f, o, m] = t;
  return [H1(e, s, a, n, f, o, m), Fo.utcInstance];
}
function Sz(t) {
  const [, e, n, a, s, f, o, m] = t;
  return [H1(e, m, n, a, s, f, o), Fo.utcInstance];
}
const Tz = Bf(az, W1), Mz = Bf(sz, W1), Iz = Bf(lz, W1), Oz = Bf(vM), xM = Vf(
  pz,
  jf,
  Jd,
  Qd
), Cz = Vf(
  uz,
  jf,
  Jd,
  Qd
), Az = Vf(
  cz,
  jf,
  Jd,
  Qd
), Pz = Vf(
  jf,
  Jd,
  Qd
);
function kz(t) {
  return Uf(
    t,
    [Tz, xM],
    [Mz, Cz],
    [Iz, Az],
    [Oz, Pz]
  );
}
function Lz(t) {
  return Uf(xz(t), [vz, _z]);
}
function Dz(t) {
  return Uf(
    t,
    [bz, y2],
    [wz, y2],
    [Ez, Sz]
  );
}
function Nz(t) {
  return Uf(t, [mz, yz]);
}
const Rz = Vf(jf);
function zz(t) {
  return Uf(t, [dz, Rz]);
}
const Fz = Bf(hz, fz), Bz = Bf(_M), Vz = Vf(
  jf,
  Jd,
  Qd
);
function Uz(t) {
  return Uf(
    t,
    [Fz, xM],
    [Bz, Vz]
  );
}
const g2 = "Invalid Duration", bM = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, jz = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...bM
}, Ia = 146097 / 400, Qh = 146097 / 4800, Gz = {
  years: {
    quarters: 4,
    months: 12,
    weeks: Ia / 7,
    days: Ia,
    hours: Ia * 24,
    minutes: Ia * 24 * 60,
    seconds: Ia * 24 * 60 * 60,
    milliseconds: Ia * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: Ia / 28,
    days: Ia / 4,
    hours: Ia * 24 / 4,
    minutes: Ia * 24 * 60 / 4,
    seconds: Ia * 24 * 60 * 60 / 4,
    milliseconds: Ia * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: Qh / 7,
    days: Qh,
    hours: Qh * 24,
    minutes: Qh * 24 * 60,
    seconds: Qh * 24 * 60 * 60,
    milliseconds: Qh * 24 * 60 * 60 * 1e3
  },
  ...bM
}, Pc = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], wM = Pc.slice(0).reverse();
function pu(t, e, n = !1) {
  const a = {
    values: n ? e.values : { ...t.values, ...e.values || {} },
    loc: t.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy,
    matrix: e.matrix || t.matrix
  };
  return new Yr(a);
}
function v2(t) {
  return Math.trunc(t * 1e3) / 1e3;
}
function EM(t, e, n, a, s) {
  const f = t[s][n], o = e[n] / f, m = W5(o);
  a[s] = v2(a[s] + m), e[n] = v2(e[n] - m * f);
}
function qz(t, e) {
  wM.reduce((n, a) => Wr(e[a]) ? n : (n && EM(t, e, n, e, a), a), null);
}
function $z(t) {
  const e = {};
  for (const [n, a] of Object.entries(t))
    a !== 0 && (e[n] = a);
  return e;
}
class Yr {
  constructor(e) {
    const n = e.conversionAccuracy === "longterm" || !1;
    let a = n ? Gz : jz;
    e.matrix && (a = e.matrix), this.values = e.values, this.loc = e.loc || zn.create(), this.conversionAccuracy = n ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = a, this.isLuxonDuration = !0;
  }
  static fromMillis(e, n) {
    return Yr.fromObject({ milliseconds: e }, n);
  }
  static fromObject(e, n = {}) {
    if (e == null || typeof e != "object")
      throw new Pa(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
      );
    return new Yr({
      values: jg(e, Yr.normalizeUnit),
      loc: zn.fromObject(n),
      conversionAccuracy: n.conversionAccuracy,
      matrix: n.matrix
    });
  }
  static fromDurationLike(e) {
    if (jc(e))
      return Yr.fromMillis(e);
    if (Yr.isDuration(e))
      return e;
    if (typeof e == "object")
      return Yr.fromObject(e);
    throw new Pa(
      `Unknown duration argument ${e} of type ${typeof e}`
    );
  }
  static fromISO(e, n) {
    const [a] = Nz(e);
    return a ? Yr.fromObject(a, n) : Yr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static fromISOTime(e, n) {
    const [a] = zz(e);
    return a ? Yr.fromObject(a, n) : Yr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static invalid(e, n = null) {
    if (!e)
      throw new Pa("need to specify a reason the Duration is invalid");
    const a = e instanceof as ? e : new as(e, n);
    if (Oi.throwOnInvalid)
      throw new b5(a);
    return new Yr({ invalid: a });
  }
  static normalizeUnit(e) {
    const n = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[e && e.toLowerCase()];
    if (!n)
      throw new BT(e);
    return n;
  }
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(e, n = {}) {
    const a = {
      ...n,
      floor: n.round !== !1 && n.floor !== !1
    };
    return this.isValid ? bo.create(this.loc, a).formatDurationFromString(this, e) : g2;
  }
  toHuman(e = {}) {
    if (!this.isValid)
      return g2;
    const n = Pc.map((a) => {
      const s = this.values[a];
      return Wr(s) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: a.slice(0, -1) }).format(s);
    }).filter((a) => a);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(n);
  }
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  toISO() {
    if (!this.isValid)
      return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += q1(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  toISOTime(e = {}) {
    if (!this.isValid)
      return null;
    const n = this.toMillis();
    return n < 0 || n >= 864e5 ? null : (e = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...e,
      includeOffset: !1
    }, xr.fromMillis(n, { zone: "UTC" }).toISOTime(e));
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  toMillis() {
    var n;
    if (!this.isValid)
      return NaN;
    let e = (n = this.values.milliseconds) != null ? n : 0;
    for (let a of wM.slice(1))
      this.values[a] && (e += this.values[a] * this.matrix[a].milliseconds);
    return e;
  }
  valueOf() {
    return this.toMillis();
  }
  plus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e), a = {};
    for (const s of Pc)
      (Df(n.values, s) || Df(this.values, s)) && (a[s] = n.get(s) + this.get(s));
    return pu(this, { values: a }, !0);
  }
  minus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e);
    return this.plus(n.negate());
  }
  mapUnits(e) {
    if (!this.isValid)
      return this;
    const n = {};
    for (const a of Object.keys(this.values))
      n[a] = sM(e(this.values[a], a));
    return pu(this, { values: n }, !0);
  }
  get(e) {
    return this[Yr.normalizeUnit(e)];
  }
  set(e) {
    if (!this.isValid)
      return this;
    const n = { ...this.values, ...jg(e, Yr.normalizeUnit) };
    return pu(this, { values: n });
  }
  reconfigure({ locale: e, numberingSystem: n, conversionAccuracy: a, matrix: s } = {}) {
    const o = { loc: this.loc.clone({ locale: e, numberingSystem: n }), matrix: s, conversionAccuracy: a };
    return pu(this, o);
  }
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  normalize() {
    if (!this.isValid)
      return this;
    const e = this.toObject();
    return this.valueOf() >= 0 ? (qz(this.matrix, e), pu(this, { values: e }, !0)) : this.negate().normalize().negate();
  }
  rescale() {
    if (!this.isValid)
      return this;
    const e = $z(this.normalize().shiftToAll().toObject());
    return pu(this, { values: e }, !0);
  }
  shiftTo(...e) {
    if (!this.isValid)
      return this;
    if (e.length === 0)
      return this;
    e = e.map((o) => Yr.normalizeUnit(o));
    const n = {}, a = {}, s = this.toObject();
    let f;
    for (const o of Pc)
      if (e.indexOf(o) >= 0) {
        f = o;
        let m = 0;
        for (const b in a)
          m += this.matrix[b][o] * a[b], a[b] = 0;
        jc(s[o]) && (m += s[o]);
        const g = Math.trunc(m);
        n[o] = g, a[o] = (m * 1e3 - g * 1e3) / 1e3;
        for (const b in s)
          Pc.indexOf(b) > Pc.indexOf(o) && EM(this.matrix, s, b, n, o);
      } else
        jc(s[o]) && (a[o] = s[o]);
    for (const o in a)
      a[o] !== 0 && (n[f] += o === f ? a[o] : a[o] / this.matrix[f][o]);
    return pu(this, { values: n }, !0).normalize();
  }
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  negate() {
    if (!this.isValid)
      return this;
    const e = {};
    for (const n of Object.keys(this.values))
      e[n] = this.values[n] === 0 ? 0 : -this.values[n];
    return pu(this, { values: e }, !0);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
      return !1;
    function n(a, s) {
      return a === void 0 || a === 0 ? s === void 0 || s === 0 : a === s;
    }
    for (const a of Pc)
      if (!n(this.values[a], e.values[a]))
        return !1;
    return !0;
  }
}
const ef = "Invalid Interval";
function Wz(t, e) {
  return !t || !t.isValid ? fi.invalid("missing or invalid start") : !e || !e.isValid ? fi.invalid("missing or invalid end") : e < t ? fi.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`
  ) : null;
}
class fi {
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  static invalid(e, n = null) {
    if (!e)
      throw new Pa("need to specify a reason the Interval is invalid");
    const a = e instanceof as ? e : new as(e, n);
    if (Oi.throwOnInvalid)
      throw new x5(a);
    return new fi({ invalid: a });
  }
  static fromDateTimes(e, n) {
    const a = Hp(e), s = Hp(n), f = Wz(a, s);
    return f == null ? new fi({
      start: a,
      end: s
    }) : f;
  }
  static after(e, n) {
    const a = Yr.fromDurationLike(n), s = Hp(e);
    return fi.fromDateTimes(s, s.plus(a));
  }
  static before(e, n) {
    const a = Yr.fromDurationLike(n), s = Hp(e);
    return fi.fromDateTimes(s.minus(a), s);
  }
  static fromISO(e, n) {
    const [a, s] = (e || "").split("/", 2);
    if (a && s) {
      let f, o;
      try {
        f = xr.fromISO(a, n), o = f.isValid;
      } catch {
        o = !1;
      }
      let m, g;
      try {
        m = xr.fromISO(s, n), g = m.isValid;
      } catch {
        g = !1;
      }
      if (o && g)
        return fi.fromDateTimes(f, m);
      if (o) {
        const b = Yr.fromISO(s, n);
        if (b.isValid)
          return fi.after(f, b);
      } else if (g) {
        const b = Yr.fromISO(a, n);
        if (b.isValid)
          return fi.before(m, b);
      }
    }
    return fi.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  count(e = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const n = this.start.startOf(e), a = this.end.startOf(e);
    return Math.floor(a.diff(n, e).get(e)) + (a.valueOf() !== this.end.valueOf());
  }
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  set({ start: e, end: n } = {}) {
    return this.isValid ? fi.fromDateTimes(e || this.s, n || this.e) : this;
  }
  splitAt(...e) {
    if (!this.isValid)
      return [];
    const n = e.map(Hp).filter((o) => this.contains(o)).sort(), a = [];
    let { s } = this, f = 0;
    for (; s < this.e; ) {
      const o = n[f] || this.e, m = +o > +this.e ? this.e : o;
      a.push(fi.fromDateTimes(s, m)), s = m, f += 1;
    }
    return a;
  }
  splitBy(e) {
    const n = Yr.fromDurationLike(e);
    if (!this.isValid || !n.isValid || n.as("milliseconds") === 0)
      return [];
    let { s: a } = this, s = 1, f;
    const o = [];
    for (; a < this.e; ) {
      const m = this.start.plus(n.mapUnits((g) => g * s));
      f = +m > +this.e ? this.e : m, o.push(fi.fromDateTimes(a, f)), a = f, s += 1;
    }
    return o;
  }
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  intersection(e) {
    if (!this.isValid)
      return this;
    const n = this.s > e.s ? this.s : e.s, a = this.e < e.e ? this.e : e.e;
    return n >= a ? null : fi.fromDateTimes(n, a);
  }
  union(e) {
    if (!this.isValid)
      return this;
    const n = this.s < e.s ? this.s : e.s, a = this.e > e.e ? this.e : e.e;
    return fi.fromDateTimes(n, a);
  }
  static merge(e) {
    const [n, a] = e.sort((s, f) => s.s - f.s).reduce(
      ([s, f], o) => f ? f.overlaps(o) || f.abutsStart(o) ? [s, f.union(o)] : [s.concat([f]), o] : [s, o],
      [[], null]
    );
    return a && n.push(a), n;
  }
  static xor(e) {
    let n = null, a = 0;
    const s = [], f = e.map((g) => [
      { time: g.s, type: "s" },
      { time: g.e, type: "e" }
    ]), o = Array.prototype.concat(...f), m = o.sort((g, b) => g.time - b.time);
    for (const g of m)
      a += g.type === "s" ? 1 : -1, a === 1 ? n = g.time : (n && +n != +g.time && s.push(fi.fromDateTimes(n, g.time)), n = null);
    return fi.merge(s);
  }
  difference(...e) {
    return fi.xor([this].concat(e)).map((n) => this.intersection(n)).filter((n) => n && !n.isEmpty());
  }
  toString() {
    return this.isValid ? `[${this.s.toISO()} \u2013 ${this.e.toISO()})` : ef;
  }
  toLocaleString(e = Bg, n = {}) {
    return this.isValid ? bo.create(this.s.loc.clone(n), e).formatInterval(this) : ef;
  }
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : ef;
  }
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : ef;
  }
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : ef;
  }
  toFormat(e, { separator: n = " \u2013 " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${n}${this.e.toFormat(e)}` : ef;
  }
  toDuration(e, n) {
    return this.isValid ? this.e.diff(this.s, e, n) : Yr.invalid(this.invalidReason);
  }
  mapEndpoints(e) {
    return fi.fromDateTimes(e(this.s), e(this.e));
  }
}
class Ay {
  static hasDST(e = Oi.defaultZone) {
    const n = xr.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && n.offset !== n.set({ month: 6 }).offset;
  }
  static isValidIANAZone(e) {
    return Bl.isValidZone(e);
  }
  static normalizeZone(e) {
    return wu(e, Oi.defaultZone);
  }
  static months(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null, outputCalendar: f = "gregory" } = {}) {
    return (s || zn.create(n, a, f)).months(e);
  }
  static monthsFormat(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null, outputCalendar: f = "gregory" } = {}) {
    return (s || zn.create(n, a, f)).months(e, !0);
  }
  static weekdays(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null } = {}) {
    return (s || zn.create(n, a, null)).weekdays(e);
  }
  static weekdaysFormat(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null } = {}) {
    return (s || zn.create(n, a, null)).weekdays(e, !0);
  }
  static meridiems({ locale: e = null } = {}) {
    return zn.create(e).meridiems();
  }
  static eras(e = "short", { locale: n = null } = {}) {
    return zn.create(n, null, "gregory").eras(e);
  }
  static features() {
    return { relative: oM() };
  }
}
function _2(t, e) {
  const n = (s) => s.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), a = n(e) - n(t);
  return Math.floor(Yr.fromMillis(a).as("days"));
}
function Hz(t, e, n) {
  const a = [
    ["years", (g, b) => b.year - g.year],
    ["quarters", (g, b) => b.quarter - g.quarter + (b.year - g.year) * 4],
    ["months", (g, b) => b.month - g.month + (b.year - g.year) * 12],
    [
      "weeks",
      (g, b) => {
        const T = _2(g, b);
        return (T - T % 7) / 7;
      }
    ],
    ["days", _2]
  ], s = {}, f = t;
  let o, m;
  for (const [g, b] of a)
    n.indexOf(g) >= 0 && (o = g, s[g] = b(t, e), m = f.plus(s), m > e ? (s[g]--, t = f.plus(s), t > e && (m = t, s[g]--, t = f.plus(s))) : t = m);
  return [t, s, m, o];
}
function Zz(t, e, n, a) {
  let [s, f, o, m] = Hz(t, e, n);
  const g = e - s, b = n.filter(
    (M) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(M) >= 0
  );
  b.length === 0 && (o < e && (o = s.plus({ [m]: 1 })), o !== s && (f[m] = (f[m] || 0) + g / (o - s)));
  const T = Yr.fromObject(f, a);
  return b.length > 0 ? Yr.fromMillis(g, a).shiftTo(...b).plus(T) : T;
}
const Z1 = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
}, x2 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, Xz = Z1.hanidec.replace(/[\[|\]]/g, "").split("");
function Kz(t) {
  let e = parseInt(t, 10);
  if (isNaN(e)) {
    e = "";
    for (let n = 0; n < t.length; n++) {
      const a = t.charCodeAt(n);
      if (t[n].search(Z1.hanidec) !== -1)
        e += Xz.indexOf(t[n]);
      else
        for (const s in x2) {
          const [f, o] = x2[s];
          a >= f && a <= o && (e += a - f);
        }
    }
    return parseInt(e, 10);
  } else
    return e;
}
function Xa({ numberingSystem: t }, e = "") {
  return new RegExp(`${Z1[t || "latn"]}${e}`);
}
const Yz = "missing Intl.DateTimeFormat.formatToParts support";
function rn(t, e = (n) => n) {
  return { regex: t, deser: ([n]) => e(Kz(n)) };
}
const Jz = String.fromCharCode(160), SM = `[ ${Jz}]`, TM = new RegExp(SM, "g");
function Qz(t) {
  return t.replace(/\./g, "\\.?").replace(TM, SM);
}
function b2(t) {
  return t.replace(/\./g, "").replace(TM, " ").toLowerCase();
}
function Ka(t, e) {
  return t === null ? null : {
    regex: RegExp(t.map(Qz).join("|")),
    deser: ([n]) => t.findIndex((a) => b2(n) === b2(a)) + e
  };
}
function w2(t, e) {
  return { regex: t, deser: ([, n, a]) => Mv(n, a), groups: e };
}
function Py(t) {
  return { regex: t, deser: ([e]) => e };
}
function e6(t) {
  return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function t6(t, e) {
  const n = Xa(e), a = Xa(e, "{2}"), s = Xa(e, "{3}"), f = Xa(e, "{4}"), o = Xa(e, "{6}"), m = Xa(e, "{1,2}"), g = Xa(e, "{1,3}"), b = Xa(e, "{1,6}"), T = Xa(e, "{1,9}"), M = Xa(e, "{2,4}"), I = Xa(e, "{4,6}"), A = (Z) => ({ regex: RegExp(e6(Z.val)), deser: ([X]) => X, literal: !0 }), V = ((Z) => {
    if (t.literal)
      return A(Z);
    switch (Z.val) {
      case "G":
        return Ka(e.eras("short"), 0);
      case "GG":
        return Ka(e.eras("long"), 0);
      case "y":
        return rn(b);
      case "yy":
        return rn(M, t1);
      case "yyyy":
        return rn(f);
      case "yyyyy":
        return rn(I);
      case "yyyyyy":
        return rn(o);
      case "M":
        return rn(m);
      case "MM":
        return rn(a);
      case "MMM":
        return Ka(e.months("short", !0), 1);
      case "MMMM":
        return Ka(e.months("long", !0), 1);
      case "L":
        return rn(m);
      case "LL":
        return rn(a);
      case "LLL":
        return Ka(e.months("short", !1), 1);
      case "LLLL":
        return Ka(e.months("long", !1), 1);
      case "d":
        return rn(m);
      case "dd":
        return rn(a);
      case "o":
        return rn(g);
      case "ooo":
        return rn(s);
      case "HH":
        return rn(a);
      case "H":
        return rn(m);
      case "hh":
        return rn(a);
      case "h":
        return rn(m);
      case "mm":
        return rn(a);
      case "m":
        return rn(m);
      case "q":
        return rn(m);
      case "qq":
        return rn(a);
      case "s":
        return rn(m);
      case "ss":
        return rn(a);
      case "S":
        return rn(g);
      case "SSS":
        return rn(s);
      case "u":
        return Py(T);
      case "uu":
        return Py(m);
      case "uuu":
        return rn(n);
      case "a":
        return Ka(e.meridiems(), 0);
      case "kkkk":
        return rn(f);
      case "kk":
        return rn(M, t1);
      case "W":
        return rn(m);
      case "WW":
        return rn(a);
      case "E":
      case "c":
        return rn(n);
      case "EEE":
        return Ka(e.weekdays("short", !1), 1);
      case "EEEE":
        return Ka(e.weekdays("long", !1), 1);
      case "ccc":
        return Ka(e.weekdays("short", !0), 1);
      case "cccc":
        return Ka(e.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return w2(new RegExp(`([+-]${m.source})(?::(${a.source}))?`), 2);
      case "ZZZ":
        return w2(new RegExp(`([+-]${m.source})(${a.source})?`), 2);
      case "z":
        return Py(/[a-z_+-/]{1,256}?/i);
      case " ":
        return Py(/[^\S\n\r]/);
      default:
        return A(Z);
    }
  })(t) || {
    invalidReason: Yz
  };
  return V.token = t, V;
}
const r6 = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function n6(t, e, n) {
  const { type: a, value: s } = t;
  if (a === "literal") {
    const g = /^\s+$/.test(s);
    return {
      literal: !g,
      val: g ? " " : s
    };
  }
  const f = e[a];
  let o = a;
  a === "hour" && (e.hour12 != null ? o = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? o = "hour12" : o = "hour24" : o = n.hour12 ? "hour12" : "hour24");
  let m = r6[o];
  if (typeof m == "object" && (m = m[f]), m)
    return {
      literal: !1,
      val: m
    };
}
function i6(t) {
  return [`^${t.map((n) => n.regex).reduce((n, a) => `${n}(${a.source})`, "")}$`, t];
}
function o6(t, e, n) {
  const a = t.match(e);
  if (a) {
    const s = {};
    let f = 1;
    for (const o in n)
      if (Df(n, o)) {
        const m = n[o], g = m.groups ? m.groups + 1 : 1;
        !m.literal && m.token && (s[m.token.val[0]] = m.deser(a.slice(f, f + g))), f += g;
      }
    return [a, s];
  } else
    return [a, {}];
}
function a6(t) {
  const e = (f) => {
    switch (f) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let n = null, a;
  return Wr(t.z) || (n = Bl.create(t.z)), Wr(t.Z) || (n || (n = new Fo(t.Z)), a = t.Z), Wr(t.q) || (t.M = (t.q - 1) * 3 + 1), Wr(t.h) || (t.h < 12 && t.a === 1 ? t.h += 12 : t.h === 12 && t.a === 0 && (t.h = 0)), t.G === 0 && t.y && (t.y = -t.y), Wr(t.u) || (t.S = G1(t.u)), [Object.keys(t).reduce((f, o) => {
    const m = e(o);
    return m && (f[m] = t[o]), f;
  }, {}), n, a];
}
let W_ = null;
function s6() {
  return W_ || (W_ = xr.fromMillis(1555555555555)), W_;
}
function l6(t, e) {
  if (t.literal)
    return t;
  const n = bo.macroTokenToFormatOpts(t.val), a = OM(n, e);
  return a == null || a.includes(void 0) ? t : a;
}
function MM(t, e) {
  return Array.prototype.concat(...t.map((n) => l6(n, e)));
}
function IM(t, e, n) {
  const a = MM(bo.parseFormat(n), t), s = a.map((o) => t6(o, t)), f = s.find((o) => o.invalidReason);
  if (f)
    return { input: e, tokens: a, invalidReason: f.invalidReason };
  {
    const [o, m] = i6(s), g = RegExp(o, "i"), [b, T] = o6(e, g, m), [M, I, A] = T ? a6(T) : [null, null, void 0];
    if (Df(T, "a") && Df(T, "H"))
      throw new rd(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: e, tokens: a, regex: g, rawMatches: b, matches: T, result: M, zone: I, specificOffset: A };
  }
}
function u6(t, e, n) {
  const { result: a, zone: s, specificOffset: f, invalidReason: o } = IM(t, e, n);
  return [a, s, f, o];
}
function OM(t, e) {
  if (!t)
    return null;
  const a = bo.create(e, t).dtFormatter(s6()), s = a.formatToParts(), f = a.resolvedOptions();
  return s.map((o) => n6(o, t, f));
}
const CM = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], AM = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function ka(t, e) {
  return new as(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`
  );
}
function PM(t, e, n) {
  const a = new Date(Date.UTC(t, e - 1, n));
  t < 100 && t >= 0 && a.setUTCFullYear(a.getUTCFullYear() - 1900);
  const s = a.getUTCDay();
  return s === 0 ? 7 : s;
}
function kM(t, e, n) {
  return n + (Yd(t) ? AM : CM)[e - 1];
}
function LM(t, e) {
  const n = Yd(t) ? AM : CM, a = n.findIndex((f) => f < e), s = e - n[a];
  return { month: a + 1, day: s };
}
function r1(t) {
  const { year: e, month: n, day: a } = t, s = kM(e, n, a), f = PM(e, n, a);
  let o = Math.floor((s - f + 10) / 7), m;
  return o < 1 ? (m = e - 1, o = Ug(m)) : o > Ug(e) ? (m = e + 1, o = 1) : m = e, { weekYear: m, weekNumber: o, weekday: f, ...Iv(t) };
}
function E2(t) {
  const { weekYear: e, weekNumber: n, weekday: a } = t, s = PM(e, 1, 4), f = yd(e);
  let o = n * 7 + a - s - 3, m;
  o < 1 ? (m = e - 1, o += yd(m)) : o > f ? (m = e + 1, o -= yd(e)) : m = e;
  const { month: g, day: b } = LM(m, o);
  return { year: m, month: g, day: b, ...Iv(t) };
}
function H_(t) {
  const { year: e, month: n, day: a } = t, s = kM(e, n, a);
  return { year: e, ordinal: s, ...Iv(t) };
}
function S2(t) {
  const { year: e, ordinal: n } = t, { month: a, day: s } = LM(e, n);
  return { year: e, month: a, day: s, ...Iv(t) };
}
function c6(t) {
  const e = Sv(t.weekYear), n = Ll(t.weekNumber, 1, Ug(t.weekYear)), a = Ll(t.weekday, 1, 7);
  return e ? n ? a ? !1 : ka("weekday", t.weekday) : ka("week", t.week) : ka("weekYear", t.weekYear);
}
function h6(t) {
  const e = Sv(t.year), n = Ll(t.ordinal, 1, yd(t.year));
  return e ? n ? !1 : ka("ordinal", t.ordinal) : ka("year", t.year);
}
function DM(t) {
  const e = Sv(t.year), n = Ll(t.month, 1, 12), a = Ll(t.day, 1, Vg(t.year, t.month));
  return e ? n ? a ? !1 : ka("day", t.day) : ka("month", t.month) : ka("year", t.year);
}
function NM(t) {
  const { hour: e, minute: n, second: a, millisecond: s } = t, f = Ll(e, 0, 23) || e === 24 && n === 0 && a === 0 && s === 0, o = Ll(n, 0, 59), m = Ll(a, 0, 59), g = Ll(s, 0, 999);
  return f ? o ? m ? g ? !1 : ka("millisecond", s) : ka("second", a) : ka("minute", n) : ka("hour", e);
}
const Z_ = "Invalid DateTime", T2 = 864e13;
function ky(t) {
  return new as("unsupported zone", `the zone "${t.name}" is not supported`);
}
function X_(t) {
  return t.weekData === null && (t.weekData = r1(t.c)), t.weekData;
}
function Sc(t, e) {
  const n = {
    ts: t.ts,
    zone: t.zone,
    c: t.c,
    o: t.o,
    loc: t.loc,
    invalid: t.invalid
  };
  return new xr({ ...n, ...e, old: n });
}
function RM(t, e, n) {
  let a = t - e * 60 * 1e3;
  const s = n.offset(a);
  if (e === s)
    return [a, e];
  a -= (s - e) * 60 * 1e3;
  const f = n.offset(a);
  return s === f ? [a, s] : [t - Math.min(s, f) * 60 * 1e3, Math.max(s, f)];
}
function Ly(t, e) {
  t += e * 60 * 1e3;
  const n = new Date(t);
  return {
    year: n.getUTCFullYear(),
    month: n.getUTCMonth() + 1,
    day: n.getUTCDate(),
    hour: n.getUTCHours(),
    minute: n.getUTCMinutes(),
    second: n.getUTCSeconds(),
    millisecond: n.getUTCMilliseconds()
  };
}
function sg(t, e, n) {
  return RM(Tv(t), e, n);
}
function M2(t, e) {
  const n = t.o, a = t.c.year + Math.trunc(e.years), s = t.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, f = {
    ...t.c,
    year: a,
    month: s,
    day: Math.min(t.c.day, Vg(a, s)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
  }, o = Yr.fromObject({
    years: e.years - Math.trunc(e.years),
    quarters: e.quarters - Math.trunc(e.quarters),
    months: e.months - Math.trunc(e.months),
    weeks: e.weeks - Math.trunc(e.weeks),
    days: e.days - Math.trunc(e.days),
    hours: e.hours,
    minutes: e.minutes,
    seconds: e.seconds,
    milliseconds: e.milliseconds
  }).as("milliseconds"), m = Tv(f);
  let [g, b] = RM(m, n, t.zone);
  return o !== 0 && (g += o, b = t.zone.offset(g)), { ts: g, o: b };
}
function Wp(t, e, n, a, s, f) {
  const { setZone: o, zone: m } = n;
  if (t && Object.keys(t).length !== 0 || e) {
    const g = e || m, b = xr.fromObject(t, {
      ...n,
      zone: g,
      specificOffset: f
    });
    return o ? b : b.setZone(m);
  } else
    return xr.invalid(
      new as("unparsable", `the input "${s}" can't be parsed as ${a}`)
    );
}
function Dy(t, e, n = !0) {
  return t.isValid ? bo.create(zn.create("en-US"), {
    allowZ: n,
    forceSimple: !0
  }).formatDateTimeFromString(t, e) : null;
}
function K_(t, e) {
  const n = t.c.year > 9999 || t.c.year < 0;
  let a = "";
  return n && t.c.year >= 0 && (a += "+"), a += Ci(t.c.year, n ? 6 : 4), e ? (a += "-", a += Ci(t.c.month), a += "-", a += Ci(t.c.day)) : (a += Ci(t.c.month), a += Ci(t.c.day)), a;
}
function I2(t, e, n, a, s, f) {
  let o = Ci(t.c.hour);
  return e ? (o += ":", o += Ci(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (o += ":")) : o += Ci(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (o += Ci(t.c.second), (t.c.millisecond !== 0 || !a) && (o += ".", o += Ci(t.c.millisecond, 3))), s && (t.isOffsetFixed && t.offset === 0 && !f ? o += "Z" : t.o < 0 ? (o += "-", o += Ci(Math.trunc(-t.o / 60)), o += ":", o += Ci(Math.trunc(-t.o % 60))) : (o += "+", o += Ci(Math.trunc(t.o / 60)), o += ":", o += Ci(Math.trunc(t.o % 60)))), f && (o += "[" + t.zone.ianaName + "]"), o;
}
const zM = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, f6 = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, p6 = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, FM = ["year", "month", "day", "hour", "minute", "second", "millisecond"], d6 = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], m6 = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function O2(t) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[t.toLowerCase()];
  if (!e)
    throw new BT(t);
  return e;
}
function C2(t, e) {
  const n = wu(e.zone, Oi.defaultZone), a = zn.fromObject(e), s = Oi.now();
  let f, o;
  if (Wr(t.year))
    f = s;
  else {
    for (const b of FM)
      Wr(t[b]) && (t[b] = zM[b]);
    const m = DM(t) || NM(t);
    if (m)
      return xr.invalid(m);
    const g = n.offset(s);
    [f, o] = sg(t, g, n);
  }
  return new xr({ ts: f, zone: n, loc: a, o });
}
function A2(t, e, n) {
  const a = Wr(n.round) ? !0 : n.round, s = (o, m) => (o = q1(o, a || n.calendary ? 0 : 2, !0), e.loc.clone(n).relFormatter(n).format(o, m)), f = (o) => n.calendary ? e.hasSame(t, o) ? 0 : e.startOf(o).diff(t.startOf(o), o).get(o) : e.diff(t, o).get(o);
  if (n.unit)
    return s(f(n.unit), n.unit);
  for (const o of n.units) {
    const m = f(o);
    if (Math.abs(m) >= 1)
      return s(m, o);
  }
  return s(t > e ? -0 : 0, n.units[n.units.length - 1]);
}
function P2(t) {
  let e = {}, n;
  return t.length > 0 && typeof t[t.length - 1] == "object" ? (e = t[t.length - 1], n = Array.from(t).slice(0, t.length - 1)) : n = Array.from(t), [e, n];
}
class xr {
  constructor(e) {
    const n = e.zone || Oi.defaultZone;
    let a = e.invalid || (Number.isNaN(e.ts) ? new as("invalid input") : null) || (n.isValid ? null : ky(n));
    this.ts = Wr(e.ts) ? Oi.now() : e.ts;
    let s = null, f = null;
    if (!a)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(n))
        [s, f] = [e.old.c, e.old.o];
      else {
        const m = n.offset(this.ts);
        s = Ly(this.ts, m), a = Number.isNaN(s.year) ? new as("invalid input") : null, s = a ? null : s, f = a ? null : m;
      }
    this._zone = n, this.loc = e.loc || zn.create(), this.invalid = a, this.weekData = null, this.c = s, this.o = f, this.isLuxonDateTime = !0;
  }
  static now() {
    return new xr({});
  }
  static local() {
    const [e, n] = P2(arguments), [a, s, f, o, m, g, b] = n;
    return C2({ year: a, month: s, day: f, hour: o, minute: m, second: g, millisecond: b }, e);
  }
  static utc() {
    const [e, n] = P2(arguments), [a, s, f, o, m, g, b] = n;
    return e.zone = Fo.utcInstance, C2({ year: a, month: s, day: f, hour: o, minute: m, second: g, millisecond: b }, e);
  }
  static fromJSDate(e, n = {}) {
    const a = j5(e) ? e.valueOf() : NaN;
    if (Number.isNaN(a))
      return xr.invalid("invalid input");
    const s = wu(n.zone, Oi.defaultZone);
    return s.isValid ? new xr({
      ts: a,
      zone: s,
      loc: zn.fromObject(n)
    }) : xr.invalid(ky(s));
  }
  static fromMillis(e, n = {}) {
    if (jc(e))
      return e < -T2 || e > T2 ? xr.invalid("Timestamp out of range") : new xr({
        ts: e,
        zone: wu(n.zone, Oi.defaultZone),
        loc: zn.fromObject(n)
      });
    throw new Pa(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
    );
  }
  static fromSeconds(e, n = {}) {
    if (jc(e))
      return new xr({
        ts: e * 1e3,
        zone: wu(n.zone, Oi.defaultZone),
        loc: zn.fromObject(n)
      });
    throw new Pa("fromSeconds requires a numerical input");
  }
  static fromObject(e, n = {}) {
    e = e || {};
    const a = wu(n.zone, Oi.defaultZone);
    if (!a.isValid)
      return xr.invalid(ky(a));
    const s = Oi.now(), f = Wr(n.specificOffset) ? a.offset(s) : n.specificOffset, o = jg(e, O2), m = !Wr(o.ordinal), g = !Wr(o.year), b = !Wr(o.month) || !Wr(o.day), T = g || b, M = o.weekYear || o.weekNumber, I = zn.fromObject(n);
    if ((T || m) && M)
      throw new rd(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (b && m)
      throw new rd("Can't mix ordinal dates with month/day");
    const A = M || o.weekday && !T;
    let z, V, Z = Ly(s, f);
    A ? (z = d6, V = f6, Z = r1(Z)) : m ? (z = m6, V = p6, Z = H_(Z)) : (z = FM, V = zM);
    let X = !1;
    for (const Re of z) {
      const Ee = o[Re];
      Wr(Ee) ? X ? o[Re] = V[Re] : o[Re] = Z[Re] : X = !0;
    }
    const Y = A ? c6(o) : m ? h6(o) : DM(o), de = Y || NM(o);
    if (de)
      return xr.invalid(de);
    const ye = A ? E2(o) : m ? S2(o) : o, [Ie, Be] = sg(ye, f, a), De = new xr({
      ts: Ie,
      zone: a,
      o: Be,
      loc: I
    });
    return o.weekday && T && e.weekday !== De.weekday ? xr.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${o.weekday} and a date of ${De.toISO()}`
    ) : De;
  }
  static fromISO(e, n = {}) {
    const [a, s] = kz(e);
    return Wp(a, s, n, "ISO 8601", e);
  }
  static fromRFC2822(e, n = {}) {
    const [a, s] = Lz(e);
    return Wp(a, s, n, "RFC 2822", e);
  }
  static fromHTTP(e, n = {}) {
    const [a, s] = Dz(e);
    return Wp(a, s, n, "HTTP", n);
  }
  static fromFormat(e, n, a = {}) {
    if (Wr(e) || Wr(n))
      throw new Pa("fromFormat requires an input string and a format");
    const { locale: s = null, numberingSystem: f = null } = a, o = zn.fromOpts({
      locale: s,
      numberingSystem: f,
      defaultToEN: !0
    }), [m, g, b, T] = u6(o, e, n);
    return T ? xr.invalid(T) : Wp(m, g, a, `format ${n}`, e, b);
  }
  static fromString(e, n, a = {}) {
    return xr.fromFormat(e, n, a);
  }
  static fromSQL(e, n = {}) {
    const [a, s] = Uz(e);
    return Wp(a, s, n, "SQL", e);
  }
  static invalid(e, n = null) {
    if (!e)
      throw new Pa("need to specify a reason the DateTime is invalid");
    const a = e instanceof as ? e : new as(e, n);
    if (Oi.throwOnInvalid)
      throw new _5(a);
    return new xr({ invalid: a });
  }
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  static parseFormatForOpts(e, n = {}) {
    const a = OM(e, zn.fromObject(n));
    return a ? a.map((s) => s ? s.val : null).join("") : null;
  }
  static expandFormat(e, n = {}) {
    return MM(bo.parseFormat(e), zn.fromObject(n)).map((s) => s.val).join("");
  }
  get(e) {
    return this[e];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? X_(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? X_(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? X_(this).weekday : NaN;
  }
  get ordinal() {
    return this.isValid ? H_(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? Ay.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? Ay.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? Ay.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? Ay.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const e = 864e5, n = 6e4, a = Tv(this.c), s = this.zone.offset(a - e), f = this.zone.offset(a + e), o = this.zone.offset(a - s * n), m = this.zone.offset(a - f * n);
    if (o === m)
      return [this];
    const g = a - o * n, b = a - m * n, T = Ly(g, o), M = Ly(b, m);
    return T.hour === M.hour && T.minute === M.minute && T.second === M.second && T.millisecond === M.millisecond ? [Sc(this, { ts: g }), Sc(this, { ts: b })] : [this];
  }
  get isInLeapYear() {
    return Yd(this.year);
  }
  get daysInMonth() {
    return Vg(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? yd(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? Ug(this.weekYear) : NaN;
  }
  resolvedLocaleOptions(e = {}) {
    const { locale: n, numberingSystem: a, calendar: s } = bo.create(
      this.loc.clone(e),
      e
    ).resolvedOptions(this);
    return { locale: n, numberingSystem: a, outputCalendar: s };
  }
  toUTC(e = 0, n = {}) {
    return this.setZone(Fo.instance(e), n);
  }
  toLocal() {
    return this.setZone(Oi.defaultZone);
  }
  setZone(e, { keepLocalTime: n = !1, keepCalendarTime: a = !1 } = {}) {
    if (e = wu(e, Oi.defaultZone), e.equals(this.zone))
      return this;
    if (e.isValid) {
      let s = this.ts;
      if (n || a) {
        const f = e.offset(this.ts), o = this.toObject();
        [s] = sg(o, f, e);
      }
      return Sc(this, { ts: s, zone: e });
    } else
      return xr.invalid(ky(e));
  }
  reconfigure({ locale: e, numberingSystem: n, outputCalendar: a } = {}) {
    const s = this.loc.clone({ locale: e, numberingSystem: n, outputCalendar: a });
    return Sc(this, { loc: s });
  }
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  set(e) {
    if (!this.isValid)
      return this;
    const n = jg(e, O2), a = !Wr(n.weekYear) || !Wr(n.weekNumber) || !Wr(n.weekday), s = !Wr(n.ordinal), f = !Wr(n.year), o = !Wr(n.month) || !Wr(n.day), m = f || o, g = n.weekYear || n.weekNumber;
    if ((m || s) && g)
      throw new rd(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (o && s)
      throw new rd("Can't mix ordinal dates with month/day");
    let b;
    a ? b = E2({ ...r1(this.c), ...n }) : Wr(n.ordinal) ? (b = { ...this.toObject(), ...n }, Wr(n.day) && (b.day = Math.min(Vg(b.year, b.month), b.day))) : b = S2({ ...H_(this.c), ...n });
    const [T, M] = sg(b, this.o, this.zone);
    return Sc(this, { ts: T, o: M });
  }
  plus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e);
    return Sc(this, M2(this, n));
  }
  minus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e).negate();
    return Sc(this, M2(this, n));
  }
  startOf(e) {
    if (!this.isValid)
      return this;
    const n = {}, a = Yr.normalizeUnit(e);
    switch (a) {
      case "years":
        n.month = 1;
      case "quarters":
      case "months":
        n.day = 1;
      case "weeks":
      case "days":
        n.hour = 0;
      case "hours":
        n.minute = 0;
      case "minutes":
        n.second = 0;
      case "seconds":
        n.millisecond = 0;
        break;
    }
    if (a === "weeks" && (n.weekday = 1), a === "quarters") {
      const s = Math.ceil(this.month / 3);
      n.month = (s - 1) * 3 + 1;
    }
    return this.set(n);
  }
  endOf(e) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e).minus(1) : this;
  }
  toFormat(e, n = {}) {
    return this.isValid ? bo.create(this.loc.redefaultToEN(n)).formatDateTimeFromString(this, e) : Z_;
  }
  toLocaleString(e = Bg, n = {}) {
    return this.isValid ? bo.create(this.loc.clone(n), e).formatDateTime(this) : Z_;
  }
  toLocaleParts(e = {}) {
    return this.isValid ? bo.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  toISO({
    format: e = "extended",
    suppressSeconds: n = !1,
    suppressMilliseconds: a = !1,
    includeOffset: s = !0,
    extendedZone: f = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const o = e === "extended";
    let m = K_(this, o);
    return m += "T", m += I2(this, o, n, a, s, f), m;
  }
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? K_(this, e === "extended") : null;
  }
  toISOWeekDate() {
    return Dy(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: n = !1,
    includeOffset: a = !0,
    includePrefix: s = !1,
    extendedZone: f = !1,
    format: o = "extended"
  } = {}) {
    return this.isValid ? (s ? "T" : "") + I2(
      this,
      o === "extended",
      n,
      e,
      a,
      f
    ) : null;
  }
  toRFC2822() {
    return Dy(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  toHTTP() {
    return Dy(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    return this.isValid ? K_(this, !0) : null;
  }
  toSQLTime({ includeOffset: e = !0, includeZone: n = !1, includeOffsetSpace: a = !0 } = {}) {
    let s = "HH:mm:ss.SSS";
    return (n || e) && (a && (s += " "), n ? s += "z" : e && (s += "ZZ")), Dy(this, s, !0);
  }
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  toString() {
    return this.isValid ? this.toISO() : Z_;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(e = {}) {
    if (!this.isValid)
      return {};
    const n = { ...this.c };
    return e.includeConfig && (n.outputCalendar = this.outputCalendar, n.numberingSystem = this.loc.numberingSystem, n.locale = this.loc.locale), n;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(e, n = "milliseconds", a = {}) {
    if (!this.isValid || !e.isValid)
      return Yr.invalid("created by diffing an invalid DateTime");
    const s = { locale: this.locale, numberingSystem: this.numberingSystem, ...a }, f = G5(n).map(Yr.normalizeUnit), o = e.valueOf() > this.valueOf(), m = o ? this : e, g = o ? e : this, b = Zz(m, g, f, s);
    return o ? b.negate() : b;
  }
  diffNow(e = "milliseconds", n = {}) {
    return this.diff(xr.now(), e, n);
  }
  until(e) {
    return this.isValid ? fi.fromDateTimes(this, e) : this;
  }
  hasSame(e, n) {
    if (!this.isValid)
      return !1;
    const a = e.valueOf(), s = this.setZone(e.zone, { keepLocalTime: !0 });
    return s.startOf(n) <= a && a <= s.endOf(n);
  }
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  toRelative(e = {}) {
    if (!this.isValid)
      return null;
    const n = e.base || xr.fromObject({}, { zone: this.zone }), a = e.padding ? this < n ? -e.padding : e.padding : 0;
    let s = ["years", "months", "days", "hours", "minutes", "seconds"], f = e.unit;
    return Array.isArray(e.unit) && (s = e.unit, f = void 0), A2(n, this.plus(a), {
      ...e,
      numeric: "always",
      units: s,
      unit: f
    });
  }
  toRelativeCalendar(e = {}) {
    return this.isValid ? A2(e.base || xr.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  static min(...e) {
    if (!e.every(xr.isDateTime))
      throw new Pa("min requires all arguments be DateTimes");
    return d2(e, (n) => n.valueOf(), Math.min);
  }
  static max(...e) {
    if (!e.every(xr.isDateTime))
      throw new Pa("max requires all arguments be DateTimes");
    return d2(e, (n) => n.valueOf(), Math.max);
  }
  static fromFormatExplain(e, n, a = {}) {
    const { locale: s = null, numberingSystem: f = null } = a, o = zn.fromOpts({
      locale: s,
      numberingSystem: f,
      defaultToEN: !0
    });
    return IM(o, e, n);
  }
  static fromStringExplain(e, n, a = {}) {
    return xr.fromFormatExplain(e, n, a);
  }
  static get DATE_SHORT() {
    return Bg;
  }
  static get DATE_MED() {
    return VT;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return w5;
  }
  static get DATE_FULL() {
    return UT;
  }
  static get DATE_HUGE() {
    return jT;
  }
  static get TIME_SIMPLE() {
    return GT;
  }
  static get TIME_WITH_SECONDS() {
    return qT;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return $T;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return WT;
  }
  static get TIME_24_SIMPLE() {
    return HT;
  }
  static get TIME_24_WITH_SECONDS() {
    return ZT;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return XT;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return KT;
  }
  static get DATETIME_SHORT() {
    return YT;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return JT;
  }
  static get DATETIME_MED() {
    return QT;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return eM;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return E5;
  }
  static get DATETIME_FULL() {
    return tM;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return rM;
  }
  static get DATETIME_HUGE() {
    return nM;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return iM;
  }
}
function Hp(t) {
  if (xr.isDateTime(t))
    return t;
  if (t && t.valueOf && jc(t.valueOf()))
    return xr.fromJSDate(t);
  if (t && typeof t == "object")
    return xr.fromObject(t);
  throw new Pa(
    `Unknown datetime argument: ${t}, of type ${typeof t}`
  );
}
function k2(t, e = "second", n, a) {
  const { t: s } = An(), f = new Date(t).toISOString(), o = {
    year: s("yyyy"),
    month: s("M/yyyy"),
    day: s("M/d/yyyy"),
    second: s("M/d/yyyy HH:mm:ss")
  }, g = (n ? {
    year: "yyyy",
    month: "yyyy-MM",
    day: "yyyy-MM-dd",
    second: void 0
  } : o)[e];
  return g ? xr.fromISO(f).toFormat(
    `${a ? "UTC:" : ""}${g}`
  ) : f.replace(/\.\d{3}/, "");
}
function L2(t) {
  return new Date(t).toISOString().split(".")[0] + "Z";
}
function Y_(t) {
  return xr.fromISO(t).toFormat("yyyy-MM-dd");
}
const Ai = Qc("map", () => {
  const t = Hr({}), e = Fn([]), n = Fn([]), a = Hr(!1), s = Hr(!0), f = Hr(void 0);
  function o(X) {
    f.value = X;
  }
  function m(...X) {
    e.value = [.../* @__PURE__ */ new Set([...e.value, ...X])];
  }
  function g(...X) {
    n.value = [.../* @__PURE__ */ new Set([...n.value, ...X])];
  }
  function b(...X) {
    e.value = e.value.filter(
      (Y) => X.indexOf(Y.id) === -1
    ), n.value = n.value.filter(
      (Y) => X.indexOf(Y.id) === -1
    );
  }
  function T() {
    e.value = [];
  }
  function M(X) {
    var Y;
    return !!((Y = e.value) != null && Y.find((de) => de.id === X));
  }
  function I(X) {
    var Y;
    e.value = [
      ...((Y = e.value) == null ? void 0 : Y.sort(
        (de, ye) => X.indexOf(de.id) - X.indexOf(ye.id)
      )) || []
    ];
  }
  function A(X, Y) {
    e.value = e.value.map((de) => de.id === X ? { ...de, opacity: Y, previousOpacity: de.opacity } : de);
  }
  function z(X, Y, de) {
    e.value = e.value.map((ye) => ye.id === X ? {
      ...ye,
      currentTimeMinValue: Y ? L2(Y) : void 0,
      currentTimeMaxValue: de ? L2(de) : void 0
    } : ye);
  }
  function V(X) {
    a.value = X;
  }
  function Z(X) {
    s.value = X;
  }
  return {
    map: t,
    layers: e,
    layers_3d: n,
    is_3d_active: a,
    is_3d_mesh: s,
    bgLayer: f,
    addLayers: m,
    add3dLayers: g,
    removeLayers: b,
    removeAllLayers: T,
    reorderLayers: I,
    setLayerOpacity: A,
    setLayerTime: z,
    setBgLayer: o,
    setIs3dActive: V,
    setIs3dMesh: Z,
    hasLayer: M
  };
});
class y6 {
  constructor() {
    bi(this, "styleWatcher");
  }
  bootstrapStyle() {
    const e = Ws();
    let n, a = !1;
    n = Na(() => {
      e.bgVectorSources && (this.restoreStyle(!1), a && this.persistStyle(), a = !0, n && n());
    });
  }
  persistStyle() {
    const e = Ws(), { bgStyle: n } = xn(e);
    this.styleWatcher || (this.styleWatcher = Bn(
      n,
      (a, s) => {
        if (s !== a) {
          const f = Ai();
          f.bgLayer && (Ir.setValue(
            f.bgLayer.name,
            a || [],
            My.styleToLocalStorage
          ), Ir.setValue(
            Rg,
            a || [],
            My.styleToSerial
          ));
        }
      },
      { immediate: !0 }
    ));
  }
  restoreStyle(e) {
    const n = Ws();
    n.setStyle(null);
    const s = Ai().bgLayer;
    if (s) {
      let f = [];
      e || (f = Ir.getValue(
        Rg,
        My.styleSerialToStyle
      )), f.length === 0 && (f = Ir.getValue(
        s.name,
        My.styleLocalStorageToStyle
      )), f && f.length > 0 && n.setStyle(f);
    }
  }
}
const BM = new y6(), g6 = [
  156543.033928,
  78271.516964,
  39135.758482,
  19567.879241,
  9783.9396205,
  4891.96981025,
  2445.98490513,
  1222.99245256,
  611.496226281,
  305.748113141,
  152.87405657,
  76.4370282852,
  38.2185141426,
  19.1092570713,
  9.55462853565,
  4.77731426782,
  2.38865713391,
  1.19432856696,
  0.597164283478,
  0.298582141739,
  0.1492910708695,
  0.07464553543475
], v6 = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "20",
  "21"
];
function us(t) {
  return us = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, us(t);
}
function Qs(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _6(t, e) {
  if (us(t) !== "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var a = n.call(t, e || "default");
    if (us(a) !== "object")
      return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function VM(t) {
  var e = _6(t, "string");
  return us(e) === "symbol" ? e : String(e);
}
function D2(t, e) {
  for (var n = 0; n < e.length; n++) {
    var a = e[n];
    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, VM(a.key), a);
  }
}
function el(t, e, n) {
  return e && D2(t.prototype, e), n && D2(t, n), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function Cu(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function n1(t, e) {
  return n1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, s) {
    return a.__proto__ = s, a;
  }, n1(t, e);
}
function Ov(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && n1(t, e);
}
function em(t, e) {
  if (e && (us(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Cu(t);
}
function Ys(t) {
  return Ys = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, Ys(t);
}
function Fu(t, e, n) {
  return e = VM(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function x6(t) {
  if (Array.isArray(t))
    return t;
}
function b6(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function N2(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, a = new Array(e); n < e; n++)
    a[n] = t[n];
  return a;
}
function w6(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return N2(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set")
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return N2(t, e);
  }
}
function E6() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function S6(t) {
  return x6(t) || b6(t) || w6(t) || E6();
}
function R2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function z2(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? R2(Object(n), !0).forEach(function(a) {
      Fu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : R2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
var T6 = {
  type: "logger",
  log: function(e) {
    this.output("log", e);
  },
  warn: function(e) {
    this.output("warn", e);
  },
  error: function(e) {
    this.output("error", e);
  },
  output: function(e, n) {
    console && console[e] && console[e].apply(console, n);
  }
}, M6 = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Qs(this, t), this.init(e, n);
  }
  return el(t, [{
    key: "init",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = a.prefix || "i18next:", this.logger = n || T6, this.options = a, this.debug = a.debug;
    }
  }, {
    key: "setDebug",
    value: function(n) {
      this.debug = n;
    }
  }, {
    key: "log",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(n, a, s, f) {
      return f && !this.debug ? null : (typeof n[0] == "string" && (n[0] = "".concat(s).concat(this.prefix, " ").concat(n[0])), this.logger[a](n));
    }
  }, {
    key: "create",
    value: function(n) {
      return new t(this.logger, z2(z2({}, {
        prefix: "".concat(this.prefix, ":").concat(n, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function(n) {
      return n = n || this.options, n.prefix = n.prefix || this.prefix, new t(this.logger, n);
    }
  }]), t;
}(), Gs = new M6(), Nu = function() {
  function t() {
    Qs(this, t), this.observers = {};
  }
  return el(t, [{
    key: "on",
    value: function(n, a) {
      var s = this;
      return n.split(" ").forEach(function(f) {
        s.observers[f] = s.observers[f] || [], s.observers[f].push(a);
      }), this;
    }
  }, {
    key: "off",
    value: function(n, a) {
      if (!!this.observers[n]) {
        if (!a) {
          delete this.observers[n];
          return;
        }
        this.observers[n] = this.observers[n].filter(function(s) {
          return s !== a;
        });
      }
    }
  }, {
    key: "emit",
    value: function(n) {
      for (var a = arguments.length, s = new Array(a > 1 ? a - 1 : 0), f = 1; f < a; f++)
        s[f - 1] = arguments[f];
      if (this.observers[n]) {
        var o = [].concat(this.observers[n]);
        o.forEach(function(g) {
          g.apply(void 0, s);
        });
      }
      if (this.observers["*"]) {
        var m = [].concat(this.observers["*"]);
        m.forEach(function(g) {
          g.apply(g, [n].concat(s));
        });
      }
    }
  }]), t;
}();
function Zp() {
  var t, e, n = new Promise(function(a, s) {
    t = a, e = s;
  });
  return n.resolve = t, n.reject = e, n;
}
function F2(t) {
  return t == null ? "" : "" + t;
}
function I6(t, e, n) {
  t.forEach(function(a) {
    e[a] && (n[a] = e[a]);
  });
}
function X1(t, e, n) {
  function a(m) {
    return m && m.indexOf("###") > -1 ? m.replace(/###/g, ".") : m;
  }
  function s() {
    return !t || typeof t == "string";
  }
  for (var f = typeof e != "string" ? [].concat(e) : e.split("."); f.length > 1; ) {
    if (s())
      return {};
    var o = a(f.shift());
    !t[o] && n && (t[o] = new n()), Object.prototype.hasOwnProperty.call(t, o) ? t = t[o] : t = {};
  }
  return s() ? {} : {
    obj: t,
    k: a(f.shift())
  };
}
function B2(t, e, n) {
  var a = X1(t, e, Object), s = a.obj, f = a.k;
  s[f] = n;
}
function O6(t, e, n, a) {
  var s = X1(t, e, Object), f = s.obj, o = s.k;
  f[o] = f[o] || [], a && (f[o] = f[o].concat(n)), a || f[o].push(n);
}
function Gg(t, e) {
  var n = X1(t, e), a = n.obj, s = n.k;
  if (!!a)
    return a[s];
}
function V2(t, e, n) {
  var a = Gg(t, n);
  return a !== void 0 ? a : Gg(e, n);
}
function UM(t, e, n) {
  for (var a in e)
    a !== "__proto__" && a !== "constructor" && (a in t ? typeof t[a] == "string" || t[a] instanceof String || typeof e[a] == "string" || e[a] instanceof String ? n && (t[a] = e[a]) : UM(t[a], e[a], n) : t[a] = e[a]);
  return t;
}
function tf(t) {
  return t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var C6 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function A6(t) {
  return typeof t == "string" ? t.replace(/[&<>"'\/]/g, function(e) {
    return C6[e];
  }) : t;
}
var Cv = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, P6 = [" ", ",", "?", "!", ";"];
function k6(t, e, n) {
  e = e || "", n = n || "";
  var a = P6.filter(function(m) {
    return e.indexOf(m) < 0 && n.indexOf(m) < 0;
  });
  if (a.length === 0)
    return !0;
  var s = new RegExp("(".concat(a.map(function(m) {
    return m === "?" ? "\\?" : m;
  }).join("|"), ")")), f = !s.test(t);
  if (!f) {
    var o = t.indexOf(n);
    o > 0 && !s.test(t.substring(0, o)) && (f = !0);
  }
  return f;
}
function U2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Ny(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? U2(Object(n), !0).forEach(function(a) {
      Fu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : U2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function L6(t) {
  var e = D6();
  return function() {
    var a = Ys(t), s;
    if (e) {
      var f = Ys(this).constructor;
      s = Reflect.construct(a, arguments, f);
    } else
      s = a.apply(this, arguments);
    return em(this, s);
  };
}
function D6() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function jM(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!!t) {
    if (t[e])
      return t[e];
    for (var a = e.split(n), s = t, f = 0; f < a.length; ++f) {
      if (!s || typeof s[a[f]] == "string" && f + 1 < a.length)
        return;
      if (s[a[f]] === void 0) {
        for (var o = 2, m = a.slice(f, f + o).join(n), g = s[m]; g === void 0 && a.length > f + o; )
          o++, m = a.slice(f, f + o).join(n), g = s[m];
        if (g === void 0)
          return;
        if (g === null)
          return null;
        if (e.endsWith(m)) {
          if (typeof g == "string")
            return g;
          if (m && typeof g[m] == "string")
            return g[m];
        }
        var b = a.slice(f + o).join(n);
        return b ? jM(g, b, n) : void 0;
      }
      s = s[a[f]];
    }
    return s;
  }
}
var N6 = function(t) {
  Ov(n, t);
  var e = L6(n);
  function n(a) {
    var s, f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return Qs(this, n), s = e.call(this), Cv && Nu.call(Cu(s)), s.data = a || {}, s.options = f, s.options.keySeparator === void 0 && (s.options.keySeparator = "."), s.options.ignoreJSONStructure === void 0 && (s.options.ignoreJSONStructure = !0), s;
  }
  return el(n, [{
    key: "addNamespaces",
    value: function(s) {
      this.options.ns.indexOf(s) < 0 && this.options.ns.push(s);
    }
  }, {
    key: "removeNamespaces",
    value: function(s) {
      var f = this.options.ns.indexOf(s);
      f > -1 && this.options.ns.splice(f, 1);
    }
  }, {
    key: "getResource",
    value: function(s, f, o) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, g = m.keySeparator !== void 0 ? m.keySeparator : this.options.keySeparator, b = m.ignoreJSONStructure !== void 0 ? m.ignoreJSONStructure : this.options.ignoreJSONStructure, T = [s, f];
      o && typeof o != "string" && (T = T.concat(o)), o && typeof o == "string" && (T = T.concat(g ? o.split(g) : o)), s.indexOf(".") > -1 && (T = s.split("."));
      var M = Gg(this.data, T);
      return M || !b || typeof o != "string" ? M : jM(this.data && this.data[s] && this.data[s][f], o, g);
    }
  }, {
    key: "addResource",
    value: function(s, f, o, m) {
      var g = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, b = this.options.keySeparator;
      b === void 0 && (b = ".");
      var T = [s, f];
      o && (T = T.concat(b ? o.split(b) : o)), s.indexOf(".") > -1 && (T = s.split("."), m = f, f = T[1]), this.addNamespaces(f), B2(this.data, T, m), g.silent || this.emit("added", s, f, o, m);
    }
  }, {
    key: "addResources",
    value: function(s, f, o) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var g in o)
        (typeof o[g] == "string" || Object.prototype.toString.apply(o[g]) === "[object Array]") && this.addResource(s, f, g, o[g], {
          silent: !0
        });
      m.silent || this.emit("added", s, f, o);
    }
  }, {
    key: "addResourceBundle",
    value: function(s, f, o, m, g) {
      var b = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, T = [s, f];
      s.indexOf(".") > -1 && (T = s.split("."), m = o, o = f, f = T[1]), this.addNamespaces(f);
      var M = Gg(this.data, T) || {};
      m ? UM(M, o, g) : M = Ny(Ny({}, M), o), B2(this.data, T, M), b.silent || this.emit("added", s, f, o);
    }
  }, {
    key: "removeResourceBundle",
    value: function(s, f) {
      this.hasResourceBundle(s, f) && delete this.data[s][f], this.removeNamespaces(f), this.emit("removed", s, f);
    }
  }, {
    key: "hasResourceBundle",
    value: function(s, f) {
      return this.getResource(s, f) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(s, f) {
      return f || (f = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? Ny(Ny({}, {}), this.getResource(s, f)) : this.getResource(s, f);
    }
  }, {
    key: "getDataByLanguage",
    value: function(s) {
      return this.data[s];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function(s) {
      var f = this.getDataByLanguage(s), o = f && Object.keys(f) || [];
      return !!o.find(function(m) {
        return f[m] && Object.keys(f[m]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), n;
}(Nu), GM = {
  processors: {},
  addPostProcessor: function(e) {
    this.processors[e.name] = e;
  },
  handle: function(e, n, a, s, f) {
    var o = this;
    return e.forEach(function(m) {
      o.processors[m] && (n = o.processors[m].process(n, a, s, f));
    }), n;
  }
};
function j2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Po(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? j2(Object(n), !0).forEach(function(a) {
      Fu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : j2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function R6(t) {
  var e = z6();
  return function() {
    var a = Ys(t), s;
    if (e) {
      var f = Ys(this).constructor;
      s = Reflect.construct(a, arguments, f);
    } else
      s = a.apply(this, arguments);
    return em(this, s);
  };
}
function z6() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var G2 = {}, q2 = function(t) {
  Ov(n, t);
  var e = R6(n);
  function n(a) {
    var s, f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Qs(this, n), s = e.call(this), Cv && Nu.call(Cu(s)), I6(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], a, Cu(s)), s.options = f, s.options.keySeparator === void 0 && (s.options.keySeparator = "."), s.logger = Gs.create("translator"), s;
  }
  return el(n, [{
    key: "changeLanguage",
    value: function(s) {
      s && (this.language = s);
    }
  }, {
    key: "exists",
    value: function(s) {
      var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (s == null)
        return !1;
      var o = this.resolve(s, f);
      return o && o.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(s, f) {
      var o = f.nsSeparator !== void 0 ? f.nsSeparator : this.options.nsSeparator;
      o === void 0 && (o = ":");
      var m = f.keySeparator !== void 0 ? f.keySeparator : this.options.keySeparator, g = f.ns || this.options.defaultNS || [], b = o && s.indexOf(o) > -1, T = !this.options.userDefinedKeySeparator && !f.keySeparator && !this.options.userDefinedNsSeparator && !f.nsSeparator && !k6(s, o, m);
      if (b && !T) {
        var M = s.match(this.interpolator.nestingRegexp);
        if (M && M.length > 0)
          return {
            key: s,
            namespaces: g
          };
        var I = s.split(o);
        (o !== m || o === m && this.options.ns.indexOf(I[0]) > -1) && (g = I.shift()), s = I.join(m);
      }
      return typeof g == "string" && (g = [g]), {
        key: s,
        namespaces: g
      };
    }
  }, {
    key: "translate",
    value: function(s, f, o) {
      var m = this;
      if (us(f) !== "object" && this.options.overloadTranslationOptionHandler && (f = this.options.overloadTranslationOptionHandler(arguments)), f || (f = {}), s == null)
        return "";
      Array.isArray(s) || (s = [String(s)]);
      var g = f.returnDetails !== void 0 ? f.returnDetails : this.options.returnDetails, b = f.keySeparator !== void 0 ? f.keySeparator : this.options.keySeparator, T = this.extractFromKey(s[s.length - 1], f), M = T.key, I = T.namespaces, A = I[I.length - 1], z = f.lng || this.language, V = f.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (z && z.toLowerCase() === "cimode") {
        if (V) {
          var Z = f.nsSeparator || this.options.nsSeparator;
          return g ? {
            res: "".concat(A).concat(Z).concat(M),
            usedKey: M,
            exactUsedKey: M,
            usedLng: z,
            usedNS: A
          } : "".concat(A).concat(Z).concat(M);
        }
        return g ? {
          res: M,
          usedKey: M,
          exactUsedKey: M,
          usedLng: z,
          usedNS: A
        } : M;
      }
      var X = this.resolve(s, f), Y = X && X.res, de = X && X.usedKey || M, ye = X && X.exactUsedKey || M, Ie = Object.prototype.toString.apply(Y), Be = ["[object Number]", "[object Function]", "[object RegExp]"], De = f.joinArrays !== void 0 ? f.joinArrays : this.options.joinArrays, Re = !this.i18nFormat || this.i18nFormat.handleAsObject, Ee = typeof Y != "string" && typeof Y != "boolean" && typeof Y != "number";
      if (Re && Y && Ee && Be.indexOf(Ie) < 0 && !(typeof De == "string" && Ie === "[object Array]")) {
        if (!f.returnObjects && !this.options.returnObjects) {
          this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          var ze = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(de, Y, Po(Po({}, f), {}, {
            ns: I
          })) : "key '".concat(M, " (").concat(this.language, ")' returned an object instead of string.");
          return g ? (X.res = ze, X) : ze;
        }
        if (b) {
          var rt = Ie === "[object Array]", Ze = rt ? [] : {}, yt = rt ? ye : de;
          for (var xe in Y)
            if (Object.prototype.hasOwnProperty.call(Y, xe)) {
              var Ke = "".concat(yt).concat(b).concat(xe);
              Ze[xe] = this.translate(Ke, Po(Po({}, f), {
                joinArrays: !1,
                ns: I
              })), Ze[xe] === Ke && (Ze[xe] = Y[xe]);
            }
          Y = Ze;
        }
      } else if (Re && typeof De == "string" && Ie === "[object Array]")
        Y = Y.join(De), Y && (Y = this.extendTranslation(Y, s, f, o));
      else {
        var ct = !1, vt = !1, Pt = f.count !== void 0 && typeof f.count != "string", tr = n.hasDefaultValue(f), Pn = Pt ? this.pluralResolver.getSuffix(z, f.count, f) : "", Dr = f["defaultValue".concat(Pn)] || f.defaultValue;
        !this.isValidLookup(Y) && tr && (ct = !0, Y = Dr), this.isValidLookup(Y) || (vt = !0, Y = M);
        var hr = f.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, Zn = hr && vt ? void 0 : Y, Nr = tr && Dr !== Y && this.options.updateMissing;
        if (vt || ct || Nr) {
          if (this.logger.log(Nr ? "updateKey" : "missingKey", z, A, M, Nr ? Dr : Y), b) {
            var Fi = this.resolve(M, Po(Po({}, f), {}, {
              keySeparator: !1
            }));
            Fi && Fi.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var Gr = [], Cr = this.languageUtils.getFallbackCodes(this.options.fallbackLng, f.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && Cr && Cr[0])
            for (var Vn = 0; Vn < Cr.length; Vn++)
              Gr.push(Cr[Vn]);
          else
            this.options.saveMissingTo === "all" ? Gr = this.languageUtils.toResolveHierarchy(f.lng || this.language) : Gr.push(f.lng || this.language);
          var wr = function(oi, Un, K) {
            var me = tr && K !== Y ? K : Zn;
            m.options.missingKeyHandler ? m.options.missingKeyHandler(oi, A, Un, me, Nr, f) : m.backendConnector && m.backendConnector.saveMissing && m.backendConnector.saveMissing(oi, A, Un, me, Nr, f), m.emit("missingKey", oi, A, Un, Y);
          };
          this.options.saveMissing && (this.options.saveMissingPlurals && Pt ? Gr.forEach(function(En) {
            m.pluralResolver.getSuffixes(En, f).forEach(function(oi) {
              wr([En], M + oi, f["defaultValue".concat(oi)] || Dr);
            });
          }) : wr(Gr, M, Dr));
        }
        Y = this.extendTranslation(Y, s, f, X, o), vt && Y === M && this.options.appendNamespaceToMissingKey && (Y = "".concat(A, ":").concat(M)), (vt || ct) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? Y = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(A, ":").concat(M) : M, ct ? Y : void 0) : Y = this.options.parseMissingKeyHandler(Y));
      }
      return g ? (X.res = Y, X) : Y;
    }
  }, {
    key: "extendTranslation",
    value: function(s, f, o, m, g) {
      var b = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        s = this.i18nFormat.parse(s, Po(Po({}, this.options.interpolation.defaultVariables), o), m.usedLng, m.usedNS, m.usedKey, {
          resolved: m
        });
      else if (!o.skipInterpolation) {
        o.interpolation && this.interpolator.init(Po(Po({}, o), {
          interpolation: Po(Po({}, this.options.interpolation), o.interpolation)
        }));
        var T = typeof s == "string" && (o && o.interpolation && o.interpolation.skipOnVariables !== void 0 ? o.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), M;
        if (T) {
          var I = s.match(this.interpolator.nestingRegexp);
          M = I && I.length;
        }
        var A = o.replace && typeof o.replace != "string" ? o.replace : o;
        if (this.options.interpolation.defaultVariables && (A = Po(Po({}, this.options.interpolation.defaultVariables), A)), s = this.interpolator.interpolate(s, A, o.lng || this.language, o), T) {
          var z = s.match(this.interpolator.nestingRegexp), V = z && z.length;
          M < V && (o.nest = !1);
        }
        o.nest !== !1 && (s = this.interpolator.nest(s, function() {
          for (var Y = arguments.length, de = new Array(Y), ye = 0; ye < Y; ye++)
            de[ye] = arguments[ye];
          return g && g[0] === de[0] && !o.context ? (b.logger.warn("It seems you are nesting recursively key: ".concat(de[0], " in key: ").concat(f[0])), null) : b.translate.apply(b, de.concat([f]));
        }, o)), o.interpolation && this.interpolator.reset();
      }
      var Z = o.postProcess || this.options.postProcess, X = typeof Z == "string" ? [Z] : Z;
      return s != null && X && X.length && o.applyPostProcessor !== !1 && (s = GM.handle(X, s, f, this.options && this.options.postProcessPassResolved ? Po({
        i18nResolved: m
      }, o) : o, this)), s;
    }
  }, {
    key: "resolve",
    value: function(s) {
      var f = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, m, g, b, T, M;
      return typeof s == "string" && (s = [s]), s.forEach(function(I) {
        if (!f.isValidLookup(m)) {
          var A = f.extractFromKey(I, o), z = A.key;
          g = z;
          var V = A.namespaces;
          f.options.fallbackNS && (V = V.concat(f.options.fallbackNS));
          var Z = o.count !== void 0 && typeof o.count != "string", X = Z && !o.ordinal && o.count === 0 && f.pluralResolver.shouldUseIntlApi(), Y = o.context !== void 0 && (typeof o.context == "string" || typeof o.context == "number") && o.context !== "", de = o.lngs ? o.lngs : f.languageUtils.toResolveHierarchy(o.lng || f.language, o.fallbackLng);
          V.forEach(function(ye) {
            f.isValidLookup(m) || (M = ye, !G2["".concat(de[0], "-").concat(ye)] && f.utils && f.utils.hasLoadedNamespace && !f.utils.hasLoadedNamespace(M) && (G2["".concat(de[0], "-").concat(ye)] = !0, f.logger.warn('key "'.concat(g, '" for languages "').concat(de.join(", "), `" won't get resolved as namespace "`).concat(M, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), de.forEach(function(Ie) {
              if (!f.isValidLookup(m)) {
                T = Ie;
                var Be = [z];
                if (f.i18nFormat && f.i18nFormat.addLookupKeys)
                  f.i18nFormat.addLookupKeys(Be, z, Ie, ye, o);
                else {
                  var De;
                  Z && (De = f.pluralResolver.getSuffix(Ie, o.count, o));
                  var Re = "".concat(f.options.pluralSeparator, "zero");
                  if (Z && (Be.push(z + De), X && Be.push(z + Re)), Y) {
                    var Ee = "".concat(z).concat(f.options.contextSeparator).concat(o.context);
                    Be.push(Ee), Z && (Be.push(Ee + De), X && Be.push(Ee + Re));
                  }
                }
                for (var ze; ze = Be.pop(); )
                  f.isValidLookup(m) || (b = ze, m = f.getResource(Ie, ye, ze, o));
              }
            }));
          });
        }
      }), {
        res: m,
        usedKey: g,
        exactUsedKey: b,
        usedLng: T,
        usedNS: M
      };
    }
  }, {
    key: "isValidLookup",
    value: function(s) {
      return s !== void 0 && !(!this.options.returnNull && s === null) && !(!this.options.returnEmptyString && s === "");
    }
  }, {
    key: "getResource",
    value: function(s, f, o) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(s, f, o, m) : this.resourceStore.getResource(s, f, o, m);
    }
  }], [{
    key: "hasDefaultValue",
    value: function(s) {
      var f = "defaultValue";
      for (var o in s)
        if (Object.prototype.hasOwnProperty.call(s, o) && f === o.substring(0, f.length) && s[o] !== void 0)
          return !0;
      return !1;
    }
  }]), n;
}(Nu);
function J_(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
var $2 = function() {
  function t(e) {
    Qs(this, t), this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Gs.create("languageUtils");
  }
  return el(t, [{
    key: "getScriptPartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return null;
      var a = n.split("-");
      return a.length === 2 || (a.pop(), a[a.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(a.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return n;
      var a = n.split("-");
      return this.formatLanguageCode(a[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(n) {
      if (typeof n == "string" && n.indexOf("-") > -1) {
        var a = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], s = n.split("-");
        return this.options.lowerCaseLng ? s = s.map(function(f) {
          return f.toLowerCase();
        }) : s.length === 2 ? (s[0] = s[0].toLowerCase(), s[1] = s[1].toUpperCase(), a.indexOf(s[1].toLowerCase()) > -1 && (s[1] = J_(s[1].toLowerCase()))) : s.length === 3 && (s[0] = s[0].toLowerCase(), s[1].length === 2 && (s[1] = s[1].toUpperCase()), s[0] !== "sgn" && s[2].length === 2 && (s[2] = s[2].toUpperCase()), a.indexOf(s[1].toLowerCase()) > -1 && (s[1] = J_(s[1].toLowerCase())), a.indexOf(s[2].toLowerCase()) > -1 && (s[2] = J_(s[2].toLowerCase()))), s.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? n.toLowerCase() : n;
    }
  }, {
    key: "isSupportedCode",
    value: function(n) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (n = this.getLanguagePartFromCode(n)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(n) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function(n) {
      var a = this;
      if (!n)
        return null;
      var s;
      return n.forEach(function(f) {
        if (!s) {
          var o = a.formatLanguageCode(f);
          (!a.options.supportedLngs || a.isSupportedCode(o)) && (s = o);
        }
      }), !s && this.options.supportedLngs && n.forEach(function(f) {
        if (!s) {
          var o = a.getLanguagePartFromCode(f);
          if (a.isSupportedCode(o))
            return s = o;
          s = a.options.supportedLngs.find(function(m) {
            if (m.indexOf(o) === 0)
              return m;
          });
        }
      }), s || (s = this.getFallbackCodes(this.options.fallbackLng)[0]), s;
    }
  }, {
    key: "getFallbackCodes",
    value: function(n, a) {
      if (!n)
        return [];
      if (typeof n == "function" && (n = n(a)), typeof n == "string" && (n = [n]), Object.prototype.toString.apply(n) === "[object Array]")
        return n;
      if (!a)
        return n.default || [];
      var s = n[a];
      return s || (s = n[this.getScriptPartFromCode(a)]), s || (s = n[this.formatLanguageCode(a)]), s || (s = n[this.getLanguagePartFromCode(a)]), s || (s = n.default), s || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(n, a) {
      var s = this, f = this.getFallbackCodes(a || this.options.fallbackLng || [], n), o = [], m = function(b) {
        !b || (s.isSupportedCode(b) ? o.push(b) : s.logger.warn("rejecting language code not found in supportedLngs: ".concat(b)));
      };
      return typeof n == "string" && n.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && m(this.formatLanguageCode(n)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && m(this.getScriptPartFromCode(n)), this.options.load !== "currentOnly" && m(this.getLanguagePartFromCode(n))) : typeof n == "string" && m(this.formatLanguageCode(n)), f.forEach(function(g) {
        o.indexOf(g) < 0 && m(s.formatLanguageCode(g));
      }), o;
    }
  }]), t;
}(), F6 = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], B6 = {
  1: function(e) {
    return Number(e > 1);
  },
  2: function(e) {
    return Number(e != 1);
  },
  3: function(e) {
    return 0;
  },
  4: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  5: function(e) {
    return Number(e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5);
  },
  6: function(e) {
    return Number(e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2);
  },
  7: function(e) {
    return Number(e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  8: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3);
  },
  9: function(e) {
    return Number(e >= 2);
  },
  10: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4);
  },
  11: function(e) {
    return Number(e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3);
  },
  12: function(e) {
    return Number(e % 10 != 1 || e % 100 == 11);
  },
  13: function(e) {
    return Number(e !== 0);
  },
  14: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3);
  },
  15: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  16: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2);
  },
  17: function(e) {
    return Number(e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1);
  },
  18: function(e) {
    return Number(e == 0 ? 0 : e == 1 ? 1 : 2);
  },
  19: function(e) {
    return Number(e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3);
  },
  20: function(e) {
    return Number(e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2);
  },
  21: function(e) {
    return Number(e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0);
  },
  22: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3);
  }
}, V6 = ["v1", "v2", "v3"], W2 = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function U6() {
  var t = {};
  return F6.forEach(function(e) {
    e.lngs.forEach(function(n) {
      t[n] = {
        numbers: e.nr,
        plurals: B6[e.fc]
      };
    });
  }), t;
}
var j6 = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Qs(this, t), this.languageUtils = e, this.options = n, this.logger = Gs.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = U6();
  }
  return el(t, [{
    key: "addRule",
    value: function(n, a) {
      this.rules[n] = a;
    }
  }, {
    key: "getRule",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
        try {
          return new Intl.PluralRules(n, {
            type: a.ordinal ? "ordinal" : "cardinal"
          });
        } catch {
          return;
        }
      return this.rules[n] || this.rules[this.languageUtils.getLanguagePartFromCode(n)];
    }
  }, {
    key: "needsPlural",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = this.getRule(n, a);
      return this.shouldUseIntlApi() ? s && s.resolvedOptions().pluralCategories.length > 1 : s && s.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(n, a) {
      var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(n, s).map(function(f) {
        return "".concat(a).concat(f);
      });
    }
  }, {
    key: "getSuffixes",
    value: function(n) {
      var a = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = this.getRule(n, s);
      return f ? this.shouldUseIntlApi() ? f.resolvedOptions().pluralCategories.sort(function(o, m) {
        return W2[o] - W2[m];
      }).map(function(o) {
        return "".concat(a.options.prepend).concat(o);
      }) : f.numbers.map(function(o) {
        return a.getSuffix(n, o, s);
      }) : [];
    }
  }, {
    key: "getSuffix",
    value: function(n, a) {
      var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, f = this.getRule(n, s);
      return f ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(f.select(a)) : this.getSuffixRetroCompatible(f, a) : (this.logger.warn("no plural rule found for: ".concat(n)), "");
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function(n, a) {
      var s = this, f = n.noAbs ? n.plurals(a) : n.plurals(Math.abs(a)), o = n.numbers[f];
      this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 && (o === 2 ? o = "plural" : o === 1 && (o = ""));
      var m = function() {
        return s.options.prepend && o.toString() ? s.options.prepend + o.toString() : o.toString();
      };
      return this.options.compatibilityJSON === "v1" ? o === 1 ? "" : typeof o == "number" ? "_plural_".concat(o.toString()) : m() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 ? m() : this.options.prepend && f.toString() ? this.options.prepend + f.toString() : f.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function() {
      return !V6.includes(this.options.compatibilityJSON);
    }
  }]), t;
}();
function H2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Ya(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? H2(Object(n), !0).forEach(function(a) {
      Fu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : H2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
var G6 = function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Qs(this, t), this.logger = Gs.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || function(n) {
      return n;
    }, this.init(e);
  }
  return el(t, [{
    key: "init",
    value: function() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      n.interpolation || (n.interpolation = {
        escapeValue: !0
      });
      var a = n.interpolation;
      this.escape = a.escape !== void 0 ? a.escape : A6, this.escapeValue = a.escapeValue !== void 0 ? a.escapeValue : !0, this.useRawValueToEscape = a.useRawValueToEscape !== void 0 ? a.useRawValueToEscape : !1, this.prefix = a.prefix ? tf(a.prefix) : a.prefixEscaped || "{{", this.suffix = a.suffix ? tf(a.suffix) : a.suffixEscaped || "}}", this.formatSeparator = a.formatSeparator ? a.formatSeparator : a.formatSeparator || ",", this.unescapePrefix = a.unescapeSuffix ? "" : a.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : a.unescapeSuffix || "", this.nestingPrefix = a.nestingPrefix ? tf(a.nestingPrefix) : a.nestingPrefixEscaped || tf("$t("), this.nestingSuffix = a.nestingSuffix ? tf(a.nestingSuffix) : a.nestingSuffixEscaped || tf(")"), this.nestingOptionsSeparator = a.nestingOptionsSeparator ? a.nestingOptionsSeparator : a.nestingOptionsSeparator || ",", this.maxReplaces = a.maxReplaces ? a.maxReplaces : 1e3, this.alwaysFormat = a.alwaysFormat !== void 0 ? a.alwaysFormat : !1, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var n = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(n, "g");
      var a = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(a, "g");
      var s = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(s, "g");
    }
  }, {
    key: "interpolate",
    value: function(n, a, s, f) {
      var o = this, m, g, b, T = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function M(Z) {
        return Z.replace(/\$/g, "$$$$");
      }
      var I = function(X) {
        if (X.indexOf(o.formatSeparator) < 0) {
          var Y = V2(a, T, X);
          return o.alwaysFormat ? o.format(Y, void 0, s, Ya(Ya(Ya({}, f), a), {}, {
            interpolationkey: X
          })) : Y;
        }
        var de = X.split(o.formatSeparator), ye = de.shift().trim(), Ie = de.join(o.formatSeparator).trim();
        return o.format(V2(a, T, ye), Ie, s, Ya(Ya(Ya({}, f), a), {}, {
          interpolationkey: ye
        }));
      };
      this.resetRegExp();
      var A = f && f.missingInterpolationHandler || this.options.missingInterpolationHandler, z = f && f.interpolation && f.interpolation.skipOnVariables !== void 0 ? f.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, V = [{
        regex: this.regexpUnescape,
        safeValue: function(X) {
          return M(X);
        }
      }, {
        regex: this.regexp,
        safeValue: function(X) {
          return o.escapeValue ? M(o.escape(X)) : M(X);
        }
      }];
      return V.forEach(function(Z) {
        for (b = 0; m = Z.regex.exec(n); ) {
          var X = m[1].trim();
          if (g = I(X), g === void 0)
            if (typeof A == "function") {
              var Y = A(n, m, f);
              g = typeof Y == "string" ? Y : "";
            } else if (f && Object.prototype.hasOwnProperty.call(f, X))
              g = "";
            else if (z) {
              g = m[0];
              continue;
            } else
              o.logger.warn("missed to pass in variable ".concat(X, " for interpolating ").concat(n)), g = "";
          else
            typeof g != "string" && !o.useRawValueToEscape && (g = F2(g));
          var de = Z.safeValue(g);
          if (n = n.replace(m[0], de), z ? (Z.regex.lastIndex += g.length, Z.regex.lastIndex -= m[0].length) : Z.regex.lastIndex = 0, b++, b >= o.maxReplaces)
            break;
        }
      }), n;
    }
  }, {
    key: "nest",
    value: function(n, a) {
      var s = this, f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o, m, g;
      function b(A, z) {
        var V = this.nestingOptionsSeparator;
        if (A.indexOf(V) < 0)
          return A;
        var Z = A.split(new RegExp("".concat(V, "[ ]*{"))), X = "{".concat(Z[1]);
        A = Z[0], X = this.interpolate(X, g);
        var Y = X.match(/'/g), de = X.match(/"/g);
        (Y && Y.length % 2 === 0 && !de || de.length % 2 !== 0) && (X = X.replace(/'/g, '"'));
        try {
          g = JSON.parse(X), z && (g = Ya(Ya({}, z), g));
        } catch (ye) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(A), ye), "".concat(A).concat(V).concat(X);
        }
        return delete g.defaultValue, A;
      }
      for (; o = this.nestingRegexp.exec(n); ) {
        var T = [];
        g = Ya({}, f), g = g.replace && typeof g.replace != "string" ? g.replace : g, g.applyPostProcessor = !1, delete g.defaultValue;
        var M = !1;
        if (o[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(o[1])) {
          var I = o[1].split(this.formatSeparator).map(function(A) {
            return A.trim();
          });
          o[1] = I.shift(), T = I, M = !0;
        }
        if (m = a(b.call(this, o[1].trim(), g), g), m && o[0] === n && typeof m != "string")
          return m;
        typeof m != "string" && (m = F2(m)), m || (this.logger.warn("missed to resolve ".concat(o[1], " for nesting ").concat(n)), m = ""), M && (m = T.reduce(function(A, z) {
          return s.format(A, z, f.lng, Ya(Ya({}, f), {}, {
            interpolationkey: o[1].trim()
          }));
        }, m.trim())), n = n.replace(o[0], m), this.regexp.lastIndex = 0;
      }
      return n;
    }
  }]), t;
}();
function Z2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Cl(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Z2(Object(n), !0).forEach(function(a) {
      Fu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Z2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function q6(t) {
  var e = t.toLowerCase().trim(), n = {};
  if (t.indexOf("(") > -1) {
    var a = t.split("(");
    e = a[0].toLowerCase().trim();
    var s = a[1].substring(0, a[1].length - 1);
    if (e === "currency" && s.indexOf(":") < 0)
      n.currency || (n.currency = s.trim());
    else if (e === "relativetime" && s.indexOf(":") < 0)
      n.range || (n.range = s.trim());
    else {
      var f = s.split(";");
      f.forEach(function(o) {
        if (!!o) {
          var m = o.split(":"), g = S6(m), b = g[0], T = g.slice(1), M = T.join(":").trim().replace(/^'+|'+$/g, "");
          n[b.trim()] || (n[b.trim()] = M), M === "false" && (n[b.trim()] = !1), M === "true" && (n[b.trim()] = !0), isNaN(M) || (n[b.trim()] = parseInt(M, 10));
        }
      });
    }
  }
  return {
    formatName: e,
    formatOptions: n
  };
}
function rf(t) {
  var e = {};
  return function(a, s, f) {
    var o = s + JSON.stringify(f), m = e[o];
    return m || (m = t(s, f), e[o] = m), m(a);
  };
}
var $6 = function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Qs(this, t), this.logger = Gs.create("formatter"), this.options = e, this.formats = {
      number: rf(function(n, a) {
        var s = new Intl.NumberFormat(n, Cl({}, a));
        return function(f) {
          return s.format(f);
        };
      }),
      currency: rf(function(n, a) {
        var s = new Intl.NumberFormat(n, Cl(Cl({}, a), {}, {
          style: "currency"
        }));
        return function(f) {
          return s.format(f);
        };
      }),
      datetime: rf(function(n, a) {
        var s = new Intl.DateTimeFormat(n, Cl({}, a));
        return function(f) {
          return s.format(f);
        };
      }),
      relativetime: rf(function(n, a) {
        var s = new Intl.RelativeTimeFormat(n, Cl({}, a));
        return function(f) {
          return s.format(f, a.range || "day");
        };
      }),
      list: rf(function(n, a) {
        var s = new Intl.ListFormat(n, Cl({}, a));
        return function(f) {
          return s.format(f);
        };
      })
    }, this.init(e);
  }
  return el(t, [{
    key: "init",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, s = a.interpolation;
      this.formatSeparator = s.formatSeparator ? s.formatSeparator : s.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function(n, a) {
      this.formats[n.toLowerCase().trim()] = a;
    }
  }, {
    key: "addCached",
    value: function(n, a) {
      this.formats[n.toLowerCase().trim()] = rf(a);
    }
  }, {
    key: "format",
    value: function(n, a, s) {
      var f = this, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, m = a.split(this.formatSeparator), g = m.reduce(function(b, T) {
        var M = q6(T), I = M.formatName, A = M.formatOptions;
        if (f.formats[I]) {
          var z = b;
          try {
            var V = o && o.formatParams && o.formatParams[o.interpolationkey] || {}, Z = V.locale || V.lng || o.locale || o.lng || s;
            z = f.formats[I](b, Z, Cl(Cl(Cl({}, A), o), V));
          } catch (X) {
            f.logger.warn(X);
          }
          return z;
        } else
          f.logger.warn("there was no format function for ".concat(I));
        return b;
      }, n);
      return g;
    }
  }]), t;
}();
function X2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function K2(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? X2(Object(n), !0).forEach(function(a) {
      Fu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : X2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function W6(t) {
  var e = H6();
  return function() {
    var a = Ys(t), s;
    if (e) {
      var f = Ys(this).constructor;
      s = Reflect.construct(a, arguments, f);
    } else
      s = a.apply(this, arguments);
    return em(this, s);
  };
}
function H6() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Z6(t, e) {
  t.pending[e] !== void 0 && (delete t.pending[e], t.pendingCount--);
}
var X6 = function(t) {
  Ov(n, t);
  var e = W6(n);
  function n(a, s, f) {
    var o, m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return Qs(this, n), o = e.call(this), Cv && Nu.call(Cu(o)), o.backend = a, o.store = s, o.services = f, o.languageUtils = f.languageUtils, o.options = m, o.logger = Gs.create("backendConnector"), o.waitingReads = [], o.maxParallelReads = m.maxParallelReads || 10, o.readingCalls = 0, o.maxRetries = m.maxRetries >= 0 ? m.maxRetries : 5, o.retryTimeout = m.retryTimeout >= 1 ? m.retryTimeout : 350, o.state = {}, o.queue = [], o.backend && o.backend.init && o.backend.init(f, m.backend, m), o;
  }
  return el(n, [{
    key: "queueLoad",
    value: function(s, f, o, m) {
      var g = this, b = {}, T = {}, M = {}, I = {};
      return s.forEach(function(A) {
        var z = !0;
        f.forEach(function(V) {
          var Z = "".concat(A, "|").concat(V);
          !o.reload && g.store.hasResourceBundle(A, V) ? g.state[Z] = 2 : g.state[Z] < 0 || (g.state[Z] === 1 ? T[Z] === void 0 && (T[Z] = !0) : (g.state[Z] = 1, z = !1, T[Z] === void 0 && (T[Z] = !0), b[Z] === void 0 && (b[Z] = !0), I[V] === void 0 && (I[V] = !0)));
        }), z || (M[A] = !0);
      }), (Object.keys(b).length || Object.keys(T).length) && this.queue.push({
        pending: T,
        pendingCount: Object.keys(T).length,
        loaded: {},
        errors: [],
        callback: m
      }), {
        toLoad: Object.keys(b),
        pending: Object.keys(T),
        toLoadLanguages: Object.keys(M),
        toLoadNamespaces: Object.keys(I)
      };
    }
  }, {
    key: "loaded",
    value: function(s, f, o) {
      var m = s.split("|"), g = m[0], b = m[1];
      f && this.emit("failedLoading", g, b, f), o && this.store.addResourceBundle(g, b, o), this.state[s] = f ? -1 : 2;
      var T = {};
      this.queue.forEach(function(M) {
        O6(M.loaded, [g], b), Z6(M, s), f && M.errors.push(f), M.pendingCount === 0 && !M.done && (Object.keys(M.loaded).forEach(function(I) {
          T[I] || (T[I] = {});
          var A = M.loaded[I];
          A.length && A.forEach(function(z) {
            T[I][z] === void 0 && (T[I][z] = !0);
          });
        }), M.done = !0, M.errors.length ? M.callback(M.errors) : M.callback());
      }), this.emit("loaded", T), this.queue = this.queue.filter(function(M) {
        return !M.done;
      });
    }
  }, {
    key: "read",
    value: function(s, f, o) {
      var m = this, g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, b = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, T = arguments.length > 5 ? arguments[5] : void 0;
      if (!s.length)
        return T(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: s,
          ns: f,
          fcName: o,
          tried: g,
          wait: b,
          callback: T
        });
        return;
      }
      this.readingCalls++;
      var M = function(V, Z) {
        if (m.readingCalls--, m.waitingReads.length > 0) {
          var X = m.waitingReads.shift();
          m.read(X.lng, X.ns, X.fcName, X.tried, X.wait, X.callback);
        }
        if (V && Z && g < m.maxRetries) {
          setTimeout(function() {
            m.read.call(m, s, f, o, g + 1, b * 2, T);
          }, b);
          return;
        }
        T(V, Z);
      }, I = this.backend[o].bind(this.backend);
      if (I.length === 2) {
        try {
          var A = I(s, f);
          A && typeof A.then == "function" ? A.then(function(z) {
            return M(null, z);
          }).catch(M) : M(null, A);
        } catch (z) {
          M(z);
        }
        return;
      }
      return I(s, f, M);
    }
  }, {
    key: "prepareLoading",
    value: function(s, f) {
      var o = this, m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, g = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), g && g();
      typeof s == "string" && (s = this.languageUtils.toResolveHierarchy(s)), typeof f == "string" && (f = [f]);
      var b = this.queueLoad(s, f, m, g);
      if (!b.toLoad.length)
        return b.pending.length || g(), null;
      b.toLoad.forEach(function(T) {
        o.loadOne(T);
      });
    }
  }, {
    key: "load",
    value: function(s, f, o) {
      this.prepareLoading(s, f, {}, o);
    }
  }, {
    key: "reload",
    value: function(s, f, o) {
      this.prepareLoading(s, f, {
        reload: !0
      }, o);
    }
  }, {
    key: "loadOne",
    value: function(s) {
      var f = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", m = s.split("|"), g = m[0], b = m[1];
      this.read(g, b, "read", void 0, void 0, function(T, M) {
        T && f.logger.warn("".concat(o, "loading namespace ").concat(b, " for language ").concat(g, " failed"), T), !T && M && f.logger.log("".concat(o, "loaded namespace ").concat(b, " for language ").concat(g), M), f.loaded(s, T, M);
      });
    }
  }, {
    key: "saveMissing",
    value: function(s, f, o, m, g) {
      var b = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, T = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function() {
      };
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(f)) {
        this.logger.warn('did not save key "'.concat(o, '" as the namespace "').concat(f, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (!(o == null || o === "")) {
        if (this.backend && this.backend.create) {
          var M = K2(K2({}, b), {}, {
            isUpdate: g
          }), I = this.backend.create.bind(this.backend);
          if (I.length < 6)
            try {
              var A;
              I.length === 5 ? A = I(s, f, o, m, M) : A = I(s, f, o, m), A && typeof A.then == "function" ? A.then(function(z) {
                return T(null, z);
              }).catch(T) : T(null, A);
            } catch (z) {
              T(z);
            }
          else
            I(s, f, o, m, T, M);
        }
        !s || !s[0] || this.store.addResource(s[0], f, o, m);
      }
    }
  }]), n;
}(Nu);
function Y2() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      var n = {};
      if (us(e[1]) === "object" && (n = e[1]), typeof e[1] == "string" && (n.defaultValue = e[1]), typeof e[2] == "string" && (n.tDescription = e[2]), us(e[2]) === "object" || us(e[3]) === "object") {
        var a = e[3] || e[2];
        Object.keys(a).forEach(function(s) {
          n[s] = a[s];
        });
      }
      return n;
    },
    interpolation: {
      escapeValue: !0,
      format: function(e, n, a, s) {
        return e;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function J2(t) {
  return typeof t.ns == "string" && (t.ns = [t.ns]), typeof t.fallbackLng == "string" && (t.fallbackLng = [t.fallbackLng]), typeof t.fallbackNS == "string" && (t.fallbackNS = [t.fallbackNS]), t.supportedLngs && t.supportedLngs.indexOf("cimode") < 0 && (t.supportedLngs = t.supportedLngs.concat(["cimode"])), t;
}
function Q2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Rs(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Q2(Object(n), !0).forEach(function(a) {
      Fu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Q2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function K6(t) {
  var e = Y6();
  return function() {
    var a = Ys(t), s;
    if (e) {
      var f = Ys(this).constructor;
      s = Reflect.construct(a, arguments, f);
    } else
      s = a.apply(this, arguments);
    return em(this, s);
  };
}
function Y6() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ry() {
}
function J6(t) {
  var e = Object.getOwnPropertyNames(Object.getPrototypeOf(t));
  e.forEach(function(n) {
    typeof t[n] == "function" && (t[n] = t[n].bind(t));
  });
}
var qg = function(t) {
  Ov(n, t);
  var e = K6(n);
  function n() {
    var a, s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, f = arguments.length > 1 ? arguments[1] : void 0;
    if (Qs(this, n), a = e.call(this), Cv && Nu.call(Cu(a)), a.options = J2(s), a.services = {}, a.logger = Gs, a.modules = {
      external: []
    }, J6(Cu(a)), f && !a.isInitialized && !s.isClone) {
      if (!a.options.initImmediate)
        return a.init(s, f), em(a, Cu(a));
      setTimeout(function() {
        a.init(s, f);
      }, 0);
    }
    return a;
  }
  return el(n, [{
    key: "init",
    value: function() {
      var s = this, f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 ? arguments[1] : void 0;
      typeof f == "function" && (o = f, f = {}), !f.defaultNS && f.defaultNS !== !1 && f.ns && (typeof f.ns == "string" ? f.defaultNS = f.ns : f.ns.indexOf("translation") < 0 && (f.defaultNS = f.ns[0]));
      var m = Y2();
      this.options = Rs(Rs(Rs({}, m), this.options), J2(f)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = Rs(Rs({}, m.interpolation), this.options.interpolation)), f.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = f.keySeparator), f.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = f.nsSeparator);
      function g(X) {
        return X ? typeof X == "function" ? new X() : X : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? Gs.init(g(this.modules.logger), this.options) : Gs.init(null, this.options);
        var b;
        this.modules.formatter ? b = this.modules.formatter : typeof Intl < "u" && (b = $6);
        var T = new $2(this.options);
        this.store = new N6(this.options.resources, this.options);
        var M = this.services;
        M.logger = Gs, M.resourceStore = this.store, M.languageUtils = T, M.pluralResolver = new j6(T, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), b && (!this.options.interpolation.format || this.options.interpolation.format === m.interpolation.format) && (M.formatter = g(b), M.formatter.init(M, this.options), this.options.interpolation.format = M.formatter.format.bind(M.formatter)), M.interpolator = new G6(this.options), M.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, M.backendConnector = new X6(g(this.modules.backend), M.resourceStore, M, this.options), M.backendConnector.on("*", function(X) {
          for (var Y = arguments.length, de = new Array(Y > 1 ? Y - 1 : 0), ye = 1; ye < Y; ye++)
            de[ye - 1] = arguments[ye];
          s.emit.apply(s, [X].concat(de));
        }), this.modules.languageDetector && (M.languageDetector = g(this.modules.languageDetector), M.languageDetector.init && M.languageDetector.init(M, this.options.detection, this.options)), this.modules.i18nFormat && (M.i18nFormat = g(this.modules.i18nFormat), M.i18nFormat.init && M.i18nFormat.init(this)), this.translator = new q2(this.services, this.options), this.translator.on("*", function(X) {
          for (var Y = arguments.length, de = new Array(Y > 1 ? Y - 1 : 0), ye = 1; ye < Y; ye++)
            de[ye - 1] = arguments[ye];
          s.emit.apply(s, [X].concat(de));
        }), this.modules.external.forEach(function(X) {
          X.init && X.init(s);
        });
      }
      if (this.format = this.options.interpolation.format, o || (o = Ry), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var I = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        I.length > 0 && I[0] !== "dev" && (this.options.lng = I[0]);
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var A = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      A.forEach(function(X) {
        s[X] = function() {
          var Y;
          return (Y = s.store)[X].apply(Y, arguments);
        };
      });
      var z = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      z.forEach(function(X) {
        s[X] = function() {
          var Y;
          return (Y = s.store)[X].apply(Y, arguments), s;
        };
      });
      var V = Zp(), Z = function() {
        var Y = function(ye, Ie) {
          s.isInitialized && !s.initializedStoreOnce && s.logger.warn("init: i18next is already initialized. You should call init just once!"), s.isInitialized = !0, s.options.isClone || s.logger.log("initialized", s.options), s.emit("initialized", s.options), V.resolve(Ie), o(ye, Ie);
        };
        if (s.languages && s.options.compatibilityAPI !== "v1" && !s.isInitialized)
          return Y(null, s.t.bind(s));
        s.changeLanguage(s.options.lng, Y);
      };
      return this.options.resources || !this.options.initImmediate ? Z() : setTimeout(Z, 0), V;
    }
  }, {
    key: "loadResources",
    value: function(s) {
      var f = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ry, m = o, g = typeof s == "string" ? s : this.language;
      if (typeof s == "function" && (m = s), !this.options.resources || this.options.partialBundledLanguages) {
        if (g && g.toLowerCase() === "cimode")
          return m();
        var b = [], T = function(A) {
          if (!!A) {
            var z = f.services.languageUtils.toResolveHierarchy(A);
            z.forEach(function(V) {
              b.indexOf(V) < 0 && b.push(V);
            });
          }
        };
        if (g)
          T(g);
        else {
          var M = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          M.forEach(function(I) {
            return T(I);
          });
        }
        this.options.preload && this.options.preload.forEach(function(I) {
          return T(I);
        }), this.services.backendConnector.load(b, this.options.ns, function(I) {
          !I && !f.resolvedLanguage && f.language && f.setResolvedLanguage(f.language), m(I);
        });
      } else
        m(null);
    }
  }, {
    key: "reloadResources",
    value: function(s, f, o) {
      var m = Zp();
      return s || (s = this.languages), f || (f = this.options.ns), o || (o = Ry), this.services.backendConnector.reload(s, f, function(g) {
        m.resolve(), o(g);
      }), m;
    }
  }, {
    key: "use",
    value: function(s) {
      if (!s)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!s.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return s.type === "backend" && (this.modules.backend = s), (s.type === "logger" || s.log && s.warn && s.error) && (this.modules.logger = s), s.type === "languageDetector" && (this.modules.languageDetector = s), s.type === "i18nFormat" && (this.modules.i18nFormat = s), s.type === "postProcessor" && GM.addPostProcessor(s), s.type === "formatter" && (this.modules.formatter = s), s.type === "3rdParty" && this.modules.external.push(s), this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function(s) {
      if (!(!s || !this.languages) && !(["cimode", "dev"].indexOf(s) > -1))
        for (var f = 0; f < this.languages.length; f++) {
          var o = this.languages[f];
          if (!(["cimode", "dev"].indexOf(o) > -1) && this.store.hasLanguageSomeTranslations(o)) {
            this.resolvedLanguage = o;
            break;
          }
        }
    }
  }, {
    key: "changeLanguage",
    value: function(s, f) {
      var o = this;
      this.isLanguageChangingTo = s;
      var m = Zp();
      this.emit("languageChanging", s);
      var g = function(I) {
        o.language = I, o.languages = o.services.languageUtils.toResolveHierarchy(I), o.resolvedLanguage = void 0, o.setResolvedLanguage(I);
      }, b = function(I, A) {
        A ? (g(A), o.translator.changeLanguage(A), o.isLanguageChangingTo = void 0, o.emit("languageChanged", A), o.logger.log("languageChanged", A)) : o.isLanguageChangingTo = void 0, m.resolve(function() {
          return o.t.apply(o, arguments);
        }), f && f(I, function() {
          return o.t.apply(o, arguments);
        });
      }, T = function(I) {
        !s && !I && o.services.languageDetector && (I = []);
        var A = typeof I == "string" ? I : o.services.languageUtils.getBestMatchFromCodes(I);
        A && (o.language || g(A), o.translator.language || o.translator.changeLanguage(A), o.services.languageDetector && o.services.languageDetector.cacheUserLanguage && o.services.languageDetector.cacheUserLanguage(A)), o.loadResources(A, function(z) {
          b(z, A);
        });
      };
      return !s && this.services.languageDetector && !this.services.languageDetector.async ? T(this.services.languageDetector.detect()) : !s && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(T) : this.services.languageDetector.detect(T) : T(s), m;
    }
  }, {
    key: "getFixedT",
    value: function(s, f, o) {
      var m = this, g = function b(T, M) {
        var I;
        if (us(M) !== "object") {
          for (var A = arguments.length, z = new Array(A > 2 ? A - 2 : 0), V = 2; V < A; V++)
            z[V - 2] = arguments[V];
          I = m.options.overloadTranslationOptionHandler([T, M].concat(z));
        } else
          I = Rs({}, M);
        I.lng = I.lng || b.lng, I.lngs = I.lngs || b.lngs, I.ns = I.ns || b.ns, I.keyPrefix = I.keyPrefix || o || b.keyPrefix;
        var Z = m.options.keySeparator || ".", X;
        return I.keyPrefix && Array.isArray(T) ? X = T.map(function(Y) {
          return "".concat(I.keyPrefix).concat(Z).concat(Y);
        }) : X = I.keyPrefix ? "".concat(I.keyPrefix).concat(Z).concat(T) : T, m.t(X, I);
      };
      return typeof s == "string" ? g.lng = s : g.lngs = s, g.ns = f, g.keyPrefix = o, g;
    }
  }, {
    key: "t",
    value: function() {
      var s;
      return this.translator && (s = this.translator).translate.apply(s, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var s;
      return this.translator && (s = this.translator).exists.apply(s, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(s) {
      this.options.defaultNS = s;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(s) {
      var f = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var m = this.resolvedLanguage || this.languages[0], g = this.options ? this.options.fallbackLng : !1, b = this.languages[this.languages.length - 1];
      if (m.toLowerCase() === "cimode")
        return !0;
      var T = function(A, z) {
        var V = f.services.backendConnector.state["".concat(A, "|").concat(z)];
        return V === -1 || V === 2;
      };
      if (o.precheck) {
        var M = o.precheck(this, T);
        if (M !== void 0)
          return M;
      }
      return !!(this.hasResourceBundle(m, s) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || T(m, s) && (!g || T(b, s)));
    }
  }, {
    key: "loadNamespaces",
    value: function(s, f) {
      var o = this, m = Zp();
      return this.options.ns ? (typeof s == "string" && (s = [s]), s.forEach(function(g) {
        o.options.ns.indexOf(g) < 0 && o.options.ns.push(g);
      }), this.loadResources(function(g) {
        m.resolve(), f && f(g);
      }), m) : (f && f(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(s, f) {
      var o = Zp();
      typeof s == "string" && (s = [s]);
      var m = this.options.preload || [], g = s.filter(function(b) {
        return m.indexOf(b) < 0;
      });
      return g.length ? (this.options.preload = m.concat(g), this.loadResources(function(b) {
        o.resolve(), f && f(b);
      }), o) : (f && f(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(s) {
      if (s || (s = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !s)
        return "rtl";
      var f = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], o = this.services && this.services.languageUtils || new $2(Y2());
      return f.indexOf(o.getLanguagePartFromCode(s)) > -1 || s.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var s = this, f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ry, m = Rs(Rs(Rs({}, this.options), f), {
        isClone: !0
      }), g = new n(m);
      (f.debug !== void 0 || f.prefix !== void 0) && (g.logger = g.logger.clone(f));
      var b = ["store", "services", "language"];
      return b.forEach(function(T) {
        g[T] = s[T];
      }), g.services = Rs({}, this.services), g.services.utils = {
        hasLoadedNamespace: g.hasLoadedNamespace.bind(g)
      }, g.translator = new q2(g.services, g.options), g.translator.on("*", function(T) {
        for (var M = arguments.length, I = new Array(M > 1 ? M - 1 : 0), A = 1; A < M; A++)
          I[A - 1] = arguments[A];
        g.emit.apply(g, [T].concat(I));
      }), g.init(m, o), g.translator.options = g.options, g.translator.backendConnector.services.utils = {
        hasLoadedNamespace: g.hasLoadedNamespace.bind(g)
      }, g;
    }
  }, {
    key: "toJSON",
    value: function() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]), n;
}(Nu);
Fu(qg, "createInstance", function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0;
  return new qg(t, e);
});
var ii = qg.createInstance();
ii.createInstance = qg.createInstance;
ii.createInstance;
ii.dir;
ii.init;
ii.loadResources;
ii.reloadResources;
ii.use;
ii.changeLanguage;
ii.getFixedT;
ii.t;
ii.exists;
ii.setDefaultNamespace;
ii.hasLoadedNamespace;
ii.loadNamespaces;
ii.loadLanguages;
const Q6 = "/";
var qM = /* @__PURE__ */ ((t) => (t.PNG = "image/png", t.JPG = "image/jpeg", t))(qM || {}), If = /* @__PURE__ */ ((t) => (t.VALUE = "value", t.RANGE = "range", t))(If || {}), lg = /* @__PURE__ */ ((t) => (t.DATEPICKER = "datepicker", t.SLIDER = "slider", t))(lg || {});
const eF = "root_3d", tF = -222, Ro = Qc(
  "config",
  () => {
    const t = Fn(), e = Hr("main"), n = Ur(() => {
      var g;
      return (g = t.value) == null ? void 0 : g.themes;
    }), a = Ur(
      () => {
        var g;
        return (g = n.value) == null ? void 0 : g.find((b) => b.name === e.value);
      }
    ), s = Ur(() => {
      var g;
      return ((g = t.value) == null ? void 0 : g.background_layers) || [];
    }), f = Ur(() => {
      var b;
      const g = (b = n.value) == null ? void 0 : b.filter(
        (T) => {
          var M;
          return ((M = T.metadata) == null ? void 0 : M.ol3d_type) !== void 0;
        }
      );
      if (!!g)
        return {
          name: eF,
          id: tF,
          children: g.map(
            (T) => T != null && T.children ? T.children[0] : T
          ),
          metadata: {}
        };
    });
    function o(g) {
      t.value = g;
    }
    function m(g) {
      e.value = g;
    }
    return {
      config: t,
      themes: n,
      themeName: e,
      theme: a,
      bgLayers: s,
      layerTrees_3d: f,
      setTheme: m,
      setThemes: o
    };
  },
  {}
);
function Gc() {
  function t(m, g) {
    return n(m, void 0, g);
  }
  function e(m, g) {
    return n(void 0, m, g);
  }
  function n(m, g, b) {
    const { theme: T } = Ro();
    if (b = b || T, m && (b == null ? void 0 : b.id) === m || g && (b == null ? void 0 : b.name) === g)
      return b;
    if (b != null && b.children)
      for (const M of b.children) {
        const I = n(m, g, M);
        if (I)
          return I;
      }
  }
  function a(m) {
    const { layerTrees_3d: g } = Ro();
    return n(m, void 0, g);
  }
  function s(m) {
    const { bgLayers: g } = Ro();
    return g.find((b) => b.id === m);
  }
  function f(m) {
    const { bgLayers: g } = Ro();
    return g.find((b) => b.name === m);
  }
  function o(m) {
    const { setTheme: g } = Ro();
    g(m);
  }
  return {
    findById: t,
    findByName: e,
    find3dLayerById: a,
    findBgLayerById: s,
    findBgLayerByName: f,
    setTheme: o
  };
}
const eE = Gc();
function Au() {
  function t(m, g) {
    try {
      const b = JSON.parse(m).concat(JSON.parse(g));
      return new Set(b).size < b.length;
    } catch {
      return !1;
    }
  }
  function e(m) {
    var g, b;
    return m.opacity = m.previousOpacity = (b = (g = m.metadata) == null ? void 0 : g.start_opacity) != null ? b : 1, n(m), m;
  }
  function n(m) {
    var g, b, T, M, I, A;
    m.currentTimeMinValue || (m.currentTimeMinValue = (T = (g = m.time) == null ? void 0 : g.minDefValue) != null ? T : (b = m.time) == null ? void 0 : b.minValue), m.currentTimeMaxValue || (m.currentTimeMaxValue = (A = (M = m.time) == null ? void 0 : M.maxDefValue) != null ? A : (I = m.time) == null ? void 0 : I.maxValue);
  }
  function a(m) {
    return [
      m.currentTimeMinValue,
      ...m.currentTimeMaxValue ? [m.currentTimeMaxValue] : []
    ].join(Q6);
  }
  function s(m) {
    var T, M;
    if (!((T = m.metadata) != null && T.exclusion))
      return;
    const g = Ai(), b = g.layers.filter(
      (I) => {
        var A, z;
        return t(
          (A = m == null ? void 0 : m.metadata) == null ? void 0 : A.exclusion,
          (z = I == null ? void 0 : I.metadata) == null ? void 0 : z.exclusion
        );
      }
    );
    b.length > 0 && (g.removeLayers(...b.map((I) => I.id)), alert(
      ii.t(
        "The layer <b>{{layersToRemove}}</b> has been removed because it cannot be displayed while the layer <b>{{layer}}</b> is displayed",
        {
          count: b.length,
          layersToRemove: b.map((I) => ii.t(I.name, { ns: "client" })).join(", "),
          layer: ii.t(m.name, { ns: "client" }),
          ns: "client"
        }
      )
    )), m.id !== ((M = g.bgLayer) == null ? void 0 : M.id) && f(m);
  }
  function f(m) {
    var b, T, M;
    const g = Ai();
    t(
      (b = m.metadata) == null ? void 0 : b.exclusion,
      (M = (T = g.bgLayer) == null ? void 0 : T.metadata) == null ? void 0 : M.exclusion
    ) && (g.setBgLayer(null), alert(
      ii.t(
        "Background has been deactivated because the layer {{layer}} cannot be displayed on top of it.",
        {
          layer: ii.t(m.name, { ns: "client" }),
          ns: "client"
        }
      )
    ));
  }
  function o(m, g = !0, b) {
    var z;
    const T = Ro(), M = Ai(), I = b ? T.layerTrees_3d : T.theme, A = eE.findById(m, I);
    if (A) {
      const V = ((z = A.metadata) == null ? void 0 : z.linked_layers) || [];
      g === !1 ? M.removeLayers(A.id, ...V) : (s(A), (b ? M.add3dLayers : M.addLayers)(
        e(A),
        ...V.map(
          (X) => e(
            eE.findById(parseInt(X, 10))
          )
        )
      ));
    }
  }
  return {
    initLayer: e,
    getLayerCurrentTime: a,
    handleExclusionLayers: s,
    toggleLayer: o
  };
}
const zy = -200, rF = "https://map.geoportail.lu/ogcproxywms", $M = "https://map.geoportail.lu/httpsproxy";
function $g() {
  return cC(
    [5.31, 49.38, 6.64, 50.21],
    PT,
    md
  );
}
function nF(t) {
  const { name: e, layers: n, imageType: a, url: s, id: f } = t, o = new gC({
    url: s || rF,
    hidpi: DT(),
    serverType: "mapserver",
    params: {
      FORMAT: a,
      LAYERS: n
    },
    ...s != null || $M ? { crossOrigin: "anonymous" } : {}
  });
  if (t.currentTimeMinValue) {
    const g = o.getParams();
    g.TIME = Au().getLayerCurrentTime(t), o.updateParams(g);
  }
  const m = new mC({
    properties: {
      "olcs.extent": $g(),
      label: e,
      id: f
    },
    source: o
  });
  return m.set("olcs.extent", $g()), m.set("label", e), m.set("id", f), m;
}
function iF(t) {
  var b, T;
  const { name: e, imageType: n, id: a } = t, s = WM(t), f = Wy(md), o = f.getExtent(), m = new vC({
    url: aF(t),
    tilePixelRatio: s ? 2 : 1,
    layer: e,
    matrixSet: `GLOBAL_WEBMERCATOR_4_V3${s ? "_HD" : ""}`,
    format: n,
    requestEncoding: "REST",
    projection: f,
    tileGrid: new _C({
      origin: xC(o),
      extent: o,
      resolutions: g6,
      matrixIds: v6
    }),
    style: "default",
    crossOrigin: "anonymous"
  }), g = new yC({
    source: m,
    properties: {
      "olcs.extent": $g(),
      label: e,
      id: a
    }
  });
  if (g.set("olcs.extent", $g()), g.set("label", e), g.set("id", a), t.currentTimeMinValue) {
    const M = (T = (b = t.metadata) == null ? void 0 : b.time_layers) == null ? void 0 : T[t.currentTimeMinValue], I = m.getUrls();
    if (M && I) {
      const A = I.map(
        (z) => z.replace(
          /\/[^/]*\/{TileMatrixSet}/,
          "/" + M + "/{TileMatrixSet}"
        )
      );
      m.setUrls(A), g.set("label", M);
    }
  }
  return g;
}
function oF(t, e) {
  const n = Nl(), a = t.get(e.id);
  if (!a)
    return;
  const s = Object.assign(
    {
      container: n.getOlMap().getTarget()
    },
    a
  ), f = new LT({
    maplibreOptions: s,
    label: e.name,
    id: e.id,
    queryable_id: e.id,
    metadata: e.metadata
  }), o = Ws();
  return f != null && f.getMapLibreMap().loaded() ? o.setBaseStyle(
    e.id,
    f == null ? void 0 : f.getMapLibreMap().getStyle()
  ) : new Promise(
    (m) => f == null ? void 0 : f.getMapLibreMap().once("data", m)
  ).then(
    () => o.setBaseStyle(
      e.id,
      f == null ? void 0 : f.getMapLibreMap().getStyle()
    )
  ), f;
}
function aF(t, e = "https") {
  const n = t.imageType.split("/")[1], a = Ir.getValue(Hd, j1) ? "app.geoportail.lu" : "geoportail.lu";
  return `${e === "https" ? "//wmts{3-4}." : "//wmts{1-2}."}${a}/mapproxy_4_v3/wmts/{Layer}${WM(t) ? "_hd" : ""}/{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}.${n}`;
}
function WM(t) {
  var e;
  return !!((e = t == null ? void 0 : t.metadata) != null && e.hasRetina) && DT();
}
function HM() {
  function t(A) {
    var V;
    let z;
    switch (A.type) {
      case "WMS": {
        z = nF(A);
        break;
      }
      case "WMTS":
      case "BG WMTS": {
        z = iF(A);
        break;
      }
      default:
        throw new Error(`Unrecognized layer type: ${A.type}`);
    }
    if (z.set("metadata", A.metadata), z.set("queryable_id", A.id), z.set("current_time", Au().getLayerCurrentTime(A)), z.set("time", A.time), z.setOpacity(A.opacity), (V = A.metadata) != null && V.hasOwnProperty("attribution")) {
      const Z = z.getSource();
      Z == null || Z.setAttributions(A.metadata.attribution);
    }
    return z;
  }
  function e(A, z) {
    if (!z)
      return;
    const V = b(z);
    A.addLayer(V);
  }
  function n(A, z) {
    return A.getLayers().getArray().find((V) => V.get("id") === z);
  }
  function a(A, z) {
    const V = n(A, z);
    V && A.removeLayer(V);
  }
  function s(A, z) {
    const V = A.getLayers().getArray();
    z.forEach((Z, X) => {
      const Y = V.find(
        (de) => de.get("id") === Z.id
      );
      Y == null || Y.setZIndex(X + 1);
    });
  }
  function f(A, z, V) {
    const Z = A.getLayers().getArray().find((X) => X.get("id") === z);
    Z && Z.setOpacity(V);
  }
  function o(A) {
    $p.delete(A);
  }
  function m(A) {
    return $p.has(A.id);
  }
  function g(A, z) {
    $p.set(A, z);
  }
  function b(A) {
    const z = A.id, V = $p.get(z);
    if (V)
      return V;
    {
      const Z = t(A);
      return g(z, Z), Z;
    }
  }
  function T(A) {
    return A && $p.get(A.id) || null;
  }
  function M(A, z) {
    const Z = A.getLayers().getArray().find((X) => X.getZIndex() === zy);
    Z && z(Z);
  }
  function I(A, z, V) {
    var ye;
    const Z = A.getLayers(), X = Z.getArray().findIndex((Ie) => Ie.getZIndex() === zy), Y = (ye = Z.getArray()[X]) == null ? void 0 : ye.get("id");
    let de;
    z && (m(z) ? de = T(z) : (V && (de = oF(V, z)), de = de || t(z), g(z.id, de))), X >= 0 ? de ? (de.setZIndex(zy), Z.setAt(X, de)) : Z.removeAt(X) : de && (de.setZIndex(zy), A.addLayer(de)), Y !== (z == null ? void 0 : z.id) && BM.restoreStyle(!0);
  }
  return {
    createLayer: t,
    addLayer: e,
    findLayer: n,
    removeLayer: a,
    removeFromCache: o,
    reorderLayers: s,
    setLayerOpacity: f,
    getLayerFromCache: T,
    setBgLayer: I,
    applyOnBgLayer: M
  };
}
class sF {
  constructor(e) {
    bi(this, "previousLayers");
    bi(this, "previousVectorSources");
    const n = Ai(), a = Ws(), s = Nl(), f = Ff(), o = HM(), { appliedStyle: m } = xn(a);
    Bn(
      () => n.layers,
      (g) => {
        const b = {
          layers: this.previousLayers
        }, T = {
          layers: g
        }, M = s.getRemovedLayers(
          T,
          b
        ), I = s.getAddedLayers(
          T,
          b
        ), A = s.getMutatedLayers(
          T,
          b
        );
        M.forEach((z) => o.removeLayer(e, z.id)), I.forEach(
          (z) => o.addLayer(e, z.layer)
        ), A.forEach((z) => {
          o.setLayerOpacity(e, z.id, z.opacity);
        }), T.layers && o.reorderLayers(e, T.layers), this.previousLayers = g;
      }
    ), Bn(
      () => n.bgLayer,
      (g) => g !== void 0 && o.setBgLayer(e, g, a.bgVectorSources)
    ), Na(() => {
      a.isExpertStyleActive || (m.value = f.applyDefaultStyle(
        n.bgLayer,
        a.bgVectorBaseStyles,
        a.bgStyle
      ));
    }), Bn(m, (g) => {
      a.bgStyle === null && !a.isExpertStyleActive ? f.unregisterStyle(a.styleSerial, a.registerUrls).then(a.styleSerial = null) : f.registerStyle(g, a.styleSerial, a.registerUrls).then((b) => {
        var M;
        a.styleSerial = b;
        const T = (M = n == null ? void 0 : n.bgLayer) == null ? void 0 : M.id;
        (n == null ? void 0 : n.bgLayer) && T !== void 0 && b !== void 0 && (o.applyOnBgLayer(e, (I) => {
          I.set(
            "xyz_custom",
            f.getDefaultMapBoxStyleXYZ(b)
          );
        }), o.setBgLayer(
          e,
          n == null ? void 0 : n.bgLayer,
          a.bgVectorSources
        ));
      }), o.applyOnBgLayer(
        e,
        (b) => f.applyConsolidatedStyle(b, g)
      );
    }), Bn(
      () => a.bgVectorSources,
      (g) => {
        var b;
        for (const T of g.keys())
          (!this.previousVectorSources || this.previousVectorSources.get(T) !== g.get(T)) && (o.removeFromCache(T), T === ((b = n == null ? void 0 : n.bgLayer) == null ? void 0 : b.id) && o.setBgLayer(e, n == null ? void 0 : n.bgLayer, g));
        this.previousVectorSources = g;
      }
    );
  }
}
const lF = {
  0: 8,
  1: 9,
  2: 9,
  3: 10,
  4: 11,
  5: 12,
  6: 13,
  7: 14,
  8: 16,
  9: 17,
  10: 18,
  11: 19,
  12: 20,
  13: 21
};
class uF {
  bootstrap() {
    this.restore(), this.persist();
  }
  persistZoom() {
    const e = Nl().getOlMap().getView(), n = () => {
      const a = e.getZoom();
      Ir.setValue(e2, a ? Math.ceil(a) : null);
    };
    n(), Cb.listen(
      e,
      "change:resolution",
      Xw(n, 300)
    );
  }
  persistXY() {
    const e = Nl().getOlMap().getView(), n = () => {
      const a = e.getCenter();
      Ir.setValue(t2, a ? Math.round(a[0]) : null), Ir.setValue(r2, a ? Math.round(a[1]) : null);
    };
    n(), Cb.listen(
      e,
      SC.PROPERTYCHANGE,
      Xw(n, 300)
    );
  }
  persist() {
    this.persistXY(), this.persistZoom();
  }
  restore() {
    const e = Nl().getOlMap().getView(), n = Ir.getValue(e2, Sf), a = Ir.getInitialVersion(), s = Ir.getValue(t2, Sf), f = Ir.getValue(r2, Sf), o = Ir.getValue(Q4), m = hC(
      Z4,
      md
    );
    let g, b;
    n !== void 0 ? b = a === 3 ? Number(n) : lF[n] : b = 8, s != null && f != null ? a === 3 && o != null ? g = Ob([s, f], o, md) : g = a === 3 ? [s, f] : m([f, s], void 0, 2) : g = Ob(
      [6, 49.7],
      PT,
      md
    ), e.setCenter(g), e.setZoom(b);
  }
}
const cF = new uF();
function Gf(t, e) {
  const n = new t(e), a = Nl(), s = xf("olMap");
  return va(() => {
    s.addControl(n), s.changed();
  }), Jc(() => {
    const f = a.getOlMap();
    f.removeControl(n), f.changed();
  }), {
    control: n
  };
}
const hF = /* @__PURE__ */ ur({
  __name: "attribution-control",
  props: {
    className: { type: String, required: !1, default: "geoportailv3-attribution" },
    collapsed: { type: Boolean, required: !1, default: !1 },
    collapsible: { type: Boolean, required: !1, default: !1 }
  },
  setup(t) {
    return Gf(TC, t), (n, a) => it("v-if", !0);
  }
}), fF = /* @__PURE__ */ mr(hF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/attribution-control.vue"]]), pF = ["title"], dF = /* @__PURE__ */ ur({
  __name: "location-control",
  props: {
    className: { type: String, required: !1, default: "location-button" },
    label: { type: String, required: !1, default: "\uE800" },
    tipLabel: { type: String, required: !1, default: "Location" }
  },
  setup(t) {
    const e = t, { t: n } = An(), a = Hr(null);
    function s() {
    }
    return va(
      () => Gf(TE, { ...e, target: a })
    ), (f, o) => (Ue(), st("div", {
      ref_key: "controlElement",
      ref: a,
      class: Lr(`tracker-off ${e.className} ${le(EE)} ${le(SE)}`)
    }, [
      Ne("button", {
        title: le(n)(e.tipLabel),
        onClick: s
      }, Vt(e.label), 9, pF)
    ], 2));
  }
}), mF = /* @__PURE__ */ mr(dF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/location-control.vue"]]), yF = ["title"], gF = /* @__PURE__ */ ur({
  __name: "map-3d",
  props: {
    className: { type: String, required: !1, default: "map-3d-button" },
    label: { type: String, required: !1, default: "\uE057" },
    tipLabel: { type: String, required: !1, default: "3d" }
  },
  setup(t) {
    const e = t, n = Ai(), { t: a } = An(), s = Hr(null);
    va(
      () => Gf(TE, { ...e, target: s })
    );
    const f = () => {
      n.is_3d_active = !n.is_3d_active;
    };
    return (o, m) => (Ue(), st("div", {
      ref_key: "controlElement",
      ref: s,
      class: Lr(`${e.className} ${le(EE)} ${le(SE)} ${le(n).is_3d_active ? "active" : ""}`)
    }, [
      Ne("button", {
        title: le(a)(e.tipLabel),
        onClick: f
      }, Vt(e.label), 9, yF)
    ], 2));
  }
}), vF = /* @__PURE__ */ mr(gF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/map-3d.vue"]]), _F = /* @__PURE__ */ ur({
  __name: "fullscreen-control",
  props: {
    className: { type: String, required: !1 },
    label: { type: String, required: !1, default: "\uE01C" },
    labelActive: { type: String, required: !1, default: "\uE02C" }
  },
  setup(t) {
    return Gf(MC, t), (n, a) => it("v-if", !0);
  }
}), xF = /* @__PURE__ */ mr(_F, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/fullscreen-control.vue"]]), bF = /* @__PURE__ */ ur({
  __name: "zoom-control",
  props: {
    className: { type: String, required: !1 },
    zoomInLabel: { type: String, required: !1, default: "\uE032" },
    zoomOutLabel: { type: String, required: !1, default: "\uE033" }
  },
  setup(t) {
    return Gf(IC, t), (n, a) => it("v-if", !0);
  }
}), wF = /* @__PURE__ */ mr(bF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/zoom-control.vue"]]);
class EF extends OC {
  constructor(n) {
    super(n);
    bi(this, "ol3dm");
  }
  handleZoomToExtent() {
    this.ol3dm && this.ol3dm.luxCameraExtentInRadians && this.ol3dm.is3dEnabled() || super.handleZoomToExtent();
  }
}
const SF = /* @__PURE__ */ ur({
  __name: "zoom-to-extent-control",
  props: {
    className: { type: String, required: !1 },
    label: { type: String, required: !1, default: "\uE01B" },
    tipLabel: { type: String, required: !1 },
    extent: { type: null, required: !0 }
  },
  setup(t) {
    return Gf(EF, t), (n, a) => it("v-if", !0);
  }
}), TF = /* @__PURE__ */ mr(SF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/zoom-to-extent-control.vue"]]), MF = /* @__PURE__ */ ur({
  __name: "map-container",
  props: {
    v4_standalone: { type: Boolean, required: !1, default: !1 }
  },
  setup(t) {
    const e = Nl(), n = Hr(null), a = e.createMap(), s = [
      425152.9429259216,
      632446599999133e-8,
      914349.9239510496,
      6507914867875754e-9
    ];
    return va(() => {
      n.value && (new sF(a), cF.bootstrap(), a.setTarget(n.value), window.olMap = a);
    }), pS("olMap", a), (f, o) => (Ue(), st("div", {
      id: "map-container",
      ref_key: "mapContainer",
      ref: n,
      class: "h-full w-full bg-white absolute"
    }, [
      Gt(wF),
      Gt(TF, { extent: s }),
      Gt(xF),
      Gt(fF),
      t.v4_standalone ? (Ue(), cn(vF, { key: 0 })) : it("v-if", !0),
      Gt(mF)
    ], 512));
  }
}), IF = /* @__PURE__ */ mr(MF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map/map-container.vue"]]), OF = "fr", CF = !0, AF = !1, PF = !1, Pi = Qc(
  "app",
  () => {
    const t = Hr(OF), e = Hr(CF), n = Hr(AF), a = Hr(PF), s = Hr(), f = Hr(), o = Hr(!1);
    function m(V) {
      t.value = V;
    }
    function g(V) {
      e.value = V, V || (a.value = !1, n.value = !1);
    }
    function b(V) {
      n.value = V, V && (a.value = !1);
    }
    function T(V) {
      a.value = V;
    }
    function M(V) {
      f.value = V;
    }
    function I(V) {
      s.value = V;
    }
    function A() {
      o.value = !0;
    }
    function z() {
      o.value = !1;
    }
    return {
      lang: t,
      layersOpen: e,
      myLayersTabOpen: n,
      themeGridOpen: a,
      mapId: s,
      styleEditorOpen: o,
      remoteLayersOpen: f,
      setLang: m,
      setLayersOpen: g,
      setMyLayersTabOpen: b,
      setThemeGridOpen: T,
      setRemoteLayersOpen: M,
      setMapId: I,
      openStyleEditorPanel: A,
      closeStyleEditorPanel: z
    };
  },
  {}
), Wg = {
  name: "blank",
  id: 0
};
function ZM() {
  const t = Pi(), { mapId: e } = xn(t), n = Gc(), a = Ai(), s = Au(), f = Ur(() => {
    var M;
    if (!e.value) {
      const I = (M = Ro().theme) == null ? void 0 : M.name;
      if (I)
        return os().bg_layer_theme_defaults[I] || g();
    }
    return g();
  });
  function o(M) {
    const I = n.findBgLayerById(M);
    m(I || null);
  }
  function m(M) {
    if (M) {
      if (M.type === "WMTS" || M.type === "BG WMTS")
        M.type = "BG WMTS";
      else if (M.type === "BG MVT")
        console.log(`passed through MVT layer ${M.name}`);
      else
        throw new Error(
          `Only WMTS and MVT BG layers are currently implemented (not ${M.type} for ${M.name})`
        );
      s.handleExclusionLayers(M), a.setBgLayer(s.initLayer(M));
    } else
      a.setBgLayer(null);
  }
  function g() {
    var M;
    return ((M = T().find((I) => I.is_default)) == null ? void 0 : M.id) || Wg.id;
  }
  function b() {
    return Wg.id;
  }
  function T() {
    return os().bg_layers;
  }
  return {
    setBgLayer: o,
    setMapBackground: m,
    getBgLayersFromConfig: T,
    getNullId: b,
    getDefaultSelectedId: g,
    defaultSelectedBgId: f
  };
}
const kF = ["title"], LF = /* @__PURE__ */ ur({
  __name: "background-selector-item",
  props: {
    bgTitle: {
      type: String,
      default: ""
    },
    bgName: {
      type: String,
      default: ""
    }
  },
  setup(t) {
    const e = t, { t: n } = An(), a = Ur(() => {
      const f = n(e.bgTitle), o = e.bgTitle.length > 0, m = `${n("Background layer:")} ${n(e.bgName)}`;
      return `${f}${o ? " - " : ""}${m}`;
    }), s = Ur(
      () => `h-full w-full rounded-sm lux-bg-sel-icon
        lux-bg-sel-${e.bgName}
        bg-${e.bgName}_sm
        md:bg-${e.bgName}
        hd:bg-${e.bgName}_sm_hi
        hd_md:bg-${e.bgName}_hi`
    );
    return (f, o) => (Ue(), st("button", {
      title: le(a),
      class: Lr(le(s))
    }, null, 10, kF));
  }
}), tE = /* @__PURE__ */ mr(LF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/background-selector/background-selector-item.vue"]]), DF = { class: "flex flex-row-reverse" }, NF = /* @__PURE__ */ ur({
  __name: "background-selector",
  props: {
    isOpen: {
      type: Boolean,
      default: !1
    }
  },
  setup(t) {
    const e = t, { t: n } = An(), a = ZM(), s = Ai(), f = Ro(), { bgLayer: o } = xn(s), m = Hr(e.isOpen), g = Hr([]), b = Ur(
      () => {
        var A, z;
        return (z = (A = o.value) == null ? void 0 : A.id) != null ? z : a.getNullId();
      }
    ), T = Ur(
      () => {
        var A, z;
        return (z = (A = g.value) == null ? void 0 : A.find((V) => V.id === b.value)) == null ? void 0 : z.name;
      }
    );
    Bn(
      () => f.bgLayers,
      (A) => {
        g.value = os().bg_layers.map(
          (z) => Object.assign(
            {
              id: z.id
            },
            A.find((V) => z.id === V.id),
            {
              name: z.icon_id
            }
          )
        );
      },
      { immediate: !0 }
    ), Bn(
      () => s.bgLayer,
      (A, z) => {
        const V = s.layers;
        z === void 0 && A === null && (V == null ? void 0 : V.length) === 0 && (a.setBgLayer(a.defaultSelectedBgId.value), A === null && CT().addNotification(
          n(
            "Aucune couche n'\xE9tant d\xE9finie pour cette carte, une couche de fond a automatiquement \xE9t\xE9 ajout\xE9e.",
            { ns: "client" }
          )
        ));
      }
    );
    function M(A) {
      a.setBgLayer(A.id), m.value = !1;
    }
    function I() {
      m.value = !m.value;
    }
    return (A, z) => (Ue(), st("div", DF, [
      Ne("div", {
        class: Lr(["lux-bg-sel border border-black", m.value === !0 ? "hidden" : "block"])
      }, [
        Gt(tE, {
          "aria-expanded": m.value,
          "bg-title": "Select BG layer",
          "bg-name": le(T),
          onClick: I
        }, null, 8, ["aria-expanded", "bg-name"])
      ], 2),
      Ne("div", {
        class: Lr(m.value === !0 ? "flex flex-col md:flex-row" : "hidden")
      }, [
        (Ue(!0), st(un, null, Ra(g.value, (V) => (Ue(), st("div", {
          key: V.id,
          class: Lr([
            "lux-bg-sel hover:bg-cyan-600",
            V.id === le(b) ? "border-red-500 border-2" : "border-black border"
          ])
        }, [
          Gt(tE, {
            "bg-name": V.name,
            onClick: (Z) => M(V)
          }, null, 8, ["bg-name", "onClick"])
        ], 2))), 128))
      ], 2)
    ]));
  }
}), RF = /* @__PURE__ */ mr(NF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/background-selector/background-selector.vue"]]), zF = /* @__PURE__ */ Ne("div", { class: "fixed inset-0 bg-gray-900 opacity-40 z-[1050]" }, null, -1), FF = { class: "bg-white shadow-modal rounded-lg overflow-hidden w-[700px]" }, BF = { class: "relative flex flex-row justify-center p-4 border-b-[1px]" }, VF = { class: "text-xl" }, UF = /* @__PURE__ */ Ne("span", { "aria-hidden": "true" }, "\xD7", -1), jF = [
  UF
], GF = {
  key: 0,
  class: "p-[15px] border-t-[1px]"
}, qF = { class: "flex flex-row justify-end" }, $F = /* @__PURE__ */ ur({
  __name: "modal-dialog",
  props: {
    footer: {
      type: Boolean,
      default: !0
    },
    maxHeight: {
      type: Boolean,
      default: !1
    },
    title: String
  },
  emits: ["close"],
  setup(t) {
    const { t: e } = An(), n = Hr();
    va(() => {
      n.value.focus();
    });
    const a = Fn(!0);
    function s() {
      a.value = !1;
    }
    return (f, o) => (Ue(), cn(kS, { to: "body" }, [
      it(" backdrop "),
      zF,
      it(" modal "),
      Gt(_v, {
        appear: "",
        "enter-active-class": "duration-200 ease-out",
        "enter-from-class": "transform opacity-0 -translate-y-60",
        "enter-to-class": "opacity-100 translate-y-0",
        "leave-active-class": "duration-200 ease-in",
        "leave-from-class": "opacity-100 translate-y-0",
        "leave-to-class": "transform opacity-0 -translate-y-60",
        onAfterLeave: o[3] || (o[3] = (m) => f.$emit("close"))
      }, {
        default: Bd(() => [
          le(a) ? (Ue(), st("div", {
            key: 0,
            role: "dialog",
            ref_key: "modal",
            ref: n,
            tabindex: "0",
            onKeydown: o[2] || (o[2] = sf((m) => s(), ["esc"])),
            class: "fixed inset-x-0 inset-y-8 flex items-start justify-center z-[1100] outline-none"
          }, [
            Ne("div", FF, [
              it(" header (title)"),
              Ne("div", BF, [
                Ne("h4", VF, Vt(t.title), 1),
                Ne("button", {
                  type: "button",
                  class: "absolute right-2 top-1 text-slate-400 text-[24px]",
                  "data-dismiss": "modal",
                  "aria-label": "Close",
                  onClick: o[0] || (o[0] = (m) => s())
                }, jF)
              ]),
              it(" content slot "),
              Ne("div", {
                class: Lr(["p-[15px] overflow-y-auto", t.maxHeight ? "max-h-96" : "max-h-full"])
              }, [
                SP(f.$slots, "content")
              ], 2),
              it(" footer (optional)"),
              t.footer ? (Ue(), st("div", GF, [
                Ne("div", qF, [
                  Ne("button", {
                    type: "button",
                    class: "lux-btn",
                    "data-dismiss": "modal",
                    onClick: o[1] || (o[1] = (m) => s())
                  }, Vt(le(e)("Close", { ns: "client" })), 1)
                ])
              ])) : it("v-if", !0)
            ])
          ], 544)) : it("v-if", !0)
        ]),
        _: 3
      })
    ]));
  }
}), XM = /* @__PURE__ */ mr($F, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/common/modal-dialog.vue"]]), K1 = Qc(
  "metadata",
  () => {
    const t = Hr();
    function e(a) {
      t.value = a;
    }
    function n() {
      t.value = void 0;
    }
    return {
      metadataId: t,
      setMetadataId: e,
      clearMetadataId: n
    };
  },
  {}
), WF = {
  class: "mb-px",
  key: "node.id"
}, HF = ["aria-expanded", "data-cy"], ZF = { class: "leading-6" }, XF = ["aria-expanded", "data-cy"], KF = { class: "grow" }, YF = { class: "leading-6" }, JF = {
  key: 1,
  class: "flex text-tertiary pr-2"
}, QF = ["data-cy"], eB = { class: "ml-1 hover:underline" }, tB = /* @__PURE__ */ ur({
  __name: "layer-tree-node",
  props: {
    node: { type: null, required: !0 }
  },
  emits: ["toggleLayer", "toggleParent"],
  setup(t, { emit: e }) {
    const n = t, { t: a } = An(), { setMetadataId: s } = K1(), f = !!n.node.children, o = n.node.depth === 0, m = n.node.depth >= 10, g = Ur(() => a(n.node.name, { ns: "client" }));
    function b(M) {
      e("toggleLayer", M);
    }
    function T(M) {
      e("toggleParent", M);
    }
    return (M, I) => {
      const A = bP("layer-tree-node", !0);
      return f ? (Ue(), st("div", WF, [
        it("    First level parents"),
        t.node.depth === 1 ? (Ue(), st("button", {
          key: 0,
          class: "group node-1 w-full text-left flex px-2 py-1.5 uppercase bg-tertiary",
          "aria-expanded": t.node.expanded,
          onClick: I[0] || (I[0] = (z) => T(t.node)),
          "data-cy": `parentLayerLabel-${t.node.id}`
        }, [
          Ne("div", {
            class: Lr(["grow", t.node.expanded ? "text-white" : "text-secondary"])
          }, Vt(le(g)), 3),
          Ne("div", ZF, [
            Ne("div", {
              class: Lr(["fa fa-sharp fa-solid group-hover:text-white text-primary", t.node.expanded ? "fa-caret-up" : "fa-caret-down"])
            }, null, 2)
          ])
        ], 8, HF)) : t.node.depth > 1 && !m ? (Ue(), st(un, { key: 1 }, [
          it("    Other parents"),
          Ne("button", {
            class: Lr(["w-full text-left flex px-2 py-1.5 pl-2", t.node.expanded ? "text-tertiary" : "bg-white text-primary"]),
            "aria-expanded": t.node.expanded,
            onClick: I[1] || (I[1] = (z) => T(t.node)),
            "data-cy": `parentLayerLabel-${t.node.id}`
          }, [
            Ne("div", KF, Vt(le(g)), 1),
            Ne("div", YF, [
              Ne("div", {
                class: Lr(["fa-sharp fa-solid", t.node.expanded ? "fa-minus" : "fa-plus"])
              }, null, 2)
            ])
          ], 10, XF)
        ], 2112)) : it("v-if", !0),
        it("    Children"),
        m ? it("v-if", !0) : (Ue(), st("div", {
          key: 2,
          class: Lr(["bg-secondary", [
            { "pl-2": t.node.depth > 1 },
            { "lux-collapse": !o },
            { expanded: !o && t.node.expanded }
          ]])
        }, [
          (Ue(!0), st(un, null, Ra(t.node.children, (z) => (Ue(), cn(A, {
            key: z.id,
            node: z,
            onToggleParent: I[2] || (I[2] = (V) => T(V)),
            onToggleLayer: I[3] || (I[3] = (V) => b(V))
          }, null, 8, ["node"]))), 128))
        ], 2))
      ])) : (Ue(), st("div", JF, [
        Ne("button", {
          class: "self-start before:text-[.85rem] before:transform before:translate-y-[.1rem] before:inline-block before:content-['\\f129'] fa-solid fa-fw fa-fh fa-info",
          onClick: I[4] || (I[4] = (z) => le(s)(t.node.id))
        }),
        Ne("button", {
          class: Lr(["w-full text-left", { "font-bold": t.node.checked }]),
          onClick: I[5] || (I[5] = (z) => b(t.node)),
          "data-cy": `layerLabel-${t.node.id}`
        }, [
          Ne("i", {
            class: Lr(["fa-solid", t.node.checked ? "fa-check-square" : "fa-square"])
          }, null, 2),
          Ne("span", eB, Vt(le(g)), 1)
        ], 10, QF)
      ]));
    };
  }
}), i1 = /* @__PURE__ */ mr(tB, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-tree/layer-tree-node.vue"]]);
class rB {
  toggleNode(e, n, a) {
    var s;
    return (n == null ? void 0 : n.id) === e ? {
      ...n,
      [a]: !n[a]
    } : {
      ...n,
      children: (s = n.children) == null ? void 0 : s.map(
        (f) => this.toggleNode(e, f, a)
      )
    };
  }
  updateLayers(e, n) {
    const { id: a } = e;
    if (e.children)
      return {
        ...e,
        children: e.children.map((s) => this.updateLayers(s, n))
      };
    {
      const s = !!(n != null && n.find((f) => f.id === a));
      return {
        ...e,
        checked: s
      };
    }
  }
}
const Of = new rB();
var Da = /* @__PURE__ */ ((t) => (t.WMS = "WMS", t.WMTS = "WMTS", t))(Da || {});
class Q_ {
  constructor(e, n = 0, a = !1) {
    this.message = e, this.httpStatus = n, this.isCrossOriginRelated = a;
  }
}
let nB = 0;
function iB() {
  return nB++;
}
function oB(t, e, n) {
  return new Promise((a, s) => {
    const f = iB(), o = {
      requestId: f,
      taskName: t,
      params: n
    };
    e === null ? window.dispatchEvent(
      new CustomEvent("ogc-client.request", {
        detail: o
      })
    ) : e.postMessage(o);
    const m = ({ detail: g, data: b }) => {
      const T = g || b;
      T.requestId === f && (e === null ? window.removeEventListener("message", m) : e.removeEventListener("message", m), "error" in T ? s(T.error) : a(T.response));
    };
    e === null ? window.addEventListener("ogc-client.response", m) : e.addEventListener("message", m);
  });
}
function Y1(t, e, n) {
  const a = typeof WorkerGlobalScope < "u", s = async ({ detail: f, data: o }) => {
    const m = f || o;
    if (m.taskName === t) {
      let g, b;
      try {
        g = await n(m.params);
      } catch (M) {
        b = M;
      }
      const T = {
        taskName: t,
        requestId: m.requestId,
        ...g && { response: g },
        ...b && { error: b }
      };
      a ? e.postMessage(T) : e.dispatchEvent(
        new CustomEvent("ogc-client.response", {
          detail: T
        })
      );
    }
  };
  a ? e.addEventListener("message", s) : e.addEventListener("ogc-client.request", s);
}
let e0;
function aB() {
  return e0 || (e0 = new Worker(URL.createObjectURL(new Blob([`function t(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function e(t,e,r,n,o,i,a){try{var c=t[i](a),u=c.value}catch(t){return void r(t)}c.done?e(u):Promise.resolve(u).then(n,o)}function r(t){return function(){var r=this,n=arguments;return new Promise((function(o,i){var a=t.apply(r,n);function c(t){e(a,o,i,c,u,"next",t)}function u(t){e(a,o,i,c,u,"throw",t)}c(void 0)}))}}function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}var o={exports:{}};!function(t){var e=function(t){var e,r=Object.prototype,o=r.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function s(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{s({},"")}catch(t){s=function(t,e,r){return t[e]=r}}function f(t,e,r,n){var o=e&&e.prototype instanceof m?e:m,i=Object.create(o.prototype),a=new j(n||[]);return i._invoke=function(t,e,r){var n=h;return function(o,i){if(n===v)throw new Error("Generator is already running");if(n===d){if("throw"===o)throw i;return G()}for(r.method=o,r.arg=i;;){var a=r.delegate;if(a){var c=k(a,r);if(c){if(c===y)continue;return c}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===h)throw n=d,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=v;var u=l(t,e,r);if("normal"===u.type){if(n=r.done?d:p,u.arg===y)continue;return{value:u.arg,done:r.done}}"throw"===u.type&&(n=d,r.method="throw",r.arg=u.arg)}}}(t,r,a),i}function l(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=f;var h="suspendedStart",p="suspendedYield",v="executing",d="completed",y={};function m(){}function g(){}function b(){}var S={};S[a]=function(){return this};var E=Object.getPrototypeOf,w=E&&E(E(C([])));w&&w!==r&&o.call(w,a)&&(S=w);var O=b.prototype=m.prototype=Object.create(S);function x(t){["next","throw","return"].forEach((function(e){s(t,e,(function(t){return this._invoke(e,t)}))}))}function P(t,e){function r(i,a,c,u){var s=l(t[i],t,a);if("throw"!==s.type){var f=s.arg,h=f.value;return h&&"object"===n(h)&&o.call(h,"__await")?e.resolve(h.__await).then((function(t){r("next",t,c,u)}),(function(t){r("throw",t,c,u)})):e.resolve(h).then((function(t){f.value=t,c(f)}),(function(t){return r("throw",t,c,u)}))}u(s.arg)}var i;this._invoke=function(t,n){function o(){return new e((function(e,o){r(t,n,e,o)}))}return i=i?i.then(o,o):o()}}function k(t,r){var n=t.iterator[r.method];if(n===e){if(r.delegate=null,"throw"===r.method){if(t.iterator.return&&(r.method="return",r.arg=e,k(t,r),"throw"===r.method))return y;r.method="throw",r.arg=new TypeError("The iterator does not provide a 'throw' method")}return y}var o=l(n,t.iterator,r.arg);if("throw"===o.type)return r.method="throw",r.arg=o.arg,r.delegate=null,y;var i=o.arg;return i?i.done?(r[t.resultName]=i.value,r.next=t.nextLoc,"return"!==r.method&&(r.method="next",r.arg=e),r.delegate=null,y):i:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function R(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function T(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function j(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(R,this),this.reset(!0)}function C(t){if(t){var r=t[a];if(r)return r.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,i=function r(){for(;++n<t.length;)if(o.call(t,n))return r.value=t[n],r.done=!1,r;return r.value=e,r.done=!0,r};return i.next=i}}return{next:G}}function G(){return{value:e,done:!0}}return g.prototype=O.constructor=b,b.constructor=g,g.displayName=s(b,u,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===g||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,b):(t.__proto__=b,s(t,u,"GeneratorFunction")),t.prototype=Object.create(O),t},t.awrap=function(t){return{__await:t}},x(P.prototype),P.prototype[c]=function(){return this},t.AsyncIterator=P,t.async=function(e,r,n,o,i){void 0===i&&(i=Promise);var a=new P(f(e,r,n,o),i);return t.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},x(O),s(O,u,"Generator"),O[a]=function(){return this},O.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=C,j.prototype={constructor:j,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(T),!t)for(var r in this)"t"===r.charAt(0)&&o.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=e)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var r=this;function n(n,o){return c.type="throw",c.arg=t,r.next=n,o&&(r.method="next",r.arg=e),!!o}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],c=a.completion;if("root"===a.tryLoc)return n("end");if(a.tryLoc<=this.prev){var u=o.call(a,"catchLoc"),s=o.call(a,"finallyLoc");if(u&&s){if(this.prev<a.catchLoc)return n(a.catchLoc,!0);if(this.prev<a.finallyLoc)return n(a.finallyLoc)}else if(u){if(this.prev<a.catchLoc)return n(a.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return n(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&o.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var i=n;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),T(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;T(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,r,n){return this.delegate={iterator:C(t),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=e),y}},t}(t.exports);try{regeneratorRuntime=e}catch(t){Function("r","regeneratorRuntime = r")(e)}}(o);var i=o.exports;function a(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?a(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(t,e,n){var o="undefined"!=typeof WorkerGlobalScope,a=function(){var a=r(i.mark((function r(a){var u,s,f,l,h,p;return i.wrap((function(r){for(;;)switch(r.prev=r.next){case 0:if(u=a.detail,s=a.data,(f=u||s).taskName!==t){r.next=14;break}return r.prev=3,r.next=6,n(f.params);case 6:l=r.sent,r.next=12;break;case 9:r.prev=9,r.t0=r.catch(3),h=r.t0;case 12:p=c(c({taskName:t,requestId:f.requestId},l&&{response:l}),h&&{error:h}),o?e.postMessage(p):e.dispatchEvent(new CustomEvent("ogc-client.response",{detail:p}));case 14:case"end":return r.stop()}}),r,null,[[3,9]])})));return function(t){return a.apply(this,arguments)}}();o?e.addEventListener("message",a):e.addEventListener("ogc-client.request",a)}function s(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function f(t){return function(t){if(Array.isArray(t))return s(t)}(t)||function(t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||function(t,e){if(t){if("string"==typeof t)return s(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?s(t,e):void 0}}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function l(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function h(t,e){return h=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},h(t,e)}function p(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&h(t,e)}function v(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function d(t){return d=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},d(t)}function y(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function m(t,e,r){return m=y()?Reflect.construct:function(t,e,r){var n=[null];n.push.apply(n,e);var o=new(Function.bind.apply(t,n));return r&&h(o,r.prototype),o},m.apply(null,arguments)}function g(t){var e="function"==typeof Map?new Map:void 0;return g=function(t){if(null===t||(r=t,-1===Function.toString.call(r).indexOf("[native code]")))return t;var r;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,n)}function n(){return m(t,arguments,d(this).constructor)}return n.prototype=Object.create(t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),h(n,t)},g(t)}function b(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function S(t,e,r){return e&&b(t.prototype,e),r&&b(t,r),t}var E=function(){function t(e){l(this,t),this.chars=f(e),this.charCount=this.chars.length,this.charIndex=0,this.charsToBytes=new Array(this.charCount),this.multiByteMode=!1,this.string=e;var r=this.chars,n=this.charCount,o=this.charsToBytes;if(n===e.length)for(var i=0;i<n;++i)o[i]=i;else{for(var a=0,c=0;c<n;++c)o[c]=a,a+=r[c].length;this.multiByteMode=!0}}return S(t,[{key:"isEnd",get:function(){return this.charIndex>=this.charCount}},{key:"_charLength",value:function(t){var e=t.length;return e<2||!this.multiByteMode?e:t.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,"_").length}},{key:"advance",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.charIndex=Math.min(this.charCount,this.charIndex+t)}},{key:"consume",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=this.peek(t);return this.advance(t),e}},{key:"consumeMatch",value:function(t){if(!t.sticky)throw new Error('\`regex\` must have a sticky flag ("y")');t.lastIndex=this.charsToBytes[this.charIndex];var e=t.exec(this.string);if(null===e)return"";var r=e[0];return this.advance(this._charLength(r)),r}},{key:"consumeMatchFn",value:function(t){for(var e=this.charIndex;!this.isEnd&&t(this.peek());)this.advance();return this.charIndex>e?this.string.slice(this.charsToBytes[e],this.charsToBytes[this.charIndex]):""}},{key:"consumeString",value:function(t){if(this.consumeStringFast(t))return t;if(!this.multiByteMode)return"";var e=t.length,r=this._charLength(t);return r!==e&&t===this.peek(r)?(this.advance(r),t):""}},{key:"consumeStringFast",value:function(t){if(this.peek()===t[0]){var e=t.length;if(1===e)return this.advance(),t;if(this.peek(e)===t)return this.advance(e),t}return""}},{key:"consumeUntilMatch",value:function(t){if(!t.global)throw new Error('\`regex\` must have a global flag ("g")');var e=this.charsToBytes[this.charIndex];t.lastIndex=e;var r=t.exec(this.string);if(null===r||r.index===e)return"";var n=this.string.slice(e,r.index);return this.advance(this._charLength(n)),n}},{key:"consumeUntilString",value:function(t){var e=this.charIndex,r=this.charsToBytes,n=this.string,o=r[e],i=n.indexOf(t,o);if(i<=0)return"";var a=n.slice(o,i);return this.advance(this._charLength(a)),a}},{key:"peek",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;if(this.charIndex>=this.charCount)return"";if(1===t)return this.chars[this.charIndex];var e=this.charsToBytes,r=this.charIndex;return this.string.slice(e[r],e[r+t])}},{key:"reset",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;this.charIndex=t>=0?Math.min(this.charCount,t):Math.max(0,this.charIndex+t)}}]),t}(),w=E,O={},x=Object.freeze(Object.assign(Object.create(null),{amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}));function P(t){if(k(t))return!0;var e=T(t);return 45===e||46===e||e>=48&&e<=57||183===e||e>=768&&e<=879||e>=8255&&e<=8256}function k(t){var e=T(t);return 58===e||95===e||e>=65&&e<=90||e>=97&&e<=122||e>=192&&e<=214||e>=216&&e<=246||e>=248&&e<=767||e>=880&&e<=893||e>=895&&e<=8191||e>=8204&&e<=8205||e>=8304&&e<=8591||e>=11264&&e<=12271||e>=12289&&e<=55295||e>=63744&&e<=64975||e>=65008&&e<=65533||e>=65536&&e<=983039}function R(t){var e=T(t);return 9===e||10===e||13===e||e>=32&&e<=55295||e>=57344&&e<=65533||e>=65536&&e<=1114111}function T(t){return t.codePointAt(0)||-1}O.predefinedEntities=x,O.isNameChar=P,O.isNameStartChar=k,O.isNotXmlChar=function(t){return!R(t)},O.isReferenceChar=function(t){return"#"===t||P(t)},O.isWhitespace=function(t){var e=T(t);return 32===e||9===e||10===e||13===e},O.isXmlChar=R;var j=function(){function t(){l(this,t),this.parent=null}return S(t,[{key:"document",get:function(){return this.parent?this.parent.document:null}},{key:"isRootNode",get:function(){return!!this.parent&&this.parent===this.document}},{key:"preserveWhitespace",get:function(){return Boolean(this.parent&&this.parent.preserveWhitespace)}},{key:"type",get:function(){return""}},{key:"toJSON",value:function(){var t={type:this.type};return this.isRootNode&&(t.isRootNode=!0),this.preserveWhitespace&&(t.preserveWhitespace=!0),t}}]),t}();j.TYPE_CDATA="cdata",j.TYPE_COMMENT="comment",j.TYPE_DOCUMENT="document",j.TYPE_ELEMENT="element",j.TYPE_PROCESSING_INSTRUCTION="pi",j.TYPE_TEXT="text";var C=j;function G(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var N=C,A=function(t){p(r,N);var e=G(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).text=n,t}return S(r,[{key:"type",get:function(){return N.TYPE_TEXT}},{key:"toJSON",value:function(){return Object.assign(N.prototype.toJSON.call(this),{text:this.text})}}]),r}(),F=A;function I(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var L=C,M=F,B=function(t){p(r,M);var e=I(r);function r(){return l(this,r),e.apply(this,arguments)}return S(r,[{key:"type",get:function(){return L.TYPE_CDATA}}]),r}(),_=B;function U(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var D=C,W=function(t){p(r,D);var e=U(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).content=n,t}return S(r,[{key:"type",get:function(){return D.TYPE_COMMENT}},{key:"toJSON",value:function(){return Object.assign(D.prototype.toJSON.call(this),{content:this.content})}}]),r}(),X=W;function Y(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var q=C,J=function(t){p(r,q);var e=Y(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Object.create(null),i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return l(this,r),(n=e.call(this)).name=t,n.attributes=o,n.children=i,n}return S(r,[{key:"isEmpty",get:function(){return 0===this.children.length}},{key:"preserveWhitespace",get:function(){for(var t=this;t instanceof r;){if("xml:space"in t.attributes)return"preserve"===t.attributes["xml:space"];t=t.parent}return!1}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return q.TYPE_ELEMENT}},{key:"toJSON",value:function(){return Object.assign(q.prototype.toJSON.call(this),{name:this.name,attributes:this.attributes,children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),V=J;function $(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var K=V,z=C,H=function(t){p(r,z);var e=$(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return l(this,r),(t=e.call(this)).children=n,t}return S(r,[{key:"document",get:function(){return this}},{key:"root",get:function(){return this.children.find((function(t){return t instanceof K}))||null}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return z.TYPE_DOCUMENT}},{key:"toJSON",value:function(){return Object.assign(z.prototype.toJSON.call(this),{children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),Q=H;function Z(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var tt=C,et=function(t){p(r,tt);var e=Z(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return l(this,r),(n=e.call(this)).name=t,n.content=o,n}return S(r,[{key:"type",get:function(){return tt.TYPE_PROCESSING_INSTRUCTION}},{key:"toJSON",value:function(){return Object.assign(tt.prototype.toJSON.call(this),{name:this.name,content:this.content})}}]),r}(),rt=et;function nt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return ot(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return ot(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function ot(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var it=w,at=O,ct=_,ut=X,st=Q,ft=V,lt=rt,ht=F,pt=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(l(this,t),this.document=new st,this.currentNode=this.document,this.options=r,this.scanner=new it(vt(e)),this.consumeProlog(),this.consumeElement()||this.error("Root element is missing or invalid");this.consumeMisc(););this.scanner.isEnd||this.error("Extra content at the end of the document")}return S(t,[{key:"addNode",value:function(t){t.parent=this.currentNode,this.currentNode.children.push(t)}},{key:"addText",value:function(t){var e=this.currentNode.children;if(e.length>0){var r=e[e.length-1];if(r instanceof ht)return void(r.text+=t)}this.addNode(new ht(t))}},{key:"consumeAttributeValue",value:function(){var t,e=this.scanner,r=e.peek();if('"'!==r&&"'"!==r)return!1;e.advance();var n=!1,o="",i='"'===r?new RegExp('[^"&<]+',"y"):new RegExp("[^'&<]+","y");t:for(;!e.isEnd;){switch((t=e.consumeMatch(i))&&(this.validateChars(t),o+=t.replace(/[\\t\\r\\n]/g," ")),e.peek()){case r:n=!0;break t;case"&":o+=this.consumeReference();continue;case"<":this.error("Unescaped \`<\` is not allowed in an attribute value");break;case"":this.error("Unclosed attribute")}}return n||this.error("Unclosed attribute"),e.advance(),o}},{key:"consumeCdataSection",value:function(){var t=this.scanner;if(!t.consumeStringFast("<![CDATA["))return!1;var e=t.consumeUntilString("]]>");return this.validateChars(e),t.consumeStringFast("]]>")||this.error("Unclosed CDATA section"),this.options.preserveCdata?this.addNode(new ct(e)):this.addText(e),!0}},{key:"consumeCharData",value:function(){var t=this.scanner,e=t.consumeUntilMatch(/<|&|]]>/g);return!!e&&(this.validateChars(e),"]"===t.peek()&&"]]>"===t.peek(3)&&this.error("Element content may not contain the CDATA section close delimiter \`]]>\`"),this.addText(e),!0)}},{key:"consumeComment",value:function(){var t=this.scanner;if(!t.consumeStringFast("\\x3c!--"))return!1;var e=t.consumeUntilString("--");return this.validateChars(e),t.consumeStringFast("--\\x3e")||("--"===t.peek(2)?this.error("The string \`--\` isn't allowed inside a comment"):this.error("Unclosed comment")),this.options.preserveComments&&this.addNode(new ut(e.trim())),!0}},{key:"consumeContentReference",value:function(){var t=this.consumeReference();return!!t&&(this.addText(t),!0)}},{key:"consumeDoctypeDeclaration",value:function(){var t=this.scanner;return!(!t.consumeStringFast("<!DOCTYPE")||!this.consumeWhitespace())&&(t.consumeMatch(new RegExp("[^[>]+","y")),t.consumeMatch(new RegExp("\\\\[[\\\\s\\\\S]+?\\\\][\\\\x20\\\\t\\\\r\\\\n]*>","y"))||t.consumeStringFast(">")||this.error("Unclosed doctype declaration"),!0)}},{key:"consumeElement",value:function(){var t=this.scanner,e=t.charIndex;if("<"!==t.peek())return!1;t.advance();var r=this.consumeName();if(!r)return t.reset(e),!1;for(var n=Object.create(null);this.consumeWhitespace();){var o=this.consumeName();if(o){var i=this.consumeEqual()&&this.consumeAttributeValue();!1===i&&this.error("Attribute value expected"),o in n&&this.error("Duplicate attribute: ".concat(o)),"xml:space"===o&&"default"!==i&&"preserve"!==i&&this.error('Value of the \`xml:space\` attribute must be "default" or "preserve"'),n[o]=i}}if(this.options.sortAttributes){for(var a=Object.keys(n).sort(),c=Object.create(null),u=0;u<a.length;++u){var s=a[u];c[s]=n[s]}n=c}var f=Boolean(t.consumeStringFast("/>")),l=new ft(r,n);if(l.parent=this.currentNode,!f){for(t.consumeStringFast(">")||this.error("Unclosed start tag for element \`".concat(r,"\`")),this.currentNode=l,this.consumeCharData();this.consumeElement()||this.consumeContentReference()||this.consumeCdataSection()||this.consumeProcessingInstruction()||this.consumeComment();)this.consumeCharData();var h,p=t.charIndex;t.consumeStringFast("</")&&(h=this.consumeName())&&h===r||(t.reset(p),this.error("Missing end tag for element ".concat(r))),this.consumeWhitespace(),t.consumeStringFast(">")||this.error("Unclosed end tag for element ".concat(r)),this.currentNode=l.parent}return this.addNode(l),!0}},{key:"consumeEqual",value:function(){return this.consumeWhitespace(),!!this.scanner.consumeStringFast("=")&&(this.consumeWhitespace(),!0)}},{key:"consumeMisc",value:function(){return this.consumeComment()||this.consumeProcessingInstruction()||this.consumeWhitespace()}},{key:"consumeName",value:function(){return at.isNameStartChar(this.scanner.peek())?this.scanner.consumeMatchFn(at.isNameChar):""}},{key:"consumeProcessingInstruction",value:function(){var t=this.scanner,e=t.charIndex;if(!t.consumeStringFast("<?"))return!1;var r=this.consumeName();if(r?"xml"===r.toLowerCase()&&(t.reset(e),this.error("XML declaration isn't allowed here")):this.error("Invalid processing instruction"),!this.consumeWhitespace()){if(t.consumeStringFast("?>"))return this.addNode(new lt(r)),!0;this.error("Whitespace is required after a processing instruction name")}var n=t.consumeUntilString("?>");return this.validateChars(n),t.consumeStringFast("?>")||this.error("Unterminated processing instruction"),this.addNode(new lt(r,n)),!0}},{key:"consumeProlog",value:function(){var t=this.scanner,e=t.charIndex;for(this.consumeXmlDeclaration();this.consumeMisc(););if(this.consumeDoctypeDeclaration())for(;this.consumeMisc(););return e<t.charIndex}},{key:"consumeReference",value:function(){var t=this.scanner;if("&"!==t.peek())return!1;t.advance();var e,r=t.consumeMatchFn(at.isReferenceChar);if(";"!==t.consume()&&this.error("Unterminated reference (a reference must end with \`;\`)"),"#"===r[0]){var o="x"===r[1]?parseInt(r.slice(2),16):parseInt(r.slice(1),10);isNaN(o)&&this.error("Invalid character reference"),e=String.fromCodePoint(o),at.isXmlChar(e)||this.error("Character reference resolves to an invalid character")}else if(void 0===(e=at.predefinedEntities[r])){var i=this.options,a=i.ignoreUndefinedEntities,c=i.resolveUndefinedEntity,u="&".concat(r,";");if(c){var s=c(u);if(null!=s){var f=n(s);if("string"!==f)throw new TypeError("\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ".concat(f));return s}}if(a)return u;t.reset(-u.length),this.error("Named entity isn't defined: ".concat(u))}return e}},{key:"consumeSystemLiteral",value:function(){var t=this.scanner,e=t.consumeStringFast('"')||t.consumeStringFast("'");if(!e)return!1;var r=t.consumeUntilString(e);return this.validateChars(r),t.consumeStringFast(e)||this.error("Missing end quote"),r}},{key:"consumeWhitespace",value:function(){return Boolean(this.scanner.consumeMatchFn(at.isWhitespace))}},{key:"consumeXmlDeclaration",value:function(){var t=this.scanner;if(!t.consumeStringFast("<?xml"))return!1;this.consumeWhitespace()||this.error("Invalid XML declaration");var e=Boolean(t.consumeStringFast("version"))&&this.consumeEqual()&&this.consumeSystemLiteral();if(!1===e?this.error("XML version is missing or invalid"):/^1\\.[0-9]+$/.test(e)||this.error("Invalid character in version number"),this.consumeWhitespace()){Boolean(t.consumeStringFast("encoding"))&&this.consumeEqual()&&this.consumeSystemLiteral()&&this.consumeWhitespace();var r=Boolean(t.consumeStringFast("standalone"))&&this.consumeEqual()&&this.consumeSystemLiteral();r&&("yes"!==r&&"no"!==r&&this.error('Only "yes" and "no" are permitted as values of \`standalone\`'),this.consumeWhitespace())}return t.consumeStringFast("?>")||this.error("Invalid or unclosed XML declaration"),!0}},{key:"error",value:function(t){for(var e=this.scanner,r=e.charIndex,n=e.string,o=1,i="",a=1,c=0;c<r;++c){var u=n[c];"\\n"===u?(o=1,i="",a+=1):(o+=1,i+=u)}var s=n.indexOf("\\n",r),f=0;(i+=-1===s?n.slice(r):n.slice(r,s)).length>50&&(o<40?i=i.slice(0,50):(f=o-20,i=i.slice(f,o+30)));var l=new Error("".concat(t," (line ").concat(a,", column ").concat(o,")\\n")+"  ".concat(i,"\\n")+" ".repeat(o-f+1)+"^\\n");throw Object.assign(l,{column:o,excerpt:i,line:a,pos:r}),l}},{key:"validateChars",value:function(t){var e,r=0,n=nt(t);try{for(n.s();!(e=n.n()).done;){var o=e.value;at.isNotXmlChar(o)&&(this.scanner.reset(-(f(t).length-r)),this.error("Invalid character")),r+=1}}catch(t){n.e(t)}finally{n.f()}}}]),t}();function vt(t){return"\\ufeff"===t[0]&&(t=t.slice(1)),t.replace(/\\r\\n?/g,"\\n")}var dt=pt,yt=_,mt=X,gt=Q,bt=V,St=C,Et=rt,wt=F;function Ot(t,e){return new dt(t,e).document}Ot.XmlCdata=yt,Ot.XmlComment=mt,Ot.XmlDocument=gt,Ot.XmlElement=bt,Ot.XmlNode=St,Ot.XmlProcessingInstruction=Et,Ot.XmlText=wt;var xt=Ot;function Pt(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var kt=function(t){p(r,g(Error));var e=Pt(r);function r(t){return l(this,r),e.call(this,t)}return r}();function Rt(t){return t.children[0]}function Tt(t){var e=t.indexOf(":");return e>-1?t.substr(e+1):t}function jt(t){return t.name||""}function Ct(t,e,r){var n=Tt(e);return t&&Array.isArray(t.children)?t.children.reduce((function t(e,o){return Tt(jt(o))===n&&e.push(o),r&&Array.isArray(o.children)?[].concat(f(e),f(o.children.reduce(t,[]))):e}),[]):[]}function Gt(t,e,r){return Ct(t,e,r)[0]||null}function Nt(t){return t&&Array.isArray(t.children)?f(t.children.filter((function(t){return"XmlElement"===t.constructor.name}))):[]}function At(t){var e=t&&Array.isArray(t.children)?t.children.find((function(t){return"text"===t.type})):null;return e?e.text:""}function Ft(t,e){return t&&t.attributes[e]||""}var It=function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];l(this,t),this.message=e,this.httpStatus=r,this.isCrossOriginRelated=n};function Lt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Mt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Mt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Mt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Bt=["utf-8","utf-16","iso-8859-1"];function _t(t,e){var r,n=e?function(t){var e=/charset=([^;]+)/.exec(t);return e?e[1]:null}(e):null,o=Lt(n?[n].concat(Bt):Bt);try{for(o.s();!(r=o.n()).done;){var i=r.value;try{return new TextDecoder(i,{fatal:!0}).decode(t)}catch(t){}}}catch(t){o.e(t)}finally{o.f()}return console.warn("XML document encoding could not be determined, falling back to ".concat("utf-8",".")),new TextDecoder("utf-8").decode(t)}function Ut(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Dt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Dt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Dt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Wt=new Map;function Xt(t){return function(t){if(Wt.has(t))return Wt.get(t);var e=fetch(t);return e.finally((function(){return Wt.delete(t)})),Wt.set(t,e),e}(t).catch((function(){return fetch(t,{method:"HEAD",mode:"no-cors"}).catch((function(t){throw new It("Fetching the document failed either due to network errors or unreachable host, error is: ".concat(t.message),0,!1)})).then((function(){throw new It("The document could not be fetched due to CORS limitations",0,!0)}))})).then(function(){var t=r(i.mark((function t(e){var r,n,o;return i.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(e.ok){t.next=5;break}return t.next=3,e.text();case 3:throw r=t.sent,new It("Received an error with code ".concat(e.status,": ").concat(r),e.status,!1);case 5:return t.next=7,e.arrayBuffer();case 7:return n=t.sent,o=e.headers.get("Content-Type"),t.abrupt("return",_t(n,o));case 10:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}()).then((function(t){return function(t){var e=null;try{e=xt(t)}catch(t){throw new kt(t.message)}return e}(t)}))}function Yt(t,e){var r=t.match(/(https?%3A%2F%2F[^/]+)$/);if(r){var n=r[1],o=Yt(decodeURIComponent(n),e);return t.replace(n,encodeURIComponent(o))}var i,a=new URL(t),c=Object.keys(e),u=c.map((function(t){return t.toLowerCase()})),s=[],f=Ut(a.searchParams.keys());try{for(f.s();!(i=f.n()).done;){var l=i.value;u.indexOf(l.toLowerCase())>-1&&s.push(l)}}catch(t){f.e(t)}finally{f.f()}return s.map((function(t){return a.searchParams.delete(t)})),c.forEach((function(t){return a.searchParams.set(t,!0===e[t]?"":e[t])})),a.toString()}var qt=["EPSG:4046","EPSG:4075","EPSG:4120","EPSG:4122","EPSG:4124","EPSG:4126","EPSG:4149","EPSG:4151","EPSG:4153","EPSG:4155","EPSG:4157","EPSG:4159","EPSG:4161","EPSG:4163","EPSG:4165","EPSG:4167","EPSG:4169","EPSG:4171","EPSG:4173","EPSG:4175","EPSG:4178","EPSG:4180","EPSG:4182","EPSG:4184","EPSG:4188","EPSG:4190","EPSG:4191","EPSG:4196","EPSG:4198","EPSG:4202","EPSG:4210","EPSG:4211","EPSG:4214","EPSG:4226","EPSG:4229","EPSG:4231","EPSG:4233","EPSG:4236","EPSG:4238","EPSG:4240","EPSG:4242","EPSG:4244","EPSG:4246","EPSG:4248","EPSG:4250","EPSG:4252","EPSG:4255","EPSG:4258","EPSG:4261","EPSG:4264","EPSG:4267","EPSG:4270","EPSG:4273","EPSG:4276","EPSG:4279","EPSG:4281","EPSG:4284","EPSG:4286","EPSG:4288","EPSG:4292","EPSG:4295","EPSG:4297","EPSG:4299","EPSG:4302","EPSG:4324","EPSG:4326"];function Jt(t){return qt.indexOf(Vt(t))>-1}function Vt(t){if(/^urn:(?:x-)?ogc:def:crs:epsg:/.test(t.toLowerCase())){var e=/([0-9]+)$/.exec(t)[1];return"EPSG:".concat(e)}return t}function $t(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function Kt(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?$t(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):$t(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function zt(t){return Rt(t).attributes.version}function Ht(t){var e=zt(t);return Ct(Gt(Rt(t),"Capability"),"Layer").map((function(t){return Qt(t,e)}))}function Qt(e,r){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a="1.3.0"===r?"CRS":"SRS",c=Ct(e,a).map(At),u=c.length>0?c:n,s=Ct(e,"Style").map(Zt),f=s.length>0?s:o;function l(t){return(Jt(Ft(t,a))&&"1.3.0"===r?["miny","minx","maxy","maxx"]:["minx","miny","maxx","maxy"]).map((function(e){return Ft(t,e)}))}var h=Gt(e,"Attribution"),p=null!==h?te(h):i,v=Ct(e,"Layer").map((function(t){return Qt(t,r,u,f,p)}));return Kt({name:At(Gt(e,"Name")),title:At(Gt(e,"Title")),abstract:At(Gt(e,"Abstract")),availableCrs:u,styles:f,attribution:p,boundingBoxes:Ct(e,"BoundingBox").reduce((function(e,r){return Kt(Kt({},e),{},t({},Ft(r,a),l(r)))}),{})},v.length&&{children:v})}function Zt(t){var e=Ft(Gt(Gt(t,"LegendURL"),"OnlineResource"),"xlink:href");return Kt({name:At(Gt(t,"Name")),title:At(Gt(t,"Title"))},e&&{legendUrl:e})}function te(t){var e=Ft(Gt(Gt(t,"LogoURL"),"OnlineResource"),"xlink:href"),r=Ft(Gt(t,"OnlineResource"),"xlink:href"),n=At(Gt(t,"Title"));return Kt(Kt(Kt({},n&&{title:n}),r&&{url:r}),e&&{logoUrl:e})}function ee(t){return Rt(t).attributes.version}function re(t){var e;if(ee(t).startsWith("1.0")){var r=Gt(Gt(Gt(Rt(t),"Capability"),"Request"),"GetFeature");e=Nt(Gt(r,"ResultFormat")).map(jt)}else{var n=Ct(Gt(Rt(t),"OperationsMetadata"),"Operation").find((function(t){return"GetFeature"===Ft(t,"name")})),o=Ct(n,"Parameter").find((function(t){return"outputFormat"===Ft(t,"name")}));e=Ct(o,"Value",!0).map(At)}return e}function ne(t){var e=ee(t),r=re(t);return Ct(Gt(Rt(t),"FeatureTypeList"),"FeatureType").map((function(t){return function(t,e,r){var n=e.startsWith("2.")?"CRS":"SRS",o=e.startsWith("1.0")?"SRS":"Default".concat(n);function i(){var e=Gt(t,"LatLongBoundingBox");return["minx","miny","maxx","maxy"].map((function(t){return Ft(e,t)})).map(parseFloat)}function a(){var e=Gt(t,"WGS84BoundingBox");return["LowerCorner","UpperCorner"].map((function(t){return Gt(e,t)})).map((function(t){return At(t).split(" ")})).reduce((function(t,e){return[].concat(f(t),f(e))})).map(parseFloat)}var c=e.startsWith("1.0")?[]:Ct(t,"Other".concat(n)).map(At).map(Vt),u=e.startsWith("1.0")?[]:Ct(Gt(t,"OutputFormats"),"Format").map(At);return{name:At(Gt(t,"Name")),title:At(Gt(t,"Title")),abstract:At(Gt(t,"Abstract")),defaultCrs:Vt(At(Gt(t,o))),otherCrs:c,outputFormats:u.length>0?u:r,latLonBoundingBox:e.startsWith("1.0")?i():a()}}(t,e,r)}))}function oe(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function ie(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?oe(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):oe(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ae(e,r,n){var o,i=Rt(e);if(n.startsWith("2.0"))o=Ct(i,"member").map((function(t){return Nt(t)[0]}));else{var a=Gt(i,"featureMembers");o=a?Nt(a):Ct(i,"featureMember").map((function(t){return Nt(t)[0]}))}var c="1.0.0"===n?"fid":"gml:id";function u(e){return Nt(e).filter((function(t){return Tt(jt(t))in r.properties})).reduce((function(e,n){var o=Tt(jt(n));return ie(ie({},e),{},t({},o,function(t,e){switch(r.properties[t]){case"integer":return parseInt(e);case"float":return parseFloat(e);case"boolean":return"true"===e;default:return e}}(o,At(n))))}),{})}return o.map((function(t){return{id:Ft(t,c),properties:u(t)}}))}function ce(e,r,n,o,i,a,c,u,s,f){var l="2.0.0"===r?"COUNT":"MAXFEATURES",h=t({SERVICE:"WFS",REQUEST:"GetFeature",VERSION:r},"2.0.0"===r?"TYPENAMES":"TYPENAME",n);if(void 0!==o&&(h.OUTPUTFORMAT=o),void 0!==a&&(h.PROPERTYNAME=a.join(",")),c?(h.RESULTTYPE="hits",h[l]="1"):void 0!==i&&(h[l]=i.toString(10)),u&&(h.SRSNAME=u),s){var p=s.join(",");h.BBOX=f?"".concat(p,",").concat(f):p}return Yt(e,h)}u("parseWmsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,r=Gt(Rt(e),"Service"),n=Ct(Gt(r,"KeywordList"),"Keyword").map(At).filter((function(t,e,r){return r.indexOf(t)===e})),{title:At(Gt(r,"Title")),name:At(Gt(r,"Name")),abstract:At(Gt(r,"Abstract")),fees:At(Gt(r,"Fees")),constraints:At(Gt(r,"AccessConstraints")),keywords:n}),layers:Ht(t),version:zt(t)};var e,r,n}))})),u("parseWfsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,n=ee(e),o=n.startsWith("1.0")?"Service":"ServiceIdentification",i=n.startsWith("1.0")?"Name":"ServiceType",a=Gt(Rt(e),o),r=n.startsWith("1.0")?At(Gt(a,"Keywords")).split(",").map((function(t){return t.trim()})):Ct(Gt(a,"Keywords"),"Keyword").map(At),{title:At(Gt(a,"Title")),name:At(Gt(a,i)),abstract:At(Gt(a,"Abstract")),fees:At(Gt(a,"Fees")),constraints:At(Gt(a,"AccessConstraints")),keywords:r,outputFormats:re(e)}),featureTypes:ne(t),version:ee(t)};var e,r,n,o,i,a}))})),u("queryWfsFeatureTypeDetails",self,(function(t){var e=t.url,r=t.serviceVersion,n=t.featureTypeFull;return Xt(ce(e,r,n.name,void 0,void 0,Object.keys(n.properties))).then((function(t){return{props:(e=ae(t,n,r),e.reduce((function(t,e){var r=function(r){var n=e.properties[r];r in t||(t[r]={uniqueValues:[]});var o=t[r].uniqueValues.find((function(t){return t.value===n}));o?o.count++:t[r].uniqueValues.push({value:n,count:1})};for(var n in e.properties)r(n);return t}),{}))};var e}))}));
`], { type: "application/javascript" })), {
    type: "module"
  })), e0;
}
function sB(t) {
  return oB("parseWmsCapabilities", aB(), {
    url: t
  });
}
const du = "";
class lB {
  constructor(e) {
    this.chars = [...e], this.charCount = this.chars.length, this.charIndex = 0, this.charsToBytes = new Array(this.charCount), this.multiByteMode = !1, this.string = e;
    let { chars: n, charCount: a, charsToBytes: s } = this;
    if (a === e.length)
      for (let f = 0; f < a; ++f)
        s[f] = f;
    else {
      for (let f = 0, o = 0; o < a; ++o)
        s[o] = f, f += n[o].length;
      this.multiByteMode = !0;
    }
  }
  get isEnd() {
    return this.charIndex >= this.charCount;
  }
  _charLength(e) {
    let { length: n } = e;
    return n < 2 || !this.multiByteMode ? n : e.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length;
  }
  advance(e = 1) {
    this.charIndex = Math.min(this.charCount, this.charIndex + e);
  }
  consume(e = 1) {
    let n = this.peek(e);
    return this.advance(e), n;
  }
  consumeMatch(e) {
    if (!e.sticky)
      throw new Error('`regex` must have a sticky flag ("y")');
    e.lastIndex = this.charsToBytes[this.charIndex];
    let n = e.exec(this.string);
    if (n === null)
      return du;
    let a = n[0];
    return this.advance(this._charLength(a)), a;
  }
  consumeMatchFn(e) {
    let n = this.charIndex;
    for (; !this.isEnd && e(this.peek()); )
      this.advance();
    return this.charIndex > n ? this.string.slice(this.charsToBytes[n], this.charsToBytes[this.charIndex]) : du;
  }
  consumeString(e) {
    if (this.consumeStringFast(e))
      return e;
    if (!this.multiByteMode)
      return du;
    let { length: n } = e, a = this._charLength(e);
    return a !== n && e === this.peek(a) ? (this.advance(a), e) : du;
  }
  consumeStringFast(e) {
    if (this.peek() === e[0]) {
      let { length: n } = e;
      if (n === 1)
        return this.advance(), e;
      if (this.peek(n) === e)
        return this.advance(n), e;
    }
    return du;
  }
  consumeUntilMatch(e) {
    if (!e.global)
      throw new Error('`regex` must have a global flag ("g")');
    let n = this.charsToBytes[this.charIndex];
    e.lastIndex = n;
    let a = e.exec(this.string);
    if (a === null || a.index === n)
      return du;
    let s = this.string.slice(n, a.index);
    return this.advance(this._charLength(s)), s;
  }
  consumeUntilString(e) {
    let { charIndex: n, charsToBytes: a, string: s } = this, f = a[n], o = s.indexOf(e, f);
    if (o <= 0)
      return du;
    let m = s.slice(f, o);
    return this.advance(this._charLength(m)), m;
  }
  peek(e = 1) {
    if (this.charIndex >= this.charCount)
      return du;
    if (e === 1)
      return this.chars[this.charIndex];
    let { charsToBytes: n, charIndex: a } = this;
    return this.string.slice(n[a], n[a + e]);
  }
  reset(e = 0) {
    this.charIndex = e >= 0 ? Math.min(this.charCount, e) : Math.max(0, this.charIndex + e);
  }
}
var uB = lB, Bu = {};
const cB = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
  amp: "&",
  apos: "'",
  gt: ">",
  lt: "<",
  quot: '"'
}));
Bu.predefinedEntities = cB;
function KM(t) {
  if (YM(t))
    return !0;
  let e = Av(t);
  return e === 45 || e === 46 || e >= 48 && e <= 57 || e === 183 || e >= 768 && e <= 879 || e >= 8255 && e <= 8256;
}
Bu.isNameChar = KM;
function YM(t) {
  let e = Av(t);
  return e === 58 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 192 && e <= 214 || e >= 216 && e <= 246 || e >= 248 && e <= 767 || e >= 880 && e <= 893 || e >= 895 && e <= 8191 || e >= 8204 && e <= 8205 || e >= 8304 && e <= 8591 || e >= 11264 && e <= 12271 || e >= 12289 && e <= 55295 || e >= 63744 && e <= 64975 || e >= 65008 && e <= 65533 || e >= 65536 && e <= 983039;
}
Bu.isNameStartChar = YM;
function hB(t) {
  return !JM(t);
}
Bu.isNotXmlChar = hB;
function fB(t) {
  return t === "#" || KM(t);
}
Bu.isReferenceChar = fB;
function pB(t) {
  let e = Av(t);
  return e === 32 || e === 9 || e === 10 || e === 13;
}
Bu.isWhitespace = pB;
function JM(t) {
  let e = Av(t);
  return e === 9 || e === 10 || e === 13 || e >= 32 && e <= 55295 || e >= 57344 && e <= 65533 || e >= 65536 && e <= 1114111;
}
Bu.isXmlChar = JM;
function Av(t) {
  return t.codePointAt(0) || -1;
}
class th {
  constructor() {
    this.parent = null;
  }
  get document() {
    return this.parent ? this.parent.document : null;
  }
  get isRootNode() {
    return this.parent ? this.parent === this.document : !1;
  }
  get preserveWhitespace() {
    return Boolean(this.parent && this.parent.preserveWhitespace);
  }
  get type() {
    return "";
  }
  toJSON() {
    let e = {
      type: this.type
    };
    return this.isRootNode && (e.isRootNode = !0), this.preserveWhitespace && (e.preserveWhitespace = !0), e;
  }
}
th.TYPE_CDATA = "cdata";
th.TYPE_COMMENT = "comment";
th.TYPE_DOCUMENT = "document";
th.TYPE_ELEMENT = "element";
th.TYPE_PROCESSING_INSTRUCTION = "pi";
th.TYPE_TEXT = "text";
var rh = th;
const t0 = rh;
class dB extends t0 {
  constructor(e = "") {
    super(), this.text = e;
  }
  get type() {
    return t0.TYPE_TEXT;
  }
  toJSON() {
    return Object.assign(t0.prototype.toJSON.call(this), {
      text: this.text
    });
  }
}
var J1 = dB;
const mB = rh, yB = J1;
class gB extends yB {
  get type() {
    return mB.TYPE_CDATA;
  }
}
var QM = gB;
const r0 = rh;
class vB extends r0 {
  constructor(e = "") {
    super(), this.content = e;
  }
  get type() {
    return r0.TYPE_COMMENT;
  }
  toJSON() {
    return Object.assign(r0.prototype.toJSON.call(this), {
      content: this.content
    });
  }
}
var eI = vB;
const n0 = rh;
class Q1 extends n0 {
  constructor(e, n = /* @__PURE__ */ Object.create(null), a = []) {
    super(), this.name = e, this.attributes = n, this.children = a;
  }
  get isEmpty() {
    return this.children.length === 0;
  }
  get preserveWhitespace() {
    let e = this;
    for (; e instanceof Q1; ) {
      if ("xml:space" in e.attributes)
        return e.attributes["xml:space"] === "preserve";
      e = e.parent;
    }
    return !1;
  }
  get text() {
    return this.children.map((e) => "text" in e ? e.text : "").join("");
  }
  get type() {
    return n0.TYPE_ELEMENT;
  }
  toJSON() {
    return Object.assign(n0.prototype.toJSON.call(this), {
      name: this.name,
      attributes: this.attributes,
      children: this.children.map((e) => e.toJSON())
    });
  }
}
var ex = Q1;
const _B = ex, i0 = rh;
class xB extends i0 {
  constructor(e = []) {
    super(), this.children = e;
  }
  get document() {
    return this;
  }
  get root() {
    return this.children.find((e) => e instanceof _B) || null;
  }
  get text() {
    return this.children.map((e) => "text" in e ? e.text : "").join("");
  }
  get type() {
    return i0.TYPE_DOCUMENT;
  }
  toJSON() {
    return Object.assign(i0.prototype.toJSON.call(this), {
      children: this.children.map((e) => e.toJSON())
    });
  }
}
var tI = xB;
const o0 = rh;
class bB extends o0 {
  constructor(e, n = "") {
    super(), this.name = e, this.content = n;
  }
  get type() {
    return o0.TYPE_PROCESSING_INSTRUCTION;
  }
  toJSON() {
    return Object.assign(o0.prototype.toJSON.call(this), {
      name: this.name,
      content: this.content
    });
  }
}
var rI = bB;
const wB = uB, Tc = Bu, EB = QM, SB = eI, TB = tI, MB = ex, rE = rI, nE = J1, a0 = "";
class IB {
  constructor(e, n = {}) {
    for (this.document = new TB(), this.currentNode = this.document, this.options = n, this.scanner = new wB(CB(e)), this.consumeProlog(), this.consumeElement() || this.error("Root element is missing or invalid"); this.consumeMisc(); )
      ;
    this.scanner.isEnd || this.error("Extra content at the end of the document");
  }
  addNode(e) {
    e.parent = this.currentNode, this.currentNode.children.push(e);
  }
  addText(e) {
    let { children: n } = this.currentNode;
    if (n.length > 0) {
      let a = n[n.length - 1];
      if (a instanceof nE) {
        a.text += e;
        return;
      }
    }
    this.addNode(new nE(e));
  }
  consumeAttributeValue() {
    let { scanner: e } = this, n = e.peek();
    if (n !== '"' && n !== "'")
      return !1;
    e.advance();
    let a, s = !1, f = a0, o = n === '"' ? /[^"&<]+/y : /[^'&<]+/y;
    e:
      for (; !e.isEnd; )
        switch (a = e.consumeMatch(o), a && (this.validateChars(a), f += a.replace(/[\t\r\n]/g, " ")), e.peek()) {
          case n:
            s = !0;
            break e;
          case "&":
            f += this.consumeReference();
            continue;
          case "<":
            this.error("Unescaped `<` is not allowed in an attribute value");
            break;
          case a0:
            this.error("Unclosed attribute");
            break;
        }
    return s || this.error("Unclosed attribute"), e.advance(), f;
  }
  consumeCdataSection() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<![CDATA["))
      return !1;
    let n = e.consumeUntilString("]]>");
    return this.validateChars(n), e.consumeStringFast("]]>") || this.error("Unclosed CDATA section"), this.options.preserveCdata ? this.addNode(new EB(n)) : this.addText(n), !0;
  }
  consumeCharData() {
    let { scanner: e } = this, n = e.consumeUntilMatch(/<|&|]]>/g);
    return n ? (this.validateChars(n), e.peek() === "]" && e.peek(3) === "]]>" && this.error("Element content may not contain the CDATA section close delimiter `]]>`"), this.addText(n), !0) : !1;
  }
  consumeComment() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<!--"))
      return !1;
    let n = e.consumeUntilString("--");
    return this.validateChars(n), e.consumeStringFast("-->") || (e.peek(2) === "--" ? this.error("The string `--` isn't allowed inside a comment") : this.error("Unclosed comment")), this.options.preserveComments && this.addNode(new SB(n.trim())), !0;
  }
  consumeContentReference() {
    let e = this.consumeReference();
    return e ? (this.addText(e), !0) : !1;
  }
  consumeDoctypeDeclaration() {
    let { scanner: e } = this;
    return !e.consumeStringFast("<!DOCTYPE") || !this.consumeWhitespace() ? !1 : (e.consumeMatch(/[^[>]+/y), e.consumeMatch(/\[[\s\S]+?\][\x20\t\r\n]*>/y) || e.consumeStringFast(">") || this.error("Unclosed doctype declaration"), !0);
  }
  consumeElement() {
    let { scanner: e } = this, n = e.charIndex;
    if (e.peek() !== "<")
      return !1;
    e.advance();
    let a = this.consumeName();
    if (!a)
      return e.reset(n), !1;
    let s = /* @__PURE__ */ Object.create(null);
    for (; this.consumeWhitespace(); ) {
      let m = this.consumeName();
      if (!m)
        continue;
      let g = this.consumeEqual() && this.consumeAttributeValue();
      g === !1 && this.error("Attribute value expected"), m in s && this.error(`Duplicate attribute: ${m}`), m === "xml:space" && g !== "default" && g !== "preserve" && this.error('Value of the `xml:space` attribute must be "default" or "preserve"'), s[m] = g;
    }
    if (this.options.sortAttributes) {
      let m = Object.keys(s).sort(), g = /* @__PURE__ */ Object.create(null);
      for (let b = 0; b < m.length; ++b) {
        let T = m[b];
        g[T] = s[T];
      }
      s = g;
    }
    let f = Boolean(e.consumeStringFast("/>")), o = new MB(a, s);
    if (o.parent = this.currentNode, !f) {
      for (e.consumeStringFast(">") || this.error(`Unclosed start tag for element \`${a}\``), this.currentNode = o, this.consumeCharData(); this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment(); )
        this.consumeCharData();
      let m = e.charIndex, g;
      (!e.consumeStringFast("</") || !(g = this.consumeName()) || g !== a) && (e.reset(m), this.error(`Missing end tag for element ${a}`)), this.consumeWhitespace(), e.consumeStringFast(">") || this.error(`Unclosed end tag for element ${a}`), this.currentNode = o.parent;
    }
    return this.addNode(o), !0;
  }
  consumeEqual() {
    return this.consumeWhitespace(), this.scanner.consumeStringFast("=") ? (this.consumeWhitespace(), !0) : !1;
  }
  consumeMisc() {
    return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();
  }
  consumeName() {
    return Tc.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(Tc.isNameChar) : a0;
  }
  consumeProcessingInstruction() {
    let { scanner: e } = this, n = e.charIndex;
    if (!e.consumeStringFast("<?"))
      return !1;
    let a = this.consumeName();
    if (a ? a.toLowerCase() === "xml" && (e.reset(n), this.error("XML declaration isn't allowed here")) : this.error("Invalid processing instruction"), !this.consumeWhitespace()) {
      if (e.consumeStringFast("?>"))
        return this.addNode(new rE(a)), !0;
      this.error("Whitespace is required after a processing instruction name");
    }
    let s = e.consumeUntilString("?>");
    return this.validateChars(s), e.consumeStringFast("?>") || this.error("Unterminated processing instruction"), this.addNode(new rE(a, s)), !0;
  }
  consumeProlog() {
    let { scanner: e } = this, n = e.charIndex;
    for (this.consumeXmlDeclaration(); this.consumeMisc(); )
      ;
    if (this.consumeDoctypeDeclaration())
      for (; this.consumeMisc(); )
        ;
    return n < e.charIndex;
  }
  consumeReference() {
    let { scanner: e } = this;
    if (e.peek() !== "&")
      return !1;
    e.advance();
    let n = e.consumeMatchFn(Tc.isReferenceChar);
    e.consume() !== ";" && this.error("Unterminated reference (a reference must end with `;`)");
    let a;
    if (n[0] === "#") {
      let s = n[1] === "x" ? parseInt(n.slice(2), 16) : parseInt(n.slice(1), 10);
      isNaN(s) && this.error("Invalid character reference"), a = String.fromCodePoint(s), Tc.isXmlChar(a) || this.error("Character reference resolves to an invalid character");
    } else if (a = Tc.predefinedEntities[n], a === void 0) {
      let {
        ignoreUndefinedEntities: s,
        resolveUndefinedEntity: f
      } = this.options, o = `&${n};`;
      if (f) {
        let m = f(o);
        if (m != null) {
          let g = typeof m;
          if (g !== "string")
            throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${g}`);
          return m;
        }
      }
      if (s)
        return o;
      e.reset(-o.length), this.error(`Named entity isn't defined: ${o}`);
    }
    return a;
  }
  consumeSystemLiteral() {
    let { scanner: e } = this, n = e.consumeStringFast('"') || e.consumeStringFast("'");
    if (!n)
      return !1;
    let a = e.consumeUntilString(n);
    return this.validateChars(a), e.consumeStringFast(n) || this.error("Missing end quote"), a;
  }
  consumeWhitespace() {
    return Boolean(this.scanner.consumeMatchFn(Tc.isWhitespace));
  }
  consumeXmlDeclaration() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<?xml"))
      return !1;
    this.consumeWhitespace() || this.error("Invalid XML declaration");
    let n = Boolean(e.consumeStringFast("version")) && this.consumeEqual() && this.consumeSystemLiteral();
    if (n === !1 ? this.error("XML version is missing or invalid") : /^1\.[0-9]+$/.test(n) || this.error("Invalid character in version number"), this.consumeWhitespace()) {
      Boolean(e.consumeStringFast("encoding")) && this.consumeEqual() && this.consumeSystemLiteral() && this.consumeWhitespace();
      let s = Boolean(e.consumeStringFast("standalone")) && this.consumeEqual() && this.consumeSystemLiteral();
      s && (s !== "yes" && s !== "no" && this.error('Only "yes" and "no" are permitted as values of `standalone`'), this.consumeWhitespace());
    }
    return e.consumeStringFast("?>") || this.error("Invalid or unclosed XML declaration"), !0;
  }
  error(e) {
    let { charIndex: n, string: a } = this.scanner, s = 1, f = "", o = 1;
    for (let T = 0; T < n; ++T) {
      let M = a[T];
      M === `
` ? (s = 1, f = "", o += 1) : (s += 1, f += M);
    }
    let m = a.indexOf(`
`, n);
    f += m === -1 ? a.slice(n) : a.slice(n, m);
    let g = 0;
    f.length > 50 && (s < 40 ? f = f.slice(0, 50) : (g = s - 20, f = f.slice(g, s + 30)));
    let b = new Error(
      `${e} (line ${o}, column ${s})
  ${f}
` + " ".repeat(s - g + 1) + `^
`
    );
    throw Object.assign(b, {
      column: s,
      excerpt: f,
      line: o,
      pos: n
    }), b;
  }
  validateChars(e) {
    let n = 0;
    for (let a of e)
      Tc.isNotXmlChar(a) && (this.scanner.reset(-([...e].length - n)), this.error("Invalid character")), n += 1;
  }
}
var OB = IB;
function CB(t) {
  return t[0] === "\uFEFF" && (t = t.slice(1)), t.replace(/\r\n?/g, `
`);
}
const AB = OB, PB = QM, kB = eI, LB = tI, DB = ex, NB = rh, RB = rI, zB = J1;
function Vu(t, e) {
  return new AB(t, e).document;
}
Vu.XmlCdata = PB;
Vu.XmlComment = kB;
Vu.XmlDocument = LB;
Vu.XmlElement = DB;
Vu.XmlNode = NB;
Vu.XmlProcessingInstruction = RB;
Vu.XmlText = zB;
var FB = Vu;
class BB extends Error {
  constructor(e) {
    super(e);
  }
}
function VB(t) {
  let e = null;
  try {
    e = FB(t);
  } catch (n) {
    throw new BB(n.message);
  }
  return e;
}
function Vl(t) {
  return t.children[0];
}
function Hg(t) {
  const e = t.indexOf(":");
  return e > -1 ? t.substr(e + 1) : t;
}
function Zg(t) {
  return t.name || "";
}
function Eo(t, e, n) {
  const a = Hg(e);
  function s(f, o) {
    return Hg(Zg(o)) === a && f.push(o), n && Array.isArray(o.children) ? [...f, ...o.children.reduce(s, [])] : f;
  }
  return t && Array.isArray(t.children) ? t.children.reduce(s, []) : [];
}
function br(t, e, n) {
  return Eo(t, e, n)[0] || null;
}
function id(t) {
  return t && Array.isArray(t.children) ? [...t.children.filter((e) => e.constructor.name === "XmlElement")] : [];
}
function _n(t) {
  const e = t && Array.isArray(t.children) ? t.children.find((n) => n.type === "text") : null;
  return e ? e.text : "";
}
function Hs(t, e) {
  return t && t.attributes[e] || "";
}
const iE = ["utf-8", "utf-16", "iso-8859-1"], oE = "utf-8";
function UB(t) {
  const e = /charset=([^;]+)/.exec(t);
  return e ? e[1] : null;
}
function jB(t, e) {
  const n = e ? UB(e) : null, a = n ? [n, ...iE] : iE;
  for (const s of a)
    try {
      return new TextDecoder(s, { fatal: !0 }).decode(t);
    } catch {
    }
  return console.warn(
    `XML document encoding could not be determined, falling back to ${oE}.`
  ), new TextDecoder(oE).decode(t);
}
const Fy = /* @__PURE__ */ new Map();
function GB(t) {
  if (Fy.has(t))
    return Fy.get(t);
  const e = fetch(t);
  return e.finally(() => Fy.delete(t)), Fy.set(t, e), e;
}
function tx(t) {
  return GB(t).catch(
    () => fetch(t, { method: "HEAD", mode: "no-cors" }).catch((e) => {
      throw new Q_(
        `Fetching the document failed either due to network errors or unreachable host, error is: ${e.message}`,
        0,
        !1
      );
    }).then(() => {
      throw new Q_(
        "The document could not be fetched due to CORS limitations",
        0,
        !0
      );
    })
  ).then(async (e) => {
    if (!e.ok) {
      const s = await e.text();
      throw new Q_(
        `Received an error with code ${e.status}: ${s}`,
        e.status,
        !1
      );
    }
    const n = await e.arrayBuffer(), a = e.headers.get("Content-Type");
    return jB(n, a);
  }).then((e) => VB(e));
}
function rx(t, e) {
  const n = t.match(/(https?%3A%2F%2F[^/]+)$/);
  if (n) {
    const m = n[1], g = rx(decodeURIComponent(m), e);
    return t.replace(m, encodeURIComponent(g));
  }
  const a = new URL(t), s = Object.keys(e), f = s.map((m) => m.toLowerCase()), o = [];
  for (const m of a.searchParams.keys())
    f.indexOf(m.toLowerCase()) > -1 && o.push(m);
  return o.map((m) => a.searchParams.delete(m)), s.forEach(
    (m) => a.searchParams.set(m, e[m] === !0 ? "" : e[m])
  ), a.toString();
}
let qB = 1e3 * 60 * 60;
function $B() {
  return qB;
}
const Ru = "caches" in self ? caches.open("ogc-client") : null;
async function WB(t, ...e) {
  if (!Ru)
    return;
  const n = "https://cache/" + e.join("/");
  await (await Ru).put(
    n,
    new Response(JSON.stringify(t), {
      headers: {
        "x-expiry": (Date.now() + $B()).toString(10)
      }
    })
  );
}
async function HB(...t) {
  if (!Ru)
    return !1;
  const e = "https://cache/" + t.join("/");
  return (await Ru).match(e).then((a) => !!a && parseInt(a.headers.get("x-expiry")) > Date.now());
}
async function ZB(...t) {
  if (!Ru)
    return null;
  const e = "https://cache/" + t.join("/"), a = await (await Ru).match(e);
  return a ? a.clone().json() : null;
}
const By = /* @__PURE__ */ new Map();
async function XB(t, ...e) {
  if (await KB(), await HB(...e))
    return ZB(...e);
  const n = e.join("#");
  if (By.has(n))
    return By.get(n);
  const a = t();
  a instanceof Promise && (a.then(() => By.delete(n)), By.set(n, a));
  const s = await a;
  return await WB(s, ...e), s;
}
async function KB() {
  if (!Ru)
    return;
  const t = await Ru, e = await t.keys();
  for (let n of e) {
    const a = await t.match(n);
    parseInt(a.headers.get("x-expiry")) <= Date.now() && await t.delete(n);
  }
}
function YB(t, e, n, a, s, f, o, m, g, b) {
  const T = e === "2.0.0" ? "TYPENAMES" : "TYPENAME", M = e === "2.0.0" ? "COUNT" : "MAXFEATURES", I = {
    SERVICE: "WFS",
    REQUEST: "GetFeature",
    VERSION: e,
    [T]: n
  };
  if (a !== void 0 && (I.OUTPUTFORMAT = a), f !== void 0 && (I.PROPERTYNAME = f.join(",")), o ? (I.RESULTTYPE = "hits", I[M] = "1") : s !== void 0 && (I[M] = s.toString(10)), m && (I.SRSNAME = m), g) {
    const A = g.join(",");
    I.BBOX = b ? `${A},${b}` : A;
  }
  return rx(t, I);
}
class JB {
  constructor(e) {
    const n = rx(e, {
      SERVICE: "WMS",
      REQUEST: "GetCapabilities"
    });
    this._capabilitiesPromise = XB(
      () => sB(n),
      "WMS",
      "CAPABILITIES",
      n
    ).then(({ info: a, layers: s, version: f }) => {
      this._info = a, this._layers = s, this._version = f;
    }), this._info = null, this._layers = null, this._version = null;
  }
  isReady() {
    return this._capabilitiesPromise.then(() => this);
  }
  getServiceInfo() {
    return this._info;
  }
  getLayers() {
    function e(n) {
      return {
        title: n.title,
        name: n.name,
        abstract: n.abstract,
        ..."children" in n && {
          children: n.children.map(e)
        }
      };
    }
    return this._layers.map(e);
  }
  getLayerByName(e) {
    let n = null;
    function a(s) {
      if (n === null) {
        if (s.name === e) {
          n = s;
          return;
        }
        "children" in s && s.children.map(a);
      }
    }
    return this._layers.map(a), n;
  }
  getVersion() {
    return this._version;
  }
}
const QB = [
  "EPSG:4046",
  "EPSG:4075",
  "EPSG:4120",
  "EPSG:4122",
  "EPSG:4124",
  "EPSG:4126",
  "EPSG:4149",
  "EPSG:4151",
  "EPSG:4153",
  "EPSG:4155",
  "EPSG:4157",
  "EPSG:4159",
  "EPSG:4161",
  "EPSG:4163",
  "EPSG:4165",
  "EPSG:4167",
  "EPSG:4169",
  "EPSG:4171",
  "EPSG:4173",
  "EPSG:4175",
  "EPSG:4178",
  "EPSG:4180",
  "EPSG:4182",
  "EPSG:4184",
  "EPSG:4188",
  "EPSG:4190",
  "EPSG:4191",
  "EPSG:4196",
  "EPSG:4198",
  "EPSG:4202",
  "EPSG:4210",
  "EPSG:4211",
  "EPSG:4214",
  "EPSG:4226",
  "EPSG:4229",
  "EPSG:4231",
  "EPSG:4233",
  "EPSG:4236",
  "EPSG:4238",
  "EPSG:4240",
  "EPSG:4242",
  "EPSG:4244",
  "EPSG:4246",
  "EPSG:4248",
  "EPSG:4250",
  "EPSG:4252",
  "EPSG:4255",
  "EPSG:4258",
  "EPSG:4261",
  "EPSG:4264",
  "EPSG:4267",
  "EPSG:4270",
  "EPSG:4273",
  "EPSG:4276",
  "EPSG:4279",
  "EPSG:4281",
  "EPSG:4284",
  "EPSG:4286",
  "EPSG:4288",
  "EPSG:4292",
  "EPSG:4295",
  "EPSG:4297",
  "EPSG:4299",
  "EPSG:4302",
  "EPSG:4324",
  "EPSG:4326"
];
function e8(t) {
  return QB.indexOf(o1(t)) > -1;
}
function o1(t) {
  return /^urn:(?:x-)?ogc:def:crs:epsg:/.test(t.toLowerCase()) ? `EPSG:${/([0-9]+)$/.exec(t)[1]}` : t;
}
function nI(t) {
  return Vl(t).attributes.version;
}
function t8(t) {
  const e = nI(t), n = br(
    Vl(t),
    "Capability"
  );
  return Eo(n, "Layer").map(
    (a) => iI(a, e)
  );
}
function r8(t) {
  const e = br(Vl(t), "Service"), n = Eo(
    br(e, "KeywordList"),
    "Keyword"
  ).map(_n).filter((a, s, f) => f.indexOf(a) === s);
  return {
    title: _n(br(e, "Title")),
    name: _n(br(e, "Name")),
    abstract: _n(br(e, "Abstract")),
    fees: _n(br(e, "Fees")),
    constraints: _n(br(e, "AccessConstraints")),
    keywords: n
  };
}
function iI(t, e, n = [], a = [], s = null) {
  const f = e === "1.3.0" ? "CRS" : "SRS", o = Eo(t, f).map(_n), m = o.length > 0 ? o : n, g = Eo(t, "Style").map(
    n8
  ), b = g.length > 0 ? g : a;
  function T(z) {
    const V = Hs(z, f);
    return (e8(V) && e === "1.3.0" ? ["miny", "minx", "maxy", "maxx"] : ["minx", "miny", "maxx", "maxy"]).map((X) => Hs(z, X));
  }
  const M = br(t, "Attribution"), I = M !== null ? i8(M) : s, A = Eo(t, "Layer").map(
    (z) => iI(z, e, m, b, I)
  );
  return {
    name: _n(br(t, "Name")),
    title: _n(br(t, "Title")),
    abstract: _n(br(t, "Abstract")),
    availableCrs: m,
    styles: b,
    attribution: I,
    boundingBoxes: Eo(t, "BoundingBox").reduce(
      (z, V) => ({
        ...z,
        [Hs(V, f)]: T(V)
      }),
      {}
    ),
    ...A.length && { children: A }
  };
}
function n8(t) {
  const e = Hs(
    br(br(t, "LegendURL"), "OnlineResource"),
    "xlink:href"
  );
  return {
    name: _n(br(t, "Name")),
    title: _n(br(t, "Title")),
    ...e && { legendUrl: e }
  };
}
function i8(t) {
  const e = Hs(
    br(
      br(t, "LogoURL"),
      "OnlineResource"
    ),
    "xlink:href"
  ), n = Hs(
    br(t, "OnlineResource"),
    "xlink:href"
  ), a = _n(br(t, "Title"));
  return {
    ...a && { title: a },
    ...n && { url: n },
    ...e && { logoUrl: e }
  };
}
function Pv(t) {
  return Vl(t).attributes.version;
}
function oI(t) {
  const e = Pv(t);
  let n;
  if (e.startsWith("1.0")) {
    const a = br(
      br(
        br(Vl(t), "Capability"),
        "Request"
      ),
      "GetFeature"
    );
    n = id(
      br(a, "ResultFormat")
    ).map(Zg);
  } else {
    const a = br(
      Vl(t),
      "OperationsMetadata"
    ), s = Eo(a, "Operation").find(
      (o) => Hs(o, "name") === "GetFeature"
    ), f = Eo(s, "Parameter").find(
      (o) => Hs(o, "name") === "outputFormat"
    );
    n = Eo(f, "Value", !0).map(
      _n
    );
  }
  return n;
}
function o8(t) {
  const e = Pv(t), n = e.startsWith("1.0") ? "Service" : "ServiceIdentification", a = e.startsWith("1.0") ? "Name" : "ServiceType", s = br(Vl(t), n);
  let f;
  return e.startsWith("1.0") ? f = _n(br(s, "Keywords")).split(",").map((o) => o.trim()) : f = Eo(
    br(s, "Keywords"),
    "Keyword"
  ).map(_n), {
    title: _n(br(s, "Title")),
    name: _n(br(s, a)),
    abstract: _n(br(s, "Abstract")),
    fees: _n(br(s, "Fees")),
    constraints: _n(br(s, "AccessConstraints")),
    keywords: f,
    outputFormats: oI(t)
  };
}
function a8(t) {
  const e = Pv(t), n = oI(t), a = br(
    Vl(t),
    "FeatureTypeList"
  );
  return Eo(a, "FeatureType").map(
    (s) => s8(s, e, n)
  );
}
function s8(t, e, n) {
  const a = e.startsWith("2.") ? "CRS" : "SRS", s = e.startsWith("1.0") ? "SRS" : `Default${a}`;
  function f() {
    const b = br(t, "LatLongBoundingBox");
    return ["minx", "miny", "maxx", "maxy"].map((T) => Hs(b, T)).map(parseFloat);
  }
  function o() {
    const b = br(t, "WGS84BoundingBox");
    return ["LowerCorner", "UpperCorner"].map((T) => br(b, T)).map((T) => _n(T).split(" ")).reduce((T, M) => [...T, ...M]).map(parseFloat);
  }
  const m = e.startsWith("1.0") ? [] : Eo(t, `Other${a}`).map(_n).map(o1), g = e.startsWith("1.0") ? [] : Eo(
    br(t, "OutputFormats"),
    "Format"
  ).map(_n);
  return {
    name: _n(br(t, "Name")),
    title: _n(br(t, "Title")),
    abstract: _n(br(t, "Abstract")),
    defaultCrs: o1(
      _n(br(t, s))
    ),
    otherCrs: m,
    outputFormats: g.length > 0 ? g : n,
    latLonBoundingBox: e.startsWith("1.0") ? f() : o()
  };
}
function l8(t, e, n) {
  const a = Vl(t);
  let s;
  if (n.startsWith("2.0"))
    s = Eo(a, "member").map(
      (b) => id(b)[0]
    );
  else {
    const b = br(a, "featureMembers");
    s = b ? id(b) : Eo(a, "featureMember").map(
      (T) => id(T)[0]
    );
  }
  const f = n === "1.0.0" ? "fid" : "gml:id";
  function o(b) {
    return b in e.properties;
  }
  function m(b, T) {
    switch (e.properties[b]) {
      case "integer":
        return parseInt(T);
      case "float":
        return parseFloat(T);
      case "boolean":
        return T === "true";
      default:
        return T;
    }
  }
  function g(b) {
    return id(b).filter((T) => o(Hg(Zg(T)))).reduce((T, M) => {
      const I = Hg(Zg(M));
      return {
        ...T,
        [I]: m(I, _n(M))
      };
    }, {});
  }
  return s.map((b) => ({
    id: Hs(b, f),
    properties: g(b)
  }));
}
function u8(t) {
  return t.reduce((e, n) => {
    for (const a in n.properties) {
      const s = n.properties[a];
      a in e || (e[a] = { uniqueValues: [] });
      const f = e[a].uniqueValues.find(
        (o) => o.value === s
      );
      f ? f.count++ : e[a].uniqueValues.push({ value: s, count: 1 });
    }
    return e;
  }, {});
}
Y1(
  "parseWmsCapabilities",
  self,
  ({ url: t }) => tx(t).then((e) => ({
    info: r8(e),
    layers: t8(e),
    version: nI(e)
  }))
);
Y1(
  "parseWfsCapabilities",
  self,
  ({ url: t }) => tx(t).then((e) => ({
    info: o8(e),
    featureTypes: a8(e),
    version: Pv(e)
  }))
);
Y1(
  "queryWfsFeatureTypeDetails",
  self,
  ({ url: t, serviceVersion: e, featureTypeFull: n }) => {
    const a = YB(
      t,
      e,
      n.name,
      void 0,
      void 0,
      Object.keys(n.properties)
    );
    return tx(a).then((s) => ({
      props: u8(
        l8(s, n, e)
      )
    }));
  }
);
const c8 = () => [
  {
    url: "http://wmts1.geoportail.lu/opendata/service",
    label: "Open Data Webservices WMS"
  },
  {
    url: "http://ows.terrestris.de/osm-gray/service",
    label: "OpenStreetMap by Terrestris (Grey)"
  },
  {
    url: "http://ows.terrestris.de/osm/service",
    label: "OpenStreetMap by Terrestris (Color)"
  }
];
class h8 {
  constructor(e) {
    bi(this, "capabilitiesPromise");
    bi(this, "serviceInfo");
    bi(this, "layers");
    const n = new CC();
    let a = "&";
    e.indexOf("?") === -1 && (a = "?"), e.indexOf("Capabilities") === -1 && (e = e + a + "SERVICE=WMTS&REQUEST=GetCapabilities"), this.capabilitiesPromise = fetch(e).then((s) => s.text()).then((s) => {
      var o;
      const f = n.read(s);
      this.serviceInfo = this.mapServiceInfo(f.ServiceIdentification), this.layers = this.mapToRemoteLayers((o = f.Contents) == null ? void 0 : o.Layer);
    });
  }
  mapToRemoteLayers(e) {
    return [
      {
        type: Da.WMTS,
        children: e.map(
          (n) => ({
            type: Da.WMTS,
            abstract: n.Abstract,
            format: n.Format,
            name: n.Identifier,
            title: n.Title,
            tileMatrixSetLink: n.TileMatrixSetLink,
            wgs84BoundingBox: n.WGS84BoundingBox
          })
        )
      }
    ];
  }
  mapServiceInfo(e) {
    return {
      type: Da.WMTS,
      title: e.Title,
      abstract: e.Abstract,
      fees: e.Fees,
      constraints: e.AccessConstraints,
      serviceTypeVersion: e.ServiceTypeVersion
    };
  }
  isReady() {
    return this.capabilitiesPromise.then(() => this);
  }
  getLayerByName(e) {
    return this.layers[0].children.filter((n) => n.name === e)[0];
  }
  getLayers() {
    return this.layers;
  }
  getServiceInfo() {
    return this.serviceInfo;
  }
}
class f8 {
  async getRemoteEndpoint(e) {
    let n;
    return await this.getWmsEndpoint(e).isReady().catch(async () => {
      n = await this.getWmtsEndpoint(e).isReady();
    }) || n;
  }
  getWmsEndpoint(e) {
    return new JB(this.getProxyfiedUrl(e));
  }
  getWmtsEndpoint(e) {
    return new h8(this.getProxyfiedUrl(e));
  }
  getProxyfiedUrl(e) {
    return e.indexOf("httpsproxy") > 0 ? e : $M + "?url=" + encodeURIComponent(e);
  }
  async fetchRemoteWmsEndpoint() {
    return new Promise((e) => e(c8()));
  }
  isRemoteLayer(e) {
    return typeof e == "string" && (e.indexOf(Da.WMS) === 0 || e.indexOf(Da.WMTS) === 0);
  }
}
const qc = new f8();
function p8(t, e) {
  var n, a;
  return t.children && !e.children || ((n = e.children) == null ? void 0 : n.length) === 0 ? 1 : e.children && !t.children || ((a = t.children) == null ? void 0 : a.length) === 0 ? -1 : 0;
}
function aI(t, e, n = 0) {
  const { name: a = "", type: s = Da.WMS, children: f } = t, o = `${s}||${e}||${a}`.split("-").join("%2D"), m = Ai();
  return {
    id: o,
    name: a,
    depth: n,
    children: f == null ? void 0 : f.sort(p8).map((g) => aI(g, e, n + 1)),
    checked: m.hasLayer(o),
    expanded: !1
  };
}
function d8(t) {
  const e = decodeURIComponent(t), [n, a, s] = e.split("||");
  return sI({
    id: e,
    url: qc.getProxyfiedUrl(a),
    remoteLayer: { name: s, type: n }
  });
}
function sI({
  id: t,
  url: e,
  remoteLayer: n
}) {
  const { name: a = "", type: s = Da.WMS } = n;
  return {
    id: t,
    name: a,
    layers: a,
    url: e,
    type: s,
    imageType: qM.PNG
  };
}
const m8 = { class: "relative text-center" }, y8 = ["placeholder", "value"], g8 = {
  key: 0,
  class: "text-center"
}, v8 = { class: "lux-label" }, _8 = {
  key: 1,
  class: "text-center"
}, x8 = { class: "lux-label" }, b8 = {
  key: 2,
  class: "text-center"
}, w8 = /* @__PURE__ */ Ne("div", { class: "fa fa-refresh fa-spin" }, null, -1), E8 = {
  key: 3,
  class: "overflow-auto max-h-[calc(400px-36px)]"
}, S8 = /* @__PURE__ */ ur({
  __name: "remote-layers",
  setup(t) {
    const { t: e } = An(), n = Ai(), a = Au(), s = Fn([]), f = Fn(), { remoteLayersOpen: o } = xn(Pi()), { setRemoteLayersOpen: m } = Pi();
    let g = !1, b, T, M;
    Na(I);
    function I() {
      f.value = f.value ? Of.updateLayers(
        f.value,
        n.layers
      ) : void 0;
    }
    qc.fetchRemoteWmsEndpoint().then((ye) => {
      s.value = ye.map(({ url: Ie, label: Be }) => ({
        label: Be,
        value: Ie
      }));
    });
    async function A(ye) {
      g = !0, M = await qc.getRemoteEndpoint(ye).catch(() => alert(e("Impossible de contacter ce WMS", { ns: "client" }))), T = ye, g = !1;
    }
    async function z() {
      const ye = M, Ie = ye == null ? void 0 : ye.getLayers();
      if (Ie && Ie[0]) {
        const Be = aI(
          Ie[0],
          T
        );
        f.value = Of.updateLayers(Be, n.layers);
      }
    }
    async function V(ye) {
      T = b = ye, await A(T), z();
    }
    function Z(ye) {
      b = ye.target.value;
    }
    async function X() {
      await A(b), z();
    }
    function Y(ye) {
      f.value = Of.toggleNode(
        ye.id,
        f.value,
        "expanded"
      );
    }
    function de(ye) {
      const { id: Ie, name: Be } = ye, De = M;
      if (ye.checked === !0)
        n.removeLayers(Ie);
      else {
        const Re = De == null ? void 0 : De.getLayerByName(Be);
        if (Re) {
          const Ee = a.initLayer(
            sI({
              id: Ie,
              url: qc.getProxyfiedUrl(T),
              remoteLayer: Re
            })
          );
          n.addLayers(Ee);
        }
      }
    }
    return (ye, Ie) => le(o) ? (Ue(), cn(XM, {
      key: 0,
      title: le(e)("Add external data", { ns: "client" }),
      onClose: Ie[0] || (Ie[0] = (Be) => le(m)(!1))
    }, {
      content: Bd(() => {
        var Be, De;
        return [
          Ne("div", m8, [
            Gt(AT, {
              class: "lux-remote-services-dropdown",
              options: le(s),
              placeholder: le(e)("Predefined wms", { ns: "client" }),
              onChange: V
            }, null, 8, ["options", "placeholder"]),
            Ne("input", {
              class: "lux-input w-[300px]",
              type: "url",
              placeholder: le(e)("Choose or write a WMS url", {
                ns: "client"
              }),
              value: le(T) || "",
              onChange: Z
            }, null, 40, y8),
            Ne("button", {
              type: "button",
              class: "lux-btn",
              onClick: X
            }, Vt(le(e)("Get the layers", { ns: "client" })), 1)
          ]),
          !le(g) && le(M) ? (Ue(), st("div", g8, [
            Ne("span", v8, Vt(le(e)("Description du service :", {
              ns: "client"
            })), 1),
            Tg(" " + Vt((Be = le(M).getServiceInfo()) == null ? void 0 : Be.abstract), 1)
          ])) : it("v-if", !0),
          !le(g) && le(M) ? (Ue(), st("div", _8, [
            Ne("span", x8, Vt(le(e)("Access constraints :", {
              ns: "client"
            })), 1),
            Tg(" " + Vt((De = le(M).getServiceInfo()) == null ? void 0 : De.constraints), 1)
          ])) : it("v-if", !0),
          le(g) ? (Ue(), st("div", b8, [
            w8,
            Ne("span", null, Vt(le(e)("Chargement des informations", {
              ns: "client"
            })), 1)
          ])) : it("v-if", !0),
          le(g) ? it("v-if", !0) : (Ue(), st("div", E8, [
            le(f) ? (Ue(), cn(i1, {
              key: 0,
              class: "block p-[10px] mb-[11px]",
              node: le(f),
              onToggleParent: Y,
              onToggleLayer: de
            }, null, 8, ["node"])) : it("v-if", !0)
          ]))
        ];
      }),
      _: 1
    }, 8, ["title"])) : it("v-if", !0);
  }
}), T8 = /* @__PURE__ */ mr(S8, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/remote-layers/remote-layers.vue"]]);
function M8(t, e = "fr-FR") {
  const n = new Date(t);
  return new Intl.DateTimeFormat(e).format(n);
}
const I8 = { class: "font-bold" }, O8 = { class: "col-span-2" }, C8 = /* @__PURE__ */ ur({
  __name: "layer-metadata-item",
  props: {
    label: { type: String, required: !0 },
    value: { type: String, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Ue(), st(un, null, [
      Ne("span", I8, Vt(e.label), 1),
      Ne("span", O8, Vt(e.value), 1)
    ], 64));
  }
}), Xp = /* @__PURE__ */ mr(C8, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-metadata/layer-metadata-item.vue"]]);
function A8(t) {
  return {
    fr: "fre",
    en: "eng",
    de: "ger",
    lb: "ltz"
  }[t.toLowerCase()];
}
function P8(t) {
  return new DOMParser().parseFromString(t, "text/html").body;
}
function k8(t) {
  const e = [];
  function n(a) {
    const s = a.split("|");
    s[3] === "WWW:LINK-1.0-http--link" && e.indexOf(s[2]) === -1 && e.push(s[2]);
  }
  return Array.isArray(t) ? t.forEach(n, t) : n(t), e;
}
function L8(t) {
  const n = (Array.isArray(t) ? t : [t]).filter((a) => a.split("|")[1] === "metadata");
  return {
    organisaton: n[0].split("|")[2],
    name: n[0].split("|")[5],
    unknown: n[0].split("|")[6],
    address: n[0].split("|")[7],
    email: n[0].split("|")[4]
  };
}
class lI {
}
class D8 extends lI {
  async getMetadata(e, n, a) {
    console.assert(e === Da.WMS);
    const s = qc.getWmsEndpoint(n);
    await s.isReady();
    const f = s == null ? void 0 : s.getServiceInfo(), o = s == null ? void 0 : s.getLayerByName(a);
    return {
      title: o.title,
      description: o.abstract,
      keywords: f.keywords,
      accessConstraints: f.constraints,
      serviceDescription: f.abstract
    };
  }
}
const N8 = new D8();
class R8 extends lI {
  async getMetadata(e, n, a) {
    console.assert(e === Da.WMTS);
    const s = qc.getWmtsEndpoint(n);
    await s.isReady();
    const f = s == null ? void 0 : s.getServiceInfo(), o = s == null ? void 0 : s.getLayerByName(a);
    return {
      title: o.title,
      description: o.abstract,
      accessConstraints: f.constraints,
      serviceDescription: f.abstract
    };
  }
}
const z8 = new R8();
class F8 {
  async getMetadata(e, n, a) {
    if (e === Da.WMS)
      return N8.getMetadata(e, n, a);
    if (e === Da.WMTS)
      return z8.getMetadata(e, n, a);
    throw new Error(`Unsupported service type: ${e}`);
  }
}
const B8 = new F8();
class V8 {
  constructor() {
    bi(this, "geonetworkBaseUrl", "https://geocatalogue.geoportail.lu/geonetwork/srv");
    bi(this, "legendBaseUrl", "https://map.geoportail.lu/legends/get_html");
    bi(this, "localMetadataBaseUrl", "https://map.geoportail.lu/getMetadata");
  }
  async getLayerMetadata(e, n) {
    const a = Gc(), s = a.findBgLayerById(+e) || a.findById(+e) || a.find3dLayerById(+e);
    if (s) {
      const f = s.metadata, o = f == null ? void 0 : f.metadata_id, m = o && await this.getLocalMetadata(
        this.localMetadataBaseUrl,
        o,
        n
      ), g = s.name, b = (f == null ? void 0 : f.legend_name) || "", T = s == null ? void 0 : s.id, M = b && await this.getLegendHtml(
        this.legendBaseUrl,
        b,
        T,
        n
      );
      return {
        ...m,
        title: g,
        hasLegend: !!M,
        ...M && { legendHtml: M }
      };
    } else {
      const [f, o, m] = String(e).split("%2D").join("-").split("||");
      return B8.getMetadata(
        f,
        o,
        m
      );
    }
  }
  getLocalMetadata(e, n, a) {
    return fetch(`${e}?lang=${a}&uid=${n}`).then(async (s) => {
      const f = (await s.json()).metadata;
      return {
        name: f.title,
        serviceDescription: f.serviceDescription,
        description: f.abstract,
        legalConstraints: f.legalConstraints,
        link: k8(f.link),
        revisionDate: f.revisionDate,
        keyword: f.keyword,
        responsibleParty: f.responsibleParty ? L8(f.responsibleParty) : void 0,
        metadataLink: `${this.geonetworkBaseUrl}/${A8(
          a
        )}/catalog.search#/metadata/${n}`,
        isError: !1
      };
    }).catch(() => ({ isError: !0 }));
  }
  getLegendHtml(e, n, a, s) {
    const f = {
      lang: s,
      ...n && { name: n },
      ...a && { id: a.toString() }
    };
    if (f.name && f.lang) {
      window.devicePixelRatio > 1 && (f.dpi = (window.devicePixelRatio * 96).toString());
      const o = `${e}?${new URLSearchParams(
        f
      ).toString()}`;
      return fetch(o).then(async (m) => {
        if (m.status >= 400 && m.status < 600)
          throw new Error("Server responded with error code");
        const g = await m.text();
        return g ? P8(g) : void 0;
      }).catch(() => {
      });
    }
  }
}
const aE = new V8(), U8 = { class: "grid gap-2 grid-cols-3 pt-3 text-[13px] font-arial break-words" }, j8 = {
  key: 2,
  class: "col-span-3 grid gap-2 grid-cols-3"
}, G8 = { class: "font-bold" }, q8 = { class: "col-span-2" }, $8 = ["title"], W8 = ["title"], H8 = {
  key: 4,
  class: "col-span-3"
}, Z8 = { class: "font-bold" }, X8 = { class: "col-span-2" }, K8 = ["href"], Y8 = {
  key: 7,
  class: "col-span-3 grid gap-2 grid-cols-3"
}, J8 = { class: "font-bold" }, Q8 = { class: "col-span-2" }, eV = { key: 0 }, tV = { key: 1 }, rV = { key: 2 }, nV = { key: 3 }, iV = { key: 4 }, oV = ["href"], aV = {
  key: 8,
  class: "grid gap-2 grid-cols-3 col-span-3"
}, sV = { class: "font-bold" }, lV = { class: "col-span-2" }, uV = ["href"], cV = {
  key: 9,
  class: "col-span-3"
}, hV = { key: 10 }, fV = { class: "text-xl" }, pV = {
  key: 11,
  class: "col-span-3"
}, dV = /* @__PURE__ */ ur({
  __name: "layer-metadata",
  setup(t) {
    const e = K1(), { metadataId: n } = xn(e), { t: a, i18next: s } = An(), f = Hr(), o = Hr(!0), m = 220;
    Bn(n, async (I) => {
      var A, z;
      f.value = I ? await aE.getLayerMetadata(I, s.language) : void 0, o.value = (((z = (A = f.value) == null ? void 0 : A.description) == null ? void 0 : z.length) || 0) < m;
    }), va(() => {
      s.on("languageChanged", async () => {
        n.value && (f.value = await aE.getLayerMetadata(
          n.value,
          s.language
        ));
      });
    });
    const g = Ur(
      () => {
        var I, A, z;
        return o.value ? (I = f.value) == null ? void 0 : I.description : (z = (A = f.value) == null ? void 0 : A.description) == null ? void 0 : z.slice(0, m);
      }
    );
    function b() {
      o.value = !0;
    }
    function T() {
      o.value = !1;
    }
    function M() {
      e.clearMetadataId();
    }
    return (I, A) => {
      const z = EP("dompurify-html");
      return f.value ? (Ue(), cn(XM, {
        key: 0,
        footer: !1,
        "max-height": !0,
        title: le(a)(`${f.value.title}`, { ns: "client" }),
        onClose: M
      }, {
        content: Bd(() => {
          var V, Z, X, Y, de, ye, Ie, Be, De, Re, Ee, ze, rt, Ze, yt;
          return [
            Ne("div", U8, [
              f.value.name ? (Ue(), cn(Xp, {
                key: 0,
                label: le(a)("Name"),
                value: f.value.name
              }, null, 8, ["label", "value"])) : it("v-if", !0),
              f.value.serviceDescription ? (Ue(), cn(Xp, {
                key: 1,
                label: le(a)("Description du Service"),
                value: f.value.serviceDescription
              }, null, 8, ["label", "value"])) : it("v-if", !0),
              f.value.description ? (Ue(), st("div", j8, [
                Ne("span", G8, Vt(le(a)("Description")), 1),
                Ne("span", q8, [
                  $b(Ne("span", null, null, 512), [
                    [z, le(g)]
                  ]),
                  o.value ? it("v-if", !0) : (Ue(), st("button", {
                    key: 0,
                    title: le(a)("Display full description", {
                      ns: "client"
                    }),
                    onClick: b,
                    class: "text-secondary hover:underline"
                  }, " ... ", 8, $8)),
                  o.value && (((V = le(g)) == null ? void 0 : V.length) || 0) > m ? (Ue(), st("button", {
                    key: 1,
                    title: le(a)("Hide full description", {
                      ns: "client"
                    }),
                    onClick: T,
                    class: "text-secondary hover:underline"
                  }, " - ", 8, W8)) : it("v-if", !0)
                ])
              ])) : it("v-if", !0),
              f.value.legalConstraints ? (Ue(), cn(Xp, {
                key: 3,
                label: le(a)("Contrainte d'utilisation"),
                value: f.value.legalConstraints
              }, null, 8, ["label", "value"])) : it("v-if", !0),
              ((Z = f.value.link) == null ? void 0 : Z.length) !== 0 ? (Ue(), st("div", H8, [
                (Ue(!0), st(un, null, Ra(f.value.link, (xe) => (Ue(), st("div", {
                  class: "grid gap-2 grid-cols-3",
                  key: xe
                }, [
                  Ne("span", Z8, Vt(le(a)("Url vers la resource")), 1),
                  Ne("span", X8, [
                    Ne("a", {
                      class: "text-secondary hover:underline",
                      target: "_blank",
                      href: xe
                    }, Vt(xe), 9, K8)
                  ])
                ]))), 128))
              ])) : it("v-if", !0),
              f.value.revisionDate ? (Ue(), cn(Xp, {
                key: 5,
                label: le(a)("Revision date"),
                value: le(M8)(f.value.revisionDate, le(s).language)
              }, null, 8, ["label", "value"])) : it("v-if", !0),
              f.value.keyword ? (Ue(), cn(Xp, {
                key: 6,
                label: le(a)("Keywords"),
                value: (X = f.value.keyword) == null ? void 0 : X.join(",")
              }, null, 8, ["label", "value"])) : it("v-if", !0),
              f.value.responsibleParty ? (Ue(), st("div", Y8, [
                Ne("div", J8, Vt(le(a)("Contact")), 1),
                Ne("div", Q8, [
                  (Y = f.value.responsibleParty) != null && Y.organisaton ? (Ue(), st("p", eV, Vt((de = f.value.responsibleParty) == null ? void 0 : de.organisaton), 1)) : it("v-if", !0),
                  (ye = f.value.responsibleParty) != null && ye.name ? (Ue(), st("p", tV, Vt((Ie = f.value.responsibleParty) == null ? void 0 : Ie.name), 1)) : it("v-if", !0),
                  (Be = f.value.responsibleParty) != null && Be.unknown ? (Ue(), st("p", rV, Vt((De = f.value.responsibleParty) == null ? void 0 : De.unknown), 1)) : it("v-if", !0),
                  (Re = f.value.responsibleParty) != null && Re.address ? (Ue(), st("p", nV, Vt((Ee = f.value.responsibleParty) == null ? void 0 : Ee.address), 1)) : it("v-if", !0),
                  (ze = f.value.responsibleParty) != null && ze.email ? (Ue(), st("p", iV, [
                    Ne("a", {
                      class: "text-secondary hover:underline",
                      href: "mailto:" + ((rt = f.value.responsibleParty) == null ? void 0 : rt.email)
                    }, Vt((Ze = f.value.responsibleParty) == null ? void 0 : Ze.email), 9, oV)
                  ])) : it("v-if", !0)
                ])
              ])) : it("v-if", !0),
              f.value.metadataLink ? (Ue(), st("div", aV, [
                Ne("span", sV, Vt(le(a)("Link to the metadata")), 1),
                Ne("span", lV, [
                  Ne("a", {
                    class: "text-secondary hover:underline",
                    target: "_blank",
                    href: f.value.metadataLink
                  }, Vt(le(a)("link")), 9, uV)
                ])
              ])) : it("v-if", !0),
              f.value.isError ? (Ue(), st("div", cV, Vt(le(a)("The metadata is right now not available")), 1)) : it("v-if", !0),
              f.value.legendHtml ? (Ue(), st("div", hV, [
                Ne("h4", fV, Vt(le(a)("Legend")), 1),
                $b(Ne("span", null, null, 512), [
                  [z, (yt = f.value.legendHtml) == null ? void 0 : yt.innerHTML]
                ])
              ])) : it("v-if", !0),
              f.value.hasLegend ? it("v-if", !0) : (Ue(), st("div", pV, Vt(le(a)("The legend is not available for this layer")), 1))
            ])
          ];
        }),
        _: 1
      }, 8, ["title"])) : it("v-if", !0);
    };
  }
}), mV = /* @__PURE__ */ mr(dV, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-metadata/layer-metadata.vue"]]), yV = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM0AAAAoCAMAAABq645qAAACPVBMVEUAAABaW13////tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy5DjxTaAAAAvXRSTlMAAAABAgMEBQYHCAkKCwwNDg8QERESFBUWFxkaGx0eHyAhIiInKSosMTIzNTY5Ojs8PUFCQ0RERkpMTk9QU1RVVldaXmFjZWZmamtwcXJzdXd3eHl7fX+AgYKDhIaHiIiKi4yOj5CTlJWWl5iZmZqcnZ+goaKjpKanqKqqq6ywsbK0tbW4u7u8vb6/wMHExcbHysvMzM7P0NDS1NXa29zd3t/g4eTl5ujp6uvs7e7u8PLz9PX29/j5+vv8/f5cALqzAAAEcklEQVRo3u3Z+ZPUVBAH8O63LsLKijoIgotHFI+HgiKNeGC8MCqgUUFAJYjgAQ6HKMgGEQQiqChIPFh1iciiwPIEhvv49t/mD5lBORa2tHbLTO2rmqnUTCrJZ3r65ZuEjDHGGLrMWGcKMah7mh/7NP8PzXBqbqgfzdtPb7i/fjQPvq8r5jUVXNNIY4moYeL6+XNfn9Ov6LUZ2/Z7Pxo3YaZWTp/uLPw/reXYbqLRPz/38g+qJ/oTEV396IzmgmquXHZoIRHd/sTs31T1DqIBcyqHZjQWtTbf6nQiokHLVVWn7ju4euXGjsX9LtTAGgPAGGMzOPZSOGFYtmAXsO8skFkgZovQgi2QcZKyIGAAjJQtIgAB/5vRTc2IvbqSqOWNJQdUVdfe+/zitmsu2jeQ/GWMC43HacRhxhAWcJRyEgmYBSVYgROwgJkzeGVEDGEGotqnPaih1Xp63KSvVFVVtz0wt23AvMVda5AZY2FM7OWO/N2DwBMgESBiQZyABUgYSYQkYSBjhAh7QXN3Zfey7YdyzXh6aQpdu2fIpWsD30CykKOU4XPgmBPEnNcmC1jgIT9uCx9ZkOW1kQi9oBm6aMvO3KIVomUPES19/KIaoNo34uA8cUgtB4DzmQXCFoCFhbXgMtgC8DNGKMj7xnIKtj2toeGf55X5c9+ZRpo1lWjyq5c/33Avj+5obpz25miiwd+p6q4/2jfvIrqtrYlemF5MzZObTuhHCw6cUd2y/91ftj5DRJOn0JKniqm56jPtUNXDx44u6NywvaPzPqL+G5v3jCimhhqaX/vyi6VTxtzyYkVV9dSsRvrmnVXUI5oo7GkNEV2RH/igaRVV1Y8fOdE+tEc0tlzqBU1tND+7U1W18t51F8/QAFJrkUccL4VjABFb+MwoMyznszWzBZxfDT2SIbZgm0/TzBbIpLqcr8GwScJxfF4UiliAgGEZ1gKx8VK4bmuafmpdrqr6cFdXBJBSORPkp9A0ZI8hAi4jYQY8CEN8MDML2K/FBBdwKU80kOp3eSBirq7BkJJLstK5UShw+eYhDBGUYNPQeN3WTND2rd+r6oquNUZQ00A49gCEJQg8RhJD8j0DQX6IEBZYMLMAAANZrpHa8lkNBwjOi0Ion90KRIDIQEzsdVfzlurhT1X11F2XqE3qwfNQMiYLGYIYNgAQMcTltXHV3z9w1dAD/8LapH/XJt9eycWudG4U8lGrjYeSIAtMFlaD1SU1NxAR0cA9qrpqr6ruaOmybxLPREBojLEOzoMNkAXsO4YNYRnIpNo3WS30+EByXt+kttY3AEdAyGmZ4/TcKORCDgDhEAg5D0wO7vK1mbmwhajxA9XWkXTTh8dVj6wZX9gr6ZFL9eTm1nbVhUREdOs2Vb25sJqmRTuOq+r+rwfmgGEHVYcU+H7a8KNrdP6kYTXBJ6qPFVjT2DxwzD/msbWqE+vnrvqvevSeutGMUm0dXC+ahk3asb5unt+8cvLIqOvr52nU7Dv7nq31afo0/0mzrhiavwAx1n2SsZnMdgAAAABJRU5ErkJggg==";
class gV {
  bootstrap() {
    this.restore();
    let e;
    e = Na(() => {
      this.persist(), e && e();
    });
  }
  persist() {
    const e = Pi(), { lang: n } = xn(e);
    Bn(
      n,
      (a, s) => {
        s !== a && (Ir.setValue(Ou, a), document.documentElement.setAttribute("lang", a));
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Ir.getValue(Ou);
    if (e) {
      const { setLang: n } = Pi(), { i18next: a } = An();
      a.changeLanguage(e), n(e);
    }
  }
}
const vV = new gV(), _V = /* @__PURE__ */ ur({
  __name: "language-selector",
  setup(t) {
    const { i18next: e, t: n } = An(), { setLang: a } = Pi(), { lang: s } = xn(Pi()), f = Ur(
      () => ["en", "de", "fr", "lb"].map((g) => ({
        label: n(g),
        value: g,
        ariaLabel: n("Changer de langue : {{lang}}", { lang: g })
      }))
    ), o = n("Changer de langue");
    vV.bootstrap();
    function m(g) {
      e.changeLanguage(g), a(g);
    }
    return (g, b) => (Ue(), st("div", null, [
      Gt(AT, {
        class: "lux-navbar-dropdown lux-dropdown-inline text-white h-full",
        options: le(f),
        placeholder: le(o),
        modelValue: le(s),
        "onUpdate:modelValue": b[0] || (b[0] = (T) => hn(s) ? s.value = T : null),
        onChange: m
      }, null, 8, ["options", "placeholder", "modelValue"])
    ]));
  }
}), xV = /* @__PURE__ */ mr(_V, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/nav-bars/language-selector.vue"]]);
class bV {
  setCurrentThemeColors(e) {
    const n = document.querySelector(":root");
    ["primary", "secondary", "tertiary"].forEach((s) => {
      const f = getComputedStyle(n).getPropertyValue(
        `--${e}-${s}`
      );
      n.style.setProperty(`--color-${s}`, f);
    });
  }
}
const wV = new bV(), EV = { class: "w-full h-14 flex bg-white shadow-header z-10 shrink-0" }, SV = /* @__PURE__ */ Ne("div", { class: "flex-2 p-[5px]" }, [
  /* @__PURE__ */ Ne("img", { src: yV })
], -1), TV = /* @__PURE__ */ Ne("div", { class: "grow text-center" }, "search", -1), MV = { class: "h-full flex" }, IV = { class: "hidden lg:inline-block" }, OV = { class: "border-l-[1px] border-stone-300 h-full" }, CV = /* @__PURE__ */ ur({
  __name: "header-bar",
  setup(t) {
    const { t: e } = An(), n = Pi(), { layersOpen: a, myLayersTabOpen: s, themeGridOpen: f } = xn(n), { setLayersOpen: o, setMyLayersTabOpen: m, setThemeGridOpen: g } = n, b = Ro(), { theme: T } = xn(b);
    Bn(
      T,
      (I) => {
        I && wV.setCurrentThemeColors(I.name);
      },
      { immediate: !0 }
    );
    function M() {
      a.value ? a.value && (f.value ? o(!1) : (s.value && m(!1), g(!0))) : (o(!0), s.value && m(!1), g(!0));
    }
    return (I, A) => {
      var z, V;
      return Ue(), st("header", EV, [
        SV,
        TV,
        Ne("div", null, [
          Ne("ul", MV, [
            Ne("li", null, [
              Ne("button", {
                class: Lr(["flex items-center before:font-icons before:text-3xl before:w-16 text-primary uppercase h-full mr-3", `before:content-${(z = le(T)) == null ? void 0 : z.name}`]),
                onClick: M
              }, [
                Ne("span", IV, Vt(le(e)(`${(V = le(T)) == null ? void 0 : V.name}`)), 1)
              ], 2)
            ]),
            Ne("li", OV, [
              Gt(xV, { class: "flex-none h-full" })
            ])
          ])
        ])
      ]);
    };
  }
}), AV = /* @__PURE__ */ mr(CV, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/header/header-bar.vue"]]), PV = { class: "block text-[13px] sm:text-base uppercase" }, kV = /* @__PURE__ */ ur({
  __name: "button-icon",
  props: {
    label: { type: String, required: !0 },
    icon: { type: String, required: !0 },
    active: { type: Boolean, required: !1 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Ue(), st("button", {
      class: Lr(["h-[42px] w-full sm:h-full sm:w-16 hover:text-white hover:bg-primary", e.active ? "bg-primary text-white" : ""])
    }, [
      Ne("span", {
        class: Lr(["block text-[1.7rem] sm:text-[2rem] -mt-1.5 -mb-3 after:font-icons", e.active ? "lux-close-cross" : `after:content-${e.icon}`])
      }, null, 2),
      Ne("span", PV, Vt(e.label), 1)
    ], 2));
  }
}), Al = /* @__PURE__ */ mr(kV, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/footer/button-icon.vue"]]), LV = ["href"], DV = /* @__PURE__ */ ur({
  __name: "button-link",
  props: {
    label: { type: String, required: !0 },
    link: { type: String, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Ue(), st("a", {
      class: "h-full flex flex-col justify-center px-[7px] uppercase hover:text-white hover:bg-primary",
      href: `${e.link}`,
      target: "_blank"
    }, Vt(n.$props.label), 9, LV));
  }
}), mu = /* @__PURE__ */ mr(DV, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/footer/button-link.vue"]]), NV = { class: "flex flex-col w-12 justify-between bg-white z-5 shrink-0 sm:flex-row sm:w-full sm:h-14 sm:shadow-footer" }, RV = { class: "flex flex-col w-full sm:w-80 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" }, zV = { class: "flex flex-col w-12 sm:w-64 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" }, FV = { class: "w-[466px] hidden sm:flex flex-row justify-end text-gray-500 whitespace-nowrap" }, BV = /* @__PURE__ */ ur({
  __name: "footer-bar",
  setup(t) {
    const { t: e, i18next: n } = An(), { setLayersOpen: a } = Pi(), { layersOpen: s } = xn(Pi());
    return (f, o) => (Ue(), st("footer", NV, [
      it(" left buttons "),
      Ne("ul", RV, [
        Ne("li", null, [
          Gt(Al, {
            label: le(e)("Layers", { ns: "client" }),
            icon: "layers",
            active: le(s),
            onClick: o[0] || (o[0] = () => le(a)(!le(s)))
          }, null, 8, ["label", "active"])
        ]),
        it(`TODOs in each button when implemented
        - remove class="text-gray-300"
        - add click handler that calls setLayersOpen(true) and opens tool (also via app store)
      `),
        Ne("li", null, [
          Gt(Al, {
            class: "text-gray-300",
            label: le(e)("My Maps", { ns: "client" }),
            icon: "mymaps"
          }, null, 8, ["label"])
        ]),
        Ne("li", null, [
          Gt(Al, {
            class: "text-gray-300",
            label: le(e)("Infos", { ns: "client" }),
            icon: "infos"
          }, null, 8, ["label"])
        ]),
        Ne("li", null, [
          Gt(Al, {
            class: "text-gray-300",
            label: le(e)("Legends", { ns: "client" }),
            icon: "legends"
          }, null, 8, ["label"])
        ]),
        Ne("li", null, [
          Gt(Al, {
            class: "text-gray-300",
            label: le(e)("Routing", { ns: "client" }),
            icon: "routing"
          }, null, 8, ["label"])
        ])
      ]),
      it(" center buttons "),
      Ne("div", zV, [
        Gt(Al, {
          class: "text-gray-300",
          label: le(e)("Dessin", { ns: "client" }),
          icon: "draw"
        }, null, 8, ["label"]),
        Gt(Al, {
          class: "text-gray-300 hidden sm:block",
          label: le(e)("Mesurer", { ns: "client" }),
          icon: "measure"
        }, null, 8, ["label"]),
        Gt(Al, {
          class: "text-gray-300 hidden sm:block",
          label: le(e)("Imprimer", { ns: "client" }),
          icon: "print"
        }, null, 8, ["label"]),
        Gt(Al, {
          class: "text-gray-300",
          label: le(e)("Partager", { ns: "client" }),
          icon: "share"
        }, null, 8, ["label"])
      ]),
      it(" right buttons "),
      Ne("div", FV, [
        Gt(mu, {
          class: "hidden lg:flex",
          label: le(e)("What's new", { ns: "client" }),
          link: `https://geoportail.lu/${le(n).language}/questions/whats-new/`
        }, null, 8, ["label", "link"]),
        it("TODO get geonetworkBaseUrl from config"),
        Gt(mu, {
          class: "hidden lg:flex",
          label: le(e)("Geocatalogue", { ns: "client" }),
          link: ""
        }, null, 8, ["label"]),
        it("TODO handle feedback links (for different portals?)"),
        Gt(mu, {
          class: "hidden lg:flex",
          label: le(e)("Feedback", { ns: "client" }),
          link: ""
        }, null, 8, ["label"]),
        Gt(mu, {
          class: "hidden lg:flex",
          label: le(e)("A Propos", { ns: "client" }),
          link: `https://www.geoportail.lu/${le(n).language}/propos/`
        }, null, 8, ["label", "link"]),
        Gt(mu, {
          class: "hidden lg:flex",
          label: le(e)("Aide", { ns: "client" }),
          link: `https://www.geoportail.lu/${le(n).language}/documentation/`
        }, null, 8, ["label", "link"]),
        Gt(mu, {
          class: "hidden lg:flex",
          label: le(e)("Contact", { ns: "client" }),
          link: `https://www.geoportail.lu/${le(n).language}/propos/contactez-nous/`
        }, null, 8, ["label", "link"]),
        Gt(mu, {
          label: le(e)("Legalites", { ns: "client" }),
          link: `https://www.geoportail.lu/${le(n).language}/propos/mentions-legales/`
        }, null, 8, ["label", "link"]),
        Gt(mu, {
          label: le(e)("ACT", { ns: "client" }),
          link: "http://www.act.public.lu/"
        }, null, 8, ["label", "link"])
      ])
    ]));
  }
}), VV = /* @__PURE__ */ mr(BV, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/footer/footer-bar.vue"]]), UV = { class: "flex flex-row flex-wrap pl-2.5" }, jV = ["onClick"], GV = { class: "text-2xl absolute top-5" }, qV = /* @__PURE__ */ ur({
  __name: "theme-grid",
  props: {
    themes: { type: Array, required: !0 }
  },
  setup(t) {
    const e = t, { t: n } = An();
    return (a, s) => (Ue(), st("div", UV, [
      (Ue(!0), st(un, null, Ra(e.themes, (f) => (Ue(), st("button", {
        class: Lr(["relative shrink-0 h-[150px] w-1/2 px-2.5 text-start text-gray-100/40 uppercase hover:bg-[#ccc]", `bg-${f.name}-primary hover:text-${f.name}-primary`]),
        key: f.id,
        onClick: (o) => a.$emit("setTheme", f.name)
      }, [
        Ne("div", GV, Vt(le(n)(`${f.name}`)), 1),
        Ne("div", {
          class: Lr(["text-6xl absolute bottom-1 after:font-icons", `after:content-${f.name}`])
        }, null, 2)
      ], 10, jV))), 128))
    ]));
  }
}), $V = /* @__PURE__ */ mr(qV, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/theme-selector/theme-grid.vue"]]), WV = ["aria-expanded"], HV = { class: "py-0.5" }, ZV = { class: "px-1 py-0.5 shrink-0 flex flex-row text-[12px] bg-secondary text-white" }, XV = { class: "py-[3px]" }, KV = { class: "flex flex-row flex-wrap ml-1 w-12" }, YV = /* @__PURE__ */ ur({
  __name: "theme-selector-button",
  props: {
    themes: { type: Array, required: !0 },
    currentTheme: { type: null, required: !1 },
    isOpen: { type: Boolean, required: !1 }
  },
  setup(t) {
    const e = t, { t: n } = An(), a = Ur(() => {
      var s;
      return ((s = e.themes) == null ? void 0 : s.slice(0, 8)) || [];
    });
    return (s, f) => {
      var o;
      return Ue(), st("button", {
        class: "w-full flex flex-row justify-between bg-tertiary text-white px-2 py-1.5 uppercase cursor-pointer hover:bg-white hover:text-primary",
        "aria-expanded": e.isOpen
      }, [
        Ne("span", HV, Vt(le(n)("Theme")) + ": " + Vt(le(n)(`${(o = e.currentTheme) == null ? void 0 : o.name}`)), 1),
        Ne("span", ZV, [
          Ne("span", XV, Vt(le(n)("Changer")), 1),
          Ne("span", KV, [
            (Ue(!0), st(un, null, Ra(le(a), (m) => (Ue(), st("div", {
              class: Lr(`h-2.5 w-2.5 m-px bg-${m.name}-primary`),
              key: m.id
            }, null, 2))), 128))
          ])
        ])
      ], 8, WV);
    };
  }
}), JV = /* @__PURE__ */ mr(YV, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/theme-selector/theme-selector-button.vue"]]), QV = {
  key: 0,
  class: "absolute inset-x-0 top-14 bottom-0 mt-1 bg-primary overflow-y-auto overflow-x-hidden"
}, eU = /* @__PURE__ */ ur({
  __name: "theme-selector",
  setup(t) {
    const e = Pi(), { setThemeGridOpen: n } = e, { themeGridOpen: a } = xn(e), s = Ro(), f = Gc(), { theme: o, themes: m } = xn(s), g = Ur(
      () => {
        var M;
        return ((M = m.value) == null ? void 0 : M.filter(
          (I) => {
            var A;
            return ((A = I.metadata) == null ? void 0 : A.display_in_switcher) === !0;
          }
        )) || [];
      }
    );
    function b() {
      n(!a.value);
    }
    function T(M) {
      f.setTheme(M), b();
    }
    return (M, I) => (Ue(), st(un, null, [
      Gt(JV, {
        onClick: b,
        themes: le(g),
        currentTheme: le(o),
        isOpen: le(a)
      }, null, 8, ["themes", "currentTheme", "isOpen"]),
      le(a) ? (Ue(), st("div", QV, [
        Gt($V, {
          onSetTheme: T,
          themes: le(g)
        }, null, 8, ["themes"])
      ])) : it("v-if", !0)
    ], 64));
  }
}), tU = /* @__PURE__ */ mr(eU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/theme-selector/theme-selector.vue"]]);
function a1(t, e = 0) {
  const { name: n, id: a, children: s, metadata: f } = t;
  return {
    name: n,
    id: a,
    depth: e,
    children: s == null ? void 0 : s.map((o) => a1(o, e + 1)),
    checked: !1,
    expanded: (f == null ? void 0 : f.is_expanded) || !1
  };
}
const rU = /* @__PURE__ */ ur({
  __name: "catalog-tree",
  setup(t) {
    const e = Ai(), n = Ro(), a = Au(), s = Fn(), f = Fn(), o = Ur(
      () => !e.is_3d_active || e.is_3d_active && !e.is_3d_mesh
    ), { layerTrees_3d: m } = xn(n);
    Na(g);
    function g() {
      var M;
      if (n.theme && e.layers) {
        const I = s.value && s.value.id === ((M = n.theme) == null ? void 0 : M.id) ? s.value : a1(n.theme);
        s.value = Of.updateLayers(
          I,
          e.layers
        );
      }
    }
    Na(() => {
      if (m.value) {
        const M = f.value ? f.value : a1(m.value);
        f.value = Of.updateLayers(
          M,
          e.layers_3d
        );
      }
    });
    function b(M, I) {
      const A = I ? f : s;
      A.value = Of.toggleNode(
        M.id,
        A.value,
        "expanded"
      );
    }
    function T(M, I) {
      a.toggleLayer(+M.id, !M.checked, I);
    }
    return (M, I) => (Ue(), st("div", null, [
      it(" 3D layers catalog, only displayed when 3D is active "),
      le(f) && le(e).is_3d_active ? (Ue(), cn(i1, {
        class: "mb-7",
        node: le(f),
        key: le(f).id,
        onToggleParent: I[0] || (I[0] = (A) => b(A, !0)),
        onToggleLayer: I[1] || (I[1] = (A) => T(A, !0))
      }, null, 8, ["node"])) : it("v-if", !0),
      it(" Main catalog, displays by default and 3D terrain active "),
      le(s) && le(o) ? (Ue(), cn(i1, {
        node: le(s),
        key: le(s).id,
        onToggleParent: I[2] || (I[2] = (A) => b(A, !1)),
        onToggleLayer: I[3] || (I[3] = (A) => T(A, !1))
      }, null, 8, ["node"])) : it("v-if", !0)
    ]));
  }
}), nU = /* @__PURE__ */ mr(rU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/catalog/catalog-tree.vue"]]), iU = /* @__PURE__ */ ur({
  __name: "catalog-tab",
  setup(t) {
    const { themeGridOpen: e } = xn(Pi());
    return (n, a) => (Ue(), st(un, null, [
      Gt(tU),
      le(e) === !1 ? (Ue(), cn(nU, {
        key: 0,
        class: "pt-5 absolute inset-x-2.5 bg-primary overflow-y-auto overflow-x-hidden"
      })) : it("v-if", !0)
    ], 64));
  }
}), oU = /* @__PURE__ */ mr(iU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/catalog/catalog-tab.vue"]]);
/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function sE(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Js(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? sE(Object(n), !0).forEach(function(a) {
      aU(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : sE(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function ug(t) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ug = function(e) {
    return typeof e;
  } : ug = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ug(t);
}
function aU(t, e, n) {
  return e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Ul() {
  return Ul = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, Ul.apply(this, arguments);
}
function sU(t, e) {
  if (t == null)
    return {};
  var n = {}, a = Object.keys(t), s, f;
  for (f = 0; f < a.length; f++)
    s = a[f], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
function lU(t, e) {
  if (t == null)
    return {};
  var n = sU(t, e), a, s;
  if (Object.getOwnPropertySymbols) {
    var f = Object.getOwnPropertySymbols(t);
    for (s = 0; s < f.length; s++)
      a = f[s], !(e.indexOf(a) >= 0) && (!Object.prototype.propertyIsEnumerable.call(t, a) || (n[a] = t[a]));
  }
  return n;
}
var uU = "1.15.0";
function Rl(t) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(t);
}
var ql = Rl(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), tm = Rl(/Edge/i), lE = Rl(/firefox/i), vd = Rl(/safari/i) && !Rl(/chrome/i) && !Rl(/android/i), uI = Rl(/iP(ad|od|hone)/i), cI = Rl(/chrome/i) && Rl(/android/i), hI = {
  capture: !1,
  passive: !1
};
function nn(t, e, n) {
  t.addEventListener(e, n, !ql && hI);
}
function Kr(t, e, n) {
  t.removeEventListener(e, n, !ql && hI);
}
function Xg(t, e) {
  if (!!e) {
    if (e[0] === ">" && (e = e.substring(1)), t)
      try {
        if (t.matches)
          return t.matches(e);
        if (t.msMatchesSelector)
          return t.msMatchesSelector(e);
        if (t.webkitMatchesSelector)
          return t.webkitMatchesSelector(e);
      } catch {
        return !1;
      }
    return !1;
  }
}
function cU(t) {
  return t.host && t !== document && t.host.nodeType ? t.host : t.parentNode;
}
function Fs(t, e, n, a) {
  if (t) {
    n = n || document;
    do {
      if (e != null && (e[0] === ">" ? t.parentNode === n && Xg(t, e) : Xg(t, e)) || a && t === n)
        return t;
      if (t === n)
        break;
    } while (t = cU(t));
  }
  return null;
}
var uE = /\s+/g;
function ha(t, e, n) {
  if (t && e)
    if (t.classList)
      t.classList[n ? "add" : "remove"](e);
    else {
      var a = (" " + t.className + " ").replace(uE, " ").replace(" " + e + " ", " ");
      t.className = (a + (n ? " " + e : "")).replace(uE, " ");
    }
}
function ar(t, e, n) {
  var a = t && t.style;
  if (a) {
    if (n === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(t, "") : t.currentStyle && (n = t.currentStyle), e === void 0 ? n : n[e];
    !(e in a) && e.indexOf("webkit") === -1 && (e = "-webkit-" + e), a[e] = n + (typeof n == "string" ? "" : "px");
  }
}
function Cf(t, e) {
  var n = "";
  if (typeof t == "string")
    n = t;
  else
    do {
      var a = ar(t, "transform");
      a && a !== "none" && (n = a + " " + n);
    } while (!e && (t = t.parentNode));
  var s = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return s && new s(n);
}
function fI(t, e, n) {
  if (t) {
    var a = t.getElementsByTagName(e), s = 0, f = a.length;
    if (n)
      for (; s < f; s++)
        n(a[s], s);
    return a;
  }
  return [];
}
function Zs() {
  var t = document.scrollingElement;
  return t || document.documentElement;
}
function Ri(t, e, n, a, s) {
  if (!(!t.getBoundingClientRect && t !== window)) {
    var f, o, m, g, b, T, M;
    if (t !== window && t.parentNode && t !== Zs() ? (f = t.getBoundingClientRect(), o = f.top, m = f.left, g = f.bottom, b = f.right, T = f.height, M = f.width) : (o = 0, m = 0, g = window.innerHeight, b = window.innerWidth, T = window.innerHeight, M = window.innerWidth), (e || n) && t !== window && (s = s || t.parentNode, !ql))
      do
        if (s && s.getBoundingClientRect && (ar(s, "transform") !== "none" || n && ar(s, "position") !== "static")) {
          var I = s.getBoundingClientRect();
          o -= I.top + parseInt(ar(s, "border-top-width")), m -= I.left + parseInt(ar(s, "border-left-width")), g = o + f.height, b = m + f.width;
          break;
        }
      while (s = s.parentNode);
    if (a && t !== window) {
      var A = Cf(s || t), z = A && A.a, V = A && A.d;
      A && (o /= V, m /= z, M /= z, T /= V, g = o + T, b = m + M);
    }
    return {
      top: o,
      left: m,
      bottom: g,
      right: b,
      width: M,
      height: T
    };
  }
}
function cE(t, e, n) {
  for (var a = Su(t, !0), s = Ri(t)[e]; a; ) {
    var f = Ri(a)[n], o = void 0;
    if (n === "top" || n === "left" ? o = s >= f : o = s <= f, !o)
      return a;
    if (a === Zs())
      break;
    a = Su(a, !1);
  }
  return !1;
}
function Nf(t, e, n, a) {
  for (var s = 0, f = 0, o = t.children; f < o.length; ) {
    if (o[f].style.display !== "none" && o[f] !== sr.ghost && (a || o[f] !== sr.dragged) && Fs(o[f], n.draggable, t, !1)) {
      if (s === e)
        return o[f];
      s++;
    }
    f++;
  }
  return null;
}
function nx(t, e) {
  for (var n = t.lastElementChild; n && (n === sr.ghost || ar(n, "display") === "none" || e && !Xg(n, e)); )
    n = n.previousElementSibling;
  return n || null;
}
function Aa(t, e) {
  var n = 0;
  if (!t || !t.parentNode)
    return -1;
  for (; t = t.previousElementSibling; )
    t.nodeName.toUpperCase() !== "TEMPLATE" && t !== sr.clone && (!e || Xg(t, e)) && n++;
  return n;
}
function hE(t) {
  var e = 0, n = 0, a = Zs();
  if (t)
    do {
      var s = Cf(t), f = s.a, o = s.d;
      e += t.scrollLeft * f, n += t.scrollTop * o;
    } while (t !== a && (t = t.parentNode));
  return [e, n];
}
function hU(t, e) {
  for (var n in t)
    if (!!t.hasOwnProperty(n)) {
      for (var a in e)
        if (e.hasOwnProperty(a) && e[a] === t[n][a])
          return Number(n);
    }
  return -1;
}
function Su(t, e) {
  if (!t || !t.getBoundingClientRect)
    return Zs();
  var n = t, a = !1;
  do
    if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) {
      var s = ar(n);
      if (n.clientWidth < n.scrollWidth && (s.overflowX == "auto" || s.overflowX == "scroll") || n.clientHeight < n.scrollHeight && (s.overflowY == "auto" || s.overflowY == "scroll")) {
        if (!n.getBoundingClientRect || n === document.body)
          return Zs();
        if (a || e)
          return n;
        a = !0;
      }
    }
  while (n = n.parentNode);
  return Zs();
}
function fU(t, e) {
  if (t && e)
    for (var n in e)
      e.hasOwnProperty(n) && (t[n] = e[n]);
  return t;
}
function s0(t, e) {
  return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width);
}
var _d;
function pI(t, e) {
  return function() {
    if (!_d) {
      var n = arguments, a = this;
      n.length === 1 ? t.call(a, n[0]) : t.apply(a, n), _d = setTimeout(function() {
        _d = void 0;
      }, e);
    }
  };
}
function pU() {
  clearTimeout(_d), _d = void 0;
}
function dI(t, e, n) {
  t.scrollLeft += e, t.scrollTop += n;
}
function mI(t) {
  var e = window.Polymer, n = window.jQuery || window.Zepto;
  return e && e.dom ? e.dom(t).cloneNode(!0) : n ? n(t).clone(!0)[0] : t.cloneNode(!0);
}
var ma = "Sortable" + new Date().getTime();
function dU() {
  var t = [], e;
  return {
    captureAnimationState: function() {
      if (t = [], !!this.options.animation) {
        var a = [].slice.call(this.el.children);
        a.forEach(function(s) {
          if (!(ar(s, "display") === "none" || s === sr.ghost)) {
            t.push({
              target: s,
              rect: Ri(s)
            });
            var f = Js({}, t[t.length - 1].rect);
            if (s.thisAnimationDuration) {
              var o = Cf(s, !0);
              o && (f.top -= o.f, f.left -= o.e);
            }
            s.fromRect = f;
          }
        });
      }
    },
    addAnimationState: function(a) {
      t.push(a);
    },
    removeAnimationState: function(a) {
      t.splice(hU(t, {
        target: a
      }), 1);
    },
    animateAll: function(a) {
      var s = this;
      if (!this.options.animation) {
        clearTimeout(e), typeof a == "function" && a();
        return;
      }
      var f = !1, o = 0;
      t.forEach(function(m) {
        var g = 0, b = m.target, T = b.fromRect, M = Ri(b), I = b.prevFromRect, A = b.prevToRect, z = m.rect, V = Cf(b, !0);
        V && (M.top -= V.f, M.left -= V.e), b.toRect = M, b.thisAnimationDuration && s0(I, M) && !s0(T, M) && (z.top - M.top) / (z.left - M.left) === (T.top - M.top) / (T.left - M.left) && (g = yU(z, I, A, s.options)), s0(M, T) || (b.prevFromRect = T, b.prevToRect = M, g || (g = s.options.animation), s.animate(b, z, M, g)), g && (f = !0, o = Math.max(o, g), clearTimeout(b.animationResetTimer), b.animationResetTimer = setTimeout(function() {
          b.animationTime = 0, b.prevFromRect = null, b.fromRect = null, b.prevToRect = null, b.thisAnimationDuration = null;
        }, g), b.thisAnimationDuration = g);
      }), clearTimeout(e), f ? e = setTimeout(function() {
        typeof a == "function" && a();
      }, o) : typeof a == "function" && a(), t = [];
    },
    animate: function(a, s, f, o) {
      if (o) {
        ar(a, "transition", ""), ar(a, "transform", "");
        var m = Cf(this.el), g = m && m.a, b = m && m.d, T = (s.left - f.left) / (g || 1), M = (s.top - f.top) / (b || 1);
        a.animatingX = !!T, a.animatingY = !!M, ar(a, "transform", "translate3d(" + T + "px," + M + "px,0)"), this.forRepaintDummy = mU(a), ar(a, "transition", "transform " + o + "ms" + (this.options.easing ? " " + this.options.easing : "")), ar(a, "transform", "translate3d(0,0,0)"), typeof a.animated == "number" && clearTimeout(a.animated), a.animated = setTimeout(function() {
          ar(a, "transition", ""), ar(a, "transform", ""), a.animated = !1, a.animatingX = !1, a.animatingY = !1;
        }, o);
      }
    }
  };
}
function mU(t) {
  return t.offsetWidth;
}
function yU(t, e, n, a) {
  return Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) / Math.sqrt(Math.pow(e.top - n.top, 2) + Math.pow(e.left - n.left, 2)) * a.animation;
}
var nf = [], l0 = {
  initializeByDefault: !0
}, rm = {
  mount: function(e) {
    for (var n in l0)
      l0.hasOwnProperty(n) && !(n in e) && (e[n] = l0[n]);
    nf.forEach(function(a) {
      if (a.pluginName === e.pluginName)
        throw "Sortable: Cannot mount plugin ".concat(e.pluginName, " more than once");
    }), nf.push(e);
  },
  pluginEvent: function(e, n, a) {
    var s = this;
    this.eventCanceled = !1, a.cancel = function() {
      s.eventCanceled = !0;
    };
    var f = e + "Global";
    nf.forEach(function(o) {
      !n[o.pluginName] || (n[o.pluginName][f] && n[o.pluginName][f](Js({
        sortable: n
      }, a)), n.options[o.pluginName] && n[o.pluginName][e] && n[o.pluginName][e](Js({
        sortable: n
      }, a)));
    });
  },
  initializePlugins: function(e, n, a, s) {
    nf.forEach(function(m) {
      var g = m.pluginName;
      if (!(!e.options[g] && !m.initializeByDefault)) {
        var b = new m(e, n, e.options);
        b.sortable = e, b.options = e.options, e[g] = b, Ul(a, b.defaults);
      }
    });
    for (var f in e.options)
      if (!!e.options.hasOwnProperty(f)) {
        var o = this.modifyOption(e, f, e.options[f]);
        typeof o < "u" && (e.options[f] = o);
      }
  },
  getEventProperties: function(e, n) {
    var a = {};
    return nf.forEach(function(s) {
      typeof s.eventProperties == "function" && Ul(a, s.eventProperties.call(n[s.pluginName], e));
    }), a;
  },
  modifyOption: function(e, n, a) {
    var s;
    return nf.forEach(function(f) {
      !e[f.pluginName] || f.optionListeners && typeof f.optionListeners[n] == "function" && (s = f.optionListeners[n].call(e[f.pluginName], a));
    }), s;
  }
};
function gU(t) {
  var e = t.sortable, n = t.rootEl, a = t.name, s = t.targetEl, f = t.cloneEl, o = t.toEl, m = t.fromEl, g = t.oldIndex, b = t.newIndex, T = t.oldDraggableIndex, M = t.newDraggableIndex, I = t.originalEvent, A = t.putSortable, z = t.extraEventProperties;
  if (e = e || n && n[ma], !!e) {
    var V, Z = e.options, X = "on" + a.charAt(0).toUpperCase() + a.substr(1);
    window.CustomEvent && !ql && !tm ? V = new CustomEvent(a, {
      bubbles: !0,
      cancelable: !0
    }) : (V = document.createEvent("Event"), V.initEvent(a, !0, !0)), V.to = o || n, V.from = m || n, V.item = s || n, V.clone = f, V.oldIndex = g, V.newIndex = b, V.oldDraggableIndex = T, V.newDraggableIndex = M, V.originalEvent = I, V.pullMode = A ? A.lastPutMode : void 0;
    var Y = Js(Js({}, z), rm.getEventProperties(a, e));
    for (var de in Y)
      V[de] = Y[de];
    n && n.dispatchEvent(V), Z[X] && Z[X].call(e, V);
  }
}
var vU = ["evt"], Jo = function(e, n) {
  var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = a.evt, f = lU(a, vU);
  rm.pluginEvent.bind(sr)(e, n, Js({
    dragEl: St,
    parentEl: hi,
    ghostEl: Sr,
    rootEl: $n,
    nextEl: kc,
    lastDownEl: cg,
    cloneEl: ri,
    cloneHidden: Eu,
    dragStarted: od,
    putSortable: no,
    activeSortable: sr.active,
    originalEvent: s,
    oldIndex: gf,
    oldDraggableIndex: xd,
    newIndex: fa,
    newDraggableIndex: _u,
    hideGhostForTarget: _I,
    unhideGhostForTarget: xI,
    cloneNowHidden: function() {
      Eu = !0;
    },
    cloneNowShown: function() {
      Eu = !1;
    },
    dispatchSortableEvent: function(m) {
      Lo({
        sortable: n,
        name: m,
        originalEvent: s
      });
    }
  }, f));
};
function Lo(t) {
  gU(Js({
    putSortable: no,
    cloneEl: ri,
    targetEl: St,
    rootEl: $n,
    oldIndex: gf,
    oldDraggableIndex: xd,
    newIndex: fa,
    newDraggableIndex: _u
  }, t));
}
var St, hi, Sr, $n, kc, cg, ri, Eu, gf, fa, xd, _u, Vy, no, uf = !1, Kg = !1, Yg = [], Mc, Ja, u0, c0, fE, pE, od, of, bd, wd = !1, Uy = !1, hg, go, h0 = [], s1 = !1, Jg = [], kv = typeof document < "u", jy = uI, dE = tm || ql ? "cssFloat" : "float", _U = kv && !cI && !uI && "draggable" in document.createElement("div"), yI = function() {
  if (!!kv) {
    if (ql)
      return !1;
    var t = document.createElement("x");
    return t.style.cssText = "pointer-events:auto", t.style.pointerEvents === "auto";
  }
}(), gI = function(e, n) {
  var a = ar(e), s = parseInt(a.width) - parseInt(a.paddingLeft) - parseInt(a.paddingRight) - parseInt(a.borderLeftWidth) - parseInt(a.borderRightWidth), f = Nf(e, 0, n), o = Nf(e, 1, n), m = f && ar(f), g = o && ar(o), b = m && parseInt(m.marginLeft) + parseInt(m.marginRight) + Ri(f).width, T = g && parseInt(g.marginLeft) + parseInt(g.marginRight) + Ri(o).width;
  if (a.display === "flex")
    return a.flexDirection === "column" || a.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (a.display === "grid")
    return a.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (f && m.float && m.float !== "none") {
    var M = m.float === "left" ? "left" : "right";
    return o && (g.clear === "both" || g.clear === M) ? "vertical" : "horizontal";
  }
  return f && (m.display === "block" || m.display === "flex" || m.display === "table" || m.display === "grid" || b >= s && a[dE] === "none" || o && a[dE] === "none" && b + T > s) ? "vertical" : "horizontal";
}, xU = function(e, n, a) {
  var s = a ? e.left : e.top, f = a ? e.right : e.bottom, o = a ? e.width : e.height, m = a ? n.left : n.top, g = a ? n.right : n.bottom, b = a ? n.width : n.height;
  return s === m || f === g || s + o / 2 === m + b / 2;
}, bU = function(e, n) {
  var a;
  return Yg.some(function(s) {
    var f = s[ma].options.emptyInsertThreshold;
    if (!(!f || nx(s))) {
      var o = Ri(s), m = e >= o.left - f && e <= o.right + f, g = n >= o.top - f && n <= o.bottom + f;
      if (m && g)
        return a = s;
    }
  }), a;
}, vI = function(e) {
  function n(f, o) {
    return function(m, g, b, T) {
      var M = m.options.group.name && g.options.group.name && m.options.group.name === g.options.group.name;
      if (f == null && (o || M))
        return !0;
      if (f == null || f === !1)
        return !1;
      if (o && f === "clone")
        return f;
      if (typeof f == "function")
        return n(f(m, g, b, T), o)(m, g, b, T);
      var I = (o ? m : g).options.group.name;
      return f === !0 || typeof f == "string" && f === I || f.join && f.indexOf(I) > -1;
    };
  }
  var a = {}, s = e.group;
  (!s || ug(s) != "object") && (s = {
    name: s
  }), a.name = s.name, a.checkPull = n(s.pull, !0), a.checkPut = n(s.put), a.revertClone = s.revertClone, e.group = a;
}, _I = function() {
  !yI && Sr && ar(Sr, "display", "none");
}, xI = function() {
  !yI && Sr && ar(Sr, "display", "");
};
kv && !cI && document.addEventListener("click", function(t) {
  if (Kg)
    return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), Kg = !1, !1;
}, !0);
var Ic = function(e) {
  if (St) {
    e = e.touches ? e.touches[0] : e;
    var n = bU(e.clientX, e.clientY);
    if (n) {
      var a = {};
      for (var s in e)
        e.hasOwnProperty(s) && (a[s] = e[s]);
      a.target = a.rootEl = n, a.preventDefault = void 0, a.stopPropagation = void 0, n[ma]._onDragOver(a);
    }
  }
}, wU = function(e) {
  St && St.parentNode[ma]._isOutsideThisEl(e.target);
};
function sr(t, e) {
  if (!(t && t.nodeType && t.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t));
  this.el = t, this.options = e = Ul({}, e), t[ma] = this;
  var n = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(t.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: !1,
    invertedSwapThreshold: null,
    removeCloneOnHide: !0,
    direction: function() {
      return gI(t, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(o, m) {
      o.setData("Text", m.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: sr.supportPointer !== !1 && "PointerEvent" in window && !vd,
    emptyInsertThreshold: 5
  };
  rm.initializePlugins(this, t, n);
  for (var a in n)
    !(a in e) && (e[a] = n[a]);
  vI(e);
  for (var s in this)
    s.charAt(0) === "_" && typeof this[s] == "function" && (this[s] = this[s].bind(this));
  this.nativeDraggable = e.forceFallback ? !1 : _U, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? nn(t, "pointerdown", this._onTapStart) : (nn(t, "mousedown", this._onTapStart), nn(t, "touchstart", this._onTapStart)), this.nativeDraggable && (nn(t, "dragover", this), nn(t, "dragenter", this)), Yg.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), Ul(this, dU());
}
sr.prototype = {
  constructor: sr,
  _isOutsideThisEl: function(e) {
    !this.el.contains(e) && e !== this.el && (of = null);
  },
  _getDirection: function(e, n) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, e, n, St) : this.options.direction;
  },
  _onTapStart: function(e) {
    if (!!e.cancelable) {
      var n = this, a = this.el, s = this.options, f = s.preventOnFilter, o = e.type, m = e.touches && e.touches[0] || e.pointerType && e.pointerType === "touch" && e, g = (m || e).target, b = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || g, T = s.filter;
      if (AU(a), !St && !(/mousedown|pointerdown/.test(o) && e.button !== 0 || s.disabled) && !b.isContentEditable && !(!this.nativeDraggable && vd && g && g.tagName.toUpperCase() === "SELECT") && (g = Fs(g, s.draggable, a, !1), !(g && g.animated) && cg !== g)) {
        if (gf = Aa(g), xd = Aa(g, s.draggable), typeof T == "function") {
          if (T.call(this, e, g, this)) {
            Lo({
              sortable: n,
              rootEl: b,
              name: "filter",
              targetEl: g,
              toEl: a,
              fromEl: a
            }), Jo("filter", n, {
              evt: e
            }), f && e.cancelable && e.preventDefault();
            return;
          }
        } else if (T && (T = T.split(",").some(function(M) {
          if (M = Fs(b, M.trim(), a, !1), M)
            return Lo({
              sortable: n,
              rootEl: M,
              name: "filter",
              targetEl: g,
              fromEl: a,
              toEl: a
            }), Jo("filter", n, {
              evt: e
            }), !0;
        }), T)) {
          f && e.cancelable && e.preventDefault();
          return;
        }
        s.handle && !Fs(b, s.handle, a, !1) || this._prepareDragStart(e, m, g);
      }
    }
  },
  _prepareDragStart: function(e, n, a) {
    var s = this, f = s.el, o = s.options, m = f.ownerDocument, g;
    if (a && !St && a.parentNode === f) {
      var b = Ri(a);
      if ($n = f, St = a, hi = St.parentNode, kc = St.nextSibling, cg = a, Vy = o.group, sr.dragged = St, Mc = {
        target: St,
        clientX: (n || e).clientX,
        clientY: (n || e).clientY
      }, fE = Mc.clientX - b.left, pE = Mc.clientY - b.top, this._lastX = (n || e).clientX, this._lastY = (n || e).clientY, St.style["will-change"] = "all", g = function() {
        if (Jo("delayEnded", s, {
          evt: e
        }), sr.eventCanceled) {
          s._onDrop();
          return;
        }
        s._disableDelayedDragEvents(), !lE && s.nativeDraggable && (St.draggable = !0), s._triggerDragStart(e, n), Lo({
          sortable: s,
          name: "choose",
          originalEvent: e
        }), ha(St, o.chosenClass, !0);
      }, o.ignore.split(",").forEach(function(T) {
        fI(St, T.trim(), f0);
      }), nn(m, "dragover", Ic), nn(m, "mousemove", Ic), nn(m, "touchmove", Ic), nn(m, "mouseup", s._onDrop), nn(m, "touchend", s._onDrop), nn(m, "touchcancel", s._onDrop), lE && this.nativeDraggable && (this.options.touchStartThreshold = 4, St.draggable = !0), Jo("delayStart", this, {
        evt: e
      }), o.delay && (!o.delayOnTouchOnly || n) && (!this.nativeDraggable || !(tm || ql))) {
        if (sr.eventCanceled) {
          this._onDrop();
          return;
        }
        nn(m, "mouseup", s._disableDelayedDrag), nn(m, "touchend", s._disableDelayedDrag), nn(m, "touchcancel", s._disableDelayedDrag), nn(m, "mousemove", s._delayedDragTouchMoveHandler), nn(m, "touchmove", s._delayedDragTouchMoveHandler), o.supportPointer && nn(m, "pointermove", s._delayedDragTouchMoveHandler), s._dragStartTimer = setTimeout(g, o.delay);
      } else
        g();
    }
  },
  _delayedDragTouchMoveHandler: function(e) {
    var n = e.touches ? e.touches[0] : e;
    Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    St && f0(St), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var e = this.el.ownerDocument;
    Kr(e, "mouseup", this._disableDelayedDrag), Kr(e, "touchend", this._disableDelayedDrag), Kr(e, "touchcancel", this._disableDelayedDrag), Kr(e, "mousemove", this._delayedDragTouchMoveHandler), Kr(e, "touchmove", this._delayedDragTouchMoveHandler), Kr(e, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(e, n) {
    n = n || e.pointerType == "touch" && e, !this.nativeDraggable || n ? this.options.supportPointer ? nn(document, "pointermove", this._onTouchMove) : n ? nn(document, "touchmove", this._onTouchMove) : nn(document, "mousemove", this._onTouchMove) : (nn(St, "dragend", this), nn($n, "dragstart", this._onDragStart));
    try {
      document.selection ? fg(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(e, n) {
    if (uf = !1, $n && St) {
      Jo("dragStarted", this, {
        evt: n
      }), this.nativeDraggable && nn(document, "dragover", wU);
      var a = this.options;
      !e && ha(St, a.dragClass, !1), ha(St, a.ghostClass, !0), sr.active = this, e && this._appendGhost(), Lo({
        sortable: this,
        name: "start",
        originalEvent: n
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (Ja) {
      this._lastX = Ja.clientX, this._lastY = Ja.clientY, _I();
      for (var e = document.elementFromPoint(Ja.clientX, Ja.clientY), n = e; e && e.shadowRoot && (e = e.shadowRoot.elementFromPoint(Ja.clientX, Ja.clientY), e !== n); )
        n = e;
      if (St.parentNode[ma]._isOutsideThisEl(e), n)
        do {
          if (n[ma]) {
            var a = void 0;
            if (a = n[ma]._onDragOver({
              clientX: Ja.clientX,
              clientY: Ja.clientY,
              target: e,
              rootEl: n
            }), a && !this.options.dragoverBubble)
              break;
          }
          e = n;
        } while (n = n.parentNode);
      xI();
    }
  },
  _onTouchMove: function(e) {
    if (Mc) {
      var n = this.options, a = n.fallbackTolerance, s = n.fallbackOffset, f = e.touches ? e.touches[0] : e, o = Sr && Cf(Sr, !0), m = Sr && o && o.a, g = Sr && o && o.d, b = jy && go && hE(go), T = (f.clientX - Mc.clientX + s.x) / (m || 1) + (b ? b[0] - h0[0] : 0) / (m || 1), M = (f.clientY - Mc.clientY + s.y) / (g || 1) + (b ? b[1] - h0[1] : 0) / (g || 1);
      if (!sr.active && !uf) {
        if (a && Math.max(Math.abs(f.clientX - this._lastX), Math.abs(f.clientY - this._lastY)) < a)
          return;
        this._onDragStart(e, !0);
      }
      if (Sr) {
        o ? (o.e += T - (u0 || 0), o.f += M - (c0 || 0)) : o = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: T,
          f: M
        };
        var I = "matrix(".concat(o.a, ",").concat(o.b, ",").concat(o.c, ",").concat(o.d, ",").concat(o.e, ",").concat(o.f, ")");
        ar(Sr, "webkitTransform", I), ar(Sr, "mozTransform", I), ar(Sr, "msTransform", I), ar(Sr, "transform", I), u0 = T, c0 = M, Ja = f;
      }
      e.cancelable && e.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!Sr) {
      var e = this.options.fallbackOnBody ? document.body : $n, n = Ri(St, !0, jy, !0, e), a = this.options;
      if (jy) {
        for (go = e; ar(go, "position") === "static" && ar(go, "transform") === "none" && go !== document; )
          go = go.parentNode;
        go !== document.body && go !== document.documentElement ? (go === document && (go = Zs()), n.top += go.scrollTop, n.left += go.scrollLeft) : go = Zs(), h0 = hE(go);
      }
      Sr = St.cloneNode(!0), ha(Sr, a.ghostClass, !1), ha(Sr, a.fallbackClass, !0), ha(Sr, a.dragClass, !0), ar(Sr, "transition", ""), ar(Sr, "transform", ""), ar(Sr, "box-sizing", "border-box"), ar(Sr, "margin", 0), ar(Sr, "top", n.top), ar(Sr, "left", n.left), ar(Sr, "width", n.width), ar(Sr, "height", n.height), ar(Sr, "opacity", "0.8"), ar(Sr, "position", jy ? "absolute" : "fixed"), ar(Sr, "zIndex", "100000"), ar(Sr, "pointerEvents", "none"), sr.ghost = Sr, e.appendChild(Sr), ar(Sr, "transform-origin", fE / parseInt(Sr.style.width) * 100 + "% " + pE / parseInt(Sr.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(e, n) {
    var a = this, s = e.dataTransfer, f = a.options;
    if (Jo("dragStart", this, {
      evt: e
    }), sr.eventCanceled) {
      this._onDrop();
      return;
    }
    Jo("setupClone", this), sr.eventCanceled || (ri = mI(St), ri.removeAttribute("id"), ri.draggable = !1, ri.style["will-change"] = "", this._hideClone(), ha(ri, this.options.chosenClass, !1), sr.clone = ri), a.cloneId = fg(function() {
      Jo("clone", a), !sr.eventCanceled && (a.options.removeCloneOnHide || $n.insertBefore(ri, St), a._hideClone(), Lo({
        sortable: a,
        name: "clone"
      }));
    }), !n && ha(St, f.dragClass, !0), n ? (Kg = !0, a._loopId = setInterval(a._emulateDragOver, 50)) : (Kr(document, "mouseup", a._onDrop), Kr(document, "touchend", a._onDrop), Kr(document, "touchcancel", a._onDrop), s && (s.effectAllowed = "move", f.setData && f.setData.call(a, s, St)), nn(document, "drop", a), ar(St, "transform", "translateZ(0)")), uf = !0, a._dragStartId = fg(a._dragStarted.bind(a, n, e)), nn(document, "selectstart", a), od = !0, vd && ar(document.body, "user-select", "none");
  },
  _onDragOver: function(e) {
    var n = this.el, a = e.target, s, f, o, m = this.options, g = m.group, b = sr.active, T = Vy === g, M = m.sort, I = no || b, A, z = this, V = !1;
    if (s1)
      return;
    function Z(Pt, tr) {
      Jo(Pt, z, Js({
        evt: e,
        isOwner: T,
        axis: A ? "vertical" : "horizontal",
        revert: o,
        dragRect: s,
        targetRect: f,
        canSort: M,
        fromSortable: I,
        target: a,
        completed: Y,
        onMove: function(Dr, hr) {
          return Gy($n, n, St, s, Dr, Ri(Dr), e, hr);
        },
        changed: de
      }, tr));
    }
    function X() {
      Z("dragOverAnimationCapture"), z.captureAnimationState(), z !== I && I.captureAnimationState();
    }
    function Y(Pt) {
      return Z("dragOverCompleted", {
        insertion: Pt
      }), Pt && (T ? b._hideClone() : b._showClone(z), z !== I && (ha(St, no ? no.options.ghostClass : b.options.ghostClass, !1), ha(St, m.ghostClass, !0)), no !== z && z !== sr.active ? no = z : z === sr.active && no && (no = null), I === z && (z._ignoreWhileAnimating = a), z.animateAll(function() {
        Z("dragOverAnimationComplete"), z._ignoreWhileAnimating = null;
      }), z !== I && (I.animateAll(), I._ignoreWhileAnimating = null)), (a === St && !St.animated || a === n && !a.animated) && (of = null), !m.dragoverBubble && !e.rootEl && a !== document && (St.parentNode[ma]._isOutsideThisEl(e.target), !Pt && Ic(e)), !m.dragoverBubble && e.stopPropagation && e.stopPropagation(), V = !0;
    }
    function de() {
      fa = Aa(St), _u = Aa(St, m.draggable), Lo({
        sortable: z,
        name: "change",
        toEl: n,
        newIndex: fa,
        newDraggableIndex: _u,
        originalEvent: e
      });
    }
    if (e.preventDefault !== void 0 && e.cancelable && e.preventDefault(), a = Fs(a, m.draggable, n, !0), Z("dragOver"), sr.eventCanceled)
      return V;
    if (St.contains(e.target) || a.animated && a.animatingX && a.animatingY || z._ignoreWhileAnimating === a)
      return Y(!1);
    if (Kg = !1, b && !m.disabled && (T ? M || (o = hi !== $n) : no === this || (this.lastPutMode = Vy.checkPull(this, b, St, e)) && g.checkPut(this, b, St, e))) {
      if (A = this._getDirection(e, a) === "vertical", s = Ri(St), Z("dragOverValid"), sr.eventCanceled)
        return V;
      if (o)
        return hi = $n, X(), this._hideClone(), Z("revert"), sr.eventCanceled || (kc ? $n.insertBefore(St, kc) : $n.appendChild(St)), Y(!0);
      var ye = nx(n, m.draggable);
      if (!ye || MU(e, A, this) && !ye.animated) {
        if (ye === St)
          return Y(!1);
        if (ye && n === e.target && (a = ye), a && (f = Ri(a)), Gy($n, n, St, s, a, f, e, !!a) !== !1)
          return X(), ye && ye.nextSibling ? n.insertBefore(St, ye.nextSibling) : n.appendChild(St), hi = n, de(), Y(!0);
      } else if (ye && TU(e, A, this)) {
        var Ie = Nf(n, 0, m, !0);
        if (Ie === St)
          return Y(!1);
        if (a = Ie, f = Ri(a), Gy($n, n, St, s, a, f, e, !1) !== !1)
          return X(), n.insertBefore(St, Ie), hi = n, de(), Y(!0);
      } else if (a.parentNode === n) {
        f = Ri(a);
        var Be = 0, De, Re = St.parentNode !== n, Ee = !xU(St.animated && St.toRect || s, a.animated && a.toRect || f, A), ze = A ? "top" : "left", rt = cE(a, "top", "top") || cE(St, "top", "top"), Ze = rt ? rt.scrollTop : void 0;
        of !== a && (De = f[ze], wd = !1, Uy = !Ee && m.invertSwap || Re), Be = IU(e, a, f, A, Ee ? 1 : m.swapThreshold, m.invertedSwapThreshold == null ? m.swapThreshold : m.invertedSwapThreshold, Uy, of === a);
        var yt;
        if (Be !== 0) {
          var xe = Aa(St);
          do
            xe -= Be, yt = hi.children[xe];
          while (yt && (ar(yt, "display") === "none" || yt === Sr));
        }
        if (Be === 0 || yt === a)
          return Y(!1);
        of = a, bd = Be;
        var Ke = a.nextElementSibling, ct = !1;
        ct = Be === 1;
        var vt = Gy($n, n, St, s, a, f, e, ct);
        if (vt !== !1)
          return (vt === 1 || vt === -1) && (ct = vt === 1), s1 = !0, setTimeout(SU, 30), X(), ct && !Ke ? n.appendChild(St) : a.parentNode.insertBefore(St, ct ? Ke : a), rt && dI(rt, 0, Ze - rt.scrollTop), hi = St.parentNode, De !== void 0 && !Uy && (hg = Math.abs(De - Ri(a)[ze])), de(), Y(!0);
      }
      if (n.contains(St))
        return Y(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    Kr(document, "mousemove", this._onTouchMove), Kr(document, "touchmove", this._onTouchMove), Kr(document, "pointermove", this._onTouchMove), Kr(document, "dragover", Ic), Kr(document, "mousemove", Ic), Kr(document, "touchmove", Ic);
  },
  _offUpEvents: function() {
    var e = this.el.ownerDocument;
    Kr(e, "mouseup", this._onDrop), Kr(e, "touchend", this._onDrop), Kr(e, "pointerup", this._onDrop), Kr(e, "touchcancel", this._onDrop), Kr(document, "selectstart", this);
  },
  _onDrop: function(e) {
    var n = this.el, a = this.options;
    if (fa = Aa(St), _u = Aa(St, a.draggable), Jo("drop", this, {
      evt: e
    }), hi = St && St.parentNode, fa = Aa(St), _u = Aa(St, a.draggable), sr.eventCanceled) {
      this._nulling();
      return;
    }
    uf = !1, Uy = !1, wd = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), l1(this.cloneId), l1(this._dragStartId), this.nativeDraggable && (Kr(document, "drop", this), Kr(n, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), vd && ar(document.body, "user-select", ""), ar(St, "transform", ""), e && (od && (e.cancelable && e.preventDefault(), !a.dropBubble && e.stopPropagation()), Sr && Sr.parentNode && Sr.parentNode.removeChild(Sr), ($n === hi || no && no.lastPutMode !== "clone") && ri && ri.parentNode && ri.parentNode.removeChild(ri), St && (this.nativeDraggable && Kr(St, "dragend", this), f0(St), St.style["will-change"] = "", od && !uf && ha(St, no ? no.options.ghostClass : this.options.ghostClass, !1), ha(St, this.options.chosenClass, !1), Lo({
      sortable: this,
      name: "unchoose",
      toEl: hi,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: e
    }), $n !== hi ? (fa >= 0 && (Lo({
      rootEl: hi,
      name: "add",
      toEl: hi,
      fromEl: $n,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "remove",
      toEl: hi,
      originalEvent: e
    }), Lo({
      rootEl: hi,
      name: "sort",
      toEl: hi,
      fromEl: $n,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "sort",
      toEl: hi,
      originalEvent: e
    })), no && no.save()) : fa !== gf && fa >= 0 && (Lo({
      sortable: this,
      name: "update",
      toEl: hi,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "sort",
      toEl: hi,
      originalEvent: e
    })), sr.active && ((fa == null || fa === -1) && (fa = gf, _u = xd), Lo({
      sortable: this,
      name: "end",
      toEl: hi,
      originalEvent: e
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    Jo("nulling", this), $n = St = hi = Sr = kc = ri = cg = Eu = Mc = Ja = od = fa = _u = gf = xd = of = bd = no = Vy = sr.dragged = sr.ghost = sr.clone = sr.active = null, Jg.forEach(function(e) {
      e.checked = !0;
    }), Jg.length = u0 = c0 = 0;
  },
  handleEvent: function(e) {
    switch (e.type) {
      case "drop":
      case "dragend":
        this._onDrop(e);
        break;
      case "dragenter":
      case "dragover":
        St && (this._onDragOver(e), EU(e));
        break;
      case "selectstart":
        e.preventDefault();
        break;
    }
  },
  toArray: function() {
    for (var e = [], n, a = this.el.children, s = 0, f = a.length, o = this.options; s < f; s++)
      n = a[s], Fs(n, o.draggable, this.el, !1) && e.push(n.getAttribute(o.dataIdAttr) || CU(n));
    return e;
  },
  sort: function(e, n) {
    var a = {}, s = this.el;
    this.toArray().forEach(function(f, o) {
      var m = s.children[o];
      Fs(m, this.options.draggable, s, !1) && (a[f] = m);
    }, this), n && this.captureAnimationState(), e.forEach(function(f) {
      a[f] && (s.removeChild(a[f]), s.appendChild(a[f]));
    }), n && this.animateAll();
  },
  save: function() {
    var e = this.options.store;
    e && e.set && e.set(this);
  },
  closest: function(e, n) {
    return Fs(e, n || this.options.draggable, this.el, !1);
  },
  option: function(e, n) {
    var a = this.options;
    if (n === void 0)
      return a[e];
    var s = rm.modifyOption(this, e, n);
    typeof s < "u" ? a[e] = s : a[e] = n, e === "group" && vI(a);
  },
  destroy: function() {
    Jo("destroy", this);
    var e = this.el;
    e[ma] = null, Kr(e, "mousedown", this._onTapStart), Kr(e, "touchstart", this._onTapStart), Kr(e, "pointerdown", this._onTapStart), this.nativeDraggable && (Kr(e, "dragover", this), Kr(e, "dragenter", this)), Array.prototype.forEach.call(e.querySelectorAll("[draggable]"), function(n) {
      n.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), Yg.splice(Yg.indexOf(this.el), 1), this.el = e = null;
  },
  _hideClone: function() {
    if (!Eu) {
      if (Jo("hideClone", this), sr.eventCanceled)
        return;
      ar(ri, "display", "none"), this.options.removeCloneOnHide && ri.parentNode && ri.parentNode.removeChild(ri), Eu = !0;
    }
  },
  _showClone: function(e) {
    if (e.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (Eu) {
      if (Jo("showClone", this), sr.eventCanceled)
        return;
      St.parentNode == $n && !this.options.group.revertClone ? $n.insertBefore(ri, St) : kc ? $n.insertBefore(ri, kc) : $n.appendChild(ri), this.options.group.revertClone && this.animate(St, ri), ar(ri, "display", ""), Eu = !1;
    }
  }
};
function EU(t) {
  t.dataTransfer && (t.dataTransfer.dropEffect = "move"), t.cancelable && t.preventDefault();
}
function Gy(t, e, n, a, s, f, o, m) {
  var g, b = t[ma], T = b.options.onMove, M;
  return window.CustomEvent && !ql && !tm ? g = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (g = document.createEvent("Event"), g.initEvent("move", !0, !0)), g.to = e, g.from = t, g.dragged = n, g.draggedRect = a, g.related = s || e, g.relatedRect = f || Ri(e), g.willInsertAfter = m, g.originalEvent = o, t.dispatchEvent(g), T && (M = T.call(b, g, o)), M;
}
function f0(t) {
  t.draggable = !1;
}
function SU() {
  s1 = !1;
}
function TU(t, e, n) {
  var a = Ri(Nf(n.el, 0, n.options, !0)), s = 10;
  return e ? t.clientX < a.left - s || t.clientY < a.top && t.clientX < a.right : t.clientY < a.top - s || t.clientY < a.bottom && t.clientX < a.left;
}
function MU(t, e, n) {
  var a = Ri(nx(n.el, n.options.draggable)), s = 10;
  return e ? t.clientX > a.right + s || t.clientX <= a.right && t.clientY > a.bottom && t.clientX >= a.left : t.clientX > a.right && t.clientY > a.top || t.clientX <= a.right && t.clientY > a.bottom + s;
}
function IU(t, e, n, a, s, f, o, m) {
  var g = a ? t.clientY : t.clientX, b = a ? n.height : n.width, T = a ? n.top : n.left, M = a ? n.bottom : n.right, I = !1;
  if (!o) {
    if (m && hg < b * s) {
      if (!wd && (bd === 1 ? g > T + b * f / 2 : g < M - b * f / 2) && (wd = !0), wd)
        I = !0;
      else if (bd === 1 ? g < T + hg : g > M - hg)
        return -bd;
    } else if (g > T + b * (1 - s) / 2 && g < M - b * (1 - s) / 2)
      return OU(e);
  }
  return I = I || o, I && (g < T + b * f / 2 || g > M - b * f / 2) ? g > T + b / 2 ? 1 : -1 : 0;
}
function OU(t) {
  return Aa(St) < Aa(t) ? 1 : -1;
}
function CU(t) {
  for (var e = t.tagName + t.className + t.src + t.href + t.textContent, n = e.length, a = 0; n--; )
    a += e.charCodeAt(n);
  return a.toString(36);
}
function AU(t) {
  Jg.length = 0;
  for (var e = t.getElementsByTagName("input"), n = e.length; n--; ) {
    var a = e[n];
    a.checked && Jg.push(a);
  }
}
function fg(t) {
  return setTimeout(t, 0);
}
function l1(t) {
  return clearTimeout(t);
}
kv && nn(document, "touchmove", function(t) {
  (sr.active || uf) && t.cancelable && t.preventDefault();
});
sr.utils = {
  on: nn,
  off: Kr,
  css: ar,
  find: fI,
  is: function(e, n) {
    return !!Fs(e, n, e, !1);
  },
  extend: fU,
  throttle: pI,
  closest: Fs,
  toggleClass: ha,
  clone: mI,
  index: Aa,
  nextTick: fg,
  cancelNextTick: l1,
  detectDirection: gI,
  getChild: Nf
};
sr.get = function(t) {
  return t[ma];
};
sr.mount = function() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  e[0].constructor === Array && (e = e[0]), e.forEach(function(a) {
    if (!a.prototype || !a.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(a));
    a.utils && (sr.utils = Js(Js({}, sr.utils), a.utils)), rm.mount(a);
  });
};
sr.create = function(t, e) {
  return new sr(t, e);
};
sr.version = uU;
var Ii = [], ad, u1, c1 = !1, p0, d0, Qg, sd;
function PU() {
  function t() {
    this.defaults = {
      scroll: !0,
      forceAutoScrollFallback: !1,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var e in this)
      e.charAt(0) === "_" && typeof this[e] == "function" && (this[e] = this[e].bind(this));
  }
  return t.prototype = {
    dragStarted: function(n) {
      var a = n.originalEvent;
      this.sortable.nativeDraggable ? nn(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? nn(document, "pointermove", this._handleFallbackAutoScroll) : a.touches ? nn(document, "touchmove", this._handleFallbackAutoScroll) : nn(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(n) {
      var a = n.originalEvent;
      !this.options.dragOverBubble && !a.rootEl && this._handleAutoScroll(a);
    },
    drop: function() {
      this.sortable.nativeDraggable ? Kr(document, "dragover", this._handleAutoScroll) : (Kr(document, "pointermove", this._handleFallbackAutoScroll), Kr(document, "touchmove", this._handleFallbackAutoScroll), Kr(document, "mousemove", this._handleFallbackAutoScroll)), mE(), pg(), pU();
    },
    nulling: function() {
      Qg = u1 = ad = c1 = sd = p0 = d0 = null, Ii.length = 0;
    },
    _handleFallbackAutoScroll: function(n) {
      this._handleAutoScroll(n, !0);
    },
    _handleAutoScroll: function(n, a) {
      var s = this, f = (n.touches ? n.touches[0] : n).clientX, o = (n.touches ? n.touches[0] : n).clientY, m = document.elementFromPoint(f, o);
      if (Qg = n, a || this.options.forceAutoScrollFallback || tm || ql || vd) {
        m0(n, this.options, m, a);
        var g = Su(m, !0);
        c1 && (!sd || f !== p0 || o !== d0) && (sd && mE(), sd = setInterval(function() {
          var b = Su(document.elementFromPoint(f, o), !0);
          b !== g && (g = b, pg()), m0(n, s.options, b, a);
        }, 10), p0 = f, d0 = o);
      } else {
        if (!this.options.bubbleScroll || Su(m, !0) === Zs()) {
          pg();
          return;
        }
        m0(n, this.options, Su(m, !1), !1);
      }
    }
  }, Ul(t, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function pg() {
  Ii.forEach(function(t) {
    clearInterval(t.pid);
  }), Ii = [];
}
function mE() {
  clearInterval(sd);
}
var m0 = pI(function(t, e, n, a) {
  if (!!e.scroll) {
    var s = (t.touches ? t.touches[0] : t).clientX, f = (t.touches ? t.touches[0] : t).clientY, o = e.scrollSensitivity, m = e.scrollSpeed, g = Zs(), b = !1, T;
    u1 !== n && (u1 = n, pg(), ad = e.scroll, T = e.scrollFn, ad === !0 && (ad = Su(n, !0)));
    var M = 0, I = ad;
    do {
      var A = I, z = Ri(A), V = z.top, Z = z.bottom, X = z.left, Y = z.right, de = z.width, ye = z.height, Ie = void 0, Be = void 0, De = A.scrollWidth, Re = A.scrollHeight, Ee = ar(A), ze = A.scrollLeft, rt = A.scrollTop;
      A === g ? (Ie = de < De && (Ee.overflowX === "auto" || Ee.overflowX === "scroll" || Ee.overflowX === "visible"), Be = ye < Re && (Ee.overflowY === "auto" || Ee.overflowY === "scroll" || Ee.overflowY === "visible")) : (Ie = de < De && (Ee.overflowX === "auto" || Ee.overflowX === "scroll"), Be = ye < Re && (Ee.overflowY === "auto" || Ee.overflowY === "scroll"));
      var Ze = Ie && (Math.abs(Y - s) <= o && ze + de < De) - (Math.abs(X - s) <= o && !!ze), yt = Be && (Math.abs(Z - f) <= o && rt + ye < Re) - (Math.abs(V - f) <= o && !!rt);
      if (!Ii[M])
        for (var xe = 0; xe <= M; xe++)
          Ii[xe] || (Ii[xe] = {});
      (Ii[M].vx != Ze || Ii[M].vy != yt || Ii[M].el !== A) && (Ii[M].el = A, Ii[M].vx = Ze, Ii[M].vy = yt, clearInterval(Ii[M].pid), (Ze != 0 || yt != 0) && (b = !0, Ii[M].pid = setInterval(function() {
        a && this.layer === 0 && sr.active._onTouchMove(Qg);
        var Ke = Ii[this.layer].vy ? Ii[this.layer].vy * m : 0, ct = Ii[this.layer].vx ? Ii[this.layer].vx * m : 0;
        typeof T == "function" && T.call(sr.dragged.parentNode[ma], ct, Ke, t, Qg, Ii[this.layer].el) !== "continue" || dI(Ii[this.layer].el, ct, Ke);
      }.bind({
        layer: M
      }), 24))), M++;
    } while (e.bubbleScroll && I !== g && (I = Su(I, !1)));
    c1 = b;
  }
}, 30), bI = function(e) {
  var n = e.originalEvent, a = e.putSortable, s = e.dragEl, f = e.activeSortable, o = e.dispatchSortableEvent, m = e.hideGhostForTarget, g = e.unhideGhostForTarget;
  if (!!n) {
    var b = a || f;
    m();
    var T = n.changedTouches && n.changedTouches.length ? n.changedTouches[0] : n, M = document.elementFromPoint(T.clientX, T.clientY);
    g(), b && !b.el.contains(M) && (o("spill"), this.onSpill({
      dragEl: s,
      putSortable: a
    }));
  }
};
function ix() {
}
ix.prototype = {
  startIndex: null,
  dragStart: function(e) {
    var n = e.oldDraggableIndex;
    this.startIndex = n;
  },
  onSpill: function(e) {
    var n = e.dragEl, a = e.putSortable;
    this.sortable.captureAnimationState(), a && a.captureAnimationState();
    var s = Nf(this.sortable.el, this.startIndex, this.options);
    s ? this.sortable.el.insertBefore(n, s) : this.sortable.el.appendChild(n), this.sortable.animateAll(), a && a.animateAll();
  },
  drop: bI
};
Ul(ix, {
  pluginName: "revertOnSpill"
});
function ox() {
}
ox.prototype = {
  onSpill: function(e) {
    var n = e.dragEl, a = e.putSortable, s = a || this.sortable;
    s.captureAnimationState(), n.parentNode && n.parentNode.removeChild(n), s.animateAll();
  },
  drop: bI
};
Ul(ox, {
  pluginName: "removeOnSpill"
});
sr.mount(new PU());
sr.mount(ox, ix);
const wI = 0.5, kU = !1, ev = Qc(
  "slider",
  () => {
    const t = Ai(), e = Hr(wI), n = Hr(kU), a = Ur(
      () => [...t.layers].reverse()[0]
    );
    function s(o) {
      let m = o;
      o < 0.1 ? m = 0.1 : o > 0.9 && (m = 0.9), e.value = m;
    }
    function f(o) {
      n.value = o != null ? o : !n.value;
    }
    return {
      sliderActive: n,
      sliderRatio: e,
      sliderTopLayer: a,
      setRatio: s,
      toggleSlider: f
    };
  },
  {}
);
function ax(t, e) {
  const { t: n } = An();
  function a() {
    return n(t.name, { ns: "client" });
  }
  function s() {
    e == null || e.emit("clickInfo", t);
  }
  return {
    t: n,
    getLabel: a,
    onClickInfo: s
  };
}
const LU = { class: "lux-layer-manager-item mt-2.5" }, DU = ["title"], NU = { class: "flex-1 text-left cursor-default" }, RU = ["aria-label", "title"], zU = /* @__PURE__ */ ur({
  __name: "layer-item-background",
  props: {
    showEditButton: { type: Boolean, required: !0 },
    layer: { type: null, required: !0 }
  },
  emits: ["clickEdit", "clickInfo"],
  setup(t, { emit: e }) {
    const n = t, { t: a, onClickInfo: s } = ax(n.layer, { emit: e }), f = Ur(
      () => a('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: o()
      })
    );
    function o() {
      return a(n.layer.name, { ns: "client" });
    }
    return (m, g) => (Ue(), st("div", LU, [
      Ne("button", {
        class: "fa fa-info w-3",
        title: le(f),
        onClick: g[0] || (g[0] = (...b) => le(s) && le(s)(...b))
      }, null, 8, DU),
      Ne("span", NU, Vt(o()), 1),
      t.showEditButton ? (Ue(), st("button", {
        key: 0,
        class: "fa fa-pencil",
        "aria-label": le(a)("Open editor panel", { ns: "client" }),
        title: le(a)("Open editor panel", { ns: "client" }),
        onClick: g[1] || (g[1] = (b) => m.$emit("clickEdit"))
      }, null, 8, RU)) : it("v-if", !0)
    ]));
  }
}), FU = /* @__PURE__ */ mr(zU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item-background.vue"]]), BU = ["id"], VU = ["aria-checked", "title"], UU = ["id", "value", "aria-label"], jU = ["aria-checked", "aria-label"], GU = /* @__PURE__ */ ur({
  __name: "layer-item-sub",
  props: {
    layer: { type: null, required: !0 },
    isOpen: { type: Boolean, required: !0 },
    isLayerComparatorOpen: { type: Boolean, required: !0 },
    displayLayerComparatorOpen: { type: Boolean, required: !0 }
  },
  emits: ["changeOpacity", "clickToggleLayerComparator"],
  setup(t, { emit: e }) {
    var M, I, A, z;
    const n = t, { t: a, getLabel: s } = ax(n.layer, { emit: e }), f = Fn(
      ((I = (M = n.layer) == null ? void 0 : M.opacity) != null ? I : 1) * 100
    ), o = Fn(
      ((z = (A = n.layer) == null ? void 0 : A.previousOpacity) != null ? z : f.value) * 100
    );
    function m() {
      f.value === 0 ? f.value = o.value : (o.value = f.value, f.value = 0), T();
    }
    function g(V) {
      V.target && (f.value = parseInt(V.target.value), T());
    }
    function b() {
      e("clickToggleLayerComparator", n.layer);
    }
    function T() {
      e("changeOpacity", n.layer, f.value);
    }
    return (V, Z) => (Ue(), st("div", {
      class: Lr(["lux-layer-manager-item-content", t.isOpen ? "h-6" : "h-0"]),
      id: `layer-manager-item-content-${t.layer.id}`
    }, [
      Ne("button", {
        class: Lr(["w-5 fa-solid", le(f) === 0 ? "fa-eye-slash" : "fa-eye"]),
        role: "switch",
        "aria-checked": le(f) === 0,
        title: le(a)("Toggle layer opacity for {{layerName}}", {
          layerName: le(a)(t.layer.name)
        }),
        onClick: m
      }, null, 10, VU),
      Ne("input", {
        id: `${t.layer.id}-steps-range`,
        type: "range",
        min: "0",
        max: "100",
        value: le(f),
        step: "25",
        onChange: g,
        class: "m-2.5 w-16 h-[5px] rounded-lg appearance-none cursor-pointer",
        "aria-label": le(a)("Change opacity for {{ layerName }}", { layerName: le(s)() })
      }, null, 40, UU),
      t.displayLayerComparatorOpen ? (Ue(), st("button", {
        key: 0,
        role: "switch",
        class: Lr(["fa ml-auto text-sm cursor-pointer", t.isLayerComparatorOpen ? "fa-adjust" : "fa-circle"]),
        "aria-checked": t.isLayerComparatorOpen,
        "aria-label": le(a)("Toggle layer comparator for {{ layerName }}", {
          layerName: le(s)()
        }),
        onClick: b
      }, null, 10, jU)) : it("v-if", !0)
    ], 10, BU));
  }
}), qU = /* @__PURE__ */ mr(GU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item-sub.vue"]]), $U = ["min", "max", "value"], WU = /* @__PURE__ */ ur({
  __name: "layer-time-datepicker",
  props: {
    minDateAllowed: { type: String, required: !1, default: "" },
    maxDateAllowed: { type: String, required: !1, default: "" },
    dateValue: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, a = Ur(() => Y_(n.minDateAllowed)), s = Ur(() => Y_(n.maxDateAllowed));
    function f(o) {
      e("change", o.target.value);
    }
    return (o, m) => (Ue(), st("input", {
      class: "lux-time-datepicker",
      type: "date",
      min: le(a),
      max: le(s),
      value: t.dateValue ? le(Y_)(t.dateValue) : "",
      onChange: f
    }, null, 40, $U));
  }
}), h1 = /* @__PURE__ */ mr(WU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker.vue"]]), HU = { class: "lux-time-slider w-full" }, ZU = ["for"], XU = /* @__PURE__ */ ur({
  __name: "layer-time-datepicker-value",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t) {
    const e = t, { t: n } = An(), a = Fn(
      e.layer.currentTimeMinValue
    );
    return (s, f) => {
      var o, m;
      return Ue(), st("div", HU, [
        Ne("div", null, [
          Ne("label", {
            for: `${t.layer.id}-time-slider-start`,
            class: "lux-time-slider-label"
          }, Vt(le(n)("Date:")), 9, ZU),
          Gt(h1, {
            id: `${t.layer.id}-time-slider-start`,
            "date-value": le(a),
            "min-date-allowed": (o = e.layer.time) == null ? void 0 : o.minValue,
            "max-date-allowed": (m = e.layer.time) == null ? void 0 : m.maxValue,
            onChange: f[0] || (f[0] = (g) => s.$emit("changeTime", g))
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ])
      ]);
    };
  }
}), KU = /* @__PURE__ */ mr(XU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker-value.vue"]]), YU = { class: "lux-time-slider w-full" }, JU = ["for"], QU = ["for"], ej = /* @__PURE__ */ ur({
  __name: "layer-time-datepicker-range",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    const n = t, { t: a } = An(), s = Fn(
      n.layer.currentTimeMinValue
    ), f = Fn(
      n.layer.currentTimeMaxValue
    );
    function o(g) {
      e("changeTime", g, n.layer.currentTimeMaxValue);
    }
    function m(g) {
      e("changeTime", n.layer.currentTimeMinValue, g);
    }
    return (g, b) => {
      var T, M, I, A;
      return Ue(), st("div", YU, [
        it(" Date START datepicker input "),
        Ne("div", null, [
          Ne("label", {
            for: `${t.layer.id}-time-slider-start`,
            class: "lux-time-slider-label"
          }, Vt(le(a)("From:")), 9, JU),
          Gt(h1, {
            id: `${t.layer.id}-time-slider-start`,
            "date-value": le(s),
            "min-date-allowed": (T = n.layer.time) == null ? void 0 : T.minValue,
            "max-date-allowed": (M = n.layer.time) == null ? void 0 : M.maxValue,
            onChange: o
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ]),
        it(" Date END datepicker input "),
        Ne("div", null, [
          Ne("label", {
            for: `${t.layer.id}-time-slider-end`,
            class: "lux-time-slider-label"
          }, Vt(le(a)("To:")), 9, QU),
          Gt(h1, {
            id: `${t.layer.id}-time-slider-end`,
            "date-value": le(f),
            "min-date-allowed": (I = n.layer.time) == null ? void 0 : I.minValue,
            "max-date-allowed": (A = n.layer.time) == null ? void 0 : A.maxValue,
            onChange: m
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ])
      ]);
    };
  }
}), tj = /* @__PURE__ */ mr(ej, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker-range.vue"]]), rj = { class: "lux-time-slider w-full" }, nj = ["max", "value"], ij = { class: "lux-time-slider-displayed-dates" }, oj = {
  key: 0,
  class: "lux-time-slider-start-date"
}, aj = {
  key: 1,
  class: "lux-time-slider-end-date"
}, sj = /* @__PURE__ */ ur({
  __name: "layer-time-slider",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    const n = t, a = Ur(
      () => {
        var g, b;
        return (b = (g = n.layer.time) == null ? void 0 : g.values) == null ? void 0 : b.findIndex(
          (T) => T === n.layer.currentTimeMinValue
        );
      }
    ), s = Ur(o), f = Ur(() => {
      var g;
      return (g = s.value) == null ? void 0 : g.length;
    });
    function o() {
      var V, Z;
      const g = n.layer.time, b = [];
      if (!g)
        return b;
      if (g.values)
        return g.values;
      const T = new Date(g.minValue), M = new Date((V = g.maxValue) != null ? V : Date.now()), I = 1024, A = new Date(T.getTime()), z = (Z = g.interval) != null ? Z : [0, 1, 0, 0];
      if (A.setFullYear(
        T.getFullYear() + I * z[0]
      ), A.setMonth(
        T.getMonth() + I * z[1],
        T.getDate() + I * z[2]
      ), A.setSeconds(T.getSeconds() + I * z[3]), A > M)
        for (let X = 0; ; X++) {
          const Y = new Date(T.getTime());
          if (Y.setFullYear(T.getFullYear() + X * z[0]), Y.setMonth(
            T.getMonth() + X * z[1],
            T.getDate() + X * z[2]
          ), Y.setSeconds(T.getSeconds() + X * z[3]), Y <= M)
            b.push(Y.getTime());
          else
            break;
        }
      return b;
    }
    function m(g) {
      const b = parseInt(g.target.value), T = s.value[b];
      e("changeTime", new Date(T).toISOString());
    }
    return (g, b) => {
      var T, M, I, A, z;
      return Ue(), st("div", rj, [
        it(" Slider "),
        Ne("div", null, [
          Ne("input", {
            class: "lux-time-slidebar",
            min: "0",
            type: "range",
            max: le(f) - 1,
            value: le(a),
            onChange: m
          }, null, 40, nj)
        ]),
        it(" Display localized time values "),
        Ne("div", ij, [
          ((T = t.layer.time) == null ? void 0 : T.mode) === le(If).RANGE || ((M = t.layer.time) == null ? void 0 : M.mode) === le(If).VALUE ? (Ue(), st("div", oj, [
            Ne("span", null, Vt(t.layer.currentTimeMinValue ? le(k2)(t.layer.currentTimeMinValue, (I = t.layer.time) == null ? void 0 : I.resolution) : "-"), 1)
          ])) : it("v-if", !0),
          ((A = t.layer.time) == null ? void 0 : A.mode) === le(If).RANGE ? (Ue(), st("div", aj, [
            Ne("span", null, Vt(t.layer.currentTimeMaxValue ? le(k2)(t.layer.currentTimeMaxValue, (z = t.layer.time) == null ? void 0 : z.resolution) : "-"), 1)
          ])) : it("v-if", !0)
        ])
      ]);
    };
  }
}), lj = /* @__PURE__ */ mr(sj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-slider.vue"]]), uj = /* @__PURE__ */ ur({
  __name: "layer-time",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    function n(a, s) {
      e("changeTime", a, s);
    }
    return (a, s) => {
      var f, o, m, g, b;
      return Ue(), st(un, null, [
        it(" Layer time: slider widget "),
        ((f = t.layer.time) == null ? void 0 : f.widget) === le(lg).SLIDER ? (Ue(), cn(lj, {
          key: 0,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : it("v-if", !0),
        it(" Layer time: datepicker VALUE (one date) widget "),
        ((o = t.layer.time) == null ? void 0 : o.widget) === le(lg).DATEPICKER && ((m = t.layer.time) == null ? void 0 : m.mode) === le(If).VALUE ? (Ue(), cn(KU, {
          key: 1,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : it("v-if", !0),
        it(' Layer time: datepicker RANGE ("from:" date - "to:" date) widget '),
        ((g = t.layer.time) == null ? void 0 : g.widget) === le(lg).DATEPICKER && ((b = t.layer.time) == null ? void 0 : b.mode) === le(If).RANGE ? (Ue(), cn(tj, {
          key: 2,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : it("v-if", !0)
      ], 64);
    };
  }
}), cj = /* @__PURE__ */ mr(uj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time.vue"]]), hj = { class: "lux-layer-manager-item relative" }, fj = { class: "w-full flex flex-nowrap items-start gap-x-2" }, pj = ["title"], dj = ["aria-label", "title"], mj = ["aria-expanded", "aria-controls", "data-cy"], yj = { class: "grow" }, gj = ["title", "aria-label"], vj = /* @__PURE__ */ ur({
  __name: "layer-item",
  props: {
    is3d: { type: Boolean, required: !0 },
    layer: { type: null, required: !0 },
    draggableClassName: { type: String, required: !0 },
    isOpen: { type: Boolean, required: !0 },
    isLayerComparatorOpen: { type: Boolean, required: !0 },
    displayLayerComparatorOpen: { type: Boolean, required: !0 }
  },
  emits: ["clickInfo", "clickToggle", "clickToggleLayerComparator", "clickRemove", "changeOpacity", "changeTime"],
  setup(t, { emit: e }) {
    const n = t, { t: a, getLabel: s, onClickInfo: f } = ax(n.layer, { emit: e }), o = Ur(
      () => a('Sort "{{layerName}}" in the list', {
        ns: "client",
        layerName: s()
      })
    ), m = Ur(
      () => a('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: s()
      })
    ), g = Ur(
      () => a('Remove layer "{{layerName}}"', {
        ns: "client",
        layerName: s()
      })
    );
    function b(T, M) {
      e("changeTime", T, M);
    }
    return (T, M) => (Ue(), st("div", hj, [
      Ne("div", fj, [
        Ne("button", {
          class: Lr(["fa-solid fa-bars cursor-move mt-1", t.draggableClassName]),
          title: le(o)
        }, null, 10, pj),
        Ne("button", {
          class: "fa-solid fa-info mt-1",
          "aria-label": le(m),
          title: le(m),
          onClick: M[0] || (M[0] = (...I) => le(f) && le(f)(...I))
        }, null, 8, dj),
        Ne("button", {
          "aria-expanded": t.isOpen,
          "aria-controls": `layer-manager-item-content-${t.layer.id}`,
          "data-cy": `myLayerItemLabel-${t.layer.id}`,
          class: Lr([t.is3d ? "cursor-default" : "", "grow text-left break-words w-[70%] flex items-center"]),
          onClick: M[1] || (M[1] = (I) => T.$emit("clickToggle", t.layer))
        }, [
          Ne("span", yj, Vt(le(s)()), 1),
          t.is3d ? it("v-if", !0) : (Ue(), st("span", {
            key: 0,
            class: Lr(["w-3.5 fa-solid", t.isOpen ? "fa-xmark" : "fa-ellipsis"]),
            "aria-hidden": "true"
          }, null, 2))
        ], 10, mj),
        Ne("button", {
          class: "mt-1 fa-solid fa-trash",
          title: le(g),
          "aria-label": le(g),
          onClick: M[2] || (M[2] = (I) => T.$emit("clickRemove", t.layer))
        }, null, 8, gj)
      ]),
      it(" Layer item sub content (opacity and toggle comparator) "),
      t.is3d ? it("v-if", !0) : (Ue(), cn(qU, {
        key: 0,
        layer: t.layer,
        isOpen: t.isOpen,
        isLayerComparatorOpen: t.isLayerComparatorOpen,
        displayLayerComparatorOpen: t.displayLayerComparatorOpen,
        onClickToggleLayerComparator: M[3] || (M[3] = (I) => T.$emit("clickToggleLayerComparator", I)),
        onChangeOpacity: M[4] || (M[4] = (I, A) => T.$emit("changeOpacity", I, A))
      }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen"])),
      it(" Layer time: slider OR datepicker widgets "),
      t.layer.time ? (Ue(), cn(cj, {
        key: 1,
        layer: t.layer,
        onChangeTime: b
      }, null, 8, ["layer"])) : it("v-if", !0)
    ]));
  }
}), yE = /* @__PURE__ */ mr(vj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item.vue"]]), _j = {
  key: 0,
  class: "mb-4"
}, xj = ["id"], bj = { id: "sortable-layers" }, wj = ["id"], Ej = { class: "flex flex-row justify-center space-x-1 my-2" }, Sj = /* @__PURE__ */ ur({
  __name: "layer-manager",
  emits: ["displayCatalog"],
  setup(t, { emit: e }) {
    const { t: n } = An(), { setMetadataId: a } = K1(), s = Ai(), f = Pi(), o = Ff(), m = ev(), { bgLayer: g } = xn(s), { sliderActive: b } = xn(m), T = Ur(() => [...s.layers].reverse()), M = Ur(() => [...s.layers_3d].reverse()), I = Fn(), A = "drag-handle", z = Ur(
      () => o.isLayerStyleEditable(g.value)
    ), { setRemoteLayersOpen: V } = Pi();
    va(() => {
      const De = document.getElementById("sortable-layers");
      De && sr.create(De, {
        dataIdAttr: "data-id",
        dragClass: "lux-sortable-drag",
        ghostClass: "lux-sortable-ghost",
        sort: !0,
        handle: `.${A}`,
        onSort: Z
      });
    });
    function Z(De) {
      const Re = De.to.children;
      s.reorderLayers([...Re].map((Ee) => Number(Ee.id)).reverse());
    }
    function X(De, Re) {
      s.setLayerOpacity(De.id, Re / 100);
    }
    function Y(De, Re, Ee) {
      s.setLayerTime(De.id, Re, Ee);
    }
    function de(De) {
      s.removeLayers(De.id);
    }
    function ye(De) {
      I.value = I.value !== De.id ? De.id : void 0;
    }
    function Ie() {
      f.openStyleEditorPanel();
    }
    function Be() {
      m.toggleSlider();
    }
    return (De, Re) => (Ue(), st("div", null, [
      le(M).length > 0 ? (Ue(), st("ul", _j, [
        (Ue(!0), st(un, null, Ra(le(M), (Ee, ze) => (Ue(), st("li", {
          key: Ee.id,
          id: Ee.id
        }, [
          Gt(yE, {
            is3d: !0,
            draggableClassName: A,
            layer: Ee,
            isOpen: le(I) === Ee.id,
            isLayerComparatorOpen: le(b),
            displayLayerComparatorOpen: ze === 0,
            onClickRemove: de,
            onClickToggle: ye,
            onClickToggleLayerComparator: Be,
            onClickInfo: (rt) => le(a)(Ee.id),
            onChangeOpacity: X,
            onChangeTime: (rt, Ze) => Y(Ee, rt, Ze)
          }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen", "onClickInfo", "onChangeTime"])
        ], 8, xj))), 128))
      ])) : it("v-if", !0),
      Ne("ul", bj, [
        (Ue(!0), st(un, null, Ra(le(T), (Ee, ze) => (Ue(), st("li", {
          key: Ee.id,
          id: Ee.id
        }, [
          Gt(yE, {
            is3d: !1,
            draggableClassName: A,
            layer: Ee,
            isOpen: le(I) === Ee.id,
            isLayerComparatorOpen: le(b),
            displayLayerComparatorOpen: ze === 0,
            onClickRemove: de,
            onClickToggle: ye,
            onClickToggleLayerComparator: Be,
            onClickInfo: (rt) => le(a)(Ee.id),
            onChangeOpacity: X,
            onChangeTime: (rt, Ze) => Y(Ee, rt, Ze)
          }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen", "onClickInfo", "onChangeTime"])
        ], 8, wj))), 128))
      ]),
      Gt(FU, {
        layer: le(g) || le(Wg),
        showEditButton: le(z),
        onClickInfo: Re[0] || (Re[0] = () => le(g) && le(a)(le(g).id)),
        onClickEdit: Ie
      }, null, 8, ["layer", "showEditButton"]),
      Ne("div", Ej, [
        Ne("button", {
          class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
          onClick: Re[1] || (Re[1] = (Ee) => e("displayCatalog"))
        }, Vt(le(n)("+ Add layers", { ns: "client" })), 1),
        Ne("button", {
          class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
          onClick: Re[2] || (Re[2] = (Ee) => le(V)(!0))
        }, Vt(le(n)("+ Add external Wms", { ns: "client" })), 1)
      ])
    ]));
  }
}), Tj = /* @__PURE__ */ mr(Sj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-manager.vue"]]), Mj = { class: "flex flex-col h-full pt-1.5" }, Ij = { class: "h-16 shrink-0 flex justify-between lux-panel-title" }, Oj = ["aria-label"], Cj = { class: "flex flex-row gap-2 h-10 text-2xl" }, Aj = ["aria-expanded"], Pj = { key: 0 }, kj = ["aria-expanded"], Lj = { class: "relative grow p-2.5 bg-primary overflow-auto" }, Dj = /* @__PURE__ */ ur({
  __name: "layer-panel",
  setup(t) {
    const { t: e } = An(), n = Pi(), { setLayersOpen: a } = n, { myLayersTabOpen: s } = xn(n), { layers: f } = xn(Ai());
    function o() {
      n.setMyLayersTabOpen(!0);
    }
    function m() {
      n.setMyLayersTabOpen(!1);
    }
    return (g, b) => (Ue(), st("div", Mj, [
      it(" Panel title and close button "),
      Ne("div", Ij, [
        Ne("h1", null, Vt(le(e)("layers", { ns: "client" })), 1),
        Ne("span", null, [
          Ne("button", {
            onClick: b[0] || (b[0] = () => le(a)(!1)),
            "aria-label": le(e)("Close", { ns: "client" }),
            class: "fa-sharp fa-solid fa-close"
          }, null, 8, Oj)
        ])
      ]),
      it(" My Layers and Catalog tab labels "),
      Ne("div", Cj, [
        Ne("button", {
          onClick: o,
          class: Lr(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", le(s) ? "bg-primary" : "bg-tertiary"]),
          "aria-expanded": le(s)
        }, [
          Tg(Vt(le(e)("my_layers", { ns: "client" })) + " ", 1),
          le(f).length ? (Ue(), st("span", Pj, "(" + Vt(le(f).length) + ")", 1)) : it("v-if", !0)
        ], 10, Aj),
        Ne("button", {
          onClick: m,
          class: Lr(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", le(s) ? "bg-tertiary" : "bg-primary"]),
          "aria-expanded": !le(s)
        }, Vt(le(e)("Catalog", { ns: "client" })), 11, kj)
      ]),
      it(" Panel content (MyLayers and Catalog) "),
      Ne("div", Lj, [
        le(s) ? (Ue(), cn(Tj, {
          key: 0,
          onDisplayCatalog: m
        })) : it("v-if", !0),
        le(s) ? it("v-if", !0) : (Ue(), cn(oU, { key: 1 }))
      ])
    ]));
  }
}), Nj = /* @__PURE__ */ mr(Dj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-panel/layer-panel.vue"]]);
class Rj {
  bootstrap() {
    let e;
    e = Na(() => {
      this.restore(), this.persist(), e && e();
    });
  }
  persist() {
    const e = ev();
    Bn(
      [() => e.sliderActive, () => e.sliderRatio],
      ([n, a], [s]) => {
        n !== s && Ir.setValue(X0, n), Ir.setValue(
          K0,
          a
        );
      }
    );
  }
  restore() {
    const e = Ir.getValue(X0, j1), n = Ir.getValue(K0, Sf), { toggleSlider: a, setRatio: s } = ev();
    typeof e < "u" && e !== null && (a(e), typeof n !== void 0 && n !== null && s(n != null ? n : wI));
  }
}
const zj = new Rj(), Fj = ["onKeydown"], Bj = /* @__PURE__ */ Ne("span", { class: "lux-slider-line" }, null, -1), Vj = /* @__PURE__ */ Ne("span", { class: "lux-slider-arrows" }, [
  /* @__PURE__ */ Ne("span"),
  /* @__PURE__ */ Ne("span")
], -1), Uj = {
  key: 0,
  class: "lux-slider-layer-label"
}, jj = /* @__PURE__ */ Ne("i", { class: "fa fa-arrow-left mr-2" }, null, -1), Gj = /* @__PURE__ */ ur({
  __name: "splitter-element",
  props: {
    sliderActive: { type: Boolean, required: !0 },
    sliderRatio: { type: Number, required: !0 },
    sliderTopLayer: { type: null, required: !0 },
    sliderOffset: { type: Number, required: !0 },
    containerOffset: { type: Number, required: !0 }
  },
  emits: ["moveSplitBar", "escSplitBar"],
  setup(t, { expose: e, emit: n }) {
    const a = t, s = 30, { t: f } = An(), o = Hr(null), m = Ur(() => ({ left: `${a.sliderOffset}px` }));
    let g = !1;
    e({
      sliderElement: o
    });
    function b(Z) {
      n("moveSplitBar", Z + o.value.offsetWidth / 2);
    }
    function T() {
      g = !0, document.addEventListener("mousemove", M), document.addEventListener("mouseup", I);
    }
    function M(Z) {
      !g || b(Z.clientX - a.containerOffset);
    }
    function I() {
      g = !1, document.removeEventListener("mousemove", M), document.removeEventListener("mouseup", I);
    }
    function A() {
      b(o.value.offsetLeft + s);
    }
    function z() {
      b(o.value.offsetLeft - s);
    }
    function V() {
      n("escSplitBar");
    }
    return va(() => {
      var Z;
      (Z = o.value) == null || Z.focus({ focusVisible: !0 });
    }), Jc(() => {
      document.removeEventListener("mousemove", M), document.removeEventListener("mouseup", I);
    }), (Z, X) => (Ue(), st("button", {
      ref_key: "sliderElement",
      ref: o,
      onMousedown: T,
      onMousemove: M,
      onMouseup: I,
      onKeydown: [
        sf(A, ["space"]),
        sf(A, ["right"]),
        sf(z, ["left"]),
        sf(z, ["delete"]),
        sf(V, ["esc"])
      ],
      class: "left-[20px] absolute h-full w-[32px] block",
      style: Rf(le(m)),
      role: "seperator",
      "aria-controls": "map-container"
    }, [
      Bj,
      Vj,
      t.sliderTopLayer ? (Ue(), st("span", Uj, [
        jj,
        Ne("span", null, Vt(le(f)(t.sliderTopLayer.name)), 1)
      ])) : it("v-if", !0)
    ], 44, Fj));
  }
}), qj = /* @__PURE__ */ mr(Gj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/slider/splitter-element.vue"]]), $j = /* @__PURE__ */ ur({
  __name: "slider-comparator",
  setup(t) {
    const e = ev(), n = HM(), a = Nl().olMap, s = Hr(null), { sliderActive: f, sliderRatio: o, sliderTopLayer: m } = xn(e), g = Ur(
      () => {
        var X, Y;
        return ((Y = (X = s.value) == null ? void 0 : X.sliderElement) == null ? void 0 : Y.offsetWidth) || 0;
      }
    ), b = Ur(
      () => {
        var X, Y;
        return a.value && s.value ? o.value * a.value.getSize()[0] - ((Y = (X = s.value) == null ? void 0 : X.sliderElement) == null ? void 0 : Y.offsetWidth) / 2 + a.value.getViewport().offsetLeft : 0;
      }
    );
    let T, M, I;
    zj.bootstrap(), Bn([m, f], ([X, Y], [de]) => {
      var ye;
      X && Y ? (X !== de && z(), A()) : z(), (ye = a.value) == null || ye.render();
    }), Bn(b, () => {
      var X;
      (X = a.value) == null || X.render();
    });
    function A() {
      const X = n.getLayerFromCache(m.value);
      !X || (T = X.on(
        Ab.PRERENDER,
        function(Y) {
          var ze;
          const de = Y.context, ye = (ze = a.value) == null ? void 0 : ze.getSize(), Ie = b.value + g.value / 2, Be = py(Y, [0, 0]), De = py(Y, [Ie, 0]), Re = py(Y, [0, ye[1]]), Ee = py(Y, [Ie, ye[0]]);
          de.save(), de.beginPath(), de.moveTo(Be[0], Be[1]), de.lineTo(Re[0], Re[1]), de.lineTo(Ee[0], Ee[1]), de.lineTo(De[0], De[1]), de.closePath(), de.clip();
        }
      ), M = X.on(
        Ab.POSTRENDER,
        function(Y) {
          Y.context.restore();
        }
      ));
    }
    function z() {
      AC([T, M]);
    }
    function V(X) {
      var ye;
      const Y = (ye = a.value) == null ? void 0 : ye.getSize(), de = X / Y[0];
      e.setRatio(de);
    }
    function Z() {
      e.toggleSlider();
    }
    return va(() => {
      var X, Y;
      I = (Y = (X = a.value) == null ? void 0 : X.getTargetElement()) == null ? void 0 : Y.closest(".map-wrapper");
    }), Jc(() => {
      z();
    }), (X, Y) => {
      var de;
      return le(m) && le(f) ? (Ue(), cn(qj, {
        key: 0,
        ref_key: "splitterElement",
        ref: s,
        sliderActive: le(f),
        sliderRatio: le(o),
        sliderTopLayer: le(m),
        sliderOffset: le(b),
        containerOffset: ((de = le(I)) == null ? void 0 : de.offsetLeft) || 0,
        onMoveSplitBar: V,
        onEscSplitBar: Z
      }, null, 8, ["sliderActive", "sliderRatio", "sliderTopLayer", "sliderOffset", "containerOffset"])) : it("v-if", !0);
    };
  }
}), Wj = /* @__PURE__ */ mr($j, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/slider/slider-comparator.vue"]]), qy = "-", y0 = ",", gE = "--";
class Hj {
  constructor() {
    bi(this, "layersOpacitiesToNumbersV2", (e) => this.layersOpacitiesToNumbers(e, y0));
  }
  layerTimesToStrings(e) {
    return e ? e.split(gE) : [];
  }
  layerIdsToLayers(e) {
    const n = Gc(), a = Au();
    return (e ? e.split(qy) : []).map((f) => {
      const o = qc.isRemoteLayer(f) ? d8(f) : n.findById(parseInt(f, 10));
      return o ? a.initLayer(o) : void 0;
    });
  }
  layerNamesToLayersV2(e) {
    const n = Gc(), a = Au();
    return (e ? e.split(y0) : []).map((f) => {
      const o = n.findByName(f);
      return o ? a.initLayer(o) : void 0;
    });
  }
  layersOpacitiesToNumbers(e, n = qy) {
    return K4(e, n);
  }
  layersVisibilitiesToBooleansV2(e) {
    return Y4(e, y0);
  }
  layersToLayerIds(e) {
    return (e == null ? void 0 : e.map((n) => n.id).join(qy)) || "";
  }
  layersToLayerOpacities(e) {
    return (e == null ? void 0 : e.map((n) => {
      var a;
      return (a = n.opacity) != null ? a : 1;
    }).join(qy)) || "";
  }
  layersToLayerTimes(e) {
    return (e == null ? void 0 : e.map((n) => {
      var a;
      return (a = Au().getLayerCurrentTime(n)) != null ? a : "";
    }).join(gE)) || "";
  }
  bgLayerNameToBgLayer(e) {
    const n = Gc();
    return e ? n.findBgLayerByName(e) : null;
  }
  bgLayerToBgLayerName(e) {
    return (e == null ? void 0 : e.name) || Wg.name;
  }
}
const da = new Hj(), Zj = "basemap_2015_global", Xj = "orthogr_2013_global", Kj = {
  webbasemap: "basemap_2015_global",
  "pixelmaps-color": "topogr_global",
  "pixelmaps-gray": "topo_bw_jpeg",
  streets: "streets_jpeg",
  voidlayer: "blank"
};
class Yj {
  bootstrap() {
    const e = Ro();
    let n;
    n = Na(() => {
      e.bgLayers.length > 0 && (this.restore(), this.persist(), n && n());
    });
  }
  persist() {
    const e = Ai(), { bgLayer: n } = xn(e);
    Bn(
      n,
      (a, s) => {
        s !== a && Ir.setValue(
          Yw,
          a,
          da.bgLayerToBgLayerName
        );
      },
      { immediate: !0 }
    );
  }
  restore() {
    const { setMapBackground: e } = ZM(), n = this.getBgLayerFromStorage();
    e(n);
  }
  getBgLayerFromStorage() {
    const e = Ir.getInitialVersion(), n = Ir.getValue(Yw);
    return n ? e === 2 ? this.getBgLayerFromStorageV2(n) : da.bgLayerNameToBgLayer(n) : da.bgLayerNameToBgLayer(Zj);
  }
  getBgLayerFromStorageV2(e) {
    const n = Ir.getValue(
      RT,
      Sf
    );
    let a = "";
    return e ? a = Kj[e] : n === 0 && (a = Xj), da.bgLayerNameToBgLayer(a);
  }
}
const Jj = new Yj();
class Qj {
  bootstrap() {
    const e = Ro();
    let n;
    n = Na(() => {
      e.themes && (this.restore(), this.persist(), n && n());
    });
  }
  persist() {
    const e = Ai(), { layers: n } = xn(e);
    Bn(
      n,
      (a, s) => {
        s !== a && (Ir.setValue(
          Kw,
          a,
          da.layersToLayerIds
        ), Ir.setValue(
          Jw,
          a,
          da.layersToLayerOpacities
        ), Ir.setValue(
          Qw,
          a,
          da.layersToLayerTimes
        ));
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Ir.getInitialVersion(), n = Ai(), a = Ir.getValue(
      Kw,
      e === 2 ? da.layerNamesToLayersV2 : da.layerIdsToLayers
    );
    this.restoreLayersOpacities(a, e), this.restoreLayersTimes(a), e === 2 && (Ir.removeItem(RT), Ir.removeItem(e5), Ir.removeItem(n2), Ir.removeItem(i2)), n.addLayers(...(a == null ? void 0 : a.filter((s) => s)) || []);
  }
  restoreLayersOpacities(e, n) {
    const a = n === 2 ? this.getOpacitiesFromStorageV2() : this.getOpacitiesFromStorage();
    a.length && (e == null || e.forEach(
      (s, f) => {
        var o;
        return s && (s.opacity = (o = a[f]) != null ? o : 1);
      }
    ));
  }
  restoreLayersTimes(e) {
    const n = Ir.getValue(
      Qw,
      da.layerTimesToStrings
    );
    n.length && (e == null || e.forEach(
      (a, s) => a && n[s] && this.restoreLayerTime(a, n[s])
    ));
  }
  restoreLayerTime(e, n) {
    const a = n.split("/");
    e.currentTimeMinValue = a[0], e.currentTimeMaxValue = a[1];
  }
  getOpacitiesFromStorage() {
    return Ir.getValue(
      Jw,
      da.layersOpacitiesToNumbers
    );
  }
  getOpacitiesFromStorageV2() {
    const e = Ir.getValue(
      n2,
      da.layersOpacitiesToNumbersV2
    ), n = Ir.getValue(
      i2,
      da.layersVisibilitiesToBooleansV2
    );
    return e.map((a, s) => n[s] ? a : 0);
  }
}
const e9 = new Qj();
class t9 {
  themeToThemeName(e) {
    return (e == null ? void 0 : e.name) || "";
  }
}
const r9 = new t9();
class n9 {
  bootstrap() {
    this.restore();
    let e;
    e = Na(() => {
      this.persist(), e && e();
    });
  }
  persist() {
    const e = Ro();
    Bn(
      () => e.theme,
      (n, a) => {
        a !== n && n && Ir.setValue(
          Dd,
          n,
          r9.themeToThemeName
        );
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Ir.getValue(Dd);
    if (e) {
      const { setTheme: n } = Ro();
      n(e);
    }
  }
}
const i9 = new n9();
class o9 {
  bootstrapLayersOpen() {
    this.restoreLayersOpen();
    let e;
    e = Na(() => {
      this.persistLayersOpen(), e && e();
    });
  }
  persistLayersOpen() {
    const e = Pi(), { layersOpen: n } = xn(e);
    Bn(
      n,
      (a, s) => {
        s !== a && Ir.setValue(Dg, a);
      },
      { immediate: !0 }
    );
  }
  restoreLayersOpen() {
    const e = Ir.getValue(Dg) !== "false", { setLayersOpen: n } = Pi();
    n(e);
  }
}
const a9 = new o9();
class s9 {
  bootstrap() {
    this.restore();
    let e;
    e = Na(() => {
      this.persist(), e && e();
    });
  }
  persist() {
  }
  restore() {
    const e = Ir.getValue(J4);
    Pi().setMapId(e);
  }
}
const l9 = new s9();
function f1(t) {
  return f1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, f1(t);
}
var EI = [], u9 = EI.forEach, c9 = EI.slice;
function p1(t) {
  return u9.call(c9.call(arguments, 1), function(e) {
    if (e)
      for (var n in e)
        t[n] === void 0 && (t[n] = e[n]);
  }), t;
}
function SI() {
  return typeof XMLHttpRequest == "function" || (typeof XMLHttpRequest > "u" ? "undefined" : f1(XMLHttpRequest)) === "object";
}
function h9(t) {
  return !!t && typeof t.then == "function";
}
function f9(t) {
  return h9(t) ? t : Promise.resolve(t);
}
function p9(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var tv = { exports: {} }, $y = { exports: {} }, vE;
function d9() {
  return vE || (vE = 1, function(t, e) {
    var n = typeof self < "u" ? self : Us, a = function() {
      function f() {
        this.fetch = !1, this.DOMException = n.DOMException;
      }
      return f.prototype = n, new f();
    }();
    (function(f) {
      (function(o) {
        var m = {
          searchParams: "URLSearchParams" in f,
          iterable: "Symbol" in f && "iterator" in Symbol,
          blob: "FileReader" in f && "Blob" in f && function() {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          }(),
          formData: "FormData" in f,
          arrayBuffer: "ArrayBuffer" in f
        };
        function g(xe) {
          return xe && DataView.prototype.isPrototypeOf(xe);
        }
        if (m.arrayBuffer)
          var b = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ], T = ArrayBuffer.isView || function(xe) {
            return xe && b.indexOf(Object.prototype.toString.call(xe)) > -1;
          };
        function M(xe) {
          if (typeof xe != "string" && (xe = String(xe)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(xe))
            throw new TypeError("Invalid character in header field name");
          return xe.toLowerCase();
        }
        function I(xe) {
          return typeof xe != "string" && (xe = String(xe)), xe;
        }
        function A(xe) {
          var Ke = {
            next: function() {
              var ct = xe.shift();
              return { done: ct === void 0, value: ct };
            }
          };
          return m.iterable && (Ke[Symbol.iterator] = function() {
            return Ke;
          }), Ke;
        }
        function z(xe) {
          this.map = {}, xe instanceof z ? xe.forEach(function(Ke, ct) {
            this.append(ct, Ke);
          }, this) : Array.isArray(xe) ? xe.forEach(function(Ke) {
            this.append(Ke[0], Ke[1]);
          }, this) : xe && Object.getOwnPropertyNames(xe).forEach(function(Ke) {
            this.append(Ke, xe[Ke]);
          }, this);
        }
        z.prototype.append = function(xe, Ke) {
          xe = M(xe), Ke = I(Ke);
          var ct = this.map[xe];
          this.map[xe] = ct ? ct + ", " + Ke : Ke;
        }, z.prototype.delete = function(xe) {
          delete this.map[M(xe)];
        }, z.prototype.get = function(xe) {
          return xe = M(xe), this.has(xe) ? this.map[xe] : null;
        }, z.prototype.has = function(xe) {
          return this.map.hasOwnProperty(M(xe));
        }, z.prototype.set = function(xe, Ke) {
          this.map[M(xe)] = I(Ke);
        }, z.prototype.forEach = function(xe, Ke) {
          for (var ct in this.map)
            this.map.hasOwnProperty(ct) && xe.call(Ke, this.map[ct], ct, this);
        }, z.prototype.keys = function() {
          var xe = [];
          return this.forEach(function(Ke, ct) {
            xe.push(ct);
          }), A(xe);
        }, z.prototype.values = function() {
          var xe = [];
          return this.forEach(function(Ke) {
            xe.push(Ke);
          }), A(xe);
        }, z.prototype.entries = function() {
          var xe = [];
          return this.forEach(function(Ke, ct) {
            xe.push([ct, Ke]);
          }), A(xe);
        }, m.iterable && (z.prototype[Symbol.iterator] = z.prototype.entries);
        function V(xe) {
          if (xe.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
          xe.bodyUsed = !0;
        }
        function Z(xe) {
          return new Promise(function(Ke, ct) {
            xe.onload = function() {
              Ke(xe.result);
            }, xe.onerror = function() {
              ct(xe.error);
            };
          });
        }
        function X(xe) {
          var Ke = new FileReader(), ct = Z(Ke);
          return Ke.readAsArrayBuffer(xe), ct;
        }
        function Y(xe) {
          var Ke = new FileReader(), ct = Z(Ke);
          return Ke.readAsText(xe), ct;
        }
        function de(xe) {
          for (var Ke = new Uint8Array(xe), ct = new Array(Ke.length), vt = 0; vt < Ke.length; vt++)
            ct[vt] = String.fromCharCode(Ke[vt]);
          return ct.join("");
        }
        function ye(xe) {
          if (xe.slice)
            return xe.slice(0);
          var Ke = new Uint8Array(xe.byteLength);
          return Ke.set(new Uint8Array(xe)), Ke.buffer;
        }
        function Ie() {
          return this.bodyUsed = !1, this._initBody = function(xe) {
            this._bodyInit = xe, xe ? typeof xe == "string" ? this._bodyText = xe : m.blob && Blob.prototype.isPrototypeOf(xe) ? this._bodyBlob = xe : m.formData && FormData.prototype.isPrototypeOf(xe) ? this._bodyFormData = xe : m.searchParams && URLSearchParams.prototype.isPrototypeOf(xe) ? this._bodyText = xe.toString() : m.arrayBuffer && m.blob && g(xe) ? (this._bodyArrayBuffer = ye(xe.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : m.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(xe) || T(xe)) ? this._bodyArrayBuffer = ye(xe) : this._bodyText = xe = Object.prototype.toString.call(xe) : this._bodyText = "", this.headers.get("content-type") || (typeof xe == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : m.searchParams && URLSearchParams.prototype.isPrototypeOf(xe) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
          }, m.blob && (this.blob = function() {
            var xe = V(this);
            if (xe)
              return xe;
            if (this._bodyBlob)
              return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]));
          }, this.arrayBuffer = function() {
            return this._bodyArrayBuffer ? V(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(X);
          }), this.text = function() {
            var xe = V(this);
            if (xe)
              return xe;
            if (this._bodyBlob)
              return Y(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(de(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }, m.formData && (this.formData = function() {
            return this.text().then(Ee);
          }), this.json = function() {
            return this.text().then(JSON.parse);
          }, this;
        }
        var Be = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function De(xe) {
          var Ke = xe.toUpperCase();
          return Be.indexOf(Ke) > -1 ? Ke : xe;
        }
        function Re(xe, Ke) {
          Ke = Ke || {};
          var ct = Ke.body;
          if (xe instanceof Re) {
            if (xe.bodyUsed)
              throw new TypeError("Already read");
            this.url = xe.url, this.credentials = xe.credentials, Ke.headers || (this.headers = new z(xe.headers)), this.method = xe.method, this.mode = xe.mode, this.signal = xe.signal, !ct && xe._bodyInit != null && (ct = xe._bodyInit, xe.bodyUsed = !0);
          } else
            this.url = String(xe);
          if (this.credentials = Ke.credentials || this.credentials || "same-origin", (Ke.headers || !this.headers) && (this.headers = new z(Ke.headers)), this.method = De(Ke.method || this.method || "GET"), this.mode = Ke.mode || this.mode || null, this.signal = Ke.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && ct)
            throw new TypeError("Body not allowed for GET or HEAD requests");
          this._initBody(ct);
        }
        Re.prototype.clone = function() {
          return new Re(this, { body: this._bodyInit });
        };
        function Ee(xe) {
          var Ke = new FormData();
          return xe.trim().split("&").forEach(function(ct) {
            if (ct) {
              var vt = ct.split("="), Pt = vt.shift().replace(/\+/g, " "), tr = vt.join("=").replace(/\+/g, " ");
              Ke.append(decodeURIComponent(Pt), decodeURIComponent(tr));
            }
          }), Ke;
        }
        function ze(xe) {
          var Ke = new z(), ct = xe.replace(/\r?\n[\t ]+/g, " ");
          return ct.split(/\r?\n/).forEach(function(vt) {
            var Pt = vt.split(":"), tr = Pt.shift().trim();
            if (tr) {
              var Pn = Pt.join(":").trim();
              Ke.append(tr, Pn);
            }
          }), Ke;
        }
        Ie.call(Re.prototype);
        function rt(xe, Ke) {
          Ke || (Ke = {}), this.type = "default", this.status = Ke.status === void 0 ? 200 : Ke.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in Ke ? Ke.statusText : "OK", this.headers = new z(Ke.headers), this.url = Ke.url || "", this._initBody(xe);
        }
        Ie.call(rt.prototype), rt.prototype.clone = function() {
          return new rt(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new z(this.headers),
            url: this.url
          });
        }, rt.error = function() {
          var xe = new rt(null, { status: 0, statusText: "" });
          return xe.type = "error", xe;
        };
        var Ze = [301, 302, 303, 307, 308];
        rt.redirect = function(xe, Ke) {
          if (Ze.indexOf(Ke) === -1)
            throw new RangeError("Invalid status code");
          return new rt(null, { status: Ke, headers: { location: xe } });
        }, o.DOMException = f.DOMException;
        try {
          new o.DOMException();
        } catch {
          o.DOMException = function(Ke, ct) {
            this.message = Ke, this.name = ct;
            var vt = Error(Ke);
            this.stack = vt.stack;
          }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException;
        }
        function yt(xe, Ke) {
          return new Promise(function(ct, vt) {
            var Pt = new Re(xe, Ke);
            if (Pt.signal && Pt.signal.aborted)
              return vt(new o.DOMException("Aborted", "AbortError"));
            var tr = new XMLHttpRequest();
            function Pn() {
              tr.abort();
            }
            tr.onload = function() {
              var Dr = {
                status: tr.status,
                statusText: tr.statusText,
                headers: ze(tr.getAllResponseHeaders() || "")
              };
              Dr.url = "responseURL" in tr ? tr.responseURL : Dr.headers.get("X-Request-URL");
              var hr = "response" in tr ? tr.response : tr.responseText;
              ct(new rt(hr, Dr));
            }, tr.onerror = function() {
              vt(new TypeError("Network request failed"));
            }, tr.ontimeout = function() {
              vt(new TypeError("Network request failed"));
            }, tr.onabort = function() {
              vt(new o.DOMException("Aborted", "AbortError"));
            }, tr.open(Pt.method, Pt.url, !0), Pt.credentials === "include" ? tr.withCredentials = !0 : Pt.credentials === "omit" && (tr.withCredentials = !1), "responseType" in tr && m.blob && (tr.responseType = "blob"), Pt.headers.forEach(function(Dr, hr) {
              tr.setRequestHeader(hr, Dr);
            }), Pt.signal && (Pt.signal.addEventListener("abort", Pn), tr.onreadystatechange = function() {
              tr.readyState === 4 && Pt.signal.removeEventListener("abort", Pn);
            }), tr.send(typeof Pt._bodyInit > "u" ? null : Pt._bodyInit);
          });
        }
        return yt.polyfill = !0, f.fetch || (f.fetch = yt, f.Headers = z, f.Request = Re, f.Response = rt), o.Headers = z, o.Request = Re, o.Response = rt, o.fetch = yt, Object.defineProperty(o, "__esModule", { value: !0 }), o;
      })({});
    })(a), a.fetch.ponyfill = !0, delete a.fetch.polyfill;
    var s = a;
    e = s.fetch, e.default = s.fetch, e.fetch = s.fetch, e.Headers = s.Headers, e.Request = s.Request, e.Response = s.Response, t.exports = e;
  }($y, $y.exports)), $y.exports;
}
(function(t, e) {
  var n;
  if (typeof fetch == "function" && (typeof Us < "u" && Us.fetch ? n = Us.fetch : typeof window < "u" && window.fetch ? n = window.fetch : n = fetch), typeof p9 < "u" && (typeof window > "u" || typeof window.document > "u")) {
    var a = n || d9();
    a.default && (a = a.default), e.default = a, t.exports = e.default;
  }
})(tv, tv.exports);
const TI = tv.exports, _E = /* @__PURE__ */ kC({
  __proto__: null,
  default: TI
}, [tv.exports]);
function rv(t) {
  return rv = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, rv(t);
}
var zl;
typeof fetch == "function" && (typeof global < "u" && global.fetch ? zl = global.fetch : typeof window < "u" && window.fetch ? zl = window.fetch : zl = fetch);
var Nd;
SI() && (typeof global < "u" && global.XMLHttpRequest ? Nd = global.XMLHttpRequest : typeof window < "u" && window.XMLHttpRequest && (Nd = window.XMLHttpRequest));
var nv;
typeof ActiveXObject == "function" && (typeof global < "u" && global.ActiveXObject ? nv = global.ActiveXObject : typeof window < "u" && window.ActiveXObject && (nv = window.ActiveXObject));
!zl && _E && !Nd && !nv && (zl = TI || _E);
typeof zl != "function" && (zl = void 0);
var d1 = function(e, n) {
  if (n && rv(n) === "object") {
    var a = "";
    for (var s in n)
      a += "&" + encodeURIComponent(s) + "=" + encodeURIComponent(n[s]);
    if (!a)
      return e;
    e = e + (e.indexOf("?") !== -1 ? "&" : "?") + a.slice(1);
  }
  return e;
}, xE = function(e, n, a) {
  zl(e, n).then(function(s) {
    if (!s.ok)
      return a(s.statusText || "Error", {
        status: s.status
      });
    s.text().then(function(f) {
      a(null, {
        status: s.status,
        data: f
      });
    }).catch(a);
  }).catch(a);
}, bE = !1, m9 = function(e, n, a, s) {
  e.queryStringParams && (n = d1(n, e.queryStringParams));
  var f = p1({}, typeof e.customHeaders == "function" ? e.customHeaders() : e.customHeaders);
  a && (f["Content-Type"] = "application/json");
  var o = typeof e.requestOptions == "function" ? e.requestOptions(a) : e.requestOptions, m = p1({
    method: a ? "POST" : "GET",
    body: a ? e.stringify(a) : void 0,
    headers: f
  }, bE ? {} : o);
  try {
    xE(n, m, s);
  } catch (g) {
    if (!o || Object.keys(o).length === 0 || !g.message || g.message.indexOf("not implemented") < 0)
      return s(g);
    try {
      Object.keys(o).forEach(function(b) {
        delete m[b];
      }), xE(n, m, s), bE = !0;
    } catch (b) {
      s(b);
    }
  }
}, y9 = function(e, n, a, s) {
  a && rv(a) === "object" && (a = d1("", a).slice(1)), e.queryStringParams && (n = d1(n, e.queryStringParams));
  try {
    var f;
    Nd ? f = new Nd() : f = new nv("MSXML2.XMLHTTP.3.0"), f.open(a ? "POST" : "GET", n, 1), e.crossDomain || f.setRequestHeader("X-Requested-With", "XMLHttpRequest"), f.withCredentials = !!e.withCredentials, a && f.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), f.overrideMimeType && f.overrideMimeType("application/json");
    var o = e.customHeaders;
    if (o = typeof o == "function" ? o() : o, o)
      for (var m in o)
        f.setRequestHeader(m, o[m]);
    f.onreadystatechange = function() {
      f.readyState > 3 && s(f.status >= 400 ? f.statusText : null, {
        status: f.status,
        data: f.responseText
      });
    }, f.send(a);
  } catch (g) {
    console && console.log(g);
  }
}, g9 = function(e, n, a, s) {
  if (typeof a == "function" && (s = a, a = void 0), s = s || function() {
  }, zl && n.indexOf("file:") !== 0)
    return m9(e, n, a, s);
  if (SI() || typeof ActiveXObject == "function")
    return y9(e, n, a, s);
  s(new Error("No fetch and no xhr implementation found!"));
};
function Rd(t) {
  return Rd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Rd(t);
}
function v9(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function wE(t, e) {
  for (var n = 0; n < e.length; n++) {
    var a = e[n];
    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, MI(a.key), a);
  }
}
function _9(t, e, n) {
  return e && wE(t.prototype, e), n && wE(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function x9(t, e, n) {
  return e = MI(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function MI(t) {
  var e = b9(t, "string");
  return Rd(e) === "symbol" ? e : String(e);
}
function b9(t, e) {
  if (Rd(t) !== "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var a = n.call(t, e || "default");
    if (Rd(a) !== "object")
      return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var w9 = function() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    allowMultiLoading: !1,
    parse: function(n) {
      return JSON.parse(n);
    },
    stringify: JSON.stringify,
    parsePayload: function(n, a, s) {
      return x9({}, a, s || "");
    },
    request: g9,
    reloadInterval: typeof window < "u" ? !1 : 60 * 60 * 1e3,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: !1,
    withCredentials: !1,
    overrideMimeType: !1,
    requestOptions: {
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
}, II = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    v9(this, t), this.services = e, this.options = n, this.allOptions = a, this.type = "backend", this.init(e, n, a);
  }
  return _9(t, [{
    key: "init",
    value: function(n) {
      var a = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = n, this.options = p1(s, this.options || {}, w9()), this.allOptions = f, this.services && this.options.reloadInterval && setInterval(function() {
        return a.reload();
      }, this.options.reloadInterval);
    }
  }, {
    key: "readMulti",
    value: function(n, a, s) {
      this._readAny(n, n, a, a, s);
    }
  }, {
    key: "read",
    value: function(n, a, s) {
      this._readAny([n], n, [a], a, s);
    }
  }, {
    key: "_readAny",
    value: function(n, a, s, f, o) {
      var m = this, g = this.options.loadPath;
      typeof this.options.loadPath == "function" && (g = this.options.loadPath(n, s)), g = f9(g), g.then(function(b) {
        if (!b)
          return o(null, {});
        var T = m.services.interpolator.interpolate(b, {
          lng: n.join("+"),
          ns: s.join("+")
        });
        m.loadUrl(T, o, a, f);
      });
    }
  }, {
    key: "loadUrl",
    value: function(n, a, s, f) {
      var o = this;
      this.options.request(this.options, n, void 0, function(m, g) {
        if (g && (g.status >= 500 && g.status < 600 || !g.status))
          return a("failed loading " + n + "; status code: " + g.status, !0);
        if (g && g.status >= 400 && g.status < 500)
          return a("failed loading " + n + "; status code: " + g.status, !1);
        if (!g && m && m.message && m.message.indexOf("Failed to fetch") > -1)
          return a("failed loading " + n + ": " + m.message, !0);
        if (m)
          return a(m, !1);
        var b, T;
        try {
          typeof g.data == "string" ? b = o.options.parse(g.data, s, f) : b = g.data;
        } catch {
          T = "failed parsing " + n + " to json";
        }
        if (T)
          return a(T, !1);
        a(null, b);
      });
    }
  }, {
    key: "create",
    value: function(n, a, s, f, o) {
      var m = this;
      if (!!this.options.addPath) {
        typeof n == "string" && (n = [n]);
        var g = this.options.parsePayload(a, s, f), b = 0, T = [], M = [];
        n.forEach(function(I) {
          var A = m.options.addPath;
          typeof m.options.addPath == "function" && (A = m.options.addPath(I, a));
          var z = m.services.interpolator.interpolate(A, {
            lng: I,
            ns: a
          });
          m.options.request(m.options, z, g, function(V, Z) {
            b += 1, T.push(V), M.push(Z), b === n.length && typeof o == "function" && o(T, M);
          });
        });
      }
    }
  }, {
    key: "reload",
    value: function() {
      var n = this, a = this.services, s = a.backendConnector, f = a.languageUtils, o = a.logger, m = s.language;
      if (!(m && m.toLowerCase() === "cimode")) {
        var g = [], b = function(M) {
          var I = f.toResolveHierarchy(M);
          I.forEach(function(A) {
            g.indexOf(A) < 0 && g.push(A);
          });
        };
        b(m), this.allOptions.preload && this.allOptions.preload.forEach(function(T) {
          return b(T);
        }), g.forEach(function(T) {
          n.allOptions.ns.forEach(function(M) {
            s.read(T, M, "read", null, null, function(I, A) {
              I && o.warn("loading namespace ".concat(M, " for language ").concat(T, " failed"), I), !I && A && o.log("loaded namespace ".concat(M, " for language ").concat(T), A), s.loaded("".concat(T, "|").concat(M), I, A);
            });
          });
        });
      }
    }
  }]), t;
}();
II.type = "backend";
const E9 = /* @__PURE__ */ ur({
  __name: "simple-style-item",
  props: {
    styleName: { type: String, required: !0 },
    colors: { type: Array, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Ue(!0), st(un, null, Ra(e.colors, (s, f) => (Ue(), st("span", {
      key: `${t.styleName}-${f}`,
      class: "grow m-px",
      style: Rf(`background-color: ${s}`)
    }, " \xA0 ", 4))), 128));
  }
}), S9 = /* @__PURE__ */ mr(E9, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/simple-style-item.vue"]]), T9 = { class: "text-white border-2 p-[10px] m-[10px]" }, M9 = { class: "text-center mb-3" }, I9 = ["title"], O9 = { class: "text-white" }, C9 = ["title", "onClick"], A9 = { class: "flex" }, P9 = /* @__PURE__ */ ur({
  __name: "simple-style-selector",
  setup(t) {
    const { t: e } = An(), n = Ws(), a = Ff(), { bgStyle: s } = xn(n), f = os().simple_styles.road, o = Hr(f);
    Bn(
      s,
      (g) => o.value = a.checkSelection(
        g || [],
        f
      ),
      { immediate: !0 }
    );
    function m(g) {
      n.setSimpleStyle(g);
    }
    return (g, b) => (Ue(), st("div", T9, [
      it(" TODO: create clean container for simple and advanced style editors "),
      Ne("h5", M9, Vt(le(e)("Select a style", { ns: "client" })), 1),
      (Ue(!0), st(un, null, Ra(o.value, (T) => (Ue(), st("div", {
        key: T.unlocalized_label,
        title: le(e)(T.unlocalized_label, { ns: "client" }),
        class: Lr(`${T.selected ? "border-dotted" : "border-hidden"} border-2 p-px`)
      }, [
        Ne("span", O9, Vt(le(e)(T.unlocalized_label, { ns: "client" })) + " : ", 1),
        Ne("button", {
          title: le(e)("Select style: {{styleName}}", {
            styleName: le(e)(T.unlocalized_label)
          }),
          onClick: (M) => m(T),
          class: "w-full"
        }, [
          Ne("span", A9, [
            Gt(S9, {
              colors: T.colors,
              "style-name": T.unlocalized_label
            }, null, 8, ["colors", "style-name"])
          ])
        ], 8, C9)
      ], 10, I9))), 128))
    ]));
  }
}), k9 = /* @__PURE__ */ mr(P9, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/simple-style-selector.vue"]]);
function L9(t) {
  const e = D9(t);
  return !e || !e.medium_style_class ? [] : os().medium_default_styles[e.medium_style_class];
}
function D9(t) {
  return os().bg_layers.find((e) => e.id == (t == null ? void 0 : t.id));
}
const N9 = { class: "flex w-full items-center" }, R9 = {
  for: "colorId",
  class: "w-40"
}, z9 = { class: "grow" }, F9 = ["value"], B9 = ["checked", "aria-label"], V9 = /* @__PURE__ */ ur({
  __name: "medium-style-item",
  props: {
    style: { type: null, required: !0 },
    colorEditable: { type: Boolean, required: !0 }
  },
  emits: ["changeStyle"],
  setup(t, { emit: e }) {
    const n = t, { t: a } = An();
    function s(o) {
      if (o.target) {
        const m = {
          ...n.style,
          color: o.target.value
        };
        e("changeStyle", m);
      }
    }
    function f(o) {
      if (o) {
        const m = {
          ...n.style,
          visible: o.target.checked
        };
        e("changeStyle", m);
      }
    }
    return (o, m) => (Ue(), st("div", N9, [
      Ne("label", R9, Vt(le(a)(t.style.label)), 1),
      Ne("div", z9, [
        t.colorEditable && n.style.color ? (Ue(), st("input", {
          key: 0,
          id: "colorId",
          type: "color",
          class: "w-11 h-5 py-[1px] px-[2px]",
          value: n.style.color,
          onInput: s
        }, null, 40, F9)) : it("v-if", !0)
      ]),
      Ne("input", {
        type: "checkbox",
        class: "flex-none mr-3",
        checked: n.style.visible,
        onChange: f,
        "aria-label": le(a)("Show or hide {{ thematicName }}", {
          thematicName: n.style.label
        })
      }, null, 40, B9)
    ]));
  }
}), U9 = /* @__PURE__ */ mr(V9, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/medium-style-item.vue"]]), j9 = { class: "text-white border-2 p-[10px] m-[10px]" }, G9 = { class: "text-center mb-3" }, q9 = /* @__PURE__ */ ur({
  __name: "medium-style-selector",
  props: {
    layer: { type: null, required: !0 }
  },
  setup(t) {
    const e = t, n = ["basemap_2015_global"], a = Ws(), { bgStyle: s } = xn(a), { t: f } = An(), o = Ur(
      () => n.includes(e.layer.name)
    ), m = Ur(
      () => s.value || L9(e.layer)
    );
    function g(b, T) {
      s.value = m.value.map(
        (M, I) => I === b ? T : M
      ), a.disableExpertStyle();
    }
    return (b, T) => (Ue(), st("div", j9, [
      Ne("h5", G9, Vt(le(o) ? le(f)("Select a colour for every theme") : le(f)("Activate categories")), 1),
      (Ue(!0), st(un, null, Ra(le(m), (M, I) => (Ue(), cn(U9, {
        key: M.label,
        style: Rf(M),
        onChangeStyle: (A) => g(I, A),
        colorEditable: le(o)
      }, null, 8, ["style", "onChangeStyle", "colorEditable"]))), 128))
    ]));
  }
}), $9 = /* @__PURE__ */ mr(q9, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/medium-style-selector.vue"]]);
var OI = { exports: {} };
(function(t, e) {
  (function(n, a) {
    a();
  })(Us, function() {
    function n(b, T) {
      return typeof T > "u" ? T = { autoBom: !1 } : typeof T != "object" && (console.warn("Deprecated: Expected third argument to be a object"), T = { autoBom: !T }), T.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(b.type) ? new Blob(["\uFEFF", b], { type: b.type }) : b;
    }
    function a(b, T, M) {
      var I = new XMLHttpRequest();
      I.open("GET", b), I.responseType = "blob", I.onload = function() {
        g(I.response, T, M);
      }, I.onerror = function() {
        console.error("could not download file");
      }, I.send();
    }
    function s(b) {
      var T = new XMLHttpRequest();
      T.open("HEAD", b, !1);
      try {
        T.send();
      } catch {
      }
      return 200 <= T.status && 299 >= T.status;
    }
    function f(b) {
      try {
        b.dispatchEvent(new MouseEvent("click"));
      } catch {
        var T = document.createEvent("MouseEvents");
        T.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), b.dispatchEvent(T);
      }
    }
    var o = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof Us == "object" && Us.global === Us ? Us : void 0, m = o.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = o.saveAs || (typeof window != "object" || window !== o ? function() {
    } : "download" in HTMLAnchorElement.prototype && !m ? function(b, T, M) {
      var I = o.URL || o.webkitURL, A = document.createElement("a");
      T = T || b.name || "download", A.download = T, A.rel = "noopener", typeof b == "string" ? (A.href = b, A.origin === location.origin ? f(A) : s(A.href) ? a(b, T, M) : f(A, A.target = "_blank")) : (A.href = I.createObjectURL(b), setTimeout(function() {
        I.revokeObjectURL(A.href);
      }, 4e4), setTimeout(function() {
        f(A);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(b, T, M) {
      if (T = T || b.name || "download", typeof b != "string")
        navigator.msSaveOrOpenBlob(n(b, M), T);
      else if (s(b))
        a(b, T, M);
      else {
        var I = document.createElement("a");
        I.href = b, I.target = "_blank", setTimeout(function() {
          f(I);
        });
      }
    } : function(b, T, M, I) {
      if (I = I || open("", "_blank"), I && (I.document.title = I.document.body.innerText = "downloading..."), typeof b == "string")
        return a(b, T, M);
      var A = b.type === "application/octet-stream", z = /constructor/i.test(o.HTMLElement) || o.safari, V = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((V || A && z || m) && typeof FileReader < "u") {
        var Z = new FileReader();
        Z.onloadend = function() {
          var de = Z.result;
          de = V ? de : de.replace(/^data:[^;]*;/, "data:attachment/file;"), I ? I.location.href = de : location = de, I = null;
        }, Z.readAsDataURL(b);
      } else {
        var X = o.URL || o.webkitURL, Y = X.createObjectURL(b);
        I ? I.location = Y : location.href = Y, I = null, setTimeout(function() {
          X.revokeObjectURL(Y);
        }, 4e4);
      }
    });
    o.saveAs = g.saveAs = g, t.exports = g;
  });
})(OI);
const W9 = { class: "text-white border-2 p-[10px] m-[10px] flex flex-col" }, H9 = { class: "text-center mb-3" }, Z9 = { class: "flex flex-row justify-center" }, X9 = { class: "absolute top-[70px] w-full text-center text-base" }, K9 = { class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] text-sm" }, Y9 = {
  class: "'block z-[5] w-full h-full cursor-pointer after:absolute after:py-[15px] after:px-[15px] after:w-full after:text-center after:content-upload",
  for: "uploadMvtStyle"
}, J9 = { class: "absolute top-[70px] w-full text-center text-base" }, Q9 = ["href"], e7 = /* @__PURE__ */ ur({
  __name: "expert-style-selector",
  setup(t) {
    const e = Ai(), n = Ws(), a = Ff(), { appliedStyle: s } = xn(n), { t: f } = An();
    function o() {
      const b = s.value, T = JSON.stringify(b), M = new Blob([T], { type: "text/plain;charset=utf-8" }), I = "styles.json";
      OI.exports.saveAs(M, I);
    }
    function m(b) {
      const T = b.target.files;
      if ((T == null ? void 0 : T.length) !== 1)
        return;
      const M = T[0];
      new File([], "./text.txt").text().then((A) => console.log(A)), M.type === "application/json" && (M.text().then((A) => {
        n.enableExpertStyle(), s.value = JSON.parse(A);
      }), b.target.value = "");
    }
    function g() {
      return n.styleSerial === null ? a.getDefaultMapBoxStyleUrl(
        a.getVectorId(e.bgLayer)
      ) : `${n.registerUrls.get("get")}?id=${n.styleSerial}`;
    }
    return (b, T) => (Ue(), st("div", W9, [
      Ne("h5", H9, Vt(le(f)("Lancer \xE9diteur externe ou importer json")), 1),
      Ne("div", Z9, [
        Ne("a", {
          href: "#",
          class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] z-5 text-sm after:absolute after:left-[20px] after:top-[10px] after:z-4 after:w-[3.6em] after:text-center after:content-download",
          onClick: T[0] || (T[0] = (M) => o())
        }, [
          Ne("span", X9, Vt(le(f)("Download style")), 1)
        ]),
        Ne("div", K9, [
          Ne("label", Y9, [
            Ne("span", J9, Vt(le(f)("Upload style")), 1)
          ]),
          Ne("input", {
            class: "invisible",
            type: "file",
            name: "uploadMvtStyle",
            id: "uploadMvtStyle",
            onChange: m
          }, null, 32)
        ])
      ]),
      Ne("a", {
        href: `https://maputnik.github.io/editor/?style=${g()}`,
        target: "_blank",
        class: "lux-btn text-center"
      }, Vt(le(f)("Open Maputnik editor")), 9, Q9)
    ]));
  }
}), t7 = /* @__PURE__ */ mr(e7, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/expert-style-selector.vue"]]), r7 = { key: 0 }, n7 = { class: "h-20 shrink-0 flex justify-between lux-panel-title" }, i7 = { key: 0 }, o7 = { key: 1 }, a7 = { key: 2 }, s7 = /* @__PURE__ */ ur({
  __name: "style-selector",
  setup(t) {
    const { t: e } = An(), n = Ai(), a = Pi(), s = Ws(), { bgLayer: f } = xn(n), o = Ff(), m = Ur(
      () => o.getStyleCapabilitiesFromLayer(f.value)
    );
    Bn(f, (I) => {
      o.isLayerStyleEditable(I) || a.closeStyleEditorPanel();
    });
    let g = Hr(!1), b = Hr(!1), T = Hr(!1);
    function M() {
      s.setStyle(null);
    }
    return (I, A) => le(m).isEditable ? (Ue(), st("div", r7, [
      Ne("button", {
        onClick: A[0] || (A[0] = () => le(a).closeStyleEditorPanel())
      }, "X close"),
      Ne("h2", n7, Vt(le(e)("Style editor")), 1),
      le(m).hasSimpleStyle ? (Ue(), st("div", i7, [
        Ne("button", {
          onClick: A[1] || (A[1] = () => hn(g) ? g.value = !le(g) : g = !le(g))
        }, Vt(le(e)("Choose a predefined style")), 1),
        Gt(k9, {
          class: Lr(le(g) ? "" : "hidden")
        }, null, 8, ["class"])
      ])) : it("v-if", !0),
      le(m).hasAdvancedStyle ? (Ue(), st("div", o7, [
        Ne("button", {
          onClick: A[2] || (A[2] = () => hn(b) ? b.value = !le(b) : b = !le(b))
        }, Vt(le(e)("Change main colours")), 1),
        le(f) ? (Ue(), cn($9, {
          key: 0,
          class: Lr(le(b) ? "" : "hidden"),
          layer: le(f)
        }, null, 8, ["class", "layer"])) : it("v-if", !0)
      ])) : it("v-if", !0),
      le(m).hasExpertStyle ? (Ue(), st("div", a7, [
        Ne("button", {
          onClick: A[3] || (A[3] = () => hn(T) ? T.value = !le(T) : T = !le(T))
        }, Vt(le(e)("Advanced settings")), 1),
        le(f) ? (Ue(), cn(t7, {
          key: 0,
          class: Lr(le(T) ? "" : "hidden"),
          layer: le(f)
        }, null, 8, ["class", "layer"])) : it("v-if", !0)
      ])) : it("v-if", !0),
      Ne("button", {
        onClick: M,
        class: "lux-btn"
      }, Vt(le(e)("Reset style", { ns: "client" })), 1)
    ])) : it("v-if", !0);
  }
}), l7 = /* @__PURE__ */ mr(s7, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/style-selector.vue"]]);
function CI(t, e, n) {
  n(t, e) && t instanceof PC && t.getLayers().forEach((s) => {
    CI(s, [...e, t], n);
  });
}
const u7 = { class: "h-screen flex flex-col overflow-hidden" }, c7 = { class: "flex grow" }, h7 = {
  key: 0,
  class: "w-full sm:w-80 bg-secondary z-10"
}, f7 = {
  key: 1,
  class: "w-80 bg-primary"
}, p7 = { class: "map-wrapper grow bg-blue-100 relative" }, d7 = { class: "absolute right-1 top-16" }, m7 = /* @__PURE__ */ ur({
  __name: "App",
  setup(t) {
    l9.bootstrap(), e9.bootstrap(), i9.bootstrap(), a9.bootstrapLayersOpen(), BM.bootstrapStyle(), Jj.bootstrap();
    const { layersOpen: e, styleEditorOpen: n } = xn(Pi());
    Bn(
      e,
      () => setTimeout(() => {
        a();
      }, 50)
    ), va(() => window.addEventListener("resize", a)), Jc(() => window.removeEventListener("resize", a));
    function a() {
      const s = Nl().getOlMap();
      s.updateSize(), CI(s.getLayerGroup(), [], (f) => (f instanceof LT && f.getMapLibreMap().resize(), !0));
    }
    return (s, f) => (Ue(), st("div", u7, [
      Gt(AV),
      Ne("main", c7, [
        it(" Layer panel "),
        le(e) ? (Ue(), st("div", h7, [
          Gt(Nj)
        ])) : it("v-if", !0),
        it(" Style editor "),
        le(n) ? (Ue(), st("div", f7, [
          Gt(l7)
        ])) : it("v-if", !0),
        it(" Map container and slider comparator "),
        Ne("div", p7, [
          Gt(IF, { v4_standalone: !0 }),
          Gt(Wj),
          Gt(T8),
          Gt(mV)
        ]),
        it(" Background selector "),
        Ne("div", d7, [
          Gt(RF)
        ])
      ]),
      Gt(VV, { class: "fixed bottom-5 sm:static z-20" }),
      Gt(V4)
    ]));
  }
}), y7 = /* @__PURE__ */ mr(m7, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/App.vue"]]);
A4();
ii.use(II);
ii.init({
  lng: "fr",
  debug: !1,
  defaultNS: "client",
  supportedLngs: ["de", "en", "fr", "lb"],
  ns: ["client", "legends", "server", "tooltips"],
  fallbackLng: "fr",
  backend: {
    loadPath: "/static-ngeo/web-components/assets/locales/{{ns}}.{{lng}}.json"
  }
});
const sx = jk(y7);
sx.use(XL());
sx.use(g5, { i18next: ii });
sx.use(SL);
const j7 = (t = {}, e = null) => P4(
  {
    setup: () => {
      const n = yv();
      Object.assign(n.appContext, e._context), Object.assign(n.provides, e._context.provides);
    },
    render: () => US(t)
  },
  { shadowRoot: !1 }
);
export {
  V4 as AlertNotifications,
  y7 as App,
  RF as BackgroundSelector,
  AT as DropdownList,
  VV as FooterBar,
  AV as HeaderBar,
  g5 as I18NextVue,
  mV as LayerMetadata,
  Nj as LayerPanel,
  IF as MapContainer,
  LT as MapLibreLayer,
  T8 as RemoteLayers,
  Wj as SliderComparator,
  SL as VueDOMPurifyHTML,
  sx as app,
  II as backend,
  j7 as createElementInstance,
  XL as createPinia,
  P4 as defineCustomElement,
  ii as i18next,
  Jj as statePersistorBgLayerService,
  a9 as statePersistorLayersOpenService,
  e9 as statePersistorLayersService,
  l9 as statePersistorMyMapService,
  BM as statePersistorStyleService,
  i9 as statePersistorThemeService,
  xn as storeToRefs,
  wV as themeSelectorService,
  Pi as useAppStore,
  ZM as useBackgroundLayer,
  Au as useLayers,
  Nl as useMap,
  Ai as useMapStore,
  Ff as useMvtStyles,
  HM as useOpenLayers,
  Ws as useStyleStore,
  Ro as useThemeStore,
  Gc as useThemes,
  Bn as watch
};
