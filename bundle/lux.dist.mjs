var bC = Object.defineProperty;
var wC = (t, e, n) => e in t ? bC(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var ri = (t, e, n) => (wC(t, typeof e != "symbol" ? e + "" : e, n), n);
import { get as Ky, transformExtent as EC, getTransform as SC, transform as Db } from "ol/proj";
import { register as TC } from "ol/proj/proj4";
import MC from "ol/Map";
import IC from "ol/View";
import OC from "ol/layer/Image";
import PE from "ol/source/ImageWMS";
import CC from "ol/layer/Tile";
import AE from "ol/source/WMTS";
import PC from "ol/tilegrid/WMTS";
import { getTopLeft as AC } from "ol/extent";
import kC from "ol/layer/Layer";
import { toDegrees as LC } from "ol/math";
import { toLonLat as DC } from "ol/proj.js";
import * as Nb from "ol/events";
import NC from "ol/ObjectEventType";
import { CLASS_UNSELECTABLE as kE, CLASS_CONTROL as LE } from "ol/css";
import DE from "ol/control/Control";
import RC from "ol/control/FullScreen";
import zC from "ol/control/Zoom";
import FC from "ol/control/ZoomToExtent";
import BC from "ol/format/WMTSCapabilities.js";
import { getRenderPixel as gy } from "ol/render";
import { unByKey as VC } from "ol/Observable";
import Rb from "ol/render/EventType";
import UC from "ol/layer/Group.js";
function jC(t, e) {
  for (var n = 0; n < e.length; n++) {
    const a = e[n];
    if (typeof a != "string" && !Array.isArray(a)) {
      for (const s in a)
        if (s !== "default" && !(s in t)) {
          const f = Object.getOwnPropertyDescriptor(a, s);
          f && Object.defineProperty(t, s, f.get ? f : {
            enumerable: !0,
            get: () => a[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
function ju(t, e) {
  const n = /* @__PURE__ */ Object.create(null), a = t.split(",");
  for (let s = 0; s < a.length; s++)
    n[a[s]] = !0;
  return e ? (s) => !!n[s.toLowerCase()] : (s) => !!n[s];
}
function Gu(t) {
  if (er(t)) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const a = t[n], s = Hn(a) ? WC(a) : Gu(a);
      if (s)
        for (const f in s)
          e[f] = s[f];
    }
    return e;
  } else {
    if (Hn(t))
      return t;
    if (fn(t))
      return t;
  }
}
const GC = /;(?![^(]*\))/g, $C = /:([^]+)/, qC = /\/\*.*?\*\//gs;
function WC(t) {
  const e = {};
  return t.replace(qC, "").split(GC).forEach((n) => {
    if (n) {
      const a = n.split($C);
      a.length > 1 && (e[a[0].trim()] = a[1].trim());
    }
  }), e;
}
function Br(t) {
  let e = "";
  if (Hn(t))
    e = t;
  else if (er(t))
    for (let n = 0; n < t.length; n++) {
      const a = Br(t[n]);
      a && (e += a + " ");
    }
  else if (fn(t))
    for (const n in t)
      t[n] && (e += n + " ");
  return e.trim();
}
const HC = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", ZC = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", XC = /* @__PURE__ */ ju(HC), KC = /* @__PURE__ */ ju(ZC), YC = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", JC = /* @__PURE__ */ ju(YC);
function NE(t) {
  return !!t || t === "";
}
const Ht = (t) => Hn(t) ? t : t == null ? "" : er(t) || fn(t) && (t.toString === BE || !yr(t.toString)) ? JSON.stringify(t, RE, 2) : String(t), RE = (t, e) => e && e.__v_isRef ? RE(t, e.value) : $c(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce((n, [a, s]) => (n[`${a} =>`] = s, n), {})
} : FE(e) ? {
  [`Set(${e.size})`]: [...e.values()]
} : fn(e) && !er(e) && !VE(e) ? String(e) : e, wn = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, wf = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], ao = () => {
}, zE = () => !1, QC = /^on[^a-z]/, Ud = (t) => QC.test(t), _g = (t) => t.startsWith("onUpdate:"), Wn = Object.assign, wx = (t, e) => {
  const n = t.indexOf(e);
  n > -1 && t.splice(n, 1);
}, eP = Object.prototype.hasOwnProperty, jr = (t, e) => eP.call(t, e), er = Array.isArray, $c = (t) => cv(t) === "[object Map]", FE = (t) => cv(t) === "[object Set]", yr = (t) => typeof t == "function", Hn = (t) => typeof t == "string", Ex = (t) => typeof t == "symbol", fn = (t) => t !== null && typeof t == "object", Sx = (t) => fn(t) && yr(t.then) && yr(t.catch), BE = Object.prototype.toString, cv = (t) => BE.call(t), Tx = (t) => cv(t).slice(8, -1), VE = (t) => cv(t) === "[object Object]", Mx = (t) => Hn(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Yy = /* @__PURE__ */ ju(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), tP = /* @__PURE__ */ ju("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), hv = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = t(n));
}, rP = /-(\w)/g, ya = hv((t) => t.replace(rP, (e, n) => n ? n.toUpperCase() : "")), nP = /\B([A-Z])/g, ta = hv((t) => t.replace(nP, "-$1").toLowerCase()), Yc = hv((t) => t.charAt(0).toUpperCase() + t.slice(1)), Nc = hv((t) => t ? `on${Yc(t)}` : ""), Td = (t, e) => !Object.is(t, e), jp = (t, e) => {
  for (let n = 0; n < t.length; n++)
    t[n](e);
}, xg = (t, e, n) => {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !1,
    value: n
  });
}, iP = (t) => {
  const e = parseFloat(t);
  return isNaN(e) ? t : e;
}, E0 = (t) => {
  const e = Hn(t) ? Number(t) : NaN;
  return isNaN(e) ? t : e;
};
let zb;
const UE = () => zb || (zb = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function bg(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
let pa;
class jE {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = pa, !e && pa && (this.index = (pa.scopes || (pa.scopes = [])).push(this) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const n = pa;
      try {
        return pa = this, e();
      } finally {
        pa = n;
      }
    } else
      process.env.NODE_ENV !== "production" && bg("cannot run an inactive effect scope.");
  }
  on() {
    pa = this;
  }
  off() {
    pa = this.parent;
  }
  stop(e) {
    if (this._active) {
      let n, a;
      for (n = 0, a = this.effects.length; n < a; n++)
        this.effects[n].stop();
      for (n = 0, a = this.cleanups.length; n < a; n++)
        this.cleanups[n]();
      if (this.scopes)
        for (n = 0, a = this.scopes.length; n < a; n++)
          this.scopes[n].stop(!0);
      if (!this.detached && this.parent && !e) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function GE(t) {
  return new jE(t);
}
function oP(t, e = pa) {
  e && e.active && e.effects.push(t);
}
function $E() {
  return pa;
}
function aP(t) {
  pa ? pa.cleanups.push(t) : process.env.NODE_ENV !== "production" && bg("onScopeDispose() is called when there is no active effect scope to be associated with.");
}
const Md = (t) => {
  const e = new Set(t);
  return e.w = 0, e.n = 0, e;
}, qE = (t) => (t.w & Ru) > 0, WE = (t) => (t.n & Ru) > 0, sP = ({ deps: t }) => {
  if (t.length)
    for (let e = 0; e < t.length; e++)
      t[e].w |= Ru;
}, lP = (t) => {
  const { deps: e } = t;
  if (e.length) {
    let n = 0;
    for (let a = 0; a < e.length; a++) {
      const s = e[a];
      qE(s) && !WE(s) ? s.delete(t) : e[n++] = s, s.w &= ~Ru, s.n &= ~Ru;
    }
    e.length = n;
  }
}, wg = /* @__PURE__ */ new WeakMap();
let Jp = 0, Ru = 1;
const S0 = 30;
let No;
const qc = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : ""), T0 = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class Ix {
  constructor(e, n = null, a) {
    this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, oP(this, a);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = No, n = Pu;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = No, No = this, Pu = !0, Ru = 1 << ++Jp, Jp <= S0 ? sP(this) : Fb(this), this.fn();
    } finally {
      Jp <= S0 && lP(this), Ru = 1 << --Jp, No = this.parent, Pu = n, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    No === this ? this.deferStop = !0 : this.active && (Fb(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function Fb(t) {
  const { deps: e } = t;
  if (e.length) {
    for (let n = 0; n < e.length; n++)
      e[n].delete(t);
    e.length = 0;
  }
}
let Pu = !0;
const HE = [];
function rh() {
  HE.push(Pu), Pu = !1;
}
function nh() {
  const t = HE.pop();
  Pu = t === void 0 ? !0 : t;
}
function Bo(t, e, n) {
  if (Pu && No) {
    let a = wg.get(t);
    a || wg.set(t, a = /* @__PURE__ */ new Map());
    let s = a.get(n);
    s || a.set(n, s = Md());
    const f = process.env.NODE_ENV !== "production" ? { effect: No, target: t, type: e, key: n } : void 0;
    M0(s, f);
  }
}
function M0(t, e) {
  let n = !1;
  Jp <= S0 ? WE(t) || (t.n |= Ru, n = !qE(t)) : n = !t.has(No), n && (t.add(No), No.deps.push(t), process.env.NODE_ENV !== "production" && No.onTrack && No.onTrack(Object.assign({ effect: No }, e)));
}
function Gl(t, e, n, a, s, f) {
  const o = wg.get(t);
  if (!o)
    return;
  let m = [];
  if (e === "clear")
    m = [...o.values()];
  else if (n === "length" && er(t)) {
    const b = Number(a);
    o.forEach((T, M) => {
      (M === "length" || M >= b) && m.push(T);
    });
  } else
    switch (n !== void 0 && m.push(o.get(n)), e) {
      case "add":
        er(t) ? Mx(n) && m.push(o.get("length")) : (m.push(o.get(qc)), $c(t) && m.push(o.get(T0)));
        break;
      case "delete":
        er(t) || (m.push(o.get(qc)), $c(t) && m.push(o.get(T0)));
        break;
      case "set":
        $c(t) && m.push(o.get(qc));
        break;
    }
  const g = process.env.NODE_ENV !== "production" ? { target: t, type: e, key: n, newValue: a, oldValue: s, oldTarget: f } : void 0;
  if (m.length === 1)
    m[0] && (process.env.NODE_ENV !== "production" ? df(m[0], g) : df(m[0]));
  else {
    const b = [];
    for (const T of m)
      T && b.push(...T);
    process.env.NODE_ENV !== "production" ? df(Md(b), g) : df(Md(b));
  }
}
function df(t, e) {
  const n = er(t) ? t : [...t];
  for (const a of n)
    a.computed && Bb(a, e);
  for (const a of n)
    a.computed || Bb(a, e);
}
function Bb(t, e) {
  (t !== No || t.allowRecurse) && (process.env.NODE_ENV !== "production" && t.onTrigger && t.onTrigger(Wn({ effect: t }, e)), t.scheduler ? t.scheduler() : t.run());
}
function uP(t, e) {
  var n;
  return (n = wg.get(t)) === null || n === void 0 ? void 0 : n.get(e);
}
const cP = /* @__PURE__ */ ju("__proto__,__v_isRef,__isVue"), ZE = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(Ex)
), hP = /* @__PURE__ */ fv(), fP = /* @__PURE__ */ fv(!1, !0), pP = /* @__PURE__ */ fv(!0), dP = /* @__PURE__ */ fv(!0, !0), Vb = /* @__PURE__ */ mP();
function mP() {
  const t = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    t[e] = function(...n) {
      const a = hr(this);
      for (let f = 0, o = this.length; f < o; f++)
        Bo(a, "get", f + "");
      const s = a[e](...n);
      return s === -1 || s === !1 ? a[e](...n.map(hr)) : s;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    t[e] = function(...n) {
      rh();
      const a = hr(this)[e].apply(this, n);
      return nh(), a;
    };
  }), t;
}
function yP(t) {
  const e = hr(this);
  return Bo(e, "has", t), e.hasOwnProperty(t);
}
function fv(t = !1, e = !1) {
  return function(a, s, f) {
    if (s === "__v_isReactive")
      return !t;
    if (s === "__v_isReadonly")
      return t;
    if (s === "__v_isShallow")
      return e;
    if (s === "__v_raw" && f === (t ? e ? rS : tS : e ? eS : QE).get(a))
      return a;
    const o = er(a);
    if (!t) {
      if (o && jr(Vb, s))
        return Reflect.get(Vb, s, f);
      if (s === "hasOwnProperty")
        return yP;
    }
    const m = Reflect.get(a, s, f);
    return (Ex(s) ? ZE.has(s) : cP(s)) || (t || Bo(a, "get", s), e) ? m : hn(m) ? o && Mx(s) ? m : m.value : fn(m) ? t ? nS(m) : mv(m) : m;
  };
}
const gP = /* @__PURE__ */ XE(), vP = /* @__PURE__ */ XE(!0);
function XE(t = !1) {
  return function(n, a, s, f) {
    let o = n[a];
    if (zu(o) && hn(o) && !hn(s))
      return !1;
    if (!t && (!Eg(s) && !zu(s) && (o = hr(o), s = hr(s)), !er(n) && hn(o) && !hn(s)))
      return o.value = s, !0;
    const m = er(n) && Mx(a) ? Number(a) < n.length : jr(n, a), g = Reflect.set(n, a, s, f);
    return n === hr(f) && (m ? Td(s, o) && Gl(n, "set", a, s, o) : Gl(n, "add", a, s)), g;
  };
}
function _P(t, e) {
  const n = jr(t, e), a = t[e], s = Reflect.deleteProperty(t, e);
  return s && n && Gl(t, "delete", e, void 0, a), s;
}
function xP(t, e) {
  const n = Reflect.has(t, e);
  return (!Ex(e) || !ZE.has(e)) && Bo(t, "has", e), n;
}
function bP(t) {
  return Bo(t, "iterate", er(t) ? "length" : qc), Reflect.ownKeys(t);
}
const KE = {
  get: hP,
  set: gP,
  deleteProperty: _P,
  has: xP,
  ownKeys: bP
}, YE = {
  get: pP,
  set(t, e) {
    return process.env.NODE_ENV !== "production" && bg(`Set operation on key "${String(e)}" failed: target is readonly.`, t), !0;
  },
  deleteProperty(t, e) {
    return process.env.NODE_ENV !== "production" && bg(`Delete operation on key "${String(e)}" failed: target is readonly.`, t), !0;
  }
}, wP = /* @__PURE__ */ Wn({}, KE, {
  get: fP,
  set: vP
}), EP = /* @__PURE__ */ Wn({}, YE, {
  get: dP
}), Ox = (t) => t, pv = (t) => Reflect.getPrototypeOf(t);
function vy(t, e, n = !1, a = !1) {
  t = t.__v_raw;
  const s = hr(t), f = hr(e);
  n || (e !== f && Bo(s, "get", e), Bo(s, "get", f));
  const { has: o } = pv(s), m = a ? Ox : n ? Cx : Id;
  if (o.call(s, e))
    return m(t.get(e));
  if (o.call(s, f))
    return m(t.get(f));
  t !== s && t.get(e);
}
function _y(t, e = !1) {
  const n = this.__v_raw, a = hr(n), s = hr(t);
  return e || (t !== s && Bo(a, "has", t), Bo(a, "has", s)), t === s ? n.has(t) : n.has(t) || n.has(s);
}
function xy(t, e = !1) {
  return t = t.__v_raw, !e && Bo(hr(t), "iterate", qc), Reflect.get(t, "size", t);
}
function Ub(t) {
  t = hr(t);
  const e = hr(this);
  return pv(e).has.call(e, t) || (e.add(t), Gl(e, "add", t, t)), this;
}
function jb(t, e) {
  e = hr(e);
  const n = hr(this), { has: a, get: s } = pv(n);
  let f = a.call(n, t);
  f ? process.env.NODE_ENV !== "production" && JE(n, a, t) : (t = hr(t), f = a.call(n, t));
  const o = s.call(n, t);
  return n.set(t, e), f ? Td(e, o) && Gl(n, "set", t, e, o) : Gl(n, "add", t, e), this;
}
function Gb(t) {
  const e = hr(this), { has: n, get: a } = pv(e);
  let s = n.call(e, t);
  s ? process.env.NODE_ENV !== "production" && JE(e, n, t) : (t = hr(t), s = n.call(e, t));
  const f = a ? a.call(e, t) : void 0, o = e.delete(t);
  return s && Gl(e, "delete", t, void 0, f), o;
}
function $b() {
  const t = hr(this), e = t.size !== 0, n = process.env.NODE_ENV !== "production" ? $c(t) ? new Map(t) : new Set(t) : void 0, a = t.clear();
  return e && Gl(t, "clear", void 0, void 0, n), a;
}
function by(t, e) {
  return function(a, s) {
    const f = this, o = f.__v_raw, m = hr(o), g = e ? Ox : t ? Cx : Id;
    return !t && Bo(m, "iterate", qc), o.forEach((b, T) => a.call(s, g(b), g(T), f));
  };
}
function wy(t, e, n) {
  return function(...a) {
    const s = this.__v_raw, f = hr(s), o = $c(f), m = t === "entries" || t === Symbol.iterator && o, g = t === "keys" && o, b = s[t](...a), T = n ? Ox : e ? Cx : Id;
    return !e && Bo(f, "iterate", g ? T0 : qc), {
      next() {
        const { value: M, done: I } = b.next();
        return I ? { value: M, done: I } : {
          value: m ? [T(M[0]), T(M[1])] : T(M),
          done: I
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function du(t) {
  return function(...e) {
    if (process.env.NODE_ENV !== "production") {
      const n = e[0] ? `on key "${e[0]}" ` : "";
      console.warn(`${Yc(t)} operation ${n}failed: target is readonly.`, hr(this));
    }
    return t === "delete" ? !1 : this;
  };
}
function SP() {
  const t = {
    get(f) {
      return vy(this, f);
    },
    get size() {
      return xy(this);
    },
    has: _y,
    add: Ub,
    set: jb,
    delete: Gb,
    clear: $b,
    forEach: by(!1, !1)
  }, e = {
    get(f) {
      return vy(this, f, !1, !0);
    },
    get size() {
      return xy(this);
    },
    has: _y,
    add: Ub,
    set: jb,
    delete: Gb,
    clear: $b,
    forEach: by(!1, !0)
  }, n = {
    get(f) {
      return vy(this, f, !0);
    },
    get size() {
      return xy(this, !0);
    },
    has(f) {
      return _y.call(this, f, !0);
    },
    add: du("add"),
    set: du("set"),
    delete: du("delete"),
    clear: du("clear"),
    forEach: by(!0, !1)
  }, a = {
    get(f) {
      return vy(this, f, !0, !0);
    },
    get size() {
      return xy(this, !0);
    },
    has(f) {
      return _y.call(this, f, !0);
    },
    add: du("add"),
    set: du("set"),
    delete: du("delete"),
    clear: du("clear"),
    forEach: by(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((f) => {
    t[f] = wy(f, !1, !1), n[f] = wy(f, !0, !1), e[f] = wy(f, !1, !0), a[f] = wy(f, !0, !0);
  }), [
    t,
    n,
    e,
    a
  ];
}
const [TP, MP, IP, OP] = /* @__PURE__ */ SP();
function dv(t, e) {
  const n = e ? t ? OP : IP : t ? MP : TP;
  return (a, s, f) => s === "__v_isReactive" ? !t : s === "__v_isReadonly" ? t : s === "__v_raw" ? a : Reflect.get(jr(n, s) && s in a ? n : a, s, f);
}
const CP = {
  get: /* @__PURE__ */ dv(!1, !1)
}, PP = {
  get: /* @__PURE__ */ dv(!1, !0)
}, AP = {
  get: /* @__PURE__ */ dv(!0, !1)
}, kP = {
  get: /* @__PURE__ */ dv(!0, !0)
};
function JE(t, e, n) {
  const a = hr(n);
  if (a !== n && e.call(t, a)) {
    const s = Tx(t);
    console.warn(`Reactive ${s} contains both the raw and reactive versions of the same object${s === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const QE = /* @__PURE__ */ new WeakMap(), eS = /* @__PURE__ */ new WeakMap(), tS = /* @__PURE__ */ new WeakMap(), rS = /* @__PURE__ */ new WeakMap();
function LP(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function DP(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : LP(Tx(t));
}
function mv(t) {
  return zu(t) ? t : yv(t, !1, KE, CP, QE);
}
function NP(t) {
  return yv(t, !1, wP, PP, eS);
}
function nS(t) {
  return yv(t, !0, YE, AP, tS);
}
function mf(t) {
  return yv(t, !0, EP, kP, rS);
}
function yv(t, e, n, a, s) {
  if (!fn(t))
    return process.env.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(t)}`), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  const f = s.get(t);
  if (f)
    return f;
  const o = DP(t);
  if (o === 0)
    return t;
  const m = new Proxy(t, o === 2 ? a : n);
  return s.set(t, m), m;
}
function ss(t) {
  return zu(t) ? ss(t.__v_raw) : !!(t && t.__v_isReactive);
}
function zu(t) {
  return !!(t && t.__v_isReadonly);
}
function Eg(t) {
  return !!(t && t.__v_isShallow);
}
function Sg(t) {
  return ss(t) || zu(t);
}
function hr(t) {
  const e = t && t.__v_raw;
  return e ? hr(e) : t;
}
function ts(t) {
  return xg(t, "__v_skip", !0), t;
}
const Id = (t) => fn(t) ? mv(t) : t, Cx = (t) => fn(t) ? nS(t) : t;
function iS(t) {
  Pu && No && (t = hr(t), process.env.NODE_ENV !== "production" ? M0(t.dep || (t.dep = Md()), {
    target: t,
    type: "get",
    key: "value"
  }) : M0(t.dep || (t.dep = Md())));
}
function oS(t, e) {
  t = hr(t);
  const n = t.dep;
  n && (process.env.NODE_ENV !== "production" ? df(n, {
    target: t,
    type: "set",
    key: "value",
    newValue: e
  }) : df(n));
}
function hn(t) {
  return !!(t && t.__v_isRef === !0);
}
function Er(t) {
  return aS(t, !1);
}
function Bn(t) {
  return aS(t, !0);
}
function aS(t, e) {
  return hn(t) ? t : new RP(t, e);
}
class RP {
  constructor(e, n) {
    this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : hr(e), this._value = n ? e : Id(e);
  }
  get value() {
    return iS(this), this._value;
  }
  set value(e) {
    const n = this.__v_isShallow || Eg(e) || zu(e);
    e = n ? e : hr(e), Td(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : Id(e), oS(this, e));
  }
}
function se(t) {
  return hn(t) ? t.value : t;
}
const zP = {
  get: (t, e, n) => se(Reflect.get(t, e, n)),
  set: (t, e, n, a) => {
    const s = t[e];
    return hn(s) && !hn(n) ? (s.value = n, !0) : Reflect.set(t, e, n, a);
  }
};
function sS(t) {
  return ss(t) ? t : new Proxy(t, zP);
}
function qb(t) {
  process.env.NODE_ENV !== "production" && !Sg(t) && console.warn("toRefs() expects a reactive object but received a plain one.");
  const e = er(t) ? new Array(t.length) : {};
  for (const n in t)
    e[n] = cd(t, n);
  return e;
}
class FP {
  constructor(e, n, a) {
    this._object = e, this._key = n, this._defaultValue = a, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return uP(hr(this._object), this._key);
  }
}
function cd(t, e, n) {
  const a = t[e];
  return hn(a) ? a : new FP(t, e, n);
}
var lS;
class BP {
  constructor(e, n, a, s) {
    this._setter = n, this.dep = void 0, this.__v_isRef = !0, this[lS] = !1, this._dirty = !0, this.effect = new Ix(e, () => {
      this._dirty || (this._dirty = !0, oS(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = a;
  }
  get value() {
    const e = hr(this);
    return iS(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
lS = "__v_isReadonly";
function VP(t, e, n = !1) {
  let a, s;
  const f = yr(t);
  f ? (a = t, s = process.env.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : ao) : (a = t.get, s = t.set);
  const o = new BP(a, s, f || !s, n);
  return process.env.NODE_ENV !== "production" && e && !n && (o.effect.onTrack = e.onTrack, o.effect.onTrigger = e.onTrigger), o;
}
const Wc = [];
function Jy(t) {
  Wc.push(t);
}
function Qy() {
  Wc.pop();
}
function lt(t, ...e) {
  if (process.env.NODE_ENV === "production")
    return;
  rh();
  const n = Wc.length ? Wc[Wc.length - 1].component : null, a = n && n.appContext.config.warnHandler, s = UP();
  if (a)
    Bl(a, n, 11, [
      t + e.join(""),
      n && n.proxy,
      s.map(({ vnode: f }) => `at <${Sv(n, f.type)}>`).join(`
`),
      s
    ]);
  else {
    const f = [`[Vue warn]: ${t}`, ...e];
    s.length && f.push(`
`, ...jP(s)), console.warn(...f);
  }
  nh();
}
function UP() {
  let t = Wc[Wc.length - 1];
  if (!t)
    return [];
  const e = [];
  for (; t; ) {
    const n = e[0];
    n && n.vnode === t ? n.recurseCount++ : e.push({
      vnode: t,
      recurseCount: 0
    });
    const a = t.component && t.component.parent;
    t = a && a.vnode;
  }
  return e;
}
function jP(t) {
  const e = [];
  return t.forEach((n, a) => {
    e.push(...a === 0 ? [] : [`
`], ...GP(n));
  }), e;
}
function GP({ vnode: t, recurseCount: e }) {
  const n = e > 0 ? `... (${e} recursive calls)` : "", a = t.component ? t.component.parent == null : !1, s = ` at <${Sv(t.component, t.type, a)}`, f = ">" + n;
  return t.props ? [s, ...$P(t.props), f] : [s + f];
}
function $P(t) {
  const e = [], n = Object.keys(t);
  return n.slice(0, 3).forEach((a) => {
    e.push(...uS(a, t[a]));
  }), n.length > 3 && e.push(" ..."), e;
}
function uS(t, e, n) {
  return Hn(e) ? (e = JSON.stringify(e), n ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? n ? e : [`${t}=${e}`] : hn(e) ? (e = uS(t, hr(e.value), !0), n ? e : [`${t}=Ref<`, e, ">"]) : yr(e) ? [`${t}=fn${e.name ? `<${e.name}>` : ""}`] : (e = hr(e), n ? e : [`${t}=`, e]);
}
function qP(t, e) {
  process.env.NODE_ENV !== "production" && t !== void 0 && (typeof t != "number" ? lt(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && lt(`${e} is NaN - the duration expression might be incorrect.`));
}
const Px = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function Bl(t, e, n, a) {
  let s;
  try {
    s = a ? t(...a) : t();
  } catch (f) {
    gv(f, e, n);
  }
  return s;
}
function Da(t, e, n, a) {
  if (yr(t)) {
    const f = Bl(t, e, n, a);
    return f && Sx(f) && f.catch((o) => {
      gv(o, e, n);
    }), f;
  }
  const s = [];
  for (let f = 0; f < t.length; f++)
    s.push(Da(t[f], e, n, a));
  return s;
}
function gv(t, e, n, a = !0) {
  const s = e ? e.vnode : null;
  if (e) {
    let f = e.parent;
    const o = e.proxy, m = process.env.NODE_ENV !== "production" ? Px[n] : n;
    for (; f; ) {
      const b = f.ec;
      if (b) {
        for (let T = 0; T < b.length; T++)
          if (b[T](t, o, m) === !1)
            return;
      }
      f = f.parent;
    }
    const g = e.appContext.config.errorHandler;
    if (g) {
      Bl(g, null, 10, [t, o, m]);
      return;
    }
  }
  WP(t, n, s, a);
}
function WP(t, e, n, a = !0) {
  if (process.env.NODE_ENV !== "production") {
    const s = Px[e];
    if (n && Jy(n), lt(`Unhandled error${s ? ` during execution of ${s}` : ""}`), n && Qy(), a)
      throw t;
    console.error(t);
  } else
    console.error(t);
}
let Od = !1, I0 = !1;
const xo = [];
let Vs = 0;
const Ef = [];
let Fs = null, bu = 0;
const cS = /* @__PURE__ */ Promise.resolve();
let Ax = null;
const HP = 100;
function Tg(t) {
  const e = Ax || cS;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function ZP(t) {
  let e = Vs + 1, n = xo.length;
  for (; e < n; ) {
    const a = e + n >>> 1;
    Cd(xo[a]) < t ? e = a + 1 : n = a;
  }
  return e;
}
function vv(t) {
  (!xo.length || !xo.includes(t, Od && t.allowRecurse ? Vs + 1 : Vs)) && (t.id == null ? xo.push(t) : xo.splice(ZP(t.id), 0, t), hS());
}
function hS() {
  !Od && !I0 && (I0 = !0, Ax = cS.then(dS));
}
function XP(t) {
  const e = xo.indexOf(t);
  e > Vs && xo.splice(e, 1);
}
function fS(t) {
  er(t) ? Ef.push(...t) : (!Fs || !Fs.includes(t, t.allowRecurse ? bu + 1 : bu)) && Ef.push(t), hS();
}
function Wb(t, e = Od ? Vs + 1 : 0) {
  for (process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()); e < xo.length; e++) {
    const n = xo[e];
    if (n && n.pre) {
      if (process.env.NODE_ENV !== "production" && kx(t, n))
        continue;
      xo.splice(e, 1), e--, n();
    }
  }
}
function pS(t) {
  if (Ef.length) {
    const e = [...new Set(Ef)];
    if (Ef.length = 0, Fs) {
      Fs.push(...e);
      return;
    }
    for (Fs = e, process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), Fs.sort((n, a) => Cd(n) - Cd(a)), bu = 0; bu < Fs.length; bu++)
      process.env.NODE_ENV !== "production" && kx(t, Fs[bu]) || Fs[bu]();
    Fs = null, bu = 0;
  }
}
const Cd = (t) => t.id == null ? 1 / 0 : t.id, KP = (t, e) => {
  const n = Cd(t) - Cd(e);
  if (n === 0) {
    if (t.pre && !e.pre)
      return -1;
    if (e.pre && !t.pre)
      return 1;
  }
  return n;
};
function dS(t) {
  I0 = !1, Od = !0, process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), xo.sort(KP);
  const e = process.env.NODE_ENV !== "production" ? (n) => kx(t, n) : ao;
  try {
    for (Vs = 0; Vs < xo.length; Vs++) {
      const n = xo[Vs];
      if (n && n.active !== !1) {
        if (process.env.NODE_ENV !== "production" && e(n))
          continue;
        Bl(n, null, 14);
      }
    }
  } finally {
    Vs = 0, xo.length = 0, pS(t), Od = !1, Ax = null, (xo.length || Ef.length) && dS(t);
  }
}
function kx(t, e) {
  if (!t.has(e))
    t.set(e, 1);
  else {
    const n = t.get(e);
    if (n > HP) {
      const a = e.ownerInstance, s = a && Vx(a.type);
      return lt(`Maximum recursive updates exceeded${s ? ` in component <${s}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`), !0;
    } else
      t.set(e, n + 1);
  }
}
let Au = !1;
const hf = /* @__PURE__ */ new Set();
process.env.NODE_ENV !== "production" && (UE().__VUE_HMR_RUNTIME__ = {
  createRecord: A_(mS),
  rerender: A_(QP),
  reload: A_(eA)
});
const Jc = /* @__PURE__ */ new Map();
function YP(t) {
  const e = t.type.__hmrId;
  let n = Jc.get(e);
  n || (mS(e, t.type), n = Jc.get(e)), n.instances.add(t);
}
function JP(t) {
  Jc.get(t.type.__hmrId).instances.delete(t);
}
function mS(t, e) {
  return Jc.has(t) ? !1 : (Jc.set(t, {
    initialDef: hd(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function hd(t) {
  return KS(t) ? t.__vccOpts : t;
}
function QP(t, e) {
  const n = Jc.get(t);
  !n || (n.initialDef.render = e, [...n.instances].forEach((a) => {
    e && (a.render = e, hd(a.type).render = e), a.renderCache = [], Au = !0, a.update(), Au = !1;
  }));
}
function eA(t, e) {
  const n = Jc.get(t);
  if (!n)
    return;
  e = hd(e), Hb(n.initialDef, e);
  const a = [...n.instances];
  for (const s of a) {
    const f = hd(s.type);
    hf.has(f) || (f !== n.initialDef && Hb(f, e), hf.add(f)), s.appContext.optionsCache.delete(s.type), s.ceReload ? (hf.add(f), s.ceReload(e.styles), hf.delete(f)) : s.parent ? vv(s.parent.update) : s.appContext.reload ? s.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
  }
  fS(() => {
    for (const s of a)
      hf.delete(hd(s.type));
  });
}
function Hb(t, e) {
  Wn(t, e);
  for (const n in t)
    n !== "__file" && !(n in e) && delete t[n];
}
function A_(t) {
  return (e, n) => {
    try {
      return t(e, n);
    } catch (a) {
      console.error(a), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.");
    }
  };
}
let Us, Qp = [], O0 = !1;
function jd(t, ...e) {
  Us ? Us.emit(t, ...e) : O0 || Qp.push({ event: t, args: e });
}
function yS(t, e) {
  var n, a;
  Us = t, Us ? (Us.enabled = !0, Qp.forEach(({ event: s, args: f }) => Us.emit(s, ...f)), Qp = []) : typeof window < "u" && window.HTMLElement && !(!((a = (n = window.navigator) === null || n === void 0 ? void 0 : n.userAgent) === null || a === void 0) && a.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((f) => {
    yS(f, e);
  }), setTimeout(() => {
    Us || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, O0 = !0, Qp = []);
  }, 3e3)) : (O0 = !0, Qp = []);
}
function tA(t, e) {
  jd("app:init", t, e, {
    Fragment: on,
    Text: $d,
    Comment: Xi,
    Static: eg
  });
}
function rA(t) {
  jd("app:unmount", t);
}
const nA = /* @__PURE__ */ Lx("component:added"), gS = /* @__PURE__ */ Lx("component:updated"), iA = /* @__PURE__ */ Lx("component:removed"), oA = (t) => {
  Us && typeof Us.cleanupBuffer == "function" && !Us.cleanupBuffer(t) && iA(t);
};
function Lx(t) {
  return (e) => {
    jd(t, e.appContext.app, e.uid, e.parent ? e.parent.uid : void 0, e);
  };
}
const aA = /* @__PURE__ */ vS("perf:start"), sA = /* @__PURE__ */ vS("perf:end");
function vS(t) {
  return (e, n, a) => {
    jd(t, e.appContext.app, e.uid, e, n, a);
  };
}
function lA(t, e, n) {
  jd("component:emit", t.appContext.app, t, e, n);
}
function uA(t, e, ...n) {
  if (t.isUnmounted)
    return;
  const a = t.vnode.props || wn;
  if (process.env.NODE_ENV !== "production") {
    const { emitsOptions: T, propsOptions: [M] } = t;
    if (T)
      if (!(e in T))
        (!M || !(Nc(e) in M)) && lt(`Component emitted event "${e}" but it is neither declared in the emits option nor as an "${Nc(e)}" prop.`);
      else {
        const I = T[e];
        yr(I) && (I(...n) || lt(`Invalid event arguments: event validation failed for event "${e}".`));
      }
  }
  let s = n;
  const f = e.startsWith("update:"), o = f && e.slice(7);
  if (o && o in a) {
    const T = `${o === "modelValue" ? "model" : o}Modifiers`, { number: M, trim: I } = a[T] || wn;
    I && (s = n.map((A) => Hn(A) ? A.trim() : A)), M && (s = n.map(iP));
  }
  if (process.env.NODE_ENV !== "production" && lA(t, e, s), process.env.NODE_ENV !== "production") {
    const T = e.toLowerCase();
    T !== e && a[Nc(T)] && lt(`Event "${T}" is emitted in component ${Sv(t, t.type)} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${ta(e)}" instead of "${e}".`);
  }
  let m, g = a[m = Nc(e)] || a[m = Nc(ya(e))];
  !g && f && (g = a[m = Nc(ta(e))]), g && Da(g, t, 6, s);
  const b = a[m + "Once"];
  if (b) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[m])
      return;
    t.emitted[m] = !0, Da(b, t, 6, s);
  }
}
function _S(t, e, n = !1) {
  const a = e.emitsCache, s = a.get(t);
  if (s !== void 0)
    return s;
  const f = t.emits;
  let o = {}, m = !1;
  if (!yr(t)) {
    const g = (b) => {
      const T = _S(b, e, !0);
      T && (m = !0, Wn(o, T));
    };
    !n && e.mixins.length && e.mixins.forEach(g), t.extends && g(t.extends), t.mixins && t.mixins.forEach(g);
  }
  return !f && !m ? (fn(t) && a.set(t, null), null) : (er(f) ? f.forEach((g) => o[g] = null) : Wn(o, f), fn(t) && a.set(t, o), o);
}
function _v(t, e) {
  return !t || !Ud(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), jr(t, e[0].toLowerCase() + e.slice(1)) || jr(t, ta(e)) || jr(t, e));
}
let zi = null, xS = null;
function Mg(t) {
  const e = zi;
  return zi = t, xS = t && t.type.__scopeId || null, e;
}
function ku(t, e = zi, n) {
  if (!e || t._n)
    return t;
  const a = (...s) => {
    a._d && aw(-1);
    const f = Mg(e);
    let o;
    try {
      o = t(...s);
    } finally {
      Mg(f), a._d && aw(1);
    }
    return process.env.NODE_ENV !== "production" && gS(e), o;
  };
  return a._n = !0, a._c = !0, a._d = !0, a;
}
let C0 = !1;
function Ig() {
  C0 = !0;
}
function k_(t) {
  const { type: e, vnode: n, proxy: a, withProxy: s, props: f, propsOptions: [o], slots: m, attrs: g, emit: b, render: T, renderCache: M, data: I, setupState: A, ctx: z, inheritAttrs: V } = t;
  let q, re;
  const X = Mg(t);
  process.env.NODE_ENV !== "production" && (C0 = !1);
  try {
    if (n.shapeFlag & 4) {
      const ve = s || a;
      q = rs(T.call(ve, ve, M, f, A, I, z)), re = g;
    } else {
      const ve = e;
      process.env.NODE_ENV !== "production" && g === f && Ig(), q = rs(ve.length > 1 ? ve(f, process.env.NODE_ENV !== "production" ? {
        get attrs() {
          return Ig(), g;
        },
        slots: m,
        emit: b
      } : { attrs: g, slots: m, emit: b }) : ve(f, null)), re = e.props ? g : hA(g);
    }
  } catch (ve) {
    dd.length = 0, gv(ve, t, 1), q = kt(Xi);
  }
  let ae = q, ce;
  if (process.env.NODE_ENV !== "production" && q.patchFlag > 0 && q.patchFlag & 2048 && ([ae, ce] = cA(q)), re && V !== !1) {
    const ve = Object.keys(re), { shapeFlag: Ne } = ae;
    if (ve.length) {
      if (Ne & 7)
        o && ve.some(_g) && (re = fA(re, o)), ae = Qs(ae, re);
      else if (process.env.NODE_ENV !== "production" && !C0 && ae.type !== Xi) {
        const ze = Object.keys(g), Ae = [], Se = [];
        for (let Ie = 0, Xe = ze.length; Ie < Xe; Ie++) {
          const $e = ze[Ie];
          Ud($e) ? _g($e) || Ae.push($e[2].toLowerCase() + $e.slice(3)) : Se.push($e);
        }
        Se.length && lt(`Extraneous non-props attributes (${Se.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`), Ae.length && lt(`Extraneous non-emits event listeners (${Ae.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
      }
    }
  }
  return n.dirs && (process.env.NODE_ENV !== "production" && !Zb(ae) && lt("Runtime directive used on component with non-element root node. The directives will not function as intended."), ae = Qs(ae), ae.dirs = ae.dirs ? ae.dirs.concat(n.dirs) : n.dirs), n.transition && (process.env.NODE_ENV !== "production" && !Zb(ae) && lt("Component inside <Transition> renders non-element root node that cannot be animated."), ae.transition = n.transition), process.env.NODE_ENV !== "production" && ce ? ce(ae) : q = ae, Mg(X), q;
}
const cA = (t) => {
  const e = t.children, n = t.dynamicChildren, a = bS(e);
  if (!a)
    return [t, void 0];
  const s = e.indexOf(a), f = n ? n.indexOf(a) : -1, o = (m) => {
    e[s] = m, n && (f > -1 ? n[f] = m : m.patchFlag > 0 && (t.dynamicChildren = [...n, m]));
  };
  return [rs(a), o];
};
function bS(t) {
  let e;
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    if (Lf(a)) {
      if (a.type !== Xi || a.children === "v-if") {
        if (e)
          return;
        e = a;
      }
    } else
      return;
  }
  return e;
}
const hA = (t) => {
  let e;
  for (const n in t)
    (n === "class" || n === "style" || Ud(n)) && ((e || (e = {}))[n] = t[n]);
  return e;
}, fA = (t, e) => {
  const n = {};
  for (const a in t)
    (!_g(a) || !(a.slice(9) in e)) && (n[a] = t[a]);
  return n;
}, Zb = (t) => t.shapeFlag & 7 || t.type === Xi;
function pA(t, e, n) {
  const { props: a, children: s, component: f } = t, { props: o, children: m, patchFlag: g } = e, b = f.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (s || m) && Au || e.dirs || e.transition)
    return !0;
  if (n && g >= 0) {
    if (g & 1024)
      return !0;
    if (g & 16)
      return a ? Xb(a, o, b) : !!o;
    if (g & 8) {
      const T = e.dynamicProps;
      for (let M = 0; M < T.length; M++) {
        const I = T[M];
        if (o[I] !== a[I] && !_v(b, I))
          return !0;
      }
    }
  } else
    return (s || m) && (!m || !m.$stable) ? !0 : a === o ? !1 : a ? o ? Xb(a, o, b) : !0 : !!o;
  return !1;
}
function Xb(t, e, n) {
  const a = Object.keys(e);
  if (a.length !== Object.keys(t).length)
    return !0;
  for (let s = 0; s < a.length; s++) {
    const f = a[s];
    if (e[f] !== t[f] && !_v(n, f))
      return !0;
  }
  return !1;
}
function dA({ vnode: t, parent: e }, n) {
  for (; e && e.subTree === t; )
    (t = e.vnode).el = n, e = e.parent;
}
const mA = (t) => t.__isSuspense;
function yA(t, e) {
  e && e.pendingBranch ? er(t) ? e.effects.push(...t) : e.effects.push(t) : fS(t);
}
function wS(t, e) {
  if (!di)
    process.env.NODE_ENV !== "production" && lt("provide() can only be used inside setup().");
  else {
    let n = di.provides;
    const a = di.parent && di.parent.provides;
    a === n && (n = di.provides = Object.create(a)), n[t] = e;
  }
}
function Sf(t, e, n = !1) {
  const a = di || zi;
  if (a) {
    const s = a.parent == null ? a.vnode.appContext && a.vnode.appContext.provides : a.parent.provides;
    if (s && t in s)
      return s[t];
    if (arguments.length > 1)
      return n && yr(e) ? e.call(a.proxy) : e;
    process.env.NODE_ENV !== "production" && lt(`injection "${String(t)}" not found.`);
  } else
    process.env.NODE_ENV !== "production" && lt("inject() can only be used inside setup() or functional components.");
}
function va(t, e) {
  return Dx(t, null, e);
}
const Ey = {};
function An(t, e, n) {
  return process.env.NODE_ENV !== "production" && !yr(e) && lt("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), Dx(t, e, n);
}
function Dx(t, e, { immediate: n, deep: a, flush: s, onTrack: f, onTrigger: o } = wn) {
  process.env.NODE_ENV !== "production" && !e && (n !== void 0 && lt('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), a !== void 0 && lt('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));
  const m = (ce) => {
    lt("Invalid watch source: ", ce, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.");
  }, g = $E() === (di == null ? void 0 : di.scope) ? di : null;
  let b, T = !1, M = !1;
  if (hn(t) ? (b = () => t.value, T = Eg(t)) : ss(t) ? (b = () => t, a = !0) : er(t) ? (M = !0, T = t.some((ce) => ss(ce) || Eg(ce)), b = () => t.map((ce) => {
    if (hn(ce))
      return ce.value;
    if (ss(ce))
      return Gc(ce);
    if (yr(ce))
      return Bl(ce, g, 2);
    process.env.NODE_ENV !== "production" && m(ce);
  })) : yr(t) ? e ? b = () => Bl(t, g, 2) : b = () => {
    if (!(g && g.isUnmounted))
      return I && I(), Da(t, g, 3, [A]);
  } : (b = ao, process.env.NODE_ENV !== "production" && m(t)), e && a) {
    const ce = b;
    b = () => Gc(ce());
  }
  let I, A = (ce) => {
    I = X.onStop = () => {
      Bl(ce, g, 4);
    };
  }, z;
  if (Ad)
    if (A = ao, e ? n && Da(e, g, 3, [
      b(),
      M ? [] : void 0,
      A
    ]) : b(), s === "sync") {
      const ce = Ek();
      z = ce.__watcherHandles || (ce.__watcherHandles = []);
    } else
      return ao;
  let V = M ? new Array(t.length).fill(Ey) : Ey;
  const q = () => {
    if (!!X.active)
      if (e) {
        const ce = X.run();
        (a || T || (M ? ce.some((ve, Ne) => Td(ve, V[Ne])) : Td(ce, V))) && (I && I(), Da(e, g, 3, [
          ce,
          V === Ey ? void 0 : M && V[0] === Ey ? [] : V,
          A
        ]), V = ce);
      } else
        X.run();
  };
  q.allowRecurse = !!e;
  let re;
  s === "sync" ? re = q : s === "post" ? re = () => ea(q, g && g.suspense) : (q.pre = !0, g && (q.id = g.uid), re = () => vv(q));
  const X = new Ix(b, re);
  process.env.NODE_ENV !== "production" && (X.onTrack = f, X.onTrigger = o), e ? n ? q() : V = X.run() : s === "post" ? ea(X.run.bind(X), g && g.suspense) : X.run();
  const ae = () => {
    X.stop(), g && g.scope && wx(g.scope.effects, X);
  };
  return z && z.push(ae), ae;
}
function gA(t, e, n) {
  const a = this.proxy, s = Hn(t) ? t.includes(".") ? ES(a, t) : () => a[t] : t.bind(a, a);
  let f;
  yr(e) ? f = e : (f = e.handler, n = e);
  const o = di;
  Df(this);
  const m = Dx(s, f.bind(a), n);
  return o ? Df(o) : Zc(), m;
}
function ES(t, e) {
  const n = e.split(".");
  return () => {
    let a = t;
    for (let s = 0; s < n.length && a; s++)
      a = a[n[s]];
    return a;
  };
}
function Gc(t, e) {
  if (!fn(t) || t.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(t)))
    return t;
  if (e.add(t), hn(t))
    Gc(t.value, e);
  else if (er(t))
    for (let n = 0; n < t.length; n++)
      Gc(t[n], e);
  else if (FE(t) || $c(t))
    t.forEach((n) => {
      Gc(n, e);
    });
  else if (VE(t))
    for (const n in t)
      Gc(t[n], e);
  return t;
}
function vA() {
  const t = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return _a(() => {
    t.isMounted = !0;
  }), OS(() => {
    t.isUnmounting = !0;
  }), t;
}
const Ia = [Function, Array], _A = {
  name: "BaseTransition",
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Ia,
    onEnter: Ia,
    onAfterEnter: Ia,
    onEnterCancelled: Ia,
    onBeforeLeave: Ia,
    onLeave: Ia,
    onAfterLeave: Ia,
    onLeaveCancelled: Ia,
    onBeforeAppear: Ia,
    onAppear: Ia,
    onAfterAppear: Ia,
    onAppearCancelled: Ia
  },
  setup(t, { slots: e }) {
    const n = wv(), a = vA();
    let s;
    return () => {
      const f = e.default && MS(e.default(), !0);
      if (!f || !f.length)
        return;
      let o = f[0];
      if (f.length > 1) {
        let V = !1;
        for (const q of f)
          if (q.type !== Xi) {
            if (process.env.NODE_ENV !== "production" && V) {
              lt("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
              break;
            }
            if (o = q, V = !0, process.env.NODE_ENV === "production")
              break;
          }
      }
      const m = hr(t), { mode: g } = m;
      if (process.env.NODE_ENV !== "production" && g && g !== "in-out" && g !== "out-in" && g !== "default" && lt(`invalid <transition> mode: ${g}`), a.isLeaving)
        return L_(o);
      const b = Kb(o);
      if (!b)
        return L_(o);
      const T = P0(b, m, a, n);
      A0(b, T);
      const M = n.subTree, I = M && Kb(M);
      let A = !1;
      const { getTransitionKey: z } = b.type;
      if (z) {
        const V = z();
        s === void 0 ? s = V : V !== s && (s = V, A = !0);
      }
      if (I && I.type !== Xi && (!Vc(b, I) || A)) {
        const V = P0(I, m, a, n);
        if (A0(I, V), g === "out-in")
          return a.isLeaving = !0, V.afterLeave = () => {
            a.isLeaving = !1, n.update.active !== !1 && n.update();
          }, L_(o);
        g === "in-out" && b.type !== Xi && (V.delayLeave = (q, re, X) => {
          const ae = TS(a, I);
          ae[String(I.key)] = I, q._leaveCb = () => {
            re(), q._leaveCb = void 0, delete T.delayedLeave;
          }, T.delayedLeave = X;
        });
      }
      return o;
    };
  }
}, SS = _A;
function TS(t, e) {
  const { leavingVNodes: n } = t;
  let a = n.get(e.type);
  return a || (a = /* @__PURE__ */ Object.create(null), n.set(e.type, a)), a;
}
function P0(t, e, n, a) {
  const { appear: s, mode: f, persisted: o = !1, onBeforeEnter: m, onEnter: g, onAfterEnter: b, onEnterCancelled: T, onBeforeLeave: M, onLeave: I, onAfterLeave: A, onLeaveCancelled: z, onBeforeAppear: V, onAppear: q, onAfterAppear: re, onAppearCancelled: X } = e, ae = String(t.key), ce = TS(n, t), ve = (Ae, Se) => {
    Ae && Da(Ae, a, 9, Se);
  }, Ne = (Ae, Se) => {
    const Ie = Se[1];
    ve(Ae, Se), er(Ae) ? Ae.every((Xe) => Xe.length <= 1) && Ie() : Ae.length <= 1 && Ie();
  }, ze = {
    mode: f,
    persisted: o,
    beforeEnter(Ae) {
      let Se = m;
      if (!n.isMounted)
        if (s)
          Se = V || m;
        else
          return;
      Ae._leaveCb && Ae._leaveCb(!0);
      const Ie = ce[ae];
      Ie && Vc(t, Ie) && Ie.el._leaveCb && Ie.el._leaveCb(), ve(Se, [Ae]);
    },
    enter(Ae) {
      let Se = g, Ie = b, Xe = T;
      if (!n.isMounted)
        if (s)
          Se = q || g, Ie = re || b, Xe = X || T;
        else
          return;
      let $e = !1;
      const at = Ae._enterCb = (be) => {
        $e || ($e = !0, be ? ve(Xe, [Ae]) : ve(Ie, [Ae]), ze.delayedLeave && ze.delayedLeave(), Ae._enterCb = void 0);
      };
      Se ? Ne(Se, [Ae, at]) : at();
    },
    leave(Ae, Se) {
      const Ie = String(t.key);
      if (Ae._enterCb && Ae._enterCb(!0), n.isUnmounting)
        return Se();
      ve(M, [Ae]);
      let Xe = !1;
      const $e = Ae._leaveCb = (at) => {
        Xe || (Xe = !0, Se(), at ? ve(z, [Ae]) : ve(A, [Ae]), Ae._leaveCb = void 0, ce[Ie] === t && delete ce[Ie]);
      };
      ce[Ie] = t, I ? Ne(I, [Ae, $e]) : $e();
    },
    clone(Ae) {
      return P0(Ae, e, n, a);
    }
  };
  return ze;
}
function L_(t) {
  if (Gd(t))
    return t = Qs(t), t.children = null, t;
}
function Kb(t) {
  return Gd(t) ? t.children ? t.children[0] : void 0 : t;
}
function A0(t, e) {
  t.shapeFlag & 6 && t.component ? A0(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
}
function MS(t, e = !1, n) {
  let a = [], s = 0;
  for (let f = 0; f < t.length; f++) {
    let o = t[f];
    const m = n == null ? o.key : String(n) + String(o.key != null ? o.key : f);
    o.type === on ? (o.patchFlag & 128 && s++, a = a.concat(MS(o.children, e, m))) : (e || o.type !== Xi) && a.push(m != null ? Qs(o, { key: m }) : o);
  }
  if (s > 1)
    for (let f = 0; f < a.length; f++)
      a[f].patchFlag = -2;
  return a;
}
function ir(t) {
  return yr(t) ? { setup: t, name: t.name } : t;
}
const fd = (t) => !!t.type.__asyncLoader, Gd = (t) => t.type.__isKeepAlive;
function xA(t, e) {
  IS(t, "a", e);
}
function bA(t, e) {
  IS(t, "da", e);
}
function IS(t, e, n = di) {
  const a = t.__wdc || (t.__wdc = () => {
    let s = n;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return t();
  });
  if (xv(e, a, n), n) {
    let s = n.parent;
    for (; s && s.parent; )
      Gd(s.parent.vnode) && wA(a, e, n, s), s = s.parent;
  }
}
function wA(t, e, n, a) {
  const s = xv(e, t, a, !0);
  $u(() => {
    wx(a[e], s);
  }, n);
}
function xv(t, e, n = di, a = !1) {
  if (n) {
    const s = n[t] || (n[t] = []), f = e.__weh || (e.__weh = (...o) => {
      if (n.isUnmounted)
        return;
      rh(), Df(n);
      const m = Da(e, n, t, o);
      return Zc(), nh(), m;
    });
    return a ? s.unshift(f) : s.push(f), f;
  } else if (process.env.NODE_ENV !== "production") {
    const s = Nc(Px[t].replace(/ hook$/, ""));
    lt(`${s} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const Hl = (t) => (e, n = di) => (!Ad || t === "sp") && xv(t, (...a) => e(...a), n), EA = Hl("bm"), _a = Hl("m"), SA = Hl("bu"), TA = Hl("u"), OS = Hl("bum"), $u = Hl("um"), MA = Hl("sp"), IA = Hl("rtg"), OA = Hl("rtc");
function CA(t, e = di) {
  xv("ec", t, e);
}
function CS(t) {
  tP(t) && lt("Do not use built-in directive ids as custom directive id: " + t);
}
function Og(t, e) {
  const n = zi;
  if (n === null)
    return process.env.NODE_ENV !== "production" && lt("withDirectives can only be used inside render functions."), t;
  const a = Ev(n) || n.proxy, s = t.dirs || (t.dirs = []);
  for (let f = 0; f < e.length; f++) {
    let [o, m, g, b = wn] = e[f];
    o && (yr(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Gc(m), s.push({
      dir: o,
      instance: a,
      value: m,
      oldValue: void 0,
      arg: g,
      modifiers: b
    }));
  }
  return t;
}
function Tc(t, e, n, a) {
  const s = t.dirs, f = e && e.dirs;
  for (let o = 0; o < s.length; o++) {
    const m = s[o];
    f && (m.oldValue = f[o].value);
    let g = m.dir[a];
    g && (rh(), Da(g, n, 8, [
      t.el,
      m,
      t,
      e
    ]), nh());
  }
}
const k0 = "components", PA = "directives";
function AA(t, e) {
  return PS(k0, t, !0, e) || t;
}
const kA = Symbol();
function Nx(t) {
  return PS(PA, t);
}
function PS(t, e, n = !0, a = !1) {
  const s = zi || di;
  if (s) {
    const f = s.type;
    if (t === k0) {
      const m = Vx(f, !1);
      if (m && (m === e || m === ya(e) || m === Yc(ya(e))))
        return f;
    }
    const o = Yb(s[t] || f[t], e) || Yb(s.appContext[t], e);
    if (!o && a)
      return f;
    if (process.env.NODE_ENV !== "production" && n && !o) {
      const m = t === k0 ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      lt(`Failed to resolve ${t.slice(0, -1)}: ${e}${m}`);
    }
    return o;
  } else
    process.env.NODE_ENV !== "production" && lt(`resolve${Yc(t.slice(0, -1))} can only be used in render() or setup().`);
}
function Yb(t, e) {
  return t && (t[e] || t[ya(e)] || t[Yc(ya(e))]);
}
function Ra(t, e, n, a) {
  let s;
  const f = n && n[a];
  if (er(t) || Hn(t)) {
    s = new Array(t.length);
    for (let o = 0, m = t.length; o < m; o++)
      s[o] = e(t[o], o, void 0, f && f[o]);
  } else if (typeof t == "number") {
    process.env.NODE_ENV !== "production" && !Number.isInteger(t) && lt(`The v-for range expect an integer value but got ${t}.`), s = new Array(t);
    for (let o = 0; o < t; o++)
      s[o] = e(o + 1, o, void 0, f && f[o]);
  } else if (fn(t))
    if (t[Symbol.iterator])
      s = Array.from(t, (o, m) => e(o, m, void 0, f && f[m]));
    else {
      const o = Object.keys(t);
      s = new Array(o.length);
      for (let m = 0, g = o.length; m < g; m++) {
        const b = o[m];
        s[m] = e(t[b], b, m, f && f[m]);
      }
    }
  else
    s = [];
  return n && (n[a] = s), s;
}
function AS(t, e, n = {}, a, s) {
  if (zi.isCE || zi.parent && fd(zi.parent) && zi.parent.isCE)
    return e !== "default" && (n.name = e), kt("slot", n, a && a());
  let f = t[e];
  process.env.NODE_ENV !== "production" && f && f.length > 1 && (lt("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."), f = () => []), f && f._c && (f._d = !1), Be();
  const o = f && kS(f(n)), m = an(on, {
    key: n.key || o && o.key || `_${e}`
  }, o || (a ? a() : []), o && t._ === 1 ? 64 : -2);
  return !s && m.scopeId && (m.slotScopeIds = [m.scopeId + "-s"]), f && f._c && (f._d = !0), m;
}
function kS(t) {
  return t.some((e) => Lf(e) ? !(e.type === Xi || e.type === on && !kS(e.children)) : !0) ? t : null;
}
const L0 = (t) => t ? ZS(t) ? Ev(t) || t.proxy : L0(t.parent) : null, Hc = /* @__PURE__ */ Wn(/* @__PURE__ */ Object.create(null), {
  $: (t) => t,
  $el: (t) => t.vnode.el,
  $data: (t) => t.data,
  $props: (t) => process.env.NODE_ENV !== "production" ? mf(t.props) : t.props,
  $attrs: (t) => process.env.NODE_ENV !== "production" ? mf(t.attrs) : t.attrs,
  $slots: (t) => process.env.NODE_ENV !== "production" ? mf(t.slots) : t.slots,
  $refs: (t) => process.env.NODE_ENV !== "production" ? mf(t.refs) : t.refs,
  $parent: (t) => L0(t.parent),
  $root: (t) => L0(t.root),
  $emit: (t) => t.emit,
  $options: (t) => zx(t),
  $forceUpdate: (t) => t.f || (t.f = () => vv(t.update)),
  $nextTick: (t) => t.n || (t.n = Tg.bind(t.proxy)),
  $watch: (t) => gA.bind(t)
}), Rx = (t) => t === "_" || t === "$", D_ = (t, e) => t !== wn && !t.__isScriptSetup && jr(t, e), LS = {
  get({ _: t }, e) {
    const { ctx: n, setupState: a, data: s, props: f, accessCache: o, type: m, appContext: g } = t;
    if (process.env.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let b;
    if (e[0] !== "$") {
      const A = o[e];
      if (A !== void 0)
        switch (A) {
          case 1:
            return a[e];
          case 2:
            return s[e];
          case 4:
            return n[e];
          case 3:
            return f[e];
        }
      else {
        if (D_(a, e))
          return o[e] = 1, a[e];
        if (s !== wn && jr(s, e))
          return o[e] = 2, s[e];
        if ((b = t.propsOptions[0]) && jr(b, e))
          return o[e] = 3, f[e];
        if (n !== wn && jr(n, e))
          return o[e] = 4, n[e];
        D0 && (o[e] = 0);
      }
    }
    const T = Hc[e];
    let M, I;
    if (T)
      return e === "$attrs" && (Bo(t, "get", e), process.env.NODE_ENV !== "production" && Ig()), T(t);
    if ((M = m.__cssModules) && (M = M[e]))
      return M;
    if (n !== wn && jr(n, e))
      return o[e] = 4, n[e];
    if (I = g.config.globalProperties, jr(I, e))
      return I[e];
    process.env.NODE_ENV !== "production" && zi && (!Hn(e) || e.indexOf("__v") !== 0) && (s !== wn && Rx(e[0]) && jr(s, e) ? lt(`Property ${JSON.stringify(e)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`) : t === zi && lt(`Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`));
  },
  set({ _: t }, e, n) {
    const { data: a, setupState: s, ctx: f } = t;
    return D_(s, e) ? (s[e] = n, !0) : process.env.NODE_ENV !== "production" && s.__isScriptSetup && jr(s, e) ? (lt(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : a !== wn && jr(a, e) ? (a[e] = n, !0) : jr(t.props, e) ? (process.env.NODE_ENV !== "production" && lt(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (process.env.NODE_ENV !== "production" && lt(`Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`), !1) : (process.env.NODE_ENV !== "production" && e in t.appContext.config.globalProperties ? Object.defineProperty(f, e, {
      enumerable: !0,
      configurable: !0,
      value: n
    }) : f[e] = n, !0);
  },
  has({ _: { data: t, setupState: e, accessCache: n, ctx: a, appContext: s, propsOptions: f } }, o) {
    let m;
    return !!n[o] || t !== wn && jr(t, o) || D_(e, o) || (m = f[0]) && jr(m, o) || jr(a, o) || jr(Hc, o) || jr(s.config.globalProperties, o);
  },
  defineProperty(t, e, n) {
    return n.get != null ? t._.accessCache[e] = 0 : jr(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n);
  }
};
process.env.NODE_ENV !== "production" && (LS.ownKeys = (t) => (lt("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."), Reflect.ownKeys(t)));
function LA(t) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => t
  }), Object.keys(Hc).forEach((n) => {
    Object.defineProperty(e, n, {
      configurable: !0,
      enumerable: !1,
      get: () => Hc[n](t),
      set: ao
    });
  }), e;
}
function DA(t) {
  const { ctx: e, propsOptions: [n] } = t;
  n && Object.keys(n).forEach((a) => {
    Object.defineProperty(e, a, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[a],
      set: ao
    });
  });
}
function NA(t) {
  const { ctx: e, setupState: n } = t;
  Object.keys(hr(n)).forEach((a) => {
    if (!n.__isScriptSetup) {
      if (Rx(a[0])) {
        lt(`setup() return property ${JSON.stringify(a)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(e, a, {
        enumerable: !0,
        configurable: !0,
        get: () => n[a],
        set: ao
      });
    }
  });
}
function RA() {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, n) => {
    t[n] ? lt(`${e} property "${n}" is already defined in ${t[n]}.`) : t[n] = e;
  };
}
let D0 = !0;
function zA(t) {
  const e = zx(t), n = t.proxy, a = t.ctx;
  D0 = !1, e.beforeCreate && Jb(e.beforeCreate, t, "bc");
  const {
    data: s,
    computed: f,
    methods: o,
    watch: m,
    provide: g,
    inject: b,
    created: T,
    beforeMount: M,
    mounted: I,
    beforeUpdate: A,
    updated: z,
    activated: V,
    deactivated: q,
    beforeDestroy: re,
    beforeUnmount: X,
    destroyed: ae,
    unmounted: ce,
    render: ve,
    renderTracked: Ne,
    renderTriggered: ze,
    errorCaptured: Ae,
    serverPrefetch: Se,
    expose: Ie,
    inheritAttrs: Xe,
    components: $e,
    directives: at,
    filters: be
  } = e, Je = process.env.NODE_ENV !== "production" ? RA() : null;
  if (process.env.NODE_ENV !== "production") {
    const [vt] = t.propsOptions;
    if (vt)
      for (const At in vt)
        Je("Props", At);
  }
  if (b && FA(b, a, Je, t.appContext.config.unwrapInjectedRef), o)
    for (const vt in o) {
      const At = o[vt];
      yr(At) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(a, vt, {
        value: At.bind(n),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : a[vt] = At.bind(n), process.env.NODE_ENV !== "production" && Je("Methods", vt)) : process.env.NODE_ENV !== "production" && lt(`Method "${vt}" has type "${typeof At}" in the component definition. Did you reference the function correctly?`);
    }
  if (s) {
    process.env.NODE_ENV !== "production" && !yr(s) && lt("The data option must be a function. Plain object usage is no longer supported.");
    const vt = s.call(n, n);
    if (process.env.NODE_ENV !== "production" && Sx(vt) && lt("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."), !fn(vt))
      process.env.NODE_ENV !== "production" && lt("data() should return an object.");
    else if (t.data = mv(vt), process.env.NODE_ENV !== "production")
      for (const At in vt)
        Je("Data", At), Rx(At[0]) || Object.defineProperty(a, At, {
          configurable: !0,
          enumerable: !0,
          get: () => vt[At],
          set: ao
        });
  }
  if (D0 = !0, f)
    for (const vt in f) {
      const At = f[vt], tr = yr(At) ? At.bind(n, n) : yr(At.get) ? At.get.bind(n, n) : ao;
      process.env.NODE_ENV !== "production" && tr === ao && lt(`Computed property "${vt}" has no getter.`);
      const kn = !yr(At) && yr(At.set) ? At.set.bind(n) : process.env.NODE_ENV !== "production" ? () => {
        lt(`Write operation failed: computed property "${vt}" is readonly.`);
      } : ao, Nr = ar({
        get: tr,
        set: kn
      });
      Object.defineProperty(a, vt, {
        enumerable: !0,
        configurable: !0,
        get: () => Nr.value,
        set: (pr) => Nr.value = pr
      }), process.env.NODE_ENV !== "production" && Je("Computed", vt);
    }
  if (m)
    for (const vt in m)
      DS(m[vt], a, n, vt);
  if (g) {
    const vt = yr(g) ? g.call(n) : g;
    Reflect.ownKeys(vt).forEach((At) => {
      wS(At, vt[At]);
    });
  }
  T && Jb(T, t, "c");
  function ht(vt, At) {
    er(At) ? At.forEach((tr) => vt(tr.bind(n))) : At && vt(At.bind(n));
  }
  if (ht(EA, M), ht(_a, I), ht(SA, A), ht(TA, z), ht(xA, V), ht(bA, q), ht(CA, Ae), ht(OA, Ne), ht(IA, ze), ht(OS, X), ht($u, ce), ht(MA, Se), er(Ie))
    if (Ie.length) {
      const vt = t.exposed || (t.exposed = {});
      Ie.forEach((At) => {
        Object.defineProperty(vt, At, {
          get: () => n[At],
          set: (tr) => n[At] = tr
        });
      });
    } else
      t.exposed || (t.exposed = {});
  ve && t.render === ao && (t.render = ve), Xe != null && (t.inheritAttrs = Xe), $e && (t.components = $e), at && (t.directives = at);
}
function FA(t, e, n = ao, a = !1) {
  er(t) && (t = N0(t));
  for (const s in t) {
    const f = t[s];
    let o;
    fn(f) ? "default" in f ? o = Sf(f.from || s, f.default, !0) : o = Sf(f.from || s) : o = Sf(f), hn(o) ? a ? Object.defineProperty(e, s, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (m) => o.value = m
    }) : (process.env.NODE_ENV !== "production" && lt(`injected property "${s}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`), e[s] = o) : e[s] = o, process.env.NODE_ENV !== "production" && n("Inject", s);
  }
}
function Jb(t, e, n) {
  Da(er(t) ? t.map((a) => a.bind(e.proxy)) : t.bind(e.proxy), e, n);
}
function DS(t, e, n, a) {
  const s = a.includes(".") ? ES(n, a) : () => n[a];
  if (Hn(t)) {
    const f = e[t];
    yr(f) ? An(s, f) : process.env.NODE_ENV !== "production" && lt(`Invalid watch handler specified by key "${t}"`, f);
  } else if (yr(t))
    An(s, t.bind(n));
  else if (fn(t))
    if (er(t))
      t.forEach((f) => DS(f, e, n, a));
    else {
      const f = yr(t.handler) ? t.handler.bind(n) : e[t.handler];
      yr(f) ? An(s, f, t) : process.env.NODE_ENV !== "production" && lt(`Invalid watch handler specified by key "${t.handler}"`, f);
    }
  else
    process.env.NODE_ENV !== "production" && lt(`Invalid watch option: "${a}"`, t);
}
function zx(t) {
  const e = t.type, { mixins: n, extends: a } = e, { mixins: s, optionsCache: f, config: { optionMergeStrategies: o } } = t.appContext, m = f.get(e);
  let g;
  return m ? g = m : !s.length && !n && !a ? g = e : (g = {}, s.length && s.forEach((b) => Cg(g, b, o, !0)), Cg(g, e, o)), fn(e) && f.set(e, g), g;
}
function Cg(t, e, n, a = !1) {
  const { mixins: s, extends: f } = e;
  f && Cg(t, f, n, !0), s && s.forEach((o) => Cg(t, o, n, !0));
  for (const o in e)
    if (a && o === "expose")
      process.env.NODE_ENV !== "production" && lt('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');
    else {
      const m = BA[o] || n && n[o];
      t[o] = m ? m(t[o], e[o]) : e[o];
    }
  return t;
}
const BA = {
  data: Qb,
  props: Rc,
  emits: Rc,
  methods: Rc,
  computed: Rc,
  beforeCreate: ko,
  created: ko,
  beforeMount: ko,
  mounted: ko,
  beforeUpdate: ko,
  updated: ko,
  beforeDestroy: ko,
  beforeUnmount: ko,
  destroyed: ko,
  unmounted: ko,
  activated: ko,
  deactivated: ko,
  errorCaptured: ko,
  serverPrefetch: ko,
  components: Rc,
  directives: Rc,
  watch: UA,
  provide: Qb,
  inject: VA
};
function Qb(t, e) {
  return e ? t ? function() {
    return Wn(yr(t) ? t.call(this, this) : t, yr(e) ? e.call(this, this) : e);
  } : e : t;
}
function VA(t, e) {
  return Rc(N0(t), N0(e));
}
function N0(t) {
  if (er(t)) {
    const e = {};
    for (let n = 0; n < t.length; n++)
      e[t[n]] = t[n];
    return e;
  }
  return t;
}
function ko(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function Rc(t, e) {
  return t ? Wn(Wn(/* @__PURE__ */ Object.create(null), t), e) : e;
}
function UA(t, e) {
  if (!t)
    return e;
  if (!e)
    return t;
  const n = Wn(/* @__PURE__ */ Object.create(null), t);
  for (const a in e)
    n[a] = ko(t[a], e[a]);
  return n;
}
function jA(t, e, n, a = !1) {
  const s = {}, f = {};
  xg(f, bv, 1), t.propsDefaults = /* @__PURE__ */ Object.create(null), NS(t, e, s, f);
  for (const o in t.propsOptions[0])
    o in s || (s[o] = void 0);
  process.env.NODE_ENV !== "production" && zS(e || {}, s, t), n ? t.props = a ? s : NP(s) : t.type.props ? t.props = s : t.props = f, t.attrs = f;
}
function GA(t) {
  for (; t; ) {
    if (t.type.__hmrId)
      return !0;
    t = t.parent;
  }
}
function $A(t, e, n, a) {
  const { props: s, attrs: f, vnode: { patchFlag: o } } = t, m = hr(s), [g] = t.propsOptions;
  let b = !1;
  if (!(process.env.NODE_ENV !== "production" && GA(t)) && (a || o > 0) && !(o & 16)) {
    if (o & 8) {
      const T = t.vnode.dynamicProps;
      for (let M = 0; M < T.length; M++) {
        let I = T[M];
        if (_v(t.emitsOptions, I))
          continue;
        const A = e[I];
        if (g)
          if (jr(f, I))
            A !== f[I] && (f[I] = A, b = !0);
          else {
            const z = ya(I);
            s[z] = R0(g, m, z, A, t, !1);
          }
        else
          A !== f[I] && (f[I] = A, b = !0);
      }
    }
  } else {
    NS(t, e, s, f) && (b = !0);
    let T;
    for (const M in m)
      (!e || !jr(e, M) && ((T = ta(M)) === M || !jr(e, T))) && (g ? n && (n[M] !== void 0 || n[T] !== void 0) && (s[M] = R0(g, m, M, void 0, t, !0)) : delete s[M]);
    if (f !== m)
      for (const M in f)
        (!e || !jr(e, M) && !0) && (delete f[M], b = !0);
  }
  b && Gl(t, "set", "$attrs"), process.env.NODE_ENV !== "production" && zS(e || {}, s, t);
}
function NS(t, e, n, a) {
  const [s, f] = t.propsOptions;
  let o = !1, m;
  if (e)
    for (let g in e) {
      if (Yy(g))
        continue;
      const b = e[g];
      let T;
      s && jr(s, T = ya(g)) ? !f || !f.includes(T) ? n[T] = b : (m || (m = {}))[T] = b : _v(t.emitsOptions, g) || (!(g in a) || b !== a[g]) && (a[g] = b, o = !0);
    }
  if (f) {
    const g = hr(n), b = m || wn;
    for (let T = 0; T < f.length; T++) {
      const M = f[T];
      n[M] = R0(s, g, M, b[M], t, !jr(b, M));
    }
  }
  return o;
}
function R0(t, e, n, a, s, f) {
  const o = t[n];
  if (o != null) {
    const m = jr(o, "default");
    if (m && a === void 0) {
      const g = o.default;
      if (o.type !== Function && yr(g)) {
        const { propsDefaults: b } = s;
        n in b ? a = b[n] : (Df(s), a = b[n] = g.call(null, e), Zc());
      } else
        a = g;
    }
    o[0] && (f && !m ? a = !1 : o[1] && (a === "" || a === ta(n)) && (a = !0));
  }
  return a;
}
function RS(t, e, n = !1) {
  const a = e.propsCache, s = a.get(t);
  if (s)
    return s;
  const f = t.props, o = {}, m = [];
  let g = !1;
  if (!yr(t)) {
    const T = (M) => {
      g = !0;
      const [I, A] = RS(M, e, !0);
      Wn(o, I), A && m.push(...A);
    };
    !n && e.mixins.length && e.mixins.forEach(T), t.extends && T(t.extends), t.mixins && t.mixins.forEach(T);
  }
  if (!f && !g)
    return fn(t) && a.set(t, wf), wf;
  if (er(f))
    for (let T = 0; T < f.length; T++) {
      process.env.NODE_ENV !== "production" && !Hn(f[T]) && lt("props must be strings when using array syntax.", f[T]);
      const M = ya(f[T]);
      ew(M) && (o[M] = wn);
    }
  else if (f) {
    process.env.NODE_ENV !== "production" && !fn(f) && lt("invalid props options", f);
    for (const T in f) {
      const M = ya(T);
      if (ew(M)) {
        const I = f[T], A = o[M] = er(I) || yr(I) ? { type: I } : Object.assign({}, I);
        if (A) {
          const z = rw(Boolean, A.type), V = rw(String, A.type);
          A[0] = z > -1, A[1] = V < 0 || z < V, (z > -1 || jr(A, "default")) && m.push(M);
        }
      }
    }
  }
  const b = [o, m];
  return fn(t) && a.set(t, b), b;
}
function ew(t) {
  return t[0] !== "$" ? !0 : (process.env.NODE_ENV !== "production" && lt(`Invalid prop name: "${t}" is a reserved property.`), !1);
}
function z0(t) {
  const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : t === null ? "null" : "";
}
function tw(t, e) {
  return z0(t) === z0(e);
}
function rw(t, e) {
  return er(e) ? e.findIndex((n) => tw(n, t)) : yr(e) && tw(e, t) ? 0 : -1;
}
function zS(t, e, n) {
  const a = hr(e), s = n.propsOptions[0];
  for (const f in s) {
    let o = s[f];
    o != null && qA(f, a[f], o, !jr(t, f) && !jr(t, ta(f)));
  }
}
function qA(t, e, n, a) {
  const { type: s, required: f, validator: o } = n;
  if (f && a) {
    lt('Missing required prop: "' + t + '"');
    return;
  }
  if (!(e == null && !n.required)) {
    if (s != null && s !== !0) {
      let m = !1;
      const g = er(s) ? s : [s], b = [];
      for (let T = 0; T < g.length && !m; T++) {
        const { valid: M, expectedType: I } = HA(e, g[T]);
        b.push(I || ""), m = M;
      }
      if (!m) {
        lt(ZA(t, e, b));
        return;
      }
    }
    o && !o(e) && lt('Invalid prop: custom validator check failed for prop "' + t + '".');
  }
}
const WA = /* @__PURE__ */ ju("String,Number,Boolean,Function,Symbol,BigInt");
function HA(t, e) {
  let n;
  const a = z0(e);
  if (WA(a)) {
    const s = typeof t;
    n = s === a.toLowerCase(), !n && s === "object" && (n = t instanceof e);
  } else
    a === "Object" ? n = fn(t) : a === "Array" ? n = er(t) : a === "null" ? n = t === null : n = t instanceof e;
  return {
    valid: n,
    expectedType: a
  };
}
function ZA(t, e, n) {
  let a = `Invalid prop: type check failed for prop "${t}". Expected ${n.map(Yc).join(" | ")}`;
  const s = n[0], f = Tx(e), o = nw(e, s), m = nw(e, f);
  return n.length === 1 && iw(s) && !XA(s, f) && (a += ` with value ${o}`), a += `, got ${f} `, iw(f) && (a += `with value ${m}.`), a;
}
function nw(t, e) {
  return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`;
}
function iw(t) {
  return ["string", "number", "boolean"].some((n) => t.toLowerCase() === n);
}
function XA(...t) {
  return t.some((e) => e.toLowerCase() === "boolean");
}
const FS = (t) => t[0] === "_" || t === "$stable", Fx = (t) => er(t) ? t.map(rs) : [rs(t)], KA = (t, e, n) => {
  if (e._n)
    return e;
  const a = ku((...s) => (process.env.NODE_ENV !== "production" && di && lt(`Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`), Fx(e(...s))), n);
  return a._c = !1, a;
}, BS = (t, e, n) => {
  const a = t._ctx;
  for (const s in t) {
    if (FS(s))
      continue;
    const f = t[s];
    if (yr(f))
      e[s] = KA(s, f, a);
    else if (f != null) {
      process.env.NODE_ENV !== "production" && lt(`Non-function value encountered for slot "${s}". Prefer function slots for better performance.`);
      const o = Fx(f);
      e[s] = () => o;
    }
  }
}, VS = (t, e) => {
  process.env.NODE_ENV !== "production" && !Gd(t.vnode) && lt("Non-function value encountered for default slot. Prefer function slots for better performance.");
  const n = Fx(e);
  t.slots.default = () => n;
}, YA = (t, e) => {
  if (t.vnode.shapeFlag & 32) {
    const n = e._;
    n ? (t.slots = hr(e), xg(e, "_", n)) : BS(e, t.slots = {});
  } else
    t.slots = {}, e && VS(t, e);
  xg(t.slots, bv, 1);
}, JA = (t, e, n) => {
  const { vnode: a, slots: s } = t;
  let f = !0, o = wn;
  if (a.shapeFlag & 32) {
    const m = e._;
    m ? process.env.NODE_ENV !== "production" && Au ? Wn(s, e) : n && m === 1 ? f = !1 : (Wn(s, e), !n && m === 1 && delete s._) : (f = !e.$stable, BS(e, s)), o = e;
  } else
    e && (VS(t, e), o = { default: 1 });
  if (f)
    for (const m in s)
      !FS(m) && !(m in o) && delete s[m];
};
function US() {
  return {
    app: null,
    config: {
      isNativeTag: zE,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let QA = 0;
function ek(t, e) {
  return function(a, s = null) {
    yr(a) || (a = Object.assign({}, a)), s != null && !fn(s) && (process.env.NODE_ENV !== "production" && lt("root props passed to app.mount() must be an object."), s = null);
    const f = US(), o = /* @__PURE__ */ new Set();
    let m = !1;
    const g = f.app = {
      _uid: QA++,
      _component: a,
      _props: s,
      _container: null,
      _context: f,
      _instance: null,
      version: uw,
      get config() {
        return f.config;
      },
      set config(b) {
        process.env.NODE_ENV !== "production" && lt("app.config cannot be replaced. Modify individual options instead.");
      },
      use(b, ...T) {
        return o.has(b) ? process.env.NODE_ENV !== "production" && lt("Plugin has already been applied to target app.") : b && yr(b.install) ? (o.add(b), b.install(g, ...T)) : yr(b) ? (o.add(b), b(g, ...T)) : process.env.NODE_ENV !== "production" && lt('A plugin must either be a function or an object with an "install" function.'), g;
      },
      mixin(b) {
        return f.mixins.includes(b) ? process.env.NODE_ENV !== "production" && lt("Mixin has already been applied to target app" + (b.name ? `: ${b.name}` : "")) : f.mixins.push(b), g;
      },
      component(b, T) {
        return process.env.NODE_ENV !== "production" && V0(b, f.config), T ? (process.env.NODE_ENV !== "production" && f.components[b] && lt(`Component "${b}" has already been registered in target app.`), f.components[b] = T, g) : f.components[b];
      },
      directive(b, T) {
        return process.env.NODE_ENV !== "production" && CS(b), T ? (process.env.NODE_ENV !== "production" && f.directives[b] && lt(`Directive "${b}" has already been registered in target app.`), f.directives[b] = T, g) : f.directives[b];
      },
      mount(b, T, M) {
        if (m)
          process.env.NODE_ENV !== "production" && lt("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
        else {
          process.env.NODE_ENV !== "production" && b.__vue_app__ && lt("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");
          const I = kt(a, s);
          return I.appContext = f, process.env.NODE_ENV !== "production" && (f.reload = () => {
            t(Qs(I), b, M);
          }), T && e ? e(I, b) : t(I, b, M), m = !0, g._container = b, b.__vue_app__ = g, process.env.NODE_ENV !== "production" && (g._instance = I.component, tA(g, uw)), Ev(I.component) || I.component.proxy;
        }
      },
      unmount() {
        m ? (t(null, g._container), process.env.NODE_ENV !== "production" && (g._instance = null, rA(g)), delete g._container.__vue_app__) : process.env.NODE_ENV !== "production" && lt("Cannot unmount an app that is not mounted.");
      },
      provide(b, T) {
        return process.env.NODE_ENV !== "production" && b in f.provides && lt(`App already provides property with key "${String(b)}". It will be overwritten with the new value.`), f.provides[b] = T, g;
      }
    };
    return g;
  };
}
function F0(t, e, n, a, s = !1) {
  if (er(t)) {
    t.forEach((I, A) => F0(I, e && (er(e) ? e[A] : e), n, a, s));
    return;
  }
  if (fd(a) && !s)
    return;
  const f = a.shapeFlag & 4 ? Ev(a.component) || a.component.proxy : a.el, o = s ? null : f, { i: m, r: g } = t;
  if (process.env.NODE_ENV !== "production" && !m) {
    lt("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");
    return;
  }
  const b = e && e.r, T = m.refs === wn ? m.refs = {} : m.refs, M = m.setupState;
  if (b != null && b !== g && (Hn(b) ? (T[b] = null, jr(M, b) && (M[b] = null)) : hn(b) && (b.value = null)), yr(g))
    Bl(g, m, 12, [o, T]);
  else {
    const I = Hn(g), A = hn(g);
    if (I || A) {
      const z = () => {
        if (t.f) {
          const V = I ? jr(M, g) ? M[g] : T[g] : g.value;
          s ? er(V) && wx(V, f) : er(V) ? V.includes(f) || V.push(f) : I ? (T[g] = [f], jr(M, g) && (M[g] = T[g])) : (g.value = [f], t.k && (T[t.k] = g.value));
        } else
          I ? (T[g] = o, jr(M, g) && (M[g] = o)) : A ? (g.value = o, t.k && (T[t.k] = o)) : process.env.NODE_ENV !== "production" && lt("Invalid template ref type:", g, `(${typeof g})`);
      };
      o ? (z.id = -1, ea(z, n)) : z();
    } else
      process.env.NODE_ENV !== "production" && lt("Invalid template ref type:", g, `(${typeof g})`);
  }
}
let Gp, Tu;
function Nl(t, e) {
  t.appContext.config.performance && Pg() && Tu.mark(`vue-${e}-${t.uid}`), process.env.NODE_ENV !== "production" && aA(t, e, Pg() ? Tu.now() : Date.now());
}
function Rl(t, e) {
  if (t.appContext.config.performance && Pg()) {
    const n = `vue-${e}-${t.uid}`, a = n + ":end";
    Tu.mark(a), Tu.measure(`<${Sv(t, t.type)}> ${e}`, n, a), Tu.clearMarks(n), Tu.clearMarks(a);
  }
  process.env.NODE_ENV !== "production" && sA(t, e, Pg() ? Tu.now() : Date.now());
}
function Pg() {
  return Gp !== void 0 || (typeof window < "u" && window.performance ? (Gp = !0, Tu = window.performance) : Gp = !1), Gp;
}
function tk() {
  const t = [];
  if (process.env.NODE_ENV !== "production" && t.length) {
    const e = t.length > 1;
    console.warn(`Feature flag${e ? "s" : ""} ${t.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const ea = yA;
function rk(t) {
  return nk(t);
}
function nk(t, e) {
  tk();
  const n = UE();
  n.__VUE__ = !0, process.env.NODE_ENV !== "production" && yS(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
  const { insert: a, remove: s, patchProp: f, createElement: o, createText: m, createComment: g, setText: b, setElementText: T, parentNode: M, nextSibling: I, setScopeId: A = ao, insertStaticContent: z } = t, V = (K, ye, Re, qe = null, We = null, nt = null, mt = !1, et = null, ut = process.env.NODE_ENV !== "production" && Au ? !1 : !!ye.dynamicChildren) => {
    if (K === ye)
      return;
    K && !Vc(K, ye) && (qe = Vn(K), Zn(K, We, nt, !0), K = null), ye.patchFlag === -2 && (ut = !1, ye.dynamicChildren = null);
    const { type: Qe, ref: It, shapeFlag: bt } = ye;
    switch (Qe) {
      case $d:
        q(K, ye, Re, qe);
        break;
      case Xi:
        re(K, ye, Re, qe);
        break;
      case eg:
        K == null ? X(ye, Re, qe, mt) : process.env.NODE_ENV !== "production" && ae(K, ye, Re, mt);
        break;
      case on:
        at(K, ye, Re, qe, We, nt, mt, et, ut);
        break;
      default:
        bt & 1 ? Ne(K, ye, Re, qe, We, nt, mt, et, ut) : bt & 6 ? be(K, ye, Re, qe, We, nt, mt, et, ut) : bt & 64 || bt & 128 ? Qe.process(K, ye, Re, qe, We, nt, mt, et, ut, Sn) : process.env.NODE_ENV !== "production" && lt("Invalid VNode type:", Qe, `(${typeof Qe})`);
    }
    It != null && We && F0(It, K && K.ref, nt, ye || K, !ye);
  }, q = (K, ye, Re, qe) => {
    if (K == null)
      a(ye.el = m(ye.children), Re, qe);
    else {
      const We = ye.el = K.el;
      ye.children !== K.children && b(We, ye.children);
    }
  }, re = (K, ye, Re, qe) => {
    K == null ? a(ye.el = g(ye.children || ""), Re, qe) : ye.el = K.el;
  }, X = (K, ye, Re, qe) => {
    [K.el, K.anchor] = z(K.children, ye, Re, qe, K.el, K.anchor);
  }, ae = (K, ye, Re, qe) => {
    if (ye.children !== K.children) {
      const We = I(K.anchor);
      ve(K), [ye.el, ye.anchor] = z(ye.children, Re, We, qe);
    } else
      ye.el = K.el, ye.anchor = K.anchor;
  }, ce = ({ el: K, anchor: ye }, Re, qe) => {
    let We;
    for (; K && K !== ye; )
      We = I(K), a(K, Re, qe), K = We;
    a(ye, Re, qe);
  }, ve = ({ el: K, anchor: ye }) => {
    let Re;
    for (; K && K !== ye; )
      Re = I(K), s(K), K = Re;
    s(ye);
  }, Ne = (K, ye, Re, qe, We, nt, mt, et, ut) => {
    mt = mt || ye.type === "svg", K == null ? ze(ye, Re, qe, We, nt, mt, et, ut) : Ie(K, ye, We, nt, mt, et, ut);
  }, ze = (K, ye, Re, qe, We, nt, mt, et) => {
    let ut, Qe;
    const { type: It, props: bt, shapeFlag: Lt, transition: Ut, dirs: dr } = K;
    if (ut = K.el = o(K.type, nt, bt && bt.is, bt), Lt & 8 ? T(ut, K.children) : Lt & 16 && Se(K.children, ut, null, qe, We, nt && It !== "foreignObject", mt, et), dr && Tc(K, null, qe, "created"), Ae(ut, K, K.scopeId, mt, qe), bt) {
      for (const kr in bt)
        kr !== "value" && !Yy(kr) && f(ut, kr, null, bt[kr], nt, K.children, qe, We, Ar);
      "value" in bt && f(ut, "value", null, bt.value), (Qe = bt.onVnodeBeforeMount) && Rs(Qe, qe, K);
    }
    process.env.NODE_ENV !== "production" && (Object.defineProperty(ut, "__vnode", {
      value: K,
      enumerable: !1
    }), Object.defineProperty(ut, "__vueParentComponent", {
      value: qe,
      enumerable: !1
    })), dr && Tc(K, null, qe, "beforeMount");
    const Vr = (!We || We && !We.pendingBranch) && Ut && !Ut.persisted;
    Vr && Ut.beforeEnter(ut), a(ut, ye, Re), ((Qe = bt && bt.onVnodeMounted) || Vr || dr) && ea(() => {
      Qe && Rs(Qe, qe, K), Vr && Ut.enter(ut), dr && Tc(K, null, qe, "mounted");
    }, We);
  }, Ae = (K, ye, Re, qe, We) => {
    if (Re && A(K, Re), qe)
      for (let nt = 0; nt < qe.length; nt++)
        A(K, qe[nt]);
    if (We) {
      let nt = We.subTree;
      if (process.env.NODE_ENV !== "production" && nt.patchFlag > 0 && nt.patchFlag & 2048 && (nt = bS(nt.children) || nt), ye === nt) {
        const mt = We.vnode;
        Ae(K, mt, mt.scopeId, mt.slotScopeIds, We.parent);
      }
    }
  }, Se = (K, ye, Re, qe, We, nt, mt, et, ut = 0) => {
    for (let Qe = ut; Qe < K.length; Qe++) {
      const It = K[Qe] = et ? wu(K[Qe]) : rs(K[Qe]);
      V(null, It, ye, Re, qe, We, nt, mt, et);
    }
  }, Ie = (K, ye, Re, qe, We, nt, mt) => {
    const et = ye.el = K.el;
    let { patchFlag: ut, dynamicChildren: Qe, dirs: It } = ye;
    ut |= K.patchFlag & 16;
    const bt = K.props || wn, Lt = ye.props || wn;
    let Ut;
    Re && Mc(Re, !1), (Ut = Lt.onVnodeBeforeUpdate) && Rs(Ut, Re, ye, K), It && Tc(ye, K, Re, "beforeUpdate"), Re && Mc(Re, !0), process.env.NODE_ENV !== "production" && Au && (ut = 0, mt = !1, Qe = null);
    const dr = We && ye.type !== "foreignObject";
    if (Qe ? (Xe(K.dynamicChildren, Qe, et, Re, qe, dr, nt), process.env.NODE_ENV !== "production" && Re && Re.type.__hmrId && pd(K, ye)) : mt || tr(K, ye, et, null, Re, qe, dr, nt, !1), ut > 0) {
      if (ut & 16)
        $e(et, ye, bt, Lt, Re, qe, We);
      else if (ut & 2 && bt.class !== Lt.class && f(et, "class", null, Lt.class, We), ut & 4 && f(et, "style", bt.style, Lt.style, We), ut & 8) {
        const Vr = ye.dynamicProps;
        for (let kr = 0; kr < Vr.length; kr++) {
          const Jr = Vr[kr], Xn = bt[Jr], Bi = Lt[Jr];
          (Bi !== Xn || Jr === "value") && f(et, Jr, Xn, Bi, We, K.children, Re, qe, Ar);
        }
      }
      ut & 1 && K.children !== ye.children && T(et, ye.children);
    } else
      !mt && Qe == null && $e(et, ye, bt, Lt, Re, qe, We);
    ((Ut = Lt.onVnodeUpdated) || It) && ea(() => {
      Ut && Rs(Ut, Re, ye, K), It && Tc(ye, K, Re, "updated");
    }, qe);
  }, Xe = (K, ye, Re, qe, We, nt, mt) => {
    for (let et = 0; et < ye.length; et++) {
      const ut = K[et], Qe = ye[et], It = ut.el && (ut.type === on || !Vc(ut, Qe) || ut.shapeFlag & 70) ? M(ut.el) : Re;
      V(ut, Qe, It, null, qe, We, nt, mt, !0);
    }
  }, $e = (K, ye, Re, qe, We, nt, mt) => {
    if (Re !== qe) {
      if (Re !== wn)
        for (const et in Re)
          !Yy(et) && !(et in qe) && f(K, et, Re[et], null, mt, ye.children, We, nt, Ar);
      for (const et in qe) {
        if (Yy(et))
          continue;
        const ut = qe[et], Qe = Re[et];
        ut !== Qe && et !== "value" && f(K, et, Qe, ut, mt, ye.children, We, nt, Ar);
      }
      "value" in qe && f(K, "value", Re.value, qe.value);
    }
  }, at = (K, ye, Re, qe, We, nt, mt, et, ut) => {
    const Qe = ye.el = K ? K.el : m(""), It = ye.anchor = K ? K.anchor : m("");
    let { patchFlag: bt, dynamicChildren: Lt, slotScopeIds: Ut } = ye;
    process.env.NODE_ENV !== "production" && (Au || bt & 2048) && (bt = 0, ut = !1, Lt = null), Ut && (et = et ? et.concat(Ut) : Ut), K == null ? (a(Qe, Re, qe), a(It, Re, qe), Se(ye.children, Re, It, We, nt, mt, et, ut)) : bt > 0 && bt & 64 && Lt && K.dynamicChildren ? (Xe(K.dynamicChildren, Lt, Re, We, nt, mt, et), process.env.NODE_ENV !== "production" && We && We.type.__hmrId ? pd(K, ye) : (ye.key != null || We && ye === We.subTree) && pd(K, ye, !0)) : tr(K, ye, Re, It, We, nt, mt, et, ut);
  }, be = (K, ye, Re, qe, We, nt, mt, et, ut) => {
    ye.slotScopeIds = et, K == null ? ye.shapeFlag & 512 ? We.ctx.activate(ye, Re, qe, mt, ut) : Je(ye, Re, qe, We, nt, mt, ut) : ht(K, ye, ut);
  }, Je = (K, ye, Re, qe, We, nt, mt) => {
    const et = K.component = dk(K, qe, We);
    if (process.env.NODE_ENV !== "production" && et.type.__hmrId && YP(et), process.env.NODE_ENV !== "production" && (Jy(K), Nl(et, "mount")), Gd(K) && (et.ctx.renderer = Sn), process.env.NODE_ENV !== "production" && Nl(et, "init"), yk(et), process.env.NODE_ENV !== "production" && Rl(et, "init"), et.asyncDep) {
      if (We && We.registerDep(et, vt), !K.el) {
        const ut = et.subTree = kt(Xi);
        re(null, ut, ye, Re);
      }
      return;
    }
    vt(et, K, ye, Re, We, nt, mt), process.env.NODE_ENV !== "production" && (Qy(), Rl(et, "mount"));
  }, ht = (K, ye, Re) => {
    const qe = ye.component = K.component;
    if (pA(K, ye, Re))
      if (qe.asyncDep && !qe.asyncResolved) {
        process.env.NODE_ENV !== "production" && Jy(ye), At(qe, ye, Re), process.env.NODE_ENV !== "production" && Qy();
        return;
      } else
        qe.next = ye, XP(qe.update), qe.update();
    else
      ye.el = K.el, qe.vnode = ye;
  }, vt = (K, ye, Re, qe, We, nt, mt) => {
    const et = () => {
      if (K.isMounted) {
        let { next: It, bu: bt, u: Lt, parent: Ut, vnode: dr } = K, Vr = It, kr;
        process.env.NODE_ENV !== "production" && Jy(It || K.vnode), Mc(K, !1), It ? (It.el = dr.el, At(K, It, mt)) : It = dr, bt && jp(bt), (kr = It.props && It.props.onVnodeBeforeUpdate) && Rs(kr, Ut, It, dr), Mc(K, !0), process.env.NODE_ENV !== "production" && Nl(K, "render");
        const Jr = k_(K);
        process.env.NODE_ENV !== "production" && Rl(K, "render");
        const Xn = K.subTree;
        K.subTree = Jr, process.env.NODE_ENV !== "production" && Nl(K, "patch"), V(
          Xn,
          Jr,
          M(Xn.el),
          Vn(Xn),
          K,
          We,
          nt
        ), process.env.NODE_ENV !== "production" && Rl(K, "patch"), It.el = Jr.el, Vr === null && dA(K, Jr.el), Lt && ea(Lt, We), (kr = It.props && It.props.onVnodeUpdated) && ea(() => Rs(kr, Ut, It, dr), We), process.env.NODE_ENV !== "production" && gS(K), process.env.NODE_ENV !== "production" && Qy();
      } else {
        let It;
        const { el: bt, props: Lt } = ye, { bm: Ut, m: dr, parent: Vr } = K, kr = fd(ye);
        if (Mc(K, !1), Ut && jp(Ut), !kr && (It = Lt && Lt.onVnodeBeforeMount) && Rs(It, Vr, ye), Mc(K, !0), bt && Un) {
          const Jr = () => {
            process.env.NODE_ENV !== "production" && Nl(K, "render"), K.subTree = k_(K), process.env.NODE_ENV !== "production" && Rl(K, "render"), process.env.NODE_ENV !== "production" && Nl(K, "hydrate"), Un(bt, K.subTree, K, We, null), process.env.NODE_ENV !== "production" && Rl(K, "hydrate");
          };
          kr ? ye.type.__asyncLoader().then(
            () => !K.isUnmounted && Jr()
          ) : Jr();
        } else {
          process.env.NODE_ENV !== "production" && Nl(K, "render");
          const Jr = K.subTree = k_(K);
          process.env.NODE_ENV !== "production" && Rl(K, "render"), process.env.NODE_ENV !== "production" && Nl(K, "patch"), V(null, Jr, Re, qe, K, We, nt), process.env.NODE_ENV !== "production" && Rl(K, "patch"), ye.el = Jr.el;
        }
        if (dr && ea(dr, We), !kr && (It = Lt && Lt.onVnodeMounted)) {
          const Jr = ye;
          ea(() => Rs(It, Vr, Jr), We);
        }
        (ye.shapeFlag & 256 || Vr && fd(Vr.vnode) && Vr.vnode.shapeFlag & 256) && K.a && ea(K.a, We), K.isMounted = !0, process.env.NODE_ENV !== "production" && nA(K), ye = Re = qe = null;
      }
    }, ut = K.effect = new Ix(
      et,
      () => vv(Qe),
      K.scope
    ), Qe = K.update = () => ut.run();
    Qe.id = K.uid, Mc(K, !0), process.env.NODE_ENV !== "production" && (ut.onTrack = K.rtc ? (It) => jp(K.rtc, It) : void 0, ut.onTrigger = K.rtg ? (It) => jp(K.rtg, It) : void 0, Qe.ownerInstance = K), Qe();
  }, At = (K, ye, Re) => {
    ye.component = K;
    const qe = K.vnode.props;
    K.vnode = ye, K.next = null, $A(K, ye.props, qe, Re), JA(K, ye.children, Re), rh(), Wb(), nh();
  }, tr = (K, ye, Re, qe, We, nt, mt, et, ut = !1) => {
    const Qe = K && K.children, It = K ? K.shapeFlag : 0, bt = ye.children, { patchFlag: Lt, shapeFlag: Ut } = ye;
    if (Lt > 0) {
      if (Lt & 128) {
        Nr(Qe, bt, Re, qe, We, nt, mt, et, ut);
        return;
      } else if (Lt & 256) {
        kn(Qe, bt, Re, qe, We, nt, mt, et, ut);
        return;
      }
    }
    Ut & 8 ? (It & 16 && Ar(Qe, We, nt), bt !== Qe && T(Re, bt)) : It & 16 ? Ut & 16 ? Nr(Qe, bt, Re, qe, We, nt, mt, et, ut) : Ar(Qe, We, nt, !0) : (It & 8 && T(Re, ""), Ut & 16 && Se(bt, Re, qe, We, nt, mt, et, ut));
  }, kn = (K, ye, Re, qe, We, nt, mt, et, ut) => {
    K = K || wf, ye = ye || wf;
    const Qe = K.length, It = ye.length, bt = Math.min(Qe, It);
    let Lt;
    for (Lt = 0; Lt < bt; Lt++) {
      const Ut = ye[Lt] = ut ? wu(ye[Lt]) : rs(ye[Lt]);
      V(K[Lt], Ut, Re, null, We, nt, mt, et, ut);
    }
    Qe > It ? Ar(K, We, nt, !0, !1, bt) : Se(ye, Re, qe, We, nt, mt, et, ut, bt);
  }, Nr = (K, ye, Re, qe, We, nt, mt, et, ut) => {
    let Qe = 0;
    const It = ye.length;
    let bt = K.length - 1, Lt = It - 1;
    for (; Qe <= bt && Qe <= Lt; ) {
      const Ut = K[Qe], dr = ye[Qe] = ut ? wu(ye[Qe]) : rs(ye[Qe]);
      if (Vc(Ut, dr))
        V(Ut, dr, Re, null, We, nt, mt, et, ut);
      else
        break;
      Qe++;
    }
    for (; Qe <= bt && Qe <= Lt; ) {
      const Ut = K[bt], dr = ye[Lt] = ut ? wu(ye[Lt]) : rs(ye[Lt]);
      if (Vc(Ut, dr))
        V(Ut, dr, Re, null, We, nt, mt, et, ut);
      else
        break;
      bt--, Lt--;
    }
    if (Qe > bt) {
      if (Qe <= Lt) {
        const Ut = Lt + 1, dr = Ut < It ? ye[Ut].el : qe;
        for (; Qe <= Lt; )
          V(null, ye[Qe] = ut ? wu(ye[Qe]) : rs(ye[Qe]), Re, dr, We, nt, mt, et, ut), Qe++;
      }
    } else if (Qe > Lt)
      for (; Qe <= bt; )
        Zn(K[Qe], We, nt, !0), Qe++;
    else {
      const Ut = Qe, dr = Qe, Vr = /* @__PURE__ */ new Map();
      for (Qe = dr; Qe <= Lt; Qe++) {
        const Tn = ye[Qe] = ut ? wu(ye[Qe]) : rs(ye[Qe]);
        Tn.key != null && (process.env.NODE_ENV !== "production" && Vr.has(Tn.key) && lt("Duplicate keys found during update:", JSON.stringify(Tn.key), "Make sure keys are unique."), Vr.set(Tn.key, Qe));
      }
      let kr, Jr = 0;
      const Xn = Lt - dr + 1;
      let Bi = !1, so = 0;
      const Kn = new Array(Xn);
      for (Qe = 0; Qe < Xn; Qe++)
        Kn[Qe] = 0;
      for (Qe = Ut; Qe <= bt; Qe++) {
        const Tn = K[Qe];
        if (Jr >= Xn) {
          Zn(Tn, We, nt, !0);
          continue;
        }
        let si;
        if (Tn.key != null)
          si = Vr.get(Tn.key);
        else
          for (kr = dr; kr <= Lt; kr++)
            if (Kn[kr - dr] === 0 && Vc(Tn, ye[kr])) {
              si = kr;
              break;
            }
        si === void 0 ? Zn(Tn, We, nt, !0) : (Kn[si - dr] = Qe + 1, si >= so ? so = si : Bi = !0, V(Tn, ye[si], Re, null, We, nt, mt, et, ut), Jr++);
      }
      const ki = Bi ? ik(Kn) : wf;
      for (kr = ki.length - 1, Qe = Xn - 1; Qe >= 0; Qe--) {
        const Tn = dr + Qe, si = ye[Tn], Fa = Tn + 1 < It ? ye[Tn + 1].el : qe;
        Kn[Qe] === 0 ? V(null, si, Re, Fa, We, nt, mt, et, ut) : Bi && (kr < 0 || Qe !== ki[kr] ? pr(si, Re, Fa, 2) : kr--);
      }
    }
  }, pr = (K, ye, Re, qe, We = null) => {
    const { el: nt, type: mt, transition: et, children: ut, shapeFlag: Qe } = K;
    if (Qe & 6) {
      pr(K.component.subTree, ye, Re, qe);
      return;
    }
    if (Qe & 128) {
      K.suspense.move(ye, Re, qe);
      return;
    }
    if (Qe & 64) {
      mt.move(K, ye, Re, Sn);
      return;
    }
    if (mt === on) {
      a(nt, ye, Re);
      for (let bt = 0; bt < ut.length; bt++)
        pr(ut[bt], ye, Re, qe);
      a(K.anchor, ye, Re);
      return;
    }
    if (mt === eg) {
      ce(K, ye, Re);
      return;
    }
    if (qe !== 2 && Qe & 1 && et)
      if (qe === 0)
        et.beforeEnter(nt), a(nt, ye, Re), ea(() => et.enter(nt), We);
      else {
        const { leave: bt, delayLeave: Lt, afterLeave: Ut } = et, dr = () => a(nt, ye, Re), Vr = () => {
          bt(nt, () => {
            dr(), Ut && Ut();
          });
        };
        Lt ? Lt(nt, dr, Vr) : Vr();
      }
    else
      a(nt, ye, Re);
  }, Zn = (K, ye, Re, qe = !1, We = !1) => {
    const { type: nt, props: mt, ref: et, children: ut, dynamicChildren: Qe, shapeFlag: It, patchFlag: bt, dirs: Lt } = K;
    if (et != null && F0(et, null, Re, K, !0), It & 256) {
      ye.ctx.deactivate(K);
      return;
    }
    const Ut = It & 1 && Lt, dr = !fd(K);
    let Vr;
    if (dr && (Vr = mt && mt.onVnodeBeforeUnmount) && Rs(Vr, ye, K), It & 6)
      $r(K.component, Re, qe);
    else {
      if (It & 128) {
        K.suspense.unmount(Re, qe);
        return;
      }
      Ut && Tc(K, null, ye, "beforeUnmount"), It & 64 ? K.type.remove(K, ye, Re, We, Sn, qe) : Qe && (nt !== on || bt > 0 && bt & 64) ? Ar(Qe, ye, Re, !1, !0) : (nt === on && bt & 384 || !We && It & 16) && Ar(ut, ye, Re), qe && Rr(K);
    }
    (dr && (Vr = mt && mt.onVnodeUnmounted) || Ut) && ea(() => {
      Vr && Rs(Vr, ye, K), Ut && Tc(K, null, ye, "unmounted");
    }, Re);
  }, Rr = (K) => {
    const { type: ye, el: Re, anchor: qe, transition: We } = K;
    if (ye === on) {
      process.env.NODE_ENV !== "production" && K.patchFlag > 0 && K.patchFlag & 2048 && We && !We.persisted ? K.children.forEach((mt) => {
        mt.type === Xi ? s(mt.el) : Rr(mt);
      }) : Fi(Re, qe);
      return;
    }
    if (ye === eg) {
      ve(K);
      return;
    }
    const nt = () => {
      s(Re), We && !We.persisted && We.afterLeave && We.afterLeave();
    };
    if (K.shapeFlag & 1 && We && !We.persisted) {
      const { leave: mt, delayLeave: et } = We, ut = () => mt(Re, nt);
      et ? et(K.el, nt, ut) : ut();
    } else
      nt();
  }, Fi = (K, ye) => {
    let Re;
    for (; K !== ye; )
      Re = I(K), s(K), K = Re;
    s(ye);
  }, $r = (K, ye, Re) => {
    process.env.NODE_ENV !== "production" && K.type.__hmrId && JP(K);
    const { bum: qe, scope: We, update: nt, subTree: mt, um: et } = K;
    qe && jp(qe), We.stop(), nt && (nt.active = !1, Zn(mt, K, ye, Re)), et && ea(et, ye), ea(() => {
      K.isUnmounted = !0;
    }, ye), ye && ye.pendingBranch && !ye.isUnmounted && K.asyncDep && !K.asyncResolved && K.suspenseId === ye.pendingId && (ye.deps--, ye.deps === 0 && ye.resolve()), process.env.NODE_ENV !== "production" && oA(K);
  }, Ar = (K, ye, Re, qe = !1, We = !1, nt = 0) => {
    for (let mt = nt; mt < K.length; mt++)
      Zn(K[mt], ye, Re, qe, We);
  }, Vn = (K) => K.shapeFlag & 6 ? Vn(K.component.subTree) : K.shapeFlag & 128 ? K.suspense.next() : I(K.anchor || K.el), Sr = (K, ye, Re) => {
    K == null ? ye._vnode && Zn(ye._vnode, null, null, !0) : V(ye._vnode || null, K, ye, null, null, null, Re), Wb(), pS(), ye._vnode = K;
  }, Sn = {
    p: V,
    um: Zn,
    m: pr,
    r: Rr,
    mt: Je,
    mc: Se,
    pc: tr,
    pbc: Xe,
    n: Vn,
    o: t
  };
  let ai, Un;
  return e && ([ai, Un] = e(Sn)), {
    render: Sr,
    hydrate: ai,
    createApp: ek(Sr, ai)
  };
}
function Mc({ effect: t, update: e }, n) {
  t.allowRecurse = e.allowRecurse = n;
}
function pd(t, e, n = !1) {
  const a = t.children, s = e.children;
  if (er(a) && er(s))
    for (let f = 0; f < a.length; f++) {
      const o = a[f];
      let m = s[f];
      m.shapeFlag & 1 && !m.dynamicChildren && ((m.patchFlag <= 0 || m.patchFlag === 32) && (m = s[f] = wu(s[f]), m.el = o.el), n || pd(o, m)), m.type === $d && (m.el = o.el), process.env.NODE_ENV !== "production" && m.type === Xi && !m.el && (m.el = o.el);
    }
}
function ik(t) {
  const e = t.slice(), n = [0];
  let a, s, f, o, m;
  const g = t.length;
  for (a = 0; a < g; a++) {
    const b = t[a];
    if (b !== 0) {
      if (s = n[n.length - 1], t[s] < b) {
        e[a] = s, n.push(a);
        continue;
      }
      for (f = 0, o = n.length - 1; f < o; )
        m = f + o >> 1, t[n[m]] < b ? f = m + 1 : o = m;
      b < t[n[f]] && (f > 0 && (e[a] = n[f - 1]), n[f] = a);
    }
  }
  for (f = n.length, o = n[f - 1]; f-- > 0; )
    n[f] = o, o = e[o];
  return n;
}
const ok = (t) => t.__isTeleport, Tf = (t) => t && (t.disabled || t.disabled === ""), ow = (t) => typeof SVGElement < "u" && t instanceof SVGElement, B0 = (t, e) => {
  const n = t && t.to;
  if (Hn(n))
    if (e) {
      const a = e(n);
      return a || process.env.NODE_ENV !== "production" && lt(`Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`), a;
    } else
      return process.env.NODE_ENV !== "production" && lt("Current renderer does not support string target for Teleports. (missing querySelector renderer option)"), null;
  else
    return process.env.NODE_ENV !== "production" && !n && !Tf(t) && lt(`Invalid Teleport target: ${n}`), n;
}, ak = {
  __isTeleport: !0,
  process(t, e, n, a, s, f, o, m, g, b) {
    const { mc: T, pc: M, pbc: I, o: { insert: A, querySelector: z, createText: V, createComment: q } } = b, re = Tf(e.props);
    let { shapeFlag: X, children: ae, dynamicChildren: ce } = e;
    if (process.env.NODE_ENV !== "production" && Au && (g = !1, ce = null), t == null) {
      const ve = e.el = process.env.NODE_ENV !== "production" ? q("teleport start") : V(""), Ne = e.anchor = process.env.NODE_ENV !== "production" ? q("teleport end") : V("");
      A(ve, n, a), A(Ne, n, a);
      const ze = e.target = B0(e.props, z), Ae = e.targetAnchor = V("");
      ze ? (A(Ae, ze), o = o || ow(ze)) : process.env.NODE_ENV !== "production" && !re && lt("Invalid Teleport target on mount:", ze, `(${typeof ze})`);
      const Se = (Ie, Xe) => {
        X & 16 && T(ae, Ie, Xe, s, f, o, m, g);
      };
      re ? Se(n, Ne) : ze && Se(ze, Ae);
    } else {
      e.el = t.el;
      const ve = e.anchor = t.anchor, Ne = e.target = t.target, ze = e.targetAnchor = t.targetAnchor, Ae = Tf(t.props), Se = Ae ? n : Ne, Ie = Ae ? ve : ze;
      if (o = o || ow(Ne), ce ? (I(t.dynamicChildren, ce, Se, s, f, o, m), pd(t, e, !0)) : g || M(t, e, Se, Ie, s, f, o, m, !1), re)
        Ae || Sy(e, n, ve, b, 1);
      else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
        const Xe = e.target = B0(e.props, z);
        Xe ? Sy(e, Xe, null, b, 0) : process.env.NODE_ENV !== "production" && lt("Invalid Teleport target on update:", Ne, `(${typeof Ne})`);
      } else
        Ae && Sy(e, Ne, ze, b, 1);
    }
    GS(e);
  },
  remove(t, e, n, a, { um: s, o: { remove: f } }, o) {
    const { shapeFlag: m, children: g, anchor: b, targetAnchor: T, target: M, props: I } = t;
    if (M && f(T), (o || !Tf(I)) && (f(b), m & 16))
      for (let A = 0; A < g.length; A++) {
        const z = g[A];
        s(z, e, n, !0, !!z.dynamicChildren);
      }
  },
  move: Sy,
  hydrate: sk
};
function Sy(t, e, n, { o: { insert: a }, m: s }, f = 2) {
  f === 0 && a(t.targetAnchor, e, n);
  const { el: o, anchor: m, shapeFlag: g, children: b, props: T } = t, M = f === 2;
  if (M && a(o, e, n), (!M || Tf(T)) && g & 16)
    for (let I = 0; I < b.length; I++)
      s(b[I], e, n, 2);
  M && a(m, e, n);
}
function sk(t, e, n, a, s, f, { o: { nextSibling: o, parentNode: m, querySelector: g } }, b) {
  const T = e.target = B0(e.props, g);
  if (T) {
    const M = T._lpa || T.firstChild;
    if (e.shapeFlag & 16)
      if (Tf(e.props))
        e.anchor = b(o(t), e, m(t), n, a, s, f), e.targetAnchor = M;
      else {
        e.anchor = o(t);
        let I = M;
        for (; I; )
          if (I = o(I), I && I.nodeType === 8 && I.data === "teleport anchor") {
            e.targetAnchor = I, T._lpa = e.targetAnchor && o(e.targetAnchor);
            break;
          }
        b(M, e, T, n, a, s, f);
      }
    GS(e);
  }
  return e.anchor && o(e.anchor);
}
const jS = ak;
function GS(t) {
  const e = t.ctx;
  if (e && e.ut) {
    let n = t.children[0].el;
    for (; n !== t.targetAnchor; )
      n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid), n = n.nextSibling;
    e.ut();
  }
}
const on = Symbol(process.env.NODE_ENV !== "production" ? "Fragment" : void 0), $d = Symbol(process.env.NODE_ENV !== "production" ? "Text" : void 0), Xi = Symbol(process.env.NODE_ENV !== "production" ? "Comment" : void 0), eg = Symbol(process.env.NODE_ENV !== "production" ? "Static" : void 0), dd = [];
let is = null;
function Be(t = !1) {
  dd.push(is = t ? null : []);
}
function lk() {
  dd.pop(), is = dd[dd.length - 1] || null;
}
let Pd = 1;
function aw(t) {
  Pd += t;
}
function $S(t) {
  return t.dynamicChildren = Pd > 0 ? is || wf : null, lk(), Pd > 0 && is && is.push(t), t;
}
function rt(t, e, n, a, s, f) {
  return $S(Fe(t, e, n, a, s, f, !0));
}
function an(t, e, n, a, s) {
  return $S(kt(t, e, n, a, s, !0));
}
function Lf(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function Vc(t, e) {
  return process.env.NODE_ENV !== "production" && e.shapeFlag & 6 && hf.has(e.type) ? (t.shapeFlag &= -257, e.shapeFlag &= -513, !1) : t.type === e.type && t.key === e.key;
}
const uk = (...t) => WS(...t), bv = "__vInternal", qS = ({ key: t }) => t != null ? t : null, tg = ({ ref: t, ref_key: e, ref_for: n }) => t != null ? Hn(t) || hn(t) || yr(t) ? { i: zi, r: t, k: e, f: !!n } : t : null;
function Fe(t, e = null, n = null, a = 0, s = null, f = t === on ? 0 : 1, o = !1, m = !1) {
  const g = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && qS(e),
    ref: e && tg(e),
    scopeId: xS,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: f,
    patchFlag: a,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: zi
  };
  return m ? (Bx(g, n), f & 128 && t.normalize(g)) : n && (g.shapeFlag |= Hn(n) ? 8 : 16), process.env.NODE_ENV !== "production" && g.key !== g.key && lt("VNode created with invalid key (NaN). VNode type:", g.type), Pd > 0 && !o && is && (g.patchFlag > 0 || f & 6) && g.patchFlag !== 32 && is.push(g), g;
}
const kt = process.env.NODE_ENV !== "production" ? uk : WS;
function WS(t, e = null, n = null, a = 0, s = null, f = !1) {
  if ((!t || t === kA) && (process.env.NODE_ENV !== "production" && !t && lt(`Invalid vnode type when creating vnode: ${t}.`), t = Xi), Lf(t)) {
    const m = Qs(t, e, !0);
    return n && Bx(m, n), Pd > 0 && !f && is && (m.shapeFlag & 6 ? is[is.indexOf(t)] = m : is.push(m)), m.patchFlag |= -2, m;
  }
  if (KS(t) && (t = t.__vccOpts), e) {
    e = ck(e);
    let { class: m, style: g } = e;
    m && !Hn(m) && (e.class = Br(m)), fn(g) && (Sg(g) && !er(g) && (g = Wn({}, g)), e.style = Gu(g));
  }
  const o = Hn(t) ? 1 : mA(t) ? 128 : ok(t) ? 64 : fn(t) ? 4 : yr(t) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && o & 4 && Sg(t) && (t = hr(t), lt("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `
Component that was made reactive: `, t)), Fe(t, e, n, a, s, o, f, !0);
}
function ck(t) {
  return t ? Sg(t) || bv in t ? Wn({}, t) : t : null;
}
function Qs(t, e, n = !1) {
  const { props: a, ref: s, patchFlag: f, children: o } = t, m = e ? hk(a || {}, e) : a;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: m,
    key: m && qS(m),
    ref: e && e.ref ? n && s ? er(s) ? s.concat(tg(e)) : [s, tg(e)] : tg(e) : s,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && f === -1 && er(o) ? o.map(HS) : o,
    target: t.target,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    patchFlag: e && t.type !== on ? f === -1 ? 16 : f | 16 : f,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: t.transition,
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && Qs(t.ssContent),
    ssFallback: t.ssFallback && Qs(t.ssFallback),
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
}
function HS(t) {
  const e = Qs(t);
  return er(t.children) && (e.children = t.children.map(HS)), e;
}
function Ag(t = " ", e = 0) {
  return kt($d, null, t, e);
}
function Ye(t = "", e = !1) {
  return e ? (Be(), an(Xi, null, t)) : kt(Xi, null, t);
}
function rs(t) {
  return t == null || typeof t == "boolean" ? kt(Xi) : er(t) ? kt(
    on,
    null,
    t.slice()
  ) : typeof t == "object" ? wu(t) : kt($d, null, String(t));
}
function wu(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : Qs(t);
}
function Bx(t, e) {
  let n = 0;
  const { shapeFlag: a } = t;
  if (e == null)
    e = null;
  else if (er(e))
    n = 16;
  else if (typeof e == "object")
    if (a & 65) {
      const s = e.default;
      s && (s._c && (s._d = !1), Bx(t, s()), s._c && (s._d = !0));
      return;
    } else {
      n = 32;
      const s = e._;
      !s && !(bv in e) ? e._ctx = zi : s === 3 && zi && (zi.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
  else
    yr(e) ? (e = { default: e, _ctx: zi }, n = 32) : (e = String(e), a & 64 ? (n = 16, e = [Ag(e)]) : n = 8);
  t.children = e, t.shapeFlag |= n;
}
function hk(...t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    for (const s in a)
      if (s === "class")
        e.class !== a.class && (e.class = Br([e.class, a.class]));
      else if (s === "style")
        e.style = Gu([e.style, a.style]);
      else if (Ud(s)) {
        const f = e[s], o = a[s];
        o && f !== o && !(er(f) && f.includes(o)) && (e[s] = f ? [].concat(f, o) : o);
      } else
        s !== "" && (e[s] = a[s]);
  }
  return e;
}
function Rs(t, e, n, a = null) {
  Da(t, e, 7, [
    n,
    a
  ]);
}
const fk = US();
let pk = 0;
function dk(t, e, n) {
  const a = t.type, s = (e ? e.appContext : t.appContext) || fk, f = {
    uid: pk++,
    vnode: t,
    type: a,
    parent: e,
    appContext: s,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new jE(!0),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(s.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: RS(a, s),
    emitsOptions: _S(a, s),
    emit: null,
    emitted: null,
    propsDefaults: wn,
    inheritAttrs: a.inheritAttrs,
    ctx: wn,
    data: wn,
    props: wn,
    attrs: wn,
    slots: wn,
    refs: wn,
    setupState: wn,
    setupContext: null,
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return process.env.NODE_ENV !== "production" ? f.ctx = LA(f) : f.ctx = { _: f }, f.root = e ? e.root : f, f.emit = uA.bind(null, f), t.ce && t.ce(f), f;
}
let di = null;
const wv = () => di || zi, Df = (t) => {
  di = t, t.scope.on();
}, Zc = () => {
  di && di.scope.off(), di = null;
}, mk = /* @__PURE__ */ ju("slot,component");
function V0(t, e) {
  const n = e.isNativeTag || zE;
  (mk(t) || n(t)) && lt("Do not use built-in or reserved HTML elements as component id: " + t);
}
function ZS(t) {
  return t.vnode.shapeFlag & 4;
}
let Ad = !1;
function yk(t, e = !1) {
  Ad = e;
  const { props: n, children: a } = t.vnode, s = ZS(t);
  jA(t, n, s, e), YA(t, a);
  const f = s ? gk(t, e) : void 0;
  return Ad = !1, f;
}
function gk(t, e) {
  var n;
  const a = t.type;
  if (process.env.NODE_ENV !== "production") {
    if (a.name && V0(a.name, t.appContext.config), a.components) {
      const f = Object.keys(a.components);
      for (let o = 0; o < f.length; o++)
        V0(f[o], t.appContext.config);
    }
    if (a.directives) {
      const f = Object.keys(a.directives);
      for (let o = 0; o < f.length; o++)
        CS(f[o]);
    }
    a.compilerOptions && vk() && lt('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.');
  }
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = ts(new Proxy(t.ctx, LS)), process.env.NODE_ENV !== "production" && DA(t);
  const { setup: s } = a;
  if (s) {
    const f = t.setupContext = s.length > 1 ? _k(t) : null;
    Df(t), rh();
    const o = Bl(s, t, 0, [process.env.NODE_ENV !== "production" ? mf(t.props) : t.props, f]);
    if (nh(), Zc(), Sx(o)) {
      if (o.then(Zc, Zc), e)
        return o.then((m) => {
          sw(t, m, e);
        }).catch((m) => {
          gv(m, t, 0);
        });
      if (t.asyncDep = o, process.env.NODE_ENV !== "production" && !t.suspense) {
        const m = (n = a.name) !== null && n !== void 0 ? n : "Anonymous";
        lt(`Component <${m}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
      }
    } else
      sw(t, o, e);
  } else
    XS(t, e);
}
function sw(t, e, n) {
  yr(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : fn(e) ? (process.env.NODE_ENV !== "production" && Lf(e) && lt("setup() should not return VNodes directly - return a render function instead."), process.env.NODE_ENV !== "production" && (t.devtoolsRawSetupState = e), t.setupState = sS(e), process.env.NODE_ENV !== "production" && NA(t)) : process.env.NODE_ENV !== "production" && e !== void 0 && lt(`setup() should return an object. Received: ${e === null ? "null" : typeof e}`), XS(t, n);
}
let U0;
const vk = () => !U0;
function XS(t, e, n) {
  const a = t.type;
  if (!t.render) {
    if (!e && U0 && !a.render) {
      const s = a.template || zx(t).template;
      if (s) {
        process.env.NODE_ENV !== "production" && Nl(t, "compile");
        const { isCustomElement: f, compilerOptions: o } = t.appContext.config, { delimiters: m, compilerOptions: g } = a, b = Wn(Wn({
          isCustomElement: f,
          delimiters: m
        }, o), g);
        a.render = U0(s, b), process.env.NODE_ENV !== "production" && Rl(t, "compile");
      }
    }
    t.render = a.render || ao;
  }
  Df(t), rh(), zA(t), nh(), Zc(), process.env.NODE_ENV !== "production" && !a.render && t.render === ao && !e && (a.template ? lt('Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".') : lt("Component is missing template or render function."));
}
function lw(t) {
  return new Proxy(t.attrs, process.env.NODE_ENV !== "production" ? {
    get(e, n) {
      return Ig(), Bo(t, "get", "$attrs"), e[n];
    },
    set() {
      return lt("setupContext.attrs is readonly."), !1;
    },
    deleteProperty() {
      return lt("setupContext.attrs is readonly."), !1;
    }
  } : {
    get(e, n) {
      return Bo(t, "get", "$attrs"), e[n];
    }
  });
}
function _k(t) {
  const e = (a) => {
    if (process.env.NODE_ENV !== "production" && (t.exposed && lt("expose() should be called only once per setup()."), a != null)) {
      let s = typeof a;
      s === "object" && (er(a) ? s = "array" : hn(a) && (s = "ref")), s !== "object" && lt(`expose() should be passed a plain object, received ${s}.`);
    }
    t.exposed = a || {};
  };
  let n;
  return process.env.NODE_ENV !== "production" ? Object.freeze({
    get attrs() {
      return n || (n = lw(t));
    },
    get slots() {
      return mf(t.slots);
    },
    get emit() {
      return (a, ...s) => t.emit(a, ...s);
    },
    expose: e
  }) : {
    get attrs() {
      return n || (n = lw(t));
    },
    slots: t.slots,
    emit: t.emit,
    expose: e
  };
}
function Ev(t) {
  if (t.exposed)
    return t.exposeProxy || (t.exposeProxy = new Proxy(sS(ts(t.exposed)), {
      get(e, n) {
        if (n in e)
          return e[n];
        if (n in Hc)
          return Hc[n](t);
      },
      has(e, n) {
        return n in e || n in Hc;
      }
    }));
}
const xk = /(?:^|[-_])(\w)/g, bk = (t) => t.replace(xk, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function Vx(t, e = !0) {
  return yr(t) ? t.displayName || t.name : t.name || e && t.__name;
}
function Sv(t, e, n = !1) {
  let a = Vx(e);
  if (!a && e.__file) {
    const s = e.__file.match(/([^/\\]+)\.\w+$/);
    s && (a = s[1]);
  }
  if (!a && t && t.parent) {
    const s = (f) => {
      for (const o in f)
        if (f[o] === e)
          return o;
    };
    a = s(t.components || t.parent.type.components) || s(t.appContext.components);
  }
  return a ? bk(a) : n ? "App" : "Anonymous";
}
function KS(t) {
  return yr(t) && "__vccOpts" in t;
}
const ar = (t, e) => VP(t, e, Ad);
function YS(t, e, n) {
  const a = arguments.length;
  return a === 2 ? fn(e) && !er(e) ? Lf(e) ? kt(t, null, [e]) : kt(t, e) : kt(t, null, e) : (a > 3 ? n = Array.prototype.slice.call(arguments, 2) : a === 3 && Lf(n) && (n = [n]), kt(t, e, n));
}
const wk = Symbol(process.env.NODE_ENV !== "production" ? "ssrContext" : ""), Ek = () => {
  {
    const t = Sf(wk);
    return t || process.env.NODE_ENV !== "production" && lt("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), t;
  }
};
function N_(t) {
  return !!(t && t.__v_isShallow);
}
function Sk() {
  if (process.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const t = { style: "color:#3ba776" }, e = { style: "color:#0b1bc9" }, n = { style: "color:#b62e24" }, a = { style: "color:#9d288c" }, s = {
    header(M) {
      return fn(M) ? M.__isVue ? ["div", t, "VueInstance"] : hn(M) ? [
        "div",
        {},
        ["span", t, T(M)],
        "<",
        m(M.value),
        ">"
      ] : ss(M) ? [
        "div",
        {},
        ["span", t, N_(M) ? "ShallowReactive" : "Reactive"],
        "<",
        m(M),
        `>${zu(M) ? " (readonly)" : ""}`
      ] : zu(M) ? [
        "div",
        {},
        ["span", t, N_(M) ? "ShallowReadonly" : "Readonly"],
        "<",
        m(M),
        ">"
      ] : null : null;
    },
    hasBody(M) {
      return M && M.__isVue;
    },
    body(M) {
      if (M && M.__isVue)
        return [
          "div",
          {},
          ...f(M.$)
        ];
    }
  };
  function f(M) {
    const I = [];
    M.type.props && M.props && I.push(o("props", hr(M.props))), M.setupState !== wn && I.push(o("setup", M.setupState)), M.data !== wn && I.push(o("data", hr(M.data)));
    const A = g(M, "computed");
    A && I.push(o("computed", A));
    const z = g(M, "inject");
    return z && I.push(o("injected", z)), I.push([
      "div",
      {},
      [
        "span",
        {
          style: a.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: M }]
    ]), I;
  }
  function o(M, I) {
    return I = Wn({}, I), Object.keys(I).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        M
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(I).map((A) => [
          "div",
          {},
          ["span", a, A + ": "],
          m(I[A], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function m(M, I = !0) {
    return typeof M == "number" ? ["span", e, M] : typeof M == "string" ? ["span", n, JSON.stringify(M)] : typeof M == "boolean" ? ["span", a, M] : fn(M) ? ["object", { object: I ? hr(M) : M }] : ["span", n, String(M)];
  }
  function g(M, I) {
    const A = M.type;
    if (yr(A))
      return;
    const z = {};
    for (const V in M.ctx)
      b(A, V, I) && (z[V] = M.ctx[V]);
    return z;
  }
  function b(M, I, A) {
    const z = M[A];
    if (er(z) && z.includes(I) || fn(z) && I in z || M.extends && b(M.extends, I, A) || M.mixins && M.mixins.some((V) => b(V, I, A)))
      return !0;
  }
  function T(M) {
    return N_(M) ? "ShallowRef" : M.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(s) : window.devtoolsFormatters = [s];
}
const uw = "3.2.47", Tk = "http://www.w3.org/2000/svg", Uc = typeof document < "u" ? document : null, cw = Uc && /* @__PURE__ */ Uc.createElement("template"), Mk = {
  insert: (t, e, n) => {
    e.insertBefore(t, n || null);
  },
  remove: (t) => {
    const e = t.parentNode;
    e && e.removeChild(t);
  },
  createElement: (t, e, n, a) => {
    const s = e ? Uc.createElementNS(Tk, t) : Uc.createElement(t, n ? { is: n } : void 0);
    return t === "select" && a && a.multiple != null && s.setAttribute("multiple", a.multiple), s;
  },
  createText: (t) => Uc.createTextNode(t),
  createComment: (t) => Uc.createComment(t),
  setText: (t, e) => {
    t.nodeValue = e;
  },
  setElementText: (t, e) => {
    t.textContent = e;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => Uc.querySelector(t),
  setScopeId(t, e) {
    t.setAttribute(e, "");
  },
  insertStaticContent(t, e, n, a, s, f) {
    const o = n ? n.previousSibling : e.lastChild;
    if (s && (s === f || s.nextSibling))
      for (; e.insertBefore(s.cloneNode(!0), n), !(s === f || !(s = s.nextSibling)); )
        ;
    else {
      cw.innerHTML = a ? `<svg>${t}</svg>` : t;
      const m = cw.content;
      if (a) {
        const g = m.firstChild;
        for (; g.firstChild; )
          m.appendChild(g.firstChild);
        m.removeChild(g);
      }
      e.insertBefore(m, n);
    }
    return [
      o ? o.nextSibling : e.firstChild,
      n ? n.previousSibling : e.lastChild
    ];
  }
};
function Ik(t, e, n) {
  const a = t._vtc;
  a && (e = (e ? [e, ...a] : [...a]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e;
}
function Ok(t, e, n) {
  const a = t.style, s = Hn(n);
  if (n && !s) {
    if (e && !Hn(e))
      for (const f in e)
        n[f] == null && j0(a, f, "");
    for (const f in n)
      j0(a, f, n[f]);
  } else {
    const f = a.display;
    s ? e !== n && (a.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (a.display = f);
  }
}
const Ck = /[^\\];\s*$/, hw = /\s*!important$/;
function j0(t, e, n) {
  if (er(n))
    n.forEach((a) => j0(t, e, a));
  else if (n == null && (n = ""), process.env.NODE_ENV !== "production" && Ck.test(n) && lt(`Unexpected semicolon at the end of '${e}' style value: '${n}'`), e.startsWith("--"))
    t.setProperty(e, n);
  else {
    const a = Pk(t, e);
    hw.test(n) ? t.setProperty(ta(a), n.replace(hw, ""), "important") : t[a] = n;
  }
}
const fw = ["Webkit", "Moz", "ms"], R_ = {};
function Pk(t, e) {
  const n = R_[e];
  if (n)
    return n;
  let a = ya(e);
  if (a !== "filter" && a in t)
    return R_[e] = a;
  a = Yc(a);
  for (let s = 0; s < fw.length; s++) {
    const f = fw[s] + a;
    if (f in t)
      return R_[e] = f;
  }
  return e;
}
const pw = "http://www.w3.org/1999/xlink";
function Ak(t, e, n, a, s) {
  if (a && e.startsWith("xlink:"))
    n == null ? t.removeAttributeNS(pw, e.slice(6, e.length)) : t.setAttributeNS(pw, e, n);
  else {
    const f = JC(e);
    n == null || f && !NE(n) ? t.removeAttribute(e) : t.setAttribute(e, f ? "" : n);
  }
}
function kk(t, e, n, a, s, f, o) {
  if (e === "innerHTML" || e === "textContent") {
    a && o(a, s, f), t[e] = n == null ? "" : n;
    return;
  }
  if (e === "value" && t.tagName !== "PROGRESS" && !t.tagName.includes("-")) {
    t._value = n;
    const g = n == null ? "" : n;
    (t.value !== g || t.tagName === "OPTION") && (t.value = g), n == null && t.removeAttribute(e);
    return;
  }
  let m = !1;
  if (n === "" || n == null) {
    const g = typeof t[e];
    g === "boolean" ? n = NE(n) : n == null && g === "string" ? (n = "", m = !0) : g === "number" && (n = 0, m = !0);
  }
  try {
    t[e] = n;
  } catch (g) {
    process.env.NODE_ENV !== "production" && !m && lt(`Failed setting prop "${e}" on <${t.tagName.toLowerCase()}>: value ${n} is invalid.`, g);
  }
  m && t.removeAttribute(e);
}
function Lk(t, e, n, a) {
  t.addEventListener(e, n, a);
}
function Dk(t, e, n, a) {
  t.removeEventListener(e, n, a);
}
function Nk(t, e, n, a, s = null) {
  const f = t._vei || (t._vei = {}), o = f[e];
  if (a && o)
    o.value = a;
  else {
    const [m, g] = Rk(e);
    if (a) {
      const b = f[e] = Bk(a, s);
      Lk(t, m, b, g);
    } else
      o && (Dk(t, m, o, g), f[e] = void 0);
  }
}
const dw = /(?:Once|Passive|Capture)$/;
function Rk(t) {
  let e;
  if (dw.test(t)) {
    e = {};
    let a;
    for (; a = t.match(dw); )
      t = t.slice(0, t.length - a[0].length), e[a[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : ta(t.slice(2)), e];
}
let z_ = 0;
const zk = /* @__PURE__ */ Promise.resolve(), Fk = () => z_ || (zk.then(() => z_ = 0), z_ = Date.now());
function Bk(t, e) {
  const n = (a) => {
    if (!a._vts)
      a._vts = Date.now();
    else if (a._vts <= n.attached)
      return;
    Da(Vk(a, n.value), e, 5, [a]);
  };
  return n.value = t, n.attached = Fk(), n;
}
function Vk(t, e) {
  if (er(e)) {
    const n = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      n.call(t), t._stopped = !0;
    }, e.map((a) => (s) => !s._stopped && a && a(s));
  } else
    return e;
}
const mw = /^on[a-z]/, Uk = (t, e, n, a, s = !1, f, o, m, g) => {
  e === "class" ? Ik(t, a, s) : e === "style" ? Ok(t, n, a) : Ud(e) ? _g(e) || Nk(t, e, n, a, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : jk(t, e, a, s)) ? kk(t, e, a, f, o, m, g) : (e === "true-value" ? t._trueValue = a : e === "false-value" && (t._falseValue = a), Ak(t, e, a, s));
};
function jk(t, e, n, a) {
  return a ? !!(e === "innerHTML" || e === "textContent" || e in t && mw.test(e) && yr(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || mw.test(e) && Hn(n) ? !1 : e in t;
}
const mu = "transition", $p = "animation", Tv = (t, { slots: e }) => YS(SS, Gk(t), e);
Tv.displayName = "Transition";
const JS = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Tv.props = /* @__PURE__ */ Wn({}, SS.props, JS);
const Ic = (t, e = []) => {
  er(t) ? t.forEach((n) => n(...e)) : t && t(...e);
}, yw = (t) => t ? er(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;
function Gk(t) {
  const e = {};
  for (const $e in t)
    $e in JS || (e[$e] = t[$e]);
  if (t.css === !1)
    return e;
  const { name: n = "v", type: a, duration: s, enterFromClass: f = `${n}-enter-from`, enterActiveClass: o = `${n}-enter-active`, enterToClass: m = `${n}-enter-to`, appearFromClass: g = f, appearActiveClass: b = o, appearToClass: T = m, leaveFromClass: M = `${n}-leave-from`, leaveActiveClass: I = `${n}-leave-active`, leaveToClass: A = `${n}-leave-to` } = t, z = $k(s), V = z && z[0], q = z && z[1], { onBeforeEnter: re, onEnter: X, onEnterCancelled: ae, onLeave: ce, onLeaveCancelled: ve, onBeforeAppear: Ne = re, onAppear: ze = X, onAppearCancelled: Ae = ae } = e, Se = ($e, at, be) => {
    Oc($e, at ? T : m), Oc($e, at ? b : o), be && be();
  }, Ie = ($e, at) => {
    $e._isLeaving = !1, Oc($e, M), Oc($e, A), Oc($e, I), at && at();
  }, Xe = ($e) => (at, be) => {
    const Je = $e ? ze : X, ht = () => Se(at, $e, be);
    Ic(Je, [at, ht]), gw(() => {
      Oc(at, $e ? g : f), yu(at, $e ? T : m), yw(Je) || vw(at, a, V, ht);
    });
  };
  return Wn(e, {
    onBeforeEnter($e) {
      Ic(re, [$e]), yu($e, f), yu($e, o);
    },
    onBeforeAppear($e) {
      Ic(Ne, [$e]), yu($e, g), yu($e, b);
    },
    onEnter: Xe(!1),
    onAppear: Xe(!0),
    onLeave($e, at) {
      $e._isLeaving = !0;
      const be = () => Ie($e, at);
      yu($e, M), Hk(), yu($e, I), gw(() => {
        !$e._isLeaving || (Oc($e, M), yu($e, A), yw(ce) || vw($e, a, q, be));
      }), Ic(ce, [$e, be]);
    },
    onEnterCancelled($e) {
      Se($e, !1), Ic(ae, [$e]);
    },
    onAppearCancelled($e) {
      Se($e, !0), Ic(Ae, [$e]);
    },
    onLeaveCancelled($e) {
      Ie($e), Ic(ve, [$e]);
    }
  });
}
function $k(t) {
  if (t == null)
    return null;
  if (fn(t))
    return [F_(t.enter), F_(t.leave)];
  {
    const e = F_(t);
    return [e, e];
  }
}
function F_(t) {
  const e = E0(t);
  return process.env.NODE_ENV !== "production" && qP(e, "<transition> explicit duration"), e;
}
function yu(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.add(n)), (t._vtc || (t._vtc = /* @__PURE__ */ new Set())).add(e);
}
function Oc(t, e) {
  e.split(/\s+/).forEach((a) => a && t.classList.remove(a));
  const { _vtc: n } = t;
  n && (n.delete(e), n.size || (t._vtc = void 0));
}
function gw(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let qk = 0;
function vw(t, e, n, a) {
  const s = t._endId = ++qk, f = () => {
    s === t._endId && a();
  };
  if (n)
    return setTimeout(f, n);
  const { type: o, timeout: m, propCount: g } = Wk(t, e);
  if (!o)
    return a();
  const b = o + "end";
  let T = 0;
  const M = () => {
    t.removeEventListener(b, I), f();
  }, I = (A) => {
    A.target === t && ++T >= g && M();
  };
  setTimeout(() => {
    T < g && M();
  }, m + 1), t.addEventListener(b, I);
}
function Wk(t, e) {
  const n = window.getComputedStyle(t), a = (z) => (n[z] || "").split(", "), s = a(`${mu}Delay`), f = a(`${mu}Duration`), o = _w(s, f), m = a(`${$p}Delay`), g = a(`${$p}Duration`), b = _w(m, g);
  let T = null, M = 0, I = 0;
  e === mu ? o > 0 && (T = mu, M = o, I = f.length) : e === $p ? b > 0 && (T = $p, M = b, I = g.length) : (M = Math.max(o, b), T = M > 0 ? o > b ? mu : $p : null, I = T ? T === mu ? f.length : g.length : 0);
  const A = T === mu && /\b(transform|all)(,|$)/.test(a(`${mu}Property`).toString());
  return {
    type: T,
    timeout: M,
    propCount: I,
    hasTransform: A
  };
}
function _w(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((n, a) => xw(n) + xw(t[a])));
}
function xw(t) {
  return Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function Hk() {
  return document.body.offsetHeight;
}
const Zk = ["ctrl", "shift", "alt", "meta"], Xk = {
  stop: (t) => t.stopPropagation(),
  prevent: (t) => t.preventDefault(),
  self: (t) => t.target !== t.currentTarget,
  ctrl: (t) => !t.ctrlKey,
  shift: (t) => !t.shiftKey,
  alt: (t) => !t.altKey,
  meta: (t) => !t.metaKey,
  left: (t) => "button" in t && t.button !== 0,
  middle: (t) => "button" in t && t.button !== 1,
  right: (t) => "button" in t && t.button !== 2,
  exact: (t, e) => Zk.some((n) => t[`${n}Key`] && !e.includes(n))
}, js = (t, e) => (n, ...a) => {
  for (let s = 0; s < e.length; s++) {
    const f = Xk[e[s]];
    if (f && f(n, e))
      return;
  }
  return t(n, ...a);
}, Kk = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Gs = (t, e) => (n) => {
  if (!("key" in n))
    return;
  const a = ta(n.key);
  if (e.some((s) => s === a || Kk[s] === a))
    return t(n);
}, Yk = /* @__PURE__ */ Wn({ patchProp: Uk }, Mk);
let bw;
function QS() {
  return bw || (bw = rk(Yk));
}
const ww = (...t) => {
  QS().render(...t);
}, Jk = (...t) => {
  const e = QS().createApp(...t);
  process.env.NODE_ENV !== "production" && (Qk(e), eL(e));
  const { mount: n } = e;
  return e.mount = (a) => {
    const s = tL(a);
    if (!s)
      return;
    const f = e._component;
    !yr(f) && !f.render && !f.template && (f.template = s.innerHTML), s.innerHTML = "";
    const o = n(s, !1, s instanceof SVGElement);
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), o;
  }, e;
};
function Qk(t) {
  Object.defineProperty(t.config, "isNativeTag", {
    value: (e) => XC(e) || KC(e),
    writable: !1
  });
}
function eL(t) {
  {
    const e = t.config.isCustomElement;
    Object.defineProperty(t.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        lt("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.");
      }
    });
    const n = t.config.compilerOptions, a = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom';
    Object.defineProperty(t.config, "compilerOptions", {
      get() {
        return lt(a), n;
      },
      set() {
        lt(a);
      }
    });
  }
}
function tL(t) {
  if (Hn(t)) {
    const e = document.querySelector(t);
    return process.env.NODE_ENV !== "production" && !e && lt(`Failed to mount app: mount target selector "${t}" returned null.`), e;
  }
  return process.env.NODE_ENV !== "production" && window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && lt('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'), t;
}
function rL() {
  Sk();
}
process.env.NODE_ENV !== "production" && rL();
/*! @license DOMPurify 2.4.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.5/LICENSE */
function Mu(t) {
  return Mu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Mu(t);
}
function G0(t, e) {
  return G0 = Object.setPrototypeOf || function(a, s) {
    return a.__proto__ = s, a;
  }, G0(t, e);
}
function nL() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function rg(t, e, n) {
  return nL() ? rg = Reflect.construct : rg = function(s, f, o) {
    var m = [null];
    m.push.apply(m, f);
    var g = Function.bind.apply(s, m), b = new g();
    return o && G0(b, o.prototype), b;
  }, rg.apply(null, arguments);
}
function Qa(t) {
  return iL(t) || oL(t) || aL(t) || sL();
}
function iL(t) {
  if (Array.isArray(t))
    return $0(t);
}
function oL(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function aL(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return $0(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set")
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return $0(t, e);
  }
}
function $0(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, a = new Array(e); n < e; n++)
    a[n] = t[n];
  return a;
}
function sL() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var lL = Object.hasOwnProperty, Ew = Object.setPrototypeOf, uL = Object.isFrozen, cL = Object.getPrototypeOf, hL = Object.getOwnPropertyDescriptor, Vo = Object.freeze, hs = Object.seal, fL = Object.create, eT = typeof Reflect < "u" && Reflect, kg = eT.apply, q0 = eT.construct;
kg || (kg = function(e, n, a) {
  return e.apply(n, a);
});
Vo || (Vo = function(e) {
  return e;
});
hs || (hs = function(e) {
  return e;
});
q0 || (q0 = function(e, n) {
  return rg(e, Qa(n));
});
var pL = za(Array.prototype.forEach), Sw = za(Array.prototype.pop), qp = za(Array.prototype.push), ng = za(String.prototype.toLowerCase), B_ = za(String.prototype.toString), dL = za(String.prototype.match), Za = za(String.prototype.replace), mL = za(String.prototype.indexOf), yL = za(String.prototype.trim), Po = za(RegExp.prototype.test), V_ = gL(TypeError);
function za(t) {
  return function(e) {
    for (var n = arguments.length, a = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      a[s - 1] = arguments[s];
    return kg(t, e, a);
  };
}
function gL(t) {
  return function() {
    for (var e = arguments.length, n = new Array(e), a = 0; a < e; a++)
      n[a] = arguments[a];
    return q0(t, n);
  };
}
function Pr(t, e, n) {
  n = n || ng, Ew && Ew(t, null);
  for (var a = e.length; a--; ) {
    var s = e[a];
    if (typeof s == "string") {
      var f = n(s);
      f !== s && (uL(e) || (e[a] = f), s = f);
    }
    t[s] = !0;
  }
  return t;
}
function Cc(t) {
  var e = fL(null), n;
  for (n in t)
    kg(lL, t, [n]) === !0 && (e[n] = t[n]);
  return e;
}
function Ty(t, e) {
  for (; t !== null; ) {
    var n = hL(t, e);
    if (n) {
      if (n.get)
        return za(n.get);
      if (typeof n.value == "function")
        return za(n.value);
    }
    t = cL(t);
  }
  function a(s) {
    return console.warn("fallback value for", s), null;
  }
  return a;
}
var Tw = Vo(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), U_ = Vo(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), j_ = Vo(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), vL = Vo(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), G_ = Vo(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), _L = Vo(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Mw = Vo(["#text"]), Iw = Vo(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), $_ = Vo(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Ow = Vo(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), My = Vo(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), xL = hs(/\{\{[\w\W]*|[\w\W]*\}\}/gm), bL = hs(/<%[\w\W]*|[\w\W]*%>/gm), wL = hs(/\${[\w\W]*}/gm), EL = hs(/^data-[\-\w.\u00B7-\uFFFF]/), SL = hs(/^aria-[\-\w]+$/), TL = hs(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
), ML = hs(/^(?:\w+script|data):/i), IL = hs(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
), OL = hs(/^html$/i), CL = function() {
  return typeof window > "u" ? null : window;
}, PL = function(e, n) {
  if (Mu(e) !== "object" || typeof e.createPolicy != "function")
    return null;
  var a = null, s = "data-tt-policy-suffix";
  n.currentScript && n.currentScript.hasAttribute(s) && (a = n.currentScript.getAttribute(s));
  var f = "dompurify" + (a ? "#" + a : "");
  try {
    return e.createPolicy(f, {
      createHTML: function(m) {
        return m;
      },
      createScriptURL: function(m) {
        return m;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + f + " could not be created."), null;
  }
};
function tT() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : CL(), e = function(fe) {
    return tT(fe);
  };
  if (e.version = "2.4.5", e.removed = [], !t || !t.document || t.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var n = t.document, a = t.document, s = t.DocumentFragment, f = t.HTMLTemplateElement, o = t.Node, m = t.Element, g = t.NodeFilter, b = t.NamedNodeMap, T = b === void 0 ? t.NamedNodeMap || t.MozNamedAttrMap : b, M = t.HTMLFormElement, I = t.DOMParser, A = t.trustedTypes, z = m.prototype, V = Ty(z, "cloneNode"), q = Ty(z, "nextSibling"), re = Ty(z, "childNodes"), X = Ty(z, "parentNode");
  if (typeof f == "function") {
    var ae = a.createElement("template");
    ae.content && ae.content.ownerDocument && (a = ae.content.ownerDocument);
  }
  var ce = PL(A, n), ve = ce ? ce.createHTML("") : "", Ne = a, ze = Ne.implementation, Ae = Ne.createNodeIterator, Se = Ne.createDocumentFragment, Ie = Ne.getElementsByTagName, Xe = n.importNode, $e = {};
  try {
    $e = Cc(a).documentMode ? a.documentMode : {};
  } catch {
  }
  var at = {};
  e.isSupported = typeof X == "function" && ze && typeof ze.createHTMLDocument < "u" && $e !== 9;
  var be = xL, Je = bL, ht = wL, vt = EL, At = SL, tr = ML, kn = IL, Nr = TL, pr = null, Zn = Pr({}, [].concat(Qa(Tw), Qa(U_), Qa(j_), Qa(G_), Qa(Mw))), Rr = null, Fi = Pr({}, [].concat(Qa(Iw), Qa($_), Qa(Ow), Qa(My))), $r = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Ar = null, Vn = null, Sr = !0, Sn = !0, ai = !1, Un = !0, K = !1, ye = !1, Re = !1, qe = !1, We = !1, nt = !1, mt = !1, et = !0, ut = !1, Qe = "user-content-", It = !0, bt = !1, Lt = {}, Ut = null, dr = Pr({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Vr = null, kr = Pr({}, ["audio", "video", "img", "source", "image", "track"]), Jr = null, Xn = Pr({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Bi = "http://www.w3.org/1998/Math/MathML", so = "http://www.w3.org/2000/svg", Kn = "http://www.w3.org/1999/xhtml", ki = Kn, Tn = !1, si = null, Fa = Pr({}, [Bi, so, Kn], B_), Uo, Ba = ["application/xhtml+xml", "text/html"], na = "text/html", sn, So = null, ol = a.createElement("form"), bn = function(fe) {
    return fe instanceof RegExp || fe instanceof Function;
  }, N = function(fe) {
    So && So === fe || ((!fe || Mu(fe) !== "object") && (fe = {}), fe = Cc(fe), Uo = Ba.indexOf(fe.PARSER_MEDIA_TYPE) === -1 ? Uo = na : Uo = fe.PARSER_MEDIA_TYPE, sn = Uo === "application/xhtml+xml" ? B_ : ng, pr = "ALLOWED_TAGS" in fe ? Pr({}, fe.ALLOWED_TAGS, sn) : Zn, Rr = "ALLOWED_ATTR" in fe ? Pr({}, fe.ALLOWED_ATTR, sn) : Fi, si = "ALLOWED_NAMESPACES" in fe ? Pr({}, fe.ALLOWED_NAMESPACES, B_) : Fa, Jr = "ADD_URI_SAFE_ATTR" in fe ? Pr(
      Cc(Xn),
      fe.ADD_URI_SAFE_ATTR,
      sn
    ) : Xn, Vr = "ADD_DATA_URI_TAGS" in fe ? Pr(
      Cc(kr),
      fe.ADD_DATA_URI_TAGS,
      sn
    ) : kr, Ut = "FORBID_CONTENTS" in fe ? Pr({}, fe.FORBID_CONTENTS, sn) : dr, Ar = "FORBID_TAGS" in fe ? Pr({}, fe.FORBID_TAGS, sn) : {}, Vn = "FORBID_ATTR" in fe ? Pr({}, fe.FORBID_ATTR, sn) : {}, Lt = "USE_PROFILES" in fe ? fe.USE_PROFILES : !1, Sr = fe.ALLOW_ARIA_ATTR !== !1, Sn = fe.ALLOW_DATA_ATTR !== !1, ai = fe.ALLOW_UNKNOWN_PROTOCOLS || !1, Un = fe.ALLOW_SELF_CLOSE_IN_ATTR !== !1, K = fe.SAFE_FOR_TEMPLATES || !1, ye = fe.WHOLE_DOCUMENT || !1, We = fe.RETURN_DOM || !1, nt = fe.RETURN_DOM_FRAGMENT || !1, mt = fe.RETURN_TRUSTED_TYPE || !1, qe = fe.FORCE_BODY || !1, et = fe.SANITIZE_DOM !== !1, ut = fe.SANITIZE_NAMED_PROPS || !1, It = fe.KEEP_CONTENT !== !1, bt = fe.IN_PLACE || !1, Nr = fe.ALLOWED_URI_REGEXP || Nr, ki = fe.NAMESPACE || Kn, $r = fe.CUSTOM_ELEMENT_HANDLING || {}, fe.CUSTOM_ELEMENT_HANDLING && bn(fe.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && ($r.tagNameCheck = fe.CUSTOM_ELEMENT_HANDLING.tagNameCheck), fe.CUSTOM_ELEMENT_HANDLING && bn(fe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && ($r.attributeNameCheck = fe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), fe.CUSTOM_ELEMENT_HANDLING && typeof fe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && ($r.allowCustomizedBuiltInElements = fe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), K && (Sn = !1), nt && (We = !0), Lt && (pr = Pr({}, Qa(Mw)), Rr = [], Lt.html === !0 && (Pr(pr, Tw), Pr(Rr, Iw)), Lt.svg === !0 && (Pr(pr, U_), Pr(Rr, $_), Pr(Rr, My)), Lt.svgFilters === !0 && (Pr(pr, j_), Pr(Rr, $_), Pr(Rr, My)), Lt.mathMl === !0 && (Pr(pr, G_), Pr(Rr, Ow), Pr(Rr, My))), fe.ADD_TAGS && (pr === Zn && (pr = Cc(pr)), Pr(pr, fe.ADD_TAGS, sn)), fe.ADD_ATTR && (Rr === Fi && (Rr = Cc(Rr)), Pr(Rr, fe.ADD_ATTR, sn)), fe.ADD_URI_SAFE_ATTR && Pr(Jr, fe.ADD_URI_SAFE_ATTR, sn), fe.FORBID_CONTENTS && (Ut === dr && (Ut = Cc(Ut)), Pr(Ut, fe.FORBID_CONTENTS, sn)), It && (pr["#text"] = !0), ye && Pr(pr, ["html", "head", "body"]), pr.table && (Pr(pr, ["tbody"]), delete Ar.tbody), Vo && Vo(fe), So = fe);
  }, F = Pr({}, ["mi", "mo", "mn", "ms", "mtext"]), U = Pr({}, ["foreignobject", "desc", "title", "annotation-xml"]), Z = Pr({}, ["title", "style", "font", "a", "script"]), Q = Pr({}, U_);
  Pr(Q, j_), Pr(Q, vL);
  var pe = Pr({}, G_);
  Pr(pe, _L);
  var de = function(fe) {
    var Ee = X(fe);
    (!Ee || !Ee.tagName) && (Ee = {
      namespaceURI: ki,
      tagName: "template"
    });
    var He = ng(fe.tagName), jt = ng(Ee.tagName);
    return si[fe.namespaceURI] ? fe.namespaceURI === so ? Ee.namespaceURI === Kn ? He === "svg" : Ee.namespaceURI === Bi ? He === "svg" && (jt === "annotation-xml" || F[jt]) : Boolean(Q[He]) : fe.namespaceURI === Bi ? Ee.namespaceURI === Kn ? He === "math" : Ee.namespaceURI === so ? He === "math" && U[jt] : Boolean(pe[He]) : fe.namespaceURI === Kn ? Ee.namespaceURI === so && !U[jt] || Ee.namespaceURI === Bi && !F[jt] ? !1 : !pe[He] && (Z[He] || !Q[He]) : !!(Uo === "application/xhtml+xml" && si[fe.namespaceURI]) : !1;
  }, G = function(fe) {
    qp(e.removed, {
      element: fe
    });
    try {
      fe.parentNode.removeChild(fe);
    } catch {
      try {
        fe.outerHTML = ve;
      } catch {
        fe.remove();
      }
    }
  }, ie = function(fe, Ee) {
    try {
      qp(e.removed, {
        attribute: Ee.getAttributeNode(fe),
        from: Ee
      });
    } catch {
      qp(e.removed, {
        attribute: null,
        from: Ee
      });
    }
    if (Ee.removeAttribute(fe), fe === "is" && !Rr[fe])
      if (We || nt)
        try {
          G(Ee);
        } catch {
        }
      else
        try {
          Ee.setAttribute(fe, "");
        } catch {
        }
  }, _e = function(fe) {
    var Ee, He;
    if (qe)
      fe = "<remove></remove>" + fe;
    else {
      var jt = dL(fe, /^[\r\n\t ]+/);
      He = jt && jt[0];
    }
    Uo === "application/xhtml+xml" && ki === Kn && (fe = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + fe + "</body></html>");
    var qt = ce ? ce.createHTML(fe) : fe;
    if (ki === Kn)
      try {
        Ee = new I().parseFromString(qt, Uo);
      } catch {
      }
    if (!Ee || !Ee.documentElement) {
      Ee = ze.createDocument(ki, "template", null);
      try {
        Ee.documentElement.innerHTML = Tn ? ve : qt;
      } catch {
      }
    }
    var Jt = Ee.body || Ee.documentElement;
    return fe && He && Jt.insertBefore(a.createTextNode(He), Jt.childNodes[0] || null), ki === Kn ? Ie.call(Ee, ye ? "html" : "body")[0] : ye ? Ee.documentElement : Jt;
  }, Ge = function(fe) {
    return Ae.call(
      fe.ownerDocument || fe,
      fe,
      g.SHOW_ELEMENT | g.SHOW_COMMENT | g.SHOW_TEXT,
      null,
      !1
    );
  }, Ze = function(fe) {
    return fe instanceof M && (typeof fe.nodeName != "string" || typeof fe.textContent != "string" || typeof fe.removeChild != "function" || !(fe.attributes instanceof T) || typeof fe.removeAttribute != "function" || typeof fe.setAttribute != "function" || typeof fe.namespaceURI != "string" || typeof fe.insertBefore != "function" || typeof fe.hasChildNodes != "function");
  }, Ce = function(fe) {
    return Mu(o) === "object" ? fe instanceof o : fe && Mu(fe) === "object" && typeof fe.nodeType == "number" && typeof fe.nodeName == "string";
  }, Ue = function(fe, Ee, He) {
    !at[fe] || pL(at[fe], function(jt) {
      jt.call(e, Ee, He, So);
    });
  }, Et = function(fe) {
    var Ee;
    if (Ue("beforeSanitizeElements", fe, null), Ze(fe) || Po(/[\u0080-\uFFFF]/, fe.nodeName))
      return G(fe), !0;
    var He = sn(fe.nodeName);
    if (Ue("uponSanitizeElement", fe, {
      tagName: He,
      allowedTags: pr
    }), fe.hasChildNodes() && !Ce(fe.firstElementChild) && (!Ce(fe.content) || !Ce(fe.content.firstElementChild)) && Po(/<[/\w]/g, fe.innerHTML) && Po(/<[/\w]/g, fe.textContent) || He === "select" && Po(/<template/i, fe.innerHTML))
      return G(fe), !0;
    if (!pr[He] || Ar[He]) {
      if (!Ar[He] && Le(He) && ($r.tagNameCheck instanceof RegExp && Po($r.tagNameCheck, He) || $r.tagNameCheck instanceof Function && $r.tagNameCheck(He)))
        return !1;
      if (It && !Ut[He]) {
        var jt = X(fe) || fe.parentNode, qt = re(fe) || fe.childNodes;
        if (qt && jt)
          for (var Jt = qt.length, Zt = Jt - 1; Zt >= 0; --Zt)
            jt.insertBefore(V(qt[Zt], !0), q(fe));
      }
      return G(fe), !0;
    }
    return fe instanceof m && !de(fe) || (He === "noscript" || He === "noembed") && Po(/<\/no(script|embed)/i, fe.innerHTML) ? (G(fe), !0) : (K && fe.nodeType === 3 && (Ee = fe.textContent, Ee = Za(Ee, be, " "), Ee = Za(Ee, Je, " "), Ee = Za(Ee, ht, " "), fe.textContent !== Ee && (qp(e.removed, {
      element: fe.cloneNode()
    }), fe.textContent = Ee)), Ue("afterSanitizeElements", fe, null), !1);
  }, _t = function(fe, Ee, He) {
    if (et && (Ee === "id" || Ee === "name") && (He in a || He in ol))
      return !1;
    if (!(Sn && !Vn[Ee] && Po(vt, Ee))) {
      if (!(Sr && Po(At, Ee))) {
        if (!Rr[Ee] || Vn[Ee]) {
          if (!(Le(fe) && ($r.tagNameCheck instanceof RegExp && Po($r.tagNameCheck, fe) || $r.tagNameCheck instanceof Function && $r.tagNameCheck(fe)) && ($r.attributeNameCheck instanceof RegExp && Po($r.attributeNameCheck, Ee) || $r.attributeNameCheck instanceof Function && $r.attributeNameCheck(Ee)) || Ee === "is" && $r.allowCustomizedBuiltInElements && ($r.tagNameCheck instanceof RegExp && Po($r.tagNameCheck, He) || $r.tagNameCheck instanceof Function && $r.tagNameCheck(He))))
            return !1;
        } else if (!Jr[Ee]) {
          if (!Po(Nr, Za(He, kn, ""))) {
            if (!((Ee === "src" || Ee === "xlink:href" || Ee === "href") && fe !== "script" && mL(He, "data:") === 0 && Vr[fe])) {
              if (!(ai && !Po(tr, Za(He, kn, "")))) {
                if (He)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Le = function(fe) {
    return fe.indexOf("-") > 0;
  }, pt = function(fe) {
    var Ee, He, jt, qt;
    Ue("beforeSanitizeAttributes", fe, null);
    var Jt = fe.attributes;
    if (!!Jt) {
      var Zt = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: Rr
      };
      for (qt = Jt.length; qt--; ) {
        Ee = Jt[qt];
        var Yn = Ee, Qt = Yn.name, dn = Yn.namespaceURI;
        if (He = Qt === "value" ? Ee.value : yL(Ee.value), jt = sn(Qt), Zt.attrName = jt, Zt.attrValue = He, Zt.keepAttr = !0, Zt.forceKeepAttr = void 0, Ue("uponSanitizeAttribute", fe, Zt), He = Zt.attrValue, !Zt.forceKeepAttr && (ie(Qt, fe), !!Zt.keepAttr)) {
          if (!Un && Po(/\/>/i, He)) {
            ie(Qt, fe);
            continue;
          }
          K && (He = Za(He, be, " "), He = Za(He, Je, " "), He = Za(He, ht, " "));
          var Ur = sn(fe.nodeName);
          if (!!_t(Ur, jt, He)) {
            if (ut && (jt === "id" || jt === "name") && (ie(Qt, fe), He = Qe + He), ce && Mu(A) === "object" && typeof A.getAttributeType == "function" && !dn)
              switch (A.getAttributeType(Ur, jt)) {
                case "TrustedHTML":
                  He = ce.createHTML(He);
                  break;
                case "TrustedScriptURL":
                  He = ce.createScriptURL(He);
                  break;
              }
            try {
              dn ? fe.setAttributeNS(dn, Qt, He) : fe.setAttribute(Qt, He), Sw(e.removed);
            } catch {
            }
          }
        }
      }
      Ue("afterSanitizeAttributes", fe, null);
    }
  }, st = function De(fe) {
    var Ee, He = Ge(fe);
    for (Ue("beforeSanitizeShadowDOM", fe, null); Ee = He.nextNode(); )
      Ue("uponSanitizeShadowNode", Ee, null), !Et(Ee) && (Ee.content instanceof s && De(Ee.content), pt(Ee));
    Ue("afterSanitizeShadowDOM", fe, null);
  };
  return e.sanitize = function(De) {
    var fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Ee, He, jt, qt, Jt;
    if (Tn = !De, Tn && (De = "<!-->"), typeof De != "string" && !Ce(De)) {
      if (typeof De.toString != "function")
        throw V_("toString is not a function");
      if (De = De.toString(), typeof De != "string")
        throw V_("dirty is not a string, aborting");
    }
    if (!e.isSupported) {
      if (Mu(t.toStaticHTML) === "object" || typeof t.toStaticHTML == "function") {
        if (typeof De == "string")
          return t.toStaticHTML(De);
        if (Ce(De))
          return t.toStaticHTML(De.outerHTML);
      }
      return De;
    }
    if (Re || N(fe), e.removed = [], typeof De == "string" && (bt = !1), bt) {
      if (De.nodeName) {
        var Zt = sn(De.nodeName);
        if (!pr[Zt] || Ar[Zt])
          throw V_("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (De instanceof o)
      Ee = _e("<!---->"), He = Ee.ownerDocument.importNode(De, !0), He.nodeType === 1 && He.nodeName === "BODY" || He.nodeName === "HTML" ? Ee = He : Ee.appendChild(He);
    else {
      if (!We && !K && !ye && De.indexOf("<") === -1)
        return ce && mt ? ce.createHTML(De) : De;
      if (Ee = _e(De), !Ee)
        return We ? null : mt ? ve : "";
    }
    Ee && qe && G(Ee.firstChild);
    for (var Yn = Ge(bt ? De : Ee); jt = Yn.nextNode(); )
      jt.nodeType === 3 && jt === qt || Et(jt) || (jt.content instanceof s && st(jt.content), pt(jt), qt = jt);
    if (qt = null, bt)
      return De;
    if (We) {
      if (nt)
        for (Jt = Se.call(Ee.ownerDocument); Ee.firstChild; )
          Jt.appendChild(Ee.firstChild);
      else
        Jt = Ee;
      return (Rr.shadowroot || Rr.shadowrootmod) && (Jt = Xe.call(n, Jt, !0)), Jt;
    }
    var Qt = ye ? Ee.outerHTML : Ee.innerHTML;
    return ye && pr["!doctype"] && Ee.ownerDocument && Ee.ownerDocument.doctype && Ee.ownerDocument.doctype.name && Po(OL, Ee.ownerDocument.doctype.name) && (Qt = "<!DOCTYPE " + Ee.ownerDocument.doctype.name + `>
` + Qt), K && (Qt = Za(Qt, be, " "), Qt = Za(Qt, Je, " "), Qt = Za(Qt, ht, " ")), ce && mt ? ce.createHTML(Qt) : Qt;
  }, e.setConfig = function(De) {
    N(De), Re = !0;
  }, e.clearConfig = function() {
    So = null, Re = !1;
  }, e.isValidAttribute = function(De, fe, Ee) {
    So || N({});
    var He = sn(De), jt = sn(fe);
    return _t(He, jt, Ee);
  }, e.addHook = function(De, fe) {
    typeof fe == "function" && (at[De] = at[De] || [], qp(at[De], fe));
  }, e.removeHook = function(De) {
    if (at[De])
      return Sw(at[De]);
  }, e.removeHooks = function(De) {
    at[De] && (at[De] = []);
  }, e.removeAllHooks = function() {
    at = {};
  }, e;
}
var AL = tT(), rT = !1;
function Iy(t, e, n) {
  return Array.isArray(t) ? (t.length = Math.max(t.length, e), t.splice(e, 1, n), n) : (t[e] = n, n);
}
function q_(t, e) {
  if (Array.isArray(t)) {
    t.splice(e, 1);
    return;
  }
  delete t[e];
}
function kL(t, e) {
  var s;
  const n = (s = t.hooks) != null ? s : {};
  let a;
  for (a in n) {
    const f = n[a];
    f !== void 0 && e.addHook(a, f);
  }
}
function nT() {
  return AL();
}
function LL(t = {}, e = nT) {
  const n = e();
  kL(t, n);
  const a = function(s, f) {
    var M, I;
    const o = f.value;
    if (f.oldValue === o)
      return;
    const m = `${o}`, g = f.arg, b = t.namedConfigurations, T = (M = t.default) != null ? M : {};
    if (b && g !== void 0) {
      s.innerHTML = n.sanitize(
        m,
        (I = b[g]) != null ? I : T
      );
      return;
    }
    s.innerHTML = n.sanitize(
      m,
      T
    );
  };
  return {
    mounted: a,
    updated: a
  };
}
const DL = {
  install(t, e = {}, n = nT) {
    t.directive(
      "dompurify-html",
      LL(e, n)
    );
  }
};
function NL() {
  return iT().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function iT() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
}
const RL = typeof Proxy == "function", zL = "devtools-plugin:setup", FL = "plugin:settings:set";
let rf, W0;
function BL() {
  var t;
  return rf !== void 0 || (typeof window < "u" && window.performance ? (rf = !0, W0 = window.performance) : typeof global < "u" && ((t = global.perf_hooks) === null || t === void 0 ? void 0 : t.performance) ? (rf = !0, W0 = global.perf_hooks.performance) : rf = !1), rf;
}
function VL() {
  return BL() ? W0.now() : Date.now();
}
class UL {
  constructor(e, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e, this.hook = n;
    const a = {};
    if (e.settings)
      for (const o in e.settings) {
        const m = e.settings[o];
        a[o] = m.defaultValue;
      }
    const s = `__vue-devtools-plugin-settings__${e.id}`;
    let f = Object.assign({}, a);
    try {
      const o = localStorage.getItem(s), m = JSON.parse(o);
      Object.assign(f, m);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return f;
      },
      setSettings(o) {
        try {
          localStorage.setItem(s, JSON.stringify(o));
        } catch {
        }
        f = o;
      },
      now() {
        return VL();
      }
    }, n && n.on(FL, (o, m) => {
      o === this.plugin.id && this.fallbacks.setSettings(m);
    }), this.proxiedOn = new Proxy({}, {
      get: (o, m) => this.target ? this.target.on[m] : (...g) => {
        this.onQueue.push({
          method: m,
          args: g
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (o, m) => this.target ? this.target[m] : m === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(m) ? (...g) => (this.targetQueue.push({
        method: m,
        args: g,
        resolve: () => {
        }
      }), this.fallbacks[m](...g)) : (...g) => new Promise((b) => {
        this.targetQueue.push({
          method: m,
          args: g,
          resolve: b
        });
      })
    });
  }
  async setRealTarget(e) {
    this.target = e;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function oT(t, e) {
  const n = t, a = iT(), s = NL(), f = RL && n.enableEarlyProxy;
  if (s && (a.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !f))
    s.emit(zL, t, e);
  else {
    const o = f ? new UL(n, s) : null;
    (a.__VUE_DEVTOOLS_PLUGINS__ = a.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: e,
      proxy: o
    }), o && e(o.proxiedTarget);
  }
}
/*!
  * pinia v2.0.33
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
let ed;
const kd = (t) => ed = t, aT = process.env.NODE_ENV !== "production" ? Symbol("pinia") : Symbol();
function Qc(t) {
  return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
}
var Hs;
(function(t) {
  t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
})(Hs || (Hs = {}));
const Mv = typeof window < "u", md = (process.env.NODE_ENV !== "production" || !1) && process.env.NODE_ENV !== "test" && Mv, Cw = /* @__PURE__ */ (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : { HTMLElement: null })();
function jL(t, { autoBom: e = !1 } = {}) {
  return e && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], { type: t.type }) : t;
}
function Ux(t, e, n) {
  const a = new XMLHttpRequest();
  a.open("GET", t), a.responseType = "blob", a.onload = function() {
    uT(a.response, e, n);
  }, a.onerror = function() {
    console.error("could not download file");
  }, a.send();
}
function sT(t) {
  const e = new XMLHttpRequest();
  e.open("HEAD", t, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function ig(t) {
  try {
    t.dispatchEvent(new MouseEvent("click"));
  } catch {
    const n = document.createEvent("MouseEvents");
    n.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), t.dispatchEvent(n);
  }
}
const og = typeof navigator == "object" ? navigator : { userAgent: "" }, lT = /* @__PURE__ */ (() => /Macintosh/.test(og.userAgent) && /AppleWebKit/.test(og.userAgent) && !/Safari/.test(og.userAgent))(), uT = Mv ? typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !lT ? GL : "msSaveOrOpenBlob" in og ? $L : qL : () => {
};
function GL(t, e = "download", n) {
  const a = document.createElement("a");
  a.download = e, a.rel = "noopener", typeof t == "string" ? (a.href = t, a.origin !== location.origin ? sT(a.href) ? Ux(t, e, n) : (a.target = "_blank", ig(a)) : ig(a)) : (a.href = URL.createObjectURL(t), setTimeout(function() {
    URL.revokeObjectURL(a.href);
  }, 4e4), setTimeout(function() {
    ig(a);
  }, 0));
}
function $L(t, e = "download", n) {
  if (typeof t == "string")
    if (sT(t))
      Ux(t, e, n);
    else {
      const a = document.createElement("a");
      a.href = t, a.target = "_blank", setTimeout(function() {
        ig(a);
      });
    }
  else
    navigator.msSaveOrOpenBlob(jL(t, n), e);
}
function qL(t, e, n, a) {
  if (a = a || open("", "_blank"), a && (a.document.title = a.document.body.innerText = "downloading..."), typeof t == "string")
    return Ux(t, e, n);
  const s = t.type === "application/octet-stream", f = /constructor/i.test(String(Cw.HTMLElement)) || "safari" in Cw, o = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((o || s && f || lT) && typeof FileReader < "u") {
    const m = new FileReader();
    m.onloadend = function() {
      let g = m.result;
      if (typeof g != "string")
        throw a = null, new Error("Wrong reader.result type");
      g = o ? g : g.replace(/^data:[^;]*;/, "data:attachment/file;"), a ? a.location.href = g : location.assign(g), a = null;
    }, m.readAsDataURL(t);
  } else {
    const m = URL.createObjectURL(t);
    a ? a.location.assign(m) : location.href = m, a = null, setTimeout(function() {
      URL.revokeObjectURL(m);
    }, 4e4);
  }
}
function Zi(t, e) {
  const n = "\u{1F34D} " + t;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(n, e) : e === "error" ? console.error(n) : e === "warn" ? console.warn(n) : console.log(n);
}
function jx(t) {
  return "_a" in t && "install" in t;
}
function cT() {
  if (!("clipboard" in navigator))
    return Zi("Your browser doesn't support the Clipboard API", "error"), !0;
}
function hT(t) {
  return t instanceof Error && t.message.toLowerCase().includes("document is not focused") ? (Zi('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) : !1;
}
async function WL(t) {
  if (!cT())
    try {
      await navigator.clipboard.writeText(JSON.stringify(t.state.value)), Zi("Global state copied to clipboard.");
    } catch (e) {
      if (hT(e))
        return;
      Zi("Failed to serialize the state. Check the console for more details.", "error"), console.error(e);
    }
}
async function HL(t) {
  if (!cT())
    try {
      t.state.value = JSON.parse(await navigator.clipboard.readText()), Zi("Global state pasted from clipboard.");
    } catch (e) {
      if (hT(e))
        return;
      Zi("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(e);
    }
}
async function ZL(t) {
  try {
    uT(new Blob([JSON.stringify(t.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (e) {
    Zi("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
let Al;
function XL() {
  Al || (Al = document.createElement("input"), Al.type = "file", Al.accept = ".json");
  function t() {
    return new Promise((e, n) => {
      Al.onchange = async () => {
        const a = Al.files;
        if (!a)
          return e(null);
        const s = a.item(0);
        return e(s ? { text: await s.text(), file: s } : null);
      }, Al.oncancel = () => e(null), Al.onerror = n, Al.click();
    });
  }
  return t;
}
async function KL(t) {
  try {
    const n = await (await XL())();
    if (!n)
      return;
    const { text: a, file: s } = n;
    t.state.value = JSON.parse(a), Zi(`Global state imported from "${s.name}".`);
  } catch (e) {
    Zi("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
function es(t) {
  return {
    _custom: {
      display: t
    }
  };
}
const fT = "\u{1F34D} Pinia (root)", H0 = "_root";
function YL(t) {
  return jx(t) ? {
    id: H0,
    label: fT
  } : {
    id: t.$id,
    label: t.$id
  };
}
function JL(t) {
  if (jx(t)) {
    const n = Array.from(t._s.keys()), a = t._s;
    return {
      state: n.map((f) => ({
        editable: !0,
        key: f,
        value: t.state.value[f]
      })),
      getters: n.filter((f) => a.get(f)._getters).map((f) => {
        const o = a.get(f);
        return {
          editable: !1,
          key: f,
          value: o._getters.reduce((m, g) => (m[g] = o[g], m), {})
        };
      })
    };
  }
  const e = {
    state: Object.keys(t.$state).map((n) => ({
      editable: !0,
      key: n,
      value: t.$state[n]
    }))
  };
  return t._getters && t._getters.length && (e.getters = t._getters.map((n) => ({
    editable: !1,
    key: n,
    value: t[n]
  }))), t._customProperties.size && (e.customProperties = Array.from(t._customProperties).map((n) => ({
    editable: !0,
    key: n,
    value: t[n]
  }))), e;
}
function QL(t) {
  return t ? Array.isArray(t) ? t.reduce((e, n) => (e.keys.push(n.key), e.operations.push(n.type), e.oldValue[n.key] = n.oldValue, e.newValue[n.key] = n.newValue, e), {
    oldValue: {},
    keys: [],
    operations: [],
    newValue: {}
  }) : {
    operation: es(t.type),
    key: es(t.key),
    oldValue: t.oldValue,
    newValue: t.newValue
  } : {};
}
function eD(t) {
  switch (t) {
    case Hs.direct:
      return "mutation";
    case Hs.patchFunction:
      return "$patch";
    case Hs.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let yf = !0;
const ag = [], zc = "pinia:mutations", vo = "pinia", { assign: tD } = Object, Lg = (t) => "\u{1F34D} " + t;
function rD(t, e) {
  oT({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: ag,
    app: t
  }, (n) => {
    typeof n.now != "function" && Zi("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), n.addTimelineLayer({
      id: zc,
      label: "Pinia \u{1F34D}",
      color: 15064968
    }), n.addInspector({
      id: vo,
      label: "Pinia \u{1F34D}",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            WL(e);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: async () => {
            await HL(e), n.sendInspectorTree(vo), n.sendInspectorState(vo);
          },
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            ZL(e);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: async () => {
            await KL(e), n.sendInspectorTree(vo), n.sendInspectorState(vo);
          },
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: "Reset the state (option store only)",
          action: (a) => {
            const s = e._s.get(a);
            s ? s._isOptionsAPI ? (s.$reset(), Zi(`Store "${a}" reset.`)) : Zi(`Cannot reset "${a}" store because it's a setup store.`, "warn") : Zi(`Cannot reset "${a}" store because it wasn't found.`, "warn");
          }
        }
      ]
    }), n.on.inspectComponent((a, s) => {
      const f = a.componentInstance && a.componentInstance.proxy;
      if (f && f._pStores) {
        const o = a.componentInstance.proxy._pStores;
        Object.values(o).forEach((m) => {
          a.instanceData.state.push({
            type: Lg(m.$id),
            key: "state",
            editable: !0,
            value: m._isOptionsAPI ? {
              _custom: {
                value: hr(m.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => m.$reset()
                  }
                ]
              }
            } : Object.keys(m.$state).reduce((g, b) => (g[b] = m.$state[b], g), {})
          }), m._getters && m._getters.length && a.instanceData.state.push({
            type: Lg(m.$id),
            key: "getters",
            editable: !1,
            value: m._getters.reduce((g, b) => {
              try {
                g[b] = m[b];
              } catch (T) {
                g[b] = T;
              }
              return g;
            }, {})
          });
        });
      }
    }), n.on.getInspectorTree((a) => {
      if (a.app === t && a.inspectorId === vo) {
        let s = [e];
        s = s.concat(Array.from(e._s.values())), a.rootNodes = (a.filter ? s.filter((f) => "$id" in f ? f.$id.toLowerCase().includes(a.filter.toLowerCase()) : fT.toLowerCase().includes(a.filter.toLowerCase())) : s).map(YL);
      }
    }), n.on.getInspectorState((a) => {
      if (a.app === t && a.inspectorId === vo) {
        const s = a.nodeId === H0 ? e : e._s.get(a.nodeId);
        if (!s)
          return;
        s && (a.state = JL(s));
      }
    }), n.on.editInspectorState((a, s) => {
      if (a.app === t && a.inspectorId === vo) {
        const f = a.nodeId === H0 ? e : e._s.get(a.nodeId);
        if (!f)
          return Zi(`store "${a.nodeId}" not found`, "error");
        const { path: o } = a;
        jx(f) ? o.unshift("state") : (o.length !== 1 || !f._customProperties.has(o[0]) || o[0] in f.$state) && o.unshift("$state"), yf = !1, a.set(f, o, a.state.value), yf = !0;
      }
    }), n.on.editComponentState((a) => {
      if (a.type.startsWith("\u{1F34D}")) {
        const s = a.type.replace(/^\s*/, ""), f = e._s.get(s);
        if (!f)
          return Zi(`store "${s}" not found`, "error");
        const { path: o } = a;
        if (o[0] !== "state")
          return Zi(`Invalid path for store "${s}":
${o}
Only state can be modified.`);
        o[0] = "$state", yf = !1, a.set(f, o, a.state.value), yf = !0;
      }
    });
  });
}
function nD(t, e) {
  ag.includes(Lg(e.$id)) || ag.push(Lg(e.$id)), oT({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: ag,
    app: t,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: !0
      }
    }
  }, (n) => {
    const a = typeof n.now == "function" ? n.now.bind(n) : Date.now;
    e.$onAction(({ after: o, onError: m, name: g, args: b }) => {
      const T = pT++;
      n.addTimelineEvent({
        layerId: zc,
        event: {
          time: a(),
          title: "\u{1F6EB} " + g,
          subtitle: "start",
          data: {
            store: es(e.$id),
            action: es(g),
            args: b
          },
          groupId: T
        }
      }), o((M) => {
        jc = void 0, n.addTimelineEvent({
          layerId: zc,
          event: {
            time: a(),
            title: "\u{1F6EC} " + g,
            subtitle: "end",
            data: {
              store: es(e.$id),
              action: es(g),
              args: b,
              result: M
            },
            groupId: T
          }
        });
      }), m((M) => {
        jc = void 0, n.addTimelineEvent({
          layerId: zc,
          event: {
            time: a(),
            logType: "error",
            title: "\u{1F4A5} " + g,
            subtitle: "end",
            data: {
              store: es(e.$id),
              action: es(g),
              args: b,
              error: M
            },
            groupId: T
          }
        });
      });
    }, !0), e._customProperties.forEach((o) => {
      An(() => se(e[o]), (m, g) => {
        n.notifyComponentUpdate(), n.sendInspectorState(vo), yf && n.addTimelineEvent({
          layerId: zc,
          event: {
            time: a(),
            title: "Change",
            subtitle: o,
            data: {
              newValue: m,
              oldValue: g
            },
            groupId: jc
          }
        });
      }, { deep: !0 });
    }), e.$subscribe(({ events: o, type: m }, g) => {
      if (n.notifyComponentUpdate(), n.sendInspectorState(vo), !yf)
        return;
      const b = {
        time: a(),
        title: eD(m),
        data: tD({ store: es(e.$id) }, QL(o)),
        groupId: jc
      };
      jc = void 0, m === Hs.patchFunction ? b.subtitle = "\u2935\uFE0F" : m === Hs.patchObject ? b.subtitle = "\u{1F9E9}" : o && !Array.isArray(o) && (b.subtitle = o.type), o && (b.data["rawEvent(s)"] = {
        _custom: {
          display: "DebuggerEvent",
          type: "object",
          tooltip: "raw DebuggerEvent[]",
          value: o
        }
      }), n.addTimelineEvent({
        layerId: zc,
        event: b
      });
    }, { detached: !0, flush: "sync" });
    const s = e._hotUpdate;
    e._hotUpdate = ts((o) => {
      s(o), n.addTimelineEvent({
        layerId: zc,
        event: {
          time: a(),
          title: "\u{1F525} " + e.$id,
          subtitle: "HMR update",
          data: {
            store: es(e.$id),
            info: es("HMR update")
          }
        }
      }), n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo);
    });
    const { $dispose: f } = e;
    e.$dispose = () => {
      f(), n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo), n.getSettings().logStoreChanges && Zi(`Disposed "${e.$id}" store \u{1F5D1}`);
    }, n.notifyComponentUpdate(), n.sendInspectorTree(vo), n.sendInspectorState(vo), n.getSettings().logStoreChanges && Zi(`"${e.$id}" store installed \u{1F195}`);
  });
}
let pT = 0, jc;
function Pw(t, e) {
  const n = e.reduce((a, s) => (a[s] = hr(t)[s], a), {});
  for (const a in n)
    t[a] = function() {
      const s = pT, f = new Proxy(t, {
        get(...o) {
          return jc = s, Reflect.get(...o);
        },
        set(...o) {
          return jc = s, Reflect.set(...o);
        }
      });
      return n[a].apply(f, arguments);
    };
}
function iD({ app: t, store: e, options: n }) {
  if (!e.$id.startsWith("__hot:")) {
    if (n.state && (e._isOptionsAPI = !0), typeof n.state == "function") {
      Pw(
        e,
        Object.keys(n.actions)
      );
      const a = e._hotUpdate;
      hr(e)._hotUpdate = function(s) {
        a.apply(this, arguments), Pw(e, Object.keys(s._hmrPayload.actions));
      };
    }
    nD(
      t,
      e
    );
  }
}
function oD() {
  const t = GE(!0), e = t.run(() => Er({}));
  let n = [], a = [];
  const s = ts({
    install(f) {
      kd(s), s._a = f, f.provide(aT, s), f.config.globalProperties.$pinia = s, md && rD(f, s), a.forEach((o) => n.push(o)), a = [];
    },
    use(f) {
      return !this._a && !rT ? a.push(f) : n.push(f), this;
    },
    _p: n,
    _a: null,
    _e: t,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return md && typeof Proxy < "u" && s.use(iD), s;
}
function dT(t, e) {
  for (const n in e) {
    const a = e[n];
    if (!(n in t))
      continue;
    const s = t[n];
    Qc(s) && Qc(a) && !hn(a) && !ss(a) ? t[n] = dT(s, a) : t[n] = a;
  }
  return t;
}
const mT = () => {
};
function Aw(t, e, n, a = mT) {
  t.push(e);
  const s = () => {
    const f = t.indexOf(e);
    f > -1 && (t.splice(f, 1), a());
  };
  return !n && $E() && aP(s), s;
}
function nf(t, ...e) {
  t.slice().forEach((n) => {
    n(...e);
  });
}
function Z0(t, e) {
  t instanceof Map && e instanceof Map && e.forEach((n, a) => t.set(a, n)), t instanceof Set && e instanceof Set && e.forEach(t.add, t);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const a = e[n], s = t[n];
    Qc(s) && Qc(a) && t.hasOwnProperty(n) && !hn(a) && !ss(a) ? t[n] = Z0(s, a) : t[n] = a;
  }
  return t;
}
const aD = process.env.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : Symbol();
function sD(t) {
  return !Qc(t) || !t.hasOwnProperty(aD);
}
const { assign: Ca } = Object;
function kw(t) {
  return !!(hn(t) && t.effect);
}
function Lw(t, e, n, a) {
  const { state: s, actions: f, getters: o } = e, m = n.state.value[t];
  let g;
  function b() {
    !m && (process.env.NODE_ENV === "production" || !a) && (n.state.value[t] = s ? s() : {});
    const T = process.env.NODE_ENV !== "production" && a ? qb(Er(s ? s() : {}).value) : qb(n.state.value[t]);
    return Ca(T, f, Object.keys(o || {}).reduce((M, I) => (process.env.NODE_ENV !== "production" && I in T && console.warn(`[\u{1F34D}]: A getter cannot have the same name as another state property. Rename one of them. Found with "${I}" in store "${t}".`), M[I] = ts(ar(() => {
      kd(n);
      const A = n._s.get(t);
      return o[I].call(A, A);
    })), M), {}));
  }
  return g = X0(t, b, e, n, a, !0), g;
}
function X0(t, e, n = {}, a, s, f) {
  let o;
  const m = Ca({ actions: {} }, n);
  if (process.env.NODE_ENV !== "production" && !a._e.active)
    throw new Error("Pinia destroyed");
  const g = {
    deep: !0
  };
  process.env.NODE_ENV !== "production" && !rT && (g.onTrigger = (Se) => {
    b ? A = Se : b == !1 && !ze._hotUpdating && (Array.isArray(A) ? A.push(Se) : console.error("\u{1F34D} debuggerEvents should be an array. This is most likely an internal Pinia bug."));
  });
  let b, T, M = ts([]), I = ts([]), A;
  const z = a.state.value[t];
  !f && !z && (process.env.NODE_ENV === "production" || !s) && (a.state.value[t] = {});
  const V = Er({});
  let q;
  function re(Se) {
    let Ie;
    b = T = !1, process.env.NODE_ENV !== "production" && (A = []), typeof Se == "function" ? (Se(a.state.value[t]), Ie = {
      type: Hs.patchFunction,
      storeId: t,
      events: A
    }) : (Z0(a.state.value[t], Se), Ie = {
      type: Hs.patchObject,
      payload: Se,
      storeId: t,
      events: A
    });
    const Xe = q = Symbol();
    Tg().then(() => {
      q === Xe && (b = !0);
    }), T = !0, nf(M, Ie, a.state.value[t]);
  }
  const X = f ? function() {
    const { state: Ie } = n, Xe = Ie ? Ie() : {};
    this.$patch(($e) => {
      Ca($e, Xe);
    });
  } : process.env.NODE_ENV !== "production" ? () => {
    throw new Error(`\u{1F34D}: Store "${t}" is built using the setup syntax and does not implement $reset().`);
  } : mT;
  function ae() {
    o.stop(), M = [], I = [], a._s.delete(t);
  }
  function ce(Se, Ie) {
    return function() {
      kd(a);
      const Xe = Array.from(arguments), $e = [], at = [];
      function be(vt) {
        $e.push(vt);
      }
      function Je(vt) {
        at.push(vt);
      }
      nf(I, {
        args: Xe,
        name: Se,
        store: ze,
        after: be,
        onError: Je
      });
      let ht;
      try {
        ht = Ie.apply(this && this.$id === t ? this : ze, Xe);
      } catch (vt) {
        throw nf(at, vt), vt;
      }
      return ht instanceof Promise ? ht.then((vt) => (nf($e, vt), vt)).catch((vt) => (nf(at, vt), Promise.reject(vt))) : (nf($e, ht), ht);
    };
  }
  const ve = /* @__PURE__ */ ts({
    actions: {},
    getters: {},
    state: [],
    hotState: V
  }), Ne = {
    _p: a,
    $id: t,
    $onAction: Aw.bind(null, I),
    $patch: re,
    $reset: X,
    $subscribe(Se, Ie = {}) {
      const Xe = Aw(M, Se, Ie.detached, () => $e()), $e = o.run(() => An(() => a.state.value[t], (at) => {
        (Ie.flush === "sync" ? T : b) && Se({
          storeId: t,
          type: Hs.direct,
          events: A
        }, at);
      }, Ca({}, g, Ie)));
      return Xe;
    },
    $dispose: ae
  }, ze = mv(process.env.NODE_ENV !== "production" || md ? Ca(
    {
      _hmrPayload: ve,
      _customProperties: ts(/* @__PURE__ */ new Set())
    },
    Ne
  ) : Ne);
  a._s.set(t, ze);
  const Ae = a._e.run(() => (o = GE(), o.run(() => e())));
  for (const Se in Ae) {
    const Ie = Ae[Se];
    if (hn(Ie) && !kw(Ie) || ss(Ie))
      process.env.NODE_ENV !== "production" && s ? Iy(V.value, Se, cd(Ae, Se)) : f || (z && sD(Ie) && (hn(Ie) ? Ie.value = z[Se] : Z0(Ie, z[Se])), a.state.value[t][Se] = Ie), process.env.NODE_ENV !== "production" && ve.state.push(Se);
    else if (typeof Ie == "function") {
      const Xe = process.env.NODE_ENV !== "production" && s ? Ie : ce(Se, Ie);
      Ae[Se] = Xe, process.env.NODE_ENV !== "production" && (ve.actions[Se] = Ie), m.actions[Se] = Ie;
    } else
      process.env.NODE_ENV !== "production" && kw(Ie) && (ve.getters[Se] = f ? n.getters[Se] : Ie, Mv && (Ae._getters || (Ae._getters = ts([]))).push(Se));
  }
  if (Ca(ze, Ae), Ca(hr(ze), Ae), Object.defineProperty(ze, "$state", {
    get: () => process.env.NODE_ENV !== "production" && s ? V.value : a.state.value[t],
    set: (Se) => {
      if (process.env.NODE_ENV !== "production" && s)
        throw new Error("cannot set hotState");
      re((Ie) => {
        Ca(Ie, Se);
      });
    }
  }), process.env.NODE_ENV !== "production" && (ze._hotUpdate = ts((Se) => {
    ze._hotUpdating = !0, Se._hmrPayload.state.forEach((Ie) => {
      if (Ie in ze.$state) {
        const Xe = Se.$state[Ie], $e = ze.$state[Ie];
        typeof Xe == "object" && Qc(Xe) && Qc($e) ? dT(Xe, $e) : Se.$state[Ie] = $e;
      }
      Iy(ze, Ie, cd(Se.$state, Ie));
    }), Object.keys(ze.$state).forEach((Ie) => {
      Ie in Se.$state || q_(ze, Ie);
    }), b = !1, T = !1, a.state.value[t] = cd(Se._hmrPayload, "hotState"), T = !0, Tg().then(() => {
      b = !0;
    });
    for (const Ie in Se._hmrPayload.actions) {
      const Xe = Se[Ie];
      Iy(ze, Ie, ce(Ie, Xe));
    }
    for (const Ie in Se._hmrPayload.getters) {
      const Xe = Se._hmrPayload.getters[Ie], $e = f ? ar(() => (kd(a), Xe.call(ze, ze))) : Xe;
      Iy(ze, Ie, $e);
    }
    Object.keys(ze._hmrPayload.getters).forEach((Ie) => {
      Ie in Se._hmrPayload.getters || q_(ze, Ie);
    }), Object.keys(ze._hmrPayload.actions).forEach((Ie) => {
      Ie in Se._hmrPayload.actions || q_(ze, Ie);
    }), ze._hmrPayload = Se._hmrPayload, ze._getters = Se._getters, ze._hotUpdating = !1;
  })), md) {
    const Se = {
      writable: !0,
      configurable: !0,
      enumerable: !1
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((Ie) => {
      Object.defineProperty(ze, Ie, Ca({ value: ze[Ie] }, Se));
    });
  }
  return a._p.forEach((Se) => {
    if (md) {
      const Ie = o.run(() => Se({
        store: ze,
        app: a._a,
        pinia: a,
        options: m
      }));
      Object.keys(Ie || {}).forEach((Xe) => ze._customProperties.add(Xe)), Ca(ze, Ie);
    } else
      Ca(ze, o.run(() => Se({
        store: ze,
        app: a._a,
        pinia: a,
        options: m
      })));
  }), process.env.NODE_ENV !== "production" && ze.$state && typeof ze.$state == "object" && typeof ze.$state.constructor == "function" && !ze.$state.constructor.toString().includes("[native code]") && console.warn(`[\u{1F34D}]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${ze.$id}".`), z && f && n.hydrate && n.hydrate(ze.$state, z), b = !0, T = !0, ze;
}
function ih(t, e, n) {
  let a, s;
  const f = typeof e == "function";
  typeof t == "string" ? (a = t, s = f ? n : e) : (s = t, a = t.id);
  function o(m, g) {
    const b = wv();
    if (m = (process.env.NODE_ENV === "test" && ed && ed._testing ? null : m) || b && Sf(aT, null), m && kd(m), process.env.NODE_ENV !== "production" && !ed)
      throw new Error(`[\u{1F34D}]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);
    m = ed, m._s.has(a) || (f ? X0(a, e, s, m) : Lw(a, s, m), process.env.NODE_ENV !== "production" && (o._pinia = m));
    const T = m._s.get(a);
    if (process.env.NODE_ENV !== "production" && g) {
      const M = "__hot:" + a, I = f ? X0(M, e, s, m, !0) : Lw(M, Ca({}, s), m, !0);
      g._hotUpdate(I), delete m.state.value[M], m._s.delete(M);
    }
    if (process.env.NODE_ENV !== "production" && Mv && b && b.proxy && !g) {
      const M = b.proxy, I = "_pStores" in M ? M._pStores : M._pStores = {};
      I[a] = T;
    }
    return T;
  }
  return o.$id = a, o;
}
function pn(t) {
  {
    t = hr(t);
    const e = {};
    for (const n in t) {
      const a = t[n];
      (hn(a) || ss(a)) && (e[n] = cd(t, n));
    }
    return e;
  }
}
function lD(t) {
  t("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), t.WGS84 = t["EPSG:4326"], t["EPSG:3785"] = t["EPSG:3857"], t.GOOGLE = t["EPSG:3857"], t["EPSG:900913"] = t["EPSG:3857"], t["EPSG:102113"] = t["EPSG:3857"];
}
var eh = 1, th = 2, Mf = 3, uD = 4, K0 = 5, Dw = 6378137, cD = 6356752314e-3, Nw = 0.0066943799901413165, yd = 484813681109536e-20, ft = Math.PI / 2, hD = 0.16666666666666666, fD = 0.04722222222222222, pD = 0.022156084656084655, Ct = 1e-10, io = 0.017453292519943295, qs = 57.29577951308232, un = Math.PI / 4, Ld = Math.PI * 2, wi = 3.14159265359, ra = {};
ra.greenwich = 0;
ra.lisbon = -9.131906111111;
ra.paris = 2.337229166667;
ra.bogota = -74.080916666667;
ra.madrid = -3.687938888889;
ra.rome = 12.452333333333;
ra.bern = 7.439583333333;
ra.jakarta = 106.807719444444;
ra.ferro = -17.666666666667;
ra.brussels = 4.367975;
ra.stockholm = 18.058277777778;
ra.athens = 23.7163375;
ra.oslo = 10.722916666667;
const dD = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var Rw = /[\s_\-\/\(\)]/g;
function Fu(t, e) {
  if (t[e])
    return t[e];
  for (var n = Object.keys(t), a = e.toLowerCase().replace(Rw, ""), s = -1, f, o; ++s < n.length; )
    if (f = n[s], o = f.toLowerCase().replace(Rw, ""), o === a)
      return t[f];
}
function Y0(t) {
  var e = {}, n = t.split("+").map(function(m) {
    return m.trim();
  }).filter(function(m) {
    return m;
  }).reduce(function(m, g) {
    var b = g.split("=");
    return b.push(!0), m[b[0].toLowerCase()] = b[1], m;
  }, {}), a, s, f, o = {
    proj: "projName",
    datum: "datumCode",
    rf: function(m) {
      e.rf = parseFloat(m);
    },
    lat_0: function(m) {
      e.lat0 = m * io;
    },
    lat_1: function(m) {
      e.lat1 = m * io;
    },
    lat_2: function(m) {
      e.lat2 = m * io;
    },
    lat_ts: function(m) {
      e.lat_ts = m * io;
    },
    lon_0: function(m) {
      e.long0 = m * io;
    },
    lon_1: function(m) {
      e.long1 = m * io;
    },
    lon_2: function(m) {
      e.long2 = m * io;
    },
    alpha: function(m) {
      e.alpha = parseFloat(m) * io;
    },
    gamma: function(m) {
      e.rectified_grid_angle = parseFloat(m);
    },
    lonc: function(m) {
      e.longc = m * io;
    },
    x_0: function(m) {
      e.x0 = parseFloat(m);
    },
    y_0: function(m) {
      e.y0 = parseFloat(m);
    },
    k_0: function(m) {
      e.k0 = parseFloat(m);
    },
    k: function(m) {
      e.k0 = parseFloat(m);
    },
    a: function(m) {
      e.a = parseFloat(m);
    },
    b: function(m) {
      e.b = parseFloat(m);
    },
    r_a: function() {
      e.R_A = !0;
    },
    zone: function(m) {
      e.zone = parseInt(m, 10);
    },
    south: function() {
      e.utmSouth = !0;
    },
    towgs84: function(m) {
      e.datum_params = m.split(",").map(function(g) {
        return parseFloat(g);
      });
    },
    to_meter: function(m) {
      e.to_meter = parseFloat(m);
    },
    units: function(m) {
      e.units = m;
      var g = Fu(dD, m);
      g && (e.to_meter = g.to_meter);
    },
    from_greenwich: function(m) {
      e.from_greenwich = m * io;
    },
    pm: function(m) {
      var g = Fu(ra, m);
      e.from_greenwich = (g || parseFloat(m)) * io;
    },
    nadgrids: function(m) {
      m === "@null" ? e.datumCode = "none" : e.nadgrids = m;
    },
    axis: function(m) {
      var g = "ewnsud";
      m.length === 3 && g.indexOf(m.substr(0, 1)) !== -1 && g.indexOf(m.substr(1, 1)) !== -1 && g.indexOf(m.substr(2, 1)) !== -1 && (e.axis = m);
    },
    approx: function() {
      e.approx = !0;
    }
  };
  for (a in n)
    s = n[a], a in o ? (f = o[a], typeof f == "function" ? f(s) : e[f] = s) : e[a] = s;
  return typeof e.datumCode == "string" && e.datumCode !== "WGS84" && (e.datumCode = e.datumCode.toLowerCase()), e;
}
var Dd = 1, yT = 2, gT = 3, Dg = 4, vT = 5, Gx = -1, mD = /\s/, yD = /[A-Za-z]/, gD = /[A-Za-z84_]/, Iv = /[,\]]/, _T = /[\d\.E\-\+]/;
function Zl(t) {
  if (typeof t != "string")
    throw new Error("not a string");
  this.text = t.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Dd;
}
Zl.prototype.readCharicter = function() {
  var t = this.text[this.place++];
  if (this.state !== Dg)
    for (; mD.test(t); ) {
      if (this.place >= this.text.length)
        return;
      t = this.text[this.place++];
    }
  switch (this.state) {
    case Dd:
      return this.neutral(t);
    case yT:
      return this.keyword(t);
    case Dg:
      return this.quoted(t);
    case vT:
      return this.afterquote(t);
    case gT:
      return this.number(t);
    case Gx:
      return;
  }
};
Zl.prototype.afterquote = function(t) {
  if (t === '"') {
    this.word += '"', this.state = Dg;
    return;
  }
  if (Iv.test(t)) {
    this.word = this.word.trim(), this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in afterquote yet, index ' + this.place);
};
Zl.prototype.afterItem = function(t) {
  if (t === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = Dd;
    return;
  }
  if (t === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Dd, this.currentObject = this.stack.pop(), this.currentObject || (this.state = Gx);
    return;
  }
};
Zl.prototype.number = function(t) {
  if (_T.test(t)) {
    this.word += t;
    return;
  }
  if (Iv.test(t)) {
    this.word = parseFloat(this.word), this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in number yet, index ' + this.place);
};
Zl.prototype.quoted = function(t) {
  if (t === '"') {
    this.state = vT;
    return;
  }
  this.word += t;
};
Zl.prototype.keyword = function(t) {
  if (gD.test(t)) {
    this.word += t;
    return;
  }
  if (t === "[") {
    var e = [];
    e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, this.state = Dd;
    return;
  }
  if (Iv.test(t)) {
    this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in keyword yet, index ' + this.place);
};
Zl.prototype.neutral = function(t) {
  if (yD.test(t)) {
    this.word = t, this.state = yT;
    return;
  }
  if (t === '"') {
    this.word = "", this.state = Dg;
    return;
  }
  if (_T.test(t)) {
    this.word = t, this.state = gT;
    return;
  }
  if (Iv.test(t)) {
    this.afterItem(t);
    return;
  }
  throw new Error(`havn't handled "` + t + '" in neutral yet, index ' + this.place);
};
Zl.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === Gx)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function vD(t) {
  var e = new Zl(t);
  return e.output();
}
function zw(t, e, n) {
  Array.isArray(e) && (n.unshift(e), e = null);
  var a = e ? {} : t, s = n.reduce(function(f, o) {
    return gf(o, f), f;
  }, a);
  e && (t[e] = s);
}
function gf(t, e) {
  if (!Array.isArray(t)) {
    e[t] = !0;
    return;
  }
  var n = t.shift();
  if (n === "PARAMETER" && (n = t.shift()), t.length === 1) {
    if (Array.isArray(t[0])) {
      e[n] = {}, gf(t[0], e[n]);
      return;
    }
    e[n] = t[0];
    return;
  }
  if (!t.length) {
    e[n] = !0;
    return;
  }
  if (n === "TOWGS84") {
    e[n] = t;
    return;
  }
  if (n === "AXIS") {
    n in e || (e[n] = []), e[n].push(t);
    return;
  }
  Array.isArray(n) || (e[n] = {});
  var a;
  switch (n) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      e[n] = {
        name: t[0].toLowerCase(),
        convert: t[1]
      }, t.length === 3 && gf(t[2], e[n]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      e[n] = {
        name: t[0],
        a: t[1],
        rf: t[2]
      }, t.length === 4 && gf(t[3], e[n]);
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      t[0] = ["name", t[0]], zw(e, n, t);
      return;
    default:
      for (a = -1; ++a < t.length; )
        if (!Array.isArray(t[a]))
          return gf(t, e[n]);
      return zw(e, n, t);
  }
}
var _D = 0.017453292519943295;
function xD(t, e) {
  var n = e[0], a = e[1];
  !(n in t) && a in t && (t[n] = t[a], e.length === 3 && (t[n] = e[2](t[n])));
}
function kl(t) {
  return t * _D;
}
function bD(t) {
  if (t.type === "GEOGCS" ? t.projName = "longlat" : t.type === "LOCAL_CS" ? (t.projName = "identity", t.local = !0) : typeof t.PROJECTION == "object" ? t.projName = Object.keys(t.PROJECTION)[0] : t.projName = t.PROJECTION, t.AXIS) {
    for (var e = "", n = 0, a = t.AXIS.length; n < a; ++n) {
      var s = [t.AXIS[n][0].toLowerCase(), t.AXIS[n][1].toLowerCase()];
      s[0].indexOf("north") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "north" ? e += "n" : s[0].indexOf("south") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "south" ? e += "s" : s[0].indexOf("east") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "east" ? e += "e" : (s[0].indexOf("west") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "west") && (e += "w");
    }
    e.length === 2 && (e += "u"), e.length === 3 && (t.axis = e);
  }
  t.UNIT && (t.units = t.UNIT.name.toLowerCase(), t.units === "metre" && (t.units = "meter"), t.UNIT.convert && (t.type === "GEOGCS" ? t.DATUM && t.DATUM.SPHEROID && (t.to_meter = t.UNIT.convert * t.DATUM.SPHEROID.a) : t.to_meter = t.UNIT.convert));
  var f = t.GEOGCS;
  t.type === "GEOGCS" && (f = t), f && (f.DATUM ? t.datumCode = f.DATUM.name.toLowerCase() : t.datumCode = f.name.toLowerCase(), t.datumCode.slice(0, 2) === "d_" && (t.datumCode = t.datumCode.slice(2)), (t.datumCode === "new_zealand_geodetic_datum_1949" || t.datumCode === "new_zealand_1949") && (t.datumCode = "nzgd49"), (t.datumCode === "wgs_1984" || t.datumCode === "world_geodetic_system_1984") && (t.PROJECTION === "Mercator_Auxiliary_Sphere" && (t.sphere = !0), t.datumCode = "wgs84"), t.datumCode.slice(-6) === "_ferro" && (t.datumCode = t.datumCode.slice(0, -6)), t.datumCode.slice(-8) === "_jakarta" && (t.datumCode = t.datumCode.slice(0, -8)), ~t.datumCode.indexOf("belge") && (t.datumCode = "rnb72"), f.DATUM && f.DATUM.SPHEROID && (t.ellps = f.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), t.ellps.toLowerCase().slice(0, 13) === "international" && (t.ellps = "intl"), t.a = f.DATUM.SPHEROID.a, t.rf = parseFloat(f.DATUM.SPHEROID.rf, 10)), f.DATUM && f.DATUM.TOWGS84 && (t.datum_params = f.DATUM.TOWGS84), ~t.datumCode.indexOf("osgb_1936") && (t.datumCode = "osgb36"), ~t.datumCode.indexOf("osni_1952") && (t.datumCode = "osni52"), (~t.datumCode.indexOf("tm65") || ~t.datumCode.indexOf("geodetic_datum_of_1965")) && (t.datumCode = "ire65"), t.datumCode === "ch1903+" && (t.datumCode = "ch1903"), ~t.datumCode.indexOf("israel") && (t.datumCode = "isr93")), t.b && !isFinite(t.b) && (t.b = t.a);
  function o(b) {
    var T = t.to_meter || 1;
    return b * T;
  }
  var m = function(b) {
    return xD(t, b);
  }, g = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", kl],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", kl],
    ["x0", "false_easting", o],
    ["y0", "false_northing", o],
    ["long0", "central_meridian", kl],
    ["lat0", "latitude_of_origin", kl],
    ["lat0", "standard_parallel_1", kl],
    ["lat1", "standard_parallel_1", kl],
    ["lat2", "standard_parallel_2", kl],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", kl],
    ["srsCode", "name"]
  ];
  g.forEach(m), !t.long0 && t.longc && (t.projName === "Albers_Conic_Equal_Area" || t.projName === "Lambert_Azimuthal_Equal_Area") && (t.long0 = t.longc), !t.lat_ts && t.lat1 && (t.projName === "Stereographic_South_Pole" || t.projName === "Polar Stereographic (variant B)") && (t.lat0 = kl(t.lat1 > 0 ? 90 : -90), t.lat_ts = t.lat1);
}
function xT(t) {
  var e = vD(t), n = e.shift(), a = e.shift();
  e.unshift(["name", a]), e.unshift(["type", n]);
  var s = {};
  return gf(e, s), bD(s), s;
}
function Do(t) {
  var e = this;
  if (arguments.length === 2) {
    var n = arguments[1];
    typeof n == "string" ? n.charAt(0) === "+" ? Do[t] = Y0(arguments[1]) : Do[t] = xT(arguments[1]) : Do[t] = n;
  } else if (arguments.length === 1) {
    if (Array.isArray(t))
      return t.map(function(a) {
        Array.isArray(a) ? Do.apply(e, a) : Do(a);
      });
    if (typeof t == "string") {
      if (t in Do)
        return Do[t];
    } else
      "EPSG" in t ? Do["EPSG:" + t.EPSG] = t : "ESRI" in t ? Do["ESRI:" + t.ESRI] = t : "IAU2000" in t ? Do["IAU2000:" + t.IAU2000] = t : console.log(t);
    return;
  }
}
lD(Do);
function wD(t) {
  return typeof t == "string";
}
function ED(t) {
  return t in Do;
}
var SD = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function TD(t) {
  return SD.some(function(e) {
    return t.indexOf(e) > -1;
  });
}
var MD = ["3857", "900913", "3785", "102113"];
function ID(t) {
  var e = Fu(t, "authority");
  if (!!e) {
    var n = Fu(e, "epsg");
    return n && MD.indexOf(n) > -1;
  }
}
function OD(t) {
  var e = Fu(t, "extension");
  if (!!e)
    return Fu(e, "proj4");
}
function CD(t) {
  return t[0] === "+";
}
function PD(t) {
  if (wD(t)) {
    if (ED(t))
      return Do[t];
    if (TD(t)) {
      var e = xT(t);
      if (ID(e))
        return Do["EPSG:3857"];
      var n = OD(e);
      return n ? Y0(n) : e;
    }
    if (CD(t))
      return Y0(t);
  } else
    return t;
}
function Fw(t, e) {
  t = t || {};
  var n, a;
  if (!e)
    return t;
  for (a in e)
    n = e[a], n !== void 0 && (t[a] = n);
  return t;
}
function el(t, e, n) {
  var a = t * e;
  return n / Math.sqrt(1 - a * a);
}
function qd(t) {
  return t < 0 ? -1 : 1;
}
function Vt(t) {
  return Math.abs(t) <= wi ? t : t - qd(t) * Ld;
}
function ls(t, e, n) {
  var a = t * n, s = 0.5 * t;
  return a = Math.pow((1 - a) / (1 + a), s), Math.tan(0.5 * (ft - e)) / a;
}
function Nd(t, e) {
  for (var n = 0.5 * t, a, s, f = ft - 2 * Math.atan(e), o = 0; o <= 15; o++)
    if (a = t * Math.sin(f), s = ft - 2 * Math.atan(e * Math.pow((1 - a) / (1 + a), n)) - f, f += s, Math.abs(s) <= 1e-10)
      return f;
  return -9999;
}
function AD() {
  var t = this.b / this.a;
  this.es = 1 - t * t, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = el(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function kD(t) {
  var e = t.x, n = t.y;
  if (n * qs > 90 && n * qs < -90 && e * qs > 180 && e * qs < -180)
    return null;
  var a, s;
  if (Math.abs(Math.abs(n) - ft) <= Ct)
    return null;
  if (this.sphere)
    a = this.x0 + this.a * this.k0 * Vt(e - this.long0), s = this.y0 + this.a * this.k0 * Math.log(Math.tan(un + 0.5 * n));
  else {
    var f = Math.sin(n), o = ls(this.e, n, f);
    a = this.x0 + this.a * this.k0 * Vt(e - this.long0), s = this.y0 - this.a * this.k0 * Math.log(o);
  }
  return t.x = a, t.y = s, t;
}
function LD(t) {
  var e = t.x - this.x0, n = t.y - this.y0, a, s;
  if (this.sphere)
    s = ft - 2 * Math.atan(Math.exp(-n / (this.a * this.k0)));
  else {
    var f = Math.exp(-n / (this.a * this.k0));
    if (s = Nd(this.e, f), s === -9999)
      return null;
  }
  return a = Vt(this.long0 + e / (this.a * this.k0)), t.x = a, t.y = s, t;
}
var DD = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const ND = {
  init: AD,
  forward: kD,
  inverse: LD,
  names: DD
};
function RD() {
}
function Bw(t) {
  return t;
}
var zD = ["longlat", "identity"];
const FD = {
  init: RD,
  forward: Bw,
  inverse: Bw,
  names: zD
};
var BD = [ND, FD], sg = {}, Ng = [];
function bT(t, e) {
  var n = Ng.length;
  return t.names ? (Ng[n] = t, t.names.forEach(function(a) {
    sg[a.toLowerCase()] = n;
  }), this) : (console.log(e), !0);
}
function VD(t) {
  if (!t)
    return !1;
  var e = t.toLowerCase();
  if (typeof sg[e] < "u" && Ng[sg[e]])
    return Ng[sg[e]];
}
function UD() {
  BD.forEach(bT);
}
const jD = {
  start: UD,
  add: bT,
  get: VD
};
var _r = {};
_r.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
_r.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
_r.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
_r.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
_r.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
_r.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
_r.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
_r.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
_r.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
_r.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
_r.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
_r.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
_r.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
_r.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
_r.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
_r.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
_r.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
_r.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
_r.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
_r.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
_r.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
_r.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
_r.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
_r.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
_r.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
_r.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
_r.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
_r.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
_r.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
_r.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
_r.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
_r.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
_r.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
_r.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
_r.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
_r.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
_r.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
_r.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
_r.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
_r.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
_r.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var GD = _r.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
_r.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function $D(t, e, n, a) {
  var s = t * t, f = e * e, o = (s - f) / s, m = 0;
  a ? (t *= 1 - o * (hD + o * (fD + o * pD)), s = t * t, o = 0) : m = Math.sqrt(o);
  var g = (s - f) / f;
  return {
    es: o,
    e: m,
    ep2: g
  };
}
function qD(t, e, n, a, s) {
  if (!t) {
    var f = Fu(_r, a);
    f || (f = GD), t = f.a, e = f.b, n = f.rf;
  }
  return n && !e && (e = (1 - 1 / n) * t), (n === 0 || Math.abs(t - e) < Ct) && (s = !0, e = t), {
    a: t,
    b: e,
    rf: n,
    sphere: s
  };
}
var Ki = {};
Ki.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
Ki.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
Ki.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
Ki.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
Ki.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
Ki.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
Ki.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
Ki.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
Ki.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
Ki.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
Ki.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
Ki.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
Ki.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
Ki.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
Ki.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
Ki.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
Ki.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function WD(t, e, n, a, s, f, o) {
  var m = {};
  return t === void 0 || t === "none" ? m.datum_type = K0 : m.datum_type = uD, e && (m.datum_params = e.map(parseFloat), (m.datum_params[0] !== 0 || m.datum_params[1] !== 0 || m.datum_params[2] !== 0) && (m.datum_type = eh), m.datum_params.length > 3 && (m.datum_params[3] !== 0 || m.datum_params[4] !== 0 || m.datum_params[5] !== 0 || m.datum_params[6] !== 0) && (m.datum_type = th, m.datum_params[3] *= yd, m.datum_params[4] *= yd, m.datum_params[5] *= yd, m.datum_params[6] = m.datum_params[6] / 1e6 + 1)), o && (m.datum_type = Mf, m.grids = o), m.a = n, m.b = a, m.es = s, m.ep2 = f, m;
}
var wT = {};
function HD(t, e) {
  var n = new DataView(e), a = KD(n), s = YD(n, a);
  s.nSubgrids > 1 && console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
  var f = JD(n, s, a), o = { header: s, subgrids: f };
  return wT[t] = o, o;
}
function ZD(t) {
  if (t === void 0)
    return null;
  var e = t.split(",");
  return e.map(XD);
}
function XD(t) {
  if (t.length === 0)
    return null;
  var e = t[0] === "@";
  return e && (t = t.slice(1)), t === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : {
    name: t,
    mandatory: !e,
    grid: wT[t] || null,
    isNull: !1
  };
}
function vf(t) {
  return t / 3600 * Math.PI / 180;
}
function KD(t) {
  var e = t.getInt32(8, !1);
  return e === 11 ? !1 : (e = t.getInt32(8, !0), e !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function YD(t, e) {
  return {
    nFields: t.getInt32(8, e),
    nSubgridFields: t.getInt32(24, e),
    nSubgrids: t.getInt32(40, e),
    shiftType: J0(t, 56, 56 + 8).trim(),
    fromSemiMajorAxis: t.getFloat64(120, e),
    fromSemiMinorAxis: t.getFloat64(136, e),
    toSemiMajorAxis: t.getFloat64(152, e),
    toSemiMinorAxis: t.getFloat64(168, e)
  };
}
function J0(t, e, n) {
  return String.fromCharCode.apply(null, new Uint8Array(t.buffer.slice(e, n)));
}
function JD(t, e, n) {
  for (var a = 176, s = [], f = 0; f < e.nSubgrids; f++) {
    var o = eN(t, a, n), m = tN(t, a, o, n), g = Math.round(
      1 + (o.upperLongitude - o.lowerLongitude) / o.longitudeInterval
    ), b = Math.round(
      1 + (o.upperLatitude - o.lowerLatitude) / o.latitudeInterval
    );
    s.push({
      ll: [vf(o.lowerLongitude), vf(o.lowerLatitude)],
      del: [vf(o.longitudeInterval), vf(o.latitudeInterval)],
      lim: [g, b],
      count: o.gridNodeCount,
      cvs: QD(m)
    });
  }
  return s;
}
function QD(t) {
  return t.map(function(e) {
    return [vf(e.longitudeShift), vf(e.latitudeShift)];
  });
}
function eN(t, e, n) {
  return {
    name: J0(t, e + 8, e + 16).trim(),
    parent: J0(t, e + 24, e + 24 + 8).trim(),
    lowerLatitude: t.getFloat64(e + 72, n),
    upperLatitude: t.getFloat64(e + 88, n),
    lowerLongitude: t.getFloat64(e + 104, n),
    upperLongitude: t.getFloat64(e + 120, n),
    latitudeInterval: t.getFloat64(e + 136, n),
    longitudeInterval: t.getFloat64(e + 152, n),
    gridNodeCount: t.getInt32(e + 168, n)
  };
}
function tN(t, e, n, a) {
  for (var s = e + 176, f = 16, o = [], m = 0; m < n.gridNodeCount; m++) {
    var g = {
      latitudeShift: t.getFloat32(s + m * f, a),
      longitudeShift: t.getFloat32(s + m * f + 4, a),
      latitudeAccuracy: t.getFloat32(s + m * f + 8, a),
      longitudeAccuracy: t.getFloat32(s + m * f + 12, a)
    };
    o.push(g);
  }
  return o;
}
function Zs(t, e) {
  if (!(this instanceof Zs))
    return new Zs(t);
  e = e || function(b) {
    if (b)
      throw b;
  };
  var n = PD(t);
  if (typeof n != "object") {
    e(t);
    return;
  }
  var a = Zs.projections.get(n.projName);
  if (!a) {
    e(t);
    return;
  }
  if (n.datumCode && n.datumCode !== "none") {
    var s = Fu(Ki, n.datumCode);
    s && (n.datum_params = n.datum_params || (s.towgs84 ? s.towgs84.split(",") : null), n.ellps = s.ellipse, n.datumName = s.datumName ? s.datumName : n.datumCode);
  }
  n.k0 = n.k0 || 1, n.axis = n.axis || "enu", n.ellps = n.ellps || "wgs84", n.lat1 = n.lat1 || n.lat0;
  var f = qD(n.a, n.b, n.rf, n.ellps, n.sphere), o = $D(f.a, f.b, f.rf, n.R_A), m = ZD(n.nadgrids), g = n.datum || WD(
    n.datumCode,
    n.datum_params,
    f.a,
    f.b,
    o.es,
    o.ep2,
    m
  );
  Fw(this, n), Fw(this, a), this.a = f.a, this.b = f.b, this.rf = f.rf, this.sphere = f.sphere, this.es = o.es, this.e = o.e, this.ep2 = o.ep2, this.datum = g, this.init(), e(null, this);
}
Zs.projections = jD;
Zs.projections.start();
function rN(t, e) {
  return t.datum_type !== e.datum_type || t.a !== e.a || Math.abs(t.es - e.es) > 5e-11 ? !1 : t.datum_type === eh ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] : t.datum_type === th ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] && t.datum_params[3] === e.datum_params[3] && t.datum_params[4] === e.datum_params[4] && t.datum_params[5] === e.datum_params[5] && t.datum_params[6] === e.datum_params[6] : !0;
}
function ET(t, e, n) {
  var a = t.x, s = t.y, f = t.z ? t.z : 0, o, m, g, b;
  if (s < -ft && s > -1.001 * ft)
    s = -ft;
  else if (s > ft && s < 1.001 * ft)
    s = ft;
  else {
    if (s < -ft)
      return { x: -1 / 0, y: -1 / 0, z: t.z };
    if (s > ft)
      return { x: 1 / 0, y: 1 / 0, z: t.z };
  }
  return a > Math.PI && (a -= 2 * Math.PI), m = Math.sin(s), b = Math.cos(s), g = m * m, o = n / Math.sqrt(1 - e * g), {
    x: (o + f) * b * Math.cos(a),
    y: (o + f) * b * Math.sin(a),
    z: (o * (1 - e) + f) * m
  };
}
function ST(t, e, n, a) {
  var s = 1e-12, f = s * s, o = 30, m, g, b, T, M, I, A, z, V, q, re, X, ae, ce = t.x, ve = t.y, Ne = t.z ? t.z : 0, ze, Ae, Se;
  if (m = Math.sqrt(ce * ce + ve * ve), g = Math.sqrt(ce * ce + ve * ve + Ne * Ne), m / n < s) {
    if (ze = 0, g / n < s)
      return Ae = ft, Se = -a, {
        x: t.x,
        y: t.y,
        z: t.z
      };
  } else
    ze = Math.atan2(ve, ce);
  b = Ne / g, T = m / g, M = 1 / Math.sqrt(1 - e * (2 - e) * T * T), z = T * (1 - e) * M, V = b * M, ae = 0;
  do
    ae++, A = n / Math.sqrt(1 - e * V * V), Se = m * z + Ne * V - A * (1 - e * V * V), I = e * A / (A + Se), M = 1 / Math.sqrt(1 - I * (2 - I) * T * T), q = T * (1 - I) * M, re = b * M, X = re * z - q * V, z = q, V = re;
  while (X * X > f && ae < o);
  return Ae = Math.atan(re / Math.abs(q)), {
    x: ze,
    y: Ae,
    z: Se
  };
}
function nN(t, e, n) {
  if (e === eh)
    return {
      x: t.x + n[0],
      y: t.y + n[1],
      z: t.z + n[2]
    };
  if (e === th) {
    var a = n[0], s = n[1], f = n[2], o = n[3], m = n[4], g = n[5], b = n[6];
    return {
      x: b * (t.x - g * t.y + m * t.z) + a,
      y: b * (g * t.x + t.y - o * t.z) + s,
      z: b * (-m * t.x + o * t.y + t.z) + f
    };
  }
}
function iN(t, e, n) {
  if (e === eh)
    return {
      x: t.x - n[0],
      y: t.y - n[1],
      z: t.z - n[2]
    };
  if (e === th) {
    var a = n[0], s = n[1], f = n[2], o = n[3], m = n[4], g = n[5], b = n[6], T = (t.x - a) / b, M = (t.y - s) / b, I = (t.z - f) / b;
    return {
      x: T + g * M - m * I,
      y: -g * T + M + o * I,
      z: m * T - o * M + I
    };
  }
}
function Oy(t) {
  return t === eh || t === th;
}
function oN(t, e, n) {
  if (rN(t, e) || t.datum_type === K0 || e.datum_type === K0)
    return n;
  var a = t.a, s = t.es;
  if (t.datum_type === Mf) {
    var f = Vw(t, !1, n);
    if (f !== 0)
      return;
    a = Dw, s = Nw;
  }
  var o = e.a, m = e.b, g = e.es;
  if (e.datum_type === Mf && (o = Dw, m = cD, g = Nw), s === g && a === o && !Oy(t.datum_type) && !Oy(e.datum_type))
    return n;
  if (n = ET(n, s, a), Oy(t.datum_type) && (n = nN(n, t.datum_type, t.datum_params)), Oy(e.datum_type) && (n = iN(n, e.datum_type, e.datum_params)), n = ST(n, g, o, m), e.datum_type === Mf) {
    var b = Vw(e, !0, n);
    if (b !== 0)
      return;
  }
  return n;
}
function Vw(t, e, n) {
  if (t.grids === null || t.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  for (var a = { x: -n.x, y: n.y }, s = { x: Number.NaN, y: Number.NaN }, f = [], o = 0; o < t.grids.length; o++) {
    var m = t.grids[o];
    if (f.push(m.name), m.isNull) {
      s = a;
      break;
    }
    if (m.mandatory, m.grid === null) {
      if (m.mandatory)
        return console.log("Unable to find mandatory grid '" + m.name + "'"), -1;
      continue;
    }
    var g = m.grid.subgrids[0], b = (Math.abs(g.del[1]) + Math.abs(g.del[0])) / 1e4, T = g.ll[0] - b, M = g.ll[1] - b, I = g.ll[0] + (g.lim[0] - 1) * g.del[0] + b, A = g.ll[1] + (g.lim[1] - 1) * g.del[1] + b;
    if (!(M > a.y || T > a.x || A < a.y || I < a.x) && (s = aN(a, e, g), !isNaN(s.x)))
      break;
  }
  return isNaN(s.x) ? (console.log("Failed to find a grid shift table for location '" + -a.x * qs + " " + a.y * qs + " tried: '" + f + "'"), -1) : (n.x = -s.x, n.y = s.y, 0);
}
function aN(t, e, n) {
  var a = { x: Number.NaN, y: Number.NaN };
  if (isNaN(t.x))
    return a;
  var s = { x: t.x, y: t.y };
  s.x -= n.ll[0], s.y -= n.ll[1], s.x = Vt(s.x - Math.PI) + Math.PI;
  var f = Uw(s, n);
  if (e) {
    if (isNaN(f.x))
      return a;
    f.x = s.x - f.x, f.y = s.y - f.y;
    var o = 9, m = 1e-12, g, b;
    do {
      if (b = Uw(f, n), isNaN(b.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      g = { x: s.x - (b.x + f.x), y: s.y - (b.y + f.y) }, f.x += g.x, f.y += g.y;
    } while (o-- && Math.abs(g.x) > m && Math.abs(g.y) > m);
    if (o < 0)
      return console.log("Inverse grid shift iterator failed to converge."), a;
    a.x = Vt(f.x + n.ll[0]), a.y = f.y + n.ll[1];
  } else
    isNaN(f.x) || (a.x = t.x + f.x, a.y = t.y + f.y);
  return a;
}
function Uw(t, e) {
  var n = { x: t.x / e.del[0], y: t.y / e.del[1] }, a = { x: Math.floor(n.x), y: Math.floor(n.y) }, s = { x: n.x - 1 * a.x, y: n.y - 1 * a.y }, f = { x: Number.NaN, y: Number.NaN }, o;
  if (a.x < 0 || a.x >= e.lim[0] || a.y < 0 || a.y >= e.lim[1])
    return f;
  o = a.y * e.lim[0] + a.x;
  var m = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o++;
  var g = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o += e.lim[0];
  var b = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o--;
  var T = { x: e.cvs[o][0], y: e.cvs[o][1] }, M = s.x * s.y, I = s.x * (1 - s.y), A = (1 - s.x) * (1 - s.y), z = (1 - s.x) * s.y;
  return f.x = A * m.x + I * g.x + z * T.x + M * b.x, f.y = A * m.y + I * g.y + z * T.y + M * b.y, f;
}
function jw(t, e, n) {
  var a = n.x, s = n.y, f = n.z || 0, o, m, g, b = {};
  for (g = 0; g < 3; g++)
    if (!(e && g === 2 && n.z === void 0))
      switch (g === 0 ? (o = a, "ew".indexOf(t.axis[g]) !== -1 ? m = "x" : m = "y") : g === 1 ? (o = s, "ns".indexOf(t.axis[g]) !== -1 ? m = "y" : m = "x") : (o = f, m = "z"), t.axis[g]) {
        case "e":
          b[m] = o;
          break;
        case "w":
          b[m] = -o;
          break;
        case "n":
          b[m] = o;
          break;
        case "s":
          b[m] = -o;
          break;
        case "u":
          n[m] !== void 0 && (b.z = o);
          break;
        case "d":
          n[m] !== void 0 && (b.z = -o);
          break;
        default:
          return null;
      }
  return b;
}
function TT(t) {
  var e = {
    x: t[0],
    y: t[1]
  };
  return t.length > 2 && (e.z = t[2]), t.length > 3 && (e.m = t[3]), e;
}
function sN(t) {
  Gw(t.x), Gw(t.y);
}
function Gw(t) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(t))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof t != "number" || t !== t || !isFinite(t))
    throw new TypeError("coordinates must be finite numbers");
}
function lN(t, e) {
  return (t.datum.datum_type === eh || t.datum.datum_type === th || t.datum.datum_type === Mf) && e.datumCode !== "WGS84" || (e.datum.datum_type === eh || e.datum.datum_type === th || e.datum.datum_type === Mf) && t.datumCode !== "WGS84";
}
function Rg(t, e, n, a) {
  var s;
  Array.isArray(n) ? n = TT(n) : n = {
    x: n.x,
    y: n.y,
    z: n.z,
    m: n.m
  };
  var f = n.z !== void 0;
  if (sN(n), t.datum && e.datum && lN(t, e) && (s = new Zs("WGS84"), n = Rg(t, s, n, a), t = s), a && t.axis !== "enu" && (n = jw(t, !1, n)), t.projName === "longlat")
    n = {
      x: n.x * io,
      y: n.y * io,
      z: n.z || 0
    };
  else if (t.to_meter && (n = {
    x: n.x * t.to_meter,
    y: n.y * t.to_meter,
    z: n.z || 0
  }), n = t.inverse(n), !n)
    return;
  if (t.from_greenwich && (n.x += t.from_greenwich), n = oN(t.datum, e.datum, n), !!n)
    return e.from_greenwich && (n = {
      x: n.x - e.from_greenwich,
      y: n.y,
      z: n.z || 0
    }), e.projName === "longlat" ? n = {
      x: n.x * qs,
      y: n.y * qs,
      z: n.z || 0
    } : (n = e.forward(n), e.to_meter && (n = {
      x: n.x / e.to_meter,
      y: n.y / e.to_meter,
      z: n.z || 0
    })), a && e.axis !== "enu" ? jw(e, !0, n) : (f || delete n.z, n);
}
var $w = Zs("WGS84");
function W_(t, e, n, a) {
  var s, f, o;
  return Array.isArray(n) ? (s = Rg(t, e, n, a) || { x: NaN, y: NaN }, n.length > 2 ? typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent" ? typeof s.z == "number" ? [s.x, s.y, s.z].concat(n.splice(3)) : [s.x, s.y, n[2]].concat(n.splice(3)) : [s.x, s.y].concat(n.splice(2)) : [s.x, s.y]) : (f = Rg(t, e, n, a), o = Object.keys(n), o.length === 2 || o.forEach(function(m) {
    if (typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent") {
      if (m === "x" || m === "y" || m === "z")
        return;
    } else if (m === "x" || m === "y")
      return;
    f[m] = n[m];
  }), f);
}
function qw(t) {
  return t instanceof Zs ? t : t.oProj ? t.oProj : Zs(t);
}
function wo(t, e, n) {
  t = qw(t);
  var a = !1, s;
  return typeof e > "u" ? (e = t, t = $w, a = !0) : (typeof e.x < "u" || Array.isArray(e)) && (n = e, e = t, t = $w, a = !0), e = qw(e), n ? W_(t, e, n) : (s = {
    forward: function(f, o) {
      return W_(t, e, f, o);
    },
    inverse: function(f, o) {
      return W_(e, t, f, o);
    }
  }, a && (s.oProj = e), s);
}
var Ww = 6, MT = "AJSAJS", IT = "AFAFAF", _f = 65, Qo = 73, Pa = 79, td = 86, rd = 90;
const uN = {
  forward: OT,
  inverse: cN,
  toPoint: CT
};
function OT(t, e) {
  return e = e || 5, pN(hN({
    lat: t[1],
    lon: t[0]
  }), e);
}
function cN(t) {
  var e = $x(AT(t.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
}
function CT(t) {
  var e = $x(AT(t.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function H_(t) {
  return t * (Math.PI / 180);
}
function Hw(t) {
  return 180 * (t / Math.PI);
}
function hN(t) {
  var e = t.lat, n = t.lon, a = 6378137, s = 669438e-8, f = 0.9996, o, m, g, b, T, M, I, A = H_(e), z = H_(n), V, q;
  q = Math.floor((n + 180) / 6) + 1, n === 180 && (q = 60), e >= 56 && e < 64 && n >= 3 && n < 12 && (q = 32), e >= 72 && e < 84 && (n >= 0 && n < 9 ? q = 31 : n >= 9 && n < 21 ? q = 33 : n >= 21 && n < 33 ? q = 35 : n >= 33 && n < 42 && (q = 37)), o = (q - 1) * 6 - 180 + 3, V = H_(o), m = s / (1 - s), g = a / Math.sqrt(1 - s * Math.sin(A) * Math.sin(A)), b = Math.tan(A) * Math.tan(A), T = m * Math.cos(A) * Math.cos(A), M = Math.cos(A) * (z - V), I = a * ((1 - s / 4 - 3 * s * s / 64 - 5 * s * s * s / 256) * A - (3 * s / 8 + 3 * s * s / 32 + 45 * s * s * s / 1024) * Math.sin(2 * A) + (15 * s * s / 256 + 45 * s * s * s / 1024) * Math.sin(4 * A) - 35 * s * s * s / 3072 * Math.sin(6 * A));
  var re = f * g * (M + (1 - b + T) * M * M * M / 6 + (5 - 18 * b + b * b + 72 * T - 58 * m) * M * M * M * M * M / 120) + 5e5, X = f * (I + g * Math.tan(A) * (M * M / 2 + (5 - b + 9 * T + 4 * T * T) * M * M * M * M / 24 + (61 - 58 * b + b * b + 600 * T - 330 * m) * M * M * M * M * M * M / 720));
  return e < 0 && (X += 1e7), {
    northing: Math.round(X),
    easting: Math.round(re),
    zoneNumber: q,
    zoneLetter: fN(e)
  };
}
function $x(t) {
  var e = t.northing, n = t.easting, a = t.zoneLetter, s = t.zoneNumber;
  if (s < 0 || s > 60)
    return null;
  var f = 0.9996, o = 6378137, m = 669438e-8, g, b = (1 - Math.sqrt(1 - m)) / (1 + Math.sqrt(1 - m)), T, M, I, A, z, V, q, re, X, ae = n - 5e5, ce = e;
  a < "N" && (ce -= 1e7), q = (s - 1) * 6 - 180 + 3, g = m / (1 - m), V = ce / f, re = V / (o * (1 - m / 4 - 3 * m * m / 64 - 5 * m * m * m / 256)), X = re + (3 * b / 2 - 27 * b * b * b / 32) * Math.sin(2 * re) + (21 * b * b / 16 - 55 * b * b * b * b / 32) * Math.sin(4 * re) + 151 * b * b * b / 96 * Math.sin(6 * re), T = o / Math.sqrt(1 - m * Math.sin(X) * Math.sin(X)), M = Math.tan(X) * Math.tan(X), I = g * Math.cos(X) * Math.cos(X), A = o * (1 - m) / Math.pow(1 - m * Math.sin(X) * Math.sin(X), 1.5), z = ae / (T * f);
  var ve = X - T * Math.tan(X) / A * (z * z / 2 - (5 + 3 * M + 10 * I - 4 * I * I - 9 * g) * z * z * z * z / 24 + (61 + 90 * M + 298 * I + 45 * M * M - 252 * g - 3 * I * I) * z * z * z * z * z * z / 720);
  ve = Hw(ve);
  var Ne = (z - (1 + 2 * M + I) * z * z * z / 6 + (5 - 2 * I + 28 * M - 3 * I * I + 8 * g + 24 * M * M) * z * z * z * z * z / 120) / Math.cos(X);
  Ne = q + Hw(Ne);
  var ze;
  if (t.accuracy) {
    var Ae = $x({
      northing: t.northing + t.accuracy,
      easting: t.easting + t.accuracy,
      zoneLetter: t.zoneLetter,
      zoneNumber: t.zoneNumber
    });
    ze = {
      top: Ae.lat,
      right: Ae.lon,
      bottom: ve,
      left: Ne
    };
  } else
    ze = {
      lat: ve,
      lon: Ne
    };
  return ze;
}
function fN(t) {
  var e = "Z";
  return 84 >= t && t >= 72 ? e = "X" : 72 > t && t >= 64 ? e = "W" : 64 > t && t >= 56 ? e = "V" : 56 > t && t >= 48 ? e = "U" : 48 > t && t >= 40 ? e = "T" : 40 > t && t >= 32 ? e = "S" : 32 > t && t >= 24 ? e = "R" : 24 > t && t >= 16 ? e = "Q" : 16 > t && t >= 8 ? e = "P" : 8 > t && t >= 0 ? e = "N" : 0 > t && t >= -8 ? e = "M" : -8 > t && t >= -16 ? e = "L" : -16 > t && t >= -24 ? e = "K" : -24 > t && t >= -32 ? e = "J" : -32 > t && t >= -40 ? e = "H" : -40 > t && t >= -48 ? e = "G" : -48 > t && t >= -56 ? e = "F" : -56 > t && t >= -64 ? e = "E" : -64 > t && t >= -72 ? e = "D" : -72 > t && t >= -80 && (e = "C"), e;
}
function pN(t, e) {
  var n = "00000" + t.easting, a = "00000" + t.northing;
  return t.zoneNumber + t.zoneLetter + dN(t.easting, t.northing, t.zoneNumber) + n.substr(n.length - 5, e) + a.substr(a.length - 5, e);
}
function dN(t, e, n) {
  var a = PT(n), s = Math.floor(t / 1e5), f = Math.floor(e / 1e5) % 20;
  return mN(s, f, a);
}
function PT(t) {
  var e = t % Ww;
  return e === 0 && (e = Ww), e;
}
function mN(t, e, n) {
  var a = n - 1, s = MT.charCodeAt(a), f = IT.charCodeAt(a), o = s + t - 1, m = f + e, g = !1;
  o > rd && (o = o - rd + _f - 1, g = !0), (o === Qo || s < Qo && o > Qo || (o > Qo || s < Qo) && g) && o++, (o === Pa || s < Pa && o > Pa || (o > Pa || s < Pa) && g) && (o++, o === Qo && o++), o > rd && (o = o - rd + _f - 1), m > td ? (m = m - td + _f - 1, g = !0) : g = !1, (m === Qo || f < Qo && m > Qo || (m > Qo || f < Qo) && g) && m++, (m === Pa || f < Pa && m > Pa || (m > Pa || f < Pa) && g) && (m++, m === Qo && m++), m > td && (m = m - td + _f - 1);
  var b = String.fromCharCode(o) + String.fromCharCode(m);
  return b;
}
function AT(t) {
  if (t && t.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var e = t.length, n = null, a = "", s, f = 0; !/[A-Z]/.test(s = t.charAt(f)); ) {
    if (f >= 2)
      throw "MGRSPoint bad conversion from: " + t;
    a += s, f++;
  }
  var o = parseInt(a, 10);
  if (f === 0 || f + 3 > e)
    throw "MGRSPoint bad conversion from: " + t;
  var m = t.charAt(f++);
  if (m <= "A" || m === "B" || m === "Y" || m >= "Z" || m === "I" || m === "O")
    throw "MGRSPoint zone letter " + m + " not handled: " + t;
  n = t.substring(f, f += 2);
  for (var g = PT(o), b = yN(n.charAt(0), g), T = gN(n.charAt(1), g); T < vN(m); )
    T += 2e6;
  var M = e - f;
  if (M % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + t;
  var I = M / 2, A = 0, z = 0, V, q, re, X, ae;
  return I > 0 && (V = 1e5 / Math.pow(10, I), q = t.substring(f, f + I), A = parseFloat(q) * V, re = t.substring(f + I), z = parseFloat(re) * V), X = A + b, ae = z + T, {
    easting: X,
    northing: ae,
    zoneLetter: m,
    zoneNumber: o,
    accuracy: V
  };
}
function yN(t, e) {
  for (var n = MT.charCodeAt(e - 1), a = 1e5, s = !1; n !== t.charCodeAt(0); ) {
    if (n++, n === Qo && n++, n === Pa && n++, n > rd) {
      if (s)
        throw "Bad character: " + t;
      n = _f, s = !0;
    }
    a += 1e5;
  }
  return a;
}
function gN(t, e) {
  if (t > "V")
    throw "MGRSPoint given invalid Northing " + t;
  for (var n = IT.charCodeAt(e - 1), a = 0, s = !1; n !== t.charCodeAt(0); ) {
    if (n++, n === Qo && n++, n === Pa && n++, n > td) {
      if (s)
        throw "Bad character: " + t;
      n = _f, s = !0;
    }
    a += 1e5;
  }
  return a;
}
function vN(t) {
  var e;
  switch (t) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0)
    return e;
  throw "Invalid zone letter: " + t;
}
function Nf(t, e, n) {
  if (!(this instanceof Nf))
    return new Nf(t, e, n);
  if (Array.isArray(t))
    this.x = t[0], this.y = t[1], this.z = t[2] || 0;
  else if (typeof t == "object")
    this.x = t.x, this.y = t.y, this.z = t.z || 0;
  else if (typeof t == "string" && typeof e > "u") {
    var a = t.split(",");
    this.x = parseFloat(a[0], 10), this.y = parseFloat(a[1], 10), this.z = parseFloat(a[2], 10) || 0;
  } else
    this.x = t, this.y = e, this.z = n || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Nf.fromMGRS = function(t) {
  return new Nf(CT(t));
};
Nf.prototype.toMGRS = function(t) {
  return OT([this.x, this.y], t);
};
var _N = 1, xN = 0.25, Zw = 0.046875, Xw = 0.01953125, Kw = 0.01068115234375, bN = 0.75, wN = 0.46875, EN = 0.013020833333333334, SN = 0.007120768229166667, TN = 0.3645833333333333, MN = 0.005696614583333333, IN = 0.3076171875;
function kT(t) {
  var e = [];
  e[0] = _N - t * (xN + t * (Zw + t * (Xw + t * Kw))), e[1] = t * (bN - t * (Zw + t * (Xw + t * Kw)));
  var n = t * t;
  return e[2] = n * (wN - t * (EN + t * SN)), n *= t, e[3] = n * (TN - t * MN), e[4] = n * t * IN, e;
}
function Ov(t, e, n, a) {
  return n *= e, e *= e, a[0] * t - n * (a[1] + e * (a[2] + e * (a[3] + e * a[4])));
}
var ON = 20;
function LT(t, e, n) {
  for (var a = 1 / (1 - e), s = t, f = ON; f; --f) {
    var o = Math.sin(s), m = 1 - e * o * o;
    if (m = (Ov(s, o, Math.cos(s), n) - t) * (m * Math.sqrt(m)) * a, s -= m, Math.abs(m) < Ct)
      return s;
  }
  return s;
}
function CN() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = kT(this.es), this.ml0 = Ov(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function PN(t) {
  var e = t.x, n = t.y, a = Vt(e - this.long0), s, f, o, m = Math.sin(n), g = Math.cos(n);
  if (this.es) {
    var T = g * a, M = Math.pow(T, 2), I = this.ep2 * Math.pow(g, 2), A = Math.pow(I, 2), z = Math.abs(g) > Ct ? Math.tan(n) : 0, V = Math.pow(z, 2), q = Math.pow(V, 2);
    s = 1 - this.es * Math.pow(m, 2), T = T / Math.sqrt(s);
    var re = Ov(n, m, g, this.en);
    f = this.a * (this.k0 * T * (1 + M / 6 * (1 - V + I + M / 20 * (5 - 18 * V + q + 14 * I - 58 * V * I + M / 42 * (61 + 179 * q - q * V - 479 * V))))) + this.x0, o = this.a * (this.k0 * (re - this.ml0 + m * a * T / 2 * (1 + M / 12 * (5 - V + 9 * I + 4 * A + M / 30 * (61 + q - 58 * V + 270 * I - 330 * V * I + M / 56 * (1385 + 543 * q - q * V - 3111 * V)))))) + this.y0;
  } else {
    var b = g * Math.sin(a);
    if (Math.abs(Math.abs(b) - 1) < Ct)
      return 93;
    if (f = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0, o = g * Math.cos(a) / Math.sqrt(1 - Math.pow(b, 2)), b = Math.abs(o), b >= 1) {
      if (b - 1 > Ct)
        return 93;
      o = 0;
    } else
      o = Math.acos(o);
    n < 0 && (o = -o), o = this.a * this.k0 * (o - this.lat0) + this.y0;
  }
  return t.x = f, t.y = o, t;
}
function AN(t) {
  var e, n, a, s, f = (t.x - this.x0) * (1 / this.a), o = (t.y - this.y0) * (1 / this.a);
  if (this.es)
    if (e = this.ml0 + o / this.k0, n = LT(e, this.es, this.en), Math.abs(n) < ft) {
      var M = Math.sin(n), I = Math.cos(n), A = Math.abs(I) > Ct ? Math.tan(n) : 0, z = this.ep2 * Math.pow(I, 2), V = Math.pow(z, 2), q = Math.pow(A, 2), re = Math.pow(q, 2);
      e = 1 - this.es * Math.pow(M, 2);
      var X = f * Math.sqrt(e) / this.k0, ae = Math.pow(X, 2);
      e = e * A, a = n - e * ae / (1 - this.es) * 0.5 * (1 - ae / 12 * (5 + 3 * q - 9 * z * q + z - 4 * V - ae / 30 * (61 + 90 * q - 252 * z * q + 45 * re + 46 * z - ae / 56 * (1385 + 3633 * q + 4095 * re + 1574 * re * q)))), s = Vt(this.long0 + X * (1 - ae / 6 * (1 + 2 * q + z - ae / 20 * (5 + 28 * q + 24 * re + 8 * z * q + 6 * z - ae / 42 * (61 + 662 * q + 1320 * re + 720 * re * q)))) / I);
    } else
      a = ft * qd(o), s = 0;
  else {
    var m = Math.exp(f / this.k0), g = 0.5 * (m - 1 / m), b = this.lat0 + o / this.k0, T = Math.cos(b);
    e = Math.sqrt((1 - Math.pow(T, 2)) / (1 + Math.pow(g, 2))), a = Math.asin(e), o < 0 && (a = -a), g === 0 && T === 0 ? s = 0 : s = Vt(Math.atan2(g, T) + this.long0);
  }
  return t.x = s, t.y = a, t;
}
var kN = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const lg = {
  init: CN,
  forward: PN,
  inverse: AN,
  names: kN
};
function DT(t) {
  var e = Math.exp(t);
  return e = (e - 1 / e) / 2, e;
}
function ns(t, e) {
  t = Math.abs(t), e = Math.abs(e);
  var n = Math.max(t, e), a = Math.min(t, e) / (n || 1);
  return n * Math.sqrt(1 + Math.pow(a, 2));
}
function LN(t) {
  var e = 1 + t, n = e - 1;
  return n === 0 ? t : t * Math.log(e) / n;
}
function DN(t) {
  var e = Math.abs(t);
  return e = LN(e * (1 + e / (ns(1, e) + 1))), t < 0 ? -e : e;
}
function qx(t, e) {
  for (var n = 2 * Math.cos(2 * e), a = t.length - 1, s = t[a], f = 0, o; --a >= 0; )
    o = -f + n * s + t[a], f = s, s = o;
  return e + o * Math.sin(2 * e);
}
function NN(t, e) {
  for (var n = 2 * Math.cos(e), a = t.length - 1, s = t[a], f = 0, o; --a >= 0; )
    o = -f + n * s + t[a], f = s, s = o;
  return Math.sin(e) * o;
}
function RN(t) {
  var e = Math.exp(t);
  return e = (e + 1 / e) / 2, e;
}
function NT(t, e, n) {
  for (var a = Math.sin(e), s = Math.cos(e), f = DT(n), o = RN(n), m = 2 * s * o, g = -2 * a * f, b = t.length - 1, T = t[b], M = 0, I = 0, A = 0, z, V; --b >= 0; )
    z = I, V = M, I = T, M = A, T = -z + m * I - g * M + t[b], A = -V + g * I + m * M;
  return m = a * o, g = s * f, [m * T - g * A, m * A + g * T];
}
function zN() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (lg.init.apply(this), this.forward = lg.forward, this.inverse = lg.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var t = this.es / (1 + Math.sqrt(1 - this.es)), e = t / (2 - t), n = e;
  this.cgb[0] = e * (2 + e * (-2 / 3 + e * (-2 + e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675)))))), this.cbg[0] = e * (-2 + e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725)))))), n = n * e, this.cgb[1] = n * (7 / 3 + e * (-8 / 5 + e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))))), this.cbg[1] = n * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), n = n * e, this.cgb[2] = n * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = n * (-26 / 15 + e * (34 / 21 + e * (8 / 5 + e * (-12686 / 2835)))), n = n * e, this.cgb[3] = n * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = n * (1237 / 630 + e * (-12 / 5 + e * (-24832 / 14175))), n = n * e, this.cgb[4] = n * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = n * (-734 / 315 + e * (109598 / 31185)), n = n * e, this.cgb[5] = n * (601676 / 22275), this.cbg[5] = n * (444337 / 155925), n = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + n * (1 / 4 + n * (1 / 64 + n / 256))), this.utg[0] = e * (-0.5 + e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800)))))), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = n * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = n * (13 / 48 + e * (-3 / 5 + e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))))), n = n * e, this.utg[2] = n * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = n * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), n = n * e, this.utg[3] = n * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = n * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), n = n * e, this.utg[4] = n * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = n * (34729 / 80640 + e * (-3418889 / 1995840)), n = n * e, this.utg[5] = n * (-20648693 / 638668800), this.gtu[5] = n * (212378941 / 319334400);
  var a = qx(this.cbg, this.lat0);
  this.Zb = -this.Qn * (a + NN(this.gtu, 2 * a));
}
function FN(t) {
  var e = Vt(t.x - this.long0), n = t.y;
  n = qx(this.cbg, n);
  var a = Math.sin(n), s = Math.cos(n), f = Math.sin(e), o = Math.cos(e);
  n = Math.atan2(a, o * s), e = Math.atan2(f * s, ns(a, s * o)), e = DN(Math.tan(e));
  var m = NT(this.gtu, 2 * n, 2 * e);
  n = n + m[0], e = e + m[1];
  var g, b;
  return Math.abs(e) <= 2.623395162778 ? (g = this.a * (this.Qn * e) + this.x0, b = this.a * (this.Qn * n + this.Zb) + this.y0) : (g = 1 / 0, b = 1 / 0), t.x = g, t.y = b, t;
}
function BN(t) {
  var e = (t.x - this.x0) * (1 / this.a), n = (t.y - this.y0) * (1 / this.a);
  n = (n - this.Zb) / this.Qn, e = e / this.Qn;
  var a, s;
  if (Math.abs(e) <= 2.623395162778) {
    var f = NT(this.utg, 2 * n, 2 * e);
    n = n + f[0], e = e + f[1], e = Math.atan(DT(e));
    var o = Math.sin(n), m = Math.cos(n), g = Math.sin(e), b = Math.cos(e);
    n = Math.atan2(o * b, ns(g, b * m)), e = Math.atan2(g, b * m), a = Vt(e + this.long0), s = qx(this.cgb, n);
  } else
    a = 1 / 0, s = 1 / 0;
  return t.x = a, t.y = s, t;
}
var VN = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
const ug = {
  init: zN,
  forward: FN,
  inverse: BN,
  names: VN
};
function UN(t, e) {
  if (t === void 0) {
    if (t = Math.floor((Vt(e) + Math.PI) * 30 / Math.PI) + 1, t < 0)
      return 0;
    if (t > 60)
      return 60;
  }
  return t;
}
var jN = "etmerc";
function GN() {
  var t = UN(this.zone, this.long0);
  if (t === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(t) - 183) * io, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, ug.init.apply(this), this.forward = ug.forward, this.inverse = ug.inverse;
}
var $N = ["Universal Transverse Mercator System", "utm"];
const qN = {
  init: GN,
  names: $N,
  dependsOn: jN
};
function Wx(t, e) {
  return Math.pow((1 - t) / (1 + t), e);
}
var WN = 20;
function HN() {
  var t = Math.sin(this.lat0), e = Math.cos(this.lat0);
  e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(t / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + un) / (Math.pow(Math.tan(0.5 * this.lat0 + un), this.C) * Wx(this.e * t, this.ratexp));
}
function ZN(t) {
  var e = t.x, n = t.y;
  return t.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * n + un), this.C) * Wx(this.e * Math.sin(n), this.ratexp)) - ft, t.x = this.C * e, t;
}
function XN(t) {
  for (var e = 1e-14, n = t.x / this.C, a = t.y, s = Math.pow(Math.tan(0.5 * a + un) / this.K, 1 / this.C), f = WN; f > 0 && (a = 2 * Math.atan(s * Wx(this.e * Math.sin(t.y), -0.5 * this.e)) - ft, !(Math.abs(a - t.y) < e)); --f)
    t.y = a;
  return f ? (t.x = n, t.y = a, t) : null;
}
var KN = ["gauss"];
const Hx = {
  init: HN,
  forward: ZN,
  inverse: XN,
  names: KN
};
function YN() {
  Hx.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function JN(t) {
  var e, n, a, s;
  return t.x = Vt(t.x - this.long0), Hx.forward.apply(this, [t]), e = Math.sin(t.y), n = Math.cos(t.y), a = Math.cos(t.x), s = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * n * a), t.x = s * n * Math.sin(t.x), t.y = s * (this.cosc0 * e - this.sinc0 * n * a), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
}
function QN(t) {
  var e, n, a, s, f;
  if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, f = Math.sqrt(t.x * t.x + t.y * t.y)) {
    var o = 2 * Math.atan2(f, this.R2);
    e = Math.sin(o), n = Math.cos(o), s = Math.asin(n * this.sinc0 + t.y * e * this.cosc0 / f), a = Math.atan2(t.x * e, f * this.cosc0 * n - t.y * this.sinc0 * e);
  } else
    s = this.phic0, a = 0;
  return t.x = a, t.y = s, Hx.inverse.apply(this, [t]), t.x = Vt(t.x + this.long0), t;
}
var e3 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const t3 = {
  init: YN,
  forward: JN,
  inverse: QN,
  names: e3
};
function r3(t, e, n) {
  return e *= n, Math.tan(0.5 * (ft + t)) * Math.pow((1 - e) / (1 + e), 0.5 * n);
}
function n3() {
  this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Ct && (this.k0 = 0.5 * (1 + qd(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= Ct && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Ct && (this.k0 = 0.5 * this.cons * el(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / ls(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = el(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - ft, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function i3(t) {
  var e = t.x, n = t.y, a = Math.sin(n), s = Math.cos(n), f, o, m, g, b, T, M = Vt(e - this.long0);
  return Math.abs(Math.abs(e - this.long0) - Math.PI) <= Ct && Math.abs(n + this.lat0) <= Ct ? (t.x = NaN, t.y = NaN, t) : this.sphere ? (f = 2 * this.k0 / (1 + this.sinlat0 * a + this.coslat0 * s * Math.cos(M)), t.x = this.a * f * s * Math.sin(M) + this.x0, t.y = this.a * f * (this.coslat0 * a - this.sinlat0 * s * Math.cos(M)) + this.y0, t) : (o = 2 * Math.atan(this.ssfn_(n, a, this.e)) - ft, g = Math.cos(o), m = Math.sin(o), Math.abs(this.coslat0) <= Ct ? (b = ls(this.e, n * this.con, this.con * a), T = 2 * this.a * this.k0 * b / this.cons, t.x = this.x0 + T * Math.sin(e - this.long0), t.y = this.y0 - this.con * T * Math.cos(e - this.long0), t) : (Math.abs(this.sinlat0) < Ct ? (f = 2 * this.a * this.k0 / (1 + g * Math.cos(M)), t.y = f * m) : (f = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * m + this.cosX0 * g * Math.cos(M))), t.y = f * (this.cosX0 * m - this.sinX0 * g * Math.cos(M)) + this.y0), t.x = f * g * Math.sin(M) + this.x0, t));
}
function o3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n, a, s, f, o = Math.sqrt(t.x * t.x + t.y * t.y);
  if (this.sphere) {
    var m = 2 * Math.atan(o / (2 * this.a * this.k0));
    return e = this.long0, n = this.lat0, o <= Ct ? (t.x = e, t.y = n, t) : (n = Math.asin(Math.cos(m) * this.sinlat0 + t.y * Math.sin(m) * this.coslat0 / o), Math.abs(this.coslat0) < Ct ? this.lat0 > 0 ? e = Vt(this.long0 + Math.atan2(t.x, -1 * t.y)) : e = Vt(this.long0 + Math.atan2(t.x, t.y)) : e = Vt(this.long0 + Math.atan2(t.x * Math.sin(m), o * this.coslat0 * Math.cos(m) - t.y * this.sinlat0 * Math.sin(m))), t.x = e, t.y = n, t);
  } else if (Math.abs(this.coslat0) <= Ct) {
    if (o <= Ct)
      return n = this.lat0, e = this.long0, t.x = e, t.y = n, t;
    t.x *= this.con, t.y *= this.con, a = o * this.cons / (2 * this.a * this.k0), n = this.con * Nd(this.e, a), e = this.con * Vt(this.con * this.long0 + Math.atan2(t.x, -1 * t.y));
  } else
    s = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, o <= Ct ? f = this.X0 : (f = Math.asin(Math.cos(s) * this.sinX0 + t.y * Math.sin(s) * this.cosX0 / o), e = Vt(this.long0 + Math.atan2(t.x * Math.sin(s), o * this.cosX0 * Math.cos(s) - t.y * this.sinX0 * Math.sin(s)))), n = -1 * Nd(this.e, Math.tan(0.5 * (ft + f)));
  return t.x = e, t.y = n, t;
}
var a3 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
const s3 = {
  init: n3,
  forward: i3,
  inverse: o3,
  names: a3,
  ssfn_: r3
};
function l3() {
  var t = this.lat0;
  this.lambda0 = this.long0;
  var e = Math.sin(t), n = this.a, a = this.rf, s = 1 / a, f = 2 * s - Math.pow(s, 2), o = this.e = Math.sqrt(f);
  this.R = this.k0 * n * Math.sqrt(1 - f) / (1 - f * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + f / (1 - f) * Math.pow(Math.cos(t), 4)), this.b0 = Math.asin(e / this.alpha);
  var m = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), g = Math.log(Math.tan(Math.PI / 4 + t / 2)), b = Math.log((1 + o * e) / (1 - o * e));
  this.K = m - this.alpha * g + this.alpha * o / 2 * b;
}
function u3(t) {
  var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)), n = this.e / 2 * Math.log((1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))), a = -this.alpha * (e + n) + this.K, s = 2 * (Math.atan(Math.exp(a)) - Math.PI / 4), f = this.alpha * (t.x - this.lambda0), o = Math.atan(Math.sin(f) / (Math.sin(this.b0) * Math.tan(s) + Math.cos(this.b0) * Math.cos(f))), m = Math.asin(Math.cos(this.b0) * Math.sin(s) - Math.sin(this.b0) * Math.cos(s) * Math.cos(f));
  return t.y = this.R / 2 * Math.log((1 + Math.sin(m)) / (1 - Math.sin(m))) + this.y0, t.x = this.R * o + this.x0, t;
}
function c3(t) {
  for (var e = t.x - this.x0, n = t.y - this.y0, a = e / this.R, s = 2 * (Math.atan(Math.exp(n / this.R)) - Math.PI / 4), f = Math.asin(Math.cos(this.b0) * Math.sin(s) + Math.sin(this.b0) * Math.cos(s) * Math.cos(a)), o = Math.atan(Math.sin(a) / (Math.cos(this.b0) * Math.cos(a) - Math.sin(this.b0) * Math.tan(s))), m = this.lambda0 + o / this.alpha, g = 0, b = f, T = -1e3, M = 0; Math.abs(b - T) > 1e-7; ) {
    if (++M > 20)
      return;
    g = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + f / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(b)) / 2)), T = b, b = 2 * Math.atan(Math.exp(g)) - Math.PI / 2;
  }
  return t.x = m, t.y = b, t;
}
var h3 = ["somerc"];
const f3 = {
  init: l3,
  forward: u3,
  inverse: c3,
  names: h3
};
var ff = 1e-7;
function p3(t) {
  var e = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], n = typeof t.PROJECTION == "object" ? Object.keys(t.PROJECTION)[0] : t.PROJECTION;
  return "no_uoff" in t || "no_off" in t || e.indexOf(n) !== -1;
}
function d3() {
  var t, e, n, a, s, f, o, m, g, b, T = 0, M, I = 0, A = 0, z = 0, V = 0, q = 0, re = 0;
  this.no_off = p3(this), this.no_rot = "no_rot" in this;
  var X = !1;
  "alpha" in this && (X = !0);
  var ae = !1;
  if ("rectified_grid_angle" in this && (ae = !0), X && (re = this.alpha), ae && (T = this.rectified_grid_angle * io), X || ae)
    I = this.longc;
  else if (A = this.long1, V = this.lat1, z = this.long2, q = this.lat2, Math.abs(V - q) <= ff || (t = Math.abs(V)) <= ff || Math.abs(t - ft) <= ff || Math.abs(Math.abs(this.lat0) - ft) <= ff || Math.abs(Math.abs(q) - ft) <= ff)
    throw new Error();
  var ce = 1 - this.es;
  e = Math.sqrt(ce), Math.abs(this.lat0) > Ct ? (m = Math.sin(this.lat0), n = Math.cos(this.lat0), t = 1 - this.es * m * m, this.B = n * n, this.B = Math.sqrt(1 + this.es * this.B * this.B / ce), this.A = this.B * this.k0 * e / t, a = this.B * e / (n * Math.sqrt(t)), s = a * a - 1, s <= 0 ? s = 0 : (s = Math.sqrt(s), this.lat0 < 0 && (s = -s)), this.E = s += a, this.E *= Math.pow(ls(this.e, this.lat0, m), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = a = s = 1), X || ae ? (X ? (M = Math.asin(Math.sin(re) / a), ae || (T = re)) : (M = T, re = Math.asin(a * Math.sin(M))), this.lam0 = I - Math.asin(0.5 * (s - 1 / s) * Math.tan(M)) / this.B) : (f = Math.pow(ls(this.e, V, Math.sin(V)), this.B), o = Math.pow(ls(this.e, q, Math.sin(q)), this.B), s = this.E / f, g = (o - f) / (o + f), b = this.E * this.E, b = (b - o * f) / (b + o * f), t = A - z, t < -Math.pi ? z -= Ld : t > Math.pi && (z += Ld), this.lam0 = Vt(0.5 * (A + z) - Math.atan(b * Math.tan(0.5 * this.B * (A - z)) / g) / this.B), M = Math.atan(2 * Math.sin(this.B * Vt(A - this.lam0)) / (s - 1 / s)), T = re = Math.asin(a * Math.sin(M))), this.singam = Math.sin(M), this.cosgam = Math.cos(M), this.sinrot = Math.sin(T), this.cosrot = Math.cos(T), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(a * a - 1) / Math.cos(re))), this.lat0 < 0 && (this.u_0 = -this.u_0)), s = 0.5 * M, this.v_pole_n = this.ArB * Math.log(Math.tan(un - s)), this.v_pole_s = this.ArB * Math.log(Math.tan(un + s));
}
function m3(t) {
  var e = {}, n, a, s, f, o, m, g, b;
  if (t.x = t.x - this.lam0, Math.abs(Math.abs(t.y) - ft) > Ct) {
    if (o = this.E / Math.pow(ls(this.e, t.y, Math.sin(t.y)), this.B), m = 1 / o, n = 0.5 * (o - m), a = 0.5 * (o + m), f = Math.sin(this.B * t.x), s = (n * this.singam - f * this.cosgam) / a, Math.abs(Math.abs(s) - 1) < Ct)
      throw new Error();
    b = 0.5 * this.ArB * Math.log((1 - s) / (1 + s)), m = Math.cos(this.B * t.x), Math.abs(m) < ff ? g = this.A * t.x : g = this.ArB * Math.atan2(n * this.cosgam + f * this.singam, m);
  } else
    b = t.y > 0 ? this.v_pole_n : this.v_pole_s, g = this.ArB * t.y;
  return this.no_rot ? (e.x = g, e.y = b) : (g -= this.u_0, e.x = b * this.cosrot + g * this.sinrot, e.y = g * this.cosrot - b * this.sinrot), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function y3(t) {
  var e, n, a, s, f, o, m, g = {};
  if (t.x = (t.x - this.x0) * (1 / this.a), t.y = (t.y - this.y0) * (1 / this.a), this.no_rot ? (n = t.y, e = t.x) : (n = t.x * this.cosrot - t.y * this.sinrot, e = t.y * this.cosrot + t.x * this.sinrot + this.u_0), a = Math.exp(-this.BrA * n), s = 0.5 * (a - 1 / a), f = 0.5 * (a + 1 / a), o = Math.sin(this.BrA * e), m = (o * this.cosgam + s * this.singam) / f, Math.abs(Math.abs(m) - 1) < Ct)
    g.x = 0, g.y = m < 0 ? -ft : ft;
  else {
    if (g.y = this.E / Math.sqrt((1 + m) / (1 - m)), g.y = Nd(this.e, Math.pow(g.y, 1 / this.B)), g.y === 1 / 0)
      throw new Error();
    g.x = -this.rB * Math.atan2(s * this.cosgam - o * this.singam, Math.cos(this.BrA * e));
  }
  return g.x += this.lam0, g;
}
var g3 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const v3 = {
  init: d3,
  forward: m3,
  inverse: y3,
  names: g3
};
function _3() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < Ct)) {
    var t = this.b / this.a;
    this.e = Math.sqrt(1 - t * t);
    var e = Math.sin(this.lat1), n = Math.cos(this.lat1), a = el(this.e, e, n), s = ls(this.e, this.lat1, e), f = Math.sin(this.lat2), o = Math.cos(this.lat2), m = el(this.e, f, o), g = ls(this.e, this.lat2, f), b = ls(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > Ct ? this.ns = Math.log(a / m) / Math.log(s / g) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = a / (this.ns * Math.pow(s, this.ns)), this.rh = this.a * this.f0 * Math.pow(b, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function x3(t) {
  var e = t.x, n = t.y;
  Math.abs(2 * Math.abs(n) - Math.PI) <= Ct && (n = qd(n) * (ft - 2 * Ct));
  var a = Math.abs(Math.abs(n) - ft), s, f;
  if (a > Ct)
    s = ls(this.e, n, Math.sin(n)), f = this.a * this.f0 * Math.pow(s, this.ns);
  else {
    if (a = n * this.ns, a <= 0)
      return null;
    f = 0;
  }
  var o = this.ns * Vt(e - this.long0);
  return t.x = this.k0 * (f * Math.sin(o)) + this.x0, t.y = this.k0 * (this.rh - f * Math.cos(o)) + this.y0, t;
}
function b3(t) {
  var e, n, a, s, f, o = (t.x - this.x0) / this.k0, m = this.rh - (t.y - this.y0) / this.k0;
  this.ns > 0 ? (e = Math.sqrt(o * o + m * m), n = 1) : (e = -Math.sqrt(o * o + m * m), n = -1);
  var g = 0;
  if (e !== 0 && (g = Math.atan2(n * o, n * m)), e !== 0 || this.ns > 0) {
    if (n = 1 / this.ns, a = Math.pow(e / (this.a * this.f0), n), s = Nd(this.e, a), s === -9999)
      return null;
  } else
    s = -ft;
  return f = Vt(g / this.ns + this.long0), t.x = f, t.y = s, t;
}
var w3 = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const E3 = {
  init: _3,
  forward: x3,
  inverse: b3,
  names: w3
};
function S3() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function T3(t) {
  var e, n, a, s, f, o, m, g = t.x, b = t.y, T = Vt(g - this.long0);
  return e = Math.pow((1 + this.e * Math.sin(b)) / (1 - this.e * Math.sin(b)), this.alfa * this.e / 2), n = 2 * (Math.atan(this.k * Math.pow(Math.tan(b / 2 + this.s45), this.alfa) / e) - this.s45), a = -T * this.alfa, s = Math.asin(Math.cos(this.ad) * Math.sin(n) + Math.sin(this.ad) * Math.cos(n) * Math.cos(a)), f = Math.asin(Math.cos(n) * Math.sin(a) / Math.cos(s)), o = this.n * f, m = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n), t.y = m * Math.cos(o) / 1, t.x = m * Math.sin(o) / 1, this.czech || (t.y *= -1, t.x *= -1), t;
}
function M3(t) {
  var e, n, a, s, f, o, m, g, b = t.x;
  t.x = t.y, t.y = b, this.czech || (t.y *= -1, t.x *= -1), o = Math.sqrt(t.x * t.x + t.y * t.y), f = Math.atan2(t.y, t.x), s = f / Math.sin(this.s0), a = 2 * (Math.atan(Math.pow(this.ro0 / o, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(a) - Math.sin(this.ad) * Math.cos(a) * Math.cos(s)), n = Math.asin(Math.cos(a) * Math.sin(s) / Math.cos(e)), t.x = this.long0 - n / this.alfa, m = e, g = 0;
  var T = 0;
  do
    t.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(m)) / (1 - this.e * Math.sin(m)), this.e / 2)) - this.s45), Math.abs(m - t.y) < 1e-10 && (g = 1), m = t.y, T += 1;
  while (g === 0 && T < 15);
  return T >= 15 ? null : t;
}
var I3 = ["Krovak", "krovak"];
const O3 = {
  init: S3,
  forward: T3,
  inverse: M3,
  names: I3
};
function zo(t, e, n, a, s) {
  return t * s - e * Math.sin(2 * s) + n * Math.sin(4 * s) - a * Math.sin(6 * s);
}
function Wd(t) {
  return 1 - 0.25 * t * (1 + t / 16 * (3 + 1.25 * t));
}
function Hd(t) {
  return 0.375 * t * (1 + 0.25 * t * (1 + 0.46875 * t));
}
function Zd(t) {
  return 0.05859375 * t * t * (1 + 0.75 * t);
}
function Xd(t) {
  return t * t * t * (35 / 3072);
}
function Rf(t, e, n) {
  var a = e * n;
  return t / Math.sqrt(1 - a * a);
}
function Vf(t) {
  return Math.abs(t) < ft ? t : t - qd(t) * Math.PI;
}
function zg(t, e, n, a, s) {
  var f, o;
  f = t / e;
  for (var m = 0; m < 15; m++)
    if (o = (t - (e * f - n * Math.sin(2 * f) + a * Math.sin(4 * f) - s * Math.sin(6 * f))) / (e - 2 * n * Math.cos(2 * f) + 4 * a * Math.cos(4 * f) - 6 * s * Math.cos(6 * f)), f += o, Math.abs(o) <= 1e-10)
      return f;
  return NaN;
}
function C3() {
  this.sphere || (this.e0 = Wd(this.es), this.e1 = Hd(this.es), this.e2 = Zd(this.es), this.e3 = Xd(this.es), this.ml0 = this.a * zo(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function P3(t) {
  var e, n, a = t.x, s = t.y;
  if (a = Vt(a - this.long0), this.sphere)
    e = this.a * Math.asin(Math.cos(s) * Math.sin(a)), n = this.a * (Math.atan2(Math.tan(s), Math.cos(a)) - this.lat0);
  else {
    var f = Math.sin(s), o = Math.cos(s), m = Rf(this.a, this.e, f), g = Math.tan(s) * Math.tan(s), b = a * Math.cos(s), T = b * b, M = this.es * o * o / (1 - this.es), I = this.a * zo(this.e0, this.e1, this.e2, this.e3, s);
    e = m * b * (1 - T * g * (1 / 6 - (8 - g + 8 * M) * T / 120)), n = I - this.ml0 + m * f / o * T * (0.5 + (5 - g + 6 * M) * T / 24);
  }
  return t.x = e + this.x0, t.y = n + this.y0, t;
}
function A3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = t.x / this.a, n = t.y / this.a, a, s;
  if (this.sphere) {
    var f = n + this.lat0;
    a = Math.asin(Math.sin(f) * Math.cos(e)), s = Math.atan2(Math.tan(e), Math.cos(f));
  } else {
    var o = this.ml0 / this.a + n, m = zg(o, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(m) - ft) <= Ct)
      return t.x = this.long0, t.y = ft, n < 0 && (t.y *= -1), t;
    var g = Rf(this.a, this.e, Math.sin(m)), b = g * g * g / this.a / this.a * (1 - this.es), T = Math.pow(Math.tan(m), 2), M = e * this.a / g, I = M * M;
    a = m - g * Math.tan(m) / b * M * M * (0.5 - (1 + 3 * T) * M * M / 24), s = M * (1 - I * (T / 3 + (1 + 3 * T) * T * I / 15)) / Math.cos(m);
  }
  return t.x = Vt(s + this.long0), t.y = Vf(a), t;
}
var k3 = ["Cassini", "Cassini_Soldner", "cass"];
const L3 = {
  init: C3,
  forward: P3,
  inverse: A3,
  names: k3
};
function Lu(t, e) {
  var n;
  return t > 1e-7 ? (n = t * e, (1 - t * t) * (e / (1 - n * n) - 0.5 / t * Math.log((1 - n) / (1 + n)))) : 2 * e;
}
var D3 = 1, N3 = 2, R3 = 3, z3 = 4;
function F3() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - ft) < Ct ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(t) < Ct ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
    var e;
    switch (this.qp = Lu(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = H3(this.es), this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = Lu(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function B3(t) {
  var e, n, a, s, f, o, m, g, b, T, M = t.x, I = t.y;
  if (M = Vt(M - this.long0), this.sphere) {
    if (f = Math.sin(I), T = Math.cos(I), a = Math.cos(M), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (n = this.mode === this.EQUIT ? 1 + T * a : 1 + this.sinph0 * f + this.cosph0 * T * a, n <= Ct)
        return null;
      n = Math.sqrt(2 / n), e = n * T * Math.sin(M), n *= this.mode === this.EQUIT ? f : this.cosph0 * f - this.sinph0 * T * a;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (a = -a), Math.abs(I + this.lat0) < Ct)
        return null;
      n = un - I * 0.5, n = 2 * (this.mode === this.S_POLE ? Math.cos(n) : Math.sin(n)), e = n * Math.sin(M), n *= a;
    }
  } else {
    switch (m = 0, g = 0, b = 0, a = Math.cos(M), s = Math.sin(M), f = Math.sin(I), o = Lu(this.e, f), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (m = o / this.qp, g = Math.sqrt(1 - m * m)), this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * m + this.cosb1 * g * a;
        break;
      case this.EQUIT:
        b = 1 + g * a;
        break;
      case this.N_POLE:
        b = ft + I, o = this.qp - o;
        break;
      case this.S_POLE:
        b = I - ft, o = this.qp + o;
        break;
    }
    if (Math.abs(b) < Ct)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b), this.mode === this.OBLIQ ? n = this.ymf * b * (this.cosb1 * m - this.sinb1 * g * a) : n = (b = Math.sqrt(2 / (1 + g * a))) * m * this.ymf, e = this.xmf * b * g * s;
        break;
      case this.N_POLE:
      case this.S_POLE:
        o >= 0 ? (e = (b = Math.sqrt(o)) * s, n = a * (this.mode === this.S_POLE ? b : -b)) : e = n = 0;
        break;
    }
  }
  return t.x = this.a * e + this.x0, t.y = this.a * n + this.y0, t;
}
function V3(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = t.x / this.a, n = t.y / this.a, a, s, f, o, m, g, b;
  if (this.sphere) {
    var T = 0, M, I = 0;
    if (M = Math.sqrt(e * e + n * n), s = M * 0.5, s > 1)
      return null;
    switch (s = 2 * Math.asin(s), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (I = Math.sin(s), T = Math.cos(s)), this.mode) {
      case this.EQUIT:
        s = Math.abs(M) <= Ct ? 0 : Math.asin(n * I / M), e *= I, n = T * M;
        break;
      case this.OBLIQ:
        s = Math.abs(M) <= Ct ? this.lat0 : Math.asin(T * this.sinph0 + n * I * this.cosph0 / M), e *= I * this.cosph0, n = (T - Math.sin(s) * this.sinph0) * M;
        break;
      case this.N_POLE:
        n = -n, s = ft - s;
        break;
      case this.S_POLE:
        s -= ft;
        break;
    }
    a = n === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(e, n);
  } else {
    if (b = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (e /= this.dd, n *= this.dd, g = Math.sqrt(e * e + n * n), g < Ct)
        return t.x = this.long0, t.y = this.lat0, t;
      o = 2 * Math.asin(0.5 * g / this.rq), f = Math.cos(o), e *= o = Math.sin(o), this.mode === this.OBLIQ ? (b = f * this.sinb1 + n * o * this.cosb1 / g, m = this.qp * b, n = g * this.cosb1 * f - n * this.sinb1 * o) : (b = n * o / g, m = this.qp * b, n = g * f);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), m = e * e + n * n, !m)
        return t.x = this.long0, t.y = this.lat0, t;
      b = 1 - m / this.qp, this.mode === this.S_POLE && (b = -b);
    }
    a = Math.atan2(e, n), s = Z3(Math.asin(b), this.apa);
  }
  return t.x = Vt(this.long0 + a), t.y = s, t;
}
var U3 = 0.3333333333333333, j3 = 0.17222222222222222, G3 = 0.10257936507936508, $3 = 0.06388888888888888, q3 = 0.0664021164021164, W3 = 0.016415012942191543;
function H3(t) {
  var e, n = [];
  return n[0] = t * U3, e = t * t, n[0] += e * j3, n[1] = e * $3, e *= t, n[0] += e * G3, n[1] += e * q3, n[2] = e * W3, n;
}
function Z3(t, e) {
  var n = t + t;
  return t + e[0] * Math.sin(n) + e[1] * Math.sin(n + n) + e[2] * Math.sin(n + n + n);
}
var X3 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const K3 = {
  init: F3,
  forward: B3,
  inverse: V3,
  names: X3,
  S_POLE: D3,
  N_POLE: N3,
  EQUIT: R3,
  OBLIQ: z3
};
function Bu(t) {
  return Math.abs(t) > 1 && (t = t > 1 ? 1 : -1), Math.asin(t);
}
function Y3() {
  Math.abs(this.lat1 + this.lat2) < Ct || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = el(this.e3, this.sin_po, this.cos_po), this.qs1 = Lu(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = el(this.e3, this.sin_po, this.cos_po), this.qs2 = Lu(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Lu(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > Ct ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function J3(t) {
  var e = t.x, n = t.y;
  this.sin_phi = Math.sin(n), this.cos_phi = Math.cos(n);
  var a = Lu(this.e3, this.sin_phi), s = this.a * Math.sqrt(this.c - this.ns0 * a) / this.ns0, f = this.ns0 * Vt(e - this.long0), o = s * Math.sin(f) + this.x0, m = this.rh - s * Math.cos(f) + this.y0;
  return t.x = o, t.y = m, t;
}
function Q3(t) {
  var e, n, a, s, f, o;
  return t.x -= this.x0, t.y = this.rh - t.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(t.x * t.x + t.y * t.y), a = 1) : (e = -Math.sqrt(t.x * t.x + t.y * t.y), a = -1), s = 0, e !== 0 && (s = Math.atan2(a * t.x, a * t.y)), a = e * this.ns0 / this.a, this.sphere ? o = Math.asin((this.c - a * a) / (2 * this.ns0)) : (n = (this.c - a * a) / this.ns0, o = this.phi1z(this.e3, n)), f = Vt(s / this.ns0 + this.long0), t.x = f, t.y = o, t;
}
function eR(t, e) {
  var n, a, s, f, o, m = Bu(0.5 * e);
  if (t < Ct)
    return m;
  for (var g = t * t, b = 1; b <= 25; b++)
    if (n = Math.sin(m), a = Math.cos(m), s = t * n, f = 1 - s * s, o = 0.5 * f * f / a * (e / (1 - g) - n / f + 0.5 / t * Math.log((1 - s) / (1 + s))), m = m + o, Math.abs(o) <= 1e-7)
      return m;
  return null;
}
var tR = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const rR = {
  init: Y3,
  forward: J3,
  inverse: Q3,
  names: tR,
  phi1z: eR
};
function nR() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function iR(t) {
  var e, n, a, s, f, o, m, g, b = t.x, T = t.y;
  return a = Vt(b - this.long0), e = Math.sin(T), n = Math.cos(T), s = Math.cos(a), o = this.sin_p14 * e + this.cos_p14 * n * s, f = 1, o > 0 || Math.abs(o) <= Ct ? (m = this.x0 + this.a * f * n * Math.sin(a) / o, g = this.y0 + this.a * f * (this.cos_p14 * e - this.sin_p14 * n * s) / o) : (m = this.x0 + this.infinity_dist * n * Math.sin(a), g = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * n * s)), t.x = m, t.y = g, t;
}
function oR(t) {
  var e, n, a, s, f, o;
  return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, (e = Math.sqrt(t.x * t.x + t.y * t.y)) ? (s = Math.atan2(e, this.rc), n = Math.sin(s), a = Math.cos(s), o = Bu(a * this.sin_p14 + t.y * n * this.cos_p14 / e), f = Math.atan2(t.x * n, e * this.cos_p14 * a - t.y * this.sin_p14 * n), f = Vt(this.long0 + f)) : (o = this.phic0, f = 0), t.x = f, t.y = o, t;
}
var aR = ["gnom"];
const sR = {
  init: nR,
  forward: iR,
  inverse: oR,
  names: aR
};
function lR(t, e) {
  var n = 1 - (1 - t * t) / (2 * t) * Math.log((1 - t) / (1 + t));
  if (Math.abs(Math.abs(e) - n) < 1e-6)
    return e < 0 ? -1 * ft : ft;
  for (var a = Math.asin(0.5 * e), s, f, o, m, g = 0; g < 30; g++)
    if (f = Math.sin(a), o = Math.cos(a), m = t * f, s = Math.pow(1 - m * m, 2) / (2 * o) * (e / (1 - t * t) - f / (1 - m * m) + 0.5 / t * Math.log((1 - m) / (1 + m))), a += s, Math.abs(s) <= 1e-10)
      return a;
  return NaN;
}
function uR() {
  this.sphere || (this.k0 = el(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function cR(t) {
  var e = t.x, n = t.y, a, s, f = Vt(e - this.long0);
  if (this.sphere)
    a = this.x0 + this.a * f * Math.cos(this.lat_ts), s = this.y0 + this.a * Math.sin(n) / Math.cos(this.lat_ts);
  else {
    var o = Lu(this.e, Math.sin(n));
    a = this.x0 + this.a * this.k0 * f, s = this.y0 + this.a * o * 0.5 / this.k0;
  }
  return t.x = a, t.y = s, t;
}
function hR(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n;
  return this.sphere ? (e = Vt(this.long0 + t.x / this.a / Math.cos(this.lat_ts)), n = Math.asin(t.y / this.a * Math.cos(this.lat_ts))) : (n = lR(this.e, 2 * t.y * this.k0 / this.a), e = Vt(this.long0 + t.x / (this.a * this.k0))), t.x = e, t.y = n, t;
}
var fR = ["cea"];
const pR = {
  init: uR,
  forward: cR,
  inverse: hR,
  names: fR
};
function dR() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function mR(t) {
  var e = t.x, n = t.y, a = Vt(e - this.long0), s = Vf(n - this.lat0);
  return t.x = this.x0 + this.a * a * this.rc, t.y = this.y0 + this.a * s, t;
}
function yR(t) {
  var e = t.x, n = t.y;
  return t.x = Vt(this.long0 + (e - this.x0) / (this.a * this.rc)), t.y = Vf(this.lat0 + (n - this.y0) / this.a), t;
}
var gR = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const vR = {
  init: dR,
  forward: mR,
  inverse: yR,
  names: gR
};
var Yw = 20;
function _R() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Wd(this.es), this.e1 = Hd(this.es), this.e2 = Zd(this.es), this.e3 = Xd(this.es), this.ml0 = this.a * zo(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function xR(t) {
  var e = t.x, n = t.y, a, s, f, o = Vt(e - this.long0);
  if (f = o * Math.sin(n), this.sphere)
    Math.abs(n) <= Ct ? (a = this.a * o, s = -1 * this.a * this.lat0) : (a = this.a * Math.sin(f) / Math.tan(n), s = this.a * (Vf(n - this.lat0) + (1 - Math.cos(f)) / Math.tan(n)));
  else if (Math.abs(n) <= Ct)
    a = this.a * o, s = -1 * this.ml0;
  else {
    var m = Rf(this.a, this.e, Math.sin(n)) / Math.tan(n);
    a = m * Math.sin(f), s = this.a * zo(this.e0, this.e1, this.e2, this.e3, n) - this.ml0 + m * (1 - Math.cos(f));
  }
  return t.x = a + this.x0, t.y = s + this.y0, t;
}
function bR(t) {
  var e, n, a, s, f, o, m, g, b;
  if (a = t.x - this.x0, s = t.y - this.y0, this.sphere)
    if (Math.abs(s + this.a * this.lat0) <= Ct)
      e = Vt(a / this.a + this.long0), n = 0;
    else {
      o = this.lat0 + s / this.a, m = a * a / this.a / this.a + o * o, g = o;
      var T;
      for (f = Yw; f; --f)
        if (T = Math.tan(g), b = -1 * (o * (g * T + 1) - g - 0.5 * (g * g + m) * T) / ((g - o) / T - 1), g += b, Math.abs(b) <= Ct) {
          n = g;
          break;
        }
      e = Vt(this.long0 + Math.asin(a * Math.tan(g) / this.a) / Math.sin(n));
    }
  else if (Math.abs(s + this.ml0) <= Ct)
    n = 0, e = Vt(this.long0 + a / this.a);
  else {
    o = (this.ml0 + s) / this.a, m = a * a / this.a / this.a + o * o, g = o;
    var M, I, A, z, V;
    for (f = Yw; f; --f)
      if (V = this.e * Math.sin(g), M = Math.sqrt(1 - V * V) * Math.tan(g), I = this.a * zo(this.e0, this.e1, this.e2, this.e3, g), A = this.e0 - 2 * this.e1 * Math.cos(2 * g) + 4 * this.e2 * Math.cos(4 * g) - 6 * this.e3 * Math.cos(6 * g), z = I / this.a, b = (o * (M * z + 1) - z - 0.5 * M * (z * z + m)) / (this.es * Math.sin(2 * g) * (z * z + m - 2 * o * z) / (4 * M) + (o - z) * (M * A - 2 / Math.sin(2 * g)) - A), g -= b, Math.abs(b) <= Ct) {
        n = g;
        break;
      }
    M = Math.sqrt(1 - this.es * Math.pow(Math.sin(n), 2)) * Math.tan(n), e = Vt(this.long0 + Math.asin(a * M / this.a) / Math.sin(n));
  }
  return t.x = e, t.y = n, t;
}
var wR = ["Polyconic", "poly"];
const ER = {
  init: _R,
  forward: xR,
  inverse: bR,
  names: wR
};
function SR() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function TR(t) {
  var e, n = t.x, a = t.y, s = a - this.lat0, f = n - this.long0, o = s / yd * 1e-5, m = f, g = 1, b = 0;
  for (e = 1; e <= 10; e++)
    g = g * o, b = b + this.A[e] * g;
  var T = b, M = m, I = 1, A = 0, z, V, q = 0, re = 0;
  for (e = 1; e <= 6; e++)
    z = I * T - A * M, V = A * T + I * M, I = z, A = V, q = q + this.B_re[e] * I - this.B_im[e] * A, re = re + this.B_im[e] * I + this.B_re[e] * A;
  return t.x = re * this.a + this.x0, t.y = q * this.a + this.y0, t;
}
function MR(t) {
  var e, n = t.x, a = t.y, s = n - this.x0, f = a - this.y0, o = f / this.a, m = s / this.a, g = 1, b = 0, T, M, I = 0, A = 0;
  for (e = 1; e <= 6; e++)
    T = g * o - b * m, M = b * o + g * m, g = T, b = M, I = I + this.C_re[e] * g - this.C_im[e] * b, A = A + this.C_im[e] * g + this.C_re[e] * b;
  for (var z = 0; z < this.iterations; z++) {
    var V = I, q = A, re, X, ae = o, ce = m;
    for (e = 2; e <= 6; e++)
      re = V * I - q * A, X = q * I + V * A, V = re, q = X, ae = ae + (e - 1) * (this.B_re[e] * V - this.B_im[e] * q), ce = ce + (e - 1) * (this.B_im[e] * V + this.B_re[e] * q);
    V = 1, q = 0;
    var ve = this.B_re[1], Ne = this.B_im[1];
    for (e = 2; e <= 6; e++)
      re = V * I - q * A, X = q * I + V * A, V = re, q = X, ve = ve + e * (this.B_re[e] * V - this.B_im[e] * q), Ne = Ne + e * (this.B_im[e] * V + this.B_re[e] * q);
    var ze = ve * ve + Ne * Ne;
    I = (ae * ve + ce * Ne) / ze, A = (ce * ve - ae * Ne) / ze;
  }
  var Ae = I, Se = A, Ie = 1, Xe = 0;
  for (e = 1; e <= 9; e++)
    Ie = Ie * Ae, Xe = Xe + this.D[e] * Ie;
  var $e = this.lat0 + Xe * yd * 1e5, at = this.long0 + Se;
  return t.x = at, t.y = $e, t;
}
var IR = ["New_Zealand_Map_Grid", "nzmg"];
const OR = {
  init: SR,
  forward: TR,
  inverse: MR,
  names: IR
};
function CR() {
}
function PR(t) {
  var e = t.x, n = t.y, a = Vt(e - this.long0), s = this.x0 + this.a * a, f = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + n / 2.5)) * 1.25;
  return t.x = s, t.y = f, t;
}
function AR(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e = Vt(this.long0 + t.x / this.a), n = 2.5 * (Math.atan(Math.exp(0.8 * t.y / this.a)) - Math.PI / 4);
  return t.x = e, t.y = n, t;
}
var kR = ["Miller_Cylindrical", "mill"];
const LR = {
  init: CR,
  forward: PR,
  inverse: AR,
  names: kR
};
var DR = 20;
function NR() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = kT(this.es);
}
function RR(t) {
  var e, n, a = t.x, s = t.y;
  if (a = Vt(a - this.long0), this.sphere) {
    if (!this.m)
      s = this.n !== 1 ? Math.asin(this.n * Math.sin(s)) : s;
    else
      for (var f = this.n * Math.sin(s), o = DR; o; --o) {
        var m = (this.m * s + Math.sin(s) - f) / (this.m + Math.cos(s));
        if (s -= m, Math.abs(m) < Ct)
          break;
      }
    e = this.a * this.C_x * a * (this.m + Math.cos(s)), n = this.a * this.C_y * s;
  } else {
    var g = Math.sin(s), b = Math.cos(s);
    n = this.a * Ov(s, g, b, this.en), e = this.a * a * b / Math.sqrt(1 - this.es * g * g);
  }
  return t.x = e, t.y = n, t;
}
function zR(t) {
  var e, n, a, s;
  return t.x -= this.x0, a = t.x / this.a, t.y -= this.y0, e = t.y / this.a, this.sphere ? (e /= this.C_y, a = a / (this.C_x * (this.m + Math.cos(e))), this.m ? e = Bu((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = Bu(Math.sin(e) / this.n)), a = Vt(a + this.long0), e = Vf(e)) : (e = LT(t.y / this.a, this.es, this.en), s = Math.abs(e), s < ft ? (s = Math.sin(e), n = this.long0 + t.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(e)), a = Vt(n)) : s - Ct < ft && (a = this.long0)), t.x = a, t.y = e, t;
}
var FR = ["Sinusoidal", "sinu"];
const BR = {
  init: NR,
  forward: RR,
  inverse: zR,
  names: FR
};
function VR() {
}
function UR(t) {
  for (var e = t.x, n = t.y, a = Vt(e - this.long0), s = n, f = Math.PI * Math.sin(n); ; ) {
    var o = -(s + Math.sin(s) - f) / (1 + Math.cos(s));
    if (s += o, Math.abs(o) < Ct)
      break;
  }
  s /= 2, Math.PI / 2 - Math.abs(n) < Ct && (a = 0);
  var m = 0.900316316158 * this.a * a * Math.cos(s) + this.x0, g = 1.4142135623731 * this.a * Math.sin(s) + this.y0;
  return t.x = m, t.y = g, t;
}
function jR(t) {
  var e, n;
  t.x -= this.x0, t.y -= this.y0, n = t.y / (1.4142135623731 * this.a), Math.abs(n) > 0.999999999999 && (n = 0.999999999999), e = Math.asin(n);
  var a = Vt(this.long0 + t.x / (0.900316316158 * this.a * Math.cos(e)));
  a < -Math.PI && (a = -Math.PI), a > Math.PI && (a = Math.PI), n = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(n) > 1 && (n = 1);
  var s = Math.asin(n);
  return t.x = a, t.y = s, t;
}
var GR = ["Mollweide", "moll"];
const $R = {
  init: VR,
  forward: UR,
  inverse: jR,
  names: GR
};
function qR() {
  Math.abs(this.lat1 + this.lat2) < Ct || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Wd(this.es), this.e1 = Hd(this.es), this.e2 = Zd(this.es), this.e3 = Xd(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = el(this.e, this.sinphi, this.cosphi), this.ml1 = zo(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < Ct ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = el(this.e, this.sinphi, this.cosphi), this.ml2 = zo(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = zo(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function WR(t) {
  var e = t.x, n = t.y, a;
  if (this.sphere)
    a = this.a * (this.g - n);
  else {
    var s = zo(this.e0, this.e1, this.e2, this.e3, n);
    a = this.a * (this.g - s);
  }
  var f = this.ns * Vt(e - this.long0), o = this.x0 + a * Math.sin(f), m = this.y0 + this.rh - a * Math.cos(f);
  return t.x = o, t.y = m, t;
}
function HR(t) {
  t.x -= this.x0, t.y = this.rh - t.y + this.y0;
  var e, n, a, s;
  this.ns >= 0 ? (n = Math.sqrt(t.x * t.x + t.y * t.y), e = 1) : (n = -Math.sqrt(t.x * t.x + t.y * t.y), e = -1);
  var f = 0;
  if (n !== 0 && (f = Math.atan2(e * t.x, e * t.y)), this.sphere)
    return s = Vt(this.long0 + f / this.ns), a = Vf(this.g - n / this.a), t.x = s, t.y = a, t;
  var o = this.g - n / this.a;
  return a = zg(o, this.e0, this.e1, this.e2, this.e3), s = Vt(this.long0 + f / this.ns), t.x = s, t.y = a, t;
}
var ZR = ["Equidistant_Conic", "eqdc"];
const XR = {
  init: qR,
  forward: WR,
  inverse: HR,
  names: ZR
};
function KR() {
  this.R = this.a;
}
function YR(t) {
  var e = t.x, n = t.y, a = Vt(e - this.long0), s, f;
  Math.abs(n) <= Ct && (s = this.x0 + this.R * a, f = this.y0);
  var o = Bu(2 * Math.abs(n / Math.PI));
  (Math.abs(a) <= Ct || Math.abs(Math.abs(n) - ft) <= Ct) && (s = this.x0, n >= 0 ? f = this.y0 + Math.PI * this.R * Math.tan(0.5 * o) : f = this.y0 + Math.PI * this.R * -Math.tan(0.5 * o));
  var m = 0.5 * Math.abs(Math.PI / a - a / Math.PI), g = m * m, b = Math.sin(o), T = Math.cos(o), M = T / (b + T - 1), I = M * M, A = M * (2 / b - 1), z = A * A, V = Math.PI * this.R * (m * (M - z) + Math.sqrt(g * (M - z) * (M - z) - (z + g) * (I - z))) / (z + g);
  a < 0 && (V = -V), s = this.x0 + V;
  var q = g + M;
  return V = Math.PI * this.R * (A * q - m * Math.sqrt((z + g) * (g + 1) - q * q)) / (z + g), n >= 0 ? f = this.y0 + V : f = this.y0 - V, t.x = s, t.y = f, t;
}
function JR(t) {
  var e, n, a, s, f, o, m, g, b, T, M, I, A;
  return t.x -= this.x0, t.y -= this.y0, M = Math.PI * this.R, a = t.x / M, s = t.y / M, f = a * a + s * s, o = -Math.abs(s) * (1 + f), m = o - 2 * s * s + a * a, g = -2 * o + 1 + 2 * s * s + f * f, A = s * s / g + (2 * m * m * m / g / g / g - 9 * o * m / g / g) / 27, b = (o - m * m / 3 / g) / g, T = 2 * Math.sqrt(-b / 3), M = 3 * A / b / T, Math.abs(M) > 1 && (M >= 0 ? M = 1 : M = -1), I = Math.acos(M) / 3, t.y >= 0 ? n = (-T * Math.cos(I + Math.PI / 3) - m / 3 / g) * Math.PI : n = -(-T * Math.cos(I + Math.PI / 3) - m / 3 / g) * Math.PI, Math.abs(a) < Ct ? e = this.long0 : e = Vt(this.long0 + Math.PI * (f - 1 + Math.sqrt(1 + 2 * (a * a - s * s) + f * f)) / 2 / a), t.x = e, t.y = n, t;
}
var QR = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const e4 = {
  init: KR,
  forward: YR,
  inverse: JR,
  names: QR
};
function t4() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}
function r4(t) {
  var e = t.x, n = t.y, a = Math.sin(t.y), s = Math.cos(t.y), f = Vt(e - this.long0), o, m, g, b, T, M, I, A, z, V, q, re, X, ae, ce, ve, Ne, ze, Ae, Se, Ie, Xe, $e;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= Ct ? (t.x = this.x0 + this.a * (ft - n) * Math.sin(f), t.y = this.y0 - this.a * (ft - n) * Math.cos(f), t) : Math.abs(this.sin_p12 + 1) <= Ct ? (t.x = this.x0 + this.a * (ft + n) * Math.sin(f), t.y = this.y0 + this.a * (ft + n) * Math.cos(f), t) : (ze = this.sin_p12 * a + this.cos_p12 * s * Math.cos(f), ve = Math.acos(ze), Ne = ve ? ve / Math.sin(ve) : 1, t.x = this.x0 + this.a * Ne * s * Math.sin(f), t.y = this.y0 + this.a * Ne * (this.cos_p12 * a - this.sin_p12 * s * Math.cos(f)), t) : (o = Wd(this.es), m = Hd(this.es), g = Zd(this.es), b = Xd(this.es), Math.abs(this.sin_p12 - 1) <= Ct ? (T = this.a * zo(o, m, g, b, ft), M = this.a * zo(o, m, g, b, n), t.x = this.x0 + (T - M) * Math.sin(f), t.y = this.y0 - (T - M) * Math.cos(f), t) : Math.abs(this.sin_p12 + 1) <= Ct ? (T = this.a * zo(o, m, g, b, ft), M = this.a * zo(o, m, g, b, n), t.x = this.x0 + (T + M) * Math.sin(f), t.y = this.y0 + (T + M) * Math.cos(f), t) : (I = a / s, A = Rf(this.a, this.e, this.sin_p12), z = Rf(this.a, this.e, a), V = Math.atan((1 - this.es) * I + this.es * A * this.sin_p12 / (z * s)), q = Math.atan2(Math.sin(f), this.cos_p12 * Math.tan(V) - this.sin_p12 * Math.cos(f)), q === 0 ? Ae = Math.asin(this.cos_p12 * Math.sin(V) - this.sin_p12 * Math.cos(V)) : Math.abs(Math.abs(q) - Math.PI) <= Ct ? Ae = -Math.asin(this.cos_p12 * Math.sin(V) - this.sin_p12 * Math.cos(V)) : Ae = Math.asin(Math.sin(f) * Math.cos(V) / Math.sin(q)), re = this.e * this.sin_p12 / Math.sqrt(1 - this.es), X = this.e * this.cos_p12 * Math.cos(q) / Math.sqrt(1 - this.es), ae = re * X, ce = X * X, Se = Ae * Ae, Ie = Se * Ae, Xe = Ie * Ae, $e = Xe * Ae, ve = A * Ae * (1 - Se * ce * (1 - ce) / 6 + Ie / 8 * ae * (1 - 2 * ce) + Xe / 120 * (ce * (4 - 7 * ce) - 3 * re * re * (1 - 7 * ce)) - $e / 48 * ae), t.x = this.x0 + ve * Math.sin(q), t.y = this.y0 + ve * Math.cos(q), t));
}
function n4(t) {
  t.x -= this.x0, t.y -= this.y0;
  var e, n, a, s, f, o, m, g, b, T, M, I, A, z, V, q, re, X, ae, ce, ve, Ne, ze, Ae;
  return this.sphere ? (e = Math.sqrt(t.x * t.x + t.y * t.y), e > 2 * ft * this.a ? void 0 : (n = e / this.a, a = Math.sin(n), s = Math.cos(n), f = this.long0, Math.abs(e) <= Ct ? o = this.lat0 : (o = Bu(s * this.sin_p12 + t.y * a * this.cos_p12 / e), m = Math.abs(this.lat0) - ft, Math.abs(m) <= Ct ? this.lat0 >= 0 ? f = Vt(this.long0 + Math.atan2(t.x, -t.y)) : f = Vt(this.long0 - Math.atan2(-t.x, t.y)) : f = Vt(this.long0 + Math.atan2(t.x * a, e * this.cos_p12 * s - t.y * this.sin_p12 * a))), t.x = f, t.y = o, t)) : (g = Wd(this.es), b = Hd(this.es), T = Zd(this.es), M = Xd(this.es), Math.abs(this.sin_p12 - 1) <= Ct ? (I = this.a * zo(g, b, T, M, ft), e = Math.sqrt(t.x * t.x + t.y * t.y), A = I - e, o = zg(A / this.a, g, b, T, M), f = Vt(this.long0 + Math.atan2(t.x, -1 * t.y)), t.x = f, t.y = o, t) : Math.abs(this.sin_p12 + 1) <= Ct ? (I = this.a * zo(g, b, T, M, ft), e = Math.sqrt(t.x * t.x + t.y * t.y), A = e - I, o = zg(A / this.a, g, b, T, M), f = Vt(this.long0 + Math.atan2(t.x, t.y)), t.x = f, t.y = o, t) : (e = Math.sqrt(t.x * t.x + t.y * t.y), q = Math.atan2(t.x, t.y), z = Rf(this.a, this.e, this.sin_p12), re = Math.cos(q), X = this.e * this.cos_p12 * re, ae = -X * X / (1 - this.es), ce = 3 * this.es * (1 - ae) * this.sin_p12 * this.cos_p12 * re / (1 - this.es), ve = e / z, Ne = ve - ae * (1 + ae) * Math.pow(ve, 3) / 6 - ce * (1 + 3 * ae) * Math.pow(ve, 4) / 24, ze = 1 - ae * Ne * Ne / 2 - ve * Ne * Ne * Ne / 6, V = Math.asin(this.sin_p12 * Math.cos(Ne) + this.cos_p12 * Math.sin(Ne) * re), f = Vt(this.long0 + Math.asin(Math.sin(q) * Math.sin(Ne) / Math.cos(V))), Ae = Math.sin(V), o = Math.atan2((Ae - this.es * ze * this.sin_p12) * Math.tan(V), Ae * (1 - this.es)), t.x = f, t.y = o, t));
}
var i4 = ["Azimuthal_Equidistant", "aeqd"];
const o4 = {
  init: t4,
  forward: r4,
  inverse: n4,
  names: i4
};
function a4() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function s4(t) {
  var e, n, a, s, f, o, m, g, b = t.x, T = t.y;
  return a = Vt(b - this.long0), e = Math.sin(T), n = Math.cos(T), s = Math.cos(a), o = this.sin_p14 * e + this.cos_p14 * n * s, f = 1, (o > 0 || Math.abs(o) <= Ct) && (m = this.a * f * n * Math.sin(a), g = this.y0 + this.a * f * (this.cos_p14 * e - this.sin_p14 * n * s)), t.x = m, t.y = g, t;
}
function l4(t) {
  var e, n, a, s, f, o, m;
  return t.x -= this.x0, t.y -= this.y0, e = Math.sqrt(t.x * t.x + t.y * t.y), n = Bu(e / this.a), a = Math.sin(n), s = Math.cos(n), o = this.long0, Math.abs(e) <= Ct ? (m = this.lat0, t.x = o, t.y = m, t) : (m = Bu(s * this.sin_p14 + t.y * a * this.cos_p14 / e), f = Math.abs(this.lat0) - ft, Math.abs(f) <= Ct ? (this.lat0 >= 0 ? o = Vt(this.long0 + Math.atan2(t.x, -t.y)) : o = Vt(this.long0 - Math.atan2(-t.x, t.y)), t.x = o, t.y = m, t) : (o = Vt(this.long0 + Math.atan2(t.x * a, e * this.cos_p14 * s - t.y * this.sin_p14 * a)), t.x = o, t.y = m, t));
}
var u4 = ["ortho"];
const c4 = {
  init: a4,
  forward: s4,
  inverse: l4,
  names: u4
};
var ii = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, cn = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function h4() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= ft - un / 2 ? this.face = ii.TOP : this.lat0 <= -(ft - un / 2) ? this.face = ii.BOTTOM : Math.abs(this.long0) <= un ? this.face = ii.FRONT : Math.abs(this.long0) <= ft + un ? this.face = this.long0 > 0 ? ii.RIGHT : ii.LEFT : this.face = ii.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function f4(t) {
  var e = { x: 0, y: 0 }, n, a, s, f, o, m, g = { value: 0 };
  if (t.x -= this.long0, this.es !== 0 ? n = Math.atan(this.one_minus_f_squared * Math.tan(t.y)) : n = t.y, a = t.x, this.face === ii.TOP)
    f = ft - n, a >= un && a <= ft + un ? (g.value = cn.AREA_0, s = a - ft) : a > ft + un || a <= -(ft + un) ? (g.value = cn.AREA_1, s = a > 0 ? a - wi : a + wi) : a > -(ft + un) && a <= -un ? (g.value = cn.AREA_2, s = a + ft) : (g.value = cn.AREA_3, s = a);
  else if (this.face === ii.BOTTOM)
    f = ft + n, a >= un && a <= ft + un ? (g.value = cn.AREA_0, s = -a + ft) : a < un && a >= -un ? (g.value = cn.AREA_1, s = -a) : a < -un && a >= -(ft + un) ? (g.value = cn.AREA_2, s = -a - ft) : (g.value = cn.AREA_3, s = a > 0 ? -a + wi : -a - wi);
  else {
    var b, T, M, I, A, z, V;
    this.face === ii.RIGHT ? a = If(a, +ft) : this.face === ii.BACK ? a = If(a, +wi) : this.face === ii.LEFT && (a = If(a, -ft)), I = Math.sin(n), A = Math.cos(n), z = Math.sin(a), V = Math.cos(a), b = A * V, T = A * z, M = I, this.face === ii.FRONT ? (f = Math.acos(b), s = Cy(f, M, T, g)) : this.face === ii.RIGHT ? (f = Math.acos(T), s = Cy(f, M, -b, g)) : this.face === ii.BACK ? (f = Math.acos(-b), s = Cy(f, M, -T, g)) : this.face === ii.LEFT ? (f = Math.acos(-T), s = Cy(f, M, b, g)) : (f = s = 0, g.value = cn.AREA_0);
  }
  return m = Math.atan(12 / wi * (s + Math.acos(Math.sin(s) * Math.cos(un)) - ft)), o = Math.sqrt((1 - Math.cos(f)) / (Math.cos(m) * Math.cos(m)) / (1 - Math.cos(Math.atan(1 / Math.cos(s))))), g.value === cn.AREA_1 ? m += ft : g.value === cn.AREA_2 ? m += wi : g.value === cn.AREA_3 && (m += 1.5 * wi), e.x = o * Math.cos(m), e.y = o * Math.sin(m), e.x = e.x * this.a + this.x0, e.y = e.y * this.a + this.y0, t.x = e.x, t.y = e.y, t;
}
function p4(t) {
  var e = { lam: 0, phi: 0 }, n, a, s, f, o, m, g, b, T, M = { value: 0 };
  if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, a = Math.atan(Math.sqrt(t.x * t.x + t.y * t.y)), n = Math.atan2(t.y, t.x), t.x >= 0 && t.x >= Math.abs(t.y) ? M.value = cn.AREA_0 : t.y >= 0 && t.y >= Math.abs(t.x) ? (M.value = cn.AREA_1, n -= ft) : t.x < 0 && -t.x >= Math.abs(t.y) ? (M.value = cn.AREA_2, n = n < 0 ? n + wi : n - wi) : (M.value = cn.AREA_3, n += ft), T = wi / 12 * Math.tan(n), o = Math.sin(T) / (Math.cos(T) - 1 / Math.sqrt(2)), m = Math.atan(o), s = Math.cos(n), f = Math.tan(a), g = 1 - s * s * f * f * (1 - Math.cos(Math.atan(1 / Math.cos(m)))), g < -1 ? g = -1 : g > 1 && (g = 1), this.face === ii.TOP)
    b = Math.acos(g), e.phi = ft - b, M.value === cn.AREA_0 ? e.lam = m + ft : M.value === cn.AREA_1 ? e.lam = m < 0 ? m + wi : m - wi : M.value === cn.AREA_2 ? e.lam = m - ft : e.lam = m;
  else if (this.face === ii.BOTTOM)
    b = Math.acos(g), e.phi = b - ft, M.value === cn.AREA_0 ? e.lam = -m + ft : M.value === cn.AREA_1 ? e.lam = -m : M.value === cn.AREA_2 ? e.lam = -m - ft : e.lam = m < 0 ? -m - wi : -m + wi;
  else {
    var I, A, z;
    I = g, T = I * I, T >= 1 ? z = 0 : z = Math.sqrt(1 - T) * Math.sin(m), T += z * z, T >= 1 ? A = 0 : A = Math.sqrt(1 - T), M.value === cn.AREA_1 ? (T = A, A = -z, z = T) : M.value === cn.AREA_2 ? (A = -A, z = -z) : M.value === cn.AREA_3 && (T = A, A = z, z = -T), this.face === ii.RIGHT ? (T = I, I = -A, A = T) : this.face === ii.BACK ? (I = -I, A = -A) : this.face === ii.LEFT && (T = I, I = A, A = -T), e.phi = Math.acos(-z) - ft, e.lam = Math.atan2(A, I), this.face === ii.RIGHT ? e.lam = If(e.lam, -ft) : this.face === ii.BACK ? e.lam = If(e.lam, -wi) : this.face === ii.LEFT && (e.lam = If(e.lam, +ft));
  }
  if (this.es !== 0) {
    var V, q, re;
    V = e.phi < 0 ? 1 : 0, q = Math.tan(e.phi), re = this.b / Math.sqrt(q * q + this.one_minus_f_squared), e.phi = Math.atan(Math.sqrt(this.a * this.a - re * re) / (this.one_minus_f * re)), V && (e.phi = -e.phi);
  }
  return e.lam += this.long0, t.x = e.lam, t.y = e.phi, t;
}
function Cy(t, e, n, a) {
  var s;
  return t < Ct ? (a.value = cn.AREA_0, s = 0) : (s = Math.atan2(e, n), Math.abs(s) <= un ? a.value = cn.AREA_0 : s > un && s <= ft + un ? (a.value = cn.AREA_1, s -= ft) : s > ft + un || s <= -(ft + un) ? (a.value = cn.AREA_2, s = s >= 0 ? s - wi : s + wi) : (a.value = cn.AREA_3, s += ft)), s;
}
function If(t, e) {
  var n = t + e;
  return n < -wi ? n += Ld : n > +wi && (n -= Ld), n;
}
var d4 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const m4 = {
  init: h4,
  forward: f4,
  inverse: p4,
  names: d4
};
var Q0 = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], nd = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], RT = 0.8487, zT = 1.3523, FT = qs / 5, y4 = 1 / FT, xf = 18, Fg = function(t, e) {
  return t[0] + e * (t[1] + e * (t[2] + e * t[3]));
}, g4 = function(t, e) {
  return t[1] + e * (2 * t[2] + e * 3 * t[3]);
};
function v4(t, e, n, a) {
  for (var s = e; a; --a) {
    var f = t(s);
    if (s -= f, Math.abs(f) < n)
      break;
  }
  return s;
}
function _4() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function x4(t) {
  var e = Vt(t.x - this.long0), n = Math.abs(t.y), a = Math.floor(n * FT);
  a < 0 ? a = 0 : a >= xf && (a = xf - 1), n = qs * (n - y4 * a);
  var s = {
    x: Fg(Q0[a], n) * e,
    y: Fg(nd[a], n)
  };
  return t.y < 0 && (s.y = -s.y), s.x = s.x * this.a * RT + this.x0, s.y = s.y * this.a * zT + this.y0, s;
}
function b4(t) {
  var e = {
    x: (t.x - this.x0) / (this.a * RT),
    y: Math.abs(t.y - this.y0) / (this.a * zT)
  };
  if (e.y >= 1)
    e.x /= Q0[xf][0], e.y = t.y < 0 ? -ft : ft;
  else {
    var n = Math.floor(e.y * xf);
    for (n < 0 ? n = 0 : n >= xf && (n = xf - 1); ; )
      if (nd[n][0] > e.y)
        --n;
      else if (nd[n + 1][0] <= e.y)
        ++n;
      else
        break;
    var a = nd[n], s = 5 * (e.y - a[0]) / (nd[n + 1][0] - a[0]);
    s = v4(function(f) {
      return (Fg(a, f) - e.y) / g4(a, f);
    }, s, Ct, 100), e.x /= Fg(Q0[n], s), e.y = (5 * n + s) * io, t.y < 0 && (e.y = -e.y);
  }
  return e.x = Vt(e.x + this.long0), e;
}
var w4 = ["Robinson", "robin"];
const E4 = {
  init: _4,
  forward: x4,
  inverse: b4,
  names: w4
};
function S4() {
  this.name = "geocent";
}
function T4(t) {
  var e = ET(t, this.es, this.a);
  return e;
}
function M4(t) {
  var e = ST(t, this.es, this.a, this.b);
  return e;
}
var I4 = ["Geocentric", "geocentric", "geocent", "Geocent"];
const O4 = {
  init: S4,
  forward: T4,
  inverse: M4,
  names: I4
};
var _o = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, Wp = {
  h: { def: 1e5, num: !0 },
  azi: { def: 0, num: !0, degrees: !0 },
  tilt: { def: 0, num: !0, degrees: !0 },
  long0: { def: 0, num: !0 },
  lat0: { def: 0, num: !0 }
};
function C4() {
  if (Object.keys(Wp).forEach(function(n) {
    if (typeof this[n] > "u")
      this[n] = Wp[n].def;
    else {
      if (Wp[n].num && isNaN(this[n]))
        throw new Error("Invalid parameter value, must be numeric " + n + " = " + this[n]);
      Wp[n].num && (this[n] = parseFloat(this[n]));
    }
    Wp[n].degrees && (this[n] = this[n] * io);
  }.bind(this)), Math.abs(Math.abs(this.lat0) - ft) < Ct ? this.mode = this.lat0 < 0 ? _o.S_POLE : _o.N_POLE : Math.abs(this.lat0) < Ct ? this.mode = _o.EQUIT : (this.mode = _o.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var t = this.tilt, e = this.azi;
  this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(t), this.sw = Math.sin(t);
}
function P4(t) {
  t.x -= this.long0;
  var e = Math.sin(t.y), n = Math.cos(t.y), a = Math.cos(t.x), s, f;
  switch (this.mode) {
    case _o.OBLIQ:
      f = this.sinph0 * e + this.cosph0 * n * a;
      break;
    case _o.EQUIT:
      f = n * a;
      break;
    case _o.S_POLE:
      f = -e;
      break;
    case _o.N_POLE:
      f = e;
      break;
  }
  switch (f = this.pn1 / (this.p - f), s = f * n * Math.sin(t.x), this.mode) {
    case _o.OBLIQ:
      f *= this.cosph0 * e - this.sinph0 * n * a;
      break;
    case _o.EQUIT:
      f *= e;
      break;
    case _o.N_POLE:
      f *= -(n * a);
      break;
    case _o.S_POLE:
      f *= n * a;
      break;
  }
  var o, m;
  return o = f * this.cg + s * this.sg, m = 1 / (o * this.sw * this.h1 + this.cw), s = (s * this.cg - f * this.sg) * this.cw * m, f = o * m, t.x = s * this.a, t.y = f * this.a, t;
}
function A4(t) {
  t.x /= this.a, t.y /= this.a;
  var e = { x: t.x, y: t.y }, n, a, s;
  s = 1 / (this.pn1 - t.y * this.sw), n = this.pn1 * t.x * s, a = this.pn1 * t.y * this.cw * s, t.x = n * this.cg + a * this.sg, t.y = a * this.cg - n * this.sg;
  var f = ns(t.x, t.y);
  if (Math.abs(f) < Ct)
    e.x = 0, e.y = t.y;
  else {
    var o, m;
    switch (m = 1 - f * f * this.pfact, m = (this.p - Math.sqrt(m)) / (this.pn1 / f + f / this.pn1), o = Math.sqrt(1 - m * m), this.mode) {
      case _o.OBLIQ:
        e.y = Math.asin(o * this.sinph0 + t.y * m * this.cosph0 / f), t.y = (o - this.sinph0 * Math.sin(e.y)) * f, t.x *= m * this.cosph0;
        break;
      case _o.EQUIT:
        e.y = Math.asin(t.y * m / f), t.y = o * f, t.x *= m;
        break;
      case _o.N_POLE:
        e.y = Math.asin(o), t.y = -t.y;
        break;
      case _o.S_POLE:
        e.y = -Math.asin(o);
        break;
    }
    e.x = Math.atan2(t.x, t.y);
  }
  return t.x = e.x + this.long0, t.y = e.y, t;
}
var k4 = ["Tilted_Perspective", "tpers"];
const L4 = {
  init: C4,
  forward: P4,
  inverse: A4,
  names: k4
};
function D4() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var t = 1 - this.es, e = 1 / t;
    this.radius_p = Math.sqrt(t), this.radius_p2 = t, this.radius_p_inv2 = e, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function N4(t) {
  var e = t.x, n = t.y, a, s, f, o;
  if (e = e - this.long0, this.shape === "ellipse") {
    n = Math.atan(this.radius_p2 * Math.tan(n));
    var m = this.radius_p / ns(this.radius_p * Math.cos(n), Math.sin(n));
    if (s = m * Math.cos(e) * Math.cos(n), f = m * Math.sin(e) * Math.cos(n), o = m * Math.sin(n), (this.radius_g - s) * s - f * f - o * o * this.radius_p_inv2 < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    a = this.radius_g - s, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(f / ns(o, a)), t.y = this.radius_g_1 * Math.atan(o / a)) : (t.x = this.radius_g_1 * Math.atan(f / a), t.y = this.radius_g_1 * Math.atan(o / ns(f, a)));
  } else
    this.shape === "sphere" && (a = Math.cos(n), s = Math.cos(e) * a, f = Math.sin(e) * a, o = Math.sin(n), a = this.radius_g - s, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(f / ns(o, a)), t.y = this.radius_g_1 * Math.atan(o / a)) : (t.x = this.radius_g_1 * Math.atan(f / a), t.y = this.radius_g_1 * Math.atan(o / ns(f, a))));
  return t.x = t.x * this.a, t.y = t.y * this.a, t;
}
function R4(t) {
  var e = -1, n = 0, a = 0, s, f, o, m;
  if (t.x = t.x / this.a, t.y = t.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (a = Math.tan(t.y / this.radius_g_1), n = Math.tan(t.x / this.radius_g_1) * ns(1, a)) : (n = Math.tan(t.x / this.radius_g_1), a = Math.tan(t.y / this.radius_g_1) * ns(1, n));
    var g = a / this.radius_p;
    if (s = n * n + g * g + e * e, f = 2 * this.radius_g * e, o = f * f - 4 * s * this.C, o < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    m = (-f - Math.sqrt(o)) / (2 * s), e = this.radius_g + m * e, n *= m, a *= m, t.x = Math.atan2(n, e), t.y = Math.atan(a * Math.cos(t.x) / e), t.y = Math.atan(this.radius_p_inv2 * Math.tan(t.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (a = Math.tan(t.y / this.radius_g_1), n = Math.tan(t.x / this.radius_g_1) * Math.sqrt(1 + a * a)) : (n = Math.tan(t.x / this.radius_g_1), a = Math.tan(t.y / this.radius_g_1) * Math.sqrt(1 + n * n)), s = n * n + a * a + e * e, f = 2 * this.radius_g * e, o = f * f - 4 * s * this.C, o < 0)
      return t.x = Number.NaN, t.y = Number.NaN, t;
    m = (-f - Math.sqrt(o)) / (2 * s), e = this.radius_g + m * e, n *= m, a *= m, t.x = Math.atan2(n, e), t.y = Math.atan(a * Math.cos(t.x) / e);
  }
  return t.x = t.x + this.long0, t;
}
var z4 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const F4 = {
  init: D4,
  forward: N4,
  inverse: R4,
  names: z4
};
function B4(t) {
  t.Proj.projections.add(lg), t.Proj.projections.add(ug), t.Proj.projections.add(qN), t.Proj.projections.add(t3), t.Proj.projections.add(s3), t.Proj.projections.add(f3), t.Proj.projections.add(v3), t.Proj.projections.add(E3), t.Proj.projections.add(O3), t.Proj.projections.add(L3), t.Proj.projections.add(K3), t.Proj.projections.add(rR), t.Proj.projections.add(sR), t.Proj.projections.add(pR), t.Proj.projections.add(vR), t.Proj.projections.add(ER), t.Proj.projections.add(OR), t.Proj.projections.add(LR), t.Proj.projections.add(BR), t.Proj.projections.add($R), t.Proj.projections.add(XR), t.Proj.projections.add(e4), t.Proj.projections.add(o4), t.Proj.projections.add(c4), t.Proj.projections.add(m4), t.Proj.projections.add(E4), t.Proj.projections.add(O4), t.Proj.projections.add(L4), t.Proj.projections.add(F4);
}
wo.defaultDatum = "WGS84";
wo.Proj = Zs;
wo.WGS84 = new wo.Proj("WGS84");
wo.Point = Nf;
wo.toPoint = TT;
wo.defs = Do;
wo.nadgrid = HD;
wo.transform = Rg;
wo.mgrs = uN;
wo.version = "__VERSION__";
B4(wo);
function V4() {
  var t, e, n;
  wo.defs("EPSG:32632", "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs"), wo.defs("EPSG:32631", "+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs"), wo.defs(
    "EPSG:2169",
    "+proj=tmerc +lat_0=49.83333333333334 +lon_0=6.166666666666667 +k=1 +x_0=80000 +y_0=100000 +ellps=intl +towgs84=-189.681,18.3463,-42.7695,-0.33746,-3.09264,2.53861,0.4598 +units=m +no_defs"
  ), TC(wo), (t = Ky("EPSG:32632")) == null || t.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]), (e = Ky("EPSG:32631")) == null || e.setExtent([
    166021.44,
    0,
    833978.55,
    932900518e-2
  ]), (n = Ky("EPSG:2169")) == null || n.setExtent([
    48225.17,
    56225.6,
    105842.04,
    139616.4
  ]);
}
function U4(t, e, n) {
  const a = ir(t);
  class s extends Zx {
    constructor(o) {
      super(a, o, e, n);
    }
  }
  return ri(s, "def", a), s;
}
const j4 = typeof HTMLElement < "u" ? HTMLElement : class {
};
class Zx extends j4 {
  constructor(n, a = {}, s = {}, f) {
    super();
    ri(this, "_instance", null);
    ri(this, "_connected", !1);
    ri(this, "_resolved", !1);
    ri(this, "_numberProps", null);
    ri(this, "_styles");
    ri(this, "_slots");
    this._def = n, this._props = a, this._config = s, this._config = Wn(
      {
        shadowRoot: !0
      },
      this._config
    ), this._config.shadowRoot ? this.shadowRoot && f ? f(this._createVNode(), this.shadowRoot) : (this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def)) : f && f(this._createVNode(), this._root);
  }
  get _root() {
    return this._config.shadowRoot ? this.shadowRoot : this;
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, Tg(() => {
      this._connected || (ww(null, this._root), this._instance = null);
    });
  }
  _resolveDef() {
    this._resolved = !0;
    for (let s = 0; s < this.attributes.length; s++)
      this._setAttr(this.attributes[s].name);
    new MutationObserver((s) => {
      for (const f of s)
        this._setAttr(f.attributeName);
    }).observe(this, { attributes: !0 });
    const n = (s, f = !1) => {
      const { props: o, styles: m } = s;
      let g;
      if (o && !er(o))
        for (const b in o) {
          const T = o[b];
          (T === Number || T && T.type === Number) && (b in this._props && (this._props[b] = E0(this._props[b])), (g || (g = /* @__PURE__ */ Object.create(null)))[ya(b)] = !0);
        }
      this._numberProps = g, f && this._resolveProps(s), this._applyStyles(m), this._update();
    }, a = this._def.__asyncLoader;
    a ? a().then((s) => n(s, !0)) : n(this._def);
  }
  _resolveProps(n) {
    const { props: a } = n, s = er(a) ? a : Object.keys(a || {});
    for (const f of Object.keys(this))
      f[0] !== "_" && s.includes(f) && this._setProp(f, this[f], !0, !1);
    for (const f of s.map(ya))
      Object.defineProperty(this, f, {
        get() {
          return this._getProp(f);
        },
        set(o) {
          this._setProp(f, o);
        }
      });
  }
  _setAttr(n) {
    let a = this.getAttribute(n);
    const s = ya(n);
    this._numberProps && this._numberProps[s] && (a = E0(a)), this._setProp(s, a, !1);
  }
  _getProp(n) {
    return this._props[n];
  }
  _setProp(n, a, s = !0, f = !0) {
    a !== this._props[n] && (this._props[n] = a, f && this._instance && this._update(), s && (a === !0 ? this.setAttribute(ta(n), "") : typeof a == "string" || typeof a == "number" ? this.setAttribute(ta(n), a + "") : a || this.removeAttribute(ta(n))));
  }
  _update() {
    ww(this._createVNode(), this._root);
  }
  _createVNode() {
    const n = kt(this._def, Wn({}, this._props));
    return this._instance || (n.ce = (a) => {
      this._instance = a, a.isCE = !0;
      const s = (o, m) => {
        this.dispatchEvent(
          new CustomEvent(o, {
            detail: m
          })
        );
      };
      a.emit = (o, ...m) => {
        s(o, m), ta(o) !== o && s(ta(o), m);
      };
      let f = this;
      for (; f = f && (f.parentNode || f.host); )
        if (f instanceof Zx) {
          a.parent = f._instance, a.provides = f._instance.provides;
          break;
        }
    }), n;
  }
  _applyStyles(n) {
    n && n.forEach((a) => {
      const s = document.createElement("style");
      s.textContent = a, this._root.appendChild(s);
    });
  }
}
var Rd = /* @__PURE__ */ ((t) => (t.INFO = "alert-info", t.WARNING = "alert-warning", t.ERROR = "alert-danger", t))(Rd || {});
const G4 = Rd.INFO, $4 = 7e3, q4 = 4e3, Bg = ih(
  "alert-notifications",
  () => {
    const t = Er([]);
    function e(a, s = G4, f) {
      const o = {
        message: a,
        type: s,
        duration: f != null ? f : s === Rd.WARNING ? q4 : $4
      };
      t.value.push(o);
    }
    function n(a) {
      t.value.splice(a, 1);
    }
    return {
      notifications: t,
      addNotification: e,
      removeNotification: n
    };
  },
  {}
), W4 = /* @__PURE__ */ ir({
  __name: "notification-item",
  props: {
    notification: { type: null, required: !0 }
  },
  emits: ["close"],
  setup(t) {
    const e = t, n = Bn(!0);
    function a(s, f) {
      setTimeout(() => {
        n.value = !1;
      }, e.notification.duration), f();
    }
    return (s, f) => {
      const o = Nx("dompurify-html");
      return Be(), an(Tv, {
        name: "fade-out",
        appear: "",
        "leave-active-class": "duration-200 ease-in",
        "leave-from-class": "opacity-100",
        "leave-to-class": "transform opacity-0",
        onEnter: a,
        onAfterLeave: f[0] || (f[0] = (m) => s.$emit("close"))
      }, {
        default: ku(() => [
          se(n) ? Og((Be(), rt("div", {
            key: 0,
            class: Br(["lux-alert", `lux-${e.notification.type}`]),
            role: "alert"
          }, null, 2)), [
            [o, e.notification.message]
          ]) : Ye("v-if", !0)
        ]),
        _: 1
      });
    };
  }
}), lr = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [a, s] of e)
    n[a] = s;
  return n;
}, H4 = /* @__PURE__ */ lr(W4, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/alert-notifications/notification-item.vue"]]), Z4 = {
  key: 0,
  class: "lux-notifications fixed w-[500px] top-10 left-1/2 ml-[-250px] z-50"
}, X4 = /* @__PURE__ */ ir({
  __name: "alert-notifications",
  setup(t) {
    const e = Bg(), { notifications: n } = pn(e);
    function a(s) {
      e.removeNotification(s);
    }
    return (s, f) => (Be(), an(jS, { to: "body" }, [
      se(n).length ? (Be(), rt("div", Z4, [
        (Be(!0), rt(on, null, Ra(se(n), (o, m) => (Be(), an(H4, {
          key: m,
          notification: o,
          onClose: () => a(m)
        }, null, 8, ["notification", "onClose"]))), 128))
      ])) : Ye("v-if", !0)
    ]));
  }
}), K4 = /* @__PURE__ */ lr(X4, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/alert-notifications/alert-notifications.vue"]]), Y4 = { class: "lux-dropdown" }, J4 = { class: "h-full" }, Q4 = ["aria-expanded"], e5 = /* @__PURE__ */ Fe("span", { class: "lux-caret" }, null, -1), t5 = { class: "lux-dropdown-wrapper" }, r5 = ["aria-label", "data-value"], n5 = /* @__PURE__ */ ir({
  __name: "dropdown-list",
  props: {
    placeholder: { type: String, required: !0 },
    options: { type: Array, required: !0, default: () => [{ label: "Default label", value: "Default value" }] },
    modelValue: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, a = Bn(!1), s = Bn();
    function f(b) {
      a.value = b === void 0 ? !a.value : b;
    }
    function o(b) {
      b.stopImmediatePropagation(), f();
    }
    function m(b) {
      s.value = b.target.dataset.value, e("change", s.value);
    }
    function g() {
      f(!1);
    }
    return _a(() => document.addEventListener("click", g)), $u(() => document.removeEventListener("click", g)), (b, T) => {
      var M, I;
      return Be(), rt("div", Y4, [
        Fe("div", J4, [
          Fe("button", {
            type: "button",
            class: Br(["lux-btn lux-dropdown-btn", se(a) ? "expanded" : ""]),
            "aria-expanded": se(a),
            "aria-haspopup": "true",
            onClick: o
          }, [
            Fe("span", null, Ht((I = n.placeholder) != null ? I : (M = n.options[0]) == null ? void 0 : M.label), 1),
            e5
          ], 10, Q4)
        ]),
        Fe("div", t5, [
          Fe("ul", {
            class: Br(["lux-dropdown-list", se(a) ? "" : "hidden"]),
            tabindex: "-1"
          }, [
            (Be(!0), rt(on, null, Ra(n.options, (A) => (Be(), rt("li", {
              key: A.value,
              class: Br(t.modelValue === A.value ? "selected" : "")
            }, [
              Fe("button", {
                class: "lux-dropdown-list-item",
                "aria-label": A.ariaLabel,
                "data-value": A.value,
                onClick: m
              }, Ht(A.label), 9, r5)
            ], 2))), 128))
          ], 2)
        ])
      ]);
    };
  }
}), BT = /* @__PURE__ */ lr(n5, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/common/dropdown-list.vue"]]), gd = "EPSG:3857", VT = "EPSG:4326", i5 = "EPSG:2169";
let Z_;
const Jw = Bn();
function Vl() {
  function t() {
    return Z_;
  }
  function e() {
    return Jw.value = Z_ = new MC({
      view: new IC({
        zoom: 10,
        center: [682439, 6379152],
        multiWorld: !0
      }),
      controls: [],
      keyboardEventTarget: document
    }), Z_;
  }
  function n(T, M) {
    return T.id === M.id;
  }
  function a(T, M) {
    return T === M;
  }
  function s(T, M) {
    var I;
    return (I = T.layers) == null ? void 0 : I.some((A) => n(A, M));
  }
  function f(T, M) {
    var A;
    const I = (A = T == null ? void 0 : T.layers) == null ? void 0 : A.find((z) => n(z, M));
    return !a(I, M);
  }
  function o(T, M) {
    return !(M === null || !("layers" in T) || !("layers" in M) || typeof M.layers > "u" || typeof T.layers > "u" || T.layers === M.layers);
  }
  function m(T, M) {
    return !("layers" in T) || typeof T.layers > "u" ? [] : M === null || !("layers" in M) ? T.layers.map((I, A) => ({ layer: I, position: A })) : T.layers === M.layers ? [] : T.layers.reduce(
      (I, A, z) => s(M, A) ? I : [
        ...I,
        {
          layer: A,
          position: z
        }
      ],
      []
    );
  }
  function g(T, M) {
    return o(T, M) ? M.layers.reduce(
      (I, A) => s(T, A) ? I : [...I, A],
      []
    ) : [];
  }
  function b(T, M) {
    return o(T, M) ? T.layers.reduce(
      (I, A) => f(M, A) ? [...I, A] : I,
      []
    ) : [];
  }
  return {
    olMap: Jw,
    getOlMap: t,
    createMap: e,
    equalsLayer: n,
    hasLayer: s,
    layerHasChanged: f,
    contextHasChanged: o,
    getAddedLayers: m,
    getRemovedLayers: g,
    getMutatedLayers: b
  };
}
const Hp = /* @__PURE__ */ new Map();
function us(t) {
  return us = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, us(t);
}
function nl(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function o5(t, e) {
  if (us(t) !== "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var a = n.call(t, e || "default");
    if (us(a) !== "object")
      return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function UT(t) {
  var e = o5(t, "string");
  return us(e) === "symbol" ? e : String(e);
}
function Qw(t, e) {
  for (var n = 0; n < e.length; n++) {
    var a = e[n];
    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, UT(a.key), a);
  }
}
function il(t, e, n) {
  return e && Qw(t.prototype, e), n && Qw(t, n), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function Du(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function ex(t, e) {
  return ex = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, s) {
    return a.__proto__ = s, a;
  }, ex(t, e);
}
function Cv(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && ex(t, e);
}
function Kd(t, e) {
  if (e && (us(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Du(t);
}
function tl(t) {
  return tl = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, tl(t);
}
function qu(t, e, n) {
  return e = UT(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function a5(t) {
  if (Array.isArray(t))
    return t;
}
function s5(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function e2(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, a = new Array(e); n < e; n++)
    a[n] = t[n];
  return a;
}
function l5(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return e2(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set")
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return e2(t, e);
  }
}
function u5() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function c5(t) {
  return a5(t) || s5(t) || l5(t) || u5();
}
function t2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function r2(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? t2(Object(n), !0).forEach(function(a) {
      qu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : t2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
var h5 = {
  type: "logger",
  log: function(e) {
    this.output("log", e);
  },
  warn: function(e) {
    this.output("warn", e);
  },
  error: function(e) {
    this.output("error", e);
  },
  output: function(e, n) {
    console && console[e] && console[e].apply(console, n);
  }
}, f5 = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    nl(this, t), this.init(e, n);
  }
  return il(t, [{
    key: "init",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = a.prefix || "i18next:", this.logger = n || h5, this.options = a, this.debug = a.debug;
    }
  }, {
    key: "setDebug",
    value: function(n) {
      this.debug = n;
    }
  }, {
    key: "log",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var n = arguments.length, a = new Array(n), s = 0; s < n; s++)
        a[s] = arguments[s];
      return this.forward(a, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(n, a, s, f) {
      return f && !this.debug ? null : (typeof n[0] == "string" && (n[0] = "".concat(s).concat(this.prefix, " ").concat(n[0])), this.logger[a](n));
    }
  }, {
    key: "create",
    value: function(n) {
      return new t(this.logger, r2(r2({}, {
        prefix: "".concat(this.prefix, ":").concat(n, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function(n) {
      return n = n || this.options, n.prefix = n.prefix || this.prefix, new t(this.logger, n);
    }
  }]), t;
}(), Ws = new f5(), Vu = function() {
  function t() {
    nl(this, t), this.observers = {};
  }
  return il(t, [{
    key: "on",
    value: function(n, a) {
      var s = this;
      return n.split(" ").forEach(function(f) {
        s.observers[f] = s.observers[f] || [], s.observers[f].push(a);
      }), this;
    }
  }, {
    key: "off",
    value: function(n, a) {
      if (!!this.observers[n]) {
        if (!a) {
          delete this.observers[n];
          return;
        }
        this.observers[n] = this.observers[n].filter(function(s) {
          return s !== a;
        });
      }
    }
  }, {
    key: "emit",
    value: function(n) {
      for (var a = arguments.length, s = new Array(a > 1 ? a - 1 : 0), f = 1; f < a; f++)
        s[f - 1] = arguments[f];
      if (this.observers[n]) {
        var o = [].concat(this.observers[n]);
        o.forEach(function(g) {
          g.apply(void 0, s);
        });
      }
      if (this.observers["*"]) {
        var m = [].concat(this.observers["*"]);
        m.forEach(function(g) {
          g.apply(g, [n].concat(s));
        });
      }
    }
  }]), t;
}();
function Zp() {
  var t, e, n = new Promise(function(a, s) {
    t = a, e = s;
  });
  return n.resolve = t, n.reject = e, n;
}
function n2(t) {
  return t == null ? "" : "" + t;
}
function p5(t, e, n) {
  t.forEach(function(a) {
    e[a] && (n[a] = e[a]);
  });
}
function Xx(t, e, n) {
  function a(m) {
    return m && m.indexOf("###") > -1 ? m.replace(/###/g, ".") : m;
  }
  function s() {
    return !t || typeof t == "string";
  }
  for (var f = typeof e != "string" ? [].concat(e) : e.split("."); f.length > 1; ) {
    if (s())
      return {};
    var o = a(f.shift());
    !t[o] && n && (t[o] = new n()), Object.prototype.hasOwnProperty.call(t, o) ? t = t[o] : t = {};
  }
  return s() ? {} : {
    obj: t,
    k: a(f.shift())
  };
}
function i2(t, e, n) {
  var a = Xx(t, e, Object), s = a.obj, f = a.k;
  s[f] = n;
}
function d5(t, e, n, a) {
  var s = Xx(t, e, Object), f = s.obj, o = s.k;
  f[o] = f[o] || [], a && (f[o] = f[o].concat(n)), a || f[o].push(n);
}
function Vg(t, e) {
  var n = Xx(t, e), a = n.obj, s = n.k;
  if (!!a)
    return a[s];
}
function o2(t, e, n) {
  var a = Vg(t, n);
  return a !== void 0 ? a : Vg(e, n);
}
function jT(t, e, n) {
  for (var a in e)
    a !== "__proto__" && a !== "constructor" && (a in t ? typeof t[a] == "string" || t[a] instanceof String || typeof e[a] == "string" || e[a] instanceof String ? n && (t[a] = e[a]) : jT(t[a], e[a], n) : t[a] = e[a]);
  return t;
}
function of(t) {
  return t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var m5 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function y5(t) {
  return typeof t == "string" ? t.replace(/[&<>"'\/]/g, function(e) {
    return m5[e];
  }) : t;
}
var Pv = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, g5 = [" ", ",", "?", "!", ";"];
function v5(t, e, n) {
  e = e || "", n = n || "";
  var a = g5.filter(function(m) {
    return e.indexOf(m) < 0 && n.indexOf(m) < 0;
  });
  if (a.length === 0)
    return !0;
  var s = new RegExp("(".concat(a.map(function(m) {
    return m === "?" ? "\\?" : m;
  }).join("|"), ")")), f = !s.test(t);
  if (!f) {
    var o = t.indexOf(n);
    o > 0 && !s.test(t.substring(0, o)) && (f = !0);
  }
  return f;
}
function a2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Py(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? a2(Object(n), !0).forEach(function(a) {
      qu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : a2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function _5(t) {
  var e = x5();
  return function() {
    var a = tl(t), s;
    if (e) {
      var f = tl(this).constructor;
      s = Reflect.construct(a, arguments, f);
    } else
      s = a.apply(this, arguments);
    return Kd(this, s);
  };
}
function x5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function GT(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!!t) {
    if (t[e])
      return t[e];
    for (var a = e.split(n), s = t, f = 0; f < a.length; ++f) {
      if (!s || typeof s[a[f]] == "string" && f + 1 < a.length)
        return;
      if (s[a[f]] === void 0) {
        for (var o = 2, m = a.slice(f, f + o).join(n), g = s[m]; g === void 0 && a.length > f + o; )
          o++, m = a.slice(f, f + o).join(n), g = s[m];
        if (g === void 0)
          return;
        if (g === null)
          return null;
        if (e.endsWith(m)) {
          if (typeof g == "string")
            return g;
          if (m && typeof g[m] == "string")
            return g[m];
        }
        var b = a.slice(f + o).join(n);
        return b ? GT(g, b, n) : void 0;
      }
      s = s[a[f]];
    }
    return s;
  }
}
var b5 = function(t) {
  Cv(n, t);
  var e = _5(n);
  function n(a) {
    var s, f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return nl(this, n), s = e.call(this), Pv && Vu.call(Du(s)), s.data = a || {}, s.options = f, s.options.keySeparator === void 0 && (s.options.keySeparator = "."), s.options.ignoreJSONStructure === void 0 && (s.options.ignoreJSONStructure = !0), s;
  }
  return il(n, [{
    key: "addNamespaces",
    value: function(s) {
      this.options.ns.indexOf(s) < 0 && this.options.ns.push(s);
    }
  }, {
    key: "removeNamespaces",
    value: function(s) {
      var f = this.options.ns.indexOf(s);
      f > -1 && this.options.ns.splice(f, 1);
    }
  }, {
    key: "getResource",
    value: function(s, f, o) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, g = m.keySeparator !== void 0 ? m.keySeparator : this.options.keySeparator, b = m.ignoreJSONStructure !== void 0 ? m.ignoreJSONStructure : this.options.ignoreJSONStructure, T = [s, f];
      o && typeof o != "string" && (T = T.concat(o)), o && typeof o == "string" && (T = T.concat(g ? o.split(g) : o)), s.indexOf(".") > -1 && (T = s.split("."));
      var M = Vg(this.data, T);
      return M || !b || typeof o != "string" ? M : GT(this.data && this.data[s] && this.data[s][f], o, g);
    }
  }, {
    key: "addResource",
    value: function(s, f, o, m) {
      var g = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, b = this.options.keySeparator;
      b === void 0 && (b = ".");
      var T = [s, f];
      o && (T = T.concat(b ? o.split(b) : o)), s.indexOf(".") > -1 && (T = s.split("."), m = f, f = T[1]), this.addNamespaces(f), i2(this.data, T, m), g.silent || this.emit("added", s, f, o, m);
    }
  }, {
    key: "addResources",
    value: function(s, f, o) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var g in o)
        (typeof o[g] == "string" || Object.prototype.toString.apply(o[g]) === "[object Array]") && this.addResource(s, f, g, o[g], {
          silent: !0
        });
      m.silent || this.emit("added", s, f, o);
    }
  }, {
    key: "addResourceBundle",
    value: function(s, f, o, m, g) {
      var b = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, T = [s, f];
      s.indexOf(".") > -1 && (T = s.split("."), m = o, o = f, f = T[1]), this.addNamespaces(f);
      var M = Vg(this.data, T) || {};
      m ? jT(M, o, g) : M = Py(Py({}, M), o), i2(this.data, T, M), b.silent || this.emit("added", s, f, o);
    }
  }, {
    key: "removeResourceBundle",
    value: function(s, f) {
      this.hasResourceBundle(s, f) && delete this.data[s][f], this.removeNamespaces(f), this.emit("removed", s, f);
    }
  }, {
    key: "hasResourceBundle",
    value: function(s, f) {
      return this.getResource(s, f) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(s, f) {
      return f || (f = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? Py(Py({}, {}), this.getResource(s, f)) : this.getResource(s, f);
    }
  }, {
    key: "getDataByLanguage",
    value: function(s) {
      return this.data[s];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function(s) {
      var f = this.getDataByLanguage(s), o = f && Object.keys(f) || [];
      return !!o.find(function(m) {
        return f[m] && Object.keys(f[m]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), n;
}(Vu), $T = {
  processors: {},
  addPostProcessor: function(e) {
    this.processors[e.name] = e;
  },
  handle: function(e, n, a, s, f) {
    var o = this;
    return e.forEach(function(m) {
      o.processors[m] && (n = o.processors[m].process(n, a, s, f));
    }), n;
  }
};
function s2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Ao(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? s2(Object(n), !0).forEach(function(a) {
      qu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : s2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function w5(t) {
  var e = E5();
  return function() {
    var a = tl(t), s;
    if (e) {
      var f = tl(this).constructor;
      s = Reflect.construct(a, arguments, f);
    } else
      s = a.apply(this, arguments);
    return Kd(this, s);
  };
}
function E5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var l2 = {}, u2 = function(t) {
  Cv(n, t);
  var e = w5(n);
  function n(a) {
    var s, f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return nl(this, n), s = e.call(this), Pv && Vu.call(Du(s)), p5(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], a, Du(s)), s.options = f, s.options.keySeparator === void 0 && (s.options.keySeparator = "."), s.logger = Ws.create("translator"), s;
  }
  return il(n, [{
    key: "changeLanguage",
    value: function(s) {
      s && (this.language = s);
    }
  }, {
    key: "exists",
    value: function(s) {
      var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (s == null)
        return !1;
      var o = this.resolve(s, f);
      return o && o.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(s, f) {
      var o = f.nsSeparator !== void 0 ? f.nsSeparator : this.options.nsSeparator;
      o === void 0 && (o = ":");
      var m = f.keySeparator !== void 0 ? f.keySeparator : this.options.keySeparator, g = f.ns || this.options.defaultNS || [], b = o && s.indexOf(o) > -1, T = !this.options.userDefinedKeySeparator && !f.keySeparator && !this.options.userDefinedNsSeparator && !f.nsSeparator && !v5(s, o, m);
      if (b && !T) {
        var M = s.match(this.interpolator.nestingRegexp);
        if (M && M.length > 0)
          return {
            key: s,
            namespaces: g
          };
        var I = s.split(o);
        (o !== m || o === m && this.options.ns.indexOf(I[0]) > -1) && (g = I.shift()), s = I.join(m);
      }
      return typeof g == "string" && (g = [g]), {
        key: s,
        namespaces: g
      };
    }
  }, {
    key: "translate",
    value: function(s, f, o) {
      var m = this;
      if (us(f) !== "object" && this.options.overloadTranslationOptionHandler && (f = this.options.overloadTranslationOptionHandler(arguments)), f || (f = {}), s == null)
        return "";
      Array.isArray(s) || (s = [String(s)]);
      var g = f.returnDetails !== void 0 ? f.returnDetails : this.options.returnDetails, b = f.keySeparator !== void 0 ? f.keySeparator : this.options.keySeparator, T = this.extractFromKey(s[s.length - 1], f), M = T.key, I = T.namespaces, A = I[I.length - 1], z = f.lng || this.language, V = f.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (z && z.toLowerCase() === "cimode") {
        if (V) {
          var q = f.nsSeparator || this.options.nsSeparator;
          return g ? {
            res: "".concat(A).concat(q).concat(M),
            usedKey: M,
            exactUsedKey: M,
            usedLng: z,
            usedNS: A
          } : "".concat(A).concat(q).concat(M);
        }
        return g ? {
          res: M,
          usedKey: M,
          exactUsedKey: M,
          usedLng: z,
          usedNS: A
        } : M;
      }
      var re = this.resolve(s, f), X = re && re.res, ae = re && re.usedKey || M, ce = re && re.exactUsedKey || M, ve = Object.prototype.toString.apply(X), Ne = ["[object Number]", "[object Function]", "[object RegExp]"], ze = f.joinArrays !== void 0 ? f.joinArrays : this.options.joinArrays, Ae = !this.i18nFormat || this.i18nFormat.handleAsObject, Se = typeof X != "string" && typeof X != "boolean" && typeof X != "number";
      if (Ae && X && Se && Ne.indexOf(ve) < 0 && !(typeof ze == "string" && ve === "[object Array]")) {
        if (!f.returnObjects && !this.options.returnObjects) {
          this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          var Ie = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(ae, X, Ao(Ao({}, f), {}, {
            ns: I
          })) : "key '".concat(M, " (").concat(this.language, ")' returned an object instead of string.");
          return g ? (re.res = Ie, re) : Ie;
        }
        if (b) {
          var Xe = ve === "[object Array]", $e = Xe ? [] : {}, at = Xe ? ce : ae;
          for (var be in X)
            if (Object.prototype.hasOwnProperty.call(X, be)) {
              var Je = "".concat(at).concat(b).concat(be);
              $e[be] = this.translate(Je, Ao(Ao({}, f), {
                joinArrays: !1,
                ns: I
              })), $e[be] === Je && ($e[be] = X[be]);
            }
          X = $e;
        }
      } else if (Ae && typeof ze == "string" && ve === "[object Array]")
        X = X.join(ze), X && (X = this.extendTranslation(X, s, f, o));
      else {
        var ht = !1, vt = !1, At = f.count !== void 0 && typeof f.count != "string", tr = n.hasDefaultValue(f), kn = At ? this.pluralResolver.getSuffix(z, f.count, f) : "", Nr = f["defaultValue".concat(kn)] || f.defaultValue;
        !this.isValidLookup(X) && tr && (ht = !0, X = Nr), this.isValidLookup(X) || (vt = !0, X = M);
        var pr = f.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, Zn = pr && vt ? void 0 : X, Rr = tr && Nr !== X && this.options.updateMissing;
        if (vt || ht || Rr) {
          if (this.logger.log(Rr ? "updateKey" : "missingKey", z, A, M, Rr ? Nr : X), b) {
            var Fi = this.resolve(M, Ao(Ao({}, f), {}, {
              keySeparator: !1
            }));
            Fi && Fi.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var $r = [], Ar = this.languageUtils.getFallbackCodes(this.options.fallbackLng, f.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && Ar && Ar[0])
            for (var Vn = 0; Vn < Ar.length; Vn++)
              $r.push(Ar[Vn]);
          else
            this.options.saveMissingTo === "all" ? $r = this.languageUtils.toResolveHierarchy(f.lng || this.language) : $r.push(f.lng || this.language);
          var Sr = function(ai, Un, K) {
            var ye = tr && K !== X ? K : Zn;
            m.options.missingKeyHandler ? m.options.missingKeyHandler(ai, A, Un, ye, Rr, f) : m.backendConnector && m.backendConnector.saveMissing && m.backendConnector.saveMissing(ai, A, Un, ye, Rr, f), m.emit("missingKey", ai, A, Un, X);
          };
          this.options.saveMissing && (this.options.saveMissingPlurals && At ? $r.forEach(function(Sn) {
            m.pluralResolver.getSuffixes(Sn, f).forEach(function(ai) {
              Sr([Sn], M + ai, f["defaultValue".concat(ai)] || Nr);
            });
          }) : Sr($r, M, Nr));
        }
        X = this.extendTranslation(X, s, f, re, o), vt && X === M && this.options.appendNamespaceToMissingKey && (X = "".concat(A, ":").concat(M)), (vt || ht) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? X = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(A, ":").concat(M) : M, ht ? X : void 0) : X = this.options.parseMissingKeyHandler(X));
      }
      return g ? (re.res = X, re) : X;
    }
  }, {
    key: "extendTranslation",
    value: function(s, f, o, m, g) {
      var b = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        s = this.i18nFormat.parse(s, Ao(Ao({}, this.options.interpolation.defaultVariables), o), m.usedLng, m.usedNS, m.usedKey, {
          resolved: m
        });
      else if (!o.skipInterpolation) {
        o.interpolation && this.interpolator.init(Ao(Ao({}, o), {
          interpolation: Ao(Ao({}, this.options.interpolation), o.interpolation)
        }));
        var T = typeof s == "string" && (o && o.interpolation && o.interpolation.skipOnVariables !== void 0 ? o.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), M;
        if (T) {
          var I = s.match(this.interpolator.nestingRegexp);
          M = I && I.length;
        }
        var A = o.replace && typeof o.replace != "string" ? o.replace : o;
        if (this.options.interpolation.defaultVariables && (A = Ao(Ao({}, this.options.interpolation.defaultVariables), A)), s = this.interpolator.interpolate(s, A, o.lng || this.language, o), T) {
          var z = s.match(this.interpolator.nestingRegexp), V = z && z.length;
          M < V && (o.nest = !1);
        }
        o.nest !== !1 && (s = this.interpolator.nest(s, function() {
          for (var X = arguments.length, ae = new Array(X), ce = 0; ce < X; ce++)
            ae[ce] = arguments[ce];
          return g && g[0] === ae[0] && !o.context ? (b.logger.warn("It seems you are nesting recursively key: ".concat(ae[0], " in key: ").concat(f[0])), null) : b.translate.apply(b, ae.concat([f]));
        }, o)), o.interpolation && this.interpolator.reset();
      }
      var q = o.postProcess || this.options.postProcess, re = typeof q == "string" ? [q] : q;
      return s != null && re && re.length && o.applyPostProcessor !== !1 && (s = $T.handle(re, s, f, this.options && this.options.postProcessPassResolved ? Ao({
        i18nResolved: m
      }, o) : o, this)), s;
    }
  }, {
    key: "resolve",
    value: function(s) {
      var f = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, m, g, b, T, M;
      return typeof s == "string" && (s = [s]), s.forEach(function(I) {
        if (!f.isValidLookup(m)) {
          var A = f.extractFromKey(I, o), z = A.key;
          g = z;
          var V = A.namespaces;
          f.options.fallbackNS && (V = V.concat(f.options.fallbackNS));
          var q = o.count !== void 0 && typeof o.count != "string", re = q && !o.ordinal && o.count === 0 && f.pluralResolver.shouldUseIntlApi(), X = o.context !== void 0 && (typeof o.context == "string" || typeof o.context == "number") && o.context !== "", ae = o.lngs ? o.lngs : f.languageUtils.toResolveHierarchy(o.lng || f.language, o.fallbackLng);
          V.forEach(function(ce) {
            f.isValidLookup(m) || (M = ce, !l2["".concat(ae[0], "-").concat(ce)] && f.utils && f.utils.hasLoadedNamespace && !f.utils.hasLoadedNamespace(M) && (l2["".concat(ae[0], "-").concat(ce)] = !0, f.logger.warn('key "'.concat(g, '" for languages "').concat(ae.join(", "), `" won't get resolved as namespace "`).concat(M, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), ae.forEach(function(ve) {
              if (!f.isValidLookup(m)) {
                T = ve;
                var Ne = [z];
                if (f.i18nFormat && f.i18nFormat.addLookupKeys)
                  f.i18nFormat.addLookupKeys(Ne, z, ve, ce, o);
                else {
                  var ze;
                  q && (ze = f.pluralResolver.getSuffix(ve, o.count, o));
                  var Ae = "".concat(f.options.pluralSeparator, "zero");
                  if (q && (Ne.push(z + ze), re && Ne.push(z + Ae)), X) {
                    var Se = "".concat(z).concat(f.options.contextSeparator).concat(o.context);
                    Ne.push(Se), q && (Ne.push(Se + ze), re && Ne.push(Se + Ae));
                  }
                }
                for (var Ie; Ie = Ne.pop(); )
                  f.isValidLookup(m) || (b = Ie, m = f.getResource(ve, ce, Ie, o));
              }
            }));
          });
        }
      }), {
        res: m,
        usedKey: g,
        exactUsedKey: b,
        usedLng: T,
        usedNS: M
      };
    }
  }, {
    key: "isValidLookup",
    value: function(s) {
      return s !== void 0 && !(!this.options.returnNull && s === null) && !(!this.options.returnEmptyString && s === "");
    }
  }, {
    key: "getResource",
    value: function(s, f, o) {
      var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(s, f, o, m) : this.resourceStore.getResource(s, f, o, m);
    }
  }], [{
    key: "hasDefaultValue",
    value: function(s) {
      var f = "defaultValue";
      for (var o in s)
        if (Object.prototype.hasOwnProperty.call(s, o) && f === o.substring(0, f.length) && s[o] !== void 0)
          return !0;
      return !1;
    }
  }]), n;
}(Vu);
function X_(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
var c2 = function() {
  function t(e) {
    nl(this, t), this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Ws.create("languageUtils");
  }
  return il(t, [{
    key: "getScriptPartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return null;
      var a = n.split("-");
      return a.length === 2 || (a.pop(), a[a.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(a.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return n;
      var a = n.split("-");
      return this.formatLanguageCode(a[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(n) {
      if (typeof n == "string" && n.indexOf("-") > -1) {
        var a = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], s = n.split("-");
        return this.options.lowerCaseLng ? s = s.map(function(f) {
          return f.toLowerCase();
        }) : s.length === 2 ? (s[0] = s[0].toLowerCase(), s[1] = s[1].toUpperCase(), a.indexOf(s[1].toLowerCase()) > -1 && (s[1] = X_(s[1].toLowerCase()))) : s.length === 3 && (s[0] = s[0].toLowerCase(), s[1].length === 2 && (s[1] = s[1].toUpperCase()), s[0] !== "sgn" && s[2].length === 2 && (s[2] = s[2].toUpperCase()), a.indexOf(s[1].toLowerCase()) > -1 && (s[1] = X_(s[1].toLowerCase())), a.indexOf(s[2].toLowerCase()) > -1 && (s[2] = X_(s[2].toLowerCase()))), s.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? n.toLowerCase() : n;
    }
  }, {
    key: "isSupportedCode",
    value: function(n) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (n = this.getLanguagePartFromCode(n)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(n) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function(n) {
      var a = this;
      if (!n)
        return null;
      var s;
      return n.forEach(function(f) {
        if (!s) {
          var o = a.formatLanguageCode(f);
          (!a.options.supportedLngs || a.isSupportedCode(o)) && (s = o);
        }
      }), !s && this.options.supportedLngs && n.forEach(function(f) {
        if (!s) {
          var o = a.getLanguagePartFromCode(f);
          if (a.isSupportedCode(o))
            return s = o;
          s = a.options.supportedLngs.find(function(m) {
            if (m.indexOf(o) === 0)
              return m;
          });
        }
      }), s || (s = this.getFallbackCodes(this.options.fallbackLng)[0]), s;
    }
  }, {
    key: "getFallbackCodes",
    value: function(n, a) {
      if (!n)
        return [];
      if (typeof n == "function" && (n = n(a)), typeof n == "string" && (n = [n]), Object.prototype.toString.apply(n) === "[object Array]")
        return n;
      if (!a)
        return n.default || [];
      var s = n[a];
      return s || (s = n[this.getScriptPartFromCode(a)]), s || (s = n[this.formatLanguageCode(a)]), s || (s = n[this.getLanguagePartFromCode(a)]), s || (s = n.default), s || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(n, a) {
      var s = this, f = this.getFallbackCodes(a || this.options.fallbackLng || [], n), o = [], m = function(b) {
        !b || (s.isSupportedCode(b) ? o.push(b) : s.logger.warn("rejecting language code not found in supportedLngs: ".concat(b)));
      };
      return typeof n == "string" && n.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && m(this.formatLanguageCode(n)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && m(this.getScriptPartFromCode(n)), this.options.load !== "currentOnly" && m(this.getLanguagePartFromCode(n))) : typeof n == "string" && m(this.formatLanguageCode(n)), f.forEach(function(g) {
        o.indexOf(g) < 0 && m(s.formatLanguageCode(g));
      }), o;
    }
  }]), t;
}(), S5 = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], T5 = {
  1: function(e) {
    return Number(e > 1);
  },
  2: function(e) {
    return Number(e != 1);
  },
  3: function(e) {
    return 0;
  },
  4: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  5: function(e) {
    return Number(e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5);
  },
  6: function(e) {
    return Number(e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2);
  },
  7: function(e) {
    return Number(e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  8: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3);
  },
  9: function(e) {
    return Number(e >= 2);
  },
  10: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4);
  },
  11: function(e) {
    return Number(e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3);
  },
  12: function(e) {
    return Number(e % 10 != 1 || e % 100 == 11);
  },
  13: function(e) {
    return Number(e !== 0);
  },
  14: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3);
  },
  15: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  16: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2);
  },
  17: function(e) {
    return Number(e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1);
  },
  18: function(e) {
    return Number(e == 0 ? 0 : e == 1 ? 1 : 2);
  },
  19: function(e) {
    return Number(e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3);
  },
  20: function(e) {
    return Number(e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2);
  },
  21: function(e) {
    return Number(e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0);
  },
  22: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3);
  }
}, M5 = ["v1", "v2", "v3"], h2 = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function I5() {
  var t = {};
  return S5.forEach(function(e) {
    e.lngs.forEach(function(n) {
      t[n] = {
        numbers: e.nr,
        plurals: T5[e.fc]
      };
    });
  }), t;
}
var O5 = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    nl(this, t), this.languageUtils = e, this.options = n, this.logger = Ws.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = I5();
  }
  return il(t, [{
    key: "addRule",
    value: function(n, a) {
      this.rules[n] = a;
    }
  }, {
    key: "getRule",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
        try {
          return new Intl.PluralRules(n, {
            type: a.ordinal ? "ordinal" : "cardinal"
          });
        } catch {
          return;
        }
      return this.rules[n] || this.rules[this.languageUtils.getLanguagePartFromCode(n)];
    }
  }, {
    key: "needsPlural",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = this.getRule(n, a);
      return this.shouldUseIntlApi() ? s && s.resolvedOptions().pluralCategories.length > 1 : s && s.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(n, a) {
      var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(n, s).map(function(f) {
        return "".concat(a).concat(f);
      });
    }
  }, {
    key: "getSuffixes",
    value: function(n) {
      var a = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = this.getRule(n, s);
      return f ? this.shouldUseIntlApi() ? f.resolvedOptions().pluralCategories.sort(function(o, m) {
        return h2[o] - h2[m];
      }).map(function(o) {
        return "".concat(a.options.prepend).concat(o);
      }) : f.numbers.map(function(o) {
        return a.getSuffix(n, o, s);
      }) : [];
    }
  }, {
    key: "getSuffix",
    value: function(n, a) {
      var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, f = this.getRule(n, s);
      return f ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(f.select(a)) : this.getSuffixRetroCompatible(f, a) : (this.logger.warn("no plural rule found for: ".concat(n)), "");
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function(n, a) {
      var s = this, f = n.noAbs ? n.plurals(a) : n.plurals(Math.abs(a)), o = n.numbers[f];
      this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 && (o === 2 ? o = "plural" : o === 1 && (o = ""));
      var m = function() {
        return s.options.prepend && o.toString() ? s.options.prepend + o.toString() : o.toString();
      };
      return this.options.compatibilityJSON === "v1" ? o === 1 ? "" : typeof o == "number" ? "_plural_".concat(o.toString()) : m() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 ? m() : this.options.prepend && f.toString() ? this.options.prepend + f.toString() : f.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function() {
      return !M5.includes(this.options.compatibilityJSON);
    }
  }]), t;
}();
function f2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Xa(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? f2(Object(n), !0).forEach(function(a) {
      qu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : f2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
var C5 = function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    nl(this, t), this.logger = Ws.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || function(n) {
      return n;
    }, this.init(e);
  }
  return il(t, [{
    key: "init",
    value: function() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      n.interpolation || (n.interpolation = {
        escapeValue: !0
      });
      var a = n.interpolation;
      this.escape = a.escape !== void 0 ? a.escape : y5, this.escapeValue = a.escapeValue !== void 0 ? a.escapeValue : !0, this.useRawValueToEscape = a.useRawValueToEscape !== void 0 ? a.useRawValueToEscape : !1, this.prefix = a.prefix ? of(a.prefix) : a.prefixEscaped || "{{", this.suffix = a.suffix ? of(a.suffix) : a.suffixEscaped || "}}", this.formatSeparator = a.formatSeparator ? a.formatSeparator : a.formatSeparator || ",", this.unescapePrefix = a.unescapeSuffix ? "" : a.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : a.unescapeSuffix || "", this.nestingPrefix = a.nestingPrefix ? of(a.nestingPrefix) : a.nestingPrefixEscaped || of("$t("), this.nestingSuffix = a.nestingSuffix ? of(a.nestingSuffix) : a.nestingSuffixEscaped || of(")"), this.nestingOptionsSeparator = a.nestingOptionsSeparator ? a.nestingOptionsSeparator : a.nestingOptionsSeparator || ",", this.maxReplaces = a.maxReplaces ? a.maxReplaces : 1e3, this.alwaysFormat = a.alwaysFormat !== void 0 ? a.alwaysFormat : !1, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var n = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(n, "g");
      var a = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(a, "g");
      var s = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(s, "g");
    }
  }, {
    key: "interpolate",
    value: function(n, a, s, f) {
      var o = this, m, g, b, T = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function M(q) {
        return q.replace(/\$/g, "$$$$");
      }
      var I = function(re) {
        if (re.indexOf(o.formatSeparator) < 0) {
          var X = o2(a, T, re);
          return o.alwaysFormat ? o.format(X, void 0, s, Xa(Xa(Xa({}, f), a), {}, {
            interpolationkey: re
          })) : X;
        }
        var ae = re.split(o.formatSeparator), ce = ae.shift().trim(), ve = ae.join(o.formatSeparator).trim();
        return o.format(o2(a, T, ce), ve, s, Xa(Xa(Xa({}, f), a), {}, {
          interpolationkey: ce
        }));
      };
      this.resetRegExp();
      var A = f && f.missingInterpolationHandler || this.options.missingInterpolationHandler, z = f && f.interpolation && f.interpolation.skipOnVariables !== void 0 ? f.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, V = [{
        regex: this.regexpUnescape,
        safeValue: function(re) {
          return M(re);
        }
      }, {
        regex: this.regexp,
        safeValue: function(re) {
          return o.escapeValue ? M(o.escape(re)) : M(re);
        }
      }];
      return V.forEach(function(q) {
        for (b = 0; m = q.regex.exec(n); ) {
          var re = m[1].trim();
          if (g = I(re), g === void 0)
            if (typeof A == "function") {
              var X = A(n, m, f);
              g = typeof X == "string" ? X : "";
            } else if (f && Object.prototype.hasOwnProperty.call(f, re))
              g = "";
            else if (z) {
              g = m[0];
              continue;
            } else
              o.logger.warn("missed to pass in variable ".concat(re, " for interpolating ").concat(n)), g = "";
          else
            typeof g != "string" && !o.useRawValueToEscape && (g = n2(g));
          var ae = q.safeValue(g);
          if (n = n.replace(m[0], ae), z ? (q.regex.lastIndex += g.length, q.regex.lastIndex -= m[0].length) : q.regex.lastIndex = 0, b++, b >= o.maxReplaces)
            break;
        }
      }), n;
    }
  }, {
    key: "nest",
    value: function(n, a) {
      var s = this, f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o, m, g;
      function b(A, z) {
        var V = this.nestingOptionsSeparator;
        if (A.indexOf(V) < 0)
          return A;
        var q = A.split(new RegExp("".concat(V, "[ ]*{"))), re = "{".concat(q[1]);
        A = q[0], re = this.interpolate(re, g);
        var X = re.match(/'/g), ae = re.match(/"/g);
        (X && X.length % 2 === 0 && !ae || ae.length % 2 !== 0) && (re = re.replace(/'/g, '"'));
        try {
          g = JSON.parse(re), z && (g = Xa(Xa({}, z), g));
        } catch (ce) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(A), ce), "".concat(A).concat(V).concat(re);
        }
        return delete g.defaultValue, A;
      }
      for (; o = this.nestingRegexp.exec(n); ) {
        var T = [];
        g = Xa({}, f), g = g.replace && typeof g.replace != "string" ? g.replace : g, g.applyPostProcessor = !1, delete g.defaultValue;
        var M = !1;
        if (o[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(o[1])) {
          var I = o[1].split(this.formatSeparator).map(function(A) {
            return A.trim();
          });
          o[1] = I.shift(), T = I, M = !0;
        }
        if (m = a(b.call(this, o[1].trim(), g), g), m && o[0] === n && typeof m != "string")
          return m;
        typeof m != "string" && (m = n2(m)), m || (this.logger.warn("missed to resolve ".concat(o[1], " for nesting ").concat(n)), m = ""), M && (m = T.reduce(function(A, z) {
          return s.format(A, z, f.lng, Xa(Xa({}, f), {}, {
            interpolationkey: o[1].trim()
          }));
        }, m.trim())), n = n.replace(o[0], m), this.regexp.lastIndex = 0;
      }
      return n;
    }
  }]), t;
}();
function p2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function Ll(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? p2(Object(n), !0).forEach(function(a) {
      qu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : p2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function P5(t) {
  var e = t.toLowerCase().trim(), n = {};
  if (t.indexOf("(") > -1) {
    var a = t.split("(");
    e = a[0].toLowerCase().trim();
    var s = a[1].substring(0, a[1].length - 1);
    if (e === "currency" && s.indexOf(":") < 0)
      n.currency || (n.currency = s.trim());
    else if (e === "relativetime" && s.indexOf(":") < 0)
      n.range || (n.range = s.trim());
    else {
      var f = s.split(";");
      f.forEach(function(o) {
        if (!!o) {
          var m = o.split(":"), g = c5(m), b = g[0], T = g.slice(1), M = T.join(":").trim().replace(/^'+|'+$/g, "");
          n[b.trim()] || (n[b.trim()] = M), M === "false" && (n[b.trim()] = !1), M === "true" && (n[b.trim()] = !0), isNaN(M) || (n[b.trim()] = parseInt(M, 10));
        }
      });
    }
  }
  return {
    formatName: e,
    formatOptions: n
  };
}
function af(t) {
  var e = {};
  return function(a, s, f) {
    var o = s + JSON.stringify(f), m = e[o];
    return m || (m = t(s, f), e[o] = m), m(a);
  };
}
var A5 = function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    nl(this, t), this.logger = Ws.create("formatter"), this.options = e, this.formats = {
      number: af(function(n, a) {
        var s = new Intl.NumberFormat(n, Ll({}, a));
        return function(f) {
          return s.format(f);
        };
      }),
      currency: af(function(n, a) {
        var s = new Intl.NumberFormat(n, Ll(Ll({}, a), {}, {
          style: "currency"
        }));
        return function(f) {
          return s.format(f);
        };
      }),
      datetime: af(function(n, a) {
        var s = new Intl.DateTimeFormat(n, Ll({}, a));
        return function(f) {
          return s.format(f);
        };
      }),
      relativetime: af(function(n, a) {
        var s = new Intl.RelativeTimeFormat(n, Ll({}, a));
        return function(f) {
          return s.format(f, a.range || "day");
        };
      }),
      list: af(function(n, a) {
        var s = new Intl.ListFormat(n, Ll({}, a));
        return function(f) {
          return s.format(f);
        };
      })
    }, this.init(e);
  }
  return il(t, [{
    key: "init",
    value: function(n) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, s = a.interpolation;
      this.formatSeparator = s.formatSeparator ? s.formatSeparator : s.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function(n, a) {
      this.formats[n.toLowerCase().trim()] = a;
    }
  }, {
    key: "addCached",
    value: function(n, a) {
      this.formats[n.toLowerCase().trim()] = af(a);
    }
  }, {
    key: "format",
    value: function(n, a, s) {
      var f = this, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, m = a.split(this.formatSeparator), g = m.reduce(function(b, T) {
        var M = P5(T), I = M.formatName, A = M.formatOptions;
        if (f.formats[I]) {
          var z = b;
          try {
            var V = o && o.formatParams && o.formatParams[o.interpolationkey] || {}, q = V.locale || V.lng || o.locale || o.lng || s;
            z = f.formats[I](b, q, Ll(Ll(Ll({}, A), o), V));
          } catch (re) {
            f.logger.warn(re);
          }
          return z;
        } else
          f.logger.warn("there was no format function for ".concat(I));
        return b;
      }, n);
      return g;
    }
  }]), t;
}();
function d2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function m2(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? d2(Object(n), !0).forEach(function(a) {
      qu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : d2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function k5(t) {
  var e = L5();
  return function() {
    var a = tl(t), s;
    if (e) {
      var f = tl(this).constructor;
      s = Reflect.construct(a, arguments, f);
    } else
      s = a.apply(this, arguments);
    return Kd(this, s);
  };
}
function L5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function D5(t, e) {
  t.pending[e] !== void 0 && (delete t.pending[e], t.pendingCount--);
}
var N5 = function(t) {
  Cv(n, t);
  var e = k5(n);
  function n(a, s, f) {
    var o, m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return nl(this, n), o = e.call(this), Pv && Vu.call(Du(o)), o.backend = a, o.store = s, o.services = f, o.languageUtils = f.languageUtils, o.options = m, o.logger = Ws.create("backendConnector"), o.waitingReads = [], o.maxParallelReads = m.maxParallelReads || 10, o.readingCalls = 0, o.maxRetries = m.maxRetries >= 0 ? m.maxRetries : 5, o.retryTimeout = m.retryTimeout >= 1 ? m.retryTimeout : 350, o.state = {}, o.queue = [], o.backend && o.backend.init && o.backend.init(f, m.backend, m), o;
  }
  return il(n, [{
    key: "queueLoad",
    value: function(s, f, o, m) {
      var g = this, b = {}, T = {}, M = {}, I = {};
      return s.forEach(function(A) {
        var z = !0;
        f.forEach(function(V) {
          var q = "".concat(A, "|").concat(V);
          !o.reload && g.store.hasResourceBundle(A, V) ? g.state[q] = 2 : g.state[q] < 0 || (g.state[q] === 1 ? T[q] === void 0 && (T[q] = !0) : (g.state[q] = 1, z = !1, T[q] === void 0 && (T[q] = !0), b[q] === void 0 && (b[q] = !0), I[V] === void 0 && (I[V] = !0)));
        }), z || (M[A] = !0);
      }), (Object.keys(b).length || Object.keys(T).length) && this.queue.push({
        pending: T,
        pendingCount: Object.keys(T).length,
        loaded: {},
        errors: [],
        callback: m
      }), {
        toLoad: Object.keys(b),
        pending: Object.keys(T),
        toLoadLanguages: Object.keys(M),
        toLoadNamespaces: Object.keys(I)
      };
    }
  }, {
    key: "loaded",
    value: function(s, f, o) {
      var m = s.split("|"), g = m[0], b = m[1];
      f && this.emit("failedLoading", g, b, f), o && this.store.addResourceBundle(g, b, o), this.state[s] = f ? -1 : 2;
      var T = {};
      this.queue.forEach(function(M) {
        d5(M.loaded, [g], b), D5(M, s), f && M.errors.push(f), M.pendingCount === 0 && !M.done && (Object.keys(M.loaded).forEach(function(I) {
          T[I] || (T[I] = {});
          var A = M.loaded[I];
          A.length && A.forEach(function(z) {
            T[I][z] === void 0 && (T[I][z] = !0);
          });
        }), M.done = !0, M.errors.length ? M.callback(M.errors) : M.callback());
      }), this.emit("loaded", T), this.queue = this.queue.filter(function(M) {
        return !M.done;
      });
    }
  }, {
    key: "read",
    value: function(s, f, o) {
      var m = this, g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, b = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, T = arguments.length > 5 ? arguments[5] : void 0;
      if (!s.length)
        return T(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: s,
          ns: f,
          fcName: o,
          tried: g,
          wait: b,
          callback: T
        });
        return;
      }
      this.readingCalls++;
      var M = function(V, q) {
        if (m.readingCalls--, m.waitingReads.length > 0) {
          var re = m.waitingReads.shift();
          m.read(re.lng, re.ns, re.fcName, re.tried, re.wait, re.callback);
        }
        if (V && q && g < m.maxRetries) {
          setTimeout(function() {
            m.read.call(m, s, f, o, g + 1, b * 2, T);
          }, b);
          return;
        }
        T(V, q);
      }, I = this.backend[o].bind(this.backend);
      if (I.length === 2) {
        try {
          var A = I(s, f);
          A && typeof A.then == "function" ? A.then(function(z) {
            return M(null, z);
          }).catch(M) : M(null, A);
        } catch (z) {
          M(z);
        }
        return;
      }
      return I(s, f, M);
    }
  }, {
    key: "prepareLoading",
    value: function(s, f) {
      var o = this, m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, g = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), g && g();
      typeof s == "string" && (s = this.languageUtils.toResolveHierarchy(s)), typeof f == "string" && (f = [f]);
      var b = this.queueLoad(s, f, m, g);
      if (!b.toLoad.length)
        return b.pending.length || g(), null;
      b.toLoad.forEach(function(T) {
        o.loadOne(T);
      });
    }
  }, {
    key: "load",
    value: function(s, f, o) {
      this.prepareLoading(s, f, {}, o);
    }
  }, {
    key: "reload",
    value: function(s, f, o) {
      this.prepareLoading(s, f, {
        reload: !0
      }, o);
    }
  }, {
    key: "loadOne",
    value: function(s) {
      var f = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", m = s.split("|"), g = m[0], b = m[1];
      this.read(g, b, "read", void 0, void 0, function(T, M) {
        T && f.logger.warn("".concat(o, "loading namespace ").concat(b, " for language ").concat(g, " failed"), T), !T && M && f.logger.log("".concat(o, "loaded namespace ").concat(b, " for language ").concat(g), M), f.loaded(s, T, M);
      });
    }
  }, {
    key: "saveMissing",
    value: function(s, f, o, m, g) {
      var b = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, T = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function() {
      };
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(f)) {
        this.logger.warn('did not save key "'.concat(o, '" as the namespace "').concat(f, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (!(o == null || o === "")) {
        if (this.backend && this.backend.create) {
          var M = m2(m2({}, b), {}, {
            isUpdate: g
          }), I = this.backend.create.bind(this.backend);
          if (I.length < 6)
            try {
              var A;
              I.length === 5 ? A = I(s, f, o, m, M) : A = I(s, f, o, m), A && typeof A.then == "function" ? A.then(function(z) {
                return T(null, z);
              }).catch(T) : T(null, A);
            } catch (z) {
              T(z);
            }
          else
            I(s, f, o, m, T, M);
        }
        !s || !s[0] || this.store.addResource(s[0], f, o, m);
      }
    }
  }]), n;
}(Vu);
function y2() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      var n = {};
      if (us(e[1]) === "object" && (n = e[1]), typeof e[1] == "string" && (n.defaultValue = e[1]), typeof e[2] == "string" && (n.tDescription = e[2]), us(e[2]) === "object" || us(e[3]) === "object") {
        var a = e[3] || e[2];
        Object.keys(a).forEach(function(s) {
          n[s] = a[s];
        });
      }
      return n;
    },
    interpolation: {
      escapeValue: !0,
      format: function(e, n, a, s) {
        return e;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function g2(t) {
  return typeof t.ns == "string" && (t.ns = [t.ns]), typeof t.fallbackLng == "string" && (t.fallbackLng = [t.fallbackLng]), typeof t.fallbackNS == "string" && (t.fallbackNS = [t.fallbackNS]), t.supportedLngs && t.supportedLngs.indexOf("cimode") < 0 && (t.supportedLngs = t.supportedLngs.concat(["cimode"])), t;
}
function v2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function zs(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? v2(Object(n), !0).forEach(function(a) {
      qu(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : v2(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function R5(t) {
  var e = z5();
  return function() {
    var a = tl(t), s;
    if (e) {
      var f = tl(this).constructor;
      s = Reflect.construct(a, arguments, f);
    } else
      s = a.apply(this, arguments);
    return Kd(this, s);
  };
}
function z5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ay() {
}
function F5(t) {
  var e = Object.getOwnPropertyNames(Object.getPrototypeOf(t));
  e.forEach(function(n) {
    typeof t[n] == "function" && (t[n] = t[n].bind(t));
  });
}
var Ug = function(t) {
  Cv(n, t);
  var e = R5(n);
  function n() {
    var a, s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, f = arguments.length > 1 ? arguments[1] : void 0;
    if (nl(this, n), a = e.call(this), Pv && Vu.call(Du(a)), a.options = g2(s), a.services = {}, a.logger = Ws, a.modules = {
      external: []
    }, F5(Du(a)), f && !a.isInitialized && !s.isClone) {
      if (!a.options.initImmediate)
        return a.init(s, f), Kd(a, Du(a));
      setTimeout(function() {
        a.init(s, f);
      }, 0);
    }
    return a;
  }
  return il(n, [{
    key: "init",
    value: function() {
      var s = this, f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 ? arguments[1] : void 0;
      typeof f == "function" && (o = f, f = {}), !f.defaultNS && f.defaultNS !== !1 && f.ns && (typeof f.ns == "string" ? f.defaultNS = f.ns : f.ns.indexOf("translation") < 0 && (f.defaultNS = f.ns[0]));
      var m = y2();
      this.options = zs(zs(zs({}, m), this.options), g2(f)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = zs(zs({}, m.interpolation), this.options.interpolation)), f.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = f.keySeparator), f.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = f.nsSeparator);
      function g(re) {
        return re ? typeof re == "function" ? new re() : re : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? Ws.init(g(this.modules.logger), this.options) : Ws.init(null, this.options);
        var b;
        this.modules.formatter ? b = this.modules.formatter : typeof Intl < "u" && (b = A5);
        var T = new c2(this.options);
        this.store = new b5(this.options.resources, this.options);
        var M = this.services;
        M.logger = Ws, M.resourceStore = this.store, M.languageUtils = T, M.pluralResolver = new O5(T, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), b && (!this.options.interpolation.format || this.options.interpolation.format === m.interpolation.format) && (M.formatter = g(b), M.formatter.init(M, this.options), this.options.interpolation.format = M.formatter.format.bind(M.formatter)), M.interpolator = new C5(this.options), M.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, M.backendConnector = new N5(g(this.modules.backend), M.resourceStore, M, this.options), M.backendConnector.on("*", function(re) {
          for (var X = arguments.length, ae = new Array(X > 1 ? X - 1 : 0), ce = 1; ce < X; ce++)
            ae[ce - 1] = arguments[ce];
          s.emit.apply(s, [re].concat(ae));
        }), this.modules.languageDetector && (M.languageDetector = g(this.modules.languageDetector), M.languageDetector.init && M.languageDetector.init(M, this.options.detection, this.options)), this.modules.i18nFormat && (M.i18nFormat = g(this.modules.i18nFormat), M.i18nFormat.init && M.i18nFormat.init(this)), this.translator = new u2(this.services, this.options), this.translator.on("*", function(re) {
          for (var X = arguments.length, ae = new Array(X > 1 ? X - 1 : 0), ce = 1; ce < X; ce++)
            ae[ce - 1] = arguments[ce];
          s.emit.apply(s, [re].concat(ae));
        }), this.modules.external.forEach(function(re) {
          re.init && re.init(s);
        });
      }
      if (this.format = this.options.interpolation.format, o || (o = Ay), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var I = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        I.length > 0 && I[0] !== "dev" && (this.options.lng = I[0]);
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var A = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      A.forEach(function(re) {
        s[re] = function() {
          var X;
          return (X = s.store)[re].apply(X, arguments);
        };
      });
      var z = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      z.forEach(function(re) {
        s[re] = function() {
          var X;
          return (X = s.store)[re].apply(X, arguments), s;
        };
      });
      var V = Zp(), q = function() {
        var X = function(ce, ve) {
          s.isInitialized && !s.initializedStoreOnce && s.logger.warn("init: i18next is already initialized. You should call init just once!"), s.isInitialized = !0, s.options.isClone || s.logger.log("initialized", s.options), s.emit("initialized", s.options), V.resolve(ve), o(ce, ve);
        };
        if (s.languages && s.options.compatibilityAPI !== "v1" && !s.isInitialized)
          return X(null, s.t.bind(s));
        s.changeLanguage(s.options.lng, X);
      };
      return this.options.resources || !this.options.initImmediate ? q() : setTimeout(q, 0), V;
    }
  }, {
    key: "loadResources",
    value: function(s) {
      var f = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ay, m = o, g = typeof s == "string" ? s : this.language;
      if (typeof s == "function" && (m = s), !this.options.resources || this.options.partialBundledLanguages) {
        if (g && g.toLowerCase() === "cimode")
          return m();
        var b = [], T = function(A) {
          if (!!A) {
            var z = f.services.languageUtils.toResolveHierarchy(A);
            z.forEach(function(V) {
              b.indexOf(V) < 0 && b.push(V);
            });
          }
        };
        if (g)
          T(g);
        else {
          var M = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          M.forEach(function(I) {
            return T(I);
          });
        }
        this.options.preload && this.options.preload.forEach(function(I) {
          return T(I);
        }), this.services.backendConnector.load(b, this.options.ns, function(I) {
          !I && !f.resolvedLanguage && f.language && f.setResolvedLanguage(f.language), m(I);
        });
      } else
        m(null);
    }
  }, {
    key: "reloadResources",
    value: function(s, f, o) {
      var m = Zp();
      return s || (s = this.languages), f || (f = this.options.ns), o || (o = Ay), this.services.backendConnector.reload(s, f, function(g) {
        m.resolve(), o(g);
      }), m;
    }
  }, {
    key: "use",
    value: function(s) {
      if (!s)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!s.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return s.type === "backend" && (this.modules.backend = s), (s.type === "logger" || s.log && s.warn && s.error) && (this.modules.logger = s), s.type === "languageDetector" && (this.modules.languageDetector = s), s.type === "i18nFormat" && (this.modules.i18nFormat = s), s.type === "postProcessor" && $T.addPostProcessor(s), s.type === "formatter" && (this.modules.formatter = s), s.type === "3rdParty" && this.modules.external.push(s), this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function(s) {
      if (!(!s || !this.languages) && !(["cimode", "dev"].indexOf(s) > -1))
        for (var f = 0; f < this.languages.length; f++) {
          var o = this.languages[f];
          if (!(["cimode", "dev"].indexOf(o) > -1) && this.store.hasLanguageSomeTranslations(o)) {
            this.resolvedLanguage = o;
            break;
          }
        }
    }
  }, {
    key: "changeLanguage",
    value: function(s, f) {
      var o = this;
      this.isLanguageChangingTo = s;
      var m = Zp();
      this.emit("languageChanging", s);
      var g = function(I) {
        o.language = I, o.languages = o.services.languageUtils.toResolveHierarchy(I), o.resolvedLanguage = void 0, o.setResolvedLanguage(I);
      }, b = function(I, A) {
        A ? (g(A), o.translator.changeLanguage(A), o.isLanguageChangingTo = void 0, o.emit("languageChanged", A), o.logger.log("languageChanged", A)) : o.isLanguageChangingTo = void 0, m.resolve(function() {
          return o.t.apply(o, arguments);
        }), f && f(I, function() {
          return o.t.apply(o, arguments);
        });
      }, T = function(I) {
        !s && !I && o.services.languageDetector && (I = []);
        var A = typeof I == "string" ? I : o.services.languageUtils.getBestMatchFromCodes(I);
        A && (o.language || g(A), o.translator.language || o.translator.changeLanguage(A), o.services.languageDetector && o.services.languageDetector.cacheUserLanguage && o.services.languageDetector.cacheUserLanguage(A)), o.loadResources(A, function(z) {
          b(z, A);
        });
      };
      return !s && this.services.languageDetector && !this.services.languageDetector.async ? T(this.services.languageDetector.detect()) : !s && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(T) : this.services.languageDetector.detect(T) : T(s), m;
    }
  }, {
    key: "getFixedT",
    value: function(s, f, o) {
      var m = this, g = function b(T, M) {
        var I;
        if (us(M) !== "object") {
          for (var A = arguments.length, z = new Array(A > 2 ? A - 2 : 0), V = 2; V < A; V++)
            z[V - 2] = arguments[V];
          I = m.options.overloadTranslationOptionHandler([T, M].concat(z));
        } else
          I = zs({}, M);
        I.lng = I.lng || b.lng, I.lngs = I.lngs || b.lngs, I.ns = I.ns || b.ns, I.keyPrefix = I.keyPrefix || o || b.keyPrefix;
        var q = m.options.keySeparator || ".", re;
        return I.keyPrefix && Array.isArray(T) ? re = T.map(function(X) {
          return "".concat(I.keyPrefix).concat(q).concat(X);
        }) : re = I.keyPrefix ? "".concat(I.keyPrefix).concat(q).concat(T) : T, m.t(re, I);
      };
      return typeof s == "string" ? g.lng = s : g.lngs = s, g.ns = f, g.keyPrefix = o, g;
    }
  }, {
    key: "t",
    value: function() {
      var s;
      return this.translator && (s = this.translator).translate.apply(s, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var s;
      return this.translator && (s = this.translator).exists.apply(s, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(s) {
      this.options.defaultNS = s;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(s) {
      var f = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var m = this.resolvedLanguage || this.languages[0], g = this.options ? this.options.fallbackLng : !1, b = this.languages[this.languages.length - 1];
      if (m.toLowerCase() === "cimode")
        return !0;
      var T = function(A, z) {
        var V = f.services.backendConnector.state["".concat(A, "|").concat(z)];
        return V === -1 || V === 2;
      };
      if (o.precheck) {
        var M = o.precheck(this, T);
        if (M !== void 0)
          return M;
      }
      return !!(this.hasResourceBundle(m, s) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || T(m, s) && (!g || T(b, s)));
    }
  }, {
    key: "loadNamespaces",
    value: function(s, f) {
      var o = this, m = Zp();
      return this.options.ns ? (typeof s == "string" && (s = [s]), s.forEach(function(g) {
        o.options.ns.indexOf(g) < 0 && o.options.ns.push(g);
      }), this.loadResources(function(g) {
        m.resolve(), f && f(g);
      }), m) : (f && f(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(s, f) {
      var o = Zp();
      typeof s == "string" && (s = [s]);
      var m = this.options.preload || [], g = s.filter(function(b) {
        return m.indexOf(b) < 0;
      });
      return g.length ? (this.options.preload = m.concat(g), this.loadResources(function(b) {
        o.resolve(), f && f(b);
      }), o) : (f && f(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(s) {
      if (s || (s = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !s)
        return "rtl";
      var f = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], o = this.services && this.services.languageUtils || new c2(y2());
      return f.indexOf(o.getLanguagePartFromCode(s)) > -1 || s.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var s = this, f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ay, m = zs(zs(zs({}, this.options), f), {
        isClone: !0
      }), g = new n(m);
      (f.debug !== void 0 || f.prefix !== void 0) && (g.logger = g.logger.clone(f));
      var b = ["store", "services", "language"];
      return b.forEach(function(T) {
        g[T] = s[T];
      }), g.services = zs({}, this.services), g.services.utils = {
        hasLoadedNamespace: g.hasLoadedNamespace.bind(g)
      }, g.translator = new u2(g.services, g.options), g.translator.on("*", function(T) {
        for (var M = arguments.length, I = new Array(M > 1 ? M - 1 : 0), A = 1; A < M; A++)
          I[A - 1] = arguments[A];
        g.emit.apply(g, [T].concat(I));
      }), g.init(m, o), g.translator.options = g.options, g.translator.backendConnector.services.utils = {
        hasLoadedNamespace: g.hasLoadedNamespace.bind(g)
      }, g;
    }
  }, {
    key: "toJSON",
    value: function() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]), n;
}(Vu);
qu(Ug, "createInstance", function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0;
  return new Ug(t, e);
});
var oi = Ug.createInstance();
oi.createInstance = Ug.createInstance;
oi.createInstance;
oi.dir;
oi.init;
oi.loadResources;
oi.reloadResources;
oi.use;
oi.changeLanguage;
oi.getFixedT;
oi.t;
oi.exists;
oi.setDefaultNamespace;
oi.hasLoadedNamespace;
oi.loadNamespaces;
oi.loadLanguages;
const B5 = "/";
var qT = /* @__PURE__ */ ((t) => (t.PNG = "image/png", t.JPG = "image/jpeg", t))(qT || {}), zl = /* @__PURE__ */ ((t) => (t.VALUE = "value", t.RANGE = "range", t))(zl || {}), cg = /* @__PURE__ */ ((t) => (t.DATEPICKER = "datepicker", t.SLIDER = "slider", t))(cg || {});
function V5(t, {
  i18next: e,
  rerenderOn: n = ["languageChanged", "loaded", "added", "removed"]
}) {
  const a = e.t.bind(e), s = Er(new Date()), f = () => s.value = new Date(), o = () => s.value;
  n.forEach((T) => {
    var M;
    switch (T) {
      case "added":
      case "removed":
        (M = e.store) == null || M.on(T, f);
        break;
      default:
        e.on(T, f);
        break;
    }
  }), t.component("i18next", U5), t.mixin({
    beforeCreate() {
      var T, M;
      const I = this.$options;
      if (!I.__i18n && !I.i18nOptions) {
        this.__translate = void 0;
        return;
      }
      const A = this.$options.name, z = (Math.random() * 10 ** 8 | 0).toString(), V = [A, z].filter((ve) => !!ve).join("-");
      this.__bundles = [];
      const q = (ve) => {
        Object.entries(ve).forEach(([Ne, ze]) => {
          e.addResourceBundle(Ne, V, ze, !0, !1), this.__bundles.push([Ne, V]);
        });
      };
      (T = I.__i18n) == null || T.forEach((ve) => {
        q(JSON.parse(ve));
      });
      let { lng: re, ns: X, keyPrefix: ae } = b(I, q);
      (M = this.__bundles) != null && M.length && (X = [V].concat(X != null ? X : []));
      const ce = m(re, X);
      this.__translate = (ve, Ne) => !ae || g(ve) ? ce(ve, Ne) : ce(ae + "." + ve, Ne);
    },
    unmounted() {
      var T;
      (T = this.__bundles) == null || T.forEach(([M, I]) => e.removeResourceBundle(M, I));
    }
  }), t.config.globalProperties.$t = function(T, M) {
    var I;
    return o(), e.isInitialized ? ((I = this == null ? void 0 : this.__translate) != null ? I : a)(T, M) : T;
  }, t.config.globalProperties.$i18next = new Proxy(e, {
    get(T, M) {
      return o(), Reflect.get(T, M);
    }
  });
  function m(T, M) {
    return T ? e.getFixedT(T, M) : M ? e.getFixedT(null, M) : a;
  }
  function g(T) {
    const M = e.options.nsSeparator;
    return typeof M == "string" && T.includes(M);
  }
  function b(T, M) {
    let I, A, z;
    if (T.i18nOptions) {
      let V, q;
      ({
        lng: I,
        namespaces: q = e.options.defaultNS,
        keyPrefix: z,
        messages: V
      } = T.i18nOptions), V && M(V), A = typeof q == "string" ? [q] : q, A && e.loadNamespaces(A);
    }
    return { lng: I, ns: A, keyPrefix: z };
  }
}
function En() {
  const t = wv();
  if (!t)
    throw new Error("i18next-vue: No Vue instance in context. Make sure to register the i18next-vue plugin using app.use(...).");
  const e = t.appContext.config.globalProperties;
  return {
    i18next: e.$i18next,
    t: e.$t.bind(t.proxy)
  };
}
var _2 = new RegExp("{\\s*([a-z0-9\\-]+)\\s*}", "gi"), U5 = ir({
  props: {
    translation: {
      type: String,
      required: !0
    }
  },
  setup(t, { slots: e }) {
    return () => {
      const n = t.translation, a = [];
      let s, f = 0;
      for (; (s = _2.exec(n)) !== null; ) {
        a.push(n.substring(f, s.index));
        const o = e[s[1]];
        o ? a.push(...o()) : a.push(s[0]), f = _2.lastIndex;
      }
      return a.push(n.substring(f)), a;
    };
  }
});
class oh extends Error {
}
class j5 extends oh {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class G5 extends oh {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class $5 extends oh {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class id extends oh {
}
class WT extends oh {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class ka extends oh {
}
class gu extends oh {
  constructor() {
    super("Zone is an abstract class");
  }
}
const Ot = "numeric", fs = "short", ga = "long", jg = {
  year: Ot,
  month: Ot,
  day: Ot
}, HT = {
  year: Ot,
  month: fs,
  day: Ot
}, q5 = {
  year: Ot,
  month: fs,
  day: Ot,
  weekday: fs
}, ZT = {
  year: Ot,
  month: ga,
  day: Ot
}, XT = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga
}, KT = {
  hour: Ot,
  minute: Ot
}, YT = {
  hour: Ot,
  minute: Ot,
  second: Ot
}, JT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: fs
}, QT = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: ga
}, eM = {
  hour: Ot,
  minute: Ot,
  hourCycle: "h23"
}, tM = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23"
}, rM = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23",
  timeZoneName: fs
}, nM = {
  hour: Ot,
  minute: Ot,
  second: Ot,
  hourCycle: "h23",
  timeZoneName: ga
}, iM = {
  year: Ot,
  month: Ot,
  day: Ot,
  hour: Ot,
  minute: Ot
}, oM = {
  year: Ot,
  month: Ot,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot
}, aM = {
  year: Ot,
  month: fs,
  day: Ot,
  hour: Ot,
  minute: Ot
}, sM = {
  year: Ot,
  month: fs,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot
}, W5 = {
  year: Ot,
  month: fs,
  day: Ot,
  weekday: fs,
  hour: Ot,
  minute: Ot
}, lM = {
  year: Ot,
  month: ga,
  day: Ot,
  hour: Ot,
  minute: Ot,
  timeZoneName: fs
}, uM = {
  year: Ot,
  month: ga,
  day: Ot,
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: fs
}, cM = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga,
  hour: Ot,
  minute: Ot,
  timeZoneName: ga
}, hM = {
  year: Ot,
  month: ga,
  day: Ot,
  weekday: ga,
  hour: Ot,
  minute: Ot,
  second: Ot,
  timeZoneName: ga
};
class Yd {
  get type() {
    throw new gu();
  }
  get name() {
    throw new gu();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new gu();
  }
  offsetName(e, n) {
    throw new gu();
  }
  formatOffset(e, n) {
    throw new gu();
  }
  offset(e) {
    throw new gu();
  }
  equals(e) {
    throw new gu();
  }
  get isValid() {
    throw new gu();
  }
}
let K_ = null;
class Av extends Yd {
  static get instance() {
    return K_ === null && (K_ = new Av()), K_;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: n, locale: a }) {
    return pM(e, n, a);
  }
  formatOffset(e, n) {
    return _d(this.offset(e), n);
  }
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  equals(e) {
    return e.type === "system";
  }
  get isValid() {
    return !0;
  }
}
let hg = {};
function H5(t) {
  return hg[t] || (hg[t] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: t,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), hg[t];
}
const Z5 = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function X5(t, e) {
  const n = t.format(e).replace(/\u200E/g, ""), a = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n), [, s, f, o, m, g, b, T] = a;
  return [o, s, f, m, g, b, T];
}
function K5(t, e) {
  const n = t.formatToParts(e), a = [];
  for (let s = 0; s < n.length; s++) {
    const { type: f, value: o } = n[s], m = Z5[f];
    f === "era" ? a[m] = o : Hr(m) || (a[m] = parseInt(o, 10));
  }
  return a;
}
let ky = {};
class $l extends Yd {
  static create(e) {
    return ky[e] || (ky[e] = new $l(e)), ky[e];
  }
  static resetCache() {
    ky = {}, hg = {};
  }
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  static isValidZone(e) {
    if (!e)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = $l.isValidZone(e);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: n, locale: a }) {
    return pM(e, n, a, this.name);
  }
  formatOffset(e, n) {
    return _d(this.offset(e), n);
  }
  offset(e) {
    const n = new Date(e);
    if (isNaN(n))
      return NaN;
    const a = H5(this.name);
    let [s, f, o, m, g, b, T] = a.formatToParts ? K5(a, n) : X5(a, n);
    m === "BC" && (s = -Math.abs(s) + 1);
    const I = Lv({
      year: s,
      month: f,
      day: o,
      hour: g === 24 ? 0 : g,
      minute: b,
      second: T,
      millisecond: 0
    });
    let A = +n;
    const z = A % 1e3;
    return A -= z >= 0 ? z : 1e3 + z, (I - A) / (60 * 1e3);
  }
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
}
let x2 = {};
function Y5(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let a = x2[n];
  return a || (a = new Intl.ListFormat(t, e), x2[n] = a), a;
}
let tx = {};
function rx(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let a = tx[n];
  return a || (a = new Intl.DateTimeFormat(t, e), tx[n] = a), a;
}
let nx = {};
function J5(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let a = nx[n];
  return a || (a = new Intl.NumberFormat(t, e), nx[n] = a), a;
}
let ix = {};
function Q5(t, e = {}) {
  const { base: n, ...a } = e, s = JSON.stringify([t, a]);
  let f = ix[s];
  return f || (f = new Intl.RelativeTimeFormat(t, e), ix[s] = f), f;
}
let od = null;
function ez() {
  return od || (od = new Intl.DateTimeFormat().resolvedOptions().locale, od);
}
function tz(t) {
  const e = t.indexOf("-x-");
  e !== -1 && (t = t.substring(0, e));
  const n = t.indexOf("-u-");
  if (n === -1)
    return [t];
  {
    let a, s;
    try {
      a = rx(t).resolvedOptions(), s = t;
    } catch {
      const g = t.substring(0, n);
      a = rx(g).resolvedOptions(), s = g;
    }
    const { numberingSystem: f, calendar: o } = a;
    return [s, f, o];
  }
}
function rz(t, e, n) {
  return (n || e) && (t.includes("-u-") || (t += "-u"), n && (t += `-ca-${n}`), e && (t += `-nu-${e}`)), t;
}
function nz(t) {
  const e = [];
  for (let n = 1; n <= 12; n++) {
    const a = br.utc(2009, n, 1);
    e.push(t(a));
  }
  return e;
}
function iz(t) {
  const e = [];
  for (let n = 1; n <= 7; n++) {
    const a = br.utc(2016, 11, 13 + n);
    e.push(t(a));
  }
  return e;
}
function Ly(t, e, n, a) {
  const s = t.listingMode();
  return s === "error" ? null : s === "en" ? n(e) : a(e);
}
function oz(t) {
  return t.numberingSystem && t.numberingSystem !== "latn" ? !1 : t.numberingSystem === "latn" || !t.locale || t.locale.startsWith("en") || new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem === "latn";
}
class az {
  constructor(e, n, a) {
    this.padTo = a.padTo || 0, this.floor = a.floor || !1;
    const { padTo: s, floor: f, ...o } = a;
    if (!n || Object.keys(o).length > 0) {
      const m = { useGrouping: !1, ...a };
      a.padTo > 0 && (m.minimumIntegerDigits = a.padTo), this.inf = J5(e, m);
    }
  }
  format(e) {
    if (this.inf) {
      const n = this.floor ? Math.floor(e) : e;
      return this.inf.format(n);
    } else {
      const n = this.floor ? Math.floor(e) : Yx(e, 3);
      return Pi(n, this.padTo);
    }
  }
}
class sz {
  constructor(e, n, a) {
    this.opts = a, this.originalZone = void 0;
    let s;
    if (this.opts.timeZone)
      this.dt = e;
    else if (e.zone.type === "fixed") {
      const o = -1 * (e.offset / 60), m = o >= 0 ? `Etc/GMT+${o}` : `Etc/GMT${o}`;
      e.offset !== 0 && $l.create(m).valid ? (s = m, this.dt = e) : (s = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    } else
      e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, s = e.zone.name) : (s = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    const f = { ...this.opts };
    f.timeZone = f.timeZone || s, this.dtf = rx(n, f);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? e.map((n) => {
      if (n.type === "timeZoneName") {
        const a = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...n,
          value: a
        };
      } else
        return n;
    }) : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class lz {
  constructor(e, n, a) {
    this.opts = { style: "long", ...a }, !n && fM() && (this.rtf = Q5(e, a));
  }
  format(e, n) {
    return this.rtf ? this.rtf.format(e, n) : Mz(n, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, n) {
    return this.rtf ? this.rtf.formatToParts(e, n) : [];
  }
}
class Fn {
  static fromOpts(e) {
    return Fn.create(e.locale, e.numberingSystem, e.outputCalendar, e.defaultToEN);
  }
  static create(e, n, a, s = !1) {
    const f = e || Ci.defaultLocale, o = f || (s ? "en-US" : ez()), m = n || Ci.defaultNumberingSystem, g = a || Ci.defaultOutputCalendar;
    return new Fn(o, m, g, f);
  }
  static resetCache() {
    od = null, tx = {}, nx = {}, ix = {};
  }
  static fromObject({ locale: e, numberingSystem: n, outputCalendar: a } = {}) {
    return Fn.create(e, n, a);
  }
  constructor(e, n, a, s) {
    const [f, o, m] = tz(e);
    this.locale = f, this.numberingSystem = n || o || null, this.outputCalendar = a || m || null, this.intl = rz(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = s, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = oz(this)), this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish(), n = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && n ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : Fn.create(
      e.locale || this.specifiedLocale,
      e.numberingSystem || this.numberingSystem,
      e.outputCalendar || this.outputCalendar,
      e.defaultToEN || !1
    );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, n = !1) {
    return Ly(this, e, yM, () => {
      const a = n ? { month: e, day: "numeric" } : { month: e }, s = n ? "format" : "standalone";
      return this.monthsCache[s][e] || (this.monthsCache[s][e] = nz((f) => this.extract(f, a, "month"))), this.monthsCache[s][e];
    });
  }
  weekdays(e, n = !1) {
    return Ly(this, e, _M, () => {
      const a = n ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, s = n ? "format" : "standalone";
      return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = iz(
        (f) => this.extract(f, a, "weekday")
      )), this.weekdaysCache[s][e];
    });
  }
  meridiems() {
    return Ly(
      this,
      void 0,
      () => xM,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [br.utc(2016, 11, 13, 9), br.utc(2016, 11, 13, 19)].map(
            (n) => this.extract(n, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return Ly(this, e, bM, () => {
      const n = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [br.utc(-40, 1, 1), br.utc(2017, 1, 1)].map(
        (a) => this.extract(a, n, "era")
      )), this.eraCache[e];
    });
  }
  extract(e, n, a) {
    const s = this.dtFormatter(e, n), f = s.formatToParts(), o = f.find((m) => m.type.toLowerCase() === a);
    return o ? o.value : null;
  }
  numberFormatter(e = {}) {
    return new az(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, n = {}) {
    return new sz(e, this.intl, n);
  }
  relFormatter(e = {}) {
    return new lz(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return Y5(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
}
let Y_ = null;
class Fo extends Yd {
  static get utcInstance() {
    return Y_ === null && (Y_ = new Fo(0)), Y_;
  }
  static instance(e) {
    return e === 0 ? Fo.utcInstance : new Fo(e);
  }
  static parseSpecifier(e) {
    if (e) {
      const n = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (n)
        return new Fo(Dv(n[1], n[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${_d(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${_d(-this.fixed, "narrow")}`;
  }
  offsetName() {
    return this.name;
  }
  formatOffset(e, n) {
    return _d(this.fixed, n);
  }
  get isUniversal() {
    return !0;
  }
  offset() {
    return this.fixed;
  }
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  get isValid() {
    return !0;
  }
}
class uz extends Yd {
  constructor(e) {
    super(), this.zoneName = e;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return !1;
  }
  get isValid() {
    return !1;
  }
}
function Iu(t, e) {
  if (Hr(t) || t === null)
    return e;
  if (t instanceof Yd)
    return t;
  if (cz(t)) {
    const n = t.toLowerCase();
    return n === "default" ? e : n === "local" || n === "system" ? Av.instance : n === "utc" || n === "gmt" ? Fo.utcInstance : Fo.parseSpecifier(n) || $l.create(t);
  } else
    return Xc(t) ? Fo.instance(t) : typeof t == "object" && "offset" in t && typeof t.offset == "function" ? t : new uz(t);
}
let b2 = () => Date.now(), w2 = "system", E2 = null, S2 = null, T2 = null, M2 = 60, I2;
class Ci {
  static get now() {
    return b2;
  }
  static set now(e) {
    b2 = e;
  }
  static set defaultZone(e) {
    w2 = e;
  }
  static get defaultZone() {
    return Iu(w2, Av.instance);
  }
  static get defaultLocale() {
    return E2;
  }
  static set defaultLocale(e) {
    E2 = e;
  }
  static get defaultNumberingSystem() {
    return S2;
  }
  static set defaultNumberingSystem(e) {
    S2 = e;
  }
  static get defaultOutputCalendar() {
    return T2;
  }
  static set defaultOutputCalendar(e) {
    T2 = e;
  }
  static get twoDigitCutoffYear() {
    return M2;
  }
  static set twoDigitCutoffYear(e) {
    M2 = e % 100;
  }
  static get throwOnInvalid() {
    return I2;
  }
  static set throwOnInvalid(e) {
    I2 = e;
  }
  static resetCaches() {
    Fn.resetCache(), $l.resetCache();
  }
}
function Hr(t) {
  return typeof t > "u";
}
function Xc(t) {
  return typeof t == "number";
}
function kv(t) {
  return typeof t == "number" && t % 1 === 0;
}
function cz(t) {
  return typeof t == "string";
}
function hz(t) {
  return Object.prototype.toString.call(t) === "[object Date]";
}
function fM() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function fz(t) {
  return Array.isArray(t) ? t : [t];
}
function O2(t, e, n) {
  if (t.length !== 0)
    return t.reduce((a, s) => {
      const f = [e(s), s];
      return a && n(a[0], f[0]) === a[0] ? a : f;
    }, null)[1];
}
function pz(t, e) {
  return e.reduce((n, a) => (n[a] = t[a], n), {});
}
function zf(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function Fl(t, e, n) {
  return kv(t) && t >= e && t <= n;
}
function dz(t, e) {
  return t - e * Math.floor(t / e);
}
function Pi(t, e = 2) {
  const n = t < 0;
  let a;
  return n ? a = "-" + ("" + -t).padStart(e, "0") : a = ("" + t).padStart(e, "0"), a;
}
function Eu(t) {
  if (!(Hr(t) || t === null || t === ""))
    return parseInt(t, 10);
}
function Pc(t) {
  if (!(Hr(t) || t === null || t === ""))
    return parseFloat(t);
}
function Kx(t) {
  if (!(Hr(t) || t === null || t === "")) {
    const e = parseFloat("0." + t) * 1e3;
    return Math.floor(e);
  }
}
function mz(t) {
  return t > 0 ? Math.floor(t) : Math.ceil(t);
}
function Yx(t, e, n = !1) {
  const a = 10 ** e;
  return (n ? Math.trunc : Math.round)(t * a) / a;
}
function Jd(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function vd(t) {
  return Jd(t) ? 366 : 365;
}
function Gg(t, e) {
  const n = dz(e - 1, 12) + 1, a = t + (e - n) / 12;
  return n === 2 ? Jd(a) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1];
}
function Lv(t) {
  let e = Date.UTC(
    t.year,
    t.month - 1,
    t.day,
    t.hour,
    t.minute,
    t.second,
    t.millisecond
  );
  return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(t.year, t.month - 1, t.day)), +e;
}
function $g(t) {
  const e = (t + Math.floor(t / 4) - Math.floor(t / 100) + Math.floor(t / 400)) % 7, n = t - 1, a = (n + Math.floor(n / 4) - Math.floor(n / 100) + Math.floor(n / 400)) % 7;
  return e === 4 || a === 3 ? 53 : 52;
}
function ox(t) {
  return t > 99 ? t : t > Ci.twoDigitCutoffYear ? 1900 + t : 2e3 + t;
}
function pM(t, e, n, a = null) {
  const s = new Date(t), f = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  a && (f.timeZone = a);
  const o = { timeZoneName: e, ...f }, m = new Intl.DateTimeFormat(n, o).formatToParts(s).find((g) => g.type.toLowerCase() === "timezonename");
  return m ? m.value : null;
}
function Dv(t, e) {
  let n = parseInt(t, 10);
  Number.isNaN(n) && (n = 0);
  const a = parseInt(e, 10) || 0, s = n < 0 || Object.is(n, -0) ? -a : a;
  return n * 60 + s;
}
function dM(t) {
  const e = Number(t);
  if (typeof t == "boolean" || t === "" || Number.isNaN(e))
    throw new ka(`Invalid unit value ${t}`);
  return e;
}
function qg(t, e) {
  const n = {};
  for (const a in t)
    if (zf(t, a)) {
      const s = t[a];
      if (s == null)
        continue;
      n[e(a)] = dM(s);
    }
  return n;
}
function _d(t, e) {
  const n = Math.trunc(Math.abs(t / 60)), a = Math.trunc(Math.abs(t % 60)), s = t >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${s}${Pi(n, 2)}:${Pi(a, 2)}`;
    case "narrow":
      return `${s}${n}${a > 0 ? `:${a}` : ""}`;
    case "techie":
      return `${s}${Pi(n, 2)}${Pi(a, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function Nv(t) {
  return pz(t, ["hour", "minute", "second", "millisecond"]);
}
const yz = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], mM = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], gz = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function yM(t) {
  switch (t) {
    case "narrow":
      return [...gz];
    case "short":
      return [...mM];
    case "long":
      return [...yz];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const gM = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], vM = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], vz = ["M", "T", "W", "T", "F", "S", "S"];
function _M(t) {
  switch (t) {
    case "narrow":
      return [...vz];
    case "short":
      return [...vM];
    case "long":
      return [...gM];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const xM = ["AM", "PM"], _z = ["Before Christ", "Anno Domini"], xz = ["BC", "AD"], bz = ["B", "A"];
function bM(t) {
  switch (t) {
    case "narrow":
      return [...bz];
    case "short":
      return [...xz];
    case "long":
      return [..._z];
    default:
      return null;
  }
}
function wz(t) {
  return xM[t.hour < 12 ? 0 : 1];
}
function Ez(t, e) {
  return _M(e)[t.weekday - 1];
}
function Sz(t, e) {
  return yM(e)[t.month - 1];
}
function Tz(t, e) {
  return bM(e)[t.year < 0 ? 0 : 1];
}
function Mz(t, e, n = "always", a = !1) {
  const s = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, f = ["hours", "minutes", "seconds"].indexOf(t) === -1;
  if (n === "auto" && f) {
    const M = t === "days";
    switch (e) {
      case 1:
        return M ? "tomorrow" : `next ${s[t][0]}`;
      case -1:
        return M ? "yesterday" : `last ${s[t][0]}`;
      case 0:
        return M ? "today" : `this ${s[t][0]}`;
    }
  }
  const o = Object.is(e, -0) || e < 0, m = Math.abs(e), g = m === 1, b = s[t], T = a ? g ? b[1] : b[2] || b[1] : g ? s[t][0] : t;
  return o ? `${m} ${T} ago` : `in ${m} ${T}`;
}
function C2(t, e) {
  let n = "";
  for (const a of t)
    a.literal ? n += a.val : n += e(a.val);
  return n;
}
const Iz = {
  D: jg,
  DD: HT,
  DDD: ZT,
  DDDD: XT,
  t: KT,
  tt: YT,
  ttt: JT,
  tttt: QT,
  T: eM,
  TT: tM,
  TTT: rM,
  TTTT: nM,
  f: iM,
  ff: aM,
  fff: lM,
  ffff: cM,
  F: oM,
  FF: sM,
  FFF: uM,
  FFFF: hM
};
class bo {
  static create(e, n = {}) {
    return new bo(e, n);
  }
  static parseFormat(e) {
    let n = null, a = "", s = !1;
    const f = [];
    for (let o = 0; o < e.length; o++) {
      const m = e.charAt(o);
      m === "'" ? (a.length > 0 && f.push({ literal: s || /^\s+$/.test(a), val: a }), n = null, a = "", s = !s) : s || m === n ? a += m : (a.length > 0 && f.push({ literal: /^\s+$/.test(a), val: a }), a = m, n = m);
    }
    return a.length > 0 && f.push({ literal: s || /^\s+$/.test(a), val: a }), f;
  }
  static macroTokenToFormatOpts(e) {
    return Iz[e];
  }
  constructor(e, n) {
    this.opts = n, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, n) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...n }).format();
  }
  dtFormatter(e, n = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...n });
  }
  formatDateTime(e, n) {
    return this.dtFormatter(e, n).format();
  }
  formatDateTimeParts(e, n) {
    return this.dtFormatter(e, n).formatToParts();
  }
  formatInterval(e, n) {
    return this.dtFormatter(e.start, n).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, n) {
    return this.dtFormatter(e, n).resolvedOptions();
  }
  num(e, n = 0) {
    if (this.opts.forceSimple)
      return Pi(e, n);
    const a = { ...this.opts };
    return n > 0 && (a.padTo = n), this.loc.numberFormatter(a).format(e);
  }
  formatDateTimeFromString(e, n) {
    const a = this.loc.listingMode() === "en", s = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", f = (A, z) => this.loc.extract(e, A, z), o = (A) => e.isOffsetFixed && e.offset === 0 && A.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, A.format) : "", m = () => a ? wz(e) : f({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), g = (A, z) => a ? Sz(e, A) : f(z ? { month: A } : { month: A, day: "numeric" }, "month"), b = (A, z) => a ? Ez(e, A) : f(
      z ? { weekday: A } : { weekday: A, month: "long", day: "numeric" },
      "weekday"
    ), T = (A) => {
      const z = bo.macroTokenToFormatOpts(A);
      return z ? this.formatWithSystemDefault(e, z) : A;
    }, M = (A) => a ? Tz(e, A) : f({ era: A }, "era"), I = (A) => {
      switch (A) {
        case "S":
          return this.num(e.millisecond);
        case "u":
        case "SSS":
          return this.num(e.millisecond, 3);
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        case "Z":
          return o({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return o({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return o({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return e.zoneName;
        case "a":
          return m();
        case "d":
          return s ? f({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return s ? f({ day: "2-digit" }, "day") : this.num(e.day, 2);
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return b("short", !0);
        case "cccc":
          return b("long", !0);
        case "ccccc":
          return b("narrow", !0);
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return b("short", !1);
        case "EEEE":
          return b("long", !1);
        case "EEEEE":
          return b("narrow", !1);
        case "L":
          return s ? f({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return s ? f({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return g("short", !0);
        case "LLLL":
          return g("long", !0);
        case "LLLLL":
          return g("narrow", !0);
        case "M":
          return s ? f({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return s ? f({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return g("short", !1);
        case "MMMM":
          return g("long", !1);
        case "MMMMM":
          return g("narrow", !1);
        case "y":
          return s ? f({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return s ? f({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return s ? f({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return s ? f({ year: "numeric" }, "year") : this.num(e.year, 6);
        case "G":
          return M("short");
        case "GG":
          return M("long");
        case "GGGGG":
          return M("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return T(A);
      }
    };
    return C2(bo.parseFormat(n), I);
  }
  formatDurationFromString(e, n) {
    const a = (g) => {
      switch (g[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, s = (g) => (b) => {
      const T = a(b);
      return T ? this.num(g.get(T), b.length) : b;
    }, f = bo.parseFormat(n), o = f.reduce(
      (g, { literal: b, val: T }) => b ? g : g.concat(T),
      []
    ), m = e.shiftTo(...o.map(a).filter((g) => g));
    return C2(f, s(m));
  }
}
class os {
  constructor(e, n) {
    this.reason = e, this.explanation = n;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const wM = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function Uf(...t) {
  const e = t.reduce((n, a) => n + a.source, "");
  return RegExp(`^${e}$`);
}
function jf(...t) {
  return (e) => t.reduce(
    ([n, a, s], f) => {
      const [o, m, g] = f(e, s);
      return [{ ...n, ...o }, m || a, g];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function Gf(t, ...e) {
  if (t == null)
    return [null, null];
  for (const [n, a] of e) {
    const s = n.exec(t);
    if (s)
      return a(s);
  }
  return [null, null];
}
function EM(...t) {
  return (e, n) => {
    const a = {};
    let s;
    for (s = 0; s < t.length; s++)
      a[t[s]] = Eu(e[n + s]);
    return [a, null, n + s];
  };
}
const SM = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, Oz = `(?:${SM.source}?(?:\\[(${wM.source})\\])?)?`, Jx = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, TM = RegExp(`${Jx.source}${Oz}`), Qx = RegExp(`(?:T${TM.source})?`), Cz = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, Pz = /(\d{4})-?W(\d\d)(?:-?(\d))?/, Az = /(\d{4})-?(\d{3})/, kz = EM("weekYear", "weekNumber", "weekDay"), Lz = EM("year", "ordinal"), Dz = /(\d{4})-(\d\d)-(\d\d)/, MM = RegExp(
  `${Jx.source} ?(?:${SM.source}|(${wM.source}))?`
), Nz = RegExp(`(?: ${MM.source})?`);
function Of(t, e, n) {
  const a = t[e];
  return Hr(a) ? n : Eu(a);
}
function Rz(t, e) {
  return [{
    year: Of(t, e),
    month: Of(t, e + 1, 1),
    day: Of(t, e + 2, 1)
  }, null, e + 3];
}
function $f(t, e) {
  return [{
    hours: Of(t, e, 0),
    minutes: Of(t, e + 1, 0),
    seconds: Of(t, e + 2, 0),
    milliseconds: Kx(t[e + 3])
  }, null, e + 4];
}
function Qd(t, e) {
  const n = !t[e] && !t[e + 1], a = Dv(t[e + 1], t[e + 2]), s = n ? null : Fo.instance(a);
  return [{}, s, e + 3];
}
function em(t, e) {
  const n = t[e] ? $l.create(t[e]) : null;
  return [{}, n, e + 1];
}
const zz = RegExp(`^T?${Jx.source}$`), Fz = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function Bz(t) {
  const [e, n, a, s, f, o, m, g, b] = t, T = e[0] === "-", M = g && g[0] === "-", I = (A, z = !1) => A !== void 0 && (z || A && T) ? -A : A;
  return [
    {
      years: I(Pc(n)),
      months: I(Pc(a)),
      weeks: I(Pc(s)),
      days: I(Pc(f)),
      hours: I(Pc(o)),
      minutes: I(Pc(m)),
      seconds: I(Pc(g), g === "-0"),
      milliseconds: I(Kx(b), M)
    }
  ];
}
const Vz = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function e1(t, e, n, a, s, f, o) {
  const m = {
    year: e.length === 2 ? ox(Eu(e)) : Eu(e),
    month: mM.indexOf(n) + 1,
    day: Eu(a),
    hour: Eu(s),
    minute: Eu(f)
  };
  return o && (m.second = Eu(o)), t && (m.weekday = t.length > 3 ? gM.indexOf(t) + 1 : vM.indexOf(t) + 1), m;
}
const Uz = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function jz(t) {
  const [
    ,
    e,
    n,
    a,
    s,
    f,
    o,
    m,
    g,
    b,
    T,
    M
  ] = t, I = e1(e, s, a, n, f, o, m);
  let A;
  return g ? A = Vz[g] : b ? A = 0 : A = Dv(T, M), [I, new Fo(A)];
}
function Gz(t) {
  return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const $z = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, qz = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Wz = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function P2(t) {
  const [, e, n, a, s, f, o, m] = t;
  return [e1(e, s, a, n, f, o, m), Fo.utcInstance];
}
function Hz(t) {
  const [, e, n, a, s, f, o, m] = t;
  return [e1(e, m, n, a, s, f, o), Fo.utcInstance];
}
const Zz = Uf(Cz, Qx), Xz = Uf(Pz, Qx), Kz = Uf(Az, Qx), Yz = Uf(TM), IM = jf(
  Rz,
  $f,
  Qd,
  em
), Jz = jf(
  kz,
  $f,
  Qd,
  em
), Qz = jf(
  Lz,
  $f,
  Qd,
  em
), e6 = jf(
  $f,
  Qd,
  em
);
function t6(t) {
  return Gf(
    t,
    [Zz, IM],
    [Xz, Jz],
    [Kz, Qz],
    [Yz, e6]
  );
}
function r6(t) {
  return Gf(Gz(t), [Uz, jz]);
}
function n6(t) {
  return Gf(
    t,
    [$z, P2],
    [qz, P2],
    [Wz, Hz]
  );
}
function i6(t) {
  return Gf(t, [Fz, Bz]);
}
const o6 = jf($f);
function a6(t) {
  return Gf(t, [zz, o6]);
}
const s6 = Uf(Dz, Nz), l6 = Uf(MM), u6 = jf(
  $f,
  Qd,
  em
);
function c6(t) {
  return Gf(
    t,
    [s6, IM],
    [l6, u6]
  );
}
const A2 = "Invalid Duration", OM = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, h6 = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...OM
}, Oa = 146097 / 400, sf = 146097 / 4800, f6 = {
  years: {
    quarters: 4,
    months: 12,
    weeks: Oa / 7,
    days: Oa,
    hours: Oa * 24,
    minutes: Oa * 24 * 60,
    seconds: Oa * 24 * 60 * 60,
    milliseconds: Oa * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: Oa / 28,
    days: Oa / 4,
    hours: Oa * 24 / 4,
    minutes: Oa * 24 * 60 / 4,
    seconds: Oa * 24 * 60 * 60 / 4,
    milliseconds: Oa * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: sf / 7,
    days: sf,
    hours: sf * 24,
    minutes: sf * 24 * 60,
    seconds: sf * 24 * 60 * 60,
    milliseconds: sf * 24 * 60 * 60 * 1e3
  },
  ...OM
}, Fc = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], CM = Fc.slice(0).reverse();
function vu(t, e, n = !1) {
  const a = {
    values: n ? e.values : { ...t.values, ...e.values || {} },
    loc: t.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy,
    matrix: e.matrix || t.matrix
  };
  return new Yr(a);
}
function k2(t) {
  return Math.trunc(t * 1e3) / 1e3;
}
function PM(t, e, n, a, s) {
  const f = t[s][n], o = e[n] / f, m = mz(o);
  a[s] = k2(a[s] + m), e[n] = k2(e[n] - m * f);
}
function p6(t, e) {
  CM.reduce((n, a) => Hr(e[a]) ? n : (n && PM(t, e, n, e, a), a), null);
}
function d6(t) {
  const e = {};
  for (const [n, a] of Object.entries(t))
    a !== 0 && (e[n] = a);
  return e;
}
class Yr {
  constructor(e) {
    const n = e.conversionAccuracy === "longterm" || !1;
    let a = n ? f6 : h6;
    e.matrix && (a = e.matrix), this.values = e.values, this.loc = e.loc || Fn.create(), this.conversionAccuracy = n ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = a, this.isLuxonDuration = !0;
  }
  static fromMillis(e, n) {
    return Yr.fromObject({ milliseconds: e }, n);
  }
  static fromObject(e, n = {}) {
    if (e == null || typeof e != "object")
      throw new ka(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
      );
    return new Yr({
      values: qg(e, Yr.normalizeUnit),
      loc: Fn.fromObject(n),
      conversionAccuracy: n.conversionAccuracy,
      matrix: n.matrix
    });
  }
  static fromDurationLike(e) {
    if (Xc(e))
      return Yr.fromMillis(e);
    if (Yr.isDuration(e))
      return e;
    if (typeof e == "object")
      return Yr.fromObject(e);
    throw new ka(
      `Unknown duration argument ${e} of type ${typeof e}`
    );
  }
  static fromISO(e, n) {
    const [a] = i6(e);
    return a ? Yr.fromObject(a, n) : Yr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static fromISOTime(e, n) {
    const [a] = a6(e);
    return a ? Yr.fromObject(a, n) : Yr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static invalid(e, n = null) {
    if (!e)
      throw new ka("need to specify a reason the Duration is invalid");
    const a = e instanceof os ? e : new os(e, n);
    if (Ci.throwOnInvalid)
      throw new $5(a);
    return new Yr({ invalid: a });
  }
  static normalizeUnit(e) {
    const n = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[e && e.toLowerCase()];
    if (!n)
      throw new WT(e);
    return n;
  }
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(e, n = {}) {
    const a = {
      ...n,
      floor: n.round !== !1 && n.floor !== !1
    };
    return this.isValid ? bo.create(this.loc, a).formatDurationFromString(this, e) : A2;
  }
  toHuman(e = {}) {
    if (!this.isValid)
      return A2;
    const n = Fc.map((a) => {
      const s = this.values[a];
      return Hr(s) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: a.slice(0, -1) }).format(s);
    }).filter((a) => a);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(n);
  }
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  toISO() {
    if (!this.isValid)
      return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += Yx(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  toISOTime(e = {}) {
    if (!this.isValid)
      return null;
    const n = this.toMillis();
    return n < 0 || n >= 864e5 ? null : (e = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...e,
      includeOffset: !1
    }, br.fromMillis(n, { zone: "UTC" }).toISOTime(e));
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  toMillis() {
    var n;
    if (!this.isValid)
      return NaN;
    let e = (n = this.values.milliseconds) != null ? n : 0;
    for (let a of CM.slice(1))
      this.values[a] && (e += this.values[a] * this.matrix[a].milliseconds);
    return e;
  }
  valueOf() {
    return this.toMillis();
  }
  plus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e), a = {};
    for (const s of Fc)
      (zf(n.values, s) || zf(this.values, s)) && (a[s] = n.get(s) + this.get(s));
    return vu(this, { values: a }, !0);
  }
  minus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e);
    return this.plus(n.negate());
  }
  mapUnits(e) {
    if (!this.isValid)
      return this;
    const n = {};
    for (const a of Object.keys(this.values))
      n[a] = dM(e(this.values[a], a));
    return vu(this, { values: n }, !0);
  }
  get(e) {
    return this[Yr.normalizeUnit(e)];
  }
  set(e) {
    if (!this.isValid)
      return this;
    const n = { ...this.values, ...qg(e, Yr.normalizeUnit) };
    return vu(this, { values: n });
  }
  reconfigure({ locale: e, numberingSystem: n, conversionAccuracy: a, matrix: s } = {}) {
    const o = { loc: this.loc.clone({ locale: e, numberingSystem: n }), matrix: s, conversionAccuracy: a };
    return vu(this, o);
  }
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  normalize() {
    if (!this.isValid)
      return this;
    const e = this.toObject();
    return this.valueOf() >= 0 ? (p6(this.matrix, e), vu(this, { values: e }, !0)) : this.negate().normalize().negate();
  }
  rescale() {
    if (!this.isValid)
      return this;
    const e = d6(this.normalize().shiftToAll().toObject());
    return vu(this, { values: e }, !0);
  }
  shiftTo(...e) {
    if (!this.isValid)
      return this;
    if (e.length === 0)
      return this;
    e = e.map((o) => Yr.normalizeUnit(o));
    const n = {}, a = {}, s = this.toObject();
    let f;
    for (const o of Fc)
      if (e.indexOf(o) >= 0) {
        f = o;
        let m = 0;
        for (const b in a)
          m += this.matrix[b][o] * a[b], a[b] = 0;
        Xc(s[o]) && (m += s[o]);
        const g = Math.trunc(m);
        n[o] = g, a[o] = (m * 1e3 - g * 1e3) / 1e3;
        for (const b in s)
          Fc.indexOf(b) > Fc.indexOf(o) && PM(this.matrix, s, b, n, o);
      } else
        Xc(s[o]) && (a[o] = s[o]);
    for (const o in a)
      a[o] !== 0 && (n[f] += o === f ? a[o] : a[o] / this.matrix[f][o]);
    return vu(this, { values: n }, !0).normalize();
  }
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  negate() {
    if (!this.isValid)
      return this;
    const e = {};
    for (const n of Object.keys(this.values))
      e[n] = this.values[n] === 0 ? 0 : -this.values[n];
    return vu(this, { values: e }, !0);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
      return !1;
    function n(a, s) {
      return a === void 0 || a === 0 ? s === void 0 || s === 0 : a === s;
    }
    for (const a of Fc)
      if (!n(this.values[a], e.values[a]))
        return !1;
    return !0;
  }
}
const lf = "Invalid Interval";
function m6(t, e) {
  return !t || !t.isValid ? pi.invalid("missing or invalid start") : !e || !e.isValid ? pi.invalid("missing or invalid end") : e < t ? pi.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`
  ) : null;
}
class pi {
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  static invalid(e, n = null) {
    if (!e)
      throw new ka("need to specify a reason the Interval is invalid");
    const a = e instanceof os ? e : new os(e, n);
    if (Ci.throwOnInvalid)
      throw new G5(a);
    return new pi({ invalid: a });
  }
  static fromDateTimes(e, n) {
    const a = Kp(e), s = Kp(n), f = m6(a, s);
    return f == null ? new pi({
      start: a,
      end: s
    }) : f;
  }
  static after(e, n) {
    const a = Yr.fromDurationLike(n), s = Kp(e);
    return pi.fromDateTimes(s, s.plus(a));
  }
  static before(e, n) {
    const a = Yr.fromDurationLike(n), s = Kp(e);
    return pi.fromDateTimes(s.minus(a), s);
  }
  static fromISO(e, n) {
    const [a, s] = (e || "").split("/", 2);
    if (a && s) {
      let f, o;
      try {
        f = br.fromISO(a, n), o = f.isValid;
      } catch {
        o = !1;
      }
      let m, g;
      try {
        m = br.fromISO(s, n), g = m.isValid;
      } catch {
        g = !1;
      }
      if (o && g)
        return pi.fromDateTimes(f, m);
      if (o) {
        const b = Yr.fromISO(s, n);
        if (b.isValid)
          return pi.after(f, b);
      } else if (g) {
        const b = Yr.fromISO(a, n);
        if (b.isValid)
          return pi.before(m, b);
      }
    }
    return pi.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  count(e = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const n = this.start.startOf(e), a = this.end.startOf(e);
    return Math.floor(a.diff(n, e).get(e)) + (a.valueOf() !== this.end.valueOf());
  }
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  set({ start: e, end: n } = {}) {
    return this.isValid ? pi.fromDateTimes(e || this.s, n || this.e) : this;
  }
  splitAt(...e) {
    if (!this.isValid)
      return [];
    const n = e.map(Kp).filter((o) => this.contains(o)).sort(), a = [];
    let { s } = this, f = 0;
    for (; s < this.e; ) {
      const o = n[f] || this.e, m = +o > +this.e ? this.e : o;
      a.push(pi.fromDateTimes(s, m)), s = m, f += 1;
    }
    return a;
  }
  splitBy(e) {
    const n = Yr.fromDurationLike(e);
    if (!this.isValid || !n.isValid || n.as("milliseconds") === 0)
      return [];
    let { s: a } = this, s = 1, f;
    const o = [];
    for (; a < this.e; ) {
      const m = this.start.plus(n.mapUnits((g) => g * s));
      f = +m > +this.e ? this.e : m, o.push(pi.fromDateTimes(a, f)), a = f, s += 1;
    }
    return o;
  }
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  intersection(e) {
    if (!this.isValid)
      return this;
    const n = this.s > e.s ? this.s : e.s, a = this.e < e.e ? this.e : e.e;
    return n >= a ? null : pi.fromDateTimes(n, a);
  }
  union(e) {
    if (!this.isValid)
      return this;
    const n = this.s < e.s ? this.s : e.s, a = this.e > e.e ? this.e : e.e;
    return pi.fromDateTimes(n, a);
  }
  static merge(e) {
    const [n, a] = e.sort((s, f) => s.s - f.s).reduce(
      ([s, f], o) => f ? f.overlaps(o) || f.abutsStart(o) ? [s, f.union(o)] : [s.concat([f]), o] : [s, o],
      [[], null]
    );
    return a && n.push(a), n;
  }
  static xor(e) {
    let n = null, a = 0;
    const s = [], f = e.map((g) => [
      { time: g.s, type: "s" },
      { time: g.e, type: "e" }
    ]), o = Array.prototype.concat(...f), m = o.sort((g, b) => g.time - b.time);
    for (const g of m)
      a += g.type === "s" ? 1 : -1, a === 1 ? n = g.time : (n && +n != +g.time && s.push(pi.fromDateTimes(n, g.time)), n = null);
    return pi.merge(s);
  }
  difference(...e) {
    return pi.xor([this].concat(e)).map((n) => this.intersection(n)).filter((n) => n && !n.isEmpty());
  }
  toString() {
    return this.isValid ? `[${this.s.toISO()} \u2013 ${this.e.toISO()})` : lf;
  }
  toLocaleString(e = jg, n = {}) {
    return this.isValid ? bo.create(this.s.loc.clone(n), e).formatInterval(this) : lf;
  }
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : lf;
  }
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : lf;
  }
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : lf;
  }
  toFormat(e, { separator: n = " \u2013 " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${n}${this.e.toFormat(e)}` : lf;
  }
  toDuration(e, n) {
    return this.isValid ? this.e.diff(this.s, e, n) : Yr.invalid(this.invalidReason);
  }
  mapEndpoints(e) {
    return pi.fromDateTimes(e(this.s), e(this.e));
  }
}
class Dy {
  static hasDST(e = Ci.defaultZone) {
    const n = br.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && n.offset !== n.set({ month: 6 }).offset;
  }
  static isValidIANAZone(e) {
    return $l.isValidZone(e);
  }
  static normalizeZone(e) {
    return Iu(e, Ci.defaultZone);
  }
  static months(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null, outputCalendar: f = "gregory" } = {}) {
    return (s || Fn.create(n, a, f)).months(e);
  }
  static monthsFormat(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null, outputCalendar: f = "gregory" } = {}) {
    return (s || Fn.create(n, a, f)).months(e, !0);
  }
  static weekdays(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null } = {}) {
    return (s || Fn.create(n, a, null)).weekdays(e);
  }
  static weekdaysFormat(e = "long", { locale: n = null, numberingSystem: a = null, locObj: s = null } = {}) {
    return (s || Fn.create(n, a, null)).weekdays(e, !0);
  }
  static meridiems({ locale: e = null } = {}) {
    return Fn.create(e).meridiems();
  }
  static eras(e = "short", { locale: n = null } = {}) {
    return Fn.create(n, null, "gregory").eras(e);
  }
  static features() {
    return { relative: fM() };
  }
}
function L2(t, e) {
  const n = (s) => s.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), a = n(e) - n(t);
  return Math.floor(Yr.fromMillis(a).as("days"));
}
function y6(t, e, n) {
  const a = [
    ["years", (g, b) => b.year - g.year],
    ["quarters", (g, b) => b.quarter - g.quarter + (b.year - g.year) * 4],
    ["months", (g, b) => b.month - g.month + (b.year - g.year) * 12],
    [
      "weeks",
      (g, b) => {
        const T = L2(g, b);
        return (T - T % 7) / 7;
      }
    ],
    ["days", L2]
  ], s = {}, f = t;
  let o, m;
  for (const [g, b] of a)
    n.indexOf(g) >= 0 && (o = g, s[g] = b(t, e), m = f.plus(s), m > e ? (s[g]--, t = f.plus(s), t > e && (m = t, s[g]--, t = f.plus(s))) : t = m);
  return [t, s, m, o];
}
function g6(t, e, n, a) {
  let [s, f, o, m] = y6(t, e, n);
  const g = e - s, b = n.filter(
    (M) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(M) >= 0
  );
  b.length === 0 && (o < e && (o = s.plus({ [m]: 1 })), o !== s && (f[m] = (f[m] || 0) + g / (o - s)));
  const T = Yr.fromObject(f, a);
  return b.length > 0 ? Yr.fromMillis(g, a).shiftTo(...b).plus(T) : T;
}
const t1 = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
}, D2 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, v6 = t1.hanidec.replace(/[\[|\]]/g, "").split("");
function _6(t) {
  let e = parseInt(t, 10);
  if (isNaN(e)) {
    e = "";
    for (let n = 0; n < t.length; n++) {
      const a = t.charCodeAt(n);
      if (t[n].search(t1.hanidec) !== -1)
        e += v6.indexOf(t[n]);
      else
        for (const s in D2) {
          const [f, o] = D2[s];
          a >= f && a <= o && (e += a - f);
        }
    }
    return parseInt(e, 10);
  } else
    return e;
}
function Ka({ numberingSystem: t }, e = "") {
  return new RegExp(`${t1[t || "latn"]}${e}`);
}
const x6 = "missing Intl.DateTimeFormat.formatToParts support";
function rn(t, e = (n) => n) {
  return { regex: t, deser: ([n]) => e(_6(n)) };
}
const b6 = String.fromCharCode(160), AM = `[ ${b6}]`, kM = new RegExp(AM, "g");
function w6(t) {
  return t.replace(/\./g, "\\.?").replace(kM, AM);
}
function N2(t) {
  return t.replace(/\./g, "").replace(kM, " ").toLowerCase();
}
function Ya(t, e) {
  return t === null ? null : {
    regex: RegExp(t.map(w6).join("|")),
    deser: ([n]) => t.findIndex((a) => N2(n) === N2(a)) + e
  };
}
function R2(t, e) {
  return { regex: t, deser: ([, n, a]) => Dv(n, a), groups: e };
}
function Ny(t) {
  return { regex: t, deser: ([e]) => e };
}
function E6(t) {
  return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function S6(t, e) {
  const n = Ka(e), a = Ka(e, "{2}"), s = Ka(e, "{3}"), f = Ka(e, "{4}"), o = Ka(e, "{6}"), m = Ka(e, "{1,2}"), g = Ka(e, "{1,3}"), b = Ka(e, "{1,6}"), T = Ka(e, "{1,9}"), M = Ka(e, "{2,4}"), I = Ka(e, "{4,6}"), A = (q) => ({ regex: RegExp(E6(q.val)), deser: ([re]) => re, literal: !0 }), V = ((q) => {
    if (t.literal)
      return A(q);
    switch (q.val) {
      case "G":
        return Ya(e.eras("short"), 0);
      case "GG":
        return Ya(e.eras("long"), 0);
      case "y":
        return rn(b);
      case "yy":
        return rn(M, ox);
      case "yyyy":
        return rn(f);
      case "yyyyy":
        return rn(I);
      case "yyyyyy":
        return rn(o);
      case "M":
        return rn(m);
      case "MM":
        return rn(a);
      case "MMM":
        return Ya(e.months("short", !0), 1);
      case "MMMM":
        return Ya(e.months("long", !0), 1);
      case "L":
        return rn(m);
      case "LL":
        return rn(a);
      case "LLL":
        return Ya(e.months("short", !1), 1);
      case "LLLL":
        return Ya(e.months("long", !1), 1);
      case "d":
        return rn(m);
      case "dd":
        return rn(a);
      case "o":
        return rn(g);
      case "ooo":
        return rn(s);
      case "HH":
        return rn(a);
      case "H":
        return rn(m);
      case "hh":
        return rn(a);
      case "h":
        return rn(m);
      case "mm":
        return rn(a);
      case "m":
        return rn(m);
      case "q":
        return rn(m);
      case "qq":
        return rn(a);
      case "s":
        return rn(m);
      case "ss":
        return rn(a);
      case "S":
        return rn(g);
      case "SSS":
        return rn(s);
      case "u":
        return Ny(T);
      case "uu":
        return Ny(m);
      case "uuu":
        return rn(n);
      case "a":
        return Ya(e.meridiems(), 0);
      case "kkkk":
        return rn(f);
      case "kk":
        return rn(M, ox);
      case "W":
        return rn(m);
      case "WW":
        return rn(a);
      case "E":
      case "c":
        return rn(n);
      case "EEE":
        return Ya(e.weekdays("short", !1), 1);
      case "EEEE":
        return Ya(e.weekdays("long", !1), 1);
      case "ccc":
        return Ya(e.weekdays("short", !0), 1);
      case "cccc":
        return Ya(e.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return R2(new RegExp(`([+-]${m.source})(?::(${a.source}))?`), 2);
      case "ZZZ":
        return R2(new RegExp(`([+-]${m.source})(${a.source})?`), 2);
      case "z":
        return Ny(/[a-z_+-/]{1,256}?/i);
      case " ":
        return Ny(/[^\S\n\r]/);
      default:
        return A(q);
    }
  })(t) || {
    invalidReason: x6
  };
  return V.token = t, V;
}
const T6 = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function M6(t, e, n) {
  const { type: a, value: s } = t;
  if (a === "literal") {
    const g = /^\s+$/.test(s);
    return {
      literal: !g,
      val: g ? " " : s
    };
  }
  const f = e[a];
  let o = a;
  a === "hour" && (e.hour12 != null ? o = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? o = "hour12" : o = "hour24" : o = n.hour12 ? "hour12" : "hour24");
  let m = T6[o];
  if (typeof m == "object" && (m = m[f]), m)
    return {
      literal: !1,
      val: m
    };
}
function I6(t) {
  return [`^${t.map((n) => n.regex).reduce((n, a) => `${n}(${a.source})`, "")}$`, t];
}
function O6(t, e, n) {
  const a = t.match(e);
  if (a) {
    const s = {};
    let f = 1;
    for (const o in n)
      if (zf(n, o)) {
        const m = n[o], g = m.groups ? m.groups + 1 : 1;
        !m.literal && m.token && (s[m.token.val[0]] = m.deser(a.slice(f, f + g))), f += g;
      }
    return [a, s];
  } else
    return [a, {}];
}
function C6(t) {
  const e = (f) => {
    switch (f) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let n = null, a;
  return Hr(t.z) || (n = $l.create(t.z)), Hr(t.Z) || (n || (n = new Fo(t.Z)), a = t.Z), Hr(t.q) || (t.M = (t.q - 1) * 3 + 1), Hr(t.h) || (t.h < 12 && t.a === 1 ? t.h += 12 : t.h === 12 && t.a === 0 && (t.h = 0)), t.G === 0 && t.y && (t.y = -t.y), Hr(t.u) || (t.S = Kx(t.u)), [Object.keys(t).reduce((f, o) => {
    const m = e(o);
    return m && (f[m] = t[o]), f;
  }, {}), n, a];
}
let J_ = null;
function P6() {
  return J_ || (J_ = br.fromMillis(1555555555555)), J_;
}
function A6(t, e) {
  if (t.literal)
    return t;
  const n = bo.macroTokenToFormatOpts(t.val), a = NM(n, e);
  return a == null || a.includes(void 0) ? t : a;
}
function LM(t, e) {
  return Array.prototype.concat(...t.map((n) => A6(n, e)));
}
function DM(t, e, n) {
  const a = LM(bo.parseFormat(n), t), s = a.map((o) => S6(o, t)), f = s.find((o) => o.invalidReason);
  if (f)
    return { input: e, tokens: a, invalidReason: f.invalidReason };
  {
    const [o, m] = I6(s), g = RegExp(o, "i"), [b, T] = O6(e, g, m), [M, I, A] = T ? C6(T) : [null, null, void 0];
    if (zf(T, "a") && zf(T, "H"))
      throw new id(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: e, tokens: a, regex: g, rawMatches: b, matches: T, result: M, zone: I, specificOffset: A };
  }
}
function k6(t, e, n) {
  const { result: a, zone: s, specificOffset: f, invalidReason: o } = DM(t, e, n);
  return [a, s, f, o];
}
function NM(t, e) {
  if (!t)
    return null;
  const a = bo.create(e, t).dtFormatter(P6()), s = a.formatToParts(), f = a.resolvedOptions();
  return s.map((o) => M6(o, t, f));
}
const RM = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], zM = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function La(t, e) {
  return new os(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`
  );
}
function FM(t, e, n) {
  const a = new Date(Date.UTC(t, e - 1, n));
  t < 100 && t >= 0 && a.setUTCFullYear(a.getUTCFullYear() - 1900);
  const s = a.getUTCDay();
  return s === 0 ? 7 : s;
}
function BM(t, e, n) {
  return n + (Jd(t) ? zM : RM)[e - 1];
}
function VM(t, e) {
  const n = Jd(t) ? zM : RM, a = n.findIndex((f) => f < e), s = e - n[a];
  return { month: a + 1, day: s };
}
function ax(t) {
  const { year: e, month: n, day: a } = t, s = BM(e, n, a), f = FM(e, n, a);
  let o = Math.floor((s - f + 10) / 7), m;
  return o < 1 ? (m = e - 1, o = $g(m)) : o > $g(e) ? (m = e + 1, o = 1) : m = e, { weekYear: m, weekNumber: o, weekday: f, ...Nv(t) };
}
function z2(t) {
  const { weekYear: e, weekNumber: n, weekday: a } = t, s = FM(e, 1, 4), f = vd(e);
  let o = n * 7 + a - s - 3, m;
  o < 1 ? (m = e - 1, o += vd(m)) : o > f ? (m = e + 1, o -= vd(e)) : m = e;
  const { month: g, day: b } = VM(m, o);
  return { year: m, month: g, day: b, ...Nv(t) };
}
function Q_(t) {
  const { year: e, month: n, day: a } = t, s = BM(e, n, a);
  return { year: e, ordinal: s, ...Nv(t) };
}
function F2(t) {
  const { year: e, ordinal: n } = t, { month: a, day: s } = VM(e, n);
  return { year: e, month: a, day: s, ...Nv(t) };
}
function L6(t) {
  const e = kv(t.weekYear), n = Fl(t.weekNumber, 1, $g(t.weekYear)), a = Fl(t.weekday, 1, 7);
  return e ? n ? a ? !1 : La("weekday", t.weekday) : La("week", t.week) : La("weekYear", t.weekYear);
}
function D6(t) {
  const e = kv(t.year), n = Fl(t.ordinal, 1, vd(t.year));
  return e ? n ? !1 : La("ordinal", t.ordinal) : La("year", t.year);
}
function UM(t) {
  const e = kv(t.year), n = Fl(t.month, 1, 12), a = Fl(t.day, 1, Gg(t.year, t.month));
  return e ? n ? a ? !1 : La("day", t.day) : La("month", t.month) : La("year", t.year);
}
function jM(t) {
  const { hour: e, minute: n, second: a, millisecond: s } = t, f = Fl(e, 0, 23) || e === 24 && n === 0 && a === 0 && s === 0, o = Fl(n, 0, 59), m = Fl(a, 0, 59), g = Fl(s, 0, 999);
  return f ? o ? m ? g ? !1 : La("millisecond", s) : La("second", a) : La("minute", n) : La("hour", e);
}
const e0 = "Invalid DateTime", B2 = 864e13;
function Ry(t) {
  return new os("unsupported zone", `the zone "${t.name}" is not supported`);
}
function t0(t) {
  return t.weekData === null && (t.weekData = ax(t.c)), t.weekData;
}
function Ac(t, e) {
  const n = {
    ts: t.ts,
    zone: t.zone,
    c: t.c,
    o: t.o,
    loc: t.loc,
    invalid: t.invalid
  };
  return new br({ ...n, ...e, old: n });
}
function GM(t, e, n) {
  let a = t - e * 60 * 1e3;
  const s = n.offset(a);
  if (e === s)
    return [a, e];
  a -= (s - e) * 60 * 1e3;
  const f = n.offset(a);
  return s === f ? [a, s] : [t - Math.min(s, f) * 60 * 1e3, Math.max(s, f)];
}
function zy(t, e) {
  t += e * 60 * 1e3;
  const n = new Date(t);
  return {
    year: n.getUTCFullYear(),
    month: n.getUTCMonth() + 1,
    day: n.getUTCDate(),
    hour: n.getUTCHours(),
    minute: n.getUTCMinutes(),
    second: n.getUTCSeconds(),
    millisecond: n.getUTCMilliseconds()
  };
}
function fg(t, e, n) {
  return GM(Lv(t), e, n);
}
function V2(t, e) {
  const n = t.o, a = t.c.year + Math.trunc(e.years), s = t.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, f = {
    ...t.c,
    year: a,
    month: s,
    day: Math.min(t.c.day, Gg(a, s)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
  }, o = Yr.fromObject({
    years: e.years - Math.trunc(e.years),
    quarters: e.quarters - Math.trunc(e.quarters),
    months: e.months - Math.trunc(e.months),
    weeks: e.weeks - Math.trunc(e.weeks),
    days: e.days - Math.trunc(e.days),
    hours: e.hours,
    minutes: e.minutes,
    seconds: e.seconds,
    milliseconds: e.milliseconds
  }).as("milliseconds"), m = Lv(f);
  let [g, b] = GM(m, n, t.zone);
  return o !== 0 && (g += o, b = t.zone.offset(g)), { ts: g, o: b };
}
function Xp(t, e, n, a, s, f) {
  const { setZone: o, zone: m } = n;
  if (t && Object.keys(t).length !== 0 || e) {
    const g = e || m, b = br.fromObject(t, {
      ...n,
      zone: g,
      specificOffset: f
    });
    return o ? b : b.setZone(m);
  } else
    return br.invalid(
      new os("unparsable", `the input "${s}" can't be parsed as ${a}`)
    );
}
function Fy(t, e, n = !0) {
  return t.isValid ? bo.create(Fn.create("en-US"), {
    allowZ: n,
    forceSimple: !0
  }).formatDateTimeFromString(t, e) : null;
}
function r0(t, e) {
  const n = t.c.year > 9999 || t.c.year < 0;
  let a = "";
  return n && t.c.year >= 0 && (a += "+"), a += Pi(t.c.year, n ? 6 : 4), e ? (a += "-", a += Pi(t.c.month), a += "-", a += Pi(t.c.day)) : (a += Pi(t.c.month), a += Pi(t.c.day)), a;
}
function U2(t, e, n, a, s, f) {
  let o = Pi(t.c.hour);
  return e ? (o += ":", o += Pi(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (o += ":")) : o += Pi(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (o += Pi(t.c.second), (t.c.millisecond !== 0 || !a) && (o += ".", o += Pi(t.c.millisecond, 3))), s && (t.isOffsetFixed && t.offset === 0 && !f ? o += "Z" : t.o < 0 ? (o += "-", o += Pi(Math.trunc(-t.o / 60)), o += ":", o += Pi(Math.trunc(-t.o % 60))) : (o += "+", o += Pi(Math.trunc(t.o / 60)), o += ":", o += Pi(Math.trunc(t.o % 60)))), f && (o += "[" + t.zone.ianaName + "]"), o;
}
const $M = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, N6 = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, R6 = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, qM = ["year", "month", "day", "hour", "minute", "second", "millisecond"], z6 = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], F6 = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function j2(t) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[t.toLowerCase()];
  if (!e)
    throw new WT(t);
  return e;
}
function G2(t, e) {
  const n = Iu(e.zone, Ci.defaultZone), a = Fn.fromObject(e), s = Ci.now();
  let f, o;
  if (Hr(t.year))
    f = s;
  else {
    for (const b of qM)
      Hr(t[b]) && (t[b] = $M[b]);
    const m = UM(t) || jM(t);
    if (m)
      return br.invalid(m);
    const g = n.offset(s);
    [f, o] = fg(t, g, n);
  }
  return new br({ ts: f, zone: n, loc: a, o });
}
function $2(t, e, n) {
  const a = Hr(n.round) ? !0 : n.round, s = (o, m) => (o = Yx(o, a || n.calendary ? 0 : 2, !0), e.loc.clone(n).relFormatter(n).format(o, m)), f = (o) => n.calendary ? e.hasSame(t, o) ? 0 : e.startOf(o).diff(t.startOf(o), o).get(o) : e.diff(t, o).get(o);
  if (n.unit)
    return s(f(n.unit), n.unit);
  for (const o of n.units) {
    const m = f(o);
    if (Math.abs(m) >= 1)
      return s(m, o);
  }
  return s(t > e ? -0 : 0, n.units[n.units.length - 1]);
}
function q2(t) {
  let e = {}, n;
  return t.length > 0 && typeof t[t.length - 1] == "object" ? (e = t[t.length - 1], n = Array.from(t).slice(0, t.length - 1)) : n = Array.from(t), [e, n];
}
class br {
  constructor(e) {
    const n = e.zone || Ci.defaultZone;
    let a = e.invalid || (Number.isNaN(e.ts) ? new os("invalid input") : null) || (n.isValid ? null : Ry(n));
    this.ts = Hr(e.ts) ? Ci.now() : e.ts;
    let s = null, f = null;
    if (!a)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(n))
        [s, f] = [e.old.c, e.old.o];
      else {
        const m = n.offset(this.ts);
        s = zy(this.ts, m), a = Number.isNaN(s.year) ? new os("invalid input") : null, s = a ? null : s, f = a ? null : m;
      }
    this._zone = n, this.loc = e.loc || Fn.create(), this.invalid = a, this.weekData = null, this.c = s, this.o = f, this.isLuxonDateTime = !0;
  }
  static now() {
    return new br({});
  }
  static local() {
    const [e, n] = q2(arguments), [a, s, f, o, m, g, b] = n;
    return G2({ year: a, month: s, day: f, hour: o, minute: m, second: g, millisecond: b }, e);
  }
  static utc() {
    const [e, n] = q2(arguments), [a, s, f, o, m, g, b] = n;
    return e.zone = Fo.utcInstance, G2({ year: a, month: s, day: f, hour: o, minute: m, second: g, millisecond: b }, e);
  }
  static fromJSDate(e, n = {}) {
    const a = hz(e) ? e.valueOf() : NaN;
    if (Number.isNaN(a))
      return br.invalid("invalid input");
    const s = Iu(n.zone, Ci.defaultZone);
    return s.isValid ? new br({
      ts: a,
      zone: s,
      loc: Fn.fromObject(n)
    }) : br.invalid(Ry(s));
  }
  static fromMillis(e, n = {}) {
    if (Xc(e))
      return e < -B2 || e > B2 ? br.invalid("Timestamp out of range") : new br({
        ts: e,
        zone: Iu(n.zone, Ci.defaultZone),
        loc: Fn.fromObject(n)
      });
    throw new ka(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
    );
  }
  static fromSeconds(e, n = {}) {
    if (Xc(e))
      return new br({
        ts: e * 1e3,
        zone: Iu(n.zone, Ci.defaultZone),
        loc: Fn.fromObject(n)
      });
    throw new ka("fromSeconds requires a numerical input");
  }
  static fromObject(e, n = {}) {
    e = e || {};
    const a = Iu(n.zone, Ci.defaultZone);
    if (!a.isValid)
      return br.invalid(Ry(a));
    const s = Ci.now(), f = Hr(n.specificOffset) ? a.offset(s) : n.specificOffset, o = qg(e, j2), m = !Hr(o.ordinal), g = !Hr(o.year), b = !Hr(o.month) || !Hr(o.day), T = g || b, M = o.weekYear || o.weekNumber, I = Fn.fromObject(n);
    if ((T || m) && M)
      throw new id(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (b && m)
      throw new id("Can't mix ordinal dates with month/day");
    const A = M || o.weekday && !T;
    let z, V, q = zy(s, f);
    A ? (z = z6, V = N6, q = ax(q)) : m ? (z = F6, V = R6, q = Q_(q)) : (z = qM, V = $M);
    let re = !1;
    for (const Ae of z) {
      const Se = o[Ae];
      Hr(Se) ? re ? o[Ae] = V[Ae] : o[Ae] = q[Ae] : re = !0;
    }
    const X = A ? L6(o) : m ? D6(o) : UM(o), ae = X || jM(o);
    if (ae)
      return br.invalid(ae);
    const ce = A ? z2(o) : m ? F2(o) : o, [ve, Ne] = fg(ce, f, a), ze = new br({
      ts: ve,
      zone: a,
      o: Ne,
      loc: I
    });
    return o.weekday && T && e.weekday !== ze.weekday ? br.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${o.weekday} and a date of ${ze.toISO()}`
    ) : ze;
  }
  static fromISO(e, n = {}) {
    const [a, s] = t6(e);
    return Xp(a, s, n, "ISO 8601", e);
  }
  static fromRFC2822(e, n = {}) {
    const [a, s] = r6(e);
    return Xp(a, s, n, "RFC 2822", e);
  }
  static fromHTTP(e, n = {}) {
    const [a, s] = n6(e);
    return Xp(a, s, n, "HTTP", n);
  }
  static fromFormat(e, n, a = {}) {
    if (Hr(e) || Hr(n))
      throw new ka("fromFormat requires an input string and a format");
    const { locale: s = null, numberingSystem: f = null } = a, o = Fn.fromOpts({
      locale: s,
      numberingSystem: f,
      defaultToEN: !0
    }), [m, g, b, T] = k6(o, e, n);
    return T ? br.invalid(T) : Xp(m, g, a, `format ${n}`, e, b);
  }
  static fromString(e, n, a = {}) {
    return br.fromFormat(e, n, a);
  }
  static fromSQL(e, n = {}) {
    const [a, s] = c6(e);
    return Xp(a, s, n, "SQL", e);
  }
  static invalid(e, n = null) {
    if (!e)
      throw new ka("need to specify a reason the DateTime is invalid");
    const a = e instanceof os ? e : new os(e, n);
    if (Ci.throwOnInvalid)
      throw new j5(a);
    return new br({ invalid: a });
  }
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  static parseFormatForOpts(e, n = {}) {
    const a = NM(e, Fn.fromObject(n));
    return a ? a.map((s) => s ? s.val : null).join("") : null;
  }
  static expandFormat(e, n = {}) {
    return LM(bo.parseFormat(e), Fn.fromObject(n)).map((s) => s.val).join("");
  }
  get(e) {
    return this[e];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? t0(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? t0(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? t0(this).weekday : NaN;
  }
  get ordinal() {
    return this.isValid ? Q_(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? Dy.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? Dy.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? Dy.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? Dy.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const e = 864e5, n = 6e4, a = Lv(this.c), s = this.zone.offset(a - e), f = this.zone.offset(a + e), o = this.zone.offset(a - s * n), m = this.zone.offset(a - f * n);
    if (o === m)
      return [this];
    const g = a - o * n, b = a - m * n, T = zy(g, o), M = zy(b, m);
    return T.hour === M.hour && T.minute === M.minute && T.second === M.second && T.millisecond === M.millisecond ? [Ac(this, { ts: g }), Ac(this, { ts: b })] : [this];
  }
  get isInLeapYear() {
    return Jd(this.year);
  }
  get daysInMonth() {
    return Gg(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? vd(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? $g(this.weekYear) : NaN;
  }
  resolvedLocaleOptions(e = {}) {
    const { locale: n, numberingSystem: a, calendar: s } = bo.create(
      this.loc.clone(e),
      e
    ).resolvedOptions(this);
    return { locale: n, numberingSystem: a, outputCalendar: s };
  }
  toUTC(e = 0, n = {}) {
    return this.setZone(Fo.instance(e), n);
  }
  toLocal() {
    return this.setZone(Ci.defaultZone);
  }
  setZone(e, { keepLocalTime: n = !1, keepCalendarTime: a = !1 } = {}) {
    if (e = Iu(e, Ci.defaultZone), e.equals(this.zone))
      return this;
    if (e.isValid) {
      let s = this.ts;
      if (n || a) {
        const f = e.offset(this.ts), o = this.toObject();
        [s] = fg(o, f, e);
      }
      return Ac(this, { ts: s, zone: e });
    } else
      return br.invalid(Ry(e));
  }
  reconfigure({ locale: e, numberingSystem: n, outputCalendar: a } = {}) {
    const s = this.loc.clone({ locale: e, numberingSystem: n, outputCalendar: a });
    return Ac(this, { loc: s });
  }
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  set(e) {
    if (!this.isValid)
      return this;
    const n = qg(e, j2), a = !Hr(n.weekYear) || !Hr(n.weekNumber) || !Hr(n.weekday), s = !Hr(n.ordinal), f = !Hr(n.year), o = !Hr(n.month) || !Hr(n.day), m = f || o, g = n.weekYear || n.weekNumber;
    if ((m || s) && g)
      throw new id(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (o && s)
      throw new id("Can't mix ordinal dates with month/day");
    let b;
    a ? b = z2({ ...ax(this.c), ...n }) : Hr(n.ordinal) ? (b = { ...this.toObject(), ...n }, Hr(n.day) && (b.day = Math.min(Gg(b.year, b.month), b.day))) : b = F2({ ...Q_(this.c), ...n });
    const [T, M] = fg(b, this.o, this.zone);
    return Ac(this, { ts: T, o: M });
  }
  plus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e);
    return Ac(this, V2(this, n));
  }
  minus(e) {
    if (!this.isValid)
      return this;
    const n = Yr.fromDurationLike(e).negate();
    return Ac(this, V2(this, n));
  }
  startOf(e) {
    if (!this.isValid)
      return this;
    const n = {}, a = Yr.normalizeUnit(e);
    switch (a) {
      case "years":
        n.month = 1;
      case "quarters":
      case "months":
        n.day = 1;
      case "weeks":
      case "days":
        n.hour = 0;
      case "hours":
        n.minute = 0;
      case "minutes":
        n.second = 0;
      case "seconds":
        n.millisecond = 0;
        break;
    }
    if (a === "weeks" && (n.weekday = 1), a === "quarters") {
      const s = Math.ceil(this.month / 3);
      n.month = (s - 1) * 3 + 1;
    }
    return this.set(n);
  }
  endOf(e) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e).minus(1) : this;
  }
  toFormat(e, n = {}) {
    return this.isValid ? bo.create(this.loc.redefaultToEN(n)).formatDateTimeFromString(this, e) : e0;
  }
  toLocaleString(e = jg, n = {}) {
    return this.isValid ? bo.create(this.loc.clone(n), e).formatDateTime(this) : e0;
  }
  toLocaleParts(e = {}) {
    return this.isValid ? bo.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  toISO({
    format: e = "extended",
    suppressSeconds: n = !1,
    suppressMilliseconds: a = !1,
    includeOffset: s = !0,
    extendedZone: f = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const o = e === "extended";
    let m = r0(this, o);
    return m += "T", m += U2(this, o, n, a, s, f), m;
  }
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? r0(this, e === "extended") : null;
  }
  toISOWeekDate() {
    return Fy(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: n = !1,
    includeOffset: a = !0,
    includePrefix: s = !1,
    extendedZone: f = !1,
    format: o = "extended"
  } = {}) {
    return this.isValid ? (s ? "T" : "") + U2(
      this,
      o === "extended",
      n,
      e,
      a,
      f
    ) : null;
  }
  toRFC2822() {
    return Fy(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  toHTTP() {
    return Fy(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    return this.isValid ? r0(this, !0) : null;
  }
  toSQLTime({ includeOffset: e = !0, includeZone: n = !1, includeOffsetSpace: a = !0 } = {}) {
    let s = "HH:mm:ss.SSS";
    return (n || e) && (a && (s += " "), n ? s += "z" : e && (s += "ZZ")), Fy(this, s, !0);
  }
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  toString() {
    return this.isValid ? this.toISO() : e0;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(e = {}) {
    if (!this.isValid)
      return {};
    const n = { ...this.c };
    return e.includeConfig && (n.outputCalendar = this.outputCalendar, n.numberingSystem = this.loc.numberingSystem, n.locale = this.loc.locale), n;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(e, n = "milliseconds", a = {}) {
    if (!this.isValid || !e.isValid)
      return Yr.invalid("created by diffing an invalid DateTime");
    const s = { locale: this.locale, numberingSystem: this.numberingSystem, ...a }, f = fz(n).map(Yr.normalizeUnit), o = e.valueOf() > this.valueOf(), m = o ? this : e, g = o ? e : this, b = g6(m, g, f, s);
    return o ? b.negate() : b;
  }
  diffNow(e = "milliseconds", n = {}) {
    return this.diff(br.now(), e, n);
  }
  until(e) {
    return this.isValid ? pi.fromDateTimes(this, e) : this;
  }
  hasSame(e, n) {
    if (!this.isValid)
      return !1;
    const a = e.valueOf(), s = this.setZone(e.zone, { keepLocalTime: !0 });
    return s.startOf(n) <= a && a <= s.endOf(n);
  }
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  toRelative(e = {}) {
    if (!this.isValid)
      return null;
    const n = e.base || br.fromObject({}, { zone: this.zone }), a = e.padding ? this < n ? -e.padding : e.padding : 0;
    let s = ["years", "months", "days", "hours", "minutes", "seconds"], f = e.unit;
    return Array.isArray(e.unit) && (s = e.unit, f = void 0), $2(n, this.plus(a), {
      ...e,
      numeric: "always",
      units: s,
      unit: f
    });
  }
  toRelativeCalendar(e = {}) {
    return this.isValid ? $2(e.base || br.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  static min(...e) {
    if (!e.every(br.isDateTime))
      throw new ka("min requires all arguments be DateTimes");
    return O2(e, (n) => n.valueOf(), Math.min);
  }
  static max(...e) {
    if (!e.every(br.isDateTime))
      throw new ka("max requires all arguments be DateTimes");
    return O2(e, (n) => n.valueOf(), Math.max);
  }
  static fromFormatExplain(e, n, a = {}) {
    const { locale: s = null, numberingSystem: f = null } = a, o = Fn.fromOpts({
      locale: s,
      numberingSystem: f,
      defaultToEN: !0
    });
    return DM(o, e, n);
  }
  static fromStringExplain(e, n, a = {}) {
    return br.fromFormatExplain(e, n, a);
  }
  static get DATE_SHORT() {
    return jg;
  }
  static get DATE_MED() {
    return HT;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return q5;
  }
  static get DATE_FULL() {
    return ZT;
  }
  static get DATE_HUGE() {
    return XT;
  }
  static get TIME_SIMPLE() {
    return KT;
  }
  static get TIME_WITH_SECONDS() {
    return YT;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return JT;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return QT;
  }
  static get TIME_24_SIMPLE() {
    return eM;
  }
  static get TIME_24_WITH_SECONDS() {
    return tM;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return rM;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return nM;
  }
  static get DATETIME_SHORT() {
    return iM;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return oM;
  }
  static get DATETIME_MED() {
    return aM;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return sM;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return W5;
  }
  static get DATETIME_FULL() {
    return lM;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return uM;
  }
  static get DATETIME_HUGE() {
    return cM;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return hM;
  }
}
function Kp(t) {
  if (br.isDateTime(t))
    return t;
  if (t && t.valueOf && Xc(t.valueOf()))
    return br.fromJSDate(t);
  if (t && typeof t == "object")
    return br.fromObject(t);
  throw new ka(
    `Unknown datetime argument: ${t}, of type ${typeof t}`
  );
}
const WM = [0, 1, 0, 0];
function W2(t, e = "second", n, a) {
  const { t: s } = En(), f = new Date(t).toISOString(), o = {
    year: s("yyyy"),
    month: s("M/yyyy"),
    day: s("M/d/yyyy"),
    second: s("M/d/yyyy HH:mm:ss")
  }, g = (n ? {
    year: "yyyy",
    month: "yyyy-MM",
    day: "yyyy-MM-dd",
    second: void 0
  } : o)[e];
  return g ? br.fromISO(f).toFormat(
    `${a ? "UTC:" : ""}${g}`
  ) : f.replace(/\.\d{3}/, "");
}
function sx(t) {
  return new Date(t).toISOString().split(".")[0] + "Z";
}
function n0(t) {
  return br.fromISO(t).toFormat("yyyy-MM-dd");
}
function B6(t, e) {
  return t <= e.minValue ? e.minValue : t >= e.maxValue ? e.maxValue : e.timeValueList ? V6(t, e) : U6(t, e);
}
function V6(t, e) {
  var g;
  const n = (g = e.timeValueList) != null ? g : [];
  let a, s = 0, f = n.length - 1;
  for (; f - s > 1; )
    a = Math.floor((s + f) / 2), n[a] >= t ? f = a : s = a;
  const o = Math.abs(n[s] - t), m = Math.abs(n[f] - t);
  return n[o < m ? s : f];
}
function U6(t, e) {
  var g;
  const n = (g = e.timeInterval) != null ? g : WM, a = new Date(t).getTime(), s = new Date(e.minValue), f = e.maxValue;
  let o = e.minValue, m = Math.abs(a - o);
  for (let b = 1; ; b++) {
    const T = new Date(s.getTime());
    if (T.setFullYear(s.getFullYear() + b * n[0]), T.setMonth(
      s.getMonth() + b * n[1],
      s.getDate() + b * n[2]
    ), T.setSeconds(s.getSeconds() + b * n[3]), T.getTime() > f)
      break;
    const M = Math.abs(a - T.getTime());
    if (M <= m)
      o = T.getTime(), m = M;
    else
      break;
  }
  return o;
}
const Ei = ih("map", () => {
  const t = cs(), e = Er({}), n = Bn([]), a = Bn([]), s = Er(!1), f = Er(!1), o = Er(void 0);
  function m(X) {
    o.value = X;
  }
  function g(...X) {
    n.value = [.../* @__PURE__ */ new Set([...n.value, ...X])];
  }
  function b(...X) {
    a.value = [.../* @__PURE__ */ new Set([...a.value, ...X])];
  }
  function T(...X) {
    n.value = n.value.filter(
      (ae) => X.indexOf(ae.id) === -1
    ), a.value = a.value.filter(
      (ae) => X.indexOf(ae.id) === -1
    );
  }
  function M() {
    n.value = [];
  }
  function I(X) {
    var ae;
    return !!((ae = n.value) != null && ae.find((ce) => ce.id === X));
  }
  function A(X, ae = !1) {
    var ve;
    const ce = ae ? a : n;
    ce.value = [
      ...((ve = ce.value) == null ? void 0 : ve.sort(
        (Ne, ze) => X.indexOf(Ne.id) - X.indexOf(ze.id)
      )) || []
    ];
  }
  function z(X, ae) {
    n.value = n.value.map((ce) => ce.id === X ? { ...ce, opacity: ae, previousOpacity: ce.opacity } : ce);
  }
  function V(X, ae, ce) {
    n.value = n.value.map((ve) => {
      if (ve.id === X) {
        const Ne = {
          ...ve,
          currentTimeMinValue: ae ? sx(ae) : void 0,
          currentTimeMaxValue: ce ? sx(ce) : void 0
        };
        return Ne.type === "WMTS" && (Ne.name = t.getLayerCurrentLabel(Ne)), Ne;
      }
      return ve;
    });
  }
  function q(X) {
    s.value = X;
  }
  function re(X) {
    f.value = X;
  }
  return {
    map: e,
    layers: n,
    layers3d: a,
    is3dActive: s,
    is3dMesh: f,
    bgLayer: o,
    addLayers: g,
    add3dLayers: b,
    removeLayers: T,
    removeAllLayers: M,
    reorderLayers: A,
    setLayerOpacity: z,
    setLayerTime: V,
    setBgLayer: m,
    setIs3dActive: q,
    setIs3dMesh: re,
    hasLayer: I
  };
}), j6 = "root_3d", G6 = -222, Ro = ih(
  "config",
  () => {
    const t = Bn(), e = Er("main"), n = ar(() => {
      var g;
      return (g = t.value) == null ? void 0 : g.themes;
    }), a = ar(
      () => {
        var g;
        return (g = n.value) == null ? void 0 : g.find((b) => b.name === e.value);
      }
    ), s = ar(() => {
      var g;
      return ((g = t.value) == null ? void 0 : g.background_layers) || [];
    }), f = ar(() => {
      var b;
      const g = (b = n.value) == null ? void 0 : b.filter(
        (T) => {
          var M;
          return ((M = T.metadata) == null ? void 0 : M.ol3d_type) !== void 0;
        }
      );
      if (!!g)
        return {
          name: j6,
          id: G6,
          children: g.flatMap(
            (T) => T != null && T.children ? T.children : T
          ),
          metadata: {}
        };
    });
    function o(g) {
      t.value = g;
    }
    function m(g) {
      e.value = g;
    }
    return {
      config: t,
      themes: n,
      themeName: e,
      theme: a,
      bgLayers: s,
      layerTrees_3d: f,
      setTheme: m,
      setThemes: o
    };
  },
  {}
);
function Kc() {
  function t(m, g) {
    return n(m, void 0, g);
  }
  function e(m, g) {
    return n(void 0, m, g);
  }
  function n(m, g, b) {
    const { theme: T } = Ro();
    if (b = b || T, m && (b == null ? void 0 : b.id) === m || g && (b == null ? void 0 : b.name) === g)
      return b;
    if (b != null && b.children)
      for (const M of b.children) {
        const I = n(m, g, M);
        if (I)
          return I;
      }
  }
  function a(m) {
    const { layerTrees_3d: g } = Ro();
    return n(m, void 0, g);
  }
  function s(m) {
    const { bgLayers: g } = Ro();
    return g.find((b) => b.id === m);
  }
  function f(m) {
    const { bgLayers: g } = Ro();
    return g.find((b) => b.name === m);
  }
  function o(m) {
    const { setTheme: g } = Ro();
    g(m);
  }
  return {
    findById: t,
    findByName: e,
    find3dLayerById: a,
    findBgLayerById: s,
    findBgLayerByName: f,
    setTheme: o
  };
}
const H2 = Kc();
function cs() {
  function t(g, b) {
    try {
      const T = JSON.parse(g).concat(JSON.parse(b));
      return new Set(T).size < T.length;
    } catch {
      return !1;
    }
  }
  function e(g) {
    var b, T;
    return g.opacity = g.previousOpacity = (T = (b = g.metadata) == null ? void 0 : b.start_opacity) != null ? T : 1, n(g), g;
  }
  function n(g) {
    var T, M, I, A, z, V, q;
    g.currentTimeMinValue || (g.currentTimeMinValue = (I = (T = g.time) == null ? void 0 : T.minDefValue) != null ? I : (M = g.time) == null ? void 0 : M.minValue);
    const b = ((A = g.time) == null ? void 0 : A.mode) === zl.RANGE;
    !g.currentTimeMaxValue && b && (g.currentTimeMaxValue = (q = (z = g.time) == null ? void 0 : z.maxDefValue) != null ? q : (V = g.time) == null ? void 0 : V.maxValue);
  }
  function a(g) {
    var M, I, A;
    const b = s(g);
    let T = g.name;
    return b && (T = (A = (I = (M = g.metadata) == null ? void 0 : M.time_layers) == null ? void 0 : I[b]) != null ? A : T), T;
  }
  function s(g) {
    return [
      g.currentTimeMinValue,
      ...g.currentTimeMaxValue ? [g.currentTimeMaxValue] : []
    ].join(B5);
  }
  function f(g) {
    var I, A;
    const b = Bg();
    if (!((I = g.metadata) != null && I.exclusion))
      return;
    const T = Ei(), M = T.layers.filter(
      (z) => {
        var V, q;
        return t(
          (V = g == null ? void 0 : g.metadata) == null ? void 0 : V.exclusion,
          (q = z == null ? void 0 : z.metadata) == null ? void 0 : q.exclusion
        );
      }
    );
    M.length > 0 && (T.removeLayers(...M.map((z) => z.id)), b.addNotification(
      oi.t(
        "The layer <b>{{layersToRemove}}</b> has been removed because it cannot be displayed while the layer <b>{{layer}}</b> is displayed",
        {
          count: M.length,
          layersToRemove: M.map((z) => oi.t(z.name, { ns: "client" })).join(", "),
          layer: oi.t(g.name, { ns: "client" }),
          ns: "client"
        }
      ),
      Rd.WARNING
    )), g.id !== ((A = T.bgLayer) == null ? void 0 : A.id) && o(g);
  }
  function o(g) {
    var M, I, A;
    const b = Ei(), T = Bg();
    t(
      (M = g.metadata) == null ? void 0 : M.exclusion,
      (A = (I = b.bgLayer) == null ? void 0 : I.metadata) == null ? void 0 : A.exclusion
    ) && (b.setBgLayer(null), T.addNotification(
      oi.t(
        "Background has been deactivated because the layer {{layer}} cannot be displayed on top of it.",
        {
          layer: oi.t(g.name, { ns: "client" }),
          ns: "client"
        }
      ),
      Rd.WARNING
    ));
  }
  function m(g, b = !0, T) {
    var V;
    const M = Ro(), I = Ei(), A = T ? M.layerTrees_3d : M.theme, z = H2.findById(g, A);
    if (z) {
      const q = ((V = z.metadata) == null ? void 0 : V.linked_layers) || [];
      b === !1 ? I.removeLayers(z.id, ...q) : (f(z), (T ? I.add3dLayers : I.addLayers)(
        e(z),
        ...q.map(
          (X) => e(
            H2.findById(parseInt(X, 10))
          )
        )
      ));
    }
  }
  return {
    initLayer: e,
    getLayerCurrentLabel: a,
    getLayerCurrentTime: s,
    handleExclusionLayers: f,
    toggleLayer: m
  };
}
class $6 {
  styleSerialToStyle(e) {
    return e ? JSON.parse(decodeURIComponent(e)) || [] : [];
  }
  styleLocalStorageToStyle(e) {
    return e ? JSON.parse(e).medium || [] : [];
  }
  styleToSerial(e) {
    return e && e.length > 0 ? JSON.stringify(e) : "";
  }
  styleToLocalStorage(e) {
    return e && e.length > 0 ? JSON.stringify({ medium: e }) : "";
  }
}
const By = new $6();
function Z2(t, e) {
  let n;
  return (...a) => {
    clearTimeout(n), n = setTimeout(() => {
      t.apply(a);
    }, e);
  };
}
function Cf(t) {
  return (t == null ? void 0 : t.trim()) && !isNaN(Number(t)) ? Number(t) : void 0;
}
function q6(t, e) {
  return (t == null ? void 0 : t.split(e).map(
    (n) => n !== null && !isNaN(Number(n)) ? parseFloat(n) : void 0
  )) || [];
}
function W6(t, e) {
  return (t == null ? void 0 : t.split(e).map(r1)) || [];
}
function r1(t) {
  return (t == null ? void 0 : t.trim()) === "true" ? !0 : (t == null ? void 0 : t.trim()) === "false" ? !1 : void 0;
}
function HM() {
  return window.matchMedia(
    "(-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2), (min-resolution: 192dpi)"
  ).matches;
}
function Xs(t) {
  return typeof window < "u" && window.navigator && t.test(navigator.userAgent);
}
const H6 = Xs(/firefox/i);
Xs(/safari/i) && !Xs(/chrome/i) && Xs(/android/i);
Xs(/iP(ad|od|hone)/i);
Xs(/chrome/i) && Xs(/android/i);
Xs(/chrome/i);
Xs(
  /(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i
);
Xs(/Edge/i);
const tm = "ipv6", rm = "applogin", nm = "localforage", Pf = "debug", Wg = "fid", Nu = "lang", Hg = "layersOpen", Zg = "address", lx = "version", Z6 = "map_id", X2 = "layers", K2 = "bgLayer", Y2 = "opacities", zd = "theme", J2 = "time", Q2 = "zoom", X6 = "SRS", eE = "X", tE = "Y", Xg = "serial", ZM = [
  "basemap_2015_global",
  "topogr_global",
  "topo_bw_jpeg"
], ux = "lc", cx = "sliderRatio", XM = "bgOpacity", K6 = "layers_indices", rE = "layers_opacity", nE = "layers_visibility";
var oo = /* @__PURE__ */ ((t) => (t[t.localStorage = 0] = "localStorage", t[t.permalink = 1] = "permalink", t[t.permalinkAsPath = 2] = "permalinkAsPath", t[t.permalinkAndLocalStorage = 3] = "permalinkAndLocalStorage", t))(oo || {});
class KM {
}
class Kg extends KM {
  static processRules(e) {
    return Kg.ruleUseLocalStorage(e) ? oo.localStorage : oo.permalink;
  }
  static processRulesForKey(e, n) {
    if (e === zd && {}.VITE_DEPLOY_GHPAGES !== "true")
      return oo.permalinkAsPath;
    if (ZM.includes(e))
      return oo.localStorage;
    if (e === Xg)
      return oo.permalink;
    if (e === Hg)
      return oo.localStorage;
  }
  static ruleUseLocalStorage(e) {
    return [Y6, J6, Q6].reduce(
      (n, a) => n || a(e),
      !1
    );
  }
}
const Y6 = (t) => Object.keys(t).length === 0, J6 = (t) => Object.keys(t).length === 1 && (t.hasOwnProperty(tm) || t.hasOwnProperty(rm) || t.hasOwnProperty(nm)), Q6 = (t) => Object.keys(t).length === 3 && t.hasOwnProperty(tm) && t.hasOwnProperty(rm) && t.hasOwnProperty(nm);
class Yg extends KM {
  static processRules() {
    return oo.permalinkAndLocalStorage;
  }
  static processRulesForKey(e, n) {
    if (Yg.ruleUsePermalink(e))
      return oo.permalink;
    if (e === Hg || ZM.includes(e))
      return oo.localStorage;
    if (e === Xg)
      return oo.permalink;
    if (e === zd)
      return oo.permalinkAsPath;
  }
  static ruleUsePermalink(e) {
    return [
      eF,
      tF,
      rF
    ].reduce(
      (n, a) => n || a(e),
      !1
    );
  }
}
const eF = (t) => t === ux || t === cx, tF = (t) => t === lx, rF = (t) => t === zd && {}.VITE_DEPLOY_GHPAGES === "true";
class YM {
  constructor() {
    ri(this, "snappedUrl");
    this.snappedUrl = new URL(window.location.toString());
  }
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(e) {
    throw new Error("Method key() not implemented. " + e);
  }
  getSnappedUrl() {
    return this.snappedUrl;
  }
  getSnappedParamsAsObj() {
    return this.getSnappedParams().reduce(
      (e, n) => {
        const [a, s] = n.split("=");
        return { ...e, [a]: s };
      },
      {}
    );
  }
  getSnappedParams() {
    return this.getSnappedUrl().search.replace("?", "").split("&").filter((e) => e.split("=")[1]);
  }
  setItem(e, n) {
    const a = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    a.set(encodeURIComponent(e), encodeURIComponent(n));
    try {
      window.history.replaceState(null, "", "?" + a.toString());
    } catch {
    }
  }
  getItem(e) {
    const n = this.getSnappedUrl().searchParams.get(e);
    return n !== null ? decodeURIComponent(n) : n;
  }
  removeItem(e) {
    const n = new URLSearchParams(
      new URL(window.location.toString()).search
    );
    n.delete(e);
    try {
      window.history.replaceState(null, "", "?" + n.toString());
    } catch {
    }
  }
  encodeQueryParam(e, n) {
    return `${encodeURIComponent(e)}=${encodeURIComponent(n)}`;
  }
}
const i0 = new YM();
class nF extends YM {
  getItem(e) {
    const n = this.getSnappedUrl().pathname.split("/"), a = n.findIndex((s) => s === e);
    return n[a + 1];
  }
  setItem(e, n) {
    const a = new URL(window.location.toString()).search, s = `/${e}/${n}${a}`;
    try {
      window.history.replaceState(null, "", s);
    } catch {
    }
  }
}
const iF = new nF();
class oF {
  get length() {
    throw new Error("Method not implemented.");
  }
  clear() {
    throw new Error("Method not implemented.");
  }
  key(e) {
    throw new Error("Method key() not implemented. " + e);
  }
  removeItem(e) {
    const n = this.getWriteStorages(e);
    n == null || n.map(
      (a) => a.removeItem(e)
    );
  }
  setItem(e, n) {
    this.setValue(e, n);
  }
  getItem(e) {
    return this.getValue(e);
  }
  get paramKeys() {
    return i0.getSnappedParamsAsObj();
  }
  getValue(e) {
    var s;
    const n = (s = this.correspondingStorages(
      Kg.processRules(this.paramKeys)
    )) == null ? void 0 : s.pop(), a = this.storageForKey(e, Kg, n);
    return a ? a.getItem(e) : null;
  }
  setValue(e, n) {
    const a = this.getWriteStorages(e);
    a == null || a.map(
      (s) => s.setItem(e, n)
    );
  }
  getWriteStorages(e) {
    const n = this.correspondingStorages(
      Yg.processRules()
    ), a = this.storageForKey(e, Yg);
    return a ? [a] : n;
  }
  storageForKey(e, n, a) {
    var f;
    const s = (f = this.correspondingStorages(
      n.processRulesForKey(e, this.paramKeys)
    )) == null ? void 0 : f.pop();
    return s != null ? s : a;
  }
  correspondingStorages(e) {
    if (e === oo.permalinkAndLocalStorage)
      return [i0, localStorage];
    if (e === oo.localStorage)
      return [localStorage];
    if (e === oo.permalink)
      return [i0];
    if (e === oo.permalinkAsPath)
      return [iF];
  }
}
const Vy = new oF();
function aF(t) {
  return sF(t) || lF(t) || uF(t) || cF(t);
}
const sF = (t) => Object.keys(t).length === 0, lF = (t) => {
  const e = Object.keys(t);
  return Object.keys(t).length === 1 && [
    tm,
    rm,
    nm,
    Wg,
    Nu,
    Zg,
    Pf
  ].some((n) => e.indexOf(n) !== -1);
}, uF = (t) => {
  const e = Object.keys(t), n = (s) => e.indexOf(s) !== -1, a = [
    [rm, nm],
    [Pf, Wg],
    [Nu, Wg],
    [Pf, Nu],
    [Pf, Zg],
    [Nu, Zg]
  ];
  return Object.keys(t).length === 2 && a.reduce(
    (s, f) => s || f.every(n),
    !1
  );
}, cF = (t) => {
  const e = Object.keys(t), n = (o) => e.indexOf(o) !== -1, a = [tm, rm, nm].every(
    n
  ), s = [Pf, Wg, Nu].every(n), f = [Pf, Zg, Nu].every(n);
  return Object.keys(t).length === 3 && (a || s || f);
};
class hF {
  constructor() {
    ri(this, "intialVersion");
    const e = Vy.paramKeys, n = this.getValue(lx, Cf);
    this.intialVersion = n ? Math.max(2, Math.min(n, 3)) : aF(e) ? 3 : 2, this.setValue(lx, 3);
  }
  getInitialVersion() {
    return this.intialVersion;
  }
  mapToEntity(e, n) {
    return n ? n(e) : e;
  }
  mapToStorage(e, n) {
    return n ? n(e) : String(e);
  }
  getValue(e, n) {
    return this.mapToEntity(Vy.getValue(e), n);
  }
  setValue(e, n, a) {
    Vy.setValue(e, this.mapToStorage(n, a));
  }
  removeItem(e) {
    Vy.removeItem(e);
  }
}
const Cr = new hF(), fF = [
  "line",
  "fill",
  "symbol",
  "fill-extrusion",
  "background",
  "hillshade"
], as = () => ({
  bg_layers: [
    {
      icon_id: "route",
      vector_id: "roadmap",
      simple_style_class: "road",
      medium_style_class: "road",
      expert_style_class: "maputnik",
      id: 556,
      is_default: !0
    },
    {
      icon_id: "topo",
      vector_id: "topomap",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 529
    },
    {
      icon_id: "topo_bw",
      vector_id: "topomap_gray",
      medium_style_class: "topo",
      expert_style_class: "maputnik",
      id: 502
    },
    {
      icon_id: "ortho",
      id: 530
    },
    {
      icon_id: "hybrid",
      id: 501
    },
    {
      icon_id: "blank",
      id: 0
    }
  ],
  bg_layer_theme_defaults: {
    tourisme: 502
  },
  simple_styles: {
    road: [
      {
        unlocalized_label: "Light grey",
        hillshade: !1,
        colors: [
          "#ffffff",
          "#ffffff",
          "#d6e0d7",
          "#e1e1e1",
          "#cccccc",
          "#f2f2f2"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Dark grey",
        hillshade: !1,
        colors: [
          "#808080",
          "#808080",
          "#494b4a",
          "#505052",
          "#232426",
          "#454545"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Dark sand",
        hillshade: !1,
        colors: [
          "#9e9375",
          "#9e9375",
          "#6b6249",
          "#403928",
          "#b8aa84",
          "#1a1814"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Kids",
        hillshade: !1,
        colors: [
          "#f9c50d",
          "#ffffff",
          "#839836",
          "#d6d3ce",
          "#2a5ba8",
          "#eeeeee"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Light mauve",
        hillshade: !1,
        colors: [
          "#f3edf5",
          "#f3edf5",
          "#9d7da8",
          "#caa9d1",
          "#613b5c",
          "#e5d3e6"
        ],
        selected: !1
      },
      {
        unlocalized_label: "Light Blue",
        hillshade: !1,
        colors: [
          "#dceaf5",
          "#dceaf5",
          "#5598cf",
          "#81b7e3",
          "#3b576e",
          "#b6cde0"
        ],
        selected: !1
      }
    ]
  },
  medium_default_styles: {
    road: [
      {
        label: "Roads primary",
        color: "#f7f7f7",
        lines: [
          "lu_road_trunk_primary",
          "lu_bridge_major",
          "lu_tunnel_major",
          "lu_road_major_motorway"
        ],
        visible: !0
      },
      {
        label: "Roads secondary",
        color: "#f7f7f7",
        lines: [
          "lu_road_minor",
          "lu_road_secondary_tertiary",
          "lu_bridge_minor",
          "lu_road_path",
          "lu_bridge_path",
          "lu_bridge_railway case",
          "lu_bridge_path case"
        ],
        visible: !0
      },
      {
        label: "Vegetation",
        color: "#B8D293",
        opacity: "1",
        fills: [
          "lu_landcover_wood",
          "lu_landcover_grass",
          "lu_landuse_stadium",
          "lu_landuse_cemetery"
        ],
        visible: !0
      },
      {
        label: "Buildings",
        color: "#D6AA85",
        opacity: "1",
        fillExtrusions: ["lu_building-3d_public", "lu_building-3d"],
        fills: ["lu_building", "lu_building_public"],
        lines: ["lu_bridge_railway", "lu_railway", "lu_tunnel_railway"],
        visible: !0
      },
      {
        label: "Water",
        color: "#94c1e1",
        lines: [
          "lu_waterway",
          "lu_waterway_tunnel",
          "lu_waterway_intermittent"
        ],
        fills: ["lu_water"],
        visible: !0
      },
      {
        label: "Background",
        color: "#e7e7e7",
        backgrounds: ["background"],
        visible: !0
      },
      {
        label: "Hillshade",
        hillshades: ["hillshade"],
        visible: !0
      }
    ],
    topo: [
      {
        label: "Primary Names",
        symbols: [
          "lu_place-label_other",
          "lu_place-label_city",
          "lu_place-label_canton",
          "lu_country-label-other",
          "lu_country-label",
          "place_label_other",
          "place_label_city",
          "country_label-other",
          "country_label"
        ],
        visible: !0
      },
      {
        label: "Secondary Names",
        symbols: [
          "lu_place-label_isolated",
          "lu_place-label_locality_forest",
          "lu_place-label_locality_lieudit"
        ],
        visible: !0
      },
      {
        label: "Transport",
        lines: [
          "lu_tunnel_track-casing",
          "lu_tunnel_major_motorway-casing",
          "lu_tunnel_railway_transit",
          "lu_tunnel_railway",
          "lu_tunnel_railway-hatching",
          "lu_tunnel_path",
          "lu_tunnel_track",
          "lu_tunnel_minor",
          "lu_tunnel_major_motorway",
          "lu_tunnel_secondary_tertiary",
          "lu_tunnel_trunk_primary",
          "lu_road_track-casing",
          "lu_road_minor-casing",
          "lu_road_major_motorway-casing",
          "lu_road_secondary_tertiary-casing",
          "lu_road_trunk_primary-casing",
          "lu_road_pier",
          "lu_road_path",
          "lu_road_track",
          "lu_road_minor",
          "lu_road_major_motorway",
          "lu_road_secondary_tertiary",
          "lu_road_trunk_primary",
          "lu_tram",
          "lu_tram-hatching",
          "lu_railway_transit",
          "lu_railway",
          "lu_railway-hatching",
          "lu_bridge_railway-casing",
          "lu_bridge_track-casing",
          "lu_bridge_path-casing",
          "lu_bridge_minor-casing",
          "lu_bridge_major_motorway-casing",
          "lu_bridge_secondary_tertiary-casing",
          "lu_bridge_trunk_primary-casing",
          "lu_bridge_railway",
          "lu_bridge_path",
          "lu_bridge_track",
          "lu_bridge_minor",
          "lu_bridge_major_motorway",
          "lu_bridge_secondary_tertiary",
          "lu_bridge_trunk_primary",
          "tunnel_track-casing",
          "tunnel_major_motorway-casing",
          "tunnel_railway_transit",
          "tunnel_railway_transit-hatching",
          "tunnel_railway",
          "tunnel_railway-hatching",
          "tunnel_path",
          "tunnel_track",
          "tunnel_minor",
          "tunnel_major_motorway",
          "tunnel_secondary_tertiary",
          "tunnel_trunk_primary",
          "road_track-casing",
          "road_minor-casing",
          "road_major_motorway-casing",
          "road_secondary_tertiary-casing",
          "road_trunk_primary-casing",
          "road_pier",
          "road_path",
          "road_track",
          "road_minor",
          "road_major_motorway",
          "road_secondary_tertiary",
          "road_trunk_primary",
          "railway-transit",
          "railway-transit-hatching",
          "railway",
          "railway-hatching",
          "bridge_railway-casing",
          "bridge_path-casing",
          "bridge_track_casing",
          "bridge_minor-casing",
          "bridge_major_motorway-casing",
          "bridge_secondary_tertiary-casing",
          "bridge_trunk_primary-casing",
          "bridge_railway",
          "bridge_path",
          "bridge_track",
          "bridge_minor",
          "bridge_major_motorway",
          "bridge_secondary_tertiary",
          "bridge_trunk_primary"
        ],
        symbols: [
          "lu_road_major-label",
          "lu_motorway-shield",
          "lu_road-shield"
        ],
        visible: !0
      },
      {
        label: "Vegetation",
        fills: [
          "lu_landuse_stadium",
          "lu_landuse_cemetery",
          "lu_landuse_gras",
          "lu_landuse_park",
          "lu_landuse_park-outline",
          "lu_landuse_vineyard",
          "lu_landuse_orchard",
          "lu_landuse_wood",
          "landcover_grass",
          "landcover_wood"
        ],
        visible: !0
      },
      {
        label: "Electricity",
        fills: ["lu_power_station", "lu_power_pylone"],
        lines: ["lu_power_line", "lu_power_station-outline"],
        symbols: ["lu_power_station-label", "lu_eolienne"],
        visible: !0
      },
      {
        label: "Contours and Height Points",
        lines: [
          "lu_contour-100",
          "lu_contour-50",
          "lu_contour-20",
          "lu_contour-10",
          "lu_contour"
        ],
        symbols: [
          "lu_contour-label-100",
          "lu_contour-label-20",
          "lu_apex-label"
        ],
        visible: !0
      },
      {
        label: "Hillshade",
        hillshades: ["lu_hillshade"],
        visible: !0
      }
    ]
  },
  http_bg_server: "wmts{1-2}",
  https_bg_server: "wmts{3-4}",
  bg_wmts_server_path: "mapproxy_4_v3/wmts/{Layer}",
  bg_wmts_tile_template: "{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}",
  bg_layer_projection: "EPSG:3857",
  olcs_extent: [5.31, 49.38, 6.64, 50.21],
  olcs_extent_projection: "EPSG:3857",
  bg_layer_resolutions: [
    156543.033928,
    78271.516964,
    39135.758482,
    19567.879241,
    9783.9396205,
    4891.96981025,
    2445.98490513,
    1222.99245256,
    611.496226281,
    305.748113141,
    152.87405657,
    76.4370282852,
    38.2185141426,
    19.1092570713,
    9.55462853565,
    4.77731426782,
    2.38865713391,
    1.19432856696,
    0.597164283478,
    0.298582141739,
    0.1492910708695,
    0.07464553543475
  ],
  bg_matrix_ids: [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "20",
    "21"
  ]
});
function qf() {
  function t(V) {
    const q = new URLSearchParams(document.location.search), re = q.get("embeddedserver"), X = q.get("embeddedserverprotocol") || "http";
    return (re ? `${X}://${re}` : "https://vectortiles.geoportail.lu") + `/styles/${V}/style.json`;
  }
  function e(V) {
    return `https://vectortiles.geoportail.lu/styles/${V}/{z}/{x}/{y}.png`;
  }
  function n(V) {
    return /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/gi.test(V);
  }
  const a = Ks();
  function s(V, q) {
    if (V == null)
      return;
    const re = /* @__PURE__ */ new Map();
    a.bgVectorSources.forEach((X, ae) => {
      if (ae === V.id) {
        const ce = { ...X, xyz_custom: q };
        re.set(ae, ce);
      } else
        re.set(ae, X);
    }), a.setBgVectorSources(re);
  }
  function f(V, q, re = !1) {
    const X = "", ae = t(q), ce = e(q), ve = {
      label: V,
      defaultMapBoxStyle: ae,
      defaultMapBoxStyleXYZ: ce,
      xyz: ce,
      xyz_custom: X,
      style: ae
    }, Ne = new URLSearchParams(window.location.search).get("serial"), ze = new URLSearchParams(window.location.search).get(
      "serialLayer"
    );
    if (Ne)
      n(Ne) && console.log(ze);
    else if (!re)
      return Promise.resolve(ve);
    return Promise.resolve(ve);
  }
  function o(V) {
    const q = as().medium_default_styles.road;
    if (V) {
      V.colors.forEach((X, ae) => {
        q[ae].color = X;
      });
      const re = q.findIndex(
        (X) => X.label === "Hillshade"
      );
      q[re].visible = V.hillshade;
    }
    return q;
  }
  function m(V, q, re) {
    if (!V || !q.get(V.id))
      return;
    const X = JSON.parse(
      JSON.stringify(q.get(V.id))
    );
    if (!!X && !(!X || !X.layers))
      return re && re.forEach((ae) => {
        X == null || X.layers.forEach((ce, ve) => {
          for (const Ne of fF)
            if ((ae[`${Ne}s`] || []).includes(ce.id)) {
              const Ae = Object.assign(
                {},
                X.layers[ve].paint
              );
              ae.color && (Ae[`${Ne}-color`] = ae.color, Ae[`${Ne}-opacity`] = 1, X.layers[ve].paint = Ae), X.layers[ve].layout = Object.assign(
                {},
                X.layers[ve].layout,
                { visibility: ae.visible ? "visible" : "none" }
              );
            }
        });
      }), X;
  }
  function g(V, q) {
    if (V === null)
      return Promise.resolve();
    {
      const re = `${q.get("delete")}?id=${V}`;
      return fetch(re).catch(() => "");
    }
  }
  function b(V, q, re) {
    return g(q, re).then(() => {
      const X = new FormData(), ae = JSON.stringify(V), ce = new Blob([ae], { type: "application/json" });
      X.append("style", ce, "style.json");
      const ve = {
        method: "POST",
        body: X
      };
      return fetch(re.get("upload") || "", ve).then((Ne) => Ne.json()).then((Ne) => Ne.id).catch((Ne) => console.warn(Ne));
    });
  }
  function T(V, q) {
    if (!q)
      return;
    const re = V.maplibreMap;
    !re || (re.loaded() ? re.setStyle(q) : new Promise((X) => re.once("data", X)).then(
      () => re.setStyle(q)
    ));
  }
  function M(V) {
    const q = as().bg_layers.find(
      (re) => re.id == (V == null ? void 0 : V.id)
    );
    return q == null ? void 0 : q.vector_id;
  }
  function I(V) {
    const q = as().bg_layers.find(
      (re) => re.id == (V == null ? void 0 : V.id)
    );
    return (q == null ? void 0 : q.vector_id) !== void 0;
  }
  function A(V) {
    const q = as().bg_layers.find(
      (re) => re.id == (V == null ? void 0 : V.id)
    );
    return {
      isEditable: (q == null ? void 0 : q.vector_id) !== void 0,
      hasSimpleStyle: (q == null ? void 0 : q.simple_style_class) !== void 0,
      hasAdvancedStyle: (q == null ? void 0 : q.medium_style_class) !== void 0,
      hasExpertStyle: (q == null ? void 0 : q.expert_style_class) !== void 0
    };
  }
  function z(V, q) {
    return q.map(
      (re) => Object.assign(re, {
        selected: re.colors.every(
          (X, ae) => {
            var ce;
            return ((ce = V[ae]) == null ? void 0 : ce.color) === X;
          }
        )
      })
    );
  }
  return {
    getDefaultMapBoxStyleUrl: t,
    getDefaultMapBoxStyleXYZ: e,
    setConfigForLayer: f,
    getRoadStyleFromSimpleStyle: o,
    applyDefaultStyle: m,
    applyConsolidatedStyle: T,
    getVectorId: M,
    setCustomStyleSerial: s,
    unregisterStyle: g,
    registerStyle: b,
    checkSelection: z,
    isLayerStyleEditable: I,
    getStyleCapabilitiesFromLayer: A
  };
}
const Ks = ih(
  "style",
  () => {
    const t = qf(), e = Bn(), n = Bn(/* @__PURE__ */ new Map()), a = Bn(
      /* @__PURE__ */ new Map()
    ), s = Bn(!1), f = Bn(null), o = Bn(), m = Bn(
      /* @__PURE__ */ new Map([
        ["get", "/getvtstyle"],
        ["upload", "/uploadvtstyle"],
        ["delete", "/deletevtstyle"]
      ])
    ), g = [];
    as().bg_layers.forEach((re) => {
      if (re.vector_id) {
        const X = t.setConfigForLayer(
          re.icon_id,
          re.vector_id
        );
        g.push(
          X.then((ae) => ({ id: re.id, config: ae }))
        );
      }
    }), Promise.all(g).then((re) => {
      const X = /* @__PURE__ */ new Map();
      re.forEach((ae) => X.set(ae.id, ae.config)), n.value = X;
    });
    function b(re, X) {
      m.value.set(re, X);
    }
    function T(re) {
      n.value = re;
    }
    function M(re) {
      const X = /* @__PURE__ */ new Map();
      a.value.forEach((ae, ce) => {
        ce !== re && X.set(ce, ae);
      }), a.value = X;
    }
    function I(re, X) {
      const ae = /* @__PURE__ */ new Map();
      a.value.forEach(
        (ce, ve) => ae.set(ve, ce)
      ), ae.set(re, X), a.value = ae;
    }
    function A(re) {
      e.value = t.getRoadStyleFromSimpleStyle(re), V();
    }
    function z(re) {
      e.value = re, V();
    }
    function V() {
      s.value = !1;
    }
    function q() {
      s.value = !0;
    }
    return {
      bgStyle: e,
      bgVectorSources: n,
      bgVectorBaseStyles: a,
      isExpertStyleActive: s,
      appliedStyle: o,
      removeBaseStyle: M,
      setBaseStyle: I,
      setBgVectorSources: T,
      setRegisterUrl: b,
      setSimpleStyle: A,
      setStyle: z,
      disableExpertStyle: V,
      enableExpertStyle: q,
      styleSerial: f,
      registerUrls: m
    };
  },
  {}
);
class pF {
  constructor() {
    ri(this, "styleWatcher");
  }
  bootstrapStyle() {
    const e = Ks();
    let n, a = !1;
    n = va(() => {
      e.bgVectorSources && (this.restoreStyle(!1), a && this.persistStyle(), a = !0, n && n());
    });
  }
  persistStyle() {
    const e = Ks(), { bgStyle: n } = pn(e);
    this.styleWatcher || (this.styleWatcher = An(
      n,
      (a, s) => {
        if (s !== a) {
          const f = Ei();
          f.bgLayer && (Cr.setValue(
            f.bgLayer.name,
            a || [],
            By.styleToLocalStorage
          ), Cr.setValue(
            Xg,
            a || [],
            By.styleToSerial
          ));
        }
      },
      { immediate: !0 }
    ));
  }
  restoreStyle(e) {
    const n = Ks();
    n.setStyle(null);
    const s = Ei().bgLayer;
    if (s) {
      let f = [];
      e || (f = Cr.getValue(
        Xg,
        By.styleSerialToStyle
      )), f.length === 0 && (f = Cr.getValue(
        s.name,
        By.styleLocalStorageToStyle
      )), f && f.length > 0 && n.setStyle(f);
    }
  }
}
const JM = new pF(), dF = "https://map.geoportail.lu/ogcproxywms", mF = "https://map.geoportail.lu/httpsproxy";
class yF {
  constructor() {
    ri(this, "_wmsProxyUrl", dF);
    ri(this, "_remoteProxyUrl", mF);
  }
  get wmsProxyUrl() {
    return this._wmsProxyUrl === void 0 && console.warn("Warning: proxyWmsUrl is not set."), this._wmsProxyUrl;
  }
  get remoteProxyUrl() {
    return this._remoteProxyUrl === void 0 && console.warn("Warning: remoteProxy is not set."), this._remoteProxyUrl;
  }
  getProxyfiedUrl(e) {
    return e.indexOf("httpsproxy") > 0 ? e : this.remoteProxyUrl + "?url=" + encodeURIComponent(e);
  }
  init_v3(e, n) {
    e && (this._wmsProxyUrl = e), n && (this._remoteProxyUrl = n);
  }
}
const Ff = new yF();
function QM() {
  return EC(
    [5.31, 49.38, 6.64, 50.21],
    VT,
    gd
  );
}
function eI(t) {
  var e;
  return !!((e = t == null ? void 0 : t.metadata) != null && e.hasRetina) && HM();
}
function gF(t, e = "https") {
  const n = t.imageType.split("/")[1], a = Cr.getValue(tm, r1) ? "app.geoportail.lu" : "geoportail.lu";
  return `${e === "https" ? "//wmts{3-4}." : "//wmts{1-2}."}${a}/mapproxy_4_v3/wmts/{Layer}${eI(t) ? "_hd" : ""}/{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}.${n}`;
}
class vF {
  createOlLayer(e) {
    const { name: n, layers: a, imageType: s, url: f, id: o } = e, m = new PE({
      url: f || Ff.wmsProxyUrl,
      hidpi: HM(),
      serverType: "mapserver",
      params: {
        FORMAT: s,
        LAYERS: a
      },
      ...f != null || Ff.remoteProxyUrl ? { crossOrigin: "anonymous" } : {}
    });
    return new OC({
      properties: {
        "olcs.extent": QM(),
        label: n,
        id: o
      },
      source: m
    });
  }
  setLayerTime(e, n) {
    const a = e.getParams();
    a.TIME = n, e.updateParams(a);
  }
}
const tI = new vF(), _F = [
  156543.033928,
  78271.516964,
  39135.758482,
  19567.879241,
  9783.9396205,
  4891.96981025,
  2445.98490513,
  1222.99245256,
  611.496226281,
  305.748113141,
  152.87405657,
  76.4370282852,
  38.2185141426,
  19.1092570713,
  9.55462853565,
  4.77731426782,
  2.38865713391,
  1.19432856696,
  0.597164283478,
  0.298582141739,
  0.1492910708695,
  0.07464553543475
], xF = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "20",
  "21"
];
class bF {
  createOlLayer(e) {
    const { name: n, imageType: a, id: s } = e, f = eI(e), o = Ky(gd), m = o.getExtent(), g = new AE({
      url: gF(e),
      tilePixelRatio: f ? 2 : 1,
      layer: n,
      matrixSet: `GLOBAL_WEBMERCATOR_4_V3${f ? "_HD" : ""}`,
      format: a,
      requestEncoding: "REST",
      projection: o,
      tileGrid: new PC({
        origin: AC(m),
        extent: m,
        resolutions: _F,
        matrixIds: xF
      }),
      style: "default",
      crossOrigin: "anonymous"
    });
    return new CC({
      source: g,
      properties: {
        "olcs.extent": QM(),
        label: n,
        id: s
      }
    });
  }
  setLayerTime(e, n, a) {
    const s = e.get("metadata").time_layers[a], f = n.getUrls();
    if (f) {
      const o = this.transformUrls(f, s);
      n.setUrls(o), e.set("label", s), e.set("layer_name", s);
    }
  }
  transformUrls(e, n) {
    return e.map(
      (a) => a.replace(
        /[/][^/]*[/]{TileMatrixSet}/,
        `/${n}/{TileMatrixSet}`
      )
    );
  }
}
const rI = new bF();
var $s = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, nI = { exports: {} };
(function(t, e) {
  (function(n, a) {
    t.exports = a();
  })($s, function() {
    var n, a, s;
    function f(o, m) {
      if (!n)
        n = m;
      else if (!a)
        a = m;
      else {
        var g = "var sharedChunk = {}; (" + n + ")(sharedChunk); (" + a + ")(sharedChunk);", b = {};
        n(b), s = m(b), typeof window < "u" && (s.workerUrl = window.URL.createObjectURL(new Blob([g], { type: "text/javascript" })));
      }
    }
    return f(["exports"], function(o) {
      function m(r, i) {
        return r(i = { exports: {} }, i.exports), i.exports;
      }
      var g = b;
      function b(r, i, l, p) {
        this.cx = 3 * r, this.bx = 3 * (l - r) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (p - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r, this.p1y = p, this.p2x = l, this.p2y = p;
      }
      b.prototype.sampleCurveX = function(r) {
        return ((this.ax * r + this.bx) * r + this.cx) * r;
      }, b.prototype.sampleCurveY = function(r) {
        return ((this.ay * r + this.by) * r + this.cy) * r;
      }, b.prototype.sampleCurveDerivativeX = function(r) {
        return (3 * this.ax * r + 2 * this.bx) * r + this.cx;
      }, b.prototype.solveCurveX = function(r, i) {
        var l, p, y, v, x;
        for (i === void 0 && (i = 1e-6), y = r, x = 0; x < 8; x++) {
          if (v = this.sampleCurveX(y) - r, Math.abs(v) < i)
            return y;
          var S = this.sampleCurveDerivativeX(y);
          if (Math.abs(S) < 1e-6)
            break;
          y -= v / S;
        }
        if ((y = r) < (l = 0))
          return l;
        if (y > (p = 1))
          return p;
        for (; l < p; ) {
          if (v = this.sampleCurveX(y), Math.abs(v - r) < i)
            return y;
          r > v ? l = y : p = y, y = 0.5 * (p - l) + l;
        }
        return y;
      }, b.prototype.solve = function(r, i) {
        return this.sampleCurveY(this.solveCurveX(r, i));
      };
      var T = M;
      function M(r, i) {
        this.x = r, this.y = i;
      }
      M.prototype = { clone: function() {
        return new M(this.x, this.y);
      }, add: function(r) {
        return this.clone()._add(r);
      }, sub: function(r) {
        return this.clone()._sub(r);
      }, multByPoint: function(r) {
        return this.clone()._multByPoint(r);
      }, divByPoint: function(r) {
        return this.clone()._divByPoint(r);
      }, mult: function(r) {
        return this.clone()._mult(r);
      }, div: function(r) {
        return this.clone()._div(r);
      }, rotate: function(r) {
        return this.clone()._rotate(r);
      }, rotateAround: function(r, i) {
        return this.clone()._rotateAround(r, i);
      }, matMult: function(r) {
        return this.clone()._matMult(r);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(r) {
        return this.x === r.x && this.y === r.y;
      }, dist: function(r) {
        return Math.sqrt(this.distSqr(r));
      }, distSqr: function(r) {
        var i = r.x - this.x, l = r.y - this.y;
        return i * i + l * l;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(r) {
        return Math.atan2(this.y - r.y, this.x - r.x);
      }, angleWith: function(r) {
        return this.angleWithSep(r.x, r.y);
      }, angleWithSep: function(r, i) {
        return Math.atan2(this.x * i - this.y * r, this.x * r + this.y * i);
      }, _matMult: function(r) {
        var i = r[2] * this.x + r[3] * this.y;
        return this.x = r[0] * this.x + r[1] * this.y, this.y = i, this;
      }, _add: function(r) {
        return this.x += r.x, this.y += r.y, this;
      }, _sub: function(r) {
        return this.x -= r.x, this.y -= r.y, this;
      }, _mult: function(r) {
        return this.x *= r, this.y *= r, this;
      }, _div: function(r) {
        return this.x /= r, this.y /= r, this;
      }, _multByPoint: function(r) {
        return this.x *= r.x, this.y *= r.y, this;
      }, _divByPoint: function(r) {
        return this.x /= r.x, this.y /= r.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var r = this.y;
        return this.y = this.x, this.x = -r, this;
      }, _rotate: function(r) {
        var i = Math.cos(r), l = Math.sin(r), p = l * this.x + i * this.y;
        return this.x = i * this.x - l * this.y, this.y = p, this;
      }, _rotateAround: function(r, i) {
        var l = Math.cos(r), p = Math.sin(r), y = i.y + p * (this.x - i.x) + l * (this.y - i.y);
        return this.x = i.x + l * (this.x - i.x) - p * (this.y - i.y), this.y = y, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, M.convert = function(r) {
        return r instanceof M ? r : Array.isArray(r) ? new M(r[0], r[1]) : r;
      };
      var I = typeof self < "u" ? self : {}, A = Math.pow(2, 53) - 1;
      function z(r, i, l, p) {
        var y = new g(r, i, l, p);
        return function(v) {
          return y.solve(v);
        };
      }
      var V = z(0.25, 0.1, 0.25, 1);
      function q(r, i, l) {
        return Math.min(l, Math.max(i, r));
      }
      function re(r, i, l) {
        var p = l - i, y = ((r - i) % p + p) % p + i;
        return y === i ? l : y;
      }
      function X(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        for (var p = 0, y = i; p < y.length; p += 1) {
          var v = y[p];
          for (var x in v)
            r[x] = v[x];
        }
        return r;
      }
      var ae = 1;
      function ce() {
        return ae++;
      }
      function ve() {
        return function r(i) {
          return i ? (i ^ 16 * Math.random() >> i / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, r);
        }();
      }
      function Ne(r) {
        return !!r && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(r);
      }
      function ze(r, i) {
        r.forEach(function(l) {
          i[l] && (i[l] = i[l].bind(i));
        });
      }
      function Ae(r, i) {
        return r.indexOf(i, r.length - i.length) !== -1;
      }
      function Se(r, i, l) {
        var p = {};
        for (var y in r)
          p[y] = i.call(l || this, r[y], y, r);
        return p;
      }
      function Ie(r, i, l) {
        var p = {};
        for (var y in r)
          i.call(l || this, r[y], y, r) && (p[y] = r[y]);
        return p;
      }
      function Xe(r) {
        return Array.isArray(r) ? r.map(Xe) : typeof r == "object" && r ? Se(r, Xe) : r;
      }
      var $e = {};
      function at(r) {
        $e[r] || (typeof console < "u" && console.warn(r), $e[r] = !0);
      }
      function be(r, i, l) {
        return (l.y - r.y) * (i.x - r.x) > (i.y - r.y) * (l.x - r.x);
      }
      function Je(r) {
        for (var i = 0, l = 0, p = r.length, y = p - 1, v = void 0, x = void 0; l < p; y = l++)
          i += ((x = r[y]).x - (v = r[l]).x) * (v.y + x.y);
        return i;
      }
      function ht() {
        return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
      }
      function vt(r) {
        var i = {};
        if (r.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, function(p, y, v, x) {
          var S = v || x;
          return i[y] = !S || S.toLowerCase(), "";
        }), i["max-age"]) {
          var l = parseInt(i["max-age"], 10);
          isNaN(l) ? delete i["max-age"] : i["max-age"] = l;
        }
        return i;
      }
      var At = null;
      function tr(r) {
        if (At == null) {
          var i = r.navigator ? r.navigator.userAgent : null;
          At = !!r.safari || !(!i || !(/\b(iPad|iPhone|iPod)\b/.test(i) || i.match("Safari") && !i.match("Chrome")));
        }
        return At;
      }
      function kn(r) {
        try {
          var i = I[r];
          return i.setItem("_mapbox_test_", 1), i.removeItem("_mapbox_test_"), !0;
        } catch {
          return !1;
        }
      }
      var Nr, pr, Zn, Rr, Fi = I.performance && I.performance.now ? I.performance.now.bind(I.performance) : Date.now.bind(Date), $r = I.requestAnimationFrame || I.mozRequestAnimationFrame || I.webkitRequestAnimationFrame || I.msRequestAnimationFrame, Ar = I.cancelAnimationFrame || I.mozCancelAnimationFrame || I.webkitCancelAnimationFrame || I.msCancelAnimationFrame, Vn = { now: Fi, frame: function(r) {
        var i = $r(r);
        return { cancel: function() {
          return Ar(i);
        } };
      }, getImageData: function(r, i) {
        i === void 0 && (i = 0);
        var l = I.document.createElement("canvas"), p = l.getContext("2d");
        if (!p)
          throw new Error("failed to create canvas 2d context");
        return l.width = r.width, l.height = r.height, p.drawImage(r, 0, 0, r.width, r.height), p.getImageData(-i, -i, r.width + 2 * i, r.height + 2 * i);
      }, resolveURL: function(r) {
        return Nr || (Nr = I.document.createElement("a")), Nr.href = r, Nr.href;
      }, hardwareConcurrency: I.navigator && I.navigator.hardwareConcurrency || 4, get devicePixelRatio() {
        return I.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!I.matchMedia && (pr == null && (pr = I.matchMedia("(prefers-reduced-motion: reduce)")), pr.matches);
      } }, Sr = { API_URL: "https://api.mapbox.com", get EVENTS_URL() {
        return this.API_URL ? this.API_URL.indexOf("https://api.mapbox.cn") === 0 ? "https://events.mapbox.cn/events/v2" : this.API_URL.indexOf("https://api.mapbox.com") === 0 ? "https://events.mapbox.com/events/v2" : null : null;
      }, FEEDBACK_URL: "https://apps.mapbox.com/feedback", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, Sn = { supported: !1, testSupport: function(r) {
        !ai && Rr && (Un ? K(r) : Zn = r);
      } }, ai = !1, Un = !1;
      function K(r) {
        var i = r.createTexture();
        r.bindTexture(r.TEXTURE_2D, i);
        try {
          if (r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, Rr), r.isContextLost())
            return;
          Sn.supported = !0;
        } catch {
        }
        r.deleteTexture(i), ai = !0;
      }
      I.document && ((Rr = I.document.createElement("img")).onload = function() {
        Zn && K(Zn), Zn = null, Un = !0;
      }, Rr.onerror = function() {
        ai = !0, Zn = null;
      }, Rr.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      var ye = "01", Re = function(r, i) {
        this._transformRequestFn = r, this._customAccessToken = i, this._createSkuToken();
      };
      function qe(r) {
        return r.indexOf("mapbox:") === 0;
      }
      Re.prototype._createSkuToken = function() {
        var r = function() {
          for (var i = "", l = 0; l < 10; l++)
            i += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
          return { token: ["1", ye, i].join(""), tokenExpiresAt: Date.now() + 432e5 };
        }();
        this._skuToken = r.token, this._skuTokenExpiresAt = r.tokenExpiresAt;
      }, Re.prototype._isSkuTokenExpired = function() {
        return Date.now() > this._skuTokenExpiresAt;
      }, Re.prototype.transformRequest = function(r, i) {
        return this._transformRequestFn && this._transformRequestFn(r, i) || { url: r };
      }, Re.prototype.normalizeStyleURL = function(r, i) {
        if (!qe(r))
          return r;
        var l = et(r);
        return l.path = "/styles/v1" + l.path, this._makeAPIURL(l, this._customAccessToken || i);
      }, Re.prototype.normalizeGlyphsURL = function(r, i) {
        if (!qe(r))
          return r;
        var l = et(r);
        return l.path = "/fonts/v1" + l.path, this._makeAPIURL(l, this._customAccessToken || i);
      }, Re.prototype.normalizeSourceURL = function(r, i) {
        if (!qe(r))
          return r;
        var l = et(r);
        return l.path = "/v4/" + l.authority + ".json", l.params.push("secure"), this._makeAPIURL(l, this._customAccessToken || i);
      }, Re.prototype.normalizeSpriteURL = function(r, i, l, p) {
        var y = et(r);
        return qe(r) ? (y.path = "/styles/v1" + y.path + "/sprite" + i + l, this._makeAPIURL(y, this._customAccessToken || p)) : (y.path += "" + i + l, ut(y));
      }, Re.prototype.normalizeTileURL = function(r, i) {
        if (this._isSkuTokenExpired() && this._createSkuToken(), r && !qe(r))
          return r;
        var l = et(r);
        l.path = l.path.replace(/(\.(png|jpg)\d*)(?=$)/, (Vn.devicePixelRatio >= 2 || i === 512 ? "@2x" : "") + (Sn.supported ? ".webp" : "$1")), l.path = l.path.replace(/^.+\/v4\//, "/"), l.path = "/v4" + l.path;
        var p = this._customAccessToken || function(y) {
          for (var v = 0, x = y; v < x.length; v += 1) {
            var S = x[v].match(/^access_token=(.*)$/);
            if (S)
              return S[1];
          }
          return null;
        }(l.params) || Sr.ACCESS_TOKEN;
        return Sr.REQUIRE_ACCESS_TOKEN && p && this._skuToken && l.params.push("sku=" + this._skuToken), this._makeAPIURL(l, p);
      }, Re.prototype.canonicalizeTileURL = function(r, i) {
        var l = et(r);
        if (!l.path.match(/(^\/v4\/)/) || !l.path.match(/\.[\w]+$/))
          return r;
        var p = "mapbox://tiles/";
        p += l.path.replace("/v4/", "");
        var y = l.params;
        return i && (y = y.filter(function(v) {
          return !v.match(/^access_token=/);
        })), y.length && (p += "?" + y.join("&")), p;
      }, Re.prototype.canonicalizeTileset = function(r, i) {
        for (var l = !!i && qe(i), p = [], y = 0, v = r.tiles || []; y < v.length; y += 1) {
          var x = v[y];
          nt(x) ? p.push(this.canonicalizeTileURL(x, l)) : p.push(x);
        }
        return p;
      }, Re.prototype._makeAPIURL = function(r, i) {
        var l = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", p = et(Sr.API_URL);
        if (r.protocol = p.protocol, r.authority = p.authority, r.protocol === "http") {
          var y = r.params.indexOf("secure");
          y >= 0 && r.params.splice(y, 1);
        }
        if (p.path !== "/" && (r.path = "" + p.path + r.path), !Sr.REQUIRE_ACCESS_TOKEN)
          return ut(r);
        if (!(i = i || Sr.ACCESS_TOKEN))
          throw new Error("An API access token is required to use Mapbox GL. " + l);
        if (i[0] === "s")
          throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + l);
        return r.params = r.params.filter(function(v) {
          return v.indexOf("access_token") === -1;
        }), r.params.push("access_token=" + i), ut(r);
      };
      var We = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
      function nt(r) {
        return We.test(r);
      }
      var mt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function et(r) {
        var i = r.match(mt);
        if (!i)
          throw new Error("Unable to parse URL object");
        return { protocol: i[1], authority: i[2], path: i[3] || "/", params: i[4] ? i[4].split("&") : [] };
      }
      function ut(r) {
        var i = r.params.length ? "?" + r.params.join("&") : "";
        return r.protocol + "://" + r.authority + r.path + i;
      }
      function Qe(r) {
        if (!r)
          return null;
        var i = r.split(".");
        if (!i || i.length !== 3)
          return null;
        try {
          return JSON.parse(decodeURIComponent(I.atob(i[1]).split("").map(function(l) {
            return "%" + ("00" + l.charCodeAt(0).toString(16)).slice(-2);
          }).join("")));
        } catch {
          return null;
        }
      }
      var It = function(r) {
        this.type = r, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
      };
      It.prototype.getStorageKey = function(r) {
        var i, l = Qe(Sr.ACCESS_TOKEN);
        return i = l && l.u ? I.btoa(encodeURIComponent(l.u).replace(/%([0-9A-F]{2})/g, function(p, y) {
          return String.fromCharCode(Number("0x" + y));
        })) : Sr.ACCESS_TOKEN || "", r ? "mapbox.eventData." + r + ":" + i : "mapbox.eventData:" + i;
      }, It.prototype.fetchEventData = function() {
        var r = kn("localStorage"), i = this.getStorageKey(), l = this.getStorageKey("uuid");
        if (r)
          try {
            var p = I.localStorage.getItem(i);
            p && (this.eventData = JSON.parse(p));
            var y = I.localStorage.getItem(l);
            y && (this.anonId = y);
          } catch {
            at("Unable to read from LocalStorage");
          }
      }, It.prototype.saveEventData = function() {
        var r = kn("localStorage"), i = this.getStorageKey(), l = this.getStorageKey("uuid");
        if (r)
          try {
            I.localStorage.setItem(l, this.anonId), Object.keys(this.eventData).length >= 1 && I.localStorage.setItem(i, JSON.stringify(this.eventData));
          } catch {
            at("Unable to write to LocalStorage");
          }
      }, It.prototype.processRequests = function(r) {
      }, It.prototype.postEvent = function(r, i, l, p) {
        var y = this;
        if (Sr.EVENTS_URL) {
          var v = et(Sr.EVENTS_URL);
          v.params.push("access_token=" + (p || Sr.ACCESS_TOKEN || ""));
          var x = { event: this.type, created: new Date(r).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: "1.13.3", skuId: ye, userId: this.anonId }, S = i ? X(x, i) : x, C = { url: ut(v), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([S]) };
          this.pendingRequest = bn(C, function(P) {
            y.pendingRequest = null, l(P), y.saveEventData(), y.processRequests(p);
          });
        }
      }, It.prototype.queueRequest = function(r, i) {
        this.queue.push(r), this.processRequests(i);
      };
      var bt, Lt, Ut = function(r) {
        function i() {
          r.call(this, "map.load"), this.success = {}, this.skuToken = "";
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.postMapLoadEvent = function(l, p, y, v) {
          this.skuToken = y;
          var x = !(!v && !Sr.ACCESS_TOKEN), S = Array.isArray(l) && l.some(function(C) {
            return qe(C) || nt(C);
          });
          Sr.EVENTS_URL && x && S && this.queueRequest({ id: p, timestamp: Date.now() }, v);
        }, i.prototype.processRequests = function(l) {
          var p = this;
          if (!this.pendingRequest && this.queue.length !== 0) {
            var y = this.queue.shift(), v = y.id, x = y.timestamp;
            v && this.success[v] || (this.anonId || this.fetchEventData(), Ne(this.anonId) || (this.anonId = ve()), this.postEvent(x, { skuToken: this.skuToken }, function(S) {
              S || v && (p.success[v] = !0);
            }, l));
          }
        }, i;
      }(It), dr = new (function(r) {
        function i(l) {
          r.call(this, "appUserTurnstile"), this._customAccessToken = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.postTurnstileEvent = function(l, p) {
          Sr.EVENTS_URL && Sr.ACCESS_TOKEN && Array.isArray(l) && l.some(function(y) {
            return qe(y) || nt(y);
          }) && this.queueRequest(Date.now(), p);
        }, i.prototype.processRequests = function(l) {
          var p = this;
          if (!this.pendingRequest && this.queue.length !== 0) {
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            var y = Qe(Sr.ACCESS_TOKEN), v = y ? y.u : Sr.ACCESS_TOKEN, x = v !== this.eventData.tokenU;
            Ne(this.anonId) || (this.anonId = ve(), x = !0);
            var S = this.queue.shift();
            if (this.eventData.lastSuccess) {
              var C = new Date(this.eventData.lastSuccess), P = new Date(S), L = (S - this.eventData.lastSuccess) / 864e5;
              x = x || L >= 1 || L < -1 || C.getDate() !== P.getDate();
            } else
              x = !0;
            if (!x)
              return this.processRequests();
            this.postEvent(S, { "enabled.telemetry": !1 }, function(D) {
              D || (p.eventData.lastSuccess = S, p.eventData.tokenU = v);
            }, l);
          }
        }, i;
      }(It))(), Vr = dr.postTurnstileEvent.bind(dr), kr = new Ut(), Jr = kr.postMapLoadEvent.bind(kr), Xn = 500, Bi = 50;
      function so() {
        I.caches && !bt && (bt = I.caches.open("mapbox-tiles"));
      }
      function Kn(r) {
        var i = r.indexOf("?");
        return i < 0 ? r : r.slice(0, i);
      }
      var ki, Tn = 1 / 0;
      function si() {
        return ki == null && (ki = I.OffscreenCanvas && new I.OffscreenCanvas(1, 1).getContext("2d") && typeof I.createImageBitmap == "function"), ki;
      }
      var Fa = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
      typeof Object.freeze == "function" && Object.freeze(Fa);
      var Uo = function(r) {
        function i(l, p, y) {
          p === 401 && nt(y) && (l += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), r.call(this, l), this.status = p, this.url = y, this.name = this.constructor.name, this.message = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.toString = function() {
          return this.name + ": " + this.message + " (" + this.status + "): " + this.url;
        }, i;
      }(Error), Ba = ht() ? function() {
        return self.worker && self.worker.referrer;
      } : function() {
        return (I.location.protocol === "blob:" ? I.parent : I).location.href;
      }, na, sn, So = function(r, i) {
        if (!(/^file:/.test(l = r.url) || /^file:/.test(Ba()) && !/^\w+:/.test(l))) {
          if (I.fetch && I.Request && I.AbortController && I.Request.prototype.hasOwnProperty("signal"))
            return function(p, y) {
              var v, x = new I.AbortController(), S = new I.Request(p.url, { method: p.method || "GET", body: p.body, credentials: p.credentials, headers: p.headers, referrer: Ba(), signal: x.signal }), C = !1, P = !1, L = (v = S.url).indexOf("sku=") > 0 && nt(v);
              p.type === "json" && S.headers.set("Accept", "application/json");
              var D = function(j, J, ee) {
                if (!P) {
                  if (j && j.message !== "SecurityError" && at(j), J && ee)
                    return B(J);
                  var he = Date.now();
                  I.fetch(S).then(function(oe) {
                    if (oe.ok) {
                      var ge = L ? oe.clone() : null;
                      return B(oe, ge, he);
                    }
                    return y(new Uo(oe.statusText, oe.status, p.url));
                  }).catch(function(oe) {
                    oe.code !== 20 && y(new Error(oe.message));
                  });
                }
              }, B = function(j, J, ee) {
                (p.type === "arrayBuffer" ? j.arrayBuffer() : p.type === "json" ? j.json() : j.text()).then(function(he) {
                  P || (J && ee && function(oe, ge, we) {
                    if (so(), bt) {
                      var Te = { status: ge.status, statusText: ge.statusText, headers: new I.Headers() };
                      ge.headers.forEach(function(Ve, Ke) {
                        return Te.headers.set(Ke, Ve);
                      });
                      var Oe = vt(ge.headers.get("Cache-Control") || "");
                      Oe["no-store"] || (Oe["max-age"] && Te.headers.set("Expires", new Date(we + 1e3 * Oe["max-age"]).toUTCString()), new Date(Te.headers.get("Expires")).getTime() - we < 42e4 || function(Ve, Ke) {
                        if (Lt === void 0)
                          try {
                            new Response(new ReadableStream()), Lt = !0;
                          } catch {
                            Lt = !1;
                          }
                        Lt ? Ke(Ve.body) : Ve.blob().then(Ke);
                      }(ge, function(Ve) {
                        var Ke = new I.Response(Ve, Te);
                        so(), bt && bt.then(function(ot) {
                          return ot.put(Kn(oe.url), Ke);
                        }).catch(function(ot) {
                          return at(ot.message);
                        });
                      }));
                    }
                  }(S, J, ee), C = !0, y(null, he, j.headers.get("Cache-Control"), j.headers.get("Expires")));
                }).catch(function(he) {
                  P || y(new Error(he.message));
                });
              };
              return L ? function(j, J) {
                if (so(), !bt)
                  return J(null);
                var ee = Kn(j.url);
                bt.then(function(he) {
                  he.match(ee).then(function(oe) {
                    var ge = function(we) {
                      if (!we)
                        return !1;
                      var Te = new Date(we.headers.get("Expires") || 0), Oe = vt(we.headers.get("Cache-Control") || "");
                      return Te > Date.now() && !Oe["no-cache"];
                    }(oe);
                    he.delete(ee), ge && he.put(ee, oe.clone()), J(null, oe, ge);
                  }).catch(J);
                }).catch(J);
              }(S, D) : D(null, null), { cancel: function() {
                P = !0, C || x.abort();
              } };
            }(r, i);
          if (ht() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", r, i, void 0, !0);
        }
        var l;
        return function(p, y) {
          var v = new I.XMLHttpRequest();
          for (var x in v.open(p.method || "GET", p.url, !0), p.type === "arrayBuffer" && (v.responseType = "arraybuffer"), p.headers)
            v.setRequestHeader(x, p.headers[x]);
          return p.type === "json" && (v.responseType = "text", v.setRequestHeader("Accept", "application/json")), v.withCredentials = p.credentials === "include", v.onerror = function() {
            y(new Error(v.statusText));
          }, v.onload = function() {
            if ((v.status >= 200 && v.status < 300 || v.status === 0) && v.response !== null) {
              var S = v.response;
              if (p.type === "json")
                try {
                  S = JSON.parse(v.response);
                } catch (C) {
                  return y(C);
                }
              y(null, S, v.getResponseHeader("Cache-Control"), v.getResponseHeader("Expires"));
            } else
              y(new Uo(v.statusText, v.status, p.url));
          }, v.send(p.body), { cancel: function() {
            return v.abort();
          } };
        }(r, i);
      }, ol = function(r, i) {
        return So(X(r, { type: "arrayBuffer" }), i);
      }, bn = function(r, i) {
        return So(X(r, { method: "POST" }), i);
      }, N = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      na = [], sn = 0;
      var F = function(r, i) {
        if (Sn.supported && (r.headers || (r.headers = {}), r.headers.accept = "image/webp,*/*"), sn >= Sr.MAX_PARALLEL_IMAGE_REQUESTS) {
          var l = { requestParameters: r, callback: i, cancelled: !1, cancel: function() {
            this.cancelled = !0;
          } };
          return na.push(l), l;
        }
        sn++;
        var p = !1, y = function() {
          if (!p)
            for (p = !0, sn--; na.length && sn < Sr.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              var x = na.shift();
              x.cancelled || (x.cancel = F(x.requestParameters, x.callback).cancel);
            }
        }, v = ol(r, function(x, S, C, P) {
          y(), x ? i(x) : S && (si() ? function(L, D) {
            var B = new I.Blob([new Uint8Array(L)], { type: "image/png" });
            I.createImageBitmap(B).then(function(j) {
              D(null, j);
            }).catch(function(j) {
              D(new Error("Could not load image because of " + j.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            });
          }(S, i) : function(L, D, B, j) {
            var J = new I.Image(), ee = I.URL;
            J.onload = function() {
              D(null, J), ee.revokeObjectURL(J.src), J.onload = null, I.requestAnimationFrame(function() {
                J.src = N;
              });
            }, J.onerror = function() {
              return D(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            };
            var he = new I.Blob([new Uint8Array(L)], { type: "image/png" });
            J.cacheControl = B, J.expires = j, J.src = L.byteLength ? ee.createObjectURL(he) : N;
          }(S, i, C, P));
        });
        return { cancel: function() {
          v.cancel(), y();
        } };
      };
      function U(r, i, l) {
        l[r] && l[r].indexOf(i) !== -1 || (l[r] = l[r] || [], l[r].push(i));
      }
      function Z(r, i, l) {
        if (l && l[r]) {
          var p = l[r].indexOf(i);
          p !== -1 && l[r].splice(p, 1);
        }
      }
      var Q = function(r, i) {
        i === void 0 && (i = {}), X(this, i), this.type = r;
      }, pe = function(r) {
        function i(l, p) {
          p === void 0 && (p = {}), r.call(this, "error", X({ error: l }, p));
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(Q), de = function() {
      };
      de.prototype.on = function(r, i) {
        return this._listeners = this._listeners || {}, U(r, i, this._listeners), this;
      }, de.prototype.off = function(r, i) {
        return Z(r, i, this._listeners), Z(r, i, this._oneTimeListeners), this;
      }, de.prototype.once = function(r, i) {
        return this._oneTimeListeners = this._oneTimeListeners || {}, U(r, i, this._oneTimeListeners), this;
      }, de.prototype.fire = function(r, i) {
        typeof r == "string" && (r = new Q(r, i || {}));
        var l = r.type;
        if (this.listens(l)) {
          r.target = this;
          for (var p = 0, y = this._listeners && this._listeners[l] ? this._listeners[l].slice() : []; p < y.length; p += 1)
            y[p].call(this, r);
          for (var v = 0, x = this._oneTimeListeners && this._oneTimeListeners[l] ? this._oneTimeListeners[l].slice() : []; v < x.length; v += 1) {
            var S = x[v];
            Z(l, S, this._oneTimeListeners), S.call(this, r);
          }
          var C = this._eventedParent;
          C && (X(r, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), C.fire(r));
        } else
          r instanceof pe && console.error(r.error);
        return this;
      }, de.prototype.listens = function(r) {
        return this._listeners && this._listeners[r] && this._listeners[r].length > 0 || this._oneTimeListeners && this._oneTimeListeners[r] && this._oneTimeListeners[r].length > 0 || this._eventedParent && this._eventedParent.listens(r);
      }, de.prototype.setEventedParent = function(r, i) {
        return this._eventedParent = r, this._eventedParentData = i, this;
      };
      var G = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }, ie = function(r, i, l, p) {
        this.message = (r ? r + ": " : "") + l, p && (this.identifier = p), i != null && i.__line__ && (this.line = i.__line__);
      };
      function _e(r) {
        var i = r.value;
        return i ? [new ie(r.key, i, "constants have been deprecated as of v8")] : [];
      }
      function Ge(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        for (var p = 0, y = i; p < y.length; p += 1) {
          var v = y[p];
          for (var x in v)
            r[x] = v[x];
        }
        return r;
      }
      function Ze(r) {
        return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
      }
      function Ce(r) {
        if (Array.isArray(r))
          return r.map(Ce);
        if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
          var i = {};
          for (var l in r)
            i[l] = Ce(r[l]);
          return i;
        }
        return Ze(r);
      }
      var Ue = function(r) {
        function i(l, p) {
          r.call(this, p), this.message = p, this.key = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(Error), Et = function(r, i) {
        i === void 0 && (i = []), this.parent = r, this.bindings = {};
        for (var l = 0, p = i; l < p.length; l += 1) {
          var y = p[l];
          this.bindings[y[0]] = y[1];
        }
      };
      Et.prototype.concat = function(r) {
        return new Et(this, r);
      }, Et.prototype.get = function(r) {
        if (this.bindings[r])
          return this.bindings[r];
        if (this.parent)
          return this.parent.get(r);
        throw new Error(r + " not found in scope.");
      }, Et.prototype.has = function(r) {
        return !!this.bindings[r] || !!this.parent && this.parent.has(r);
      };
      var _t = { kind: "null" }, Le = { kind: "number" }, pt = { kind: "string" }, st = { kind: "boolean" }, De = { kind: "color" }, fe = { kind: "object" }, Ee = { kind: "value" }, He = { kind: "collator" }, jt = { kind: "formatted" }, qt = { kind: "resolvedImage" };
      function Jt(r, i) {
        return { kind: "array", itemType: r, N: i };
      }
      function Zt(r) {
        if (r.kind === "array") {
          var i = Zt(r.itemType);
          return typeof r.N == "number" ? "array<" + i + ", " + r.N + ">" : r.itemType.kind === "value" ? "array" : "array<" + i + ">";
        }
        return r.kind;
      }
      var Yn = [_t, Le, pt, st, De, jt, fe, Jt(Ee), qt];
      function Qt(r, i) {
        if (i.kind === "error")
          return null;
        if (r.kind === "array") {
          if (i.kind === "array" && (i.N === 0 && i.itemType.kind === "value" || !Qt(r.itemType, i.itemType)) && (typeof r.N != "number" || r.N === i.N))
            return null;
        } else {
          if (r.kind === i.kind)
            return null;
          if (r.kind === "value") {
            for (var l = 0, p = Yn; l < p.length; l += 1)
              if (!Qt(p[l], i))
                return null;
          }
        }
        return "Expected " + Zt(r) + " but found " + Zt(i) + " instead.";
      }
      function dn(r, i) {
        return i.some(function(l) {
          return l.kind === r.kind;
        });
      }
      function Ur(r, i) {
        return i.some(function(l) {
          return l === "null" ? r === null : l === "array" ? Array.isArray(r) : l === "object" ? r && !Array.isArray(r) && typeof r == "object" : l === typeof r;
        });
      }
      var gr = m(function(r, i) {
        var l = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function p(S) {
          return (S = Math.round(S)) < 0 ? 0 : S > 255 ? 255 : S;
        }
        function y(S) {
          return p(S[S.length - 1] === "%" ? parseFloat(S) / 100 * 255 : parseInt(S));
        }
        function v(S) {
          return (C = S[S.length - 1] === "%" ? parseFloat(S) / 100 : parseFloat(S)) < 0 ? 0 : C > 1 ? 1 : C;
          var C;
        }
        function x(S, C, P) {
          return P < 0 ? P += 1 : P > 1 && (P -= 1), 6 * P < 1 ? S + (C - S) * P * 6 : 2 * P < 1 ? C : 3 * P < 2 ? S + (C - S) * (2 / 3 - P) * 6 : S;
        }
        try {
          i.parseCSSColor = function(S) {
            var C, P = S.replace(/ /g, "").toLowerCase();
            if (P in l)
              return l[P].slice();
            if (P[0] === "#")
              return P.length === 4 ? (C = parseInt(P.substr(1), 16)) >= 0 && C <= 4095 ? [(3840 & C) >> 4 | (3840 & C) >> 8, 240 & C | (240 & C) >> 4, 15 & C | (15 & C) << 4, 1] : null : P.length === 7 && (C = parseInt(P.substr(1), 16)) >= 0 && C <= 16777215 ? [(16711680 & C) >> 16, (65280 & C) >> 8, 255 & C, 1] : null;
            var L = P.indexOf("("), D = P.indexOf(")");
            if (L !== -1 && D + 1 === P.length) {
              var B = P.substr(0, L), j = P.substr(L + 1, D - (L + 1)).split(","), J = 1;
              switch (B) {
                case "rgba":
                  if (j.length !== 4)
                    return null;
                  J = v(j.pop());
                case "rgb":
                  return j.length !== 3 ? null : [y(j[0]), y(j[1]), y(j[2]), J];
                case "hsla":
                  if (j.length !== 4)
                    return null;
                  J = v(j.pop());
                case "hsl":
                  if (j.length !== 3)
                    return null;
                  var ee = (parseFloat(j[0]) % 360 + 360) % 360 / 360, he = v(j[1]), oe = v(j[2]), ge = oe <= 0.5 ? oe * (he + 1) : oe + he - oe * he, we = 2 * oe - ge;
                  return [p(255 * x(we, ge, ee + 1 / 3)), p(255 * x(we, ge, ee)), p(255 * x(we, ge, ee - 1 / 3)), J];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch {
        }
      }).parseCSSColor, zr = function(r, i, l, p) {
        p === void 0 && (p = 1), this.r = r, this.g = i, this.b = l, this.a = p;
      };
      zr.parse = function(r) {
        if (r) {
          if (r instanceof zr)
            return r;
          if (typeof r == "string") {
            var i = gr(r);
            if (i)
              return new zr(i[0] / 255 * i[3], i[1] / 255 * i[3], i[2] / 255 * i[3], i[3]);
          }
        }
      }, zr.prototype.toString = function() {
        var r = this.toArray(), i = r[1], l = r[2], p = r[3];
        return "rgba(" + Math.round(r[0]) + "," + Math.round(i) + "," + Math.round(l) + "," + p + ")";
      }, zr.prototype.toArray = function() {
        var r = this.a;
        return r === 0 ? [0, 0, 0, 0] : [255 * this.r / r, 255 * this.g / r, 255 * this.b / r, r];
      }, zr.black = new zr(0, 0, 0, 1), zr.white = new zr(1, 1, 1, 1), zr.transparent = new zr(0, 0, 0, 0), zr.red = new zr(1, 0, 0, 1);
      var Yi = function(r, i, l) {
        this.sensitivity = r ? i ? "variant" : "case" : i ? "accent" : "base", this.locale = l, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
      };
      Yi.prototype.compare = function(r, i) {
        return this.collator.compare(r, i);
      }, Yi.prototype.resolvedLocale = function() {
        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
      };
      var Zu = function(r, i, l, p, y) {
        this.text = r, this.image = i, this.scale = l, this.fontStack = p, this.textColor = y;
      }, mi = function(r) {
        this.sections = r;
      };
      mi.fromString = function(r) {
        return new mi([new Zu(r, null, null, null, null)]);
      }, mi.prototype.isEmpty = function() {
        return this.sections.length === 0 || !this.sections.some(function(r) {
          return r.text.length !== 0 || r.image && r.image.name.length !== 0;
        });
      }, mi.factory = function(r) {
        return r instanceof mi ? r : mi.fromString(r);
      }, mi.prototype.toString = function() {
        return this.sections.length === 0 ? "" : this.sections.map(function(r) {
          return r.text;
        }).join("");
      }, mi.prototype.serialize = function() {
        for (var r = ["format"], i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          if (p.image)
            r.push(["image", p.image.name]);
          else {
            r.push(p.text);
            var y = {};
            p.fontStack && (y["text-font"] = ["literal", p.fontStack.split(",")]), p.scale && (y["font-scale"] = p.scale), p.textColor && (y["text-color"] = ["rgba"].concat(p.textColor.toArray())), r.push(y);
          }
        }
        return r;
      };
      var Ji = function(r) {
        this.name = r.name, this.available = r.available;
      };
      function Wf(r, i, l, p) {
        return typeof r == "number" && r >= 0 && r <= 255 && typeof i == "number" && i >= 0 && i <= 255 && typeof l == "number" && l >= 0 && l <= 255 ? p === void 0 || typeof p == "number" && p >= 0 && p <= 1 ? null : "Invalid rgba value [" + [r, i, l, p].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + (typeof p == "number" ? [r, i, l, p] : [r, i, l]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
      }
      function Xu(r) {
        if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof zr || r instanceof Yi || r instanceof mi || r instanceof Ji)
          return !0;
        if (Array.isArray(r)) {
          for (var i = 0, l = r; i < l.length; i += 1)
            if (!Xu(l[i]))
              return !1;
          return !0;
        }
        if (typeof r == "object") {
          for (var p in r)
            if (!Xu(r[p]))
              return !1;
          return !0;
        }
        return !1;
      }
      function Ln(r) {
        if (r === null)
          return _t;
        if (typeof r == "string")
          return pt;
        if (typeof r == "boolean")
          return st;
        if (typeof r == "number")
          return Le;
        if (r instanceof zr)
          return De;
        if (r instanceof Yi)
          return He;
        if (r instanceof mi)
          return jt;
        if (r instanceof Ji)
          return qt;
        if (Array.isArray(r)) {
          for (var i, l = r.length, p = 0, y = r; p < y.length; p += 1) {
            var v = Ln(y[p]);
            if (i) {
              if (i === v)
                continue;
              i = Ee;
              break;
            }
            i = v;
          }
          return Jt(i || Ee, l);
        }
        return fe;
      }
      function Ku(r) {
        var i = typeof r;
        return r === null ? "" : i === "string" || i === "number" || i === "boolean" ? String(r) : r instanceof zr || r instanceof mi || r instanceof Ji ? r.toString() : JSON.stringify(r);
      }
      Ji.prototype.toString = function() {
        return this.name;
      }, Ji.fromString = function(r) {
        return r ? new Ji({ name: r, available: !1 }) : null;
      }, Ji.prototype.serialize = function() {
        return ["image", this.name];
      };
      var Vi = function(r, i) {
        this.type = r, this.value = i;
      };
      Vi.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("'literal' expression requires exactly one argument, but found " + (r.length - 1) + " instead.");
        if (!Xu(r[1]))
          return i.error("invalid value");
        var l = r[1], p = Ln(l), y = i.expectedType;
        return p.kind !== "array" || p.N !== 0 || !y || y.kind !== "array" || typeof y.N == "number" && y.N !== 0 || (p = y), new Vi(p, l);
      }, Vi.prototype.evaluate = function() {
        return this.value;
      }, Vi.prototype.eachChild = function() {
      }, Vi.prototype.outputDefined = function() {
        return !0;
      }, Vi.prototype.serialize = function() {
        return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof zr ? ["rgba"].concat(this.value.toArray()) : this.value instanceof mi ? this.value.serialize() : this.value;
      };
      var yi = function(r) {
        this.name = "ExpressionEvaluationError", this.message = r;
      };
      yi.prototype.toJSON = function() {
        return this.message;
      };
      var jo = { string: pt, number: Le, boolean: st, object: fe }, mn = function(r, i) {
        this.type = r, this.args = i;
      };
      mn.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l, p = 1, y = r[0];
        if (y === "array") {
          var v, x;
          if (r.length > 2) {
            var S = r[1];
            if (typeof S != "string" || !(S in jo) || S === "object")
              return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
            v = jo[S], p++;
          } else
            v = Ee;
          if (r.length > 3) {
            if (r[2] !== null && (typeof r[2] != "number" || r[2] < 0 || r[2] !== Math.floor(r[2])))
              return i.error('The length argument to "array" must be a positive integer literal', 2);
            x = r[2], p++;
          }
          l = Jt(v, x);
        } else
          l = jo[y];
        for (var C = []; p < r.length; p++) {
          var P = i.parse(r[p], p, Ee);
          if (!P)
            return null;
          C.push(P);
        }
        return new mn(l, C);
      }, mn.prototype.evaluate = function(r) {
        for (var i = 0; i < this.args.length; i++) {
          var l = this.args[i].evaluate(r);
          if (!Qt(this.type, Ln(l)))
            return l;
          if (i === this.args.length - 1)
            throw new yi("Expected value to be of type " + Zt(this.type) + ", but found " + Zt(Ln(l)) + " instead.");
        }
        return null;
      }, mn.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, mn.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, mn.prototype.serialize = function() {
        var r = this.type, i = [r.kind];
        if (r.kind === "array") {
          var l = r.itemType;
          if (l.kind === "string" || l.kind === "number" || l.kind === "boolean") {
            i.push(l.kind);
            var p = r.N;
            (typeof p == "number" || this.args.length > 1) && i.push(p);
          }
        }
        return i.concat(this.args.map(function(y) {
          return y.serialize();
        }));
      };
      var ia = function(r) {
        this.type = jt, this.sections = r;
      };
      ia.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l = r[1];
        if (!Array.isArray(l) && typeof l == "object")
          return i.error("First argument must be an image or text section.");
        for (var p = [], y = !1, v = 1; v <= r.length - 1; ++v) {
          var x = r[v];
          if (y && typeof x == "object" && !Array.isArray(x)) {
            y = !1;
            var S = null;
            if (x["font-scale"] && !(S = i.parse(x["font-scale"], 1, Le)))
              return null;
            var C = null;
            if (x["text-font"] && !(C = i.parse(x["text-font"], 1, Jt(pt))))
              return null;
            var P = null;
            if (x["text-color"] && !(P = i.parse(x["text-color"], 1, De)))
              return null;
            var L = p[p.length - 1];
            L.scale = S, L.font = C, L.textColor = P;
          } else {
            var D = i.parse(r[v], 1, Ee);
            if (!D)
              return null;
            var B = D.type.kind;
            if (B !== "string" && B !== "value" && B !== "null" && B !== "resolvedImage")
              return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
            y = !0, p.push({ content: D, scale: null, font: null, textColor: null });
          }
        }
        return new ia(p);
      }, ia.prototype.evaluate = function(r) {
        return new mi(this.sections.map(function(i) {
          var l = i.content.evaluate(r);
          return Ln(l) === qt ? new Zu("", l, null, null, null) : new Zu(Ku(l), null, i.scale ? i.scale.evaluate(r) : null, i.font ? i.font.evaluate(r).join(",") : null, i.textColor ? i.textColor.evaluate(r) : null);
        }));
      }, ia.prototype.eachChild = function(r) {
        for (var i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          r(p.content), p.scale && r(p.scale), p.font && r(p.font), p.textColor && r(p.textColor);
        }
      }, ia.prototype.outputDefined = function() {
        return !1;
      }, ia.prototype.serialize = function() {
        for (var r = ["format"], i = 0, l = this.sections; i < l.length; i += 1) {
          var p = l[i];
          r.push(p.content.serialize());
          var y = {};
          p.scale && (y["font-scale"] = p.scale.serialize()), p.font && (y["text-font"] = p.font.serialize()), p.textColor && (y["text-color"] = p.textColor.serialize()), r.push(y);
        }
        return r;
      };
      var To = function(r) {
        this.type = qt, this.input = r;
      };
      To.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected two arguments.");
        var l = i.parse(r[1], 1, pt);
        return l ? new To(l) : i.error("No image name provided.");
      }, To.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r), l = Ji.fromString(i);
        return l && r.availableImages && (l.available = r.availableImages.indexOf(i) > -1), l;
      }, To.prototype.eachChild = function(r) {
        r(this.input);
      }, To.prototype.outputDefined = function() {
        return !1;
      }, To.prototype.serialize = function() {
        return ["image", this.input.serialize()];
      };
      var sm = { "to-boolean": st, "to-color": De, "to-number": Le, "to-string": pt }, Go = function(r, i) {
        this.type = r, this.args = i;
      };
      Go.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expected at least one argument.");
        var l = r[0];
        if ((l === "to-boolean" || l === "to-string") && r.length !== 2)
          return i.error("Expected one argument.");
        for (var p = sm[l], y = [], v = 1; v < r.length; v++) {
          var x = i.parse(r[v], v, Ee);
          if (!x)
            return null;
          y.push(x);
        }
        return new Go(p, y);
      }, Go.prototype.evaluate = function(r) {
        if (this.type.kind === "boolean")
          return Boolean(this.args[0].evaluate(r));
        if (this.type.kind === "color") {
          for (var i, l, p = 0, y = this.args; p < y.length; p += 1) {
            if (l = null, (i = y[p].evaluate(r)) instanceof zr)
              return i;
            if (typeof i == "string") {
              var v = r.parseColor(i);
              if (v)
                return v;
            } else if (Array.isArray(i) && !(l = i.length < 3 || i.length > 4 ? "Invalid rbga value " + JSON.stringify(i) + ": expected an array containing either three or four numeric values." : Wf(i[0], i[1], i[2], i[3])))
              return new zr(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
          }
          throw new yi(l || "Could not parse color from value '" + (typeof i == "string" ? i : String(JSON.stringify(i))) + "'");
        }
        if (this.type.kind === "number") {
          for (var x = null, S = 0, C = this.args; S < C.length; S += 1) {
            if ((x = C[S].evaluate(r)) === null)
              return 0;
            var P = Number(x);
            if (!isNaN(P))
              return P;
          }
          throw new yi("Could not convert " + JSON.stringify(x) + " to number.");
        }
        return this.type.kind === "formatted" ? mi.fromString(Ku(this.args[0].evaluate(r))) : this.type.kind === "resolvedImage" ? Ji.fromString(Ku(this.args[0].evaluate(r))) : Ku(this.args[0].evaluate(r));
      }, Go.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, Go.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, Go.prototype.serialize = function() {
        if (this.type.kind === "formatted")
          return new ia([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
        if (this.type.kind === "resolvedImage")
          return new To(this.args[0]).serialize();
        var r = ["to-" + this.type.kind];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var Bv = ["Unknown", "Point", "LineString", "Polygon"], Va = function() {
        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
      };
      Va.prototype.id = function() {
        return this.feature && "id" in this.feature ? this.feature.id : null;
      }, Va.prototype.geometryType = function() {
        return this.feature ? typeof this.feature.type == "number" ? Bv[this.feature.type] : this.feature.type : null;
      }, Va.prototype.geometry = function() {
        return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
      }, Va.prototype.canonicalID = function() {
        return this.canonical;
      }, Va.prototype.properties = function() {
        return this.feature && this.feature.properties || {};
      }, Va.prototype.parseColor = function(r) {
        var i = this._parseColorCache[r];
        return i || (i = this._parseColorCache[r] = zr.parse(r)), i;
      };
      var Si = function(r, i, l, p) {
        this.name = r, this.type = i, this._evaluate = l, this.args = p;
      };
      Si.prototype.evaluate = function(r) {
        return this._evaluate(r, this.args);
      }, Si.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, Si.prototype.outputDefined = function() {
        return !1;
      }, Si.prototype.serialize = function() {
        return [this.name].concat(this.args.map(function(r) {
          return r.serialize();
        }));
      }, Si.parse = function(r, i) {
        var l, p = r[0], y = Si.definitions[p];
        if (!y)
          return i.error('Unknown expression "' + p + '". If you wanted a literal array, use ["literal", [...]].', 0);
        for (var v = Array.isArray(y) ? y[0] : y.type, x = Array.isArray(y) ? [[y[1], y[2]]] : y.overloads, S = x.filter(function(Rt) {
          var yt = Rt[0];
          return !Array.isArray(yt) || yt.length === r.length - 1;
        }), C = null, P = 0, L = S; P < L.length; P += 1) {
          var D = L[P], B = D[0], j = D[1];
          C = new ys(i.registry, i.path, null, i.scope);
          for (var J = [], ee = !1, he = 1; he < r.length; he++) {
            var oe = r[he], ge = Array.isArray(B) ? B[he - 1] : B.type, we = C.parse(oe, 1 + J.length, ge);
            if (!we) {
              ee = !0;
              break;
            }
            J.push(we);
          }
          if (!ee)
            if (Array.isArray(B) && B.length !== J.length)
              C.error("Expected " + B.length + " arguments, but found " + J.length + " instead.");
            else {
              for (var Te = 0; Te < J.length; Te++) {
                var Oe = Array.isArray(B) ? B[Te] : B.type, Ve = J[Te];
                C.concat(Te + 1).checkSubtype(Oe, Ve.type);
              }
              if (C.errors.length === 0)
                return new Si(p, v, j, J);
            }
        }
        if (S.length === 1)
          (l = i.errors).push.apply(l, C.errors);
        else {
          for (var Ke = (S.length ? S : x).map(function(Rt) {
            var yt;
            return yt = Rt[0], Array.isArray(yt) ? "(" + yt.map(Zt).join(", ") + ")" : "(" + Zt(yt.type) + "...)";
          }).join(" | "), ot = [], Pt = 1; Pt < r.length; Pt++) {
            var dt = i.parse(r[Pt], 1 + ot.length);
            if (!dt)
              return null;
            ot.push(Zt(dt.type));
          }
          i.error("Expected arguments of type " + Ke + ", but found (" + ot.join(", ") + ") instead.");
        }
        return null;
      }, Si.register = function(r, i) {
        for (var l in Si.definitions = i, i)
          r[l] = Si;
      };
      var xa = function(r, i, l) {
        this.type = He, this.locale = l, this.caseSensitive = r, this.diacriticSensitive = i;
      };
      function Ui(r, i) {
        r[0] = Math.min(r[0], i[0]), r[1] = Math.min(r[1], i[1]), r[2] = Math.max(r[2], i[0]), r[3] = Math.max(r[3], i[1]);
      }
      function al(r, i) {
        return !(r[0] <= i[0] || r[2] >= i[2] || r[1] <= i[1] || r[3] >= i[3]);
      }
      function Vv(r, i) {
        var l = (180 + r[0]) / 360, p = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r[1] * Math.PI / 360))) / 360, y = Math.pow(2, i.z);
        return [Math.round(l * y * 8192), Math.round(p * y * 8192)];
      }
      function Uv(r, i, l) {
        return i[1] > r[1] != l[1] > r[1] && r[0] < (l[0] - i[0]) * (r[1] - i[1]) / (l[1] - i[1]) + i[0];
      }
      function Hf(r, i) {
        for (var l, p, y, v, x, S, C, P = !1, L = 0, D = i.length; L < D; L++)
          for (var B = i[L], j = 0, J = B.length; j < J - 1; j++) {
            if ((v = (l = r)[0] - (p = B[j])[0]) * (C = l[1] - (y = B[j + 1])[1]) - (S = l[0] - y[0]) * (x = l[1] - p[1]) == 0 && v * S <= 0 && x * C <= 0)
              return !1;
            Uv(r, B[j], B[j + 1]) && (P = !P);
          }
        return P;
      }
      function jv(r, i) {
        for (var l = 0; l < i.length; l++)
          if (Hf(r, i[l]))
            return !0;
        return !1;
      }
      function lm(r, i, l, p) {
        var y = p[0] - l[0], v = p[1] - l[1], x = (r[0] - l[0]) * v - y * (r[1] - l[1]), S = (i[0] - l[0]) * v - y * (i[1] - l[1]);
        return x > 0 && S < 0 || x < 0 && S > 0;
      }
      function Gv(r, i, l) {
        for (var p = 0, y = l; p < y.length; p += 1)
          for (var v = y[p], x = 0; x < v.length - 1; ++x)
            if ((D = [(L = v[x + 1])[0] - (P = v[x])[0], L[1] - P[1]])[0] * (B = [(C = i)[0] - (S = r)[0], C[1] - S[1]])[1] - D[1] * B[0] != 0 && lm(S, C, P, L) && lm(P, L, S, C))
              return !0;
        var S, C, P, L, D, B;
        return !1;
      }
      function um(r, i) {
        for (var l = 0; l < r.length; ++l)
          if (!Hf(r[l], i))
            return !1;
        for (var p = 0; p < r.length - 1; ++p)
          if (Gv(r[p], r[p + 1], i))
            return !1;
        return !0;
      }
      function cm(r, i) {
        for (var l = 0; l < i.length; l++)
          if (um(r, i[l]))
            return !0;
        return !1;
      }
      function Kl(r, i, l) {
        for (var p = [], y = 0; y < r.length; y++) {
          for (var v = [], x = 0; x < r[y].length; x++) {
            var S = Vv(r[y][x], l);
            Ui(i, S), v.push(S);
          }
          p.push(v);
        }
        return p;
      }
      function Zf(r, i, l) {
        for (var p = [], y = 0; y < r.length; y++) {
          var v = Kl(r[y], i, l);
          p.push(v);
        }
        return p;
      }
      function Yu(r, i, l, p) {
        if (r[0] < l[0] || r[0] > l[2]) {
          var y = 0.5 * p, v = r[0] - l[0] > y ? -p : l[0] - r[0] > y ? p : 0;
          v === 0 && (v = r[0] - l[2] > y ? -p : l[2] - r[0] > y ? p : 0), r[0] += v;
        }
        Ui(i, r);
      }
      function hm(r, i, l, p) {
        for (var y = 8192 * Math.pow(2, p.z), v = [8192 * p.x, 8192 * p.y], x = [], S = 0, C = r; S < C.length; S += 1)
          for (var P = 0, L = C[S]; P < L.length; P += 1) {
            var D = L[P], B = [D.x + v[0], D.y + v[1]];
            Yu(B, i, l, y), x.push(B);
          }
        return x;
      }
      function lh(r, i, l, p) {
        for (var y, v = 8192 * Math.pow(2, p.z), x = [8192 * p.x, 8192 * p.y], S = [], C = 0, P = r; C < P.length; C += 1) {
          for (var L = [], D = 0, B = P[C]; D < B.length; D += 1) {
            var j = B[D], J = [j.x + x[0], j.y + x[1]];
            Ui(i, J), L.push(J);
          }
          S.push(L);
        }
        if (i[2] - i[0] <= v / 2) {
          (y = i)[0] = y[1] = 1 / 0, y[2] = y[3] = -1 / 0;
          for (var ee = 0, he = S; ee < he.length; ee += 1)
            for (var oe = 0, ge = he[ee]; oe < ge.length; oe += 1)
              Yu(ge[oe], i, l, v);
        }
        return S;
      }
      xa.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected one argument.");
        var l = r[1];
        if (typeof l != "object" || Array.isArray(l))
          return i.error("Collator options argument must be an object.");
        var p = i.parse(l["case-sensitive"] !== void 0 && l["case-sensitive"], 1, st);
        if (!p)
          return null;
        var y = i.parse(l["diacritic-sensitive"] !== void 0 && l["diacritic-sensitive"], 1, st);
        if (!y)
          return null;
        var v = null;
        return l.locale && !(v = i.parse(l.locale, 1, pt)) ? null : new xa(p, y, v);
      }, xa.prototype.evaluate = function(r) {
        return new Yi(this.caseSensitive.evaluate(r), this.diacriticSensitive.evaluate(r), this.locale ? this.locale.evaluate(r) : null);
      }, xa.prototype.eachChild = function(r) {
        r(this.caseSensitive), r(this.diacriticSensitive), this.locale && r(this.locale);
      }, xa.prototype.outputDefined = function() {
        return !1;
      }, xa.prototype.serialize = function() {
        var r = {};
        return r["case-sensitive"] = this.caseSensitive.serialize(), r["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (r.locale = this.locale.serialize()), ["collator", r];
      };
      var $o = function(r, i) {
        this.type = st, this.geojson = r, this.geometries = i;
      };
      function ps(r) {
        if (r instanceof Si && (r.name === "get" && r.args.length === 1 || r.name === "feature-state" || r.name === "has" && r.args.length === 1 || r.name === "properties" || r.name === "geometry-type" || r.name === "id" || /^filter-/.test(r.name)) || r instanceof $o)
          return !1;
        var i = !0;
        return r.eachChild(function(l) {
          i && !ps(l) && (i = !1);
        }), i;
      }
      function ds(r) {
        if (r instanceof Si && r.name === "feature-state")
          return !1;
        var i = !0;
        return r.eachChild(function(l) {
          i && !ds(l) && (i = !1);
        }), i;
      }
      function sl(r, i) {
        if (r instanceof Si && i.indexOf(r.name) >= 0)
          return !1;
        var l = !0;
        return r.eachChild(function(p) {
          l && !sl(p, i) && (l = !1);
        }), l;
      }
      $o.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("'within' expression requires exactly one argument, but found " + (r.length - 1) + " instead.");
        if (Xu(r[1])) {
          var l = r[1];
          if (l.type === "FeatureCollection")
            for (var p = 0; p < l.features.length; ++p) {
              var y = l.features[p].geometry.type;
              if (y === "Polygon" || y === "MultiPolygon")
                return new $o(l, l.features[p].geometry);
            }
          else if (l.type === "Feature") {
            var v = l.geometry.type;
            if (v === "Polygon" || v === "MultiPolygon")
              return new $o(l, l.geometry);
          } else if (l.type === "Polygon" || l.type === "MultiPolygon")
            return new $o(l, l);
        }
        return i.error("'within' expression requires valid geojson object that contains polygon geometry type.");
      }, $o.prototype.evaluate = function(r) {
        if (r.geometry() != null && r.canonicalID() != null) {
          if (r.geometryType() === "Point")
            return function(i, l) {
              var p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = i.canonicalID();
              if (l.type === "Polygon") {
                var x = Kl(l.coordinates, y, v), S = hm(i.geometry(), p, y, v);
                if (!al(p, y))
                  return !1;
                for (var C = 0, P = S; C < P.length; C += 1)
                  if (!Hf(P[C], x))
                    return !1;
              }
              if (l.type === "MultiPolygon") {
                var L = Zf(l.coordinates, y, v), D = hm(i.geometry(), p, y, v);
                if (!al(p, y))
                  return !1;
                for (var B = 0, j = D; B < j.length; B += 1)
                  if (!jv(j[B], L))
                    return !1;
              }
              return !0;
            }(r, this.geometries);
          if (r.geometryType() === "LineString")
            return function(i, l) {
              var p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = i.canonicalID();
              if (l.type === "Polygon") {
                var x = Kl(l.coordinates, y, v), S = lh(i.geometry(), p, y, v);
                if (!al(p, y))
                  return !1;
                for (var C = 0, P = S; C < P.length; C += 1)
                  if (!um(P[C], x))
                    return !1;
              }
              if (l.type === "MultiPolygon") {
                var L = Zf(l.coordinates, y, v), D = lh(i.geometry(), p, y, v);
                if (!al(p, y))
                  return !1;
                for (var B = 0, j = D; B < j.length; B += 1)
                  if (!cm(j[B], L))
                    return !1;
              }
              return !0;
            }(r, this.geometries);
        }
        return !1;
      }, $o.prototype.eachChild = function() {
      }, $o.prototype.outputDefined = function() {
        return !0;
      }, $o.prototype.serialize = function() {
        return ["within", this.geojson];
      };
      var ms = function(r, i) {
        this.type = i.type, this.name = r, this.boundExpression = i;
      };
      ms.parse = function(r, i) {
        if (r.length !== 2 || typeof r[1] != "string")
          return i.error("'var' expression requires exactly one string literal argument.");
        var l = r[1];
        return i.scope.has(l) ? new ms(l, i.scope.get(l)) : i.error('Unknown variable "' + l + '". Make sure "' + l + '" has been bound in an enclosing "let" expression before using it.', 1);
      }, ms.prototype.evaluate = function(r) {
        return this.boundExpression.evaluate(r);
      }, ms.prototype.eachChild = function() {
      }, ms.prototype.outputDefined = function() {
        return !1;
      }, ms.prototype.serialize = function() {
        return ["var", this.name];
      };
      var ys = function(r, i, l, p, y) {
        i === void 0 && (i = []), p === void 0 && (p = new Et()), y === void 0 && (y = []), this.registry = r, this.path = i, this.key = i.map(function(v) {
          return "[" + v + "]";
        }).join(""), this.scope = p, this.errors = y, this.expectedType = l;
      };
      function uh(r, i) {
        for (var l, p = r.length - 1, y = 0, v = p, x = 0; y <= v; )
          if ((l = r[x = Math.floor((y + v) / 2)]) <= i) {
            if (x === p || i < r[x + 1])
              return x;
            y = x + 1;
          } else {
            if (!(l > i))
              throw new yi("Input is not a number.");
            v = x - 1;
          }
        return 0;
      }
      ys.prototype.parse = function(r, i, l, p, y) {
        return y === void 0 && (y = {}), i ? this.concat(i, l, p)._parse(r, y) : this._parse(r, y);
      }, ys.prototype._parse = function(r, i) {
        function l(P, L, D) {
          return D === "assert" ? new mn(L, [P]) : D === "coerce" ? new Go(L, [P]) : P;
        }
        if (r !== null && typeof r != "string" && typeof r != "boolean" && typeof r != "number" || (r = ["literal", r]), Array.isArray(r)) {
          if (r.length === 0)
            return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
          var p = r[0];
          if (typeof p != "string")
            return this.error("Expression name must be a string, but found " + typeof p + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null;
          var y = this.registry[p];
          if (y) {
            var v = y.parse(r, this);
            if (!v)
              return null;
            if (this.expectedType) {
              var x = this.expectedType, S = v.type;
              if (x.kind !== "string" && x.kind !== "number" && x.kind !== "boolean" && x.kind !== "object" && x.kind !== "array" || S.kind !== "value")
                if (x.kind !== "color" && x.kind !== "formatted" && x.kind !== "resolvedImage" || S.kind !== "value" && S.kind !== "string") {
                  if (this.checkSubtype(x, S))
                    return null;
                } else
                  v = l(v, x, i.typeAnnotation || "coerce");
              else
                v = l(v, x, i.typeAnnotation || "assert");
            }
            if (!(v instanceof Vi) && v.type.kind !== "resolvedImage" && function P(L) {
              if (L instanceof ms)
                return P(L.boundExpression);
              if (L instanceof Si && L.name === "error" || L instanceof xa || L instanceof $o)
                return !1;
              var D = L instanceof Go || L instanceof mn, B = !0;
              return L.eachChild(function(j) {
                B = D ? B && P(j) : B && j instanceof Vi;
              }), !!B && ps(L) && sl(L, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
            }(v)) {
              var C = new Va();
              try {
                v = new Vi(v.type, v.evaluate(C));
              } catch (P) {
                return this.error(P.message), null;
              }
            }
            return v;
          }
          return this.error('Unknown expression "' + p + '". If you wanted a literal array, use ["literal", [...]].', 0);
        }
        return this.error(r === void 0 ? "'undefined' value invalid. Use null instead." : typeof r == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found " + typeof r + " instead.");
      }, ys.prototype.concat = function(r, i, l) {
        var p = typeof r == "number" ? this.path.concat(r) : this.path, y = l ? this.scope.concat(l) : this.scope;
        return new ys(this.registry, p, i || null, y, this.errors);
      }, ys.prototype.error = function(r) {
        for (var i = [], l = arguments.length - 1; l-- > 0; )
          i[l] = arguments[l + 1];
        var p = "" + this.key + i.map(function(y) {
          return "[" + y + "]";
        }).join("");
        this.errors.push(new Ue(p, r));
      }, ys.prototype.checkSubtype = function(r, i) {
        var l = Qt(r, i);
        return l && this.error(l), l;
      };
      var lo = function(r, i, l) {
        this.type = r, this.input = i, this.labels = [], this.outputs = [];
        for (var p = 0, y = l; p < y.length; p += 1) {
          var v = y[p], x = v[1];
          this.labels.push(v[0]), this.outputs.push(x);
        }
      };
      function jn(r, i, l) {
        return r * (1 - l) + i * l;
      }
      lo.parse = function(r, i) {
        if (r.length - 1 < 4)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if ((r.length - 1) % 2 != 0)
          return i.error("Expected an even number of arguments.");
        var l = i.parse(r[1], 1, Le);
        if (!l)
          return null;
        var p = [], y = null;
        i.expectedType && i.expectedType.kind !== "value" && (y = i.expectedType);
        for (var v = 1; v < r.length; v += 2) {
          var x = v === 1 ? -1 / 0 : r[v], S = r[v + 1], C = v, P = v + 1;
          if (typeof x != "number")
            return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', C);
          if (p.length && p[p.length - 1][0] >= x)
            return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', C);
          var L = i.parse(S, P, y);
          if (!L)
            return null;
          y = y || L.type, p.push([x, L]);
        }
        return new lo(y, l, p);
      }, lo.prototype.evaluate = function(r) {
        var i = this.labels, l = this.outputs;
        if (i.length === 1)
          return l[0].evaluate(r);
        var p = this.input.evaluate(r);
        if (p <= i[0])
          return l[0].evaluate(r);
        var y = i.length;
        return p >= i[y - 1] ? l[y - 1].evaluate(r) : l[uh(i, p)].evaluate(r);
      }, lo.prototype.eachChild = function(r) {
        r(this.input);
        for (var i = 0, l = this.outputs; i < l.length; i += 1)
          r(l[i]);
      }, lo.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        });
      }, lo.prototype.serialize = function() {
        for (var r = ["step", this.input.serialize()], i = 0; i < this.labels.length; i++)
          i > 0 && r.push(this.labels[i]), r.push(this.outputs[i].serialize());
        return r;
      };
      var Yl = Object.freeze({ __proto__: null, number: jn, color: function(r, i, l) {
        return new zr(jn(r.r, i.r, l), jn(r.g, i.g, l), jn(r.b, i.b, l), jn(r.a, i.a, l));
      }, array: function(r, i, l) {
        return r.map(function(p, y) {
          return jn(p, i[y], l);
        });
      } }), fm = 6 / 29 * 3 * (6 / 29), $v = Math.PI / 180, qv = 180 / Math.PI;
      function Xf(r) {
        return r > 0.008856451679035631 ? Math.pow(r, 1 / 3) : r / fm + 4 / 29;
      }
      function Kf(r) {
        return r > 6 / 29 ? r * r * r : fm * (r - 4 / 29);
      }
      function Yf(r) {
        return 255 * (r <= 31308e-7 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055);
      }
      function Jf(r) {
        return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      }
      function pm(r) {
        var i = Jf(r.r), l = Jf(r.g), p = Jf(r.b), y = Xf((0.4124564 * i + 0.3575761 * l + 0.1804375 * p) / 0.95047), v = Xf((0.2126729 * i + 0.7151522 * l + 0.072175 * p) / 1);
        return { l: 116 * v - 16, a: 500 * (y - v), b: 200 * (v - Xf((0.0193339 * i + 0.119192 * l + 0.9503041 * p) / 1.08883)), alpha: r.a };
      }
      function dm(r) {
        var i = (r.l + 16) / 116, l = isNaN(r.a) ? i : i + r.a / 500, p = isNaN(r.b) ? i : i - r.b / 200;
        return i = 1 * Kf(i), l = 0.95047 * Kf(l), p = 1.08883 * Kf(p), new zr(Yf(3.2404542 * l - 1.5371385 * i - 0.4985314 * p), Yf(-0.969266 * l + 1.8760108 * i + 0.041556 * p), Yf(0.0556434 * l - 0.2040259 * i + 1.0572252 * p), r.alpha);
      }
      function Wv(r, i, l) {
        var p = i - r;
        return r + l * (p > 180 || p < -180 ? p - 360 * Math.round(p / 360) : p);
      }
      var Ju = { forward: pm, reverse: dm, interpolate: function(r, i, l) {
        return { l: jn(r.l, i.l, l), a: jn(r.a, i.a, l), b: jn(r.b, i.b, l), alpha: jn(r.alpha, i.alpha, l) };
      } }, Qu = { forward: function(r) {
        var i = pm(r), l = i.l, p = i.a, y = i.b, v = Math.atan2(y, p) * qv;
        return { h: v < 0 ? v + 360 : v, c: Math.sqrt(p * p + y * y), l, alpha: r.a };
      }, reverse: function(r) {
        var i = r.h * $v, l = r.c;
        return dm({ l: r.l, a: Math.cos(i) * l, b: Math.sin(i) * l, alpha: r.alpha });
      }, interpolate: function(r, i, l) {
        return { h: Wv(r.h, i.h, l), c: jn(r.c, i.c, l), l: jn(r.l, i.l, l), alpha: jn(r.alpha, i.alpha, l) };
      } }, mm = Object.freeze({ __proto__: null, lab: Ju, hcl: Qu }), Ti = function(r, i, l, p, y) {
        this.type = r, this.operator = i, this.interpolation = l, this.input = p, this.labels = [], this.outputs = [];
        for (var v = 0, x = y; v < x.length; v += 1) {
          var S = x[v], C = S[1];
          this.labels.push(S[0]), this.outputs.push(C);
        }
      };
      function Qf(r, i, l, p) {
        var y = p - l, v = r - l;
        return y === 0 ? 0 : i === 1 ? v / y : (Math.pow(i, v) - 1) / (Math.pow(i, y) - 1);
      }
      Ti.interpolationFactor = function(r, i, l, p) {
        var y = 0;
        if (r.name === "exponential")
          y = Qf(i, r.base, l, p);
        else if (r.name === "linear")
          y = Qf(i, 1, l, p);
        else if (r.name === "cubic-bezier") {
          var v = r.controlPoints;
          y = new g(v[0], v[1], v[2], v[3]).solve(Qf(i, 1, l, p));
        }
        return y;
      }, Ti.parse = function(r, i) {
        var l = r[0], p = r[1], y = r[2], v = r.slice(3);
        if (!Array.isArray(p) || p.length === 0)
          return i.error("Expected an interpolation type expression.", 1);
        if (p[0] === "linear")
          p = { name: "linear" };
        else if (p[0] === "exponential") {
          var x = p[1];
          if (typeof x != "number")
            return i.error("Exponential interpolation requires a numeric base.", 1, 1);
          p = { name: "exponential", base: x };
        } else {
          if (p[0] !== "cubic-bezier")
            return i.error("Unknown interpolation type " + String(p[0]), 1, 0);
          var S = p.slice(1);
          if (S.length !== 4 || S.some(function(he) {
            return typeof he != "number" || he < 0 || he > 1;
          }))
            return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
          p = { name: "cubic-bezier", controlPoints: S };
        }
        if (r.length - 1 < 4)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if ((r.length - 1) % 2 != 0)
          return i.error("Expected an even number of arguments.");
        if (!(y = i.parse(y, 2, Le)))
          return null;
        var C = [], P = null;
        l === "interpolate-hcl" || l === "interpolate-lab" ? P = De : i.expectedType && i.expectedType.kind !== "value" && (P = i.expectedType);
        for (var L = 0; L < v.length; L += 2) {
          var D = v[L], B = v[L + 1], j = L + 3, J = L + 4;
          if (typeof D != "number")
            return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', j);
          if (C.length && C[C.length - 1][0] >= D)
            return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', j);
          var ee = i.parse(B, J, P);
          if (!ee)
            return null;
          P = P || ee.type, C.push([D, ee]);
        }
        return P.kind === "number" || P.kind === "color" || P.kind === "array" && P.itemType.kind === "number" && typeof P.N == "number" ? new Ti(P, l, p, y, C) : i.error("Type " + Zt(P) + " is not interpolatable.");
      }, Ti.prototype.evaluate = function(r) {
        var i = this.labels, l = this.outputs;
        if (i.length === 1)
          return l[0].evaluate(r);
        var p = this.input.evaluate(r);
        if (p <= i[0])
          return l[0].evaluate(r);
        var y = i.length;
        if (p >= i[y - 1])
          return l[y - 1].evaluate(r);
        var v = uh(i, p), x = Ti.interpolationFactor(this.interpolation, p, i[v], i[v + 1]), S = l[v].evaluate(r), C = l[v + 1].evaluate(r);
        return this.operator === "interpolate" ? Yl[this.type.kind.toLowerCase()](S, C, x) : this.operator === "interpolate-hcl" ? Qu.reverse(Qu.interpolate(Qu.forward(S), Qu.forward(C), x)) : Ju.reverse(Ju.interpolate(Ju.forward(S), Ju.forward(C), x));
      }, Ti.prototype.eachChild = function(r) {
        r(this.input);
        for (var i = 0, l = this.outputs; i < l.length; i += 1)
          r(l[i]);
      }, Ti.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        });
      }, Ti.prototype.serialize = function() {
        var r;
        r = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
        for (var i = [this.operator, r, this.input.serialize()], l = 0; l < this.labels.length; l++)
          i.push(this.labels[l], this.outputs[l].serialize());
        return i;
      };
      var gs = function(r, i) {
        this.type = r, this.args = i;
      };
      gs.parse = function(r, i) {
        if (r.length < 2)
          return i.error("Expectected at least one argument.");
        var l = null, p = i.expectedType;
        p && p.kind !== "value" && (l = p);
        for (var y = [], v = 0, x = r.slice(1); v < x.length; v += 1) {
          var S = i.parse(x[v], 1 + y.length, l, void 0, { typeAnnotation: "omit" });
          if (!S)
            return null;
          l = l || S.type, y.push(S);
        }
        var C = p && y.some(function(P) {
          return Qt(p, P.type);
        });
        return new gs(C ? Ee : l, y);
      }, gs.prototype.evaluate = function(r) {
        for (var i, l = null, p = 0, y = 0, v = this.args; y < v.length && (p++, (l = v[y].evaluate(r)) && l instanceof Ji && !l.available && (i || (i = l.name), l = null, p === this.args.length && (l = i)), l === null); y += 1)
          ;
        return l;
      }, gs.prototype.eachChild = function(r) {
        this.args.forEach(r);
      }, gs.prototype.outputDefined = function() {
        return this.args.every(function(r) {
          return r.outputDefined();
        });
      }, gs.prototype.serialize = function() {
        var r = ["coalesce"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var vs = function(r, i) {
        this.type = i.type, this.bindings = [].concat(r), this.result = i;
      };
      vs.prototype.evaluate = function(r) {
        return this.result.evaluate(r);
      }, vs.prototype.eachChild = function(r) {
        for (var i = 0, l = this.bindings; i < l.length; i += 1)
          r(l[i][1]);
        r(this.result);
      }, vs.parse = function(r, i) {
        if (r.length < 4)
          return i.error("Expected at least 3 arguments, but found " + (r.length - 1) + " instead.");
        for (var l = [], p = 1; p < r.length - 1; p += 2) {
          var y = r[p];
          if (typeof y != "string")
            return i.error("Expected string, but found " + typeof y + " instead.", p);
          if (/[^a-zA-Z0-9_]/.test(y))
            return i.error("Variable names must contain only alphanumeric characters or '_'.", p);
          var v = i.parse(r[p + 1], p + 1);
          if (!v)
            return null;
          l.push([y, v]);
        }
        var x = i.parse(r[r.length - 1], r.length - 1, i.expectedType, l);
        return x ? new vs(l, x) : null;
      }, vs.prototype.outputDefined = function() {
        return this.result.outputDefined();
      }, vs.prototype.serialize = function() {
        for (var r = ["let"], i = 0, l = this.bindings; i < l.length; i += 1) {
          var p = l[i];
          r.push(p[0], p[1].serialize());
        }
        return r.push(this.result.serialize()), r;
      };
      var ll = function(r, i, l) {
        this.type = r, this.index = i, this.input = l;
      };
      ll.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected 2 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Le), p = i.parse(r[2], 2, Jt(i.expectedType || Ee));
        return l && p ? new ll(p.type.itemType, l, p) : null;
      }, ll.prototype.evaluate = function(r) {
        var i = this.index.evaluate(r), l = this.input.evaluate(r);
        if (i < 0)
          throw new yi("Array index out of bounds: " + i + " < 0.");
        if (i >= l.length)
          throw new yi("Array index out of bounds: " + i + " > " + (l.length - 1) + ".");
        if (i !== Math.floor(i))
          throw new yi("Array index must be an integer, but found " + i + " instead.");
        return l[i];
      }, ll.prototype.eachChild = function(r) {
        r(this.index), r(this.input);
      }, ll.prototype.outputDefined = function() {
        return !1;
      }, ll.prototype.serialize = function() {
        return ["at", this.index.serialize(), this.input.serialize()];
      };
      var ul = function(r, i) {
        this.type = st, this.needle = r, this.haystack = i;
      };
      ul.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected 2 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Ee), p = i.parse(r[2], 2, Ee);
        return l && p ? dn(l.type, [st, pt, Le, _t, Ee]) ? new ul(l, p) : i.error("Expected first argument to be of type boolean, string, number or null, but found " + Zt(l.type) + " instead") : null;
      }, ul.prototype.evaluate = function(r) {
        var i = this.needle.evaluate(r), l = this.haystack.evaluate(r);
        if (!l)
          return !1;
        if (!Ur(i, ["boolean", "string", "number", "null"]))
          throw new yi("Expected first argument to be of type boolean, string, number or null, but found " + Zt(Ln(i)) + " instead.");
        if (!Ur(l, ["string", "array"]))
          throw new yi("Expected second argument to be of type array or string, but found " + Zt(Ln(l)) + " instead.");
        return l.indexOf(i) >= 0;
      }, ul.prototype.eachChild = function(r) {
        r(this.needle), r(this.haystack);
      }, ul.prototype.outputDefined = function() {
        return !0;
      }, ul.prototype.serialize = function() {
        return ["in", this.needle.serialize(), this.haystack.serialize()];
      };
      var _s = function(r, i, l) {
        this.type = Le, this.needle = r, this.haystack = i, this.fromIndex = l;
      };
      _s.parse = function(r, i) {
        if (r.length <= 2 || r.length >= 5)
          return i.error("Expected 3 or 4 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Ee), p = i.parse(r[2], 2, Ee);
        if (!l || !p)
          return null;
        if (!dn(l.type, [st, pt, Le, _t, Ee]))
          return i.error("Expected first argument to be of type boolean, string, number or null, but found " + Zt(l.type) + " instead");
        if (r.length === 4) {
          var y = i.parse(r[3], 3, Le);
          return y ? new _s(l, p, y) : null;
        }
        return new _s(l, p);
      }, _s.prototype.evaluate = function(r) {
        var i = this.needle.evaluate(r), l = this.haystack.evaluate(r);
        if (!Ur(i, ["boolean", "string", "number", "null"]))
          throw new yi("Expected first argument to be of type boolean, string, number or null, but found " + Zt(Ln(i)) + " instead.");
        if (!Ur(l, ["string", "array"]))
          throw new yi("Expected second argument to be of type array or string, but found " + Zt(Ln(l)) + " instead.");
        if (this.fromIndex) {
          var p = this.fromIndex.evaluate(r);
          return l.indexOf(i, p);
        }
        return l.indexOf(i);
      }, _s.prototype.eachChild = function(r) {
        r(this.needle), r(this.haystack), this.fromIndex && r(this.fromIndex);
      }, _s.prototype.outputDefined = function() {
        return !1;
      }, _s.prototype.serialize = function() {
        if (this.fromIndex != null && this.fromIndex !== void 0) {
          var r = this.fromIndex.serialize();
          return ["index-of", this.needle.serialize(), this.haystack.serialize(), r];
        }
        return ["index-of", this.needle.serialize(), this.haystack.serialize()];
      };
      var cl = function(r, i, l, p, y, v) {
        this.inputType = r, this.type = i, this.input = l, this.cases = p, this.outputs = y, this.otherwise = v;
      };
      cl.parse = function(r, i) {
        if (r.length < 5)
          return i.error("Expected at least 4 arguments, but found only " + (r.length - 1) + ".");
        if (r.length % 2 != 1)
          return i.error("Expected an even number of arguments.");
        var l, p;
        i.expectedType && i.expectedType.kind !== "value" && (p = i.expectedType);
        for (var y = {}, v = [], x = 2; x < r.length - 1; x += 2) {
          var S = r[x], C = r[x + 1];
          Array.isArray(S) || (S = [S]);
          var P = i.concat(x);
          if (S.length === 0)
            return P.error("Expected at least one branch label.");
          for (var L = 0, D = S; L < D.length; L += 1) {
            var B = D[L];
            if (typeof B != "number" && typeof B != "string")
              return P.error("Branch labels must be numbers or strings.");
            if (typeof B == "number" && Math.abs(B) > Number.MAX_SAFE_INTEGER)
              return P.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
            if (typeof B == "number" && Math.floor(B) !== B)
              return P.error("Numeric branch labels must be integer values.");
            if (l) {
              if (P.checkSubtype(l, Ln(B)))
                return null;
            } else
              l = Ln(B);
            if (y[String(B)] !== void 0)
              return P.error("Branch labels must be unique.");
            y[String(B)] = v.length;
          }
          var j = i.parse(C, x, p);
          if (!j)
            return null;
          p = p || j.type, v.push(j);
        }
        var J = i.parse(r[1], 1, Ee);
        if (!J)
          return null;
        var ee = i.parse(r[r.length - 1], r.length - 1, p);
        return ee ? J.type.kind !== "value" && i.concat(1).checkSubtype(l, J.type) ? null : new cl(l, p, J, y, v, ee) : null;
      }, cl.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r);
        return (Ln(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(r);
      }, cl.prototype.eachChild = function(r) {
        r(this.input), this.outputs.forEach(r), r(this.otherwise);
      }, cl.prototype.outputDefined = function() {
        return this.outputs.every(function(r) {
          return r.outputDefined();
        }) && this.otherwise.outputDefined();
      }, cl.prototype.serialize = function() {
        for (var r = this, i = ["match", this.input.serialize()], l = [], p = {}, y = 0, v = Object.keys(this.cases).sort(); y < v.length; y += 1) {
          var x = v[y];
          (D = p[this.cases[x]]) === void 0 ? (p[this.cases[x]] = l.length, l.push([this.cases[x], [x]])) : l[D][1].push(x);
        }
        for (var S = function(j) {
          return r.inputType.kind === "number" ? Number(j) : j;
        }, C = 0, P = l; C < P.length; C += 1) {
          var L = P[C], D = L[0], B = L[1];
          i.push(B.length === 1 ? S(B[0]) : B.map(S)), i.push(this.outputs[outputIndex$1].serialize());
        }
        return i.push(this.otherwise.serialize()), i;
      };
      var hl = function(r, i, l) {
        this.type = r, this.branches = i, this.otherwise = l;
      };
      hl.parse = function(r, i) {
        if (r.length < 4)
          return i.error("Expected at least 3 arguments, but found only " + (r.length - 1) + ".");
        if (r.length % 2 != 0)
          return i.error("Expected an odd number of arguments.");
        var l;
        i.expectedType && i.expectedType.kind !== "value" && (l = i.expectedType);
        for (var p = [], y = 1; y < r.length - 1; y += 2) {
          var v = i.parse(r[y], y, st);
          if (!v)
            return null;
          var x = i.parse(r[y + 1], y + 1, l);
          if (!x)
            return null;
          p.push([v, x]), l = l || x.type;
        }
        var S = i.parse(r[r.length - 1], r.length - 1, l);
        return S ? new hl(l, p, S) : null;
      }, hl.prototype.evaluate = function(r) {
        for (var i = 0, l = this.branches; i < l.length; i += 1) {
          var p = l[i], y = p[1];
          if (p[0].evaluate(r))
            return y.evaluate(r);
        }
        return this.otherwise.evaluate(r);
      }, hl.prototype.eachChild = function(r) {
        for (var i = 0, l = this.branches; i < l.length; i += 1) {
          var p = l[i], y = p[1];
          r(p[0]), r(y);
        }
        r(this.otherwise);
      }, hl.prototype.outputDefined = function() {
        return this.branches.every(function(r) {
          return r[1].outputDefined();
        }) && this.otherwise.outputDefined();
      }, hl.prototype.serialize = function() {
        var r = ["case"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var xs = function(r, i, l, p) {
        this.type = r, this.input = i, this.beginIndex = l, this.endIndex = p;
      };
      function ym(r, i) {
        return r === "==" || r === "!=" ? i.kind === "boolean" || i.kind === "string" || i.kind === "number" || i.kind === "null" || i.kind === "value" : i.kind === "string" || i.kind === "number" || i.kind === "value";
      }
      function gm(r, i, l, p) {
        return p.compare(i, l) === 0;
      }
      function Zr(r, i, l) {
        var p = r !== "==" && r !== "!=";
        return function() {
          function y(v, x, S) {
            this.type = st, this.lhs = v, this.rhs = x, this.collator = S, this.hasUntypedArgument = v.type.kind === "value" || x.type.kind === "value";
          }
          return y.parse = function(v, x) {
            if (v.length !== 3 && v.length !== 4)
              return x.error("Expected two or three arguments.");
            var S = v[0], C = x.parse(v[1], 1, Ee);
            if (!C)
              return null;
            if (!ym(S, C.type))
              return x.concat(1).error('"' + S + `" comparisons are not supported for type '` + Zt(C.type) + "'.");
            var P = x.parse(v[2], 2, Ee);
            if (!P)
              return null;
            if (!ym(S, P.type))
              return x.concat(2).error('"' + S + `" comparisons are not supported for type '` + Zt(P.type) + "'.");
            if (C.type.kind !== P.type.kind && C.type.kind !== "value" && P.type.kind !== "value")
              return x.error("Cannot compare types '" + Zt(C.type) + "' and '" + Zt(P.type) + "'.");
            p && (C.type.kind === "value" && P.type.kind !== "value" ? C = new mn(P.type, [C]) : C.type.kind !== "value" && P.type.kind === "value" && (P = new mn(C.type, [P])));
            var L = null;
            if (v.length === 4) {
              if (C.type.kind !== "string" && P.type.kind !== "string" && C.type.kind !== "value" && P.type.kind !== "value")
                return x.error("Cannot use collator to compare non-string types.");
              if (!(L = x.parse(v[3], 3, He)))
                return null;
            }
            return new y(C, P, L);
          }, y.prototype.evaluate = function(v) {
            var x = this.lhs.evaluate(v), S = this.rhs.evaluate(v);
            if (p && this.hasUntypedArgument) {
              var C = Ln(x), P = Ln(S);
              if (C.kind !== P.kind || C.kind !== "string" && C.kind !== "number")
                throw new yi('Expected arguments for "' + r + '" to be (string, string) or (number, number), but found (' + C.kind + ", " + P.kind + ") instead.");
            }
            if (this.collator && !p && this.hasUntypedArgument) {
              var L = Ln(x), D = Ln(S);
              if (L.kind !== "string" || D.kind !== "string")
                return i(v, x, S);
            }
            return this.collator ? l(v, x, S, this.collator.evaluate(v)) : i(v, x, S);
          }, y.prototype.eachChild = function(v) {
            v(this.lhs), v(this.rhs), this.collator && v(this.collator);
          }, y.prototype.outputDefined = function() {
            return !0;
          }, y.prototype.serialize = function() {
            var v = [r];
            return this.eachChild(function(x) {
              v.push(x.serialize());
            }), v;
          }, y;
        }();
      }
      xs.parse = function(r, i) {
        if (r.length <= 2 || r.length >= 5)
          return i.error("Expected 3 or 4 arguments, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1, Ee), p = i.parse(r[2], 2, Le);
        if (!l || !p)
          return null;
        if (!dn(l.type, [Jt(Ee), pt, Ee]))
          return i.error("Expected first argument to be of type array or string, but found " + Zt(l.type) + " instead");
        if (r.length === 4) {
          var y = i.parse(r[3], 3, Le);
          return y ? new xs(l.type, l, p, y) : null;
        }
        return new xs(l.type, l, p);
      }, xs.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r), l = this.beginIndex.evaluate(r);
        if (!Ur(i, ["string", "array"]))
          throw new yi("Expected first argument to be of type array or string, but found " + Zt(Ln(i)) + " instead.");
        if (this.endIndex) {
          var p = this.endIndex.evaluate(r);
          return i.slice(l, p);
        }
        return i.slice(l);
      }, xs.prototype.eachChild = function(r) {
        r(this.input), r(this.beginIndex), this.endIndex && r(this.endIndex);
      }, xs.prototype.outputDefined = function() {
        return !1;
      }, xs.prototype.serialize = function() {
        if (this.endIndex != null && this.endIndex !== void 0) {
          var r = this.endIndex.serialize();
          return ["slice", this.input.serialize(), this.beginIndex.serialize(), r];
        }
        return ["slice", this.input.serialize(), this.beginIndex.serialize()];
      };
      var Hv = Zr("==", function(r, i, l) {
        return i === l;
      }, gm), ch = Zr("!=", function(r, i, l) {
        return i !== l;
      }, function(r, i, l, p) {
        return !gm(0, i, l, p);
      }), vm = Zr("<", function(r, i, l) {
        return i < l;
      }, function(r, i, l, p) {
        return p.compare(i, l) < 0;
      }), _m = Zr(">", function(r, i, l) {
        return i > l;
      }, function(r, i, l, p) {
        return p.compare(i, l) > 0;
      }), xm = Zr("<=", function(r, i, l) {
        return i <= l;
      }, function(r, i, l, p) {
        return p.compare(i, l) <= 0;
      }), bm = Zr(">=", function(r, i, l) {
        return i >= l;
      }, function(r, i, l, p) {
        return p.compare(i, l) >= 0;
      }), fl = function(r, i, l, p, y) {
        this.type = pt, this.number = r, this.locale = i, this.currency = l, this.minFractionDigits = p, this.maxFractionDigits = y;
      };
      fl.parse = function(r, i) {
        if (r.length !== 3)
          return i.error("Expected two arguments.");
        var l = i.parse(r[1], 1, Le);
        if (!l)
          return null;
        var p = r[2];
        if (typeof p != "object" || Array.isArray(p))
          return i.error("NumberFormat options argument must be an object.");
        var y = null;
        if (p.locale && !(y = i.parse(p.locale, 1, pt)))
          return null;
        var v = null;
        if (p.currency && !(v = i.parse(p.currency, 1, pt)))
          return null;
        var x = null;
        if (p["min-fraction-digits"] && !(x = i.parse(p["min-fraction-digits"], 1, Le)))
          return null;
        var S = null;
        return p["max-fraction-digits"] && !(S = i.parse(p["max-fraction-digits"], 1, Le)) ? null : new fl(l, y, v, x, S);
      }, fl.prototype.evaluate = function(r) {
        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(r) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(r) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(r) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(r) : void 0 }).format(this.number.evaluate(r));
      }, fl.prototype.eachChild = function(r) {
        r(this.number), this.locale && r(this.locale), this.currency && r(this.currency), this.minFractionDigits && r(this.minFractionDigits), this.maxFractionDigits && r(this.maxFractionDigits);
      }, fl.prototype.outputDefined = function() {
        return !1;
      }, fl.prototype.serialize = function() {
        var r = {};
        return this.locale && (r.locale = this.locale.serialize()), this.currency && (r.currency = this.currency.serialize()), this.minFractionDigits && (r["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (r["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), r];
      };
      var bs = function(r) {
        this.type = Le, this.input = r;
      };
      bs.parse = function(r, i) {
        if (r.length !== 2)
          return i.error("Expected 1 argument, but found " + (r.length - 1) + " instead.");
        var l = i.parse(r[1], 1);
        return l ? l.type.kind !== "array" && l.type.kind !== "string" && l.type.kind !== "value" ? i.error("Expected argument of type string or array, but found " + Zt(l.type) + " instead.") : new bs(l) : null;
      }, bs.prototype.evaluate = function(r) {
        var i = this.input.evaluate(r);
        if (typeof i == "string" || Array.isArray(i))
          return i.length;
        throw new yi("Expected value to be of type string or array, but found " + Zt(Ln(i)) + " instead.");
      }, bs.prototype.eachChild = function(r) {
        r(this.input);
      }, bs.prototype.outputDefined = function() {
        return !1;
      }, bs.prototype.serialize = function() {
        var r = ["length"];
        return this.eachChild(function(i) {
          r.push(i.serialize());
        }), r;
      };
      var pl = { "==": Hv, "!=": ch, ">": _m, "<": vm, ">=": bm, "<=": xm, array: mn, at: ll, boolean: mn, case: hl, coalesce: gs, collator: xa, format: ia, image: To, in: ul, "index-of": _s, interpolate: Ti, "interpolate-hcl": Ti, "interpolate-lab": Ti, length: bs, let: vs, literal: Vi, match: cl, number: mn, "number-format": fl, object: mn, slice: xs, step: lo, string: mn, "to-boolean": Go, "to-color": Go, "to-number": Go, "to-string": Go, var: ms, within: $o };
      function wm(r, i) {
        var l = i[0], p = i[1], y = i[2], v = i[3];
        l = l.evaluate(r), p = p.evaluate(r), y = y.evaluate(r);
        var x = v ? v.evaluate(r) : 1, S = Wf(l, p, y, x);
        if (S)
          throw new yi(S);
        return new zr(l / 255 * x, p / 255 * x, y / 255 * x, x);
      }
      function Em(r, i) {
        return r in i;
      }
      function ep(r, i) {
        var l = i[r];
        return l === void 0 ? null : l;
      }
      function dl(r) {
        return { type: r };
      }
      function Sm(r) {
        return { result: "success", value: r };
      }
      function ml(r) {
        return { result: "error", value: r };
      }
      function yl(r) {
        return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven";
      }
      function Tm(r) {
        return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
      }
      function ec(r) {
        return !!r.expression && r.expression.interpolated;
      }
      function Qr(r) {
        return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
      }
      function hh(r) {
        return typeof r == "object" && r !== null && !Array.isArray(r);
      }
      function Zv(r) {
        return r;
      }
      function Jl(r, i, l) {
        return r !== void 0 ? r : i !== void 0 ? i : l !== void 0 ? l : void 0;
      }
      function Mm(r, i, l, p, y) {
        return Jl(typeof l === y ? p[l] : void 0, r.default, i.default);
      }
      function Xv(r, i, l) {
        if (Qr(l) !== "number")
          return Jl(r.default, i.default);
        var p = r.stops.length;
        if (p === 1 || l <= r.stops[0][0])
          return r.stops[0][1];
        if (l >= r.stops[p - 1][0])
          return r.stops[p - 1][1];
        var y = uh(r.stops.map(function(v) {
          return v[0];
        }), l);
        return r.stops[y][1];
      }
      function Im(r, i, l) {
        var p = r.base !== void 0 ? r.base : 1;
        if (Qr(l) !== "number")
          return Jl(r.default, i.default);
        var y = r.stops.length;
        if (y === 1 || l <= r.stops[0][0])
          return r.stops[0][1];
        if (l >= r.stops[y - 1][0])
          return r.stops[y - 1][1];
        var v = uh(r.stops.map(function(D) {
          return D[0];
        }), l), x = function(D, B, j, J) {
          var ee = J - j, he = D - j;
          return ee === 0 ? 0 : B === 1 ? he / ee : (Math.pow(B, he) - 1) / (Math.pow(B, ee) - 1);
        }(l, p, r.stops[v][0], r.stops[v + 1][0]), S = r.stops[v][1], C = r.stops[v + 1][1], P = Yl[i.type] || Zv;
        if (r.colorSpace && r.colorSpace !== "rgb") {
          var L = mm[r.colorSpace];
          P = function(D, B) {
            return L.reverse(L.interpolate(L.forward(D), L.forward(B), x));
          };
        }
        return typeof S.evaluate == "function" ? { evaluate: function() {
          for (var D = [], B = arguments.length; B--; )
            D[B] = arguments[B];
          var j = S.evaluate.apply(void 0, D), J = C.evaluate.apply(void 0, D);
          if (j !== void 0 && J !== void 0)
            return P(j, J, x);
        } } : P(S, C, x);
      }
      function fh(r, i, l) {
        return i.type === "color" ? l = zr.parse(l) : i.type === "formatted" ? l = mi.fromString(l.toString()) : i.type === "resolvedImage" ? l = Ji.fromString(l.toString()) : Qr(l) === i.type || i.type === "enum" && i.values[l] || (l = void 0), Jl(l, r.default, i.default);
      }
      Si.register(pl, { error: [{ kind: "error" }, [pt], function(r, i) {
        throw new yi(i[0].evaluate(r));
      }], typeof: [pt, [Ee], function(r, i) {
        return Zt(Ln(i[0].evaluate(r)));
      }], "to-rgba": [Jt(Le, 4), [De], function(r, i) {
        return i[0].evaluate(r).toArray();
      }], rgb: [De, [Le, Le, Le], wm], rgba: [De, [Le, Le, Le, Le], wm], has: { type: st, overloads: [[[pt], function(r, i) {
        return Em(i[0].evaluate(r), r.properties());
      }], [[pt, fe], function(r, i) {
        var l = i[1];
        return Em(i[0].evaluate(r), l.evaluate(r));
      }]] }, get: { type: Ee, overloads: [[[pt], function(r, i) {
        return ep(i[0].evaluate(r), r.properties());
      }], [[pt, fe], function(r, i) {
        var l = i[1];
        return ep(i[0].evaluate(r), l.evaluate(r));
      }]] }, "feature-state": [Ee, [pt], function(r, i) {
        return ep(i[0].evaluate(r), r.featureState || {});
      }], properties: [fe, [], function(r) {
        return r.properties();
      }], "geometry-type": [pt, [], function(r) {
        return r.geometryType();
      }], id: [Ee, [], function(r) {
        return r.id();
      }], zoom: [Le, [], function(r) {
        return r.globals.zoom;
      }], "heatmap-density": [Le, [], function(r) {
        return r.globals.heatmapDensity || 0;
      }], "line-progress": [Le, [], function(r) {
        return r.globals.lineProgress || 0;
      }], accumulated: [Ee, [], function(r) {
        return r.globals.accumulated === void 0 ? null : r.globals.accumulated;
      }], "+": [Le, dl(Le), function(r, i) {
        for (var l = 0, p = 0, y = i; p < y.length; p += 1)
          l += y[p].evaluate(r);
        return l;
      }], "*": [Le, dl(Le), function(r, i) {
        for (var l = 1, p = 0, y = i; p < y.length; p += 1)
          l *= y[p].evaluate(r);
        return l;
      }], "-": { type: Le, overloads: [[[Le, Le], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) - l.evaluate(r);
      }], [[Le], function(r, i) {
        return -i[0].evaluate(r);
      }]] }, "/": [Le, [Le, Le], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) / l.evaluate(r);
      }], "%": [Le, [Le, Le], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) % l.evaluate(r);
      }], ln2: [Le, [], function() {
        return Math.LN2;
      }], pi: [Le, [], function() {
        return Math.PI;
      }], e: [Le, [], function() {
        return Math.E;
      }], "^": [Le, [Le, Le], function(r, i) {
        var l = i[1];
        return Math.pow(i[0].evaluate(r), l.evaluate(r));
      }], sqrt: [Le, [Le], function(r, i) {
        return Math.sqrt(i[0].evaluate(r));
      }], log10: [Le, [Le], function(r, i) {
        return Math.log(i[0].evaluate(r)) / Math.LN10;
      }], ln: [Le, [Le], function(r, i) {
        return Math.log(i[0].evaluate(r));
      }], log2: [Le, [Le], function(r, i) {
        return Math.log(i[0].evaluate(r)) / Math.LN2;
      }], sin: [Le, [Le], function(r, i) {
        return Math.sin(i[0].evaluate(r));
      }], cos: [Le, [Le], function(r, i) {
        return Math.cos(i[0].evaluate(r));
      }], tan: [Le, [Le], function(r, i) {
        return Math.tan(i[0].evaluate(r));
      }], asin: [Le, [Le], function(r, i) {
        return Math.asin(i[0].evaluate(r));
      }], acos: [Le, [Le], function(r, i) {
        return Math.acos(i[0].evaluate(r));
      }], atan: [Le, [Le], function(r, i) {
        return Math.atan(i[0].evaluate(r));
      }], min: [Le, dl(Le), function(r, i) {
        return Math.min.apply(Math, i.map(function(l) {
          return l.evaluate(r);
        }));
      }], max: [Le, dl(Le), function(r, i) {
        return Math.max.apply(Math, i.map(function(l) {
          return l.evaluate(r);
        }));
      }], abs: [Le, [Le], function(r, i) {
        return Math.abs(i[0].evaluate(r));
      }], round: [Le, [Le], function(r, i) {
        var l = i[0].evaluate(r);
        return l < 0 ? -Math.round(-l) : Math.round(l);
      }], floor: [Le, [Le], function(r, i) {
        return Math.floor(i[0].evaluate(r));
      }], ceil: [Le, [Le], function(r, i) {
        return Math.ceil(i[0].evaluate(r));
      }], "filter-==": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1];
        return r.properties()[l.value] === p.value;
      }], "filter-id-==": [st, [Ee], function(r, i) {
        var l = i[0];
        return r.id() === l.value;
      }], "filter-type-==": [st, [pt], function(r, i) {
        var l = i[0];
        return r.geometryType() === l.value;
      }], "filter-<": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y < v;
      }], "filter-id-<": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p < y;
      }], "filter->": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y > v;
      }], "filter-id->": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p > y;
      }], "filter-<=": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y <= v;
      }], "filter-id-<=": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p <= y;
      }], "filter->=": [st, [pt, Ee], function(r, i) {
        var l = i[0], p = i[1], y = r.properties()[l.value], v = p.value;
        return typeof y == typeof v && y >= v;
      }], "filter-id->=": [st, [Ee], function(r, i) {
        var l = i[0], p = r.id(), y = l.value;
        return typeof p == typeof y && p >= y;
      }], "filter-has": [st, [Ee], function(r, i) {
        return i[0].value in r.properties();
      }], "filter-has-id": [st, [], function(r) {
        return r.id() !== null && r.id() !== void 0;
      }], "filter-type-in": [st, [Jt(pt)], function(r, i) {
        return i[0].value.indexOf(r.geometryType()) >= 0;
      }], "filter-id-in": [st, [Jt(Ee)], function(r, i) {
        return i[0].value.indexOf(r.id()) >= 0;
      }], "filter-in-small": [st, [pt, Jt(Ee)], function(r, i) {
        var l = i[0];
        return i[1].value.indexOf(r.properties()[l.value]) >= 0;
      }], "filter-in-large": [st, [pt, Jt(Ee)], function(r, i) {
        var l = i[0], p = i[1];
        return function(y, v, x, S) {
          for (; x <= S; ) {
            var C = x + S >> 1;
            if (v[C] === y)
              return !0;
            v[C] > y ? S = C - 1 : x = C + 1;
          }
          return !1;
        }(r.properties()[l.value], p.value, 0, p.value.length - 1);
      }], all: { type: st, overloads: [[[st, st], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) && l.evaluate(r);
      }], [dl(st), function(r, i) {
        for (var l = 0, p = i; l < p.length; l += 1)
          if (!p[l].evaluate(r))
            return !1;
        return !0;
      }]] }, any: { type: st, overloads: [[[st, st], function(r, i) {
        var l = i[1];
        return i[0].evaluate(r) || l.evaluate(r);
      }], [dl(st), function(r, i) {
        for (var l = 0, p = i; l < p.length; l += 1)
          if (p[l].evaluate(r))
            return !0;
        return !1;
      }]] }, "!": [st, [st], function(r, i) {
        return !i[0].evaluate(r);
      }], "is-supported-script": [st, [pt], function(r, i) {
        var l = r.globals && r.globals.isSupportedScript;
        return !l || l(i[0].evaluate(r));
      }], upcase: [pt, [pt], function(r, i) {
        return i[0].evaluate(r).toUpperCase();
      }], downcase: [pt, [pt], function(r, i) {
        return i[0].evaluate(r).toLowerCase();
      }], concat: [pt, dl(Ee), function(r, i) {
        return i.map(function(l) {
          return Ku(l.evaluate(r));
        }).join("");
      }], "resolved-locale": [pt, [He], function(r, i) {
        return i[0].evaluate(r).resolvedLocale();
      }] });
      var Ql = function(r, i) {
        this.expression = r, this._warningHistory = {}, this._evaluator = new Va(), this._defaultValue = i ? function(l) {
          return l.type === "color" && hh(l.default) ? new zr(0, 0, 0, 0) : l.type === "color" ? zr.parse(l.default) || null : l.default === void 0 ? null : l.default;
        }(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null;
      };
      function tc(r) {
        return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in pl;
      }
      function ph(r, i) {
        var l = new ys(pl, [], i ? function(y) {
          var v = { color: De, string: pt, number: Le, enum: pt, boolean: st, formatted: jt, resolvedImage: qt };
          return y.type === "array" ? Jt(v[y.value] || Ee, y.length) : v[y.type];
        }(i) : void 0), p = l.parse(r, void 0, void 0, void 0, i && i.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return p ? Sm(new Ql(p, i)) : ml(l.errors);
      }
      Ql.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._evaluator.globals = r, this._evaluator.feature = i, this._evaluator.featureState = l, this._evaluator.canonical = p, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = v, this.expression.evaluate(this._evaluator);
      }, Ql.prototype.evaluate = function(r, i, l, p, y, v) {
        this._evaluator.globals = r, this._evaluator.feature = i || null, this._evaluator.featureState = l || null, this._evaluator.canonical = p, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = v || null;
        try {
          var x = this.expression.evaluate(this._evaluator);
          if (x == null || typeof x == "number" && x != x)
            return this._defaultValue;
          if (this._enumValues && !(x in this._enumValues))
            throw new yi("Expected value to be one of " + Object.keys(this._enumValues).map(function(S) {
              return JSON.stringify(S);
            }).join(", ") + ", but found " + JSON.stringify(x) + " instead.");
          return x;
        } catch (S) {
          return this._warningHistory[S.message] || (this._warningHistory[S.message] = !0, typeof console < "u" && console.warn(S.message)), this._defaultValue;
        }
      };
      var rc = function(r, i) {
        this.kind = r, this._styleExpression = i, this.isStateDependent = r !== "constant" && !ds(i.expression);
      };
      rc.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluateWithoutErrorHandling(r, i, l, p, y, v);
      }, rc.prototype.evaluate = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluate(r, i, l, p, y, v);
      };
      var eu = function(r, i, l, p) {
        this.kind = r, this.zoomStops = l, this._styleExpression = i, this.isStateDependent = r !== "camera" && !ds(i.expression), this.interpolationType = p;
      };
      function Om(r, i) {
        if ((r = ph(r, i)).result === "error")
          return r;
        var l = r.value.expression, p = ps(l);
        if (!p && !yl(i))
          return ml([new Ue("", "data expressions not supported")]);
        var y = sl(l, ["zoom"]);
        if (!y && !Tm(i))
          return ml([new Ue("", "zoom expressions not supported")]);
        var v = function x(S) {
          var C = null;
          if (S instanceof vs)
            C = x(S.result);
          else if (S instanceof gs)
            for (var P = 0, L = S.args; P < L.length && !(C = x(L[P])); P += 1)
              ;
          else
            (S instanceof lo || S instanceof Ti) && S.input instanceof Si && S.input.name === "zoom" && (C = S);
          return C instanceof Ue || S.eachChild(function(D) {
            var B = x(D);
            B instanceof Ue ? C = B : !C && B ? C = new Ue("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : C && B && C !== B && (C = new Ue("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), C;
        }(l);
        return v || y ? v instanceof Ue ? ml([v]) : v instanceof Ti && !ec(i) ? ml([new Ue("", '"interpolate" expressions cannot be used with this property')]) : Sm(v ? new eu(p ? "camera" : "composite", r.value, v.labels, v instanceof Ti ? v.interpolation : void 0) : new rc(p ? "constant" : "source", r.value)) : ml([new Ue("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      eu.prototype.evaluateWithoutErrorHandling = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluateWithoutErrorHandling(r, i, l, p, y, v);
      }, eu.prototype.evaluate = function(r, i, l, p, y, v) {
        return this._styleExpression.evaluate(r, i, l, p, y, v);
      }, eu.prototype.interpolationFactor = function(r, i, l) {
        return this.interpolationType ? Ti.interpolationFactor(this.interpolationType, r, i, l) : 0;
      };
      var tu = function(r, i) {
        this._parameters = r, this._specification = i, Ge(this, function l(p, y) {
          var v, x, S, C = y.type === "color", P = p.stops && typeof p.stops[0][0] == "object", L = P || !(P || p.property !== void 0), D = p.type || (ec(y) ? "exponential" : "interval");
          if (C && ((p = Ge({}, p)).stops && (p.stops = p.stops.map(function(dt) {
            return [dt[0], zr.parse(dt[1])];
          })), p.default = zr.parse(p.default ? p.default : y.default)), p.colorSpace && p.colorSpace !== "rgb" && !mm[p.colorSpace])
            throw new Error("Unknown color space: " + p.colorSpace);
          if (D === "exponential")
            v = Im;
          else if (D === "interval")
            v = Xv;
          else if (D === "categorical") {
            v = Mm, x = /* @__PURE__ */ Object.create(null);
            for (var B = 0, j = p.stops; B < j.length; B += 1) {
              var J = j[B];
              x[J[0]] = J[1];
            }
            S = typeof p.stops[0][0];
          } else {
            if (D !== "identity")
              throw new Error('Unknown function type "' + D + '"');
            v = fh;
          }
          if (P) {
            for (var ee = {}, he = [], oe = 0; oe < p.stops.length; oe++) {
              var ge = p.stops[oe], we = ge[0].zoom;
              ee[we] === void 0 && (ee[we] = { zoom: we, type: p.type, property: p.property, default: p.default, stops: [] }, he.push(we)), ee[we].stops.push([ge[0].value, ge[1]]);
            }
            for (var Te = [], Oe = 0, Ve = he; Oe < Ve.length; Oe += 1) {
              var Ke = Ve[Oe];
              Te.push([ee[Ke].zoom, l(ee[Ke], y)]);
            }
            var ot = { name: "linear" };
            return { kind: "composite", interpolationType: ot, interpolationFactor: Ti.interpolationFactor.bind(void 0, ot), zoomStops: Te.map(function(dt) {
              return dt[0];
            }), evaluate: function(dt, Rt) {
              var yt = dt.zoom;
              return Im({ stops: Te, base: p.base }, y, yt).evaluate(yt, Rt);
            } };
          }
          if (L) {
            var Pt = D === "exponential" ? { name: "exponential", base: p.base !== void 0 ? p.base : 1 } : null;
            return { kind: "camera", interpolationType: Pt, interpolationFactor: Ti.interpolationFactor.bind(void 0, Pt), zoomStops: p.stops.map(function(dt) {
              return dt[0];
            }), evaluate: function(dt) {
              return v(p, y, dt.zoom, x, S);
            } };
          }
          return { kind: "source", evaluate: function(dt, Rt) {
            var yt = Rt && Rt.properties ? Rt.properties[p.property] : void 0;
            return yt === void 0 ? Jl(p.default, y.default) : v(p, y, yt, x, S);
          } };
        }(this._parameters, this._specification));
      };
      function oa(r) {
        var i = r.key, l = r.value, p = r.valueSpec || {}, y = r.objectElementValidators || {}, v = r.style, x = r.styleSpec, S = [], C = Qr(l);
        if (C !== "object")
          return [new ie(i, l, "object expected, " + C + " found")];
        for (var P in l) {
          var L = P.split(".")[0], D = p[L] || p["*"], B = void 0;
          if (y[L])
            B = y[L];
          else if (p[L])
            B = xr;
          else if (y["*"])
            B = y["*"];
          else {
            if (!p["*"]) {
              S.push(new ie(i, l[P], 'unknown property "' + P + '"'));
              continue;
            }
            B = xr;
          }
          S = S.concat(B({ key: (i && i + ".") + P, value: l[P], valueSpec: D, style: v, styleSpec: x, object: l, objectKey: P }, l));
        }
        for (var j in p)
          y[j] || p[j].required && p[j].default === void 0 && l[j] === void 0 && S.push(new ie(i, l, 'missing required property "' + j + '"'));
        return S;
      }
      function Cm(r) {
        var i = r.value, l = r.valueSpec, p = r.style, y = r.styleSpec, v = r.key, x = r.arrayElementValidator || xr;
        if (Qr(i) !== "array")
          return [new ie(v, i, "array expected, " + Qr(i) + " found")];
        if (l.length && i.length !== l.length)
          return [new ie(v, i, "array length " + l.length + " expected, length " + i.length + " found")];
        if (l["min-length"] && i.length < l["min-length"])
          return [new ie(v, i, "array length at least " + l["min-length"] + " expected, length " + i.length + " found")];
        var S = { type: l.value, values: l.values };
        y.$version < 7 && (S.function = l.function), Qr(l.value) === "object" && (S = l.value);
        for (var C = [], P = 0; P < i.length; P++)
          C = C.concat(x({ array: i, arrayIndex: P, value: i[P], valueSpec: S, style: p, styleSpec: y, key: v + "[" + P + "]" }));
        return C;
      }
      function Pm(r) {
        var i = r.key, l = r.value, p = r.valueSpec, y = Qr(l);
        return y === "number" && l != l && (y = "NaN"), y !== "number" ? [new ie(i, l, "number expected, " + y + " found")] : "minimum" in p && l < p.minimum ? [new ie(i, l, l + " is less than the minimum value " + p.minimum)] : "maximum" in p && l > p.maximum ? [new ie(i, l, l + " is greater than the maximum value " + p.maximum)] : [];
      }
      function Am(r) {
        var i, l, p, y = r.valueSpec, v = Ze(r.value.type), x = {}, S = v !== "categorical" && r.value.property === void 0, C = !S, P = Qr(r.value.stops) === "array" && Qr(r.value.stops[0]) === "array" && Qr(r.value.stops[0][0]) === "object", L = oa({ key: r.key, value: r.value, valueSpec: r.styleSpec.function, style: r.style, styleSpec: r.styleSpec, objectElementValidators: { stops: function(j) {
          if (v === "identity")
            return [new ie(j.key, j.value, 'identity function may not have a "stops" property')];
          var J = [], ee = j.value;
          return J = J.concat(Cm({ key: j.key, value: ee, valueSpec: j.valueSpec, style: j.style, styleSpec: j.styleSpec, arrayElementValidator: D })), Qr(ee) === "array" && ee.length === 0 && J.push(new ie(j.key, ee, "array must have at least one stop")), J;
        }, default: function(j) {
          return xr({ key: j.key, value: j.value, valueSpec: y, style: j.style, styleSpec: j.styleSpec });
        } } });
        return v === "identity" && S && L.push(new ie(r.key, r.value, 'missing required property "property"')), v === "identity" || r.value.stops || L.push(new ie(r.key, r.value, 'missing required property "stops"')), v === "exponential" && r.valueSpec.expression && !ec(r.valueSpec) && L.push(new ie(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (C && !yl(r.valueSpec) ? L.push(new ie(r.key, r.value, "property functions not supported")) : S && !Tm(r.valueSpec) && L.push(new ie(r.key, r.value, "zoom functions not supported"))), v !== "categorical" && !P || r.value.property !== void 0 || L.push(new ie(r.key, r.value, '"property" property is required')), L;
        function D(j) {
          var J = [], ee = j.value, he = j.key;
          if (Qr(ee) !== "array")
            return [new ie(he, ee, "array expected, " + Qr(ee) + " found")];
          if (ee.length !== 2)
            return [new ie(he, ee, "array length 2 expected, length " + ee.length + " found")];
          if (P) {
            if (Qr(ee[0]) !== "object")
              return [new ie(he, ee, "object expected, " + Qr(ee[0]) + " found")];
            if (ee[0].zoom === void 0)
              return [new ie(he, ee, "object stop key must have zoom")];
            if (ee[0].value === void 0)
              return [new ie(he, ee, "object stop key must have value")];
            if (p && p > Ze(ee[0].zoom))
              return [new ie(he, ee[0].zoom, "stop zoom values must appear in ascending order")];
            Ze(ee[0].zoom) !== p && (p = Ze(ee[0].zoom), l = void 0, x = {}), J = J.concat(oa({ key: he + "[0]", value: ee[0], valueSpec: { zoom: {} }, style: j.style, styleSpec: j.styleSpec, objectElementValidators: { zoom: Pm, value: B } }));
          } else
            J = J.concat(B({ key: he + "[0]", value: ee[0], valueSpec: {}, style: j.style, styleSpec: j.styleSpec }, ee));
          return tc(Ce(ee[1])) ? J.concat([new ie(he + "[1]", ee[1], "expressions are not allowed in function stops.")]) : J.concat(xr({ key: he + "[1]", value: ee[1], valueSpec: y, style: j.style, styleSpec: j.styleSpec }));
        }
        function B(j, J) {
          var ee = Qr(j.value), he = Ze(j.value), oe = j.value !== null ? j.value : J;
          if (i) {
            if (ee !== i)
              return [new ie(j.key, oe, ee + " stop domain type must match previous stop domain type " + i)];
          } else
            i = ee;
          if (ee !== "number" && ee !== "string" && ee !== "boolean")
            return [new ie(j.key, oe, "stop domain value must be a number, string, or boolean")];
          if (ee !== "number" && v !== "categorical") {
            var ge = "number expected, " + ee + " found";
            return yl(y) && v === void 0 && (ge += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ie(j.key, oe, ge)];
          }
          return v !== "categorical" || ee !== "number" || isFinite(he) && Math.floor(he) === he ? v !== "categorical" && ee === "number" && l !== void 0 && he < l ? [new ie(j.key, oe, "stop domain values must appear in ascending order")] : (l = he, v === "categorical" && he in x ? [new ie(j.key, oe, "stop domain values must be unique")] : (x[he] = !0, [])) : [new ie(j.key, oe, "integer expected, found " + he)];
        }
      }
      function gl(r) {
        var i = (r.expressionContext === "property" ? Om : ph)(Ce(r.value), r.valueSpec);
        if (i.result === "error")
          return i.value.map(function(p) {
            return new ie("" + r.key + p.key, r.value, p.message);
          });
        var l = i.value.expression || i.value._styleExpression.expression;
        if (r.expressionContext === "property" && r.propertyKey === "text-font" && !l.outputDefined())
          return [new ie(r.key, r.value, 'Invalid data expression for "' + r.propertyKey + '". Output values must be contained as literals within the expression.')];
        if (r.expressionContext === "property" && r.propertyType === "layout" && !ds(l))
          return [new ie(r.key, r.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (r.expressionContext === "filter" && !ds(l))
          return [new ie(r.key, r.value, '"feature-state" data expressions are not supported with filters.')];
        if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
          if (!sl(l, ["zoom", "feature-state"]))
            return [new ie(r.key, r.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (r.expressionContext === "cluster-initial" && !ps(l))
            return [new ie(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function nc(r) {
        var i = r.key, l = r.value, p = r.valueSpec, y = [];
        return Array.isArray(p.values) ? p.values.indexOf(Ze(l)) === -1 && y.push(new ie(i, l, "expected one of [" + p.values.join(", ") + "], " + JSON.stringify(l) + " found")) : Object.keys(p.values).indexOf(Ze(l)) === -1 && y.push(new ie(i, l, "expected one of [" + Object.keys(p.values).join(", ") + "], " + JSON.stringify(l) + " found")), y;
      }
      function dh(r) {
        if (r === !0 || r === !1)
          return !0;
        if (!Array.isArray(r) || r.length === 0)
          return !1;
        switch (r[0]) {
          case "has":
            return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
          case "in":
            return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
          case "any":
          case "all":
            for (var i = 0, l = r.slice(1); i < l.length; i += 1) {
              var p = l[i];
              if (!dh(p) && typeof p != "boolean")
                return !1;
            }
            return !0;
          default:
            return !0;
        }
      }
      tu.deserialize = function(r) {
        return new tu(r._parameters, r._specification);
      }, tu.serialize = function(r) {
        return { _parameters: r._parameters, _specification: r._specification };
      };
      var tp = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function mh(r) {
        if (r == null)
          return { filter: function() {
            return !0;
          }, needGeometry: !1 };
        dh(r) || (r = yh(r));
        var i = ph(r, tp);
        if (i.result === "error")
          throw new Error(i.value.map(function(l) {
            return l.key + ": " + l.message;
          }).join(", "));
        return { filter: function(l, p, y) {
          return i.value.evaluate(l, p, {}, y);
        }, needGeometry: function l(p) {
          if (!Array.isArray(p))
            return !1;
          if (p[0] === "within")
            return !0;
          for (var y = 1; y < p.length; y++)
            if (l(p[y]))
              return !0;
          return !1;
        }(r) };
      }
      function Kv(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function yh(r) {
        if (!r)
          return !0;
        var i, l = r[0];
        return r.length <= 1 ? l !== "any" : l === "==" ? rp(r[1], r[2], "==") : l === "!=" ? gh(rp(r[1], r[2], "==")) : l === "<" || l === ">" || l === "<=" || l === ">=" ? rp(r[1], r[2], l) : l === "any" ? (i = r.slice(1), ["any"].concat(i.map(yh))) : l === "all" ? ["all"].concat(r.slice(1).map(yh)) : l === "none" ? ["all"].concat(r.slice(1).map(yh).map(gh)) : l === "in" ? km(r[1], r.slice(2)) : l === "!in" ? gh(km(r[1], r.slice(2))) : l === "has" ? Lm(r[1]) : l === "!has" ? gh(Lm(r[1])) : l !== "within" || r;
      }
      function rp(r, i, l) {
        switch (r) {
          case "$type":
            return ["filter-type-" + l, i];
          case "$id":
            return ["filter-id-" + l, i];
          default:
            return ["filter-" + l, r, i];
        }
      }
      function km(r, i) {
        if (i.length === 0)
          return !1;
        switch (r) {
          case "$type":
            return ["filter-type-in", ["literal", i]];
          case "$id":
            return ["filter-id-in", ["literal", i]];
          default:
            return i.length > 200 && !i.some(function(l) {
              return typeof l != typeof i[0];
            }) ? ["filter-in-large", r, ["literal", i.sort(Kv)]] : ["filter-in-small", r, ["literal", i]];
        }
      }
      function Lm(r) {
        switch (r) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", r];
        }
      }
      function gh(r) {
        return ["!", r];
      }
      function np(r) {
        return dh(Ce(r.value)) ? gl(Ge({}, r, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : function i(l) {
          var p = l.value, y = l.key;
          if (Qr(p) !== "array")
            return [new ie(y, p, "array expected, " + Qr(p) + " found")];
          var v, x = l.styleSpec, S = [];
          if (p.length < 1)
            return [new ie(y, p, "filter array must have at least 1 element")];
          switch (S = S.concat(nc({ key: y + "[0]", value: p[0], valueSpec: x.filter_operator, style: l.style, styleSpec: l.styleSpec })), Ze(p[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              p.length >= 2 && Ze(p[1]) === "$type" && S.push(new ie(y, p, '"$type" cannot be use with operator "' + p[0] + '"'));
            case "==":
            case "!=":
              p.length !== 3 && S.push(new ie(y, p, 'filter array for operator "' + p[0] + '" must have 3 elements'));
            case "in":
            case "!in":
              p.length >= 2 && (v = Qr(p[1])) !== "string" && S.push(new ie(y + "[1]", p[1], "string expected, " + v + " found"));
              for (var C = 2; C < p.length; C++)
                v = Qr(p[C]), Ze(p[1]) === "$type" ? S = S.concat(nc({ key: y + "[" + C + "]", value: p[C], valueSpec: x.geometry_type, style: l.style, styleSpec: l.styleSpec })) : v !== "string" && v !== "number" && v !== "boolean" && S.push(new ie(y + "[" + C + "]", p[C], "string, number, or boolean expected, " + v + " found"));
              break;
            case "any":
            case "all":
            case "none":
              for (var P = 1; P < p.length; P++)
                S = S.concat(i({ key: y + "[" + P + "]", value: p[P], style: l.style, styleSpec: l.styleSpec }));
              break;
            case "has":
            case "!has":
              v = Qr(p[1]), p.length !== 2 ? S.push(new ie(y, p, 'filter array for "' + p[0] + '" operator must have 2 elements')) : v !== "string" && S.push(new ie(y + "[1]", p[1], "string expected, " + v + " found"));
              break;
            case "within":
              v = Qr(p[1]), p.length !== 2 ? S.push(new ie(y, p, 'filter array for "' + p[0] + '" operator must have 2 elements')) : v !== "object" && S.push(new ie(y + "[1]", p[1], "object expected, " + v + " found"));
          }
          return S;
        }(r);
      }
      function ip(r, i) {
        var l = r.key, p = r.style, y = r.styleSpec, v = r.value, x = r.objectKey, S = y[i + "_" + r.layerType];
        if (!S)
          return [];
        var C = x.match(/^(.*)-transition$/);
        if (i === "paint" && C && S[C[1]] && S[C[1]].transition)
          return xr({ key: l, value: v, valueSpec: y.transition, style: p, styleSpec: y });
        var P, L = r.valueSpec || S[x];
        if (!L)
          return [new ie(l, v, 'unknown property "' + x + '"')];
        if (Qr(v) === "string" && yl(L) && !L.tokens && (P = /^{([^}]+)}$/.exec(v)))
          return [new ie(l, v, '"' + x + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(P[1]) + " }`.")];
        var D = [];
        return r.layerType === "symbol" && (x === "text-field" && p && !p.glyphs && D.push(new ie(l, v, 'use of "text-field" requires a style "glyphs" property')), x === "text-font" && hh(Ce(v)) && Ze(v.type) === "identity" && D.push(new ie(l, v, '"text-font" does not support identity functions'))), D.concat(xr({ key: r.key, value: v, valueSpec: L, style: p, styleSpec: y, expressionContext: "property", propertyType: i, propertyKey: x }));
      }
      function op(r) {
        return ip(r, "paint");
      }
      function ic(r) {
        return ip(r, "layout");
      }
      function Dm(r) {
        var i = [], l = r.value, p = r.key, y = r.style, v = r.styleSpec;
        l.type || l.ref || i.push(new ie(p, l, 'either "type" or "ref" is required'));
        var x, S = Ze(l.type), C = Ze(l.ref);
        if (l.id)
          for (var P = Ze(l.id), L = 0; L < r.arrayIndex; L++) {
            var D = y.layers[L];
            Ze(D.id) === P && i.push(new ie(p, l.id, 'duplicate layer id "' + l.id + '", previously used at line ' + D.id.__line__));
          }
        if ("ref" in l)
          ["type", "source", "source-layer", "filter", "layout"].forEach(function(J) {
            J in l && i.push(new ie(p, l[J], '"' + J + '" is prohibited for ref layers'));
          }), y.layers.forEach(function(J) {
            Ze(J.id) === C && (x = J);
          }), x ? x.ref ? i.push(new ie(p, l.ref, "ref cannot reference another ref layer")) : S = Ze(x.type) : i.push(new ie(p, l.ref, 'ref layer "' + C + '" not found'));
        else if (S !== "background")
          if (l.source) {
            var B = y.sources && y.sources[l.source], j = B && Ze(B.type);
            B ? j === "vector" && S === "raster" ? i.push(new ie(p, l.source, 'layer "' + l.id + '" requires a raster source')) : j === "raster" && S !== "raster" ? i.push(new ie(p, l.source, 'layer "' + l.id + '" requires a vector source')) : j !== "vector" || l["source-layer"] ? j === "raster-dem" && S !== "hillshade" ? i.push(new ie(p, l.source, "raster-dem source can only be used with layer type 'hillshade'.")) : S !== "line" || !l.paint || !l.paint["line-gradient"] || j === "geojson" && B.lineMetrics || i.push(new ie(p, l, 'layer "' + l.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : i.push(new ie(p, l, 'layer "' + l.id + '" must specify a "source-layer"')) : i.push(new ie(p, l.source, 'source "' + l.source + '" not found'));
          } else
            i.push(new ie(p, l, 'missing required property "source"'));
        return i = i.concat(oa({ key: p, value: l, valueSpec: v.layer, style: r.style, styleSpec: r.styleSpec, objectElementValidators: { "*": function() {
          return [];
        }, type: function() {
          return xr({ key: p + ".type", value: l.type, valueSpec: v.layer.type, style: r.style, styleSpec: r.styleSpec, object: l, objectKey: "type" });
        }, filter: np, layout: function(J) {
          return oa({ layer: l, key: J.key, value: J.value, style: J.style, styleSpec: J.styleSpec, objectElementValidators: { "*": function(ee) {
            return ic(Ge({ layerType: S }, ee));
          } } });
        }, paint: function(J) {
          return oa({ layer: l, key: J.key, value: J.value, style: J.style, styleSpec: J.styleSpec, objectElementValidators: { "*": function(ee) {
            return op(Ge({ layerType: S }, ee));
          } } });
        } } }));
      }
      function vl(r) {
        var i = r.value, l = r.key, p = Qr(i);
        return p !== "string" ? [new ie(l, i, "string expected, " + p + " found")] : [];
      }
      var yn = { promoteId: function(r) {
        var i = r.key, l = r.value;
        if (Qr(l) === "string")
          return vl({ key: i, value: l });
        var p = [];
        for (var y in l)
          p.push.apply(p, vl({ key: i + "." + y, value: l[y] }));
        return p;
      } };
      function vh(r) {
        var i = r.value, l = r.key, p = r.styleSpec, y = r.style;
        if (!i.type)
          return [new ie(l, i, '"type" is required')];
        var v, x = Ze(i.type);
        switch (x) {
          case "vector":
          case "raster":
          case "raster-dem":
            return oa({ key: l, value: i, valueSpec: p["source_" + x.replace("-", "_")], style: r.style, styleSpec: p, objectElementValidators: yn });
          case "geojson":
            if (v = oa({ key: l, value: i, valueSpec: p.source_geojson, style: y, styleSpec: p, objectElementValidators: yn }), i.cluster)
              for (var S in i.clusterProperties) {
                var C = i.clusterProperties[S], P = C[0], L = typeof P == "string" ? [P, ["accumulated"], ["get", S]] : P;
                v.push.apply(v, gl({ key: l + "." + S + ".map", value: C[1], expressionContext: "cluster-map" })), v.push.apply(v, gl({ key: l + "." + S + ".reduce", value: L, expressionContext: "cluster-reduce" }));
              }
            return v;
          case "video":
            return oa({ key: l, value: i, valueSpec: p.source_video, style: y, styleSpec: p });
          case "image":
            return oa({ key: l, value: i, valueSpec: p.source_image, style: y, styleSpec: p });
          case "canvas":
            return [new ie(l, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return nc({ key: l + ".type", value: i.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: y, styleSpec: p });
        }
      }
      function _l(r) {
        var i = r.value, l = r.styleSpec, p = l.light, y = r.style, v = [], x = Qr(i);
        if (i === void 0)
          return v;
        if (x !== "object")
          return v.concat([new ie("light", i, "object expected, " + x + " found")]);
        for (var S in i) {
          var C = S.match(/^(.*)-transition$/);
          v = v.concat(C && p[C[1]] && p[C[1]].transition ? xr({ key: S, value: i[S], valueSpec: l.transition, style: y, styleSpec: l }) : p[S] ? xr({ key: S, value: i[S], valueSpec: p[S], style: y, styleSpec: l }) : [new ie(S, i[S], 'unknown property "' + S + '"')]);
        }
        return v;
      }
      var ws = { "*": function() {
        return [];
      }, array: Cm, boolean: function(r) {
        var i = r.value, l = r.key, p = Qr(i);
        return p !== "boolean" ? [new ie(l, i, "boolean expected, " + p + " found")] : [];
      }, number: Pm, color: function(r) {
        var i = r.key, l = r.value, p = Qr(l);
        return p !== "string" ? [new ie(i, l, "color expected, " + p + " found")] : gr(l) === null ? [new ie(i, l, 'color expected, "' + l + '" found')] : [];
      }, constants: _e, enum: nc, filter: np, function: Am, layer: Dm, object: oa, source: vh, light: _l, string: vl, formatted: function(r) {
        return vl(r).length === 0 ? [] : gl(r);
      }, resolvedImage: function(r) {
        return vl(r).length === 0 ? [] : gl(r);
      } };
      function xr(r) {
        var i = r.value, l = r.valueSpec, p = r.styleSpec;
        return l.expression && hh(Ze(i)) ? Am(r) : l.expression && tc(Ce(i)) ? gl(r) : l.type && ws[l.type] ? ws[l.type](r) : oa(Ge({}, r, { valueSpec: l.type ? p[l.type] : l }));
      }
      function en(r) {
        var i = r.value, l = r.key, p = vl(r);
        return p.length || (i.indexOf("{fontstack}") === -1 && p.push(new ie(l, i, '"glyphs" url must include a "{fontstack}" token')), i.indexOf("{range}") === -1 && p.push(new ie(l, i, '"glyphs" url must include a "{range}" token'))), p;
      }
      function Mo(r, i) {
        i === void 0 && (i = G);
        var l = [];
        return l = l.concat(xr({ key: "", value: r, valueSpec: i.$root, styleSpec: i, style: r, objectElementValidators: { glyphs: en, "*": function() {
          return [];
        } } })), r.constants && (l = l.concat(_e({ key: "constants", value: r.constants, style: r, styleSpec: i }))), oc(l);
      }
      function oc(r) {
        return [].concat(r).sort(function(i, l) {
          return i.line - l.line;
        });
      }
      function ru(r) {
        return function() {
          for (var i = [], l = arguments.length; l--; )
            i[l] = arguments[l];
          return oc(r.apply(this, i));
        };
      }
      Mo.source = ru(vh), Mo.light = ru(_l), Mo.layer = ru(Dm), Mo.filter = ru(np), Mo.paintProperty = ru(op), Mo.layoutProperty = ru(ic);
      var ac = Mo, Yv = ac.light, Jv = ac.paintProperty, sc = ac.layoutProperty;
      function lc(r, i) {
        var l = !1;
        if (i && i.length)
          for (var p = 0, y = i; p < y.length; p += 1)
            r.fire(new pe(new Error(y[p].message))), l = !0;
        return l;
      }
      var Ua = Jn;
      function Jn(r, i, l) {
        var p = this.cells = [];
        if (r instanceof ArrayBuffer) {
          this.arrayBuffer = r;
          var y = new Int32Array(this.arrayBuffer);
          r = y[0], this.d = (i = y[1]) + 2 * (l = y[2]);
          for (var v = 0; v < this.d * this.d; v++) {
            var x = y[3 + v], S = y[3 + v + 1];
            p.push(x === S ? null : y.subarray(x, S));
          }
          var C = y[3 + p.length + 1];
          this.keys = y.subarray(y[3 + p.length], C), this.bboxes = y.subarray(C), this.insert = this._insertReadonly;
        } else {
          this.d = i + 2 * l;
          for (var P = 0; P < this.d * this.d; P++)
            p.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = i, this.extent = r, this.padding = l, this.scale = i / r, this.uid = 0;
        var L = l / i * r;
        this.min = -L, this.max = r + L;
      }
      Jn.prototype.insert = function(r, i, l, p, y) {
        this._forEachCell(i, l, p, y, this._insertCell, this.uid++), this.keys.push(r), this.bboxes.push(i), this.bboxes.push(l), this.bboxes.push(p), this.bboxes.push(y);
      }, Jn.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, Jn.prototype._insertCell = function(r, i, l, p, y, v) {
        this.cells[y].push(v);
      }, Jn.prototype.query = function(r, i, l, p, y) {
        var v = this.min, x = this.max;
        if (r <= v && i <= v && x <= l && x <= p && !y)
          return Array.prototype.slice.call(this.keys);
        var S = [];
        return this._forEachCell(r, i, l, p, this._queryCell, S, {}, y), S;
      }, Jn.prototype._queryCell = function(r, i, l, p, y, v, x, S) {
        var C = this.cells[y];
        if (C !== null)
          for (var P = this.keys, L = this.bboxes, D = 0; D < C.length; D++) {
            var B = C[D];
            if (x[B] === void 0) {
              var j = 4 * B;
              (S ? S(L[j + 0], L[j + 1], L[j + 2], L[j + 3]) : r <= L[j + 2] && i <= L[j + 3] && l >= L[j + 0] && p >= L[j + 1]) ? (x[B] = !0, v.push(P[B])) : x[B] = !1;
            }
          }
      }, Jn.prototype._forEachCell = function(r, i, l, p, y, v, x, S) {
        for (var C = this._convertToCellCoord(r), P = this._convertToCellCoord(i), L = this._convertToCellCoord(l), D = this._convertToCellCoord(p), B = C; B <= L; B++)
          for (var j = P; j <= D; j++) {
            var J = this.d * j + B;
            if ((!S || S(this._convertFromCellCoord(B), this._convertFromCellCoord(j), this._convertFromCellCoord(B + 1), this._convertFromCellCoord(j + 1))) && y.call(this, r, i, l, p, J, v, x, S))
              return;
          }
      }, Jn.prototype._convertFromCellCoord = function(r) {
        return (r - this.padding) / this.scale;
      }, Jn.prototype._convertToCellCoord = function(r) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(r * this.scale) + this.padding));
      }, Jn.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer)
          return this.arrayBuffer;
        for (var r = this.cells, i = 3 + this.cells.length + 1 + 1, l = 0, p = 0; p < this.cells.length; p++)
          l += this.cells[p].length;
        var y = new Int32Array(i + l + this.keys.length + this.bboxes.length);
        y[0] = this.extent, y[1] = this.n, y[2] = this.padding;
        for (var v = i, x = 0; x < r.length; x++) {
          var S = r[x];
          y[3 + x] = v, y.set(S, v), v += S.length;
        }
        return y[3 + r.length] = v, y.set(this.keys, v), y[3 + r.length + 1] = v += this.keys.length, y.set(this.bboxes, v), v += this.bboxes.length, y.buffer;
      };
      var uc = I.ImageData, Nm = I.ImageBitmap, Gn = {};
      function wt(r, i, l) {
        l === void 0 && (l = {}), Object.defineProperty(i, "_classRegistryKey", { value: r, writeable: !1 }), Gn[r] = { klass: i, omit: l.omit || [], shallow: l.shallow || [] };
      }
      for (var uo in wt("Object", Object), Ua.serialize = function(r, i) {
        var l = r.toArrayBuffer();
        return i && i.push(l), { buffer: l };
      }, Ua.deserialize = function(r) {
        return new Ua(r.buffer);
      }, wt("Grid", Ua), wt("Color", zr), wt("Error", Error), wt("ResolvedImage", Ji), wt("StylePropertyFunction", tu), wt("StyleExpression", Ql, { omit: ["_evaluator"] }), wt("ZoomDependentExpression", eu), wt("ZoomConstantExpression", rc), wt("CompoundExpression", Si, { omit: ["_evaluate"] }), pl)
        pl[uo]._classRegistryKey || wt("Expression_" + uo, pl[uo]);
      function _h(r) {
        return r && typeof ArrayBuffer < "u" && (r instanceof ArrayBuffer || r.constructor && r.constructor.name === "ArrayBuffer");
      }
      function nu(r) {
        return Nm && r instanceof Nm;
      }
      function aa(r, i) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp)
          return r;
        if (_h(r) || nu(r))
          return i && i.push(r), r;
        if (ArrayBuffer.isView(r)) {
          var l = r;
          return i && i.push(l.buffer), l;
        }
        if (r instanceof uc)
          return i && i.push(r.data.buffer), r;
        if (Array.isArray(r)) {
          for (var p = [], y = 0, v = r; y < v.length; y += 1)
            p.push(aa(v[y], i));
          return p;
        }
        if (typeof r == "object") {
          var x = r.constructor, S = x._classRegistryKey;
          if (!S)
            throw new Error("can't serialize object of unregistered class");
          var C = x.serialize ? x.serialize(r, i) : {};
          if (!x.serialize) {
            for (var P in r)
              if (r.hasOwnProperty(P) && !(Gn[S].omit.indexOf(P) >= 0)) {
                var L = r[P];
                C[P] = Gn[S].shallow.indexOf(P) >= 0 ? L : aa(L, i);
              }
            r instanceof Error && (C.message = r.message);
          }
          if (C.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return S !== "Object" && (C.$name = S), C;
        }
        throw new Error("can't serialize object of type " + typeof r);
      }
      function co(r) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp || _h(r) || nu(r) || ArrayBuffer.isView(r) || r instanceof uc)
          return r;
        if (Array.isArray(r))
          return r.map(co);
        if (typeof r == "object") {
          var i = r.$name || "Object", l = Gn[i].klass;
          if (!l)
            throw new Error("can't deserialize unregistered class " + i);
          if (l.deserialize)
            return l.deserialize(r);
          for (var p = Object.create(l.prototype), y = 0, v = Object.keys(r); y < v.length; y += 1) {
            var x = v[y];
            if (x !== "$name") {
              var S = r[x];
              p[x] = Gn[i].shallow.indexOf(x) >= 0 ? S : co(S);
            }
          }
          return p;
        }
        throw new Error("can't deserialize object of type " + typeof r);
      }
      var ap = function() {
        this.first = !0;
      };
      ap.prototype.update = function(r, i) {
        var l = Math.floor(r);
        return this.first ? (this.first = !1, this.lastIntegerZoom = l, this.lastIntegerZoomTime = 0, this.lastZoom = r, this.lastFloorZoom = l, !0) : (this.lastFloorZoom > l ? (this.lastIntegerZoom = l + 1, this.lastIntegerZoomTime = i) : this.lastFloorZoom < l && (this.lastIntegerZoom = l, this.lastIntegerZoomTime = i), r !== this.lastZoom && (this.lastZoom = r, this.lastFloorZoom = l, !0));
      };
      var ct = { "Latin-1 Supplement": function(r) {
        return r >= 128 && r <= 255;
      }, Arabic: function(r) {
        return r >= 1536 && r <= 1791;
      }, "Arabic Supplement": function(r) {
        return r >= 1872 && r <= 1919;
      }, "Arabic Extended-A": function(r) {
        return r >= 2208 && r <= 2303;
      }, "Hangul Jamo": function(r) {
        return r >= 4352 && r <= 4607;
      }, "Unified Canadian Aboriginal Syllabics": function(r) {
        return r >= 5120 && r <= 5759;
      }, Khmer: function(r) {
        return r >= 6016 && r <= 6143;
      }, "Unified Canadian Aboriginal Syllabics Extended": function(r) {
        return r >= 6320 && r <= 6399;
      }, "General Punctuation": function(r) {
        return r >= 8192 && r <= 8303;
      }, "Letterlike Symbols": function(r) {
        return r >= 8448 && r <= 8527;
      }, "Number Forms": function(r) {
        return r >= 8528 && r <= 8591;
      }, "Miscellaneous Technical": function(r) {
        return r >= 8960 && r <= 9215;
      }, "Control Pictures": function(r) {
        return r >= 9216 && r <= 9279;
      }, "Optical Character Recognition": function(r) {
        return r >= 9280 && r <= 9311;
      }, "Enclosed Alphanumerics": function(r) {
        return r >= 9312 && r <= 9471;
      }, "Geometric Shapes": function(r) {
        return r >= 9632 && r <= 9727;
      }, "Miscellaneous Symbols": function(r) {
        return r >= 9728 && r <= 9983;
      }, "Miscellaneous Symbols and Arrows": function(r) {
        return r >= 11008 && r <= 11263;
      }, "CJK Radicals Supplement": function(r) {
        return r >= 11904 && r <= 12031;
      }, "Kangxi Radicals": function(r) {
        return r >= 12032 && r <= 12255;
      }, "Ideographic Description Characters": function(r) {
        return r >= 12272 && r <= 12287;
      }, "CJK Symbols and Punctuation": function(r) {
        return r >= 12288 && r <= 12351;
      }, Hiragana: function(r) {
        return r >= 12352 && r <= 12447;
      }, Katakana: function(r) {
        return r >= 12448 && r <= 12543;
      }, Bopomofo: function(r) {
        return r >= 12544 && r <= 12591;
      }, "Hangul Compatibility Jamo": function(r) {
        return r >= 12592 && r <= 12687;
      }, Kanbun: function(r) {
        return r >= 12688 && r <= 12703;
      }, "Bopomofo Extended": function(r) {
        return r >= 12704 && r <= 12735;
      }, "CJK Strokes": function(r) {
        return r >= 12736 && r <= 12783;
      }, "Katakana Phonetic Extensions": function(r) {
        return r >= 12784 && r <= 12799;
      }, "Enclosed CJK Letters and Months": function(r) {
        return r >= 12800 && r <= 13055;
      }, "CJK Compatibility": function(r) {
        return r >= 13056 && r <= 13311;
      }, "CJK Unified Ideographs Extension A": function(r) {
        return r >= 13312 && r <= 19903;
      }, "Yijing Hexagram Symbols": function(r) {
        return r >= 19904 && r <= 19967;
      }, "CJK Unified Ideographs": function(r) {
        return r >= 19968 && r <= 40959;
      }, "Yi Syllables": function(r) {
        return r >= 40960 && r <= 42127;
      }, "Yi Radicals": function(r) {
        return r >= 42128 && r <= 42191;
      }, "Hangul Jamo Extended-A": function(r) {
        return r >= 43360 && r <= 43391;
      }, "Hangul Syllables": function(r) {
        return r >= 44032 && r <= 55215;
      }, "Hangul Jamo Extended-B": function(r) {
        return r >= 55216 && r <= 55295;
      }, "Private Use Area": function(r) {
        return r >= 57344 && r <= 63743;
      }, "CJK Compatibility Ideographs": function(r) {
        return r >= 63744 && r <= 64255;
      }, "Arabic Presentation Forms-A": function(r) {
        return r >= 64336 && r <= 65023;
      }, "Vertical Forms": function(r) {
        return r >= 65040 && r <= 65055;
      }, "CJK Compatibility Forms": function(r) {
        return r >= 65072 && r <= 65103;
      }, "Small Form Variants": function(r) {
        return r >= 65104 && r <= 65135;
      }, "Arabic Presentation Forms-B": function(r) {
        return r >= 65136 && r <= 65279;
      }, "Halfwidth and Fullwidth Forms": function(r) {
        return r >= 65280 && r <= 65519;
      } };
      function sp(r) {
        for (var i = 0, l = r; i < l.length; i += 1)
          if (xh(l[i].charCodeAt(0)))
            return !0;
        return !1;
      }
      function xh(r) {
        return !(r !== 746 && r !== 747 && (r < 4352 || !(ct["Bopomofo Extended"](r) || ct.Bopomofo(r) || ct["CJK Compatibility Forms"](r) && !(r >= 65097 && r <= 65103) || ct["CJK Compatibility Ideographs"](r) || ct["CJK Compatibility"](r) || ct["CJK Radicals Supplement"](r) || ct["CJK Strokes"](r) || !(!ct["CJK Symbols and Punctuation"](r) || r >= 12296 && r <= 12305 || r >= 12308 && r <= 12319 || r === 12336) || ct["CJK Unified Ideographs Extension A"](r) || ct["CJK Unified Ideographs"](r) || ct["Enclosed CJK Letters and Months"](r) || ct["Hangul Compatibility Jamo"](r) || ct["Hangul Jamo Extended-A"](r) || ct["Hangul Jamo Extended-B"](r) || ct["Hangul Jamo"](r) || ct["Hangul Syllables"](r) || ct.Hiragana(r) || ct["Ideographic Description Characters"](r) || ct.Kanbun(r) || ct["Kangxi Radicals"](r) || ct["Katakana Phonetic Extensions"](r) || ct.Katakana(r) && r !== 12540 || !(!ct["Halfwidth and Fullwidth Forms"](r) || r === 65288 || r === 65289 || r === 65293 || r >= 65306 && r <= 65310 || r === 65339 || r === 65341 || r === 65343 || r >= 65371 && r <= 65503 || r === 65507 || r >= 65512 && r <= 65519) || !(!ct["Small Form Variants"](r) || r >= 65112 && r <= 65118 || r >= 65123 && r <= 65126) || ct["Unified Canadian Aboriginal Syllabics"](r) || ct["Unified Canadian Aboriginal Syllabics Extended"](r) || ct["Vertical Forms"](r) || ct["Yijing Hexagram Symbols"](r) || ct["Yi Syllables"](r) || ct["Yi Radicals"](r))));
      }
      function lp(r) {
        return !(xh(r) || function(i) {
          return !!(ct["Latin-1 Supplement"](i) && (i === 167 || i === 169 || i === 174 || i === 177 || i === 188 || i === 189 || i === 190 || i === 215 || i === 247) || ct["General Punctuation"](i) && (i === 8214 || i === 8224 || i === 8225 || i === 8240 || i === 8241 || i === 8251 || i === 8252 || i === 8258 || i === 8263 || i === 8264 || i === 8265 || i === 8273) || ct["Letterlike Symbols"](i) || ct["Number Forms"](i) || ct["Miscellaneous Technical"](i) && (i >= 8960 && i <= 8967 || i >= 8972 && i <= 8991 || i >= 8996 && i <= 9e3 || i === 9003 || i >= 9085 && i <= 9114 || i >= 9150 && i <= 9165 || i === 9167 || i >= 9169 && i <= 9179 || i >= 9186 && i <= 9215) || ct["Control Pictures"](i) && i !== 9251 || ct["Optical Character Recognition"](i) || ct["Enclosed Alphanumerics"](i) || ct["Geometric Shapes"](i) || ct["Miscellaneous Symbols"](i) && !(i >= 9754 && i <= 9759) || ct["Miscellaneous Symbols and Arrows"](i) && (i >= 11026 && i <= 11055 || i >= 11088 && i <= 11097 || i >= 11192 && i <= 11243) || ct["CJK Symbols and Punctuation"](i) || ct.Katakana(i) || ct["Private Use Area"](i) || ct["CJK Compatibility Forms"](i) || ct["Small Form Variants"](i) || ct["Halfwidth and Fullwidth Forms"](i) || i === 8734 || i === 8756 || i === 8757 || i >= 9984 && i <= 10087 || i >= 10102 && i <= 10131 || i === 65532 || i === 65533);
        }(r));
      }
      function qo(r) {
        return r >= 1424 && r <= 2303 || ct["Arabic Presentation Forms-A"](r) || ct["Arabic Presentation Forms-B"](r);
      }
      function ho(r, i) {
        return !(!i && qo(r) || r >= 2304 && r <= 3583 || r >= 3840 && r <= 4255 || ct.Khmer(r));
      }
      function bh(r) {
        for (var i = 0, l = r; i < l.length; i += 1)
          if (qo(l[i].charCodeAt(0)))
            return !0;
        return !1;
      }
      var wh = null, fo = "unavailable", ja = null, Rm = function(r) {
        r && typeof r == "string" && r.indexOf("NetworkError") > -1 && (fo = "error"), wh && wh(r);
      };
      function cc() {
        up.fire(new Q("pluginStateChange", { pluginStatus: fo, pluginURL: ja }));
      }
      var up = new de(), cp = function() {
        return fo;
      }, sa = function() {
        if (fo !== "deferred" || !ja)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        fo = "loading", cc(), ja && ol({ url: ja }, function(r) {
          r ? Rm(r) : (fo = "loaded", cc());
        });
      }, Io = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function() {
        return fo === "loaded" || Io.applyArabicShaping != null;
      }, isLoading: function() {
        return fo === "loading";
      }, setState: function(r) {
        fo = r.pluginStatus, ja = r.pluginURL;
      }, isParsed: function() {
        return Io.applyArabicShaping != null && Io.processBidirectionalText != null && Io.processStyledBidirectionalText != null;
      }, getPluginURL: function() {
        return ja;
      } }, mr = function(r, i) {
        this.zoom = r, i ? (this.now = i.now, this.fadeDuration = i.fadeDuration, this.zoomHistory = i.zoomHistory, this.transition = i.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ap(), this.transition = {});
      };
      mr.prototype.isSupportedScript = function(r) {
        return function(i, l) {
          for (var p = 0, y = i; p < y.length; p += 1)
            if (!ho(y[p].charCodeAt(0), l))
              return !1;
          return !0;
        }(r, Io.isLoaded());
      }, mr.prototype.crossFadingFactor = function() {
        return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
      }, mr.prototype.getCrossfadeParameters = function() {
        var r = this.zoom, i = r - Math.floor(r), l = this.crossFadingFactor();
        return r > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: i + (1 - i) * l } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - l) * i };
      };
      var ba = function(r, i) {
        this.property = r, this.value = i, this.expression = function(l, p) {
          if (hh(l))
            return new tu(l, p);
          if (tc(l)) {
            var y = Om(l, p);
            if (y.result === "error")
              throw new Error(y.value.map(function(x) {
                return x.key + ": " + x.message;
              }).join(", "));
            return y.value;
          }
          var v = l;
          return typeof l == "string" && p.type === "color" && (v = zr.parse(l)), { kind: "constant", evaluate: function() {
            return v;
          } };
        }(i === void 0 ? r.specification.default : i, r.specification);
      };
      ba.prototype.isDataDriven = function() {
        return this.expression.kind === "source" || this.expression.kind === "composite";
      }, ba.prototype.possiblyEvaluate = function(r, i, l) {
        return this.property.possiblyEvaluate(this, r, i, l);
      };
      var Wo = function(r) {
        this.property = r, this.value = new ba(r, void 0);
      };
      Wo.prototype.transitioned = function(r, i) {
        return new xl(this.property, this.value, i, X({}, r.transition, this.transition), r.now);
      }, Wo.prototype.untransitioned = function() {
        return new xl(this.property, this.value, null, {}, 0);
      };
      var Mi = function(r) {
        this._properties = r, this._values = Object.create(r.defaultTransitionablePropertyValues);
      };
      Mi.prototype.getValue = function(r) {
        return Xe(this._values[r].value.value);
      }, Mi.prototype.setValue = function(r, i) {
        this._values.hasOwnProperty(r) || (this._values[r] = new Wo(this._values[r].property)), this._values[r].value = new ba(this._values[r].property, i === null ? void 0 : Xe(i));
      }, Mi.prototype.getTransition = function(r) {
        return Xe(this._values[r].transition);
      }, Mi.prototype.setTransition = function(r, i) {
        this._values.hasOwnProperty(r) || (this._values[r] = new Wo(this._values[r].property)), this._values[r].transition = Xe(i) || void 0;
      }, Mi.prototype.serialize = function() {
        for (var r = {}, i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i], y = this.getValue(p);
          y !== void 0 && (r[p] = y);
          var v = this.getTransition(p);
          v !== void 0 && (r[p + "-transition"] = v);
        }
        return r;
      }, Mi.prototype.transitioned = function(r, i) {
        for (var l = new Es(this._properties), p = 0, y = Object.keys(this._values); p < y.length; p += 1) {
          var v = y[p];
          l._values[v] = this._values[v].transitioned(r, i._values[v]);
        }
        return l;
      }, Mi.prototype.untransitioned = function() {
        for (var r = new Es(this._properties), i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i];
          r._values[p] = this._values[p].untransitioned();
        }
        return r;
      };
      var xl = function(r, i, l, p, y) {
        this.property = r, this.value = i, this.begin = y + p.delay || 0, this.end = this.begin + p.duration || 0, r.specification.transition && (p.delay || p.duration) && (this.prior = l);
      };
      xl.prototype.possiblyEvaluate = function(r, i, l) {
        var p = r.now || 0, y = this.value.possiblyEvaluate(r, i, l), v = this.prior;
        if (v) {
          if (p > this.end)
            return this.prior = null, y;
          if (this.value.isDataDriven())
            return this.prior = null, y;
          if (p < this.begin)
            return v.possiblyEvaluate(r, i, l);
          var x = (p - this.begin) / (this.end - this.begin);
          return this.property.interpolate(v.possiblyEvaluate(r, i, l), y, function(S) {
            if (S <= 0)
              return 0;
            if (S >= 1)
              return 1;
            var C = S * S, P = C * S;
            return 4 * (S < 0.5 ? P : 3 * (S - C) + P - 0.75);
          }(x));
        }
        return y;
      };
      var Es = function(r) {
        this._properties = r, this._values = Object.create(r.defaultTransitioningPropertyValues);
      };
      Es.prototype.possiblyEvaluate = function(r, i, l) {
        for (var p = new hc(this._properties), y = 0, v = Object.keys(this._values); y < v.length; y += 1) {
          var x = v[y];
          p._values[x] = this._values[x].possiblyEvaluate(r, i, l);
        }
        return p;
      }, Es.prototype.hasTransition = function() {
        for (var r = 0, i = Object.keys(this._values); r < i.length; r += 1)
          if (this._values[i[r]].prior)
            return !0;
        return !1;
      };
      var la = function(r) {
        this._properties = r, this._values = Object.create(r.defaultPropertyValues);
      };
      la.prototype.getValue = function(r) {
        return Xe(this._values[r].value);
      }, la.prototype.setValue = function(r, i) {
        this._values[r] = new ba(this._values[r].property, i === null ? void 0 : Xe(i));
      }, la.prototype.serialize = function() {
        for (var r = {}, i = 0, l = Object.keys(this._values); i < l.length; i += 1) {
          var p = l[i], y = this.getValue(p);
          y !== void 0 && (r[p] = y);
        }
        return r;
      }, la.prototype.possiblyEvaluate = function(r, i, l) {
        for (var p = new hc(this._properties), y = 0, v = Object.keys(this._values); y < v.length; y += 1) {
          var x = v[y];
          p._values[x] = this._values[x].possiblyEvaluate(r, i, l);
        }
        return p;
      };
      var ji = function(r, i, l) {
        this.property = r, this.value = i, this.parameters = l;
      };
      ji.prototype.isConstant = function() {
        return this.value.kind === "constant";
      }, ji.prototype.constantOr = function(r) {
        return this.value.kind === "constant" ? this.value.value : r;
      }, ji.prototype.evaluate = function(r, i, l, p) {
        return this.property.evaluate(this.value, this.parameters, r, i, l, p);
      };
      var hc = function(r) {
        this._properties = r, this._values = Object.create(r.defaultPossiblyEvaluatedValues);
      };
      hc.prototype.get = function(r) {
        return this._values[r];
      };
      var Dt = function(r) {
        this.specification = r;
      };
      Dt.prototype.possiblyEvaluate = function(r, i) {
        return r.expression.evaluate(i);
      }, Dt.prototype.interpolate = function(r, i, l) {
        var p = Yl[this.specification.type];
        return p ? p(r, i, l) : r;
      };
      var Tt = function(r, i) {
        this.specification = r, this.overrides = i;
      };
      Tt.prototype.possiblyEvaluate = function(r, i, l, p) {
        return new ji(this, r.expression.kind === "constant" || r.expression.kind === "camera" ? { kind: "constant", value: r.expression.evaluate(i, null, {}, l, p) } : r.expression, i);
      }, Tt.prototype.interpolate = function(r, i, l) {
        if (r.value.kind !== "constant" || i.value.kind !== "constant")
          return r;
        if (r.value.value === void 0 || i.value.value === void 0)
          return new ji(this, { kind: "constant", value: void 0 }, r.parameters);
        var p = Yl[this.specification.type];
        return p ? new ji(this, { kind: "constant", value: p(r.value.value, i.value.value, l) }, r.parameters) : r;
      }, Tt.prototype.evaluate = function(r, i, l, p, y, v) {
        return r.kind === "constant" ? r.value : r.evaluate(i, l, p, y, v);
      };
      var Eh = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.possiblyEvaluate = function(l, p, y, v) {
          if (l.value === void 0)
            return new ji(this, { kind: "constant", value: void 0 }, p);
          if (l.expression.kind === "constant") {
            var x = l.expression.evaluate(p, null, {}, y, v), S = l.property.specification.type === "resolvedImage" && typeof x != "string" ? x.name : x, C = this._calculate(S, S, S, p);
            return new ji(this, { kind: "constant", value: C }, p);
          }
          if (l.expression.kind === "camera") {
            var P = this._calculate(l.expression.evaluate({ zoom: p.zoom - 1 }), l.expression.evaluate({ zoom: p.zoom }), l.expression.evaluate({ zoom: p.zoom + 1 }), p);
            return new ji(this, { kind: "constant", value: P }, p);
          }
          return new ji(this, l.expression, p);
        }, i.prototype.evaluate = function(l, p, y, v, x, S) {
          if (l.kind === "source") {
            var C = l.evaluate(p, y, v, x, S);
            return this._calculate(C, C, C, p);
          }
          return l.kind === "composite" ? this._calculate(l.evaluate({ zoom: Math.floor(p.zoom) - 1 }, y, v), l.evaluate({ zoom: Math.floor(p.zoom) }, y, v), l.evaluate({ zoom: Math.floor(p.zoom) + 1 }, y, v), p) : l.value;
        }, i.prototype._calculate = function(l, p, y, v) {
          return v.zoom > v.zoomHistory.lastIntegerZoom ? { from: l, to: p } : { from: y, to: p };
        }, i.prototype.interpolate = function(l) {
          return l;
        }, i;
      }(Tt), Gi = function(r) {
        this.specification = r;
      };
      Gi.prototype.possiblyEvaluate = function(r, i, l, p) {
        if (r.value !== void 0) {
          if (r.expression.kind === "constant") {
            var y = r.expression.evaluate(i, null, {}, l, p);
            return this._calculate(y, y, y, i);
          }
          return this._calculate(r.expression.evaluate(new mr(Math.floor(i.zoom - 1), i)), r.expression.evaluate(new mr(Math.floor(i.zoom), i)), r.expression.evaluate(new mr(Math.floor(i.zoom + 1), i)), i);
        }
      }, Gi.prototype._calculate = function(r, i, l, p) {
        return p.zoom > p.zoomHistory.lastIntegerZoom ? { from: r, to: i } : { from: l, to: i };
      }, Gi.prototype.interpolate = function(r) {
        return r;
      };
      var ua = function(r) {
        this.specification = r;
      };
      ua.prototype.possiblyEvaluate = function(r, i, l, p) {
        return !!r.expression.evaluate(i, null, {}, l, p);
      }, ua.prototype.interpolate = function() {
        return !1;
      };
      var Ii = function(r) {
        for (var i in this.properties = r, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], r) {
          var l = r[i];
          l.specification.overridable && this.overridableProperties.push(i);
          var p = this.defaultPropertyValues[i] = new ba(l, void 0), y = this.defaultTransitionablePropertyValues[i] = new Wo(l);
          this.defaultTransitioningPropertyValues[i] = y.untransitioned(), this.defaultPossiblyEvaluatedValues[i] = p.possiblyEvaluate({});
        }
      };
      wt("DataDrivenProperty", Tt), wt("DataConstantProperty", Dt), wt("CrossFadedDataDrivenProperty", Eh), wt("CrossFadedProperty", Gi), wt("ColorRampProperty", ua);
      var wa = function(r) {
        function i(l, p) {
          if (r.call(this), this.id = l.id, this.type = l.type, this._featureFilter = { filter: function() {
            return !0;
          }, needGeometry: !1 }, l.type !== "custom" && (this.metadata = (l = l).metadata, this.minzoom = l.minzoom, this.maxzoom = l.maxzoom, l.type !== "background" && (this.source = l.source, this.sourceLayer = l["source-layer"], this.filter = l.filter), p.layout && (this._unevaluatedLayout = new la(p.layout)), p.paint)) {
            for (var y in this._transitionablePaint = new Mi(p.paint), l.paint)
              this.setPaintProperty(y, l.paint[y], { validate: !1 });
            for (var v in l.layout)
              this.setLayoutProperty(v, l.layout[v], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new hc(p.paint);
          }
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getCrossfadeParameters = function() {
          return this._crossfadeParameters;
        }, i.prototype.getLayoutProperty = function(l) {
          return l === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(l);
        }, i.prototype.setLayoutProperty = function(l, p, y) {
          y === void 0 && (y = {}), p != null && this._validate(sc, "layers." + this.id + ".layout." + l, l, p, y) || (l !== "visibility" ? this._unevaluatedLayout.setValue(l, p) : this.visibility = p);
        }, i.prototype.getPaintProperty = function(l) {
          return Ae(l, "-transition") ? this._transitionablePaint.getTransition(l.slice(0, -11)) : this._transitionablePaint.getValue(l);
        }, i.prototype.setPaintProperty = function(l, p, y) {
          if (y === void 0 && (y = {}), p != null && this._validate(Jv, "layers." + this.id + ".paint." + l, l, p, y))
            return !1;
          if (Ae(l, "-transition"))
            return this._transitionablePaint.setTransition(l.slice(0, -11), p || void 0), !1;
          var v = this._transitionablePaint._values[l], x = v.property.specification["property-type"] === "cross-faded-data-driven", S = v.value.isDataDriven(), C = v.value;
          this._transitionablePaint.setValue(l, p), this._handleSpecialPaintPropertyUpdate(l);
          var P = this._transitionablePaint._values[l].value;
          return P.isDataDriven() || S || x || this._handleOverridablePaintPropertyUpdate(l, C, P);
        }, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
        }, i.prototype._handleOverridablePaintPropertyUpdate = function(l, p, y) {
          return !1;
        }, i.prototype.isHidden = function(l) {
          return !!(this.minzoom && l < this.minzoom) || !!(this.maxzoom && l >= this.maxzoom) || this.visibility === "none";
        }, i.prototype.updateTransitions = function(l) {
          this._transitioningPaint = this._transitionablePaint.transitioned(l, this._transitioningPaint);
        }, i.prototype.hasTransition = function() {
          return this._transitioningPaint.hasTransition();
        }, i.prototype.recalculate = function(l, p) {
          l.getCrossfadeParameters && (this._crossfadeParameters = l.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(l, void 0, p)), this.paint = this._transitioningPaint.possiblyEvaluate(l, void 0, p);
        }, i.prototype.serialize = function() {
          var l = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (l.layout = l.layout || {}, l.layout.visibility = this.visibility), Ie(l, function(p, y) {
            return !(p === void 0 || y === "layout" && !Object.keys(p).length || y === "paint" && !Object.keys(p).length);
          });
        }, i.prototype._validate = function(l, p, y, v, x) {
          return x === void 0 && (x = {}), (!x || x.validate !== !1) && lc(this, l.call(ac, { key: p, layerType: this.type, objectKey: y, value: v, styleSpec: G, style: { glyphs: !0, sprite: !0 } }));
        }, i.prototype.is3D = function() {
          return !1;
        }, i.prototype.isTileClipped = function() {
          return !1;
        }, i.prototype.hasOffscreenPass = function() {
          return !1;
        }, i.prototype.resize = function() {
        }, i.prototype.isStateDependent = function() {
          for (var l in this.paint._values) {
            var p = this.paint.get(l);
            if (p instanceof ji && yl(p.property.specification) && (p.value.kind === "source" || p.value.kind === "composite") && p.value.isStateDependent)
              return !0;
          }
          return !1;
        }, i;
      }(de), hp = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, Sh = function(r, i) {
        this._structArray = r, this._pos1 = i * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
      }, Gr = function() {
        this.isTransferred = !1, this.capacity = -1, this.resize(0);
      };
      function gi(r, i) {
        i === void 0 && (i = 1);
        var l = 0, p = 0;
        return { members: r.map(function(y) {
          var v = hp[y.type].BYTES_PER_ELEMENT, x = l = zm(l, Math.max(i, v)), S = y.components || 1;
          return p = Math.max(p, v), l += v * S, { name: y.name, type: y.type, components: S, offset: x };
        }), size: zm(l, Math.max(p, i)), alignment: i };
      }
      function zm(r, i) {
        return Math.ceil(r / i) * i;
      }
      Gr.serialize = function(r, i) {
        return r._trim(), i && (r.isTransferred = !0, i.push(r.arrayBuffer)), { length: r.length, arrayBuffer: r.arrayBuffer };
      }, Gr.deserialize = function(r) {
        var i = Object.create(this.prototype);
        return i.arrayBuffer = r.arrayBuffer, i.length = r.length, i.capacity = r.arrayBuffer.byteLength / i.bytesPerElement, i._refreshViews(), i;
      }, Gr.prototype._trim = function() {
        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
      }, Gr.prototype.clear = function() {
        this.length = 0;
      }, Gr.prototype.resize = function(r) {
        this.reserve(r), this.length = r;
      }, Gr.prototype.reserve = function(r) {
        if (r > this.capacity) {
          this.capacity = Math.max(r, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
          var i = this.uint8;
          this._refreshViews(), i && this.uint8.set(i);
        }
      }, Gr.prototype._refreshViews = function() {
        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
      };
      var bl = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.int16[v + 0] = p, this.int16[v + 1] = y, l;
        }, i;
      }(Gr);
      bl.prototype.bytesPerElement = 4, wt("StructArrayLayout2i4", bl);
      var fp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 4 * l;
          return this.int16[S + 0] = p, this.int16[S + 1] = y, this.int16[S + 2] = v, this.int16[S + 3] = x, l;
        }, i;
      }(Gr);
      fp.prototype.bytesPerElement = 8, wt("StructArrayLayout4i8", fp);
      var Ga = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var P = 6 * l;
          return this.int16[P + 0] = p, this.int16[P + 1] = y, this.int16[P + 2] = v, this.int16[P + 3] = x, this.int16[P + 4] = S, this.int16[P + 5] = C, l;
        }, i;
      }(Gr);
      Ga.prototype.bytesPerElement = 12, wt("StructArrayLayout2i4i12", Ga);
      var po = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var P = 4 * l, L = 8 * l;
          return this.int16[P + 0] = p, this.int16[P + 1] = y, this.uint8[L + 4] = v, this.uint8[L + 5] = x, this.uint8[L + 6] = S, this.uint8[L + 7] = C, l;
        }, i;
      }(Gr);
      po.prototype.bytesPerElement = 8, wt("StructArrayLayout2i4ub8", po);
      var iu = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.float32[v + 0] = p, this.float32[v + 1] = y, l;
        }, i;
      }(Gr);
      iu.prototype.bytesPerElement = 8, wt("StructArrayLayout2f8", iu);
      var Ea = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, P, L, D) {
          var B = this.length;
          return this.resize(B + 1), this.emplace(B, l, p, y, v, x, S, C, P, L, D);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, P, L, D, B) {
          var j = 10 * l;
          return this.uint16[j + 0] = p, this.uint16[j + 1] = y, this.uint16[j + 2] = v, this.uint16[j + 3] = x, this.uint16[j + 4] = S, this.uint16[j + 5] = C, this.uint16[j + 6] = P, this.uint16[j + 7] = L, this.uint16[j + 8] = D, this.uint16[j + 9] = B, l;
        }, i;
      }(Gr);
      Ea.prototype.bytesPerElement = 20, wt("StructArrayLayout10ui20", Ea);
      var Th = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, P, L, D, B, j) {
          var J = this.length;
          return this.resize(J + 1), this.emplace(J, l, p, y, v, x, S, C, P, L, D, B, j);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, P, L, D, B, j, J) {
          var ee = 12 * l;
          return this.int16[ee + 0] = p, this.int16[ee + 1] = y, this.int16[ee + 2] = v, this.int16[ee + 3] = x, this.uint16[ee + 4] = S, this.uint16[ee + 5] = C, this.uint16[ee + 6] = P, this.uint16[ee + 7] = L, this.int16[ee + 8] = D, this.int16[ee + 9] = B, this.int16[ee + 10] = j, this.int16[ee + 11] = J, l;
        }, i;
      }(Gr);
      Th.prototype.bytesPerElement = 24, wt("StructArrayLayout4i4ui4i24", Th);
      var ou = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.float32[x + 0] = p, this.float32[x + 1] = y, this.float32[x + 2] = v, l;
        }, i;
      }(Gr);
      ou.prototype.bytesPerElement = 12, wt("StructArrayLayout3f12", ou);
      var fc = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.uint32[1 * l + 0] = p, l;
        }, i;
      }(Gr);
      fc.prototype.bytesPerElement = 4, wt("StructArrayLayout1ul4", fc);
      var pp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, P, L) {
          var D = this.length;
          return this.resize(D + 1), this.emplace(D, l, p, y, v, x, S, C, P, L);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, P, L, D) {
          var B = 10 * l, j = 5 * l;
          return this.int16[B + 0] = p, this.int16[B + 1] = y, this.int16[B + 2] = v, this.int16[B + 3] = x, this.int16[B + 4] = S, this.int16[B + 5] = C, this.uint32[j + 3] = P, this.uint16[B + 8] = L, this.uint16[B + 9] = D, l;
        }, i;
      }(Gr);
      pp.prototype.bytesPerElement = 20, wt("StructArrayLayout6i1ul2ui20", pp);
      var au = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S) {
          var C = this.length;
          return this.resize(C + 1), this.emplace(C, l, p, y, v, x, S);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C) {
          var P = 6 * l;
          return this.int16[P + 0] = p, this.int16[P + 1] = y, this.int16[P + 2] = v, this.int16[P + 3] = x, this.int16[P + 4] = S, this.int16[P + 5] = C, l;
        }, i;
      }(Gr);
      au.prototype.bytesPerElement = 12, wt("StructArrayLayout2i2i2i12", au);
      var wl = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x) {
          var S = this.length;
          return this.resize(S + 1), this.emplace(S, l, p, y, v, x);
        }, i.prototype.emplace = function(l, p, y, v, x, S) {
          var C = 4 * l, P = 8 * l;
          return this.float32[C + 0] = p, this.float32[C + 1] = y, this.float32[C + 2] = v, this.int16[P + 6] = x, this.int16[P + 7] = S, l;
        }, i;
      }(Gr);
      wl.prototype.bytesPerElement = 16, wt("StructArrayLayout2f1f2i16", wl);
      var dp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 12 * l, C = 3 * l;
          return this.uint8[S + 0] = p, this.uint8[S + 1] = y, this.float32[C + 1] = v, this.float32[C + 2] = x, l;
        }, i;
      }(Gr);
      dp.prototype.bytesPerElement = 12, wt("StructArrayLayout2ub2f12", dp);
      var Ss = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.uint16[x + 0] = p, this.uint16[x + 1] = y, this.uint16[x + 2] = v, l;
        }, i;
      }(Gr);
      Ss.prototype.bytesPerElement = 6, wt("StructArrayLayout3ui6", Ss);
      var Ts = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, P, L, D, B, j, J, ee, he, oe, ge) {
          var we = this.length;
          return this.resize(we + 1), this.emplace(we, l, p, y, v, x, S, C, P, L, D, B, j, J, ee, he, oe, ge);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, P, L, D, B, j, J, ee, he, oe, ge, we) {
          var Te = 24 * l, Oe = 12 * l, Ve = 48 * l;
          return this.int16[Te + 0] = p, this.int16[Te + 1] = y, this.uint16[Te + 2] = v, this.uint16[Te + 3] = x, this.uint32[Oe + 2] = S, this.uint32[Oe + 3] = C, this.uint32[Oe + 4] = P, this.uint16[Te + 10] = L, this.uint16[Te + 11] = D, this.uint16[Te + 12] = B, this.float32[Oe + 7] = j, this.float32[Oe + 8] = J, this.uint8[Ve + 36] = ee, this.uint8[Ve + 37] = he, this.uint8[Ve + 38] = oe, this.uint32[Oe + 10] = ge, this.int16[Te + 22] = we, l;
        }, i;
      }(Gr);
      Ts.prototype.bytesPerElement = 48, wt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ts);
      var Mh = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v, x, S, C, P, L, D, B, j, J, ee, he, oe, ge, we, Te, Oe, Ve, Ke, ot, Pt, dt, Rt, yt, sr) {
          var $t = this.length;
          return this.resize($t + 1), this.emplace($t, l, p, y, v, x, S, C, P, L, D, B, j, J, ee, he, oe, ge, we, Te, Oe, Ve, Ke, ot, Pt, dt, Rt, yt, sr);
        }, i.prototype.emplace = function(l, p, y, v, x, S, C, P, L, D, B, j, J, ee, he, oe, ge, we, Te, Oe, Ve, Ke, ot, Pt, dt, Rt, yt, sr, $t) {
          var Mt = 34 * l, fr = 17 * l;
          return this.int16[Mt + 0] = p, this.int16[Mt + 1] = y, this.int16[Mt + 2] = v, this.int16[Mt + 3] = x, this.int16[Mt + 4] = S, this.int16[Mt + 5] = C, this.int16[Mt + 6] = P, this.int16[Mt + 7] = L, this.uint16[Mt + 8] = D, this.uint16[Mt + 9] = B, this.uint16[Mt + 10] = j, this.uint16[Mt + 11] = J, this.uint16[Mt + 12] = ee, this.uint16[Mt + 13] = he, this.uint16[Mt + 14] = oe, this.uint16[Mt + 15] = ge, this.uint16[Mt + 16] = we, this.uint16[Mt + 17] = Te, this.uint16[Mt + 18] = Oe, this.uint16[Mt + 19] = Ve, this.uint16[Mt + 20] = Ke, this.uint16[Mt + 21] = ot, this.uint16[Mt + 22] = Pt, this.uint32[fr + 12] = dt, this.float32[fr + 13] = Rt, this.float32[fr + 14] = yt, this.float32[fr + 15] = sr, this.float32[fr + 16] = $t, l;
        }, i;
      }(Gr);
      Mh.prototype.bytesPerElement = 68, wt("StructArrayLayout8i15ui1ul4f68", Mh);
      var Ms = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.float32[1 * l + 0] = p, l;
        }, i;
      }(Gr);
      Ms.prototype.bytesPerElement = 4, wt("StructArrayLayout1f4", Ms);
      var Ho = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 3 * l;
          return this.int16[x + 0] = p, this.int16[x + 1] = y, this.int16[x + 2] = v, l;
        }, i;
      }(Gr);
      Ho.prototype.bytesPerElement = 6, wt("StructArrayLayout3i6", Ho);
      var mp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y) {
          var v = this.length;
          return this.resize(v + 1), this.emplace(v, l, p, y);
        }, i.prototype.emplace = function(l, p, y, v) {
          var x = 4 * l;
          return this.uint32[2 * l + 0] = p, this.uint16[x + 2] = y, this.uint16[x + 3] = v, l;
        }, i;
      }(Gr);
      mp.prototype.bytesPerElement = 8, wt("StructArrayLayout1ul2ui8", mp);
      var pc = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p) {
          var y = this.length;
          return this.resize(y + 1), this.emplace(y, l, p);
        }, i.prototype.emplace = function(l, p, y) {
          var v = 2 * l;
          return this.uint16[v + 0] = p, this.uint16[v + 1] = y, l;
        }, i;
      }(Gr);
      pc.prototype.bytesPerElement = 4, wt("StructArrayLayout2ui4", pc);
      var yp = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l) {
          var p = this.length;
          return this.resize(p + 1), this.emplace(p, l);
        }, i.prototype.emplace = function(l, p) {
          return this.uint16[1 * l + 0] = p, l;
        }, i;
      }(Gr);
      yp.prototype.bytesPerElement = 2, wt("StructArrayLayout1ui2", yp);
      var Ih = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._refreshViews = function() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }, i.prototype.emplaceBack = function(l, p, y, v) {
          var x = this.length;
          return this.resize(x + 1), this.emplace(x, l, p, y, v);
        }, i.prototype.emplace = function(l, p, y, v, x) {
          var S = 4 * l;
          return this.float32[S + 0] = p, this.float32[S + 1] = y, this.float32[S + 2] = v, this.float32[S + 3] = x, l;
        }, i;
      }(Gr);
      Ih.prototype.bytesPerElement = 16, wt("StructArrayLayout4f16", Ih);
      var u = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorPointX: { configurable: !0 }, anchorPointY: { configurable: !0 }, x1: { configurable: !0 }, y1: { configurable: !0 }, x2: { configurable: !0 }, y2: { configurable: !0 }, featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 }, anchorPoint: { configurable: !0 } };
        return l.anchorPointX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorPointY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.x1.get = function() {
          return this._structArray.int16[this._pos2 + 2];
        }, l.y1.get = function() {
          return this._structArray.int16[this._pos2 + 3];
        }, l.x2.get = function() {
          return this._structArray.int16[this._pos2 + 4];
        }, l.y2.get = function() {
          return this._structArray.int16[this._pos2 + 5];
        }, l.featureIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 3];
        }, l.sourceLayerIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 8];
        }, l.bucketIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 9];
        }, l.anchorPoint.get = function() {
          return new T(this.anchorPointX, this.anchorPointY);
        }, Object.defineProperties(i.prototype, l), i;
      }(Sh);
      u.prototype.size = 20;
      var h = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new u(this, l);
        }, i;
      }(pp);
      wt("CollisionBoxArray", h);
      var c = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, glyphStartIndex: { configurable: !0 }, numGlyphs: { configurable: !0 }, vertexStartIndex: { configurable: !0 }, lineStartIndex: { configurable: !0 }, lineLength: { configurable: !0 }, segment: { configurable: !0 }, lowerSize: { configurable: !0 }, upperSize: { configurable: !0 }, lineOffsetX: { configurable: !0 }, lineOffsetY: { configurable: !0 }, writingMode: { configurable: !0 }, placedOrientation: { configurable: !0 }, hidden: { configurable: !0 }, crossTileID: { configurable: !0 }, associatedIconIndex: { configurable: !0 } };
        return l.anchorX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.glyphStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 2];
        }, l.numGlyphs.get = function() {
          return this._structArray.uint16[this._pos2 + 3];
        }, l.vertexStartIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 2];
        }, l.lineStartIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 3];
        }, l.lineLength.get = function() {
          return this._structArray.uint32[this._pos4 + 4];
        }, l.segment.get = function() {
          return this._structArray.uint16[this._pos2 + 10];
        }, l.lowerSize.get = function() {
          return this._structArray.uint16[this._pos2 + 11];
        }, l.upperSize.get = function() {
          return this._structArray.uint16[this._pos2 + 12];
        }, l.lineOffsetX.get = function() {
          return this._structArray.float32[this._pos4 + 7];
        }, l.lineOffsetY.get = function() {
          return this._structArray.float32[this._pos4 + 8];
        }, l.writingMode.get = function() {
          return this._structArray.uint8[this._pos1 + 36];
        }, l.placedOrientation.get = function() {
          return this._structArray.uint8[this._pos1 + 37];
        }, l.placedOrientation.set = function(p) {
          this._structArray.uint8[this._pos1 + 37] = p;
        }, l.hidden.get = function() {
          return this._structArray.uint8[this._pos1 + 38];
        }, l.hidden.set = function(p) {
          this._structArray.uint8[this._pos1 + 38] = p;
        }, l.crossTileID.get = function() {
          return this._structArray.uint32[this._pos4 + 10];
        }, l.crossTileID.set = function(p) {
          this._structArray.uint32[this._pos4 + 10] = p;
        }, l.associatedIconIndex.get = function() {
          return this._structArray.int16[this._pos2 + 22];
        }, Object.defineProperties(i.prototype, l), i;
      }(Sh);
      c.prototype.size = 48;
      var d = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new c(this, l);
        }, i;
      }(Ts);
      wt("PlacedSymbolArray", d);
      var _ = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, rightJustifiedTextSymbolIndex: { configurable: !0 }, centerJustifiedTextSymbolIndex: { configurable: !0 }, leftJustifiedTextSymbolIndex: { configurable: !0 }, verticalPlacedTextSymbolIndex: { configurable: !0 }, placedIconSymbolIndex: { configurable: !0 }, verticalPlacedIconSymbolIndex: { configurable: !0 }, key: { configurable: !0 }, textBoxStartIndex: { configurable: !0 }, textBoxEndIndex: { configurable: !0 }, verticalTextBoxStartIndex: { configurable: !0 }, verticalTextBoxEndIndex: { configurable: !0 }, iconBoxStartIndex: { configurable: !0 }, iconBoxEndIndex: { configurable: !0 }, verticalIconBoxStartIndex: { configurable: !0 }, verticalIconBoxEndIndex: { configurable: !0 }, featureIndex: { configurable: !0 }, numHorizontalGlyphVertices: { configurable: !0 }, numVerticalGlyphVertices: { configurable: !0 }, numIconVertices: { configurable: !0 }, numVerticalIconVertices: { configurable: !0 }, useRuntimeCollisionCircles: { configurable: !0 }, crossTileID: { configurable: !0 }, textBoxScale: { configurable: !0 }, textOffset0: { configurable: !0 }, textOffset1: { configurable: !0 }, collisionCircleDiameter: { configurable: !0 } };
        return l.anchorX.get = function() {
          return this._structArray.int16[this._pos2 + 0];
        }, l.anchorY.get = function() {
          return this._structArray.int16[this._pos2 + 1];
        }, l.rightJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 2];
        }, l.centerJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 3];
        }, l.leftJustifiedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 4];
        }, l.verticalPlacedTextSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 5];
        }, l.placedIconSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 6];
        }, l.verticalPlacedIconSymbolIndex.get = function() {
          return this._structArray.int16[this._pos2 + 7];
        }, l.key.get = function() {
          return this._structArray.uint16[this._pos2 + 8];
        }, l.textBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 9];
        }, l.textBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 10];
        }, l.verticalTextBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 11];
        }, l.verticalTextBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 12];
        }, l.iconBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 13];
        }, l.iconBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 14];
        }, l.verticalIconBoxStartIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 15];
        }, l.verticalIconBoxEndIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 16];
        }, l.featureIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 17];
        }, l.numHorizontalGlyphVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 18];
        }, l.numVerticalGlyphVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 19];
        }, l.numIconVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 20];
        }, l.numVerticalIconVertices.get = function() {
          return this._structArray.uint16[this._pos2 + 21];
        }, l.useRuntimeCollisionCircles.get = function() {
          return this._structArray.uint16[this._pos2 + 22];
        }, l.crossTileID.get = function() {
          return this._structArray.uint32[this._pos4 + 12];
        }, l.crossTileID.set = function(p) {
          this._structArray.uint32[this._pos4 + 12] = p;
        }, l.textBoxScale.get = function() {
          return this._structArray.float32[this._pos4 + 13];
        }, l.textOffset0.get = function() {
          return this._structArray.float32[this._pos4 + 14];
        }, l.textOffset1.get = function() {
          return this._structArray.float32[this._pos4 + 15];
        }, l.collisionCircleDiameter.get = function() {
          return this._structArray.float32[this._pos4 + 16];
        }, Object.defineProperties(i.prototype, l), i;
      }(Sh);
      _.prototype.size = 68;
      var w = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new _(this, l);
        }, i;
      }(Mh);
      wt("SymbolInstanceArray", w);
      var E = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getoffsetX = function(l) {
          return this.float32[1 * l + 0];
        }, i;
      }(Ms);
      wt("GlyphOffsetArray", E);
      var O = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.getx = function(l) {
          return this.int16[3 * l + 0];
        }, i.prototype.gety = function(l) {
          return this.int16[3 * l + 1];
        }, i.prototype.gettileUnitDistanceFromAnchor = function(l) {
          return this.int16[3 * l + 2];
        }, i;
      }(Ho);
      wt("SymbolLineVertexArray", O);
      var k = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i;
        var l = { featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 } };
        return l.featureIndex.get = function() {
          return this._structArray.uint32[this._pos4 + 0];
        }, l.sourceLayerIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 2];
        }, l.bucketIndex.get = function() {
          return this._structArray.uint16[this._pos2 + 3];
        }, Object.defineProperties(i.prototype, l), i;
      }(Sh);
      k.prototype.size = 8;
      var R = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.get = function(l) {
          return new k(this, l);
        }, i;
      }(mp);
      wt("FeatureIndexArray", R);
      var $ = gi([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, W = function(r) {
        r === void 0 && (r = []), this.segments = r;
      };
      function H(r, i) {
        return 256 * (r = q(Math.floor(r), 0, 255)) + q(Math.floor(i), 0, 255);
      }
      W.prototype.prepareSegment = function(r, i, l, p) {
        var y = this.segments[this.segments.length - 1];
        return r > W.MAX_VERTEX_ARRAY_LENGTH && at("Max vertices per segment is " + W.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + r), (!y || y.vertexLength + r > W.MAX_VERTEX_ARRAY_LENGTH || y.sortKey !== p) && (y = { vertexOffset: i.length, primitiveOffset: l.length, vertexLength: 0, primitiveLength: 0 }, p !== void 0 && (y.sortKey = p), this.segments.push(y)), y;
      }, W.prototype.get = function() {
        return this.segments;
      }, W.prototype.destroy = function() {
        for (var r = 0, i = this.segments; r < i.length; r += 1) {
          var l = i[r];
          for (var p in l.vaos)
            l.vaos[p].destroy();
        }
      }, W.simpleSegment = function(r, i, l, p) {
        return new W([{ vertexOffset: r, primitiveOffset: i, vertexLength: l, primitiveLength: p, vaos: {}, sortKey: 0 }]);
      }, W.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, wt("SegmentVector", W);
      var ne = gi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), te = m(function(r) {
        r.exports = function(i, l) {
          var p, y, v, x, S, C, P, L;
          for (y = i.length - (p = 3 & i.length), v = l, S = 3432918353, C = 461845907, L = 0; L < y; )
            P = 255 & i.charCodeAt(L) | (255 & i.charCodeAt(++L)) << 8 | (255 & i.charCodeAt(++L)) << 16 | (255 & i.charCodeAt(++L)) << 24, ++L, v = 27492 + (65535 & (x = 5 * (65535 & (v = (v ^= P = (65535 & (P = (P = (65535 & P) * S + (((P >>> 16) * S & 65535) << 16) & 4294967295) << 15 | P >>> 17)) * C + (((P >>> 16) * C & 65535) << 16) & 4294967295) << 13 | v >>> 19)) + ((5 * (v >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (x >>> 16) & 65535) << 16);
          switch (P = 0, p) {
            case 3:
              P ^= (255 & i.charCodeAt(L + 2)) << 16;
            case 2:
              P ^= (255 & i.charCodeAt(L + 1)) << 8;
            case 1:
              v ^= P = (65535 & (P = (P = (65535 & (P ^= 255 & i.charCodeAt(L))) * S + (((P >>> 16) * S & 65535) << 16) & 4294967295) << 15 | P >>> 17)) * C + (((P >>> 16) * C & 65535) << 16) & 4294967295;
          }
          return v ^= i.length, v = 2246822507 * (65535 & (v ^= v >>> 16)) + ((2246822507 * (v >>> 16) & 65535) << 16) & 4294967295, v = 3266489909 * (65535 & (v ^= v >>> 13)) + ((3266489909 * (v >>> 16) & 65535) << 16) & 4294967295, (v ^= v >>> 16) >>> 0;
        };
      }), ue = m(function(r) {
        r.exports = function(i, l) {
          for (var p, y = i.length, v = l ^ y, x = 0; y >= 4; )
            p = 1540483477 * (65535 & (p = 255 & i.charCodeAt(x) | (255 & i.charCodeAt(++x)) << 8 | (255 & i.charCodeAt(++x)) << 16 | (255 & i.charCodeAt(++x)) << 24)) + ((1540483477 * (p >>> 16) & 65535) << 16), v = 1540483477 * (65535 & v) + ((1540483477 * (v >>> 16) & 65535) << 16) ^ (p = 1540483477 * (65535 & (p ^= p >>> 24)) + ((1540483477 * (p >>> 16) & 65535) << 16)), y -= 4, ++x;
          switch (y) {
            case 3:
              v ^= (255 & i.charCodeAt(x + 2)) << 16;
            case 2:
              v ^= (255 & i.charCodeAt(x + 1)) << 8;
            case 1:
              v = 1540483477 * (65535 & (v ^= 255 & i.charCodeAt(x))) + ((1540483477 * (v >>> 16) & 65535) << 16);
          }
          return v = 1540483477 * (65535 & (v ^= v >>> 13)) + ((1540483477 * (v >>> 16) & 65535) << 16), (v ^= v >>> 15) >>> 0;
        };
      }), Y = te, le = ue;
      Y.murmur3 = te, Y.murmur2 = le;
      var me = function() {
        this.ids = [], this.positions = [], this.indexed = !1;
      };
      me.prototype.add = function(r, i, l, p) {
        this.ids.push(Pe(r)), this.positions.push(i, l, p);
      }, me.prototype.getPositions = function(r) {
        for (var i = Pe(r), l = 0, p = this.ids.length - 1; l < p; ) {
          var y = l + p >> 1;
          this.ids[y] >= i ? p = y : l = y + 1;
        }
        for (var v = []; this.ids[l] === i; )
          v.push({ index: this.positions[3 * l], start: this.positions[3 * l + 1], end: this.positions[3 * l + 2] }), l++;
        return v;
      }, me.serialize = function(r, i) {
        var l = new Float64Array(r.ids), p = new Uint32Array(r.positions);
        return function y(v, x, S, C) {
          for (; S < C; ) {
            for (var P = v[S + C >> 1], L = S - 1, D = C + 1; ; ) {
              do
                L++;
              while (v[L] < P);
              do
                D--;
              while (v[D] > P);
              if (L >= D)
                break;
              Me(v, L, D), Me(x, 3 * L, 3 * D), Me(x, 3 * L + 1, 3 * D + 1), Me(x, 3 * L + 2, 3 * D + 2);
            }
            D - S < C - D ? (y(v, x, S, D), S = D + 1) : (y(v, x, D + 1, C), C = D);
          }
        }(l, p, 0, l.length - 1), i && i.push(l.buffer, p.buffer), { ids: l, positions: p };
      }, me.deserialize = function(r) {
        var i = new me();
        return i.ids = r.ids, i.positions = r.positions, i.indexed = !0, i;
      };
      var xe = Math.pow(2, 53) - 1;
      function Pe(r) {
        var i = +r;
        return !isNaN(i) && i <= xe ? i : Y(String(r));
      }
      function Me(r, i, l) {
        var p = r[i];
        r[i] = r[l], r[l] = p;
      }
      wt("FeaturePositionMap", me);
      var ke = function(r, i) {
        this.gl = r.gl, this.location = i;
      }, je = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          this.current !== l && (this.current = l, this.gl.uniform1i(this.location, l));
        }, i;
      }(ke), it = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          this.current !== l && (this.current = l, this.gl.uniform1f(this.location, l));
        }, i;
      }(ke), tt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] || (this.current = l, this.gl.uniform2f(this.location, l[0], l[1]));
        }, i;
      }(ke), gt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] && l[2] === this.current[2] || (this.current = l, this.gl.uniform3f(this.location, l[0], l[1], l[2]));
        }, i;
      }(ke), Nt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = [0, 0, 0, 0];
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l[0] === this.current[0] && l[1] === this.current[1] && l[2] === this.current[2] && l[3] === this.current[3] || (this.current = l, this.gl.uniform4f(this.location, l[0], l[1], l[2], l[3]));
        }, i;
      }(ke), Bt = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = zr.transparent;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          l.r === this.current.r && l.g === this.current.g && l.b === this.current.b && l.a === this.current.a || (this.current = l, this.gl.uniform4f(this.location, l.r, l.g, l.b, l.a));
        }, i;
      }(ke), Ft = new Float32Array(16), Ir = function(r) {
        function i(l, p) {
          r.call(this, l, p), this.current = Ft;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.set = function(l) {
          if (l[12] !== this.current[12] || l[0] !== this.current[0])
            return this.current = l, void this.gl.uniformMatrix4fv(this.location, !1, l);
          for (var p = 1; p < 16; p++)
            if (l[p] !== this.current[p]) {
              this.current = l, this.gl.uniformMatrix4fv(this.location, !1, l);
              break;
            }
        }, i;
      }(ke);
      function xt(r) {
        return [H(255 * r.r, 255 * r.g), H(255 * r.b, 255 * r.a)];
      }
      var Yt = function(r, i, l) {
        this.value = r, this.uniformNames = i.map(function(p) {
          return "u_" + p;
        }), this.type = l;
      };
      Yt.prototype.setUniform = function(r, i, l) {
        r.set(l.constantOr(this.value));
      }, Yt.prototype.getBinding = function(r, i, l) {
        return this.type === "color" ? new Bt(r, i) : new it(r, i);
      };
      var or = function(r, i) {
        this.uniformNames = i.map(function(l) {
          return "u_" + l;
        }), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
      };
      or.prototype.setConstantPatternPositions = function(r, i) {
        this.pixelRatioFrom = i.pixelRatio, this.pixelRatioTo = r.pixelRatio, this.patternFrom = i.tlbr, this.patternTo = r.tlbr;
      }, or.prototype.setUniform = function(r, i, l, p) {
        var y = p === "u_pattern_to" ? this.patternTo : p === "u_pattern_from" ? this.patternFrom : p === "u_pixel_ratio_to" ? this.pixelRatioTo : p === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
        y && r.set(y);
      }, or.prototype.getBinding = function(r, i, l) {
        return l.substr(0, 9) === "u_pattern" ? new Nt(r, i) : new it(r, i);
      };
      var Kt = function(r, i, l, p) {
        this.expression = r, this.type = l, this.maxValue = 0, this.paintVertexAttributes = i.map(function(y) {
          return { name: "a_" + y, type: "Float32", components: l === "color" ? 2 : 1, offset: 0 };
        }), this.paintVertexArray = new p();
      };
      Kt.prototype.populatePaintArray = function(r, i, l, p, y) {
        var v = this.paintVertexArray.length, x = this.expression.evaluate(new mr(0), i, {}, p, [], y);
        this.paintVertexArray.resize(r), this._setPaintValue(v, r, x);
      }, Kt.prototype.updatePaintArray = function(r, i, l, p) {
        var y = this.expression.evaluate({ zoom: 0 }, l, p);
        this._setPaintValue(r, i, y);
      }, Kt.prototype._setPaintValue = function(r, i, l) {
        if (this.type === "color")
          for (var p = xt(l), y = r; y < i; y++)
            this.paintVertexArray.emplace(y, p[0], p[1]);
        else {
          for (var v = r; v < i; v++)
            this.paintVertexArray.emplace(v, l);
          this.maxValue = Math.max(this.maxValue, Math.abs(l));
        }
      }, Kt.prototype.upload = function(r) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = r.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }, Kt.prototype.destroy = function() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      };
      var Xt = function(r, i, l, p, y, v) {
        this.expression = r, this.uniformNames = i.map(function(x) {
          return "u_" + x + "_t";
        }), this.type = l, this.useIntegerZoom = p, this.zoom = y, this.maxValue = 0, this.paintVertexAttributes = i.map(function(x) {
          return { name: "a_" + x, type: "Float32", components: l === "color" ? 4 : 2, offset: 0 };
        }), this.paintVertexArray = new v();
      };
      Xt.prototype.populatePaintArray = function(r, i, l, p, y) {
        var v = this.expression.evaluate(new mr(this.zoom), i, {}, p, [], y), x = this.expression.evaluate(new mr(this.zoom + 1), i, {}, p, [], y), S = this.paintVertexArray.length;
        this.paintVertexArray.resize(r), this._setPaintValue(S, r, v, x);
      }, Xt.prototype.updatePaintArray = function(r, i, l, p) {
        var y = this.expression.evaluate({ zoom: this.zoom }, l, p), v = this.expression.evaluate({ zoom: this.zoom + 1 }, l, p);
        this._setPaintValue(r, i, y, v);
      }, Xt.prototype._setPaintValue = function(r, i, l, p) {
        if (this.type === "color")
          for (var y = xt(l), v = xt(p), x = r; x < i; x++)
            this.paintVertexArray.emplace(x, y[0], y[1], v[0], v[1]);
        else {
          for (var S = r; S < i; S++)
            this.paintVertexArray.emplace(S, l, p);
          this.maxValue = Math.max(this.maxValue, Math.abs(l), Math.abs(p));
        }
      }, Xt.prototype.upload = function(r) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = r.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }, Xt.prototype.destroy = function() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }, Xt.prototype.setUniform = function(r, i) {
        var l = this.useIntegerZoom ? Math.floor(i.zoom) : i.zoom, p = q(this.expression.interpolationFactor(l, this.zoom, this.zoom + 1), 0, 1);
        r.set(p);
      }, Xt.prototype.getBinding = function(r, i, l) {
        return new it(r, i);
      };
      var nr = function(r, i, l, p, y, v) {
        this.expression = r, this.type = i, this.useIntegerZoom = l, this.zoom = p, this.layerId = v, this.zoomInPaintVertexArray = new y(), this.zoomOutPaintVertexArray = new y();
      };
      nr.prototype.populatePaintArray = function(r, i, l) {
        var p = this.zoomInPaintVertexArray.length;
        this.zoomInPaintVertexArray.resize(r), this.zoomOutPaintVertexArray.resize(r), this._setPaintValues(p, r, i.patterns && i.patterns[this.layerId], l);
      }, nr.prototype.updatePaintArray = function(r, i, l, p, y) {
        this._setPaintValues(r, i, l.patterns && l.patterns[this.layerId], y);
      }, nr.prototype._setPaintValues = function(r, i, l, p) {
        if (p && l) {
          var y = p[l.min], v = p[l.mid], x = p[l.max];
          if (y && v && x)
            for (var S = r; S < i; S++)
              this.zoomInPaintVertexArray.emplace(S, v.tl[0], v.tl[1], v.br[0], v.br[1], y.tl[0], y.tl[1], y.br[0], y.br[1], v.pixelRatio, y.pixelRatio), this.zoomOutPaintVertexArray.emplace(S, v.tl[0], v.tl[1], v.br[0], v.br[1], x.tl[0], x.tl[1], x.br[0], x.br[1], v.pixelRatio, x.pixelRatio);
        }
      }, nr.prototype.upload = function(r) {
        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = r.createVertexBuffer(this.zoomInPaintVertexArray, ne.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = r.createVertexBuffer(this.zoomOutPaintVertexArray, ne.members, this.expression.isStateDependent));
      }, nr.prototype.destroy = function() {
        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
      };
      var Wt = function(r, i, l) {
        this.binders = {}, this._buffers = [];
        var p = [];
        for (var y in r.paint._values)
          if (l(y)) {
            var v = r.paint.get(y);
            if (v instanceof ji && yl(v.property.specification)) {
              var x = li(y, r.type), S = v.value, C = v.property.specification.type, P = v.property.useIntegerZoom, L = v.property.specification["property-type"], D = L === "cross-faded" || L === "cross-faded-data-driven";
              if (S.kind === "constant")
                this.binders[y] = D ? new or(S.value, x) : new Yt(S.value, x, C), p.push("/u_" + y);
              else if (S.kind === "source" || D) {
                var B = On(y, C, "source");
                this.binders[y] = D ? new nr(S, C, P, i, B, r.id) : new Kt(S, x, C, B), p.push("/a_" + y);
              } else {
                var j = On(y, C, "composite");
                this.binders[y] = new Xt(S, x, C, P, i, j), p.push("/z_" + y);
              }
            }
          }
        this.cacheKey = p.sort().join("");
      };
      Wt.prototype.getMaxValue = function(r) {
        var i = this.binders[r];
        return i instanceof Kt || i instanceof Xt ? i.maxValue : 0;
      }, Wt.prototype.populatePaintArrays = function(r, i, l, p, y) {
        for (var v in this.binders) {
          var x = this.binders[v];
          (x instanceof Kt || x instanceof Xt || x instanceof nr) && x.populatePaintArray(r, i, l, p, y);
        }
      }, Wt.prototype.setConstantPatternPositions = function(r, i) {
        for (var l in this.binders) {
          var p = this.binders[l];
          p instanceof or && p.setConstantPatternPositions(r, i);
        }
      }, Wt.prototype.updatePaintArrays = function(r, i, l, p, y) {
        var v = !1;
        for (var x in r)
          for (var S = 0, C = i.getPositions(x); S < C.length; S += 1) {
            var P = C[S], L = l.feature(P.index);
            for (var D in this.binders) {
              var B = this.binders[D];
              if ((B instanceof Kt || B instanceof Xt || B instanceof nr) && B.expression.isStateDependent === !0) {
                var j = p.paint.get(D);
                B.expression = j.value, B.updatePaintArray(P.start, P.end, L, r[x], y), v = !0;
              }
            }
          }
        return v;
      }, Wt.prototype.defines = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          (l instanceof Yt || l instanceof or) && r.push.apply(r, l.uniformNames.map(function(p) {
            return "#define HAS_UNIFORM_" + p;
          }));
        }
        return r;
      }, Wt.prototype.getBinderAttributes = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          if (l instanceof Kt || l instanceof Xt)
            for (var p = 0; p < l.paintVertexAttributes.length; p++)
              r.push(l.paintVertexAttributes[p].name);
          else if (l instanceof nr)
            for (var y = 0; y < ne.members.length; y++)
              r.push(ne.members[y].name);
        }
        return r;
      }, Wt.prototype.getBinderUniforms = function() {
        var r = [];
        for (var i in this.binders) {
          var l = this.binders[i];
          if (l instanceof Yt || l instanceof or || l instanceof Xt)
            for (var p = 0, y = l.uniformNames; p < y.length; p += 1)
              r.push(y[p]);
        }
        return r;
      }, Wt.prototype.getPaintVertexBuffers = function() {
        return this._buffers;
      }, Wt.prototype.getUniforms = function(r, i) {
        var l = [];
        for (var p in this.binders) {
          var y = this.binders[p];
          if (y instanceof Yt || y instanceof or || y instanceof Xt)
            for (var v = 0, x = y.uniformNames; v < x.length; v += 1) {
              var S = x[v];
              if (i[S]) {
                var C = y.getBinding(r, i[S], S);
                l.push({ name: S, property: p, binding: C });
              }
            }
        }
        return l;
      }, Wt.prototype.setUniforms = function(r, i, l, p) {
        for (var y = 0, v = i; y < v.length; y += 1) {
          var x = v[y], S = x.name, C = x.property;
          this.binders[C].setUniform(x.binding, p, l.get(C), S);
        }
      }, Wt.prototype.updatePaintBuffers = function(r) {
        for (var i in this._buffers = [], this.binders) {
          var l = this.binders[i];
          if (r && l instanceof nr) {
            var p = r.fromScale === 2 ? l.zoomInPaintVertexBuffer : l.zoomOutPaintVertexBuffer;
            p && this._buffers.push(p);
          } else
            (l instanceof Kt || l instanceof Xt) && l.paintVertexBuffer && this._buffers.push(l.paintVertexBuffer);
        }
      }, Wt.prototype.upload = function(r) {
        for (var i in this.binders) {
          var l = this.binders[i];
          (l instanceof Kt || l instanceof Xt || l instanceof nr) && l.upload(r);
        }
        this.updatePaintBuffers();
      }, Wt.prototype.destroy = function() {
        for (var r in this.binders) {
          var i = this.binders[r];
          (i instanceof Kt || i instanceof Xt || i instanceof nr) && i.destroy();
        }
      };
      var Gt = function(r, i, l) {
        l === void 0 && (l = function() {
          return !0;
        }), this.programConfigurations = {};
        for (var p = 0, y = r; p < y.length; p += 1) {
          var v = y[p];
          this.programConfigurations[v.id] = new Wt(v, i, l);
        }
        this.needsUpload = !1, this._featureMap = new me(), this._bufferOffset = 0;
      };
      function li(r, i) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[r] || [r.replace(i + "-", "").replace(/-/g, "_")];
      }
      function On(r, i, l) {
        var p = { color: { source: iu, composite: Ih }, number: { source: Ms, composite: iu } }, y = function(v) {
          return { "line-pattern": { source: Ea, composite: Ea }, "fill-pattern": { source: Ea, composite: Ea }, "fill-extrusion-pattern": { source: Ea, composite: Ea } }[v];
        }(r);
        return y && y[l] || p[i][l];
      }
      Gt.prototype.populatePaintArrays = function(r, i, l, p, y, v) {
        for (var x in this.programConfigurations)
          this.programConfigurations[x].populatePaintArrays(r, i, p, y, v);
        i.id !== void 0 && this._featureMap.add(i.id, l, this._bufferOffset, r), this._bufferOffset = r, this.needsUpload = !0;
      }, Gt.prototype.updatePaintArrays = function(r, i, l, p) {
        for (var y = 0, v = l; y < v.length; y += 1) {
          var x = v[y];
          this.needsUpload = this.programConfigurations[x.id].updatePaintArrays(r, this._featureMap, i, x, p) || this.needsUpload;
        }
      }, Gt.prototype.get = function(r) {
        return this.programConfigurations[r];
      }, Gt.prototype.upload = function(r) {
        if (this.needsUpload) {
          for (var i in this.programConfigurations)
            this.programConfigurations[i].upload(r);
          this.needsUpload = !1;
        }
      }, Gt.prototype.destroy = function() {
        for (var r in this.programConfigurations)
          this.programConfigurations[r].destroy();
      }, wt("ConstantBinder", Yt), wt("CrossFadedConstantBinder", or), wt("SourceExpressionBinder", Kt), wt("CrossFadedCompositeBinder", nr), wt("CompositeExpressionBinder", Xt), wt("ProgramConfiguration", Wt, { omit: ["_buffers"] }), wt("ProgramConfigurationSet", Gt);
      var Li = Math.pow(2, 14) - 1, vi = -Li - 1;
      function Mn(r) {
        for (var i = 8192 / r.extent, l = r.loadGeometry(), p = 0; p < l.length; p++)
          for (var y = l[p], v = 0; v < y.length; v++) {
            var x = y[v], S = Math.round(x.x * i), C = Math.round(x.y * i);
            x.x = q(S, vi, Li), x.y = q(C, vi, Li), (S < x.x || S > x.x + 1 || C < x.y || C > x.y + 1) && at("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        return l;
      }
      function Dn(r, i) {
        return { type: r.type, id: r.id, properties: r.properties, geometry: i ? Mn(r) : [] };
      }
      function mo(r, i, l, p, y) {
        r.emplaceBack(2 * i + (p + 1) / 2, 2 * l + (y + 1) / 2);
      }
      var $i = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.layoutVertexArray = new bl(), this.indexArray = new Ss(), this.segments = new W(), this.programConfigurations = new Gt(r.layers, r.zoom), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      function Is(r, i) {
        for (var l = 0; l < r.length; l++)
          if (Sa(i, r[l]))
            return !0;
        for (var p = 0; p < i.length; p++)
          if (Sa(r, i[p]))
            return !0;
        return !!dc(r, i);
      }
      function Qi(r, i, l) {
        return !!Sa(r, i) || !!Os(i, r, l);
      }
      function ca(r, i) {
        if (r.length === 1)
          return mc(i, r[0]);
        for (var l = 0; l < i.length; l++)
          for (var p = i[l], y = 0; y < p.length; y++)
            if (Sa(r, p[y]))
              return !0;
        for (var v = 0; v < r.length; v++)
          if (mc(i, r[v]))
            return !0;
        for (var x = 0; x < i.length; x++)
          if (dc(r, i[x]))
            return !0;
        return !1;
      }
      function Zo(r, i, l) {
        if (r.length > 1) {
          if (dc(r, i))
            return !0;
          for (var p = 0; p < i.length; p++)
            if (Os(i[p], r, l))
              return !0;
        }
        for (var y = 0; y < r.length; y++)
          if (Os(r[y], i, l))
            return !0;
        return !1;
      }
      function dc(r, i) {
        if (r.length === 0 || i.length === 0)
          return !1;
        for (var l = 0; l < r.length - 1; l++)
          for (var p = r[l], y = r[l + 1], v = 0; v < i.length - 1; v++)
            if (su(p, y, i[v], i[v + 1]))
              return !0;
        return !1;
      }
      function su(r, i, l, p) {
        return be(r, l, p) !== be(i, l, p) && be(r, i, l) !== be(r, i, p);
      }
      function Os(r, i, l) {
        var p = l * l;
        if (i.length === 1)
          return r.distSqr(i[0]) < p;
        for (var y = 1; y < i.length; y++)
          if (lu(r, i[y - 1], i[y]) < p)
            return !0;
        return !1;
      }
      function lu(r, i, l) {
        var p = i.distSqr(l);
        if (p === 0)
          return r.distSqr(i);
        var y = ((r.x - i.x) * (l.x - i.x) + (r.y - i.y) * (l.y - i.y)) / p;
        return r.distSqr(y < 0 ? i : y > 1 ? l : l.sub(i)._mult(y)._add(i));
      }
      function mc(r, i) {
        for (var l, p, y, v = !1, x = 0; x < r.length; x++)
          for (var S = 0, C = (l = r[x]).length - 1; S < l.length; C = S++)
            (p = l[S]).y > i.y != (y = l[C]).y > i.y && i.x < (y.x - p.x) * (i.y - p.y) / (y.y - p.y) + p.x && (v = !v);
        return v;
      }
      function Sa(r, i) {
        for (var l = !1, p = 0, y = r.length - 1; p < r.length; y = p++) {
          var v = r[p], x = r[y];
          v.y > i.y != x.y > i.y && i.x < (x.x - v.x) * (i.y - v.y) / (x.y - v.y) + v.x && (l = !l);
        }
        return l;
      }
      function yc(r, i, l) {
        var p = l[0], y = l[2];
        if (r.x < p.x && i.x < p.x || r.x > y.x && i.x > y.x || r.y < p.y && i.y < p.y || r.y > y.y && i.y > y.y)
          return !1;
        var v = be(r, i, l[0]);
        return v !== be(r, i, l[1]) || v !== be(r, i, l[2]) || v !== be(r, i, l[3]);
      }
      function Ta(r, i, l) {
        var p = i.paint.get(r).value;
        return p.kind === "constant" ? p.value : l.programConfigurations.get(i.id).getMaxValue(r);
      }
      function ui(r) {
        return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
      }
      function $a(r, i, l, p, y) {
        if (!i[0] && !i[1])
          return r;
        var v = T.convert(i)._mult(y);
        l === "viewport" && v._rotate(-p);
        for (var x = [], S = 0; S < r.length; S++)
          x.push(r[S].sub(v));
        return x;
      }
      $i.prototype.populate = function(r, i, l) {
        var p = this.layers[0], y = [], v = null;
        p.type === "circle" && (v = p.layout.get("circle-sort-key"));
        for (var x = 0, S = r; x < S.length; x += 1) {
          var C = S[x], P = C.feature, L = C.id, D = C.index, B = C.sourceLayerIndex, j = this.layers[0]._featureFilter.needGeometry, J = Dn(P, j);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), J, l)) {
            var ee = v ? v.evaluate(J, {}, l) : void 0, he = { id: L, properties: P.properties, type: P.type, sourceLayerIndex: B, index: D, geometry: j ? J.geometry : Mn(P), patterns: {}, sortKey: ee };
            y.push(he);
          }
        }
        v && y.sort(function(ot, Pt) {
          return ot.sortKey - Pt.sortKey;
        });
        for (var oe = 0, ge = y; oe < ge.length; oe += 1) {
          var we = ge[oe], Te = we.geometry, Oe = we.index, Ve = we.sourceLayerIndex, Ke = r[Oe].feature;
          this.addFeature(we, Te, Oe, l), i.featureIndex.insert(Ke, Te, Oe, Ve, this.index);
        }
      }, $i.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, $i.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, $i.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, $i.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, $), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, $i.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, $i.prototype.addFeature = function(r, i, l, p) {
        for (var y = 0, v = i; y < v.length; y += 1)
          for (var x = 0, S = v[y]; x < S.length; x += 1) {
            var C = S[x], P = C.x, L = C.y;
            if (!(P < 0 || P >= 8192 || L < 0 || L >= 8192)) {
              var D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, r.sortKey), B = D.vertexLength;
              mo(this.layoutVertexArray, P, L, -1, -1), mo(this.layoutVertexArray, P, L, 1, -1), mo(this.layoutVertexArray, P, L, 1, 1), mo(this.layoutVertexArray, P, L, -1, 1), this.indexArray.emplaceBack(B, B + 1, B + 2), this.indexArray.emplaceBack(B, B + 3, B + 2), D.vertexLength += 4, D.primitiveLength += 2;
            }
          }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, {}, p);
      }, wt("CircleBucket", $i, { omit: ["layers"] });
      var Cs = new Ii({ "circle-sort-key": new Tt(G.layout_circle["circle-sort-key"]) }), El = { paint: new Ii({ "circle-radius": new Tt(G.paint_circle["circle-radius"]), "circle-color": new Tt(G.paint_circle["circle-color"]), "circle-blur": new Tt(G.paint_circle["circle-blur"]), "circle-opacity": new Tt(G.paint_circle["circle-opacity"]), "circle-translate": new Dt(G.paint_circle["circle-translate"]), "circle-translate-anchor": new Dt(G.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Dt(G.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Dt(G.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Tt(G.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Tt(G.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Tt(G.paint_circle["circle-stroke-opacity"]) }), layout: Cs }, Fr = typeof Float32Array < "u" ? Float32Array : Array;
      function Oo(r) {
        return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
      }
      function eo(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3], S = i[4], C = i[5], P = i[6], L = i[7], D = i[8], B = i[9], j = i[10], J = i[11], ee = i[12], he = i[13], oe = i[14], ge = i[15], we = l[0], Te = l[1], Oe = l[2], Ve = l[3];
        return r[0] = we * p + Te * S + Oe * D + Ve * ee, r[1] = we * y + Te * C + Oe * B + Ve * he, r[2] = we * v + Te * P + Oe * j + Ve * oe, r[3] = we * x + Te * L + Oe * J + Ve * ge, r[4] = (we = l[4]) * p + (Te = l[5]) * S + (Oe = l[6]) * D + (Ve = l[7]) * ee, r[5] = we * y + Te * C + Oe * B + Ve * he, r[6] = we * v + Te * P + Oe * j + Ve * oe, r[7] = we * x + Te * L + Oe * J + Ve * ge, r[8] = (we = l[8]) * p + (Te = l[9]) * S + (Oe = l[10]) * D + (Ve = l[11]) * ee, r[9] = we * y + Te * C + Oe * B + Ve * he, r[10] = we * v + Te * P + Oe * j + Ve * oe, r[11] = we * x + Te * L + Oe * J + Ve * ge, r[12] = (we = l[12]) * p + (Te = l[13]) * S + (Oe = l[14]) * D + (Ve = l[15]) * ee, r[13] = we * y + Te * C + Oe * B + Ve * he, r[14] = we * v + Te * P + Oe * j + Ve * oe, r[15] = we * x + Te * L + Oe * J + Ve * ge, r;
      }
      Math.hypot || (Math.hypot = function() {
        for (var r = arguments, i = 0, l = arguments.length; l--; )
          i += r[l] * r[l];
        return Math.sqrt(i);
      });
      var Sl, Qv = eo;
      function Oh(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3];
        return r[0] = l[0] * p + l[4] * y + l[8] * v + l[12] * x, r[1] = l[1] * p + l[5] * y + l[9] * v + l[13] * x, r[2] = l[2] * p + l[6] * y + l[10] * v + l[14] * x, r[3] = l[3] * p + l[7] * y + l[11] * v + l[15] * x, r;
      }
      Sl = new Fr(3), Fr != Float32Array && (Sl[0] = 0, Sl[1] = 0, Sl[2] = 0), function() {
        var r = new Fr(4);
        Fr != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0);
      }();
      var e_ = (function() {
        var r = new Fr(2);
        Fr != Float32Array && (r[0] = 0, r[1] = 0);
      }(), function(r) {
        function i(l) {
          r.call(this, l, El);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new $i(l);
        }, i.prototype.queryRadius = function(l) {
          var p = l;
          return Ta("circle-radius", this, p) + Ta("circle-stroke-width", this, p) + ui(this.paint.get("circle-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C, P) {
          for (var L = $a(l, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), S.angle, C), D = this.paint.get("circle-radius").evaluate(p, y) + this.paint.get("circle-stroke-width").evaluate(p, y), B = this.paint.get("circle-pitch-alignment") === "map", j = B ? L : function(Ke, ot) {
            return Ke.map(function(Pt) {
              return gc(Pt, ot);
            });
          }(L, P), J = B ? D * C : D, ee = 0, he = v; ee < he.length; ee += 1)
            for (var oe = 0, ge = he[ee]; oe < ge.length; oe += 1) {
              var we = ge[oe], Te = B ? we : gc(we, P), Oe = J, Ve = Oh([], [we.x, we.y, 0, 1], P);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Oe *= Ve[3] / S.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Oe *= S.cameraToCenterDistance / Ve[3]), Qi(j, Te, Oe))
                return !0;
            }
          return !1;
        }, i;
      }(wa));
      function gc(r, i) {
        var l = Oh([], [r.x, r.y, 0, 1], i);
        return new T(l[0] / l[3], l[1] / l[3]);
      }
      var Fm = function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }($i);
      function uu(r, i, l, p) {
        var y = i.width, v = i.height;
        if (p) {
          if (p instanceof Uint8ClampedArray)
            p = new Uint8Array(p.buffer);
          else if (p.length !== y * v * l)
            throw new RangeError("mismatched image size");
        } else
          p = new Uint8Array(y * v * l);
        return r.width = y, r.height = v, r.data = p, r;
      }
      function Ch(r, i, l) {
        var p = i.width, y = i.height;
        if (p !== r.width || y !== r.height) {
          var v = uu({}, { width: p, height: y }, l);
          t_(r, v, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r.width, p), height: Math.min(r.height, y) }, l), r.width = p, r.height = y, r.data = v.data;
        }
      }
      function t_(r, i, l, p, y, v) {
        if (y.width === 0 || y.height === 0)
          return i;
        if (y.width > r.width || y.height > r.height || l.x > r.width - y.width || l.y > r.height - y.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (y.width > i.width || y.height > i.height || p.x > i.width - y.width || p.y > i.height - y.height)
          throw new RangeError("out of range destination coordinates for image copy");
        for (var x = r.data, S = i.data, C = 0; C < y.height; C++)
          for (var P = ((l.y + C) * r.width + l.x) * v, L = ((p.y + C) * i.width + p.x) * v, D = 0; D < y.width * v; D++)
            S[L + D] = x[P + D];
        return i;
      }
      wt("HeatmapBucket", Fm, { omit: ["layers"] });
      var vc = function(r, i) {
        uu(this, r, 1, i);
      };
      vc.prototype.resize = function(r) {
        Ch(this, r, 1);
      }, vc.prototype.clone = function() {
        return new vc({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }, vc.copy = function(r, i, l, p, y) {
        t_(r, i, l, p, y, 1);
      };
      var yo = function(r, i) {
        uu(this, r, 4, i);
      };
      yo.prototype.resize = function(r) {
        Ch(this, r, 4);
      }, yo.prototype.replace = function(r, i) {
        i ? this.data.set(r) : this.data = r instanceof Uint8ClampedArray ? new Uint8Array(r.buffer) : r;
      }, yo.prototype.clone = function() {
        return new yo({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }, yo.copy = function(r, i, l, p, y) {
        t_(r, i, l, p, y, 4);
      }, wt("AlphaImage", vc), wt("RGBAImage", yo);
      var GI = { paint: new Ii({ "heatmap-radius": new Tt(G.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Tt(G.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Dt(G.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ua(G.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Dt(G.paint_heatmap["heatmap-opacity"]) }) };
      function d1(r) {
        var i = {}, l = r.resolution || 256, p = r.clips ? r.clips.length : 1, y = r.image || new yo({ width: l, height: p }), v = function(J, ee, he) {
          i[r.evaluationKey] = he;
          var oe = r.expression.evaluate(i);
          y.data[J + ee + 0] = Math.floor(255 * oe.r / oe.a), y.data[J + ee + 1] = Math.floor(255 * oe.g / oe.a), y.data[J + ee + 2] = Math.floor(255 * oe.b / oe.a), y.data[J + ee + 3] = Math.floor(255 * oe.a);
        };
        if (r.clips)
          for (var x = 0, S = 0; x < p; ++x, S += 4 * l)
            for (var C = 0, P = 0; C < l; C++, P += 4) {
              var L = C / (l - 1), D = r.clips[x];
              v(S, P, D.start * (1 - L) + D.end * L);
            }
        else
          for (var B = 0, j = 0; B < l; B++, j += 4)
            v(0, j, B / (l - 1));
        return y;
      }
      var $I = function(r) {
        function i(l) {
          r.call(this, l, GI), this._updateColorRamp();
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new Fm(l);
        }, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
          l === "heatmap-color" && this._updateColorRamp();
        }, i.prototype._updateColorRamp = function() {
          this.colorRamp = d1({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }, i.prototype.resize = function() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }, i.prototype.queryRadius = function() {
          return 0;
        }, i.prototype.queryIntersectsFeature = function() {
          return !1;
        }, i.prototype.hasOffscreenPass = function() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }, i;
      }(wa), qI = { paint: new Ii({ "hillshade-illumination-direction": new Dt(G.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Dt(G.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Dt(G.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Dt(G.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Dt(G.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Dt(G.paint_hillshade["hillshade-accent-color"]) }) }, WI = function(r) {
        function i(l) {
          r.call(this, l, qI);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.hasOffscreenPass = function() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }, i;
      }(wa), HI = gi([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, r_ = Bm, ZI = Bm;
      function Bm(r, i, l) {
        l = l || 2;
        var p, y, v, x, S, C, P, L = i && i.length, D = L ? i[0] * l : r.length, B = m1(r, 0, D, l, !0), j = [];
        if (!B || B.next === B.prev)
          return j;
        if (L && (B = function(ee, he, oe, ge) {
          var we, Te, Oe, Ve = [];
          for (we = 0, Te = he.length; we < Te; we++)
            (Oe = m1(ee, he[we] * ge, we < Te - 1 ? he[we + 1] * ge : ee.length, ge, !1)) === Oe.next && (Oe.steiner = !0), Ve.push(rO(Oe));
          for (Ve.sort(QI), we = 0; we < Ve.length; we++)
            eO(Ve[we], oe), oe = cu(oe, oe.next);
          return oe;
        }(r, i, B, l)), r.length > 80 * l) {
          p = v = r[0], y = x = r[1];
          for (var J = l; J < D; J += l)
            (S = r[J]) < p && (p = S), (C = r[J + 1]) < y && (y = C), S > v && (v = S), C > x && (x = C);
          P = (P = Math.max(v - p, x - y)) !== 0 ? 1 / P : 0;
        }
        return gp(B, j, l, p, y, P), j;
      }
      function m1(r, i, l, p, y) {
        var v, x;
        if (y === o_(r, i, l, p) > 0)
          for (v = i; v < l; v += p)
            x = v1(v, r[v], r[v + 1], x);
        else
          for (v = l - p; v >= i; v -= p)
            x = v1(v, r[v], r[v + 1], x);
        return x && Vm(x, x.next) && (_p(x), x = x.next), x;
      }
      function cu(r, i) {
        if (!r)
          return r;
        i || (i = r);
        var l, p = r;
        do
          if (l = !1, p.steiner || !Vm(p, p.next) && Qn(p.prev, p, p.next) !== 0)
            p = p.next;
          else {
            if (_p(p), (p = i = p.prev) === p.next)
              break;
            l = !0;
          }
        while (l || p !== i);
        return i;
      }
      function gp(r, i, l, p, y, v, x) {
        if (r) {
          !x && v && function(L, D, B, j) {
            var J = L;
            do
              J.z === null && (J.z = n_(J.x, J.y, D, B, j)), J.prevZ = J.prev, J.nextZ = J.next, J = J.next;
            while (J !== L);
            J.prevZ.nextZ = null, J.prevZ = null, function(ee) {
              var he, oe, ge, we, Te, Oe, Ve, Ke, ot = 1;
              do {
                for (oe = ee, ee = null, Te = null, Oe = 0; oe; ) {
                  for (Oe++, ge = oe, Ve = 0, he = 0; he < ot && (Ve++, ge = ge.nextZ); he++)
                    ;
                  for (Ke = ot; Ve > 0 || Ke > 0 && ge; )
                    Ve !== 0 && (Ke === 0 || !ge || oe.z <= ge.z) ? (we = oe, oe = oe.nextZ, Ve--) : (we = ge, ge = ge.nextZ, Ke--), Te ? Te.nextZ = we : ee = we, we.prevZ = Te, Te = we;
                  oe = ge;
                }
                Te.nextZ = null, ot *= 2;
              } while (Oe > 1);
            }(J);
          }(r, p, y, v);
          for (var S, C, P = r; r.prev !== r.next; )
            if (S = r.prev, C = r.next, v ? KI(r, p, y, v) : XI(r))
              i.push(S.i / l), i.push(r.i / l), i.push(C.i / l), _p(r), r = C.next, P = C.next;
            else if ((r = C) === P) {
              x ? x === 1 ? gp(r = YI(cu(r), i, l), i, l, p, y, v, 2) : x === 2 && JI(r, i, l, p, y, v) : gp(cu(r), i, l, p, y, v, 1);
              break;
            }
        }
      }
      function XI(r) {
        var i = r.prev, l = r, p = r.next;
        if (Qn(i, l, p) >= 0)
          return !1;
        for (var y = r.next.next; y !== r.prev; ) {
          if (Ph(i.x, i.y, l.x, l.y, p.x, p.y, y.x, y.y) && Qn(y.prev, y, y.next) >= 0)
            return !1;
          y = y.next;
        }
        return !0;
      }
      function KI(r, i, l, p) {
        var y = r.prev, v = r, x = r.next;
        if (Qn(y, v, x) >= 0)
          return !1;
        for (var S = y.x > v.x ? y.x > x.x ? y.x : x.x : v.x > x.x ? v.x : x.x, C = y.y > v.y ? y.y > x.y ? y.y : x.y : v.y > x.y ? v.y : x.y, P = n_(y.x < v.x ? y.x < x.x ? y.x : x.x : v.x < x.x ? v.x : x.x, y.y < v.y ? y.y < x.y ? y.y : x.y : v.y < x.y ? v.y : x.y, i, l, p), L = n_(S, C, i, l, p), D = r.prevZ, B = r.nextZ; D && D.z >= P && B && B.z <= L; ) {
          if (D !== r.prev && D !== r.next && Ph(y.x, y.y, v.x, v.y, x.x, x.y, D.x, D.y) && Qn(D.prev, D, D.next) >= 0 || (D = D.prevZ, B !== r.prev && B !== r.next && Ph(y.x, y.y, v.x, v.y, x.x, x.y, B.x, B.y) && Qn(B.prev, B, B.next) >= 0))
            return !1;
          B = B.nextZ;
        }
        for (; D && D.z >= P; ) {
          if (D !== r.prev && D !== r.next && Ph(y.x, y.y, v.x, v.y, x.x, x.y, D.x, D.y) && Qn(D.prev, D, D.next) >= 0)
            return !1;
          D = D.prevZ;
        }
        for (; B && B.z <= L; ) {
          if (B !== r.prev && B !== r.next && Ph(y.x, y.y, v.x, v.y, x.x, x.y, B.x, B.y) && Qn(B.prev, B, B.next) >= 0)
            return !1;
          B = B.nextZ;
        }
        return !0;
      }
      function YI(r, i, l) {
        var p = r;
        do {
          var y = p.prev, v = p.next.next;
          !Vm(y, v) && y1(y, p, p.next, v) && vp(y, v) && vp(v, y) && (i.push(y.i / l), i.push(p.i / l), i.push(v.i / l), _p(p), _p(p.next), p = r = v), p = p.next;
        } while (p !== r);
        return cu(p);
      }
      function JI(r, i, l, p, y, v) {
        var x = r;
        do {
          for (var S = x.next.next; S !== x.prev; ) {
            if (x.i !== S.i && nO(x, S)) {
              var C = g1(x, S);
              return x = cu(x, x.next), C = cu(C, C.next), gp(x, i, l, p, y, v), void gp(C, i, l, p, y, v);
            }
            S = S.next;
          }
          x = x.next;
        } while (x !== r);
      }
      function QI(r, i) {
        return r.x - i.x;
      }
      function eO(r, i) {
        if (i = function(p, y) {
          var v, x = y, S = p.x, C = p.y, P = -1 / 0;
          do {
            if (C <= x.y && C >= x.next.y && x.next.y !== x.y) {
              var L = x.x + (C - x.y) * (x.next.x - x.x) / (x.next.y - x.y);
              if (L <= S && L > P) {
                if (P = L, L === S) {
                  if (C === x.y)
                    return x;
                  if (C === x.next.y)
                    return x.next;
                }
                v = x.x < x.next.x ? x : x.next;
              }
            }
            x = x.next;
          } while (x !== y);
          if (!v)
            return null;
          if (S === P)
            return v;
          var D, B = v, j = v.x, J = v.y, ee = 1 / 0;
          x = v;
          do
            S >= x.x && x.x >= j && S !== x.x && Ph(C < J ? S : P, C, j, J, C < J ? P : S, C, x.x, x.y) && (D = Math.abs(C - x.y) / (S - x.x), vp(x, p) && (D < ee || D === ee && (x.x > v.x || x.x === v.x && tO(v, x))) && (v = x, ee = D)), x = x.next;
          while (x !== B);
          return v;
        }(r, i)) {
          var l = g1(i, r);
          cu(i, i.next), cu(l, l.next);
        }
      }
      function tO(r, i) {
        return Qn(r.prev, r, i.prev) < 0 && Qn(i.next, r, r.next) < 0;
      }
      function n_(r, i, l, p, y) {
        return (r = 1431655765 & ((r = 858993459 & ((r = 252645135 & ((r = 16711935 & ((r = 32767 * (r - l) * y) | r << 8)) | r << 4)) | r << 2)) | r << 1)) | (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = 32767 * (i - p) * y) | i << 8)) | i << 4)) | i << 2)) | i << 1)) << 1;
      }
      function rO(r) {
        var i = r, l = r;
        do
          (i.x < l.x || i.x === l.x && i.y < l.y) && (l = i), i = i.next;
        while (i !== r);
        return l;
      }
      function Ph(r, i, l, p, y, v, x, S) {
        return (y - x) * (i - S) - (r - x) * (v - S) >= 0 && (r - x) * (p - S) - (l - x) * (i - S) >= 0 && (l - x) * (v - S) - (y - x) * (p - S) >= 0;
      }
      function nO(r, i) {
        return r.next.i !== i.i && r.prev.i !== i.i && !function(l, p) {
          var y = l;
          do {
            if (y.i !== l.i && y.next.i !== l.i && y.i !== p.i && y.next.i !== p.i && y1(y, y.next, l, p))
              return !0;
            y = y.next;
          } while (y !== l);
          return !1;
        }(r, i) && (vp(r, i) && vp(i, r) && function(l, p) {
          var y = l, v = !1, x = (l.x + p.x) / 2, S = (l.y + p.y) / 2;
          do
            y.y > S != y.next.y > S && y.next.y !== y.y && x < (y.next.x - y.x) * (S - y.y) / (y.next.y - y.y) + y.x && (v = !v), y = y.next;
          while (y !== l);
          return v;
        }(r, i) && (Qn(r.prev, r, i.prev) || Qn(r, i.prev, i)) || Vm(r, i) && Qn(r.prev, r, r.next) > 0 && Qn(i.prev, i, i.next) > 0);
      }
      function Qn(r, i, l) {
        return (i.y - r.y) * (l.x - i.x) - (i.x - r.x) * (l.y - i.y);
      }
      function Vm(r, i) {
        return r.x === i.x && r.y === i.y;
      }
      function y1(r, i, l, p) {
        var y = jm(Qn(r, i, l)), v = jm(Qn(r, i, p)), x = jm(Qn(l, p, r)), S = jm(Qn(l, p, i));
        return y !== v && x !== S || !(y !== 0 || !Um(r, l, i)) || !(v !== 0 || !Um(r, p, i)) || !(x !== 0 || !Um(l, r, p)) || !(S !== 0 || !Um(l, i, p));
      }
      function Um(r, i, l) {
        return i.x <= Math.max(r.x, l.x) && i.x >= Math.min(r.x, l.x) && i.y <= Math.max(r.y, l.y) && i.y >= Math.min(r.y, l.y);
      }
      function jm(r) {
        return r > 0 ? 1 : r < 0 ? -1 : 0;
      }
      function vp(r, i) {
        return Qn(r.prev, r, r.next) < 0 ? Qn(r, i, r.next) >= 0 && Qn(r, r.prev, i) >= 0 : Qn(r, i, r.prev) < 0 || Qn(r, r.next, i) < 0;
      }
      function g1(r, i) {
        var l = new i_(r.i, r.x, r.y), p = new i_(i.i, i.x, i.y), y = r.next, v = i.prev;
        return r.next = i, i.prev = r, l.next = y, y.prev = l, p.next = l, l.prev = p, v.next = p, p.prev = v, p;
      }
      function v1(r, i, l, p) {
        var y = new i_(r, i, l);
        return p ? (y.next = p.next, y.prev = p, p.next.prev = y, p.next = y) : (y.prev = y, y.next = y), y;
      }
      function _p(r) {
        r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
      }
      function i_(r, i, l) {
        this.i = r, this.x = i, this.y = l, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
      }
      function o_(r, i, l, p) {
        for (var y = 0, v = i, x = l - p; v < l; v += p)
          y += (r[x] - r[v]) * (r[v + 1] + r[x + 1]), x = v;
        return y;
      }
      function iO(r, i, l, p, y) {
        (function v(x, S, C, P, L) {
          for (; P > C; ) {
            if (P - C > 600) {
              var D = P - C + 1, B = S - C + 1, j = Math.log(D), J = 0.5 * Math.exp(2 * j / 3), ee = 0.5 * Math.sqrt(j * J * (D - J) / D) * (B - D / 2 < 0 ? -1 : 1);
              v(x, S, Math.max(C, Math.floor(S - B * J / D + ee)), Math.min(P, Math.floor(S + (D - B) * J / D + ee)), L);
            }
            var he = x[S], oe = C, ge = P;
            for (xp(x, C, S), L(x[P], he) > 0 && xp(x, C, P); oe < ge; ) {
              for (xp(x, oe, ge), oe++, ge--; L(x[oe], he) < 0; )
                oe++;
              for (; L(x[ge], he) > 0; )
                ge--;
            }
            L(x[C], he) === 0 ? xp(x, C, ge) : xp(x, ++ge, P), ge <= S && (C = ge + 1), S <= ge && (P = ge - 1);
          }
        })(r, i, l || 0, p || r.length - 1, y || oO);
      }
      function xp(r, i, l) {
        var p = r[i];
        r[i] = r[l], r[l] = p;
      }
      function oO(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function a_(r, i) {
        var l = r.length;
        if (l <= 1)
          return [r];
        for (var p, y, v = [], x = 0; x < l; x++) {
          var S = Je(r[x]);
          S !== 0 && (r[x].area = Math.abs(S), y === void 0 && (y = S < 0), y === S < 0 ? (p && v.push(p), p = [r[x]]) : p.push(r[x]));
        }
        if (p && v.push(p), i > 1)
          for (var C = 0; C < v.length; C++)
            v[C].length <= i || (iO(v[C], i, 1, v[C].length - 1, aO), v[C] = v[C].slice(0, i));
        return v;
      }
      function aO(r, i) {
        return i.area - r.area;
      }
      function s_(r, i, l) {
        for (var p = l.patternDependencies, y = !1, v = 0, x = i; v < x.length; v += 1) {
          var S = x[v].paint.get(r + "-pattern");
          S.isConstant() || (y = !0);
          var C = S.constantOr(null);
          C && (y = !0, p[C.to] = !0, p[C.from] = !0);
        }
        return y;
      }
      function l_(r, i, l, p, y) {
        for (var v = y.patternDependencies, x = 0, S = i; x < S.length; x += 1) {
          var C = S[x], P = C.paint.get(r + "-pattern").value;
          if (P.kind !== "constant") {
            var L = P.evaluate({ zoom: p - 1 }, l, {}, y.availableImages), D = P.evaluate({ zoom: p }, l, {}, y.availableImages), B = P.evaluate({ zoom: p + 1 }, l, {}, y.availableImages);
            D = D && D.name ? D.name : D, B = B && B.name ? B.name : B, v[L = L && L.name ? L.name : L] = !0, v[D] = !0, v[B] = !0, l.patterns[C.id] = { min: L, mid: D, max: B };
          }
        }
        return l;
      }
      Bm.deviation = function(r, i, l, p) {
        var y = i && i.length, v = Math.abs(o_(r, 0, y ? i[0] * l : r.length, l));
        if (y)
          for (var x = 0, S = i.length; x < S; x++)
            v -= Math.abs(o_(r, i[x] * l, x < S - 1 ? i[x + 1] * l : r.length, l));
        var C = 0;
        for (x = 0; x < p.length; x += 3) {
          var P = p[x] * l, L = p[x + 1] * l, D = p[x + 2] * l;
          C += Math.abs((r[P] - r[D]) * (r[L + 1] - r[P + 1]) - (r[P] - r[L]) * (r[D + 1] - r[P + 1]));
        }
        return v === 0 && C === 0 ? 0 : Math.abs((C - v) / v);
      }, Bm.flatten = function(r) {
        for (var i = r[0][0].length, l = { vertices: [], holes: [], dimensions: i }, p = 0, y = 0; y < r.length; y++) {
          for (var v = 0; v < r[y].length; v++)
            for (var x = 0; x < i; x++)
              l.vertices.push(r[y][v][x]);
          y > 0 && l.holes.push(p += r[y - 1].length);
        }
        return l;
      }, r_.default = ZI;
      var qa = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new bl(), this.indexArray = new Ss(), this.indexArray2 = new pc(), this.programConfigurations = new Gt(r.layers, r.zoom), this.segments = new W(), this.segments2 = new W(), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      qa.prototype.populate = function(r, i, l) {
        this.hasPattern = s_("fill", this.layers, i);
        for (var p = this.layers[0].layout.get("fill-sort-key"), y = [], v = 0, x = r; v < x.length; v += 1) {
          var S = x[v], C = S.feature, P = S.id, L = S.index, D = S.sourceLayerIndex, B = this.layers[0]._featureFilter.needGeometry, j = Dn(C, B);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), j, l)) {
            var J = p ? p.evaluate(j, {}, l, i.availableImages) : void 0, ee = { id: P, properties: C.properties, type: C.type, sourceLayerIndex: D, index: L, geometry: B ? j.geometry : Mn(C), patterns: {}, sortKey: J };
            y.push(ee);
          }
        }
        p && y.sort(function(Ke, ot) {
          return Ke.sortKey - ot.sortKey;
        });
        for (var he = 0, oe = y; he < oe.length; he += 1) {
          var ge = oe[he], we = ge.geometry, Te = ge.index, Oe = ge.sourceLayerIndex;
          if (this.hasPattern) {
            var Ve = l_("fill", this.layers, ge, this.zoom, i);
            this.patternFeatures.push(Ve);
          } else
            this.addFeature(ge, we, Te, l, {});
          i.featureIndex.insert(r[Te].feature, we, Te, Oe, this.index);
        }
      }, qa.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, qa.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.patternFeatures; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, qa.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, qa.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, qa.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, HI), this.indexBuffer = r.createIndexBuffer(this.indexArray), this.indexBuffer2 = r.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, qa.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
      }, qa.prototype.addFeature = function(r, i, l, p, y) {
        for (var v = 0, x = a_(i, 500); v < x.length; v += 1) {
          for (var S = x[v], C = 0, P = 0, L = S; P < L.length; P += 1)
            C += L[P].length;
          for (var D = this.segments.prepareSegment(C, this.layoutVertexArray, this.indexArray), B = D.vertexLength, j = [], J = [], ee = 0, he = S; ee < he.length; ee += 1) {
            var oe = he[ee];
            if (oe.length !== 0) {
              oe !== S[0] && J.push(j.length / 2);
              var ge = this.segments2.prepareSegment(oe.length, this.layoutVertexArray, this.indexArray2), we = ge.vertexLength;
              this.layoutVertexArray.emplaceBack(oe[0].x, oe[0].y), this.indexArray2.emplaceBack(we + oe.length - 1, we), j.push(oe[0].x), j.push(oe[0].y);
              for (var Te = 1; Te < oe.length; Te++)
                this.layoutVertexArray.emplaceBack(oe[Te].x, oe[Te].y), this.indexArray2.emplaceBack(we + Te - 1, we + Te), j.push(oe[Te].x), j.push(oe[Te].y);
              ge.vertexLength += oe.length, ge.primitiveLength += oe.length;
            }
          }
          for (var Oe = r_(j, J), Ve = 0; Ve < Oe.length; Ve += 3)
            this.indexArray.emplaceBack(B + Oe[Ve], B + Oe[Ve + 1], B + Oe[Ve + 2]);
          D.vertexLength += C, D.primitiveLength += Oe.length / 3;
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, wt("FillBucket", qa, { omit: ["layers", "patternFeatures"] });
      var sO = new Ii({ "fill-sort-key": new Tt(G.layout_fill["fill-sort-key"]) }), lO = { paint: new Ii({ "fill-antialias": new Dt(G.paint_fill["fill-antialias"]), "fill-opacity": new Tt(G.paint_fill["fill-opacity"]), "fill-color": new Tt(G.paint_fill["fill-color"]), "fill-outline-color": new Tt(G.paint_fill["fill-outline-color"]), "fill-translate": new Dt(G.paint_fill["fill-translate"]), "fill-translate-anchor": new Dt(G.paint_fill["fill-translate-anchor"]), "fill-pattern": new Eh(G.paint_fill["fill-pattern"]) }), layout: sO }, uO = function(r) {
        function i(l) {
          r.call(this, l, lO);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.recalculate = function(l, p) {
          r.prototype.recalculate.call(this, l, p);
          var y = this.paint._values["fill-outline-color"];
          y.value.kind === "constant" && y.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }, i.prototype.createBucket = function(l) {
          return new qa(l);
        }, i.prototype.queryRadius = function() {
          return ui(this.paint.get("fill-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C) {
          return ca($a(l, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), S.angle, C), v);
        }, i.prototype.isTileClipped = function() {
          return !0;
        }, i;
      }(wa), cO = gi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4).members, _1 = Ah;
      function Ah(r, i, l, p, y) {
        this.properties = {}, this.extent = l, this.type = 0, this._pbf = r, this._geometry = -1, this._keys = p, this._values = y, r.readFields(hO, this, i);
      }
      function hO(r, i, l) {
        r == 1 ? i.id = l.readVarint() : r == 2 ? function(p, y) {
          for (var v = p.readVarint() + p.pos; p.pos < v; ) {
            var x = y._keys[p.readVarint()], S = y._values[p.readVarint()];
            y.properties[x] = S;
          }
        }(l, i) : r == 3 ? i.type = l.readVarint() : r == 4 && (i._geometry = l.pos);
      }
      function fO(r) {
        for (var i, l, p = 0, y = 0, v = r.length, x = v - 1; y < v; x = y++)
          p += ((l = r[x]).x - (i = r[y]).x) * (i.y + l.y);
        return p;
      }
      Ah.types = ["Unknown", "Point", "LineString", "Polygon"], Ah.prototype.loadGeometry = function() {
        var r = this._pbf;
        r.pos = this._geometry;
        for (var i, l = r.readVarint() + r.pos, p = 1, y = 0, v = 0, x = 0, S = []; r.pos < l; ) {
          if (y <= 0) {
            var C = r.readVarint();
            p = 7 & C, y = C >> 3;
          }
          if (y--, p === 1 || p === 2)
            v += r.readSVarint(), x += r.readSVarint(), p === 1 && (i && S.push(i), i = []), i.push(new T(v, x));
          else {
            if (p !== 7)
              throw new Error("unknown command " + p);
            i && i.push(i[0].clone());
          }
        }
        return i && S.push(i), S;
      }, Ah.prototype.bbox = function() {
        var r = this._pbf;
        r.pos = this._geometry;
        for (var i = r.readVarint() + r.pos, l = 1, p = 0, y = 0, v = 0, x = 1 / 0, S = -1 / 0, C = 1 / 0, P = -1 / 0; r.pos < i; ) {
          if (p <= 0) {
            var L = r.readVarint();
            l = 7 & L, p = L >> 3;
          }
          if (p--, l === 1 || l === 2)
            (y += r.readSVarint()) < x && (x = y), y > S && (S = y), (v += r.readSVarint()) < C && (C = v), v > P && (P = v);
          else if (l !== 7)
            throw new Error("unknown command " + l);
        }
        return [x, C, S, P];
      }, Ah.prototype.toGeoJSON = function(r, i, l) {
        var p, y, v = this.extent * Math.pow(2, l), x = this.extent * r, S = this.extent * i, C = this.loadGeometry(), P = Ah.types[this.type];
        function L(j) {
          for (var J = 0; J < j.length; J++) {
            var ee = j[J];
            j[J] = [360 * (ee.x + x) / v - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (ee.y + S) / v) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var D = [];
            for (p = 0; p < C.length; p++)
              D[p] = C[p][0];
            L(C = D);
            break;
          case 2:
            for (p = 0; p < C.length; p++)
              L(C[p]);
            break;
          case 3:
            for (C = function(j) {
              var J = j.length;
              if (J <= 1)
                return [j];
              for (var ee, he, oe = [], ge = 0; ge < J; ge++) {
                var we = fO(j[ge]);
                we !== 0 && (he === void 0 && (he = we < 0), he === we < 0 ? (ee && oe.push(ee), ee = [j[ge]]) : ee.push(j[ge]));
              }
              return ee && oe.push(ee), oe;
            }(C), p = 0; p < C.length; p++)
              for (y = 0; y < C[p].length; y++)
                L(C[p][y]);
        }
        C.length === 1 ? C = C[0] : P = "Multi" + P;
        var B = { type: "Feature", geometry: { type: P, coordinates: C }, properties: this.properties };
        return "id" in this && (B.id = this.id), B;
      };
      var x1 = b1;
      function b1(r, i) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = r, this._keys = [], this._values = [], this._features = [], r.readFields(pO, this, i), this.length = this._features.length;
      }
      function pO(r, i, l) {
        r === 15 ? i.version = l.readVarint() : r === 1 ? i.name = l.readString() : r === 5 ? i.extent = l.readVarint() : r === 2 ? i._features.push(l.pos) : r === 3 ? i._keys.push(l.readString()) : r === 4 && i._values.push(function(p) {
          for (var y = null, v = p.readVarint() + p.pos; p.pos < v; ) {
            var x = p.readVarint() >> 3;
            y = x === 1 ? p.readString() : x === 2 ? p.readFloat() : x === 3 ? p.readDouble() : x === 4 ? p.readVarint64() : x === 5 ? p.readVarint() : x === 6 ? p.readSVarint() : x === 7 ? p.readBoolean() : null;
          }
          return y;
        }(l));
      }
      function dO(r, i, l) {
        if (r === 3) {
          var p = new x1(l, l.readVarint() + l.pos);
          p.length && (i[p.name] = p);
        }
      }
      b1.prototype.feature = function(r) {
        if (r < 0 || r >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[r];
        var i = this._pbf.readVarint() + this._pbf.pos;
        return new _1(this._pbf, i, this.extent, this._keys, this._values);
      };
      var kh = { VectorTile: function(r, i) {
        this.layers = r.readFields(dO, {}, i);
      }, VectorTileFeature: _1, VectorTileLayer: x1 }, mO = kh.VectorTileFeature.types, u_ = Math.pow(2, 13);
      function bp(r, i, l, p, y, v, x, S) {
        r.emplaceBack(i, l, 2 * Math.floor(p * u_) + x, y * u_ * 2, v * u_ * 2, Math.round(S));
      }
      var Wa = function(r) {
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(i) {
          return i.id;
        }), this.index = r.index, this.hasPattern = !1, this.layoutVertexArray = new Ga(), this.indexArray = new Ss(), this.programConfigurations = new Gt(r.layers, r.zoom), this.segments = new W(), this.stateDependentLayerIds = this.layers.filter(function(i) {
          return i.isStateDependent();
        }).map(function(i) {
          return i.id;
        });
      };
      function yO(r, i) {
        return r.x === i.x && (r.x < 0 || r.x > 8192) || r.y === i.y && (r.y < 0 || r.y > 8192);
      }
      Wa.prototype.populate = function(r, i, l) {
        this.features = [], this.hasPattern = s_("fill-extrusion", this.layers, i);
        for (var p = 0, y = r; p < y.length; p += 1) {
          var v = y[p], x = v.feature, S = v.id, C = v.index, P = v.sourceLayerIndex, L = this.layers[0]._featureFilter.needGeometry, D = Dn(x, L);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), D, l)) {
            var B = { id: S, sourceLayerIndex: P, index: C, geometry: L ? D.geometry : Mn(x), properties: x.properties, type: x.type, patterns: {} };
            this.hasPattern ? this.features.push(l_("fill-extrusion", this.layers, B, this.zoom, i)) : this.addFeature(B, B.geometry, C, l, {}), i.featureIndex.insert(x, B.geometry, C, P, this.index, !0);
          }
        }
      }, Wa.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.features; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, Wa.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, Wa.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, Wa.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, Wa.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, cO), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, Wa.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, Wa.prototype.addFeature = function(r, i, l, p, y) {
        for (var v = 0, x = a_(i, 500); v < x.length; v += 1) {
          for (var S = x[v], C = 0, P = 0, L = S; P < L.length; P += 1)
            C += L[P].length;
          for (var D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), B = 0, j = S; B < j.length; B += 1) {
            var J = j[B];
            if (J.length !== 0 && !((fr = J).every(function(rr) {
              return rr.x < 0;
            }) || fr.every(function(rr) {
              return rr.x > 8192;
            }) || fr.every(function(rr) {
              return rr.y < 0;
            }) || fr.every(function(rr) {
              return rr.y > 8192;
            })))
              for (var ee = 0, he = 0; he < J.length; he++) {
                var oe = J[he];
                if (he >= 1) {
                  var ge = J[he - 1];
                  if (!yO(oe, ge)) {
                    D.vertexLength + 4 > W.MAX_VERTEX_ARRAY_LENGTH && (D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    var we = oe.sub(ge)._perp()._unit(), Te = ge.dist(oe);
                    ee + Te > 32768 && (ee = 0), bp(this.layoutVertexArray, oe.x, oe.y, we.x, we.y, 0, 0, ee), bp(this.layoutVertexArray, oe.x, oe.y, we.x, we.y, 0, 1, ee), bp(this.layoutVertexArray, ge.x, ge.y, we.x, we.y, 0, 0, ee += Te), bp(this.layoutVertexArray, ge.x, ge.y, we.x, we.y, 0, 1, ee);
                    var Oe = D.vertexLength;
                    this.indexArray.emplaceBack(Oe, Oe + 2, Oe + 1), this.indexArray.emplaceBack(Oe + 1, Oe + 2, Oe + 3), D.vertexLength += 4, D.primitiveLength += 2;
                  }
                }
              }
          }
          if (D.vertexLength + C > W.MAX_VERTEX_ARRAY_LENGTH && (D = this.segments.prepareSegment(C, this.layoutVertexArray, this.indexArray)), mO[r.type] === "Polygon") {
            for (var Ve = [], Ke = [], ot = D.vertexLength, Pt = 0, dt = S; Pt < dt.length; Pt += 1) {
              var Rt = dt[Pt];
              if (Rt.length !== 0) {
                Rt !== S[0] && Ke.push(Ve.length / 2);
                for (var yt = 0; yt < Rt.length; yt++) {
                  var sr = Rt[yt];
                  bp(this.layoutVertexArray, sr.x, sr.y, 0, 0, 1, 1, 0), Ve.push(sr.x), Ve.push(sr.y);
                }
              }
            }
            for (var $t = r_(Ve, Ke), Mt = 0; Mt < $t.length; Mt += 3)
              this.indexArray.emplaceBack(ot + $t[Mt], ot + $t[Mt + 2], ot + $t[Mt + 1]);
            D.primitiveLength += $t.length / 3, D.vertexLength += C;
          }
        }
        var fr;
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, wt("FillExtrusionBucket", Wa, { omit: ["layers", "features"] });
      var gO = { paint: new Ii({ "fill-extrusion-opacity": new Dt(G["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Tt(G["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Dt(G["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Dt(G["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Eh(G["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Tt(G["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Tt(G["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Dt(G["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) }, vO = function(r) {
        function i(l) {
          r.call(this, l, gO);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.createBucket = function(l) {
          return new Wa(l);
        }, i.prototype.queryRadius = function() {
          return ui(this.paint.get("fill-extrusion-translate"));
        }, i.prototype.is3D = function() {
          return !0;
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C, P) {
          var L = $a(l, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), S.angle, C), D = this.paint.get("fill-extrusion-height").evaluate(p, y), B = this.paint.get("fill-extrusion-base").evaluate(p, y), j = function(ee, he, oe, ge) {
            for (var we = [], Te = 0, Oe = ee; Te < Oe.length; Te += 1) {
              var Ve = Oe[Te], Ke = [Ve.x, Ve.y, 0, 1];
              Oh(Ke, Ke, he), we.push(new T(Ke[0] / Ke[3], Ke[1] / Ke[3]));
            }
            return we;
          }(L, P), J = function(ee, he, oe, ge) {
            for (var we = [], Te = [], Oe = ge[8] * he, Ve = ge[9] * he, Ke = ge[10] * he, ot = ge[11] * he, Pt = ge[8] * oe, dt = ge[9] * oe, Rt = ge[10] * oe, yt = ge[11] * oe, sr = 0, $t = ee; sr < $t.length; sr += 1) {
              for (var Mt = [], fr = [], rr = 0, Tr = $t[sr]; rr < Tr.length; rr += 1) {
                var zt = Tr[rr], Lr = zt.x, vn = zt.y, Cn = ge[0] * Lr + ge[4] * vn + ge[12], In = ge[1] * Lr + ge[5] * vn + ge[13], _n = ge[2] * Lr + ge[6] * vn + ge[14], Pn = ge[3] * Lr + ge[7] * vn + ge[15], ci = _n + Ke, hi = Pn + ot, Wi = Cn + Pt, xi = In + dt, Hi = _n + Rt, Nn = Pn + yt, bi = new T((Cn + Oe) / hi, (In + Ve) / hi);
                bi.z = ci / hi, Mt.push(bi);
                var vr = new T(Wi / Nn, xi / Nn);
                vr.z = Hi / Nn, fr.push(vr);
              }
              we.push(Mt), Te.push(fr);
            }
            return [we, Te];
          }(v, B, D, P);
          return function(ee, he, oe) {
            var ge = 1 / 0;
            ca(oe, he) && (ge = w1(oe, he[0]));
            for (var we = 0; we < he.length; we++)
              for (var Te = he[we], Oe = ee[we], Ve = 0; Ve < Te.length - 1; Ve++) {
                var Ke = Te[Ve], ot = [Ke, Te[Ve + 1], Oe[Ve + 1], Oe[Ve], Ke];
                Is(oe, ot) && (ge = Math.min(ge, w1(oe, ot)));
              }
            return ge !== 1 / 0 && ge;
          }(J[0], J[1], j);
        }, i;
      }(wa);
      function wp(r, i) {
        return r.x * i.x + r.y * i.y;
      }
      function w1(r, i) {
        if (r.length === 1) {
          for (var l, p = 0, y = i[p++]; !l || y.equals(l); )
            if (!(l = i[p++]))
              return 1 / 0;
          for (; p < i.length; p++) {
            var v = i[p], x = r[0], S = l.sub(y), C = v.sub(y), P = x.sub(y), L = wp(S, S), D = wp(S, C), B = wp(C, C), j = wp(P, S), J = wp(P, C), ee = L * B - D * D, he = (B * j - D * J) / ee, oe = (L * J - D * j) / ee, ge = y.z * (1 - he - oe) + l.z * he + v.z * oe;
            if (isFinite(ge))
              return ge;
          }
          return 1 / 0;
        }
        for (var we = 1 / 0, Te = 0, Oe = i; Te < Oe.length; Te += 1)
          we = Math.min(we, Oe[Te].z);
        return we;
      }
      var _O = gi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4).members, xO = gi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]).members, bO = kh.VectorTileFeature.types, wO = Math.cos(Math.PI / 180 * 37.5), E1 = Math.pow(2, 14) / 0.5, to = function(r) {
        var i = this;
        this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(l) {
          return l.id;
        }), this.index = r.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(function(l) {
          i.gradients[l.id] = {};
        }), this.layoutVertexArray = new po(), this.layoutVertexArray2 = new iu(), this.indexArray = new Ss(), this.programConfigurations = new Gt(r.layers, r.zoom), this.segments = new W(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(function(l) {
          return l.isStateDependent();
        }).map(function(l) {
          return l.id;
        });
      };
      to.prototype.populate = function(r, i, l) {
        this.hasPattern = s_("line", this.layers, i);
        for (var p = this.layers[0].layout.get("line-sort-key"), y = [], v = 0, x = r; v < x.length; v += 1) {
          var S = x[v], C = S.feature, P = S.id, L = S.index, D = S.sourceLayerIndex, B = this.layers[0]._featureFilter.needGeometry, j = Dn(C, B);
          if (this.layers[0]._featureFilter.filter(new mr(this.zoom), j, l)) {
            var J = p ? p.evaluate(j, {}, l) : void 0, ee = { id: P, properties: C.properties, type: C.type, sourceLayerIndex: D, index: L, geometry: B ? j.geometry : Mn(C), patterns: {}, sortKey: J };
            y.push(ee);
          }
        }
        p && y.sort(function(Ke, ot) {
          return Ke.sortKey - ot.sortKey;
        });
        for (var he = 0, oe = y; he < oe.length; he += 1) {
          var ge = oe[he], we = ge.geometry, Te = ge.index, Oe = ge.sourceLayerIndex;
          if (this.hasPattern) {
            var Ve = l_("line", this.layers, ge, this.zoom, i);
            this.patternFeatures.push(Ve);
          } else
            this.addFeature(ge, we, Te, l, {});
          i.featureIndex.insert(r[Te].feature, we, Te, Oe, this.index);
        }
      }, to.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(r, i, this.stateDependentLayers, l);
      }, to.prototype.addFeatures = function(r, i, l) {
        for (var p = 0, y = this.patternFeatures; p < y.length; p += 1) {
          var v = y[p];
          this.addFeature(v, v.geometry, v.index, i, l);
        }
      }, to.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0;
      }, to.prototype.uploadPending = function() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }, to.prototype.upload = function(r) {
        this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = r.createVertexBuffer(this.layoutVertexArray2, xO)), this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, _O), this.indexBuffer = r.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(r), this.uploaded = !0;
      }, to.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }, to.prototype.lineFeatureClips = function(r) {
        if (r.properties && r.properties.hasOwnProperty("mapbox_clip_start") && r.properties.hasOwnProperty("mapbox_clip_end"))
          return { start: +r.properties.mapbox_clip_start, end: +r.properties.mapbox_clip_end };
      }, to.prototype.addFeature = function(r, i, l, p, y) {
        var v = this.layers[0].layout, x = v.get("line-join").evaluate(r, {}), S = v.get("line-cap"), C = v.get("line-miter-limit"), P = v.get("line-round-limit");
        this.lineClips = this.lineFeatureClips(r);
        for (var L = 0, D = i; L < D.length; L += 1)
          this.addLine(D[L], r, x, S, C, P);
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, r, l, y, p);
      }, to.prototype.addLine = function(r, i, l, p, y, v) {
        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
          this.lineClipsArray.push(this.lineClips);
          for (var x = 0; x < r.length - 1; x++)
            this.totalDistance += r[x].dist(r[x + 1]);
          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
        }
        for (var S = bO[i.type] === "Polygon", C = r.length; C >= 2 && r[C - 1].equals(r[C - 2]); )
          C--;
        for (var P = 0; P < C - 1 && r[P].equals(r[P + 1]); )
          P++;
        if (!(C < (S ? 3 : 2))) {
          l === "bevel" && (y = 1.05);
          var L, D = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, B = this.segments.prepareSegment(10 * C, this.layoutVertexArray, this.indexArray), j = void 0, J = void 0, ee = void 0, he = void 0;
          this.e1 = this.e2 = -1, S && (he = r[P].sub(L = r[C - 2])._unit()._perp());
          for (var oe = P; oe < C; oe++)
            if (!(J = oe === C - 1 ? S ? r[P + 1] : void 0 : r[oe + 1]) || !r[oe].equals(J)) {
              he && (ee = he), L && (j = L), L = r[oe], he = J ? J.sub(L)._unit()._perp() : ee;
              var ge = (ee = ee || he).add(he);
              ge.x === 0 && ge.y === 0 || ge._unit();
              var we = ee.x * he.x + ee.y * he.y, Te = ge.x * he.x + ge.y * he.y, Oe = Te !== 0 ? 1 / Te : 1 / 0, Ve = 2 * Math.sqrt(2 - 2 * Te), Ke = Te < wO && j && J, ot = ee.x * he.y - ee.y * he.x > 0;
              if (Ke && oe > P) {
                var Pt = L.dist(j);
                if (Pt > 2 * D) {
                  var dt = L.sub(L.sub(j)._mult(D / Pt)._round());
                  this.updateDistance(j, dt), this.addCurrentVertex(dt, ee, 0, 0, B), j = dt;
                }
              }
              var Rt = j && J, yt = Rt ? l : S ? "butt" : p;
              if (Rt && yt === "round" && (Oe < v ? yt = "miter" : Oe <= 2 && (yt = "fakeround")), yt === "miter" && Oe > y && (yt = "bevel"), yt === "bevel" && (Oe > 2 && (yt = "flipbevel"), Oe < y && (yt = "miter")), j && this.updateDistance(j, L), yt === "miter")
                ge._mult(Oe), this.addCurrentVertex(L, ge, 0, 0, B);
              else if (yt === "flipbevel") {
                if (Oe > 100)
                  ge = he.mult(-1);
                else {
                  var sr = Oe * ee.add(he).mag() / ee.sub(he).mag();
                  ge._perp()._mult(sr * (ot ? -1 : 1));
                }
                this.addCurrentVertex(L, ge, 0, 0, B), this.addCurrentVertex(L, ge.mult(-1), 0, 0, B);
              } else if (yt === "bevel" || yt === "fakeround") {
                var $t = -Math.sqrt(Oe * Oe - 1), Mt = ot ? $t : 0, fr = ot ? 0 : $t;
                if (j && this.addCurrentVertex(L, ee, Mt, fr, B), yt === "fakeround")
                  for (var rr = Math.round(180 * Ve / Math.PI / 20), Tr = 1; Tr < rr; Tr++) {
                    var zt = Tr / rr;
                    if (zt !== 0.5) {
                      var Lr = zt - 0.5;
                      zt += zt * Lr * (zt - 1) * ((1.0904 + we * (we * (3.55645 - 1.43519 * we) - 3.2452)) * Lr * Lr + (0.848013 + we * (0.215638 * we - 1.06021)));
                    }
                    var vn = he.sub(ee)._mult(zt)._add(ee)._unit()._mult(ot ? -1 : 1);
                    this.addHalfVertex(L, vn.x, vn.y, !1, ot, 0, B);
                  }
                J && this.addCurrentVertex(L, he, -Mt, -fr, B);
              } else if (yt === "butt")
                this.addCurrentVertex(L, ge, 0, 0, B);
              else if (yt === "square") {
                var Cn = j ? 1 : -1;
                this.addCurrentVertex(L, ge, Cn, Cn, B);
              } else
                yt === "round" && (j && (this.addCurrentVertex(L, ee, 0, 0, B), this.addCurrentVertex(L, ee, 1, 1, B, !0)), J && (this.addCurrentVertex(L, he, -1, -1, B, !0), this.addCurrentVertex(L, he, 0, 0, B)));
              if (Ke && oe < C - 1) {
                var In = L.dist(J);
                if (In > 2 * D) {
                  var _n = L.add(J.sub(L)._mult(D / In)._round());
                  this.updateDistance(L, _n), this.addCurrentVertex(_n, he, 0, 0, B), L = _n;
                }
              }
            }
        }
      }, to.prototype.addCurrentVertex = function(r, i, l, p, y, v) {
        v === void 0 && (v = !1);
        var x = i.y * p - i.x, S = -i.y - i.x * p;
        this.addHalfVertex(r, i.x + i.y * l, i.y - i.x * l, v, !1, l, y), this.addHalfVertex(r, x, S, v, !0, -p, y), this.distance > E1 / 2 && this.totalDistance === 0 && (this.distance = 0, this.addCurrentVertex(r, i, l, p, y, v));
      }, to.prototype.addHalfVertex = function(r, i, l, p, y, v, x) {
        var S = 0.5 * (this.lineClips ? this.scaledDistance * (E1 - 1) : this.scaledDistance);
        this.layoutVertexArray.emplaceBack((r.x << 1) + (p ? 1 : 0), (r.y << 1) + (y ? 1 : 0), Math.round(63 * i) + 128, Math.round(63 * l) + 128, 1 + (v === 0 ? 0 : v < 0 ? -1 : 1) | (63 & S) << 2, S >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
        var C = x.vertexLength++;
        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, C), x.primitiveLength++), y ? this.e2 = C : this.e1 = C;
      }, to.prototype.updateScaledDistance = function() {
        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
      }, to.prototype.updateDistance = function(r, i) {
        this.distance += r.dist(i), this.updateScaledDistance();
      }, wt("LineBucket", to, { omit: ["layers", "patternFeatures"] });
      var EO = new Ii({ "line-cap": new Dt(G.layout_line["line-cap"]), "line-join": new Tt(G.layout_line["line-join"]), "line-miter-limit": new Dt(G.layout_line["line-miter-limit"]), "line-round-limit": new Dt(G.layout_line["line-round-limit"]), "line-sort-key": new Tt(G.layout_line["line-sort-key"]) }), S1 = { paint: new Ii({ "line-opacity": new Tt(G.paint_line["line-opacity"]), "line-color": new Tt(G.paint_line["line-color"]), "line-translate": new Dt(G.paint_line["line-translate"]), "line-translate-anchor": new Dt(G.paint_line["line-translate-anchor"]), "line-width": new Tt(G.paint_line["line-width"]), "line-gap-width": new Tt(G.paint_line["line-gap-width"]), "line-offset": new Tt(G.paint_line["line-offset"]), "line-blur": new Tt(G.paint_line["line-blur"]), "line-dasharray": new Gi(G.paint_line["line-dasharray"]), "line-pattern": new Eh(G.paint_line["line-pattern"]), "line-gradient": new ua(G.paint_line["line-gradient"]) }), layout: EO }, T1 = new (function(r) {
        function i() {
          r.apply(this, arguments);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.possiblyEvaluate = function(l, p) {
          return p = new mr(Math.floor(p.zoom), { now: p.now, fadeDuration: p.fadeDuration, zoomHistory: p.zoomHistory, transition: p.transition }), r.prototype.possiblyEvaluate.call(this, l, p);
        }, i.prototype.evaluate = function(l, p, y, v) {
          return p = X({}, p, { zoom: Math.floor(p.zoom) }), r.prototype.evaluate.call(this, l, p, y, v);
        }, i;
      }(Tt))(S1.paint.properties["line-width"].specification);
      T1.useIntegerZoom = !0;
      var SO = function(r) {
        function i(l) {
          r.call(this, l, S1), this.gradientVersion = 0;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype._handleSpecialPaintPropertyUpdate = function(l) {
          l === "line-gradient" && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof lo, this.gradientVersion = (this.gradientVersion + 1) % A);
        }, i.prototype.gradientExpression = function() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }, i.prototype.recalculate = function(l, p) {
          r.prototype.recalculate.call(this, l, p), this.paint._values["line-floorwidth"] = T1.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, l);
        }, i.prototype.createBucket = function(l) {
          return new to(l);
        }, i.prototype.queryRadius = function(l) {
          var p = l, y = M1(Ta("line-width", this, p), Ta("line-gap-width", this, p)), v = Ta("line-offset", this, p);
          return y / 2 + Math.abs(v) + ui(this.paint.get("line-translate"));
        }, i.prototype.queryIntersectsFeature = function(l, p, y, v, x, S, C) {
          var P = $a(l, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), S.angle, C), L = C / 2 * M1(this.paint.get("line-width").evaluate(p, y), this.paint.get("line-gap-width").evaluate(p, y)), D = this.paint.get("line-offset").evaluate(p, y);
          return D && (v = function(B, j) {
            for (var J = [], ee = new T(0, 0), he = 0; he < B.length; he++) {
              for (var oe = B[he], ge = [], we = 0; we < oe.length; we++) {
                var Te = oe[we], Oe = oe[we + 1], Ve = we === 0 ? ee : Te.sub(oe[we - 1])._unit()._perp(), Ke = we === oe.length - 1 ? ee : Oe.sub(Te)._unit()._perp(), ot = Ve._add(Ke)._unit();
                ot._mult(1 / (ot.x * Ke.x + ot.y * Ke.y)), ge.push(ot._mult(j)._add(Te));
              }
              J.push(ge);
            }
            return J;
          }(v, D * C)), function(B, j, J) {
            for (var ee = 0; ee < j.length; ee++) {
              var he = j[ee];
              if (B.length >= 3) {
                for (var oe = 0; oe < he.length; oe++)
                  if (Sa(B, he[oe]))
                    return !0;
              }
              if (Zo(B, he, J))
                return !0;
            }
            return !1;
          }(P, v, L);
        }, i.prototype.isTileClipped = function() {
          return !0;
        }, i;
      }(wa);
      function M1(r, i) {
        return i > 0 ? i + 2 * r : r;
      }
      var TO = gi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), MO = gi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), IO = (gi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), gi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }])), I1 = (gi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]), gi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), OO = gi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function CO(r, i, l) {
        return r.sections.forEach(function(p) {
          p.text = function(y, v, x) {
            var S = v.layout.get("text-transform").evaluate(x, {});
            return S === "uppercase" ? y = y.toLocaleUpperCase() : S === "lowercase" && (y = y.toLocaleLowerCase()), Io.applyArabicShaping && (y = Io.applyArabicShaping(y)), y;
          }(p.text, i, l);
        }), r;
      }
      gi([{ name: "triangle", components: 3, type: "Uint16" }]), gi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), gi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), gi([{ type: "Float32", name: "offsetX" }]), gi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
      var Ep = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" }, O1 = function(r, i, l, p, y) {
        var v, x, S = 8 * y - p - 1, C = (1 << S) - 1, P = C >> 1, L = -7, D = l ? y - 1 : 0, B = l ? -1 : 1, j = r[i + D];
        for (D += B, v = j & (1 << -L) - 1, j >>= -L, L += S; L > 0; v = 256 * v + r[i + D], D += B, L -= 8)
          ;
        for (x = v & (1 << -L) - 1, v >>= -L, L += p; L > 0; x = 256 * x + r[i + D], D += B, L -= 8)
          ;
        if (v === 0)
          v = 1 - P;
        else {
          if (v === C)
            return x ? NaN : 1 / 0 * (j ? -1 : 1);
          x += Math.pow(2, p), v -= P;
        }
        return (j ? -1 : 1) * x * Math.pow(2, v - p);
      }, C1 = function(r, i, l, p, y, v) {
        var x, S, C, P = 8 * v - y - 1, L = (1 << P) - 1, D = L >> 1, B = y === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, j = p ? 0 : v - 1, J = p ? 1 : -1, ee = i < 0 || i === 0 && 1 / i < 0 ? 1 : 0;
        for (i = Math.abs(i), isNaN(i) || i === 1 / 0 ? (S = isNaN(i) ? 1 : 0, x = L) : (x = Math.floor(Math.log(i) / Math.LN2), i * (C = Math.pow(2, -x)) < 1 && (x--, C *= 2), (i += x + D >= 1 ? B / C : B * Math.pow(2, 1 - D)) * C >= 2 && (x++, C /= 2), x + D >= L ? (S = 0, x = L) : x + D >= 1 ? (S = (i * C - 1) * Math.pow(2, y), x += D) : (S = i * Math.pow(2, D - 1) * Math.pow(2, y), x = 0)); y >= 8; r[l + j] = 255 & S, j += J, S /= 256, y -= 8)
          ;
        for (x = x << y | S, P += y; P > 0; r[l + j] = 255 & x, j += J, x /= 256, P -= 8)
          ;
        r[l + j - J] |= 128 * ee;
      }, Gm = tn;
      function tn(r) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(r) ? r : new Uint8Array(r || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      tn.Varint = 0, tn.Fixed64 = 1, tn.Bytes = 2, tn.Fixed32 = 5;
      var P1 = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
      function Tl(r) {
        return r.type === tn.Bytes ? r.readVarint() + r.pos : r.pos + 1;
      }
      function Lh(r, i, l) {
        return l ? 4294967296 * i + (r >>> 0) : 4294967296 * (i >>> 0) + (r >>> 0);
      }
      function A1(r, i, l) {
        var p = i <= 16383 ? 1 : i <= 2097151 ? 2 : i <= 268435455 ? 3 : Math.floor(Math.log(i) / (7 * Math.LN2));
        l.realloc(p);
        for (var y = l.pos - 1; y >= r; y--)
          l.buf[y + p] = l.buf[y];
      }
      function PO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeVarint(r[l]);
      }
      function AO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSVarint(r[l]);
      }
      function kO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFloat(r[l]);
      }
      function LO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeDouble(r[l]);
      }
      function DO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeBoolean(r[l]);
      }
      function NO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFixed32(r[l]);
      }
      function RO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSFixed32(r[l]);
      }
      function zO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeFixed64(r[l]);
      }
      function FO(r, i) {
        for (var l = 0; l < r.length; l++)
          i.writeSFixed64(r[l]);
      }
      function $m(r, i) {
        return (r[i] | r[i + 1] << 8 | r[i + 2] << 16) + 16777216 * r[i + 3];
      }
      function Dh(r, i, l) {
        r[l] = i, r[l + 1] = i >>> 8, r[l + 2] = i >>> 16, r[l + 3] = i >>> 24;
      }
      function k1(r, i) {
        return (r[i] | r[i + 1] << 8 | r[i + 2] << 16) + (r[i + 3] << 24);
      }
      function BO(r, i, l) {
        r === 1 && l.readMessage(VO, i);
      }
      function VO(r, i, l) {
        if (r === 3) {
          var p = l.readMessage(UO, {}), y = p.width, v = p.height, x = p.left, S = p.top, C = p.advance;
          i.push({ id: p.id, bitmap: new vc({ width: y + 6, height: v + 6 }, p.bitmap), metrics: { width: y, height: v, left: x, top: S, advance: C } });
        }
      }
      function UO(r, i, l) {
        r === 1 ? i.id = l.readVarint() : r === 2 ? i.bitmap = l.readBytes() : r === 3 ? i.width = l.readVarint() : r === 4 ? i.height = l.readVarint() : r === 5 ? i.left = l.readSVarint() : r === 6 ? i.top = l.readSVarint() : r === 7 && (i.advance = l.readVarint());
      }
      function L1(r) {
        for (var i = 0, l = 0, p = 0, y = r; p < y.length; p += 1) {
          var v = y[p];
          i += v.w * v.h, l = Math.max(l, v.w);
        }
        r.sort(function(ee, he) {
          return he.h - ee.h;
        });
        for (var x = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(i / 0.95)), l), h: 1 / 0 }], S = 0, C = 0, P = 0, L = r; P < L.length; P += 1)
          for (var D = L[P], B = x.length - 1; B >= 0; B--) {
            var j = x[B];
            if (!(D.w > j.w || D.h > j.h)) {
              if (D.x = j.x, D.y = j.y, C = Math.max(C, D.y + D.h), S = Math.max(S, D.x + D.w), D.w === j.w && D.h === j.h) {
                var J = x.pop();
                B < x.length && (x[B] = J);
              } else
                D.h === j.h ? (j.x += D.w, j.w -= D.w) : D.w === j.w ? (j.y += D.h, j.h -= D.h) : (x.push({ x: j.x + D.w, y: j.y, w: j.w - D.w, h: D.h }), j.y += D.h, j.h -= D.h);
              break;
            }
          }
        return { w: S, h: C, fill: i / (S * C) || 0 };
      }
      tn.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(r, i, l) {
        for (l = l || this.length; this.pos < l; ) {
          var p = this.readVarint(), y = p >> 3, v = this.pos;
          this.type = 7 & p, r(y, i, this), this.pos === v && this.skip(p);
        }
        return i;
      }, readMessage: function(r, i) {
        return this.readFields(r, i, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var r = $m(this.buf, this.pos);
        return this.pos += 4, r;
      }, readSFixed32: function() {
        var r = k1(this.buf, this.pos);
        return this.pos += 4, r;
      }, readFixed64: function() {
        var r = $m(this.buf, this.pos) + 4294967296 * $m(this.buf, this.pos + 4);
        return this.pos += 8, r;
      }, readSFixed64: function() {
        var r = $m(this.buf, this.pos) + 4294967296 * k1(this.buf, this.pos + 4);
        return this.pos += 8, r;
      }, readFloat: function() {
        var r = O1(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, r;
      }, readDouble: function() {
        var r = O1(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, r;
      }, readVarint: function(r) {
        var i, l, p = this.buf;
        return i = 127 & (l = p[this.pos++]), l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 7, l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 14, l < 128 ? i : (i |= (127 & (l = p[this.pos++])) << 21, l < 128 ? i : function(y, v, x) {
          var S, C, P = x.buf;
          if (S = (112 & (C = P[x.pos++])) >> 4, C < 128 || (S |= (127 & (C = P[x.pos++])) << 3, C < 128) || (S |= (127 & (C = P[x.pos++])) << 10, C < 128) || (S |= (127 & (C = P[x.pos++])) << 17, C < 128) || (S |= (127 & (C = P[x.pos++])) << 24, C < 128) || (S |= (1 & (C = P[x.pos++])) << 31, C < 128))
            return Lh(y, S, v);
          throw new Error("Expected varint not more than 10 bytes");
        }(i |= (15 & (l = p[this.pos])) << 28, r, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var r = this.readVarint();
        return r % 2 == 1 ? (r + 1) / -2 : r / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var r = this.readVarint() + this.pos, i = this.pos;
        return this.pos = r, r - i >= 12 && P1 ? function(l, p, y) {
          return P1.decode(l.subarray(p, y));
        }(this.buf, i, r) : function(l, p, y) {
          for (var v = "", x = p; x < y; ) {
            var S, C, P, L = l[x], D = null, B = L > 239 ? 4 : L > 223 ? 3 : L > 191 ? 2 : 1;
            if (x + B > y)
              break;
            B === 1 ? L < 128 && (D = L) : B === 2 ? (192 & (S = l[x + 1])) == 128 && (D = (31 & L) << 6 | 63 & S) <= 127 && (D = null) : B === 3 ? (C = l[x + 2], (192 & (S = l[x + 1])) == 128 && (192 & C) == 128 && ((D = (15 & L) << 12 | (63 & S) << 6 | 63 & C) <= 2047 || D >= 55296 && D <= 57343) && (D = null)) : B === 4 && (C = l[x + 2], P = l[x + 3], (192 & (S = l[x + 1])) == 128 && (192 & C) == 128 && (192 & P) == 128 && ((D = (15 & L) << 18 | (63 & S) << 12 | (63 & C) << 6 | 63 & P) <= 65535 || D >= 1114112) && (D = null)), D === null ? (D = 65533, B = 1) : D > 65535 && (D -= 65536, v += String.fromCharCode(D >>> 10 & 1023 | 55296), D = 56320 | 1023 & D), v += String.fromCharCode(D), x += B;
          }
          return v;
        }(this.buf, i, r);
      }, readBytes: function() {
        var r = this.readVarint() + this.pos, i = this.buf.subarray(this.pos, r);
        return this.pos = r, i;
      }, readPackedVarint: function(r, i) {
        if (this.type !== tn.Bytes)
          return r.push(this.readVarint(i));
        var l = Tl(this);
        for (r = r || []; this.pos < l; )
          r.push(this.readVarint(i));
        return r;
      }, readPackedSVarint: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSVarint());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSVarint());
        return r;
      }, readPackedBoolean: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readBoolean());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readBoolean());
        return r;
      }, readPackedFloat: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFloat());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFloat());
        return r;
      }, readPackedDouble: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readDouble());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readDouble());
        return r;
      }, readPackedFixed32: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFixed32());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFixed32());
        return r;
      }, readPackedSFixed32: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSFixed32());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSFixed32());
        return r;
      }, readPackedFixed64: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readFixed64());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readFixed64());
        return r;
      }, readPackedSFixed64: function(r) {
        if (this.type !== tn.Bytes)
          return r.push(this.readSFixed64());
        var i = Tl(this);
        for (r = r || []; this.pos < i; )
          r.push(this.readSFixed64());
        return r;
      }, skip: function(r) {
        var i = 7 & r;
        if (i === tn.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (i === tn.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (i === tn.Fixed32)
          this.pos += 4;
        else {
          if (i !== tn.Fixed64)
            throw new Error("Unimplemented type: " + i);
          this.pos += 8;
        }
      }, writeTag: function(r, i) {
        this.writeVarint(r << 3 | i);
      }, realloc: function(r) {
        for (var i = this.length || 16; i < this.pos + r; )
          i *= 2;
        if (i !== this.length) {
          var l = new Uint8Array(i);
          l.set(this.buf), this.buf = l, this.length = i;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(r) {
        this.realloc(4), Dh(this.buf, r, this.pos), this.pos += 4;
      }, writeSFixed32: function(r) {
        this.realloc(4), Dh(this.buf, r, this.pos), this.pos += 4;
      }, writeFixed64: function(r) {
        this.realloc(8), Dh(this.buf, -1 & r, this.pos), Dh(this.buf, Math.floor(r * (1 / 4294967296)), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(r) {
        this.realloc(8), Dh(this.buf, -1 & r, this.pos), Dh(this.buf, Math.floor(r * (1 / 4294967296)), this.pos + 4), this.pos += 8;
      }, writeVarint: function(r) {
        (r = +r || 0) > 268435455 || r < 0 ? function(i, l) {
          var p, y;
          if (i >= 0 ? (p = i % 4294967296 | 0, y = i / 4294967296 | 0) : (y = ~(-i / 4294967296), 4294967295 ^ (p = ~(-i % 4294967296)) ? p = p + 1 | 0 : (p = 0, y = y + 1 | 0)), i >= 18446744073709552e3 || i < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          l.realloc(10), function(v, x, S) {
            S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, v >>>= 7, S.buf[S.pos++] = 127 & v | 128, S.buf[S.pos] = 127 & (v >>>= 7);
          }(p, 0, l), function(v, x) {
            var S = (7 & v) << 4;
            x.buf[x.pos++] |= S | ((v >>>= 3) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v)))));
          }(y, l);
        }(r, this) : (this.realloc(4), this.buf[this.pos++] = 127 & r | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (r > 127 ? 128 : 0), r <= 127 || (this.buf[this.pos++] = r >>> 7 & 127))));
      }, writeSVarint: function(r) {
        this.writeVarint(r < 0 ? 2 * -r - 1 : 2 * r);
      }, writeBoolean: function(r) {
        this.writeVarint(Boolean(r));
      }, writeString: function(r) {
        r = String(r), this.realloc(4 * r.length), this.pos++;
        var i = this.pos;
        this.pos = function(p, y, v) {
          for (var x, S, C = 0; C < y.length; C++) {
            if ((x = y.charCodeAt(C)) > 55295 && x < 57344) {
              if (!S) {
                x > 56319 || C + 1 === y.length ? (p[v++] = 239, p[v++] = 191, p[v++] = 189) : S = x;
                continue;
              }
              if (x < 56320) {
                p[v++] = 239, p[v++] = 191, p[v++] = 189, S = x;
                continue;
              }
              x = S - 55296 << 10 | x - 56320 | 65536, S = null;
            } else
              S && (p[v++] = 239, p[v++] = 191, p[v++] = 189, S = null);
            x < 128 ? p[v++] = x : (x < 2048 ? p[v++] = x >> 6 | 192 : (x < 65536 ? p[v++] = x >> 12 | 224 : (p[v++] = x >> 18 | 240, p[v++] = x >> 12 & 63 | 128), p[v++] = x >> 6 & 63 | 128), p[v++] = 63 & x | 128);
          }
          return v;
        }(this.buf, r, this.pos);
        var l = this.pos - i;
        l >= 128 && A1(i, l, this), this.pos = i - 1, this.writeVarint(l), this.pos += l;
      }, writeFloat: function(r) {
        this.realloc(4), C1(this.buf, r, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(r) {
        this.realloc(8), C1(this.buf, r, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(r) {
        var i = r.length;
        this.writeVarint(i), this.realloc(i);
        for (var l = 0; l < i; l++)
          this.buf[this.pos++] = r[l];
      }, writeRawMessage: function(r, i) {
        this.pos++;
        var l = this.pos;
        r(i, this);
        var p = this.pos - l;
        p >= 128 && A1(l, p, this), this.pos = l - 1, this.writeVarint(p), this.pos += p;
      }, writeMessage: function(r, i, l) {
        this.writeTag(r, tn.Bytes), this.writeRawMessage(i, l);
      }, writePackedVarint: function(r, i) {
        i.length && this.writeMessage(r, PO, i);
      }, writePackedSVarint: function(r, i) {
        i.length && this.writeMessage(r, AO, i);
      }, writePackedBoolean: function(r, i) {
        i.length && this.writeMessage(r, DO, i);
      }, writePackedFloat: function(r, i) {
        i.length && this.writeMessage(r, kO, i);
      }, writePackedDouble: function(r, i) {
        i.length && this.writeMessage(r, LO, i);
      }, writePackedFixed32: function(r, i) {
        i.length && this.writeMessage(r, NO, i);
      }, writePackedSFixed32: function(r, i) {
        i.length && this.writeMessage(r, RO, i);
      }, writePackedFixed64: function(r, i) {
        i.length && this.writeMessage(r, zO, i);
      }, writePackedSFixed64: function(r, i) {
        i.length && this.writeMessage(r, FO, i);
      }, writeBytesField: function(r, i) {
        this.writeTag(r, tn.Bytes), this.writeBytes(i);
      }, writeFixed32Field: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeFixed32(i);
      }, writeSFixed32Field: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeSFixed32(i);
      }, writeFixed64Field: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeFixed64(i);
      }, writeSFixed64Field: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeSFixed64(i);
      }, writeVarintField: function(r, i) {
        this.writeTag(r, tn.Varint), this.writeVarint(i);
      }, writeSVarintField: function(r, i) {
        this.writeTag(r, tn.Varint), this.writeSVarint(i);
      }, writeStringField: function(r, i) {
        this.writeTag(r, tn.Bytes), this.writeString(i);
      }, writeFloatField: function(r, i) {
        this.writeTag(r, tn.Fixed32), this.writeFloat(i);
      }, writeDoubleField: function(r, i) {
        this.writeTag(r, tn.Fixed64), this.writeDouble(i);
      }, writeBooleanField: function(r, i) {
        this.writeVarintField(r, Boolean(i));
      } };
      var qm = function(r, i) {
        var l = i.pixelRatio, p = i.version, y = i.stretchX, v = i.stretchY, x = i.content;
        this.paddedRect = r, this.pixelRatio = l, this.stretchX = y, this.stretchY = v, this.content = x, this.version = p;
      }, Sp = { tl: { configurable: !0 }, br: { configurable: !0 }, tlbr: { configurable: !0 }, displaySize: { configurable: !0 } };
      Sp.tl.get = function() {
        return [this.paddedRect.x + 1, this.paddedRect.y + 1];
      }, Sp.br.get = function() {
        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
      }, Sp.tlbr.get = function() {
        return this.tl.concat(this.br);
      }, Sp.displaySize.get = function() {
        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
      }, Object.defineProperties(qm.prototype, Sp);
      var Tp = function(r, i) {
        var l = {}, p = {};
        this.haveRenderCallbacks = [];
        var y = [];
        this.addImages(r, l, y), this.addImages(i, p, y);
        var v = L1(y), x = new yo({ width: v.w || 1, height: v.h || 1 });
        for (var S in r) {
          var C = r[S], P = l[S].paddedRect;
          yo.copy(C.data, x, { x: 0, y: 0 }, { x: P.x + 1, y: P.y + 1 }, C.data);
        }
        for (var L in i) {
          var D = i[L], B = p[L].paddedRect, j = B.x + 1, J = B.y + 1, ee = D.data.width, he = D.data.height;
          yo.copy(D.data, x, { x: 0, y: 0 }, { x: j, y: J }, D.data), yo.copy(D.data, x, { x: 0, y: he - 1 }, { x: j, y: J - 1 }, { width: ee, height: 1 }), yo.copy(D.data, x, { x: 0, y: 0 }, { x: j, y: J + he }, { width: ee, height: 1 }), yo.copy(D.data, x, { x: ee - 1, y: 0 }, { x: j - 1, y: J }, { width: 1, height: he }), yo.copy(D.data, x, { x: 0, y: 0 }, { x: j + ee, y: J }, { width: 1, height: he });
        }
        this.image = x, this.iconPositions = l, this.patternPositions = p;
      };
      Tp.prototype.addImages = function(r, i, l) {
        for (var p in r) {
          var y = r[p], v = { x: 0, y: 0, w: y.data.width + 2, h: y.data.height + 2 };
          l.push(v), i[p] = new qm(v, y), y.hasRenderCallback && this.haveRenderCallbacks.push(p);
        }
      }, Tp.prototype.patchUpdatedImages = function(r, i) {
        for (var l in r.dispatchRenderCallbacks(this.haveRenderCallbacks), r.updatedImages)
          this.patchUpdatedImage(this.iconPositions[l], r.getImage(l), i), this.patchUpdatedImage(this.patternPositions[l], r.getImage(l), i);
      }, Tp.prototype.patchUpdatedImage = function(r, i, l) {
        if (r && i && r.version !== i.version) {
          r.version = i.version;
          var p = r.tl;
          l.update(i.data, void 0, { x: p[0], y: p[1] });
        }
      }, wt("ImagePosition", qm), wt("ImageAtlas", Tp);
      var Xo = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, Nh = function() {
        this.scale = 1, this.fontStack = "", this.imageName = null;
      };
      Nh.forText = function(r, i) {
        var l = new Nh();
        return l.scale = r || 1, l.fontStack = i, l;
      }, Nh.forImage = function(r) {
        var i = new Nh();
        return i.imageName = r, i;
      };
      var qi = function() {
        this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
      };
      function Wm(r, i, l, p, y, v, x, S, C, P, L, D, B, j, J, ee) {
        var he, oe = qi.fromFeature(r, y);
        D === Xo.vertical && oe.verticalizePunctuation();
        var ge = Io.processBidirectionalText, we = Io.processStyledBidirectionalText;
        if (ge && oe.sections.length === 1) {
          he = [];
          for (var Te = 0, Oe = ge(oe.toString(), c_(oe, P, v, i, p, j, J)); Te < Oe.length; Te += 1) {
            var Ve = Oe[Te], Ke = new qi();
            Ke.text = Ve, Ke.sections = oe.sections;
            for (var ot = 0; ot < Ve.length; ot++)
              Ke.sectionIndex.push(0);
            he.push(Ke);
          }
        } else if (we) {
          he = [];
          for (var Pt = 0, dt = we(oe.text, oe.sectionIndex, c_(oe, P, v, i, p, j, J)); Pt < dt.length; Pt += 1) {
            var Rt = dt[Pt], yt = new qi();
            yt.text = Rt[0], yt.sectionIndex = Rt[1], yt.sections = oe.sections, he.push(yt);
          }
        } else
          he = function(Mt, fr) {
            for (var rr = [], Tr = Mt.text, zt = 0, Lr = 0, vn = fr; Lr < vn.length; Lr += 1) {
              var Cn = vn[Lr];
              rr.push(Mt.substring(zt, Cn)), zt = Cn;
            }
            return zt < Tr.length && rr.push(Mt.substring(zt, Tr.length)), rr;
          }(oe, c_(oe, P, v, i, p, j, J));
        var sr = [], $t = { positionedLines: sr, text: oe.toString(), top: L[1], bottom: L[1], left: L[0], right: L[0], writingMode: D, iconsInText: !1, verticalizable: !1 };
        return function(Mt, fr, rr, Tr, zt, Lr, vn, Cn, In, _n, Pn, ci) {
          for (var hi = 0, Wi = -17, xi = 0, Hi = 0, Nn = Cn === "right" ? 1 : Cn === "left" ? 0 : 0.5, bi = 0, vr = 0, Xr = zt; vr < Xr.length; vr += 1) {
            var qr = Xr[vr];
            qr.trim();
            var Or = qr.getMaxScale(), ro = 24 * (Or - 1), Di = { positionedGlyphs: [], lineOffset: 0 };
            Mt.positionedLines[bi] = Di;
            var ln = Di.positionedGlyphs, $n = 0;
            if (qr.length()) {
              for (var Ni = 0; Ni < qr.length(); Ni++) {
                var Dr = qr.getSection(Ni), Ps = qr.getSectionIndex(Ni), Ko = qr.getCharCode(Ni), As = 0, Rn = null, ks = null, Ma = null, Gh = 24, wc = !(In === Xo.horizontal || !Pn && !xh(Ko) || Pn && (Hm[Ko] || (Cl = Ko, ct.Arabic(Cl) || ct["Arabic Supplement"](Cl) || ct["Arabic Extended-A"](Cl) || ct["Arabic Presentation Forms-A"](Cl) || ct["Arabic Presentation Forms-B"](Cl))));
                if (Dr.imageName) {
                  var $h = Tr[Dr.imageName];
                  if (!$h)
                    continue;
                  Ma = Dr.imageName, Mt.iconsInText = Mt.iconsInText || !0, ks = $h.paddedRect;
                  var Ol = $h.displaySize;
                  Dr.scale = 24 * Dr.scale / ci, As = ro + (24 - Ol[1] * Dr.scale), Gh = (Rn = { width: Ol[0], height: Ol[1], left: 1, top: -3, advance: wc ? Ol[1] : Ol[0] }).advance;
                  var qh = wc ? Ol[0] * Dr.scale - 24 * Or : Ol[1] * Dr.scale - 24 * Or;
                  qh > 0 && qh > $n && ($n = qh);
                } else {
                  var ry = rr[Dr.fontStack], Wh = ry && ry[Ko];
                  if (Wh && Wh.rect)
                    ks = Wh.rect, Rn = Wh.metrics;
                  else {
                    var Op = fr[Dr.fontStack], ny = Op && Op[Ko];
                    if (!ny)
                      continue;
                    Rn = ny.metrics;
                  }
                  As = 24 * (Or - Dr.scale);
                }
                wc ? (Mt.verticalizable = !0, ln.push({ glyph: Ko, imageName: Ma, x: hi, y: Wi + As, vertical: wc, scale: Dr.scale, fontStack: Dr.fontStack, sectionIndex: Ps, metrics: Rn, rect: ks }), hi += Gh * Dr.scale + _n) : (ln.push({ glyph: Ko, imageName: Ma, x: hi, y: Wi + As, vertical: wc, scale: Dr.scale, fontStack: Dr.fontStack, sectionIndex: Ps, metrics: Rn, rect: ks }), hi += Rn.advance * Dr.scale + _n);
              }
              ln.length !== 0 && (xi = Math.max(hi - _n, xi), GO(ln, 0, ln.length - 1, Nn, $n)), hi = 0;
              var iy = Lr * Or + $n;
              Di.lineOffset = Math.max($n, ro), Wi += iy, Hi = Math.max(iy, Hi), ++bi;
            } else
              Wi += Lr, ++bi;
          }
          var Cl, Cp = Wi - -17, Hh = h_(vn), fu = Hh.horizontalAlign, Zh = Hh.verticalAlign;
          (function(oy, ay, Pp, Ap, sy, kp, Lp, Dp, ly) {
            var Xh, uy = (ay - Pp) * sy;
            Xh = kp !== Lp ? -Dp * Ap - -17 : (-Ap * ly + 0.5) * Lp;
            for (var Kh = 0, Np = oy; Kh < Np.length; Kh += 1)
              for (var Ec = 0, Rp = Np[Kh].positionedGlyphs; Ec < Rp.length; Ec += 1) {
                var Yh = Rp[Ec];
                Yh.x += uy, Yh.y += Xh;
              }
          })(Mt.positionedLines, Nn, fu, Zh, xi, Hi, Lr, Cp, zt.length), Mt.top += -Zh * Cp, Mt.bottom = Mt.top + Cp, Mt.left += -fu * xi, Mt.right = Mt.left + xi;
        }($t, i, l, p, he, x, S, C, D, P, B, ee), !function(Mt) {
          for (var fr = 0, rr = Mt; fr < rr.length; fr += 1)
            if (rr[fr].positionedGlyphs.length !== 0)
              return !1;
          return !0;
        }(sr) && $t;
      }
      qi.fromFeature = function(r, i) {
        for (var l = new qi(), p = 0; p < r.sections.length; p++) {
          var y = r.sections[p];
          y.image ? l.addImageSection(y) : l.addTextSection(y, i);
        }
        return l;
      }, qi.prototype.length = function() {
        return this.text.length;
      }, qi.prototype.getSection = function(r) {
        return this.sections[this.sectionIndex[r]];
      }, qi.prototype.getSectionIndex = function(r) {
        return this.sectionIndex[r];
      }, qi.prototype.getCharCode = function(r) {
        return this.text.charCodeAt(r);
      }, qi.prototype.verticalizePunctuation = function() {
        this.text = function(r) {
          for (var i = "", l = 0; l < r.length; l++) {
            var p = r.charCodeAt(l + 1) || null, y = r.charCodeAt(l - 1) || null;
            i += p && lp(p) && !Ep[r[l + 1]] || y && lp(y) && !Ep[r[l - 1]] || !Ep[r[l]] ? r[l] : Ep[r[l]];
          }
          return i;
        }(this.text);
      }, qi.prototype.trim = function() {
        for (var r = 0, i = 0; i < this.text.length && Hm[this.text.charCodeAt(i)]; i++)
          r++;
        for (var l = this.text.length, p = this.text.length - 1; p >= 0 && p >= r && Hm[this.text.charCodeAt(p)]; p--)
          l--;
        this.text = this.text.substring(r, l), this.sectionIndex = this.sectionIndex.slice(r, l);
      }, qi.prototype.substring = function(r, i) {
        var l = new qi();
        return l.text = this.text.substring(r, i), l.sectionIndex = this.sectionIndex.slice(r, i), l.sections = this.sections, l;
      }, qi.prototype.toString = function() {
        return this.text;
      }, qi.prototype.getMaxScale = function() {
        var r = this;
        return this.sectionIndex.reduce(function(i, l) {
          return Math.max(i, r.sections[l].scale);
        }, 0);
      }, qi.prototype.addTextSection = function(r, i) {
        this.text += r.text, this.sections.push(Nh.forText(r.scale, r.fontStack || i));
        for (var l = this.sections.length - 1, p = 0; p < r.text.length; ++p)
          this.sectionIndex.push(l);
      }, qi.prototype.addImageSection = function(r) {
        var i = r.image ? r.image.name : "";
        if (i.length !== 0) {
          var l = this.getNextImageSectionCharCode();
          l ? (this.text += String.fromCharCode(l), this.sections.push(Nh.forImage(i)), this.sectionIndex.push(this.sections.length - 1)) : at("Reached maximum number of images 6401");
        } else
          at("Can't add FormattedSection with an empty image.");
      }, qi.prototype.getNextImageSectionCharCode = function() {
        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
      };
      var Hm = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Co = {};
      function D1(r, i, l, p, y, v) {
        if (i.imageName) {
          var x = p[i.imageName];
          return x ? x.displaySize[0] * i.scale * 24 / v + y : 0;
        }
        var S = l[i.fontStack], C = S && S[r];
        return C ? C.metrics.advance * i.scale + y : 0;
      }
      function N1(r, i, l, p) {
        var y = Math.pow(r - i, 2);
        return p ? r < i ? y / 2 : 2 * y : y + Math.abs(l) * l;
      }
      function jO(r, i, l) {
        var p = 0;
        return r === 10 && (p -= 1e4), l && (p += 150), r !== 40 && r !== 65288 || (p += 50), i !== 41 && i !== 65289 || (p += 50), p;
      }
      function R1(r, i, l, p, y, v) {
        for (var x = null, S = N1(i, l, y, v), C = 0, P = p; C < P.length; C += 1) {
          var L = P[C], D = N1(i - L.x, l, y, v) + L.badness;
          D <= S && (x = L, S = D);
        }
        return { index: r, x: i, priorBreak: x, badness: S };
      }
      function c_(r, i, l, p, y, v, x) {
        if (v !== "point")
          return [];
        if (!r)
          return [];
        for (var S, C = [], P = function(he, oe, ge, we, Te, Oe) {
          for (var Ve = 0, Ke = 0; Ke < he.length(); Ke++) {
            var ot = he.getSection(Ke);
            Ve += D1(he.getCharCode(Ke), ot, we, Te, oe, Oe);
          }
          return Ve / Math.max(1, Math.ceil(Ve / ge));
        }(r, i, l, p, y, x), L = r.text.indexOf("\u200B") >= 0, D = 0, B = 0; B < r.length(); B++) {
          var j = r.getSection(B), J = r.getCharCode(B);
          if (Hm[J] || (D += D1(J, j, p, y, i, x)), B < r.length() - 1) {
            var ee = !((S = J) < 11904 || !(ct["Bopomofo Extended"](S) || ct.Bopomofo(S) || ct["CJK Compatibility Forms"](S) || ct["CJK Compatibility Ideographs"](S) || ct["CJK Compatibility"](S) || ct["CJK Radicals Supplement"](S) || ct["CJK Strokes"](S) || ct["CJK Symbols and Punctuation"](S) || ct["CJK Unified Ideographs Extension A"](S) || ct["CJK Unified Ideographs"](S) || ct["Enclosed CJK Letters and Months"](S) || ct["Halfwidth and Fullwidth Forms"](S) || ct.Hiragana(S) || ct["Ideographic Description Characters"](S) || ct["Kangxi Radicals"](S) || ct["Katakana Phonetic Extensions"](S) || ct.Katakana(S) || ct["Vertical Forms"](S) || ct["Yi Radicals"](S) || ct["Yi Syllables"](S)));
            (Co[J] || ee || j.imageName) && C.push(R1(B + 1, D, P, C, jO(J, r.getCharCode(B + 1), ee && L), !1));
          }
        }
        return function he(oe) {
          return oe ? he(oe.priorBreak).concat(oe.index) : [];
        }(R1(r.length(), D, P, C, 0, !0));
      }
      function h_(r) {
        var i = 0.5, l = 0.5;
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            i = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            i = 0;
        }
        switch (r) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            l = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            l = 0;
        }
        return { horizontalAlign: i, verticalAlign: l };
      }
      function GO(r, i, l, p, y) {
        if (p || y)
          for (var v = r[l], x = (r[l].x + v.metrics.advance * v.scale) * p, S = i; S <= l; S++)
            r[S].x -= x, r[S].y += y;
      }
      function z1(r, i, l, p, y, v) {
        var x, S = r.image;
        if (S.content) {
          var C = S.content, P = S.pixelRatio || 1;
          x = [C[0] / P, C[1] / P, S.displaySize[0] - C[2] / P, S.displaySize[1] - C[3] / P];
        }
        var L, D, B, j, J = i.left * v, ee = i.right * v;
        l === "width" || l === "both" ? (j = y[0] + J - p[3], D = y[0] + ee + p[1]) : D = (j = y[0] + (J + ee - S.displaySize[0]) / 2) + S.displaySize[0];
        var he = i.top * v, oe = i.bottom * v;
        return l === "height" || l === "both" ? (L = y[1] + he - p[0], B = y[1] + oe + p[2]) : B = (L = y[1] + (he + oe - S.displaySize[1]) / 2) + S.displaySize[1], { image: S, top: L, right: D, bottom: B, left: j, collisionPadding: x };
      }
      Co[10] = !0, Co[32] = !0, Co[38] = !0, Co[40] = !0, Co[41] = !0, Co[43] = !0, Co[45] = !0, Co[47] = !0, Co[173] = !0, Co[183] = !0, Co[8203] = !0, Co[8208] = !0, Co[8211] = !0, Co[8231] = !0;
      var Rh = function(r) {
        function i(l, p, y, v) {
          r.call(this, l, p), this.angle = y, v !== void 0 && (this.segment = v);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.clone = function() {
          return new i(this.x, this.y, this.angle, this.segment);
        }, i;
      }(T);
      function f_(r, i) {
        var l = i.expression;
        if (l.kind === "constant")
          return { kind: "constant", layoutSize: l.evaluate(new mr(r + 1)) };
        if (l.kind === "source")
          return { kind: "source" };
        for (var p = l.zoomStops, y = l.interpolationType, v = 0; v < p.length && p[v] <= r; )
          v++;
        for (var x = v = Math.max(0, v - 1); x < p.length && p[x] < r + 1; )
          x++;
        x = Math.min(p.length - 1, x);
        var S = p[v], C = p[x];
        return l.kind === "composite" ? { kind: "composite", minZoom: S, maxZoom: C, interpolationType: y } : { kind: "camera", minZoom: S, maxZoom: C, minSize: l.evaluate(new mr(S)), maxSize: l.evaluate(new mr(C)), interpolationType: y };
      }
      function F1(r, i, l) {
        var p = i.uSize, y = l.lowerSize;
        return r.kind === "source" ? y / 128 : r.kind === "composite" ? jn(y / 128, l.upperSize / 128, i.uSizeT) : p;
      }
      function B1(r, i) {
        var l = 0, p = 0;
        if (r.kind === "constant")
          p = r.layoutSize;
        else if (r.kind !== "source") {
          var y = r.interpolationType, v = y ? q(Ti.interpolationFactor(y, i, r.minZoom, r.maxZoom), 0, 1) : 0;
          r.kind === "camera" ? p = jn(r.minSize, r.maxSize, v) : l = v;
        }
        return { uSizeT: l, uSize: p };
      }
      wt("Anchor", Rh);
      var $O = Object.freeze({ __proto__: null, getSizeData: f_, evaluateSizeForFeature: F1, evaluateSizeForZoom: B1, SIZE_PACK_FACTOR: 128 });
      function V1(r, i, l, p, y) {
        if (i.segment === void 0)
          return !0;
        for (var v = i, x = i.segment + 1, S = 0; S > -l / 2; ) {
          if (--x < 0)
            return !1;
          S -= r[x].dist(v), v = r[x];
        }
        S += r[x].dist(r[x + 1]), x++;
        for (var C = [], P = 0; S < l / 2; ) {
          var L = r[x], D = r[x + 1];
          if (!D)
            return !1;
          var B = r[x - 1].angleTo(L) - L.angleTo(D);
          for (B = Math.abs((B + 3 * Math.PI) % (2 * Math.PI) - Math.PI), C.push({ distance: S, angleDelta: B }), P += B; S - C[0].distance > p; )
            P -= C.shift().angleDelta;
          if (P > y)
            return !1;
          x++, S += L.dist(D);
        }
        return !0;
      }
      function U1(r) {
        for (var i = 0, l = 0; l < r.length - 1; l++)
          i += r[l].dist(r[l + 1]);
        return i;
      }
      function j1(r, i, l) {
        return r ? 0.6 * i * l : 0;
      }
      function G1(r, i) {
        return Math.max(r ? r.right - r.left : 0, i ? i.right - i.left : 0);
      }
      function qO(r, i, l, p, y, v) {
        for (var x = j1(l, y, v), S = G1(l, p) * v, C = 0, P = U1(r) / 2, L = 0; L < r.length - 1; L++) {
          var D = r[L], B = r[L + 1], j = D.dist(B);
          if (C + j > P) {
            var J = (P - C) / j, ee = jn(D.x, B.x, J), he = jn(D.y, B.y, J), oe = new Rh(ee, he, B.angleTo(D), L);
            return oe._round(), !x || V1(r, oe, S, x, i) ? oe : void 0;
          }
          C += j;
        }
      }
      function WO(r, i, l, p, y, v, x, S, C) {
        var P = j1(p, v, x), L = G1(p, y), D = L * x, B = r[0].x === 0 || r[0].x === C || r[0].y === 0 || r[0].y === C;
        return i - D < i / 4 && (i = D + i / 4), function j(J, ee, he, oe, ge, we, Te, Oe, Ve) {
          for (var Ke = we / 2, ot = U1(J), Pt = 0, dt = ee - he, Rt = [], yt = 0; yt < J.length - 1; yt++) {
            for (var sr = J[yt], $t = J[yt + 1], Mt = sr.dist($t), fr = $t.angleTo(sr); dt + he < Pt + Mt; ) {
              var rr = ((dt += he) - Pt) / Mt, Tr = jn(sr.x, $t.x, rr), zt = jn(sr.y, $t.y, rr);
              if (Tr >= 0 && Tr < Ve && zt >= 0 && zt < Ve && dt - Ke >= 0 && dt + Ke <= ot) {
                var Lr = new Rh(Tr, zt, fr, yt);
                Lr._round(), oe && !V1(J, Lr, we, oe, ge) || Rt.push(Lr);
              }
            }
            Pt += Mt;
          }
          return Oe || Rt.length || Te || (Rt = j(J, Pt / 2, he, oe, ge, we, Te, !0, Ve)), Rt;
        }(r, B ? i / 2 * S % i : (L / 2 + 2 * v) * x * S % i, i, P, l, D, B, !1, C);
      }
      function $1(r, i, l, p, y) {
        for (var v = [], x = 0; x < r.length; x++)
          for (var S = r[x], C = void 0, P = 0; P < S.length - 1; P++) {
            var L = S[P], D = S[P + 1];
            L.x < i && D.x < i || (L.x < i ? L = new T(i, L.y + (i - L.x) / (D.x - L.x) * (D.y - L.y))._round() : D.x < i && (D = new T(i, L.y + (i - L.x) / (D.x - L.x) * (D.y - L.y))._round()), L.y < l && D.y < l || (L.y < l ? L = new T(L.x + (l - L.y) / (D.y - L.y) * (D.x - L.x), l)._round() : D.y < l && (D = new T(L.x + (l - L.y) / (D.y - L.y) * (D.x - L.x), l)._round()), L.x >= p && D.x >= p || (L.x >= p ? L = new T(p, L.y + (p - L.x) / (D.x - L.x) * (D.y - L.y))._round() : D.x >= p && (D = new T(p, L.y + (p - L.x) / (D.x - L.x) * (D.y - L.y))._round()), L.y >= y && D.y >= y || (L.y >= y ? L = new T(L.x + (y - L.y) / (D.y - L.y) * (D.x - L.x), y)._round() : D.y >= y && (D = new T(L.x + (y - L.y) / (D.y - L.y) * (D.x - L.x), y)._round()), C && L.equals(C[C.length - 1]) || v.push(C = [L]), C.push(D)))));
          }
        return v;
      }
      function q1(r, i, l, p) {
        var y = [], v = r.image, x = v.pixelRatio, S = v.paddedRect.w - 2, C = v.paddedRect.h - 2, P = r.right - r.left, L = r.bottom - r.top, D = v.stretchX || [[0, S]], B = v.stretchY || [[0, C]], j = function(Tr, zt) {
          return Tr + zt[1] - zt[0];
        }, J = D.reduce(j, 0), ee = B.reduce(j, 0), he = S - J, oe = C - ee, ge = 0, we = J, Te = 0, Oe = ee, Ve = 0, Ke = he, ot = 0, Pt = oe;
        if (v.content && p) {
          var dt = v.content;
          ge = Zm(D, 0, dt[0]), Te = Zm(B, 0, dt[1]), we = Zm(D, dt[0], dt[2]), Oe = Zm(B, dt[1], dt[3]), Ve = dt[0] - ge, ot = dt[1] - Te, Ke = dt[2] - dt[0] - we, Pt = dt[3] - dt[1] - Oe;
        }
        var Rt = function(Tr, zt, Lr, vn) {
          var Cn = Xm(Tr.stretch - ge, we, P, r.left), In = Km(Tr.fixed - Ve, Ke, Tr.stretch, J), _n = Xm(zt.stretch - Te, Oe, L, r.top), Pn = Km(zt.fixed - ot, Pt, zt.stretch, ee), ci = Xm(Lr.stretch - ge, we, P, r.left), hi = Km(Lr.fixed - Ve, Ke, Lr.stretch, J), Wi = Xm(vn.stretch - Te, Oe, L, r.top), xi = Km(vn.fixed - ot, Pt, vn.stretch, ee), Hi = new T(Cn, _n), Nn = new T(ci, _n), bi = new T(ci, Wi), vr = new T(Cn, Wi), Xr = new T(In / x, Pn / x), qr = new T(hi / x, xi / x), Or = i * Math.PI / 180;
          if (Or) {
            var ro = Math.sin(Or), Di = Math.cos(Or), ln = [Di, -ro, ro, Di];
            Hi._matMult(ln), Nn._matMult(ln), vr._matMult(ln), bi._matMult(ln);
          }
          var $n = Tr.stretch + Tr.fixed, Ni = zt.stretch + zt.fixed;
          return { tl: Hi, tr: Nn, bl: vr, br: bi, tex: { x: v.paddedRect.x + 1 + $n, y: v.paddedRect.y + 1 + Ni, w: Lr.stretch + Lr.fixed - $n, h: vn.stretch + vn.fixed - Ni }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Xr, pixelOffsetBR: qr, minFontScaleX: Ke / x / P, minFontScaleY: Pt / x / L, isSDF: l };
        };
        if (p && (v.stretchX || v.stretchY))
          for (var yt = W1(D, he, J), sr = W1(B, oe, ee), $t = 0; $t < yt.length - 1; $t++)
            for (var Mt = yt[$t], fr = yt[$t + 1], rr = 0; rr < sr.length - 1; rr++)
              y.push(Rt(Mt, sr[rr], fr, sr[rr + 1]));
        else
          y.push(Rt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: S + 1 }, { fixed: 0, stretch: C + 1 }));
        return y;
      }
      function Zm(r, i, l) {
        for (var p = 0, y = 0, v = r; y < v.length; y += 1) {
          var x = v[y];
          p += Math.max(i, Math.min(l, x[1])) - Math.max(i, Math.min(l, x[0]));
        }
        return p;
      }
      function W1(r, i, l) {
        for (var p = [{ fixed: -1, stretch: 0 }], y = 0, v = r; y < v.length; y += 1) {
          var x = v[y], S = x[0], C = x[1], P = p[p.length - 1];
          p.push({ fixed: S - P.stretch, stretch: P.stretch }), p.push({ fixed: S - P.stretch, stretch: P.stretch + (C - S) });
        }
        return p.push({ fixed: i + 1, stretch: l }), p;
      }
      function Xm(r, i, l, p) {
        return r / i * l + p;
      }
      function Km(r, i, l, p) {
        return r - i * l / p;
      }
      var Ym = function(r, i, l, p, y, v, x, S, C, P) {
        if (this.boxStartIndex = r.length, C) {
          var L = v.top, D = v.bottom, B = v.collisionPadding;
          B && (L -= B[1], D += B[3]);
          var j = D - L;
          j > 0 && (j = Math.max(10, j), this.circleDiameter = j);
        } else {
          var J = v.top * x - S, ee = v.bottom * x + S, he = v.left * x - S, oe = v.right * x + S, ge = v.collisionPadding;
          if (ge && (he -= ge[0] * x, J -= ge[1] * x, oe += ge[2] * x, ee += ge[3] * x), P) {
            var we = new T(he, J), Te = new T(oe, J), Oe = new T(he, ee), Ve = new T(oe, ee), Ke = P * Math.PI / 180;
            we._rotate(Ke), Te._rotate(Ke), Oe._rotate(Ke), Ve._rotate(Ke), he = Math.min(we.x, Te.x, Oe.x, Ve.x), oe = Math.max(we.x, Te.x, Oe.x, Ve.x), J = Math.min(we.y, Te.y, Oe.y, Ve.y), ee = Math.max(we.y, Te.y, Oe.y, Ve.y);
          }
          r.emplaceBack(i.x, i.y, he, J, oe, ee, l, p, y);
        }
        this.boxEndIndex = r.length;
      }, zh = function(r, i) {
        if (r === void 0 && (r = []), i === void 0 && (i = HO), this.data = r, this.length = this.data.length, this.compare = i, this.length > 0)
          for (var l = (this.length >> 1) - 1; l >= 0; l--)
            this._down(l);
      };
      function HO(r, i) {
        return r < i ? -1 : r > i ? 1 : 0;
      }
      function ZO(r, i, l) {
        i === void 0 && (i = 1), l === void 0 && (l = !1);
        for (var p = 1 / 0, y = 1 / 0, v = -1 / 0, x = -1 / 0, S = r[0], C = 0; C < S.length; C++) {
          var P = S[C];
          (!C || P.x < p) && (p = P.x), (!C || P.y < y) && (y = P.y), (!C || P.x > v) && (v = P.x), (!C || P.y > x) && (x = P.y);
        }
        var L = Math.min(v - p, x - y), D = L / 2, B = new zh([], XO);
        if (L === 0)
          return new T(p, y);
        for (var j = p; j < v; j += L)
          for (var J = y; J < x; J += L)
            B.push(new Fh(j + D, J + D, D, r));
        for (var ee = function(ge) {
          for (var we = 0, Te = 0, Oe = 0, Ve = ge[0], Ke = 0, ot = Ve.length, Pt = ot - 1; Ke < ot; Pt = Ke++) {
            var dt = Ve[Ke], Rt = Ve[Pt], yt = dt.x * Rt.y - Rt.x * dt.y;
            Te += (dt.x + Rt.x) * yt, Oe += (dt.y + Rt.y) * yt, we += 3 * yt;
          }
          return new Fh(Te / we, Oe / we, 0, ge);
        }(r), he = B.length; B.length; ) {
          var oe = B.pop();
          (oe.d > ee.d || !ee.d) && (ee = oe, l && console.log("found best %d after %d probes", Math.round(1e4 * oe.d) / 1e4, he)), oe.max - ee.d <= i || (B.push(new Fh(oe.p.x - (D = oe.h / 2), oe.p.y - D, D, r)), B.push(new Fh(oe.p.x + D, oe.p.y - D, D, r)), B.push(new Fh(oe.p.x - D, oe.p.y + D, D, r)), B.push(new Fh(oe.p.x + D, oe.p.y + D, D, r)), he += 4);
        }
        return l && (console.log("num probes: " + he), console.log("best distance: " + ee.d)), ee.p;
      }
      function XO(r, i) {
        return i.max - r.max;
      }
      function Fh(r, i, l, p) {
        this.p = new T(r, i), this.h = l, this.d = function(y, v) {
          for (var x = !1, S = 1 / 0, C = 0; C < v.length; C++)
            for (var P = v[C], L = 0, D = P.length, B = D - 1; L < D; B = L++) {
              var j = P[L], J = P[B];
              j.y > y.y != J.y > y.y && y.x < (J.x - j.x) * (y.y - j.y) / (J.y - j.y) + j.x && (x = !x), S = Math.min(S, lu(y, j, J));
            }
          return (x ? 1 : -1) * Math.sqrt(S);
        }(this.p, p), this.max = this.d + this.h * Math.SQRT2;
      }
      zh.prototype.push = function(r) {
        this.data.push(r), this.length++, this._up(this.length - 1);
      }, zh.prototype.pop = function() {
        if (this.length !== 0) {
          var r = this.data[0], i = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = i, this._down(0)), r;
        }
      }, zh.prototype.peek = function() {
        return this.data[0];
      }, zh.prototype._up = function(r) {
        for (var i = this.data, l = this.compare, p = i[r]; r > 0; ) {
          var y = r - 1 >> 1, v = i[y];
          if (l(p, v) >= 0)
            break;
          i[r] = v, r = y;
        }
        i[r] = p;
      }, zh.prototype._down = function(r) {
        for (var i = this.data, l = this.compare, p = this.length >> 1, y = i[r]; r < p; ) {
          var v = 1 + (r << 1), x = i[v], S = v + 1;
          if (S < this.length && l(i[S], x) < 0 && (v = S, x = i[S]), l(x, y) >= 0)
            break;
          i[r] = x, r = v;
        }
        i[r] = y;
      };
      var p_ = Number.POSITIVE_INFINITY;
      function H1(r, i) {
        return i[1] !== p_ ? function(l, p, y) {
          var v = 0, x = 0;
          switch (p = Math.abs(p), y = Math.abs(y), l) {
            case "top-right":
            case "top-left":
            case "top":
              x = y - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              x = 7 - y;
          }
          switch (l) {
            case "top-right":
            case "bottom-right":
            case "right":
              v = -p;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              v = p;
          }
          return [v, x];
        }(r, i[0], i[1]) : function(l, p) {
          var y = 0, v = 0;
          p < 0 && (p = 0);
          var x = p / Math.sqrt(2);
          switch (l) {
            case "top-right":
            case "top-left":
              v = x - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              v = 7 - x;
              break;
            case "bottom":
              v = 7 - p;
              break;
            case "top":
              v = p - 7;
          }
          switch (l) {
            case "top-right":
            case "bottom-right":
              y = -x;
              break;
            case "top-left":
            case "bottom-left":
              y = x;
              break;
            case "left":
              y = p;
              break;
            case "right":
              y = -p;
          }
          return [y, v];
        }(r, i[0]);
      }
      function d_(r) {
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function Z1(r, i, l, p, y, v, x, S, C, P, L, D, B, j, J) {
        var ee = function(Te, Oe, Ve, Ke, ot, Pt, dt, Rt) {
          for (var yt = Ke.layout.get("text-rotate").evaluate(Pt, {}) * Math.PI / 180, sr = [], $t = 0, Mt = Oe.positionedLines; $t < Mt.length; $t += 1)
            for (var fr = Mt[$t], rr = 0, Tr = fr.positionedGlyphs; rr < Tr.length; rr += 1) {
              var zt = Tr[rr];
              if (zt.rect) {
                var Lr = zt.rect || {}, vn = 4, Cn = !0, In = 1, _n = 0, Pn = (ot || Rt) && zt.vertical, ci = zt.metrics.advance * zt.scale / 2;
                if (Rt && Oe.verticalizable && (_n = fr.lineOffset / 2 - (zt.imageName ? -(24 - zt.metrics.width * zt.scale) / 2 : 24 * (zt.scale - 1))), zt.imageName) {
                  var hi = dt[zt.imageName];
                  Cn = hi.sdf, vn = 1 / (In = hi.pixelRatio);
                }
                var Wi = ot ? [zt.x + ci, zt.y] : [0, 0], xi = ot ? [0, 0] : [zt.x + ci + Ve[0], zt.y + Ve[1] - _n], Hi = [0, 0];
                Pn && (Hi = xi, xi = [0, 0]);
                var Nn = (zt.metrics.left - vn) * zt.scale - ci + xi[0], bi = (-zt.metrics.top - vn) * zt.scale + xi[1], vr = Nn + Lr.w * zt.scale / In, Xr = bi + Lr.h * zt.scale / In, qr = new T(Nn, bi), Or = new T(vr, bi), ro = new T(Nn, Xr), Di = new T(vr, Xr);
                if (Pn) {
                  var ln = new T(-ci, ci - -17), $n = -Math.PI / 2, Ni = 12 - ci, Dr = new T(22 - Ni, -(zt.imageName ? Ni : 0)), Ps = new (Function.prototype.bind.apply(T, [null].concat(Hi)))();
                  qr._rotateAround($n, ln)._add(Dr)._add(Ps), Or._rotateAround($n, ln)._add(Dr)._add(Ps), ro._rotateAround($n, ln)._add(Dr)._add(Ps), Di._rotateAround($n, ln)._add(Dr)._add(Ps);
                }
                if (yt) {
                  var Ko = Math.sin(yt), As = Math.cos(yt), Rn = [As, -Ko, Ko, As];
                  qr._matMult(Rn), Or._matMult(Rn), ro._matMult(Rn), Di._matMult(Rn);
                }
                var ks = new T(0, 0), Ma = new T(0, 0);
                sr.push({ tl: qr, tr: Or, bl: ro, br: Di, tex: Lr, writingMode: Oe.writingMode, glyphOffset: Wi, sectionIndex: zt.sectionIndex, isSDF: Cn, pixelOffsetTL: ks, pixelOffsetBR: Ma, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
          return sr;
        }(0, l, S, y, v, x, p, r.allowVerticalPlacement), he = r.textSizeData, oe = null;
        he.kind === "source" ? (oe = [128 * y.layout.get("text-size").evaluate(x, {})])[0] > 32640 && at(r.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".') : he.kind === "composite" && ((oe = [128 * j.compositeTextSizes[0].evaluate(x, {}, J), 128 * j.compositeTextSizes[1].evaluate(x, {}, J)])[0] > 32640 || oe[1] > 32640) && at(r.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".'), r.addSymbols(r.text, ee, oe, S, v, x, P, i, C.lineStartIndex, C.lineLength, B, J);
        for (var ge = 0, we = L; ge < we.length; ge += 1)
          D[we[ge]] = r.text.placedSymbolArray.length - 1;
        return 4 * ee.length;
      }
      function X1(r) {
        for (var i in r)
          return r[i];
        return null;
      }
      function KO(r, i, l, p) {
        var y = r.compareText;
        if (i in y) {
          for (var v = y[i], x = v.length - 1; x >= 0; x--)
            if (p.dist(v[x]) < l)
              return !0;
        } else
          y[i] = [];
        return y[i].push(p), !1;
      }
      var YO = kh.VectorTileFeature.types, JO = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Jm(r, i, l, p, y, v, x, S, C, P, L, D, B) {
        var j = S ? Math.min(32640, Math.round(S[0])) : 0, J = S ? Math.min(32640, Math.round(S[1])) : 0;
        r.emplaceBack(i, l, Math.round(32 * p), Math.round(32 * y), v, x, (j << 1) + (C ? 1 : 0), J, 16 * P, 16 * L, 256 * D, 256 * B);
      }
      function m_(r, i, l) {
        r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l), r.emplaceBack(i.x, i.y, l);
      }
      function QO(r) {
        for (var i = 0, l = r.sections; i < l.length; i += 1)
          if (bh(l[i].text))
            return !0;
        return !1;
      }
      var Bh = function(r) {
        this.layoutVertexArray = new Th(), this.indexArray = new Ss(), this.programConfigurations = r, this.segments = new W(), this.dynamicLayoutVertexArray = new ou(), this.opacityVertexArray = new fc(), this.placedSymbolArray = new d();
      };
      Bh.prototype.isEmpty = function() {
        return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
      }, Bh.prototype.upload = function(r, i, l, p) {
        this.isEmpty() || (l && (this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, TO.members), this.indexBuffer = r.createIndexBuffer(this.indexArray, i), this.dynamicLayoutVertexBuffer = r.createVertexBuffer(this.dynamicLayoutVertexArray, MO.members, !0), this.opacityVertexBuffer = r.createVertexBuffer(this.opacityVertexArray, JO, !0), this.opacityVertexBuffer.itemSize = 1), (l || p) && this.programConfigurations.upload(r));
      }, Bh.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
      }, wt("SymbolBuffers", Bh);
      var Mp = function(r, i, l) {
        this.layoutVertexArray = new r(), this.layoutAttributes = i, this.indexArray = new l(), this.segments = new W(), this.collisionVertexArray = new dp();
      };
      Mp.prototype.upload = function(r) {
        this.layoutVertexBuffer = r.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = r.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = r.createVertexBuffer(this.collisionVertexArray, IO.members, !0);
      }, Mp.prototype.destroy = function() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
      }, wt("CollisionBuffers", Mp);
      var Wr = function(r) {
        this.collisionBoxArray = r.collisionBoxArray, this.zoom = r.zoom, this.overscaling = r.overscaling, this.layers = r.layers, this.layerIds = this.layers.map(function(v) {
          return v.id;
        }), this.index = r.index, this.pixelRatio = r.pixelRatio, this.sourceLayerIndex = r.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Oo([]), this.placementViewportMatrix = Oo([]);
        var i = this.layers[0]._unevaluatedLayout._values;
        this.textSizeData = f_(this.zoom, i["text-size"]), this.iconSizeData = f_(this.zoom, i["icon-size"]);
        var l = this.layers[0].layout, p = l.get("symbol-sort-key"), y = l.get("symbol-z-order");
        this.canOverlap = l.get("text-allow-overlap") || l.get("icon-allow-overlap") || l.get("text-ignore-placement") || l.get("icon-ignore-placement"), this.sortFeaturesByKey = y !== "viewport-y" && p.constantOr(1) !== void 0, this.sortFeaturesByY = (y === "viewport-y" || y === "auto" && !this.sortFeaturesByKey) && this.canOverlap, l.get("symbol-placement") === "point" && (this.writingModes = l.get("text-writing-mode").map(function(v) {
          return Xo[v];
        })), this.stateDependentLayerIds = this.layers.filter(function(v) {
          return v.isStateDependent();
        }).map(function(v) {
          return v.id;
        }), this.sourceID = r.sourceID;
      };
      Wr.prototype.createArrays = function() {
        this.text = new Bh(new Gt(this.layers, this.zoom, function(r) {
          return /^text/.test(r);
        })), this.icon = new Bh(new Gt(this.layers, this.zoom, function(r) {
          return /^icon/.test(r);
        })), this.glyphOffsetArray = new E(), this.lineVertexArray = new O(), this.symbolInstances = new w();
      }, Wr.prototype.calculateGlyphDependencies = function(r, i, l, p, y) {
        for (var v = 0; v < r.length; v++)
          if (i[r.charCodeAt(v)] = !0, (l || p) && y) {
            var x = Ep[r.charAt(v)];
            x && (i[x.charCodeAt(0)] = !0);
          }
      }, Wr.prototype.populate = function(r, i, l) {
        var p = this.layers[0], y = p.layout, v = y.get("text-font"), x = y.get("text-field"), S = y.get("icon-image"), C = (x.value.kind !== "constant" || x.value.value instanceof mi && !x.value.value.isEmpty() || x.value.value.toString().length > 0) && (v.value.kind !== "constant" || v.value.value.length > 0), P = S.value.kind !== "constant" || !!S.value.value || Object.keys(S.parameters).length > 0, L = y.get("symbol-sort-key");
        if (this.features = [], C || P) {
          for (var D = i.iconDependencies, B = i.glyphDependencies, j = i.availableImages, J = new mr(this.zoom), ee = 0, he = r; ee < he.length; ee += 1) {
            var oe = he[ee], ge = oe.feature, we = oe.id, Te = oe.index, Oe = oe.sourceLayerIndex, Ve = p._featureFilter.needGeometry, Ke = Dn(ge, Ve);
            if (p._featureFilter.filter(J, Ke, l)) {
              Ve || (Ke.geometry = Mn(ge));
              var ot = void 0;
              if (C) {
                var Pt = p.getValueAndResolveTokens("text-field", Ke, l, j), dt = mi.factory(Pt);
                QO(dt) && (this.hasRTLText = !0), (!this.hasRTLText || cp() === "unavailable" || this.hasRTLText && Io.isParsed()) && (ot = CO(dt, p, Ke));
              }
              var Rt = void 0;
              if (P) {
                var yt = p.getValueAndResolveTokens("icon-image", Ke, l, j);
                Rt = yt instanceof Ji ? yt : Ji.fromString(yt);
              }
              if (ot || Rt) {
                var sr = this.sortFeaturesByKey ? L.evaluate(Ke, {}, l) : void 0;
                if (this.features.push({ id: we, text: ot, icon: Rt, index: Te, sourceLayerIndex: Oe, geometry: Ke.geometry, properties: ge.properties, type: YO[ge.type], sortKey: sr }), Rt && (D[Rt.name] = !0), ot) {
                  var $t = v.evaluate(Ke, {}, l).join(","), Mt = y.get("text-rotation-alignment") === "map" && y.get("symbol-placement") !== "point";
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Xo.vertical) >= 0;
                  for (var fr = 0, rr = ot.sections; fr < rr.length; fr += 1) {
                    var Tr = rr[fr];
                    if (Tr.image)
                      D[Tr.image.name] = !0;
                    else {
                      var zt = sp(ot.toString()), Lr = Tr.fontStack || $t, vn = B[Lr] = B[Lr] || {};
                      this.calculateGlyphDependencies(Tr.text, vn, Mt, this.allowVerticalPlacement, zt);
                    }
                  }
                }
              }
            }
          }
          y.get("symbol-placement") === "line" && (this.features = function(Cn) {
            var In = {}, _n = {}, Pn = [], ci = 0;
            function hi(ln) {
              Pn.push(Cn[ln]), ci++;
            }
            function Wi(ln, $n, Ni) {
              var Dr = _n[ln];
              return delete _n[ln], _n[$n] = Dr, Pn[Dr].geometry[0].pop(), Pn[Dr].geometry[0] = Pn[Dr].geometry[0].concat(Ni[0]), Dr;
            }
            function xi(ln, $n, Ni) {
              var Dr = In[$n];
              return delete In[$n], In[ln] = Dr, Pn[Dr].geometry[0].shift(), Pn[Dr].geometry[0] = Ni[0].concat(Pn[Dr].geometry[0]), Dr;
            }
            function Hi(ln, $n, Ni) {
              var Dr = Ni ? $n[0][$n[0].length - 1] : $n[0][0];
              return ln + ":" + Dr.x + ":" + Dr.y;
            }
            for (var Nn = 0; Nn < Cn.length; Nn++) {
              var bi = Cn[Nn], vr = bi.geometry, Xr = bi.text ? bi.text.toString() : null;
              if (Xr) {
                var qr = Hi(Xr, vr), Or = Hi(Xr, vr, !0);
                if (qr in _n && Or in In && _n[qr] !== In[Or]) {
                  var ro = xi(qr, Or, vr), Di = Wi(qr, Or, Pn[ro].geometry);
                  delete In[qr], delete _n[Or], _n[Hi(Xr, Pn[Di].geometry, !0)] = Di, Pn[ro].geometry = null;
                } else
                  qr in _n ? Wi(qr, Or, vr) : Or in In ? xi(qr, Or, vr) : (hi(Nn), In[qr] = ci - 1, _n[Or] = ci - 1);
              } else
                hi(Nn);
            }
            return Pn.filter(function(ln) {
              return ln.geometry;
            });
          }(this.features)), this.sortFeaturesByKey && this.features.sort(function(Cn, In) {
            return Cn.sortKey - In.sortKey;
          });
        }
      }, Wr.prototype.update = function(r, i, l) {
        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(r, i, this.layers, l), this.icon.programConfigurations.updatePaintArrays(r, i, this.layers, l));
      }, Wr.prototype.isEmpty = function() {
        return this.symbolInstances.length === 0 && !this.hasRTLText;
      }, Wr.prototype.uploadPending = function() {
        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
      }, Wr.prototype.upload = function(r) {
        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(r), this.iconCollisionBox.upload(r)), this.text.upload(r, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(r, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
      }, Wr.prototype.destroyDebugData = function() {
        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
      }, Wr.prototype.destroy = function() {
        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
      }, Wr.prototype.addToLineVertexArray = function(r, i) {
        var l = this.lineVertexArray.length;
        if (r.segment !== void 0) {
          for (var p = r.dist(i[r.segment + 1]), y = r.dist(i[r.segment]), v = {}, x = r.segment + 1; x < i.length; x++)
            v[x] = { x: i[x].x, y: i[x].y, tileUnitDistanceFromAnchor: p }, x < i.length - 1 && (p += i[x + 1].dist(i[x]));
          for (var S = r.segment || 0; S >= 0; S--)
            v[S] = { x: i[S].x, y: i[S].y, tileUnitDistanceFromAnchor: y }, S > 0 && (y += i[S - 1].dist(i[S]));
          for (var C = 0; C < i.length; C++) {
            var P = v[C];
            this.lineVertexArray.emplaceBack(P.x, P.y, P.tileUnitDistanceFromAnchor);
          }
        }
        return { lineStartIndex: l, lineLength: this.lineVertexArray.length - l };
      }, Wr.prototype.addSymbols = function(r, i, l, p, y, v, x, S, C, P, L, D) {
        for (var B = r.indexArray, j = r.layoutVertexArray, J = r.segments.prepareSegment(4 * i.length, j, B, this.canOverlap ? v.sortKey : void 0), ee = this.glyphOffsetArray.length, he = J.vertexLength, oe = this.allowVerticalPlacement && x === Xo.vertical ? Math.PI / 2 : 0, ge = v.text && v.text.sections, we = 0; we < i.length; we++) {
          var Te = i[we], Oe = Te.tl, Ve = Te.tr, Ke = Te.bl, ot = Te.br, Pt = Te.tex, dt = Te.pixelOffsetTL, Rt = Te.pixelOffsetBR, yt = Te.minFontScaleX, sr = Te.minFontScaleY, $t = Te.glyphOffset, Mt = Te.isSDF, fr = Te.sectionIndex, rr = J.vertexLength, Tr = $t[1];
          Jm(j, S.x, S.y, Oe.x, Tr + Oe.y, Pt.x, Pt.y, l, Mt, dt.x, dt.y, yt, sr), Jm(j, S.x, S.y, Ve.x, Tr + Ve.y, Pt.x + Pt.w, Pt.y, l, Mt, Rt.x, dt.y, yt, sr), Jm(j, S.x, S.y, Ke.x, Tr + Ke.y, Pt.x, Pt.y + Pt.h, l, Mt, dt.x, Rt.y, yt, sr), Jm(j, S.x, S.y, ot.x, Tr + ot.y, Pt.x + Pt.w, Pt.y + Pt.h, l, Mt, Rt.x, Rt.y, yt, sr), m_(r.dynamicLayoutVertexArray, S, oe), B.emplaceBack(rr, rr + 1, rr + 2), B.emplaceBack(rr + 1, rr + 2, rr + 3), J.vertexLength += 4, J.primitiveLength += 2, this.glyphOffsetArray.emplaceBack($t[0]), we !== i.length - 1 && fr === i[we + 1].sectionIndex || r.programConfigurations.populatePaintArrays(j.length, v, v.index, {}, D, ge && ge[fr]);
        }
        r.placedSymbolArray.emplaceBack(S.x, S.y, ee, this.glyphOffsetArray.length - ee, he, C, P, S.segment, l ? l[0] : 0, l ? l[1] : 0, p[0], p[1], x, 0, !1, 0, L);
      }, Wr.prototype._addCollisionDebugVertex = function(r, i, l, p, y, v) {
        return i.emplaceBack(0, 0), r.emplaceBack(l.x, l.y, p, y, Math.round(v.x), Math.round(v.y));
      }, Wr.prototype.addCollisionDebugVertices = function(r, i, l, p, y, v, x) {
        var S = y.segments.prepareSegment(4, y.layoutVertexArray, y.indexArray), C = S.vertexLength, P = y.layoutVertexArray, L = y.collisionVertexArray, D = x.anchorX, B = x.anchorY;
        this._addCollisionDebugVertex(P, L, v, D, B, new T(r, i)), this._addCollisionDebugVertex(P, L, v, D, B, new T(l, i)), this._addCollisionDebugVertex(P, L, v, D, B, new T(l, p)), this._addCollisionDebugVertex(P, L, v, D, B, new T(r, p)), S.vertexLength += 4;
        var j = y.indexArray;
        j.emplaceBack(C, C + 1), j.emplaceBack(C + 1, C + 2), j.emplaceBack(C + 2, C + 3), j.emplaceBack(C + 3, C), S.primitiveLength += 4;
      }, Wr.prototype.addDebugCollisionBoxes = function(r, i, l, p) {
        for (var y = r; y < i; y++) {
          var v = this.collisionBoxArray.get(y);
          this.addCollisionDebugVertices(v.x1, v.y1, v.x2, v.y2, p ? this.textCollisionBox : this.iconCollisionBox, v.anchorPoint, l);
        }
      }, Wr.prototype.generateCollisionDebugBuffers = function() {
        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Mp(au, I1.members, pc), this.iconCollisionBox = new Mp(au, I1.members, pc);
        for (var r = 0; r < this.symbolInstances.length; r++) {
          var i = this.symbolInstances.get(r);
          this.addDebugCollisionBoxes(i.textBoxStartIndex, i.textBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.iconBoxStartIndex, i.iconBoxEndIndex, i, !1), this.addDebugCollisionBoxes(i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex, i, !1);
        }
      }, Wr.prototype._deserializeCollisionBoxesForSymbol = function(r, i, l, p, y, v, x, S, C) {
        for (var P = {}, L = i; L < l; L++) {
          var D = r.get(L);
          P.textBox = { x1: D.x1, y1: D.y1, x2: D.x2, y2: D.y2, anchorPointX: D.anchorPointX, anchorPointY: D.anchorPointY }, P.textFeatureIndex = D.featureIndex;
          break;
        }
        for (var B = p; B < y; B++) {
          var j = r.get(B);
          P.verticalTextBox = { x1: j.x1, y1: j.y1, x2: j.x2, y2: j.y2, anchorPointX: j.anchorPointX, anchorPointY: j.anchorPointY }, P.verticalTextFeatureIndex = j.featureIndex;
          break;
        }
        for (var J = v; J < x; J++) {
          var ee = r.get(J);
          P.iconBox = { x1: ee.x1, y1: ee.y1, x2: ee.x2, y2: ee.y2, anchorPointX: ee.anchorPointX, anchorPointY: ee.anchorPointY }, P.iconFeatureIndex = ee.featureIndex;
          break;
        }
        for (var he = S; he < C; he++) {
          var oe = r.get(he);
          P.verticalIconBox = { x1: oe.x1, y1: oe.y1, x2: oe.x2, y2: oe.y2, anchorPointX: oe.anchorPointX, anchorPointY: oe.anchorPointY }, P.verticalIconFeatureIndex = oe.featureIndex;
          break;
        }
        return P;
      }, Wr.prototype.deserializeCollisionBoxes = function(r) {
        this.collisionArrays = [];
        for (var i = 0; i < this.symbolInstances.length; i++) {
          var l = this.symbolInstances.get(i);
          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(r, l.textBoxStartIndex, l.textBoxEndIndex, l.verticalTextBoxStartIndex, l.verticalTextBoxEndIndex, l.iconBoxStartIndex, l.iconBoxEndIndex, l.verticalIconBoxStartIndex, l.verticalIconBoxEndIndex));
        }
      }, Wr.prototype.hasTextData = function() {
        return this.text.segments.get().length > 0;
      }, Wr.prototype.hasIconData = function() {
        return this.icon.segments.get().length > 0;
      }, Wr.prototype.hasDebugData = function() {
        return this.textCollisionBox && this.iconCollisionBox;
      }, Wr.prototype.hasTextCollisionBoxData = function() {
        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
      }, Wr.prototype.hasIconCollisionBoxData = function() {
        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
      }, Wr.prototype.addIndicesForPlacedSymbol = function(r, i) {
        for (var l = r.placedSymbolArray.get(i), p = l.vertexStartIndex + 4 * l.numGlyphs, y = l.vertexStartIndex; y < p; y += 4)
          r.indexArray.emplaceBack(y, y + 1, y + 2), r.indexArray.emplaceBack(y + 1, y + 2, y + 3);
      }, Wr.prototype.getSortedSymbolIndexes = function(r) {
        if (this.sortedAngle === r && this.symbolInstanceIndexes !== void 0)
          return this.symbolInstanceIndexes;
        for (var i = Math.sin(r), l = Math.cos(r), p = [], y = [], v = [], x = 0; x < this.symbolInstances.length; ++x) {
          v.push(x);
          var S = this.symbolInstances.get(x);
          p.push(0 | Math.round(i * S.anchorX + l * S.anchorY)), y.push(S.featureIndex);
        }
        return v.sort(function(C, P) {
          return p[C] - p[P] || y[P] - y[C];
        }), v;
      }, Wr.prototype.addToSortKeyRanges = function(r, i) {
        var l = this.sortKeyRanges[this.sortKeyRanges.length - 1];
        l && l.sortKey === i ? l.symbolInstanceEnd = r + 1 : this.sortKeyRanges.push({ sortKey: i, symbolInstanceStart: r, symbolInstanceEnd: r + 1 });
      }, Wr.prototype.sortFeatures = function(r) {
        var i = this;
        if (this.sortFeaturesByY && this.sortedAngle !== r && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(r), this.sortedAngle = r, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
          for (var l = 0, p = this.symbolInstanceIndexes; l < p.length; l += 1) {
            var y = this.symbolInstances.get(p[l]);
            this.featureSortOrder.push(y.featureIndex), [y.rightJustifiedTextSymbolIndex, y.centerJustifiedTextSymbolIndex, y.leftJustifiedTextSymbolIndex].forEach(function(v, x, S) {
              v >= 0 && S.indexOf(v) === x && i.addIndicesForPlacedSymbol(i.text, v);
            }), y.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, y.verticalPlacedTextSymbolIndex), y.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, y.placedIconSymbolIndex), y.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, y.verticalPlacedIconSymbolIndex);
          }
          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
        }
      }, wt("SymbolBucket", Wr, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Wr.MAX_GLYPHS = 65535, Wr.addDynamicAttributes = m_;
      var eC = new Ii({ "symbol-placement": new Dt(G.layout_symbol["symbol-placement"]), "symbol-spacing": new Dt(G.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Dt(G.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Tt(G.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Dt(G.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Dt(G.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Dt(G.layout_symbol["icon-ignore-placement"]), "icon-optional": new Dt(G.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Dt(G.layout_symbol["icon-rotation-alignment"]), "icon-size": new Tt(G.layout_symbol["icon-size"]), "icon-text-fit": new Dt(G.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Dt(G.layout_symbol["icon-text-fit-padding"]), "icon-image": new Tt(G.layout_symbol["icon-image"]), "icon-rotate": new Tt(G.layout_symbol["icon-rotate"]), "icon-padding": new Dt(G.layout_symbol["icon-padding"]), "icon-keep-upright": new Dt(G.layout_symbol["icon-keep-upright"]), "icon-offset": new Tt(G.layout_symbol["icon-offset"]), "icon-anchor": new Tt(G.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Dt(G.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Dt(G.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Dt(G.layout_symbol["text-rotation-alignment"]), "text-field": new Tt(G.layout_symbol["text-field"]), "text-font": new Tt(G.layout_symbol["text-font"]), "text-size": new Tt(G.layout_symbol["text-size"]), "text-max-width": new Tt(G.layout_symbol["text-max-width"]), "text-line-height": new Dt(G.layout_symbol["text-line-height"]), "text-letter-spacing": new Tt(G.layout_symbol["text-letter-spacing"]), "text-justify": new Tt(G.layout_symbol["text-justify"]), "text-radial-offset": new Tt(G.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Dt(G.layout_symbol["text-variable-anchor"]), "text-anchor": new Tt(G.layout_symbol["text-anchor"]), "text-max-angle": new Dt(G.layout_symbol["text-max-angle"]), "text-writing-mode": new Dt(G.layout_symbol["text-writing-mode"]), "text-rotate": new Tt(G.layout_symbol["text-rotate"]), "text-padding": new Dt(G.layout_symbol["text-padding"]), "text-keep-upright": new Dt(G.layout_symbol["text-keep-upright"]), "text-transform": new Tt(G.layout_symbol["text-transform"]), "text-offset": new Tt(G.layout_symbol["text-offset"]), "text-allow-overlap": new Dt(G.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Dt(G.layout_symbol["text-ignore-placement"]), "text-optional": new Dt(G.layout_symbol["text-optional"]) }), y_ = { paint: new Ii({ "icon-opacity": new Tt(G.paint_symbol["icon-opacity"]), "icon-color": new Tt(G.paint_symbol["icon-color"]), "icon-halo-color": new Tt(G.paint_symbol["icon-halo-color"]), "icon-halo-width": new Tt(G.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Tt(G.paint_symbol["icon-halo-blur"]), "icon-translate": new Dt(G.paint_symbol["icon-translate"]), "icon-translate-anchor": new Dt(G.paint_symbol["icon-translate-anchor"]), "text-opacity": new Tt(G.paint_symbol["text-opacity"]), "text-color": new Tt(G.paint_symbol["text-color"], { runtimeType: De, getOverride: function(r) {
        return r.textColor;
      }, hasOverride: function(r) {
        return !!r.textColor;
      } }), "text-halo-color": new Tt(G.paint_symbol["text-halo-color"]), "text-halo-width": new Tt(G.paint_symbol["text-halo-width"]), "text-halo-blur": new Tt(G.paint_symbol["text-halo-blur"]), "text-translate": new Dt(G.paint_symbol["text-translate"]), "text-translate-anchor": new Dt(G.paint_symbol["text-translate-anchor"]) }), layout: eC }, Vh = function(r) {
        this.type = r.property.overrides ? r.property.overrides.runtimeType : _t, this.defaultValue = r;
      };
      Vh.prototype.evaluate = function(r) {
        if (r.formattedSection) {
          var i = this.defaultValue.property.overrides;
          if (i && i.hasOverride(r.formattedSection))
            return i.getOverride(r.formattedSection);
        }
        return r.feature && r.featureState ? this.defaultValue.evaluate(r.feature, r.featureState) : this.defaultValue.property.specification.default;
      }, Vh.prototype.eachChild = function(r) {
        this.defaultValue.isConstant() || r(this.defaultValue.value._styleExpression.expression);
      }, Vh.prototype.outputDefined = function() {
        return !1;
      }, Vh.prototype.serialize = function() {
        return null;
      }, wt("FormatSectionOverride", Vh, { omit: ["defaultValue"] });
      var tC = function(r) {
        function i(l) {
          r.call(this, l, y_);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.recalculate = function(l, p) {
          if (r.prototype.recalculate.call(this, l, p), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            var y = this.layout.get("text-writing-mode");
            if (y) {
              for (var v = [], x = 0, S = y; x < S.length; x += 1) {
                var C = S[x];
                v.indexOf(C) < 0 && v.push(C);
              }
              this.layout._values["text-writing-mode"] = v;
            } else
              this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }, i.prototype.getValueAndResolveTokens = function(l, p, y, v) {
          var x = this.layout.get(l).evaluate(p, {}, y, v), S = this._unevaluatedLayout._values[l];
          return S.isDataDriven() || tc(S.value) || !x ? x : function(C, P) {
            return P.replace(/{([^{}]+)}/g, function(L, D) {
              return D in C ? String(C[D]) : "";
            });
          }(p.properties, x);
        }, i.prototype.createBucket = function(l) {
          return new Wr(l);
        }, i.prototype.queryRadius = function() {
          return 0;
        }, i.prototype.queryIntersectsFeature = function() {
          return !1;
        }, i.prototype._setPaintOverrides = function() {
          for (var l = 0, p = y_.paint.overridableProperties; l < p.length; l += 1) {
            var y = p[l];
            if (i.hasPaintOverride(this.layout, y)) {
              var v, x = this.paint.get(y), S = new Vh(x), C = new Ql(S, x.property.specification);
              v = x.value.kind === "constant" || x.value.kind === "source" ? new rc("source", C) : new eu("composite", C, x.value.zoomStops, x.value._interpolationType), this.paint._values[y] = new ji(x.property, v, x.parameters);
            }
          }
        }, i.prototype._handleOverridablePaintPropertyUpdate = function(l, p, y) {
          return !(!this.layout || p.isDataDriven() || y.isDataDriven()) && i.hasPaintOverride(this.layout, l);
        }, i.hasPaintOverride = function(l, p) {
          var y = l.get("text-field"), v = y_.paint.properties[p], x = !1, S = function(L) {
            for (var D = 0, B = L; D < B.length; D += 1)
              if (v.overrides && v.overrides.hasOverride(B[D]))
                return void (x = !0);
          };
          if (y.value.kind === "constant" && y.value.value instanceof mi)
            S(y.value.value.sections);
          else if (y.value.kind === "source") {
            var C = function(L) {
              x || (L instanceof Vi && Ln(L.value) === jt ? S(L.value.sections) : L instanceof ia ? S(L.sections) : L.eachChild(C));
            }, P = y.value;
            P._styleExpression && C(P._styleExpression.expression);
          }
          return x;
        }, i;
      }(wa), rC = { paint: new Ii({ "background-color": new Dt(G.paint_background["background-color"]), "background-pattern": new Gi(G.paint_background["background-pattern"]), "background-opacity": new Dt(G.paint_background["background-opacity"]) }) }, nC = function(r) {
        function i(l) {
          r.call(this, l, rC);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(wa), iC = { paint: new Ii({ "raster-opacity": new Dt(G.paint_raster["raster-opacity"]), "raster-hue-rotate": new Dt(G.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Dt(G.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Dt(G.paint_raster["raster-brightness-max"]), "raster-saturation": new Dt(G.paint_raster["raster-saturation"]), "raster-contrast": new Dt(G.paint_raster["raster-contrast"]), "raster-resampling": new Dt(G.paint_raster["raster-resampling"]), "raster-fade-duration": new Dt(G.paint_raster["raster-fade-duration"]) }) }, oC = function(r) {
        function i(l) {
          r.call(this, l, iC);
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i;
      }(wa), aC = function(r) {
        function i(l) {
          r.call(this, l, {}), this.implementation = l;
        }
        return r && (i.__proto__ = r), (i.prototype = Object.create(r && r.prototype)).constructor = i, i.prototype.is3D = function() {
          return this.implementation.renderingMode === "3d";
        }, i.prototype.hasOffscreenPass = function() {
          return this.implementation.prerender !== void 0;
        }, i.prototype.recalculate = function() {
        }, i.prototype.updateTransitions = function() {
        }, i.prototype.hasTransition = function() {
        }, i.prototype.serialize = function() {
        }, i.prototype.onAdd = function(l) {
          this.implementation.onAdd && this.implementation.onAdd(l, l.painter.context.gl);
        }, i.prototype.onRemove = function(l) {
          this.implementation.onRemove && this.implementation.onRemove(l, l.painter.context.gl);
        }, i;
      }(wa), sC = { circle: e_, heatmap: $I, hillshade: WI, fill: uO, "fill-extrusion": vO, line: SO, symbol: tC, background: nC, raster: oC }, K1 = I.HTMLImageElement, Y1 = I.HTMLCanvasElement, J1 = I.HTMLVideoElement, Q1 = I.ImageData, Qm = I.ImageBitmap, _c = function(r, i, l, p) {
        this.context = r, this.format = l, this.texture = r.gl.createTexture(), this.update(i, p);
      };
      _c.prototype.update = function(r, i, l) {
        var p = r.width, y = r.height, v = !(this.size && this.size[0] === p && this.size[1] === y || l), x = this.context, S = x.gl;
        if (this.useMipmap = Boolean(i && i.useMipmap), S.bindTexture(S.TEXTURE_2D, this.texture), x.pixelStoreUnpackFlipY.set(!1), x.pixelStoreUnpack.set(1), x.pixelStoreUnpackPremultiplyAlpha.set(this.format === S.RGBA && (!i || i.premultiply !== !1)), v)
          this.size = [p, y], r instanceof K1 || r instanceof Y1 || r instanceof J1 || r instanceof Q1 || Qm && r instanceof Qm ? S.texImage2D(S.TEXTURE_2D, 0, this.format, this.format, S.UNSIGNED_BYTE, r) : S.texImage2D(S.TEXTURE_2D, 0, this.format, p, y, 0, this.format, S.UNSIGNED_BYTE, r.data);
        else {
          var C = l || { x: 0, y: 0 }, P = C.x, L = C.y;
          r instanceof K1 || r instanceof Y1 || r instanceof J1 || r instanceof Q1 || Qm && r instanceof Qm ? S.texSubImage2D(S.TEXTURE_2D, 0, P, L, S.RGBA, S.UNSIGNED_BYTE, r) : S.texSubImage2D(S.TEXTURE_2D, 0, P, L, p, y, S.RGBA, S.UNSIGNED_BYTE, r.data);
        }
        this.useMipmap && this.isSizePowerOfTwo() && S.generateMipmap(S.TEXTURE_2D);
      }, _c.prototype.bind = function(r, i, l) {
        var p = this.context.gl;
        p.bindTexture(p.TEXTURE_2D, this.texture), l !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (l = p.LINEAR), r !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, r), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, l || r), this.filter = r), i !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, i), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, i), this.wrap = i);
      }, _c.prototype.isSizePowerOfTwo = function() {
        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
      }, _c.prototype.destroy = function() {
        this.context.gl.deleteTexture(this.texture), this.texture = null;
      };
      var g_ = function(r) {
        var i = this;
        this._callback = r, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function() {
          i._triggered = !1, i._callback();
        });
      };
      g_.prototype.trigger = function() {
        var r = this;
        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(function() {
          r._triggered = !1, r._callback();
        }, 0));
      }, g_.prototype.remove = function() {
        delete this._channel, this._callback = function() {
        };
      };
      var Uh = function(r, i, l) {
        this.target = r, this.parent = i, this.mapId = l, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, ze(["receive", "process"], this), this.invoker = new g_(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = ht() ? r : I;
      };
      function eb(r, i, l) {
        var p = 2 * Math.PI * 6378137 / 256 / Math.pow(2, l);
        return [r * p - 2 * Math.PI * 6378137 / 2, i * p - 2 * Math.PI * 6378137 / 2];
      }
      Uh.prototype.send = function(r, i, l, p, y) {
        var v = this;
        y === void 0 && (y = !1);
        var x = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
        l && (this.callbacks[x] = l);
        var S = tr(this.globalScope) ? void 0 : [];
        return this.target.postMessage({ id: x, type: r, hasCallback: !!l, targetMapId: p, mustQueue: y, sourceMapId: this.mapId, data: aa(i, S) }, S), { cancel: function() {
          l && delete v.callbacks[x], v.target.postMessage({ id: x, type: "<cancel>", targetMapId: p, sourceMapId: v.mapId });
        } };
      }, Uh.prototype.receive = function(r) {
        var i = r.data, l = i.id;
        if (l && (!i.targetMapId || this.mapId === i.targetMapId))
          if (i.type === "<cancel>") {
            delete this.tasks[l];
            var p = this.cancelCallbacks[l];
            delete this.cancelCallbacks[l], p && p();
          } else
            ht() || i.mustQueue ? (this.tasks[l] = i, this.taskQueue.push(l), this.invoker.trigger()) : this.processTask(l, i);
      }, Uh.prototype.process = function() {
        if (this.taskQueue.length) {
          var r = this.taskQueue.shift(), i = this.tasks[r];
          delete this.tasks[r], this.taskQueue.length && this.invoker.trigger(), i && this.processTask(r, i);
        }
      }, Uh.prototype.processTask = function(r, i) {
        var l = this;
        if (i.type === "<response>") {
          var p = this.callbacks[r];
          delete this.callbacks[r], p && (i.error ? p(co(i.error)) : p(null, co(i.data)));
        } else {
          var y = !1, v = tr(this.globalScope) ? void 0 : [], x = i.hasCallback ? function(L, D) {
            y = !0, delete l.cancelCallbacks[r], l.target.postMessage({ id: r, type: "<response>", sourceMapId: l.mapId, error: L ? aa(L) : null, data: aa(D, v) }, v);
          } : function(L) {
            y = !0;
          }, S = null, C = co(i.data);
          if (this.parent[i.type])
            S = this.parent[i.type](i.sourceMapId, C, x);
          else if (this.parent.getWorkerSource) {
            var P = i.type.split(".");
            S = this.parent.getWorkerSource(i.sourceMapId, P[0], C.source)[P[1]](C, x);
          } else
            x(new Error("Could not find function " + i.type));
          !y && S && S.cancel && (this.cancelCallbacks[r] = S.cancel);
        }
      }, Uh.prototype.remove = function() {
        this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);
      };
      var ei = function(r, i) {
        r && (i ? this.setSouthWest(r).setNorthEast(i) : r.length === 4 ? this.setSouthWest([r[0], r[1]]).setNorthEast([r[2], r[3]]) : this.setSouthWest(r[0]).setNorthEast(r[1]));
      };
      ei.prototype.setNorthEast = function(r) {
        return this._ne = r instanceof gn ? new gn(r.lng, r.lat) : gn.convert(r), this;
      }, ei.prototype.setSouthWest = function(r) {
        return this._sw = r instanceof gn ? new gn(r.lng, r.lat) : gn.convert(r), this;
      }, ei.prototype.extend = function(r) {
        var i, l, p = this._sw, y = this._ne;
        if (r instanceof gn)
          i = r, l = r;
        else {
          if (!(r instanceof ei))
            return Array.isArray(r) ? r.length === 4 || r.every(Array.isArray) ? this.extend(ei.convert(r)) : this.extend(gn.convert(r)) : this;
          if (l = r._ne, !(i = r._sw) || !l)
            return this;
        }
        return p || y ? (p.lng = Math.min(i.lng, p.lng), p.lat = Math.min(i.lat, p.lat), y.lng = Math.max(l.lng, y.lng), y.lat = Math.max(l.lat, y.lat)) : (this._sw = new gn(i.lng, i.lat), this._ne = new gn(l.lng, l.lat)), this;
      }, ei.prototype.getCenter = function() {
        return new gn((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
      }, ei.prototype.getSouthWest = function() {
        return this._sw;
      }, ei.prototype.getNorthEast = function() {
        return this._ne;
      }, ei.prototype.getNorthWest = function() {
        return new gn(this.getWest(), this.getNorth());
      }, ei.prototype.getSouthEast = function() {
        return new gn(this.getEast(), this.getSouth());
      }, ei.prototype.getWest = function() {
        return this._sw.lng;
      }, ei.prototype.getSouth = function() {
        return this._sw.lat;
      }, ei.prototype.getEast = function() {
        return this._ne.lng;
      }, ei.prototype.getNorth = function() {
        return this._ne.lat;
      }, ei.prototype.toArray = function() {
        return [this._sw.toArray(), this._ne.toArray()];
      }, ei.prototype.toString = function() {
        return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";
      }, ei.prototype.isEmpty = function() {
        return !(this._sw && this._ne);
      }, ei.prototype.contains = function(r) {
        var i = gn.convert(r), l = i.lng, p = i.lat, y = this._sw.lng <= l && l <= this._ne.lng;
        return this._sw.lng > this._ne.lng && (y = this._sw.lng >= l && l >= this._ne.lng), this._sw.lat <= p && p <= this._ne.lat && y;
      }, ei.convert = function(r) {
        return !r || r instanceof ei ? r : new ei(r);
      };
      var gn = function(r, i) {
        if (isNaN(r) || isNaN(i))
          throw new Error("Invalid LngLat object: (" + r + ", " + i + ")");
        if (this.lng = +r, this.lat = +i, this.lat > 90 || this.lat < -90)
          throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
      };
      gn.prototype.wrap = function() {
        return new gn(re(this.lng, -180, 180), this.lat);
      }, gn.prototype.toArray = function() {
        return [this.lng, this.lat];
      }, gn.prototype.toString = function() {
        return "LngLat(" + this.lng + ", " + this.lat + ")";
      }, gn.prototype.distanceTo = function(r) {
        var i = Math.PI / 180, l = this.lat * i, p = r.lat * i, y = Math.sin(l) * Math.sin(p) + Math.cos(l) * Math.cos(p) * Math.cos((r.lng - this.lng) * i);
        return 63710088e-1 * Math.acos(Math.min(y, 1));
      }, gn.prototype.toBounds = function(r) {
        r === void 0 && (r = 0);
        var i = 360 * r / 40075017, l = i / Math.cos(Math.PI / 180 * this.lat);
        return new ei(new gn(this.lng - l, this.lat - i), new gn(this.lng + l, this.lat + i));
      }, gn.convert = function(r) {
        if (r instanceof gn)
          return r;
        if (Array.isArray(r) && (r.length === 2 || r.length === 3))
          return new gn(Number(r[0]), Number(r[1]));
        if (!Array.isArray(r) && typeof r == "object" && r !== null)
          return new gn(Number("lng" in r ? r.lng : r.lon), Number(r.lat));
        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
      };
      var tb = 2 * Math.PI * 63710088e-1;
      function rb(r) {
        return tb * Math.cos(r * Math.PI / 180);
      }
      function nb(r) {
        return (180 + r) / 360;
      }
      function ib(r) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
      }
      function ob(r, i) {
        return r / rb(i);
      }
      function v_(r) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90;
      }
      var xc = function(r, i, l) {
        l === void 0 && (l = 0), this.x = +r, this.y = +i, this.z = +l;
      };
      xc.fromLngLat = function(r, i) {
        i === void 0 && (i = 0);
        var l = gn.convert(r);
        return new xc(nb(l.lng), ib(l.lat), ob(i, l.lat));
      }, xc.prototype.toLngLat = function() {
        return new gn(360 * this.x - 180, v_(this.y));
      }, xc.prototype.toAltitude = function() {
        return this.z * rb(v_(this.y));
      }, xc.prototype.meterInMercatorCoordinateUnits = function() {
        return 1 / tb * (r = v_(this.y), 1 / Math.cos(r * Math.PI / 180));
        var r;
      };
      var bc = function(r, i, l) {
        this.z = r, this.x = i, this.y = l, this.key = Ip(0, r, r, i, l);
      };
      bc.prototype.equals = function(r) {
        return this.z === r.z && this.x === r.x && this.y === r.y;
      }, bc.prototype.url = function(r, i) {
        var l, p, y, v, x, S = (p = this.y, y = this.z, v = eb(256 * (l = this.x), 256 * (p = Math.pow(2, y) - p - 1), y), x = eb(256 * (l + 1), 256 * (p + 1), y), v[0] + "," + v[1] + "," + x[0] + "," + x[1]), C = function(P, L, D) {
          for (var B, j = "", J = P; J > 0; J--)
            j += (L & (B = 1 << J - 1) ? 1 : 0) + (D & B ? 2 : 0);
          return j;
        }(this.z, this.x, this.y);
        return r[(this.x + this.y) % r.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String(i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", C).replace("{bbox-epsg-3857}", S);
      }, bc.prototype.getTilePoint = function(r) {
        var i = Math.pow(2, this.z);
        return new T(8192 * (r.x * i - this.x), 8192 * (r.y * i - this.y));
      }, bc.prototype.toString = function() {
        return this.z + "/" + this.x + "/" + this.y;
      };
      var ab = function(r, i) {
        this.wrap = r, this.canonical = i, this.key = Ip(r, i.z, i.z, i.x, i.y);
      }, ti = function(r, i, l, p, y) {
        this.overscaledZ = r, this.wrap = i, this.canonical = new bc(l, +p, +y), this.key = Ip(i, r, l, p, y);
      };
      function Ip(r, i, l, p, y) {
        (r *= 2) < 0 && (r = -1 * r - 1);
        var v = 1 << l;
        return (v * v * r + v * y + p).toString(36) + l.toString(36) + i.toString(36);
      }
      ti.prototype.equals = function(r) {
        return this.overscaledZ === r.overscaledZ && this.wrap === r.wrap && this.canonical.equals(r.canonical);
      }, ti.prototype.scaledTo = function(r) {
        var i = this.canonical.z - r;
        return r > this.canonical.z ? new ti(r, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ti(r, this.wrap, r, this.canonical.x >> i, this.canonical.y >> i);
      }, ti.prototype.calculateScaledKey = function(r, i) {
        var l = this.canonical.z - r;
        return r > this.canonical.z ? Ip(this.wrap * +i, r, this.canonical.z, this.canonical.x, this.canonical.y) : Ip(this.wrap * +i, r, r, this.canonical.x >> l, this.canonical.y >> l);
      }, ti.prototype.isChildOf = function(r) {
        if (r.wrap !== this.wrap)
          return !1;
        var i = this.canonical.z - r.canonical.z;
        return r.overscaledZ === 0 || r.overscaledZ < this.overscaledZ && r.canonical.x === this.canonical.x >> i && r.canonical.y === this.canonical.y >> i;
      }, ti.prototype.children = function(r) {
        if (this.overscaledZ >= r)
          return [new ti(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
        var i = this.canonical.z + 1, l = 2 * this.canonical.x, p = 2 * this.canonical.y;
        return [new ti(i, this.wrap, i, l, p), new ti(i, this.wrap, i, l + 1, p), new ti(i, this.wrap, i, l, p + 1), new ti(i, this.wrap, i, l + 1, p + 1)];
      }, ti.prototype.isLessThan = function(r) {
        return this.wrap < r.wrap || !(this.wrap > r.wrap) && (this.overscaledZ < r.overscaledZ || !(this.overscaledZ > r.overscaledZ) && (this.canonical.x < r.canonical.x || !(this.canonical.x > r.canonical.x) && this.canonical.y < r.canonical.y));
      }, ti.prototype.wrapped = function() {
        return new ti(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
      }, ti.prototype.unwrapTo = function(r) {
        return new ti(this.overscaledZ, r, this.canonical.z, this.canonical.x, this.canonical.y);
      }, ti.prototype.overscaleFactor = function() {
        return Math.pow(2, this.overscaledZ - this.canonical.z);
      }, ti.prototype.toUnwrapped = function() {
        return new ab(this.wrap, this.canonical);
      }, ti.prototype.toString = function() {
        return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;
      }, ti.prototype.getTilePoint = function(r) {
        return this.canonical.getTilePoint(new xc(r.x - this.wrap, r.y));
      }, wt("CanonicalTileID", bc), wt("OverscaledTileID", ti, { omit: ["posMatrix"] });
      var Ml = function(r, i, l) {
        if (this.uid = r, i.height !== i.width)
          throw new RangeError("DEM tiles must be square");
        if (l && l !== "mapbox" && l !== "terrarium")
          return at('"' + l + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');
        this.stride = i.height;
        var p = this.dim = i.height - 2;
        this.data = new Uint32Array(i.data.buffer), this.encoding = l || "mapbox";
        for (var y = 0; y < p; y++)
          this.data[this._idx(-1, y)] = this.data[this._idx(0, y)], this.data[this._idx(p, y)] = this.data[this._idx(p - 1, y)], this.data[this._idx(y, -1)] = this.data[this._idx(y, 0)], this.data[this._idx(y, p)] = this.data[this._idx(y, p - 1)];
        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(p, -1)] = this.data[this._idx(p - 1, 0)], this.data[this._idx(-1, p)] = this.data[this._idx(0, p - 1)], this.data[this._idx(p, p)] = this.data[this._idx(p - 1, p - 1)];
      };
      Ml.prototype.get = function(r, i) {
        var l = new Uint8Array(this.data.buffer), p = 4 * this._idx(r, i);
        return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(l[p], l[p + 1], l[p + 2]);
      }, Ml.prototype.getUnpackVector = function() {
        return this.encoding === "terrarium" ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
      }, Ml.prototype._idx = function(r, i) {
        if (r < -1 || r >= this.dim + 1 || i < -1 || i >= this.dim + 1)
          throw new RangeError("out of range source coordinates for DEM data");
        return (i + 1) * this.stride + (r + 1);
      }, Ml.prototype._unpackMapbox = function(r, i, l) {
        return (256 * r * 256 + 256 * i + l) / 10 - 1e4;
      }, Ml.prototype._unpackTerrarium = function(r, i, l) {
        return 256 * r + i + l / 256 - 32768;
      }, Ml.prototype.getPixels = function() {
        return new yo({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
      }, Ml.prototype.backfillBorder = function(r, i, l) {
        if (this.dim !== r.dim)
          throw new Error("dem dimension mismatch");
        var p = i * this.dim, y = i * this.dim + this.dim, v = l * this.dim, x = l * this.dim + this.dim;
        switch (i) {
          case -1:
            p = y - 1;
            break;
          case 1:
            y = p + 1;
        }
        switch (l) {
          case -1:
            v = x - 1;
            break;
          case 1:
            x = v + 1;
        }
        for (var S = -i * this.dim, C = -l * this.dim, P = v; P < x; P++)
          for (var L = p; L < y; L++)
            this.data[this._idx(L, P)] = r.data[this._idx(L + S, P + C)];
      }, wt("DEMData", Ml);
      var ey = function(r) {
        this._stringToNumber = {}, this._numberToString = [];
        for (var i = 0; i < r.length; i++) {
          var l = r[i];
          this._stringToNumber[l] = i, this._numberToString[i] = l;
        }
      };
      ey.prototype.encode = function(r) {
        return this._stringToNumber[r];
      }, ey.prototype.decode = function(r) {
        return this._numberToString[r];
      };
      var ty = function(r, i, l, p, y) {
        this.type = "Feature", this._vectorTileFeature = r, r._z = i, r._x = l, r._y = p, this.properties = r.properties, this.id = y;
      }, __ = { geometry: { configurable: !0 } };
      __.geometry.get = function() {
        return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
      }, __.geometry.set = function(r) {
        this._geometry = r;
      }, ty.prototype.toJSON = function() {
        var r = { geometry: this.geometry };
        for (var i in this)
          i !== "_geometry" && i !== "_vectorTileFeature" && (r[i] = this[i]);
        return r;
      }, Object.defineProperties(ty.prototype, __);
      var jh = function() {
        this.state = {}, this.stateChanges = {}, this.deletedStates = {};
      };
      jh.prototype.updateState = function(r, i, l) {
        var p = String(i);
        if (this.stateChanges[r] = this.stateChanges[r] || {}, this.stateChanges[r][p] = this.stateChanges[r][p] || {}, X(this.stateChanges[r][p], l), this.deletedStates[r] === null)
          for (var y in this.deletedStates[r] = {}, this.state[r])
            y !== p && (this.deletedStates[r][y] = null);
        else if (this.deletedStates[r] && this.deletedStates[r][p] === null)
          for (var v in this.deletedStates[r][p] = {}, this.state[r][p])
            l[v] || (this.deletedStates[r][p][v] = null);
        else
          for (var x in l)
            this.deletedStates[r] && this.deletedStates[r][p] && this.deletedStates[r][p][x] === null && delete this.deletedStates[r][p][x];
      }, jh.prototype.removeFeatureState = function(r, i, l) {
        if (this.deletedStates[r] !== null) {
          var p = String(i);
          if (this.deletedStates[r] = this.deletedStates[r] || {}, l && i !== void 0)
            this.deletedStates[r][p] !== null && (this.deletedStates[r][p] = this.deletedStates[r][p] || {}, this.deletedStates[r][p][l] = null);
          else if (i !== void 0)
            if (this.stateChanges[r] && this.stateChanges[r][p])
              for (l in this.deletedStates[r][p] = {}, this.stateChanges[r][p])
                this.deletedStates[r][p][l] = null;
            else
              this.deletedStates[r][p] = null;
          else
            this.deletedStates[r] = null;
        }
      }, jh.prototype.getState = function(r, i) {
        var l = String(i), p = X({}, (this.state[r] || {})[l], (this.stateChanges[r] || {})[l]);
        if (this.deletedStates[r] === null)
          return {};
        if (this.deletedStates[r]) {
          var y = this.deletedStates[r][i];
          if (y === null)
            return {};
          for (var v in y)
            delete p[v];
        }
        return p;
      }, jh.prototype.initializeTileState = function(r, i) {
        r.setFeatureState(this.state, i);
      }, jh.prototype.coalesceChanges = function(r, i) {
        var l = {};
        for (var p in this.stateChanges) {
          this.state[p] = this.state[p] || {};
          var y = {};
          for (var v in this.stateChanges[p])
            this.state[p][v] || (this.state[p][v] = {}), X(this.state[p][v], this.stateChanges[p][v]), y[v] = this.state[p][v];
          l[p] = y;
        }
        for (var x in this.deletedStates) {
          this.state[x] = this.state[x] || {};
          var S = {};
          if (this.deletedStates[x] === null)
            for (var C in this.state[x])
              S[C] = {}, this.state[x][C] = {};
          else
            for (var P in this.deletedStates[x]) {
              if (this.deletedStates[x][P] === null)
                this.state[x][P] = {};
              else
                for (var L = 0, D = Object.keys(this.deletedStates[x][P]); L < D.length; L += 1)
                  delete this.state[x][P][D[L]];
              S[P] = this.state[x][P];
            }
          l[x] = l[x] || {}, X(l[x], S);
        }
        if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(l).length !== 0)
          for (var B in r)
            r[B].setFeatureState(l, i);
      };
      var Il = function(r, i) {
        this.tileID = r, this.x = r.canonical.x, this.y = r.canonical.y, this.z = r.canonical.z, this.grid = new Ua(8192, 16, 0), this.grid3D = new Ua(8192, 16, 0), this.featureIndexArray = new R(), this.promoteId = i;
      };
      function sb(r, i, l, p, y) {
        return Se(r, function(v, x) {
          var S = i instanceof hc ? i.get(x) : null;
          return S && S.evaluate ? S.evaluate(l, p, y) : S;
        });
      }
      function lb(r) {
        for (var i = 1 / 0, l = 1 / 0, p = -1 / 0, y = -1 / 0, v = 0, x = r; v < x.length; v += 1) {
          var S = x[v];
          i = Math.min(i, S.x), l = Math.min(l, S.y), p = Math.max(p, S.x), y = Math.max(y, S.y);
        }
        return { minX: i, minY: l, maxX: p, maxY: y };
      }
      function lC(r, i) {
        return i - r;
      }
      Il.prototype.insert = function(r, i, l, p, y, v) {
        var x = this.featureIndexArray.length;
        this.featureIndexArray.emplaceBack(l, p, y);
        for (var S = v ? this.grid3D : this.grid, C = 0; C < i.length; C++) {
          for (var P = i[C], L = [1 / 0, 1 / 0, -1 / 0, -1 / 0], D = 0; D < P.length; D++) {
            var B = P[D];
            L[0] = Math.min(L[0], B.x), L[1] = Math.min(L[1], B.y), L[2] = Math.max(L[2], B.x), L[3] = Math.max(L[3], B.y);
          }
          L[0] < 8192 && L[1] < 8192 && L[2] >= 0 && L[3] >= 0 && S.insert(x, L[0], L[1], L[2], L[3]);
        }
      }, Il.prototype.loadVTLayers = function() {
        return this.vtLayers || (this.vtLayers = new kh.VectorTile(new Gm(this.rawTileData)).layers, this.sourceLayerCoder = new ey(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
      }, Il.prototype.query = function(r, i, l, p) {
        var y = this;
        this.loadVTLayers();
        for (var v = r.params || {}, x = 8192 / r.tileSize / r.scale, S = mh(v.filter), C = r.queryGeometry, P = r.queryPadding * x, L = lb(C), D = this.grid.query(L.minX - P, L.minY - P, L.maxX + P, L.maxY + P), B = lb(r.cameraQueryGeometry), j = this.grid3D.query(B.minX - P, B.minY - P, B.maxX + P, B.maxY + P, function(Te, Oe, Ve, Ke) {
          return function(ot, Pt, dt, Rt, yt) {
            for (var sr = 0, $t = ot; sr < $t.length; sr += 1) {
              var Mt = $t[sr];
              if (Pt <= Mt.x && dt <= Mt.y && Rt >= Mt.x && yt >= Mt.y)
                return !0;
            }
            var fr = [new T(Pt, dt), new T(Pt, yt), new T(Rt, yt), new T(Rt, dt)];
            if (ot.length > 2) {
              for (var rr = 0, Tr = fr; rr < Tr.length; rr += 1)
                if (Sa(ot, Tr[rr]))
                  return !0;
            }
            for (var zt = 0; zt < ot.length - 1; zt++)
              if (yc(ot[zt], ot[zt + 1], fr))
                return !0;
            return !1;
          }(r.cameraQueryGeometry, Te - P, Oe - P, Ve + P, Ke + P);
        }), J = 0, ee = j; J < ee.length; J += 1)
          D.push(ee[J]);
        D.sort(lC);
        for (var he, oe = {}, ge = function(Te) {
          var Oe = D[Te];
          if (Oe !== he) {
            he = Oe;
            var Ve = y.featureIndexArray.get(Oe), Ke = null;
            y.loadMatchingFeature(oe, Ve.bucketIndex, Ve.sourceLayerIndex, Ve.featureIndex, S, v.layers, v.availableImages, i, l, p, function(ot, Pt, dt) {
              return Ke || (Ke = Mn(ot)), Pt.queryIntersectsFeature(C, ot, dt, Ke, y.z, r.transform, x, r.pixelPosMatrix);
            });
          }
        }, we = 0; we < D.length; we++)
          ge(we);
        return oe;
      }, Il.prototype.loadMatchingFeature = function(r, i, l, p, y, v, x, S, C, P, L) {
        var D = this.bucketLayerIDs[i];
        if (!v || function(ot, Pt) {
          for (var dt = 0; dt < ot.length; dt++)
            if (Pt.indexOf(ot[dt]) >= 0)
              return !0;
          return !1;
        }(v, D)) {
          var B = this.sourceLayerCoder.decode(l), j = this.vtLayers[B].feature(p);
          if (y.needGeometry) {
            var J = Dn(j, !0);
            if (!y.filter(new mr(this.tileID.overscaledZ), J, this.tileID.canonical))
              return;
          } else if (!y.filter(new mr(this.tileID.overscaledZ), j))
            return;
          for (var ee = this.getId(j, B), he = 0; he < D.length; he++) {
            var oe = D[he];
            if (!(v && v.indexOf(oe) < 0)) {
              var ge = S[oe];
              if (ge) {
                var we = {};
                ee !== void 0 && P && (we = P.getState(ge.sourceLayer || "_geojsonTileLayer", ee));
                var Te = X({}, C[oe]);
                Te.paint = sb(Te.paint, ge.paint, j, we, x), Te.layout = sb(Te.layout, ge.layout, j, we, x);
                var Oe = !L || L(j, ge, we);
                if (Oe) {
                  var Ve = new ty(j, this.z, this.x, this.y, ee);
                  Ve.layer = Te;
                  var Ke = r[oe];
                  Ke === void 0 && (Ke = r[oe] = []), Ke.push({ featureIndex: p, feature: Ve, intersectionZ: Oe });
                }
              }
            }
          }
        }
      }, Il.prototype.lookupSymbolFeatures = function(r, i, l, p, y, v, x, S) {
        var C = {};
        this.loadVTLayers();
        for (var P = mh(y), L = 0, D = r; L < D.length; L += 1)
          this.loadMatchingFeature(C, l, p, D[L], P, v, x, S, i);
        return C;
      }, Il.prototype.hasLayer = function(r) {
        for (var i = 0, l = this.bucketLayerIDs; i < l.length; i += 1)
          for (var p = 0, y = l[i]; p < y.length; p += 1)
            if (r === y[p])
              return !0;
        return !1;
      }, Il.prototype.getId = function(r, i) {
        var l = r.id;
        return this.promoteId && typeof (l = r.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[i]]) == "boolean" && (l = Number(l)), l;
      }, wt("FeatureIndex", Il, { omit: ["rawTileData", "sourceLayerCoder"] });
      var _i = function(r, i) {
        this.tileID = r, this.uid = ce(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
      };
      _i.prototype.registerFadeDuration = function(r) {
        var i = r + this.timeAdded;
        i < Vn.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);
      }, _i.prototype.wasRequested = function() {
        return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
      }, _i.prototype.loadVectorData = function(r, i, l) {
        if (this.hasData() && this.unloadVectorData(), this.state = "loaded", r) {
          for (var p in r.featureIndex && (this.latestFeatureIndex = r.featureIndex, r.rawTileData ? (this.latestRawTileData = r.rawTileData, this.latestFeatureIndex.rawTileData = r.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = r.collisionBoxArray, this.buckets = function(P, L) {
            var D = {};
            if (!L)
              return D;
            for (var B = function() {
              var ee = J[j], he = ee.layerIds.map(function(we) {
                return L.getLayer(we);
              }).filter(Boolean);
              if (he.length !== 0) {
                ee.layers = he, ee.stateDependentLayerIds && (ee.stateDependentLayers = ee.stateDependentLayerIds.map(function(we) {
                  return he.filter(function(Te) {
                    return Te.id === we;
                  })[0];
                }));
                for (var oe = 0, ge = he; oe < ge.length; oe += 1)
                  D[ge[oe].id] = ee;
              }
            }, j = 0, J = P; j < J.length; j += 1)
              B();
            return D;
          }(r.buckets, i.style), this.hasSymbolBuckets = !1, this.buckets) {
            var y = this.buckets[p];
            if (y instanceof Wr) {
              if (this.hasSymbolBuckets = !0, !l)
                break;
              y.justReloaded = !0;
            }
          }
          if (this.hasRTLText = !1, this.hasSymbolBuckets)
            for (var v in this.buckets) {
              var x = this.buckets[v];
              if (x instanceof Wr && x.hasRTLText) {
                this.hasRTLText = !0, Io.isLoading() || Io.isLoaded() || cp() !== "deferred" || sa();
                break;
              }
            }
          for (var S in this.queryPadding = 0, this.buckets) {
            var C = this.buckets[S];
            this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(S).queryRadius(C));
          }
          r.imageAtlas && (this.imageAtlas = r.imageAtlas), r.glyphAtlasImage && (this.glyphAtlasImage = r.glyphAtlasImage);
        } else
          this.collisionBoxArray = new h();
      }, _i.prototype.unloadVectorData = function() {
        for (var r in this.buckets)
          this.buckets[r].destroy();
        this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
      }, _i.prototype.getBucket = function(r) {
        return this.buckets[r.id];
      }, _i.prototype.upload = function(r) {
        for (var i in this.buckets) {
          var l = this.buckets[i];
          l.uploadPending() && l.upload(r);
        }
        var p = r.gl;
        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new _c(r, this.imageAtlas.image, p.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new _c(r, this.glyphAtlasImage, p.ALPHA), this.glyphAtlasImage = null);
      }, _i.prototype.prepare = function(r) {
        this.imageAtlas && this.imageAtlas.patchUpdatedImages(r, this.imageAtlasTexture);
      }, _i.prototype.queryRenderedFeatures = function(r, i, l, p, y, v, x, S, C, P) {
        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: p, cameraQueryGeometry: y, scale: v, tileSize: this.tileSize, pixelPosMatrix: P, transform: S, params: x, queryPadding: this.queryPadding * C }, r, i, l) : {};
      }, _i.prototype.querySourceFeatures = function(r, i) {
        var l = this.latestFeatureIndex;
        if (l && l.rawTileData) {
          var p = l.loadVTLayers(), y = i ? i.sourceLayer : "", v = p._geojsonTileLayer || p[y];
          if (v)
            for (var x = mh(i && i.filter), S = this.tileID.canonical, C = S.z, P = S.x, L = S.y, D = { z: C, x: P, y: L }, B = 0; B < v.length; B++) {
              var j = v.feature(B);
              if (x.needGeometry) {
                var J = Dn(j, !0);
                if (!x.filter(new mr(this.tileID.overscaledZ), J, this.tileID.canonical))
                  continue;
              } else if (!x.filter(new mr(this.tileID.overscaledZ), j))
                continue;
              var ee = l.getId(j, y), he = new ty(j, C, P, L, ee);
              he.tile = D, r.push(he);
            }
        }
      }, _i.prototype.hasData = function() {
        return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
      }, _i.prototype.patternsLoaded = function() {
        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
      }, _i.prototype.setExpiryData = function(r) {
        var i = this.expirationTime;
        if (r.cacheControl) {
          var l = vt(r.cacheControl);
          l["max-age"] && (this.expirationTime = Date.now() + 1e3 * l["max-age"]);
        } else
          r.expires && (this.expirationTime = new Date(r.expires).getTime());
        if (this.expirationTime) {
          var p = Date.now(), y = !1;
          if (this.expirationTime > p)
            y = !1;
          else if (i)
            if (this.expirationTime < i)
              y = !0;
            else {
              var v = this.expirationTime - i;
              v ? this.expirationTime = p + Math.max(v, 3e4) : y = !0;
            }
          else
            y = !0;
          y ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
        }
      }, _i.prototype.getExpiryTimeout = function() {
        if (this.expirationTime)
          return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
      }, _i.prototype.setFeatureState = function(r, i) {
        if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && Object.keys(r).length !== 0) {
          var l = this.latestFeatureIndex.loadVTLayers();
          for (var p in this.buckets)
            if (i.style.hasLayer(p)) {
              var y = this.buckets[p], v = y.layers[0].sourceLayer || "_geojsonTileLayer", x = l[v], S = r[v];
              if (x && S && Object.keys(S).length !== 0) {
                y.update(S, x, this.imageAtlas && this.imageAtlas.patternPositions || {});
                var C = i && i.style && i.style.getLayer(p);
                C && (this.queryPadding = Math.max(this.queryPadding, C.queryRadius(y)));
              }
            }
        }
      }, _i.prototype.holdingForFade = function() {
        return this.symbolFadeHoldUntil !== void 0;
      }, _i.prototype.symbolFadeFinished = function() {
        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Vn.now();
      }, _i.prototype.clearFadeHold = function() {
        this.symbolFadeHoldUntil = void 0;
      }, _i.prototype.setHoldDuration = function(r) {
        this.symbolFadeHoldUntil = Vn.now() + r;
      }, _i.prototype.setDependencies = function(r, i) {
        for (var l = {}, p = 0, y = i; p < y.length; p += 1)
          l[y[p]] = !0;
        this.dependencies[r] = l;
      }, _i.prototype.hasDependency = function(r, i) {
        for (var l = 0, p = r; l < p.length; l += 1) {
          var y = this.dependencies[p[l]];
          if (y) {
            for (var v = 0, x = i; v < x.length; v += 1)
              if (y[x[v]])
                return !0;
          }
        }
        return !1;
      };
      var hu = I.performance, ub = function(r) {
        this._marks = { start: [r.url, "start"].join("#"), end: [r.url, "end"].join("#"), measure: r.url.toString() }, hu.mark(this._marks.start);
      };
      ub.prototype.finish = function() {
        hu.mark(this._marks.end);
        var r = hu.getEntriesByName(this._marks.measure);
        return r.length === 0 && (hu.measure(this._marks.measure, this._marks.start, this._marks.end), r = hu.getEntriesByName(this._marks.measure), hu.clearMarks(this._marks.start), hu.clearMarks(this._marks.end), hu.clearMeasures(this._marks.measure)), r;
      }, o.Actor = Uh, o.AlphaImage = vc, o.CanonicalTileID = bc, o.CollisionBoxArray = h, o.Color = zr, o.DEMData = Ml, o.DataConstantProperty = Dt, o.DictionaryCoder = ey, o.EXTENT = 8192, o.ErrorEvent = pe, o.EvaluationParameters = mr, o.Event = Q, o.Evented = de, o.FeatureIndex = Il, o.FillBucket = qa, o.FillExtrusionBucket = Wa, o.ImageAtlas = Tp, o.ImagePosition = qm, o.LineBucket = to, o.LngLat = gn, o.LngLatBounds = ei, o.MercatorCoordinate = xc, o.ONE_EM = 24, o.OverscaledTileID = ti, o.Point = T, o.Point$1 = T, o.Properties = Ii, o.Protobuf = Gm, o.RGBAImage = yo, o.RequestManager = Re, o.RequestPerformance = ub, o.ResourceType = Fa, o.SegmentVector = W, o.SourceFeatureState = jh, o.StructArrayLayout1ui2 = yp, o.StructArrayLayout2f1f2i16 = wl, o.StructArrayLayout2i4 = bl, o.StructArrayLayout3ui6 = Ss, o.StructArrayLayout4i8 = fp, o.SymbolBucket = Wr, o.Texture = _c, o.Tile = _i, o.Transitionable = Mi, o.Uniform1f = it, o.Uniform1i = je, o.Uniform2f = tt, o.Uniform3f = gt, o.Uniform4f = Nt, o.UniformColor = Bt, o.UniformMatrix4f = Ir, o.UnwrappedTileID = ab, o.ValidationError = ie, o.WritingMode = Xo, o.ZoomHistory = ap, o.add = function(r, i, l) {
        return r[0] = i[0] + l[0], r[1] = i[1] + l[1], r[2] = i[2] + l[2], r;
      }, o.addDynamicAttributes = m_, o.asyncAll = function(r, i, l) {
        if (!r.length)
          return l(null, []);
        var p = r.length, y = new Array(r.length), v = null;
        r.forEach(function(x, S) {
          i(x, function(C, P) {
            C && (v = C), y[S] = P, --p == 0 && l(v, y);
          });
        });
      }, o.bezier = z, o.bindAll = ze, o.browser = Vn, o.cacheEntryPossiblyAdded = function(r) {
        ++Tn > Bi && (r.getActor().send("enforceCacheSizeLimit", Xn), Tn = 0);
      }, o.clamp = q, o.clearTileCache = function(r) {
        var i = I.caches.delete("mapbox-tiles");
        r && i.catch(r).then(function() {
          return r();
        });
      }, o.clipLine = $1, o.clone = function(r) {
        var i = new Fr(16);
        return i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], i[4] = r[4], i[5] = r[5], i[6] = r[6], i[7] = r[7], i[8] = r[8], i[9] = r[9], i[10] = r[10], i[11] = r[11], i[12] = r[12], i[13] = r[13], i[14] = r[14], i[15] = r[15], i;
      }, o.clone$1 = Xe, o.clone$2 = function(r) {
        var i = new Fr(3);
        return i[0] = r[0], i[1] = r[1], i[2] = r[2], i;
      }, o.collisionCircleLayout = OO, o.config = Sr, o.create = function() {
        var r = new Fr(16);
        return Fr != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;
      }, o.create$1 = function() {
        var r = new Fr(9);
        return Fr != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
      }, o.create$2 = function() {
        var r = new Fr(4);
        return Fr != Float32Array && (r[1] = 0, r[2] = 0), r[0] = 1, r[3] = 1, r;
      }, o.createCommonjsModule = m, o.createExpression = ph, o.createLayout = gi, o.createStyleLayer = function(r) {
        return r.type === "custom" ? new aC(r) : new sC[r.type](r);
      }, o.cross = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = l[0], S = l[1], C = l[2];
        return r[0] = y * C - v * S, r[1] = v * x - p * C, r[2] = p * S - y * x, r;
      }, o.deepEqual = function r(i, l) {
        if (Array.isArray(i)) {
          if (!Array.isArray(l) || i.length !== l.length)
            return !1;
          for (var p = 0; p < i.length; p++)
            if (!r(i[p], l[p]))
              return !1;
          return !0;
        }
        if (typeof i == "object" && i !== null && l !== null) {
          if (typeof l != "object" || Object.keys(i).length !== Object.keys(l).length)
            return !1;
          for (var y in i)
            if (!r(i[y], l[y]))
              return !1;
          return !0;
        }
        return i === l;
      }, o.dot = function(r, i) {
        return r[0] * i[0] + r[1] * i[1] + r[2] * i[2];
      }, o.dot$1 = function(r, i) {
        return r[0] * i[0] + r[1] * i[1] + r[2] * i[2] + r[3] * i[3];
      }, o.ease = V, o.emitValidationErrors = lc, o.endsWith = Ae, o.enforceCacheSizeLimit = function(r) {
        so(), bt && bt.then(function(i) {
          i.keys().then(function(l) {
            for (var p = 0; p < l.length - r; p++)
              i.delete(l[p]);
          });
        });
      }, o.evaluateSizeForFeature = F1, o.evaluateSizeForZoom = B1, o.evaluateVariableOffset = H1, o.evented = up, o.extend = X, o.featureFilter = mh, o.filterObject = Ie, o.fromRotation = function(r, i) {
        var l = Math.sin(i), p = Math.cos(i);
        return r[0] = p, r[1] = l, r[2] = 0, r[3] = -l, r[4] = p, r[5] = 0, r[6] = 0, r[7] = 0, r[8] = 1, r;
      }, o.getAnchorAlignment = h_, o.getAnchorJustification = d_, o.getArrayBuffer = ol, o.getImage = F, o.getJSON = function(r, i) {
        return So(X(r, { type: "json" }), i);
      }, o.getRTLTextPluginStatus = cp, o.getReferrer = Ba, o.getVideo = function(r, i) {
        var l, p, y = I.document.createElement("video");
        y.muted = !0, y.onloadstart = function() {
          i(null, y);
        };
        for (var v = 0; v < r.length; v++) {
          var x = I.document.createElement("source");
          l = r[v], p = void 0, (p = I.document.createElement("a")).href = l, (p.protocol !== I.document.location.protocol || p.host !== I.document.location.host) && (y.crossOrigin = "Anonymous"), x.src = r[v], y.appendChild(x);
        }
        return { cancel: function() {
        } };
      }, o.identity = Oo, o.invert = function(r, i) {
        var l = i[0], p = i[1], y = i[2], v = i[3], x = i[4], S = i[5], C = i[6], P = i[7], L = i[8], D = i[9], B = i[10], j = i[11], J = i[12], ee = i[13], he = i[14], oe = i[15], ge = l * S - p * x, we = l * C - y * x, Te = l * P - v * x, Oe = p * C - y * S, Ve = p * P - v * S, Ke = y * P - v * C, ot = L * ee - D * J, Pt = L * he - B * J, dt = L * oe - j * J, Rt = D * he - B * ee, yt = D * oe - j * ee, sr = B * oe - j * he, $t = ge * sr - we * yt + Te * Rt + Oe * dt - Ve * Pt + Ke * ot;
        return $t ? (r[0] = (S * sr - C * yt + P * Rt) * ($t = 1 / $t), r[1] = (y * yt - p * sr - v * Rt) * $t, r[2] = (ee * Ke - he * Ve + oe * Oe) * $t, r[3] = (B * Ve - D * Ke - j * Oe) * $t, r[4] = (C * dt - x * sr - P * Pt) * $t, r[5] = (l * sr - y * dt + v * Pt) * $t, r[6] = (he * Te - J * Ke - oe * we) * $t, r[7] = (L * Ke - B * Te + j * we) * $t, r[8] = (x * yt - S * dt + P * ot) * $t, r[9] = (p * dt - l * yt - v * ot) * $t, r[10] = (J * Ve - ee * Te + oe * ge) * $t, r[11] = (D * Te - L * Ve - j * ge) * $t, r[12] = (S * Pt - x * Rt - C * ot) * $t, r[13] = (l * Rt - p * Pt + y * ot) * $t, r[14] = (ee * we - J * Oe - he * ge) * $t, r[15] = (L * Oe - D * we + B * ge) * $t, r) : null;
      }, o.isChar = ct, o.isMapboxURL = qe, o.keysDifference = function(r, i) {
        var l = [];
        for (var p in r)
          p in i || l.push(p);
        return l;
      }, o.makeRequest = So, o.mapObject = Se, o.mercatorXfromLng = nb, o.mercatorYfromLat = ib, o.mercatorZfromAltitude = ob, o.mul = Qv, o.multiply = eo, o.mvt = kh, o.nextPowerOfTwo = function(r) {
        return r <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
      }, o.normalize = function(r, i) {
        var l = i[0], p = i[1], y = i[2], v = l * l + p * p + y * y;
        return v > 0 && (v = 1 / Math.sqrt(v)), r[0] = i[0] * v, r[1] = i[1] * v, r[2] = i[2] * v, r;
      }, o.number = jn, o.offscreenCanvasSupported = si, o.ortho = function(r, i, l, p, y, v, x) {
        var S = 1 / (i - l), C = 1 / (p - y), P = 1 / (v - x);
        return r[0] = -2 * S, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * C, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * P, r[11] = 0, r[12] = (i + l) * S, r[13] = (y + p) * C, r[14] = (x + v) * P, r[15] = 1, r;
      }, o.parseGlyphPBF = function(r) {
        return new Gm(r).readFields(BO, []);
      }, o.pbf = Gm, o.performSymbolLayout = function(r, i, l, p, y, v, x) {
        r.createArrays(), r.tilePixelRatio = 8192 / (512 * r.overscaling), r.compareText = {}, r.iconsNeedLinear = !1;
        var S = r.layers[0].layout, C = r.layers[0]._unevaluatedLayout._values, P = {};
        if (r.textSizeData.kind === "composite") {
          var L = r.textSizeData, D = L.maxZoom;
          P.compositeTextSizes = [C["text-size"].possiblyEvaluate(new mr(L.minZoom), x), C["text-size"].possiblyEvaluate(new mr(D), x)];
        }
        if (r.iconSizeData.kind === "composite") {
          var B = r.iconSizeData, j = B.maxZoom;
          P.compositeIconSizes = [C["icon-size"].possiblyEvaluate(new mr(B.minZoom), x), C["icon-size"].possiblyEvaluate(new mr(j), x)];
        }
        P.layoutTextSize = C["text-size"].possiblyEvaluate(new mr(r.zoom + 1), x), P.layoutIconSize = C["icon-size"].possiblyEvaluate(new mr(r.zoom + 1), x), P.textMaxSize = C["text-size"].possiblyEvaluate(new mr(18));
        for (var J = 24 * S.get("text-line-height"), ee = S.get("text-rotation-alignment") === "map" && S.get("symbol-placement") !== "point", he = S.get("text-keep-upright"), oe = S.get("text-size"), ge = function() {
          var Oe = Te[we], Ve = S.get("text-font").evaluate(Oe, {}, x).join(","), Ke = oe.evaluate(Oe, {}, x), ot = P.layoutTextSize.evaluate(Oe, {}, x), Pt = P.layoutIconSize.evaluate(Oe, {}, x), dt = { horizontal: {}, vertical: void 0 }, Rt = Oe.text, yt = [0, 0];
          if (Rt) {
            var sr = Rt.toString(), $t = 24 * S.get("text-letter-spacing").evaluate(Oe, {}, x), Mt = function(vr) {
              for (var Xr = 0, qr = vr; Xr < qr.length; Xr += 1)
                if (Or = qr[Xr].charCodeAt(0), ct.Arabic(Or) || ct["Arabic Supplement"](Or) || ct["Arabic Extended-A"](Or) || ct["Arabic Presentation Forms-A"](Or) || ct["Arabic Presentation Forms-B"](Or))
                  return !1;
              var Or;
              return !0;
            }(sr) ? $t : 0, fr = S.get("text-anchor").evaluate(Oe, {}, x), rr = S.get("text-variable-anchor");
            if (!rr) {
              var Tr = S.get("text-radial-offset").evaluate(Oe, {}, x);
              yt = Tr ? H1(fr, [24 * Tr, p_]) : S.get("text-offset").evaluate(Oe, {}, x).map(function(vr) {
                return 24 * vr;
              });
            }
            var zt = ee ? "center" : S.get("text-justify").evaluate(Oe, {}, x), Lr = S.get("symbol-placement"), vn = Lr === "point" ? 24 * S.get("text-max-width").evaluate(Oe, {}, x) : 0, Cn = function() {
              r.allowVerticalPlacement && sp(sr) && (dt.vertical = Wm(Rt, i, l, y, Ve, vn, J, fr, "left", Mt, yt, Xo.vertical, !0, Lr, ot, Ke));
            };
            if (!ee && rr) {
              for (var In = zt === "auto" ? rr.map(function(vr) {
                return d_(vr);
              }) : [zt], _n = !1, Pn = 0; Pn < In.length; Pn++) {
                var ci = In[Pn];
                if (!dt.horizontal[ci])
                  if (_n)
                    dt.horizontal[ci] = dt.horizontal[0];
                  else {
                    var hi = Wm(Rt, i, l, y, Ve, vn, J, "center", ci, Mt, yt, Xo.horizontal, !1, Lr, ot, Ke);
                    hi && (dt.horizontal[ci] = hi, _n = hi.positionedLines.length === 1);
                  }
              }
              Cn();
            } else {
              zt === "auto" && (zt = d_(fr));
              var Wi = Wm(Rt, i, l, y, Ve, vn, J, fr, zt, Mt, yt, Xo.horizontal, !1, Lr, ot, Ke);
              Wi && (dt.horizontal[zt] = Wi), Cn(), sp(sr) && ee && he && (dt.vertical = Wm(Rt, i, l, y, Ve, vn, J, fr, zt, Mt, yt, Xo.vertical, !1, Lr, ot, Ke));
            }
          }
          var xi = void 0, Hi = !1;
          if (Oe.icon && Oe.icon.name) {
            var Nn = p[Oe.icon.name];
            Nn && (xi = function(vr, Xr, qr) {
              var Or = h_(qr), ro = Xr[0] - vr.displaySize[0] * Or.horizontalAlign, Di = Xr[1] - vr.displaySize[1] * Or.verticalAlign;
              return { image: vr, top: Di, bottom: Di + vr.displaySize[1], left: ro, right: ro + vr.displaySize[0] };
            }(y[Oe.icon.name], S.get("icon-offset").evaluate(Oe, {}, x), S.get("icon-anchor").evaluate(Oe, {}, x)), Hi = Nn.sdf, r.sdfIcons === void 0 ? r.sdfIcons = Nn.sdf : r.sdfIcons !== Nn.sdf && at("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Nn.pixelRatio !== r.pixelRatio || S.get("icon-rotate").constantOr(1) !== 0) && (r.iconsNeedLinear = !0));
          }
          var bi = X1(dt.horizontal) || dt.vertical;
          r.iconsInText = !!bi && bi.iconsInText, (bi || xi) && function(vr, Xr, qr, Or, ro, Di, ln, $n, Ni, Dr, Ps) {
            var Ko = Di.textMaxSize.evaluate(Xr, {});
            Ko === void 0 && (Ko = ln);
            var As, Rn = vr.layers[0].layout, ks = Rn.get("icon-offset").evaluate(Xr, {}, Ps), Ma = X1(qr.horizontal), Gh = ln / 24, wc = vr.tilePixelRatio * Gh, $h = vr.tilePixelRatio * Ko / 24, Ol = vr.tilePixelRatio * $n, qh = vr.tilePixelRatio * Rn.get("symbol-spacing"), ry = Rn.get("text-padding") * vr.tilePixelRatio, Wh = Rn.get("icon-padding") * vr.tilePixelRatio, Op = Rn.get("text-max-angle") / 180 * Math.PI, ny = Rn.get("text-rotation-alignment") === "map" && Rn.get("symbol-placement") !== "point", iy = Rn.get("icon-rotation-alignment") === "map" && Rn.get("symbol-placement") !== "point", Cl = Rn.get("symbol-placement"), Cp = qh / 2, Hh = Rn.get("icon-text-fit");
            Or && Hh !== "none" && (vr.allowVerticalPlacement && qr.vertical && (As = z1(Or, qr.vertical, Hh, Rn.get("icon-text-fit-padding"), ks, Gh)), Ma && (Or = z1(Or, Ma, Hh, Rn.get("icon-text-fit-padding"), ks, Gh)));
            var fu = function(uC, zp) {
              zp.x < 0 || zp.x >= 8192 || zp.y < 0 || zp.y >= 8192 || function(zn, Ha, cC, pu, E_, fb, cy, Ls, hy, Fp, fy, py, S_, pb, Bp, db, mb, yb, gb, vb, Yo, dy, _b, Ds, hC) {
                var xb, Sc, Jh, Qh, ef, tf = zn.addToLineVertexArray(Ha, cC), bb = 0, wb = 0, Eb = 0, Sb = 0, T_ = -1, M_ = -1, Pl = {}, Tb = Y(""), I_ = 0, O_ = 0;
                if (Ls._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? (I_ = (xb = Ls.layout.get("text-offset").evaluate(Yo, {}, Ds).map(function(Up) {
                  return 24 * Up;
                }))[0], O_ = xb[1]) : (I_ = 24 * Ls.layout.get("text-radial-offset").evaluate(Yo, {}, Ds), O_ = p_), zn.allowVerticalPlacement && pu.vertical) {
                  var Mb = Ls.layout.get("text-rotate").evaluate(Yo, {}, Ds) + 90;
                  Qh = new Ym(hy, Ha, Fp, fy, py, pu.vertical, S_, pb, Bp, Mb), cy && (ef = new Ym(hy, Ha, Fp, fy, py, cy, mb, yb, Bp, Mb));
                }
                if (E_) {
                  var C_ = Ls.layout.get("icon-rotate").evaluate(Yo, {}), Ib = Ls.layout.get("icon-text-fit") !== "none", Ob = q1(E_, C_, _b, Ib), P_ = cy ? q1(cy, C_, _b, Ib) : void 0;
                  Jh = new Ym(hy, Ha, Fp, fy, py, E_, mb, yb, !1, C_), bb = 4 * Ob.length;
                  var Cb = zn.iconSizeData, Vp = null;
                  Cb.kind === "source" ? (Vp = [128 * Ls.layout.get("icon-size").evaluate(Yo, {})])[0] > 32640 && at(zn.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".') : Cb.kind === "composite" && ((Vp = [128 * dy.compositeIconSizes[0].evaluate(Yo, {}, Ds), 128 * dy.compositeIconSizes[1].evaluate(Yo, {}, Ds)])[0] > 32640 || Vp[1] > 32640) && at(zn.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".'), zn.addSymbols(zn.icon, Ob, Vp, vb, gb, Yo, !1, Ha, tf.lineStartIndex, tf.lineLength, -1, Ds), T_ = zn.icon.placedSymbolArray.length - 1, P_ && (wb = 4 * P_.length, zn.addSymbols(zn.icon, P_, Vp, vb, gb, Yo, Xo.vertical, Ha, tf.lineStartIndex, tf.lineLength, -1, Ds), M_ = zn.icon.placedSymbolArray.length - 1);
                }
                for (var Pb in pu.horizontal) {
                  var my = pu.horizontal[Pb];
                  if (!Sc) {
                    Tb = Y(my.text);
                    var fC = Ls.layout.get("text-rotate").evaluate(Yo, {}, Ds);
                    Sc = new Ym(hy, Ha, Fp, fy, py, my, S_, pb, Bp, fC);
                  }
                  var Ab = my.positionedLines.length === 1;
                  if (Eb += Z1(zn, Ha, my, fb, Ls, Bp, Yo, db, tf, pu.vertical ? Xo.horizontal : Xo.horizontalOnly, Ab ? Object.keys(pu.horizontal) : [Pb], Pl, T_, dy, Ds), Ab)
                    break;
                }
                pu.vertical && (Sb += Z1(zn, Ha, pu.vertical, fb, Ls, Bp, Yo, db, tf, Xo.vertical, ["vertical"], Pl, M_, dy, Ds));
                var pC = Sc ? Sc.boxStartIndex : zn.collisionBoxArray.length, dC = Sc ? Sc.boxEndIndex : zn.collisionBoxArray.length, mC = Qh ? Qh.boxStartIndex : zn.collisionBoxArray.length, yC = Qh ? Qh.boxEndIndex : zn.collisionBoxArray.length, gC = Jh ? Jh.boxStartIndex : zn.collisionBoxArray.length, vC = Jh ? Jh.boxEndIndex : zn.collisionBoxArray.length, _C = ef ? ef.boxStartIndex : zn.collisionBoxArray.length, xC = ef ? ef.boxEndIndex : zn.collisionBoxArray.length, Ns = -1, yy = function(Up, Lb) {
                  return Up && Up.circleDiameter ? Math.max(Up.circleDiameter, Lb) : Lb;
                };
                Ns = yy(Sc, Ns), Ns = yy(Qh, Ns), Ns = yy(Jh, Ns);
                var kb = (Ns = yy(ef, Ns)) > -1 ? 1 : 0;
                kb && (Ns *= hC / 24), zn.glyphOffsetArray.length >= Wr.MAX_GLYPHS && at("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Yo.sortKey !== void 0 && zn.addToSortKeyRanges(zn.symbolInstances.length, Yo.sortKey), zn.symbolInstances.emplaceBack(Ha.x, Ha.y, Pl.right >= 0 ? Pl.right : -1, Pl.center >= 0 ? Pl.center : -1, Pl.left >= 0 ? Pl.left : -1, Pl.vertical || -1, T_, M_, Tb, pC, dC, mC, yC, gC, vC, _C, xC, Fp, Eb, Sb, bb, wb, kb, 0, S_, I_, O_, Ns);
              }(vr, zp, uC, qr, Or, ro, As, vr.layers[0], vr.collisionBoxArray, Xr.index, Xr.sourceLayerIndex, vr.index, wc, ry, ny, Ni, Ol, Wh, iy, ks, Xr, Di, Dr, Ps, ln);
            };
            if (Cl === "line")
              for (var Zh = 0, oy = $1(Xr.geometry, 0, 0, 8192, 8192); Zh < oy.length; Zh += 1)
                for (var ay = oy[Zh], Pp = 0, Ap = WO(ay, qh, Op, qr.vertical || Ma, Or, 24, $h, vr.overscaling, 8192); Pp < Ap.length; Pp += 1) {
                  var sy = Ap[Pp];
                  Ma && KO(vr, Ma.text, Cp, sy) || fu(ay, sy);
                }
            else if (Cl === "line-center")
              for (var kp = 0, Lp = Xr.geometry; kp < Lp.length; kp += 1) {
                var Dp = Lp[kp];
                if (Dp.length > 1) {
                  var ly = qO(Dp, Op, qr.vertical || Ma, Or, 24, $h);
                  ly && fu(Dp, ly);
                }
              }
            else if (Xr.type === "Polygon")
              for (var Xh = 0, uy = a_(Xr.geometry, 0); Xh < uy.length; Xh += 1) {
                var Kh = uy[Xh], Np = ZO(Kh, 16);
                fu(Kh[0], new Rh(Np.x, Np.y, 0));
              }
            else if (Xr.type === "LineString")
              for (var Ec = 0, Rp = Xr.geometry; Ec < Rp.length; Ec += 1) {
                var Yh = Rp[Ec];
                fu(Yh, new Rh(Yh[0].x, Yh[0].y, 0));
              }
            else if (Xr.type === "Point")
              for (var x_ = 0, cb = Xr.geometry; x_ < cb.length; x_ += 1)
                for (var b_ = 0, hb = cb[x_]; b_ < hb.length; b_ += 1) {
                  var w_ = hb[b_];
                  fu([w_], new Rh(w_.x, w_.y, 0));
                }
          }(r, Oe, dt, xi, p, P, ot, Pt, yt, Hi, x);
        }, we = 0, Te = r.features; we < Te.length; we += 1)
          ge();
        v && r.generateCollisionDebugBuffers();
      }, o.perspective = function(r, i, l, p, y) {
        var v, x = 1 / Math.tan(i / 2);
        return r[0] = x / l, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = x, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, y != null && y !== 1 / 0 ? (r[10] = (y + p) * (v = 1 / (p - y)), r[14] = 2 * y * p * v) : (r[10] = -1, r[14] = -2 * p), r;
      }, o.pick = function(r, i) {
        for (var l = {}, p = 0; p < i.length; p++) {
          var y = i[p];
          y in r && (l[y] = r[y]);
        }
        return l;
      }, o.plugin = Io, o.polygonIntersectsPolygon = Is, o.postMapLoadEvent = Jr, o.postTurnstileEvent = Vr, o.potpack = L1, o.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], o.register = wt, o.registerForPluginStateChange = function(r) {
        return r({ pluginStatus: fo, pluginURL: ja }), up.on("pluginStateChange", r), r;
      }, o.renderColorRamp = d1, o.rotate = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2], x = i[3], S = Math.sin(l), C = Math.cos(l);
        return r[0] = p * C + v * S, r[1] = y * C + x * S, r[2] = p * -S + v * C, r[3] = y * -S + x * C, r;
      }, o.rotateX = function(r, i, l) {
        var p = Math.sin(l), y = Math.cos(l), v = i[4], x = i[5], S = i[6], C = i[7], P = i[8], L = i[9], D = i[10], B = i[11];
        return i !== r && (r[0] = i[0], r[1] = i[1], r[2] = i[2], r[3] = i[3], r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15]), r[4] = v * y + P * p, r[5] = x * y + L * p, r[6] = S * y + D * p, r[7] = C * y + B * p, r[8] = P * y - v * p, r[9] = L * y - x * p, r[10] = D * y - S * p, r[11] = B * y - C * p, r;
      }, o.rotateZ = function(r, i, l) {
        var p = Math.sin(l), y = Math.cos(l), v = i[0], x = i[1], S = i[2], C = i[3], P = i[4], L = i[5], D = i[6], B = i[7];
        return i !== r && (r[8] = i[8], r[9] = i[9], r[10] = i[10], r[11] = i[11], r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15]), r[0] = v * y + P * p, r[1] = x * y + L * p, r[2] = S * y + D * p, r[3] = C * y + B * p, r[4] = P * y - v * p, r[5] = L * y - x * p, r[6] = D * y - S * p, r[7] = B * y - C * p, r;
      }, o.scale = function(r, i, l) {
        var p = l[0], y = l[1], v = l[2];
        return r[0] = i[0] * p, r[1] = i[1] * p, r[2] = i[2] * p, r[3] = i[3] * p, r[4] = i[4] * y, r[5] = i[5] * y, r[6] = i[6] * y, r[7] = i[7] * y, r[8] = i[8] * v, r[9] = i[9] * v, r[10] = i[10] * v, r[11] = i[11] * v, r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15], r;
      }, o.scale$1 = function(r, i, l) {
        return r[0] = i[0] * l, r[1] = i[1] * l, r[2] = i[2] * l, r[3] = i[3] * l, r;
      }, o.scale$2 = function(r, i, l) {
        return r[0] = i[0] * l, r[1] = i[1] * l, r[2] = i[2] * l, r;
      }, o.setCacheLimits = function(r, i) {
        Xn = r, Bi = i;
      }, o.setRTLTextPlugin = function(r, i, l) {
        if (l === void 0 && (l = !1), fo === "deferred" || fo === "loading" || fo === "loaded")
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        ja = Vn.resolveURL(r), fo = "deferred", wh = i, cc(), l || sa();
      }, o.sphericalToCartesian = function(r) {
        var i = r[0], l = r[1], p = r[2];
        return l += 90, l *= Math.PI / 180, p *= Math.PI / 180, { x: i * Math.cos(l) * Math.sin(p), y: i * Math.sin(l) * Math.sin(p), z: i * Math.cos(p) };
      }, o.sqrLen = function(r) {
        var i = r[0], l = r[1];
        return i * i + l * l;
      }, o.styleSpec = G, o.sub = function(r, i, l) {
        return r[0] = i[0] - l[0], r[1] = i[1] - l[1], r[2] = i[2] - l[2], r;
      }, o.symbolSize = $O, o.transformMat3 = function(r, i, l) {
        var p = i[0], y = i[1], v = i[2];
        return r[0] = p * l[0] + y * l[3] + v * l[6], r[1] = p * l[1] + y * l[4] + v * l[7], r[2] = p * l[2] + y * l[5] + v * l[8], r;
      }, o.transformMat4 = Oh, o.translate = function(r, i, l) {
        var p, y, v, x, S, C, P, L, D, B, j, J, ee = l[0], he = l[1], oe = l[2];
        return i === r ? (r[12] = i[0] * ee + i[4] * he + i[8] * oe + i[12], r[13] = i[1] * ee + i[5] * he + i[9] * oe + i[13], r[14] = i[2] * ee + i[6] * he + i[10] * oe + i[14], r[15] = i[3] * ee + i[7] * he + i[11] * oe + i[15]) : (y = i[1], v = i[2], x = i[3], S = i[4], C = i[5], P = i[6], L = i[7], D = i[8], B = i[9], j = i[10], J = i[11], r[0] = p = i[0], r[1] = y, r[2] = v, r[3] = x, r[4] = S, r[5] = C, r[6] = P, r[7] = L, r[8] = D, r[9] = B, r[10] = j, r[11] = J, r[12] = p * ee + S * he + D * oe + i[12], r[13] = y * ee + C * he + B * oe + i[13], r[14] = v * ee + P * he + j * oe + i[14], r[15] = x * ee + L * he + J * oe + i[15]), r;
      }, o.triggerPluginCompletionEvent = Rm, o.uniqueId = ce, o.validateCustomStyleLayer = function(r) {
        var i = [], l = r.id;
        return l === void 0 && i.push({ message: "layers." + l + ': missing required property "id"' }), r.render === void 0 && i.push({ message: "layers." + l + ': missing required method "render"' }), r.renderingMode && r.renderingMode !== "2d" && r.renderingMode !== "3d" && i.push({ message: "layers." + l + ': property "renderingMode" must be either "2d" or "3d"' }), i;
      }, o.validateLight = Yv, o.validateStyle = ac, o.values = function(r) {
        var i = [];
        for (var l in r)
          i.push(r[l]);
        return i;
      }, o.vectorTile = kh, o.version = "1.13.3", o.warnOnce = at, o.webpSupported = Sn, o.window = I, o.wrap = re;
    }), f(["./shared"], function(o) {
      function m(N) {
        var F = typeof N;
        if (F === "number" || F === "boolean" || F === "string" || N == null)
          return JSON.stringify(N);
        if (Array.isArray(N)) {
          for (var U = "[", Z = 0, Q = N; Z < Q.length; Z += 1)
            U += m(Q[Z]) + ",";
          return U + "]";
        }
        for (var pe = Object.keys(N).sort(), de = "{", G = 0; G < pe.length; G++)
          de += JSON.stringify(pe[G]) + ":" + m(N[pe[G]]) + ",";
        return de + "}";
      }
      function g(N) {
        for (var F = "", U = 0, Z = o.refProperties; U < Z.length; U += 1)
          F += "/" + m(N[Z[U]]);
        return F;
      }
      var b = function(N) {
        this.keyCache = {}, N && this.replace(N);
      };
      b.prototype.replace = function(N) {
        this._layerConfigs = {}, this._layers = {}, this.update(N, []);
      }, b.prototype.update = function(N, F) {
        for (var U = this, Z = 0, Q = N; Z < Q.length; Z += 1) {
          var pe = Q[Z];
          this._layerConfigs[pe.id] = pe;
          var de = this._layers[pe.id] = o.createStyleLayer(pe);
          de._featureFilter = o.featureFilter(de.filter), this.keyCache[pe.id] && delete this.keyCache[pe.id];
        }
        for (var G = 0, ie = F; G < ie.length; G += 1) {
          var _e = ie[G];
          delete this.keyCache[_e], delete this._layerConfigs[_e], delete this._layers[_e];
        }
        this.familiesBySource = {};
        for (var Ge = 0, Ze = function(st, De) {
          for (var fe = {}, Ee = 0; Ee < st.length; Ee++) {
            var He = De && De[st[Ee].id] || g(st[Ee]);
            De && (De[st[Ee].id] = He);
            var jt = fe[He];
            jt || (jt = fe[He] = []), jt.push(st[Ee]);
          }
          var qt = [];
          for (var Jt in fe)
            qt.push(fe[Jt]);
          return qt;
        }(o.values(this._layerConfigs), this.keyCache); Ge < Ze.length; Ge += 1) {
          var Ce = Ze[Ge].map(function(st) {
            return U._layers[st.id];
          }), Ue = Ce[0];
          if (Ue.visibility !== "none") {
            var Et = Ue.source || "", _t = this.familiesBySource[Et];
            _t || (_t = this.familiesBySource[Et] = {});
            var Le = Ue.sourceLayer || "_geojsonTileLayer", pt = _t[Le];
            pt || (pt = _t[Le] = []), pt.push(Ce);
          }
        }
      };
      var T = function(N) {
        var F = {}, U = [];
        for (var Z in N) {
          var Q = N[Z], pe = F[Z] = {};
          for (var de in Q) {
            var G = Q[+de];
            if (G && G.bitmap.width !== 0 && G.bitmap.height !== 0) {
              var ie = { x: 0, y: 0, w: G.bitmap.width + 2, h: G.bitmap.height + 2 };
              U.push(ie), pe[de] = { rect: ie, metrics: G.metrics };
            }
          }
        }
        var _e = o.potpack(U), Ge = new o.AlphaImage({ width: _e.w || 1, height: _e.h || 1 });
        for (var Ze in N) {
          var Ce = N[Ze];
          for (var Ue in Ce) {
            var Et = Ce[+Ue];
            if (Et && Et.bitmap.width !== 0 && Et.bitmap.height !== 0) {
              var _t = F[Ze][Ue].rect;
              o.AlphaImage.copy(Et.bitmap, Ge, { x: 0, y: 0 }, { x: _t.x + 1, y: _t.y + 1 }, Et.bitmap);
            }
          }
        }
        this.image = Ge, this.positions = F;
      };
      o.register("GlyphAtlas", T);
      var M = function(N) {
        this.tileID = new o.OverscaledTileID(N.tileID.overscaledZ, N.tileID.wrap, N.tileID.canonical.z, N.tileID.canonical.x, N.tileID.canonical.y), this.uid = N.uid, this.zoom = N.zoom, this.pixelRatio = N.pixelRatio, this.tileSize = N.tileSize, this.source = N.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = N.showCollisionBoxes, this.collectResourceTiming = !!N.collectResourceTiming, this.returnDependencies = !!N.returnDependencies, this.promoteId = N.promoteId;
      };
      function I(N, F, U) {
        for (var Z = new o.EvaluationParameters(F), Q = 0, pe = N; Q < pe.length; Q += 1)
          pe[Q].recalculate(Z, U);
      }
      function A(N, F) {
        var U = o.getArrayBuffer(N.request, function(Z, Q, pe, de) {
          Z ? F(Z) : Q && F(null, { vectorTile: new o.vectorTile.VectorTile(new o.pbf(Q)), rawData: Q, cacheControl: pe, expires: de });
        });
        return function() {
          U.cancel(), F();
        };
      }
      M.prototype.parse = function(N, F, U, Z, Q) {
        var pe = this;
        this.status = "parsing", this.data = N, this.collisionBoxArray = new o.CollisionBoxArray();
        var de = new o.DictionaryCoder(Object.keys(N.layers).sort()), G = new o.FeatureIndex(this.tileID, this.promoteId);
        G.bucketLayerIDs = [];
        var ie, _e, Ge, Ze, Ce = {}, Ue = { featureIndex: G, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: U }, Et = F.familiesBySource[this.source];
        for (var _t in Et) {
          var Le = N.layers[_t];
          if (Le) {
            Le.version === 1 && o.warnOnce('Vector tile source "' + this.source + '" layer "' + _t + '" does not use vector tile spec v2 and therefore may have some rendering errors.');
            for (var pt = de.encode(_t), st = [], De = 0; De < Le.length; De++) {
              var fe = Le.feature(De), Ee = G.getId(fe, _t);
              st.push({ feature: fe, id: Ee, index: De, sourceLayerIndex: pt });
            }
            for (var He = 0, jt = Et[_t]; He < jt.length; He += 1) {
              var qt = jt[He], Jt = qt[0];
              Jt.minzoom && this.zoom < Math.floor(Jt.minzoom) || Jt.maxzoom && this.zoom >= Jt.maxzoom || Jt.visibility !== "none" && (I(qt, this.zoom, U), (Ce[Jt.id] = Jt.createBucket({ index: G.bucketLayerIDs.length, layers: qt, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: pt, sourceID: this.source })).populate(st, Ue, this.tileID.canonical), G.bucketLayerIDs.push(qt.map(function(Ur) {
                return Ur.id;
              })));
            }
          }
        }
        var Zt = o.mapObject(Ue.glyphDependencies, function(Ur) {
          return Object.keys(Ur).map(Number);
        });
        Object.keys(Zt).length ? Z.send("getGlyphs", { uid: this.uid, stacks: Zt }, function(Ur, gr) {
          ie || (ie = Ur, _e = gr, dn.call(pe));
        }) : _e = {};
        var Yn = Object.keys(Ue.iconDependencies);
        Yn.length ? Z.send("getImages", { icons: Yn, source: this.source, tileID: this.tileID, type: "icons" }, function(Ur, gr) {
          ie || (ie = Ur, Ge = gr, dn.call(pe));
        }) : Ge = {};
        var Qt = Object.keys(Ue.patternDependencies);
        function dn() {
          if (ie)
            return Q(ie);
          if (_e && Ge && Ze) {
            var Ur = new T(_e), gr = new o.ImageAtlas(Ge, Ze);
            for (var zr in Ce) {
              var Yi = Ce[zr];
              Yi instanceof o.SymbolBucket ? (I(Yi.layers, this.zoom, U), o.performSymbolLayout(Yi, _e, Ur.positions, Ge, gr.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : Yi.hasPattern && (Yi instanceof o.LineBucket || Yi instanceof o.FillBucket || Yi instanceof o.FillExtrusionBucket) && (I(Yi.layers, this.zoom, U), Yi.addFeatures(Ue, this.tileID.canonical, gr.patternPositions));
            }
            this.status = "done", Q(null, { buckets: o.values(Ce).filter(function(Zu) {
              return !Zu.isEmpty();
            }), featureIndex: G, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Ur.image, imageAtlas: gr, glyphMap: this.returnDependencies ? _e : null, iconMap: this.returnDependencies ? Ge : null, glyphPositions: this.returnDependencies ? Ur.positions : null });
          }
        }
        Qt.length ? Z.send("getImages", { icons: Qt, source: this.source, tileID: this.tileID, type: "patterns" }, function(Ur, gr) {
          ie || (ie = Ur, Ze = gr, dn.call(pe));
        }) : Ze = {}, dn.call(this);
      };
      var z = function(N, F, U, Z) {
        this.actor = N, this.layerIndex = F, this.availableImages = U, this.loadVectorData = Z || A, this.loading = {}, this.loaded = {};
      };
      z.prototype.loadTile = function(N, F) {
        var U = this, Z = N.uid;
        this.loading || (this.loading = {});
        var Q = !!(N && N.request && N.request.collectResourceTiming) && new o.RequestPerformance(N.request), pe = this.loading[Z] = new M(N);
        pe.abort = this.loadVectorData(N, function(de, G) {
          if (delete U.loading[Z], de || !G)
            return pe.status = "done", U.loaded[Z] = pe, F(de);
          var ie = G.rawData, _e = {};
          G.expires && (_e.expires = G.expires), G.cacheControl && (_e.cacheControl = G.cacheControl);
          var Ge = {};
          if (Q) {
            var Ze = Q.finish();
            Ze && (Ge.resourceTiming = JSON.parse(JSON.stringify(Ze)));
          }
          pe.vectorTile = G.vectorTile, pe.parse(G.vectorTile, U.layerIndex, U.availableImages, U.actor, function(Ce, Ue) {
            if (Ce || !Ue)
              return F(Ce);
            F(null, o.extend({ rawTileData: ie.slice(0) }, Ue, _e, Ge));
          }), U.loaded = U.loaded || {}, U.loaded[Z] = pe;
        });
      }, z.prototype.reloadTile = function(N, F) {
        var U = this, Z = this.loaded, Q = N.uid, pe = this;
        if (Z && Z[Q]) {
          var de = Z[Q];
          de.showCollisionBoxes = N.showCollisionBoxes;
          var G = function(ie, _e) {
            var Ge = de.reloadCallback;
            Ge && (delete de.reloadCallback, de.parse(de.vectorTile, pe.layerIndex, U.availableImages, pe.actor, Ge)), F(ie, _e);
          };
          de.status === "parsing" ? de.reloadCallback = G : de.status === "done" && (de.vectorTile ? de.parse(de.vectorTile, this.layerIndex, this.availableImages, this.actor, G) : G());
        }
      }, z.prototype.abortTile = function(N, F) {
        var U = this.loading, Z = N.uid;
        U && U[Z] && U[Z].abort && (U[Z].abort(), delete U[Z]), F();
      }, z.prototype.removeTile = function(N, F) {
        var U = this.loaded, Z = N.uid;
        U && U[Z] && delete U[Z], F();
      };
      var V = o.window.ImageBitmap, q = function() {
        this.loaded = {};
      };
      function re(N, F) {
        if (N.length !== 0) {
          X(N[0], F);
          for (var U = 1; U < N.length; U++)
            X(N[U], !F);
        }
      }
      function X(N, F) {
        for (var U = 0, Z = 0, Q = 0, pe = N.length, de = pe - 1; Q < pe; de = Q++) {
          var G = (N[Q][0] - N[de][0]) * (N[de][1] + N[Q][1]), ie = U + G;
          Z += Math.abs(U) >= Math.abs(G) ? U - ie + G : G - ie + U, U = ie;
        }
        U + Z >= 0 != !!F && N.reverse();
      }
      q.prototype.loadTile = function(N, F) {
        var U = N.uid, Z = N.encoding, Q = N.rawImageData, pe = V && Q instanceof V ? this.getImageData(Q) : Q, de = new o.DEMData(U, pe, Z);
        this.loaded = this.loaded || {}, this.loaded[U] = de, F(null, de);
      }, q.prototype.getImageData = function(N) {
        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(N.width, N.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = N.width, this.offscreenCanvas.height = N.height, this.offscreenCanvasContext.drawImage(N, 0, 0, N.width, N.height);
        var F = this.offscreenCanvasContext.getImageData(-1, -1, N.width + 2, N.height + 2);
        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new o.RGBAImage({ width: F.width, height: F.height }, F.data);
      }, q.prototype.removeTile = function(N) {
        var F = this.loaded, U = N.uid;
        F && F[U] && delete F[U];
      };
      var ae = o.vectorTile.VectorTileFeature.prototype.toGeoJSON, ce = function(N) {
        this._feature = N, this.extent = o.EXTENT, this.type = N.type, this.properties = N.tags, "id" in N && !isNaN(N.id) && (this.id = parseInt(N.id, 10));
      };
      ce.prototype.loadGeometry = function() {
        if (this._feature.type === 1) {
          for (var N = [], F = 0, U = this._feature.geometry; F < U.length; F += 1) {
            var Z = U[F];
            N.push([new o.Point$1(Z[0], Z[1])]);
          }
          return N;
        }
        for (var Q = [], pe = 0, de = this._feature.geometry; pe < de.length; pe += 1) {
          for (var G = [], ie = 0, _e = de[pe]; ie < _e.length; ie += 1) {
            var Ge = _e[ie];
            G.push(new o.Point$1(Ge[0], Ge[1]));
          }
          Q.push(G);
        }
        return Q;
      }, ce.prototype.toGeoJSON = function(N, F, U) {
        return ae.call(this, N, F, U);
      };
      var ve = function(N) {
        this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = o.EXTENT, this.length = N.length, this._features = N;
      };
      ve.prototype.feature = function(N) {
        return new ce(this._features[N]);
      };
      var Ne = o.vectorTile.VectorTileFeature, ze = Ae;
      function Ae(N, F) {
        this.options = F || {}, this.features = N, this.length = N.length;
      }
      function Se(N, F) {
        this.id = typeof N.id == "number" ? N.id : void 0, this.type = N.type, this.rawGeometry = N.type === 1 ? [N.geometry] : N.geometry, this.properties = N.tags, this.extent = F || 4096;
      }
      Ae.prototype.feature = function(N) {
        return new Se(this.features[N], this.options.extent);
      }, Se.prototype.loadGeometry = function() {
        var N = this.rawGeometry;
        this.geometry = [];
        for (var F = 0; F < N.length; F++) {
          for (var U = N[F], Z = [], Q = 0; Q < U.length; Q++)
            Z.push(new o.Point$1(U[Q][0], U[Q][1]));
          this.geometry.push(Z);
        }
        return this.geometry;
      }, Se.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var N = this.geometry, F = 1 / 0, U = -1 / 0, Z = 1 / 0, Q = -1 / 0, pe = 0; pe < N.length; pe++)
          for (var de = N[pe], G = 0; G < de.length; G++) {
            var ie = de[G];
            F = Math.min(F, ie.x), U = Math.max(U, ie.x), Z = Math.min(Z, ie.y), Q = Math.max(Q, ie.y);
          }
        return [F, Z, U, Q];
      }, Se.prototype.toGeoJSON = Ne.prototype.toGeoJSON;
      var Ie = $e, Xe = ze;
      function $e(N) {
        var F = new o.pbf();
        return function(U, Z) {
          for (var Q in U.layers)
            Z.writeMessage(3, at, U.layers[Q]);
        }(N, F), F.finish();
      }
      function at(N, F) {
        var U;
        F.writeVarintField(15, N.version || 1), F.writeStringField(1, N.name || ""), F.writeVarintField(5, N.extent || 4096);
        var Z = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (U = 0; U < N.length; U++)
          Z.feature = N.feature(U), F.writeMessage(2, be, Z);
        var Q = Z.keys;
        for (U = 0; U < Q.length; U++)
          F.writeStringField(3, Q[U]);
        var pe = Z.values;
        for (U = 0; U < pe.length; U++)
          F.writeMessage(4, tr, pe[U]);
      }
      function be(N, F) {
        var U = N.feature;
        U.id !== void 0 && F.writeVarintField(1, U.id), F.writeMessage(2, Je, N), F.writeVarintField(3, U.type), F.writeMessage(4, At, U);
      }
      function Je(N, F) {
        var U = N.feature, Z = N.keys, Q = N.values, pe = N.keycache, de = N.valuecache;
        for (var G in U.properties) {
          var ie = pe[G];
          ie === void 0 && (Z.push(G), pe[G] = ie = Z.length - 1), F.writeVarint(ie);
          var _e = U.properties[G], Ge = typeof _e;
          Ge !== "string" && Ge !== "boolean" && Ge !== "number" && (_e = JSON.stringify(_e));
          var Ze = Ge + ":" + _e, Ce = de[Ze];
          Ce === void 0 && (Q.push(_e), de[Ze] = Ce = Q.length - 1), F.writeVarint(Ce);
        }
      }
      function ht(N, F) {
        return (F << 3) + (7 & N);
      }
      function vt(N) {
        return N << 1 ^ N >> 31;
      }
      function At(N, F) {
        for (var U = N.loadGeometry(), Z = N.type, Q = 0, pe = 0, de = U.length, G = 0; G < de; G++) {
          var ie = U[G], _e = 1;
          Z === 1 && (_e = ie.length), F.writeVarint(ht(1, _e));
          for (var Ge = Z === 3 ? ie.length - 1 : ie.length, Ze = 0; Ze < Ge; Ze++) {
            Ze === 1 && Z !== 1 && F.writeVarint(ht(2, Ge - 1));
            var Ce = ie[Ze].x - Q, Ue = ie[Ze].y - pe;
            F.writeVarint(vt(Ce)), F.writeVarint(vt(Ue)), Q += Ce, pe += Ue;
          }
          Z === 3 && F.writeVarint(ht(7, 1));
        }
      }
      function tr(N, F) {
        var U = typeof N;
        U === "string" ? F.writeStringField(1, N) : U === "boolean" ? F.writeBooleanField(7, N) : U === "number" && (N % 1 != 0 ? F.writeDoubleField(3, N) : N < 0 ? F.writeSVarintField(6, N) : F.writeVarintField(5, N));
      }
      function kn(N, F, U, Z) {
        Nr(N, U, Z), Nr(F, 2 * U, 2 * Z), Nr(F, 2 * U + 1, 2 * Z + 1);
      }
      function Nr(N, F, U) {
        var Z = N[F];
        N[F] = N[U], N[U] = Z;
      }
      function pr(N, F, U, Z) {
        var Q = N - U, pe = F - Z;
        return Q * Q + pe * pe;
      }
      Ie.fromVectorTileJs = $e, Ie.fromGeojsonVt = function(N, F) {
        F = F || {};
        var U = {};
        for (var Z in N)
          U[Z] = new ze(N[Z].features, F), U[Z].name = Z, U[Z].version = F.version, U[Z].extent = F.extent;
        return $e({ layers: U });
      }, Ie.GeoJSONWrapper = Xe;
      var Zn = function(N) {
        return N[0];
      }, Rr = function(N) {
        return N[1];
      }, Fi = function(N, F, U, Z, Q) {
        F === void 0 && (F = Zn), U === void 0 && (U = Rr), Z === void 0 && (Z = 64), Q === void 0 && (Q = Float64Array), this.nodeSize = Z, this.points = N;
        for (var pe = N.length < 65536 ? Uint16Array : Uint32Array, de = this.ids = new pe(N.length), G = this.coords = new Q(2 * N.length), ie = 0; ie < N.length; ie++)
          de[ie] = ie, G[2 * ie] = F(N[ie]), G[2 * ie + 1] = U(N[ie]);
        (function _e(Ge, Ze, Ce, Ue, Et, _t) {
          if (!(Et - Ue <= Ce)) {
            var Le = Ue + Et >> 1;
            (function pt(st, De, fe, Ee, He, jt) {
              for (; He > Ee; ) {
                if (He - Ee > 600) {
                  var qt = He - Ee + 1, Jt = fe - Ee + 1, Zt = Math.log(qt), Yn = 0.5 * Math.exp(2 * Zt / 3), Qt = 0.5 * Math.sqrt(Zt * Yn * (qt - Yn) / qt) * (Jt - qt / 2 < 0 ? -1 : 1);
                  pt(st, De, fe, Math.max(Ee, Math.floor(fe - Jt * Yn / qt + Qt)), Math.min(He, Math.floor(fe + (qt - Jt) * Yn / qt + Qt)), jt);
                }
                var dn = De[2 * fe + jt], Ur = Ee, gr = He;
                for (kn(st, De, Ee, fe), De[2 * He + jt] > dn && kn(st, De, Ee, He); Ur < gr; ) {
                  for (kn(st, De, Ur, gr), Ur++, gr--; De[2 * Ur + jt] < dn; )
                    Ur++;
                  for (; De[2 * gr + jt] > dn; )
                    gr--;
                }
                De[2 * Ee + jt] === dn ? kn(st, De, Ee, gr) : kn(st, De, ++gr, He), gr <= fe && (Ee = gr + 1), fe <= gr && (He = gr - 1);
              }
            })(Ge, Ze, Le, Ue, Et, _t % 2), _e(Ge, Ze, Ce, Ue, Le - 1, _t + 1), _e(Ge, Ze, Ce, Le + 1, Et, _t + 1);
          }
        })(de, G, Z, 0, de.length - 1, 0);
      };
      Fi.prototype.range = function(N, F, U, Z) {
        return function(Q, pe, de, G, ie, _e, Ge) {
          for (var Ze, Ce, Ue = [0, Q.length - 1, 0], Et = []; Ue.length; ) {
            var _t = Ue.pop(), Le = Ue.pop(), pt = Ue.pop();
            if (Le - pt <= Ge)
              for (var st = pt; st <= Le; st++)
                Ce = pe[2 * st + 1], (Ze = pe[2 * st]) >= de && Ze <= ie && Ce >= G && Ce <= _e && Et.push(Q[st]);
            else {
              var De = Math.floor((pt + Le) / 2);
              Ce = pe[2 * De + 1], (Ze = pe[2 * De]) >= de && Ze <= ie && Ce >= G && Ce <= _e && Et.push(Q[De]);
              var fe = (_t + 1) % 2;
              (_t === 0 ? de <= Ze : G <= Ce) && (Ue.push(pt), Ue.push(De - 1), Ue.push(fe)), (_t === 0 ? ie >= Ze : _e >= Ce) && (Ue.push(De + 1), Ue.push(Le), Ue.push(fe));
            }
          }
          return Et;
        }(this.ids, this.coords, N, F, U, Z, this.nodeSize);
      }, Fi.prototype.within = function(N, F, U) {
        return function(Z, Q, pe, de, G, ie) {
          for (var _e = [0, Z.length - 1, 0], Ge = [], Ze = G * G; _e.length; ) {
            var Ce = _e.pop(), Ue = _e.pop(), Et = _e.pop();
            if (Ue - Et <= ie)
              for (var _t = Et; _t <= Ue; _t++)
                pr(Q[2 * _t], Q[2 * _t + 1], pe, de) <= Ze && Ge.push(Z[_t]);
            else {
              var Le = Math.floor((Et + Ue) / 2), pt = Q[2 * Le], st = Q[2 * Le + 1];
              pr(pt, st, pe, de) <= Ze && Ge.push(Z[Le]);
              var De = (Ce + 1) % 2;
              (Ce === 0 ? pe - G <= pt : de - G <= st) && (_e.push(Et), _e.push(Le - 1), _e.push(De)), (Ce === 0 ? pe + G >= pt : de + G >= st) && (_e.push(Le + 1), _e.push(Ue), _e.push(De));
            }
          }
          return Ge;
        }(this.ids, this.coords, N, F, U, this.nodeSize);
      };
      var $r = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: function(N) {
        return N;
      } }, Ar = function(N) {
        this.options = ye(Object.create($r), N), this.trees = new Array(this.options.maxZoom + 1);
      };
      function Vn(N, F, U, Z, Q) {
        return { x: N, y: F, zoom: 1 / 0, id: U, parentId: -1, numPoints: Z, properties: Q };
      }
      function Sr(N, F) {
        var U = N.geometry.coordinates, Z = U[1];
        return { x: Un(U[0]), y: K(Z), zoom: 1 / 0, index: F, parentId: -1 };
      }
      function Sn(N) {
        return { type: "Feature", id: N.id, properties: ai(N), geometry: { type: "Point", coordinates: [(Z = N.x, 360 * (Z - 0.5)), (F = N.y, U = (180 - 360 * F) * Math.PI / 180, 360 * Math.atan(Math.exp(U)) / Math.PI - 90)] } };
        var F, U, Z;
      }
      function ai(N) {
        var F = N.numPoints, U = F >= 1e4 ? Math.round(F / 1e3) + "k" : F >= 1e3 ? Math.round(F / 100) / 10 + "k" : F;
        return ye(ye({}, N.properties), { cluster: !0, cluster_id: N.id, point_count: F, point_count_abbreviated: U });
      }
      function Un(N) {
        return N / 360 + 0.5;
      }
      function K(N) {
        var F = Math.sin(N * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + F) / (1 - F)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function ye(N, F) {
        for (var U in F)
          N[U] = F[U];
        return N;
      }
      function Re(N) {
        return N.x;
      }
      function qe(N) {
        return N.y;
      }
      function We(N, F, U, Z, Q, pe) {
        var de = Q - U, G = pe - Z;
        if (de !== 0 || G !== 0) {
          var ie = ((N - U) * de + (F - Z) * G) / (de * de + G * G);
          ie > 1 ? (U = Q, Z = pe) : ie > 0 && (U += de * ie, Z += G * ie);
        }
        return (de = N - U) * de + (G = F - Z) * G;
      }
      function nt(N, F, U, Z) {
        var Q = { id: N === void 0 ? null : N, type: F, geometry: U, tags: Z, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(pe) {
          var de = pe.geometry, G = pe.type;
          if (G === "Point" || G === "MultiPoint" || G === "LineString")
            mt(pe, de);
          else if (G === "Polygon" || G === "MultiLineString")
            for (var ie = 0; ie < de.length; ie++)
              mt(pe, de[ie]);
          else if (G === "MultiPolygon")
            for (ie = 0; ie < de.length; ie++)
              for (var _e = 0; _e < de[ie].length; _e++)
                mt(pe, de[ie][_e]);
        }(Q), Q;
      }
      function mt(N, F) {
        for (var U = 0; U < F.length; U += 3)
          N.minX = Math.min(N.minX, F[U]), N.minY = Math.min(N.minY, F[U + 1]), N.maxX = Math.max(N.maxX, F[U]), N.maxY = Math.max(N.maxY, F[U + 1]);
      }
      function et(N, F, U, Z) {
        if (F.geometry) {
          var Q = F.geometry.coordinates, pe = F.geometry.type, de = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2), G = [], ie = F.id;
          if (U.promoteId ? ie = F.properties[U.promoteId] : U.generateId && (ie = Z || 0), pe === "Point")
            ut(Q, G);
          else if (pe === "MultiPoint")
            for (var _e = 0; _e < Q.length; _e++)
              ut(Q[_e], G);
          else if (pe === "LineString")
            Qe(Q, G, de, !1);
          else if (pe === "MultiLineString") {
            if (U.lineMetrics) {
              for (_e = 0; _e < Q.length; _e++)
                Qe(Q[_e], G = [], de, !1), N.push(nt(ie, "LineString", G, F.properties));
              return;
            }
            It(Q, G, de, !1);
          } else if (pe === "Polygon")
            It(Q, G, de, !0);
          else {
            if (pe !== "MultiPolygon") {
              if (pe === "GeometryCollection") {
                for (_e = 0; _e < F.geometry.geometries.length; _e++)
                  et(N, { id: ie, geometry: F.geometry.geometries[_e], properties: F.properties }, U, Z);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (_e = 0; _e < Q.length; _e++) {
              var Ge = [];
              It(Q[_e], Ge, de, !0), G.push(Ge);
            }
          }
          N.push(nt(ie, pe, G, F.properties));
        }
      }
      function ut(N, F) {
        F.push(bt(N[0])), F.push(Lt(N[1])), F.push(0);
      }
      function Qe(N, F, U, Z) {
        for (var Q, pe, de = 0, G = 0; G < N.length; G++) {
          var ie = bt(N[G][0]), _e = Lt(N[G][1]);
          F.push(ie), F.push(_e), F.push(0), G > 0 && (de += Z ? (Q * _e - ie * pe) / 2 : Math.sqrt(Math.pow(ie - Q, 2) + Math.pow(_e - pe, 2))), Q = ie, pe = _e;
        }
        var Ge = F.length - 3;
        F[2] = 1, function Ze(Ce, Ue, Et, _t) {
          for (var Le, pt = _t, st = Et - Ue >> 1, De = Et - Ue, fe = Ce[Ue], Ee = Ce[Ue + 1], He = Ce[Et], jt = Ce[Et + 1], qt = Ue + 3; qt < Et; qt += 3) {
            var Jt = We(Ce[qt], Ce[qt + 1], fe, Ee, He, jt);
            if (Jt > pt)
              Le = qt, pt = Jt;
            else if (Jt === pt) {
              var Zt = Math.abs(qt - st);
              Zt < De && (Le = qt, De = Zt);
            }
          }
          pt > _t && (Le - Ue > 3 && Ze(Ce, Ue, Le, _t), Ce[Le + 2] = pt, Et - Le > 3 && Ze(Ce, Le, Et, _t));
        }(F, 0, Ge, U), F[Ge + 2] = 1, F.size = Math.abs(de), F.start = 0, F.end = F.size;
      }
      function It(N, F, U, Z) {
        for (var Q = 0; Q < N.length; Q++) {
          var pe = [];
          Qe(N[Q], pe, U, Z), F.push(pe);
        }
      }
      function bt(N) {
        return N / 360 + 0.5;
      }
      function Lt(N) {
        var F = Math.sin(N * Math.PI / 180), U = 0.5 - 0.25 * Math.log((1 + F) / (1 - F)) / Math.PI;
        return U < 0 ? 0 : U > 1 ? 1 : U;
      }
      function Ut(N, F, U, Z, Q, pe, de, G) {
        if (Z /= F, pe >= (U /= F) && de < Z)
          return N;
        if (de < U || pe >= Z)
          return null;
        for (var ie = [], _e = 0; _e < N.length; _e++) {
          var Ge = N[_e], Ze = Ge.geometry, Ce = Ge.type, Ue = Q === 0 ? Ge.minX : Ge.minY, Et = Q === 0 ? Ge.maxX : Ge.maxY;
          if (Ue >= U && Et < Z)
            ie.push(Ge);
          else if (!(Et < U || Ue >= Z)) {
            var _t = [];
            if (Ce === "Point" || Ce === "MultiPoint")
              dr(Ze, _t, U, Z, Q);
            else if (Ce === "LineString")
              Vr(Ze, _t, U, Z, Q, !1, G.lineMetrics);
            else if (Ce === "MultiLineString")
              Jr(Ze, _t, U, Z, Q, !1);
            else if (Ce === "Polygon")
              Jr(Ze, _t, U, Z, Q, !0);
            else if (Ce === "MultiPolygon")
              for (var Le = 0; Le < Ze.length; Le++) {
                var pt = [];
                Jr(Ze[Le], pt, U, Z, Q, !0), pt.length && _t.push(pt);
              }
            if (_t.length) {
              if (G.lineMetrics && Ce === "LineString") {
                for (Le = 0; Le < _t.length; Le++)
                  ie.push(nt(Ge.id, Ce, _t[Le], Ge.tags));
                continue;
              }
              Ce !== "LineString" && Ce !== "MultiLineString" || (_t.length === 1 ? (Ce = "LineString", _t = _t[0]) : Ce = "MultiLineString"), Ce !== "Point" && Ce !== "MultiPoint" || (Ce = _t.length === 3 ? "Point" : "MultiPoint"), ie.push(nt(Ge.id, Ce, _t, Ge.tags));
            }
          }
        }
        return ie.length ? ie : null;
      }
      function dr(N, F, U, Z, Q) {
        for (var pe = 0; pe < N.length; pe += 3) {
          var de = N[pe + Q];
          de >= U && de <= Z && (F.push(N[pe]), F.push(N[pe + 1]), F.push(N[pe + 2]));
        }
      }
      function Vr(N, F, U, Z, Q, pe, de) {
        for (var G, ie, _e = kr(N), Ge = Q === 0 ? Bi : so, Ze = N.start, Ce = 0; Ce < N.length - 3; Ce += 3) {
          var Ue = N[Ce], Et = N[Ce + 1], _t = N[Ce + 2], Le = N[Ce + 3], pt = N[Ce + 4], st = Q === 0 ? Ue : Et, De = Q === 0 ? Le : pt, fe = !1;
          de && (G = Math.sqrt(Math.pow(Ue - Le, 2) + Math.pow(Et - pt, 2))), st < U ? De > U && (ie = Ge(_e, Ue, Et, Le, pt, U), de && (_e.start = Ze + G * ie)) : st > Z ? De < Z && (ie = Ge(_e, Ue, Et, Le, pt, Z), de && (_e.start = Ze + G * ie)) : Xn(_e, Ue, Et, _t), De < U && st >= U && (ie = Ge(_e, Ue, Et, Le, pt, U), fe = !0), De > Z && st <= Z && (ie = Ge(_e, Ue, Et, Le, pt, Z), fe = !0), !pe && fe && (de && (_e.end = Ze + G * ie), F.push(_e), _e = kr(N)), de && (Ze += G);
        }
        var Ee = N.length - 3;
        Ue = N[Ee], Et = N[Ee + 1], _t = N[Ee + 2], (st = Q === 0 ? Ue : Et) >= U && st <= Z && Xn(_e, Ue, Et, _t), Ee = _e.length - 3, pe && Ee >= 3 && (_e[Ee] !== _e[0] || _e[Ee + 1] !== _e[1]) && Xn(_e, _e[0], _e[1], _e[2]), _e.length && F.push(_e);
      }
      function kr(N) {
        var F = [];
        return F.size = N.size, F.start = N.start, F.end = N.end, F;
      }
      function Jr(N, F, U, Z, Q, pe) {
        for (var de = 0; de < N.length; de++)
          Vr(N[de], F, U, Z, Q, pe, !1);
      }
      function Xn(N, F, U, Z) {
        N.push(F), N.push(U), N.push(Z);
      }
      function Bi(N, F, U, Z, Q, pe) {
        var de = (pe - F) / (Z - F);
        return N.push(pe), N.push(U + (Q - U) * de), N.push(1), de;
      }
      function so(N, F, U, Z, Q, pe) {
        var de = (pe - U) / (Q - U);
        return N.push(F + (Z - F) * de), N.push(pe), N.push(1), de;
      }
      function Kn(N, F) {
        for (var U = [], Z = 0; Z < N.length; Z++) {
          var Q, pe = N[Z], de = pe.type;
          if (de === "Point" || de === "MultiPoint" || de === "LineString")
            Q = ki(pe.geometry, F);
          else if (de === "MultiLineString" || de === "Polygon") {
            Q = [];
            for (var G = 0; G < pe.geometry.length; G++)
              Q.push(ki(pe.geometry[G], F));
          } else if (de === "MultiPolygon")
            for (Q = [], G = 0; G < pe.geometry.length; G++) {
              for (var ie = [], _e = 0; _e < pe.geometry[G].length; _e++)
                ie.push(ki(pe.geometry[G][_e], F));
              Q.push(ie);
            }
          U.push(nt(pe.id, de, Q, pe.tags));
        }
        return U;
      }
      function ki(N, F) {
        var U = [];
        U.size = N.size, N.start !== void 0 && (U.start = N.start, U.end = N.end);
        for (var Z = 0; Z < N.length; Z += 3)
          U.push(N[Z] + F, N[Z + 1], N[Z + 2]);
        return U;
      }
      function Tn(N, F) {
        if (N.transformed)
          return N;
        var U, Z, Q, pe = 1 << N.z, de = N.x, G = N.y;
        for (U = 0; U < N.features.length; U++) {
          var ie = N.features[U], _e = ie.geometry, Ge = ie.type;
          if (ie.geometry = [], Ge === 1)
            for (Z = 0; Z < _e.length; Z += 2)
              ie.geometry.push(si(_e[Z], _e[Z + 1], F, pe, de, G));
          else
            for (Z = 0; Z < _e.length; Z++) {
              var Ze = [];
              for (Q = 0; Q < _e[Z].length; Q += 2)
                Ze.push(si(_e[Z][Q], _e[Z][Q + 1], F, pe, de, G));
              ie.geometry.push(Ze);
            }
        }
        return N.transformed = !0, N;
      }
      function si(N, F, U, Z, Q, pe) {
        return [Math.round(U * (N * Z - Q)), Math.round(U * (F * Z - pe))];
      }
      function Fa(N, F, U, Z, Q) {
        for (var pe = F === Q.maxZoom ? 0 : Q.tolerance / ((1 << F) * Q.extent), de = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: U, y: Z, z: F, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, G = 0; G < N.length; G++) {
          de.numFeatures++, Uo(de, N[G], pe, Q);
          var ie = N[G].minX, _e = N[G].minY, Ge = N[G].maxX, Ze = N[G].maxY;
          ie < de.minX && (de.minX = ie), _e < de.minY && (de.minY = _e), Ge > de.maxX && (de.maxX = Ge), Ze > de.maxY && (de.maxY = Ze);
        }
        return de;
      }
      function Uo(N, F, U, Z) {
        var Q = F.geometry, pe = F.type, de = [];
        if (pe === "Point" || pe === "MultiPoint")
          for (var G = 0; G < Q.length; G += 3)
            de.push(Q[G]), de.push(Q[G + 1]), N.numPoints++, N.numSimplified++;
        else if (pe === "LineString")
          Ba(de, Q, N, U, !1, !1);
        else if (pe === "MultiLineString" || pe === "Polygon")
          for (G = 0; G < Q.length; G++)
            Ba(de, Q[G], N, U, pe === "Polygon", G === 0);
        else if (pe === "MultiPolygon")
          for (var ie = 0; ie < Q.length; ie++) {
            var _e = Q[ie];
            for (G = 0; G < _e.length; G++)
              Ba(de, _e[G], N, U, !0, G === 0);
          }
        if (de.length) {
          var Ge = F.tags || null;
          if (pe === "LineString" && Z.lineMetrics) {
            for (var Ze in Ge = {}, F.tags)
              Ge[Ze] = F.tags[Ze];
            Ge.mapbox_clip_start = Q.start / Q.size, Ge.mapbox_clip_end = Q.end / Q.size;
          }
          var Ce = { geometry: de, type: pe === "Polygon" || pe === "MultiPolygon" ? 3 : pe === "LineString" || pe === "MultiLineString" ? 2 : 1, tags: Ge };
          F.id !== null && (Ce.id = F.id), N.features.push(Ce);
        }
      }
      function Ba(N, F, U, Z, Q, pe) {
        var de = Z * Z;
        if (Z > 0 && F.size < (Q ? de : Z))
          U.numPoints += F.length / 3;
        else {
          for (var G = [], ie = 0; ie < F.length; ie += 3)
            (Z === 0 || F[ie + 2] > de) && (U.numSimplified++, G.push(F[ie]), G.push(F[ie + 1])), U.numPoints++;
          Q && function(_e, Ge) {
            for (var Ze = 0, Ce = 0, Ue = _e.length, Et = Ue - 2; Ce < Ue; Et = Ce, Ce += 2)
              Ze += (_e[Ce] - _e[Et]) * (_e[Ce + 1] + _e[Et + 1]);
            if (Ze > 0 === Ge)
              for (Ce = 0, Ue = _e.length; Ce < Ue / 2; Ce += 2) {
                var _t = _e[Ce], Le = _e[Ce + 1];
                _e[Ce] = _e[Ue - 2 - Ce], _e[Ce + 1] = _e[Ue - 1 - Ce], _e[Ue - 2 - Ce] = _t, _e[Ue - 1 - Ce] = Le;
              }
          }(G, pe), N.push(G);
        }
      }
      function na(N, F) {
        var U = (F = this.options = function(Q, pe) {
          for (var de in pe)
            Q[de] = pe[de];
          return Q;
        }(Object.create(this.options), F)).debug;
        if (U && console.time("preprocess data"), F.maxZoom < 0 || F.maxZoom > 24)
          throw new Error("maxZoom should be in the 0-24 range");
        if (F.promoteId && F.generateId)
          throw new Error("promoteId and generateId cannot be used together.");
        var Z = function(Q, pe) {
          var de = [];
          if (Q.type === "FeatureCollection")
            for (var G = 0; G < Q.features.length; G++)
              et(de, Q.features[G], pe, G);
          else
            et(de, Q.type === "Feature" ? Q : { geometry: Q }, pe);
          return de;
        }(N, F);
        this.tiles = {}, this.tileCoords = [], U && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", F.indexMaxZoom, F.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (Z = function(Q, pe) {
          var de = pe.buffer / pe.extent, G = Q, ie = Ut(Q, 1, -1 - de, de, 0, -1, 2, pe), _e = Ut(Q, 1, 1 - de, 2 + de, 0, -1, 2, pe);
          return (ie || _e) && (G = Ut(Q, 1, -de, 1 + de, 0, -1, 2, pe) || [], ie && (G = Kn(ie, 1).concat(G)), _e && (G = G.concat(Kn(_e, -1)))), G;
        }(Z, F)).length && this.splitTile(Z, 0, 0, 0), U && (Z.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function sn(N, F, U) {
        return 32 * ((1 << N) * U + F) + N;
      }
      function So(N, F) {
        var U = N.tileID.canonical;
        if (!this._geoJSONIndex)
          return F(null, null);
        var Z = this._geoJSONIndex.getTile(U.z, U.x, U.y);
        if (!Z)
          return F(null, null);
        var Q = new ve(Z.features), pe = Ie(Q);
        pe.byteOffset === 0 && pe.byteLength === pe.buffer.byteLength || (pe = new Uint8Array(pe)), F(null, { vectorTile: Q, rawData: pe.buffer });
      }
      Ar.prototype.load = function(N) {
        var F = this.options, U = F.log, Z = F.minZoom, Q = F.maxZoom, pe = F.nodeSize;
        U && console.time("total time");
        var de = "prepare " + N.length + " points";
        U && console.time(de), this.points = N;
        for (var G = [], ie = 0; ie < N.length; ie++)
          N[ie].geometry && G.push(Sr(N[ie], ie));
        this.trees[Q + 1] = new Fi(G, Re, qe, pe, Float32Array), U && console.timeEnd(de);
        for (var _e = Q; _e >= Z; _e--) {
          var Ge = +Date.now();
          G = this._cluster(G, _e), this.trees[_e] = new Fi(G, Re, qe, pe, Float32Array), U && console.log("z%d: %d clusters in %dms", _e, G.length, +Date.now() - Ge);
        }
        return U && console.timeEnd("total time"), this;
      }, Ar.prototype.getClusters = function(N, F) {
        var U = ((N[0] + 180) % 360 + 360) % 360 - 180, Z = Math.max(-90, Math.min(90, N[1])), Q = N[2] === 180 ? 180 : ((N[2] + 180) % 360 + 360) % 360 - 180, pe = Math.max(-90, Math.min(90, N[3]));
        if (N[2] - N[0] >= 360)
          U = -180, Q = 180;
        else if (U > Q) {
          var de = this.getClusters([U, Z, 180, pe], F), G = this.getClusters([-180, Z, Q, pe], F);
          return de.concat(G);
        }
        for (var ie = this.trees[this._limitZoom(F)], _e = [], Ge = 0, Ze = ie.range(Un(U), K(pe), Un(Q), K(Z)); Ge < Ze.length; Ge += 1) {
          var Ce = ie.points[Ze[Ge]];
          _e.push(Ce.numPoints ? Sn(Ce) : this.points[Ce.index]);
        }
        return _e;
      }, Ar.prototype.getChildren = function(N) {
        var F = this._getOriginId(N), U = this._getOriginZoom(N), Z = "No cluster with the specified id.", Q = this.trees[U];
        if (!Q)
          throw new Error(Z);
        var pe = Q.points[F];
        if (!pe)
          throw new Error(Z);
        for (var de = this.options.radius / (this.options.extent * Math.pow(2, U - 1)), G = [], ie = 0, _e = Q.within(pe.x, pe.y, de); ie < _e.length; ie += 1) {
          var Ge = Q.points[_e[ie]];
          Ge.parentId === N && G.push(Ge.numPoints ? Sn(Ge) : this.points[Ge.index]);
        }
        if (G.length === 0)
          throw new Error(Z);
        return G;
      }, Ar.prototype.getLeaves = function(N, F, U) {
        var Z = [];
        return this._appendLeaves(Z, N, F = F || 10, U = U || 0, 0), Z;
      }, Ar.prototype.getTile = function(N, F, U) {
        var Z = this.trees[this._limitZoom(N)], Q = Math.pow(2, N), pe = this.options, de = pe.radius / pe.extent, G = (U - de) / Q, ie = (U + 1 + de) / Q, _e = { features: [] };
        return this._addTileFeatures(Z.range((F - de) / Q, G, (F + 1 + de) / Q, ie), Z.points, F, U, Q, _e), F === 0 && this._addTileFeatures(Z.range(1 - de / Q, G, 1, ie), Z.points, Q, U, Q, _e), F === Q - 1 && this._addTileFeatures(Z.range(0, G, de / Q, ie), Z.points, -1, U, Q, _e), _e.features.length ? _e : null;
      }, Ar.prototype.getClusterExpansionZoom = function(N) {
        for (var F = this._getOriginZoom(N) - 1; F <= this.options.maxZoom; ) {
          var U = this.getChildren(N);
          if (F++, U.length !== 1)
            break;
          N = U[0].properties.cluster_id;
        }
        return F;
      }, Ar.prototype._appendLeaves = function(N, F, U, Z, Q) {
        for (var pe = 0, de = this.getChildren(F); pe < de.length; pe += 1) {
          var G = de[pe], ie = G.properties;
          if (ie && ie.cluster ? Q + ie.point_count <= Z ? Q += ie.point_count : Q = this._appendLeaves(N, ie.cluster_id, U, Z, Q) : Q < Z ? Q++ : N.push(G), N.length === U)
            break;
        }
        return Q;
      }, Ar.prototype._addTileFeatures = function(N, F, U, Z, Q, pe) {
        for (var de = 0, G = N; de < G.length; de += 1) {
          var ie = F[G[de]], _e = ie.numPoints, Ge = { type: 1, geometry: [[Math.round(this.options.extent * (ie.x * Q - U)), Math.round(this.options.extent * (ie.y * Q - Z))]], tags: _e ? ai(ie) : this.points[ie.index].properties }, Ze = void 0;
          _e ? Ze = ie.id : this.options.generateId ? Ze = ie.index : this.points[ie.index].id && (Ze = this.points[ie.index].id), Ze !== void 0 && (Ge.id = Ze), pe.features.push(Ge);
        }
      }, Ar.prototype._limitZoom = function(N) {
        return Math.max(this.options.minZoom, Math.min(+N, this.options.maxZoom + 1));
      }, Ar.prototype._cluster = function(N, F) {
        for (var U = [], Z = this.options, Q = Z.reduce, pe = Z.minPoints, de = Z.radius / (Z.extent * Math.pow(2, F)), G = 0; G < N.length; G++) {
          var ie = N[G];
          if (!(ie.zoom <= F)) {
            ie.zoom = F;
            for (var _e = this.trees[F + 1], Ge = _e.within(ie.x, ie.y, de), Ze = ie.numPoints || 1, Ce = Ze, Ue = 0, Et = Ge; Ue < Et.length; Ue += 1) {
              var _t = _e.points[Et[Ue]];
              _t.zoom > F && (Ce += _t.numPoints || 1);
            }
            if (Ce >= pe) {
              for (var Le = ie.x * Ze, pt = ie.y * Ze, st = Q && Ze > 1 ? this._map(ie, !0) : null, De = (G << 5) + (F + 1) + this.points.length, fe = 0, Ee = Ge; fe < Ee.length; fe += 1) {
                var He = _e.points[Ee[fe]];
                if (!(He.zoom <= F)) {
                  He.zoom = F;
                  var jt = He.numPoints || 1;
                  Le += He.x * jt, pt += He.y * jt, He.parentId = De, Q && (st || (st = this._map(ie, !0)), Q(st, this._map(He)));
                }
              }
              ie.parentId = De, U.push(Vn(Le / Ce, pt / Ce, De, Ce, st));
            } else if (U.push(ie), Ce > 1)
              for (var qt = 0, Jt = Ge; qt < Jt.length; qt += 1) {
                var Zt = _e.points[Jt[qt]];
                Zt.zoom <= F || (Zt.zoom = F, U.push(Zt));
              }
          }
        }
        return U;
      }, Ar.prototype._getOriginId = function(N) {
        return N - this.points.length >> 5;
      }, Ar.prototype._getOriginZoom = function(N) {
        return (N - this.points.length) % 32;
      }, Ar.prototype._map = function(N, F) {
        if (N.numPoints)
          return F ? ye({}, N.properties) : N.properties;
        var U = this.points[N.index].properties, Z = this.options.map(U);
        return F && Z === U ? ye({}, Z) : Z;
      }, na.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, na.prototype.splitTile = function(N, F, U, Z, Q, pe, de) {
        for (var G = [N, F, U, Z], ie = this.options, _e = ie.debug; G.length; ) {
          Z = G.pop(), U = G.pop(), F = G.pop(), N = G.pop();
          var Ge = 1 << F, Ze = sn(F, U, Z), Ce = this.tiles[Ze];
          if (!Ce && (_e > 1 && console.time("creation"), Ce = this.tiles[Ze] = Fa(N, F, U, Z, ie), this.tileCoords.push({ z: F, x: U, y: Z }), _e)) {
            _e > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", F, U, Z, Ce.numFeatures, Ce.numPoints, Ce.numSimplified), console.timeEnd("creation"));
            var Ue = "z" + F;
            this.stats[Ue] = (this.stats[Ue] || 0) + 1, this.total++;
          }
          if (Ce.source = N, Q) {
            if (F === ie.maxZoom || F === Q)
              continue;
            var Et = 1 << Q - F;
            if (U !== Math.floor(pe / Et) || Z !== Math.floor(de / Et))
              continue;
          } else if (F === ie.indexMaxZoom || Ce.numPoints <= ie.indexMaxPoints)
            continue;
          if (Ce.source = null, N.length !== 0) {
            _e > 1 && console.time("clipping");
            var _t, Le, pt, st, De, fe, Ee = 0.5 * ie.buffer / ie.extent, He = 0.5 - Ee, jt = 0.5 + Ee, qt = 1 + Ee;
            _t = Le = pt = st = null, De = Ut(N, Ge, U - Ee, U + jt, 0, Ce.minX, Ce.maxX, ie), fe = Ut(N, Ge, U + He, U + qt, 0, Ce.minX, Ce.maxX, ie), N = null, De && (_t = Ut(De, Ge, Z - Ee, Z + jt, 1, Ce.minY, Ce.maxY, ie), Le = Ut(De, Ge, Z + He, Z + qt, 1, Ce.minY, Ce.maxY, ie), De = null), fe && (pt = Ut(fe, Ge, Z - Ee, Z + jt, 1, Ce.minY, Ce.maxY, ie), st = Ut(fe, Ge, Z + He, Z + qt, 1, Ce.minY, Ce.maxY, ie), fe = null), _e > 1 && console.timeEnd("clipping"), G.push(_t || [], F + 1, 2 * U, 2 * Z), G.push(Le || [], F + 1, 2 * U, 2 * Z + 1), G.push(pt || [], F + 1, 2 * U + 1, 2 * Z), G.push(st || [], F + 1, 2 * U + 1, 2 * Z + 1);
          }
        }
      }, na.prototype.getTile = function(N, F, U) {
        var Z = this.options, Q = Z.extent, pe = Z.debug;
        if (N < 0 || N > 24)
          return null;
        var de = 1 << N, G = sn(N, F = (F % de + de) % de, U);
        if (this.tiles[G])
          return Tn(this.tiles[G], Q);
        pe > 1 && console.log("drilling down to z%d-%d-%d", N, F, U);
        for (var ie, _e = N, Ge = F, Ze = U; !ie && _e > 0; )
          _e--, Ge = Math.floor(Ge / 2), Ze = Math.floor(Ze / 2), ie = this.tiles[sn(_e, Ge, Ze)];
        return ie && ie.source ? (pe > 1 && console.log("found parent tile z%d-%d-%d", _e, Ge, Ze), pe > 1 && console.time("drilling down"), this.splitTile(ie.source, _e, Ge, Ze, N, F, U), pe > 1 && console.timeEnd("drilling down"), this.tiles[G] ? Tn(this.tiles[G], Q) : null) : null;
      };
      var ol = function(N) {
        function F(U, Z, Q, pe) {
          N.call(this, U, Z, Q, So), pe && (this.loadGeoJSON = pe);
        }
        return N && (F.__proto__ = N), (F.prototype = Object.create(N && N.prototype)).constructor = F, F.prototype.loadData = function(U, Z) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), this._pendingCallback = Z, this._pendingLoadDataParams = U, this._state && this._state !== "Idle" ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());
        }, F.prototype._loadData = function() {
          var U = this;
          if (this._pendingCallback && this._pendingLoadDataParams) {
            var Z = this._pendingCallback, Q = this._pendingLoadDataParams;
            delete this._pendingCallback, delete this._pendingLoadDataParams;
            var pe = !!(Q && Q.request && Q.request.collectResourceTiming) && new o.RequestPerformance(Q.request);
            this.loadGeoJSON(Q, function(de, G) {
              if (de || !G)
                return Z(de);
              if (typeof G != "object")
                return Z(new Error("Input data given to '" + Q.source + "' is not a valid GeoJSON object."));
              (function Ce(Ue, Et) {
                var _t, Le = Ue && Ue.type;
                if (Le === "FeatureCollection")
                  for (_t = 0; _t < Ue.features.length; _t++)
                    Ce(Ue.features[_t], Et);
                else if (Le === "GeometryCollection")
                  for (_t = 0; _t < Ue.geometries.length; _t++)
                    Ce(Ue.geometries[_t], Et);
                else if (Le === "Feature")
                  Ce(Ue.geometry, Et);
                else if (Le === "Polygon")
                  re(Ue.coordinates, Et);
                else if (Le === "MultiPolygon")
                  for (_t = 0; _t < Ue.coordinates.length; _t++)
                    re(Ue.coordinates[_t], Et);
                return Ue;
              })(G, !0);
              try {
                if (Q.filter) {
                  var ie = o.createExpression(Q.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                  if (ie.result === "error")
                    throw new Error(ie.value.map(function(Ce) {
                      return Ce.key + ": " + Ce.message;
                    }).join(", "));
                  var _e = G.features.filter(function(Ce) {
                    return ie.value.evaluate({ zoom: 0 }, Ce);
                  });
                  G = { type: "FeatureCollection", features: _e };
                }
                U._geoJSONIndex = Q.cluster ? new Ar(function(Ce) {
                  var Ue = Ce.superclusterOptions, Et = Ce.clusterProperties;
                  if (!Et || !Ue)
                    return Ue;
                  for (var _t = {}, Le = {}, pt = { accumulated: null, zoom: 0 }, st = { properties: null }, De = Object.keys(Et), fe = 0, Ee = De; fe < Ee.length; fe += 1) {
                    var He = Ee[fe], jt = Et[He], qt = jt[0], Jt = o.createExpression(jt[1]), Zt = o.createExpression(typeof qt == "string" ? [qt, ["accumulated"], ["get", He]] : qt);
                    _t[He] = Jt.value, Le[He] = Zt.value;
                  }
                  return Ue.map = function(Yn) {
                    st.properties = Yn;
                    for (var Qt = {}, dn = 0, Ur = De; dn < Ur.length; dn += 1) {
                      var gr = Ur[dn];
                      Qt[gr] = _t[gr].evaluate(pt, st);
                    }
                    return Qt;
                  }, Ue.reduce = function(Yn, Qt) {
                    st.properties = Qt;
                    for (var dn = 0, Ur = De; dn < Ur.length; dn += 1) {
                      var gr = Ur[dn];
                      pt.accumulated = Yn[gr], Yn[gr] = Le[gr].evaluate(pt, st);
                    }
                  }, Ue;
                }(Q)).load(G.features) : function(Ce, Ue) {
                  return new na(Ce, Ue);
                }(G, Q.geojsonVtOptions);
              } catch (Ce) {
                return Z(Ce);
              }
              U.loaded = {};
              var Ge = {};
              if (pe) {
                var Ze = pe.finish();
                Ze && (Ge.resourceTiming = {}, Ge.resourceTiming[Q.source] = JSON.parse(JSON.stringify(Ze)));
              }
              Z(null, Ge);
            });
          }
        }, F.prototype.coalesce = function() {
          this._state === "Coalescing" ? this._state = "Idle" : this._state === "NeedsLoadData" && (this._state = "Coalescing", this._loadData());
        }, F.prototype.reloadTile = function(U, Z) {
          var Q = this.loaded;
          return Q && Q[U.uid] ? N.prototype.reloadTile.call(this, U, Z) : this.loadTile(U, Z);
        }, F.prototype.loadGeoJSON = function(U, Z) {
          if (U.request)
            o.getJSON(U.request, Z);
          else {
            if (typeof U.data != "string")
              return Z(new Error("Input data given to '" + U.source + "' is not a valid GeoJSON object."));
            try {
              return Z(null, JSON.parse(U.data));
            } catch {
              return Z(new Error("Input data given to '" + U.source + "' is not a valid GeoJSON object."));
            }
          }
        }, F.prototype.removeSource = function(U, Z) {
          this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), Z();
        }, F.prototype.getClusterExpansionZoom = function(U, Z) {
          try {
            Z(null, this._geoJSONIndex.getClusterExpansionZoom(U.clusterId));
          } catch (Q) {
            Z(Q);
          }
        }, F.prototype.getClusterChildren = function(U, Z) {
          try {
            Z(null, this._geoJSONIndex.getChildren(U.clusterId));
          } catch (Q) {
            Z(Q);
          }
        }, F.prototype.getClusterLeaves = function(U, Z) {
          try {
            Z(null, this._geoJSONIndex.getLeaves(U.clusterId, U.limit, U.offset));
          } catch (Q) {
            Z(Q);
          }
        }, F;
      }(z), bn = function(N) {
        var F = this;
        this.self = N, this.actor = new o.Actor(N, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: z, geojson: ol }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function(U, Z) {
          if (F.workerSourceTypes[U])
            throw new Error('Worker source with name "' + U + '" already registered.');
          F.workerSourceTypes[U] = Z;
        }, this.self.registerRTLTextPlugin = function(U) {
          if (o.plugin.isParsed())
            throw new Error("RTL text plugin already registered.");
          o.plugin.applyArabicShaping = U.applyArabicShaping, o.plugin.processBidirectionalText = U.processBidirectionalText, o.plugin.processStyledBidirectionalText = U.processStyledBidirectionalText;
        };
      };
      return bn.prototype.setReferrer = function(N, F) {
        this.referrer = F;
      }, bn.prototype.setImages = function(N, F, U) {
        for (var Z in this.availableImages[N] = F, this.workerSources[N]) {
          var Q = this.workerSources[N][Z];
          for (var pe in Q)
            Q[pe].availableImages = F;
        }
        U();
      }, bn.prototype.setLayers = function(N, F, U) {
        this.getLayerIndex(N).replace(F), U();
      }, bn.prototype.updateLayers = function(N, F, U) {
        this.getLayerIndex(N).update(F.layers, F.removedIds), U();
      }, bn.prototype.loadTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).loadTile(F, U);
      }, bn.prototype.loadDEMTile = function(N, F, U) {
        this.getDEMWorkerSource(N, F.source).loadTile(F, U);
      }, bn.prototype.reloadTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).reloadTile(F, U);
      }, bn.prototype.abortTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).abortTile(F, U);
      }, bn.prototype.removeTile = function(N, F, U) {
        this.getWorkerSource(N, F.type, F.source).removeTile(F, U);
      }, bn.prototype.removeDEMTile = function(N, F) {
        this.getDEMWorkerSource(N, F.source).removeTile(F);
      }, bn.prototype.removeSource = function(N, F, U) {
        if (this.workerSources[N] && this.workerSources[N][F.type] && this.workerSources[N][F.type][F.source]) {
          var Z = this.workerSources[N][F.type][F.source];
          delete this.workerSources[N][F.type][F.source], Z.removeSource !== void 0 ? Z.removeSource(F, U) : U();
        }
      }, bn.prototype.loadWorkerSource = function(N, F, U) {
        try {
          this.self.importScripts(F.url), U();
        } catch (Z) {
          U(Z.toString());
        }
      }, bn.prototype.syncRTLPluginState = function(N, F, U) {
        try {
          o.plugin.setState(F);
          var Z = o.plugin.getPluginURL();
          if (o.plugin.isLoaded() && !o.plugin.isParsed() && Z != null) {
            this.self.importScripts(Z);
            var Q = o.plugin.isParsed();
            U(Q ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + Z), Q);
          }
        } catch (pe) {
          U(pe.toString());
        }
      }, bn.prototype.getAvailableImages = function(N) {
        var F = this.availableImages[N];
        return F || (F = []), F;
      }, bn.prototype.getLayerIndex = function(N) {
        var F = this.layerIndexes[N];
        return F || (F = this.layerIndexes[N] = new b()), F;
      }, bn.prototype.getWorkerSource = function(N, F, U) {
        var Z = this;
        return this.workerSources[N] || (this.workerSources[N] = {}), this.workerSources[N][F] || (this.workerSources[N][F] = {}), this.workerSources[N][F][U] || (this.workerSources[N][F][U] = new this.workerSourceTypes[F]({ send: function(Q, pe, de) {
          Z.actor.send(Q, pe, de, N);
        } }, this.getLayerIndex(N), this.getAvailableImages(N))), this.workerSources[N][F][U];
      }, bn.prototype.getDEMWorkerSource = function(N, F) {
        return this.demWorkerSources[N] || (this.demWorkerSources[N] = {}), this.demWorkerSources[N][F] || (this.demWorkerSources[N][F] = new q()), this.demWorkerSources[N][F];
      }, bn.prototype.enforceCacheSizeLimit = function(N, F) {
        o.enforceCacheSizeLimit(F);
      }, typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope && (self.worker = new bn(self)), bn;
    }), f(["./shared"], function(o) {
      var m = o.createCommonjsModule(function(u) {
        function h(_) {
          return !c(_);
        }
        function c(_) {
          return typeof window > "u" || typeof document > "u" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return !1;
            var E, O, k = new Blob([""], { type: "text/javascript" }), R = URL.createObjectURL(k);
            try {
              O = new Worker(R), E = !0;
            } catch {
              E = !1;
            }
            return O && O.terminate(), URL.revokeObjectURL(R), E;
          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
            var E = document.createElement("canvas");
            E.width = E.height = 1;
            var O = E.getContext("2d");
            if (!O)
              return !1;
            var k = O.getImageData(0, 0, 1, 1);
            return k && k.width === E.width;
          }() ? (d[w = _ && _.failIfMajorPerformanceCaveat] === void 0 && (d[w] = function(E) {
            var O = function(R) {
              var $ = document.createElement("canvas"), W = Object.create(h.webGLContextAttributes);
              return W.failIfMajorPerformanceCaveat = R, $.probablySupportsContext ? $.probablySupportsContext("webgl", W) || $.probablySupportsContext("experimental-webgl", W) : $.supportsContext ? $.supportsContext("webgl", W) || $.supportsContext("experimental-webgl", W) : $.getContext("webgl", W) || $.getContext("experimental-webgl", W);
            }(E);
            if (!O)
              return !1;
            var k = O.createShader(O.VERTEX_SHADER);
            return !(!k || O.isContextLost()) && (O.shaderSource(k, "void main() {}"), O.compileShader(k), O.getShaderParameter(k, O.COMPILE_STATUS) === !0);
          }(w)), d[w] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          var w;
        }
        u.exports ? u.exports = h : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = h, window.mapboxgl.notSupportedReason = c);
        var d = {};
        h.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };
      }), g = { create: function(u, h, c) {
        var d = o.window.document.createElement(u);
        return h !== void 0 && (d.className = h), c && c.appendChild(d), d;
      }, createNS: function(u, h) {
        return o.window.document.createElementNS(u, h);
      } }, b = o.window.document && o.window.document.documentElement.style;
      function T(u) {
        if (!b)
          return u[0];
        for (var h = 0; h < u.length; h++)
          if (u[h] in b)
            return u[h];
        return u[0];
      }
      var M, I = T(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);
      g.disableDrag = function() {
        b && I && (M = b[I], b[I] = "none");
      }, g.enableDrag = function() {
        b && I && (b[I] = M);
      };
      var A = T(["transform", "WebkitTransform"]);
      g.setTransform = function(u, h) {
        u.style[A] = h;
      };
      var z = !1;
      try {
        var V = Object.defineProperty({}, "passive", { get: function() {
          z = !0;
        } });
        o.window.addEventListener("test", V, V), o.window.removeEventListener("test", V, V);
      } catch {
        z = !1;
      }
      g.addEventListener = function(u, h, c, d) {
        d === void 0 && (d = {}), u.addEventListener(h, c, "passive" in d && z ? d : d.capture);
      }, g.removeEventListener = function(u, h, c, d) {
        d === void 0 && (d = {}), u.removeEventListener(h, c, "passive" in d && z ? d : d.capture);
      };
      var q = function(u) {
        u.preventDefault(), u.stopPropagation(), o.window.removeEventListener("click", q, !0);
      };
      function re(u) {
        var h = u.userImage;
        return !!(h && h.render && h.render()) && (u.data.replace(new Uint8Array(h.data.buffer)), !0);
      }
      g.suppressClick = function() {
        o.window.addEventListener("click", q, !0), o.window.setTimeout(function() {
          o.window.removeEventListener("click", q, !0);
        }, 0);
      }, g.mousePos = function(u, h) {
        var c = u.getBoundingClientRect();
        return new o.Point(h.clientX - c.left - u.clientLeft, h.clientY - c.top - u.clientTop);
      }, g.touchPos = function(u, h) {
        for (var c = u.getBoundingClientRect(), d = [], _ = 0; _ < h.length; _++)
          d.push(new o.Point(h[_].clientX - c.left - u.clientLeft, h[_].clientY - c.top - u.clientTop));
        return d;
      }, g.mouseButton = function(u) {
        return o.window.InstallTrigger !== void 0 && u.button === 2 && u.ctrlKey && o.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : u.button;
      }, g.remove = function(u) {
        u.parentNode && u.parentNode.removeChild(u);
      };
      var X = function(u) {
        function h() {
          u.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.RGBAImage({ width: 1, height: 1 }), this.dirty = !0;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.isLoaded = function() {
          return this.loaded;
        }, h.prototype.setLoaded = function(c) {
          if (this.loaded !== c && (this.loaded = c, c)) {
            for (var d = 0, _ = this.requestors; d < _.length; d += 1) {
              var w = _[d];
              this._notify(w.ids, w.callback);
            }
            this.requestors = [];
          }
        }, h.prototype.getImage = function(c) {
          return this.images[c];
        }, h.prototype.addImage = function(c, d) {
          this._validate(c, d) && (this.images[c] = d);
        }, h.prototype._validate = function(c, d) {
          var _ = !0;
          return this._validateStretch(d.stretchX, d.data && d.data.width) || (this.fire(new o.ErrorEvent(new Error('Image "' + c + '" has invalid "stretchX" value'))), _ = !1), this._validateStretch(d.stretchY, d.data && d.data.height) || (this.fire(new o.ErrorEvent(new Error('Image "' + c + '" has invalid "stretchY" value'))), _ = !1), this._validateContent(d.content, d) || (this.fire(new o.ErrorEvent(new Error('Image "' + c + '" has invalid "content" value'))), _ = !1), _;
        }, h.prototype._validateStretch = function(c, d) {
          if (!c)
            return !0;
          for (var _ = 0, w = 0, E = c; w < E.length; w += 1) {
            var O = E[w];
            if (O[0] < _ || O[1] < O[0] || d < O[1])
              return !1;
            _ = O[1];
          }
          return !0;
        }, h.prototype._validateContent = function(c, d) {
          return !(c && (c.length !== 4 || c[0] < 0 || d.data.width < c[0] || c[1] < 0 || d.data.height < c[1] || c[2] < 0 || d.data.width < c[2] || c[3] < 0 || d.data.height < c[3] || c[2] < c[0] || c[3] < c[1]));
        }, h.prototype.updateImage = function(c, d) {
          d.version = this.images[c].version + 1, this.images[c] = d, this.updatedImages[c] = !0;
        }, h.prototype.removeImage = function(c) {
          var d = this.images[c];
          delete this.images[c], delete this.patterns[c], d.userImage && d.userImage.onRemove && d.userImage.onRemove();
        }, h.prototype.listImages = function() {
          return Object.keys(this.images);
        }, h.prototype.getImages = function(c, d) {
          var _ = !0;
          if (!this.isLoaded())
            for (var w = 0, E = c; w < E.length; w += 1)
              this.images[E[w]] || (_ = !1);
          this.isLoaded() || _ ? this._notify(c, d) : this.requestors.push({ ids: c, callback: d });
        }, h.prototype._notify = function(c, d) {
          for (var _ = {}, w = 0, E = c; w < E.length; w += 1) {
            var O = E[w];
            this.images[O] || this.fire(new o.Event("styleimagemissing", { id: O }));
            var k = this.images[O];
            k ? _[O] = { data: k.data.clone(), pixelRatio: k.pixelRatio, sdf: k.sdf, version: k.version, stretchX: k.stretchX, stretchY: k.stretchY, content: k.content, hasRenderCallback: Boolean(k.userImage && k.userImage.render) } : o.warnOnce('Image "' + O + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');
          }
          d(null, _);
        }, h.prototype.getPixelSize = function() {
          var c = this.atlasImage;
          return { width: c.width, height: c.height };
        }, h.prototype.getPattern = function(c) {
          var d = this.patterns[c], _ = this.getImage(c);
          if (!_)
            return null;
          if (d && d.position.version === _.version)
            return d.position;
          if (d)
            d.position.version = _.version;
          else {
            var w = { w: _.data.width + 2, h: _.data.height + 2, x: 0, y: 0 }, E = new o.ImagePosition(w, _);
            this.patterns[c] = { bin: w, position: E };
          }
          return this._updatePatternAtlas(), this.patterns[c].position;
        }, h.prototype.bind = function(c) {
          var d = c.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new o.Texture(c, this.atlasImage, d.RGBA), this.atlasTexture.bind(d.LINEAR, d.CLAMP_TO_EDGE);
        }, h.prototype._updatePatternAtlas = function() {
          var c = [];
          for (var d in this.patterns)
            c.push(this.patterns[d].bin);
          var _ = o.potpack(c), w = _.w, E = _.h, O = this.atlasImage;
          for (var k in O.resize({ width: w || 1, height: E || 1 }), this.patterns) {
            var R = this.patterns[k].bin, $ = R.x + 1, W = R.y + 1, H = this.images[k].data, ne = H.width, te = H.height;
            o.RGBAImage.copy(H, O, { x: 0, y: 0 }, { x: $, y: W }, { width: ne, height: te }), o.RGBAImage.copy(H, O, { x: 0, y: te - 1 }, { x: $, y: W - 1 }, { width: ne, height: 1 }), o.RGBAImage.copy(H, O, { x: 0, y: 0 }, { x: $, y: W + te }, { width: ne, height: 1 }), o.RGBAImage.copy(H, O, { x: ne - 1, y: 0 }, { x: $ - 1, y: W }, { width: 1, height: te }), o.RGBAImage.copy(H, O, { x: 0, y: 0 }, { x: $ + ne, y: W }, { width: 1, height: te });
          }
          this.dirty = !0;
        }, h.prototype.beginFrame = function() {
          this.callbackDispatchedThisFrame = {};
        }, h.prototype.dispatchRenderCallbacks = function(c) {
          for (var d = 0, _ = c; d < _.length; d += 1) {
            var w = _[d];
            if (!this.callbackDispatchedThisFrame[w]) {
              this.callbackDispatchedThisFrame[w] = !0;
              var E = this.images[w];
              re(E) && this.updateImage(w, E);
            }
          }
        }, h;
      }(o.Evented), ae = Ne, ce = Ne, ve = 1e20;
      function Ne(u, h, c, d, _, w) {
        this.fontSize = u || 24, this.buffer = h === void 0 ? 3 : h, this.cutoff = d || 0.25, this.fontFamily = _ || "sans-serif", this.fontWeight = w || "normal", this.radius = c || 8;
        var E = this.size = this.fontSize + 2 * this.buffer;
        this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = E, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(E * E), this.gridInner = new Float64Array(E * E), this.f = new Float64Array(E), this.d = new Float64Array(E), this.z = new Float64Array(E + 1), this.v = new Int16Array(E), this.middle = Math.round(E / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
      }
      function ze(u, h, c, d, _, w, E) {
        for (var O = 0; O < h; O++) {
          for (var k = 0; k < c; k++)
            d[k] = u[k * h + O];
          for (Ae(d, _, w, E, c), k = 0; k < c; k++)
            u[k * h + O] = _[k];
        }
        for (k = 0; k < c; k++) {
          for (O = 0; O < h; O++)
            d[O] = u[k * h + O];
          for (Ae(d, _, w, E, h), O = 0; O < h; O++)
            u[k * h + O] = Math.sqrt(_[O]);
        }
      }
      function Ae(u, h, c, d, _) {
        c[0] = 0, d[0] = -ve, d[1] = +ve;
        for (var w = 1, E = 0; w < _; w++) {
          for (var O = (u[w] + w * w - (u[c[E]] + c[E] * c[E])) / (2 * w - 2 * c[E]); O <= d[E]; )
            E--, O = (u[w] + w * w - (u[c[E]] + c[E] * c[E])) / (2 * w - 2 * c[E]);
          c[++E] = w, d[E] = O, d[E + 1] = +ve;
        }
        for (w = 0, E = 0; w < _; w++) {
          for (; d[E + 1] < w; )
            E++;
          h[w] = (w - c[E]) * (w - c[E]) + u[c[E]];
        }
      }
      Ne.prototype.draw = function(u) {
        this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(u, this.buffer, this.middle);
        for (var h = this.ctx.getImageData(0, 0, this.size, this.size), c = new Uint8ClampedArray(this.size * this.size), d = 0; d < this.size * this.size; d++) {
          var _ = h.data[4 * d + 3] / 255;
          this.gridOuter[d] = _ === 1 ? 0 : _ === 0 ? ve : Math.pow(Math.max(0, 0.5 - _), 2), this.gridInner[d] = _ === 1 ? ve : _ === 0 ? 0 : Math.pow(Math.max(0, _ - 0.5), 2);
        }
        for (ze(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), ze(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), d = 0; d < this.size * this.size; d++)
          c[d] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[d] - this.gridInner[d]) / this.radius + this.cutoff))));
        return c;
      }, ae.default = ce;
      var Se = function(u, h) {
        this.requestManager = u, this.localIdeographFontFamily = h, this.entries = {};
      };
      Se.prototype.setURL = function(u) {
        this.url = u;
      }, Se.prototype.getGlyphs = function(u, h) {
        var c = this, d = [];
        for (var _ in u)
          for (var w = 0, E = u[_]; w < E.length; w += 1)
            d.push({ stack: _, id: E[w] });
        o.asyncAll(d, function(O, k) {
          var R = O.stack, $ = O.id, W = c.entries[R];
          W || (W = c.entries[R] = { glyphs: {}, requests: {}, ranges: {} });
          var H = W.glyphs[$];
          if (H === void 0) {
            if (H = c._tinySDF(W, R, $))
              return W.glyphs[$] = H, void k(null, { stack: R, id: $, glyph: H });
            var ne = Math.floor($ / 256);
            if (256 * ne > 65535)
              k(new Error("glyphs > 65535 not supported"));
            else if (W.ranges[ne])
              k(null, { stack: R, id: $, glyph: H });
            else {
              var te = W.requests[ne];
              te || (te = W.requests[ne] = [], Se.loadGlyphRange(R, ne, c.url, c.requestManager, function(ue, Y) {
                if (Y) {
                  for (var le in Y)
                    c._doesCharSupportLocalGlyph(+le) || (W.glyphs[+le] = Y[+le]);
                  W.ranges[ne] = !0;
                }
                for (var me = 0, xe = te; me < xe.length; me += 1)
                  (0, xe[me])(ue, Y);
                delete W.requests[ne];
              })), te.push(function(ue, Y) {
                ue ? k(ue) : Y && k(null, { stack: R, id: $, glyph: Y[$] || null });
              });
            }
          } else
            k(null, { stack: R, id: $, glyph: H });
        }, function(O, k) {
          if (O)
            h(O);
          else if (k) {
            for (var R = {}, $ = 0, W = k; $ < W.length; $ += 1) {
              var H = W[$], ne = H.stack, te = H.id, ue = H.glyph;
              (R[ne] || (R[ne] = {}))[te] = ue && { id: ue.id, bitmap: ue.bitmap.clone(), metrics: ue.metrics };
            }
            h(null, R);
          }
        });
      }, Se.prototype._doesCharSupportLocalGlyph = function(u) {
        return !!this.localIdeographFontFamily && (o.isChar["CJK Unified Ideographs"](u) || o.isChar["Hangul Syllables"](u) || o.isChar.Hiragana(u) || o.isChar.Katakana(u));
      }, Se.prototype._tinySDF = function(u, h, c) {
        var d = this.localIdeographFontFamily;
        if (d && this._doesCharSupportLocalGlyph(c)) {
          var _ = u.tinySDF;
          if (!_) {
            var w = "400";
            /bold/i.test(h) ? w = "900" : /medium/i.test(h) ? w = "500" : /light/i.test(h) && (w = "200"), _ = u.tinySDF = new Se.TinySDF(24, 3, 8, 0.25, d, w);
          }
          return { id: c, bitmap: new o.AlphaImage({ width: 30, height: 30 }, _.draw(String.fromCharCode(c))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } };
        }
      }, Se.loadGlyphRange = function(u, h, c, d, _) {
        var w = 256 * h, E = w + 255, O = d.transformRequest(d.normalizeGlyphsURL(c).replace("{fontstack}", u).replace("{range}", w + "-" + E), o.ResourceType.Glyphs);
        o.getArrayBuffer(O, function(k, R) {
          if (k)
            _(k);
          else if (R) {
            for (var $ = {}, W = 0, H = o.parseGlyphPBF(R); W < H.length; W += 1) {
              var ne = H[W];
              $[ne.id] = ne;
            }
            _(null, $);
          }
        });
      }, Se.TinySDF = ae;
      var Ie = function() {
        this.specification = o.styleSpec.light.position;
      };
      Ie.prototype.possiblyEvaluate = function(u, h) {
        return o.sphericalToCartesian(u.expression.evaluate(h));
      }, Ie.prototype.interpolate = function(u, h, c) {
        return { x: o.number(u.x, h.x, c), y: o.number(u.y, h.y, c), z: o.number(u.z, h.z, c) };
      };
      var Xe = new o.Properties({ anchor: new o.DataConstantProperty(o.styleSpec.light.anchor), position: new Ie(), color: new o.DataConstantProperty(o.styleSpec.light.color), intensity: new o.DataConstantProperty(o.styleSpec.light.intensity) }), $e = function(u) {
        function h(c) {
          u.call(this), this._transitionable = new o.Transitionable(Xe), this.setLight(c), this._transitioning = this._transitionable.untransitioned();
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getLight = function() {
          return this._transitionable.serialize();
        }, h.prototype.setLight = function(c, d) {
          if (d === void 0 && (d = {}), !this._validate(o.validateLight, c, d))
            for (var _ in c) {
              var w = c[_];
              o.endsWith(_, "-transition") ? this._transitionable.setTransition(_.slice(0, -11), w) : this._transitionable.setValue(_, w);
            }
        }, h.prototype.updateTransitions = function(c) {
          this._transitioning = this._transitionable.transitioned(c, this._transitioning);
        }, h.prototype.hasTransition = function() {
          return this._transitioning.hasTransition();
        }, h.prototype.recalculate = function(c) {
          this.properties = this._transitioning.possiblyEvaluate(c);
        }, h.prototype._validate = function(c, d, _) {
          return (!_ || _.validate !== !1) && o.emitValidationErrors(this, c.call(o.validateStyle, o.extend({ value: d, style: { glyphs: !0, sprite: !0 }, styleSpec: o.styleSpec })));
        }, h;
      }(o.Evented), at = function(u, h) {
        this.width = u, this.height = h, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
      };
      at.prototype.getDash = function(u, h) {
        var c = u.join(",") + String(h);
        return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(u, h)), this.dashEntry[c];
      }, at.prototype.getDashRanges = function(u, h, c) {
        var d = [], _ = u.length % 2 == 1 ? -u[u.length - 1] * c : 0, w = u[0] * c, E = !0;
        d.push({ left: _, right: w, isDash: E, zeroLength: u[0] === 0 });
        for (var O = u[0], k = 1; k < u.length; k++) {
          var R = u[k];
          d.push({ left: _ = O * c, right: w = (O += R) * c, isDash: E = !E, zeroLength: R === 0 });
        }
        return d;
      }, at.prototype.addRoundDash = function(u, h, c) {
        for (var d = h / 2, _ = -c; _ <= c; _++)
          for (var w = this.width * (this.nextRow + c + _), E = 0, O = u[E], k = 0; k < this.width; k++) {
            k / O.right > 1 && (O = u[++E]);
            var R = Math.abs(k - O.left), $ = Math.abs(k - O.right), W = Math.min(R, $), H = void 0, ne = _ / c * (d + 1);
            if (O.isDash) {
              var te = d - Math.abs(ne);
              H = Math.sqrt(W * W + te * te);
            } else
              H = d - Math.sqrt(W * W + ne * ne);
            this.data[w + k] = Math.max(0, Math.min(255, H + 128));
          }
      }, at.prototype.addRegularDash = function(u) {
        for (var h = u.length - 1; h >= 0; --h) {
          var c = u[h], d = u[h + 1];
          c.zeroLength ? u.splice(h, 1) : d && d.isDash === c.isDash && (d.left = c.left, u.splice(h, 1));
        }
        var _ = u[0], w = u[u.length - 1];
        _.isDash === w.isDash && (_.left = w.left - this.width, w.right = _.right + this.width);
        for (var E = this.width * this.nextRow, O = 0, k = u[O], R = 0; R < this.width; R++) {
          R / k.right > 1 && (k = u[++O]);
          var $ = Math.abs(R - k.left), W = Math.abs(R - k.right), H = Math.min($, W);
          this.data[E + R] = Math.max(0, Math.min(255, (k.isDash ? H : -H) + 128));
        }
      }, at.prototype.addDash = function(u, h) {
        var c = h ? 7 : 0, d = 2 * c + 1;
        if (this.nextRow + d > this.height)
          return o.warnOnce("LineAtlas out of space"), null;
        for (var _ = 0, w = 0; w < u.length; w++)
          _ += u[w];
        if (_ !== 0) {
          var E = this.width / _, O = this.getDashRanges(u, this.width, E);
          h ? this.addRoundDash(O, E, c) : this.addRegularDash(O);
        }
        var k = { y: (this.nextRow + c + 0.5) / this.height, height: 2 * c / this.height, width: _ };
        return this.nextRow += d, this.dirty = !0, k;
      }, at.prototype.bind = function(u) {
        var h = u.gl;
        this.texture ? (h.bindTexture(h.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, h.texSubImage2D(h.TEXTURE_2D, 0, 0, 0, this.width, this.height, h.ALPHA, h.UNSIGNED_BYTE, this.data))) : (this.texture = h.createTexture(), h.bindTexture(h.TEXTURE_2D, this.texture), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR), h.texImage2D(h.TEXTURE_2D, 0, h.ALPHA, this.width, this.height, 0, h.ALPHA, h.UNSIGNED_BYTE, this.data));
      };
      var be = function u(h, c) {
        this.workerPool = h, this.actors = [], this.currentActor = 0, this.id = o.uniqueId();
        for (var d = this.workerPool.acquire(this.id), _ = 0; _ < d.length; _++) {
          var w = new u.Actor(d[_], c, this.id);
          w.name = "Worker " + _, this.actors.push(w);
        }
      };
      function Je(u, h, c) {
        var d = function(_, w) {
          if (_)
            return c(_);
          if (w) {
            var E = o.pick(o.extend(w, u), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            w.vector_layers && (E.vectorLayers = w.vector_layers, E.vectorLayerIds = E.vectorLayers.map(function(O) {
              return O.id;
            })), E.tiles = h.canonicalizeTileset(E, u.url), c(null, E);
          }
        };
        return u.url ? o.getJSON(h.transformRequest(h.normalizeSourceURL(u.url), o.ResourceType.Source), d) : o.browser.frame(function() {
          return d(null, u);
        });
      }
      be.prototype.broadcast = function(u, h, c) {
        o.asyncAll(this.actors, function(d, _) {
          d.send(u, h, _);
        }, c = c || function() {
        });
      }, be.prototype.getActor = function() {
        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
      }, be.prototype.remove = function() {
        this.actors.forEach(function(u) {
          u.remove();
        }), this.actors = [], this.workerPool.release(this.id);
      }, be.Actor = o.Actor;
      var ht = function(u, h, c) {
        this.bounds = o.LngLatBounds.convert(this.validateBounds(u)), this.minzoom = h || 0, this.maxzoom = c || 24;
      };
      ht.prototype.validateBounds = function(u) {
        return Array.isArray(u) && u.length === 4 ? [Math.max(-180, u[0]), Math.max(-90, u[1]), Math.min(180, u[2]), Math.min(90, u[3])] : [-180, -90, 180, 90];
      }, ht.prototype.contains = function(u) {
        var h = Math.pow(2, u.z), c = Math.floor(o.mercatorXfromLng(this.bounds.getWest()) * h), d = Math.floor(o.mercatorYfromLat(this.bounds.getNorth()) * h), _ = Math.ceil(o.mercatorXfromLng(this.bounds.getEast()) * h), w = Math.ceil(o.mercatorYfromLat(this.bounds.getSouth()) * h);
        return u.x >= c && u.x < _ && u.y >= d && u.y < w;
      };
      var vt = function(u) {
        function h(c, d, _, w) {
          if (u.call(this), this.id = c, this.dispatcher = _, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.extend(this, o.pick(d, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.extend({ type: "vector" }, d), this._collectResourceTiming = d.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(w);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function() {
          var c = this;
          this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = Je(this._options, this.map._requestManager, function(d, _) {
            c._tileJSONRequest = null, c._loaded = !0, d ? c.fire(new o.ErrorEvent(d)) : _ && (o.extend(c, _), _.bounds && (c.tileBounds = new ht(_.bounds, c.minzoom, c.maxzoom)), o.postTurnstileEvent(_.tiles, c.map._requestManager._customAccessToken), o.postMapLoadEvent(_.tiles, c.map._getMapId(), c.map._requestManager._skuToken, c.map._requestManager._customAccessToken), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }, h.prototype.loaded = function() {
          return this._loaded;
        }, h.prototype.hasTile = function(c) {
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }, h.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, h.prototype.setSourceProperty = function(c) {
          this._tileJSONRequest && this._tileJSONRequest.cancel(), c(), this.map.style.sourceCaches[this.id].clearTiles(), this.load();
        }, h.prototype.setTiles = function(c) {
          var d = this;
          return this.setSourceProperty(function() {
            d._options.tiles = c;
          }), this;
        }, h.prototype.setUrl = function(c) {
          var d = this;
          return this.setSourceProperty(function() {
            d.url = c, d._options.url = c;
          }), this;
        }, h.prototype.onRemove = function() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }, h.prototype.serialize = function() {
          return o.extend({}, this._options);
        }, h.prototype.loadTile = function(c, d) {
          var _ = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme)), w = { request: this.map._requestManager.transformRequest(_, o.ResourceType.Tile), uid: c.uid, tileID: c.tileID, zoom: c.tileID.overscaledZ, tileSize: this.tileSize * c.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: o.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
          function E(O, k) {
            return delete c.request, c.aborted ? d(null) : O && O.status !== 404 ? d(O) : (k && k.resourceTiming && (c.resourceTiming = k.resourceTiming), this.map._refreshExpiredTiles && k && c.setExpiryData(k), c.loadVectorData(k, this.map.painter), o.cacheEntryPossiblyAdded(this.dispatcher), d(null), void (c.reloadCallback && (this.loadTile(c, c.reloadCallback), c.reloadCallback = null)));
          }
          w.request.collectResourceTiming = this._collectResourceTiming, c.actor && c.state !== "expired" ? c.state === "loading" ? c.reloadCallback = d : c.request = c.actor.send("reloadTile", w, E.bind(this)) : (c.actor = this.dispatcher.getActor(), c.request = c.actor.send("loadTile", w, E.bind(this)));
        }, h.prototype.abortTile = function(c) {
          c.request && (c.request.cancel(), delete c.request), c.actor && c.actor.send("abortTile", { uid: c.uid, type: this.type, source: this.id }, void 0);
        }, h.prototype.unloadTile = function(c) {
          c.unloadVectorData(), c.actor && c.actor.send("removeTile", { uid: c.uid, type: this.type, source: this.id }, void 0);
        }, h.prototype.hasTransition = function() {
          return !1;
        }, h;
      }(o.Evented), At = function(u) {
        function h(c, d, _, w) {
          u.call(this), this.id = c, this.dispatcher = _, this.setEventedParent(w), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.extend({ type: "raster" }, d), o.extend(this, o.pick(d, ["url", "scheme", "tileSize"]));
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function() {
          var c = this;
          this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = Je(this._options, this.map._requestManager, function(d, _) {
            c._tileJSONRequest = null, c._loaded = !0, d ? c.fire(new o.ErrorEvent(d)) : _ && (o.extend(c, _), _.bounds && (c.tileBounds = new ht(_.bounds, c.minzoom, c.maxzoom)), o.postTurnstileEvent(_.tiles), o.postMapLoadEvent(_.tiles, c.map._getMapId(), c.map._requestManager._skuToken), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })), c.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }, h.prototype.loaded = function() {
          return this._loaded;
        }, h.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, h.prototype.onRemove = function() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }, h.prototype.serialize = function() {
          return o.extend({}, this._options);
        }, h.prototype.hasTile = function(c) {
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }, h.prototype.loadTile = function(c, d) {
          var _ = this, w = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
          c.request = o.getImage(this.map._requestManager.transformRequest(w, o.ResourceType.Tile), function(E, O) {
            if (delete c.request, c.aborted)
              c.state = "unloaded", d(null);
            else if (E)
              c.state = "errored", d(E);
            else if (O) {
              _.map._refreshExpiredTiles && c.setExpiryData(O), delete O.cacheControl, delete O.expires;
              var k = _.map.painter.context, R = k.gl;
              c.texture = _.map.painter.getTileTexture(O.width), c.texture ? c.texture.update(O, { useMipmap: !0 }) : (c.texture = new o.Texture(k, O, R.RGBA, { useMipmap: !0 }), c.texture.bind(R.LINEAR, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), k.extTextureFilterAnisotropic && R.texParameterf(R.TEXTURE_2D, k.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, k.extTextureFilterAnisotropicMax)), c.state = "loaded", o.cacheEntryPossiblyAdded(_.dispatcher), d(null);
            }
          });
        }, h.prototype.abortTile = function(c, d) {
          c.request && (c.request.cancel(), delete c.request), d();
        }, h.prototype.unloadTile = function(c, d) {
          c.texture && this.map.painter.saveTileTexture(c.texture), d();
        }, h.prototype.hasTransition = function() {
          return !1;
        }, h;
      }(o.Evented), tr = function(u) {
        function h(c, d, _, w) {
          u.call(this, c, d, _, w), this.type = "raster-dem", this.maxzoom = 22, this._options = o.extend({ type: "raster-dem" }, d), this.encoding = d.encoding || "mapbox";
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.serialize = function() {
          return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
        }, h.prototype.loadTile = function(c, d) {
          var _ = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
          function w(E, O) {
            E && (c.state = "errored", d(E)), O && (c.dem = O, c.needsHillshadePrepare = !0, c.state = "loaded", d(null));
          }
          c.request = o.getImage(this.map._requestManager.transformRequest(_, o.ResourceType.Tile), function(E, O) {
            if (delete c.request, c.aborted)
              c.state = "unloaded", d(null);
            else if (E)
              c.state = "errored", d(E);
            else if (O) {
              this.map._refreshExpiredTiles && c.setExpiryData(O), delete O.cacheControl, delete O.expires;
              var k = o.window.ImageBitmap && O instanceof o.window.ImageBitmap && o.offscreenCanvasSupported() ? O : o.browser.getImageData(O, 1), R = { uid: c.uid, coord: c.tileID, source: this.id, rawImageData: k, encoding: this.encoding };
              c.actor && c.state !== "expired" || (c.actor = this.dispatcher.getActor(), c.actor.send("loadDEMTile", R, w.bind(this)));
            }
          }.bind(this)), c.neighboringTiles = this._getNeighboringTiles(c.tileID);
        }, h.prototype._getNeighboringTiles = function(c) {
          var d = c.canonical, _ = Math.pow(2, d.z), w = (d.x - 1 + _) % _, E = d.x === 0 ? c.wrap - 1 : c.wrap, O = (d.x + 1 + _) % _, k = d.x + 1 === _ ? c.wrap + 1 : c.wrap, R = {};
          return R[new o.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y).key] = { backfilled: !1 }, d.y > 0 && (R[new o.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y - 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, c.wrap, d.z, d.x, d.y - 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y - 1).key] = { backfilled: !1 }), d.y + 1 < _ && (R[new o.OverscaledTileID(c.overscaledZ, E, d.z, w, d.y + 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, c.wrap, d.z, d.x, d.y + 1).key] = { backfilled: !1 }, R[new o.OverscaledTileID(c.overscaledZ, k, d.z, O, d.y + 1).key] = { backfilled: !1 }), R;
        }, h.prototype.unloadTile = function(c) {
          c.demTexture && this.map.painter.saveTileTexture(c.demTexture), c.fbo && (c.fbo.destroy(), delete c.fbo), c.dem && delete c.dem, delete c.neighboringTiles, c.state = "unloaded", c.actor && c.actor.send("removeDEMTile", { uid: c.uid, source: this.id });
        }, h;
      }(At), kn = function(u) {
        function h(c, d, _, w) {
          u.call(this), this.id = c, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._loaded = !1, this.actor = _.getActor(), this.setEventedParent(w), this._data = d.data, this._options = o.extend({}, d), this._collectResourceTiming = d.collectResourceTiming, this._resourceTiming = [], d.maxzoom !== void 0 && (this.maxzoom = d.maxzoom), d.type && (this.type = d.type), d.attribution && (this.attribution = d.attribution), this.promoteId = d.promoteId;
          var E = o.EXTENT / this.tileSize;
          this.workerOptions = o.extend({ source: this.id, cluster: d.cluster || !1, geojsonVtOptions: { buffer: (d.buffer !== void 0 ? d.buffer : 128) * E, tolerance: (d.tolerance !== void 0 ? d.tolerance : 0.375) * E, extent: o.EXTENT, maxZoom: this.maxzoom, lineMetrics: d.lineMetrics || !1, generateId: d.generateId || !1 }, superclusterOptions: { maxZoom: d.clusterMaxZoom !== void 0 ? Math.min(d.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, minPoints: Math.max(2, d.clusterMinPoints || 2), extent: o.EXTENT, radius: (d.clusterRadius || 50) * E, log: !1, generateId: d.generateId || !1 }, clusterProperties: d.clusterProperties, filter: d.filter }, d.workerOptions);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function() {
          var c = this;
          this.fire(new o.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(d) {
            if (d)
              c.fire(new o.ErrorEvent(d));
            else {
              var _ = { dataType: "source", sourceDataType: "metadata" };
              c._collectResourceTiming && c._resourceTiming && c._resourceTiming.length > 0 && (_.resourceTiming = c._resourceTiming, c._resourceTiming = []), c.fire(new o.Event("data", _));
            }
          });
        }, h.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, h.prototype.setData = function(c) {
          var d = this;
          return this._data = c, this.fire(new o.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(_) {
            if (_)
              d.fire(new o.ErrorEvent(_));
            else {
              var w = { dataType: "source", sourceDataType: "content" };
              d._collectResourceTiming && d._resourceTiming && d._resourceTiming.length > 0 && (w.resourceTiming = d._resourceTiming, d._resourceTiming = []), d.fire(new o.Event("data", w));
            }
          }), this;
        }, h.prototype.getClusterExpansionZoom = function(c, d) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: c, source: this.id }, d), this;
        }, h.prototype.getClusterChildren = function(c, d) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: c, source: this.id }, d), this;
        }, h.prototype.getClusterLeaves = function(c, d, _, w) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: c, limit: d, offset: _ }, w), this;
        }, h.prototype._updateWorkerData = function(c) {
          var d = this;
          this._loaded = !1;
          var _ = o.extend({}, this.workerOptions), w = this._data;
          typeof w == "string" ? (_.request = this.map._requestManager.transformRequest(o.browser.resolveURL(w), o.ResourceType.Source), _.request.collectResourceTiming = this._collectResourceTiming) : _.data = JSON.stringify(w), this.actor.send(this.type + ".loadData", _, function(E, O) {
            d._removed || O && O.abandoned || (d._loaded = !0, O && O.resourceTiming && O.resourceTiming[d.id] && (d._resourceTiming = O.resourceTiming[d.id].slice(0)), d.actor.send(d.type + ".coalesce", { source: _.source }, null), c(E));
          });
        }, h.prototype.loaded = function() {
          return this._loaded;
        }, h.prototype.loadTile = function(c, d) {
          var _ = this, w = c.actor ? "reloadTile" : "loadTile";
          c.actor = this.actor, c.request = this.actor.send(w, { type: this.type, uid: c.uid, tileID: c.tileID, zoom: c.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: o.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, function(E, O) {
            return delete c.request, c.unloadVectorData(), c.aborted ? d(null) : E ? d(E) : (c.loadVectorData(O, _.map.painter, w === "reloadTile"), d(null));
          });
        }, h.prototype.abortTile = function(c) {
          c.request && (c.request.cancel(), delete c.request), c.aborted = !0;
        }, h.prototype.unloadTile = function(c) {
          c.unloadVectorData(), this.actor.send("removeTile", { uid: c.uid, type: this.type, source: this.id });
        }, h.prototype.onRemove = function() {
          this._removed = !0, this.actor.send("removeSource", { type: this.type, source: this.id });
        }, h.prototype.serialize = function() {
          return o.extend({}, this._options, { type: this.type, data: this._data });
        }, h.prototype.hasTransition = function() {
          return !1;
        }, h;
      }(o.Evented), Nr = o.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]), pr = function(u) {
        function h(c, d, _, w) {
          u.call(this), this.id = c, this.dispatcher = _, this.coordinates = d.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(w), this.options = d;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function(c, d) {
          var _ = this;
          this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this.url = this.options.url, o.getImage(this.map._requestManager.transformRequest(this.url, o.ResourceType.Image), function(w, E) {
            _._loaded = !0, w ? _.fire(new o.ErrorEvent(w)) : E && (_.image = E, c && (_.coordinates = c), d && d(), _._finishLoading());
          });
        }, h.prototype.loaded = function() {
          return this._loaded;
        }, h.prototype.updateImage = function(c) {
          var d = this;
          return this.image && c.url ? (this.options.url = c.url, this.load(c.coordinates, function() {
            d.texture = null;
          }), this) : this;
        }, h.prototype._finishLoading = function() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })));
        }, h.prototype.onAdd = function(c) {
          this.map = c, this.load();
        }, h.prototype.setCoordinates = function(c) {
          var d = this;
          this.coordinates = c;
          var _ = c.map(o.MercatorCoordinate.fromLngLat);
          this.tileID = function(E) {
            for (var O = 1 / 0, k = 1 / 0, R = -1 / 0, $ = -1 / 0, W = 0, H = E; W < H.length; W += 1) {
              var ne = H[W];
              O = Math.min(O, ne.x), k = Math.min(k, ne.y), R = Math.max(R, ne.x), $ = Math.max($, ne.y);
            }
            var te = Math.max(R - O, $ - k), ue = Math.max(0, Math.floor(-Math.log(te) / Math.LN2)), Y = Math.pow(2, ue);
            return new o.CanonicalTileID(ue, Math.floor((O + R) / 2 * Y), Math.floor((k + $) / 2 * Y));
          }(_), this.minzoom = this.maxzoom = this.tileID.z;
          var w = _.map(function(E) {
            return d.tileID.getTilePoint(E)._round();
          });
          return this._boundsArray = new o.StructArrayLayout4i8(), this._boundsArray.emplaceBack(w[0].x, w[0].y, 0, 0), this._boundsArray.emplaceBack(w[1].x, w[1].y, o.EXTENT, 0), this._boundsArray.emplaceBack(w[3].x, w[3].y, 0, o.EXTENT), this._boundsArray.emplaceBack(w[2].x, w[2].y, o.EXTENT, o.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })), this;
        }, h.prototype.prepare = function() {
          if (Object.keys(this.tiles).length !== 0 && this.image) {
            var c = this.map.painter.context, d = c.gl;
            for (var _ in this.boundsBuffer || (this.boundsBuffer = c.createVertexBuffer(this._boundsArray, Nr.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new o.Texture(c, this.image, d.RGBA), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE)), this.tiles) {
              var w = this.tiles[_];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture);
            }
          }
        }, h.prototype.loadTile = function(c, d) {
          this.tileID && this.tileID.equals(c.tileID.canonical) ? (this.tiles[String(c.tileID.wrap)] = c, c.buckets = {}, d(null)) : (c.state = "errored", d(null));
        }, h.prototype.serialize = function() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }, h.prototype.hasTransition = function() {
          return !1;
        }, h;
      }(o.Evented), Zn = function(u) {
        function h(c, d, _, w) {
          u.call(this, c, d, _, w), this.roundZoom = !0, this.type = "video", this.options = d;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function() {
          var c = this;
          this._loaded = !1;
          var d = this.options;
          this.urls = [];
          for (var _ = 0, w = d.urls; _ < w.length; _ += 1)
            this.urls.push(this.map._requestManager.transformRequest(w[_], o.ResourceType.Source).url);
          o.getVideo(this.urls, function(E, O) {
            c._loaded = !0, E ? c.fire(new o.ErrorEvent(E)) : O && (c.video = O, c.video.loop = !0, c.video.setAttribute("playsinline", ""), c.video.addEventListener("playing", function() {
              c.map.triggerRepaint();
            }), c.map && c.video.play(), c._finishLoading());
          });
        }, h.prototype.pause = function() {
          this.video && this.video.pause();
        }, h.prototype.play = function() {
          this.video && this.video.play();
        }, h.prototype.seek = function(c) {
          if (this.video) {
            var d = this.video.seekable;
            c < d.start(0) || c > d.end(0) ? this.fire(new o.ErrorEvent(new o.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + d.start(0) + " and " + d.end(0) + "-second mark."))) : this.video.currentTime = c;
          }
        }, h.prototype.getVideo = function() {
          return this.video;
        }, h.prototype.onAdd = function(c) {
          this.map || (this.map = c, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }, h.prototype.prepare = function() {
          if (!(Object.keys(this.tiles).length === 0 || this.video.readyState < 2)) {
            var c = this.map.painter.context, d = c.gl;
            for (var _ in this.boundsBuffer || (this.boundsBuffer = c.createVertexBuffer(this._boundsArray, Nr.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE), d.texSubImage2D(d.TEXTURE_2D, 0, 0, 0, d.RGBA, d.UNSIGNED_BYTE, this.video)) : (this.texture = new o.Texture(c, this.video, d.RGBA), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE)), this.tiles) {
              var w = this.tiles[_];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture);
            }
          }
        }, h.prototype.serialize = function() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }, h.prototype.hasTransition = function() {
          return this.video && !this.video.paused;
        }, h;
      }(pr), Rr = function(u) {
        function h(c, d, _, w) {
          u.call(this, c, d, _, w), d.coordinates ? Array.isArray(d.coordinates) && d.coordinates.length === 4 && !d.coordinates.some(function(E) {
            return !Array.isArray(E) || E.length !== 2 || E.some(function(O) {
              return typeof O != "number";
            });
          }) || this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, 'missing required property "coordinates"'))), d.animate && typeof d.animate != "boolean" && this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, 'optional "animate" property must be a boolean value'))), d.canvas ? typeof d.canvas == "string" || d.canvas instanceof o.window.HTMLCanvasElement || this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.ErrorEvent(new o.ValidationError("sources." + c, null, 'missing required property "canvas"'))), this.options = d, this.animate = d.animate === void 0 || d.animate;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.load = function() {
          this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof o.window.HTMLCanvasElement ? this.options.canvas : o.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = !0, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = !1);
          }, this._finishLoading());
        }, h.prototype.getCanvas = function() {
          return this.canvas;
        }, h.prototype.onAdd = function(c) {
          this.map = c, this.load(), this.canvas && this.animate && this.play();
        }, h.prototype.onRemove = function() {
          this.pause();
        }, h.prototype.prepare = function() {
          var c = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, c = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, c = !0), !this._hasInvalidDimensions() && Object.keys(this.tiles).length !== 0) {
            var d = this.map.painter.context, _ = d.gl;
            for (var w in this.boundsBuffer || (this.boundsBuffer = d.createVertexBuffer(this._boundsArray, Nr.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (c || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new o.Texture(d, this.canvas, _.RGBA, { premultiply: !0 }), this.tiles) {
              var E = this.tiles[w];
              E.state !== "loaded" && (E.state = "loaded", E.texture = this.texture);
            }
          }
        }, h.prototype.serialize = function() {
          return { type: "canvas", coordinates: this.coordinates };
        }, h.prototype.hasTransition = function() {
          return this._playing;
        }, h.prototype._hasInvalidDimensions = function() {
          for (var c = 0, d = [this.canvas.width, this.canvas.height]; c < d.length; c += 1) {
            var _ = d[c];
            if (isNaN(_) || _ <= 0)
              return !0;
          }
          return !1;
        }, h;
      }(pr), Fi = { vector: vt, raster: At, "raster-dem": tr, geojson: kn, video: Zn, image: pr, canvas: Rr };
      function $r(u, h) {
        var c = o.identity([]);
        return o.translate(c, c, [1, 1, 0]), o.scale(c, c, [0.5 * u.width, 0.5 * u.height, 1]), o.multiply(c, c, u.calculatePosMatrix(h.toUnwrapped()));
      }
      function Ar(u, h, c, d, _, w) {
        var E = function(ue, Y, le) {
          if (ue)
            for (var me = 0, xe = ue; me < xe.length; me += 1) {
              var Pe = Y[xe[me]];
              if (Pe && Pe.source === le && Pe.type === "fill-extrusion")
                return !0;
            }
          else
            for (var Me in Y) {
              var ke = Y[Me];
              if (ke.source === le && ke.type === "fill-extrusion")
                return !0;
            }
          return !1;
        }(_ && _.layers, h, u.id), O = w.maxPitchScaleFactor(), k = u.tilesIn(d, O, E);
        k.sort(Vn);
        for (var R = [], $ = 0, W = k; $ < W.length; $ += 1) {
          var H = W[$];
          R.push({ wrappedTileID: H.tileID.wrapped().key, queryResults: H.tile.queryRenderedFeatures(h, c, u._state, H.queryGeometry, H.cameraQueryGeometry, H.scale, _, w, O, $r(u.transform, H.tileID)) });
        }
        var ne = function(ue) {
          for (var Y = {}, le = {}, me = 0, xe = ue; me < xe.length; me += 1) {
            var Pe = xe[me], Me = Pe.queryResults, ke = Pe.wrappedTileID, je = le[ke] = le[ke] || {};
            for (var it in Me)
              for (var tt = Me[it], gt = je[it] = je[it] || {}, Nt = Y[it] = Y[it] || [], Bt = 0, Ft = tt; Bt < Ft.length; Bt += 1) {
                var Ir = Ft[Bt];
                gt[Ir.featureIndex] || (gt[Ir.featureIndex] = !0, Nt.push(Ir));
              }
          }
          return Y;
        }(R);
        for (var te in ne)
          ne[te].forEach(function(ue) {
            var Y = ue.feature, le = u.getFeatureState(Y.layer["source-layer"], Y.id);
            Y.source = Y.layer.source, Y.layer["source-layer"] && (Y.sourceLayer = Y.layer["source-layer"]), Y.state = le;
          });
        return ne;
      }
      function Vn(u, h) {
        var c = u.tileID, d = h.tileID;
        return c.overscaledZ - d.overscaledZ || c.canonical.y - d.canonical.y || c.wrap - d.wrap || c.canonical.x - d.canonical.x;
      }
      var Sr = function(u, h) {
        this.max = u, this.onRemove = h, this.reset();
      };
      Sr.prototype.reset = function() {
        for (var u in this.data)
          for (var h = 0, c = this.data[u]; h < c.length; h += 1) {
            var d = c[h];
            d.timeout && clearTimeout(d.timeout), this.onRemove(d.value);
          }
        return this.data = {}, this.order = [], this;
      }, Sr.prototype.add = function(u, h, c) {
        var d = this, _ = u.wrapped().key;
        this.data[_] === void 0 && (this.data[_] = []);
        var w = { value: h, timeout: void 0 };
        if (c !== void 0 && (w.timeout = setTimeout(function() {
          d.remove(u, w);
        }, c)), this.data[_].push(w), this.order.push(_), this.order.length > this.max) {
          var E = this._getAndRemoveByKey(this.order[0]);
          E && this.onRemove(E);
        }
        return this;
      }, Sr.prototype.has = function(u) {
        return u.wrapped().key in this.data;
      }, Sr.prototype.getAndRemove = function(u) {
        return this.has(u) ? this._getAndRemoveByKey(u.wrapped().key) : null;
      }, Sr.prototype._getAndRemoveByKey = function(u) {
        var h = this.data[u].shift();
        return h.timeout && clearTimeout(h.timeout), this.data[u].length === 0 && delete this.data[u], this.order.splice(this.order.indexOf(u), 1), h.value;
      }, Sr.prototype.getByKey = function(u) {
        var h = this.data[u];
        return h ? h[0].value : null;
      }, Sr.prototype.get = function(u) {
        return this.has(u) ? this.data[u.wrapped().key][0].value : null;
      }, Sr.prototype.remove = function(u, h) {
        if (!this.has(u))
          return this;
        var c = u.wrapped().key, d = h === void 0 ? 0 : this.data[c].indexOf(h), _ = this.data[c][d];
        return this.data[c].splice(d, 1), _.timeout && clearTimeout(_.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(_.value), this.order.splice(this.order.indexOf(c), 1), this;
      }, Sr.prototype.setMaxSize = function(u) {
        for (this.max = u; this.order.length > this.max; ) {
          var h = this._getAndRemoveByKey(this.order[0]);
          h && this.onRemove(h);
        }
        return this;
      }, Sr.prototype.filter = function(u) {
        var h = [];
        for (var c in this.data)
          for (var d = 0, _ = this.data[c]; d < _.length; d += 1) {
            var w = _[d];
            u(w.value) || h.push(w);
          }
        for (var E = 0, O = h; E < O.length; E += 1) {
          var k = O[E];
          this.remove(k.value.tileID, k);
        }
      };
      var Sn = function(u, h, c) {
        this.context = u;
        var d = u.gl;
        this.buffer = d.createBuffer(), this.dynamicDraw = Boolean(c), this.context.unbindVAO(), u.bindElementBuffer.set(this.buffer), d.bufferData(d.ELEMENT_ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete h.arrayBuffer;
      };
      Sn.prototype.bind = function() {
        this.context.bindElementBuffer.set(this.buffer);
      }, Sn.prototype.updateData = function(u) {
        var h = this.context.gl;
        this.context.unbindVAO(), this.bind(), h.bufferSubData(h.ELEMENT_ARRAY_BUFFER, 0, u.arrayBuffer);
      }, Sn.prototype.destroy = function() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      };
      var ai = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, Un = function(u, h, c, d) {
        this.length = h.length, this.attributes = c, this.itemSize = h.bytesPerElement, this.dynamicDraw = d, this.context = u;
        var _ = u.gl;
        this.buffer = _.createBuffer(), u.bindVertexBuffer.set(this.buffer), _.bufferData(_.ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete h.arrayBuffer;
      };
      Un.prototype.bind = function() {
        this.context.bindVertexBuffer.set(this.buffer);
      }, Un.prototype.updateData = function(u) {
        var h = this.context.gl;
        this.bind(), h.bufferSubData(h.ARRAY_BUFFER, 0, u.arrayBuffer);
      }, Un.prototype.enableAttributes = function(u, h) {
        for (var c = 0; c < this.attributes.length; c++) {
          var d = h.attributes[this.attributes[c].name];
          d !== void 0 && u.enableVertexAttribArray(d);
        }
      }, Un.prototype.setVertexAttribPointers = function(u, h, c) {
        for (var d = 0; d < this.attributes.length; d++) {
          var _ = this.attributes[d], w = h.attributes[_.name];
          w !== void 0 && u.vertexAttribPointer(w, _.components, u[ai[_.type]], !1, this.itemSize, _.offset + this.itemSize * (c || 0));
        }
      }, Un.prototype.destroy = function() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      };
      var K = function(u) {
        this.gl = u.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
      };
      K.prototype.get = function() {
        return this.current;
      }, K.prototype.set = function(u) {
      }, K.prototype.getDefault = function() {
        return this.default;
      }, K.prototype.setDefault = function() {
        this.set(this.default);
      };
      var ye = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return o.Color.transparent;
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c.r !== d.r || c.g !== d.g || c.b !== d.b || c.a !== d.a || this.dirty) && (this.gl.clearColor(c.r, c.g, c.b, c.a), this.current = c, this.dirty = !1);
        }, h;
      }(K), Re = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return 1;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.clearDepth(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), qe = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return 0;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.clearStencil(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), We = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return [!0, !0, !0, !0];
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || c[3] !== d[3] || this.dirty) && (this.gl.colorMask(c[0], c[1], c[2], c[3]), this.current = c, this.dirty = !1);
        }, h;
      }(K), nt = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !0;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.depthMask(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), mt = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return 255;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.stencilMask(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), et = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c.func !== d.func || c.ref !== d.ref || c.mask !== d.mask || this.dirty) && (this.gl.stencilFunc(c.func, c.ref, c.mask), this.current = c, this.dirty = !1);
        }, h;
      }(K), ut = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          var c = this.gl;
          return [c.KEEP, c.KEEP, c.KEEP];
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || this.dirty) && (this.gl.stencilOp(c[0], c[1], c[2]), this.current = c, this.dirty = !1);
        }, h;
      }(K), Qe = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.STENCIL_TEST) : d.disable(d.STENCIL_TEST), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), It = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return [0, 1];
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || this.dirty) && (this.gl.depthRange(c[0], c[1]), this.current = c, this.dirty = !1);
        }, h;
      }(K), bt = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.DEPTH_TEST) : d.disable(d.DEPTH_TEST), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), Lt = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return this.gl.LESS;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.depthFunc(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), Ut = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.BLEND) : d.disable(d.BLEND), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), dr = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          var c = this.gl;
          return [c.ONE, c.ZERO];
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || this.dirty) && (this.gl.blendFunc(c[0], c[1]), this.current = c, this.dirty = !1);
        }, h;
      }(K), Vr = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return o.Color.transparent;
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c.r !== d.r || c.g !== d.g || c.b !== d.b || c.a !== d.a || this.dirty) && (this.gl.blendColor(c.r, c.g, c.b, c.a), this.current = c, this.dirty = !1);
        }, h;
      }(K), kr = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return this.gl.FUNC_ADD;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.blendEquation(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), Jr = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            c ? d.enable(d.CULL_FACE) : d.disable(d.CULL_FACE), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), Xn = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return this.gl.BACK;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.cullFace(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), Bi = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return this.gl.CCW;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.frontFace(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), so = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.useProgram(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), Kn = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return this.gl.TEXTURE0;
        }, h.prototype.set = function(c) {
          (c !== this.current || this.dirty) && (this.gl.activeTexture(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), ki = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          var c = this.gl;
          return [0, 0, c.drawingBufferWidth, c.drawingBufferHeight];
        }, h.prototype.set = function(c) {
          var d = this.current;
          (c[0] !== d[0] || c[1] !== d[1] || c[2] !== d[2] || c[3] !== d[3] || this.dirty) && (this.gl.viewport(c[0], c[1], c[2], c[3]), this.current = c, this.dirty = !1);
        }, h;
      }(K), Tn = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindFramebuffer(d.FRAMEBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), si = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindRenderbuffer(d.RENDERBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), Fa = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindTexture(d.TEXTURE_2D, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), Uo = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.bindBuffer(d.ARRAY_BUFFER, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), Ba = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          var d = this.gl;
          d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, c), this.current = c, this.dirty = !1;
        }, h;
      }(K), na = function(u) {
        function h(c) {
          u.call(this, c), this.vao = c.extVertexArrayObject;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h.prototype.set = function(c) {
          this.vao && (c !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(c), this.current = c, this.dirty = !1);
        }, h;
      }(K), sn = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return 4;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_ALIGNMENT, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), So = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), ol = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return !1;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            var d = this.gl;
            d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(K), bn = function(u) {
        function h(c, d) {
          u.call(this, c), this.context = c, this.parent = d;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getDefault = function() {
          return null;
        }, h;
      }(K), N = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.setDirty = function() {
          this.dirty = !0;
        }, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            this.context.bindFramebuffer.set(this.parent);
            var d = this.gl;
            d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, c, 0), this.current = c, this.dirty = !1;
          }
        }, h;
      }(bn), F = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.set = function(c) {
          if (c !== this.current || this.dirty) {
            this.context.bindFramebuffer.set(this.parent);
            var d = this.gl;
            d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.RENDERBUFFER, c), this.current = c, this.dirty = !1;
          }
        }, h;
      }(bn), U = function(u, h, c, d) {
        this.context = u, this.width = h, this.height = c;
        var _ = this.framebuffer = u.gl.createFramebuffer();
        this.colorAttachment = new N(u, _), d && (this.depthAttachment = new F(u, _));
      };
      U.prototype.destroy = function() {
        var u = this.context.gl, h = this.colorAttachment.get();
        if (h && u.deleteTexture(h), this.depthAttachment) {
          var c = this.depthAttachment.get();
          c && u.deleteRenderbuffer(c);
        }
        u.deleteFramebuffer(this.framebuffer);
      };
      var Z = function(u, h, c) {
        this.func = u, this.mask = h, this.range = c;
      };
      Z.ReadOnly = !1, Z.ReadWrite = !0, Z.disabled = new Z(519, Z.ReadOnly, [0, 1]);
      var Q = function(u, h, c, d, _, w) {
        this.test = u, this.ref = h, this.mask = c, this.fail = d, this.depthFail = _, this.pass = w;
      };
      Q.disabled = new Q({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
      var pe = function(u, h, c) {
        this.blendFunction = u, this.blendColor = h, this.mask = c;
      };
      pe.disabled = new pe(pe.Replace = [1, 0], o.Color.transparent, [!1, !1, !1, !1]), pe.unblended = new pe(pe.Replace, o.Color.transparent, [!0, !0, !0, !0]), pe.alphaBlended = new pe([1, 771], o.Color.transparent, [!0, !0, !0, !0]);
      var de = function(u, h, c) {
        this.enable = u, this.mode = h, this.frontFace = c;
      };
      de.disabled = new de(!1, 1029, 2305), de.backCCW = new de(!0, 1029, 2305);
      var G = function(u) {
        this.gl = u, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new ye(this), this.clearDepth = new Re(this), this.clearStencil = new qe(this), this.colorMask = new We(this), this.depthMask = new nt(this), this.stencilMask = new mt(this), this.stencilFunc = new et(this), this.stencilOp = new ut(this), this.stencilTest = new Qe(this), this.depthRange = new It(this), this.depthTest = new bt(this), this.depthFunc = new Lt(this), this.blend = new Ut(this), this.blendFunc = new dr(this), this.blendColor = new Vr(this), this.blendEquation = new kr(this), this.cullFace = new Jr(this), this.cullFaceSide = new Xn(this), this.frontFace = new Bi(this), this.program = new so(this), this.activeTexture = new Kn(this), this.viewport = new ki(this), this.bindFramebuffer = new Tn(this), this.bindRenderbuffer = new si(this), this.bindTexture = new Fa(this), this.bindVertexBuffer = new Uo(this), this.bindElementBuffer = new Ba(this), this.bindVertexArrayOES = this.extVertexArrayObject && new na(this), this.pixelStoreUnpack = new sn(this), this.pixelStoreUnpackPremultiplyAlpha = new So(this), this.pixelStoreUnpackFlipY = new ol(this), this.extTextureFilterAnisotropic = u.getExtension("EXT_texture_filter_anisotropic") || u.getExtension("MOZ_EXT_texture_filter_anisotropic") || u.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = u.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = u.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (u.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = u.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = u.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = u.getParameter(u.MAX_TEXTURE_SIZE);
      };
      G.prototype.setDefault = function() {
        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
      }, G.prototype.setDirty = function() {
        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
      }, G.prototype.createIndexBuffer = function(u, h) {
        return new Sn(this, u, h);
      }, G.prototype.createVertexBuffer = function(u, h, c) {
        return new Un(this, u, h, c);
      }, G.prototype.createRenderbuffer = function(u, h, c) {
        var d = this.gl, _ = d.createRenderbuffer();
        return this.bindRenderbuffer.set(_), d.renderbufferStorage(d.RENDERBUFFER, u, h, c), this.bindRenderbuffer.set(null), _;
      }, G.prototype.createFramebuffer = function(u, h, c) {
        return new U(this, u, h, c);
      }, G.prototype.clear = function(u) {
        var h = u.color, c = u.depth, d = this.gl, _ = 0;
        h && (_ |= d.COLOR_BUFFER_BIT, this.clearColor.set(h), this.colorMask.set([!0, !0, !0, !0])), c !== void 0 && (_ |= d.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(c), this.depthMask.set(!0)), d.clear(_);
      }, G.prototype.setCullFace = function(u) {
        u.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(u.mode), this.frontFace.set(u.frontFace));
      }, G.prototype.setDepthMode = function(u) {
        u.func !== this.gl.ALWAYS || u.mask ? (this.depthTest.set(!0), this.depthFunc.set(u.func), this.depthMask.set(u.mask), this.depthRange.set(u.range)) : this.depthTest.set(!1);
      }, G.prototype.setStencilMode = function(u) {
        u.test.func !== this.gl.ALWAYS || u.mask ? (this.stencilTest.set(!0), this.stencilMask.set(u.mask), this.stencilOp.set([u.fail, u.depthFail, u.pass]), this.stencilFunc.set({ func: u.test.func, ref: u.ref, mask: u.test.mask })) : this.stencilTest.set(!1);
      }, G.prototype.setColorMode = function(u) {
        o.deepEqual(u.blendFunction, pe.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(u.blendFunction), this.blendColor.set(u.blendColor)), this.colorMask.set(u.mask);
      }, G.prototype.unbindVAO = function() {
        this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
      };
      var ie = function(u) {
        function h(c, d, _) {
          var w = this;
          u.call(this), this.id = c, this.dispatcher = _, this.on("data", function(E) {
            E.dataType === "source" && E.sourceDataType === "metadata" && (w._sourceLoaded = !0), w._sourceLoaded && !w._paused && E.dataType === "source" && E.sourceDataType === "content" && (w.reload(), w.transform && w.update(w.transform));
          }), this.on("error", function() {
            w._sourceErrored = !0;
          }), this._source = function(E, O, k, R) {
            var $ = new Fi[O.type](E, O, k, R);
            if ($.id !== E)
              throw new Error("Expected Source id to be " + E + " instead of " + $.id);
            return o.bindAll(["load", "abort", "unload", "serialize", "prepare"], $), $;
          }(c, d, _, this), this._tiles = {}, this._cache = new Sr(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new o.SourceFeatureState();
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.onAdd = function(c) {
          this.map = c, this._maxTileCacheSize = c ? c._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(c);
        }, h.prototype.onRemove = function(c) {
          this._source && this._source.onRemove && this._source.onRemove(c);
        }, h.prototype.loaded = function() {
          if (this._sourceErrored)
            return !0;
          if (!this._sourceLoaded || !this._source.loaded())
            return !1;
          for (var c in this._tiles) {
            var d = this._tiles[c];
            if (d.state !== "loaded" && d.state !== "errored")
              return !1;
          }
          return !0;
        }, h.prototype.getSource = function() {
          return this._source;
        }, h.prototype.pause = function() {
          this._paused = !0;
        }, h.prototype.resume = function() {
          if (this._paused) {
            var c = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, c && this.reload(), this.transform && this.update(this.transform);
          }
        }, h.prototype._loadTile = function(c, d) {
          return this._source.loadTile(c, d);
        }, h.prototype._unloadTile = function(c) {
          if (this._source.unloadTile)
            return this._source.unloadTile(c, function() {
            });
        }, h.prototype._abortTile = function(c) {
          if (this._source.abortTile)
            return this._source.abortTile(c, function() {
            });
        }, h.prototype.serialize = function() {
          return this._source.serialize();
        }, h.prototype.prepare = function(c) {
          for (var d in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {
            var _ = this._tiles[d];
            _.upload(c), _.prepare(this.map.style.imageManager);
          }
        }, h.prototype.getIds = function() {
          return o.values(this._tiles).map(function(c) {
            return c.tileID;
          }).sort(_e).map(function(c) {
            return c.key;
          });
        }, h.prototype.getRenderableIds = function(c) {
          var d = this, _ = [];
          for (var w in this._tiles)
            this._isIdRenderable(w, c) && _.push(this._tiles[w]);
          return c ? _.sort(function(E, O) {
            var k = E.tileID, R = O.tileID, $ = new o.Point(k.canonical.x, k.canonical.y)._rotate(d.transform.angle), W = new o.Point(R.canonical.x, R.canonical.y)._rotate(d.transform.angle);
            return k.overscaledZ - R.overscaledZ || W.y - $.y || W.x - $.x;
          }).map(function(E) {
            return E.tileID.key;
          }) : _.map(function(E) {
            return E.tileID;
          }).sort(_e).map(function(E) {
            return E.key;
          });
        }, h.prototype.hasRenderableParent = function(c) {
          var d = this.findLoadedParent(c, 0);
          return !!d && this._isIdRenderable(d.tileID.key);
        }, h.prototype._isIdRenderable = function(c, d) {
          return this._tiles[c] && this._tiles[c].hasData() && !this._coveredTiles[c] && (d || !this._tiles[c].holdingForFade());
        }, h.prototype.reload = function() {
          if (this._paused)
            this._shouldReloadOnResume = !0;
          else
            for (var c in this._cache.reset(), this._tiles)
              this._tiles[c].state !== "errored" && this._reloadTile(c, "reloading");
        }, h.prototype._reloadTile = function(c, d) {
          var _ = this._tiles[c];
          _ && (_.state !== "loading" && (_.state = d), this._loadTile(_, this._tileLoaded.bind(this, _, c, d)));
        }, h.prototype._tileLoaded = function(c, d, _, w) {
          if (w)
            return c.state = "errored", void (w.status !== 404 ? this._source.fire(new o.ErrorEvent(w, { tile: c })) : this.update(this.transform));
          c.timeAdded = o.browser.now(), _ === "expired" && (c.refreshedUponExpiration = !0), this._setTileReloadTimer(d, c), this.getSource().type === "raster-dem" && c.dem && this._backfillDEM(c), this._state.initializeTileState(c, this.map ? this.map.painter : null), this._source.fire(new o.Event("data", { dataType: "source", tile: c, coord: c.tileID }));
        }, h.prototype._backfillDEM = function(c) {
          for (var d = this.getRenderableIds(), _ = 0; _ < d.length; _++) {
            var w = d[_];
            if (c.neighboringTiles && c.neighboringTiles[w]) {
              var E = this.getTileByID(w);
              O(c, E), O(E, c);
            }
          }
          function O(k, R) {
            k.needsHillshadePrepare = !0;
            var $ = R.tileID.canonical.x - k.tileID.canonical.x, W = R.tileID.canonical.y - k.tileID.canonical.y, H = Math.pow(2, k.tileID.canonical.z), ne = R.tileID.key;
            $ === 0 && W === 0 || Math.abs(W) > 1 || (Math.abs($) > 1 && (Math.abs($ + H) === 1 ? $ += H : Math.abs($ - H) === 1 && ($ -= H)), R.dem && k.dem && (k.dem.backfillBorder(R.dem, $, W), k.neighboringTiles && k.neighboringTiles[ne] && (k.neighboringTiles[ne].backfilled = !0)));
          }
        }, h.prototype.getTile = function(c) {
          return this.getTileByID(c.key);
        }, h.prototype.getTileByID = function(c) {
          return this._tiles[c];
        }, h.prototype._retainLoadedChildren = function(c, d, _, w) {
          for (var E in this._tiles) {
            var O = this._tiles[E];
            if (!(w[E] || !O.hasData() || O.tileID.overscaledZ <= d || O.tileID.overscaledZ > _)) {
              for (var k = O.tileID; O && O.tileID.overscaledZ > d + 1; ) {
                var R = O.tileID.scaledTo(O.tileID.overscaledZ - 1);
                (O = this._tiles[R.key]) && O.hasData() && (k = R);
              }
              for (var $ = k; $.overscaledZ > d; )
                if (c[($ = $.scaledTo($.overscaledZ - 1)).key]) {
                  w[k.key] = k;
                  break;
                }
            }
          }
        }, h.prototype.findLoadedParent = function(c, d) {
          if (c.key in this._loadedParentTiles) {
            var _ = this._loadedParentTiles[c.key];
            return _ && _.tileID.overscaledZ >= d ? _ : null;
          }
          for (var w = c.overscaledZ - 1; w >= d; w--) {
            var E = c.scaledTo(w), O = this._getLoadedTile(E);
            if (O)
              return O;
          }
        }, h.prototype._getLoadedTile = function(c) {
          var d = this._tiles[c.key];
          return d && d.hasData() ? d : this._cache.getByKey(c.wrapped().key);
        }, h.prototype.updateCacheSize = function(c) {
          var d = Math.ceil(c.width / this._source.tileSize) + 1, _ = Math.ceil(c.height / this._source.tileSize) + 1, w = Math.floor(d * _ * 5), E = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, w) : w;
          this._cache.setMaxSize(E);
        }, h.prototype.handleWrapJump = function(c) {
          var d = Math.round((c - (this._prevLng === void 0 ? c : this._prevLng)) / 360);
          if (this._prevLng = c, d) {
            var _ = {};
            for (var w in this._tiles) {
              var E = this._tiles[w];
              E.tileID = E.tileID.unwrapTo(E.tileID.wrap + d), _[E.tileID.key] = E;
            }
            for (var O in this._tiles = _, this._timers)
              clearTimeout(this._timers[O]), delete this._timers[O];
            for (var k in this._tiles)
              this._setTileReloadTimer(k, this._tiles[k]);
          }
        }, h.prototype.update = function(c) {
          var d = this;
          if (this.transform = c, this._sourceLoaded && !this._paused) {
            var _;
            this.updateCacheSize(c), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? _ = c.getVisibleUnwrappedCoordinates(this._source.tileID).map(function(je) {
              return new o.OverscaledTileID(je.canonical.z, je.wrap, je.canonical.z, je.canonical.x, je.canonical.y);
            }) : (_ = c.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (_ = _.filter(function(je) {
              return d._source.hasTile(je);
            }))) : _ = [];
            var w = c.coveringZoomLevel(this._source), E = Math.max(w - h.maxOverzooming, this._source.minzoom), O = Math.max(w + h.maxUnderzooming, this._source.minzoom), k = this._updateRetainedTiles(_, w);
            if (Ge(this._source.type)) {
              for (var R = {}, $ = {}, W = 0, H = Object.keys(k); W < H.length; W += 1) {
                var ne = H[W], te = k[ne], ue = this._tiles[ne];
                if (ue && !(ue.fadeEndTime && ue.fadeEndTime <= o.browser.now())) {
                  var Y = this.findLoadedParent(te, E);
                  Y && (this._addTile(Y.tileID), R[Y.tileID.key] = Y.tileID), $[ne] = te;
                }
              }
              for (var le in this._retainLoadedChildren($, w, O, k), R)
                k[le] || (this._coveredTiles[le] = !0, k[le] = R[le]);
            }
            for (var me in k)
              this._tiles[me].clearFadeHold();
            for (var xe = 0, Pe = o.keysDifference(this._tiles, k); xe < Pe.length; xe += 1) {
              var Me = Pe[xe], ke = this._tiles[Me];
              ke.hasSymbolBuckets && !ke.holdingForFade() ? ke.setHoldDuration(this.map._fadeDuration) : ke.hasSymbolBuckets && !ke.symbolFadeFinished() || this._removeTile(Me);
            }
            this._updateLoadedParentTileCache();
          }
        }, h.prototype.releaseSymbolFadeTiles = function() {
          for (var c in this._tiles)
            this._tiles[c].holdingForFade() && this._removeTile(c);
        }, h.prototype._updateRetainedTiles = function(c, d) {
          for (var _ = {}, w = {}, E = Math.max(d - h.maxOverzooming, this._source.minzoom), O = Math.max(d + h.maxUnderzooming, this._source.minzoom), k = {}, R = 0, $ = c; R < $.length; R += 1) {
            var W = $[R], H = this._addTile(W);
            _[W.key] = W, H.hasData() || d < this._source.maxzoom && (k[W.key] = W);
          }
          this._retainLoadedChildren(k, d, O, _);
          for (var ne = 0, te = c; ne < te.length; ne += 1) {
            var ue = te[ne], Y = this._tiles[ue.key];
            if (!Y.hasData()) {
              if (d + 1 > this._source.maxzoom) {
                var le = ue.children(this._source.maxzoom)[0], me = this.getTile(le);
                if (me && me.hasData()) {
                  _[le.key] = le;
                  continue;
                }
              } else {
                var xe = ue.children(this._source.maxzoom);
                if (_[xe[0].key] && _[xe[1].key] && _[xe[2].key] && _[xe[3].key])
                  continue;
              }
              for (var Pe = Y.wasRequested(), Me = ue.overscaledZ - 1; Me >= E; --Me) {
                var ke = ue.scaledTo(Me);
                if (w[ke.key] || (w[ke.key] = !0, !(Y = this.getTile(ke)) && Pe && (Y = this._addTile(ke)), Y && (_[ke.key] = ke, Pe = Y.wasRequested(), Y.hasData())))
                  break;
              }
            }
          }
          return _;
        }, h.prototype._updateLoadedParentTileCache = function() {
          for (var c in this._loadedParentTiles = {}, this._tiles) {
            for (var d = [], _ = void 0, w = this._tiles[c].tileID; w.overscaledZ > 0; ) {
              if (w.key in this._loadedParentTiles) {
                _ = this._loadedParentTiles[w.key];
                break;
              }
              d.push(w.key);
              var E = w.scaledTo(w.overscaledZ - 1);
              if (_ = this._getLoadedTile(E))
                break;
              w = E;
            }
            for (var O = 0, k = d; O < k.length; O += 1)
              this._loadedParentTiles[k[O]] = _;
          }
        }, h.prototype._addTile = function(c) {
          var d = this._tiles[c.key];
          if (d)
            return d;
          (d = this._cache.getAndRemove(c)) && (this._setTileReloadTimer(c.key, d), d.tileID = c, this._state.initializeTileState(d, this.map ? this.map.painter : null), this._cacheTimers[c.key] && (clearTimeout(this._cacheTimers[c.key]), delete this._cacheTimers[c.key], this._setTileReloadTimer(c.key, d)));
          var _ = Boolean(d);
          return _ || (d = new o.Tile(c, this._source.tileSize * c.overscaleFactor()), this._loadTile(d, this._tileLoaded.bind(this, d, c.key, d.state))), d ? (d.uses++, this._tiles[c.key] = d, _ || this._source.fire(new o.Event("dataloading", { tile: d, coord: d.tileID, dataType: "source" })), d) : null;
        }, h.prototype._setTileReloadTimer = function(c, d) {
          var _ = this;
          c in this._timers && (clearTimeout(this._timers[c]), delete this._timers[c]);
          var w = d.getExpiryTimeout();
          w && (this._timers[c] = setTimeout(function() {
            _._reloadTile(c, "expired"), delete _._timers[c];
          }, w));
        }, h.prototype._removeTile = function(c) {
          var d = this._tiles[c];
          d && (d.uses--, delete this._tiles[c], this._timers[c] && (clearTimeout(this._timers[c]), delete this._timers[c]), d.uses > 0 || (d.hasData() && d.state !== "reloading" ? this._cache.add(d.tileID, d, d.getExpiryTimeout()) : (d.aborted = !0, this._abortTile(d), this._unloadTile(d))));
        }, h.prototype.clearTiles = function() {
          for (var c in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles)
            this._removeTile(c);
          this._cache.reset();
        }, h.prototype.tilesIn = function(c, d, _) {
          var w = this, E = [], O = this.transform;
          if (!O)
            return E;
          for (var k = _ ? O.getCameraQueryGeometry(c) : c, R = c.map(function(Me) {
            return O.pointCoordinate(Me);
          }), $ = k.map(function(Me) {
            return O.pointCoordinate(Me);
          }), W = this.getIds(), H = 1 / 0, ne = 1 / 0, te = -1 / 0, ue = -1 / 0, Y = 0, le = $; Y < le.length; Y += 1) {
            var me = le[Y];
            H = Math.min(H, me.x), ne = Math.min(ne, me.y), te = Math.max(te, me.x), ue = Math.max(ue, me.y);
          }
          for (var xe = function(Me) {
            var ke = w._tiles[W[Me]];
            if (!ke.holdingForFade()) {
              var je = ke.tileID, it = Math.pow(2, O.zoom - ke.tileID.overscaledZ), tt = d * ke.queryPadding * o.EXTENT / ke.tileSize / it, gt = [je.getTilePoint(new o.MercatorCoordinate(H, ne)), je.getTilePoint(new o.MercatorCoordinate(te, ue))];
              if (gt[0].x - tt < o.EXTENT && gt[0].y - tt < o.EXTENT && gt[1].x + tt >= 0 && gt[1].y + tt >= 0) {
                var Nt = R.map(function(Ft) {
                  return je.getTilePoint(Ft);
                }), Bt = $.map(function(Ft) {
                  return je.getTilePoint(Ft);
                });
                E.push({ tile: ke, tileID: je, queryGeometry: Nt, cameraQueryGeometry: Bt, scale: it });
              }
            }
          }, Pe = 0; Pe < W.length; Pe++)
            xe(Pe);
          return E;
        }, h.prototype.getVisibleCoordinates = function(c) {
          for (var d = this, _ = this.getRenderableIds(c).map(function(k) {
            return d._tiles[k].tileID;
          }), w = 0, E = _; w < E.length; w += 1) {
            var O = E[w];
            O.posMatrix = this.transform.calculatePosMatrix(O.toUnwrapped());
          }
          return _;
        }, h.prototype.hasTransition = function() {
          if (this._source.hasTransition())
            return !0;
          if (Ge(this._source.type))
            for (var c in this._tiles) {
              var d = this._tiles[c];
              if (d.fadeEndTime !== void 0 && d.fadeEndTime >= o.browser.now())
                return !0;
            }
          return !1;
        }, h.prototype.setFeatureState = function(c, d, _) {
          this._state.updateState(c = c || "_geojsonTileLayer", d, _);
        }, h.prototype.removeFeatureState = function(c, d, _) {
          this._state.removeFeatureState(c = c || "_geojsonTileLayer", d, _);
        }, h.prototype.getFeatureState = function(c, d) {
          return this._state.getState(c = c || "_geojsonTileLayer", d);
        }, h.prototype.setDependencies = function(c, d, _) {
          var w = this._tiles[c];
          w && w.setDependencies(d, _);
        }, h.prototype.reloadTilesForDependencies = function(c, d) {
          for (var _ in this._tiles)
            this._tiles[_].hasDependency(c, d) && this._reloadTile(_, "reloading");
          this._cache.filter(function(w) {
            return !w.hasDependency(c, d);
          });
        }, h;
      }(o.Evented);
      function _e(u, h) {
        var c = Math.abs(2 * u.wrap) - +(u.wrap < 0), d = Math.abs(2 * h.wrap) - +(h.wrap < 0);
        return u.overscaledZ - h.overscaledZ || d - c || h.canonical.y - u.canonical.y || h.canonical.x - u.canonical.x;
      }
      function Ge(u) {
        return u === "raster" || u === "image" || u === "video";
      }
      function Ze() {
        return new o.window.Worker(Ih.workerUrl);
      }
      ie.maxOverzooming = 10, ie.maxUnderzooming = 3;
      var Ce = "mapboxgl_preloaded_worker_pool", Ue = function() {
        this.active = {};
      };
      Ue.prototype.acquire = function(u) {
        if (!this.workers)
          for (this.workers = []; this.workers.length < Ue.workerCount; )
            this.workers.push(new Ze());
        return this.active[u] = !0, this.workers.slice();
      }, Ue.prototype.release = function(u) {
        delete this.active[u], this.numActive() === 0 && (this.workers.forEach(function(h) {
          h.terminate();
        }), this.workers = null);
      }, Ue.prototype.isPreloaded = function() {
        return !!this.active[Ce];
      }, Ue.prototype.numActive = function() {
        return Object.keys(this.active).length;
      };
      var Et, _t = Math.floor(o.browser.hardwareConcurrency / 2);
      function Le() {
        return Et || (Et = new Ue()), Et;
      }
      function pt(u, h) {
        var c = {};
        for (var d in u)
          d !== "ref" && (c[d] = u[d]);
        return o.refProperties.forEach(function(_) {
          _ in h && (c[_] = h[_]);
        }), c;
      }
      function st(u) {
        u = u.slice();
        for (var h = /* @__PURE__ */ Object.create(null), c = 0; c < u.length; c++)
          h[u[c].id] = u[c];
        for (var d = 0; d < u.length; d++)
          "ref" in u[d] && (u[d] = pt(u[d], h[u[d].ref]));
        return u;
      }
      Ue.workerCount = Math.max(Math.min(_t, 6), 1);
      var De = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
      function fe(u, h, c) {
        c.push({ command: De.addSource, args: [u, h[u]] });
      }
      function Ee(u, h, c) {
        h.push({ command: De.removeSource, args: [u] }), c[u] = !0;
      }
      function He(u, h, c, d) {
        Ee(u, c, d), fe(u, h, c);
      }
      function jt(u, h, c) {
        var d;
        for (d in u[c])
          if (u[c].hasOwnProperty(d) && d !== "data" && !o.deepEqual(u[c][d], h[c][d]))
            return !1;
        for (d in h[c])
          if (h[c].hasOwnProperty(d) && d !== "data" && !o.deepEqual(u[c][d], h[c][d]))
            return !1;
        return !0;
      }
      function qt(u, h, c, d, _, w) {
        var E;
        for (E in h = h || {}, u = u || {})
          u.hasOwnProperty(E) && (o.deepEqual(u[E], h[E]) || c.push({ command: w, args: [d, E, h[E], _] }));
        for (E in h)
          h.hasOwnProperty(E) && !u.hasOwnProperty(E) && (o.deepEqual(u[E], h[E]) || c.push({ command: w, args: [d, E, h[E], _] }));
      }
      function Jt(u) {
        return u.id;
      }
      function Zt(u, h) {
        return u[h.id] = h, u;
      }
      var Yn = function(u, h) {
        this.reset(u, h);
      };
      Yn.prototype.reset = function(u, h) {
        this.points = u || [], this._distances = [0];
        for (var c = 1; c < this.points.length; c++)
          this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(h || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
      }, Yn.prototype.lerp = function(u) {
        if (this.points.length === 1)
          return this.points[0];
        u = o.clamp(u, 0, 1);
        for (var h = 1, c = this._distances[h], d = u * this.paddedLength + this.padding; c < d && h < this._distances.length; )
          c = this._distances[++h];
        var _ = h - 1, w = this._distances[_], E = c - w, O = E > 0 ? (d - w) / E : 0;
        return this.points[_].mult(1 - O).add(this.points[h].mult(O));
      };
      var Qt = function(u, h, c) {
        var d = this.boxCells = [], _ = this.circleCells = [];
        this.xCellCount = Math.ceil(u / c), this.yCellCount = Math.ceil(h / c);
        for (var w = 0; w < this.xCellCount * this.yCellCount; w++)
          d.push([]), _.push([]);
        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = u, this.height = h, this.xScale = this.xCellCount / u, this.yScale = this.yCellCount / h, this.boxUid = 0, this.circleUid = 0;
      };
      function dn(u, h, c, d, _) {
        var w = o.create();
        return h ? (o.scale(w, w, [1 / _, 1 / _, 1]), c || o.rotateZ(w, w, d.angle)) : o.multiply(w, d.labelPlaneMatrix, u), w;
      }
      function Ur(u, h, c, d, _) {
        if (h) {
          var w = o.clone(u);
          return o.scale(w, w, [_, _, 1]), c || o.rotateZ(w, w, -d.angle), w;
        }
        return d.glCoordMatrix;
      }
      function gr(u, h) {
        var c = [u.x, u.y, 0, 1];
        yi(c, c, h);
        var d = c[3];
        return { point: new o.Point(c[0] / d, c[1] / d), signedDistanceFromCamera: d };
      }
      function zr(u, h) {
        return 0.5 + u / h * 0.5;
      }
      function Yi(u, h) {
        var c = u[0] / u[3], d = u[1] / u[3];
        return c >= -h[0] && c <= h[0] && d >= -h[1] && d <= h[1];
      }
      function Zu(u, h, c, d, _, w, E, O) {
        var k = d ? u.textSizeData : u.iconSizeData, R = o.evaluateSizeForZoom(k, c.transform.zoom), $ = [256 / c.width * 2 + 1, 256 / c.height * 2 + 1], W = d ? u.text.dynamicLayoutVertexArray : u.icon.dynamicLayoutVertexArray;
        W.clear();
        for (var H = u.lineVertexArray, ne = d ? u.text.placedSymbolArray : u.icon.placedSymbolArray, te = c.transform.width / c.transform.height, ue = !1, Y = 0; Y < ne.length; Y++) {
          var le = ne.get(Y);
          if (le.hidden || le.writingMode === o.WritingMode.vertical && !ue)
            Vi(le.numGlyphs, W);
          else {
            ue = !1;
            var me = [le.anchorX, le.anchorY, 0, 1];
            if (o.transformMat4(me, me, h), Yi(me, $)) {
              var xe = zr(c.transform.cameraToCenterDistance, me[3]), Pe = o.evaluateSizeForFeature(k, R, le), Me = E ? Pe / xe : Pe * xe, ke = new o.Point(le.anchorX, le.anchorY), je = gr(ke, _).point, it = {}, tt = Wf(le, Me, !1, O, h, _, w, u.glyphOffsetArray, H, W, je, ke, it, te);
              ue = tt.useVertical, (tt.notEnoughRoom || ue || tt.needsFlipping && Wf(le, Me, !0, O, h, _, w, u.glyphOffsetArray, H, W, je, ke, it, te).notEnoughRoom) && Vi(le.numGlyphs, W);
            } else
              Vi(le.numGlyphs, W);
          }
        }
        d ? u.text.dynamicLayoutVertexBuffer.updateData(W) : u.icon.dynamicLayoutVertexBuffer.updateData(W);
      }
      function mi(u, h, c, d, _, w, E, O, k, R, $) {
        var W = O.glyphStartIndex + O.numGlyphs, H = O.lineStartIndex, ne = O.lineStartIndex + O.lineLength, te = h.getoffsetX(O.glyphStartIndex), ue = h.getoffsetX(W - 1), Y = Ln(u * te, c, d, _, w, E, O.segment, H, ne, k, R, $);
        if (!Y)
          return null;
        var le = Ln(u * ue, c, d, _, w, E, O.segment, H, ne, k, R, $);
        return le ? { first: Y, last: le } : null;
      }
      function Ji(u, h, c, d) {
        return u === o.WritingMode.horizontal && Math.abs(c.y - h.y) > Math.abs(c.x - h.x) * d ? { useVertical: !0 } : (u === o.WritingMode.vertical ? h.y < c.y : h.x > c.x) ? { needsFlipping: !0 } : null;
      }
      function Wf(u, h, c, d, _, w, E, O, k, R, $, W, H, ne) {
        var te, ue = h / 24, Y = u.lineOffsetX * ue, le = u.lineOffsetY * ue;
        if (u.numGlyphs > 1) {
          var me = u.glyphStartIndex + u.numGlyphs, xe = u.lineStartIndex, Pe = u.lineStartIndex + u.lineLength, Me = mi(ue, O, Y, le, c, $, W, u, k, w, H);
          if (!Me)
            return { notEnoughRoom: !0 };
          var ke = gr(Me.first.point, E).point, je = gr(Me.last.point, E).point;
          if (d && !c) {
            var it = Ji(u.writingMode, ke, je, ne);
            if (it)
              return it;
          }
          te = [Me.first];
          for (var tt = u.glyphStartIndex + 1; tt < me - 1; tt++)
            te.push(Ln(ue * O.getoffsetX(tt), Y, le, c, $, W, u.segment, xe, Pe, k, w, H));
          te.push(Me.last);
        } else {
          if (d && !c) {
            var gt = gr(W, _).point, Nt = u.lineStartIndex + u.segment + 1, Bt = new o.Point(k.getx(Nt), k.gety(Nt)), Ft = gr(Bt, _), Ir = Ft.signedDistanceFromCamera > 0 ? Ft.point : Xu(W, Bt, gt, 1, _), xt = Ji(u.writingMode, gt, Ir, ne);
            if (xt)
              return xt;
          }
          var Yt = Ln(ue * O.getoffsetX(u.glyphStartIndex), Y, le, c, $, W, u.segment, u.lineStartIndex, u.lineStartIndex + u.lineLength, k, w, H);
          if (!Yt)
            return { notEnoughRoom: !0 };
          te = [Yt];
        }
        for (var or = 0, Kt = te; or < Kt.length; or += 1) {
          var Xt = Kt[or];
          o.addDynamicAttributes(R, Xt.point, Xt.angle);
        }
        return {};
      }
      function Xu(u, h, c, d, _) {
        var w = gr(u.add(u.sub(h)._unit()), _).point, E = c.sub(w);
        return c.add(E._mult(d / E.mag()));
      }
      function Ln(u, h, c, d, _, w, E, O, k, R, $, W) {
        var H = d ? u - h : u + h, ne = H > 0 ? 1 : -1, te = 0;
        d && (ne *= -1, te = Math.PI), ne < 0 && (te += Math.PI);
        for (var ue = ne > 0 ? O + E : O + E + 1, Y = _, le = _, me = 0, xe = 0, Pe = Math.abs(H), Me = []; me + xe <= Pe; ) {
          if ((ue += ne) < O || ue >= k)
            return null;
          if (le = Y, Me.push(Y), (Y = W[ue]) === void 0) {
            var ke = new o.Point(R.getx(ue), R.gety(ue)), je = gr(ke, $);
            if (je.signedDistanceFromCamera > 0)
              Y = W[ue] = je.point;
            else {
              var it = ue - ne;
              Y = Xu(me === 0 ? w : new o.Point(R.getx(it), R.gety(it)), ke, le, Pe - me + 1, $);
            }
          }
          me += xe, xe = le.dist(Y);
        }
        var tt = (Pe - me) / xe, gt = Y.sub(le), Nt = gt.mult(tt)._add(le);
        Nt._add(gt._unit()._perp()._mult(c * ne));
        var Bt = te + Math.atan2(Y.y - le.y, Y.x - le.x);
        return Me.push(Nt), { point: Nt, angle: Bt, path: Me };
      }
      Qt.prototype.keysLength = function() {
        return this.boxKeys.length + this.circleKeys.length;
      }, Qt.prototype.insert = function(u, h, c, d, _) {
        this._forEachCell(h, c, d, _, this._insertBoxCell, this.boxUid++), this.boxKeys.push(u), this.bboxes.push(h), this.bboxes.push(c), this.bboxes.push(d), this.bboxes.push(_);
      }, Qt.prototype.insertCircle = function(u, h, c, d) {
        this._forEachCell(h - d, c - d, h + d, c + d, this._insertCircleCell, this.circleUid++), this.circleKeys.push(u), this.circles.push(h), this.circles.push(c), this.circles.push(d);
      }, Qt.prototype._insertBoxCell = function(u, h, c, d, _, w) {
        this.boxCells[_].push(w);
      }, Qt.prototype._insertCircleCell = function(u, h, c, d, _, w) {
        this.circleCells[_].push(w);
      }, Qt.prototype._query = function(u, h, c, d, _, w) {
        if (c < 0 || u > this.width || d < 0 || h > this.height)
          return !_ && [];
        var E = [];
        if (u <= 0 && h <= 0 && this.width <= c && this.height <= d) {
          if (_)
            return !0;
          for (var O = 0; O < this.boxKeys.length; O++)
            E.push({ key: this.boxKeys[O], x1: this.bboxes[4 * O], y1: this.bboxes[4 * O + 1], x2: this.bboxes[4 * O + 2], y2: this.bboxes[4 * O + 3] });
          for (var k = 0; k < this.circleKeys.length; k++) {
            var R = this.circles[3 * k], $ = this.circles[3 * k + 1], W = this.circles[3 * k + 2];
            E.push({ key: this.circleKeys[k], x1: R - W, y1: $ - W, x2: R + W, y2: $ + W });
          }
          return w ? E.filter(w) : E;
        }
        return this._forEachCell(u, h, c, d, this._queryCell, E, { hitTest: _, seenUids: { box: {}, circle: {} } }, w), _ ? E.length > 0 : E;
      }, Qt.prototype._queryCircle = function(u, h, c, d, _) {
        var w = u - c, E = u + c, O = h - c, k = h + c;
        if (E < 0 || w > this.width || k < 0 || O > this.height)
          return !d && [];
        var R = [];
        return this._forEachCell(w, O, E, k, this._queryCellCircle, R, { hitTest: d, circle: { x: u, y: h, radius: c }, seenUids: { box: {}, circle: {} } }, _), d ? R.length > 0 : R;
      }, Qt.prototype.query = function(u, h, c, d, _) {
        return this._query(u, h, c, d, !1, _);
      }, Qt.prototype.hitTest = function(u, h, c, d, _) {
        return this._query(u, h, c, d, !0, _);
      }, Qt.prototype.hitTestCircle = function(u, h, c, d) {
        return this._queryCircle(u, h, c, !0, d);
      }, Qt.prototype._queryCell = function(u, h, c, d, _, w, E, O) {
        var k = E.seenUids, R = this.boxCells[_];
        if (R !== null)
          for (var $ = this.bboxes, W = 0, H = R; W < H.length; W += 1) {
            var ne = H[W];
            if (!k.box[ne]) {
              k.box[ne] = !0;
              var te = 4 * ne;
              if (u <= $[te + 2] && h <= $[te + 3] && c >= $[te + 0] && d >= $[te + 1] && (!O || O(this.boxKeys[ne]))) {
                if (E.hitTest)
                  return w.push(!0), !0;
                w.push({ key: this.boxKeys[ne], x1: $[te], y1: $[te + 1], x2: $[te + 2], y2: $[te + 3] });
              }
            }
          }
        var ue = this.circleCells[_];
        if (ue !== null)
          for (var Y = this.circles, le = 0, me = ue; le < me.length; le += 1) {
            var xe = me[le];
            if (!k.circle[xe]) {
              k.circle[xe] = !0;
              var Pe = 3 * xe;
              if (this._circleAndRectCollide(Y[Pe], Y[Pe + 1], Y[Pe + 2], u, h, c, d) && (!O || O(this.circleKeys[xe]))) {
                if (E.hitTest)
                  return w.push(!0), !0;
                var Me = Y[Pe], ke = Y[Pe + 1], je = Y[Pe + 2];
                w.push({ key: this.circleKeys[xe], x1: Me - je, y1: ke - je, x2: Me + je, y2: ke + je });
              }
            }
          }
      }, Qt.prototype._queryCellCircle = function(u, h, c, d, _, w, E, O) {
        var k = E.circle, R = E.seenUids, $ = this.boxCells[_];
        if ($ !== null)
          for (var W = this.bboxes, H = 0, ne = $; H < ne.length; H += 1) {
            var te = ne[H];
            if (!R.box[te]) {
              R.box[te] = !0;
              var ue = 4 * te;
              if (this._circleAndRectCollide(k.x, k.y, k.radius, W[ue + 0], W[ue + 1], W[ue + 2], W[ue + 3]) && (!O || O(this.boxKeys[te])))
                return w.push(!0), !0;
            }
          }
        var Y = this.circleCells[_];
        if (Y !== null)
          for (var le = this.circles, me = 0, xe = Y; me < xe.length; me += 1) {
            var Pe = xe[me];
            if (!R.circle[Pe]) {
              R.circle[Pe] = !0;
              var Me = 3 * Pe;
              if (this._circlesCollide(le[Me], le[Me + 1], le[Me + 2], k.x, k.y, k.radius) && (!O || O(this.circleKeys[Pe])))
                return w.push(!0), !0;
            }
          }
      }, Qt.prototype._forEachCell = function(u, h, c, d, _, w, E, O) {
        for (var k = this._convertToXCellCoord(u), R = this._convertToYCellCoord(h), $ = this._convertToXCellCoord(c), W = this._convertToYCellCoord(d), H = k; H <= $; H++)
          for (var ne = R; ne <= W; ne++)
            if (_.call(this, u, h, c, d, this.xCellCount * ne + H, w, E, O))
              return;
      }, Qt.prototype._convertToXCellCoord = function(u) {
        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(u * this.xScale)));
      }, Qt.prototype._convertToYCellCoord = function(u) {
        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(u * this.yScale)));
      }, Qt.prototype._circlesCollide = function(u, h, c, d, _, w) {
        var E = d - u, O = _ - h, k = c + w;
        return k * k > E * E + O * O;
      }, Qt.prototype._circleAndRectCollide = function(u, h, c, d, _, w, E) {
        var O = (w - d) / 2, k = Math.abs(u - (d + O));
        if (k > O + c)
          return !1;
        var R = (E - _) / 2, $ = Math.abs(h - (_ + R));
        if ($ > R + c)
          return !1;
        if (k <= O || $ <= R)
          return !0;
        var W = k - O, H = $ - R;
        return W * W + H * H <= c * c;
      };
      var Ku = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function Vi(u, h) {
        for (var c = 0; c < u; c++) {
          var d = h.length;
          h.resize(d + 4), h.float32.set(Ku, 3 * d);
        }
      }
      function yi(u, h, c) {
        var d = h[0], _ = h[1];
        return u[0] = c[0] * d + c[4] * _ + c[12], u[1] = c[1] * d + c[5] * _ + c[13], u[3] = c[3] * d + c[7] * _ + c[15], u;
      }
      var jo = function(u, h, c) {
        h === void 0 && (h = new Qt(u.width + 200, u.height + 200, 25)), c === void 0 && (c = new Qt(u.width + 200, u.height + 200, 25)), this.transform = u, this.grid = h, this.ignoredGrid = c, this.pitchfactor = Math.cos(u._pitch) * u.cameraToCenterDistance, this.screenRightBoundary = u.width + 100, this.screenBottomBoundary = u.height + 100, this.gridRightBoundary = u.width + 200, this.gridBottomBoundary = u.height + 200;
      };
      function mn(u, h, c) {
        return h * (o.EXTENT / (u.tileSize * Math.pow(2, c - u.tileID.overscaledZ)));
      }
      jo.prototype.placeCollisionBox = function(u, h, c, d, _) {
        var w = this.projectAndGetPerspectiveRatio(d, u.anchorPointX, u.anchorPointY), E = c * w.perspectiveRatio, O = u.x1 * E + w.point.x, k = u.y1 * E + w.point.y, R = u.x2 * E + w.point.x, $ = u.y2 * E + w.point.y;
        return !this.isInsideGrid(O, k, R, $) || !h && this.grid.hitTest(O, k, R, $, _) ? { box: [], offscreen: !1 } : { box: [O, k, R, $], offscreen: this.isOffscreen(O, k, R, $) };
      }, jo.prototype.placeCollisionCircles = function(u, h, c, d, _, w, E, O, k, R, $, W, H) {
        var ne = [], te = new o.Point(h.anchorX, h.anchorY), ue = gr(te, w), Y = zr(this.transform.cameraToCenterDistance, ue.signedDistanceFromCamera), le = (R ? _ / Y : _ * Y) / o.ONE_EM, me = gr(te, E).point, xe = mi(le, d, h.lineOffsetX * le, h.lineOffsetY * le, !1, me, te, h, c, E, {}), Pe = !1, Me = !1, ke = !0;
        if (xe) {
          for (var je = 0.5 * W * Y + H, it = new o.Point(-100, -100), tt = new o.Point(this.screenRightBoundary, this.screenBottomBoundary), gt = new Yn(), Nt = xe.first, Bt = xe.last, Ft = [], Ir = Nt.path.length - 1; Ir >= 1; Ir--)
            Ft.push(Nt.path[Ir]);
          for (var xt = 1; xt < Bt.path.length; xt++)
            Ft.push(Bt.path[xt]);
          var Yt = 2.5 * je;
          if (O) {
            var or = Ft.map(function(Zo) {
              return gr(Zo, O);
            });
            Ft = or.some(function(Zo) {
              return Zo.signedDistanceFromCamera <= 0;
            }) ? [] : or.map(function(Zo) {
              return Zo.point;
            });
          }
          var Kt = [];
          if (Ft.length > 0) {
            for (var Xt = Ft[0].clone(), nr = Ft[0].clone(), Wt = 1; Wt < Ft.length; Wt++)
              Xt.x = Math.min(Xt.x, Ft[Wt].x), Xt.y = Math.min(Xt.y, Ft[Wt].y), nr.x = Math.max(nr.x, Ft[Wt].x), nr.y = Math.max(nr.y, Ft[Wt].y);
            Kt = Xt.x >= it.x && nr.x <= tt.x && Xt.y >= it.y && nr.y <= tt.y ? [Ft] : nr.x < it.x || Xt.x > tt.x || nr.y < it.y || Xt.y > tt.y ? [] : o.clipLine([Ft], it.x, it.y, tt.x, tt.y);
          }
          for (var Gt = 0, li = Kt; Gt < li.length; Gt += 1) {
            var On;
            gt.reset(li[Gt], 0.25 * je), On = gt.length <= 0.5 * je ? 1 : Math.ceil(gt.paddedLength / Yt) + 1;
            for (var Li = 0; Li < On; Li++) {
              var vi = Li / Math.max(On - 1, 1), Mn = gt.lerp(vi), Dn = Mn.x + 100, mo = Mn.y + 100;
              ne.push(Dn, mo, je, 0);
              var $i = Dn - je, Is = mo - je, Qi = Dn + je, ca = mo + je;
              if (ke = ke && this.isOffscreen($i, Is, Qi, ca), Me = Me || this.isInsideGrid($i, Is, Qi, ca), !u && this.grid.hitTestCircle(Dn, mo, je, $) && (Pe = !0, !k))
                return { circles: [], offscreen: !1, collisionDetected: Pe };
            }
          }
        }
        return { circles: !k && Pe || !Me ? [] : ne, offscreen: ke, collisionDetected: Pe };
      }, jo.prototype.queryRenderedSymbols = function(u) {
        if (u.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
          return {};
        for (var h = [], c = 1 / 0, d = 1 / 0, _ = -1 / 0, w = -1 / 0, E = 0, O = u; E < O.length; E += 1) {
          var k = O[E], R = new o.Point(k.x + 100, k.y + 100);
          c = Math.min(c, R.x), d = Math.min(d, R.y), _ = Math.max(_, R.x), w = Math.max(w, R.y), h.push(R);
        }
        for (var $ = {}, W = {}, H = 0, ne = this.grid.query(c, d, _, w).concat(this.ignoredGrid.query(c, d, _, w)); H < ne.length; H += 1) {
          var te = ne[H], ue = te.key;
          if ($[ue.bucketInstanceId] === void 0 && ($[ue.bucketInstanceId] = {}), !$[ue.bucketInstanceId][ue.featureIndex]) {
            var Y = [new o.Point(te.x1, te.y1), new o.Point(te.x2, te.y1), new o.Point(te.x2, te.y2), new o.Point(te.x1, te.y2)];
            o.polygonIntersectsPolygon(h, Y) && ($[ue.bucketInstanceId][ue.featureIndex] = !0, W[ue.bucketInstanceId] === void 0 && (W[ue.bucketInstanceId] = []), W[ue.bucketInstanceId].push(ue.featureIndex));
          }
        }
        return W;
      }, jo.prototype.insertCollisionBox = function(u, h, c, d, _) {
        (h ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: c, featureIndex: d, collisionGroupID: _ }, u[0], u[1], u[2], u[3]);
      }, jo.prototype.insertCollisionCircles = function(u, h, c, d, _) {
        for (var w = h ? this.ignoredGrid : this.grid, E = { bucketInstanceId: c, featureIndex: d, collisionGroupID: _ }, O = 0; O < u.length; O += 4)
          w.insertCircle(E, u[O], u[O + 1], u[O + 2]);
      }, jo.prototype.projectAndGetPerspectiveRatio = function(u, h, c) {
        var d = [h, c, 0, 1];
        return yi(d, d, u), { point: new o.Point((d[0] / d[3] + 1) / 2 * this.transform.width + 100, (-d[1] / d[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / d[3] * 0.5 };
      }, jo.prototype.isOffscreen = function(u, h, c, d) {
        return c < 100 || u >= this.screenRightBoundary || d < 100 || h > this.screenBottomBoundary;
      }, jo.prototype.isInsideGrid = function(u, h, c, d) {
        return c >= 0 && u < this.gridRightBoundary && d >= 0 && h < this.gridBottomBoundary;
      }, jo.prototype.getViewportMatrix = function() {
        var u = o.identity([]);
        return o.translate(u, u, [-100, -100, 0]), u;
      };
      var ia = function(u, h, c, d) {
        this.opacity = u ? Math.max(0, Math.min(1, u.opacity + (u.placed ? h : -h))) : d && c ? 1 : 0, this.placed = c;
      };
      ia.prototype.isHidden = function() {
        return this.opacity === 0 && !this.placed;
      };
      var To = function(u, h, c, d, _) {
        this.text = new ia(u ? u.text : null, h, c, _), this.icon = new ia(u ? u.icon : null, h, d, _);
      };
      To.prototype.isHidden = function() {
        return this.text.isHidden() && this.icon.isHidden();
      };
      var sm = function(u, h, c) {
        this.text = u, this.icon = h, this.skipFade = c;
      }, Go = function() {
        this.invProjMatrix = o.create(), this.viewportMatrix = o.create(), this.circles = [];
      }, Bv = function(u, h, c, d, _) {
        this.bucketInstanceId = u, this.featureIndex = h, this.sourceLayerIndex = c, this.bucketIndex = d, this.tileID = _;
      }, Va = function(u) {
        this.crossSourceCollisions = u, this.maxGroupID = 0, this.collisionGroups = {};
      };
      function Si(u, h, c, d, _) {
        var w = o.getAnchorAlignment(u), E = -(w.horizontalAlign - 0.5) * h, O = -(w.verticalAlign - 0.5) * c, k = o.evaluateVariableOffset(u, d);
        return new o.Point(E + k[0] * _, O + k[1] * _);
      }
      function xa(u, h, c, d, _, w) {
        var E = u.x1, O = u.x2, k = u.y1, R = u.y2, $ = u.anchorPointX, W = u.anchorPointY, H = new o.Point(h, c);
        return d && H._rotate(_ ? w : -w), { x1: E + H.x, y1: k + H.y, x2: O + H.x, y2: R + H.y, anchorPointX: $, anchorPointY: W };
      }
      Va.prototype.get = function(u) {
        if (this.crossSourceCollisions)
          return { ID: 0, predicate: null };
        if (!this.collisionGroups[u]) {
          var h = ++this.maxGroupID;
          this.collisionGroups[u] = { ID: h, predicate: function(c) {
            return c.collisionGroupID === h;
          } };
        }
        return this.collisionGroups[u];
      };
      var Ui = function(u, h, c, d) {
        this.transform = u.clone(), this.collisionIndex = new jo(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = h, this.retainedQueryData = {}, this.collisionGroups = new Va(c), this.collisionCircleArrays = {}, this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {};
      };
      function al(u, h, c, d, _) {
        u.emplaceBack(h ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(h ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(h ? 1 : 0, c ? 1 : 0, d || 0, _ || 0), u.emplaceBack(h ? 1 : 0, c ? 1 : 0, d || 0, _ || 0);
      }
      Ui.prototype.getBucketParts = function(u, h, c, d) {
        var _ = c.getBucket(h), w = c.latestFeatureIndex;
        if (_ && w && h.id === _.layerIds[0]) {
          var E = c.collisionBoxArray, O = _.layers[0].layout, k = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), R = c.tileSize / o.EXTENT, $ = this.transform.calculatePosMatrix(c.tileID.toUnwrapped()), W = O.get("text-pitch-alignment") === "map", H = O.get("text-rotation-alignment") === "map", ne = mn(c, 1, this.transform.zoom), te = dn($, W, H, this.transform, ne), ue = null;
          if (W) {
            var Y = Ur($, W, H, this.transform, ne);
            ue = o.multiply([], this.transform.labelPlaneMatrix, Y);
          }
          this.retainedQueryData[_.bucketInstanceId] = new Bv(_.bucketInstanceId, w, _.sourceLayerIndex, _.index, c.tileID);
          var le = { bucket: _, layout: O, posMatrix: $, textLabelPlaneMatrix: te, labelToScreenMatrix: ue, scale: k, textPixelRatio: R, holdingForFade: c.holdingForFade(), collisionBoxArray: E, partiallyEvaluatedTextSize: o.evaluateSizeForZoom(_.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(_.sourceID) };
          if (d)
            for (var me = 0, xe = _.sortKeyRanges; me < xe.length; me += 1) {
              var Pe = xe[me];
              u.push({ sortKey: Pe.sortKey, symbolInstanceStart: Pe.symbolInstanceStart, symbolInstanceEnd: Pe.symbolInstanceEnd, parameters: le });
            }
          else
            u.push({ symbolInstanceStart: 0, symbolInstanceEnd: _.symbolInstances.length, parameters: le });
        }
      }, Ui.prototype.attemptAnchorPlacement = function(u, h, c, d, _, w, E, O, k, R, $, W, H, ne, te) {
        var ue, Y = [W.textOffset0, W.textOffset1], le = Si(u, c, d, Y, _), me = this.collisionIndex.placeCollisionBox(xa(h, le.x, le.y, w, E, this.transform.angle), $, O, k, R.predicate);
        if (!te || this.collisionIndex.placeCollisionBox(xa(te, le.x, le.y, w, E, this.transform.angle), $, O, k, R.predicate).box.length !== 0)
          return me.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[W.crossTileID] && this.prevPlacement.placements[W.crossTileID] && this.prevPlacement.placements[W.crossTileID].text && (ue = this.prevPlacement.variableOffsets[W.crossTileID].anchor), this.variableOffsets[W.crossTileID] = { textOffset: Y, width: c, height: d, anchor: u, textBoxScale: _, prevAnchor: ue }, this.markUsedJustification(H, u, W, ne), H.allowVerticalPlacement && (this.markUsedOrientation(H, ne, W), this.placedOrientations[W.crossTileID] = ne), { shift: le, placedGlyphBoxes: me }) : void 0;
      }, Ui.prototype.placeLayerBucketPart = function(u, h, c) {
        var d = this, _ = u.parameters, w = _.bucket, E = _.layout, O = _.posMatrix, k = _.textLabelPlaneMatrix, R = _.labelToScreenMatrix, $ = _.textPixelRatio, W = _.holdingForFade, H = _.collisionBoxArray, ne = _.partiallyEvaluatedTextSize, te = _.collisionGroup, ue = E.get("text-optional"), Y = E.get("icon-optional"), le = E.get("text-allow-overlap"), me = E.get("icon-allow-overlap"), xe = E.get("text-rotation-alignment") === "map", Pe = E.get("text-pitch-alignment") === "map", Me = E.get("icon-text-fit") !== "none", ke = E.get("symbol-z-order") === "viewport-y", je = le && (me || !w.hasIconData() || Y), it = me && (le || !w.hasTextData() || ue);
        !w.collisionArrays && H && w.deserializeCollisionBoxes(H);
        var tt = function(xt, Yt) {
          if (!h[xt.crossTileID])
            if (W)
              d.placements[xt.crossTileID] = new sm(!1, !1, !1);
            else {
              var or, Kt = !1, Xt = !1, nr = !0, Wt = null, Gt = { box: null, offscreen: null }, li = { box: null, offscreen: null }, On = null, Li = null, vi = 0, Mn = 0, Dn = 0;
              Yt.textFeatureIndex ? vi = Yt.textFeatureIndex : xt.useRuntimeCollisionCircles && (vi = xt.featureIndex), Yt.verticalTextFeatureIndex && (Mn = Yt.verticalTextFeatureIndex);
              var mo = Yt.textBox;
              if (mo) {
                var $i = function(Fr) {
                  var Oo = o.WritingMode.horizontal;
                  if (w.allowVerticalPlacement && !Fr && d.prevPlacement) {
                    var eo = d.prevPlacement.placedOrientations[xt.crossTileID];
                    eo && (d.placedOrientations[xt.crossTileID] = eo, d.markUsedOrientation(w, Oo = eo, xt));
                  }
                  return Oo;
                }, Is = function(Fr, Oo) {
                  if (w.allowVerticalPlacement && xt.numVerticalGlyphVertices > 0 && Yt.verticalTextBox)
                    for (var eo = 0, Sl = w.writingModes; eo < Sl.length && (Sl[eo] === o.WritingMode.vertical ? (Gt = Oo(), li = Gt) : Gt = Fr(), !(Gt && Gt.box && Gt.box.length)); eo += 1)
                      ;
                  else
                    Gt = Fr();
                };
                if (E.get("text-variable-anchor")) {
                  var Qi = E.get("text-variable-anchor");
                  if (d.prevPlacement && d.prevPlacement.variableOffsets[xt.crossTileID]) {
                    var ca = d.prevPlacement.variableOffsets[xt.crossTileID];
                    Qi.indexOf(ca.anchor) > 0 && (Qi = Qi.filter(function(Fr) {
                      return Fr !== ca.anchor;
                    })).unshift(ca.anchor);
                  }
                  var Zo = function(Fr, Oo, eo) {
                    for (var Sl = Fr.x2 - Fr.x1, Qv = Fr.y2 - Fr.y1, Oh = xt.textBoxScale, e_ = Me && !me ? Oo : null, gc = { box: [], offscreen: !1 }, Fm = le ? 2 * Qi.length : Qi.length, uu = 0; uu < Fm; ++uu) {
                      var Ch = d.attemptAnchorPlacement(Qi[uu % Qi.length], Fr, Sl, Qv, Oh, xe, Pe, $, O, te, uu >= Qi.length, xt, w, eo, e_);
                      if (Ch && (gc = Ch.placedGlyphBoxes) && gc.box && gc.box.length) {
                        Kt = !0, Wt = Ch.shift;
                        break;
                      }
                    }
                    return gc;
                  };
                  Is(function() {
                    return Zo(mo, Yt.iconBox, o.WritingMode.horizontal);
                  }, function() {
                    var Fr = Yt.verticalTextBox;
                    return w.allowVerticalPlacement && !(Gt && Gt.box && Gt.box.length) && xt.numVerticalGlyphVertices > 0 && Fr ? Zo(Fr, Yt.verticalIconBox, o.WritingMode.vertical) : { box: null, offscreen: null };
                  }), Gt && (Kt = Gt.box, nr = Gt.offscreen);
                  var dc = $i(Gt && Gt.box);
                  if (!Kt && d.prevPlacement) {
                    var su = d.prevPlacement.variableOffsets[xt.crossTileID];
                    su && (d.variableOffsets[xt.crossTileID] = su, d.markUsedJustification(w, su.anchor, xt, dc));
                  }
                } else {
                  var Os = function(Fr, Oo) {
                    var eo = d.collisionIndex.placeCollisionBox(Fr, le, $, O, te.predicate);
                    return eo && eo.box && eo.box.length && (d.markUsedOrientation(w, Oo, xt), d.placedOrientations[xt.crossTileID] = Oo), eo;
                  };
                  Is(function() {
                    return Os(mo, o.WritingMode.horizontal);
                  }, function() {
                    var Fr = Yt.verticalTextBox;
                    return w.allowVerticalPlacement && xt.numVerticalGlyphVertices > 0 && Fr ? Os(Fr, o.WritingMode.vertical) : { box: null, offscreen: null };
                  }), $i(Gt && Gt.box && Gt.box.length);
                }
              }
              if (Kt = (or = Gt) && or.box && or.box.length > 0, nr = or && or.offscreen, xt.useRuntimeCollisionCircles) {
                var lu = w.text.placedSymbolArray.get(xt.centerJustifiedTextSymbolIndex), mc = o.evaluateSizeForFeature(w.textSizeData, ne, lu), Sa = E.get("text-padding");
                On = d.collisionIndex.placeCollisionCircles(le, lu, w.lineVertexArray, w.glyphOffsetArray, mc, O, k, R, c, Pe, te.predicate, xt.collisionCircleDiameter, Sa), Kt = le || On.circles.length > 0 && !On.collisionDetected, nr = nr && On.offscreen;
              }
              if (Yt.iconFeatureIndex && (Dn = Yt.iconFeatureIndex), Yt.iconBox) {
                var yc = function(Fr) {
                  var Oo = Me && Wt ? xa(Fr, Wt.x, Wt.y, xe, Pe, d.transform.angle) : Fr;
                  return d.collisionIndex.placeCollisionBox(Oo, me, $, O, te.predicate);
                };
                Xt = li && li.box && li.box.length && Yt.verticalIconBox ? (Li = yc(Yt.verticalIconBox)).box.length > 0 : (Li = yc(Yt.iconBox)).box.length > 0, nr = nr && Li.offscreen;
              }
              var Ta = ue || xt.numHorizontalGlyphVertices === 0 && xt.numVerticalGlyphVertices === 0, ui = Y || xt.numIconVertices === 0;
              if (Ta || ui ? ui ? Ta || (Xt = Xt && Kt) : Kt = Xt && Kt : Xt = Kt = Xt && Kt, Kt && or && or.box && d.collisionIndex.insertCollisionBox(or.box, E.get("text-ignore-placement"), w.bucketInstanceId, li && li.box && Mn ? Mn : vi, te.ID), Xt && Li && d.collisionIndex.insertCollisionBox(Li.box, E.get("icon-ignore-placement"), w.bucketInstanceId, Dn, te.ID), On && (Kt && d.collisionIndex.insertCollisionCircles(On.circles, E.get("text-ignore-placement"), w.bucketInstanceId, vi, te.ID), c)) {
                var $a = w.bucketInstanceId, Cs = d.collisionCircleArrays[$a];
                Cs === void 0 && (Cs = d.collisionCircleArrays[$a] = new Go());
                for (var El = 0; El < On.circles.length; El += 4)
                  Cs.circles.push(On.circles[El + 0]), Cs.circles.push(On.circles[El + 1]), Cs.circles.push(On.circles[El + 2]), Cs.circles.push(On.collisionDetected ? 1 : 0);
              }
              d.placements[xt.crossTileID] = new sm(Kt || je, Xt || it, nr || w.justReloaded), h[xt.crossTileID] = !0;
            }
        };
        if (ke)
          for (var gt = w.getSortedSymbolIndexes(this.transform.angle), Nt = gt.length - 1; Nt >= 0; --Nt) {
            var Bt = gt[Nt];
            tt(w.symbolInstances.get(Bt), w.collisionArrays[Bt]);
          }
        else
          for (var Ft = u.symbolInstanceStart; Ft < u.symbolInstanceEnd; Ft++)
            tt(w.symbolInstances.get(Ft), w.collisionArrays[Ft]);
        if (c && w.bucketInstanceId in this.collisionCircleArrays) {
          var Ir = this.collisionCircleArrays[w.bucketInstanceId];
          o.invert(Ir.invProjMatrix, O), Ir.viewportMatrix = this.collisionIndex.getViewportMatrix();
        }
        w.justReloaded = !1;
      }, Ui.prototype.markUsedJustification = function(u, h, c, d) {
        var _;
        _ = d === o.WritingMode.vertical ? c.verticalPlacedTextSymbolIndex : { left: c.leftJustifiedTextSymbolIndex, center: c.centerJustifiedTextSymbolIndex, right: c.rightJustifiedTextSymbolIndex }[o.getAnchorJustification(h)];
        for (var w = 0, E = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex]; w < E.length; w += 1) {
          var O = E[w];
          O >= 0 && (u.text.placedSymbolArray.get(O).crossTileID = _ >= 0 && O !== _ ? 0 : c.crossTileID);
        }
      }, Ui.prototype.markUsedOrientation = function(u, h, c) {
        for (var d = h === o.WritingMode.horizontal || h === o.WritingMode.horizontalOnly ? h : 0, _ = h === o.WritingMode.vertical ? h : 0, w = 0, E = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex]; w < E.length; w += 1)
          u.text.placedSymbolArray.get(E[w]).placedOrientation = d;
        c.verticalPlacedTextSymbolIndex && (u.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = _);
      }, Ui.prototype.commit = function(u) {
        this.commitTime = u, this.zoomAtLastRecencyCheck = this.transform.zoom;
        var h = this.prevPlacement, c = !1;
        this.prevZoomAdjustment = h ? h.zoomAdjustment(this.transform.zoom) : 0;
        var d = h ? h.symbolFadeChange(u) : 1, _ = h ? h.opacities : {}, w = h ? h.variableOffsets : {}, E = h ? h.placedOrientations : {};
        for (var O in this.placements) {
          var k = this.placements[O], R = _[O];
          R ? (this.opacities[O] = new To(R, d, k.text, k.icon), c = c || k.text !== R.text.placed || k.icon !== R.icon.placed) : (this.opacities[O] = new To(null, d, k.text, k.icon, k.skipFade), c = c || k.text || k.icon);
        }
        for (var $ in _) {
          var W = _[$];
          if (!this.opacities[$]) {
            var H = new To(W, d, !1, !1);
            H.isHidden() || (this.opacities[$] = H, c = c || W.text.placed || W.icon.placed);
          }
        }
        for (var ne in w)
          this.variableOffsets[ne] || !this.opacities[ne] || this.opacities[ne].isHidden() || (this.variableOffsets[ne] = w[ne]);
        for (var te in E)
          this.placedOrientations[te] || !this.opacities[te] || this.opacities[te].isHidden() || (this.placedOrientations[te] = E[te]);
        c ? this.lastPlacementChangeTime = u : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = h ? h.lastPlacementChangeTime : u);
      }, Ui.prototype.updateLayerOpacities = function(u, h) {
        for (var c = {}, d = 0, _ = h; d < _.length; d += 1) {
          var w = _[d], E = w.getBucket(u);
          E && w.latestFeatureIndex && u.id === E.layerIds[0] && this.updateBucketOpacities(E, c, w.collisionBoxArray);
        }
      }, Ui.prototype.updateBucketOpacities = function(u, h, c) {
        var d = this;
        u.hasTextData() && u.text.opacityVertexArray.clear(), u.hasIconData() && u.icon.opacityVertexArray.clear(), u.hasIconCollisionBoxData() && u.iconCollisionBox.collisionVertexArray.clear(), u.hasTextCollisionBoxData() && u.textCollisionBox.collisionVertexArray.clear();
        var _ = u.layers[0].layout, w = new To(null, 0, !1, !1, !0), E = _.get("text-allow-overlap"), O = _.get("icon-allow-overlap"), k = _.get("text-variable-anchor"), R = _.get("text-rotation-alignment") === "map", $ = _.get("text-pitch-alignment") === "map", W = _.get("icon-text-fit") !== "none", H = new To(null, 0, E && (O || !u.hasIconData() || _.get("icon-optional")), O && (E || !u.hasTextData() || _.get("text-optional")), !0);
        !u.collisionArrays && c && (u.hasIconCollisionBoxData() || u.hasTextCollisionBoxData()) && u.deserializeCollisionBoxes(c);
        for (var ne = function(le, me, xe) {
          for (var Pe = 0; Pe < me / 4; Pe++)
            le.opacityVertexArray.emplaceBack(xe);
        }, te = function(le) {
          var me = u.symbolInstances.get(le), xe = me.numHorizontalGlyphVertices, Pe = me.numVerticalGlyphVertices, Me = me.crossTileID, ke = d.opacities[Me];
          h[Me] ? ke = w : ke || (d.opacities[Me] = ke = H), h[Me] = !0;
          var je = me.numIconVertices > 0, it = d.placedOrientations[me.crossTileID], tt = it === o.WritingMode.vertical, gt = it === o.WritingMode.horizontal || it === o.WritingMode.horizontalOnly;
          if (xe > 0 || Pe > 0) {
            var Nt = cm(ke.text);
            ne(u.text, xe, tt ? Kl : Nt), ne(u.text, Pe, gt ? Kl : Nt);
            var Bt = ke.text.isHidden();
            [me.rightJustifiedTextSymbolIndex, me.centerJustifiedTextSymbolIndex, me.leftJustifiedTextSymbolIndex].forEach(function(Gt) {
              Gt >= 0 && (u.text.placedSymbolArray.get(Gt).hidden = Bt || tt ? 1 : 0);
            }), me.verticalPlacedTextSymbolIndex >= 0 && (u.text.placedSymbolArray.get(me.verticalPlacedTextSymbolIndex).hidden = Bt || gt ? 1 : 0);
            var Ft = d.variableOffsets[me.crossTileID];
            Ft && d.markUsedJustification(u, Ft.anchor, me, it);
            var Ir = d.placedOrientations[me.crossTileID];
            Ir && (d.markUsedJustification(u, "left", me, Ir), d.markUsedOrientation(u, Ir, me));
          }
          if (je) {
            var xt = cm(ke.icon), Yt = !(W && me.verticalPlacedIconSymbolIndex && tt);
            me.placedIconSymbolIndex >= 0 && (ne(u.icon, me.numIconVertices, Yt ? xt : Kl), u.icon.placedSymbolArray.get(me.placedIconSymbolIndex).hidden = ke.icon.isHidden()), me.verticalPlacedIconSymbolIndex >= 0 && (ne(u.icon, me.numVerticalIconVertices, Yt ? Kl : xt), u.icon.placedSymbolArray.get(me.verticalPlacedIconSymbolIndex).hidden = ke.icon.isHidden());
          }
          if (u.hasIconCollisionBoxData() || u.hasTextCollisionBoxData()) {
            var or = u.collisionArrays[le];
            if (or) {
              var Kt = new o.Point(0, 0);
              if (or.textBox || or.verticalTextBox) {
                var Xt = !0;
                if (k) {
                  var nr = d.variableOffsets[Me];
                  nr ? (Kt = Si(nr.anchor, nr.width, nr.height, nr.textOffset, nr.textBoxScale), R && Kt._rotate($ ? d.transform.angle : -d.transform.angle)) : Xt = !1;
                }
                or.textBox && al(u.textCollisionBox.collisionVertexArray, ke.text.placed, !Xt || tt, Kt.x, Kt.y), or.verticalTextBox && al(u.textCollisionBox.collisionVertexArray, ke.text.placed, !Xt || gt, Kt.x, Kt.y);
              }
              var Wt = Boolean(!gt && or.verticalIconBox);
              or.iconBox && al(u.iconCollisionBox.collisionVertexArray, ke.icon.placed, Wt, W ? Kt.x : 0, W ? Kt.y : 0), or.verticalIconBox && al(u.iconCollisionBox.collisionVertexArray, ke.icon.placed, !Wt, W ? Kt.x : 0, W ? Kt.y : 0);
            }
          }
        }, ue = 0; ue < u.symbolInstances.length; ue++)
          te(ue);
        if (u.sortFeatures(this.transform.angle), this.retainedQueryData[u.bucketInstanceId] && (this.retainedQueryData[u.bucketInstanceId].featureSortOrder = u.featureSortOrder), u.hasTextData() && u.text.opacityVertexBuffer && u.text.opacityVertexBuffer.updateData(u.text.opacityVertexArray), u.hasIconData() && u.icon.opacityVertexBuffer && u.icon.opacityVertexBuffer.updateData(u.icon.opacityVertexArray), u.hasIconCollisionBoxData() && u.iconCollisionBox.collisionVertexBuffer && u.iconCollisionBox.collisionVertexBuffer.updateData(u.iconCollisionBox.collisionVertexArray), u.hasTextCollisionBoxData() && u.textCollisionBox.collisionVertexBuffer && u.textCollisionBox.collisionVertexBuffer.updateData(u.textCollisionBox.collisionVertexArray), u.bucketInstanceId in this.collisionCircleArrays) {
          var Y = this.collisionCircleArrays[u.bucketInstanceId];
          u.placementInvProjMatrix = Y.invProjMatrix, u.placementViewportMatrix = Y.viewportMatrix, u.collisionCircleArray = Y.circles, delete this.collisionCircleArrays[u.bucketInstanceId];
        }
      }, Ui.prototype.symbolFadeChange = function(u) {
        return this.fadeDuration === 0 ? 1 : (u - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
      }, Ui.prototype.zoomAdjustment = function(u) {
        return Math.max(0, (this.transform.zoom - u) / 1.5);
      }, Ui.prototype.hasTransitions = function(u) {
        return this.stale || u - this.lastPlacementChangeTime < this.fadeDuration;
      }, Ui.prototype.stillRecent = function(u, h) {
        var c = this.zoomAtLastRecencyCheck === h ? 1 - this.zoomAdjustment(h) : 1;
        return this.zoomAtLastRecencyCheck = h, this.commitTime + this.fadeDuration * c > u;
      }, Ui.prototype.setStale = function() {
        this.stale = !0;
      };
      var Vv = Math.pow(2, 25), Uv = Math.pow(2, 24), Hf = Math.pow(2, 17), jv = Math.pow(2, 16), lm = Math.pow(2, 9), Gv = Math.pow(2, 8), um = Math.pow(2, 1);
      function cm(u) {
        if (u.opacity === 0 && !u.placed)
          return 0;
        if (u.opacity === 1 && u.placed)
          return 4294967295;
        var h = u.placed ? 1 : 0, c = Math.floor(127 * u.opacity);
        return c * Vv + h * Uv + c * Hf + h * jv + c * lm + h * Gv + c * um + h;
      }
      var Kl = 0, Zf = function(u) {
        this._sortAcrossTiles = u.layout.get("symbol-z-order") !== "viewport-y" && u.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
      };
      Zf.prototype.continuePlacement = function(u, h, c, d, _) {
        for (var w = this._bucketParts; this._currentTileIndex < u.length; )
          if (h.getBucketParts(w, d, u[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, _())
            return !0;
        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, w.sort(function(E, O) {
          return E.sortKey - O.sortKey;
        })); this._currentPartIndex < w.length; )
          if (h.placeLayerBucketPart(w[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, _())
            return !0;
        return !1;
      };
      var Yu = function(u, h, c, d, _, w, E) {
        this.placement = new Ui(u, _, w, E), this._currentPlacementIndex = h.length - 1, this._forceFullPlacement = c, this._showCollisionBoxes = d, this._done = !1;
      };
      Yu.prototype.isDone = function() {
        return this._done;
      }, Yu.prototype.continuePlacement = function(u, h, c) {
        for (var d = this, _ = o.browser.now(), w = function() {
          var k = o.browser.now() - _;
          return !d._forceFullPlacement && k > 2;
        }; this._currentPlacementIndex >= 0; ) {
          var E = h[u[this._currentPlacementIndex]], O = this.placement.collisionIndex.transform.zoom;
          if (E.type === "symbol" && (!E.minzoom || E.minzoom <= O) && (!E.maxzoom || E.maxzoom > O)) {
            if (this._inProgressLayer || (this._inProgressLayer = new Zf(E)), this._inProgressLayer.continuePlacement(c[E.source], this.placement, this._showCollisionBoxes, E, w))
              return;
            delete this._inProgressLayer;
          }
          this._currentPlacementIndex--;
        }
        this._done = !0;
      }, Yu.prototype.commit = function(u) {
        return this.placement.commit(u), this.placement;
      };
      var hm = 512 / o.EXTENT / 2, lh = function(u, h, c) {
        this.tileID = u, this.indexedSymbolInstances = {}, this.bucketInstanceId = c;
        for (var d = 0; d < h.length; d++) {
          var _ = h.get(d), w = _.key;
          this.indexedSymbolInstances[w] || (this.indexedSymbolInstances[w] = []), this.indexedSymbolInstances[w].push({ crossTileID: _.crossTileID, coord: this.getScaledCoordinates(_, u) });
        }
      };
      lh.prototype.getScaledCoordinates = function(u, h) {
        var c = hm / Math.pow(2, h.canonical.z - this.tileID.canonical.z);
        return { x: Math.floor((h.canonical.x * o.EXTENT + u.anchorX) * c), y: Math.floor((h.canonical.y * o.EXTENT + u.anchorY) * c) };
      }, lh.prototype.findMatches = function(u, h, c) {
        for (var d = this.tileID.canonical.z < h.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - h.canonical.z), _ = 0; _ < u.length; _++) {
          var w = u.get(_);
          if (!w.crossTileID) {
            var E = this.indexedSymbolInstances[w.key];
            if (E)
              for (var O = this.getScaledCoordinates(w, h), k = 0, R = E; k < R.length; k += 1) {
                var $ = R[k];
                if (Math.abs($.coord.x - O.x) <= d && Math.abs($.coord.y - O.y) <= d && !c[$.crossTileID]) {
                  c[$.crossTileID] = !0, w.crossTileID = $.crossTileID;
                  break;
                }
              }
          }
        }
      };
      var $o = function() {
        this.maxCrossTileID = 0;
      };
      $o.prototype.generate = function() {
        return ++this.maxCrossTileID;
      };
      var ps = function() {
        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
      };
      ps.prototype.handleWrapJump = function(u) {
        var h = Math.round((u - this.lng) / 360);
        if (h !== 0)
          for (var c in this.indexes) {
            var d = this.indexes[c], _ = {};
            for (var w in d) {
              var E = d[w];
              E.tileID = E.tileID.unwrapTo(E.tileID.wrap + h), _[E.tileID.key] = E;
            }
            this.indexes[c] = _;
          }
        this.lng = u;
      }, ps.prototype.addBucket = function(u, h, c) {
        if (this.indexes[u.overscaledZ] && this.indexes[u.overscaledZ][u.key]) {
          if (this.indexes[u.overscaledZ][u.key].bucketInstanceId === h.bucketInstanceId)
            return !1;
          this.removeBucketCrossTileIDs(u.overscaledZ, this.indexes[u.overscaledZ][u.key]);
        }
        for (var d = 0; d < h.symbolInstances.length; d++)
          h.symbolInstances.get(d).crossTileID = 0;
        this.usedCrossTileIDs[u.overscaledZ] || (this.usedCrossTileIDs[u.overscaledZ] = {});
        var _ = this.usedCrossTileIDs[u.overscaledZ];
        for (var w in this.indexes) {
          var E = this.indexes[w];
          if (Number(w) > u.overscaledZ)
            for (var O in E) {
              var k = E[O];
              k.tileID.isChildOf(u) && k.findMatches(h.symbolInstances, u, _);
            }
          else {
            var R = E[u.scaledTo(Number(w)).key];
            R && R.findMatches(h.symbolInstances, u, _);
          }
        }
        for (var $ = 0; $ < h.symbolInstances.length; $++) {
          var W = h.symbolInstances.get($);
          W.crossTileID || (W.crossTileID = c.generate(), _[W.crossTileID] = !0);
        }
        return this.indexes[u.overscaledZ] === void 0 && (this.indexes[u.overscaledZ] = {}), this.indexes[u.overscaledZ][u.key] = new lh(u, h.symbolInstances, h.bucketInstanceId), !0;
      }, ps.prototype.removeBucketCrossTileIDs = function(u, h) {
        for (var c in h.indexedSymbolInstances)
          for (var d = 0, _ = h.indexedSymbolInstances[c]; d < _.length; d += 1)
            delete this.usedCrossTileIDs[u][_[d].crossTileID];
      }, ps.prototype.removeStaleBuckets = function(u) {
        var h = !1;
        for (var c in this.indexes) {
          var d = this.indexes[c];
          for (var _ in d)
            u[d[_].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, d[_]), delete d[_], h = !0);
        }
        return h;
      };
      var ds = function() {
        this.layerIndexes = {}, this.crossTileIDs = new $o(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
      };
      ds.prototype.addLayer = function(u, h, c) {
        var d = this.layerIndexes[u.id];
        d === void 0 && (d = this.layerIndexes[u.id] = new ps());
        var _ = !1, w = {};
        d.handleWrapJump(c);
        for (var E = 0, O = h; E < O.length; E += 1) {
          var k = O[E], R = k.getBucket(u);
          R && u.id === R.layerIds[0] && (R.bucketInstanceId || (R.bucketInstanceId = ++this.maxBucketInstanceId), d.addBucket(k.tileID, R, this.crossTileIDs) && (_ = !0), w[R.bucketInstanceId] = !0);
        }
        return d.removeStaleBuckets(w) && (_ = !0), _;
      }, ds.prototype.pruneUnusedLayers = function(u) {
        var h = {};
        for (var c in u.forEach(function(d) {
          h[d] = !0;
        }), this.layerIndexes)
          h[c] || delete this.layerIndexes[c];
      };
      var sl = function(u, h) {
        return o.emitValidationErrors(u, h && h.filter(function(c) {
          return c.identifier !== "source.canvas";
        }));
      }, ms = o.pick(De, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), ys = o.pick(De, ["setCenter", "setZoom", "setBearing", "setPitch"]), uh = function() {
        var u = {}, h = o.styleSpec.$version;
        for (var c in o.styleSpec.$root) {
          var d, _ = o.styleSpec.$root[c];
          _.required && (d = c === "version" ? h : _.type === "array" ? [] : {}) != null && (u[c] = d);
        }
        return u;
      }(), lo = function(u) {
        function h(c, d) {
          var _ = this;
          d === void 0 && (d = {}), u.call(this), this.map = c, this.dispatcher = new be(Le(), this), this.imageManager = new X(), this.imageManager.setEventedParent(this), this.glyphManager = new Se(c._requestManager, d.localIdeographFontFamily), this.lineAtlas = new at(256, 512), this.crossTileSymbolIndex = new ds(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", o.getReferrer());
          var w = this;
          this._rtlTextPluginCallback = h.registerForPluginStateChange(function(E) {
            w.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: E.pluginStatus, pluginURL: E.pluginURL }, function(O, k) {
              if (o.triggerPluginCompletionEvent(O), k && k.every(function($) {
                return $;
              }))
                for (var R in w.sourceCaches)
                  w.sourceCaches[R].reload();
            });
          }), this.on("data", function(E) {
            if (E.dataType === "source" && E.sourceDataType === "metadata") {
              var O = _.sourceCaches[E.sourceId];
              if (O) {
                var k = O.getSource();
                if (k && k.vectorLayerIds)
                  for (var R in _._layers) {
                    var $ = _._layers[R];
                    $.source === k.id && _._validateLayer($);
                  }
              }
            }
          });
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.loadURL = function(c, d) {
          var _ = this;
          d === void 0 && (d = {}), this.fire(new o.Event("dataloading", { dataType: "style" }));
          var w = typeof d.validate == "boolean" ? d.validate : !o.isMapboxURL(c);
          c = this.map._requestManager.normalizeStyleURL(c, d.accessToken);
          var E = this.map._requestManager.transformRequest(c, o.ResourceType.Style);
          this._request = o.getJSON(E, function(O, k) {
            _._request = null, O ? _.fire(new o.ErrorEvent(O)) : k && _._load(k, w);
          });
        }, h.prototype.loadJSON = function(c, d) {
          var _ = this;
          d === void 0 && (d = {}), this.fire(new o.Event("dataloading", { dataType: "style" })), this._request = o.browser.frame(function() {
            _._request = null, _._load(c, d.validate !== !1);
          });
        }, h.prototype.loadEmpty = function() {
          this.fire(new o.Event("dataloading", { dataType: "style" })), this._load(uh, !1);
        }, h.prototype._load = function(c, d) {
          if (!d || !sl(this, o.validateStyle(c))) {
            for (var _ in this._loaded = !0, this.stylesheet = c, c.sources)
              this.addSource(_, c.sources[_], { validate: !1 });
            c.sprite ? this._loadSprite(c.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(c.glyphs);
            var w = st(this.stylesheet.layers);
            this._order = w.map(function(R) {
              return R.id;
            }), this._layers = {}, this._serializedLayers = {};
            for (var E = 0, O = w; E < O.length; E += 1) {
              var k = O[E];
              (k = o.createStyleLayer(k)).setEventedParent(this, { layer: { id: k.id } }), this._layers[k.id] = k, this._serializedLayers[k.id] = k.serialize();
            }
            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new $e(this.stylesheet.light), this.fire(new o.Event("data", { dataType: "style" })), this.fire(new o.Event("style.load"));
          }
        }, h.prototype._loadSprite = function(c) {
          var d = this;
          this._spriteRequest = function(_, w, E) {
            var O, k, R, $ = o.browser.devicePixelRatio > 1 ? "@2x" : "", W = o.getJSON(w.transformRequest(w.normalizeSpriteURL(_, $, ".json"), o.ResourceType.SpriteJSON), function(te, ue) {
              W = null, R || (R = te, O = ue, ne());
            }), H = o.getImage(w.transformRequest(w.normalizeSpriteURL(_, $, ".png"), o.ResourceType.SpriteImage), function(te, ue) {
              H = null, R || (R = te, k = ue, ne());
            });
            function ne() {
              if (R)
                E(R);
              else if (O && k) {
                var te = o.browser.getImageData(k), ue = {};
                for (var Y in O) {
                  var le = O[Y], me = le.width, xe = le.height, Pe = le.x, Me = le.y, ke = le.sdf, je = le.pixelRatio, it = le.stretchX, tt = le.stretchY, gt = le.content, Nt = new o.RGBAImage({ width: me, height: xe });
                  o.RGBAImage.copy(te, Nt, { x: Pe, y: Me }, { x: 0, y: 0 }, { width: me, height: xe }), ue[Y] = { data: Nt, pixelRatio: je, sdf: ke, stretchX: it, stretchY: tt, content: gt };
                }
                E(null, ue);
              }
            }
            return { cancel: function() {
              W && (W.cancel(), W = null), H && (H.cancel(), H = null);
            } };
          }(c, this.map._requestManager, function(_, w) {
            if (d._spriteRequest = null, _)
              d.fire(new o.ErrorEvent(_));
            else if (w)
              for (var E in w)
                d.imageManager.addImage(E, w[E]);
            d.imageManager.setLoaded(!0), d._availableImages = d.imageManager.listImages(), d.dispatcher.broadcast("setImages", d._availableImages), d.fire(new o.Event("data", { dataType: "style" }));
          });
        }, h.prototype._validateLayer = function(c) {
          var d = this.sourceCaches[c.source];
          if (d) {
            var _ = c.sourceLayer;
            if (_) {
              var w = d.getSource();
              (w.type === "geojson" || w.vectorLayerIds && w.vectorLayerIds.indexOf(_) === -1) && this.fire(new o.ErrorEvent(new Error('Source layer "' + _ + '" does not exist on source "' + w.id + '" as specified by style layer "' + c.id + '"')));
            }
          }
        }, h.prototype.loaded = function() {
          if (!this._loaded || Object.keys(this._updatedSources).length)
            return !1;
          for (var c in this.sourceCaches)
            if (!this.sourceCaches[c].loaded())
              return !1;
          return !!this.imageManager.isLoaded();
        }, h.prototype._serializeLayers = function(c) {
          for (var d = [], _ = 0, w = c; _ < w.length; _ += 1) {
            var E = this._layers[w[_]];
            E.type !== "custom" && d.push(E.serialize());
          }
          return d;
        }, h.prototype.hasTransitions = function() {
          if (this.light && this.light.hasTransition())
            return !0;
          for (var c in this.sourceCaches)
            if (this.sourceCaches[c].hasTransition())
              return !0;
          for (var d in this._layers)
            if (this._layers[d].hasTransition())
              return !0;
          return !1;
        }, h.prototype._checkLoaded = function() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }, h.prototype.update = function(c) {
          if (this._loaded) {
            var d = this._changed;
            if (this._changed) {
              var _ = Object.keys(this._updatedLayers), w = Object.keys(this._removedLayers);
              for (var E in (_.length || w.length) && this._updateWorkerLayers(_, w), this._updatedSources) {
                var O = this._updatedSources[E];
                O === "reload" ? this._reloadSource(E) : O === "clear" && this._clearSource(E);
              }
              for (var k in this._updateTilesForChangedImages(), this._updatedPaintProps)
                this._layers[k].updateTransitions(c);
              this.light.updateTransitions(c), this._resetUpdates();
            }
            var R = {};
            for (var $ in this.sourceCaches) {
              var W = this.sourceCaches[$];
              R[$] = W.used, W.used = !1;
            }
            for (var H = 0, ne = this._order; H < ne.length; H += 1) {
              var te = this._layers[ne[H]];
              te.recalculate(c, this._availableImages), !te.isHidden(c.zoom) && te.source && (this.sourceCaches[te.source].used = !0);
            }
            for (var ue in R) {
              var Y = this.sourceCaches[ue];
              R[ue] !== Y.used && Y.fire(new o.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: ue }));
            }
            this.light.recalculate(c), this.z = c.zoom, d && this.fire(new o.Event("data", { dataType: "style" }));
          }
        }, h.prototype._updateTilesForChangedImages = function() {
          var c = Object.keys(this._changedImages);
          if (c.length) {
            for (var d in this.sourceCaches)
              this.sourceCaches[d].reloadTilesForDependencies(["icons", "patterns"], c);
            this._changedImages = {};
          }
        }, h.prototype._updateWorkerLayers = function(c, d) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(c), removedIds: d });
        }, h.prototype._resetUpdates = function() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
        }, h.prototype.setState = function(c) {
          var d = this;
          if (this._checkLoaded(), sl(this, o.validateStyle(c)))
            return !1;
          (c = o.clone$1(c)).layers = st(c.layers);
          var _ = function(E, O) {
            if (!E)
              return [{ command: De.setStyle, args: [O] }];
            var k = [];
            try {
              if (!o.deepEqual(E.version, O.version))
                return [{ command: De.setStyle, args: [O] }];
              o.deepEqual(E.center, O.center) || k.push({ command: De.setCenter, args: [O.center] }), o.deepEqual(E.zoom, O.zoom) || k.push({ command: De.setZoom, args: [O.zoom] }), o.deepEqual(E.bearing, O.bearing) || k.push({ command: De.setBearing, args: [O.bearing] }), o.deepEqual(E.pitch, O.pitch) || k.push({ command: De.setPitch, args: [O.pitch] }), o.deepEqual(E.sprite, O.sprite) || k.push({ command: De.setSprite, args: [O.sprite] }), o.deepEqual(E.glyphs, O.glyphs) || k.push({ command: De.setGlyphs, args: [O.glyphs] }), o.deepEqual(E.transition, O.transition) || k.push({ command: De.setTransition, args: [O.transition] }), o.deepEqual(E.light, O.light) || k.push({ command: De.setLight, args: [O.light] });
              var R = {}, $ = [];
              (function(H, ne, te, ue) {
                var Y;
                for (Y in ne = ne || {}, H = H || {})
                  H.hasOwnProperty(Y) && (ne.hasOwnProperty(Y) || Ee(Y, te, ue));
                for (Y in ne)
                  ne.hasOwnProperty(Y) && (H.hasOwnProperty(Y) ? o.deepEqual(H[Y], ne[Y]) || (H[Y].type === "geojson" && ne[Y].type === "geojson" && jt(H, ne, Y) ? te.push({ command: De.setGeoJSONSourceData, args: [Y, ne[Y].data] }) : He(Y, ne, te, ue)) : fe(Y, ne, te));
              })(E.sources, O.sources, $, R);
              var W = [];
              E.layers && E.layers.forEach(function(H) {
                R[H.source] ? k.push({ command: De.removeLayer, args: [H.id] }) : W.push(H);
              }), k = k.concat($), function(H, ne, te) {
                ne = ne || [];
                var ue, Y, le, me, xe, Pe, Me, ke = (H = H || []).map(Jt), je = ne.map(Jt), it = H.reduce(Zt, {}), tt = ne.reduce(Zt, {}), gt = ke.slice(), Nt = /* @__PURE__ */ Object.create(null);
                for (ue = 0, Y = 0; ue < ke.length; ue++)
                  tt.hasOwnProperty(le = ke[ue]) ? Y++ : (te.push({ command: De.removeLayer, args: [le] }), gt.splice(gt.indexOf(le, Y), 1));
                for (ue = 0, Y = 0; ue < je.length; ue++)
                  gt[gt.length - 1 - ue] !== (le = je[je.length - 1 - ue]) && (it.hasOwnProperty(le) ? (te.push({ command: De.removeLayer, args: [le] }), gt.splice(gt.lastIndexOf(le, gt.length - Y), 1)) : Y++, te.push({ command: De.addLayer, args: [tt[le], Pe = gt[gt.length - ue]] }), gt.splice(gt.length - ue, 0, le), Nt[le] = !0);
                for (ue = 0; ue < je.length; ue++)
                  if (me = it[le = je[ue]], xe = tt[le], !Nt[le] && !o.deepEqual(me, xe))
                    if (o.deepEqual(me.source, xe.source) && o.deepEqual(me["source-layer"], xe["source-layer"]) && o.deepEqual(me.type, xe.type)) {
                      for (Me in qt(me.layout, xe.layout, te, le, null, De.setLayoutProperty), qt(me.paint, xe.paint, te, le, null, De.setPaintProperty), o.deepEqual(me.filter, xe.filter) || te.push({ command: De.setFilter, args: [le, xe.filter] }), o.deepEqual(me.minzoom, xe.minzoom) && o.deepEqual(me.maxzoom, xe.maxzoom) || te.push({ command: De.setLayerZoomRange, args: [le, xe.minzoom, xe.maxzoom] }), me)
                        me.hasOwnProperty(Me) && Me !== "layout" && Me !== "paint" && Me !== "filter" && Me !== "metadata" && Me !== "minzoom" && Me !== "maxzoom" && (Me.indexOf("paint.") === 0 ? qt(me[Me], xe[Me], te, le, Me.slice(6), De.setPaintProperty) : o.deepEqual(me[Me], xe[Me]) || te.push({ command: De.setLayerProperty, args: [le, Me, xe[Me]] }));
                      for (Me in xe)
                        xe.hasOwnProperty(Me) && !me.hasOwnProperty(Me) && Me !== "layout" && Me !== "paint" && Me !== "filter" && Me !== "metadata" && Me !== "minzoom" && Me !== "maxzoom" && (Me.indexOf("paint.") === 0 ? qt(me[Me], xe[Me], te, le, Me.slice(6), De.setPaintProperty) : o.deepEqual(me[Me], xe[Me]) || te.push({ command: De.setLayerProperty, args: [le, Me, xe[Me]] }));
                    } else
                      te.push({ command: De.removeLayer, args: [le] }), Pe = gt[gt.lastIndexOf(le) + 1], te.push({ command: De.addLayer, args: [xe, Pe] });
              }(W, O.layers, k);
            } catch (H) {
              console.warn("Unable to compute style diff:", H), k = [{ command: De.setStyle, args: [O] }];
            }
            return k;
          }(this.serialize(), c).filter(function(E) {
            return !(E.command in ys);
          });
          if (_.length === 0)
            return !1;
          var w = _.filter(function(E) {
            return !(E.command in ms);
          });
          if (w.length > 0)
            throw new Error("Unimplemented: " + w.map(function(E) {
              return E.command;
            }).join(", ") + ".");
          return _.forEach(function(E) {
            E.command !== "setTransition" && d[E.command].apply(d, E.args);
          }), this.stylesheet = c, !0;
        }, h.prototype.addImage = function(c, d) {
          if (this.getImage(c))
            return this.fire(new o.ErrorEvent(new Error("An image with this name already exists.")));
          this.imageManager.addImage(c, d), this._afterImageUpdated(c);
        }, h.prototype.updateImage = function(c, d) {
          this.imageManager.updateImage(c, d);
        }, h.prototype.getImage = function(c) {
          return this.imageManager.getImage(c);
        }, h.prototype.removeImage = function(c) {
          if (!this.getImage(c))
            return this.fire(new o.ErrorEvent(new Error("No image with this name exists.")));
          this.imageManager.removeImage(c), this._afterImageUpdated(c);
        }, h.prototype._afterImageUpdated = function(c) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[c] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new o.Event("data", { dataType: "style" }));
        }, h.prototype.listImages = function() {
          return this._checkLoaded(), this.imageManager.listImages();
        }, h.prototype.addSource = function(c, d, _) {
          var w = this;
          if (_ === void 0 && (_ = {}), this._checkLoaded(), this.sourceCaches[c] !== void 0)
            throw new Error("There is already a source with this ID");
          if (!d.type)
            throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(d).join(", ") + ".");
          if (!(["vector", "raster", "geojson", "video", "image"].indexOf(d.type) >= 0 && this._validate(o.validateStyle.source, "sources." + c, d, null, _))) {
            this.map && this.map._collectResourceTiming && (d.collectResourceTiming = !0);
            var E = this.sourceCaches[c] = new ie(c, d, this.dispatcher);
            E.style = this, E.setEventedParent(this, function() {
              return { isSourceLoaded: w.loaded(), source: E.serialize(), sourceId: c };
            }), E.onAdd(this.map), this._changed = !0;
          }
        }, h.prototype.removeSource = function(c) {
          if (this._checkLoaded(), this.sourceCaches[c] === void 0)
            throw new Error("There is no source with this ID");
          for (var d in this._layers)
            if (this._layers[d].source === c)
              return this.fire(new o.ErrorEvent(new Error('Source "' + c + '" cannot be removed while layer "' + d + '" is using it.')));
          var _ = this.sourceCaches[c];
          delete this.sourceCaches[c], delete this._updatedSources[c], _.fire(new o.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: c })), _.setEventedParent(null), _.clearTiles(), _.onRemove && _.onRemove(this.map), this._changed = !0;
        }, h.prototype.setGeoJSONSourceData = function(c, d) {
          this._checkLoaded(), this.sourceCaches[c].getSource().setData(d), this._changed = !0;
        }, h.prototype.getSource = function(c) {
          return this.sourceCaches[c] && this.sourceCaches[c].getSource();
        }, h.prototype.addLayer = function(c, d, _) {
          _ === void 0 && (_ = {}), this._checkLoaded();
          var w = c.id;
          if (this.getLayer(w))
            this.fire(new o.ErrorEvent(new Error('Layer with id "' + w + '" already exists on this map')));
          else {
            var E;
            if (c.type === "custom") {
              if (sl(this, o.validateCustomStyleLayer(c)))
                return;
              E = o.createStyleLayer(c);
            } else {
              if (typeof c.source == "object" && (this.addSource(w, c.source), c = o.clone$1(c), c = o.extend(c, { source: w })), this._validate(o.validateStyle.layer, "layers." + w, c, { arrayIndex: -1 }, _))
                return;
              E = o.createStyleLayer(c), this._validateLayer(E), E.setEventedParent(this, { layer: { id: w } }), this._serializedLayers[E.id] = E.serialize();
            }
            var O = d ? this._order.indexOf(d) : this._order.length;
            if (d && O === -1)
              this.fire(new o.ErrorEvent(new Error('Layer with id "' + d + '" does not exist on this map.')));
            else {
              if (this._order.splice(O, 0, w), this._layerOrderChanged = !0, this._layers[w] = E, this._removedLayers[w] && E.source && E.type !== "custom") {
                var k = this._removedLayers[w];
                delete this._removedLayers[w], k.type !== E.type ? this._updatedSources[E.source] = "clear" : (this._updatedSources[E.source] = "reload", this.sourceCaches[E.source].pause());
              }
              this._updateLayer(E), E.onAdd && E.onAdd(this.map);
            }
          }
        }, h.prototype.moveLayer = function(c, d) {
          if (this._checkLoaded(), this._changed = !0, this._layers[c]) {
            if (c !== d) {
              var _ = this._order.indexOf(c);
              this._order.splice(_, 1);
              var w = d ? this._order.indexOf(d) : this._order.length;
              d && w === -1 ? this.fire(new o.ErrorEvent(new Error('Layer with id "' + d + '" does not exist on this map.'))) : (this._order.splice(w, 0, c), this._layerOrderChanged = !0);
            }
          } else
            this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be moved.")));
        }, h.prototype.removeLayer = function(c) {
          this._checkLoaded();
          var d = this._layers[c];
          if (d) {
            d.setEventedParent(null);
            var _ = this._order.indexOf(c);
            this._order.splice(_, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[c] = d, delete this._layers[c], delete this._serializedLayers[c], delete this._updatedLayers[c], delete this._updatedPaintProps[c], d.onRemove && d.onRemove(this.map);
          } else
            this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be removed.")));
        }, h.prototype.getLayer = function(c) {
          return this._layers[c];
        }, h.prototype.hasLayer = function(c) {
          return c in this._layers;
        }, h.prototype.setLayerZoomRange = function(c, d, _) {
          this._checkLoaded();
          var w = this.getLayer(c);
          w ? w.minzoom === d && w.maxzoom === _ || (d != null && (w.minzoom = d), _ != null && (w.maxzoom = _), this._updateLayer(w)) : this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot have zoom extent.")));
        }, h.prototype.setFilter = function(c, d, _) {
          _ === void 0 && (_ = {}), this._checkLoaded();
          var w = this.getLayer(c);
          if (w) {
            if (!o.deepEqual(w.filter, d))
              return d == null ? (w.filter = void 0, void this._updateLayer(w)) : void (this._validate(o.validateStyle.filter, "layers." + w.id + ".filter", d, null, _) || (w.filter = o.clone$1(d), this._updateLayer(w)));
          } else
            this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be filtered.")));
        }, h.prototype.getFilter = function(c) {
          return o.clone$1(this.getLayer(c).filter);
        }, h.prototype.setLayoutProperty = function(c, d, _, w) {
          w === void 0 && (w = {}), this._checkLoaded();
          var E = this.getLayer(c);
          E ? o.deepEqual(E.getLayoutProperty(d), _) || (E.setLayoutProperty(d, _, w), this._updateLayer(E)) : this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be styled.")));
        }, h.prototype.getLayoutProperty = function(c, d) {
          var _ = this.getLayer(c);
          if (_)
            return _.getLayoutProperty(d);
          this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style.")));
        }, h.prototype.setPaintProperty = function(c, d, _, w) {
          w === void 0 && (w = {}), this._checkLoaded();
          var E = this.getLayer(c);
          E ? o.deepEqual(E.getPaintProperty(d), _) || (E.setPaintProperty(d, _, w) && this._updateLayer(E), this._changed = !0, this._updatedPaintProps[c] = !0) : this.fire(new o.ErrorEvent(new Error("The layer '" + c + "' does not exist in the map's style and cannot be styled.")));
        }, h.prototype.getPaintProperty = function(c, d) {
          return this.getLayer(c).getPaintProperty(d);
        }, h.prototype.setFeatureState = function(c, d) {
          this._checkLoaded();
          var _ = c.source, w = c.sourceLayer, E = this.sourceCaches[_];
          if (E !== void 0) {
            var O = E.getSource().type;
            O === "geojson" && w ? this.fire(new o.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : O !== "vector" || w ? (c.id === void 0 && this.fire(new o.ErrorEvent(new Error("The feature id parameter must be provided."))), E.setFeatureState(w, c.id, d)) : this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new o.ErrorEvent(new Error("The source '" + _ + "' does not exist in the map's style.")));
        }, h.prototype.removeFeatureState = function(c, d) {
          this._checkLoaded();
          var _ = c.source, w = this.sourceCaches[_];
          if (w !== void 0) {
            var E = w.getSource().type, O = E === "vector" ? c.sourceLayer : void 0;
            E !== "vector" || O ? d && typeof c.id != "string" && typeof c.id != "number" ? this.fire(new o.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : w.removeFeatureState(O, c.id, d) : this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new o.ErrorEvent(new Error("The source '" + _ + "' does not exist in the map's style.")));
        }, h.prototype.getFeatureState = function(c) {
          this._checkLoaded();
          var d = c.source, _ = c.sourceLayer, w = this.sourceCaches[d];
          if (w !== void 0) {
            if (w.getSource().type !== "vector" || _)
              return c.id === void 0 && this.fire(new o.ErrorEvent(new Error("The feature id parameter must be provided."))), w.getFeatureState(_, c.id);
            this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new o.ErrorEvent(new Error("The source '" + d + "' does not exist in the map's style.")));
        }, h.prototype.getTransition = function() {
          return o.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }, h.prototype.serialize = function() {
          return o.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: o.mapObject(this.sourceCaches, function(c) {
            return c.serialize();
          }), layers: this._serializeLayers(this._order) }, function(c) {
            return c !== void 0;
          });
        }, h.prototype._updateLayer = function(c) {
          this._updatedLayers[c.id] = !0, c.source && !this._updatedSources[c.source] && this.sourceCaches[c.source].getSource().type !== "raster" && (this._updatedSources[c.source] = "reload", this.sourceCaches[c.source].pause()), this._changed = !0;
        }, h.prototype._flattenAndSortRenderedFeatures = function(c) {
          for (var d = this, _ = function(it) {
            return d._layers[it].type === "fill-extrusion";
          }, w = {}, E = [], O = this._order.length - 1; O >= 0; O--) {
            var k = this._order[O];
            if (_(k)) {
              w[k] = O;
              for (var R = 0, $ = c; R < $.length; R += 1) {
                var W = $[R][k];
                if (W)
                  for (var H = 0, ne = W; H < ne.length; H += 1)
                    E.push(ne[H]);
              }
            }
          }
          E.sort(function(it, tt) {
            return tt.intersectionZ - it.intersectionZ;
          });
          for (var te = [], ue = this._order.length - 1; ue >= 0; ue--) {
            var Y = this._order[ue];
            if (_(Y))
              for (var le = E.length - 1; le >= 0; le--) {
                var me = E[le].feature;
                if (w[me.layer.id] < ue)
                  break;
                te.push(me), E.pop();
              }
            else
              for (var xe = 0, Pe = c; xe < Pe.length; xe += 1) {
                var Me = Pe[xe][Y];
                if (Me)
                  for (var ke = 0, je = Me; ke < je.length; ke += 1)
                    te.push(je[ke].feature);
              }
          }
          return te;
        }, h.prototype.queryRenderedFeatures = function(c, d, _) {
          d && d.filter && this._validate(o.validateStyle.filter, "queryRenderedFeatures.filter", d.filter, null, d);
          var w = {};
          if (d && d.layers) {
            if (!Array.isArray(d.layers))
              return this.fire(new o.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
            for (var E = 0, O = d.layers; E < O.length; E += 1) {
              var k = O[E], R = this._layers[k];
              if (!R)
                return this.fire(new o.ErrorEvent(new Error("The layer '" + k + "' does not exist in the map's style and cannot be queried for features."))), [];
              w[R.source] = !0;
            }
          }
          var $ = [];
          for (var W in d.availableImages = this._availableImages, this.sourceCaches)
            d.layers && !w[W] || $.push(Ar(this.sourceCaches[W], this._layers, this._serializedLayers, c, d, _));
          return this.placement && $.push(function(H, ne, te, ue, Y, le, me) {
            for (var xe = {}, Pe = le.queryRenderedSymbols(ue), Me = [], ke = 0, je = Object.keys(Pe).map(Number); ke < je.length; ke += 1)
              Me.push(me[je[ke]]);
            Me.sort(Vn);
            for (var it = function() {
              var Ft = gt[tt], Ir = Ft.featureIndex.lookupSymbolFeatures(Pe[Ft.bucketInstanceId], ne, Ft.bucketIndex, Ft.sourceLayerIndex, Y.filter, Y.layers, Y.availableImages, H);
              for (var xt in Ir) {
                var Yt = xe[xt] = xe[xt] || [], or = Ir[xt];
                or.sort(function(nr, Wt) {
                  var Gt = Ft.featureSortOrder;
                  if (Gt) {
                    var li = Gt.indexOf(nr.featureIndex);
                    return Gt.indexOf(Wt.featureIndex) - li;
                  }
                  return Wt.featureIndex - nr.featureIndex;
                });
                for (var Kt = 0, Xt = or; Kt < Xt.length; Kt += 1)
                  Yt.push(Xt[Kt]);
              }
            }, tt = 0, gt = Me; tt < gt.length; tt += 1)
              it();
            var Nt = function(Ft) {
              xe[Ft].forEach(function(Ir) {
                var xt = Ir.feature, Yt = te[H[Ft].source].getFeatureState(xt.layer["source-layer"], xt.id);
                xt.source = xt.layer.source, xt.layer["source-layer"] && (xt.sourceLayer = xt.layer["source-layer"]), xt.state = Yt;
              });
            };
            for (var Bt in xe)
              Nt(Bt);
            return xe;
          }(this._layers, this._serializedLayers, this.sourceCaches, c, d, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures($);
        }, h.prototype.querySourceFeatures = function(c, d) {
          d && d.filter && this._validate(o.validateStyle.filter, "querySourceFeatures.filter", d.filter, null, d);
          var _ = this.sourceCaches[c];
          return _ ? function(w, E) {
            for (var O = w.getRenderableIds().map(function(ne) {
              return w.getTileByID(ne);
            }), k = [], R = {}, $ = 0; $ < O.length; $++) {
              var W = O[$], H = W.tileID.canonical.key;
              R[H] || (R[H] = !0, W.querySourceFeatures(k, E));
            }
            return k;
          }(_, d) : [];
        }, h.prototype.addSourceType = function(c, d, _) {
          return h.getSourceType(c) ? _(new Error('A source type called "' + c + '" already exists.')) : (h.setSourceType(c, d), d.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: c, url: d.workerSourceURL }, _) : _(null, null));
        }, h.prototype.getLight = function() {
          return this.light.getLight();
        }, h.prototype.setLight = function(c, d) {
          d === void 0 && (d = {}), this._checkLoaded();
          var _ = this.light.getLight(), w = !1;
          for (var E in c)
            if (!o.deepEqual(c[E], _[E])) {
              w = !0;
              break;
            }
          if (w) {
            var O = { now: o.browser.now(), transition: o.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(c, d), this.light.updateTransitions(O);
          }
        }, h.prototype._validate = function(c, d, _, w, E) {
          return E === void 0 && (E = {}), (!E || E.validate !== !1) && sl(this, c.call(o.validateStyle, o.extend({ key: d, style: this.serialize(), value: _, styleSpec: o.styleSpec }, w)));
        }, h.prototype._remove = function() {
          for (var c in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), o.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers)
            this._layers[c].setEventedParent(null);
          for (var d in this.sourceCaches)
            this.sourceCaches[d].clearTiles(), this.sourceCaches[d].setEventedParent(null);
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
        }, h.prototype._clearSource = function(c) {
          this.sourceCaches[c].clearTiles();
        }, h.prototype._reloadSource = function(c) {
          this.sourceCaches[c].resume(), this.sourceCaches[c].reload();
        }, h.prototype._updateSources = function(c) {
          for (var d in this.sourceCaches)
            this.sourceCaches[d].update(c);
        }, h.prototype._generateCollisionBoxes = function() {
          for (var c in this.sourceCaches)
            this._reloadSource(c);
        }, h.prototype._updatePlacement = function(c, d, _, w, E) {
          E === void 0 && (E = !1);
          for (var O = !1, k = !1, R = {}, $ = 0, W = this._order; $ < W.length; $ += 1) {
            var H = this._layers[W[$]];
            if (H.type === "symbol") {
              if (!R[H.source]) {
                var ne = this.sourceCaches[H.source];
                R[H.source] = ne.getRenderableIds(!0).map(function(me) {
                  return ne.getTileByID(me);
                }).sort(function(me, xe) {
                  return xe.tileID.overscaledZ - me.tileID.overscaledZ || (me.tileID.isLessThan(xe.tileID) ? -1 : 1);
                });
              }
              var te = this.crossTileSymbolIndex.addLayer(H, R[H.source], c.center.lng);
              O = O || te;
            }
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((E = E || this._layerOrderChanged || _ === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(o.browser.now(), c.zoom)) && (this.pauseablePlacement = new Yu(c, this._order, E, d, _, w, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, R), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(o.browser.now()), k = !0), O && this.pauseablePlacement.placement.setStale()), k || O)
            for (var ue = 0, Y = this._order; ue < Y.length; ue += 1) {
              var le = this._layers[Y[ue]];
              le.type === "symbol" && this.placement.updateLayerOpacities(le, R[le.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(o.browser.now());
        }, h.prototype._releaseSymbolFadeTiles = function() {
          for (var c in this.sourceCaches)
            this.sourceCaches[c].releaseSymbolFadeTiles();
        }, h.prototype.getImages = function(c, d, _) {
          this.imageManager.getImages(d.icons, _), this._updateTilesForChangedImages();
          var w = this.sourceCaches[d.source];
          w && w.setDependencies(d.tileID.key, d.type, d.icons);
        }, h.prototype.getGlyphs = function(c, d, _) {
          this.glyphManager.getGlyphs(d.stacks, _);
        }, h.prototype.getResource = function(c, d, _) {
          return o.makeRequest(d, _);
        }, h;
      }(o.Evented);
      lo.getSourceType = function(u) {
        return Fi[u];
      }, lo.setSourceType = function(u, h) {
        Fi[u] = h;
      }, lo.registerForPluginStateChange = o.registerForPluginStateChange;
      var jn = o.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), Yl = Zr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}`), fm = Zr(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), $v = Zr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), qv = Zr(`varying vec3 v_data;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), Xf = Zr("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Kf = Zr(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`), Yf = Zr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), Jf = Zr("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), pm = Zr("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), dm = Zr("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"), Wv = Zr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), Ju = Zr(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), Qu = Zr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), mm = Zr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), Ti = Zr(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), Qf = Zr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), gs = Zr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), vs = Zr(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), ll = Zr(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`), ul = Zr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`), _s = Zr(`uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), cl = Zr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), hl = Zr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), xs = Zr(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}`), ym = Zr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), gm = Zr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`);
      function Zr(u, h) {
        var c = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, d = h.match(/attribute ([\w]+) ([\w]+)/g), _ = u.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), E = w ? w.concat(_) : _, O = {};
        return { fragmentSource: u = u.replace(c, function(k, R, $, W, H) {
          return O[H] = !0, R === "define" ? `
#ifndef HAS_UNIFORM_u_` + H + `
varying ` + $ + " " + W + " " + H + `;
#else
uniform ` + $ + " " + W + " u_" + H + `;
#endif
` : `
#ifdef HAS_UNIFORM_u_` + H + `
    ` + $ + " " + W + " " + H + " = u_" + H + `;
#endif
`;
        }), vertexSource: h = h.replace(c, function(k, R, $, W, H) {
          var ne = W === "float" ? "vec2" : "vec4", te = H.match(/color/) ? "color" : ne;
          return O[H] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_` + H + `
uniform lowp float u_` + H + `_t;
attribute ` + $ + " " + ne + " a_" + H + `;
varying ` + $ + " " + W + " " + H + `;
#else
uniform ` + $ + " " + W + " u_" + H + `;
#endif
` : te === "vec4" ? `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + H + " = a_" + H + `;
#else
    ` + $ + " " + W + " " + H + " = u_" + H + `;
#endif
` : `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + H + " = unpack_mix_" + te + "(a_" + H + ", u_" + H + `_t);
#else
    ` + $ + " " + W + " " + H + " = u_" + H + `;
#endif
` : R === "define" ? `
#ifndef HAS_UNIFORM_u_` + H + `
uniform lowp float u_` + H + `_t;
attribute ` + $ + " " + ne + " a_" + H + `;
#else
uniform ` + $ + " " + W + " u_" + H + `;
#endif
` : te === "vec4" ? `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + $ + " " + W + " " + H + " = a_" + H + `;
#else
    ` + $ + " " + W + " " + H + " = u_" + H + `;
#endif
` : `
#ifndef HAS_UNIFORM_u_` + H + `
    ` + $ + " " + W + " " + H + " = unpack_mix_" + te + "(a_" + H + ", u_" + H + `_t);
#else
    ` + $ + " " + W + " " + H + " = u_" + H + `;
#endif
`;
        }), staticAttributes: d, staticUniforms: E };
      }
      var Hv = Object.freeze({ __proto__: null, prelude: Yl, background: fm, backgroundPattern: $v, circle: qv, clippingMask: Xf, heatmap: Kf, heatmapTexture: Yf, collisionBox: Jf, collisionCircle: pm, debug: dm, fill: Wv, fillOutline: Ju, fillOutlinePattern: Qu, fillPattern: mm, fillExtrusion: Ti, fillExtrusionPattern: Qf, hillshadePrepare: gs, hillshade: vs, line: ll, lineGradient: ul, linePattern: _s, lineSDF: cl, raster: hl, symbolIcon: xs, symbolSDF: ym, symbolTextAndIcon: gm }), ch = function() {
        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
      };
      function vm(u) {
        for (var h = [], c = 0; c < u.length; c++)
          if (u[c] !== null) {
            var d = u[c].split(" ");
            h.push(d.pop());
          }
        return h;
      }
      ch.prototype.bind = function(u, h, c, d, _, w, E, O) {
        this.context = u;
        for (var k = this.boundPaintVertexBuffers.length !== d.length, R = 0; !k && R < d.length; R++)
          this.boundPaintVertexBuffers[R] !== d[R] && (k = !0);
        u.extVertexArrayObject && this.vao && this.boundProgram === h && this.boundLayoutVertexBuffer === c && !k && this.boundIndexBuffer === _ && this.boundVertexOffset === w && this.boundDynamicVertexBuffer === E && this.boundDynamicVertexBuffer2 === O ? (u.bindVertexArrayOES.set(this.vao), E && E.bind(), _ && _.dynamicDraw && _.bind(), O && O.bind()) : this.freshBind(h, c, d, _, w, E, O);
      }, ch.prototype.freshBind = function(u, h, c, d, _, w, E) {
        var O, k = u.numAttributes, R = this.context, $ = R.gl;
        if (R.extVertexArrayObject)
          this.vao && this.destroy(), this.vao = R.extVertexArrayObject.createVertexArrayOES(), R.bindVertexArrayOES.set(this.vao), O = 0, this.boundProgram = u, this.boundLayoutVertexBuffer = h, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = d, this.boundVertexOffset = _, this.boundDynamicVertexBuffer = w, this.boundDynamicVertexBuffer2 = E;
        else {
          O = R.currentNumAttributes || 0;
          for (var W = k; W < O; W++)
            $.disableVertexAttribArray(W);
        }
        h.enableAttributes($, u);
        for (var H = 0, ne = c; H < ne.length; H += 1)
          ne[H].enableAttributes($, u);
        w && w.enableAttributes($, u), E && E.enableAttributes($, u), h.bind(), h.setVertexAttribPointers($, u, _);
        for (var te = 0, ue = c; te < ue.length; te += 1) {
          var Y = ue[te];
          Y.bind(), Y.setVertexAttribPointers($, u, _);
        }
        w && (w.bind(), w.setVertexAttribPointers($, u, _)), d && d.bind(), E && (E.bind(), E.setVertexAttribPointers($, u, _)), R.currentNumAttributes = k;
      }, ch.prototype.destroy = function() {
        this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
      };
      var _m = function(u, h, c, d, _, w) {
        var E = u.gl;
        this.program = E.createProgram();
        for (var O = vm(c.staticAttributes), k = d ? d.getBinderAttributes() : [], R = O.concat(k), $ = c.staticUniforms ? vm(c.staticUniforms) : [], W = d ? d.getBinderUniforms() : [], H = [], ne = 0, te = $.concat(W); ne < te.length; ne += 1) {
          var ue = te[ne];
          H.indexOf(ue) < 0 && H.push(ue);
        }
        var Y = d ? d.defines() : [];
        w && Y.push("#define OVERDRAW_INSPECTOR;");
        var le = Y.concat(Yl.fragmentSource, c.fragmentSource).join(`
`), me = Y.concat(Yl.vertexSource, c.vertexSource).join(`
`), xe = E.createShader(E.FRAGMENT_SHADER);
        if (E.isContextLost())
          this.failedToCreate = !0;
        else {
          E.shaderSource(xe, le), E.compileShader(xe), E.attachShader(this.program, xe);
          var Pe = E.createShader(E.VERTEX_SHADER);
          if (E.isContextLost())
            this.failedToCreate = !0;
          else {
            E.shaderSource(Pe, me), E.compileShader(Pe), E.attachShader(this.program, Pe), this.attributes = {};
            var Me = {};
            this.numAttributes = R.length;
            for (var ke = 0; ke < this.numAttributes; ke++)
              R[ke] && (E.bindAttribLocation(this.program, ke, R[ke]), this.attributes[R[ke]] = ke);
            E.linkProgram(this.program), E.deleteShader(Pe), E.deleteShader(xe);
            for (var je = 0; je < H.length; je++) {
              var it = H[je];
              if (it && !Me[it]) {
                var tt = E.getUniformLocation(this.program, it);
                tt && (Me[it] = tt);
              }
            }
            this.fixedUniforms = _(u, Me), this.binderUniforms = d ? d.getUniforms(u, Me) : [];
          }
        }
      };
      function xm(u, h, c) {
        var d = 1 / mn(c, 1, h.transform.tileZoom), _ = Math.pow(2, c.tileID.overscaledZ), w = c.tileSize * Math.pow(2, h.transform.tileZoom) / _, E = w * (c.tileID.canonical.x + c.tileID.wrap * _), O = w * c.tileID.canonical.y;
        return { u_image: 0, u_texsize: c.imageAtlasTexture.size, u_scale: [d, u.fromScale, u.toScale], u_fade: u.t, u_pixel_coord_upper: [E >> 16, O >> 16], u_pixel_coord_lower: [65535 & E, 65535 & O] };
      }
      _m.prototype.draw = function(u, h, c, d, _, w, E, O, k, R, $, W, H, ne, te, ue) {
        var Y, le = u.gl;
        if (!this.failedToCreate) {
          for (var me in u.program.set(this.program), u.setDepthMode(c), u.setStencilMode(d), u.setColorMode(_), u.setCullFace(w), this.fixedUniforms)
            this.fixedUniforms[me].set(E[me]);
          ne && ne.setUniforms(u, this.binderUniforms, W, { zoom: H });
          for (var xe = (Y = {}, Y[le.LINES] = 2, Y[le.TRIANGLES] = 3, Y[le.LINE_STRIP] = 1, Y)[h], Pe = 0, Me = $.get(); Pe < Me.length; Pe += 1) {
            var ke = Me[Pe], je = ke.vaos || (ke.vaos = {});
            (je[O] || (je[O] = new ch())).bind(u, this, k, ne ? ne.getPaintVertexBuffers() : [], R, ke.vertexOffset, te, ue), le.drawElements(h, ke.primitiveLength * xe, le.UNSIGNED_SHORT, ke.primitiveOffset * xe * 2);
          }
        }
      };
      var bm = function(u, h, c, d) {
        var _ = h.style.light, w = _.properties.get("position"), E = [w.x, w.y, w.z], O = o.create$1();
        _.properties.get("anchor") === "viewport" && o.fromRotation(O, -h.transform.angle), o.transformMat3(E, E, O);
        var k = _.properties.get("color");
        return { u_matrix: u, u_lightpos: E, u_lightintensity: _.properties.get("intensity"), u_lightcolor: [k.r, k.g, k.b], u_vertical_gradient: +c, u_opacity: d };
      }, fl = function(u, h, c, d, _, w, E) {
        return o.extend(bm(u, h, c, d), xm(w, h, E), { u_height_factor: -Math.pow(2, _.overscaledZ) / E.tileSize / 8 });
      }, bs = function(u) {
        return { u_matrix: u };
      }, pl = function(u, h, c, d) {
        return o.extend(bs(u), xm(c, h, d));
      }, wm = function(u, h) {
        return { u_matrix: u, u_world: h };
      }, Em = function(u, h, c, d, _) {
        return o.extend(pl(u, h, c, d), { u_world: _ });
      }, ep = function(u, h, c, d) {
        var _, w, E = u.transform;
        if (d.paint.get("circle-pitch-alignment") === "map") {
          var O = mn(c, 1, E.zoom);
          _ = !0, w = [O, O];
        } else
          _ = !1, w = E.pixelsToGLUnits;
        return { u_camera_to_center_distance: E.cameraToCenterDistance, u_scale_with_map: +(d.paint.get("circle-pitch-scale") === "map"), u_matrix: u.translatePosMatrix(h.posMatrix, c, d.paint.get("circle-translate"), d.paint.get("circle-translate-anchor")), u_pitch_with_map: +_, u_device_pixel_ratio: o.browser.devicePixelRatio, u_extrude_scale: w };
      }, dl = function(u, h, c) {
        var d = mn(c, 1, h.zoom), _ = Math.pow(2, h.zoom - c.tileID.overscaledZ), w = c.tileID.overscaleFactor();
        return { u_matrix: u, u_camera_to_center_distance: h.cameraToCenterDistance, u_pixels_to_tile_units: d, u_extrude_scale: [h.pixelsToGLUnits[0] / (d * _), h.pixelsToGLUnits[1] / (d * _)], u_overscale_factor: w };
      }, Sm = function(u, h, c) {
        return { u_matrix: u, u_inv_matrix: h, u_camera_to_center_distance: c.cameraToCenterDistance, u_viewport_size: [c.width, c.height] };
      }, ml = function(u, h, c) {
        return c === void 0 && (c = 1), { u_matrix: u, u_color: h, u_overlay: 0, u_overlay_scale: c };
      }, yl = function(u) {
        return { u_matrix: u };
      }, Tm = function(u, h, c, d) {
        return { u_matrix: u, u_extrude_scale: mn(h, 1, c), u_intensity: d };
      }, ec = function(u, h, c) {
        var d = u.transform;
        return { u_matrix: Mm(u, h, c), u_ratio: 1 / mn(h, 1, d.zoom), u_device_pixel_ratio: o.browser.devicePixelRatio, u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]] };
      }, Qr = function(u, h, c, d) {
        return o.extend(ec(u, h, c), { u_image: 0, u_image_height: d });
      }, hh = function(u, h, c, d) {
        var _ = u.transform, w = Jl(h, _);
        return { u_matrix: Mm(u, h, c), u_texsize: h.imageAtlasTexture.size, u_ratio: 1 / mn(h, 1, _.zoom), u_device_pixel_ratio: o.browser.devicePixelRatio, u_image: 0, u_scale: [w, d.fromScale, d.toScale], u_fade: d.t, u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]] };
      }, Zv = function(u, h, c, d, _) {
        var w = u.lineAtlas, E = Jl(h, u.transform), O = c.layout.get("line-cap") === "round", k = w.getDash(d.from, O), R = w.getDash(d.to, O), $ = k.width * _.fromScale, W = R.width * _.toScale;
        return o.extend(ec(u, h, c), { u_patternscale_a: [E / $, -k.height / 2], u_patternscale_b: [E / W, -R.height / 2], u_sdfgamma: w.width / (256 * Math.min($, W) * o.browser.devicePixelRatio) / 2, u_image: 0, u_tex_y_a: k.y, u_tex_y_b: R.y, u_mix: _.t });
      };
      function Jl(u, h) {
        return 1 / mn(u, 1, h.tileZoom);
      }
      function Mm(u, h, c) {
        return u.translatePosMatrix(h.tileID.posMatrix, h, c.paint.get("line-translate"), c.paint.get("line-translate-anchor"));
      }
      var Xv = function(u, h, c, d, _) {
        return { u_matrix: u, u_tl_parent: h, u_scale_parent: c, u_buffer_scale: 1, u_fade_t: d.mix, u_opacity: d.opacity * _.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: _.paint.get("raster-brightness-min"), u_brightness_high: _.paint.get("raster-brightness-max"), u_saturation_factor: (E = _.paint.get("raster-saturation"), E > 0 ? 1 - 1 / (1.001 - E) : -E), u_contrast_factor: (w = _.paint.get("raster-contrast"), w > 0 ? 1 / (1 - w) : 1 + w), u_spin_weights: Im(_.paint.get("raster-hue-rotate")) };
        var w, E;
      };
      function Im(u) {
        u *= Math.PI / 180;
        var h = Math.sin(u), c = Math.cos(u);
        return [(2 * c + 1) / 3, (-Math.sqrt(3) * h - c + 1) / 3, (Math.sqrt(3) * h - c + 1) / 3];
      }
      var fh, Ql = function(u, h, c, d, _, w, E, O, k, R) {
        var $ = _.transform;
        return { u_is_size_zoom_constant: +(u === "constant" || u === "source"), u_is_size_feature_constant: +(u === "constant" || u === "camera"), u_size_t: h ? h.uSizeT : 0, u_size: h ? h.uSize : 0, u_camera_to_center_distance: $.cameraToCenterDistance, u_pitch: $.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +c, u_aspect_ratio: $.width / $.height, u_fade_change: _.options.fadeDuration ? _.symbolFadeChange : 1, u_matrix: w, u_label_plane_matrix: E, u_coord_matrix: O, u_is_text: +k, u_pitch_with_map: +d, u_texsize: R, u_texture: 0 };
      }, tc = function(u, h, c, d, _, w, E, O, k, R, $) {
        var W = _.transform;
        return o.extend(Ql(u, h, c, d, _, w, E, O, k, R), { u_gamma_scale: d ? Math.cos(W._pitch) * W.cameraToCenterDistance : 1, u_device_pixel_ratio: o.browser.devicePixelRatio, u_is_halo: +$ });
      }, ph = function(u, h, c, d, _, w, E, O, k, R) {
        return o.extend(tc(u, h, c, d, _, w, E, O, !0, k, !0), { u_texsize_icon: R, u_texture_icon: 1 });
      }, rc = function(u, h, c) {
        return { u_matrix: u, u_opacity: h, u_color: c };
      }, eu = function(u, h, c, d, _, w) {
        return o.extend(function(E, O, k, R) {
          var $ = k.imageManager.getPattern(E.from.toString()), W = k.imageManager.getPattern(E.to.toString()), H = k.imageManager.getPixelSize(), ne = H.width, te = H.height, ue = Math.pow(2, R.tileID.overscaledZ), Y = R.tileSize * Math.pow(2, k.transform.tileZoom) / ue, le = Y * (R.tileID.canonical.x + R.tileID.wrap * ue), me = Y * R.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: $.tl, u_pattern_br_a: $.br, u_pattern_tl_b: W.tl, u_pattern_br_b: W.br, u_texsize: [ne, te], u_mix: O.t, u_pattern_size_a: $.displaySize, u_pattern_size_b: W.displaySize, u_scale_a: O.fromScale, u_scale_b: O.toScale, u_tile_units_to_pixels: 1 / mn(R, 1, k.transform.tileZoom), u_pixel_coord_upper: [le >> 16, me >> 16], u_pixel_coord_lower: [65535 & le, 65535 & me] };
        }(d, w, c, _), { u_matrix: u, u_opacity: h });
      }, Om = { fillExtrusion: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_lightpos: new o.Uniform3f(u, h.u_lightpos), u_lightintensity: new o.Uniform1f(u, h.u_lightintensity), u_lightcolor: new o.Uniform3f(u, h.u_lightcolor), u_vertical_gradient: new o.Uniform1f(u, h.u_vertical_gradient), u_opacity: new o.Uniform1f(u, h.u_opacity) };
      }, fillExtrusionPattern: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_lightpos: new o.Uniform3f(u, h.u_lightpos), u_lightintensity: new o.Uniform1f(u, h.u_lightintensity), u_lightcolor: new o.Uniform3f(u, h.u_lightcolor), u_vertical_gradient: new o.Uniform1f(u, h.u_vertical_gradient), u_height_factor: new o.Uniform1f(u, h.u_height_factor), u_image: new o.Uniform1i(u, h.u_image), u_texsize: new o.Uniform2f(u, h.u_texsize), u_pixel_coord_upper: new o.Uniform2f(u, h.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, h.u_pixel_coord_lower), u_scale: new o.Uniform3f(u, h.u_scale), u_fade: new o.Uniform1f(u, h.u_fade), u_opacity: new o.Uniform1f(u, h.u_opacity) };
      }, fill: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix) };
      }, fillPattern: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_image: new o.Uniform1i(u, h.u_image), u_texsize: new o.Uniform2f(u, h.u_texsize), u_pixel_coord_upper: new o.Uniform2f(u, h.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, h.u_pixel_coord_lower), u_scale: new o.Uniform3f(u, h.u_scale), u_fade: new o.Uniform1f(u, h.u_fade) };
      }, fillOutline: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_world: new o.Uniform2f(u, h.u_world) };
      }, fillOutlinePattern: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_world: new o.Uniform2f(u, h.u_world), u_image: new o.Uniform1i(u, h.u_image), u_texsize: new o.Uniform2f(u, h.u_texsize), u_pixel_coord_upper: new o.Uniform2f(u, h.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, h.u_pixel_coord_lower), u_scale: new o.Uniform3f(u, h.u_scale), u_fade: new o.Uniform1f(u, h.u_fade) };
      }, circle: function(u, h) {
        return { u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_scale_with_map: new o.Uniform1i(u, h.u_scale_with_map), u_pitch_with_map: new o.Uniform1i(u, h.u_pitch_with_map), u_extrude_scale: new o.Uniform2f(u, h.u_extrude_scale), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_matrix: new o.UniformMatrix4f(u, h.u_matrix) };
      }, collisionBox: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_pixels_to_tile_units: new o.Uniform1f(u, h.u_pixels_to_tile_units), u_extrude_scale: new o.Uniform2f(u, h.u_extrude_scale), u_overscale_factor: new o.Uniform1f(u, h.u_overscale_factor) };
      }, collisionCircle: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_inv_matrix: new o.UniformMatrix4f(u, h.u_inv_matrix), u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_viewport_size: new o.Uniform2f(u, h.u_viewport_size) };
      }, debug: function(u, h) {
        return { u_color: new o.UniformColor(u, h.u_color), u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_overlay: new o.Uniform1i(u, h.u_overlay), u_overlay_scale: new o.Uniform1f(u, h.u_overlay_scale) };
      }, clippingMask: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix) };
      }, heatmap: function(u, h) {
        return { u_extrude_scale: new o.Uniform1f(u, h.u_extrude_scale), u_intensity: new o.Uniform1f(u, h.u_intensity), u_matrix: new o.UniformMatrix4f(u, h.u_matrix) };
      }, heatmapTexture: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_world: new o.Uniform2f(u, h.u_world), u_image: new o.Uniform1i(u, h.u_image), u_color_ramp: new o.Uniform1i(u, h.u_color_ramp), u_opacity: new o.Uniform1f(u, h.u_opacity) };
      }, hillshade: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_image: new o.Uniform1i(u, h.u_image), u_latrange: new o.Uniform2f(u, h.u_latrange), u_light: new o.Uniform2f(u, h.u_light), u_shadow: new o.UniformColor(u, h.u_shadow), u_highlight: new o.UniformColor(u, h.u_highlight), u_accent: new o.UniformColor(u, h.u_accent) };
      }, hillshadePrepare: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_image: new o.Uniform1i(u, h.u_image), u_dimension: new o.Uniform2f(u, h.u_dimension), u_zoom: new o.Uniform1f(u, h.u_zoom), u_unpack: new o.Uniform4f(u, h.u_unpack) };
      }, line: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_ratio: new o.Uniform1f(u, h.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(u, h.u_units_to_pixels) };
      }, lineGradient: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_ratio: new o.Uniform1f(u, h.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(u, h.u_units_to_pixels), u_image: new o.Uniform1i(u, h.u_image), u_image_height: new o.Uniform1f(u, h.u_image_height) };
      }, linePattern: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_texsize: new o.Uniform2f(u, h.u_texsize), u_ratio: new o.Uniform1f(u, h.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_image: new o.Uniform1i(u, h.u_image), u_units_to_pixels: new o.Uniform2f(u, h.u_units_to_pixels), u_scale: new o.Uniform3f(u, h.u_scale), u_fade: new o.Uniform1f(u, h.u_fade) };
      }, lineSDF: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_ratio: new o.Uniform1f(u, h.u_ratio), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(u, h.u_units_to_pixels), u_patternscale_a: new o.Uniform2f(u, h.u_patternscale_a), u_patternscale_b: new o.Uniform2f(u, h.u_patternscale_b), u_sdfgamma: new o.Uniform1f(u, h.u_sdfgamma), u_image: new o.Uniform1i(u, h.u_image), u_tex_y_a: new o.Uniform1f(u, h.u_tex_y_a), u_tex_y_b: new o.Uniform1f(u, h.u_tex_y_b), u_mix: new o.Uniform1f(u, h.u_mix) };
      }, raster: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_tl_parent: new o.Uniform2f(u, h.u_tl_parent), u_scale_parent: new o.Uniform1f(u, h.u_scale_parent), u_buffer_scale: new o.Uniform1f(u, h.u_buffer_scale), u_fade_t: new o.Uniform1f(u, h.u_fade_t), u_opacity: new o.Uniform1f(u, h.u_opacity), u_image0: new o.Uniform1i(u, h.u_image0), u_image1: new o.Uniform1i(u, h.u_image1), u_brightness_low: new o.Uniform1f(u, h.u_brightness_low), u_brightness_high: new o.Uniform1f(u, h.u_brightness_high), u_saturation_factor: new o.Uniform1f(u, h.u_saturation_factor), u_contrast_factor: new o.Uniform1f(u, h.u_contrast_factor), u_spin_weights: new o.Uniform3f(u, h.u_spin_weights) };
      }, symbolIcon: function(u, h) {
        return { u_is_size_zoom_constant: new o.Uniform1i(u, h.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(u, h.u_is_size_feature_constant), u_size_t: new o.Uniform1f(u, h.u_size_t), u_size: new o.Uniform1f(u, h.u_size), u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_pitch: new o.Uniform1f(u, h.u_pitch), u_rotate_symbol: new o.Uniform1i(u, h.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(u, h.u_aspect_ratio), u_fade_change: new o.Uniform1f(u, h.u_fade_change), u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(u, h.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(u, h.u_coord_matrix), u_is_text: new o.Uniform1i(u, h.u_is_text), u_pitch_with_map: new o.Uniform1i(u, h.u_pitch_with_map), u_texsize: new o.Uniform2f(u, h.u_texsize), u_texture: new o.Uniform1i(u, h.u_texture) };
      }, symbolSDF: function(u, h) {
        return { u_is_size_zoom_constant: new o.Uniform1i(u, h.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(u, h.u_is_size_feature_constant), u_size_t: new o.Uniform1f(u, h.u_size_t), u_size: new o.Uniform1f(u, h.u_size), u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_pitch: new o.Uniform1f(u, h.u_pitch), u_rotate_symbol: new o.Uniform1i(u, h.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(u, h.u_aspect_ratio), u_fade_change: new o.Uniform1f(u, h.u_fade_change), u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(u, h.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(u, h.u_coord_matrix), u_is_text: new o.Uniform1i(u, h.u_is_text), u_pitch_with_map: new o.Uniform1i(u, h.u_pitch_with_map), u_texsize: new o.Uniform2f(u, h.u_texsize), u_texture: new o.Uniform1i(u, h.u_texture), u_gamma_scale: new o.Uniform1f(u, h.u_gamma_scale), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_is_halo: new o.Uniform1i(u, h.u_is_halo) };
      }, symbolTextAndIcon: function(u, h) {
        return { u_is_size_zoom_constant: new o.Uniform1i(u, h.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(u, h.u_is_size_feature_constant), u_size_t: new o.Uniform1f(u, h.u_size_t), u_size: new o.Uniform1f(u, h.u_size), u_camera_to_center_distance: new o.Uniform1f(u, h.u_camera_to_center_distance), u_pitch: new o.Uniform1f(u, h.u_pitch), u_rotate_symbol: new o.Uniform1i(u, h.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(u, h.u_aspect_ratio), u_fade_change: new o.Uniform1f(u, h.u_fade_change), u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(u, h.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(u, h.u_coord_matrix), u_is_text: new o.Uniform1i(u, h.u_is_text), u_pitch_with_map: new o.Uniform1i(u, h.u_pitch_with_map), u_texsize: new o.Uniform2f(u, h.u_texsize), u_texsize_icon: new o.Uniform2f(u, h.u_texsize_icon), u_texture: new o.Uniform1i(u, h.u_texture), u_texture_icon: new o.Uniform1i(u, h.u_texture_icon), u_gamma_scale: new o.Uniform1f(u, h.u_gamma_scale), u_device_pixel_ratio: new o.Uniform1f(u, h.u_device_pixel_ratio), u_is_halo: new o.Uniform1i(u, h.u_is_halo) };
      }, background: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_opacity: new o.Uniform1f(u, h.u_opacity), u_color: new o.UniformColor(u, h.u_color) };
      }, backgroundPattern: function(u, h) {
        return { u_matrix: new o.UniformMatrix4f(u, h.u_matrix), u_opacity: new o.Uniform1f(u, h.u_opacity), u_image: new o.Uniform1i(u, h.u_image), u_pattern_tl_a: new o.Uniform2f(u, h.u_pattern_tl_a), u_pattern_br_a: new o.Uniform2f(u, h.u_pattern_br_a), u_pattern_tl_b: new o.Uniform2f(u, h.u_pattern_tl_b), u_pattern_br_b: new o.Uniform2f(u, h.u_pattern_br_b), u_texsize: new o.Uniform2f(u, h.u_texsize), u_mix: new o.Uniform1f(u, h.u_mix), u_pattern_size_a: new o.Uniform2f(u, h.u_pattern_size_a), u_pattern_size_b: new o.Uniform2f(u, h.u_pattern_size_b), u_scale_a: new o.Uniform1f(u, h.u_scale_a), u_scale_b: new o.Uniform1f(u, h.u_scale_b), u_pixel_coord_upper: new o.Uniform2f(u, h.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(u, h.u_pixel_coord_lower), u_tile_units_to_pixels: new o.Uniform1f(u, h.u_tile_units_to_pixels) };
      } };
      function tu(u, h, c, d, _, w, E) {
        for (var O = u.context, k = O.gl, R = u.useProgram("collisionBox"), $ = [], W = 0, H = 0, ne = 0; ne < d.length; ne++) {
          var te = d[ne], ue = h.getTile(te), Y = ue.getBucket(c);
          if (Y) {
            var le = te.posMatrix;
            _[0] === 0 && _[1] === 0 || (le = u.translatePosMatrix(te.posMatrix, ue, _, w));
            var me = E ? Y.textCollisionBox : Y.iconCollisionBox, xe = Y.collisionCircleArray;
            if (xe.length > 0) {
              var Pe = o.create(), Me = le;
              o.mul(Pe, Y.placementInvProjMatrix, u.transform.glCoordMatrix), o.mul(Pe, Pe, Y.placementViewportMatrix), $.push({ circleArray: xe, circleOffset: H, transform: Me, invTransform: Pe }), H = W += xe.length / 4;
            }
            me && R.draw(O, k.LINES, Z.disabled, Q.disabled, u.colorModeForRenderPass(), de.disabled, dl(le, u.transform, ue), c.id, me.layoutVertexBuffer, me.indexBuffer, me.segments, null, u.transform.zoom, null, null, me.collisionVertexBuffer);
          }
        }
        if (E && $.length) {
          var ke = u.useProgram("collisionCircle"), je = new o.StructArrayLayout2f1f2i16();
          je.resize(4 * W), je._trim();
          for (var it = 0, tt = 0, gt = $; tt < gt.length; tt += 1)
            for (var Nt = gt[tt], Bt = 0; Bt < Nt.circleArray.length / 4; Bt++) {
              var Ft = 4 * Bt, Ir = Nt.circleArray[Ft + 0], xt = Nt.circleArray[Ft + 1], Yt = Nt.circleArray[Ft + 2], or = Nt.circleArray[Ft + 3];
              je.emplace(it++, Ir, xt, Yt, or, 0), je.emplace(it++, Ir, xt, Yt, or, 1), je.emplace(it++, Ir, xt, Yt, or, 2), je.emplace(it++, Ir, xt, Yt, or, 3);
            }
          (!fh || fh.length < 2 * W) && (fh = function(On) {
            var Li = 2 * On, vi = new o.StructArrayLayout3ui6();
            vi.resize(Li), vi._trim();
            for (var Mn = 0; Mn < Li; Mn++) {
              var Dn = 6 * Mn;
              vi.uint16[Dn + 0] = 4 * Mn + 0, vi.uint16[Dn + 1] = 4 * Mn + 1, vi.uint16[Dn + 2] = 4 * Mn + 2, vi.uint16[Dn + 3] = 4 * Mn + 2, vi.uint16[Dn + 4] = 4 * Mn + 3, vi.uint16[Dn + 5] = 4 * Mn + 0;
            }
            return vi;
          }(W));
          for (var Kt = O.createIndexBuffer(fh, !0), Xt = O.createVertexBuffer(je, o.collisionCircleLayout.members, !0), nr = 0, Wt = $; nr < Wt.length; nr += 1) {
            var Gt = Wt[nr], li = Sm(Gt.transform, Gt.invTransform, u.transform);
            ke.draw(O, k.TRIANGLES, Z.disabled, Q.disabled, u.colorModeForRenderPass(), de.disabled, li, c.id, Xt, Kt, o.SegmentVector.simpleSegment(0, 2 * Gt.circleOffset, Gt.circleArray.length, Gt.circleArray.length / 2), null, u.transform.zoom, null, null, null);
          }
          Xt.destroy(), Kt.destroy();
        }
      }
      var oa = o.identity(new Float32Array(16));
      function Cm(u, h, c, d, _, w) {
        var E = o.getAnchorAlignment(u), O = -(E.horizontalAlign - 0.5) * h, k = -(E.verticalAlign - 0.5) * c, R = o.evaluateVariableOffset(u, d);
        return new o.Point((O / _ + R[0]) * w, (k / _ + R[1]) * w);
      }
      function Pm(u, h, c, d, _, w, E, O, k, R, $) {
        var W = u.text.placedSymbolArray, H = u.text.dynamicLayoutVertexArray, ne = u.icon.dynamicLayoutVertexArray, te = {};
        H.clear();
        for (var ue = 0; ue < W.length; ue++) {
          var Y = W.get(ue), le = Y.hidden || !Y.crossTileID || u.allowVerticalPlacement && !Y.placedOrientation ? null : d[Y.crossTileID];
          if (le) {
            var me = new o.Point(Y.anchorX, Y.anchorY), xe = gr(me, c ? O : E), Pe = zr(w.cameraToCenterDistance, xe.signedDistanceFromCamera), Me = _.evaluateSizeForFeature(u.textSizeData, R, Y) * Pe / o.ONE_EM;
            c && (Me *= u.tilePixelRatio / k);
            for (var ke = Cm(le.anchor, le.width, le.height, le.textOffset, le.textBoxScale, Me), je = c ? gr(me.add(ke), E).point : xe.point.add(h ? ke.rotate(-w.angle) : ke), it = u.allowVerticalPlacement && Y.placedOrientation === o.WritingMode.vertical ? Math.PI / 2 : 0, tt = 0; tt < Y.numGlyphs; tt++)
              o.addDynamicAttributes(H, je, it);
            $ && Y.associatedIconIndex >= 0 && (te[Y.associatedIconIndex] = { shiftedAnchor: je, angle: it });
          } else
            Vi(Y.numGlyphs, H);
        }
        if ($) {
          ne.clear();
          for (var gt = u.icon.placedSymbolArray, Nt = 0; Nt < gt.length; Nt++) {
            var Bt = gt.get(Nt);
            if (Bt.hidden)
              Vi(Bt.numGlyphs, ne);
            else {
              var Ft = te[Nt];
              if (Ft)
                for (var Ir = 0; Ir < Bt.numGlyphs; Ir++)
                  o.addDynamicAttributes(ne, Ft.shiftedAnchor, Ft.angle);
              else
                Vi(Bt.numGlyphs, ne);
            }
          }
          u.icon.dynamicLayoutVertexBuffer.updateData(ne);
        }
        u.text.dynamicLayoutVertexBuffer.updateData(H);
      }
      function Am(u, h, c) {
        return c.iconsInText && h ? "symbolTextAndIcon" : u ? "symbolSDF" : "symbolIcon";
      }
      function gl(u, h, c, d, _, w, E, O, k, R, $, W) {
        for (var H = u.context, ne = H.gl, te = u.transform, ue = O === "map", Y = k === "map", le = ue && c.layout.get("symbol-placement") !== "point", me = ue && !Y && !le, xe = c.layout.get("symbol-sort-key").constantOr(1) !== void 0, Pe = !1, Me = u.depthModeForSublayer(0, Z.ReadOnly), ke = c.layout.get("text-variable-anchor"), je = [], it = 0, tt = d; it < tt.length; it += 1) {
          var gt = tt[it], Nt = h.getTile(gt), Bt = Nt.getBucket(c);
          if (Bt) {
            var Ft = _ ? Bt.text : Bt.icon;
            if (Ft && Ft.segments.get().length) {
              var Ir = Ft.programConfigurations.get(c.id), xt = _ || Bt.sdfIcons, Yt = _ ? Bt.textSizeData : Bt.iconSizeData, or = Y || te.pitch !== 0, Kt = u.useProgram(Am(xt, _, Bt), Ir), Xt = o.evaluateSizeForZoom(Yt, te.zoom), nr = void 0, Wt = [0, 0], Gt = void 0, li = void 0, On = null, Li = void 0;
              if (_)
                Gt = Nt.glyphAtlasTexture, li = ne.LINEAR, nr = Nt.glyphAtlasTexture.size, Bt.iconsInText && (Wt = Nt.imageAtlasTexture.size, On = Nt.imageAtlasTexture, Li = or || u.options.rotating || u.options.zooming || Yt.kind === "composite" || Yt.kind === "camera" ? ne.LINEAR : ne.NEAREST);
              else {
                var vi = c.layout.get("icon-size").constantOr(0) !== 1 || Bt.iconsNeedLinear;
                Gt = Nt.imageAtlasTexture, li = xt || u.options.rotating || u.options.zooming || vi || or ? ne.LINEAR : ne.NEAREST, nr = Nt.imageAtlasTexture.size;
              }
              var Mn = mn(Nt, 1, u.transform.zoom), Dn = dn(gt.posMatrix, Y, ue, u.transform, Mn), mo = Ur(gt.posMatrix, Y, ue, u.transform, Mn), $i = ke && Bt.hasTextData(), Is = c.layout.get("icon-text-fit") !== "none" && $i && Bt.hasIconData();
              le && Zu(Bt, gt.posMatrix, u, _, Dn, mo, Y, R);
              var Qi = u.translatePosMatrix(gt.posMatrix, Nt, w, E), ca = le || _ && ke || Is ? oa : Dn, Zo = u.translatePosMatrix(mo, Nt, w, E, !0), dc = xt && c.paint.get(_ ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, su = { program: Kt, buffers: Ft, uniformValues: xt ? Bt.iconsInText ? ph(Yt.kind, Xt, me, Y, u, Qi, ca, Zo, nr, Wt) : tc(Yt.kind, Xt, me, Y, u, Qi, ca, Zo, _, nr, !0) : Ql(Yt.kind, Xt, me, Y, u, Qi, ca, Zo, _, nr), atlasTexture: Gt, atlasTextureIcon: On, atlasInterpolation: li, atlasInterpolationIcon: Li, isSDF: xt, hasHalo: dc };
              if (xe && Bt.canOverlap) {
                Pe = !0;
                for (var Os = 0, lu = Ft.segments.get(); Os < lu.length; Os += 1) {
                  var mc = lu[Os];
                  je.push({ segments: new o.SegmentVector([mc]), sortKey: mc.sortKey, state: su });
                }
              } else
                je.push({ segments: Ft.segments, sortKey: 0, state: su });
            }
          }
        }
        Pe && je.sort(function(Cs, El) {
          return Cs.sortKey - El.sortKey;
        });
        for (var Sa = 0, yc = je; Sa < yc.length; Sa += 1) {
          var Ta = yc[Sa], ui = Ta.state;
          if (H.activeTexture.set(ne.TEXTURE0), ui.atlasTexture.bind(ui.atlasInterpolation, ne.CLAMP_TO_EDGE), ui.atlasTextureIcon && (H.activeTexture.set(ne.TEXTURE1), ui.atlasTextureIcon && ui.atlasTextureIcon.bind(ui.atlasInterpolationIcon, ne.CLAMP_TO_EDGE)), ui.isSDF) {
            var $a = ui.uniformValues;
            ui.hasHalo && ($a.u_is_halo = 1, nc(ui.buffers, Ta.segments, c, u, ui.program, Me, $, W, $a)), $a.u_is_halo = 0;
          }
          nc(ui.buffers, Ta.segments, c, u, ui.program, Me, $, W, ui.uniformValues);
        }
      }
      function nc(u, h, c, d, _, w, E, O, k) {
        var R = d.context;
        _.draw(R, R.gl.TRIANGLES, w, E, O, de.disabled, k, c.id, u.layoutVertexBuffer, u.indexBuffer, h, c.paint, d.transform.zoom, u.programConfigurations.get(c.id), u.dynamicLayoutVertexBuffer, u.opacityVertexBuffer);
      }
      function dh(u, h, c, d, _, w, E) {
        var O, k, R, $, W, H = u.context.gl, ne = c.paint.get("fill-pattern"), te = ne && ne.constantOr(1), ue = c.getCrossfadeParameters();
        E ? (k = te && !c.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", O = H.LINES) : (k = te ? "fillPattern" : "fill", O = H.TRIANGLES);
        for (var Y = 0, le = d; Y < le.length; Y += 1) {
          var me = le[Y], xe = h.getTile(me);
          if (!te || xe.patternsLoaded()) {
            var Pe = xe.getBucket(c);
            if (Pe) {
              var Me = Pe.programConfigurations.get(c.id), ke = u.useProgram(k, Me);
              te && (u.context.activeTexture.set(H.TEXTURE0), xe.imageAtlasTexture.bind(H.LINEAR, H.CLAMP_TO_EDGE), Me.updatePaintBuffers(ue));
              var je = ne.constantOr(null);
              if (je && xe.imageAtlas) {
                var it = xe.imageAtlas, tt = it.patternPositions[je.to.toString()], gt = it.patternPositions[je.from.toString()];
                tt && gt && Me.setConstantPatternPositions(tt, gt);
              }
              var Nt = u.translatePosMatrix(me.posMatrix, xe, c.paint.get("fill-translate"), c.paint.get("fill-translate-anchor"));
              if (E) {
                $ = Pe.indexBuffer2, W = Pe.segments2;
                var Bt = [H.drawingBufferWidth, H.drawingBufferHeight];
                R = k === "fillOutlinePattern" && te ? Em(Nt, u, ue, xe, Bt) : wm(Nt, Bt);
              } else
                $ = Pe.indexBuffer, W = Pe.segments, R = te ? pl(Nt, u, ue, xe) : bs(Nt);
              ke.draw(u.context, O, _, u.stencilModeForClipping(me), w, de.disabled, R, c.id, Pe.layoutVertexBuffer, $, W, c.paint, u.transform.zoom, Me);
            }
          }
        }
      }
      function tp(u, h, c, d, _, w, E) {
        for (var O = u.context, k = O.gl, R = c.paint.get("fill-extrusion-pattern"), $ = R.constantOr(1), W = c.getCrossfadeParameters(), H = c.paint.get("fill-extrusion-opacity"), ne = 0, te = d; ne < te.length; ne += 1) {
          var ue = te[ne], Y = h.getTile(ue), le = Y.getBucket(c);
          if (le) {
            var me = le.programConfigurations.get(c.id), xe = u.useProgram($ ? "fillExtrusionPattern" : "fillExtrusion", me);
            $ && (u.context.activeTexture.set(k.TEXTURE0), Y.imageAtlasTexture.bind(k.LINEAR, k.CLAMP_TO_EDGE), me.updatePaintBuffers(W));
            var Pe = R.constantOr(null);
            if (Pe && Y.imageAtlas) {
              var Me = Y.imageAtlas, ke = Me.patternPositions[Pe.to.toString()], je = Me.patternPositions[Pe.from.toString()];
              ke && je && me.setConstantPatternPositions(ke, je);
            }
            var it = u.translatePosMatrix(ue.posMatrix, Y, c.paint.get("fill-extrusion-translate"), c.paint.get("fill-extrusion-translate-anchor")), tt = c.paint.get("fill-extrusion-vertical-gradient"), gt = $ ? fl(it, u, tt, H, ue, W, Y) : bm(it, u, tt, H);
            xe.draw(O, O.gl.TRIANGLES, _, w, E, de.backCCW, gt, c.id, le.layoutVertexBuffer, le.indexBuffer, le.segments, c.paint, u.transform.zoom, me);
          }
        }
      }
      function mh(u, h, c, d, _, w) {
        var E = u.context, O = E.gl, k = h.fbo;
        if (k) {
          var R = u.useProgram("hillshade");
          E.activeTexture.set(O.TEXTURE0), O.bindTexture(O.TEXTURE_2D, k.colorAttachment.get());
          var $ = function(W, H, ne) {
            var te = ne.paint.get("hillshade-shadow-color"), ue = ne.paint.get("hillshade-highlight-color"), Y = ne.paint.get("hillshade-accent-color"), le = ne.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            ne.paint.get("hillshade-illumination-anchor") === "viewport" && (le -= W.transform.angle);
            var me, xe, Pe, Me = !W.options.moving;
            return { u_matrix: W.transform.calculatePosMatrix(H.tileID.toUnwrapped(), Me), u_image: 0, u_latrange: (me = H.tileID, xe = Math.pow(2, me.canonical.z), Pe = me.canonical.y, [new o.MercatorCoordinate(0, Pe / xe).toLngLat().lat, new o.MercatorCoordinate(0, (Pe + 1) / xe).toLngLat().lat]), u_light: [ne.paint.get("hillshade-exaggeration"), le], u_shadow: te, u_highlight: ue, u_accent: Y };
          }(u, h, c);
          R.draw(E, O.TRIANGLES, d, _, w, de.disabled, $, c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments);
        }
      }
      function Kv(u, h, c, d, _, w) {
        var E = u.context, O = E.gl, k = h.dem;
        if (k && k.data) {
          var R = k.dim, $ = k.stride, W = k.getPixels();
          if (E.activeTexture.set(O.TEXTURE1), E.pixelStoreUnpackPremultiplyAlpha.set(!1), h.demTexture = h.demTexture || u.getTileTexture($), h.demTexture) {
            var H = h.demTexture;
            H.update(W, { premultiply: !1 }), H.bind(O.NEAREST, O.CLAMP_TO_EDGE);
          } else
            h.demTexture = new o.Texture(E, W, O.RGBA, { premultiply: !1 }), h.demTexture.bind(O.NEAREST, O.CLAMP_TO_EDGE);
          E.activeTexture.set(O.TEXTURE0);
          var ne = h.fbo;
          if (!ne) {
            var te = new o.Texture(E, { width: R, height: R, data: null }, O.RGBA);
            te.bind(O.LINEAR, O.CLAMP_TO_EDGE), (ne = h.fbo = E.createFramebuffer(R, R, !0)).colorAttachment.set(te.texture);
          }
          E.bindFramebuffer.set(ne.framebuffer), E.viewport.set([0, 0, R, R]), u.useProgram("hillshadePrepare").draw(E, O.TRIANGLES, d, _, w, de.disabled, function(ue, Y) {
            var le = Y.stride, me = o.create();
            return o.ortho(me, 0, o.EXTENT, -o.EXTENT, 0, 0, 1), o.translate(me, me, [0, -o.EXTENT, 0]), { u_matrix: me, u_image: 1, u_dimension: [le, le], u_zoom: ue.overscaledZ, u_unpack: Y.getUnpackVector() };
          }(h.tileID, k), c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments), h.needsHillshadePrepare = !1;
        }
      }
      function yh(u, h, c, d, _) {
        var w = d.paint.get("raster-fade-duration");
        if (w > 0) {
          var E = o.browser.now(), O = (E - u.timeAdded) / w, k = h ? (E - h.timeAdded) / w : -1, R = c.getSource(), $ = _.coveringZoomLevel({ tileSize: R.tileSize, roundZoom: R.roundZoom }), W = !h || Math.abs(h.tileID.overscaledZ - $) > Math.abs(u.tileID.overscaledZ - $), H = W && u.refreshedUponExpiration ? 1 : o.clamp(W ? O : 1 - k, 0, 1);
          return u.refreshedUponExpiration && O >= 1 && (u.refreshedUponExpiration = !1), h ? { opacity: 1, mix: 1 - H } : { opacity: H, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      var rp = new o.Color(1, 0, 0, 1), km = new o.Color(0, 1, 0, 1), Lm = new o.Color(0, 0, 1, 1), gh = new o.Color(1, 0, 1, 1), np = new o.Color(0, 1, 1, 1);
      function ip(u, h, c, d) {
        ic(u, 0, h + c / 2, u.transform.width, c, d);
      }
      function op(u, h, c, d) {
        ic(u, h - c / 2, 0, c, u.transform.height, d);
      }
      function ic(u, h, c, d, _, w) {
        var E = u.context, O = E.gl;
        O.enable(O.SCISSOR_TEST), O.scissor(h * o.browser.devicePixelRatio, c * o.browser.devicePixelRatio, d * o.browser.devicePixelRatio, _ * o.browser.devicePixelRatio), E.clear({ color: w }), O.disable(O.SCISSOR_TEST);
      }
      function Dm(u, h, c) {
        var d = u.context, _ = d.gl, w = c.posMatrix, E = u.useProgram("debug"), O = Z.disabled, k = Q.disabled, R = u.colorModeForRenderPass();
        d.activeTexture.set(_.TEXTURE0), u.emptyTexture.bind(_.LINEAR, _.CLAMP_TO_EDGE), E.draw(d, _.LINE_STRIP, O, k, R, de.disabled, ml(w, o.Color.red), "$debug", u.debugBuffer, u.tileBorderIndexBuffer, u.debugSegments);
        var $ = h.getTileByID(c.key).latestRawTileData, W = Math.floor(($ && $.byteLength || 0) / 1024), H = h.getTile(c).tileSize, ne = 512 / Math.min(H, 512) * (c.overscaledZ / u.transform.zoom) * 0.5, te = c.canonical.toString();
        c.overscaledZ !== c.canonical.z && (te += " => " + c.overscaledZ), function(ue, Y) {
          ue.initDebugOverlayCanvas();
          var le = ue.debugOverlayCanvas, me = ue.context.gl, xe = ue.debugOverlayCanvas.getContext("2d");
          xe.clearRect(0, 0, le.width, le.height), xe.shadowColor = "white", xe.shadowBlur = 2, xe.lineWidth = 1.5, xe.strokeStyle = "white", xe.textBaseline = "top", xe.font = "bold 36px Open Sans, sans-serif", xe.fillText(Y, 5, 5), xe.strokeText(Y, 5, 5), ue.debugOverlayTexture.update(le), ue.debugOverlayTexture.bind(me.LINEAR, me.CLAMP_TO_EDGE);
        }(u, te + " " + W + "kb"), E.draw(d, _.TRIANGLES, O, k, pe.alphaBlended, de.disabled, ml(w, o.Color.transparent, ne), "$debug", u.debugBuffer, u.quadTriangleIndexBuffer, u.debugSegments);
      }
      var vl = { symbol: function(u, h, c, d, _) {
        if (u.renderPass === "translucent") {
          var w = Q.disabled, E = u.colorModeForRenderPass();
          c.layout.get("text-variable-anchor") && function(O, k, R, $, W, H, ne) {
            for (var te = k.transform, ue = W === "map", Y = H === "map", le = 0, me = O; le < me.length; le += 1) {
              var xe = me[le], Pe = $.getTile(xe), Me = Pe.getBucket(R);
              if (Me && Me.text && Me.text.segments.get().length) {
                var ke = o.evaluateSizeForZoom(Me.textSizeData, te.zoom), je = mn(Pe, 1, k.transform.zoom), it = dn(xe.posMatrix, Y, ue, k.transform, je), tt = R.layout.get("icon-text-fit") !== "none" && Me.hasIconData();
                if (ke) {
                  var gt = Math.pow(2, te.zoom - Pe.tileID.overscaledZ);
                  Pm(Me, ue, Y, ne, o.symbolSize, te, it, xe.posMatrix, gt, ke, tt);
                }
              }
            }
          }(d, u, c, h, c.layout.get("text-rotation-alignment"), c.layout.get("text-pitch-alignment"), _), c.paint.get("icon-opacity").constantOr(1) !== 0 && gl(u, h, c, d, !1, c.paint.get("icon-translate"), c.paint.get("icon-translate-anchor"), c.layout.get("icon-rotation-alignment"), c.layout.get("icon-pitch-alignment"), c.layout.get("icon-keep-upright"), w, E), c.paint.get("text-opacity").constantOr(1) !== 0 && gl(u, h, c, d, !0, c.paint.get("text-translate"), c.paint.get("text-translate-anchor"), c.layout.get("text-rotation-alignment"), c.layout.get("text-pitch-alignment"), c.layout.get("text-keep-upright"), w, E), h.map.showCollisionBoxes && (tu(u, h, c, d, c.paint.get("text-translate"), c.paint.get("text-translate-anchor"), !0), tu(u, h, c, d, c.paint.get("icon-translate"), c.paint.get("icon-translate-anchor"), !1));
        }
      }, circle: function(u, h, c, d) {
        if (u.renderPass === "translucent") {
          var _ = c.paint.get("circle-opacity"), w = c.paint.get("circle-stroke-width"), E = c.paint.get("circle-stroke-opacity"), O = c.layout.get("circle-sort-key").constantOr(1) !== void 0;
          if (_.constantOr(1) !== 0 || w.constantOr(1) !== 0 && E.constantOr(1) !== 0) {
            for (var k = u.context, R = k.gl, $ = u.depthModeForSublayer(0, Z.ReadOnly), W = Q.disabled, H = u.colorModeForRenderPass(), ne = [], te = 0; te < d.length; te++) {
              var ue = d[te], Y = h.getTile(ue), le = Y.getBucket(c);
              if (le) {
                var me = le.programConfigurations.get(c.id), xe = { programConfiguration: me, program: u.useProgram("circle", me), layoutVertexBuffer: le.layoutVertexBuffer, indexBuffer: le.indexBuffer, uniformValues: ep(u, ue, Y, c) };
                if (O)
                  for (var Pe = 0, Me = le.segments.get(); Pe < Me.length; Pe += 1) {
                    var ke = Me[Pe];
                    ne.push({ segments: new o.SegmentVector([ke]), sortKey: ke.sortKey, state: xe });
                  }
                else
                  ne.push({ segments: le.segments, sortKey: 0, state: xe });
              }
            }
            O && ne.sort(function(Nt, Bt) {
              return Nt.sortKey - Bt.sortKey;
            });
            for (var je = 0, it = ne; je < it.length; je += 1) {
              var tt = it[je], gt = tt.state;
              gt.program.draw(k, R.TRIANGLES, $, W, H, de.disabled, gt.uniformValues, c.id, gt.layoutVertexBuffer, gt.indexBuffer, tt.segments, c.paint, u.transform.zoom, gt.programConfiguration);
            }
          }
        }
      }, heatmap: function(u, h, c, d) {
        if (c.paint.get("heatmap-opacity") !== 0)
          if (u.renderPass === "offscreen") {
            var _ = u.context, w = _.gl, E = Q.disabled, O = new pe([w.ONE, w.ONE], o.Color.transparent, [!0, !0, !0, !0]);
            (function(ne, te, ue) {
              var Y = ne.gl;
              ne.activeTexture.set(Y.TEXTURE1), ne.viewport.set([0, 0, te.width / 4, te.height / 4]);
              var le = ue.heatmapFbo;
              if (le)
                Y.bindTexture(Y.TEXTURE_2D, le.colorAttachment.get()), ne.bindFramebuffer.set(le.framebuffer);
              else {
                var me = Y.createTexture();
                Y.bindTexture(Y.TEXTURE_2D, me), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_WRAP_S, Y.CLAMP_TO_EDGE), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_WRAP_T, Y.CLAMP_TO_EDGE), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MIN_FILTER, Y.LINEAR), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MAG_FILTER, Y.LINEAR), le = ue.heatmapFbo = ne.createFramebuffer(te.width / 4, te.height / 4, !1), function(xe, Pe, Me, ke) {
                  var je = xe.gl;
                  je.texImage2D(je.TEXTURE_2D, 0, je.RGBA, Pe.width / 4, Pe.height / 4, 0, je.RGBA, xe.extRenderToTextureHalfFloat ? xe.extTextureHalfFloat.HALF_FLOAT_OES : je.UNSIGNED_BYTE, null), ke.colorAttachment.set(Me);
                }(ne, te, me, le);
              }
            })(_, u, c), _.clear({ color: o.Color.transparent });
            for (var k = 0; k < d.length; k++) {
              var R = d[k];
              if (!h.hasRenderableParent(R)) {
                var $ = h.getTile(R), W = $.getBucket(c);
                if (W) {
                  var H = W.programConfigurations.get(c.id);
                  u.useProgram("heatmap", H).draw(_, w.TRIANGLES, Z.disabled, E, O, de.disabled, Tm(R.posMatrix, $, u.transform.zoom, c.paint.get("heatmap-intensity")), c.id, W.layoutVertexBuffer, W.indexBuffer, W.segments, c.paint, u.transform.zoom, H);
                }
              }
            }
            _.viewport.set([0, 0, u.width, u.height]);
          } else
            u.renderPass === "translucent" && (u.context.setColorMode(u.colorModeForRenderPass()), function(ne, te) {
              var ue = ne.context, Y = ue.gl, le = te.heatmapFbo;
              if (le) {
                ue.activeTexture.set(Y.TEXTURE0), Y.bindTexture(Y.TEXTURE_2D, le.colorAttachment.get()), ue.activeTexture.set(Y.TEXTURE1);
                var me = te.colorRampTexture;
                me || (me = te.colorRampTexture = new o.Texture(ue, te.colorRamp, Y.RGBA)), me.bind(Y.LINEAR, Y.CLAMP_TO_EDGE), ne.useProgram("heatmapTexture").draw(ue, Y.TRIANGLES, Z.disabled, Q.disabled, ne.colorModeForRenderPass(), de.disabled, function(xe, Pe, Me, ke) {
                  var je = o.create();
                  o.ortho(je, 0, xe.width, xe.height, 0, 0, 1);
                  var it = xe.context.gl;
                  return { u_matrix: je, u_world: [it.drawingBufferWidth, it.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: Pe.paint.get("heatmap-opacity") };
                }(ne, te), te.id, ne.viewportBuffer, ne.quadTriangleIndexBuffer, ne.viewportSegments, te.paint, ne.transform.zoom);
              }
            }(u, c));
      }, line: function(u, h, c, d) {
        if (u.renderPass === "translucent") {
          var _ = c.paint.get("line-opacity"), w = c.paint.get("line-width");
          if (_.constantOr(1) !== 0 && w.constantOr(1) !== 0)
            for (var E = u.depthModeForSublayer(0, Z.ReadOnly), O = u.colorModeForRenderPass(), k = c.paint.get("line-dasharray"), R = c.paint.get("line-pattern"), $ = R.constantOr(1), W = c.paint.get("line-gradient"), H = c.getCrossfadeParameters(), ne = $ ? "linePattern" : k ? "lineSDF" : W ? "lineGradient" : "line", te = u.context, ue = te.gl, Y = !0, le = 0, me = d; le < me.length; le += 1) {
              var xe = me[le], Pe = h.getTile(xe);
              if (!$ || Pe.patternsLoaded()) {
                var Me = Pe.getBucket(c);
                if (Me) {
                  var ke = Me.programConfigurations.get(c.id), je = u.context.program.get(), it = u.useProgram(ne, ke), tt = Y || it.program !== je, gt = R.constantOr(null);
                  if (gt && Pe.imageAtlas) {
                    var Nt = Pe.imageAtlas, Bt = Nt.patternPositions[gt.to.toString()], Ft = Nt.patternPositions[gt.from.toString()];
                    Bt && Ft && ke.setConstantPatternPositions(Bt, Ft);
                  }
                  var Ir = $ ? hh(u, Pe, c, H) : k ? Zv(u, Pe, c, k, H) : W ? Qr(u, Pe, c, Me.lineClipsArray.length) : ec(u, Pe, c);
                  if ($)
                    te.activeTexture.set(ue.TEXTURE0), Pe.imageAtlasTexture.bind(ue.LINEAR, ue.CLAMP_TO_EDGE), ke.updatePaintBuffers(H);
                  else if (k && (tt || u.lineAtlas.dirty))
                    te.activeTexture.set(ue.TEXTURE0), u.lineAtlas.bind(te);
                  else if (W) {
                    var xt = Me.gradients[c.id], Yt = xt.texture;
                    if (c.gradientVersion !== xt.version) {
                      var or = 256;
                      if (c.stepInterpolant) {
                        var Kt = h.getSource().maxzoom, Xt = xe.canonical.z === Kt ? Math.ceil(1 << u.transform.maxZoom - xe.canonical.z) : 1;
                        or = o.clamp(o.nextPowerOfTwo(Me.maxLineLength / o.EXTENT * 1024 * Xt), 256, te.maxTextureSize);
                      }
                      xt.gradient = o.renderColorRamp({ expression: c.gradientExpression(), evaluationKey: "lineProgress", resolution: or, image: xt.gradient || void 0, clips: Me.lineClipsArray }), xt.texture ? xt.texture.update(xt.gradient) : xt.texture = new o.Texture(te, xt.gradient, ue.RGBA), xt.version = c.gradientVersion, Yt = xt.texture;
                    }
                    te.activeTexture.set(ue.TEXTURE0), Yt.bind(c.stepInterpolant ? ue.NEAREST : ue.LINEAR, ue.CLAMP_TO_EDGE);
                  }
                  it.draw(te, ue.TRIANGLES, E, u.stencilModeForClipping(xe), O, de.disabled, Ir, c.id, Me.layoutVertexBuffer, Me.indexBuffer, Me.segments, c.paint, u.transform.zoom, ke, Me.layoutVertexBuffer2), Y = !1;
                }
              }
            }
        }
      }, fill: function(u, h, c, d) {
        var _ = c.paint.get("fill-color"), w = c.paint.get("fill-opacity");
        if (w.constantOr(1) !== 0) {
          var E = u.colorModeForRenderPass(), O = c.paint.get("fill-pattern"), k = u.opaquePassEnabledForLayer() && !O.constantOr(1) && _.constantOr(o.Color.transparent).a === 1 && w.constantOr(0) === 1 ? "opaque" : "translucent";
          if (u.renderPass === k) {
            var R = u.depthModeForSublayer(1, u.renderPass === "opaque" ? Z.ReadWrite : Z.ReadOnly);
            dh(u, h, c, d, R, E, !1);
          }
          if (u.renderPass === "translucent" && c.paint.get("fill-antialias")) {
            var $ = u.depthModeForSublayer(c.getPaintProperty("fill-outline-color") ? 2 : 0, Z.ReadOnly);
            dh(u, h, c, d, $, E, !0);
          }
        }
      }, "fill-extrusion": function(u, h, c, d) {
        var _ = c.paint.get("fill-extrusion-opacity");
        if (_ !== 0 && u.renderPass === "translucent") {
          var w = new Z(u.context.gl.LEQUAL, Z.ReadWrite, u.depthRangeFor3D);
          if (_ !== 1 || c.paint.get("fill-extrusion-pattern").constantOr(1))
            tp(u, h, c, d, w, Q.disabled, pe.disabled), tp(u, h, c, d, w, u.stencilModeFor3D(), u.colorModeForRenderPass());
          else {
            var E = u.colorModeForRenderPass();
            tp(u, h, c, d, w, Q.disabled, E);
          }
        }
      }, hillshade: function(u, h, c, d) {
        if (u.renderPass === "offscreen" || u.renderPass === "translucent") {
          for (var _ = u.context, w = u.depthModeForSublayer(0, Z.ReadOnly), E = u.colorModeForRenderPass(), O = u.renderPass === "translucent" ? u.stencilConfigForOverlap(d) : [{}, d], k = O[0], R = 0, $ = O[1]; R < $.length; R += 1) {
            var W = $[R], H = h.getTile(W);
            H.needsHillshadePrepare && u.renderPass === "offscreen" ? Kv(u, H, c, w, Q.disabled, E) : u.renderPass === "translucent" && mh(u, H, c, w, k[W.overscaledZ], E);
          }
          _.viewport.set([0, 0, u.width, u.height]);
        }
      }, raster: function(u, h, c, d) {
        if (u.renderPass === "translucent" && c.paint.get("raster-opacity") !== 0 && d.length)
          for (var _ = u.context, w = _.gl, E = h.getSource(), O = u.useProgram("raster"), k = u.colorModeForRenderPass(), R = E instanceof pr ? [{}, d] : u.stencilConfigForOverlap(d), $ = R[0], W = R[1], H = W[W.length - 1].overscaledZ, ne = !u.options.moving, te = 0, ue = W; te < ue.length; te += 1) {
            var Y = ue[te], le = u.depthModeForSublayer(Y.overscaledZ - H, c.paint.get("raster-opacity") === 1 ? Z.ReadWrite : Z.ReadOnly, w.LESS), me = h.getTile(Y), xe = u.transform.calculatePosMatrix(Y.toUnwrapped(), ne);
            me.registerFadeDuration(c.paint.get("raster-fade-duration"));
            var Pe = h.findLoadedParent(Y, 0), Me = yh(me, Pe, h, c, u.transform), ke = void 0, je = void 0, it = c.paint.get("raster-resampling") === "nearest" ? w.NEAREST : w.LINEAR;
            _.activeTexture.set(w.TEXTURE0), me.texture.bind(it, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST), _.activeTexture.set(w.TEXTURE1), Pe ? (Pe.texture.bind(it, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST), ke = Math.pow(2, Pe.tileID.overscaledZ - me.tileID.overscaledZ), je = [me.tileID.canonical.x * ke % 1, me.tileID.canonical.y * ke % 1]) : me.texture.bind(it, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST);
            var tt = Xv(xe, je || [0, 0], ke || 1, Me, c);
            E instanceof pr ? O.draw(_, w.TRIANGLES, le, Q.disabled, k, de.disabled, tt, c.id, E.boundsBuffer, u.quadTriangleIndexBuffer, E.boundsSegments) : O.draw(_, w.TRIANGLES, le, $[Y.overscaledZ], k, de.disabled, tt, c.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments);
          }
      }, background: function(u, h, c) {
        var d = c.paint.get("background-color"), _ = c.paint.get("background-opacity");
        if (_ !== 0) {
          var w = u.context, E = w.gl, O = u.transform, k = O.tileSize, R = c.paint.get("background-pattern");
          if (!u.isPatternMissing(R)) {
            var $ = !R && d.a === 1 && _ === 1 && u.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (u.renderPass === $) {
              var W = Q.disabled, H = u.depthModeForSublayer(0, $ === "opaque" ? Z.ReadWrite : Z.ReadOnly), ne = u.colorModeForRenderPass(), te = u.useProgram(R ? "backgroundPattern" : "background"), ue = O.coveringTiles({ tileSize: k });
              R && (w.activeTexture.set(E.TEXTURE0), u.imageManager.bind(u.context));
              for (var Y = c.getCrossfadeParameters(), le = 0, me = ue; le < me.length; le += 1) {
                var xe = me[le], Pe = u.transform.calculatePosMatrix(xe.toUnwrapped()), Me = R ? eu(Pe, _, u, R, { tileID: xe, tileSize: k }, Y) : rc(Pe, _, d);
                te.draw(w, E.TRIANGLES, H, W, ne, de.disabled, Me, c.id, u.tileExtentBuffer, u.quadTriangleIndexBuffer, u.tileExtentSegments);
              }
            }
          }
        }
      }, debug: function(u, h, c) {
        for (var d = 0; d < c.length; d++)
          Dm(u, h, c[d]);
      }, custom: function(u, h, c) {
        var d = u.context, _ = c.implementation;
        if (u.renderPass === "offscreen") {
          var w = _.prerender;
          w && (u.setCustomLayerDefaults(), d.setColorMode(u.colorModeForRenderPass()), w.call(_, d.gl, u.transform.customLayerMatrix()), d.setDirty(), u.setBaseState());
        } else if (u.renderPass === "translucent") {
          u.setCustomLayerDefaults(), d.setColorMode(u.colorModeForRenderPass()), d.setStencilMode(Q.disabled);
          var E = _.renderingMode === "3d" ? new Z(u.context.gl.LEQUAL, Z.ReadWrite, u.depthRangeFor3D) : u.depthModeForSublayer(0, Z.ReadOnly);
          d.setDepthMode(E), _.render(d.gl, u.transform.customLayerMatrix()), d.setDirty(), u.setBaseState(), d.bindFramebuffer.set(null);
        }
      } }, yn = function(u, h) {
        this.context = new G(u), this.transform = h, this._tileTextures = {}, this.setup(), this.numSublayers = ie.maxUnderzooming + ie.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new ds(), this.gpuTimers = {};
      };
      yn.prototype.resize = function(u, h) {
        if (this.width = u * o.browser.devicePixelRatio, this.height = h * o.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
          for (var c = 0, d = this.style._order; c < d.length; c += 1)
            this.style._layers[d[c]].resize();
      }, yn.prototype.setup = function() {
        var u = this.context, h = new o.StructArrayLayout2i4();
        h.emplaceBack(0, 0), h.emplaceBack(o.EXTENT, 0), h.emplaceBack(0, o.EXTENT), h.emplaceBack(o.EXTENT, o.EXTENT), this.tileExtentBuffer = u.createVertexBuffer(h, jn.members), this.tileExtentSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
        var c = new o.StructArrayLayout2i4();
        c.emplaceBack(0, 0), c.emplaceBack(o.EXTENT, 0), c.emplaceBack(0, o.EXTENT), c.emplaceBack(o.EXTENT, o.EXTENT), this.debugBuffer = u.createVertexBuffer(c, jn.members), this.debugSegments = o.SegmentVector.simpleSegment(0, 0, 4, 5);
        var d = new o.StructArrayLayout4i8();
        d.emplaceBack(0, 0, 0, 0), d.emplaceBack(o.EXTENT, 0, o.EXTENT, 0), d.emplaceBack(0, o.EXTENT, 0, o.EXTENT), d.emplaceBack(o.EXTENT, o.EXTENT, o.EXTENT, o.EXTENT), this.rasterBoundsBuffer = u.createVertexBuffer(d, Nr.members), this.rasterBoundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
        var _ = new o.StructArrayLayout2i4();
        _.emplaceBack(0, 0), _.emplaceBack(1, 0), _.emplaceBack(0, 1), _.emplaceBack(1, 1), this.viewportBuffer = u.createVertexBuffer(_, jn.members), this.viewportSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
        var w = new o.StructArrayLayout1ui2();
        w.emplaceBack(0), w.emplaceBack(1), w.emplaceBack(3), w.emplaceBack(2), w.emplaceBack(0), this.tileBorderIndexBuffer = u.createIndexBuffer(w);
        var E = new o.StructArrayLayout3ui6();
        E.emplaceBack(0, 1, 2), E.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = u.createIndexBuffer(E), this.emptyTexture = new o.Texture(u, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, u.gl.RGBA);
        var O = this.context.gl;
        this.stencilClearMode = new Q({ func: O.ALWAYS, mask: 0 }, 0, 255, O.ZERO, O.ZERO, O.ZERO);
      }, yn.prototype.clearStencil = function() {
        var u = this.context, h = u.gl;
        this.nextStencilID = 1, this.currentStencilSource = void 0;
        var c = o.create();
        o.ortho(c, 0, this.width, this.height, 0, 0, 1), o.scale(c, c, [h.drawingBufferWidth, h.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(u, h.TRIANGLES, Z.disabled, this.stencilClearMode, pe.disabled, de.disabled, yl(c), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
      }, yn.prototype._renderTileClippingMasks = function(u, h) {
        if (this.currentStencilSource !== u.source && u.isTileClipped() && h && h.length) {
          this.currentStencilSource = u.source;
          var c = this.context, d = c.gl;
          this.nextStencilID + h.length > 256 && this.clearStencil(), c.setColorMode(pe.disabled), c.setDepthMode(Z.disabled);
          var _ = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (var w = 0, E = h; w < E.length; w += 1) {
            var O = E[w], k = this._tileClippingMaskIDs[O.key] = this.nextStencilID++;
            _.draw(c, d.TRIANGLES, Z.disabled, new Q({ func: d.ALWAYS, mask: 0 }, k, 255, d.KEEP, d.KEEP, d.REPLACE), pe.disabled, de.disabled, yl(O.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
      }, yn.prototype.stencilModeFor3D = function() {
        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
        var u = this.nextStencilID++, h = this.context.gl;
        return new Q({ func: h.NOTEQUAL, mask: 255 }, u, 255, h.KEEP, h.KEEP, h.REPLACE);
      }, yn.prototype.stencilModeForClipping = function(u) {
        var h = this.context.gl;
        return new Q({ func: h.EQUAL, mask: 255 }, this._tileClippingMaskIDs[u.key], 0, h.KEEP, h.KEEP, h.REPLACE);
      }, yn.prototype.stencilConfigForOverlap = function(u) {
        var h, c = this.context.gl, d = u.sort(function(k, R) {
          return R.overscaledZ - k.overscaledZ;
        }), _ = d[d.length - 1].overscaledZ, w = d[0].overscaledZ - _ + 1;
        if (w > 1) {
          this.currentStencilSource = void 0, this.nextStencilID + w > 256 && this.clearStencil();
          for (var E = {}, O = 0; O < w; O++)
            E[O + _] = new Q({ func: c.GEQUAL, mask: 255 }, O + this.nextStencilID, 255, c.KEEP, c.KEEP, c.REPLACE);
          return this.nextStencilID += w, [E, d];
        }
        return [(h = {}, h[_] = Q.disabled, h), d];
      }, yn.prototype.colorModeForRenderPass = function() {
        var u = this.context.gl;
        return this._showOverdrawInspector ? new pe([u.CONSTANT_COLOR, u.ONE], new o.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? pe.unblended : pe.alphaBlended;
      }, yn.prototype.depthModeForSublayer = function(u, h, c) {
        if (!this.opaquePassEnabledForLayer())
          return Z.disabled;
        var d = 1 - ((1 + this.currentLayer) * this.numSublayers + u) * this.depthEpsilon;
        return new Z(c || this.context.gl.LEQUAL, h, [d, d]);
      }, yn.prototype.opaquePassEnabledForLayer = function() {
        return this.currentLayer < this.opaquePassCutoff;
      }, yn.prototype.render = function(u, h) {
        var c = this;
        this.style = u, this.options = h, this.lineAtlas = u.lineAtlas, this.imageManager = u.imageManager, this.glyphManager = u.glyphManager, this.symbolFadeChange = u.placement.symbolFadeChange(o.browser.now()), this.imageManager.beginFrame();
        var d = this.style._order, _ = this.style.sourceCaches;
        for (var w in _) {
          var E = _[w];
          E.used && E.prepare(this.context);
        }
        var O, k, R = {}, $ = {}, W = {};
        for (var H in _) {
          var ne = _[H];
          R[H] = ne.getVisibleCoordinates(), $[H] = R[H].slice().reverse(), W[H] = ne.getVisibleCoordinates(!0).reverse();
        }
        this.opaquePassCutoff = 1 / 0;
        for (var te = 0; te < d.length; te++)
          if (this.style._layers[d[te]].is3D()) {
            this.opaquePassCutoff = te;
            break;
          }
        this.renderPass = "offscreen";
        for (var ue = 0, Y = d; ue < Y.length; ue += 1) {
          var le = this.style._layers[Y[ue]];
          if (le.hasOffscreenPass() && !le.isHidden(this.transform.zoom)) {
            var me = $[le.source];
            (le.type === "custom" || me.length) && this.renderLayer(this, _[le.source], le, me);
          }
        }
        for (this.context.bindFramebuffer.set(null), this.context.clear({ color: h.showOverdrawInspector ? o.Color.black : o.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = h.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (u._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
          var xe = this.style._layers[d[this.currentLayer]], Pe = _[xe.source], Me = R[xe.source];
          this._renderTileClippingMasks(xe, Me), this.renderLayer(this, Pe, xe, Me);
        }
        for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
          var ke = this.style._layers[d[this.currentLayer]], je = _[ke.source], it = (ke.type === "symbol" ? W : $)[ke.source];
          this._renderTileClippingMasks(ke, R[ke.source]), this.renderLayer(this, je, ke, it);
        }
        this.options.showTileBoundaries && (o.values(this.style._layers).forEach(function(tt) {
          tt.source && !tt.isHidden(c.transform.zoom) && (tt.source !== (k && k.id) && (k = c.style.sourceCaches[tt.source]), (!O || O.getSource().maxzoom < k.getSource().maxzoom) && (O = k));
        }), O && vl.debug(this, O, O.getVisibleCoordinates())), this.options.showPadding && function(tt) {
          var gt = tt.transform.padding;
          ip(tt, tt.transform.height - (gt.top || 0), 3, rp), ip(tt, gt.bottom || 0, 3, km), op(tt, gt.left || 0, 3, Lm), op(tt, tt.transform.width - (gt.right || 0), 3, gh);
          var Nt = tt.transform.centerPoint;
          (function(Bt, Ft, Ir, xt) {
            ic(Bt, Ft - 1, Ir - 10, 2, 20, xt), ic(Bt, Ft - 10, Ir - 1, 20, 2, xt);
          })(tt, Nt.x, tt.transform.height - Nt.y, np);
        }(this), this.context.setDefault();
      }, yn.prototype.renderLayer = function(u, h, c, d) {
        c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "custom" || d.length) && (this.id = c.id, this.gpuTimingStart(c), vl[c.type](u, h, c, d, this.style.placement.variableOffsets), this.gpuTimingEnd());
      }, yn.prototype.gpuTimingStart = function(u) {
        if (this.options.gpuTiming) {
          var h = this.context.extTimerQuery, c = this.gpuTimers[u.id];
          c || (c = this.gpuTimers[u.id] = { calls: 0, cpuTime: 0, query: h.createQueryEXT() }), c.calls++, h.beginQueryEXT(h.TIME_ELAPSED_EXT, c.query);
        }
      }, yn.prototype.gpuTimingEnd = function() {
        if (this.options.gpuTiming) {
          var u = this.context.extTimerQuery;
          u.endQueryEXT(u.TIME_ELAPSED_EXT);
        }
      }, yn.prototype.collectGpuTimers = function() {
        var u = this.gpuTimers;
        return this.gpuTimers = {}, u;
      }, yn.prototype.queryGpuTimers = function(u) {
        var h = {};
        for (var c in u) {
          var d = u[c], _ = this.context.extTimerQuery, w = _.getQueryObjectEXT(d.query, _.QUERY_RESULT_EXT) / 1e6;
          _.deleteQueryEXT(d.query), h[c] = w;
        }
        return h;
      }, yn.prototype.translatePosMatrix = function(u, h, c, d, _) {
        if (!c[0] && !c[1])
          return u;
        var w = _ ? d === "map" ? this.transform.angle : 0 : d === "viewport" ? -this.transform.angle : 0;
        if (w) {
          var E = Math.sin(w), O = Math.cos(w);
          c = [c[0] * O - c[1] * E, c[0] * E + c[1] * O];
        }
        var k = [_ ? c[0] : mn(h, c[0], this.transform.zoom), _ ? c[1] : mn(h, c[1], this.transform.zoom), 0], R = new Float32Array(16);
        return o.translate(R, u, k), R;
      }, yn.prototype.saveTileTexture = function(u) {
        var h = this._tileTextures[u.size[0]];
        h ? h.push(u) : this._tileTextures[u.size[0]] = [u];
      }, yn.prototype.getTileTexture = function(u) {
        var h = this._tileTextures[u];
        return h && h.length > 0 ? h.pop() : null;
      }, yn.prototype.isPatternMissing = function(u) {
        if (!u)
          return !1;
        if (!u.from || !u.to)
          return !0;
        var h = this.imageManager.getPattern(u.from.toString()), c = this.imageManager.getPattern(u.to.toString());
        return !h || !c;
      }, yn.prototype.useProgram = function(u, h) {
        this.cache = this.cache || {};
        var c = "" + u + (h ? h.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "");
        return this.cache[c] || (this.cache[c] = new _m(this.context, u, Hv[u], h, Om[u], this._showOverdrawInspector)), this.cache[c];
      }, yn.prototype.setCustomLayerDefaults = function() {
        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
      }, yn.prototype.setBaseState = function() {
        var u = this.context.gl;
        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(u.FUNC_ADD);
      }, yn.prototype.initDebugOverlayCanvas = function() {
        this.debugOverlayCanvas == null && (this.debugOverlayCanvas = o.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new o.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
      }, yn.prototype.destroy = function() {
        this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
      };
      var vh = function(u, h) {
        this.points = u, this.planes = h;
      };
      vh.fromInvProjectionMatrix = function(u, h, c) {
        var d = Math.pow(2, c), _ = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(function(E) {
          return o.transformMat4([], E, u);
        }).map(function(E) {
          return o.scale$1([], E, 1 / E[3] / h * d);
        }), w = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(function(E) {
          var O = o.sub([], _[E[0]], _[E[1]]), k = o.sub([], _[E[2]], _[E[1]]), R = o.normalize([], o.cross([], O, k)), $ = -o.dot(R, _[E[1]]);
          return R.concat($);
        });
        return new vh(_, w);
      };
      var _l = function(u, h) {
        this.min = u, this.max = h, this.center = o.scale$2([], o.add([], this.min, this.max), 0.5);
      };
      _l.prototype.quadrant = function(u) {
        for (var h = [u % 2 == 0, u < 2], c = o.clone$2(this.min), d = o.clone$2(this.max), _ = 0; _ < h.length; _++)
          c[_] = h[_] ? this.min[_] : this.center[_], d[_] = h[_] ? this.center[_] : this.max[_];
        return d[2] = this.max[2], new _l(c, d);
      }, _l.prototype.distanceX = function(u) {
        return Math.max(Math.min(this.max[0], u[0]), this.min[0]) - u[0];
      }, _l.prototype.distanceY = function(u) {
        return Math.max(Math.min(this.max[1], u[1]), this.min[1]) - u[1];
      }, _l.prototype.intersects = function(u) {
        for (var h = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], c = !0, d = 0; d < u.planes.length; d++) {
          for (var _ = u.planes[d], w = 0, E = 0; E < h.length; E++)
            w += o.dot$1(_, h[E]) >= 0;
          if (w === 0)
            return 0;
          w !== h.length && (c = !1);
        }
        if (c)
          return 2;
        for (var O = 0; O < 3; O++) {
          for (var k = Number.MAX_VALUE, R = -Number.MAX_VALUE, $ = 0; $ < u.points.length; $++) {
            var W = u.points[$][O] - this.min[O];
            k = Math.min(k, W), R = Math.max(R, W);
          }
          if (R < 0 || k > this.max[O] - this.min[O])
            return 0;
        }
        return 1;
      };
      var ws = function(u, h, c, d) {
        if (u === void 0 && (u = 0), h === void 0 && (h = 0), c === void 0 && (c = 0), d === void 0 && (d = 0), isNaN(u) || u < 0 || isNaN(h) || h < 0 || isNaN(c) || c < 0 || isNaN(d) || d < 0)
          throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
        this.top = u, this.bottom = h, this.left = c, this.right = d;
      };
      ws.prototype.interpolate = function(u, h, c) {
        return h.top != null && u.top != null && (this.top = o.number(u.top, h.top, c)), h.bottom != null && u.bottom != null && (this.bottom = o.number(u.bottom, h.bottom, c)), h.left != null && u.left != null && (this.left = o.number(u.left, h.left, c)), h.right != null && u.right != null && (this.right = o.number(u.right, h.right, c)), this;
      }, ws.prototype.getCenter = function(u, h) {
        var c = o.clamp((this.left + u - this.right) / 2, 0, u), d = o.clamp((this.top + h - this.bottom) / 2, 0, h);
        return new o.Point(c, d);
      }, ws.prototype.equals = function(u) {
        return this.top === u.top && this.bottom === u.bottom && this.left === u.left && this.right === u.right;
      }, ws.prototype.clone = function() {
        return new ws(this.top, this.bottom, this.left, this.right);
      }, ws.prototype.toJSON = function() {
        return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
      };
      var xr = function(u, h, c, d, _) {
        this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = _ === void 0 || _, this._minZoom = u || 0, this._maxZoom = h || 22, this._minPitch = c == null ? 0 : c, this._maxPitch = d == null ? 60 : d, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new o.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new ws(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
      }, en = { minZoom: { configurable: !0 }, maxZoom: { configurable: !0 }, minPitch: { configurable: !0 }, maxPitch: { configurable: !0 }, renderWorldCopies: { configurable: !0 }, worldSize: { configurable: !0 }, centerOffset: { configurable: !0 }, size: { configurable: !0 }, bearing: { configurable: !0 }, pitch: { configurable: !0 }, fov: { configurable: !0 }, zoom: { configurable: !0 }, center: { configurable: !0 }, padding: { configurable: !0 }, centerPoint: { configurable: !0 }, unmodified: { configurable: !0 }, point: { configurable: !0 } };
      xr.prototype.clone = function() {
        var u = new xr(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
        return u.tileSize = this.tileSize, u.latRange = this.latRange, u.width = this.width, u.height = this.height, u._center = this._center, u.zoom = this.zoom, u.angle = this.angle, u._fov = this._fov, u._pitch = this._pitch, u._unmodified = this._unmodified, u._edgeInsets = this._edgeInsets.clone(), u._calcMatrices(), u;
      }, en.minZoom.get = function() {
        return this._minZoom;
      }, en.minZoom.set = function(u) {
        this._minZoom !== u && (this._minZoom = u, this.zoom = Math.max(this.zoom, u));
      }, en.maxZoom.get = function() {
        return this._maxZoom;
      }, en.maxZoom.set = function(u) {
        this._maxZoom !== u && (this._maxZoom = u, this.zoom = Math.min(this.zoom, u));
      }, en.minPitch.get = function() {
        return this._minPitch;
      }, en.minPitch.set = function(u) {
        this._minPitch !== u && (this._minPitch = u, this.pitch = Math.max(this.pitch, u));
      }, en.maxPitch.get = function() {
        return this._maxPitch;
      }, en.maxPitch.set = function(u) {
        this._maxPitch !== u && (this._maxPitch = u, this.pitch = Math.min(this.pitch, u));
      }, en.renderWorldCopies.get = function() {
        return this._renderWorldCopies;
      }, en.renderWorldCopies.set = function(u) {
        u === void 0 ? u = !0 : u === null && (u = !1), this._renderWorldCopies = u;
      }, en.worldSize.get = function() {
        return this.tileSize * this.scale;
      }, en.centerOffset.get = function() {
        return this.centerPoint._sub(this.size._div(2));
      }, en.size.get = function() {
        return new o.Point(this.width, this.height);
      }, en.bearing.get = function() {
        return -this.angle / Math.PI * 180;
      }, en.bearing.set = function(u) {
        var h = -o.wrap(u, -180, 180) * Math.PI / 180;
        this.angle !== h && (this._unmodified = !1, this.angle = h, this._calcMatrices(), this.rotationMatrix = o.create$2(), o.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
      }, en.pitch.get = function() {
        return this._pitch / Math.PI * 180;
      }, en.pitch.set = function(u) {
        var h = o.clamp(u, this.minPitch, this.maxPitch) / 180 * Math.PI;
        this._pitch !== h && (this._unmodified = !1, this._pitch = h, this._calcMatrices());
      }, en.fov.get = function() {
        return this._fov / Math.PI * 180;
      }, en.fov.set = function(u) {
        u = Math.max(0.01, Math.min(60, u)), this._fov !== u && (this._unmodified = !1, this._fov = u / 180 * Math.PI, this._calcMatrices());
      }, en.zoom.get = function() {
        return this._zoom;
      }, en.zoom.set = function(u) {
        var h = Math.min(Math.max(u, this.minZoom), this.maxZoom);
        this._zoom !== h && (this._unmodified = !1, this._zoom = h, this.scale = this.zoomScale(h), this.tileZoom = Math.floor(h), this.zoomFraction = h - this.tileZoom, this._constrain(), this._calcMatrices());
      }, en.center.get = function() {
        return this._center;
      }, en.center.set = function(u) {
        u.lat === this._center.lat && u.lng === this._center.lng || (this._unmodified = !1, this._center = u, this._constrain(), this._calcMatrices());
      }, en.padding.get = function() {
        return this._edgeInsets.toJSON();
      }, en.padding.set = function(u) {
        this._edgeInsets.equals(u) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, u, 1), this._calcMatrices());
      }, en.centerPoint.get = function() {
        return this._edgeInsets.getCenter(this.width, this.height);
      }, xr.prototype.isPaddingEqual = function(u) {
        return this._edgeInsets.equals(u);
      }, xr.prototype.interpolatePadding = function(u, h, c) {
        this._unmodified = !1, this._edgeInsets.interpolate(u, h, c), this._constrain(), this._calcMatrices();
      }, xr.prototype.coveringZoomLevel = function(u) {
        var h = (u.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / u.tileSize));
        return Math.max(0, h);
      }, xr.prototype.getVisibleUnwrappedCoordinates = function(u) {
        var h = [new o.UnwrappedTileID(0, u)];
        if (this._renderWorldCopies)
          for (var c = this.pointCoordinate(new o.Point(0, 0)), d = this.pointCoordinate(new o.Point(this.width, 0)), _ = this.pointCoordinate(new o.Point(this.width, this.height)), w = this.pointCoordinate(new o.Point(0, this.height)), E = Math.floor(Math.min(c.x, d.x, _.x, w.x)), O = Math.floor(Math.max(c.x, d.x, _.x, w.x)), k = E - 1; k <= O + 1; k++)
            k !== 0 && h.push(new o.UnwrappedTileID(k, u));
        return h;
      }, xr.prototype.coveringTiles = function(u) {
        var h = this.coveringZoomLevel(u), c = h;
        if (u.minzoom !== void 0 && h < u.minzoom)
          return [];
        u.maxzoom !== void 0 && h > u.maxzoom && (h = u.maxzoom);
        var d = o.MercatorCoordinate.fromLngLat(this.center), _ = Math.pow(2, h), w = [_ * d.x, _ * d.y, 0], E = vh.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, h), O = u.minzoom || 0;
        this.pitch <= 60 && this._edgeInsets.top < 0.1 && (O = h);
        var k = function(tt) {
          return { aabb: new _l([tt * _, 0, 0], [(tt + 1) * _, _, 0]), zoom: 0, x: 0, y: 0, wrap: tt, fullyVisible: !1 };
        }, R = [], $ = [], W = h, H = u.reparseOverscaled ? c : h;
        if (this._renderWorldCopies)
          for (var ne = 1; ne <= 3; ne++)
            R.push(k(-ne)), R.push(k(ne));
        for (R.push(k(0)); R.length > 0; ) {
          var te = R.pop(), ue = te.x, Y = te.y, le = te.fullyVisible;
          if (!le) {
            var me = te.aabb.intersects(E);
            if (me === 0)
              continue;
            le = me === 2;
          }
          var xe = te.aabb.distanceX(w), Pe = te.aabb.distanceY(w), Me = Math.max(Math.abs(xe), Math.abs(Pe));
          if (te.zoom === W || Me > 3 + (1 << W - te.zoom) - 2 && te.zoom >= O)
            $.push({ tileID: new o.OverscaledTileID(te.zoom === W ? H : te.zoom, te.wrap, te.zoom, ue, Y), distanceSq: o.sqrLen([w[0] - 0.5 - ue, w[1] - 0.5 - Y]) });
          else
            for (var ke = 0; ke < 4; ke++) {
              var je = (ue << 1) + ke % 2, it = (Y << 1) + (ke >> 1);
              R.push({ aabb: te.aabb.quadrant(ke), zoom: te.zoom + 1, x: je, y: it, wrap: te.wrap, fullyVisible: le });
            }
        }
        return $.sort(function(tt, gt) {
          return tt.distanceSq - gt.distanceSq;
        }).map(function(tt) {
          return tt.tileID;
        });
      }, xr.prototype.resize = function(u, h) {
        this.width = u, this.height = h, this.pixelsToGLUnits = [2 / u, -2 / h], this._constrain(), this._calcMatrices();
      }, en.unmodified.get = function() {
        return this._unmodified;
      }, xr.prototype.zoomScale = function(u) {
        return Math.pow(2, u);
      }, xr.prototype.scaleZoom = function(u) {
        return Math.log(u) / Math.LN2;
      }, xr.prototype.project = function(u) {
        var h = o.clamp(u.lat, -this.maxValidLatitude, this.maxValidLatitude);
        return new o.Point(o.mercatorXfromLng(u.lng) * this.worldSize, o.mercatorYfromLat(h) * this.worldSize);
      }, xr.prototype.unproject = function(u) {
        return new o.MercatorCoordinate(u.x / this.worldSize, u.y / this.worldSize).toLngLat();
      }, en.point.get = function() {
        return this.project(this.center);
      }, xr.prototype.setLocationAtPoint = function(u, h) {
        var c = this.pointCoordinate(h), d = this.pointCoordinate(this.centerPoint), _ = this.locationCoordinate(u), w = new o.MercatorCoordinate(_.x - (c.x - d.x), _.y - (c.y - d.y));
        this.center = this.coordinateLocation(w), this._renderWorldCopies && (this.center = this.center.wrap());
      }, xr.prototype.locationPoint = function(u) {
        return this.coordinatePoint(this.locationCoordinate(u));
      }, xr.prototype.pointLocation = function(u) {
        return this.coordinateLocation(this.pointCoordinate(u));
      }, xr.prototype.locationCoordinate = function(u) {
        return o.MercatorCoordinate.fromLngLat(u);
      }, xr.prototype.coordinateLocation = function(u) {
        return u.toLngLat();
      }, xr.prototype.pointCoordinate = function(u) {
        var h = [u.x, u.y, 0, 1], c = [u.x, u.y, 1, 1];
        o.transformMat4(h, h, this.pixelMatrixInverse), o.transformMat4(c, c, this.pixelMatrixInverse);
        var d = h[3], _ = c[3], w = h[1] / d, E = c[1] / _, O = h[2] / d, k = c[2] / _, R = O === k ? 0 : (0 - O) / (k - O);
        return new o.MercatorCoordinate(o.number(h[0] / d, c[0] / _, R) / this.worldSize, o.number(w, E, R) / this.worldSize);
      }, xr.prototype.coordinatePoint = function(u) {
        var h = [u.x * this.worldSize, u.y * this.worldSize, 0, 1];
        return o.transformMat4(h, h, this.pixelMatrix), new o.Point(h[0] / h[3], h[1] / h[3]);
      }, xr.prototype.getBounds = function() {
        return new o.LngLatBounds().extend(this.pointLocation(new o.Point(0, 0))).extend(this.pointLocation(new o.Point(this.width, 0))).extend(this.pointLocation(new o.Point(this.width, this.height))).extend(this.pointLocation(new o.Point(0, this.height)));
      }, xr.prototype.getMaxBounds = function() {
        return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new o.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
      }, xr.prototype.setMaxBounds = function(u) {
        u ? (this.lngRange = [u.getWest(), u.getEast()], this.latRange = [u.getSouth(), u.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
      }, xr.prototype.calculatePosMatrix = function(u, h) {
        h === void 0 && (h = !1);
        var c = u.key, d = h ? this._alignedPosMatrixCache : this._posMatrixCache;
        if (d[c])
          return d[c];
        var _ = u.canonical, w = this.worldSize / this.zoomScale(_.z), E = _.x + Math.pow(2, _.z) * u.wrap, O = o.identity(new Float64Array(16));
        return o.translate(O, O, [E * w, _.y * w, 0]), o.scale(O, O, [w / o.EXTENT, w / o.EXTENT, 1]), o.multiply(O, h ? this.alignedProjMatrix : this.projMatrix, O), d[c] = new Float32Array(O), d[c];
      }, xr.prototype.customLayerMatrix = function() {
        return this.mercatorMatrix.slice();
      }, xr.prototype._constrain = function() {
        if (this.center && this.width && this.height && !this._constraining) {
          this._constraining = !0;
          var u, h, c, d, _ = -90, w = 90, E = -180, O = 180, k = this.size, R = this._unmodified;
          if (this.latRange) {
            var $ = this.latRange;
            _ = o.mercatorYfromLat($[1]) * this.worldSize, u = (w = o.mercatorYfromLat($[0]) * this.worldSize) - _ < k.y ? k.y / (w - _) : 0;
          }
          if (this.lngRange) {
            var W = this.lngRange;
            E = o.mercatorXfromLng(W[0]) * this.worldSize, h = (O = o.mercatorXfromLng(W[1]) * this.worldSize) - E < k.x ? k.x / (O - E) : 0;
          }
          var H = this.point, ne = Math.max(h || 0, u || 0);
          if (ne)
            return this.center = this.unproject(new o.Point(h ? (O + E) / 2 : H.x, u ? (w + _) / 2 : H.y)), this.zoom += this.scaleZoom(ne), this._unmodified = R, void (this._constraining = !1);
          if (this.latRange) {
            var te = H.y, ue = k.y / 2;
            te - ue < _ && (d = _ + ue), te + ue > w && (d = w - ue);
          }
          if (this.lngRange) {
            var Y = H.x, le = k.x / 2;
            Y - le < E && (c = E + le), Y + le > O && (c = O - le);
          }
          c === void 0 && d === void 0 || (this.center = this.unproject(new o.Point(c !== void 0 ? c : H.x, d !== void 0 ? d : H.y))), this._unmodified = R, this._constraining = !1;
        }
      }, xr.prototype._calcMatrices = function() {
        if (this.height) {
          var u = this.centerOffset;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
          var h = Math.PI / 2 + this._pitch, c = this._fov * (0.5 + u.y / this.height), d = Math.sin(c) * this.cameraToCenterDistance / Math.sin(o.clamp(Math.PI - h - c, 0.01, Math.PI - 0.01)), _ = this.point, w = _.x, E = _.y, O = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * d + this.cameraToCenterDistance), k = this.height / 50, R = new Float64Array(16);
          o.perspective(R, this._fov, this.width / this.height, k, O), R[8] = 2 * -u.x / this.width, R[9] = 2 * u.y / this.height, o.scale(R, R, [1, -1, 1]), o.translate(R, R, [0, 0, -this.cameraToCenterDistance]), o.rotateX(R, R, this._pitch), o.rotateZ(R, R, this.angle), o.translate(R, R, [-w, -E, 0]), this.mercatorMatrix = o.scale([], R, [this.worldSize, this.worldSize, this.worldSize]), o.scale(R, R, [1, 1, o.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = R, this.invProjMatrix = o.invert([], this.projMatrix);
          var $ = this.width % 2 / 2, W = this.height % 2 / 2, H = Math.cos(this.angle), ne = Math.sin(this.angle), te = w - Math.round(w) + H * $ + ne * W, ue = E - Math.round(E) + H * W + ne * $, Y = new Float64Array(R);
          if (o.translate(Y, Y, [te > 0.5 ? te - 1 : te, ue > 0.5 ? ue - 1 : ue, 0]), this.alignedProjMatrix = Y, R = o.create(), o.scale(R, R, [this.width / 2, -this.height / 2, 1]), o.translate(R, R, [1, -1, 0]), this.labelPlaneMatrix = R, R = o.create(), o.scale(R, R, [1, -1, 1]), o.translate(R, R, [-1, -1, 0]), o.scale(R, R, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = R, this.pixelMatrix = o.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(R = o.invert(new Float64Array(16), this.pixelMatrix)))
            throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = R, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }
      }, xr.prototype.maxPitchScaleFactor = function() {
        if (!this.pixelMatrixInverse)
          return 1;
        var u = this.pointCoordinate(new o.Point(0, 0)), h = [u.x * this.worldSize, u.y * this.worldSize, 0, 1];
        return o.transformMat4(h, h, this.pixelMatrix)[3] / this.cameraToCenterDistance;
      }, xr.prototype.getCameraPoint = function() {
        var u = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
        return this.centerPoint.add(new o.Point(0, u));
      }, xr.prototype.getCameraQueryGeometry = function(u) {
        var h = this.getCameraPoint();
        if (u.length === 1)
          return [u[0], h];
        for (var c = h.x, d = h.y, _ = h.x, w = h.y, E = 0, O = u; E < O.length; E += 1) {
          var k = O[E];
          c = Math.min(c, k.x), d = Math.min(d, k.y), _ = Math.max(_, k.x), w = Math.max(w, k.y);
        }
        return [new o.Point(c, d), new o.Point(_, d), new o.Point(_, w), new o.Point(c, w), new o.Point(c, d)];
      }, Object.defineProperties(xr.prototype, en);
      var Mo = function(u) {
        var h, c, d, _;
        this._hashName = u && encodeURIComponent(u), o.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (h = this._updateHashUnthrottled.bind(this), c = !1, d = null, _ = function() {
          d = null, c && (h(), d = setTimeout(_, 300), c = !1);
        }, function() {
          return c = !0, d || _(), d;
        });
      };
      Mo.prototype.addTo = function(u) {
        return this._map = u, o.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
      }, Mo.prototype.remove = function() {
        return o.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
      }, Mo.prototype.getHashString = function(u) {
        var h = this._map.getCenter(), c = Math.round(100 * this._map.getZoom()) / 100, d = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), _ = Math.pow(10, d), w = Math.round(h.lng * _) / _, E = Math.round(h.lat * _) / _, O = this._map.getBearing(), k = this._map.getPitch(), R = "";
        if (R += u ? "/" + w + "/" + E + "/" + c : c + "/" + E + "/" + w, (O || k) && (R += "/" + Math.round(10 * O) / 10), k && (R += "/" + Math.round(k)), this._hashName) {
          var $ = this._hashName, W = !1, H = o.window.location.hash.slice(1).split("&").map(function(ne) {
            var te = ne.split("=")[0];
            return te === $ ? (W = !0, te + "=" + R) : ne;
          }).filter(function(ne) {
            return ne;
          });
          return W || H.push($ + "=" + R), "#" + H.join("&");
        }
        return "#" + R;
      }, Mo.prototype._getCurrentHash = function() {
        var u, h = this, c = o.window.location.hash.replace("#", "");
        return this._hashName ? (c.split("&").map(function(d) {
          return d.split("=");
        }).forEach(function(d) {
          d[0] === h._hashName && (u = d);
        }), (u && u[1] || "").split("/")) : c.split("/");
      }, Mo.prototype._onHashChange = function() {
        var u = this._getCurrentHash();
        if (u.length >= 3 && !u.some(function(c) {
          return isNaN(c);
        })) {
          var h = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(u[3] || 0) : this._map.getBearing();
          return this._map.jumpTo({ center: [+u[2], +u[1]], zoom: +u[0], bearing: h, pitch: +(u[4] || 0) }), !0;
        }
        return !1;
      }, Mo.prototype._updateHashUnthrottled = function() {
        var u = o.window.location.href.replace(/(#.+)?$/, this.getHashString());
        try {
          o.window.history.replaceState(o.window.history.state, null, u);
        } catch {
        }
      };
      var oc = { linearity: 0.3, easing: o.bezier(0, 0, 0.3, 1) }, ru = o.extend({ deceleration: 2500, maxSpeed: 1400 }, oc), ac = o.extend({ deceleration: 20, maxSpeed: 1400 }, oc), Yv = o.extend({ deceleration: 1e3, maxSpeed: 360 }, oc), Jv = o.extend({ deceleration: 1e3, maxSpeed: 90 }, oc), sc = function(u) {
        this._map = u, this.clear();
      };
      function lc(u, h) {
        (!u.duration || u.duration < h.duration) && (u.duration = h.duration, u.easing = h.easing);
      }
      function Ua(u, h, c) {
        var d = c.maxSpeed, _ = c.linearity, w = c.deceleration, E = o.clamp(u * _ / (h / 1e3), -d, d), O = Math.abs(E) / (w * _);
        return { easing: c.easing, duration: 1e3 * O, amount: E * (O / 2) };
      }
      sc.prototype.clear = function() {
        this._inertiaBuffer = [];
      }, sc.prototype.record = function(u) {
        this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: o.browser.now(), settings: u });
      }, sc.prototype._drainInertiaBuffer = function() {
        for (var u = this._inertiaBuffer, h = o.browser.now(); u.length > 0 && h - u[0].time > 160; )
          u.shift();
      }, sc.prototype._onMoveEnd = function(u) {
        if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {
          for (var h = { zoom: 0, bearing: 0, pitch: 0, pan: new o.Point(0, 0), pinchAround: void 0, around: void 0 }, c = 0, d = this._inertiaBuffer; c < d.length; c += 1) {
            var _ = d[c].settings;
            h.zoom += _.zoomDelta || 0, h.bearing += _.bearingDelta || 0, h.pitch += _.pitchDelta || 0, _.panDelta && h.pan._add(_.panDelta), _.around && (h.around = _.around), _.pinchAround && (h.pinchAround = _.pinchAround);
          }
          var w = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, E = {};
          if (h.pan.mag()) {
            var O = Ua(h.pan.mag(), w, o.extend({}, ru, u || {}));
            E.offset = h.pan.mult(O.amount / h.pan.mag()), E.center = this._map.transform.center, lc(E, O);
          }
          if (h.zoom) {
            var k = Ua(h.zoom, w, ac);
            E.zoom = this._map.transform.zoom + k.amount, lc(E, k);
          }
          if (h.bearing) {
            var R = Ua(h.bearing, w, Yv);
            E.bearing = this._map.transform.bearing + o.clamp(R.amount, -179, 179), lc(E, R);
          }
          if (h.pitch) {
            var $ = Ua(h.pitch, w, Jv);
            E.pitch = this._map.transform.pitch + $.amount, lc(E, $);
          }
          if (E.zoom || E.bearing) {
            var W = h.pinchAround === void 0 ? h.around : h.pinchAround;
            E.around = W ? this._map.unproject(W) : this._map.getCenter();
          }
          return this.clear(), o.extend(E, { noMoveStart: !0 });
        }
      };
      var Jn = function(u) {
        function h(d, _, w, E) {
          E === void 0 && (E = {});
          var O = g.mousePos(_.getCanvasContainer(), w), k = _.unproject(O);
          u.call(this, d, o.extend({ point: O, lngLat: k, originalEvent: w }, E)), this._defaultPrevented = !1, this.target = _;
        }
        u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h;
        var c = { defaultPrevented: { configurable: !0 } };
        return h.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(h.prototype, c), h;
      }(o.Event), uc = function(u) {
        function h(d, _, w) {
          var E = d === "touchend" ? w.changedTouches : w.touches, O = g.touchPos(_.getCanvasContainer(), E), k = O.map(function(W) {
            return _.unproject(W);
          }), R = O.reduce(function(W, H, ne, te) {
            return W.add(H.div(te.length));
          }, new o.Point(0, 0)), $ = _.unproject(R);
          u.call(this, d, { points: O, point: R, lngLats: k, lngLat: $, originalEvent: w }), this._defaultPrevented = !1;
        }
        u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h;
        var c = { defaultPrevented: { configurable: !0 } };
        return h.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(h.prototype, c), h;
      }(o.Event), Nm = function(u) {
        function h(d, _, w) {
          u.call(this, d, { originalEvent: w }), this._defaultPrevented = !1;
        }
        u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h;
        var c = { defaultPrevented: { configurable: !0 } };
        return h.prototype.preventDefault = function() {
          this._defaultPrevented = !0;
        }, c.defaultPrevented.get = function() {
          return this._defaultPrevented;
        }, Object.defineProperties(h.prototype, c), h;
      }(o.Event), Gn = function(u, h) {
        this._map = u, this._clickTolerance = h.clickTolerance;
      };
      Gn.prototype.reset = function() {
        delete this._mousedownPos;
      }, Gn.prototype.wheel = function(u) {
        return this._firePreventable(new Nm(u.type, this._map, u));
      }, Gn.prototype.mousedown = function(u, h) {
        return this._mousedownPos = h, this._firePreventable(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseup = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.click = function(u, h) {
        this._mousedownPos && this._mousedownPos.dist(h) >= this._clickTolerance || this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.dblclick = function(u) {
        return this._firePreventable(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseover = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.mouseout = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, Gn.prototype.touchstart = function(u) {
        return this._firePreventable(new uc(u.type, this._map, u));
      }, Gn.prototype.touchmove = function(u) {
        this._map.fire(new uc(u.type, this._map, u));
      }, Gn.prototype.touchend = function(u) {
        this._map.fire(new uc(u.type, this._map, u));
      }, Gn.prototype.touchcancel = function(u) {
        this._map.fire(new uc(u.type, this._map, u));
      }, Gn.prototype._firePreventable = function(u) {
        if (this._map.fire(u), u.defaultPrevented)
          return {};
      }, Gn.prototype.isEnabled = function() {
        return !0;
      }, Gn.prototype.isActive = function() {
        return !1;
      }, Gn.prototype.enable = function() {
      }, Gn.prototype.disable = function() {
      };
      var wt = function(u) {
        this._map = u;
      };
      wt.prototype.reset = function() {
        this._delayContextMenu = !1, delete this._contextMenuEvent;
      }, wt.prototype.mousemove = function(u) {
        this._map.fire(new Jn(u.type, this._map, u));
      }, wt.prototype.mousedown = function() {
        this._delayContextMenu = !0;
      }, wt.prototype.mouseup = function() {
        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Jn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
      }, wt.prototype.contextmenu = function(u) {
        this._delayContextMenu ? this._contextMenuEvent = u : this._map.fire(new Jn(u.type, this._map, u)), this._map.listens("contextmenu") && u.preventDefault();
      }, wt.prototype.isEnabled = function() {
        return !0;
      }, wt.prototype.isActive = function() {
        return !1;
      }, wt.prototype.enable = function() {
      }, wt.prototype.disable = function() {
      };
      var uo = function(u, h) {
        this._map = u, this._el = u.getCanvasContainer(), this._container = u.getContainer(), this._clickTolerance = h.clickTolerance || 1;
      };
      function _h(u, h) {
        for (var c = {}, d = 0; d < u.length; d++)
          c[u[d].identifier] = h[d];
        return c;
      }
      uo.prototype.isEnabled = function() {
        return !!this._enabled;
      }, uo.prototype.isActive = function() {
        return !!this._active;
      }, uo.prototype.enable = function() {
        this.isEnabled() || (this._enabled = !0);
      }, uo.prototype.disable = function() {
        this.isEnabled() && (this._enabled = !1);
      }, uo.prototype.mousedown = function(u, h) {
        this.isEnabled() && u.shiftKey && u.button === 0 && (g.disableDrag(), this._startPos = this._lastPos = h, this._active = !0);
      }, uo.prototype.mousemoveWindow = function(u, h) {
        if (this._active) {
          var c = h;
          if (!(this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance)) {
            var d = this._startPos;
            this._lastPos = c, this._box || (this._box = g.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", u));
            var _ = Math.min(d.x, c.x), w = Math.max(d.x, c.x), E = Math.min(d.y, c.y), O = Math.max(d.y, c.y);
            g.setTransform(this._box, "translate(" + _ + "px," + E + "px)"), this._box.style.width = w - _ + "px", this._box.style.height = O - E + "px";
          }
        }
      }, uo.prototype.mouseupWindow = function(u, h) {
        var c = this;
        if (this._active && u.button === 0) {
          var d = this._startPos, _ = h;
          if (this.reset(), g.suppressClick(), d.x !== _.x || d.y !== _.y)
            return this._map.fire(new o.Event("boxzoomend", { originalEvent: u })), { cameraAnimation: function(w) {
              return w.fitScreenCoordinates(d, _, c._map.getBearing(), { linear: !0 });
            } };
          this._fireEvent("boxzoomcancel", u);
        }
      }, uo.prototype.keydown = function(u) {
        this._active && u.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", u));
      }, uo.prototype.blur = function() {
        this.reset();
      }, uo.prototype.reset = function() {
        this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (g.remove(this._box), this._box = null), g.enableDrag(), delete this._startPos, delete this._lastPos;
      }, uo.prototype._fireEvent = function(u, h) {
        return this._map.fire(new o.Event(u, { originalEvent: h }));
      };
      var nu = function(u) {
        this.reset(), this.numTouches = u.numTouches;
      };
      nu.prototype.reset = function() {
        delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
      }, nu.prototype.touchstart = function(u, h, c) {
        (this.centroid || c.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = u.timeStamp), c.length === this.numTouches && (this.centroid = function(d) {
          for (var _ = new o.Point(0, 0), w = 0, E = d; w < E.length; w += 1)
            _._add(E[w]);
          return _.div(d.length);
        }(h), this.touches = _h(c, h)));
      }, nu.prototype.touchmove = function(u, h, c) {
        if (!this.aborted && this.centroid) {
          var d = _h(c, h);
          for (var _ in this.touches) {
            var w = d[_];
            (!w || w.dist(this.touches[_]) > 30) && (this.aborted = !0);
          }
        }
      }, nu.prototype.touchend = function(u, h, c) {
        if ((!this.centroid || u.timeStamp - this.startTime > 500) && (this.aborted = !0), c.length === 0) {
          var d = !this.aborted && this.centroid;
          if (this.reset(), d)
            return d;
        }
      };
      var aa = function(u) {
        this.singleTap = new nu(u), this.numTaps = u.numTaps, this.reset();
      };
      aa.prototype.reset = function() {
        this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
      }, aa.prototype.touchstart = function(u, h, c) {
        this.singleTap.touchstart(u, h, c);
      }, aa.prototype.touchmove = function(u, h, c) {
        this.singleTap.touchmove(u, h, c);
      }, aa.prototype.touchend = function(u, h, c) {
        var d = this.singleTap.touchend(u, h, c);
        if (d) {
          var _ = u.timeStamp - this.lastTime < 500, w = !this.lastTap || this.lastTap.dist(d) < 30;
          if (_ && w || this.reset(), this.count++, this.lastTime = u.timeStamp, this.lastTap = d, this.count === this.numTaps)
            return this.reset(), d;
        }
      };
      var co = function() {
        this._zoomIn = new aa({ numTouches: 1, numTaps: 2 }), this._zoomOut = new aa({ numTouches: 2, numTaps: 1 }), this.reset();
      };
      co.prototype.reset = function() {
        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
      }, co.prototype.touchstart = function(u, h, c) {
        this._zoomIn.touchstart(u, h, c), this._zoomOut.touchstart(u, h, c);
      }, co.prototype.touchmove = function(u, h, c) {
        this._zoomIn.touchmove(u, h, c), this._zoomOut.touchmove(u, h, c);
      }, co.prototype.touchend = function(u, h, c) {
        var d = this, _ = this._zoomIn.touchend(u, h, c), w = this._zoomOut.touchend(u, h, c);
        return _ ? (this._active = !0, u.preventDefault(), setTimeout(function() {
          return d.reset();
        }, 0), { cameraAnimation: function(E) {
          return E.easeTo({ duration: 300, zoom: E.getZoom() + 1, around: E.unproject(_) }, { originalEvent: u });
        } }) : w ? (this._active = !0, u.preventDefault(), setTimeout(function() {
          return d.reset();
        }, 0), { cameraAnimation: function(E) {
          return E.easeTo({ duration: 300, zoom: E.getZoom() - 1, around: E.unproject(w) }, { originalEvent: u });
        } }) : void 0;
      }, co.prototype.touchcancel = function() {
        this.reset();
      }, co.prototype.enable = function() {
        this._enabled = !0;
      }, co.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, co.prototype.isEnabled = function() {
        return this._enabled;
      }, co.prototype.isActive = function() {
        return this._active;
      };
      var ap = { 0: 1, 2: 2 }, ct = function(u) {
        this.reset(), this._clickTolerance = u.clickTolerance || 1;
      };
      ct.prototype.blur = function() {
        this.reset();
      }, ct.prototype.reset = function() {
        this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;
      }, ct.prototype._correctButton = function(u, h) {
        return !1;
      }, ct.prototype._move = function(u, h) {
        return {};
      }, ct.prototype.mousedown = function(u, h) {
        if (!this._lastPoint) {
          var c = g.mouseButton(u);
          this._correctButton(u, c) && (this._lastPoint = h, this._eventButton = c);
        }
      }, ct.prototype.mousemoveWindow = function(u, h) {
        var c = this._lastPoint;
        if (c) {
          if (u.preventDefault(), function(d, _) {
            var w = ap[_];
            return d.buttons === void 0 || (d.buttons & w) !== w;
          }(u, this._eventButton))
            this.reset();
          else if (this._moved || !(h.dist(c) < this._clickTolerance))
            return this._moved = !0, this._lastPoint = h, this._move(c, h);
        }
      }, ct.prototype.mouseupWindow = function(u) {
        this._lastPoint && g.mouseButton(u) === this._eventButton && (this._moved && g.suppressClick(), this.reset());
      }, ct.prototype.enable = function() {
        this._enabled = !0;
      }, ct.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, ct.prototype.isEnabled = function() {
        return this._enabled;
      }, ct.prototype.isActive = function() {
        return this._active;
      };
      var sp = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.mousedown = function(c, d) {
          u.prototype.mousedown.call(this, c, d), this._lastPoint && (this._active = !0);
        }, h.prototype._correctButton = function(c, d) {
          return d === 0 && !c.ctrlKey;
        }, h.prototype._move = function(c, d) {
          return { around: d, panDelta: d.sub(c) };
        }, h;
      }(ct), xh = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype._correctButton = function(c, d) {
          return d === 0 && c.ctrlKey || d === 2;
        }, h.prototype._move = function(c, d) {
          var _ = 0.8 * (d.x - c.x);
          if (_)
            return this._active = !0, { bearingDelta: _ };
        }, h.prototype.contextmenu = function(c) {
          c.preventDefault();
        }, h;
      }(ct), lp = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype._correctButton = function(c, d) {
          return d === 0 && c.ctrlKey || d === 2;
        }, h.prototype._move = function(c, d) {
          var _ = -0.5 * (d.y - c.y);
          if (_)
            return this._active = !0, { pitchDelta: _ };
        }, h.prototype.contextmenu = function(c) {
          c.preventDefault();
        }, h;
      }(ct), qo = function(u) {
        this._minTouches = 1, this._clickTolerance = u.clickTolerance || 1, this.reset();
      };
      qo.prototype.reset = function() {
        this._active = !1, this._touches = {}, this._sum = new o.Point(0, 0);
      }, qo.prototype.touchstart = function(u, h, c) {
        return this._calculateTransform(u, h, c);
      }, qo.prototype.touchmove = function(u, h, c) {
        if (this._active && !(c.length < this._minTouches))
          return u.preventDefault(), this._calculateTransform(u, h, c);
      }, qo.prototype.touchend = function(u, h, c) {
        this._calculateTransform(u, h, c), this._active && c.length < this._minTouches && this.reset();
      }, qo.prototype.touchcancel = function() {
        this.reset();
      }, qo.prototype._calculateTransform = function(u, h, c) {
        c.length > 0 && (this._active = !0);
        var d = _h(c, h), _ = new o.Point(0, 0), w = new o.Point(0, 0), E = 0;
        for (var O in d) {
          var k = d[O], R = this._touches[O];
          R && (_._add(k), w._add(k.sub(R)), E++, d[O] = k);
        }
        if (this._touches = d, !(E < this._minTouches) && w.mag()) {
          var $ = w.div(E);
          if (this._sum._add($), !(this._sum.mag() < this._clickTolerance))
            return { around: _.div(E), panDelta: $ };
        }
      }, qo.prototype.enable = function() {
        this._enabled = !0;
      }, qo.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, qo.prototype.isEnabled = function() {
        return this._enabled;
      }, qo.prototype.isActive = function() {
        return this._active;
      };
      var ho = function() {
        this.reset();
      };
      function bh(u, h, c) {
        for (var d = 0; d < u.length; d++)
          if (u[d].identifier === c)
            return h[d];
      }
      function wh(u, h) {
        return Math.log(u / h) / Math.LN2;
      }
      ho.prototype.reset = function() {
        this._active = !1, delete this._firstTwoTouches;
      }, ho.prototype._start = function(u) {
      }, ho.prototype._move = function(u, h, c) {
        return {};
      }, ho.prototype.touchstart = function(u, h, c) {
        this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([h[0], h[1]]));
      }, ho.prototype.touchmove = function(u, h, c) {
        if (this._firstTwoTouches) {
          u.preventDefault();
          var d = this._firstTwoTouches, _ = d[1], w = bh(c, h, d[0]), E = bh(c, h, _);
          if (w && E) {
            var O = this._aroundCenter ? null : w.add(E).div(2);
            return this._move([w, E], O, u);
          }
        }
      }, ho.prototype.touchend = function(u, h, c) {
        if (this._firstTwoTouches) {
          var d = this._firstTwoTouches, _ = d[1], w = bh(c, h, d[0]), E = bh(c, h, _);
          w && E || (this._active && g.suppressClick(), this.reset());
        }
      }, ho.prototype.touchcancel = function() {
        this.reset();
      }, ho.prototype.enable = function(u) {
        this._enabled = !0, this._aroundCenter = !!u && u.around === "center";
      }, ho.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, ho.prototype.isEnabled = function() {
        return this._enabled;
      }, ho.prototype.isActive = function() {
        return this._active;
      };
      var fo = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.reset = function() {
          u.prototype.reset.call(this), delete this._distance, delete this._startDistance;
        }, h.prototype._start = function(c) {
          this._startDistance = this._distance = c[0].dist(c[1]);
        }, h.prototype._move = function(c, d) {
          var _ = this._distance;
          if (this._distance = c[0].dist(c[1]), this._active || !(Math.abs(wh(this._distance, this._startDistance)) < 0.1))
            return this._active = !0, { zoomDelta: wh(this._distance, _), pinchAround: d };
        }, h;
      }(ho);
      function ja(u, h) {
        return 180 * u.angleWith(h) / Math.PI;
      }
      var Rm = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.reset = function() {
          u.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector;
        }, h.prototype._start = function(c) {
          this._startVector = this._vector = c[0].sub(c[1]), this._minDiameter = c[0].dist(c[1]);
        }, h.prototype._move = function(c, d) {
          var _ = this._vector;
          if (this._vector = c[0].sub(c[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = !0, { bearingDelta: ja(this._vector, _), pinchAround: d };
        }, h.prototype._isBelowThreshold = function(c) {
          this._minDiameter = Math.min(this._minDiameter, c.mag());
          var d = 25 / (Math.PI * this._minDiameter) * 360, _ = ja(c, this._startVector);
          return Math.abs(_) < d;
        }, h;
      }(ho);
      function cc(u) {
        return Math.abs(u.y) > Math.abs(u.x);
      }
      var up = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.reset = function() {
          u.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }, h.prototype._start = function(c) {
          this._lastPoints = c, cc(c[0].sub(c[1])) && (this._valid = !1);
        }, h.prototype._move = function(c, d, _) {
          var w = c[0].sub(this._lastPoints[0]), E = c[1].sub(this._lastPoints[1]);
          if (this._valid = this.gestureBeginsVertically(w, E, _.timeStamp), this._valid)
            return this._lastPoints = c, this._active = !0, { pitchDelta: (w.y + E.y) / 2 * -0.5 };
        }, h.prototype.gestureBeginsVertically = function(c, d, _) {
          if (this._valid !== void 0)
            return this._valid;
          var w = c.mag() >= 2, E = d.mag() >= 2;
          if (w || E) {
            if (!w || !E)
              return this._firstMove === void 0 && (this._firstMove = _), _ - this._firstMove < 100 && void 0;
            var O = c.y > 0 == d.y > 0;
            return cc(c) && cc(d) && O;
          }
        }, h;
      }(ho), cp = { panStep: 100, bearingStep: 15, pitchStep: 10 }, sa = function() {
        var u = cp;
        this._panStep = u.panStep, this._bearingStep = u.bearingStep, this._pitchStep = u.pitchStep, this._rotationDisabled = !1;
      };
      function Io(u) {
        return u * (2 - u);
      }
      sa.prototype.blur = function() {
        this.reset();
      }, sa.prototype.reset = function() {
        this._active = !1;
      }, sa.prototype.keydown = function(u) {
        var h = this;
        if (!(u.altKey || u.ctrlKey || u.metaKey)) {
          var c = 0, d = 0, _ = 0, w = 0, E = 0;
          switch (u.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              c = 1;
              break;
            case 189:
            case 109:
            case 173:
              c = -1;
              break;
            case 37:
              u.shiftKey ? d = -1 : (u.preventDefault(), w = -1);
              break;
            case 39:
              u.shiftKey ? d = 1 : (u.preventDefault(), w = 1);
              break;
            case 38:
              u.shiftKey ? _ = 1 : (u.preventDefault(), E = -1);
              break;
            case 40:
              u.shiftKey ? _ = -1 : (u.preventDefault(), E = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (d = 0, _ = 0), { cameraAnimation: function(O) {
            var k = O.getZoom();
            O.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Io, zoom: c ? Math.round(k) + c * (u.shiftKey ? 2 : 1) : k, bearing: O.getBearing() + d * h._bearingStep, pitch: O.getPitch() + _ * h._pitchStep, offset: [-w * h._panStep, -E * h._panStep], center: O.getCenter() }, { originalEvent: u });
          } };
        }
      }, sa.prototype.enable = function() {
        this._enabled = !0;
      }, sa.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, sa.prototype.isEnabled = function() {
        return this._enabled;
      }, sa.prototype.isActive = function() {
        return this._active;
      }, sa.prototype.disableRotation = function() {
        this._rotationDisabled = !0;
      }, sa.prototype.enableRotation = function() {
        this._rotationDisabled = !1;
      };
      var mr = function(u, h) {
        this._map = u, this._el = u.getCanvasContainer(), this._handler = h, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 1 / 450, o.bindAll(["_onTimeout"], this);
      };
      mr.prototype.setZoomRate = function(u) {
        this._defaultZoomRate = u;
      }, mr.prototype.setWheelZoomRate = function(u) {
        this._wheelZoomRate = u;
      }, mr.prototype.isEnabled = function() {
        return !!this._enabled;
      }, mr.prototype.isActive = function() {
        return !!this._active || this._finishTimeout !== void 0;
      }, mr.prototype.isZooming = function() {
        return !!this._zooming;
      }, mr.prototype.enable = function(u) {
        this.isEnabled() || (this._enabled = !0, this._aroundCenter = u && u.around === "center");
      }, mr.prototype.disable = function() {
        this.isEnabled() && (this._enabled = !1);
      }, mr.prototype.wheel = function(u) {
        if (this.isEnabled()) {
          var h = u.deltaMode === o.window.WheelEvent.DOM_DELTA_LINE ? 40 * u.deltaY : u.deltaY, c = o.browser.now(), d = c - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = c, h !== 0 && h % 4.000244140625 == 0 ? this._type = "wheel" : h !== 0 && Math.abs(h) < 4 ? this._type = "trackpad" : d > 400 ? (this._type = null, this._lastValue = h, this._timeout = setTimeout(this._onTimeout, 40, u)) : this._type || (this._type = Math.abs(d * h) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, h += this._lastValue)), u.shiftKey && h && (h /= 4), this._type && (this._lastWheelEvent = u, this._delta -= h, this._active || this._start(u)), u.preventDefault();
        }
      }, mr.prototype._onTimeout = function(u) {
        this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(u);
      }, mr.prototype._start = function(u) {
        if (this._delta) {
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          var h = g.mousePos(this._el, u);
          this._around = o.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(h)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
        }
      }, mr.prototype.renderFrame = function() {
        var u = this;
        if (this._frameId && (this._frameId = null, this.isActive())) {
          var h = this._map.transform;
          if (this._delta !== 0) {
            var c = this._type === "wheel" && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, d = 2 / (1 + Math.exp(-Math.abs(this._delta * c)));
            this._delta < 0 && d !== 0 && (d = 1 / d);
            var _ = typeof this._targetZoom == "number" ? h.zoomScale(this._targetZoom) : h.scale;
            this._targetZoom = Math.min(h.maxZoom, Math.max(h.minZoom, h.scaleZoom(_ * d))), this._type === "wheel" && (this._startZoom = h.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          var w, E = typeof this._targetZoom == "number" ? this._targetZoom : h.zoom, O = this._startZoom, k = this._easing, R = !1;
          if (this._type === "wheel" && O && k) {
            var $ = Math.min((o.browser.now() - this._lastWheelEventTime) / 200, 1), W = k($);
            w = o.number(O, E, W), $ < 1 ? this._frameId || (this._frameId = !0) : R = !0;
          } else
            w = E, R = !0;
          return this._active = !0, R && (this._active = !1, this._finishTimeout = setTimeout(function() {
            u._zooming = !1, u._handler._triggerRenderFrame(), delete u._targetZoom, delete u._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !R, zoomDelta: w - h.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
      }, mr.prototype._smoothOutEasing = function(u) {
        var h = o.ease;
        if (this._prevEase) {
          var c = this._prevEase, d = (o.browser.now() - c.start) / c.duration, _ = c.easing(d + 0.01) - c.easing(d), w = 0.27 / Math.sqrt(_ * _ + 1e-4) * 0.01, E = Math.sqrt(0.0729 - w * w);
          h = o.bezier(w, E, 0.25, 1);
        }
        return this._prevEase = { start: o.browser.now(), duration: u, easing: h }, h;
      }, mr.prototype.blur = function() {
        this.reset();
      }, mr.prototype.reset = function() {
        this._active = !1;
      };
      var ba = function(u, h) {
        this._clickZoom = u, this._tapZoom = h;
      };
      ba.prototype.enable = function() {
        this._clickZoom.enable(), this._tapZoom.enable();
      }, ba.prototype.disable = function() {
        this._clickZoom.disable(), this._tapZoom.disable();
      }, ba.prototype.isEnabled = function() {
        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
      }, ba.prototype.isActive = function() {
        return this._clickZoom.isActive() || this._tapZoom.isActive();
      };
      var Wo = function() {
        this.reset();
      };
      Wo.prototype.reset = function() {
        this._active = !1;
      }, Wo.prototype.blur = function() {
        this.reset();
      }, Wo.prototype.dblclick = function(u, h) {
        return u.preventDefault(), { cameraAnimation: function(c) {
          c.easeTo({ duration: 300, zoom: c.getZoom() + (u.shiftKey ? -1 : 1), around: c.unproject(h) }, { originalEvent: u });
        } };
      }, Wo.prototype.enable = function() {
        this._enabled = !0;
      }, Wo.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, Wo.prototype.isEnabled = function() {
        return this._enabled;
      }, Wo.prototype.isActive = function() {
        return this._active;
      };
      var Mi = function() {
        this._tap = new aa({ numTouches: 1, numTaps: 1 }), this.reset();
      };
      Mi.prototype.reset = function() {
        this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
      }, Mi.prototype.touchstart = function(u, h, c) {
        this._swipePoint || (this._tapTime && u.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? c.length > 0 && (this._swipePoint = h[0], this._swipeTouch = c[0].identifier) : this._tap.touchstart(u, h, c));
      }, Mi.prototype.touchmove = function(u, h, c) {
        if (this._tapTime) {
          if (this._swipePoint) {
            if (c[0].identifier !== this._swipeTouch)
              return;
            var d = h[0], _ = d.y - this._swipePoint.y;
            return this._swipePoint = d, u.preventDefault(), this._active = !0, { zoomDelta: _ / 128 };
          }
        } else
          this._tap.touchmove(u, h, c);
      }, Mi.prototype.touchend = function(u, h, c) {
        this._tapTime ? this._swipePoint && c.length === 0 && this.reset() : this._tap.touchend(u, h, c) && (this._tapTime = u.timeStamp);
      }, Mi.prototype.touchcancel = function() {
        this.reset();
      }, Mi.prototype.enable = function() {
        this._enabled = !0;
      }, Mi.prototype.disable = function() {
        this._enabled = !1, this.reset();
      }, Mi.prototype.isEnabled = function() {
        return this._enabled;
      }, Mi.prototype.isActive = function() {
        return this._active;
      };
      var xl = function(u, h, c) {
        this._el = u, this._mousePan = h, this._touchPan = c;
      };
      xl.prototype.enable = function(u) {
        this._inertiaOptions = u || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
      }, xl.prototype.disable = function() {
        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
      }, xl.prototype.isEnabled = function() {
        return this._mousePan.isEnabled() && this._touchPan.isEnabled();
      }, xl.prototype.isActive = function() {
        return this._mousePan.isActive() || this._touchPan.isActive();
      };
      var Es = function(u, h, c) {
        this._pitchWithRotate = u.pitchWithRotate, this._mouseRotate = h, this._mousePitch = c;
      };
      Es.prototype.enable = function() {
        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
      }, Es.prototype.disable = function() {
        this._mouseRotate.disable(), this._mousePitch.disable();
      }, Es.prototype.isEnabled = function() {
        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
      }, Es.prototype.isActive = function() {
        return this._mouseRotate.isActive() || this._mousePitch.isActive();
      };
      var la = function(u, h, c, d) {
        this._el = u, this._touchZoom = h, this._touchRotate = c, this._tapDragZoom = d, this._rotationDisabled = !1, this._enabled = !0;
      };
      la.prototype.enable = function(u) {
        this._touchZoom.enable(u), this._rotationDisabled || this._touchRotate.enable(u), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
      }, la.prototype.disable = function() {
        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
      }, la.prototype.isEnabled = function() {
        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
      }, la.prototype.isActive = function() {
        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
      }, la.prototype.disableRotation = function() {
        this._rotationDisabled = !0, this._touchRotate.disable();
      }, la.prototype.enableRotation = function() {
        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
      };
      var ji = function(u) {
        return u.zoom || u.drag || u.pitch || u.rotate;
      }, hc = function(u) {
        function h() {
          u.apply(this, arguments);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h;
      }(o.Event);
      function Dt(u) {
        return u.panDelta && u.panDelta.mag() || u.zoomDelta || u.bearingDelta || u.pitchDelta;
      }
      var Tt = function(u, h) {
        this._map = u, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new sc(u), this._bearingSnap = h.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(h), o.bindAll(["handleEvent", "handleWindowEvent"], this);
        var c = this._el;
        this._listeners = [[c, "touchstart", { passive: !0 }], [c, "touchmove", { passive: !1 }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [o.window.document, "mousemove", { capture: !0 }], [o.window.document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: !1 }], [c, "keyup", void 0], [c, "wheel", { passive: !1 }], [c, "contextmenu", void 0], [o.window, "blur", void 0]];
        for (var d = 0, _ = this._listeners; d < _.length; d += 1) {
          var w = _[d], E = w[0];
          g.addEventListener(E, w[1], E === o.window.document ? this.handleWindowEvent : this.handleEvent, w[2]);
        }
      };
      Tt.prototype.destroy = function() {
        for (var u = 0, h = this._listeners; u < h.length; u += 1) {
          var c = h[u], d = c[0];
          g.removeEventListener(d, c[1], d === o.window.document ? this.handleWindowEvent : this.handleEvent, c[2]);
        }
      }, Tt.prototype._addDefaultHandlers = function(u) {
        var h = this._map, c = h.getCanvasContainer();
        this._add("mapEvent", new Gn(h, u));
        var d = h.boxZoom = new uo(h, u);
        this._add("boxZoom", d);
        var _ = new co(), w = new Wo();
        h.doubleClickZoom = new ba(w, _), this._add("tapZoom", _), this._add("clickZoom", w);
        var E = new Mi();
        this._add("tapDragZoom", E);
        var O = h.touchPitch = new up();
        this._add("touchPitch", O);
        var k = new xh(u), R = new lp(u);
        h.dragRotate = new Es(u, k, R), this._add("mouseRotate", k, ["mousePitch"]), this._add("mousePitch", R, ["mouseRotate"]);
        var $ = new sp(u), W = new qo(u);
        h.dragPan = new xl(c, $, W), this._add("mousePan", $), this._add("touchPan", W, ["touchZoom", "touchRotate"]);
        var H = new Rm(), ne = new fo();
        h.touchZoomRotate = new la(c, ne, H, E), this._add("touchRotate", H, ["touchPan", "touchZoom"]), this._add("touchZoom", ne, ["touchPan", "touchRotate"]);
        var te = h.scrollZoom = new mr(h, this);
        this._add("scrollZoom", te, ["mousePan"]);
        var ue = h.keyboard = new sa();
        this._add("keyboard", ue), this._add("blockableMapEvent", new wt(h));
        for (var Y = 0, le = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; Y < le.length; Y += 1) {
          var me = le[Y];
          u.interactive && u[me] && h[me].enable(u[me]);
        }
      }, Tt.prototype._add = function(u, h, c) {
        this._handlers.push({ handlerName: u, handler: h, allowed: c }), this._handlersById[u] = h;
      }, Tt.prototype.stop = function(u) {
        if (!this._updatingCamera) {
          for (var h = 0, c = this._handlers; h < c.length; h += 1)
            c[h].handler.reset();
          this._inertia.clear(), this._fireEvents({}, {}, u), this._changes = [];
        }
      }, Tt.prototype.isActive = function() {
        for (var u = 0, h = this._handlers; u < h.length; u += 1)
          if (h[u].handler.isActive())
            return !0;
        return !1;
      }, Tt.prototype.isZooming = function() {
        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
      }, Tt.prototype.isRotating = function() {
        return !!this._eventsInProgress.rotate;
      }, Tt.prototype.isMoving = function() {
        return Boolean(ji(this._eventsInProgress)) || this.isZooming();
      }, Tt.prototype._blockedByActive = function(u, h, c) {
        for (var d in u)
          if (d !== c && (!h || h.indexOf(d) < 0))
            return !0;
        return !1;
      }, Tt.prototype.handleWindowEvent = function(u) {
        this.handleEvent(u, u.type + "Window");
      }, Tt.prototype._getMapTouches = function(u) {
        for (var h = [], c = 0, d = u; c < d.length; c += 1) {
          var _ = d[c];
          this._el.contains(_.target) && h.push(_);
        }
        return h;
      }, Tt.prototype.handleEvent = function(u, h) {
        this._updatingCamera = !0;
        for (var c = u.type === "renderFrame" ? void 0 : u, d = { needsRenderFrame: !1 }, _ = {}, w = {}, E = u.touches ? this._getMapTouches(u.touches) : void 0, O = E ? g.touchPos(this._el, E) : g.mousePos(this._el, u), k = 0, R = this._handlers; k < R.length; k += 1) {
          var $ = R[k], W = $.handlerName, H = $.handler, ne = $.allowed;
          if (H.isEnabled()) {
            var te = void 0;
            this._blockedByActive(w, ne, W) ? H.reset() : H[h || u.type] && (te = H[h || u.type](u, O, E), this.mergeHandlerResult(d, _, te, W, c), te && te.needsRenderFrame && this._triggerRenderFrame()), (te || H.isActive()) && (w[W] = H);
          }
        }
        var ue = {};
        for (var Y in this._previousActiveHandlers)
          w[Y] || (ue[Y] = c);
        this._previousActiveHandlers = w, (Object.keys(ue).length || Dt(d)) && (this._changes.push([d, _, ue]), this._triggerRenderFrame()), (Object.keys(w).length || Dt(d)) && this._map._stop(!0), this._updatingCamera = !1;
        var le = d.cameraAnimation;
        le && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], le(this._map));
      }, Tt.prototype.mergeHandlerResult = function(u, h, c, d, _) {
        if (c) {
          o.extend(u, c);
          var w = { handlerName: d, originalEvent: c.originalEvent || _ };
          c.zoomDelta !== void 0 && (h.zoom = w), c.panDelta !== void 0 && (h.drag = w), c.pitchDelta !== void 0 && (h.pitch = w), c.bearingDelta !== void 0 && (h.rotate = w);
        }
      }, Tt.prototype._applyChanges = function() {
        for (var u = {}, h = {}, c = {}, d = 0, _ = this._changes; d < _.length; d += 1) {
          var w = _[d], E = w[0], O = w[1], k = w[2];
          E.panDelta && (u.panDelta = (u.panDelta || new o.Point(0, 0))._add(E.panDelta)), E.zoomDelta && (u.zoomDelta = (u.zoomDelta || 0) + E.zoomDelta), E.bearingDelta && (u.bearingDelta = (u.bearingDelta || 0) + E.bearingDelta), E.pitchDelta && (u.pitchDelta = (u.pitchDelta || 0) + E.pitchDelta), E.around !== void 0 && (u.around = E.around), E.pinchAround !== void 0 && (u.pinchAround = E.pinchAround), E.noInertia && (u.noInertia = E.noInertia), o.extend(h, O), o.extend(c, k);
        }
        this._updateMapTransform(u, h, c), this._changes = [];
      }, Tt.prototype._updateMapTransform = function(u, h, c) {
        var d = this._map, _ = d.transform;
        if (!Dt(u))
          return this._fireEvents(h, c, !0);
        var w = u.panDelta, E = u.zoomDelta, O = u.bearingDelta, k = u.pitchDelta, R = u.around, $ = u.pinchAround;
        $ !== void 0 && (R = $), d._stop(!0), R = R || d.transform.centerPoint;
        var W = _.pointLocation(w ? R.sub(w) : R);
        O && (_.bearing += O), k && (_.pitch += k), E && (_.zoom += E), _.setLocationAtPoint(W, R), this._map._update(), u.noInertia || this._inertia.record(u), this._fireEvents(h, c, !0);
      }, Tt.prototype._fireEvents = function(u, h, c) {
        var d = this, _ = ji(this._eventsInProgress), w = ji(u), E = {};
        for (var O in u)
          this._eventsInProgress[O] || (E[O + "start"] = u[O].originalEvent), this._eventsInProgress[O] = u[O];
        for (var k in !_ && w && this._fireEvent("movestart", w.originalEvent), E)
          this._fireEvent(k, E[k]);
        for (var R in w && this._fireEvent("move", w.originalEvent), u)
          this._fireEvent(R, u[R].originalEvent);
        var $, W = {};
        for (var H in this._eventsInProgress) {
          var ne = this._eventsInProgress[H], te = ne.handlerName, ue = ne.originalEvent;
          this._handlersById[te].isActive() || (delete this._eventsInProgress[H], W[H + "end"] = $ = h[te] || ue);
        }
        for (var Y in W)
          this._fireEvent(Y, W[Y]);
        var le = ji(this._eventsInProgress);
        if (c && (_ || w) && !le) {
          this._updatingCamera = !0;
          var me = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), xe = function(Pe) {
            return Pe !== 0 && -d._bearingSnap < Pe && Pe < d._bearingSnap;
          };
          me ? (xe(me.bearing || this._map.getBearing()) && (me.bearing = 0), this._map.easeTo(me, { originalEvent: $ })) : (this._map.fire(new o.Event("moveend", { originalEvent: $ })), xe(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
        }
      }, Tt.prototype._fireEvent = function(u, h) {
        this._map.fire(new o.Event(u, h ? { originalEvent: h } : {}));
      }, Tt.prototype._requestFrame = function() {
        var u = this;
        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(function(h) {
          delete u._frameId, u.handleEvent(new hc("renderFrame", { timeStamp: h })), u._applyChanges();
        });
      }, Tt.prototype._triggerRenderFrame = function() {
        this._frameId === void 0 && (this._frameId = this._requestFrame());
      };
      var Eh = function(u) {
        function h(c, d) {
          u.call(this), this._moving = !1, this._zooming = !1, this.transform = c, this._bearingSnap = d.bearingSnap, o.bindAll(["_renderFrameCallback"], this);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.getCenter = function() {
          return new o.LngLat(this.transform.center.lng, this.transform.center.lat);
        }, h.prototype.setCenter = function(c, d) {
          return this.jumpTo({ center: c }, d);
        }, h.prototype.panBy = function(c, d, _) {
          return c = o.Point.convert(c).mult(-1), this.panTo(this.transform.center, o.extend({ offset: c }, d), _);
        }, h.prototype.panTo = function(c, d, _) {
          return this.easeTo(o.extend({ center: c }, d), _);
        }, h.prototype.getZoom = function() {
          return this.transform.zoom;
        }, h.prototype.setZoom = function(c, d) {
          return this.jumpTo({ zoom: c }, d), this;
        }, h.prototype.zoomTo = function(c, d, _) {
          return this.easeTo(o.extend({ zoom: c }, d), _);
        }, h.prototype.zoomIn = function(c, d) {
          return this.zoomTo(this.getZoom() + 1, c, d), this;
        }, h.prototype.zoomOut = function(c, d) {
          return this.zoomTo(this.getZoom() - 1, c, d), this;
        }, h.prototype.getBearing = function() {
          return this.transform.bearing;
        }, h.prototype.setBearing = function(c, d) {
          return this.jumpTo({ bearing: c }, d), this;
        }, h.prototype.getPadding = function() {
          return this.transform.padding;
        }, h.prototype.setPadding = function(c, d) {
          return this.jumpTo({ padding: c }, d), this;
        }, h.prototype.rotateTo = function(c, d, _) {
          return this.easeTo(o.extend({ bearing: c }, d), _);
        }, h.prototype.resetNorth = function(c, d) {
          return this.rotateTo(0, o.extend({ duration: 1e3 }, c), d), this;
        }, h.prototype.resetNorthPitch = function(c, d) {
          return this.easeTo(o.extend({ bearing: 0, pitch: 0, duration: 1e3 }, c), d), this;
        }, h.prototype.snapToNorth = function(c, d) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(c, d) : this;
        }, h.prototype.getPitch = function() {
          return this.transform.pitch;
        }, h.prototype.setPitch = function(c, d) {
          return this.jumpTo({ pitch: c }, d), this;
        }, h.prototype.cameraForBounds = function(c, d) {
          c = o.LngLatBounds.convert(c);
          var _ = d && d.bearing || 0;
          return this._cameraForBoxAndBearing(c.getNorthWest(), c.getSouthEast(), _, d);
        }, h.prototype._cameraForBoxAndBearing = function(c, d, _, w) {
          var E = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (w = o.extend({ padding: E, offset: [0, 0], maxZoom: this.transform.maxZoom }, w)).padding == "number") {
            var O = w.padding;
            w.padding = { top: O, bottom: O, right: O, left: O };
          }
          w.padding = o.extend(E, w.padding);
          var k = this.transform, R = k.padding, $ = k.project(o.LngLat.convert(c)), W = k.project(o.LngLat.convert(d)), H = $.rotate(-_ * Math.PI / 180), ne = W.rotate(-_ * Math.PI / 180), te = new o.Point(Math.max(H.x, ne.x), Math.max(H.y, ne.y)), ue = new o.Point(Math.min(H.x, ne.x), Math.min(H.y, ne.y)), Y = te.sub(ue), le = (k.width - (R.left + R.right + w.padding.left + w.padding.right)) / Y.x, me = (k.height - (R.top + R.bottom + w.padding.top + w.padding.bottom)) / Y.y;
          if (!(me < 0 || le < 0)) {
            var xe = Math.min(k.scaleZoom(k.scale * Math.min(le, me)), w.maxZoom), Pe = typeof w.offset.x == "number" ? new o.Point(w.offset.x, w.offset.y) : o.Point.convert(w.offset), Me = new o.Point((w.padding.left - w.padding.right) / 2, (w.padding.top - w.padding.bottom) / 2).rotate(_ * Math.PI / 180), ke = Pe.add(Me).mult(k.scale / k.zoomScale(xe));
            return { center: k.unproject($.add(W).div(2).sub(ke)), zoom: xe, bearing: _ };
          }
          o.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }, h.prototype.fitBounds = function(c, d, _) {
          return this._fitInternal(this.cameraForBounds(c, d), d, _);
        }, h.prototype.fitScreenCoordinates = function(c, d, _, w, E) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(o.Point.convert(c)), this.transform.pointLocation(o.Point.convert(d)), _, w), w, E);
        }, h.prototype._fitInternal = function(c, d, _) {
          return c ? (delete (d = o.extend(c, d)).padding, d.linear ? this.easeTo(d, _) : this.flyTo(d, _)) : this;
        }, h.prototype.jumpTo = function(c, d) {
          this.stop();
          var _ = this.transform, w = !1, E = !1, O = !1;
          return "zoom" in c && _.zoom !== +c.zoom && (w = !0, _.zoom = +c.zoom), c.center !== void 0 && (_.center = o.LngLat.convert(c.center)), "bearing" in c && _.bearing !== +c.bearing && (E = !0, _.bearing = +c.bearing), "pitch" in c && _.pitch !== +c.pitch && (O = !0, _.pitch = +c.pitch), c.padding == null || _.isPaddingEqual(c.padding) || (_.padding = c.padding), this.fire(new o.Event("movestart", d)).fire(new o.Event("move", d)), w && this.fire(new o.Event("zoomstart", d)).fire(new o.Event("zoom", d)).fire(new o.Event("zoomend", d)), E && this.fire(new o.Event("rotatestart", d)).fire(new o.Event("rotate", d)).fire(new o.Event("rotateend", d)), O && this.fire(new o.Event("pitchstart", d)).fire(new o.Event("pitch", d)).fire(new o.Event("pitchend", d)), this.fire(new o.Event("moveend", d));
        }, h.prototype.easeTo = function(c, d) {
          var _ = this;
          this._stop(!1, c.easeId), ((c = o.extend({ offset: [0, 0], duration: 500, easing: o.ease }, c)).animate === !1 || !c.essential && o.browser.prefersReducedMotion) && (c.duration = 0);
          var w = this.transform, E = this.getZoom(), O = this.getBearing(), k = this.getPitch(), R = this.getPadding(), $ = "zoom" in c ? +c.zoom : E, W = "bearing" in c ? this._normalizeBearing(c.bearing, O) : O, H = "pitch" in c ? +c.pitch : k, ne = "padding" in c ? c.padding : w.padding, te = o.Point.convert(c.offset), ue = w.centerPoint.add(te), Y = w.pointLocation(ue), le = o.LngLat.convert(c.center || Y);
          this._normalizeCenter(le);
          var me, xe, Pe = w.project(Y), Me = w.project(le).sub(Pe), ke = w.zoomScale($ - E);
          c.around && (me = o.LngLat.convert(c.around), xe = w.locationPoint(me));
          var je = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || $ !== E, this._rotating = this._rotating || O !== W, this._pitching = this._pitching || H !== k, this._padding = !w.isPaddingEqual(ne), this._easeId = c.easeId, this._prepareEase(d, c.noMoveStart, je), this._ease(function(it) {
            if (_._zooming && (w.zoom = o.number(E, $, it)), _._rotating && (w.bearing = o.number(O, W, it)), _._pitching && (w.pitch = o.number(k, H, it)), _._padding && (w.interpolatePadding(R, ne, it), ue = w.centerPoint.add(te)), me)
              w.setLocationAtPoint(me, xe);
            else {
              var tt = w.zoomScale(w.zoom - E), gt = $ > E ? Math.min(2, ke) : Math.max(0.5, ke), Nt = Math.pow(gt, 1 - it), Bt = w.unproject(Pe.add(Me.mult(it * Nt)).mult(tt));
              w.setLocationAtPoint(w.renderWorldCopies ? Bt.wrap() : Bt, ue);
            }
            _._fireMoveEvents(d);
          }, function(it) {
            _._afterEase(d, it);
          }, c), this;
        }, h.prototype._prepareEase = function(c, d, _) {
          _ === void 0 && (_ = {}), this._moving = !0, d || _.moving || this.fire(new o.Event("movestart", c)), this._zooming && !_.zooming && this.fire(new o.Event("zoomstart", c)), this._rotating && !_.rotating && this.fire(new o.Event("rotatestart", c)), this._pitching && !_.pitching && this.fire(new o.Event("pitchstart", c));
        }, h.prototype._fireMoveEvents = function(c) {
          this.fire(new o.Event("move", c)), this._zooming && this.fire(new o.Event("zoom", c)), this._rotating && this.fire(new o.Event("rotate", c)), this._pitching && this.fire(new o.Event("pitch", c));
        }, h.prototype._afterEase = function(c, d) {
          if (!this._easeId || !d || this._easeId !== d) {
            delete this._easeId;
            var _ = this._zooming, w = this._rotating, E = this._pitching;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, _ && this.fire(new o.Event("zoomend", c)), w && this.fire(new o.Event("rotateend", c)), E && this.fire(new o.Event("pitchend", c)), this.fire(new o.Event("moveend", c));
          }
        }, h.prototype.flyTo = function(c, d) {
          var _ = this;
          if (!c.essential && o.browser.prefersReducedMotion) {
            var w = o.pick(c, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(w, d);
          }
          this.stop(), c = o.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: o.ease }, c);
          var E = this.transform, O = this.getZoom(), k = this.getBearing(), R = this.getPitch(), $ = this.getPadding(), W = "zoom" in c ? o.clamp(+c.zoom, E.minZoom, E.maxZoom) : O, H = "bearing" in c ? this._normalizeBearing(c.bearing, k) : k, ne = "pitch" in c ? +c.pitch : R, te = "padding" in c ? c.padding : E.padding, ue = E.zoomScale(W - O), Y = o.Point.convert(c.offset), le = E.centerPoint.add(Y), me = E.pointLocation(le), xe = o.LngLat.convert(c.center || me);
          this._normalizeCenter(xe);
          var Pe = E.project(me), Me = E.project(xe).sub(Pe), ke = c.curve, je = Math.max(E.width, E.height), it = je / ue, tt = Me.mag();
          if ("minZoom" in c) {
            var gt = o.clamp(Math.min(c.minZoom, O, W), E.minZoom, E.maxZoom), Nt = je / E.zoomScale(gt - O);
            ke = Math.sqrt(Nt / tt * 2);
          }
          var Bt = ke * ke;
          function Ft(Wt) {
            var Gt = (it * it - je * je + (Wt ? -1 : 1) * Bt * Bt * tt * tt) / (2 * (Wt ? it : je) * Bt * tt);
            return Math.log(Math.sqrt(Gt * Gt + 1) - Gt);
          }
          function Ir(Wt) {
            return (Math.exp(Wt) - Math.exp(-Wt)) / 2;
          }
          function xt(Wt) {
            return (Math.exp(Wt) + Math.exp(-Wt)) / 2;
          }
          var Yt = Ft(0), or = function(Wt) {
            return xt(Yt) / xt(Yt + ke * Wt);
          }, Kt = function(Wt) {
            return je * ((xt(Yt) * (Ir(Gt = Yt + ke * Wt) / xt(Gt)) - Ir(Yt)) / Bt) / tt;
            var Gt;
          }, Xt = (Ft(1) - Yt) / ke;
          if (Math.abs(tt) < 1e-6 || !isFinite(Xt)) {
            if (Math.abs(je - it) < 1e-6)
              return this.easeTo(c, d);
            var nr = it < je ? -1 : 1;
            Xt = Math.abs(Math.log(it / je)) / ke, Kt = function() {
              return 0;
            }, or = function(Wt) {
              return Math.exp(nr * ke * Wt);
            };
          }
          return c.duration = "duration" in c ? +c.duration : 1e3 * Xt / ("screenSpeed" in c ? +c.screenSpeed / ke : +c.speed), c.maxDuration && c.duration > c.maxDuration && (c.duration = 0), this._zooming = !0, this._rotating = k !== H, this._pitching = ne !== R, this._padding = !E.isPaddingEqual(te), this._prepareEase(d, !1), this._ease(function(Wt) {
            var Gt = Wt * Xt, li = 1 / or(Gt);
            E.zoom = Wt === 1 ? W : O + E.scaleZoom(li), _._rotating && (E.bearing = o.number(k, H, Wt)), _._pitching && (E.pitch = o.number(R, ne, Wt)), _._padding && (E.interpolatePadding($, te, Wt), le = E.centerPoint.add(Y));
            var On = Wt === 1 ? xe : E.unproject(Pe.add(Me.mult(Kt(Gt))).mult(li));
            E.setLocationAtPoint(E.renderWorldCopies ? On.wrap() : On, le), _._fireMoveEvents(d);
          }, function() {
            return _._afterEase(d);
          }, c), this;
        }, h.prototype.isEasing = function() {
          return !!this._easeFrameId;
        }, h.prototype.stop = function() {
          return this._stop();
        }, h.prototype._stop = function(c, d) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            var _ = this._onEaseEnd;
            delete this._onEaseEnd, _.call(this, d);
          }
          if (!c) {
            var w = this.handlers;
            w && w.stop(!1);
          }
          return this;
        }, h.prototype._ease = function(c, d, _) {
          _.animate === !1 || _.duration === 0 ? (c(1), d()) : (this._easeStart = o.browser.now(), this._easeOptions = _, this._onEaseFrame = c, this._onEaseEnd = d, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }, h.prototype._renderFrameCallback = function() {
          var c = Math.min((o.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
          this._onEaseFrame(this._easeOptions.easing(c)), c < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }, h.prototype._normalizeBearing = function(c, d) {
          c = o.wrap(c, -180, 180);
          var _ = Math.abs(c - d);
          return Math.abs(c - 360 - d) < _ && (c -= 360), Math.abs(c + 360 - d) < _ && (c += 360), c;
        }, h.prototype._normalizeCenter = function(c) {
          var d = this.transform;
          if (d.renderWorldCopies && !d.lngRange) {
            var _ = c.lng - d.center.lng;
            c.lng += _ > 180 ? -360 : _ < -180 ? 360 : 0;
          }
        }, h;
      }(o.Evented), Gi = function(u) {
        u === void 0 && (u = {}), this.options = u, o.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
      };
      Gi.prototype.getDefaultPosition = function() {
        return "bottom-right";
      }, Gi.prototype.onAdd = function(u) {
        var h = this.options && this.options.compact;
        return this._map = u, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = g.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = g.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), h && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), h === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
      }, Gi.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
      }, Gi.prototype._setElementTitle = function(u, h) {
        var c = this._map._getUIString("AttributionControl." + h);
        u.title = c, u.setAttribute("aria-label", c);
      }, Gi.prototype._toggleAttribution = function() {
        this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));
      }, Gi.prototype._updateEditLink = function() {
        var u = this._editLink;
        u || (u = this._editLink = this._container.querySelector(".mapbox-improve-map"));
        var h = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || o.config.ACCESS_TOKEN }];
        if (u) {
          var c = h.reduce(function(d, _, w) {
            return _.value && (d += _.key + "=" + _.value + (w < h.length - 1 ? "&" : "")), d;
          }, "?");
          u.href = o.config.FEEDBACK_URL + "/" + c + (this._map._hash ? this._map._hash.getHashString(!0) : ""), u.rel = "noopener nofollow", this._setElementTitle(u, "MapFeedback");
        }
      }, Gi.prototype._updateData = function(u) {
        !u || u.sourceDataType !== "metadata" && u.sourceDataType !== "visibility" && u.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
      }, Gi.prototype._updateAttributions = function() {
        if (this._map.style) {
          var u = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? u = u.concat(this.options.customAttribution.map(function(O) {
            return typeof O != "string" ? "" : O;
          })) : typeof this.options.customAttribution == "string" && u.push(this.options.customAttribution)), this._map.style.stylesheet) {
            var h = this._map.style.stylesheet;
            this.styleOwner = h.owner, this.styleId = h.id;
          }
          var c = this._map.style.sourceCaches;
          for (var d in c) {
            var _ = c[d];
            if (_.used) {
              var w = _.getSource();
              w.attribution && u.indexOf(w.attribution) < 0 && u.push(w.attribution);
            }
          }
          u.sort(function(O, k) {
            return O.length - k.length;
          });
          var E = (u = u.filter(function(O, k) {
            for (var R = k + 1; R < u.length; R++)
              if (u[R].indexOf(O) >= 0)
                return !1;
            return !0;
          })).join(" | ");
          E !== this._attribHTML && (this._attribHTML = E, u.length ? (this._innerContainer.innerHTML = E, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
      }, Gi.prototype._updateCompact = function() {
        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
      };
      var ua = function() {
        o.bindAll(["_updateLogo"], this), o.bindAll(["_updateCompact"], this);
      };
      ua.prototype.onAdd = function(u) {
        this._map = u, this._container = g.create("div", "mapboxgl-ctrl");
        var h = g.create("a", "mapboxgl-ctrl-logo");
        return h.target = "_blank", h.rel = "noopener nofollow", h.href = "https://www.mapbox.com/", h.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), h.setAttribute("rel", "noopener nofollow"), this._container.appendChild(h), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
      }, ua.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
      }, ua.prototype.getDefaultPosition = function() {
        return "bottom-left";
      }, ua.prototype._updateLogo = function(u) {
        u && u.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
      }, ua.prototype._logoRequired = function() {
        if (this._map.style) {
          var u = this._map.style.sourceCaches;
          for (var h in u)
            if (u[h].getSource().mapbox_logo)
              return !0;
          return !1;
        }
      }, ua.prototype._updateCompact = function() {
        var u = this._container.children;
        if (u.length) {
          var h = u[0];
          this._map.getCanvasContainer().offsetWidth < 250 ? h.classList.add("mapboxgl-compact") : h.classList.remove("mapboxgl-compact");
        }
      };
      var Ii = function() {
        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
      };
      Ii.prototype.add = function(u) {
        var h = ++this._id;
        return this._queue.push({ callback: u, id: h, cancelled: !1 }), h;
      }, Ii.prototype.remove = function(u) {
        for (var h = this._currentlyRunning, c = 0, d = h ? this._queue.concat(h) : this._queue; c < d.length; c += 1) {
          var _ = d[c];
          if (_.id === u)
            return void (_.cancelled = !0);
        }
      }, Ii.prototype.run = function(u) {
        u === void 0 && (u = 0);
        var h = this._currentlyRunning = this._queue;
        this._queue = [];
        for (var c = 0, d = h; c < d.length; c += 1) {
          var _ = d[c];
          if (!_.cancelled && (_.callback(u), this._cleared))
            break;
        }
        this._cleared = !1, this._currentlyRunning = !1;
      }, Ii.prototype.clear = function() {
        this._currentlyRunning && (this._cleared = !0), this._queue = [];
      };
      var wa = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, hp = o.window.HTMLImageElement, Sh = o.window.HTMLElement, Gr = o.window.ImageBitmap, gi = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: !0 }, zm = function(u) {
        function h(d) {
          var _ = this;
          if ((d = o.extend({}, gi, d)).minZoom != null && d.maxZoom != null && d.minZoom > d.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (d.minPitch != null && d.maxPitch != null && d.minPitch > d.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (d.minPitch != null && d.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (d.maxPitch != null && d.maxPitch > 60)
            throw new Error("maxPitch must be less than or equal to 60");
          var w = new xr(d.minZoom, d.maxZoom, d.minPitch, d.maxPitch, d.renderWorldCopies);
          if (u.call(this, w, d), this._interactive = d.interactive, this._maxTileCacheSize = d.maxTileCacheSize, this._failIfMajorPerformanceCaveat = d.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = d.preserveDrawingBuffer, this._antialias = d.antialias, this._trackResize = d.trackResize, this._bearingSnap = d.bearingSnap, this._refreshExpiredTiles = d.refreshExpiredTiles, this._fadeDuration = d.fadeDuration, this._crossSourceCollisions = d.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = d.collectResourceTiming, this._renderTaskQueue = new Ii(), this._controls = [], this._mapId = o.uniqueId(), this._locale = o.extend({}, wa, d.locale), this._clickTolerance = d.clickTolerance, this._requestManager = new o.RequestManager(d.transformRequest, d.accessToken), typeof d.container == "string") {
            if (this._container = o.window.document.getElementById(d.container), !this._container)
              throw new Error("Container '" + d.container + "' not found.");
          } else {
            if (!(d.container instanceof Sh))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = d.container;
          }
          if (d.maxBounds && this.setMaxBounds(d.maxBounds), o.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)
            throw new Error("Failed to initialize WebGL.");
          this.on("move", function() {
            return _._update(!1);
          }), this.on("moveend", function() {
            return _._update(!1);
          }), this.on("zoom", function() {
            return _._update(!0);
          }), o.window !== void 0 && (o.window.addEventListener("online", this._onWindowOnline, !1), o.window.addEventListener("resize", this._onWindowResize, !1), o.window.addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new Tt(this, d), this._hash = d.hash && new Mo(typeof d.hash == "string" && d.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: d.center, zoom: d.zoom, bearing: d.bearing, pitch: d.pitch }), d.bounds && (this.resize(), this.fitBounds(d.bounds, o.extend({}, d.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = d.localIdeographFontFamily, d.style && this.setStyle(d.style, { localIdeographFontFamily: d.localIdeographFontFamily }), d.attributionControl && this.addControl(new Gi({ customAttribution: d.customAttribution })), this.addControl(new ua(), d.logoPosition), this.on("style.load", function() {
            _.transform.unmodified && _.jumpTo(_.style.stylesheet);
          }), this.on("data", function(E) {
            _._update(E.dataType === "style"), _.fire(new o.Event(E.dataType + "data", E));
          }), this.on("dataloading", function(E) {
            _.fire(new o.Event(E.dataType + "dataloading", E));
          });
        }
        u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h;
        var c = { showTileBoundaries: { configurable: !0 }, showPadding: { configurable: !0 }, showCollisionBoxes: { configurable: !0 }, showOverdrawInspector: { configurable: !0 }, repaint: { configurable: !0 }, vertices: { configurable: !0 }, version: { configurable: !0 } };
        return h.prototype._getMapId = function() {
          return this._mapId;
        }, h.prototype.addControl = function(d, _) {
          if (_ === void 0 && (_ = d.getDefaultPosition ? d.getDefaultPosition() : "top-right"), !d || !d.onAdd)
            return this.fire(new o.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          var w = d.onAdd(this);
          this._controls.push(d);
          var E = this._controlPositions[_];
          return _.indexOf("bottom") !== -1 ? E.insertBefore(w, E.firstChild) : E.appendChild(w), this;
        }, h.prototype.removeControl = function(d) {
          if (!d || !d.onRemove)
            return this.fire(new o.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          var _ = this._controls.indexOf(d);
          return _ > -1 && this._controls.splice(_, 1), d.onRemove(this), this;
        }, h.prototype.hasControl = function(d) {
          return this._controls.indexOf(d) > -1;
        }, h.prototype.resize = function(d) {
          var _ = this._containerDimensions(), w = _[0], E = _[1];
          if (w === this.transform.width && E === this.transform.height)
            return this;
          this._resizeCanvas(w, E), this.transform.resize(w, E), this.painter.resize(w, E);
          var O = !this._moving;
          return O && this.fire(new o.Event("movestart", d)).fire(new o.Event("move", d)), this.fire(new o.Event("resize", d)), O && this.fire(new o.Event("moveend", d)), this;
        }, h.prototype.getBounds = function() {
          return this.transform.getBounds();
        }, h.prototype.getMaxBounds = function() {
          return this.transform.getMaxBounds();
        }, h.prototype.setMaxBounds = function(d) {
          return this.transform.setMaxBounds(o.LngLatBounds.convert(d)), this._update();
        }, h.prototype.setMinZoom = function(d) {
          if ((d = d == null ? -2 : d) >= -2 && d <= this.transform.maxZoom)
            return this.transform.minZoom = d, this._update(), this.getZoom() < d && this.setZoom(d), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }, h.prototype.getMinZoom = function() {
          return this.transform.minZoom;
        }, h.prototype.setMaxZoom = function(d) {
          if ((d = d == null ? 22 : d) >= this.transform.minZoom)
            return this.transform.maxZoom = d, this._update(), this.getZoom() > d && this.setZoom(d), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }, h.prototype.getMaxZoom = function() {
          return this.transform.maxZoom;
        }, h.prototype.setMinPitch = function(d) {
          if ((d = d == null ? 0 : d) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (d >= 0 && d <= this.transform.maxPitch)
            return this.transform.minPitch = d, this._update(), this.getPitch() < d && this.setPitch(d), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }, h.prototype.getMinPitch = function() {
          return this.transform.minPitch;
        }, h.prototype.setMaxPitch = function(d) {
          if ((d = d == null ? 60 : d) > 60)
            throw new Error("maxPitch must be less than or equal to 60");
          if (d >= this.transform.minPitch)
            return this.transform.maxPitch = d, this._update(), this.getPitch() > d && this.setPitch(d), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }, h.prototype.getMaxPitch = function() {
          return this.transform.maxPitch;
        }, h.prototype.getRenderWorldCopies = function() {
          return this.transform.renderWorldCopies;
        }, h.prototype.setRenderWorldCopies = function(d) {
          return this.transform.renderWorldCopies = d, this._update();
        }, h.prototype.project = function(d) {
          return this.transform.locationPoint(o.LngLat.convert(d));
        }, h.prototype.unproject = function(d) {
          return this.transform.pointLocation(o.Point.convert(d));
        }, h.prototype.isMoving = function() {
          return this._moving || this.handlers.isMoving();
        }, h.prototype.isZooming = function() {
          return this._zooming || this.handlers.isZooming();
        }, h.prototype.isRotating = function() {
          return this._rotating || this.handlers.isRotating();
        }, h.prototype._createDelegatedListener = function(d, _, w) {
          var E, O = this;
          if (d === "mouseenter" || d === "mouseover") {
            var k = !1;
            return { layer: _, listener: w, delegates: { mousemove: function($) {
              var W = O.getLayer(_) ? O.queryRenderedFeatures($.point, { layers: [_] }) : [];
              W.length ? k || (k = !0, w.call(O, new Jn(d, O, $.originalEvent, { features: W }))) : k = !1;
            }, mouseout: function() {
              k = !1;
            } } };
          }
          if (d === "mouseleave" || d === "mouseout") {
            var R = !1;
            return { layer: _, listener: w, delegates: { mousemove: function($) {
              (O.getLayer(_) ? O.queryRenderedFeatures($.point, { layers: [_] }) : []).length ? R = !0 : R && (R = !1, w.call(O, new Jn(d, O, $.originalEvent)));
            }, mouseout: function($) {
              R && (R = !1, w.call(O, new Jn(d, O, $.originalEvent)));
            } } };
          }
          return { layer: _, listener: w, delegates: (E = {}, E[d] = function($) {
            var W = O.getLayer(_) ? O.queryRenderedFeatures($.point, { layers: [_] }) : [];
            W.length && ($.features = W, w.call(O, $), delete $.features);
          }, E) };
        }, h.prototype.on = function(d, _, w) {
          if (w === void 0)
            return u.prototype.on.call(this, d, _);
          var E = this._createDelegatedListener(d, _, w);
          for (var O in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[d] = this._delegatedListeners[d] || [], this._delegatedListeners[d].push(E), E.delegates)
            this.on(O, E.delegates[O]);
          return this;
        }, h.prototype.once = function(d, _, w) {
          if (w === void 0)
            return u.prototype.once.call(this, d, _);
          var E = this._createDelegatedListener(d, _, w);
          for (var O in E.delegates)
            this.once(O, E.delegates[O]);
          return this;
        }, h.prototype.off = function(d, _, w) {
          var E = this;
          return w === void 0 ? u.prototype.off.call(this, d, _) : (this._delegatedListeners && this._delegatedListeners[d] && function(O) {
            for (var k = O[d], R = 0; R < k.length; R++) {
              var $ = k[R];
              if ($.layer === _ && $.listener === w) {
                for (var W in $.delegates)
                  E.off(W, $.delegates[W]);
                return k.splice(R, 1), E;
              }
            }
          }(this._delegatedListeners), this);
        }, h.prototype.queryRenderedFeatures = function(d, _) {
          if (!this.style)
            return [];
          var w;
          if (_ !== void 0 || d === void 0 || d instanceof o.Point || Array.isArray(d) || (_ = d, d = void 0), _ = _ || {}, (d = d || [[0, 0], [this.transform.width, this.transform.height]]) instanceof o.Point || typeof d[0] == "number")
            w = [o.Point.convert(d)];
          else {
            var E = o.Point.convert(d[0]), O = o.Point.convert(d[1]);
            w = [E, new o.Point(O.x, E.y), O, new o.Point(E.x, O.y), E];
          }
          return this.style.queryRenderedFeatures(w, _, this.transform);
        }, h.prototype.querySourceFeatures = function(d, _) {
          return this.style.querySourceFeatures(d, _);
        }, h.prototype.setStyle = function(d, _) {
          return (_ = o.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, _)).diff !== !1 && _.localIdeographFontFamily === this._localIdeographFontFamily && this.style && d ? (this._diffStyle(d, _), this) : (this._localIdeographFontFamily = _.localIdeographFontFamily, this._updateStyle(d, _));
        }, h.prototype._getUIString = function(d) {
          var _ = this._locale[d];
          if (_ == null)
            throw new Error("Missing UI string '" + d + "'");
          return _;
        }, h.prototype._updateStyle = function(d, _) {
          return this.style && (this.style.setEventedParent(null), this.style._remove()), d ? (this.style = new lo(this, _ || {}), this.style.setEventedParent(this, { style: this.style }), typeof d == "string" ? this.style.loadURL(d) : this.style.loadJSON(d), this) : (delete this.style, this);
        }, h.prototype._lazyInitEmptyStyle = function() {
          this.style || (this.style = new lo(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }, h.prototype._diffStyle = function(d, _) {
          var w = this;
          if (typeof d == "string") {
            var E = this._requestManager.normalizeStyleURL(d), O = this._requestManager.transformRequest(E, o.ResourceType.Style);
            o.getJSON(O, function(k, R) {
              k ? w.fire(new o.ErrorEvent(k)) : R && w._updateDiff(R, _);
            });
          } else
            typeof d == "object" && this._updateDiff(d, _);
        }, h.prototype._updateDiff = function(d, _) {
          try {
            this.style.setState(d) && this._update(!0);
          } catch (w) {
            o.warnOnce("Unable to perform style diff: " + (w.message || w.error || w) + ".  Rebuilding the style from scratch."), this._updateStyle(d, _);
          }
        }, h.prototype.getStyle = function() {
          if (this.style)
            return this.style.serialize();
        }, h.prototype.isStyleLoaded = function() {
          return this.style ? this.style.loaded() : o.warnOnce("There is no style added to the map.");
        }, h.prototype.addSource = function(d, _) {
          return this._lazyInitEmptyStyle(), this.style.addSource(d, _), this._update(!0);
        }, h.prototype.isSourceLoaded = function(d) {
          var _ = this.style && this.style.sourceCaches[d];
          if (_ !== void 0)
            return _.loaded();
          this.fire(new o.ErrorEvent(new Error("There is no source with ID '" + d + "'")));
        }, h.prototype.areTilesLoaded = function() {
          var d = this.style && this.style.sourceCaches;
          for (var _ in d) {
            var w = d[_]._tiles;
            for (var E in w) {
              var O = w[E];
              if (O.state !== "loaded" && O.state !== "errored")
                return !1;
            }
          }
          return !0;
        }, h.prototype.addSourceType = function(d, _, w) {
          return this._lazyInitEmptyStyle(), this.style.addSourceType(d, _, w);
        }, h.prototype.removeSource = function(d) {
          return this.style.removeSource(d), this._update(!0);
        }, h.prototype.getSource = function(d) {
          return this.style.getSource(d);
        }, h.prototype.addImage = function(d, _, w) {
          w === void 0 && (w = {});
          var E = w.pixelRatio;
          E === void 0 && (E = 1);
          var O = w.sdf;
          O === void 0 && (O = !1);
          var k = w.stretchX, R = w.stretchY, $ = w.content;
          if (this._lazyInitEmptyStyle(), _ instanceof hp || Gr && _ instanceof Gr) {
            var W = o.browser.getImageData(_);
            this.style.addImage(d, { data: new o.RGBAImage({ width: W.width, height: W.height }, W.data), pixelRatio: E, stretchX: k, stretchY: R, content: $, sdf: O, version: 0 });
          } else {
            if (_.width === void 0 || _.height === void 0)
              return this.fire(new o.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            var H = _;
            this.style.addImage(d, { data: new o.RGBAImage({ width: _.width, height: _.height }, new Uint8Array(_.data)), pixelRatio: E, stretchX: k, stretchY: R, content: $, sdf: O, version: 0, userImage: H }), H.onAdd && H.onAdd(this, d);
          }
        }, h.prototype.updateImage = function(d, _) {
          var w = this.style.getImage(d);
          if (!w)
            return this.fire(new o.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          var E = _ instanceof hp || Gr && _ instanceof Gr ? o.browser.getImageData(_) : _, O = E.width, k = E.height, R = E.data;
          return O === void 0 || k === void 0 ? this.fire(new o.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : O !== w.data.width || k !== w.data.height ? this.fire(new o.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (w.data.replace(R, !(_ instanceof hp || Gr && _ instanceof Gr)), void this.style.updateImage(d, w));
        }, h.prototype.hasImage = function(d) {
          return d ? !!this.style.getImage(d) : (this.fire(new o.ErrorEvent(new Error("Missing required image id"))), !1);
        }, h.prototype.removeImage = function(d) {
          this.style.removeImage(d);
        }, h.prototype.loadImage = function(d, _) {
          o.getImage(this._requestManager.transformRequest(d, o.ResourceType.Image), _);
        }, h.prototype.listImages = function() {
          return this.style.listImages();
        }, h.prototype.addLayer = function(d, _) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(d, _), this._update(!0);
        }, h.prototype.moveLayer = function(d, _) {
          return this.style.moveLayer(d, _), this._update(!0);
        }, h.prototype.removeLayer = function(d) {
          return this.style.removeLayer(d), this._update(!0);
        }, h.prototype.getLayer = function(d) {
          return this.style.getLayer(d);
        }, h.prototype.setLayerZoomRange = function(d, _, w) {
          return this.style.setLayerZoomRange(d, _, w), this._update(!0);
        }, h.prototype.setFilter = function(d, _, w) {
          return w === void 0 && (w = {}), this.style.setFilter(d, _, w), this._update(!0);
        }, h.prototype.getFilter = function(d) {
          return this.style.getFilter(d);
        }, h.prototype.setPaintProperty = function(d, _, w, E) {
          return E === void 0 && (E = {}), this.style.setPaintProperty(d, _, w, E), this._update(!0);
        }, h.prototype.getPaintProperty = function(d, _) {
          return this.style.getPaintProperty(d, _);
        }, h.prototype.setLayoutProperty = function(d, _, w, E) {
          return E === void 0 && (E = {}), this.style.setLayoutProperty(d, _, w, E), this._update(!0);
        }, h.prototype.getLayoutProperty = function(d, _) {
          return this.style.getLayoutProperty(d, _);
        }, h.prototype.setLight = function(d, _) {
          return _ === void 0 && (_ = {}), this._lazyInitEmptyStyle(), this.style.setLight(d, _), this._update(!0);
        }, h.prototype.getLight = function() {
          return this.style.getLight();
        }, h.prototype.setFeatureState = function(d, _) {
          return this.style.setFeatureState(d, _), this._update();
        }, h.prototype.removeFeatureState = function(d, _) {
          return this.style.removeFeatureState(d, _), this._update();
        }, h.prototype.getFeatureState = function(d) {
          return this.style.getFeatureState(d);
        }, h.prototype.getContainer = function() {
          return this._container;
        }, h.prototype.getCanvasContainer = function() {
          return this._canvasContainer;
        }, h.prototype.getCanvas = function() {
          return this._canvas;
        }, h.prototype._containerDimensions = function() {
          var d = 0, _ = 0;
          return this._container && (d = this._container.clientWidth || 400, _ = this._container.clientHeight || 300), [d, _];
        }, h.prototype._detectMissingCSS = function() {
          o.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && o.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }, h.prototype._setupContainer = function() {
          var d = this._container;
          d.classList.add("mapboxgl-map"), (this._missingCSSCanary = g.create("div", "mapboxgl-canary", d)).style.visibility = "hidden", this._detectMissingCSS();
          var _ = this._canvasContainer = g.create("div", "mapboxgl-canvas-container", d);
          this._interactive && _.classList.add("mapboxgl-interactive"), this._canvas = g.create("canvas", "mapboxgl-canvas", _), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
          var w = this._containerDimensions();
          this._resizeCanvas(w[0], w[1]);
          var E = this._controlContainer = g.create("div", "mapboxgl-control-container", d), O = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function(k) {
            O[k] = g.create("div", "mapboxgl-ctrl-" + k, E);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }, h.prototype._resizeCanvas = function(d, _) {
          var w = o.browser.devicePixelRatio || 1;
          this._canvas.width = w * d, this._canvas.height = w * _, this._canvas.style.width = d + "px", this._canvas.style.height = _ + "px";
        }, h.prototype._setupPainter = function() {
          var d = o.extend({}, m.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), _ = this._canvas.getContext("webgl", d) || this._canvas.getContext("experimental-webgl", d);
          _ ? (this.painter = new yn(_, this.transform), o.webpSupported.testSupport(_)) : this.fire(new o.ErrorEvent(new Error("Failed to initialize WebGL")));
        }, h.prototype._contextLost = function(d) {
          d.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new o.Event("webglcontextlost", { originalEvent: d }));
        }, h.prototype._contextRestored = function(d) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new o.Event("webglcontextrestored", { originalEvent: d }));
        }, h.prototype._onMapScroll = function(d) {
          if (d.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
        }, h.prototype.loaded = function() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }, h.prototype._update = function(d) {
          return this.style ? (this._styleDirty = this._styleDirty || d, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }, h.prototype._requestRenderFrame = function(d) {
          return this._update(), this._renderTaskQueue.add(d);
        }, h.prototype._cancelRenderFrame = function(d) {
          this._renderTaskQueue.remove(d);
        }, h.prototype._render = function(d) {
          var _, w = this, E = 0, O = this.painter.context.extTimerQuery;
          if (this.listens("gpu-timing-frame") && (_ = O.createQueryEXT(), O.beginQueryEXT(O.TIME_ELAPSED_EXT, _), E = o.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(d), !this._removed) {
            var k = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              var R = this.transform.zoom, $ = o.browser.now();
              this.style.zoomHistory.update(R, $);
              var W = new o.EvaluationParameters(R, { now: $, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), H = W.crossFadingFactor();
              H === 1 && H === this._crossFadingFactor || (k = !0, this._crossFadingFactor = H), this.style.update(W);
            }
            if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new o.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new o.Event("load"))), this.style && (this.style.hasTransitions() || k) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
              var ne = o.browser.now() - E;
              O.endQueryEXT(O.TIME_ELAPSED_EXT, _), setTimeout(function() {
                var Y = O.getQueryObjectEXT(_, O.QUERY_RESULT_EXT) / 1e6;
                O.deleteQueryEXT(_), w.fire(new o.Event("gpu-timing-frame", { cpuTime: ne, gpuTime: Y }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              var te = this.painter.collectGpuTimers();
              setTimeout(function() {
                var Y = w.painter.queryGpuTimers(te);
                w.fire(new o.Event("gpu-timing-layer", { layerTimes: Y }));
              }, 50);
            }
            var ue = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return ue || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.Event("idle")), !this._loaded || this._fullyLoaded || ue || (this._fullyLoaded = !0), this;
          }
        }, h.prototype.remove = function() {
          this._hash && this._hash.remove();
          for (var d = 0, _ = this._controls; d < _.length; d += 1)
            _[d].onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), o.window !== void 0 && (o.window.removeEventListener("resize", this._onWindowResize, !1), o.window.removeEventListener("orientationchange", this._onWindowResize, !1), o.window.removeEventListener("online", this._onWindowOnline, !1));
          var w = this.painter.context.gl.getExtension("WEBGL_lose_context");
          w && w.loseContext(), bl(this._canvasContainer), bl(this._controlContainer), bl(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this._removed = !0, this.fire(new o.Event("remove"));
        }, h.prototype.triggerRepaint = function() {
          var d = this;
          this.style && !this._frame && (this._frame = o.browser.frame(function(_) {
            d._frame = null, d._render(_);
          }));
        }, h.prototype._onWindowOnline = function() {
          this._update();
        }, h.prototype._onWindowResize = function(d) {
          this._trackResize && this.resize({ originalEvent: d })._update();
        }, c.showTileBoundaries.get = function() {
          return !!this._showTileBoundaries;
        }, c.showTileBoundaries.set = function(d) {
          this._showTileBoundaries !== d && (this._showTileBoundaries = d, this._update());
        }, c.showPadding.get = function() {
          return !!this._showPadding;
        }, c.showPadding.set = function(d) {
          this._showPadding !== d && (this._showPadding = d, this._update());
        }, c.showCollisionBoxes.get = function() {
          return !!this._showCollisionBoxes;
        }, c.showCollisionBoxes.set = function(d) {
          this._showCollisionBoxes !== d && (this._showCollisionBoxes = d, d ? this.style._generateCollisionBoxes() : this._update());
        }, c.showOverdrawInspector.get = function() {
          return !!this._showOverdrawInspector;
        }, c.showOverdrawInspector.set = function(d) {
          this._showOverdrawInspector !== d && (this._showOverdrawInspector = d, this._update());
        }, c.repaint.get = function() {
          return !!this._repaint;
        }, c.repaint.set = function(d) {
          this._repaint !== d && (this._repaint = d, this.triggerRepaint());
        }, c.vertices.get = function() {
          return !!this._vertices;
        }, c.vertices.set = function(d) {
          this._vertices = d, this._update();
        }, h.prototype._setCacheLimits = function(d, _) {
          o.setCacheLimits(d, _);
        }, c.version.get = function() {
          return o.version;
        }, Object.defineProperties(h.prototype, c), h;
      }(Eh);
      function bl(u) {
        u.parentNode && u.parentNode.removeChild(u);
      }
      var fp = { showCompass: !0, showZoom: !0, visualizePitch: !1 }, Ga = function(u) {
        var h = this;
        this.options = o.extend({}, fp, u), this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", function(c) {
          return c.preventDefault();
        }), this.options.showZoom && (o.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", function(c) {
          return h._map.zoomIn({}, { originalEvent: c });
        }), g.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", !0), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", function(c) {
          return h._map.zoomOut({}, { originalEvent: c });
        }), g.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", !0)), this.options.showCompass && (o.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", function(c) {
          h.options.visualizePitch ? h._map.resetNorthPitch({}, { originalEvent: c }) : h._map.resetNorth({}, { originalEvent: c });
        }), this._compassIcon = g.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", !0));
      };
      Ga.prototype._updateZoomButtons = function() {
        var u = this._map.getZoom(), h = u === this._map.getMaxZoom(), c = u === this._map.getMinZoom();
        this._zoomInButton.disabled = h, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", h.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
      }, Ga.prototype._rotateCompassArrow = function() {
        var u = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";
        this._compassIcon.style.transform = u;
      }, Ga.prototype.onAdd = function(u) {
        return this._map = u, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new po(this._map, this._compass, this.options.visualizePitch)), this._container;
      }, Ga.prototype.onRemove = function() {
        g.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
      }, Ga.prototype._createButton = function(u, h) {
        var c = g.create("button", u, this._container);
        return c.type = "button", c.addEventListener("click", h), c;
      }, Ga.prototype._setButtonTitle = function(u, h) {
        var c = this._map._getUIString("NavigationControl." + h);
        u.title = c, u.setAttribute("aria-label", c);
      };
      var po = function(u, h, c) {
        c === void 0 && (c = !1), this._clickTolerance = 10, this.element = h, this.mouseRotate = new xh({ clickTolerance: u.dragRotate._mouseRotate._clickTolerance }), this.map = u, c && (this.mousePitch = new lp({ clickTolerance: u.dragRotate._mousePitch._clickTolerance })), o.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), g.addEventListener(h, "mousedown", this.mousedown), g.addEventListener(h, "touchstart", this.touchstart, { passive: !1 }), g.addEventListener(h, "touchmove", this.touchmove), g.addEventListener(h, "touchend", this.touchend), g.addEventListener(h, "touchcancel", this.reset);
      };
      function iu(u, h, c) {
        if (u = new o.LngLat(u.lng, u.lat), h) {
          var d = new o.LngLat(u.lng - 360, u.lat), _ = new o.LngLat(u.lng + 360, u.lat), w = c.locationPoint(u).distSqr(h);
          c.locationPoint(d).distSqr(h) < w ? u = d : c.locationPoint(_).distSqr(h) < w && (u = _);
        }
        for (; Math.abs(u.lng - c.center.lng) > 180; ) {
          var E = c.locationPoint(u);
          if (E.x >= 0 && E.y >= 0 && E.x <= c.width && E.y <= c.height)
            break;
          u.lng > c.center.lng ? u.lng -= 360 : u.lng += 360;
        }
        return u;
      }
      po.prototype.down = function(u, h) {
        this.mouseRotate.mousedown(u, h), this.mousePitch && this.mousePitch.mousedown(u, h), g.disableDrag();
      }, po.prototype.move = function(u, h) {
        var c = this.map, d = this.mouseRotate.mousemoveWindow(u, h);
        if (d && d.bearingDelta && c.setBearing(c.getBearing() + d.bearingDelta), this.mousePitch) {
          var _ = this.mousePitch.mousemoveWindow(u, h);
          _ && _.pitchDelta && c.setPitch(c.getPitch() + _.pitchDelta);
        }
      }, po.prototype.off = function() {
        var u = this.element;
        g.removeEventListener(u, "mousedown", this.mousedown), g.removeEventListener(u, "touchstart", this.touchstart, { passive: !1 }), g.removeEventListener(u, "touchmove", this.touchmove), g.removeEventListener(u, "touchend", this.touchend), g.removeEventListener(u, "touchcancel", this.reset), this.offTemp();
      }, po.prototype.offTemp = function() {
        g.enableDrag(), g.removeEventListener(o.window, "mousemove", this.mousemove), g.removeEventListener(o.window, "mouseup", this.mouseup);
      }, po.prototype.mousedown = function(u) {
        this.down(o.extend({}, u, { ctrlKey: !0, preventDefault: function() {
          return u.preventDefault();
        } }), g.mousePos(this.element, u)), g.addEventListener(o.window, "mousemove", this.mousemove), g.addEventListener(o.window, "mouseup", this.mouseup);
      }, po.prototype.mousemove = function(u) {
        this.move(u, g.mousePos(this.element, u));
      }, po.prototype.mouseup = function(u) {
        this.mouseRotate.mouseupWindow(u), this.mousePitch && this.mousePitch.mouseupWindow(u), this.offTemp();
      }, po.prototype.touchstart = function(u) {
        u.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = g.touchPos(this.element, u.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: function() {
          return u.preventDefault();
        } }, this._startPos));
      }, po.prototype.touchmove = function(u) {
        u.targetTouches.length !== 1 ? this.reset() : (this._lastPos = g.touchPos(this.element, u.targetTouches)[0], this.move({ preventDefault: function() {
          return u.preventDefault();
        } }, this._lastPos));
      }, po.prototype.touchend = function(u) {
        u.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
      }, po.prototype.reset = function() {
        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
      };
      var Ea = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function Th(u, h, c) {
        var d = u.classList;
        for (var _ in Ea)
          d.remove("mapboxgl-" + c + "-anchor-" + _);
        d.add("mapboxgl-" + c + "-anchor-" + h);
      }
      var ou, fc = function(u) {
        function h(c, d) {
          if (u.call(this), (c instanceof o.window.HTMLElement || d) && (c = o.extend({ element: c }, d)), o.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = c && c.anchor || "center", this._color = c && c.color || "#3FB1CE", this._scale = c && c.scale || 1, this._draggable = c && c.draggable || !1, this._clickTolerance = c && c.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = c && c.rotation || 0, this._rotationAlignment = c && c.rotationAlignment || "auto", this._pitchAlignment = c && c.pitchAlignment && c.pitchAlignment !== "auto" ? c.pitchAlignment : this._rotationAlignment, c && c.element)
            this._element = c.element, this._offset = o.Point.convert(c && c.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = g.create("div"), this._element.setAttribute("aria-label", "Map marker");
            var _ = g.createNS("http://www.w3.org/2000/svg", "svg");
            _.setAttributeNS(null, "display", "block"), _.setAttributeNS(null, "height", "41px"), _.setAttributeNS(null, "width", "27px"), _.setAttributeNS(null, "viewBox", "0 0 27 41");
            var w = g.createNS("http://www.w3.org/2000/svg", "g");
            w.setAttributeNS(null, "stroke", "none"), w.setAttributeNS(null, "stroke-width", "1"), w.setAttributeNS(null, "fill", "none"), w.setAttributeNS(null, "fill-rule", "evenodd");
            var E = g.createNS("http://www.w3.org/2000/svg", "g");
            E.setAttributeNS(null, "fill-rule", "nonzero");
            var O = g.createNS("http://www.w3.org/2000/svg", "g");
            O.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), O.setAttributeNS(null, "fill", "#000000");
            for (var k = 0, R = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; k < R.length; k += 1) {
              var $ = R[k], W = g.createNS("http://www.w3.org/2000/svg", "ellipse");
              W.setAttributeNS(null, "opacity", "0.04"), W.setAttributeNS(null, "cx", "10.5"), W.setAttributeNS(null, "cy", "5.80029008"), W.setAttributeNS(null, "rx", $.rx), W.setAttributeNS(null, "ry", $.ry), O.appendChild(W);
            }
            var H = g.createNS("http://www.w3.org/2000/svg", "g");
            H.setAttributeNS(null, "fill", this._color);
            var ne = g.createNS("http://www.w3.org/2000/svg", "path");
            ne.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), H.appendChild(ne);
            var te = g.createNS("http://www.w3.org/2000/svg", "g");
            te.setAttributeNS(null, "opacity", "0.25"), te.setAttributeNS(null, "fill", "#000000");
            var ue = g.createNS("http://www.w3.org/2000/svg", "path");
            ue.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), te.appendChild(ue);
            var Y = g.createNS("http://www.w3.org/2000/svg", "g");
            Y.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), Y.setAttributeNS(null, "fill", "#FFFFFF");
            var le = g.createNS("http://www.w3.org/2000/svg", "g");
            le.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            var me = g.createNS("http://www.w3.org/2000/svg", "circle");
            me.setAttributeNS(null, "fill", "#000000"), me.setAttributeNS(null, "opacity", "0.25"), me.setAttributeNS(null, "cx", "5.5"), me.setAttributeNS(null, "cy", "5.5"), me.setAttributeNS(null, "r", "5.4999962");
            var xe = g.createNS("http://www.w3.org/2000/svg", "circle");
            xe.setAttributeNS(null, "fill", "#FFFFFF"), xe.setAttributeNS(null, "cx", "5.5"), xe.setAttributeNS(null, "cy", "5.5"), xe.setAttributeNS(null, "r", "5.4999962"), le.appendChild(me), le.appendChild(xe), E.appendChild(O), E.appendChild(H), E.appendChild(te), E.appendChild(Y), E.appendChild(le), _.appendChild(E), _.setAttributeNS(null, "height", 41 * this._scale + "px"), _.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(_), this._offset = o.Point.convert(c && c.offset || [0, -14]);
          }
          this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", function(Pe) {
            Pe.preventDefault();
          }), this._element.addEventListener("mousedown", function(Pe) {
            Pe.preventDefault();
          }), Th(this._element, this._anchor, "marker"), this._popup = null;
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.addTo = function(c) {
          return this.remove(), this._map = c, c.getCanvasContainer().appendChild(this._element), c.on("move", this._update), c.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }, h.prototype.remove = function() {
          return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), g.remove(this._element), this._popup && this._popup.remove(), this;
        }, h.prototype.getLngLat = function() {
          return this._lngLat;
        }, h.prototype.setLngLat = function(c) {
          return this._lngLat = o.LngLat.convert(c), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }, h.prototype.getElement = function() {
          return this._element;
        }, h.prototype.setPopup = function(c) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), c) {
            if (!("offset" in c.options)) {
              var d = Math.sqrt(Math.pow(13.5, 2) / 2);
              c.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [d, -1 * (24.6 + d)], "bottom-right": [-d, -1 * (24.6 + d)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset;
            }
            this._popup = c, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }, h.prototype._onKeyPress = function(c) {
          var d = c.code, _ = c.charCode || c.keyCode;
          d !== "Space" && d !== "Enter" && _ !== 32 && _ !== 13 || this.togglePopup();
        }, h.prototype._onMapClick = function(c) {
          var d = c.originalEvent.target, _ = this._element;
          this._popup && (d === _ || _.contains(d)) && this.togglePopup();
        }, h.prototype.getPopup = function() {
          return this._popup;
        }, h.prototype.togglePopup = function() {
          var c = this._popup;
          return c ? (c.isOpen() ? c.remove() : c.addTo(this._map), this) : this;
        }, h.prototype._update = function(c) {
          if (this._map) {
            this._map.transform.renderWorldCopies && (this._lngLat = iu(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
            var d = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? d = "rotateZ(" + this._rotation + "deg)" : this._rotationAlignment === "map" && (d = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");
            var _ = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? _ = "rotateX(0deg)" : this._pitchAlignment === "map" && (_ = "rotateX(" + this._map.getPitch() + "deg)"), c && c.type !== "moveend" || (this._pos = this._pos.round()), g.setTransform(this._element, Ea[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + _ + " " + d);
          }
        }, h.prototype.getOffset = function() {
          return this._offset;
        }, h.prototype.setOffset = function(c) {
          return this._offset = o.Point.convert(c), this._update(), this;
        }, h.prototype._onMove = function(c) {
          if (!this._isDragging) {
            var d = this._clickTolerance || this._map._clickTolerance;
            this._isDragging = c.point.dist(this._pointerdownPos) >= d;
          }
          this._isDragging && (this._pos = c.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.Event("dragstart"))), this.fire(new o.Event("drag")));
        }, h.prototype._onUp = function() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.Event("dragend")), this._state = "inactive";
        }, h.prototype._addDragHandler = function(c) {
          this._element.contains(c.originalEvent.target) && (c.preventDefault(), this._positionDelta = c.point.sub(this._pos).add(this._offset), this._pointerdownPos = c.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
        }, h.prototype.setDraggable = function(c) {
          return this._draggable = !!c, this._map && (c ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }, h.prototype.isDraggable = function() {
          return this._draggable;
        }, h.prototype.setRotation = function(c) {
          return this._rotation = c || 0, this._update(), this;
        }, h.prototype.getRotation = function() {
          return this._rotation;
        }, h.prototype.setRotationAlignment = function(c) {
          return this._rotationAlignment = c || "auto", this._update(), this;
        }, h.prototype.getRotationAlignment = function() {
          return this._rotationAlignment;
        }, h.prototype.setPitchAlignment = function(c) {
          return this._pitchAlignment = c && c !== "auto" ? c : this._rotationAlignment, this._update(), this;
        }, h.prototype.getPitchAlignment = function() {
          return this._pitchAlignment;
        }, h;
      }(o.Evented), pp = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 }, au = 0, wl = !1, dp = function(u) {
        function h(c) {
          u.call(this), this.options = o.extend({}, pp, c), o.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.onAdd = function(c) {
          var d;
          return this._map = c, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), d = this._setupUI, ou !== void 0 ? d(ou) : o.window.navigator.permissions !== void 0 ? o.window.navigator.permissions.query({ name: "geolocation" }).then(function(_) {
            d(ou = _.state !== "denied");
          }) : d(ou = !!o.window.navigator.geolocation), this._container;
        }, h.prototype.onRemove = function() {
          this._geolocationWatchID !== void 0 && (o.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), g.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, au = 0, wl = !1;
        }, h.prototype._isOutOfMapMaxBounds = function(c) {
          var d = this._map.getMaxBounds(), _ = c.coords;
          return d && (_.longitude < d.getWest() || _.longitude > d.getEast() || _.latitude < d.getSouth() || _.latitude > d.getNorth());
        }, h.prototype._setErrorState = function() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }, h.prototype._onSuccess = function(c) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(c))
              return this._setErrorState(), this.fire(new o.Event("outofmaxbounds", c)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = c, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(c), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(c), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new o.Event("geolocate", c)), this._finish();
          }
        }, h.prototype._updateCamera = function(c) {
          var d = new o.LngLat(c.coords.longitude, c.coords.latitude), _ = c.coords.accuracy, w = this._map.getBearing(), E = o.extend({ bearing: w }, this.options.fitBoundsOptions);
          this._map.fitBounds(d.toBounds(_), E, { geolocateSource: !0 });
        }, h.prototype._updateMarker = function(c) {
          if (c) {
            var d = new o.LngLat(c.coords.longitude, c.coords.latitude);
            this._accuracyCircleMarker.setLngLat(d).addTo(this._map), this._userLocationDotMarker.setLngLat(d).addTo(this._map), this._accuracy = c.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }, h.prototype._updateCircleRadius = function() {
          var c = this._map._container.clientHeight / 2, d = this._map.unproject([0, c]), _ = this._map.unproject([1, c]), w = d.distanceTo(_), E = Math.ceil(2 * this._accuracy / w);
          this._circleElement.style.width = E + "px", this._circleElement.style.height = E + "px";
        }, h.prototype._onZoom = function() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }, h.prototype._onError = function(c) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (c.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                var d = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = d, this._geolocateButton.setAttribute("aria-label", d), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (c.code === 3 && wl)
                  return;
                this._setErrorState();
              }
            this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new o.Event("error", c)), this._finish();
          }
        }, h.prototype._finish = function() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }, h.prototype._setupUI = function(c) {
          var d = this;
          if (this._container.addEventListener("contextmenu", function(E) {
            return E.preventDefault();
          }), this._geolocateButton = g.create("button", "mapboxgl-ctrl-geolocate", this._container), g.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", !0), this._geolocateButton.type = "button", c === !1) {
            o.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
            var _ = this._map._getUIString("GeolocateControl.LocationNotAvailable");
            this._geolocateButton.disabled = !0, this._geolocateButton.title = _, this._geolocateButton.setAttribute("aria-label", _);
          } else {
            var w = this._map._getUIString("GeolocateControl.FindMyLocation");
            this._geolocateButton.title = w, this._geolocateButton.setAttribute("aria-label", w);
          }
          this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = g.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new fc(this._dotElement), this._circleElement = g.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new fc({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", function(E) {
            E.geolocateSource || d._watchState !== "ACTIVE_LOCK" || E.originalEvent && E.originalEvent.type === "resize" || (d._watchState = "BACKGROUND", d._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), d._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), d.fire(new o.Event("trackuserlocationend")));
          });
        }, h.prototype.trigger = function() {
          if (!this._setup)
            return o.warnOnce("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new o.Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                au--, wl = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new o.Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.Event("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
              this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              var c;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++au > 1 ? (c = { maximumAge: 6e5, timeout: 0 }, wl = !0) : (c = this.options.positionOptions, wl = !1), this._geolocationWatchID = o.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, c);
            }
          } else
            o.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }, h.prototype._clearWatch = function() {
          o.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }, h;
      }(o.Evented), Ss = { maxWidth: 100, unit: "metric" }, Ts = function(u) {
        this.options = o.extend({}, Ss, u), o.bindAll(["_onMove", "setUnit"], this);
      };
      function Mh(u, h, c) {
        var d = c && c.maxWidth || 100, _ = u._container.clientHeight / 2, w = u.unproject([0, _]), E = u.unproject([d, _]), O = w.distanceTo(E);
        if (c && c.unit === "imperial") {
          var k = 3.2808 * O;
          k > 5280 ? Ms(h, d, k / 5280, u._getUIString("ScaleControl.Miles")) : Ms(h, d, k, u._getUIString("ScaleControl.Feet"));
        } else
          c && c.unit === "nautical" ? Ms(h, d, O / 1852, u._getUIString("ScaleControl.NauticalMiles")) : O >= 1e3 ? Ms(h, d, O / 1e3, u._getUIString("ScaleControl.Kilometers")) : Ms(h, d, O, u._getUIString("ScaleControl.Meters"));
      }
      function Ms(u, h, c, d) {
        var _, w, E, O = (_ = c, (w = Math.pow(10, ("" + Math.floor(_)).length - 1)) * (E = (E = _ / w) >= 10 ? 10 : E >= 5 ? 5 : E >= 3 ? 3 : E >= 2 ? 2 : E >= 1 ? 1 : function(k) {
          var R = Math.pow(10, Math.ceil(-Math.log(k) / Math.LN10));
          return Math.round(k * R) / R;
        }(E)));
        u.style.width = h * (O / c) + "px", u.innerHTML = O + "&nbsp;" + d;
      }
      Ts.prototype.getDefaultPosition = function() {
        return "bottom-left";
      }, Ts.prototype._onMove = function() {
        Mh(this._map, this._container, this.options);
      }, Ts.prototype.onAdd = function(u) {
        return this._map = u, this._container = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", u.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
      }, Ts.prototype.onRemove = function() {
        g.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
      }, Ts.prototype.setUnit = function(u) {
        this.options.unit = u, Mh(this._map, this._container, this.options);
      };
      var Ho = function(u) {
        this._fullscreen = !1, u && u.container && (u.container instanceof o.window.HTMLElement ? this._container = u.container : o.warnOnce("Full screen control 'container' must be a DOM element.")), o.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in o.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in o.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in o.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in o.window.document && (this._fullscreenchange = "MSFullscreenChange");
      };
      Ho.prototype.onAdd = function(u) {
        return this._map = u, this._container || (this._container = this._map.getContainer()), this._controlContainer = g.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", o.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
      }, Ho.prototype.onRemove = function() {
        g.remove(this._controlContainer), this._map = null, o.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
      }, Ho.prototype._checkFullscreenSupport = function() {
        return !!(o.window.document.fullscreenEnabled || o.window.document.mozFullScreenEnabled || o.window.document.msFullscreenEnabled || o.window.document.webkitFullscreenEnabled);
      }, Ho.prototype._setupUI = function() {
        var u = this._fullscreenButton = g.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
        g.create("span", "mapboxgl-ctrl-icon", u).setAttribute("aria-hidden", !0), u.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), o.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
      }, Ho.prototype._updateTitle = function() {
        var u = this._getTitle();
        this._fullscreenButton.setAttribute("aria-label", u), this._fullscreenButton.title = u;
      }, Ho.prototype._getTitle = function() {
        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
      }, Ho.prototype._isFullscreen = function() {
        return this._fullscreen;
      }, Ho.prototype._changeIcon = function() {
        (o.window.document.fullscreenElement || o.window.document.mozFullScreenElement || o.window.document.webkitFullscreenElement || o.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
      }, Ho.prototype._onClickFullscreen = function() {
        this._isFullscreen() ? o.window.document.exitFullscreen ? o.window.document.exitFullscreen() : o.window.document.mozCancelFullScreen ? o.window.document.mozCancelFullScreen() : o.window.document.msExitFullscreen ? o.window.document.msExitFullscreen() : o.window.document.webkitCancelFullScreen && o.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
      };
      var mp = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, pc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), yp = function(u) {
        function h(c) {
          u.call(this), this.options = o.extend(Object.create(mp), c), o.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
        }
        return u && (h.__proto__ = u), (h.prototype = Object.create(u && u.prototype)).constructor = h, h.prototype.addTo = function(c) {
          return this._map && this.remove(), this._map = c, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.Event("open")), this;
        }, h.prototype.isOpen = function() {
          return !!this._map;
        }, h.prototype.remove = function() {
          return this._content && g.remove(this._content), this._container && (g.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new o.Event("close")), this;
        }, h.prototype.getLngLat = function() {
          return this._lngLat;
        }, h.prototype.setLngLat = function(c) {
          return this._lngLat = o.LngLat.convert(c), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }, h.prototype.trackPointer = function() {
          return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }, h.prototype.getElement = function() {
          return this._container;
        }, h.prototype.setText = function(c) {
          return this.setDOMContent(o.window.document.createTextNode(c));
        }, h.prototype.setHTML = function(c) {
          var d, _ = o.window.document.createDocumentFragment(), w = o.window.document.createElement("body");
          for (w.innerHTML = c; d = w.firstChild; )
            _.appendChild(d);
          return this.setDOMContent(_);
        }, h.prototype.getMaxWidth = function() {
          return this._container && this._container.style.maxWidth;
        }, h.prototype.setMaxWidth = function(c) {
          return this.options.maxWidth = c, this._update(), this;
        }, h.prototype.setDOMContent = function(c) {
          if (this._content)
            for (; this._content.hasChildNodes(); )
              this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else
            this._content = g.create("div", "mapboxgl-popup-content", this._container);
          return this._content.appendChild(c), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }, h.prototype.addClassName = function(c) {
          this._container && this._container.classList.add(c);
        }, h.prototype.removeClassName = function(c) {
          this._container && this._container.classList.remove(c);
        }, h.prototype.setOffset = function(c) {
          return this.options.offset = c, this._update(), this;
        }, h.prototype.toggleClassName = function(c) {
          if (this._container)
            return this._container.classList.toggle(c);
        }, h.prototype._createCloseButton = function() {
          this.options.closeButton && (this._closeButton = g.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }, h.prototype._onMouseUp = function(c) {
          this._update(c.point);
        }, h.prototype._onMouseMove = function(c) {
          this._update(c.point);
        }, h.prototype._onDrag = function(c) {
          this._update(c.point);
        }, h.prototype._update = function(c) {
          var d = this;
          if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = g.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = g.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function(W) {
            return d._container.classList.add(W);
          }), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = iu(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || c)) {
            var _ = this._pos = this._trackPointer && c ? c : this._map.project(this._lngLat), w = this.options.anchor, E = function W(H) {
              if (H) {
                if (typeof H == "number") {
                  var ne = Math.round(Math.sqrt(0.5 * Math.pow(H, 2)));
                  return { center: new o.Point(0, 0), top: new o.Point(0, H), "top-left": new o.Point(ne, ne), "top-right": new o.Point(-ne, ne), bottom: new o.Point(0, -H), "bottom-left": new o.Point(ne, -ne), "bottom-right": new o.Point(-ne, -ne), left: new o.Point(H, 0), right: new o.Point(-H, 0) };
                }
                if (H instanceof o.Point || Array.isArray(H)) {
                  var te = o.Point.convert(H);
                  return { center: te, top: te, "top-left": te, "top-right": te, bottom: te, "bottom-left": te, "bottom-right": te, left: te, right: te };
                }
                return { center: o.Point.convert(H.center || [0, 0]), top: o.Point.convert(H.top || [0, 0]), "top-left": o.Point.convert(H["top-left"] || [0, 0]), "top-right": o.Point.convert(H["top-right"] || [0, 0]), bottom: o.Point.convert(H.bottom || [0, 0]), "bottom-left": o.Point.convert(H["bottom-left"] || [0, 0]), "bottom-right": o.Point.convert(H["bottom-right"] || [0, 0]), left: o.Point.convert(H.left || [0, 0]), right: o.Point.convert(H.right || [0, 0]) };
              }
              return W(new o.Point(0, 0));
            }(this.options.offset);
            if (!w) {
              var O, k = this._container.offsetWidth, R = this._container.offsetHeight;
              O = _.y + E.bottom.y < R ? ["top"] : _.y > this._map.transform.height - R ? ["bottom"] : [], _.x < k / 2 ? O.push("left") : _.x > this._map.transform.width - k / 2 && O.push("right"), w = O.length === 0 ? "bottom" : O.join("-");
            }
            var $ = _.add(E[w]).round();
            g.setTransform(this._container, Ea[w] + " translate(" + $.x + "px," + $.y + "px)"), Th(this._container, w, "popup");
          }
        }, h.prototype._focusFirstElement = function() {
          if (this.options.focusAfterOpen && this._container) {
            var c = this._container.querySelector(pc);
            c && c.focus();
          }
        }, h.prototype._onClose = function() {
          this.remove();
        }, h;
      }(o.Evented), Ih = { version: o.version, supported: m, setRTLTextPlugin: o.setRTLTextPlugin, getRTLTextPluginStatus: o.getRTLTextPluginStatus, Map: zm, NavigationControl: Ga, GeolocateControl: dp, AttributionControl: Gi, ScaleControl: Ts, FullscreenControl: Ho, Popup: yp, Marker: fc, Style: lo, LngLat: o.LngLat, LngLatBounds: o.LngLatBounds, Point: o.Point, MercatorCoordinate: o.MercatorCoordinate, Evented: o.Evented, config: o.config, prewarm: function() {
        Le().acquire(Ce);
      }, clearPrewarmedResources: function() {
        var u = Et;
        u && (u.isPreloaded() && u.numActive() === 1 ? (u.release(Ce), Et = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get accessToken() {
        return o.config.ACCESS_TOKEN;
      }, set accessToken(u) {
        o.config.ACCESS_TOKEN = u;
      }, get baseApiUrl() {
        return o.config.API_URL;
      }, set baseApiUrl(u) {
        o.config.API_URL = u;
      }, get workerCount() {
        return Ue.workerCount;
      }, set workerCount(u) {
        Ue.workerCount = u;
      }, get maxParallelImageRequests() {
        return o.config.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(u) {
        o.config.MAX_PARALLEL_IMAGE_REQUESTS = u;
      }, clearStorage: function(u) {
        o.clearTileCache(u);
      }, workerUrl: "" };
      return Ih;
    }), s;
  });
})(nI);
const iE = nI.exports;
class iI extends kC {
  constructor(e) {
    const n = Object.assign({}, e);
    delete n.accessToken, delete n.style, delete n.container, delete n.xyz, super(n), this.set("xyz", e.maplibreOptions.xyz), this.set("xyz_custom", e.maplibreOptions.xyz_custom), this.xyz_ = e.xyz, e.accessToken && (iE.accessToken = e.accessToken), this.map_ = new iE.Map({
      container: e.maplibreOptions.container,
      style: e.maplibreOptions.style,
      attributionControl: !1,
      interactive: !1
    }), this.maplibreMap = this.map_;
  }
  getMapBoxMap() {
    return this.map_;
  }
  getMapLibreMap() {
    return this.map_;
  }
  render(e) {
    const n = this.map_.getCanvas(), a = e.viewState;
    n.style.position = "absolute";
    const s = this.getVisible();
    n.style.display = s ? "block" : "none";
    const f = this.getOpacity().toString();
    f !== n.style.opacity && (n.style.opacity = f);
    const o = a.rotation;
    return o && this.map_.rotateTo(LC(-o), {
      animate: !1
    }), this.map_.jumpTo({
      center: DC(a.center),
      zoom: a.zoom - 1,
      animate: !1
    }), this.map_._frame && (this.map_._frame.cancel(), this.map_._frame = null), this.map_._render(), n;
  }
  setLayerVisibility(e, n) {
    this.map_.setLayoutProperty(
      e,
      "visibility",
      n ? "visible" : "none"
    );
  }
  getStyle() {
    return this.map_.getStyle();
  }
  getXYZ() {
    return this.get("xyz");
  }
}
class wF {
  createOlLayer(e, n) {
    const a = Vl(), { id: s, metadata: f, name: o } = e, m = n.get(s);
    if (!m)
      return;
    const g = {
      container: a.getOlMap().getTarget(),
      ...m
    }, b = new iI({
      maplibreOptions: g,
      label: o,
      id: s,
      queryable_id: s,
      metadata: f
    }), T = Ks();
    return b != null && b.getMapLibreMap().loaded() ? T.setBaseStyle(s, b == null ? void 0 : b.getMapLibreMap().getStyle()) : new Promise(
      (M) => b == null ? void 0 : b.getMapLibreMap().once("data", M)
    ).then(
      () => T.setBaseStyle(s, b == null ? void 0 : b.getMapLibreMap().getStyle())
    ), b;
  }
}
const EF = new wF();
class SF {
  createOlLayer(e, n) {
    let a;
    if (n && (a = EF.createOlLayer(e, n)), !a)
      switch (e.type) {
        case "WMS":
          a = tI.createOlLayer(e);
          break;
        case "WMTS":
        case "BG WMTS":
          a = rI.createOlLayer(e);
          break;
        default:
          throw new Error(`Unrecognized layer type: ${e.type}`);
      }
    return a.set("id", e.id), a.set("label", e.name), a.set("layer_name", e.name), a.set("metadata", e.metadata), a.set("queryable_id", e.id), a.set("current_time", cs().getLayerCurrentTime(e)), a.set("time", e.time), a.setOpacity(e.opacity), a;
  }
}
const oE = new SF();
class TF {
  setLayerTime(e, n) {
    const a = e.getSource();
    a instanceof PE && tI.setLayerTime(a, n), a instanceof AE && rI.setLayerTime(e, a, n);
  }
}
const MF = new TF(), Uy = -200;
function oI() {
  function t(A, z) {
    if (!z)
      return;
    const V = b(z);
    A.addLayer(V);
  }
  function e(A, z) {
    return A.getLayers().getArray().find((V) => V.get("id") === z);
  }
  function n(A, z) {
    const V = e(A, z);
    V && A.removeLayer(V);
  }
  function a(A, z) {
    const V = A.getLayers().getArray();
    z.forEach((q, re) => {
      const X = V.find(
        (ae) => ae.get("id") === q.id
      );
      X == null || X.setZIndex(re + 1);
    });
  }
  function s(A, z, V) {
    const q = A.getLayers().getArray().find((re) => re.get("id") === z);
    q && q.setOpacity(V);
  }
  function f(A, z) {
    const V = cs(), q = e(A, z.id), re = V.getLayerCurrentTime(z);
    re && q && MF.setLayerTime(q, re);
  }
  function o(A) {
    Hp.delete(A);
  }
  function m(A) {
    return Hp.has(A.id);
  }
  function g(A, z) {
    Hp.set(A, z);
  }
  function b(A) {
    const z = A.id, V = Hp.get(z);
    if (V)
      return V;
    {
      const q = oE.createOlLayer(A);
      return g(z, q), q;
    }
  }
  function T(A) {
    return A && Hp.get(A.id) || null;
  }
  function M(A, z) {
    const q = A.getLayers().getArray().find((re) => re.getZIndex() === Uy);
    q && z(q);
  }
  function I(A, z, V) {
    var ce;
    const q = A.getLayers(), re = q.getArray().findIndex((ve) => ve.getZIndex() === Uy), X = (ce = q.getArray()[re]) == null ? void 0 : ce.get("id");
    let ae;
    z && (m(z) ? ae = T(z) : (ae = oE.createOlLayer(
      z,
      V
    ), g(z.id, ae))), re >= 0 ? ae ? (ae.setZIndex(Uy), q.setAt(re, ae)) : q.removeAt(re) : ae && (ae.setZIndex(Uy), A.addLayer(ae)), X && X !== (z == null ? void 0 : z.id) && JM.restoreStyle(!0);
  }
  return {
    addLayer: t,
    findLayer: e,
    removeLayer: n,
    removeFromCache: o,
    reorderLayers: a,
    setLayerOpacity: s,
    setLayerTime: f,
    getLayerFromCache: T,
    setBgLayer: I,
    applyOnBgLayer: M
  };
}
class IF {
  constructor(e) {
    ri(this, "previousLayers");
    ri(this, "previousVectorSources");
    const n = Ei(), a = Ks(), s = Vl(), f = qf(), o = oI(), { appliedStyle: m } = pn(a);
    An(
      () => n.layers,
      (g) => {
        const b = {
          layers: this.previousLayers
        }, T = {
          layers: g
        }, M = s.getRemovedLayers(
          T,
          b
        ), I = s.getAddedLayers(
          T,
          b
        ), A = s.getMutatedLayers(
          T,
          b
        );
        M.forEach((z) => o.removeLayer(e, z.id)), I.forEach((z) => {
          o.addLayer(e, z.layer), o.setLayerTime(e, z.layer);
        }), A.forEach((z) => {
          o.setLayerOpacity(e, z.id, z.opacity), o.setLayerTime(e, z);
        }), T.layers && o.reorderLayers(e, T.layers), this.previousLayers = g;
      }
    ), An(
      () => n.bgLayer,
      (g) => g !== void 0 && o.setBgLayer(e, g, a.bgVectorSources)
    ), va(() => {
      a.isExpertStyleActive || (m.value = f.applyDefaultStyle(
        n.bgLayer,
        a.bgVectorBaseStyles,
        a.bgStyle
      ));
    }), An(m, (g) => {
      a.bgStyle === null && !a.isExpertStyleActive ? f.unregisterStyle(a.styleSerial, a.registerUrls).then(a.styleSerial = null) : f.registerStyle(g, a.styleSerial, a.registerUrls).then((b) => {
        var M;
        a.styleSerial = b;
        const T = (M = n == null ? void 0 : n.bgLayer) == null ? void 0 : M.id;
        (n == null ? void 0 : n.bgLayer) && T !== void 0 && b !== void 0 && (o.applyOnBgLayer(e, (I) => {
          I.set(
            "xyz_custom",
            f.getDefaultMapBoxStyleXYZ(b)
          );
        }), o.setBgLayer(
          e,
          n == null ? void 0 : n.bgLayer,
          a.bgVectorSources
        ));
      }), o.applyOnBgLayer(
        e,
        (b) => f.applyConsolidatedStyle(b, g)
      );
    }), An(
      () => a.bgVectorSources,
      (g) => {
        var b;
        for (const T of g.keys())
          (!this.previousVectorSources || this.previousVectorSources.get(T) !== g.get(T)) && (o.removeFromCache(T), T === ((b = n == null ? void 0 : n.bgLayer) == null ? void 0 : b.id) && o.setBgLayer(e, n == null ? void 0 : n.bgLayer, g));
        this.previousVectorSources = g;
      }
    );
  }
}
const OF = {
  0: 8,
  1: 9,
  2: 9,
  3: 10,
  4: 11,
  5: 12,
  6: 13,
  7: 14,
  8: 16,
  9: 17,
  10: 18,
  11: 19,
  12: 20,
  13: 21
};
class CF {
  bootstrap() {
    this.restore(), this.persist();
  }
  persistZoom() {
    const e = Vl().getOlMap().getView(), n = () => {
      const a = e.getZoom();
      Cr.setValue(Q2, a ? Math.ceil(a) : null);
    };
    n(), Nb.listen(
      e,
      "change:resolution",
      Z2(n, 300)
    );
  }
  persistXY() {
    const e = Vl().getOlMap().getView(), n = () => {
      const a = e.getCenter();
      Cr.setValue(eE, a ? Math.round(a[0]) : null), Cr.setValue(tE, a ? Math.round(a[1]) : null);
    };
    n(), Nb.listen(
      e,
      NC.PROPERTYCHANGE,
      Z2(n, 300)
    );
  }
  persist() {
    this.persistXY(), this.persistZoom();
  }
  restore() {
    const e = Vl().getOlMap().getView(), n = Cr.getValue(Q2, Cf), a = Cr.getInitialVersion(), s = Cr.getValue(eE, Cf), f = Cr.getValue(tE, Cf), o = Cr.getValue(X6), m = SC(
      i5,
      gd
    );
    let g, b;
    n !== void 0 ? b = a === 3 ? Number(n) : OF[n] : b = 8, s != null && f != null ? a === 3 && o != null ? g = Db([s, f], o, gd) : g = a === 3 ? [s, f] : m([f, s], void 0, 2) : g = Db(
      [6, 49.7],
      VT,
      gd
    ), e.setCenter(g), e.setZoom(b);
  }
}
const PF = new CF(), AF = {
  key: 0,
  class: "absolute bottom-0 z-10 text-[0.8em] px-[4px] text-[#6b818f] bg-[#ffffffb3]"
}, kF = /* @__PURE__ */ ir({
  __name: "attribution-control",
  setup(t) {
    const e = Ei(), n = Er("");
    return va(() => {
      var a, s;
      n.value = ((s = (a = e.bgLayer) == null ? void 0 : a.metadata) == null ? void 0 : s.attribution) || "";
    }), (a, s) => {
      const f = Nx("dompurify-html");
      return n.value ? Og((Be(), rt("div", AF, null, 512)), [
        [f, n.value]
      ]) : Ye("v-if", !0);
    };
  }
}), LF = /* @__PURE__ */ lr(kF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/attribution-control.vue"]]);
function im(t, e) {
  const n = new t(e), a = Vl(), s = Sf("olMap");
  return _a(() => {
    s.addControl(n), s.changed();
  }), $u(() => {
    const f = a.getOlMap();
    f.removeControl(n), f.changed();
  }), {
    control: n
  };
}
const DF = ["title"], NF = /* @__PURE__ */ ir({
  __name: "location-control",
  props: {
    className: { type: String, required: !1, default: "location-button" },
    label: { type: String, required: !1, default: "\uE800" },
    tipLabel: { type: String, required: !1, default: "Location" }
  },
  setup(t) {
    const e = t, { t: n } = En(), a = Er(null);
    function s() {
    }
    return _a(
      () => im(DE, { ...e, target: a })
    ), (f, o) => (Be(), rt("div", {
      ref_key: "controlElement",
      ref: a,
      class: Br(`tracker-off ${e.className} ${se(kE)} ${se(LE)}`)
    }, [
      Fe("button", {
        title: se(n)(e.tipLabel),
        onClick: s
      }, Ht(e.label), 9, DF)
    ], 2));
  }
}), RF = /* @__PURE__ */ lr(NF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/location-control.vue"]]), zF = ["title"], FF = /* @__PURE__ */ ir({
  __name: "map-3d",
  props: {
    className: { type: String, required: !1, default: "map-3d-button" },
    label: { type: String, required: !1, default: "\uE057" },
    tipLabel: { type: String, required: !1, default: "3d" }
  },
  setup(t) {
    const e = t, n = Ei(), { t: a } = En(), s = Er(null);
    _a(
      () => im(DE, { ...e, target: s })
    );
    const f = () => {
      n.setIs3dActive(!n.is3dActive);
    };
    return (o, m) => (Be(), rt("div", {
      ref_key: "controlElement",
      ref: s,
      class: Br(`${e.className} ${se(kE)} ${se(LE)} ${se(n).is3dActive ? "active" : ""}`)
    }, [
      Fe("button", {
        title: se(a)(e.tipLabel),
        onClick: f
      }, Ht(e.label), 9, zF)
    ], 2));
  }
}), BF = /* @__PURE__ */ lr(FF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/map-3d.vue"]]), VF = /* @__PURE__ */ ir({
  __name: "fullscreen-control",
  props: {
    className: { type: String, required: !1 },
    label: { type: String, required: !1, default: "\uE01C" },
    labelActive: { type: String, required: !1, default: "\uE02C" }
  },
  setup(t) {
    return im(RC, t), (n, a) => Ye("v-if", !0);
  }
}), UF = /* @__PURE__ */ lr(VF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/fullscreen-control.vue"]]), jF = /* @__PURE__ */ ir({
  __name: "zoom-control",
  props: {
    className: { type: String, required: !1 },
    zoomInLabel: { type: String, required: !1, default: "\uE032" },
    zoomOutLabel: { type: String, required: !1, default: "\uE033" }
  },
  setup(t) {
    return im(zC, t), (n, a) => Ye("v-if", !0);
  }
}), GF = /* @__PURE__ */ lr(jF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/zoom-control.vue"]]);
class $F extends FC {
  constructor(n) {
    super(n);
    ri(this, "ol3dm");
  }
  handleZoomToExtent() {
    this.ol3dm && this.ol3dm.luxCameraExtentInRadians && this.ol3dm.is3dEnabled() || super.handleZoomToExtent();
  }
}
const qF = /* @__PURE__ */ ir({
  __name: "zoom-to-extent-control",
  props: {
    className: { type: String, required: !1 },
    label: { type: String, required: !1, default: "\uE01B" },
    tipLabel: { type: String, required: !1 },
    extent: { type: null, required: !0 }
  },
  setup(t) {
    return im($F, t), (n, a) => Ye("v-if", !0);
  }
}), WF = /* @__PURE__ */ lr(qF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map-controls/zoom-to-extent-control.vue"]]), HF = /* @__PURE__ */ ir({
  __name: "map-container",
  props: {
    v4_standalone: { type: Boolean, required: !1, default: !1 }
  },
  setup(t) {
    const e = Vl(), n = Er(null), a = e.createMap(), s = [
      425152.9429259216,
      632446599999133e-8,
      914349.9239510496,
      6507914867875754e-9
    ];
    return _a(() => {
      n.value && (new IF(a), PF.bootstrap(), a.setTarget(n.value), window.olMap = a);
    }), wS("olMap", a), (f, o) => (Be(), rt("div", {
      id: "map-container",
      ref_key: "mapContainer",
      ref: n,
      class: "h-full w-full bg-white relative"
    }, [
      kt(GF),
      kt(WF, { extent: s }),
      kt(UF),
      kt(LF),
      t.v4_standalone ? (Be(), an(BF, { key: 0 })) : Ye("v-if", !0),
      kt(RF)
    ], 512));
  }
}), ZF = /* @__PURE__ */ lr(HF, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/map/map-container.vue"]]), XF = "fr", KF = !0, YF = !1, JF = !1, Ai = ih(
  "app",
  () => {
    const t = Er(XF), e = Er(KF), n = Er(YF), a = Er(JF), s = Er(), f = Er(), o = Er(!1);
    function m(V) {
      t.value = V;
    }
    function g(V) {
      e.value = V, V || (a.value = !1, n.value = !1);
    }
    function b(V) {
      n.value = V, V && (a.value = !1);
    }
    function T(V) {
      a.value = V;
    }
    function M(V) {
      f.value = V;
    }
    function I(V) {
      s.value = V;
    }
    function A() {
      o.value = !0;
    }
    function z() {
      o.value = !1;
    }
    return {
      lang: t,
      layersOpen: e,
      myLayersTabOpen: n,
      themeGridOpen: a,
      mapId: s,
      styleEditorOpen: o,
      remoteLayersOpen: f,
      setLang: m,
      setLayersOpen: g,
      setMyLayersTabOpen: b,
      setThemeGridOpen: T,
      setRemoteLayersOpen: M,
      setMapId: I,
      openStyleEditorPanel: A,
      closeStyleEditorPanel: z
    };
  },
  {}
), Jg = {
  name: "blank",
  id: 0
};
function aI() {
  const t = Ai(), { mapId: e } = pn(t), n = Kc(), a = Ei(), s = cs(), f = ar(() => {
    var M;
    if (!e.value) {
      const I = (M = Ro().theme) == null ? void 0 : M.name;
      if (I)
        return as().bg_layer_theme_defaults[I] || g();
    }
    return g();
  });
  function o(M) {
    const I = n.findBgLayerById(M);
    m(I || null);
  }
  function m(M) {
    if (M) {
      if (M.type === "WMTS" || M.type === "BG WMTS")
        M.type = "BG WMTS";
      else if (M.type === "BG MVT")
        console.log(`passed through MVT layer ${M.name}`);
      else
        throw new Error(
          `Only WMTS and MVT BG layers are currently implemented (not ${M.type} for ${M.name})`
        );
      s.handleExclusionLayers(M), a.setBgLayer(s.initLayer(M));
    } else
      a.setBgLayer(null);
  }
  function g() {
    var M;
    return ((M = T().find((I) => I.is_default)) == null ? void 0 : M.id) || Jg.id;
  }
  function b() {
    return Jg.id;
  }
  function T() {
    return as().bg_layers;
  }
  return {
    setBgLayer: o,
    setMapBackground: m,
    getBgLayersFromConfig: T,
    getNullId: b,
    getDefaultSelectedId: g,
    defaultSelectedBgId: f
  };
}
const QF = ["title"], eB = /* @__PURE__ */ ir({
  __name: "background-selector-item",
  props: {
    bgTitle: {
      type: String,
      default: ""
    },
    bgName: {
      type: String,
      default: ""
    }
  },
  setup(t) {
    const e = t, { t: n } = En(), a = ar(() => {
      const f = n(e.bgTitle), o = e.bgTitle.length > 0, m = `${n("Background layer:")} ${n(e.bgName)}`;
      return `${f}${o ? " - " : ""}${m}`;
    }), s = ar(
      () => `h-full w-full rounded-sm lux-bg-sel-icon
        lux-bg-sel-${e.bgName}
        bg-${e.bgName}_sm
        md:bg-${e.bgName}
        hd:bg-${e.bgName}_sm_hi
        hd_md:bg-${e.bgName}_hi`
    );
    return (f, o) => (Be(), rt("button", {
      title: se(a),
      class: Br(se(s))
    }, null, 10, QF));
  }
}), aE = /* @__PURE__ */ lr(eB, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/background-selector/background-selector-item.vue"]]), tB = {
  key: 0,
  class: "flex flex-row-reverse"
}, rB = /* @__PURE__ */ ir({
  __name: "background-selector",
  props: {
    isOpen: {
      type: Boolean,
      default: !1
    }
  },
  setup(t) {
    const e = t, { t: n } = En(), a = aI(), s = Ei(), f = Ro(), { bgLayer: o, is3dMesh: m } = pn(s), g = Er(e.isOpen), b = Er([]), T = ar(
      () => {
        var z, V;
        return (V = (z = o.value) == null ? void 0 : z.id) != null ? V : a.getNullId();
      }
    ), M = ar(
      () => {
        var z, V;
        return (V = (z = b.value) == null ? void 0 : z.find((q) => q.id === T.value)) == null ? void 0 : V.name;
      }
    );
    An(
      () => f.bgLayers,
      (z) => {
        b.value = as().bg_layers.map(
          (V) => Object.assign(
            {
              id: V.id
            },
            z.find((q) => V.id === q.id),
            {
              name: V.icon_id
            }
          )
        );
      },
      { immediate: !0 }
    ), An(
      () => s.bgLayer,
      (z, V) => {
        const q = s.layers;
        V === void 0 && z === null && (q == null ? void 0 : q.length) === 0 && (a.setBgLayer(a.defaultSelectedBgId.value), z === null && Bg().addNotification(
          n(
            "Aucune couche n'\xE9tant d\xE9finie pour cette carte, une couche de fond a automatiquement \xE9t\xE9 ajout\xE9e.",
            { ns: "client" }
          )
        ));
      }
    );
    function I(z) {
      a.setBgLayer(z.id), g.value = !1;
    }
    function A() {
      g.value = !g.value;
    }
    return (z, V) => se(m) ? Ye("v-if", !0) : (Be(), rt("div", tB, [
      Fe("div", {
        class: Br(["lux-bg-sel border border-black", g.value === !0 ? "hidden" : "block"])
      }, [
        kt(aE, {
          "aria-expanded": g.value,
          "bg-title": "Select BG layer",
          "bg-name": se(M),
          onClick: A
        }, null, 8, ["aria-expanded", "bg-name"])
      ], 2),
      Fe("div", {
        class: Br(g.value === !0 ? "flex flex-col md:flex-row" : "hidden")
      }, [
        (Be(!0), rt(on, null, Ra(b.value, (q) => (Be(), rt("div", {
          key: q.id,
          class: Br([
            "lux-bg-sel hover:bg-cyan-600",
            q.id === se(T) ? "border-red-500 border-2" : "border-black border"
          ])
        }, [
          kt(aE, {
            "bg-name": q.name,
            onClick: (re) => I(q)
          }, null, 8, ["bg-name", "onClick"])
        ], 2))), 128))
      ], 2)
    ]));
  }
}), nB = /* @__PURE__ */ lr(rB, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/background-selector/background-selector.vue"]]), iB = /* @__PURE__ */ Fe("div", { class: "fixed inset-0 bg-gray-900 opacity-40 z-[1050]" }, null, -1), oB = { class: "bg-white shadow-modal rounded-lg overflow-hidden w-[700px]" }, aB = { class: "relative flex flex-row justify-center p-4 border-b-[1px]" }, sB = { class: "text-xl" }, lB = /* @__PURE__ */ Fe("span", { "aria-hidden": "true" }, "\xD7", -1), uB = [
  lB
], cB = {
  key: 0,
  class: "p-[15px] border-t-[1px]"
}, hB = { class: "flex flex-row justify-end" }, fB = /* @__PURE__ */ ir({
  __name: "modal-dialog",
  props: {
    footer: {
      type: Boolean,
      default: !0
    },
    maxHeight: {
      type: Boolean,
      default: !1
    },
    title: String
  },
  emits: ["close"],
  setup(t) {
    const { t: e } = En(), n = Er();
    _a(() => {
      n.value.focus();
    });
    const a = Bn(!0);
    function s() {
      a.value = !1;
    }
    return (f, o) => (Be(), an(jS, { to: "body" }, [
      Ye(" backdrop "),
      iB,
      Ye(" modal "),
      kt(Tv, {
        appear: "",
        "enter-active-class": "duration-200 ease-out",
        "enter-from-class": "transform opacity-0 -translate-y-60",
        "enter-to-class": "opacity-100 translate-y-0",
        "leave-active-class": "duration-200 ease-in",
        "leave-from-class": "opacity-100 translate-y-0",
        "leave-to-class": "transform opacity-0 -translate-y-60",
        onAfterLeave: o[3] || (o[3] = (m) => f.$emit("close"))
      }, {
        default: ku(() => [
          se(a) ? (Be(), rt("div", {
            key: 0,
            role: "dialog",
            ref_key: "modal",
            ref: n,
            tabindex: "0",
            onKeydown: o[2] || (o[2] = Gs(js((m) => s(), ["stop"]), ["esc"])),
            class: "fixed inset-x-0 inset-y-8 flex items-start justify-center z-[1100] outline-none"
          }, [
            Fe("div", oB, [
              Ye(" header (title)"),
              Fe("div", aB, [
                Fe("h4", sB, Ht(t.title), 1),
                Fe("button", {
                  type: "button",
                  class: "absolute right-2 top-1 text-slate-400 text-[24px]",
                  "data-dismiss": "modal",
                  "aria-label": "Close",
                  onClick: o[0] || (o[0] = (m) => s())
                }, uB)
              ]),
              Ye(" content slot "),
              Fe("div", {
                class: Br(["p-[15px] overflow-y-auto", t.maxHeight ? "max-h-96" : "max-h-full"])
              }, [
                AS(f.$slots, "content")
              ], 2),
              Ye(" footer (optional)"),
              t.footer ? (Be(), rt("div", cB, [
                Fe("div", hB, [
                  Fe("button", {
                    type: "button",
                    class: "lux-btn",
                    "data-dismiss": "modal",
                    onClick: o[1] || (o[1] = (m) => s())
                  }, Ht(se(e)("Close", { ns: "client" })), 1)
                ])
              ])) : Ye("v-if", !0)
            ])
          ], 544)) : Ye("v-if", !0)
        ]),
        _: 3
      })
    ]));
  }
}), sI = /* @__PURE__ */ lr(fB, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/common/modal-dialog.vue"]]), n1 = ih(
  "metadata",
  () => {
    const t = Er();
    function e(a) {
      t.value = a;
    }
    function n() {
      t.value = void 0;
    }
    return {
      metadataId: t,
      setMetadataId: e,
      clearMetadataId: n
    };
  },
  {}
), pB = ["aria-expanded"], dB = { class: "leading-6" }, mB = /* @__PURE__ */ ir({
  __name: "expandable-panel",
  props: {
    expanded: { type: Boolean, required: !0 },
    title: { type: String, required: !0 }
  },
  emits: ["togglePanel"],
  setup(t) {
    return (e, n) => (Be(), rt(on, null, [
      Fe("button", {
        onClick: n[0] || (n[0] = (a) => e.$emit("togglePanel")),
        class: "group w-full text-left flex px-2 py-1.5 uppercase bg-tertiary",
        "aria-expanded": t.expanded
      }, [
        Fe("div", {
          class: Br(["grow", t.expanded ? "text-white" : "text-secondary"])
        }, Ht(t.title), 3),
        Fe("div", dB, [
          Fe("div", {
            class: Br(["fa fa-sharp fa-solid group-hover:text-white text-primary", t.expanded ? "fa-caret-up" : "fa-caret-down"])
          }, null, 2)
        ])
      ], 8, pB),
      Fe("div", {
        class: Br(t.expanded ? "" : "hidden")
      }, [
        AS(e.$slots, "default")
      ], 2)
    ], 64));
  }
}), pg = /* @__PURE__ */ lr(mB, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/common/expandable-panel.vue"]]), yB = {
  class: "mb-px",
  key: "node.id"
}, gB = ["data-cy"], vB = ["aria-expanded", "data-cy"], _B = { class: "grow" }, xB = { class: "leading-6" }, bB = {
  key: 1,
  class: "flex text-tertiary pr-2"
}, wB = ["data-cy"], EB = { class: "ml-1 hover:underline" }, SB = /* @__PURE__ */ ir({
  __name: "layer-tree-node",
  props: {
    node: { type: null, required: !0 }
  },
  emits: ["toggleLayer", "toggleParent"],
  setup(t, { emit: e }) {
    const n = t, { t: a } = En(), { setMetadataId: s } = n1(), f = !!n.node.children, o = n.node.depth === 0, m = n.node.depth >= 10, g = ar(() => a(n.node.name, { ns: "client" }));
    function b(M) {
      e("toggleLayer", M);
    }
    function T(M) {
      e("toggleParent", M);
    }
    return (M, I) => {
      const A = AA("layer-tree-node", !0);
      return f ? (Be(), rt("div", yB, [
        Ye("    First level parents"),
        t.node.depth === 1 ? (Be(), rt("div", {
          key: 0,
          "data-cy": `parentLayerLabel-${t.node.id}`
        }, [
          kt(pg, {
            title: se(g),
            expanded: t.node.expanded,
            onTogglePanel: I[0] || (I[0] = (z) => T(t.node))
          }, null, 8, ["title", "expanded"])
        ], 8, gB)) : t.node.depth > 1 && !m ? (Be(), rt(on, { key: 1 }, [
          Ye("    Other parents (with custom panel style)"),
          Fe("button", {
            class: Br(["w-full text-left flex px-2 py-1.5 pl-2", t.node.expanded ? "text-tertiary" : "bg-white text-primary"]),
            "aria-expanded": t.node.expanded,
            onClick: I[1] || (I[1] = (z) => T(t.node)),
            "data-cy": `parentLayerLabel-${t.node.id}`
          }, [
            Fe("div", _B, Ht(se(g)), 1),
            Fe("div", xB, [
              Fe("div", {
                class: Br(["fa-sharp fa-solid", t.node.expanded ? "fa-minus" : "fa-plus"])
              }, null, 2)
            ])
          ], 10, vB)
        ], 2112)) : Ye("v-if", !0),
        Ye("    Children"),
        m ? Ye("v-if", !0) : (Be(), rt("div", {
          key: 2,
          class: Br(["bg-secondary", [
            { "pl-2": t.node.depth > 1 },
            { "lux-collapse": !o },
            { expanded: !o && t.node.expanded }
          ]])
        }, [
          (Be(!0), rt(on, null, Ra(t.node.children, (z) => (Be(), an(A, {
            key: z.id,
            node: z,
            onToggleParent: I[2] || (I[2] = (V) => T(V)),
            onToggleLayer: I[3] || (I[3] = (V) => b(V))
          }, null, 8, ["node"]))), 128))
        ], 2))
      ])) : (Be(), rt("div", bB, [
        Fe("button", {
          class: "self-start before:text-[.85rem] before:transform before:translate-y-[.1rem] before:inline-block before:content-['\\f129'] fa-solid fa-fw fa-fh fa-info",
          onClick: I[4] || (I[4] = (z) => se(s)(t.node.id))
        }),
        Fe("button", {
          class: Br(["w-full text-left", { "font-bold": t.node.checked }]),
          onClick: I[5] || (I[5] = (z) => b(t.node)),
          "data-cy": `layerLabel-${t.node.id}`
        }, [
          Fe("i", {
            class: Br(["fa-solid", t.node.checked ? "fa-check-square" : "fa-square"])
          }, null, 2),
          Fe("span", EB, Ht(se(g)), 1)
        ], 10, wB)
      ]));
    };
  }
}), hx = /* @__PURE__ */ lr(SB, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-tree/layer-tree-node.vue"]]);
class TB {
  toggleNode(e, n, a) {
    var s;
    return (n == null ? void 0 : n.id) === e ? {
      ...n,
      [a]: !n[a]
    } : {
      ...n,
      children: (s = n.children) == null ? void 0 : s.map(
        (f) => this.toggleNode(e, f, a)
      )
    };
  }
  updateLayers(e, n) {
    const { id: a } = e;
    if (e.children)
      return {
        ...e,
        children: e.children.map((s) => this.updateLayers(s, n))
      };
    {
      const s = !!(n != null && n.find((f) => f.id === a));
      return {
        ...e,
        checked: s
      };
    }
  }
}
const Af = new TB();
var Na = /* @__PURE__ */ ((t) => (t.WMS = "WMS", t.WMTS = "WMTS", t))(Na || {});
function MB(t, e) {
  var n, a;
  return t.children && !e.children || ((n = e.children) == null ? void 0 : n.length) === 0 ? 1 : e.children && !t.children || ((a = t.children) == null ? void 0 : a.length) === 0 ? -1 : 0;
}
function lI(t, e, n = 0) {
  const { name: a = "", type: s = Na.WMS, children: f } = t, o = `${s}||${e}||${a}`.split("-").join("%2D"), m = Ei();
  return {
    id: o,
    name: a,
    depth: n,
    children: f == null ? void 0 : f.sort(MB).map((g) => lI(g, e, n + 1)),
    checked: m.hasLayer(o),
    expanded: !1
  };
}
function IB(t) {
  const e = decodeURIComponent(t), [n, a, s] = e.split("||");
  return uI({
    id: e,
    url: Ff.getProxyfiedUrl(a),
    remoteLayer: { name: s, type: n }
  });
}
function uI({
  id: t,
  url: e,
  remoteLayer: n
}) {
  const { name: a = "", type: s = Na.WMS } = n;
  return {
    id: t,
    name: a,
    layers: a,
    url: e,
    type: s,
    imageType: qT.PNG
  };
}
class o0 {
  constructor(e, n = 0, a = !1) {
    this.message = e, this.httpStatus = n, this.isCrossOriginRelated = a;
  }
}
let OB = 0;
function CB() {
  return OB++;
}
function PB(t, e, n) {
  return new Promise((a, s) => {
    const f = CB(), o = {
      requestId: f,
      taskName: t,
      params: n
    };
    e === null ? window.dispatchEvent(
      new CustomEvent("ogc-client.request", {
        detail: o
      })
    ) : e.postMessage(o);
    const m = ({ detail: g, data: b }) => {
      const T = g || b;
      T.requestId === f && (e === null ? window.removeEventListener("message", m) : e.removeEventListener("message", m), "error" in T ? s(T.error) : a(T.response));
    };
    e === null ? window.addEventListener("ogc-client.response", m) : e.addEventListener("message", m);
  });
}
function i1(t, e, n) {
  const a = typeof WorkerGlobalScope < "u", s = async ({ detail: f, data: o }) => {
    const m = f || o;
    if (m.taskName === t) {
      let g, b;
      try {
        g = await n(m.params);
      } catch (M) {
        b = M;
      }
      const T = {
        taskName: t,
        requestId: m.requestId,
        ...g && { response: g },
        ...b && { error: b }
      };
      a ? e.postMessage(T) : e.dispatchEvent(
        new CustomEvent("ogc-client.response", {
          detail: T
        })
      );
    }
  };
  a ? e.addEventListener("message", s) : e.addEventListener("ogc-client.request", s);
}
let a0;
function AB() {
  return a0 || (a0 = new Worker(URL.createObjectURL(new Blob([`function t(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function e(t,e,r,n,o,i,a){try{var c=t[i](a),u=c.value}catch(t){return void r(t)}c.done?e(u):Promise.resolve(u).then(n,o)}function r(t){return function(){var r=this,n=arguments;return new Promise((function(o,i){var a=t.apply(r,n);function c(t){e(a,o,i,c,u,"next",t)}function u(t){e(a,o,i,c,u,"throw",t)}c(void 0)}))}}function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}var o={exports:{}};!function(t){var e=function(t){var e,r=Object.prototype,o=r.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function s(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{s({},"")}catch(t){s=function(t,e,r){return t[e]=r}}function f(t,e,r,n){var o=e&&e.prototype instanceof m?e:m,i=Object.create(o.prototype),a=new j(n||[]);return i._invoke=function(t,e,r){var n=h;return function(o,i){if(n===v)throw new Error("Generator is already running");if(n===d){if("throw"===o)throw i;return G()}for(r.method=o,r.arg=i;;){var a=r.delegate;if(a){var c=k(a,r);if(c){if(c===y)continue;return c}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===h)throw n=d,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=v;var u=l(t,e,r);if("normal"===u.type){if(n=r.done?d:p,u.arg===y)continue;return{value:u.arg,done:r.done}}"throw"===u.type&&(n=d,r.method="throw",r.arg=u.arg)}}}(t,r,a),i}function l(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=f;var h="suspendedStart",p="suspendedYield",v="executing",d="completed",y={};function m(){}function g(){}function b(){}var S={};S[a]=function(){return this};var E=Object.getPrototypeOf,w=E&&E(E(C([])));w&&w!==r&&o.call(w,a)&&(S=w);var O=b.prototype=m.prototype=Object.create(S);function x(t){["next","throw","return"].forEach((function(e){s(t,e,(function(t){return this._invoke(e,t)}))}))}function P(t,e){function r(i,a,c,u){var s=l(t[i],t,a);if("throw"!==s.type){var f=s.arg,h=f.value;return h&&"object"===n(h)&&o.call(h,"__await")?e.resolve(h.__await).then((function(t){r("next",t,c,u)}),(function(t){r("throw",t,c,u)})):e.resolve(h).then((function(t){f.value=t,c(f)}),(function(t){return r("throw",t,c,u)}))}u(s.arg)}var i;this._invoke=function(t,n){function o(){return new e((function(e,o){r(t,n,e,o)}))}return i=i?i.then(o,o):o()}}function k(t,r){var n=t.iterator[r.method];if(n===e){if(r.delegate=null,"throw"===r.method){if(t.iterator.return&&(r.method="return",r.arg=e,k(t,r),"throw"===r.method))return y;r.method="throw",r.arg=new TypeError("The iterator does not provide a 'throw' method")}return y}var o=l(n,t.iterator,r.arg);if("throw"===o.type)return r.method="throw",r.arg=o.arg,r.delegate=null,y;var i=o.arg;return i?i.done?(r[t.resultName]=i.value,r.next=t.nextLoc,"return"!==r.method&&(r.method="next",r.arg=e),r.delegate=null,y):i:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function R(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function T(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function j(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(R,this),this.reset(!0)}function C(t){if(t){var r=t[a];if(r)return r.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,i=function r(){for(;++n<t.length;)if(o.call(t,n))return r.value=t[n],r.done=!1,r;return r.value=e,r.done=!0,r};return i.next=i}}return{next:G}}function G(){return{value:e,done:!0}}return g.prototype=O.constructor=b,b.constructor=g,g.displayName=s(b,u,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===g||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,b):(t.__proto__=b,s(t,u,"GeneratorFunction")),t.prototype=Object.create(O),t},t.awrap=function(t){return{__await:t}},x(P.prototype),P.prototype[c]=function(){return this},t.AsyncIterator=P,t.async=function(e,r,n,o,i){void 0===i&&(i=Promise);var a=new P(f(e,r,n,o),i);return t.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},x(O),s(O,u,"Generator"),O[a]=function(){return this},O.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=C,j.prototype={constructor:j,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(T),!t)for(var r in this)"t"===r.charAt(0)&&o.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=e)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var r=this;function n(n,o){return c.type="throw",c.arg=t,r.next=n,o&&(r.method="next",r.arg=e),!!o}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],c=a.completion;if("root"===a.tryLoc)return n("end");if(a.tryLoc<=this.prev){var u=o.call(a,"catchLoc"),s=o.call(a,"finallyLoc");if(u&&s){if(this.prev<a.catchLoc)return n(a.catchLoc,!0);if(this.prev<a.finallyLoc)return n(a.finallyLoc)}else if(u){if(this.prev<a.catchLoc)return n(a.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return n(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&o.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var i=n;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),T(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;T(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,r,n){return this.delegate={iterator:C(t),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=e),y}},t}(t.exports);try{regeneratorRuntime=e}catch(t){Function("r","regeneratorRuntime = r")(e)}}(o);var i=o.exports;function a(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?a(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(t,e,n){var o="undefined"!=typeof WorkerGlobalScope,a=function(){var a=r(i.mark((function r(a){var u,s,f,l,h,p;return i.wrap((function(r){for(;;)switch(r.prev=r.next){case 0:if(u=a.detail,s=a.data,(f=u||s).taskName!==t){r.next=14;break}return r.prev=3,r.next=6,n(f.params);case 6:l=r.sent,r.next=12;break;case 9:r.prev=9,r.t0=r.catch(3),h=r.t0;case 12:p=c(c({taskName:t,requestId:f.requestId},l&&{response:l}),h&&{error:h}),o?e.postMessage(p):e.dispatchEvent(new CustomEvent("ogc-client.response",{detail:p}));case 14:case"end":return r.stop()}}),r,null,[[3,9]])})));return function(t){return a.apply(this,arguments)}}();o?e.addEventListener("message",a):e.addEventListener("ogc-client.request",a)}function s(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function f(t){return function(t){if(Array.isArray(t))return s(t)}(t)||function(t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||function(t,e){if(t){if("string"==typeof t)return s(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?s(t,e):void 0}}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function l(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function h(t,e){return h=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},h(t,e)}function p(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&h(t,e)}function v(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function d(t){return d=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},d(t)}function y(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function m(t,e,r){return m=y()?Reflect.construct:function(t,e,r){var n=[null];n.push.apply(n,e);var o=new(Function.bind.apply(t,n));return r&&h(o,r.prototype),o},m.apply(null,arguments)}function g(t){var e="function"==typeof Map?new Map:void 0;return g=function(t){if(null===t||(r=t,-1===Function.toString.call(r).indexOf("[native code]")))return t;var r;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,n)}function n(){return m(t,arguments,d(this).constructor)}return n.prototype=Object.create(t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),h(n,t)},g(t)}function b(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function S(t,e,r){return e&&b(t.prototype,e),r&&b(t,r),t}var E=function(){function t(e){l(this,t),this.chars=f(e),this.charCount=this.chars.length,this.charIndex=0,this.charsToBytes=new Array(this.charCount),this.multiByteMode=!1,this.string=e;var r=this.chars,n=this.charCount,o=this.charsToBytes;if(n===e.length)for(var i=0;i<n;++i)o[i]=i;else{for(var a=0,c=0;c<n;++c)o[c]=a,a+=r[c].length;this.multiByteMode=!0}}return S(t,[{key:"isEnd",get:function(){return this.charIndex>=this.charCount}},{key:"_charLength",value:function(t){var e=t.length;return e<2||!this.multiByteMode?e:t.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,"_").length}},{key:"advance",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.charIndex=Math.min(this.charCount,this.charIndex+t)}},{key:"consume",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=this.peek(t);return this.advance(t),e}},{key:"consumeMatch",value:function(t){if(!t.sticky)throw new Error('\`regex\` must have a sticky flag ("y")');t.lastIndex=this.charsToBytes[this.charIndex];var e=t.exec(this.string);if(null===e)return"";var r=e[0];return this.advance(this._charLength(r)),r}},{key:"consumeMatchFn",value:function(t){for(var e=this.charIndex;!this.isEnd&&t(this.peek());)this.advance();return this.charIndex>e?this.string.slice(this.charsToBytes[e],this.charsToBytes[this.charIndex]):""}},{key:"consumeString",value:function(t){if(this.consumeStringFast(t))return t;if(!this.multiByteMode)return"";var e=t.length,r=this._charLength(t);return r!==e&&t===this.peek(r)?(this.advance(r),t):""}},{key:"consumeStringFast",value:function(t){if(this.peek()===t[0]){var e=t.length;if(1===e)return this.advance(),t;if(this.peek(e)===t)return this.advance(e),t}return""}},{key:"consumeUntilMatch",value:function(t){if(!t.global)throw new Error('\`regex\` must have a global flag ("g")');var e=this.charsToBytes[this.charIndex];t.lastIndex=e;var r=t.exec(this.string);if(null===r||r.index===e)return"";var n=this.string.slice(e,r.index);return this.advance(this._charLength(n)),n}},{key:"consumeUntilString",value:function(t){var e=this.charIndex,r=this.charsToBytes,n=this.string,o=r[e],i=n.indexOf(t,o);if(i<=0)return"";var a=n.slice(o,i);return this.advance(this._charLength(a)),a}},{key:"peek",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;if(this.charIndex>=this.charCount)return"";if(1===t)return this.chars[this.charIndex];var e=this.charsToBytes,r=this.charIndex;return this.string.slice(e[r],e[r+t])}},{key:"reset",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;this.charIndex=t>=0?Math.min(this.charCount,t):Math.max(0,this.charIndex+t)}}]),t}(),w=E,O={},x=Object.freeze(Object.assign(Object.create(null),{amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}));function P(t){if(k(t))return!0;var e=T(t);return 45===e||46===e||e>=48&&e<=57||183===e||e>=768&&e<=879||e>=8255&&e<=8256}function k(t){var e=T(t);return 58===e||95===e||e>=65&&e<=90||e>=97&&e<=122||e>=192&&e<=214||e>=216&&e<=246||e>=248&&e<=767||e>=880&&e<=893||e>=895&&e<=8191||e>=8204&&e<=8205||e>=8304&&e<=8591||e>=11264&&e<=12271||e>=12289&&e<=55295||e>=63744&&e<=64975||e>=65008&&e<=65533||e>=65536&&e<=983039}function R(t){var e=T(t);return 9===e||10===e||13===e||e>=32&&e<=55295||e>=57344&&e<=65533||e>=65536&&e<=1114111}function T(t){return t.codePointAt(0)||-1}O.predefinedEntities=x,O.isNameChar=P,O.isNameStartChar=k,O.isNotXmlChar=function(t){return!R(t)},O.isReferenceChar=function(t){return"#"===t||P(t)},O.isWhitespace=function(t){var e=T(t);return 32===e||9===e||10===e||13===e},O.isXmlChar=R;var j=function(){function t(){l(this,t),this.parent=null}return S(t,[{key:"document",get:function(){return this.parent?this.parent.document:null}},{key:"isRootNode",get:function(){return!!this.parent&&this.parent===this.document}},{key:"preserveWhitespace",get:function(){return Boolean(this.parent&&this.parent.preserveWhitespace)}},{key:"type",get:function(){return""}},{key:"toJSON",value:function(){var t={type:this.type};return this.isRootNode&&(t.isRootNode=!0),this.preserveWhitespace&&(t.preserveWhitespace=!0),t}}]),t}();j.TYPE_CDATA="cdata",j.TYPE_COMMENT="comment",j.TYPE_DOCUMENT="document",j.TYPE_ELEMENT="element",j.TYPE_PROCESSING_INSTRUCTION="pi",j.TYPE_TEXT="text";var C=j;function G(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var N=C,A=function(t){p(r,N);var e=G(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).text=n,t}return S(r,[{key:"type",get:function(){return N.TYPE_TEXT}},{key:"toJSON",value:function(){return Object.assign(N.prototype.toJSON.call(this),{text:this.text})}}]),r}(),F=A;function I(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var L=C,M=F,B=function(t){p(r,M);var e=I(r);function r(){return l(this,r),e.apply(this,arguments)}return S(r,[{key:"type",get:function(){return L.TYPE_CDATA}}]),r}(),_=B;function U(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var D=C,W=function(t){p(r,D);var e=U(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return l(this,r),(t=e.call(this)).content=n,t}return S(r,[{key:"type",get:function(){return D.TYPE_COMMENT}},{key:"toJSON",value:function(){return Object.assign(D.prototype.toJSON.call(this),{content:this.content})}}]),r}(),X=W;function Y(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var q=C,J=function(t){p(r,q);var e=Y(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Object.create(null),i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return l(this,r),(n=e.call(this)).name=t,n.attributes=o,n.children=i,n}return S(r,[{key:"isEmpty",get:function(){return 0===this.children.length}},{key:"preserveWhitespace",get:function(){for(var t=this;t instanceof r;){if("xml:space"in t.attributes)return"preserve"===t.attributes["xml:space"];t=t.parent}return!1}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return q.TYPE_ELEMENT}},{key:"toJSON",value:function(){return Object.assign(q.prototype.toJSON.call(this),{name:this.name,attributes:this.attributes,children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),V=J;function $(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var K=V,z=C,H=function(t){p(r,z);var e=$(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return l(this,r),(t=e.call(this)).children=n,t}return S(r,[{key:"document",get:function(){return this}},{key:"root",get:function(){return this.children.find((function(t){return t instanceof K}))||null}},{key:"text",get:function(){return this.children.map((function(t){return"text"in t?t.text:""})).join("")}},{key:"type",get:function(){return z.TYPE_DOCUMENT}},{key:"toJSON",value:function(){return Object.assign(z.prototype.toJSON.call(this),{children:this.children.map((function(t){return t.toJSON()}))})}}]),r}(),Q=H;function Z(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var tt=C,et=function(t){p(r,tt);var e=Z(r);function r(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return l(this,r),(n=e.call(this)).name=t,n.content=o,n}return S(r,[{key:"type",get:function(){return tt.TYPE_PROCESSING_INSTRUCTION}},{key:"toJSON",value:function(){return Object.assign(tt.prototype.toJSON.call(this),{name:this.name,content:this.content})}}]),r}(),rt=et;function nt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return ot(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return ot(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function ot(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var it=w,at=O,ct=_,ut=X,st=Q,ft=V,lt=rt,ht=F,pt=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(l(this,t),this.document=new st,this.currentNode=this.document,this.options=r,this.scanner=new it(vt(e)),this.consumeProlog(),this.consumeElement()||this.error("Root element is missing or invalid");this.consumeMisc(););this.scanner.isEnd||this.error("Extra content at the end of the document")}return S(t,[{key:"addNode",value:function(t){t.parent=this.currentNode,this.currentNode.children.push(t)}},{key:"addText",value:function(t){var e=this.currentNode.children;if(e.length>0){var r=e[e.length-1];if(r instanceof ht)return void(r.text+=t)}this.addNode(new ht(t))}},{key:"consumeAttributeValue",value:function(){var t,e=this.scanner,r=e.peek();if('"'!==r&&"'"!==r)return!1;e.advance();var n=!1,o="",i='"'===r?new RegExp('[^"&<]+',"y"):new RegExp("[^'&<]+","y");t:for(;!e.isEnd;){switch((t=e.consumeMatch(i))&&(this.validateChars(t),o+=t.replace(/[\\t\\r\\n]/g," ")),e.peek()){case r:n=!0;break t;case"&":o+=this.consumeReference();continue;case"<":this.error("Unescaped \`<\` is not allowed in an attribute value");break;case"":this.error("Unclosed attribute")}}return n||this.error("Unclosed attribute"),e.advance(),o}},{key:"consumeCdataSection",value:function(){var t=this.scanner;if(!t.consumeStringFast("<![CDATA["))return!1;var e=t.consumeUntilString("]]>");return this.validateChars(e),t.consumeStringFast("]]>")||this.error("Unclosed CDATA section"),this.options.preserveCdata?this.addNode(new ct(e)):this.addText(e),!0}},{key:"consumeCharData",value:function(){var t=this.scanner,e=t.consumeUntilMatch(/<|&|]]>/g);return!!e&&(this.validateChars(e),"]"===t.peek()&&"]]>"===t.peek(3)&&this.error("Element content may not contain the CDATA section close delimiter \`]]>\`"),this.addText(e),!0)}},{key:"consumeComment",value:function(){var t=this.scanner;if(!t.consumeStringFast("\\x3c!--"))return!1;var e=t.consumeUntilString("--");return this.validateChars(e),t.consumeStringFast("--\\x3e")||("--"===t.peek(2)?this.error("The string \`--\` isn't allowed inside a comment"):this.error("Unclosed comment")),this.options.preserveComments&&this.addNode(new ut(e.trim())),!0}},{key:"consumeContentReference",value:function(){var t=this.consumeReference();return!!t&&(this.addText(t),!0)}},{key:"consumeDoctypeDeclaration",value:function(){var t=this.scanner;return!(!t.consumeStringFast("<!DOCTYPE")||!this.consumeWhitespace())&&(t.consumeMatch(new RegExp("[^[>]+","y")),t.consumeMatch(new RegExp("\\\\[[\\\\s\\\\S]+?\\\\][\\\\x20\\\\t\\\\r\\\\n]*>","y"))||t.consumeStringFast(">")||this.error("Unclosed doctype declaration"),!0)}},{key:"consumeElement",value:function(){var t=this.scanner,e=t.charIndex;if("<"!==t.peek())return!1;t.advance();var r=this.consumeName();if(!r)return t.reset(e),!1;for(var n=Object.create(null);this.consumeWhitespace();){var o=this.consumeName();if(o){var i=this.consumeEqual()&&this.consumeAttributeValue();!1===i&&this.error("Attribute value expected"),o in n&&this.error("Duplicate attribute: ".concat(o)),"xml:space"===o&&"default"!==i&&"preserve"!==i&&this.error('Value of the \`xml:space\` attribute must be "default" or "preserve"'),n[o]=i}}if(this.options.sortAttributes){for(var a=Object.keys(n).sort(),c=Object.create(null),u=0;u<a.length;++u){var s=a[u];c[s]=n[s]}n=c}var f=Boolean(t.consumeStringFast("/>")),l=new ft(r,n);if(l.parent=this.currentNode,!f){for(t.consumeStringFast(">")||this.error("Unclosed start tag for element \`".concat(r,"\`")),this.currentNode=l,this.consumeCharData();this.consumeElement()||this.consumeContentReference()||this.consumeCdataSection()||this.consumeProcessingInstruction()||this.consumeComment();)this.consumeCharData();var h,p=t.charIndex;t.consumeStringFast("</")&&(h=this.consumeName())&&h===r||(t.reset(p),this.error("Missing end tag for element ".concat(r))),this.consumeWhitespace(),t.consumeStringFast(">")||this.error("Unclosed end tag for element ".concat(r)),this.currentNode=l.parent}return this.addNode(l),!0}},{key:"consumeEqual",value:function(){return this.consumeWhitespace(),!!this.scanner.consumeStringFast("=")&&(this.consumeWhitespace(),!0)}},{key:"consumeMisc",value:function(){return this.consumeComment()||this.consumeProcessingInstruction()||this.consumeWhitespace()}},{key:"consumeName",value:function(){return at.isNameStartChar(this.scanner.peek())?this.scanner.consumeMatchFn(at.isNameChar):""}},{key:"consumeProcessingInstruction",value:function(){var t=this.scanner,e=t.charIndex;if(!t.consumeStringFast("<?"))return!1;var r=this.consumeName();if(r?"xml"===r.toLowerCase()&&(t.reset(e),this.error("XML declaration isn't allowed here")):this.error("Invalid processing instruction"),!this.consumeWhitespace()){if(t.consumeStringFast("?>"))return this.addNode(new lt(r)),!0;this.error("Whitespace is required after a processing instruction name")}var n=t.consumeUntilString("?>");return this.validateChars(n),t.consumeStringFast("?>")||this.error("Unterminated processing instruction"),this.addNode(new lt(r,n)),!0}},{key:"consumeProlog",value:function(){var t=this.scanner,e=t.charIndex;for(this.consumeXmlDeclaration();this.consumeMisc(););if(this.consumeDoctypeDeclaration())for(;this.consumeMisc(););return e<t.charIndex}},{key:"consumeReference",value:function(){var t=this.scanner;if("&"!==t.peek())return!1;t.advance();var e,r=t.consumeMatchFn(at.isReferenceChar);if(";"!==t.consume()&&this.error("Unterminated reference (a reference must end with \`;\`)"),"#"===r[0]){var o="x"===r[1]?parseInt(r.slice(2),16):parseInt(r.slice(1),10);isNaN(o)&&this.error("Invalid character reference"),e=String.fromCodePoint(o),at.isXmlChar(e)||this.error("Character reference resolves to an invalid character")}else if(void 0===(e=at.predefinedEntities[r])){var i=this.options,a=i.ignoreUndefinedEntities,c=i.resolveUndefinedEntity,u="&".concat(r,";");if(c){var s=c(u);if(null!=s){var f=n(s);if("string"!==f)throw new TypeError("\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ".concat(f));return s}}if(a)return u;t.reset(-u.length),this.error("Named entity isn't defined: ".concat(u))}return e}},{key:"consumeSystemLiteral",value:function(){var t=this.scanner,e=t.consumeStringFast('"')||t.consumeStringFast("'");if(!e)return!1;var r=t.consumeUntilString(e);return this.validateChars(r),t.consumeStringFast(e)||this.error("Missing end quote"),r}},{key:"consumeWhitespace",value:function(){return Boolean(this.scanner.consumeMatchFn(at.isWhitespace))}},{key:"consumeXmlDeclaration",value:function(){var t=this.scanner;if(!t.consumeStringFast("<?xml"))return!1;this.consumeWhitespace()||this.error("Invalid XML declaration");var e=Boolean(t.consumeStringFast("version"))&&this.consumeEqual()&&this.consumeSystemLiteral();if(!1===e?this.error("XML version is missing or invalid"):/^1\\.[0-9]+$/.test(e)||this.error("Invalid character in version number"),this.consumeWhitespace()){Boolean(t.consumeStringFast("encoding"))&&this.consumeEqual()&&this.consumeSystemLiteral()&&this.consumeWhitespace();var r=Boolean(t.consumeStringFast("standalone"))&&this.consumeEqual()&&this.consumeSystemLiteral();r&&("yes"!==r&&"no"!==r&&this.error('Only "yes" and "no" are permitted as values of \`standalone\`'),this.consumeWhitespace())}return t.consumeStringFast("?>")||this.error("Invalid or unclosed XML declaration"),!0}},{key:"error",value:function(t){for(var e=this.scanner,r=e.charIndex,n=e.string,o=1,i="",a=1,c=0;c<r;++c){var u=n[c];"\\n"===u?(o=1,i="",a+=1):(o+=1,i+=u)}var s=n.indexOf("\\n",r),f=0;(i+=-1===s?n.slice(r):n.slice(r,s)).length>50&&(o<40?i=i.slice(0,50):(f=o-20,i=i.slice(f,o+30)));var l=new Error("".concat(t," (line ").concat(a,", column ").concat(o,")\\n")+"  ".concat(i,"\\n")+" ".repeat(o-f+1)+"^\\n");throw Object.assign(l,{column:o,excerpt:i,line:a,pos:r}),l}},{key:"validateChars",value:function(t){var e,r=0,n=nt(t);try{for(n.s();!(e=n.n()).done;){var o=e.value;at.isNotXmlChar(o)&&(this.scanner.reset(-(f(t).length-r)),this.error("Invalid character")),r+=1}}catch(t){n.e(t)}finally{n.f()}}}]),t}();function vt(t){return"\\ufeff"===t[0]&&(t=t.slice(1)),t.replace(/\\r\\n?/g,"\\n")}var dt=pt,yt=_,mt=X,gt=Q,bt=V,St=C,Et=rt,wt=F;function Ot(t,e){return new dt(t,e).document}Ot.XmlCdata=yt,Ot.XmlComment=mt,Ot.XmlDocument=gt,Ot.XmlElement=bt,Ot.XmlNode=St,Ot.XmlProcessingInstruction=Et,Ot.XmlText=wt;var xt=Ot;function Pt(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=d(t);if(e){var o=d(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return v(this,r)}}var kt=function(t){p(r,g(Error));var e=Pt(r);function r(t){return l(this,r),e.call(this,t)}return r}();function Rt(t){return t.children[0]}function Tt(t){var e=t.indexOf(":");return e>-1?t.substr(e+1):t}function jt(t){return t.name||""}function Ct(t,e,r){var n=Tt(e);return t&&Array.isArray(t.children)?t.children.reduce((function t(e,o){return Tt(jt(o))===n&&e.push(o),r&&Array.isArray(o.children)?[].concat(f(e),f(o.children.reduce(t,[]))):e}),[]):[]}function Gt(t,e,r){return Ct(t,e,r)[0]||null}function Nt(t){return t&&Array.isArray(t.children)?f(t.children.filter((function(t){return"XmlElement"===t.constructor.name}))):[]}function At(t){var e=t&&Array.isArray(t.children)?t.children.find((function(t){return"text"===t.type})):null;return e?e.text:""}function Ft(t,e){return t&&t.attributes[e]||""}var It=function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];l(this,t),this.message=e,this.httpStatus=r,this.isCrossOriginRelated=n};function Lt(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Mt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Mt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Mt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Bt=["utf-8","utf-16","iso-8859-1"];function _t(t,e){var r,n=e?function(t){var e=/charset=([^;]+)/.exec(t);return e?e[1]:null}(e):null,o=Lt(n?[n].concat(Bt):Bt);try{for(o.s();!(r=o.n()).done;){var i=r.value;try{return new TextDecoder(i,{fatal:!0}).decode(t)}catch(t){}}}catch(t){o.e(t)}finally{o.f()}return console.warn("XML document encoding could not be determined, falling back to ".concat("utf-8",".")),new TextDecoder("utf-8").decode(t)}function Ut(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=function(t,e){if(!t)return;if("string"==typeof t)return Dt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return Dt(t,e)}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return a=t.done,t},e:function(t){c=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(c)throw i}}}}function Dt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var Wt=new Map;function Xt(t){return function(t){if(Wt.has(t))return Wt.get(t);var e=fetch(t);return e.finally((function(){return Wt.delete(t)})),Wt.set(t,e),e}(t).catch((function(){return fetch(t,{method:"HEAD",mode:"no-cors"}).catch((function(t){throw new It("Fetching the document failed either due to network errors or unreachable host, error is: ".concat(t.message),0,!1)})).then((function(){throw new It("The document could not be fetched due to CORS limitations",0,!0)}))})).then(function(){var t=r(i.mark((function t(e){var r,n,o;return i.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(e.ok){t.next=5;break}return t.next=3,e.text();case 3:throw r=t.sent,new It("Received an error with code ".concat(e.status,": ").concat(r),e.status,!1);case 5:return t.next=7,e.arrayBuffer();case 7:return n=t.sent,o=e.headers.get("Content-Type"),t.abrupt("return",_t(n,o));case 10:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}()).then((function(t){return function(t){var e=null;try{e=xt(t)}catch(t){throw new kt(t.message)}return e}(t)}))}function Yt(t,e){var r=t.match(/(https?%3A%2F%2F[^/]+)$/);if(r){var n=r[1],o=Yt(decodeURIComponent(n),e);return t.replace(n,encodeURIComponent(o))}var i,a=new URL(t),c=Object.keys(e),u=c.map((function(t){return t.toLowerCase()})),s=[],f=Ut(a.searchParams.keys());try{for(f.s();!(i=f.n()).done;){var l=i.value;u.indexOf(l.toLowerCase())>-1&&s.push(l)}}catch(t){f.e(t)}finally{f.f()}return s.map((function(t){return a.searchParams.delete(t)})),c.forEach((function(t){return a.searchParams.set(t,!0===e[t]?"":e[t])})),a.toString()}var qt=["EPSG:4046","EPSG:4075","EPSG:4120","EPSG:4122","EPSG:4124","EPSG:4126","EPSG:4149","EPSG:4151","EPSG:4153","EPSG:4155","EPSG:4157","EPSG:4159","EPSG:4161","EPSG:4163","EPSG:4165","EPSG:4167","EPSG:4169","EPSG:4171","EPSG:4173","EPSG:4175","EPSG:4178","EPSG:4180","EPSG:4182","EPSG:4184","EPSG:4188","EPSG:4190","EPSG:4191","EPSG:4196","EPSG:4198","EPSG:4202","EPSG:4210","EPSG:4211","EPSG:4214","EPSG:4226","EPSG:4229","EPSG:4231","EPSG:4233","EPSG:4236","EPSG:4238","EPSG:4240","EPSG:4242","EPSG:4244","EPSG:4246","EPSG:4248","EPSG:4250","EPSG:4252","EPSG:4255","EPSG:4258","EPSG:4261","EPSG:4264","EPSG:4267","EPSG:4270","EPSG:4273","EPSG:4276","EPSG:4279","EPSG:4281","EPSG:4284","EPSG:4286","EPSG:4288","EPSG:4292","EPSG:4295","EPSG:4297","EPSG:4299","EPSG:4302","EPSG:4324","EPSG:4326"];function Jt(t){return qt.indexOf(Vt(t))>-1}function Vt(t){if(/^urn:(?:x-)?ogc:def:crs:epsg:/.test(t.toLowerCase())){var e=/([0-9]+)$/.exec(t)[1];return"EPSG:".concat(e)}return t}function $t(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function Kt(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?$t(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):$t(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function zt(t){return Rt(t).attributes.version}function Ht(t){var e=zt(t);return Ct(Gt(Rt(t),"Capability"),"Layer").map((function(t){return Qt(t,e)}))}function Qt(e,r){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a="1.3.0"===r?"CRS":"SRS",c=Ct(e,a).map(At),u=c.length>0?c:n,s=Ct(e,"Style").map(Zt),f=s.length>0?s:o;function l(t){return(Jt(Ft(t,a))&&"1.3.0"===r?["miny","minx","maxy","maxx"]:["minx","miny","maxx","maxy"]).map((function(e){return Ft(t,e)}))}var h=Gt(e,"Attribution"),p=null!==h?te(h):i,v=Ct(e,"Layer").map((function(t){return Qt(t,r,u,f,p)}));return Kt({name:At(Gt(e,"Name")),title:At(Gt(e,"Title")),abstract:At(Gt(e,"Abstract")),availableCrs:u,styles:f,attribution:p,boundingBoxes:Ct(e,"BoundingBox").reduce((function(e,r){return Kt(Kt({},e),{},t({},Ft(r,a),l(r)))}),{})},v.length&&{children:v})}function Zt(t){var e=Ft(Gt(Gt(t,"LegendURL"),"OnlineResource"),"xlink:href");return Kt({name:At(Gt(t,"Name")),title:At(Gt(t,"Title"))},e&&{legendUrl:e})}function te(t){var e=Ft(Gt(Gt(t,"LogoURL"),"OnlineResource"),"xlink:href"),r=Ft(Gt(t,"OnlineResource"),"xlink:href"),n=At(Gt(t,"Title"));return Kt(Kt(Kt({},n&&{title:n}),r&&{url:r}),e&&{logoUrl:e})}function ee(t){return Rt(t).attributes.version}function re(t){var e;if(ee(t).startsWith("1.0")){var r=Gt(Gt(Gt(Rt(t),"Capability"),"Request"),"GetFeature");e=Nt(Gt(r,"ResultFormat")).map(jt)}else{var n=Ct(Gt(Rt(t),"OperationsMetadata"),"Operation").find((function(t){return"GetFeature"===Ft(t,"name")})),o=Ct(n,"Parameter").find((function(t){return"outputFormat"===Ft(t,"name")}));e=Ct(o,"Value",!0).map(At)}return e}function ne(t){var e=ee(t),r=re(t);return Ct(Gt(Rt(t),"FeatureTypeList"),"FeatureType").map((function(t){return function(t,e,r){var n=e.startsWith("2.")?"CRS":"SRS",o=e.startsWith("1.0")?"SRS":"Default".concat(n);function i(){var e=Gt(t,"LatLongBoundingBox");return["minx","miny","maxx","maxy"].map((function(t){return Ft(e,t)})).map(parseFloat)}function a(){var e=Gt(t,"WGS84BoundingBox");return["LowerCorner","UpperCorner"].map((function(t){return Gt(e,t)})).map((function(t){return At(t).split(" ")})).reduce((function(t,e){return[].concat(f(t),f(e))})).map(parseFloat)}var c=e.startsWith("1.0")?[]:Ct(t,"Other".concat(n)).map(At).map(Vt),u=e.startsWith("1.0")?[]:Ct(Gt(t,"OutputFormats"),"Format").map(At);return{name:At(Gt(t,"Name")),title:At(Gt(t,"Title")),abstract:At(Gt(t,"Abstract")),defaultCrs:Vt(At(Gt(t,o))),otherCrs:c,outputFormats:u.length>0?u:r,latLonBoundingBox:e.startsWith("1.0")?i():a()}}(t,e,r)}))}function oe(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function ie(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?oe(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):oe(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ae(e,r,n){var o,i=Rt(e);if(n.startsWith("2.0"))o=Ct(i,"member").map((function(t){return Nt(t)[0]}));else{var a=Gt(i,"featureMembers");o=a?Nt(a):Ct(i,"featureMember").map((function(t){return Nt(t)[0]}))}var c="1.0.0"===n?"fid":"gml:id";function u(e){return Nt(e).filter((function(t){return Tt(jt(t))in r.properties})).reduce((function(e,n){var o=Tt(jt(n));return ie(ie({},e),{},t({},o,function(t,e){switch(r.properties[t]){case"integer":return parseInt(e);case"float":return parseFloat(e);case"boolean":return"true"===e;default:return e}}(o,At(n))))}),{})}return o.map((function(t){return{id:Ft(t,c),properties:u(t)}}))}function ce(e,r,n,o,i,a,c,u,s,f){var l="2.0.0"===r?"COUNT":"MAXFEATURES",h=t({SERVICE:"WFS",REQUEST:"GetFeature",VERSION:r},"2.0.0"===r?"TYPENAMES":"TYPENAME",n);if(void 0!==o&&(h.OUTPUTFORMAT=o),void 0!==a&&(h.PROPERTYNAME=a.join(",")),c?(h.RESULTTYPE="hits",h[l]="1"):void 0!==i&&(h[l]=i.toString(10)),u&&(h.SRSNAME=u),s){var p=s.join(",");h.BBOX=f?"".concat(p,",").concat(f):p}return Yt(e,h)}u("parseWmsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,r=Gt(Rt(e),"Service"),n=Ct(Gt(r,"KeywordList"),"Keyword").map(At).filter((function(t,e,r){return r.indexOf(t)===e})),{title:At(Gt(r,"Title")),name:At(Gt(r,"Name")),abstract:At(Gt(r,"Abstract")),fees:At(Gt(r,"Fees")),constraints:At(Gt(r,"AccessConstraints")),keywords:n}),layers:Ht(t),version:zt(t)};var e,r,n}))})),u("parseWfsCapabilities",self,(function(t){return Xt(t.url).then((function(t){return{info:(e=t,n=ee(e),o=n.startsWith("1.0")?"Service":"ServiceIdentification",i=n.startsWith("1.0")?"Name":"ServiceType",a=Gt(Rt(e),o),r=n.startsWith("1.0")?At(Gt(a,"Keywords")).split(",").map((function(t){return t.trim()})):Ct(Gt(a,"Keywords"),"Keyword").map(At),{title:At(Gt(a,"Title")),name:At(Gt(a,i)),abstract:At(Gt(a,"Abstract")),fees:At(Gt(a,"Fees")),constraints:At(Gt(a,"AccessConstraints")),keywords:r,outputFormats:re(e)}),featureTypes:ne(t),version:ee(t)};var e,r,n,o,i,a}))})),u("queryWfsFeatureTypeDetails",self,(function(t){var e=t.url,r=t.serviceVersion,n=t.featureTypeFull;return Xt(ce(e,r,n.name,void 0,void 0,Object.keys(n.properties))).then((function(t){return{props:(e=ae(t,n,r),e.reduce((function(t,e){var r=function(r){var n=e.properties[r];r in t||(t[r]={uniqueValues:[]});var o=t[r].uniqueValues.find((function(t){return t.value===n}));o?o.count++:t[r].uniqueValues.push({value:n,count:1})};for(var n in e.properties)r(n);return t}),{}))};var e}))}));
`], { type: "application/javascript" })), {
    type: "module"
  })), a0;
}
function kB(t) {
  return PB("parseWmsCapabilities", AB(), {
    url: t
  });
}
const _u = "";
class LB {
  constructor(e) {
    this.chars = [...e], this.charCount = this.chars.length, this.charIndex = 0, this.charsToBytes = new Array(this.charCount), this.multiByteMode = !1, this.string = e;
    let { chars: n, charCount: a, charsToBytes: s } = this;
    if (a === e.length)
      for (let f = 0; f < a; ++f)
        s[f] = f;
    else {
      for (let f = 0, o = 0; o < a; ++o)
        s[o] = f, f += n[o].length;
      this.multiByteMode = !0;
    }
  }
  get isEnd() {
    return this.charIndex >= this.charCount;
  }
  _charLength(e) {
    let { length: n } = e;
    return n < 2 || !this.multiByteMode ? n : e.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length;
  }
  advance(e = 1) {
    this.charIndex = Math.min(this.charCount, this.charIndex + e);
  }
  consume(e = 1) {
    let n = this.peek(e);
    return this.advance(e), n;
  }
  consumeMatch(e) {
    if (!e.sticky)
      throw new Error('`regex` must have a sticky flag ("y")');
    e.lastIndex = this.charsToBytes[this.charIndex];
    let n = e.exec(this.string);
    if (n === null)
      return _u;
    let a = n[0];
    return this.advance(this._charLength(a)), a;
  }
  consumeMatchFn(e) {
    let n = this.charIndex;
    for (; !this.isEnd && e(this.peek()); )
      this.advance();
    return this.charIndex > n ? this.string.slice(this.charsToBytes[n], this.charsToBytes[this.charIndex]) : _u;
  }
  consumeString(e) {
    if (this.consumeStringFast(e))
      return e;
    if (!this.multiByteMode)
      return _u;
    let { length: n } = e, a = this._charLength(e);
    return a !== n && e === this.peek(a) ? (this.advance(a), e) : _u;
  }
  consumeStringFast(e) {
    if (this.peek() === e[0]) {
      let { length: n } = e;
      if (n === 1)
        return this.advance(), e;
      if (this.peek(n) === e)
        return this.advance(n), e;
    }
    return _u;
  }
  consumeUntilMatch(e) {
    if (!e.global)
      throw new Error('`regex` must have a global flag ("g")');
    let n = this.charsToBytes[this.charIndex];
    e.lastIndex = n;
    let a = e.exec(this.string);
    if (a === null || a.index === n)
      return _u;
    let s = this.string.slice(n, a.index);
    return this.advance(this._charLength(s)), s;
  }
  consumeUntilString(e) {
    let { charIndex: n, charsToBytes: a, string: s } = this, f = a[n], o = s.indexOf(e, f);
    if (o <= 0)
      return _u;
    let m = s.slice(f, o);
    return this.advance(this._charLength(m)), m;
  }
  peek(e = 1) {
    if (this.charIndex >= this.charCount)
      return _u;
    if (e === 1)
      return this.chars[this.charIndex];
    let { charsToBytes: n, charIndex: a } = this;
    return this.string.slice(n[a], n[a + e]);
  }
  reset(e = 0) {
    this.charIndex = e >= 0 ? Math.min(this.charCount, e) : Math.max(0, this.charIndex + e);
  }
}
var DB = LB, Wu = {};
const NB = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
  amp: "&",
  apos: "'",
  gt: ">",
  lt: "<",
  quot: '"'
}));
Wu.predefinedEntities = NB;
function cI(t) {
  if (hI(t))
    return !0;
  let e = Rv(t);
  return e === 45 || e === 46 || e >= 48 && e <= 57 || e === 183 || e >= 768 && e <= 879 || e >= 8255 && e <= 8256;
}
Wu.isNameChar = cI;
function hI(t) {
  let e = Rv(t);
  return e === 58 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 192 && e <= 214 || e >= 216 && e <= 246 || e >= 248 && e <= 767 || e >= 880 && e <= 893 || e >= 895 && e <= 8191 || e >= 8204 && e <= 8205 || e >= 8304 && e <= 8591 || e >= 11264 && e <= 12271 || e >= 12289 && e <= 55295 || e >= 63744 && e <= 64975 || e >= 65008 && e <= 65533 || e >= 65536 && e <= 983039;
}
Wu.isNameStartChar = hI;
function RB(t) {
  return !fI(t);
}
Wu.isNotXmlChar = RB;
function zB(t) {
  return t === "#" || cI(t);
}
Wu.isReferenceChar = zB;
function FB(t) {
  let e = Rv(t);
  return e === 32 || e === 9 || e === 10 || e === 13;
}
Wu.isWhitespace = FB;
function fI(t) {
  let e = Rv(t);
  return e === 9 || e === 10 || e === 13 || e >= 32 && e <= 55295 || e >= 57344 && e <= 65533 || e >= 65536 && e <= 1114111;
}
Wu.isXmlChar = fI;
function Rv(t) {
  return t.codePointAt(0) || -1;
}
class ah {
  constructor() {
    this.parent = null;
  }
  get document() {
    return this.parent ? this.parent.document : null;
  }
  get isRootNode() {
    return this.parent ? this.parent === this.document : !1;
  }
  get preserveWhitespace() {
    return Boolean(this.parent && this.parent.preserveWhitespace);
  }
  get type() {
    return "";
  }
  toJSON() {
    let e = {
      type: this.type
    };
    return this.isRootNode && (e.isRootNode = !0), this.preserveWhitespace && (e.preserveWhitespace = !0), e;
  }
}
ah.TYPE_CDATA = "cdata";
ah.TYPE_COMMENT = "comment";
ah.TYPE_DOCUMENT = "document";
ah.TYPE_ELEMENT = "element";
ah.TYPE_PROCESSING_INSTRUCTION = "pi";
ah.TYPE_TEXT = "text";
var sh = ah;
const s0 = sh;
class BB extends s0 {
  constructor(e = "") {
    super(), this.text = e;
  }
  get type() {
    return s0.TYPE_TEXT;
  }
  toJSON() {
    return Object.assign(s0.prototype.toJSON.call(this), {
      text: this.text
    });
  }
}
var o1 = BB;
const VB = sh, UB = o1;
class jB extends UB {
  get type() {
    return VB.TYPE_CDATA;
  }
}
var pI = jB;
const l0 = sh;
class GB extends l0 {
  constructor(e = "") {
    super(), this.content = e;
  }
  get type() {
    return l0.TYPE_COMMENT;
  }
  toJSON() {
    return Object.assign(l0.prototype.toJSON.call(this), {
      content: this.content
    });
  }
}
var dI = GB;
const u0 = sh;
class a1 extends u0 {
  constructor(e, n = /* @__PURE__ */ Object.create(null), a = []) {
    super(), this.name = e, this.attributes = n, this.children = a;
  }
  get isEmpty() {
    return this.children.length === 0;
  }
  get preserveWhitespace() {
    let e = this;
    for (; e instanceof a1; ) {
      if ("xml:space" in e.attributes)
        return e.attributes["xml:space"] === "preserve";
      e = e.parent;
    }
    return !1;
  }
  get text() {
    return this.children.map((e) => "text" in e ? e.text : "").join("");
  }
  get type() {
    return u0.TYPE_ELEMENT;
  }
  toJSON() {
    return Object.assign(u0.prototype.toJSON.call(this), {
      name: this.name,
      attributes: this.attributes,
      children: this.children.map((e) => e.toJSON())
    });
  }
}
var s1 = a1;
const $B = s1, c0 = sh;
class qB extends c0 {
  constructor(e = []) {
    super(), this.children = e;
  }
  get document() {
    return this;
  }
  get root() {
    return this.children.find((e) => e instanceof $B) || null;
  }
  get text() {
    return this.children.map((e) => "text" in e ? e.text : "").join("");
  }
  get type() {
    return c0.TYPE_DOCUMENT;
  }
  toJSON() {
    return Object.assign(c0.prototype.toJSON.call(this), {
      children: this.children.map((e) => e.toJSON())
    });
  }
}
var mI = qB;
const h0 = sh;
class WB extends h0 {
  constructor(e, n = "") {
    super(), this.name = e, this.content = n;
  }
  get type() {
    return h0.TYPE_PROCESSING_INSTRUCTION;
  }
  toJSON() {
    return Object.assign(h0.prototype.toJSON.call(this), {
      name: this.name,
      content: this.content
    });
  }
}
var yI = WB;
const HB = DB, kc = Wu, ZB = pI, XB = dI, KB = mI, YB = s1, sE = yI, lE = o1, f0 = "";
class JB {
  constructor(e, n = {}) {
    for (this.document = new KB(), this.currentNode = this.document, this.options = n, this.scanner = new HB(e8(e)), this.consumeProlog(), this.consumeElement() || this.error("Root element is missing or invalid"); this.consumeMisc(); )
      ;
    this.scanner.isEnd || this.error("Extra content at the end of the document");
  }
  addNode(e) {
    e.parent = this.currentNode, this.currentNode.children.push(e);
  }
  addText(e) {
    let { children: n } = this.currentNode;
    if (n.length > 0) {
      let a = n[n.length - 1];
      if (a instanceof lE) {
        a.text += e;
        return;
      }
    }
    this.addNode(new lE(e));
  }
  consumeAttributeValue() {
    let { scanner: e } = this, n = e.peek();
    if (n !== '"' && n !== "'")
      return !1;
    e.advance();
    let a, s = !1, f = f0, o = n === '"' ? /[^"&<]+/y : /[^'&<]+/y;
    e:
      for (; !e.isEnd; )
        switch (a = e.consumeMatch(o), a && (this.validateChars(a), f += a.replace(/[\t\r\n]/g, " ")), e.peek()) {
          case n:
            s = !0;
            break e;
          case "&":
            f += this.consumeReference();
            continue;
          case "<":
            this.error("Unescaped `<` is not allowed in an attribute value");
            break;
          case f0:
            this.error("Unclosed attribute");
            break;
        }
    return s || this.error("Unclosed attribute"), e.advance(), f;
  }
  consumeCdataSection() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<![CDATA["))
      return !1;
    let n = e.consumeUntilString("]]>");
    return this.validateChars(n), e.consumeStringFast("]]>") || this.error("Unclosed CDATA section"), this.options.preserveCdata ? this.addNode(new ZB(n)) : this.addText(n), !0;
  }
  consumeCharData() {
    let { scanner: e } = this, n = e.consumeUntilMatch(/<|&|]]>/g);
    return n ? (this.validateChars(n), e.peek() === "]" && e.peek(3) === "]]>" && this.error("Element content may not contain the CDATA section close delimiter `]]>`"), this.addText(n), !0) : !1;
  }
  consumeComment() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<!--"))
      return !1;
    let n = e.consumeUntilString("--");
    return this.validateChars(n), e.consumeStringFast("-->") || (e.peek(2) === "--" ? this.error("The string `--` isn't allowed inside a comment") : this.error("Unclosed comment")), this.options.preserveComments && this.addNode(new XB(n.trim())), !0;
  }
  consumeContentReference() {
    let e = this.consumeReference();
    return e ? (this.addText(e), !0) : !1;
  }
  consumeDoctypeDeclaration() {
    let { scanner: e } = this;
    return !e.consumeStringFast("<!DOCTYPE") || !this.consumeWhitespace() ? !1 : (e.consumeMatch(/[^[>]+/y), e.consumeMatch(/\[[\s\S]+?\][\x20\t\r\n]*>/y) || e.consumeStringFast(">") || this.error("Unclosed doctype declaration"), !0);
  }
  consumeElement() {
    let { scanner: e } = this, n = e.charIndex;
    if (e.peek() !== "<")
      return !1;
    e.advance();
    let a = this.consumeName();
    if (!a)
      return e.reset(n), !1;
    let s = /* @__PURE__ */ Object.create(null);
    for (; this.consumeWhitespace(); ) {
      let m = this.consumeName();
      if (!m)
        continue;
      let g = this.consumeEqual() && this.consumeAttributeValue();
      g === !1 && this.error("Attribute value expected"), m in s && this.error(`Duplicate attribute: ${m}`), m === "xml:space" && g !== "default" && g !== "preserve" && this.error('Value of the `xml:space` attribute must be "default" or "preserve"'), s[m] = g;
    }
    if (this.options.sortAttributes) {
      let m = Object.keys(s).sort(), g = /* @__PURE__ */ Object.create(null);
      for (let b = 0; b < m.length; ++b) {
        let T = m[b];
        g[T] = s[T];
      }
      s = g;
    }
    let f = Boolean(e.consumeStringFast("/>")), o = new YB(a, s);
    if (o.parent = this.currentNode, !f) {
      for (e.consumeStringFast(">") || this.error(`Unclosed start tag for element \`${a}\``), this.currentNode = o, this.consumeCharData(); this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment(); )
        this.consumeCharData();
      let m = e.charIndex, g;
      (!e.consumeStringFast("</") || !(g = this.consumeName()) || g !== a) && (e.reset(m), this.error(`Missing end tag for element ${a}`)), this.consumeWhitespace(), e.consumeStringFast(">") || this.error(`Unclosed end tag for element ${a}`), this.currentNode = o.parent;
    }
    return this.addNode(o), !0;
  }
  consumeEqual() {
    return this.consumeWhitespace(), this.scanner.consumeStringFast("=") ? (this.consumeWhitespace(), !0) : !1;
  }
  consumeMisc() {
    return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();
  }
  consumeName() {
    return kc.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(kc.isNameChar) : f0;
  }
  consumeProcessingInstruction() {
    let { scanner: e } = this, n = e.charIndex;
    if (!e.consumeStringFast("<?"))
      return !1;
    let a = this.consumeName();
    if (a ? a.toLowerCase() === "xml" && (e.reset(n), this.error("XML declaration isn't allowed here")) : this.error("Invalid processing instruction"), !this.consumeWhitespace()) {
      if (e.consumeStringFast("?>"))
        return this.addNode(new sE(a)), !0;
      this.error("Whitespace is required after a processing instruction name");
    }
    let s = e.consumeUntilString("?>");
    return this.validateChars(s), e.consumeStringFast("?>") || this.error("Unterminated processing instruction"), this.addNode(new sE(a, s)), !0;
  }
  consumeProlog() {
    let { scanner: e } = this, n = e.charIndex;
    for (this.consumeXmlDeclaration(); this.consumeMisc(); )
      ;
    if (this.consumeDoctypeDeclaration())
      for (; this.consumeMisc(); )
        ;
    return n < e.charIndex;
  }
  consumeReference() {
    let { scanner: e } = this;
    if (e.peek() !== "&")
      return !1;
    e.advance();
    let n = e.consumeMatchFn(kc.isReferenceChar);
    e.consume() !== ";" && this.error("Unterminated reference (a reference must end with `;`)");
    let a;
    if (n[0] === "#") {
      let s = n[1] === "x" ? parseInt(n.slice(2), 16) : parseInt(n.slice(1), 10);
      isNaN(s) && this.error("Invalid character reference"), a = String.fromCodePoint(s), kc.isXmlChar(a) || this.error("Character reference resolves to an invalid character");
    } else if (a = kc.predefinedEntities[n], a === void 0) {
      let {
        ignoreUndefinedEntities: s,
        resolveUndefinedEntity: f
      } = this.options, o = `&${n};`;
      if (f) {
        let m = f(o);
        if (m != null) {
          let g = typeof m;
          if (g !== "string")
            throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${g}`);
          return m;
        }
      }
      if (s)
        return o;
      e.reset(-o.length), this.error(`Named entity isn't defined: ${o}`);
    }
    return a;
  }
  consumeSystemLiteral() {
    let { scanner: e } = this, n = e.consumeStringFast('"') || e.consumeStringFast("'");
    if (!n)
      return !1;
    let a = e.consumeUntilString(n);
    return this.validateChars(a), e.consumeStringFast(n) || this.error("Missing end quote"), a;
  }
  consumeWhitespace() {
    return Boolean(this.scanner.consumeMatchFn(kc.isWhitespace));
  }
  consumeXmlDeclaration() {
    let { scanner: e } = this;
    if (!e.consumeStringFast("<?xml"))
      return !1;
    this.consumeWhitespace() || this.error("Invalid XML declaration");
    let n = Boolean(e.consumeStringFast("version")) && this.consumeEqual() && this.consumeSystemLiteral();
    if (n === !1 ? this.error("XML version is missing or invalid") : /^1\.[0-9]+$/.test(n) || this.error("Invalid character in version number"), this.consumeWhitespace()) {
      Boolean(e.consumeStringFast("encoding")) && this.consumeEqual() && this.consumeSystemLiteral() && this.consumeWhitespace();
      let s = Boolean(e.consumeStringFast("standalone")) && this.consumeEqual() && this.consumeSystemLiteral();
      s && (s !== "yes" && s !== "no" && this.error('Only "yes" and "no" are permitted as values of `standalone`'), this.consumeWhitespace());
    }
    return e.consumeStringFast("?>") || this.error("Invalid or unclosed XML declaration"), !0;
  }
  error(e) {
    let { charIndex: n, string: a } = this.scanner, s = 1, f = "", o = 1;
    for (let T = 0; T < n; ++T) {
      let M = a[T];
      M === `
` ? (s = 1, f = "", o += 1) : (s += 1, f += M);
    }
    let m = a.indexOf(`
`, n);
    f += m === -1 ? a.slice(n) : a.slice(n, m);
    let g = 0;
    f.length > 50 && (s < 40 ? f = f.slice(0, 50) : (g = s - 20, f = f.slice(g, s + 30)));
    let b = new Error(
      `${e} (line ${o}, column ${s})
  ${f}
` + " ".repeat(s - g + 1) + `^
`
    );
    throw Object.assign(b, {
      column: s,
      excerpt: f,
      line: o,
      pos: n
    }), b;
  }
  validateChars(e) {
    let n = 0;
    for (let a of e)
      kc.isNotXmlChar(a) && (this.scanner.reset(-([...e].length - n)), this.error("Invalid character")), n += 1;
  }
}
var QB = JB;
function e8(t) {
  return t[0] === "\uFEFF" && (t = t.slice(1)), t.replace(/\r\n?/g, `
`);
}
const t8 = QB, r8 = pI, n8 = dI, i8 = mI, o8 = s1, a8 = sh, s8 = yI, l8 = o1;
function Hu(t, e) {
  return new t8(t, e).document;
}
Hu.XmlCdata = r8;
Hu.XmlComment = n8;
Hu.XmlDocument = i8;
Hu.XmlElement = o8;
Hu.XmlNode = a8;
Hu.XmlProcessingInstruction = s8;
Hu.XmlText = l8;
var u8 = Hu;
class c8 extends Error {
  constructor(e) {
    super(e);
  }
}
function h8(t) {
  let e = null;
  try {
    e = u8(t);
  } catch (n) {
    throw new c8(n.message);
  }
  return e;
}
function ql(t) {
  return t.children[0];
}
function Qg(t) {
  const e = t.indexOf(":");
  return e > -1 ? t.substr(e + 1) : t;
}
function ev(t) {
  return t.name || "";
}
function Eo(t, e, n) {
  const a = Qg(e);
  function s(f, o) {
    return Qg(ev(o)) === a && f.push(o), n && Array.isArray(o.children) ? [...f, ...o.children.reduce(s, [])] : f;
  }
  return t && Array.isArray(t.children) ? t.children.reduce(s, []) : [];
}
function wr(t, e, n) {
  return Eo(t, e, n)[0] || null;
}
function ad(t) {
  return t && Array.isArray(t.children) ? [...t.children.filter((e) => e.constructor.name === "XmlElement")] : [];
}
function xn(t) {
  const e = t && Array.isArray(t.children) ? t.children.find((n) => n.type === "text") : null;
  return e ? e.text : "";
}
function Ys(t, e) {
  return t && t.attributes[e] || "";
}
const uE = ["utf-8", "utf-16", "iso-8859-1"], cE = "utf-8";
function f8(t) {
  const e = /charset=([^;]+)/.exec(t);
  return e ? e[1] : null;
}
function p8(t, e) {
  const n = e ? f8(e) : null, a = n ? [n, ...uE] : uE;
  for (const s of a)
    try {
      return new TextDecoder(s, { fatal: !0 }).decode(t);
    } catch {
    }
  return console.warn(
    `XML document encoding could not be determined, falling back to ${cE}.`
  ), new TextDecoder(cE).decode(t);
}
const jy = /* @__PURE__ */ new Map();
function d8(t) {
  if (jy.has(t))
    return jy.get(t);
  const e = fetch(t);
  return e.finally(() => jy.delete(t)), jy.set(t, e), e;
}
function l1(t) {
  return d8(t).catch(
    () => fetch(t, { method: "HEAD", mode: "no-cors" }).catch((e) => {
      throw new o0(
        `Fetching the document failed either due to network errors or unreachable host, error is: ${e.message}`,
        0,
        !1
      );
    }).then(() => {
      throw new o0(
        "The document could not be fetched due to CORS limitations",
        0,
        !0
      );
    })
  ).then(async (e) => {
    if (!e.ok) {
      const s = await e.text();
      throw new o0(
        `Received an error with code ${e.status}: ${s}`,
        e.status,
        !1
      );
    }
    const n = await e.arrayBuffer(), a = e.headers.get("Content-Type");
    return p8(n, a);
  }).then((e) => h8(e));
}
function u1(t, e) {
  const n = t.match(/(https?%3A%2F%2F[^/]+)$/);
  if (n) {
    const m = n[1], g = u1(decodeURIComponent(m), e);
    return t.replace(m, encodeURIComponent(g));
  }
  const a = new URL(t), s = Object.keys(e), f = s.map((m) => m.toLowerCase()), o = [];
  for (const m of a.searchParams.keys())
    f.indexOf(m.toLowerCase()) > -1 && o.push(m);
  return o.map((m) => a.searchParams.delete(m)), s.forEach(
    (m) => a.searchParams.set(m, e[m] === !0 ? "" : e[m])
  ), a.toString();
}
let m8 = 1e3 * 60 * 60;
function y8() {
  return m8;
}
const Uu = "caches" in self ? caches.open("ogc-client") : null;
async function g8(t, ...e) {
  if (!Uu)
    return;
  const n = "https://cache/" + e.join("/");
  await (await Uu).put(
    n,
    new Response(JSON.stringify(t), {
      headers: {
        "x-expiry": (Date.now() + y8()).toString(10)
      }
    })
  );
}
async function v8(...t) {
  if (!Uu)
    return !1;
  const e = "https://cache/" + t.join("/");
  return (await Uu).match(e).then((a) => !!a && parseInt(a.headers.get("x-expiry")) > Date.now());
}
async function _8(...t) {
  if (!Uu)
    return null;
  const e = "https://cache/" + t.join("/"), a = await (await Uu).match(e);
  return a ? a.clone().json() : null;
}
const Gy = /* @__PURE__ */ new Map();
async function x8(t, ...e) {
  if (await b8(), await v8(...e))
    return _8(...e);
  const n = e.join("#");
  if (Gy.has(n))
    return Gy.get(n);
  const a = t();
  a instanceof Promise && (a.then(() => Gy.delete(n)), Gy.set(n, a));
  const s = await a;
  return await g8(s, ...e), s;
}
async function b8() {
  if (!Uu)
    return;
  const t = await Uu, e = await t.keys();
  for (let n of e) {
    const a = await t.match(n);
    parseInt(a.headers.get("x-expiry")) <= Date.now() && await t.delete(n);
  }
}
function w8(t, e, n, a, s, f, o, m, g, b) {
  const T = e === "2.0.0" ? "TYPENAMES" : "TYPENAME", M = e === "2.0.0" ? "COUNT" : "MAXFEATURES", I = {
    SERVICE: "WFS",
    REQUEST: "GetFeature",
    VERSION: e,
    [T]: n
  };
  if (a !== void 0 && (I.OUTPUTFORMAT = a), f !== void 0 && (I.PROPERTYNAME = f.join(",")), o ? (I.RESULTTYPE = "hits", I[M] = "1") : s !== void 0 && (I[M] = s.toString(10)), m && (I.SRSNAME = m), g) {
    const A = g.join(",");
    I.BBOX = b ? `${A},${b}` : A;
  }
  return u1(t, I);
}
class E8 {
  constructor(e) {
    const n = u1(e, {
      SERVICE: "WMS",
      REQUEST: "GetCapabilities"
    });
    this._capabilitiesPromise = x8(
      () => kB(n),
      "WMS",
      "CAPABILITIES",
      n
    ).then(({ info: a, layers: s, version: f }) => {
      this._info = a, this._layers = s, this._version = f;
    }), this._info = null, this._layers = null, this._version = null;
  }
  isReady() {
    return this._capabilitiesPromise.then(() => this);
  }
  getServiceInfo() {
    return this._info;
  }
  getLayers() {
    function e(n) {
      return {
        title: n.title,
        name: n.name,
        abstract: n.abstract,
        ..."children" in n && {
          children: n.children.map(e)
        }
      };
    }
    return this._layers.map(e);
  }
  getLayerByName(e) {
    let n = null;
    function a(s) {
      if (n === null) {
        if (s.name === e) {
          n = s;
          return;
        }
        "children" in s && s.children.map(a);
      }
    }
    return this._layers.map(a), n;
  }
  getVersion() {
    return this._version;
  }
}
const S8 = [
  "EPSG:4046",
  "EPSG:4075",
  "EPSG:4120",
  "EPSG:4122",
  "EPSG:4124",
  "EPSG:4126",
  "EPSG:4149",
  "EPSG:4151",
  "EPSG:4153",
  "EPSG:4155",
  "EPSG:4157",
  "EPSG:4159",
  "EPSG:4161",
  "EPSG:4163",
  "EPSG:4165",
  "EPSG:4167",
  "EPSG:4169",
  "EPSG:4171",
  "EPSG:4173",
  "EPSG:4175",
  "EPSG:4178",
  "EPSG:4180",
  "EPSG:4182",
  "EPSG:4184",
  "EPSG:4188",
  "EPSG:4190",
  "EPSG:4191",
  "EPSG:4196",
  "EPSG:4198",
  "EPSG:4202",
  "EPSG:4210",
  "EPSG:4211",
  "EPSG:4214",
  "EPSG:4226",
  "EPSG:4229",
  "EPSG:4231",
  "EPSG:4233",
  "EPSG:4236",
  "EPSG:4238",
  "EPSG:4240",
  "EPSG:4242",
  "EPSG:4244",
  "EPSG:4246",
  "EPSG:4248",
  "EPSG:4250",
  "EPSG:4252",
  "EPSG:4255",
  "EPSG:4258",
  "EPSG:4261",
  "EPSG:4264",
  "EPSG:4267",
  "EPSG:4270",
  "EPSG:4273",
  "EPSG:4276",
  "EPSG:4279",
  "EPSG:4281",
  "EPSG:4284",
  "EPSG:4286",
  "EPSG:4288",
  "EPSG:4292",
  "EPSG:4295",
  "EPSG:4297",
  "EPSG:4299",
  "EPSG:4302",
  "EPSG:4324",
  "EPSG:4326"
];
function T8(t) {
  return S8.indexOf(fx(t)) > -1;
}
function fx(t) {
  return /^urn:(?:x-)?ogc:def:crs:epsg:/.test(t.toLowerCase()) ? `EPSG:${/([0-9]+)$/.exec(t)[1]}` : t;
}
function gI(t) {
  return ql(t).attributes.version;
}
function M8(t) {
  const e = gI(t), n = wr(
    ql(t),
    "Capability"
  );
  return Eo(n, "Layer").map(
    (a) => vI(a, e)
  );
}
function I8(t) {
  const e = wr(ql(t), "Service"), n = Eo(
    wr(e, "KeywordList"),
    "Keyword"
  ).map(xn).filter((a, s, f) => f.indexOf(a) === s);
  return {
    title: xn(wr(e, "Title")),
    name: xn(wr(e, "Name")),
    abstract: xn(wr(e, "Abstract")),
    fees: xn(wr(e, "Fees")),
    constraints: xn(wr(e, "AccessConstraints")),
    keywords: n
  };
}
function vI(t, e, n = [], a = [], s = null) {
  const f = e === "1.3.0" ? "CRS" : "SRS", o = Eo(t, f).map(xn), m = o.length > 0 ? o : n, g = Eo(t, "Style").map(
    O8
  ), b = g.length > 0 ? g : a;
  function T(z) {
    const V = Ys(z, f);
    return (T8(V) && e === "1.3.0" ? ["miny", "minx", "maxy", "maxx"] : ["minx", "miny", "maxx", "maxy"]).map((re) => Ys(z, re));
  }
  const M = wr(t, "Attribution"), I = M !== null ? C8(M) : s, A = Eo(t, "Layer").map(
    (z) => vI(z, e, m, b, I)
  );
  return {
    name: xn(wr(t, "Name")),
    title: xn(wr(t, "Title")),
    abstract: xn(wr(t, "Abstract")),
    availableCrs: m,
    styles: b,
    attribution: I,
    boundingBoxes: Eo(t, "BoundingBox").reduce(
      (z, V) => ({
        ...z,
        [Ys(V, f)]: T(V)
      }),
      {}
    ),
    ...A.length && { children: A }
  };
}
function O8(t) {
  const e = Ys(
    wr(wr(t, "LegendURL"), "OnlineResource"),
    "xlink:href"
  );
  return {
    name: xn(wr(t, "Name")),
    title: xn(wr(t, "Title")),
    ...e && { legendUrl: e }
  };
}
function C8(t) {
  const e = Ys(
    wr(
      wr(t, "LogoURL"),
      "OnlineResource"
    ),
    "xlink:href"
  ), n = Ys(
    wr(t, "OnlineResource"),
    "xlink:href"
  ), a = xn(wr(t, "Title"));
  return {
    ...a && { title: a },
    ...n && { url: n },
    ...e && { logoUrl: e }
  };
}
function zv(t) {
  return ql(t).attributes.version;
}
function _I(t) {
  const e = zv(t);
  let n;
  if (e.startsWith("1.0")) {
    const a = wr(
      wr(
        wr(ql(t), "Capability"),
        "Request"
      ),
      "GetFeature"
    );
    n = ad(
      wr(a, "ResultFormat")
    ).map(ev);
  } else {
    const a = wr(
      ql(t),
      "OperationsMetadata"
    ), s = Eo(a, "Operation").find(
      (o) => Ys(o, "name") === "GetFeature"
    ), f = Eo(s, "Parameter").find(
      (o) => Ys(o, "name") === "outputFormat"
    );
    n = Eo(f, "Value", !0).map(
      xn
    );
  }
  return n;
}
function P8(t) {
  const e = zv(t), n = e.startsWith("1.0") ? "Service" : "ServiceIdentification", a = e.startsWith("1.0") ? "Name" : "ServiceType", s = wr(ql(t), n);
  let f;
  return e.startsWith("1.0") ? f = xn(wr(s, "Keywords")).split(",").map((o) => o.trim()) : f = Eo(
    wr(s, "Keywords"),
    "Keyword"
  ).map(xn), {
    title: xn(wr(s, "Title")),
    name: xn(wr(s, a)),
    abstract: xn(wr(s, "Abstract")),
    fees: xn(wr(s, "Fees")),
    constraints: xn(wr(s, "AccessConstraints")),
    keywords: f,
    outputFormats: _I(t)
  };
}
function A8(t) {
  const e = zv(t), n = _I(t), a = wr(
    ql(t),
    "FeatureTypeList"
  );
  return Eo(a, "FeatureType").map(
    (s) => k8(s, e, n)
  );
}
function k8(t, e, n) {
  const a = e.startsWith("2.") ? "CRS" : "SRS", s = e.startsWith("1.0") ? "SRS" : `Default${a}`;
  function f() {
    const b = wr(t, "LatLongBoundingBox");
    return ["minx", "miny", "maxx", "maxy"].map((T) => Ys(b, T)).map(parseFloat);
  }
  function o() {
    const b = wr(t, "WGS84BoundingBox");
    return ["LowerCorner", "UpperCorner"].map((T) => wr(b, T)).map((T) => xn(T).split(" ")).reduce((T, M) => [...T, ...M]).map(parseFloat);
  }
  const m = e.startsWith("1.0") ? [] : Eo(t, `Other${a}`).map(xn).map(fx), g = e.startsWith("1.0") ? [] : Eo(
    wr(t, "OutputFormats"),
    "Format"
  ).map(xn);
  return {
    name: xn(wr(t, "Name")),
    title: xn(wr(t, "Title")),
    abstract: xn(wr(t, "Abstract")),
    defaultCrs: fx(
      xn(wr(t, s))
    ),
    otherCrs: m,
    outputFormats: g.length > 0 ? g : n,
    latLonBoundingBox: e.startsWith("1.0") ? f() : o()
  };
}
function L8(t, e, n) {
  const a = ql(t);
  let s;
  if (n.startsWith("2.0"))
    s = Eo(a, "member").map(
      (b) => ad(b)[0]
    );
  else {
    const b = wr(a, "featureMembers");
    s = b ? ad(b) : Eo(a, "featureMember").map(
      (T) => ad(T)[0]
    );
  }
  const f = n === "1.0.0" ? "fid" : "gml:id";
  function o(b) {
    return b in e.properties;
  }
  function m(b, T) {
    switch (e.properties[b]) {
      case "integer":
        return parseInt(T);
      case "float":
        return parseFloat(T);
      case "boolean":
        return T === "true";
      default:
        return T;
    }
  }
  function g(b) {
    return ad(b).filter((T) => o(Qg(ev(T)))).reduce((T, M) => {
      const I = Qg(ev(M));
      return {
        ...T,
        [I]: m(I, xn(M))
      };
    }, {});
  }
  return s.map((b) => ({
    id: Ys(b, f),
    properties: g(b)
  }));
}
function D8(t) {
  return t.reduce((e, n) => {
    for (const a in n.properties) {
      const s = n.properties[a];
      a in e || (e[a] = { uniqueValues: [] });
      const f = e[a].uniqueValues.find(
        (o) => o.value === s
      );
      f ? f.count++ : e[a].uniqueValues.push({ value: s, count: 1 });
    }
    return e;
  }, {});
}
i1(
  "parseWmsCapabilities",
  self,
  ({ url: t }) => l1(t).then((e) => ({
    info: I8(e),
    layers: M8(e),
    version: gI(e)
  }))
);
i1(
  "parseWfsCapabilities",
  self,
  ({ url: t }) => l1(t).then((e) => ({
    info: P8(e),
    featureTypes: A8(e),
    version: zv(e)
  }))
);
i1(
  "queryWfsFeatureTypeDetails",
  self,
  ({ url: t, serviceVersion: e, featureTypeFull: n }) => {
    const a = w8(
      t,
      e,
      n.name,
      void 0,
      void 0,
      Object.keys(n.properties)
    );
    return l1(a).then((s) => ({
      props: D8(
        L8(s, n, e)
      )
    }));
  }
);
const N8 = () => [
  {
    url: "http://wmts1.geoportail.lu/opendata/service",
    label: "Open Data Webservices WMS"
  },
  {
    url: "http://ows.terrestris.de/osm-gray/service",
    label: "OpenStreetMap by Terrestris (Grey)"
  },
  {
    url: "http://ows.terrestris.de/osm/service",
    label: "OpenStreetMap by Terrestris (Color)"
  }
];
class R8 {
  constructor(e) {
    ri(this, "capabilitiesPromise");
    ri(this, "serviceInfo");
    ri(this, "layers");
    const n = new BC();
    let a = "&";
    e.indexOf("?") === -1 && (a = "?"), e.indexOf("Capabilities") === -1 && (e = e + a + "SERVICE=WMTS&REQUEST=GetCapabilities"), this.capabilitiesPromise = fetch(e).then((s) => s.text()).then((s) => {
      var o;
      const f = n.read(s);
      this.serviceInfo = this.mapServiceInfo(f.ServiceIdentification), this.layers = this.mapToRemoteLayers((o = f.Contents) == null ? void 0 : o.Layer);
    });
  }
  mapToRemoteLayers(e) {
    return [
      {
        type: Na.WMTS,
        children: e.map(
          (n) => ({
            type: Na.WMTS,
            abstract: n.Abstract,
            format: n.Format,
            name: n.Identifier,
            title: n.Title,
            tileMatrixSetLink: n.TileMatrixSetLink,
            wgs84BoundingBox: n.WGS84BoundingBox
          })
        )
      }
    ];
  }
  mapServiceInfo(e) {
    return {
      type: Na.WMTS,
      title: e.Title,
      abstract: e.Abstract,
      fees: e.Fees,
      constraints: e.AccessConstraints,
      serviceTypeVersion: e.ServiceTypeVersion
    };
  }
  isReady() {
    return this.capabilitiesPromise.then(() => this);
  }
  getLayerByName(e) {
    return this.layers[0].children.filter((n) => n.name === e)[0];
  }
  getLayers() {
    return this.layers;
  }
  getServiceInfo() {
    return this.serviceInfo;
  }
}
class z8 {
  async getRemoteEndpoint(e) {
    let n;
    return await this.getWmsEndpoint(e).isReady().catch(async () => {
      n = await this.getWmtsEndpoint(e).isReady();
    }) || n;
  }
  getWmsEndpoint(e) {
    return new E8(Ff.getProxyfiedUrl(e));
  }
  getWmtsEndpoint(e) {
    return new R8(Ff.getProxyfiedUrl(e));
  }
  async fetchRemoteWmsEndpoint() {
    return new Promise((e) => e(N8()));
  }
  isRemoteLayer(e) {
    return typeof e == "string" && (e.indexOf(Na.WMS) === 0 || e.indexOf(Na.WMTS) === 0);
  }
}
const Fd = new z8(), F8 = { class: "relative text-center" }, B8 = ["placeholder", "value"], V8 = {
  key: 0,
  class: "text-center"
}, U8 = { class: "lux-label" }, j8 = {
  key: 1,
  class: "text-center"
}, G8 = { class: "lux-label" }, $8 = {
  key: 2,
  class: "text-center"
}, q8 = /* @__PURE__ */ Fe("div", { class: "fa fa-refresh fa-spin" }, null, -1), W8 = {
  key: 3,
  class: "overflow-auto max-h-[calc(400px-36px)]"
}, H8 = /* @__PURE__ */ ir({
  __name: "remote-layers",
  setup(t) {
    const { t: e } = En(), n = Ei(), a = cs(), s = Bn([]), f = Bn(), { remoteLayersOpen: o } = pn(Ai()), { setRemoteLayersOpen: m } = Ai();
    let g = !1, b, T, M;
    va(I);
    function I() {
      f.value = f.value ? Af.updateLayers(
        f.value,
        n.layers
      ) : void 0;
    }
    Fd.fetchRemoteWmsEndpoint().then((ce) => {
      s.value = ce.map(({ url: ve, label: Ne }) => ({
        label: Ne,
        value: ve
      }));
    });
    async function A(ce) {
      g = !0, M = await Fd.getRemoteEndpoint(ce).catch(() => alert(e("Impossible de contacter ce WMS", { ns: "client" }))), T = ce, g = !1;
    }
    async function z() {
      const ce = M, ve = ce == null ? void 0 : ce.getLayers();
      if (ve && ve[0]) {
        const Ne = lI(
          ve[0],
          T
        );
        f.value = Af.updateLayers(Ne, n.layers);
      }
    }
    async function V(ce) {
      T = b = ce, await A(T), z();
    }
    function q(ce) {
      b = ce.target.value;
    }
    async function re() {
      await A(b), z();
    }
    function X(ce) {
      f.value = Af.toggleNode(
        ce.id,
        f.value,
        "expanded"
      );
    }
    function ae(ce) {
      const { id: ve, name: Ne } = ce, ze = M;
      if (ce.checked === !0)
        n.removeLayers(ve);
      else {
        const Ae = ze == null ? void 0 : ze.getLayerByName(Ne);
        if (Ae) {
          const Se = a.initLayer(
            uI({
              id: ve,
              url: Ff.getProxyfiedUrl(T),
              remoteLayer: Ae
            })
          );
          n.addLayers(Se);
        }
      }
    }
    return (ce, ve) => se(o) ? (Be(), an(sI, {
      key: 0,
      title: se(e)("Add external data", { ns: "client" }),
      onClose: ve[0] || (ve[0] = (Ne) => se(m)(!1))
    }, {
      content: ku(() => {
        var Ne, ze;
        return [
          Fe("div", F8, [
            kt(BT, {
              class: "lux-remote-services-dropdown",
              options: se(s),
              placeholder: se(e)("Predefined wms", { ns: "client" }),
              onChange: V
            }, null, 8, ["options", "placeholder"]),
            Fe("input", {
              class: "lux-input w-[300px]",
              type: "url",
              placeholder: se(e)("Choose or write a WMS url", {
                ns: "client"
              }),
              value: se(T) || "",
              onChange: q
            }, null, 40, B8),
            Fe("button", {
              type: "button",
              class: "lux-btn",
              onClick: re
            }, Ht(se(e)("Get the layers", { ns: "client" })), 1)
          ]),
          !se(g) && se(M) ? (Be(), rt("div", V8, [
            Fe("span", U8, Ht(se(e)("Description du service :", {
              ns: "client"
            })), 1),
            Ag(" " + Ht((Ne = se(M).getServiceInfo()) == null ? void 0 : Ne.abstract), 1)
          ])) : Ye("v-if", !0),
          !se(g) && se(M) ? (Be(), rt("div", j8, [
            Fe("span", G8, Ht(se(e)("Access constraints :", {
              ns: "client"
            })), 1),
            Ag(" " + Ht((ze = se(M).getServiceInfo()) == null ? void 0 : ze.constraints), 1)
          ])) : Ye("v-if", !0),
          se(g) ? (Be(), rt("div", $8, [
            q8,
            Fe("span", null, Ht(se(e)("Chargement des informations", {
              ns: "client"
            })), 1)
          ])) : Ye("v-if", !0),
          se(g) ? Ye("v-if", !0) : (Be(), rt("div", W8, [
            se(f) ? (Be(), an(hx, {
              key: 0,
              class: "block p-[10px] mb-[11px]",
              node: se(f),
              onToggleParent: X,
              onToggleLayer: ae
            }, null, 8, ["node"])) : Ye("v-if", !0)
          ]))
        ];
      }),
      _: 1
    }, 8, ["title"])) : Ye("v-if", !0);
  }
}), Z8 = /* @__PURE__ */ lr(H8, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/remote-layers/remote-layers.vue"]]);
function X8(t, e = "fr-FR") {
  const n = new Date(t);
  return new Intl.DateTimeFormat(e).format(n);
}
const K8 = { class: "font-bold" }, Y8 = { class: "col-span-2" }, J8 = /* @__PURE__ */ ir({
  __name: "layer-metadata-item",
  props: {
    label: { type: String, required: !0 },
    value: { type: String, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Be(), rt(on, null, [
      Fe("span", K8, Ht(e.label), 1),
      Fe("span", Y8, Ht(e.value), 1)
    ], 64));
  }
}), Yp = /* @__PURE__ */ lr(J8, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-metadata/layer-metadata-item.vue"]]);
function Q8(t) {
  return {
    fr: "fre",
    en: "eng",
    de: "ger",
    lb: "ltz"
  }[t.toLowerCase()];
}
function eV(t) {
  return new DOMParser().parseFromString(t, "text/html").body;
}
function tV(t) {
  const e = [];
  function n(a) {
    const s = a.split("|");
    s[3] === "WWW:LINK-1.0-http--link" && e.indexOf(s[2]) === -1 && e.push(s[2]);
  }
  return Array.isArray(t) ? t.forEach(n, t) : n(t), e;
}
function rV(t) {
  const n = (Array.isArray(t) ? t : [t]).filter((a) => a.split("|")[1] === "metadata");
  return {
    organisaton: n[0].split("|")[2],
    name: n[0].split("|")[5],
    unknown: n[0].split("|")[6],
    address: n[0].split("|")[7],
    email: n[0].split("|")[4]
  };
}
class xI {
}
class nV extends xI {
  async getMetadata(e, n, a) {
    console.assert(e === Na.WMS);
    const s = Fd.getWmsEndpoint(n);
    await s.isReady();
    const f = s == null ? void 0 : s.getServiceInfo(), o = s == null ? void 0 : s.getLayerByName(a);
    return {
      title: o.title,
      description: o.abstract,
      keywords: f.keywords,
      accessConstraints: f.constraints,
      serviceDescription: f.abstract
    };
  }
}
const iV = new nV();
class oV extends xI {
  async getMetadata(e, n, a) {
    console.assert(e === Na.WMTS);
    const s = Fd.getWmtsEndpoint(n);
    await s.isReady();
    const f = s == null ? void 0 : s.getServiceInfo(), o = s == null ? void 0 : s.getLayerByName(a);
    return {
      title: o.title,
      description: o.abstract,
      accessConstraints: f.constraints,
      serviceDescription: f.abstract
    };
  }
}
const aV = new oV();
class sV {
  async getMetadata(e, n, a) {
    if (e === Na.WMS)
      return iV.getMetadata(e, n, a);
    if (e === Na.WMTS)
      return aV.getMetadata(e, n, a);
    throw new Error(`Unsupported service type: ${e}`);
  }
}
const lV = new sV();
class uV {
  constructor() {
    ri(this, "geonetworkBaseUrl", "https://geocatalogue.geoportail.lu/geonetwork/srv");
    ri(this, "legendBaseUrl", "https://map.geoportail.lu/legends/get_html");
    ri(this, "localMetadataBaseUrl", "https://map.geoportail.lu/getMetadata");
  }
  async getLayerMetadata(e, n) {
    const a = Kc(), s = a.findBgLayerById(+e) || a.findById(+e) || a.find3dLayerById(+e);
    if (s) {
      const f = s.metadata, o = f == null ? void 0 : f.metadata_id, m = o && await this.getLocalMetadata(
        this.localMetadataBaseUrl,
        o,
        n
      ), g = s.name, b = (f == null ? void 0 : f.legend_name) || "", T = s == null ? void 0 : s.id, M = b && await this.getLegendHtml(
        this.legendBaseUrl,
        b,
        T,
        n
      );
      return {
        ...m,
        title: g,
        hasLegend: !!M,
        ...M && { legendHtml: M }
      };
    } else {
      const [f, o, m] = String(e).split("%2D").join("-").split("||");
      return lV.getMetadata(
        f,
        o,
        m
      );
    }
  }
  getLocalMetadata(e, n, a) {
    return fetch(`${e}?lang=${a}&uid=${n}`).then(async (s) => {
      const f = (await s.json()).metadata;
      return {
        name: f.title,
        serviceDescription: f.serviceDescription,
        description: f.abstract,
        legalConstraints: f.legalConstraints,
        link: tV(f.link),
        revisionDate: f.revisionDate,
        keyword: f.keyword,
        responsibleParty: f.responsibleParty ? rV(f.responsibleParty) : void 0,
        metadataLink: `${this.geonetworkBaseUrl}/${Q8(
          a
        )}/catalog.search#/metadata/${n}`,
        isError: !1
      };
    }).catch(() => ({ isError: !0 }));
  }
  getLegendHtml(e, n, a, s) {
    const f = {
      lang: s,
      ...n && { name: n },
      ...a && { id: a.toString() }
    };
    if (f.name && f.lang) {
      window.devicePixelRatio > 1 && (f.dpi = (window.devicePixelRatio * 96).toString());
      const o = `${e}?${new URLSearchParams(
        f
      ).toString()}`;
      return fetch(o).then(async (m) => {
        if (m.status >= 400 && m.status < 600)
          throw new Error("Server responded with error code");
        const g = await m.text();
        return g ? eV(g) : void 0;
      }).catch(() => {
      });
    }
  }
}
const hE = new uV(), cV = { class: "grid gap-2 grid-cols-3 pt-3 text-[13px] font-arial break-words" }, hV = {
  key: 2,
  class: "col-span-3 grid gap-2 grid-cols-3"
}, fV = { class: "font-bold" }, pV = { class: "col-span-2" }, dV = ["title"], mV = ["title"], yV = {
  key: 4,
  class: "col-span-3"
}, gV = { class: "font-bold" }, vV = { class: "col-span-2" }, _V = ["href"], xV = {
  key: 7,
  class: "col-span-3 grid gap-2 grid-cols-3"
}, bV = { class: "font-bold" }, wV = { class: "col-span-2" }, EV = { key: 0 }, SV = { key: 1 }, TV = { key: 2 }, MV = { key: 3 }, IV = { key: 4 }, OV = ["href"], CV = {
  key: 8,
  class: "grid gap-2 grid-cols-3 col-span-3"
}, PV = { class: "font-bold" }, AV = { class: "col-span-2" }, kV = ["href"], LV = {
  key: 9,
  class: "col-span-3"
}, DV = { key: 10 }, NV = { class: "text-xl" }, RV = {
  key: 11,
  class: "col-span-3"
}, zV = /* @__PURE__ */ ir({
  __name: "layer-metadata",
  setup(t) {
    const e = n1(), { metadataId: n } = pn(e), { t: a, i18next: s } = En(), f = Er(), o = Er(!0), m = 220;
    An(n, async (I) => {
      var A, z;
      f.value = I ? await hE.getLayerMetadata(I, s.language) : void 0, o.value = (((z = (A = f.value) == null ? void 0 : A.description) == null ? void 0 : z.length) || 0) < m;
    }), _a(() => {
      s.on("languageChanged", async () => {
        n.value && (f.value = await hE.getLayerMetadata(
          n.value,
          s.language
        ));
      });
    });
    const g = ar(
      () => {
        var I, A, z;
        return o.value ? (I = f.value) == null ? void 0 : I.description : (z = (A = f.value) == null ? void 0 : A.description) == null ? void 0 : z.slice(0, m);
      }
    );
    function b() {
      o.value = !0;
    }
    function T() {
      o.value = !1;
    }
    function M() {
      e.clearMetadataId();
    }
    return (I, A) => {
      const z = Nx("dompurify-html");
      return f.value ? (Be(), an(sI, {
        key: 0,
        footer: !1,
        "max-height": !0,
        title: se(a)(`${f.value.title}`, { ns: "client" }),
        onClose: M
      }, {
        content: ku(() => {
          var V, q, re, X, ae, ce, ve, Ne, ze, Ae, Se, Ie, Xe, $e, at;
          return [
            Fe("div", cV, [
              f.value.name ? (Be(), an(Yp, {
                key: 0,
                label: se(a)("Name"),
                value: f.value.name
              }, null, 8, ["label", "value"])) : Ye("v-if", !0),
              f.value.serviceDescription ? (Be(), an(Yp, {
                key: 1,
                label: se(a)("Description du Service"),
                value: f.value.serviceDescription
              }, null, 8, ["label", "value"])) : Ye("v-if", !0),
              f.value.description ? (Be(), rt("div", hV, [
                Fe("span", fV, Ht(se(a)("Description")), 1),
                Fe("span", pV, [
                  Og(Fe("span", null, null, 512), [
                    [z, se(g)]
                  ]),
                  o.value ? Ye("v-if", !0) : (Be(), rt("button", {
                    key: 0,
                    title: se(a)("Display full description", {
                      ns: "client"
                    }),
                    onClick: b,
                    class: "text-secondary hover:underline"
                  }, " ... ", 8, dV)),
                  o.value && (((V = se(g)) == null ? void 0 : V.length) || 0) > m ? (Be(), rt("button", {
                    key: 1,
                    title: se(a)("Hide full description", {
                      ns: "client"
                    }),
                    onClick: T,
                    class: "text-secondary hover:underline"
                  }, " - ", 8, mV)) : Ye("v-if", !0)
                ])
              ])) : Ye("v-if", !0),
              f.value.legalConstraints ? (Be(), an(Yp, {
                key: 3,
                label: se(a)("Contrainte d'utilisation"),
                value: f.value.legalConstraints
              }, null, 8, ["label", "value"])) : Ye("v-if", !0),
              ((q = f.value.link) == null ? void 0 : q.length) !== 0 ? (Be(), rt("div", yV, [
                (Be(!0), rt(on, null, Ra(f.value.link, (be) => (Be(), rt("div", {
                  class: "grid gap-2 grid-cols-3",
                  key: be
                }, [
                  Fe("span", gV, Ht(se(a)("Url vers la resource")), 1),
                  Fe("span", vV, [
                    Fe("a", {
                      class: "text-secondary hover:underline",
                      target: "_blank",
                      href: be
                    }, Ht(be), 9, _V)
                  ])
                ]))), 128))
              ])) : Ye("v-if", !0),
              f.value.revisionDate ? (Be(), an(Yp, {
                key: 5,
                label: se(a)("Revision date"),
                value: se(X8)(f.value.revisionDate, se(s).language)
              }, null, 8, ["label", "value"])) : Ye("v-if", !0),
              f.value.keyword ? (Be(), an(Yp, {
                key: 6,
                label: se(a)("Keywords"),
                value: (re = f.value.keyword) == null ? void 0 : re.join(",")
              }, null, 8, ["label", "value"])) : Ye("v-if", !0),
              f.value.responsibleParty ? (Be(), rt("div", xV, [
                Fe("div", bV, Ht(se(a)("Contact")), 1),
                Fe("div", wV, [
                  (X = f.value.responsibleParty) != null && X.organisaton ? (Be(), rt("p", EV, Ht((ae = f.value.responsibleParty) == null ? void 0 : ae.organisaton), 1)) : Ye("v-if", !0),
                  (ce = f.value.responsibleParty) != null && ce.name ? (Be(), rt("p", SV, Ht((ve = f.value.responsibleParty) == null ? void 0 : ve.name), 1)) : Ye("v-if", !0),
                  (Ne = f.value.responsibleParty) != null && Ne.unknown ? (Be(), rt("p", TV, Ht((ze = f.value.responsibleParty) == null ? void 0 : ze.unknown), 1)) : Ye("v-if", !0),
                  (Ae = f.value.responsibleParty) != null && Ae.address ? (Be(), rt("p", MV, Ht((Se = f.value.responsibleParty) == null ? void 0 : Se.address), 1)) : Ye("v-if", !0),
                  (Ie = f.value.responsibleParty) != null && Ie.email ? (Be(), rt("p", IV, [
                    Fe("a", {
                      class: "text-secondary hover:underline",
                      href: "mailto:" + ((Xe = f.value.responsibleParty) == null ? void 0 : Xe.email)
                    }, Ht(($e = f.value.responsibleParty) == null ? void 0 : $e.email), 9, OV)
                  ])) : Ye("v-if", !0)
                ])
              ])) : Ye("v-if", !0),
              f.value.metadataLink ? (Be(), rt("div", CV, [
                Fe("span", PV, Ht(se(a)("Link to the metadata")), 1),
                Fe("span", AV, [
                  Fe("a", {
                    class: "text-secondary hover:underline",
                    target: "_blank",
                    href: f.value.metadataLink
                  }, Ht(se(a)("link")), 9, kV)
                ])
              ])) : Ye("v-if", !0),
              f.value.isError ? (Be(), rt("div", LV, Ht(se(a)("The metadata is right now not available")), 1)) : Ye("v-if", !0),
              f.value.legendHtml ? (Be(), rt("div", DV, [
                Fe("h4", NV, Ht(se(a)("Legend")), 1),
                Og(Fe("span", null, null, 512), [
                  [z, (at = f.value.legendHtml) == null ? void 0 : at.innerHTML]
                ])
              ])) : Ye("v-if", !0),
              f.value.hasLegend ? Ye("v-if", !0) : (Be(), rt("div", RV, Ht(se(a)("The legend is not available for this layer")), 1))
            ])
          ];
        }),
        _: 1
      }, 8, ["title"])) : Ye("v-if", !0);
    };
  }
}), FV = /* @__PURE__ */ lr(zV, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-metadata/layer-metadata.vue"]]), BV = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM0AAAAoCAMAAABq645qAAACPVBMVEUAAABaW13////tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy7tGy5aW13tGy5DjxTaAAAAvXRSTlMAAAABAgMEBQYHCAkKCwwNDg8QERESFBUWFxkaGx0eHyAhIiInKSosMTIzNTY5Ojs8PUFCQ0RERkpMTk9QU1RVVldaXmFjZWZmamtwcXJzdXd3eHl7fX+AgYKDhIaHiIiKi4yOj5CTlJWWl5iZmZqcnZ+goaKjpKanqKqqq6ywsbK0tbW4u7u8vb6/wMHExcbHysvMzM7P0NDS1NXa29zd3t/g4eTl5ujp6uvs7e7u8PLz9PX29/j5+vv8/f5cALqzAAAEcklEQVRo3u3Z+ZPUVBAH8O63LsLKijoIgotHFI+HgiKNeGC8MCqgUUFAJYjgAQ6HKMgGEQQiqChIPFh1iciiwPIEhvv49t/mD5lBORa2tHbLTO2rmqnUTCrJZ3r65ZuEjDHGGLrMWGcKMah7mh/7NP8PzXBqbqgfzdtPb7i/fjQPvq8r5jUVXNNIY4moYeL6+XNfn9Ov6LUZ2/Z7Pxo3YaZWTp/uLPw/reXYbqLRPz/38g+qJ/oTEV396IzmgmquXHZoIRHd/sTs31T1DqIBcyqHZjQWtTbf6nQiokHLVVWn7ju4euXGjsX9LtTAGgPAGGMzOPZSOGFYtmAXsO8skFkgZovQgi2QcZKyIGAAjJQtIgAB/5vRTc2IvbqSqOWNJQdUVdfe+/zitmsu2jeQ/GWMC43HacRhxhAWcJRyEgmYBSVYgROwgJkzeGVEDGEGotqnPaih1Xp63KSvVFVVtz0wt23AvMVda5AZY2FM7OWO/N2DwBMgESBiQZyABUgYSYQkYSBjhAh7QXN3Zfey7YdyzXh6aQpdu2fIpWsD30CykKOU4XPgmBPEnNcmC1jgIT9uCx9ZkOW1kQi9oBm6aMvO3KIVomUPES19/KIaoNo34uA8cUgtB4DzmQXCFoCFhbXgMtgC8DNGKMj7xnIKtj2toeGf55X5c9+ZRpo1lWjyq5c/33Avj+5obpz25miiwd+p6q4/2jfvIrqtrYlemF5MzZObTuhHCw6cUd2y/91ftj5DRJOn0JKniqm56jPtUNXDx44u6NywvaPzPqL+G5v3jCimhhqaX/vyi6VTxtzyYkVV9dSsRvrmnVXUI5oo7GkNEV2RH/igaRVV1Y8fOdE+tEc0tlzqBU1tND+7U1W18t51F8/QAFJrkUccL4VjABFb+MwoMyznszWzBZxfDT2SIbZgm0/TzBbIpLqcr8GwScJxfF4UiliAgGEZ1gKx8VK4bmuafmpdrqr6cFdXBJBSORPkp9A0ZI8hAi4jYQY8CEN8MDML2K/FBBdwKU80kOp3eSBirq7BkJJLstK5UShw+eYhDBGUYNPQeN3WTND2rd+r6oquNUZQ00A49gCEJQg8RhJD8j0DQX6IEBZYMLMAAANZrpHa8lkNBwjOi0Ion90KRIDIQEzsdVfzlurhT1X11F2XqE3qwfNQMiYLGYIYNgAQMcTltXHV3z9w1dAD/8LapH/XJt9eycWudG4U8lGrjYeSIAtMFlaD1SU1NxAR0cA9qrpqr6ruaOmybxLPREBojLEOzoMNkAXsO4YNYRnIpNo3WS30+EByXt+kttY3AEdAyGmZ4/TcKORCDgDhEAg5D0wO7vK1mbmwhajxA9XWkXTTh8dVj6wZX9gr6ZFL9eTm1nbVhUREdOs2Vb25sJqmRTuOq+r+rwfmgGEHVYcU+H7a8KNrdP6kYTXBJ6qPFVjT2DxwzD/msbWqE+vnrvqvevSeutGMUm0dXC+ahk3asb5unt+8cvLIqOvr52nU7Dv7nq31afo0/0mzrhiavwAx1n2SsZnMdgAAAABJRU5ErkJggg==";
class VV {
  bootstrap() {
    this.restore();
    let e;
    e = va(() => {
      this.persist(), e && e();
    });
  }
  persist() {
    const e = Ai(), { lang: n } = pn(e);
    An(
      n,
      (a, s) => {
        s !== a && (Cr.setValue(Nu, a), document.documentElement.setAttribute("lang", a));
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Cr.getValue(Nu);
    if (e) {
      const { setLang: n } = Ai(), { i18next: a } = En();
      a.changeLanguage(e), n(e);
    }
  }
}
const UV = new VV(), jV = /* @__PURE__ */ ir({
  __name: "language-selector",
  setup(t) {
    const { i18next: e, t: n } = En(), { setLang: a } = Ai(), { lang: s } = pn(Ai()), f = ar(
      () => ["en", "de", "fr", "lb"].map((g) => ({
        label: n(g),
        value: g,
        ariaLabel: n("Changer de langue : {{lang}}", { lang: g })
      }))
    ), o = n("Changer de langue");
    UV.bootstrap();
    function m(g) {
      e.changeLanguage(g), a(g);
    }
    return (g, b) => (Be(), rt("div", null, [
      kt(BT, {
        class: "lux-navbar-dropdown lux-dropdown-inline text-white h-full",
        options: se(f),
        placeholder: se(o),
        modelValue: se(s),
        "onUpdate:modelValue": b[0] || (b[0] = (T) => hn(s) ? s.value = T : null),
        onChange: m
      }, null, 8, ["options", "placeholder", "modelValue"])
    ]));
  }
}), GV = /* @__PURE__ */ lr(jV, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/nav-bars/language-selector.vue"]]);
class $V {
  setCurrentThemeColors(e) {
    const n = document.querySelector(":root");
    ["primary", "secondary", "tertiary"].forEach((s) => {
      const f = getComputedStyle(n).getPropertyValue(
        `--${e}-${s}`
      );
      n.style.setProperty(`--color-${s}`, f);
    });
  }
}
const qV = new $V(), WV = { class: "w-full h-14 flex bg-white shadow-header z-10 shrink-0" }, HV = /* @__PURE__ */ Fe("div", { class: "flex-2 p-[5px]" }, [
  /* @__PURE__ */ Fe("img", { src: BV })
], -1), ZV = /* @__PURE__ */ Fe("div", { class: "grow text-center" }, "search", -1), XV = { class: "h-full flex" }, KV = { class: "hidden lg:inline-block" }, YV = { class: "border-l-[1px] border-stone-300 h-full" }, JV = /* @__PURE__ */ ir({
  __name: "header-bar",
  setup(t) {
    const { t: e } = En(), n = Ai(), { layersOpen: a, myLayersTabOpen: s, themeGridOpen: f } = pn(n), { setLayersOpen: o, setMyLayersTabOpen: m, setThemeGridOpen: g } = n, b = Ro(), { theme: T } = pn(b);
    An(
      T,
      (I) => {
        I && qV.setCurrentThemeColors(I.name);
      },
      { immediate: !0 }
    );
    function M() {
      a.value ? a.value && (f.value ? o(!1) : (s.value && m(!1), g(!0))) : (o(!0), s.value && m(!1), g(!0));
    }
    return (I, A) => {
      var z, V;
      return Be(), rt("header", WV, [
        HV,
        ZV,
        Fe("div", null, [
          Fe("ul", XV, [
            Fe("li", null, [
              Fe("button", {
                class: Br(["flex items-center before:font-icons before:text-3xl before:w-16 text-primary uppercase h-full mr-3", `before:content-${(z = se(T)) == null ? void 0 : z.name}`]),
                onClick: M
              }, [
                Fe("span", KV, Ht(se(e)(`${(V = se(T)) == null ? void 0 : V.name}`)), 1)
              ], 2)
            ]),
            Fe("li", YV, [
              kt(GV, { class: "flex-none h-full" })
            ])
          ])
        ])
      ]);
    };
  }
}), QV = /* @__PURE__ */ lr(JV, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/header/header-bar.vue"]]), eU = { class: "block text-[13px] sm:text-base uppercase" }, tU = /* @__PURE__ */ ir({
  __name: "button-icon",
  props: {
    label: { type: String, required: !0 },
    icon: { type: String, required: !0 },
    active: { type: Boolean, required: !1 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Be(), rt("button", {
      class: Br(["h-[42px] w-full sm:h-full sm:w-16 hover:text-white hover:bg-primary", e.active ? "bg-primary text-white" : ""])
    }, [
      Fe("span", {
        class: Br(["block text-[1.7rem] sm:text-[2rem] -mt-1.5 -mb-3 after:font-icons", e.active ? "lux-close-cross" : `after:content-${e.icon}`])
      }, null, 2),
      Fe("span", eU, Ht(e.label), 1)
    ], 2));
  }
}), Dl = /* @__PURE__ */ lr(tU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/footer/button-icon.vue"]]), rU = ["href"], nU = /* @__PURE__ */ ir({
  __name: "button-link",
  props: {
    label: { type: String, required: !0 },
    link: { type: String, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Be(), rt("a", {
      class: "h-full flex flex-col justify-center px-[7px] uppercase hover:text-white hover:bg-primary",
      href: `${e.link}`,
      target: "_blank"
    }, Ht(n.$props.label), 9, rU));
  }
}), xu = /* @__PURE__ */ lr(nU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/footer/button-link.vue"]]), iU = { class: "flex flex-col w-12 justify-between bg-white z-5 shrink-0 sm:flex-row sm:w-full sm:h-14 sm:shadow-footer" }, oU = { class: "flex flex-col w-full sm:w-80 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" }, aU = { class: "flex flex-col w-12 sm:w-64 sm:flex-row justify-start text-primary divide-y sm:divide-y-0 sm:divide-x divide-gray-400 divide-solid box-content border-y sm:border-y-0 border-x border-gray-400" }, sU = { class: "w-[466px] hidden sm:flex flex-row justify-end text-gray-500 whitespace-nowrap" }, lU = /* @__PURE__ */ ir({
  __name: "footer-bar",
  setup(t) {
    const { t: e, i18next: n } = En(), { setLayersOpen: a } = Ai(), { layersOpen: s } = pn(Ai());
    return (f, o) => (Be(), rt("footer", iU, [
      Ye(" left buttons "),
      Fe("ul", oU, [
        Fe("li", null, [
          kt(Dl, {
            label: se(e)("Layers", { ns: "client" }),
            icon: "layers",
            active: se(s),
            onClick: o[0] || (o[0] = () => se(a)(!se(s)))
          }, null, 8, ["label", "active"])
        ]),
        Ye(`TODOs in each button when implemented
        - remove class="text-gray-300"
        - add click handler that calls setLayersOpen(true) and opens tool (also via app store)
      `),
        Fe("li", null, [
          kt(Dl, {
            class: "text-gray-300",
            label: se(e)("My Maps", { ns: "client" }),
            icon: "mymaps"
          }, null, 8, ["label"])
        ]),
        Fe("li", null, [
          kt(Dl, {
            class: "text-gray-300",
            label: se(e)("Infos", { ns: "client" }),
            icon: "infos"
          }, null, 8, ["label"])
        ]),
        Fe("li", null, [
          kt(Dl, {
            class: "text-gray-300",
            label: se(e)("Legends", { ns: "client" }),
            icon: "legends"
          }, null, 8, ["label"])
        ]),
        Fe("li", null, [
          kt(Dl, {
            class: "text-gray-300",
            label: se(e)("Routing", { ns: "client" }),
            icon: "routing"
          }, null, 8, ["label"])
        ])
      ]),
      Ye(" center buttons "),
      Fe("div", aU, [
        kt(Dl, {
          class: "text-gray-300",
          label: se(e)("Dessin", { ns: "client" }),
          icon: "draw"
        }, null, 8, ["label"]),
        kt(Dl, {
          class: "text-gray-300 hidden sm:block",
          label: se(e)("Mesurer", { ns: "client" }),
          icon: "measure"
        }, null, 8, ["label"]),
        kt(Dl, {
          class: "text-gray-300 hidden sm:block",
          label: se(e)("Imprimer", { ns: "client" }),
          icon: "print"
        }, null, 8, ["label"]),
        kt(Dl, {
          class: "text-gray-300",
          label: se(e)("Partager", { ns: "client" }),
          icon: "share"
        }, null, 8, ["label"])
      ]),
      Ye(" right buttons "),
      Fe("div", sU, [
        kt(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("What's new", { ns: "client" }),
          link: `https://geoportail.lu/${se(n).language}/questions/whats-new/`
        }, null, 8, ["label", "link"]),
        Ye("TODO get geonetworkBaseUrl from config"),
        kt(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("Geocatalogue", { ns: "client" }),
          link: ""
        }, null, 8, ["label"]),
        Ye("TODO handle feedback links (for different portals?)"),
        kt(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("Feedback", { ns: "client" }),
          link: ""
        }, null, 8, ["label"]),
        kt(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("A Propos", { ns: "client" }),
          link: `https://www.geoportail.lu/${se(n).language}/propos/`
        }, null, 8, ["label", "link"]),
        kt(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("Aide", { ns: "client" }),
          link: `https://www.geoportail.lu/${se(n).language}/documentation/`
        }, null, 8, ["label", "link"]),
        kt(xu, {
          class: "hidden lg:flex text-gray-500",
          label: se(e)("Contact", { ns: "client" }),
          link: `https://www.geoportail.lu/${se(n).language}/propos/contactez-nous/`
        }, null, 8, ["label", "link"]),
        kt(xu, {
          class: "text-gray-500",
          label: se(e)("Legalites", { ns: "client" }),
          link: `https://www.geoportail.lu/${se(n).language}/propos/mentions-legales/`
        }, null, 8, ["label", "link"]),
        kt(xu, {
          class: "text-gray-500",
          label: se(e)("ACT", { ns: "client" }),
          link: "http://www.act.public.lu/"
        }, null, 8, ["label", "link"])
      ])
    ]));
  }
}), uU = /* @__PURE__ */ lr(lU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/footer/footer-bar.vue"]]), cU = { class: "flex flex-row flex-wrap pl-2.5" }, hU = ["onClick"], fU = { class: "text-2xl absolute top-5" }, pU = /* @__PURE__ */ ir({
  __name: "theme-grid",
  props: {
    themes: { type: Array, required: !0 }
  },
  setup(t) {
    const e = t, { t: n } = En();
    return (a, s) => (Be(), rt("div", cU, [
      (Be(!0), rt(on, null, Ra(e.themes, (f) => (Be(), rt("button", {
        class: Br(["relative shrink-0 h-[150px] w-1/2 px-2.5 text-start text-gray-100/40 uppercase hover:bg-[#ccc]", `bg-${f.name}-primary hover:text-${f.name}-primary`]),
        key: f.id,
        onClick: (o) => a.$emit("setTheme", f.name)
      }, [
        Fe("div", fU, Ht(se(n)(`${f.name}`)), 1),
        Fe("div", {
          class: Br(["text-6xl absolute bottom-1 after:font-icons", `after:content-${f.name}`])
        }, null, 2)
      ], 10, hU))), 128))
    ]));
  }
}), dU = /* @__PURE__ */ lr(pU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/theme-selector/theme-grid.vue"]]), mU = ["aria-expanded"], yU = { class: "py-0.5" }, gU = { class: "px-1 py-0.5 shrink-0 flex flex-row text-[12px] bg-secondary text-white" }, vU = { class: "py-[3px]" }, _U = { class: "flex flex-row flex-wrap ml-1 w-12" }, xU = /* @__PURE__ */ ir({
  __name: "theme-selector-button",
  props: {
    themes: { type: Array, required: !0 },
    currentTheme: { type: null, required: !1 },
    isOpen: { type: Boolean, required: !1 }
  },
  setup(t) {
    const e = t, { t: n } = En(), a = ar(() => {
      var s;
      return ((s = e.themes) == null ? void 0 : s.slice(0, 8)) || [];
    });
    return (s, f) => {
      var o;
      return Be(), rt("button", {
        class: "w-full flex flex-row justify-between bg-tertiary text-white px-2 py-1.5 uppercase cursor-pointer hover:bg-white hover:text-primary",
        "aria-expanded": e.isOpen
      }, [
        Fe("span", yU, Ht(se(n)("Theme")) + ": " + Ht(se(n)(`${(o = e.currentTheme) == null ? void 0 : o.name}`)), 1),
        Fe("span", gU, [
          Fe("span", vU, Ht(se(n)("Changer")), 1),
          Fe("span", _U, [
            (Be(!0), rt(on, null, Ra(se(a), (m) => (Be(), rt("div", {
              class: Br(`h-2.5 w-2.5 m-px bg-${m.name}-primary`),
              key: m.id
            }, null, 2))), 128))
          ])
        ])
      ], 8, mU);
    };
  }
}), bU = /* @__PURE__ */ lr(xU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/theme-selector/theme-selector-button.vue"]]), wU = {
  key: 0,
  class: "absolute inset-x-0 top-14 bottom-0 mt-1 bg-primary overflow-y-auto overflow-x-hidden"
}, EU = /* @__PURE__ */ ir({
  __name: "theme-selector",
  setup(t) {
    const e = Ai(), { setThemeGridOpen: n } = e, { themeGridOpen: a } = pn(e), s = Ro(), f = Kc(), { theme: o, themes: m } = pn(s), g = ar(
      () => {
        var M;
        return ((M = m.value) == null ? void 0 : M.filter(
          (I) => {
            var A;
            return ((A = I.metadata) == null ? void 0 : A.display_in_switcher) === !0;
          }
        )) || [];
      }
    );
    function b() {
      n(!a.value);
    }
    function T(M) {
      f.setTheme(M), b();
    }
    return (M, I) => (Be(), rt(on, null, [
      kt(bU, {
        onClick: b,
        themes: se(g),
        currentTheme: se(o),
        isOpen: se(a)
      }, null, 8, ["themes", "currentTheme", "isOpen"]),
      se(a) ? (Be(), rt("div", wU, [
        kt(dU, {
          onSetTheme: T,
          themes: se(g)
        }, null, 8, ["themes"])
      ])) : Ye("v-if", !0)
    ], 64));
  }
}), SU = /* @__PURE__ */ lr(EU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/theme-selector/theme-selector.vue"]]);
function px(t, e = 0) {
  const { name: n, id: a, children: s, metadata: f } = t;
  return {
    name: n,
    id: a,
    depth: e,
    children: s == null ? void 0 : s.map((o) => px(o, e + 1)),
    checked: !1,
    expanded: (f == null ? void 0 : f.is_expanded) || !1
  };
}
const TU = {
  key: 0,
  class: "mb-7"
}, MU = /* @__PURE__ */ ir({
  __name: "catalog-tree",
  setup(t) {
    const e = Ei(), n = Ro(), a = cs(), s = Bn(), f = Bn(), o = ar(
      () => !e.is3dActive || e.is3dActive && !e.is3dMesh
    ), { layerTrees_3d: m } = pn(n);
    va(g);
    function g() {
      var M;
      if (n.theme && e.layers) {
        const I = s.value && s.value.id === ((M = n.theme) == null ? void 0 : M.id) ? s.value : px(n.theme);
        s.value = Af.updateLayers(
          I,
          e.layers
        );
      }
    }
    va(() => {
      if (m.value) {
        const M = f.value ? f.value : px(m.value);
        f.value = Af.updateLayers(
          M,
          e.layers3d
        );
      }
    });
    function b(M, I) {
      const A = I ? f : s;
      A.value = Af.toggleNode(
        M.id,
        A.value,
        "expanded"
      );
    }
    function T(M, I) {
      a.toggleLayer(+M.id, !M.checked, I);
    }
    return (M, I) => (Be(), rt("div", null, [
      Ye(" 3D layers catalog, only displayed when 3D is active "),
      se(f) && se(e).is3dActive ? (Be(), rt("div", TU, [
        (Be(), an(hx, {
          node: se(f),
          key: se(f).id,
          onToggleParent: I[0] || (I[0] = (A) => b(A, !0)),
          onToggleLayer: I[1] || (I[1] = (A) => T(A, !0))
        }, null, 8, ["node"]))
      ])) : Ye("v-if", !0),
      Ye(" Main catalog, displays by default and 3D terrain active "),
      se(s) && se(o) ? (Be(), an(hx, {
        node: se(s),
        key: se(s).id,
        onToggleParent: I[2] || (I[2] = (A) => b(A, !1)),
        onToggleLayer: I[3] || (I[3] = (A) => T(A, !1))
      }, null, 8, ["node"])) : Ye("v-if", !0)
    ]));
  }
}), IU = /* @__PURE__ */ lr(MU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/catalog/catalog-tree.vue"]]), OU = /* @__PURE__ */ ir({
  __name: "catalog-tab",
  setup(t) {
    const { themeGridOpen: e } = pn(Ai());
    return (n, a) => (Be(), rt(on, null, [
      kt(SU),
      se(e) === !1 ? (Be(), an(IU, {
        key: 0,
        class: "pt-5 absolute inset-x-2.5 bg-primary overflow-y-auto overflow-x-hidden"
      })) : Ye("v-if", !0)
    ], 64));
  }
}), CU = /* @__PURE__ */ lr(OU, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/catalog/catalog-tab.vue"]]);
/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function fE(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, a);
  }
  return n;
}
function rl(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? fE(Object(n), !0).forEach(function(a) {
      PU(t, a, n[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : fE(Object(n)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(n, a));
    });
  }
  return t;
}
function dg(t) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? dg = function(e) {
    return typeof e;
  } : dg = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, dg(t);
}
function PU(t, e, n) {
  return e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Wl() {
  return Wl = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, Wl.apply(this, arguments);
}
function AU(t, e) {
  if (t == null)
    return {};
  var n = {}, a = Object.keys(t), s, f;
  for (f = 0; f < a.length; f++)
    s = a[f], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
function kU(t, e) {
  if (t == null)
    return {};
  var n = AU(t, e), a, s;
  if (Object.getOwnPropertySymbols) {
    var f = Object.getOwnPropertySymbols(t);
    for (s = 0; s < f.length; s++)
      a = f[s], !(e.indexOf(a) >= 0) && (!Object.prototype.propertyIsEnumerable.call(t, a) || (n[a] = t[a]));
  }
  return n;
}
var LU = "1.15.0";
function Ul(t) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(t);
}
var Xl = Ul(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), om = Ul(/Edge/i), pE = Ul(/firefox/i), xd = Ul(/safari/i) && !Ul(/chrome/i) && !Ul(/android/i), bI = Ul(/iP(ad|od|hone)/i), wI = Ul(/chrome/i) && Ul(/android/i), EI = {
  capture: !1,
  passive: !1
};
function nn(t, e, n) {
  t.addEventListener(e, n, !Xl && EI);
}
function Kr(t, e, n) {
  t.removeEventListener(e, n, !Xl && EI);
}
function tv(t, e) {
  if (!!e) {
    if (e[0] === ">" && (e = e.substring(1)), t)
      try {
        if (t.matches)
          return t.matches(e);
        if (t.msMatchesSelector)
          return t.msMatchesSelector(e);
        if (t.webkitMatchesSelector)
          return t.webkitMatchesSelector(e);
      } catch {
        return !1;
      }
    return !1;
  }
}
function DU(t) {
  return t.host && t !== document && t.host.nodeType ? t.host : t.parentNode;
}
function Bs(t, e, n, a) {
  if (t) {
    n = n || document;
    do {
      if (e != null && (e[0] === ">" ? t.parentNode === n && tv(t, e) : tv(t, e)) || a && t === n)
        return t;
      if (t === n)
        break;
    } while (t = DU(t));
  }
  return null;
}
var dE = /\s+/g;
function ha(t, e, n) {
  if (t && e)
    if (t.classList)
      t.classList[n ? "add" : "remove"](e);
    else {
      var a = (" " + t.className + " ").replace(dE, " ").replace(" " + e + " ", " ");
      t.className = (a + (n ? " " + e : "")).replace(dE, " ");
    }
}
function cr(t, e, n) {
  var a = t && t.style;
  if (a) {
    if (n === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(t, "") : t.currentStyle && (n = t.currentStyle), e === void 0 ? n : n[e];
    !(e in a) && e.indexOf("webkit") === -1 && (e = "-webkit-" + e), a[e] = n + (typeof n == "string" ? "" : "px");
  }
}
function kf(t, e) {
  var n = "";
  if (typeof t == "string")
    n = t;
  else
    do {
      var a = cr(t, "transform");
      a && a !== "none" && (n = a + " " + n);
    } while (!e && (t = t.parentNode));
  var s = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return s && new s(n);
}
function SI(t, e, n) {
  if (t) {
    var a = t.getElementsByTagName(e), s = 0, f = a.length;
    if (n)
      for (; s < f; s++)
        n(a[s], s);
    return a;
  }
  return [];
}
function Js() {
  var t = document.scrollingElement;
  return t || document.documentElement;
}
function Ri(t, e, n, a, s) {
  if (!(!t.getBoundingClientRect && t !== window)) {
    var f, o, m, g, b, T, M;
    if (t !== window && t.parentNode && t !== Js() ? (f = t.getBoundingClientRect(), o = f.top, m = f.left, g = f.bottom, b = f.right, T = f.height, M = f.width) : (o = 0, m = 0, g = window.innerHeight, b = window.innerWidth, T = window.innerHeight, M = window.innerWidth), (e || n) && t !== window && (s = s || t.parentNode, !Xl))
      do
        if (s && s.getBoundingClientRect && (cr(s, "transform") !== "none" || n && cr(s, "position") !== "static")) {
          var I = s.getBoundingClientRect();
          o -= I.top + parseInt(cr(s, "border-top-width")), m -= I.left + parseInt(cr(s, "border-left-width")), g = o + f.height, b = m + f.width;
          break;
        }
      while (s = s.parentNode);
    if (a && t !== window) {
      var A = kf(s || t), z = A && A.a, V = A && A.d;
      A && (o /= V, m /= z, M /= z, T /= V, g = o + T, b = m + M);
    }
    return {
      top: o,
      left: m,
      bottom: g,
      right: b,
      width: M,
      height: T
    };
  }
}
function mE(t, e, n) {
  for (var a = Cu(t, !0), s = Ri(t)[e]; a; ) {
    var f = Ri(a)[n], o = void 0;
    if (n === "top" || n === "left" ? o = s >= f : o = s <= f, !o)
      return a;
    if (a === Js())
      break;
    a = Cu(a, !1);
  }
  return !1;
}
function Bf(t, e, n, a) {
  for (var s = 0, f = 0, o = t.children; f < o.length; ) {
    if (o[f].style.display !== "none" && o[f] !== ur.ghost && (a || o[f] !== ur.dragged) && Bs(o[f], n.draggable, t, !1)) {
      if (s === e)
        return o[f];
      s++;
    }
    f++;
  }
  return null;
}
function c1(t, e) {
  for (var n = t.lastElementChild; n && (n === ur.ghost || cr(n, "display") === "none" || e && !tv(n, e)); )
    n = n.previousElementSibling;
  return n || null;
}
function Aa(t, e) {
  var n = 0;
  if (!t || !t.parentNode)
    return -1;
  for (; t = t.previousElementSibling; )
    t.nodeName.toUpperCase() !== "TEMPLATE" && t !== ur.clone && (!e || tv(t, e)) && n++;
  return n;
}
function yE(t) {
  var e = 0, n = 0, a = Js();
  if (t)
    do {
      var s = kf(t), f = s.a, o = s.d;
      e += t.scrollLeft * f, n += t.scrollTop * o;
    } while (t !== a && (t = t.parentNode));
  return [e, n];
}
function NU(t, e) {
  for (var n in t)
    if (!!t.hasOwnProperty(n)) {
      for (var a in e)
        if (e.hasOwnProperty(a) && e[a] === t[n][a])
          return Number(n);
    }
  return -1;
}
function Cu(t, e) {
  if (!t || !t.getBoundingClientRect)
    return Js();
  var n = t, a = !1;
  do
    if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) {
      var s = cr(n);
      if (n.clientWidth < n.scrollWidth && (s.overflowX == "auto" || s.overflowX == "scroll") || n.clientHeight < n.scrollHeight && (s.overflowY == "auto" || s.overflowY == "scroll")) {
        if (!n.getBoundingClientRect || n === document.body)
          return Js();
        if (a || e)
          return n;
        a = !0;
      }
    }
  while (n = n.parentNode);
  return Js();
}
function RU(t, e) {
  if (t && e)
    for (var n in e)
      e.hasOwnProperty(n) && (t[n] = e[n]);
  return t;
}
function p0(t, e) {
  return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width);
}
var bd;
function TI(t, e) {
  return function() {
    if (!bd) {
      var n = arguments, a = this;
      n.length === 1 ? t.call(a, n[0]) : t.apply(a, n), bd = setTimeout(function() {
        bd = void 0;
      }, e);
    }
  };
}
function zU() {
  clearTimeout(bd), bd = void 0;
}
function MI(t, e, n) {
  t.scrollLeft += e, t.scrollTop += n;
}
function II(t) {
  var e = window.Polymer, n = window.jQuery || window.Zepto;
  return e && e.dom ? e.dom(t).cloneNode(!0) : n ? n(t).clone(!0)[0] : t.cloneNode(!0);
}
var ma = "Sortable" + new Date().getTime();
function FU() {
  var t = [], e;
  return {
    captureAnimationState: function() {
      if (t = [], !!this.options.animation) {
        var a = [].slice.call(this.el.children);
        a.forEach(function(s) {
          if (!(cr(s, "display") === "none" || s === ur.ghost)) {
            t.push({
              target: s,
              rect: Ri(s)
            });
            var f = rl({}, t[t.length - 1].rect);
            if (s.thisAnimationDuration) {
              var o = kf(s, !0);
              o && (f.top -= o.f, f.left -= o.e);
            }
            s.fromRect = f;
          }
        });
      }
    },
    addAnimationState: function(a) {
      t.push(a);
    },
    removeAnimationState: function(a) {
      t.splice(NU(t, {
        target: a
      }), 1);
    },
    animateAll: function(a) {
      var s = this;
      if (!this.options.animation) {
        clearTimeout(e), typeof a == "function" && a();
        return;
      }
      var f = !1, o = 0;
      t.forEach(function(m) {
        var g = 0, b = m.target, T = b.fromRect, M = Ri(b), I = b.prevFromRect, A = b.prevToRect, z = m.rect, V = kf(b, !0);
        V && (M.top -= V.f, M.left -= V.e), b.toRect = M, b.thisAnimationDuration && p0(I, M) && !p0(T, M) && (z.top - M.top) / (z.left - M.left) === (T.top - M.top) / (T.left - M.left) && (g = VU(z, I, A, s.options)), p0(M, T) || (b.prevFromRect = T, b.prevToRect = M, g || (g = s.options.animation), s.animate(b, z, M, g)), g && (f = !0, o = Math.max(o, g), clearTimeout(b.animationResetTimer), b.animationResetTimer = setTimeout(function() {
          b.animationTime = 0, b.prevFromRect = null, b.fromRect = null, b.prevToRect = null, b.thisAnimationDuration = null;
        }, g), b.thisAnimationDuration = g);
      }), clearTimeout(e), f ? e = setTimeout(function() {
        typeof a == "function" && a();
      }, o) : typeof a == "function" && a(), t = [];
    },
    animate: function(a, s, f, o) {
      if (o) {
        cr(a, "transition", ""), cr(a, "transform", "");
        var m = kf(this.el), g = m && m.a, b = m && m.d, T = (s.left - f.left) / (g || 1), M = (s.top - f.top) / (b || 1);
        a.animatingX = !!T, a.animatingY = !!M, cr(a, "transform", "translate3d(" + T + "px," + M + "px,0)"), this.forRepaintDummy = BU(a), cr(a, "transition", "transform " + o + "ms" + (this.options.easing ? " " + this.options.easing : "")), cr(a, "transform", "translate3d(0,0,0)"), typeof a.animated == "number" && clearTimeout(a.animated), a.animated = setTimeout(function() {
          cr(a, "transition", ""), cr(a, "transform", ""), a.animated = !1, a.animatingX = !1, a.animatingY = !1;
        }, o);
      }
    }
  };
}
function BU(t) {
  return t.offsetWidth;
}
function VU(t, e, n, a) {
  return Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) / Math.sqrt(Math.pow(e.top - n.top, 2) + Math.pow(e.left - n.left, 2)) * a.animation;
}
var uf = [], d0 = {
  initializeByDefault: !0
}, am = {
  mount: function(e) {
    for (var n in d0)
      d0.hasOwnProperty(n) && !(n in e) && (e[n] = d0[n]);
    uf.forEach(function(a) {
      if (a.pluginName === e.pluginName)
        throw "Sortable: Cannot mount plugin ".concat(e.pluginName, " more than once");
    }), uf.push(e);
  },
  pluginEvent: function(e, n, a) {
    var s = this;
    this.eventCanceled = !1, a.cancel = function() {
      s.eventCanceled = !0;
    };
    var f = e + "Global";
    uf.forEach(function(o) {
      !n[o.pluginName] || (n[o.pluginName][f] && n[o.pluginName][f](rl({
        sortable: n
      }, a)), n.options[o.pluginName] && n[o.pluginName][e] && n[o.pluginName][e](rl({
        sortable: n
      }, a)));
    });
  },
  initializePlugins: function(e, n, a, s) {
    uf.forEach(function(m) {
      var g = m.pluginName;
      if (!(!e.options[g] && !m.initializeByDefault)) {
        var b = new m(e, n, e.options);
        b.sortable = e, b.options = e.options, e[g] = b, Wl(a, b.defaults);
      }
    });
    for (var f in e.options)
      if (!!e.options.hasOwnProperty(f)) {
        var o = this.modifyOption(e, f, e.options[f]);
        typeof o < "u" && (e.options[f] = o);
      }
  },
  getEventProperties: function(e, n) {
    var a = {};
    return uf.forEach(function(s) {
      typeof s.eventProperties == "function" && Wl(a, s.eventProperties.call(n[s.pluginName], e));
    }), a;
  },
  modifyOption: function(e, n, a) {
    var s;
    return uf.forEach(function(f) {
      !e[f.pluginName] || f.optionListeners && typeof f.optionListeners[n] == "function" && (s = f.optionListeners[n].call(e[f.pluginName], a));
    }), s;
  }
};
function UU(t) {
  var e = t.sortable, n = t.rootEl, a = t.name, s = t.targetEl, f = t.cloneEl, o = t.toEl, m = t.fromEl, g = t.oldIndex, b = t.newIndex, T = t.oldDraggableIndex, M = t.newDraggableIndex, I = t.originalEvent, A = t.putSortable, z = t.extraEventProperties;
  if (e = e || n && n[ma], !!e) {
    var V, q = e.options, re = "on" + a.charAt(0).toUpperCase() + a.substr(1);
    window.CustomEvent && !Xl && !om ? V = new CustomEvent(a, {
      bubbles: !0,
      cancelable: !0
    }) : (V = document.createEvent("Event"), V.initEvent(a, !0, !0)), V.to = o || n, V.from = m || n, V.item = s || n, V.clone = f, V.oldIndex = g, V.newIndex = b, V.oldDraggableIndex = T, V.newDraggableIndex = M, V.originalEvent = I, V.pullMode = A ? A.lastPutMode : void 0;
    var X = rl(rl({}, z), am.getEventProperties(a, e));
    for (var ae in X)
      V[ae] = X[ae];
    n && n.dispatchEvent(V), q[re] && q[re].call(e, V);
  }
}
var jU = ["evt"], Jo = function(e, n) {
  var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = a.evt, f = kU(a, jU);
  am.pluginEvent.bind(ur)(e, n, rl({
    dragEl: St,
    parentEl: fi,
    ghostEl: Mr,
    rootEl: qn,
    nextEl: Bc,
    lastDownEl: mg,
    cloneEl: ni,
    cloneHidden: Ou,
    dragStarted: sd,
    putSortable: no,
    activeSortable: ur.active,
    originalEvent: s,
    oldIndex: bf,
    oldDraggableIndex: wd,
    newIndex: fa,
    newDraggableIndex: Su,
    hideGhostForTarget: AI,
    unhideGhostForTarget: kI,
    cloneNowHidden: function() {
      Ou = !0;
    },
    cloneNowShown: function() {
      Ou = !1;
    },
    dispatchSortableEvent: function(m) {
      Lo({
        sortable: n,
        name: m,
        originalEvent: s
      });
    }
  }, f));
};
function Lo(t) {
  UU(rl({
    putSortable: no,
    cloneEl: ni,
    targetEl: St,
    rootEl: qn,
    oldIndex: bf,
    oldDraggableIndex: wd,
    newIndex: fa,
    newDraggableIndex: Su
  }, t));
}
var St, fi, Mr, qn, Bc, mg, ni, Ou, bf, fa, wd, Su, $y, no, pf = !1, rv = !1, nv = [], Lc, Ja, m0, y0, gE, vE, sd, cf, Ed, Sd = !1, qy = !1, yg, go, g0 = [], dx = !1, iv = [], Fv = typeof document < "u", Wy = bI, _E = om || Xl ? "cssFloat" : "float", GU = Fv && !wI && !bI && "draggable" in document.createElement("div"), OI = function() {
  if (!!Fv) {
    if (Xl)
      return !1;
    var t = document.createElement("x");
    return t.style.cssText = "pointer-events:auto", t.style.pointerEvents === "auto";
  }
}(), CI = function(e, n) {
  var a = cr(e), s = parseInt(a.width) - parseInt(a.paddingLeft) - parseInt(a.paddingRight) - parseInt(a.borderLeftWidth) - parseInt(a.borderRightWidth), f = Bf(e, 0, n), o = Bf(e, 1, n), m = f && cr(f), g = o && cr(o), b = m && parseInt(m.marginLeft) + parseInt(m.marginRight) + Ri(f).width, T = g && parseInt(g.marginLeft) + parseInt(g.marginRight) + Ri(o).width;
  if (a.display === "flex")
    return a.flexDirection === "column" || a.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (a.display === "grid")
    return a.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (f && m.float && m.float !== "none") {
    var M = m.float === "left" ? "left" : "right";
    return o && (g.clear === "both" || g.clear === M) ? "vertical" : "horizontal";
  }
  return f && (m.display === "block" || m.display === "flex" || m.display === "table" || m.display === "grid" || b >= s && a[_E] === "none" || o && a[_E] === "none" && b + T > s) ? "vertical" : "horizontal";
}, $U = function(e, n, a) {
  var s = a ? e.left : e.top, f = a ? e.right : e.bottom, o = a ? e.width : e.height, m = a ? n.left : n.top, g = a ? n.right : n.bottom, b = a ? n.width : n.height;
  return s === m || f === g || s + o / 2 === m + b / 2;
}, qU = function(e, n) {
  var a;
  return nv.some(function(s) {
    var f = s[ma].options.emptyInsertThreshold;
    if (!(!f || c1(s))) {
      var o = Ri(s), m = e >= o.left - f && e <= o.right + f, g = n >= o.top - f && n <= o.bottom + f;
      if (m && g)
        return a = s;
    }
  }), a;
}, PI = function(e) {
  function n(f, o) {
    return function(m, g, b, T) {
      var M = m.options.group.name && g.options.group.name && m.options.group.name === g.options.group.name;
      if (f == null && (o || M))
        return !0;
      if (f == null || f === !1)
        return !1;
      if (o && f === "clone")
        return f;
      if (typeof f == "function")
        return n(f(m, g, b, T), o)(m, g, b, T);
      var I = (o ? m : g).options.group.name;
      return f === !0 || typeof f == "string" && f === I || f.join && f.indexOf(I) > -1;
    };
  }
  var a = {}, s = e.group;
  (!s || dg(s) != "object") && (s = {
    name: s
  }), a.name = s.name, a.checkPull = n(s.pull, !0), a.checkPut = n(s.put), a.revertClone = s.revertClone, e.group = a;
}, AI = function() {
  !OI && Mr && cr(Mr, "display", "none");
}, kI = function() {
  !OI && Mr && cr(Mr, "display", "");
};
Fv && !wI && document.addEventListener("click", function(t) {
  if (rv)
    return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), rv = !1, !1;
}, !0);
var Dc = function(e) {
  if (St) {
    e = e.touches ? e.touches[0] : e;
    var n = qU(e.clientX, e.clientY);
    if (n) {
      var a = {};
      for (var s in e)
        e.hasOwnProperty(s) && (a[s] = e[s]);
      a.target = a.rootEl = n, a.preventDefault = void 0, a.stopPropagation = void 0, n[ma]._onDragOver(a);
    }
  }
}, WU = function(e) {
  St && St.parentNode[ma]._isOutsideThisEl(e.target);
};
function ur(t, e) {
  if (!(t && t.nodeType && t.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t));
  this.el = t, this.options = e = Wl({}, e), t[ma] = this;
  var n = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(t.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: !1,
    invertedSwapThreshold: null,
    removeCloneOnHide: !0,
    direction: function() {
      return CI(t, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(o, m) {
      o.setData("Text", m.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: ur.supportPointer !== !1 && "PointerEvent" in window && !xd,
    emptyInsertThreshold: 5
  };
  am.initializePlugins(this, t, n);
  for (var a in n)
    !(a in e) && (e[a] = n[a]);
  PI(e);
  for (var s in this)
    s.charAt(0) === "_" && typeof this[s] == "function" && (this[s] = this[s].bind(this));
  this.nativeDraggable = e.forceFallback ? !1 : GU, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? nn(t, "pointerdown", this._onTapStart) : (nn(t, "mousedown", this._onTapStart), nn(t, "touchstart", this._onTapStart)), this.nativeDraggable && (nn(t, "dragover", this), nn(t, "dragenter", this)), nv.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), Wl(this, FU());
}
ur.prototype = {
  constructor: ur,
  _isOutsideThisEl: function(e) {
    !this.el.contains(e) && e !== this.el && (cf = null);
  },
  _getDirection: function(e, n) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, e, n, St) : this.options.direction;
  },
  _onTapStart: function(e) {
    if (!!e.cancelable) {
      var n = this, a = this.el, s = this.options, f = s.preventOnFilter, o = e.type, m = e.touches && e.touches[0] || e.pointerType && e.pointerType === "touch" && e, g = (m || e).target, b = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || g, T = s.filter;
      if (ej(a), !St && !(/mousedown|pointerdown/.test(o) && e.button !== 0 || s.disabled) && !b.isContentEditable && !(!this.nativeDraggable && xd && g && g.tagName.toUpperCase() === "SELECT") && (g = Bs(g, s.draggable, a, !1), !(g && g.animated) && mg !== g)) {
        if (bf = Aa(g), wd = Aa(g, s.draggable), typeof T == "function") {
          if (T.call(this, e, g, this)) {
            Lo({
              sortable: n,
              rootEl: b,
              name: "filter",
              targetEl: g,
              toEl: a,
              fromEl: a
            }), Jo("filter", n, {
              evt: e
            }), f && e.cancelable && e.preventDefault();
            return;
          }
        } else if (T && (T = T.split(",").some(function(M) {
          if (M = Bs(b, M.trim(), a, !1), M)
            return Lo({
              sortable: n,
              rootEl: M,
              name: "filter",
              targetEl: g,
              fromEl: a,
              toEl: a
            }), Jo("filter", n, {
              evt: e
            }), !0;
        }), T)) {
          f && e.cancelable && e.preventDefault();
          return;
        }
        s.handle && !Bs(b, s.handle, a, !1) || this._prepareDragStart(e, m, g);
      }
    }
  },
  _prepareDragStart: function(e, n, a) {
    var s = this, f = s.el, o = s.options, m = f.ownerDocument, g;
    if (a && !St && a.parentNode === f) {
      var b = Ri(a);
      if (qn = f, St = a, fi = St.parentNode, Bc = St.nextSibling, mg = a, $y = o.group, ur.dragged = St, Lc = {
        target: St,
        clientX: (n || e).clientX,
        clientY: (n || e).clientY
      }, gE = Lc.clientX - b.left, vE = Lc.clientY - b.top, this._lastX = (n || e).clientX, this._lastY = (n || e).clientY, St.style["will-change"] = "all", g = function() {
        if (Jo("delayEnded", s, {
          evt: e
        }), ur.eventCanceled) {
          s._onDrop();
          return;
        }
        s._disableDelayedDragEvents(), !pE && s.nativeDraggable && (St.draggable = !0), s._triggerDragStart(e, n), Lo({
          sortable: s,
          name: "choose",
          originalEvent: e
        }), ha(St, o.chosenClass, !0);
      }, o.ignore.split(",").forEach(function(T) {
        SI(St, T.trim(), v0);
      }), nn(m, "dragover", Dc), nn(m, "mousemove", Dc), nn(m, "touchmove", Dc), nn(m, "mouseup", s._onDrop), nn(m, "touchend", s._onDrop), nn(m, "touchcancel", s._onDrop), pE && this.nativeDraggable && (this.options.touchStartThreshold = 4, St.draggable = !0), Jo("delayStart", this, {
        evt: e
      }), o.delay && (!o.delayOnTouchOnly || n) && (!this.nativeDraggable || !(om || Xl))) {
        if (ur.eventCanceled) {
          this._onDrop();
          return;
        }
        nn(m, "mouseup", s._disableDelayedDrag), nn(m, "touchend", s._disableDelayedDrag), nn(m, "touchcancel", s._disableDelayedDrag), nn(m, "mousemove", s._delayedDragTouchMoveHandler), nn(m, "touchmove", s._delayedDragTouchMoveHandler), o.supportPointer && nn(m, "pointermove", s._delayedDragTouchMoveHandler), s._dragStartTimer = setTimeout(g, o.delay);
      } else
        g();
    }
  },
  _delayedDragTouchMoveHandler: function(e) {
    var n = e.touches ? e.touches[0] : e;
    Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    St && v0(St), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var e = this.el.ownerDocument;
    Kr(e, "mouseup", this._disableDelayedDrag), Kr(e, "touchend", this._disableDelayedDrag), Kr(e, "touchcancel", this._disableDelayedDrag), Kr(e, "mousemove", this._delayedDragTouchMoveHandler), Kr(e, "touchmove", this._delayedDragTouchMoveHandler), Kr(e, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(e, n) {
    n = n || e.pointerType == "touch" && e, !this.nativeDraggable || n ? this.options.supportPointer ? nn(document, "pointermove", this._onTouchMove) : n ? nn(document, "touchmove", this._onTouchMove) : nn(document, "mousemove", this._onTouchMove) : (nn(St, "dragend", this), nn(qn, "dragstart", this._onDragStart));
    try {
      document.selection ? gg(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(e, n) {
    if (pf = !1, qn && St) {
      Jo("dragStarted", this, {
        evt: n
      }), this.nativeDraggable && nn(document, "dragover", WU);
      var a = this.options;
      !e && ha(St, a.dragClass, !1), ha(St, a.ghostClass, !0), ur.active = this, e && this._appendGhost(), Lo({
        sortable: this,
        name: "start",
        originalEvent: n
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (Ja) {
      this._lastX = Ja.clientX, this._lastY = Ja.clientY, AI();
      for (var e = document.elementFromPoint(Ja.clientX, Ja.clientY), n = e; e && e.shadowRoot && (e = e.shadowRoot.elementFromPoint(Ja.clientX, Ja.clientY), e !== n); )
        n = e;
      if (St.parentNode[ma]._isOutsideThisEl(e), n)
        do {
          if (n[ma]) {
            var a = void 0;
            if (a = n[ma]._onDragOver({
              clientX: Ja.clientX,
              clientY: Ja.clientY,
              target: e,
              rootEl: n
            }), a && !this.options.dragoverBubble)
              break;
          }
          e = n;
        } while (n = n.parentNode);
      kI();
    }
  },
  _onTouchMove: function(e) {
    if (Lc) {
      var n = this.options, a = n.fallbackTolerance, s = n.fallbackOffset, f = e.touches ? e.touches[0] : e, o = Mr && kf(Mr, !0), m = Mr && o && o.a, g = Mr && o && o.d, b = Wy && go && yE(go), T = (f.clientX - Lc.clientX + s.x) / (m || 1) + (b ? b[0] - g0[0] : 0) / (m || 1), M = (f.clientY - Lc.clientY + s.y) / (g || 1) + (b ? b[1] - g0[1] : 0) / (g || 1);
      if (!ur.active && !pf) {
        if (a && Math.max(Math.abs(f.clientX - this._lastX), Math.abs(f.clientY - this._lastY)) < a)
          return;
        this._onDragStart(e, !0);
      }
      if (Mr) {
        o ? (o.e += T - (m0 || 0), o.f += M - (y0 || 0)) : o = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: T,
          f: M
        };
        var I = "matrix(".concat(o.a, ",").concat(o.b, ",").concat(o.c, ",").concat(o.d, ",").concat(o.e, ",").concat(o.f, ")");
        cr(Mr, "webkitTransform", I), cr(Mr, "mozTransform", I), cr(Mr, "msTransform", I), cr(Mr, "transform", I), m0 = T, y0 = M, Ja = f;
      }
      e.cancelable && e.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!Mr) {
      var e = this.options.fallbackOnBody ? document.body : qn, n = Ri(St, !0, Wy, !0, e), a = this.options;
      if (Wy) {
        for (go = e; cr(go, "position") === "static" && cr(go, "transform") === "none" && go !== document; )
          go = go.parentNode;
        go !== document.body && go !== document.documentElement ? (go === document && (go = Js()), n.top += go.scrollTop, n.left += go.scrollLeft) : go = Js(), g0 = yE(go);
      }
      Mr = St.cloneNode(!0), ha(Mr, a.ghostClass, !1), ha(Mr, a.fallbackClass, !0), ha(Mr, a.dragClass, !0), cr(Mr, "transition", ""), cr(Mr, "transform", ""), cr(Mr, "box-sizing", "border-box"), cr(Mr, "margin", 0), cr(Mr, "top", n.top), cr(Mr, "left", n.left), cr(Mr, "width", n.width), cr(Mr, "height", n.height), cr(Mr, "opacity", "0.8"), cr(Mr, "position", Wy ? "absolute" : "fixed"), cr(Mr, "zIndex", "100000"), cr(Mr, "pointerEvents", "none"), ur.ghost = Mr, e.appendChild(Mr), cr(Mr, "transform-origin", gE / parseInt(Mr.style.width) * 100 + "% " + vE / parseInt(Mr.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(e, n) {
    var a = this, s = e.dataTransfer, f = a.options;
    if (Jo("dragStart", this, {
      evt: e
    }), ur.eventCanceled) {
      this._onDrop();
      return;
    }
    Jo("setupClone", this), ur.eventCanceled || (ni = II(St), ni.removeAttribute("id"), ni.draggable = !1, ni.style["will-change"] = "", this._hideClone(), ha(ni, this.options.chosenClass, !1), ur.clone = ni), a.cloneId = gg(function() {
      Jo("clone", a), !ur.eventCanceled && (a.options.removeCloneOnHide || qn.insertBefore(ni, St), a._hideClone(), Lo({
        sortable: a,
        name: "clone"
      }));
    }), !n && ha(St, f.dragClass, !0), n ? (rv = !0, a._loopId = setInterval(a._emulateDragOver, 50)) : (Kr(document, "mouseup", a._onDrop), Kr(document, "touchend", a._onDrop), Kr(document, "touchcancel", a._onDrop), s && (s.effectAllowed = "move", f.setData && f.setData.call(a, s, St)), nn(document, "drop", a), cr(St, "transform", "translateZ(0)")), pf = !0, a._dragStartId = gg(a._dragStarted.bind(a, n, e)), nn(document, "selectstart", a), sd = !0, xd && cr(document.body, "user-select", "none");
  },
  _onDragOver: function(e) {
    var n = this.el, a = e.target, s, f, o, m = this.options, g = m.group, b = ur.active, T = $y === g, M = m.sort, I = no || b, A, z = this, V = !1;
    if (dx)
      return;
    function q(At, tr) {
      Jo(At, z, rl({
        evt: e,
        isOwner: T,
        axis: A ? "vertical" : "horizontal",
        revert: o,
        dragRect: s,
        targetRect: f,
        canSort: M,
        fromSortable: I,
        target: a,
        completed: X,
        onMove: function(Nr, pr) {
          return Hy(qn, n, St, s, Nr, Ri(Nr), e, pr);
        },
        changed: ae
      }, tr));
    }
    function re() {
      q("dragOverAnimationCapture"), z.captureAnimationState(), z !== I && I.captureAnimationState();
    }
    function X(At) {
      return q("dragOverCompleted", {
        insertion: At
      }), At && (T ? b._hideClone() : b._showClone(z), z !== I && (ha(St, no ? no.options.ghostClass : b.options.ghostClass, !1), ha(St, m.ghostClass, !0)), no !== z && z !== ur.active ? no = z : z === ur.active && no && (no = null), I === z && (z._ignoreWhileAnimating = a), z.animateAll(function() {
        q("dragOverAnimationComplete"), z._ignoreWhileAnimating = null;
      }), z !== I && (I.animateAll(), I._ignoreWhileAnimating = null)), (a === St && !St.animated || a === n && !a.animated) && (cf = null), !m.dragoverBubble && !e.rootEl && a !== document && (St.parentNode[ma]._isOutsideThisEl(e.target), !At && Dc(e)), !m.dragoverBubble && e.stopPropagation && e.stopPropagation(), V = !0;
    }
    function ae() {
      fa = Aa(St), Su = Aa(St, m.draggable), Lo({
        sortable: z,
        name: "change",
        toEl: n,
        newIndex: fa,
        newDraggableIndex: Su,
        originalEvent: e
      });
    }
    if (e.preventDefault !== void 0 && e.cancelable && e.preventDefault(), a = Bs(a, m.draggable, n, !0), q("dragOver"), ur.eventCanceled)
      return V;
    if (St.contains(e.target) || a.animated && a.animatingX && a.animatingY || z._ignoreWhileAnimating === a)
      return X(!1);
    if (rv = !1, b && !m.disabled && (T ? M || (o = fi !== qn) : no === this || (this.lastPutMode = $y.checkPull(this, b, St, e)) && g.checkPut(this, b, St, e))) {
      if (A = this._getDirection(e, a) === "vertical", s = Ri(St), q("dragOverValid"), ur.eventCanceled)
        return V;
      if (o)
        return fi = qn, re(), this._hideClone(), q("revert"), ur.eventCanceled || (Bc ? qn.insertBefore(St, Bc) : qn.appendChild(St)), X(!0);
      var ce = c1(n, m.draggable);
      if (!ce || KU(e, A, this) && !ce.animated) {
        if (ce === St)
          return X(!1);
        if (ce && n === e.target && (a = ce), a && (f = Ri(a)), Hy(qn, n, St, s, a, f, e, !!a) !== !1)
          return re(), ce && ce.nextSibling ? n.insertBefore(St, ce.nextSibling) : n.appendChild(St), fi = n, ae(), X(!0);
      } else if (ce && XU(e, A, this)) {
        var ve = Bf(n, 0, m, !0);
        if (ve === St)
          return X(!1);
        if (a = ve, f = Ri(a), Hy(qn, n, St, s, a, f, e, !1) !== !1)
          return re(), n.insertBefore(St, ve), fi = n, ae(), X(!0);
      } else if (a.parentNode === n) {
        f = Ri(a);
        var Ne = 0, ze, Ae = St.parentNode !== n, Se = !$U(St.animated && St.toRect || s, a.animated && a.toRect || f, A), Ie = A ? "top" : "left", Xe = mE(a, "top", "top") || mE(St, "top", "top"), $e = Xe ? Xe.scrollTop : void 0;
        cf !== a && (ze = f[Ie], Sd = !1, qy = !Se && m.invertSwap || Ae), Ne = YU(e, a, f, A, Se ? 1 : m.swapThreshold, m.invertedSwapThreshold == null ? m.swapThreshold : m.invertedSwapThreshold, qy, cf === a);
        var at;
        if (Ne !== 0) {
          var be = Aa(St);
          do
            be -= Ne, at = fi.children[be];
          while (at && (cr(at, "display") === "none" || at === Mr));
        }
        if (Ne === 0 || at === a)
          return X(!1);
        cf = a, Ed = Ne;
        var Je = a.nextElementSibling, ht = !1;
        ht = Ne === 1;
        var vt = Hy(qn, n, St, s, a, f, e, ht);
        if (vt !== !1)
          return (vt === 1 || vt === -1) && (ht = vt === 1), dx = !0, setTimeout(ZU, 30), re(), ht && !Je ? n.appendChild(St) : a.parentNode.insertBefore(St, ht ? Je : a), Xe && MI(Xe, 0, $e - Xe.scrollTop), fi = St.parentNode, ze !== void 0 && !qy && (yg = Math.abs(ze - Ri(a)[Ie])), ae(), X(!0);
      }
      if (n.contains(St))
        return X(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    Kr(document, "mousemove", this._onTouchMove), Kr(document, "touchmove", this._onTouchMove), Kr(document, "pointermove", this._onTouchMove), Kr(document, "dragover", Dc), Kr(document, "mousemove", Dc), Kr(document, "touchmove", Dc);
  },
  _offUpEvents: function() {
    var e = this.el.ownerDocument;
    Kr(e, "mouseup", this._onDrop), Kr(e, "touchend", this._onDrop), Kr(e, "pointerup", this._onDrop), Kr(e, "touchcancel", this._onDrop), Kr(document, "selectstart", this);
  },
  _onDrop: function(e) {
    var n = this.el, a = this.options;
    if (fa = Aa(St), Su = Aa(St, a.draggable), Jo("drop", this, {
      evt: e
    }), fi = St && St.parentNode, fa = Aa(St), Su = Aa(St, a.draggable), ur.eventCanceled) {
      this._nulling();
      return;
    }
    pf = !1, qy = !1, Sd = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), mx(this.cloneId), mx(this._dragStartId), this.nativeDraggable && (Kr(document, "drop", this), Kr(n, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), xd && cr(document.body, "user-select", ""), cr(St, "transform", ""), e && (sd && (e.cancelable && e.preventDefault(), !a.dropBubble && e.stopPropagation()), Mr && Mr.parentNode && Mr.parentNode.removeChild(Mr), (qn === fi || no && no.lastPutMode !== "clone") && ni && ni.parentNode && ni.parentNode.removeChild(ni), St && (this.nativeDraggable && Kr(St, "dragend", this), v0(St), St.style["will-change"] = "", sd && !pf && ha(St, no ? no.options.ghostClass : this.options.ghostClass, !1), ha(St, this.options.chosenClass, !1), Lo({
      sortable: this,
      name: "unchoose",
      toEl: fi,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: e
    }), qn !== fi ? (fa >= 0 && (Lo({
      rootEl: fi,
      name: "add",
      toEl: fi,
      fromEl: qn,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "remove",
      toEl: fi,
      originalEvent: e
    }), Lo({
      rootEl: fi,
      name: "sort",
      toEl: fi,
      fromEl: qn,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "sort",
      toEl: fi,
      originalEvent: e
    })), no && no.save()) : fa !== bf && fa >= 0 && (Lo({
      sortable: this,
      name: "update",
      toEl: fi,
      originalEvent: e
    }), Lo({
      sortable: this,
      name: "sort",
      toEl: fi,
      originalEvent: e
    })), ur.active && ((fa == null || fa === -1) && (fa = bf, Su = wd), Lo({
      sortable: this,
      name: "end",
      toEl: fi,
      originalEvent: e
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    Jo("nulling", this), qn = St = fi = Mr = Bc = ni = mg = Ou = Lc = Ja = sd = fa = Su = bf = wd = cf = Ed = no = $y = ur.dragged = ur.ghost = ur.clone = ur.active = null, iv.forEach(function(e) {
      e.checked = !0;
    }), iv.length = m0 = y0 = 0;
  },
  handleEvent: function(e) {
    switch (e.type) {
      case "drop":
      case "dragend":
        this._onDrop(e);
        break;
      case "dragenter":
      case "dragover":
        St && (this._onDragOver(e), HU(e));
        break;
      case "selectstart":
        e.preventDefault();
        break;
    }
  },
  toArray: function() {
    for (var e = [], n, a = this.el.children, s = 0, f = a.length, o = this.options; s < f; s++)
      n = a[s], Bs(n, o.draggable, this.el, !1) && e.push(n.getAttribute(o.dataIdAttr) || QU(n));
    return e;
  },
  sort: function(e, n) {
    var a = {}, s = this.el;
    this.toArray().forEach(function(f, o) {
      var m = s.children[o];
      Bs(m, this.options.draggable, s, !1) && (a[f] = m);
    }, this), n && this.captureAnimationState(), e.forEach(function(f) {
      a[f] && (s.removeChild(a[f]), s.appendChild(a[f]));
    }), n && this.animateAll();
  },
  save: function() {
    var e = this.options.store;
    e && e.set && e.set(this);
  },
  closest: function(e, n) {
    return Bs(e, n || this.options.draggable, this.el, !1);
  },
  option: function(e, n) {
    var a = this.options;
    if (n === void 0)
      return a[e];
    var s = am.modifyOption(this, e, n);
    typeof s < "u" ? a[e] = s : a[e] = n, e === "group" && PI(a);
  },
  destroy: function() {
    Jo("destroy", this);
    var e = this.el;
    e[ma] = null, Kr(e, "mousedown", this._onTapStart), Kr(e, "touchstart", this._onTapStart), Kr(e, "pointerdown", this._onTapStart), this.nativeDraggable && (Kr(e, "dragover", this), Kr(e, "dragenter", this)), Array.prototype.forEach.call(e.querySelectorAll("[draggable]"), function(n) {
      n.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), nv.splice(nv.indexOf(this.el), 1), this.el = e = null;
  },
  _hideClone: function() {
    if (!Ou) {
      if (Jo("hideClone", this), ur.eventCanceled)
        return;
      cr(ni, "display", "none"), this.options.removeCloneOnHide && ni.parentNode && ni.parentNode.removeChild(ni), Ou = !0;
    }
  },
  _showClone: function(e) {
    if (e.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (Ou) {
      if (Jo("showClone", this), ur.eventCanceled)
        return;
      St.parentNode == qn && !this.options.group.revertClone ? qn.insertBefore(ni, St) : Bc ? qn.insertBefore(ni, Bc) : qn.appendChild(ni), this.options.group.revertClone && this.animate(St, ni), cr(ni, "display", ""), Ou = !1;
    }
  }
};
function HU(t) {
  t.dataTransfer && (t.dataTransfer.dropEffect = "move"), t.cancelable && t.preventDefault();
}
function Hy(t, e, n, a, s, f, o, m) {
  var g, b = t[ma], T = b.options.onMove, M;
  return window.CustomEvent && !Xl && !om ? g = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (g = document.createEvent("Event"), g.initEvent("move", !0, !0)), g.to = e, g.from = t, g.dragged = n, g.draggedRect = a, g.related = s || e, g.relatedRect = f || Ri(e), g.willInsertAfter = m, g.originalEvent = o, t.dispatchEvent(g), T && (M = T.call(b, g, o)), M;
}
function v0(t) {
  t.draggable = !1;
}
function ZU() {
  dx = !1;
}
function XU(t, e, n) {
  var a = Ri(Bf(n.el, 0, n.options, !0)), s = 10;
  return e ? t.clientX < a.left - s || t.clientY < a.top && t.clientX < a.right : t.clientY < a.top - s || t.clientY < a.bottom && t.clientX < a.left;
}
function KU(t, e, n) {
  var a = Ri(c1(n.el, n.options.draggable)), s = 10;
  return e ? t.clientX > a.right + s || t.clientX <= a.right && t.clientY > a.bottom && t.clientX >= a.left : t.clientX > a.right && t.clientY > a.top || t.clientX <= a.right && t.clientY > a.bottom + s;
}
function YU(t, e, n, a, s, f, o, m) {
  var g = a ? t.clientY : t.clientX, b = a ? n.height : n.width, T = a ? n.top : n.left, M = a ? n.bottom : n.right, I = !1;
  if (!o) {
    if (m && yg < b * s) {
      if (!Sd && (Ed === 1 ? g > T + b * f / 2 : g < M - b * f / 2) && (Sd = !0), Sd)
        I = !0;
      else if (Ed === 1 ? g < T + yg : g > M - yg)
        return -Ed;
    } else if (g > T + b * (1 - s) / 2 && g < M - b * (1 - s) / 2)
      return JU(e);
  }
  return I = I || o, I && (g < T + b * f / 2 || g > M - b * f / 2) ? g > T + b / 2 ? 1 : -1 : 0;
}
function JU(t) {
  return Aa(St) < Aa(t) ? 1 : -1;
}
function QU(t) {
  for (var e = t.tagName + t.className + t.src + t.href + t.textContent, n = e.length, a = 0; n--; )
    a += e.charCodeAt(n);
  return a.toString(36);
}
function ej(t) {
  iv.length = 0;
  for (var e = t.getElementsByTagName("input"), n = e.length; n--; ) {
    var a = e[n];
    a.checked && iv.push(a);
  }
}
function gg(t) {
  return setTimeout(t, 0);
}
function mx(t) {
  return clearTimeout(t);
}
Fv && nn(document, "touchmove", function(t) {
  (ur.active || pf) && t.cancelable && t.preventDefault();
});
ur.utils = {
  on: nn,
  off: Kr,
  css: cr,
  find: SI,
  is: function(e, n) {
    return !!Bs(e, n, e, !1);
  },
  extend: RU,
  throttle: TI,
  closest: Bs,
  toggleClass: ha,
  clone: II,
  index: Aa,
  nextTick: gg,
  cancelNextTick: mx,
  detectDirection: CI,
  getChild: Bf
};
ur.get = function(t) {
  return t[ma];
};
ur.mount = function() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  e[0].constructor === Array && (e = e[0]), e.forEach(function(a) {
    if (!a.prototype || !a.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(a));
    a.utils && (ur.utils = rl(rl({}, ur.utils), a.utils)), am.mount(a);
  });
};
ur.create = function(t, e) {
  return new ur(t, e);
};
ur.version = LU;
var Oi = [], ld, yx, gx = !1, _0, x0, ov, ud;
function tj() {
  function t() {
    this.defaults = {
      scroll: !0,
      forceAutoScrollFallback: !1,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var e in this)
      e.charAt(0) === "_" && typeof this[e] == "function" && (this[e] = this[e].bind(this));
  }
  return t.prototype = {
    dragStarted: function(n) {
      var a = n.originalEvent;
      this.sortable.nativeDraggable ? nn(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? nn(document, "pointermove", this._handleFallbackAutoScroll) : a.touches ? nn(document, "touchmove", this._handleFallbackAutoScroll) : nn(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(n) {
      var a = n.originalEvent;
      !this.options.dragOverBubble && !a.rootEl && this._handleAutoScroll(a);
    },
    drop: function() {
      this.sortable.nativeDraggable ? Kr(document, "dragover", this._handleAutoScroll) : (Kr(document, "pointermove", this._handleFallbackAutoScroll), Kr(document, "touchmove", this._handleFallbackAutoScroll), Kr(document, "mousemove", this._handleFallbackAutoScroll)), xE(), vg(), zU();
    },
    nulling: function() {
      ov = yx = ld = gx = ud = _0 = x0 = null, Oi.length = 0;
    },
    _handleFallbackAutoScroll: function(n) {
      this._handleAutoScroll(n, !0);
    },
    _handleAutoScroll: function(n, a) {
      var s = this, f = (n.touches ? n.touches[0] : n).clientX, o = (n.touches ? n.touches[0] : n).clientY, m = document.elementFromPoint(f, o);
      if (ov = n, a || this.options.forceAutoScrollFallback || om || Xl || xd) {
        b0(n, this.options, m, a);
        var g = Cu(m, !0);
        gx && (!ud || f !== _0 || o !== x0) && (ud && xE(), ud = setInterval(function() {
          var b = Cu(document.elementFromPoint(f, o), !0);
          b !== g && (g = b, vg()), b0(n, s.options, b, a);
        }, 10), _0 = f, x0 = o);
      } else {
        if (!this.options.bubbleScroll || Cu(m, !0) === Js()) {
          vg();
          return;
        }
        b0(n, this.options, Cu(m, !1), !1);
      }
    }
  }, Wl(t, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function vg() {
  Oi.forEach(function(t) {
    clearInterval(t.pid);
  }), Oi = [];
}
function xE() {
  clearInterval(ud);
}
var b0 = TI(function(t, e, n, a) {
  if (!!e.scroll) {
    var s = (t.touches ? t.touches[0] : t).clientX, f = (t.touches ? t.touches[0] : t).clientY, o = e.scrollSensitivity, m = e.scrollSpeed, g = Js(), b = !1, T;
    yx !== n && (yx = n, vg(), ld = e.scroll, T = e.scrollFn, ld === !0 && (ld = Cu(n, !0)));
    var M = 0, I = ld;
    do {
      var A = I, z = Ri(A), V = z.top, q = z.bottom, re = z.left, X = z.right, ae = z.width, ce = z.height, ve = void 0, Ne = void 0, ze = A.scrollWidth, Ae = A.scrollHeight, Se = cr(A), Ie = A.scrollLeft, Xe = A.scrollTop;
      A === g ? (ve = ae < ze && (Se.overflowX === "auto" || Se.overflowX === "scroll" || Se.overflowX === "visible"), Ne = ce < Ae && (Se.overflowY === "auto" || Se.overflowY === "scroll" || Se.overflowY === "visible")) : (ve = ae < ze && (Se.overflowX === "auto" || Se.overflowX === "scroll"), Ne = ce < Ae && (Se.overflowY === "auto" || Se.overflowY === "scroll"));
      var $e = ve && (Math.abs(X - s) <= o && Ie + ae < ze) - (Math.abs(re - s) <= o && !!Ie), at = Ne && (Math.abs(q - f) <= o && Xe + ce < Ae) - (Math.abs(V - f) <= o && !!Xe);
      if (!Oi[M])
        for (var be = 0; be <= M; be++)
          Oi[be] || (Oi[be] = {});
      (Oi[M].vx != $e || Oi[M].vy != at || Oi[M].el !== A) && (Oi[M].el = A, Oi[M].vx = $e, Oi[M].vy = at, clearInterval(Oi[M].pid), ($e != 0 || at != 0) && (b = !0, Oi[M].pid = setInterval(function() {
        a && this.layer === 0 && ur.active._onTouchMove(ov);
        var Je = Oi[this.layer].vy ? Oi[this.layer].vy * m : 0, ht = Oi[this.layer].vx ? Oi[this.layer].vx * m : 0;
        typeof T == "function" && T.call(ur.dragged.parentNode[ma], ht, Je, t, ov, Oi[this.layer].el) !== "continue" || MI(Oi[this.layer].el, ht, Je);
      }.bind({
        layer: M
      }), 24))), M++;
    } while (e.bubbleScroll && I !== g && (I = Cu(I, !1)));
    gx = b;
  }
}, 30), LI = function(e) {
  var n = e.originalEvent, a = e.putSortable, s = e.dragEl, f = e.activeSortable, o = e.dispatchSortableEvent, m = e.hideGhostForTarget, g = e.unhideGhostForTarget;
  if (!!n) {
    var b = a || f;
    m();
    var T = n.changedTouches && n.changedTouches.length ? n.changedTouches[0] : n, M = document.elementFromPoint(T.clientX, T.clientY);
    g(), b && !b.el.contains(M) && (o("spill"), this.onSpill({
      dragEl: s,
      putSortable: a
    }));
  }
};
function h1() {
}
h1.prototype = {
  startIndex: null,
  dragStart: function(e) {
    var n = e.oldDraggableIndex;
    this.startIndex = n;
  },
  onSpill: function(e) {
    var n = e.dragEl, a = e.putSortable;
    this.sortable.captureAnimationState(), a && a.captureAnimationState();
    var s = Bf(this.sortable.el, this.startIndex, this.options);
    s ? this.sortable.el.insertBefore(n, s) : this.sortable.el.appendChild(n), this.sortable.animateAll(), a && a.animateAll();
  },
  drop: LI
};
Wl(h1, {
  pluginName: "revertOnSpill"
});
function f1() {
}
f1.prototype = {
  onSpill: function(e) {
    var n = e.dragEl, a = e.putSortable, s = a || this.sortable;
    s.captureAnimationState(), n.parentNode && n.parentNode.removeChild(n), s.animateAll();
  },
  drop: LI
};
Wl(f1, {
  pluginName: "removeOnSpill"
});
ur.mount(new tj());
ur.mount(f1, h1);
const DI = 0.5, rj = !1, av = ih(
  "slider",
  () => {
    const t = Ei(), e = Er(DI), n = Er(rj), a = ar(
      () => [...t.layers].reverse()[0]
    );
    function s(o) {
      let m = o;
      o < 0.1 ? m = 0.1 : o > 0.9 && (m = 0.9), e.value = m;
    }
    function f(o) {
      n.value = o != null ? o : !n.value;
    }
    return {
      sliderActive: n,
      sliderRatio: e,
      sliderTopLayer: a,
      setRatio: s,
      toggleSlider: f
    };
  },
  {}
);
function NI(t, e) {
  const { t: n } = En();
  function a() {
    e == null || e.emit("clickInfo", t);
  }
  return {
    t: n,
    onClickInfo: a
  };
}
const nj = { class: "lux-layer-manager-item mt-2.5" }, ij = ["title"], oj = { class: "flex-1 text-left cursor-default" }, aj = ["aria-label", "title"], sj = /* @__PURE__ */ ir({
  __name: "layer-item-background",
  props: {
    showEditButton: { type: Boolean, required: !0 },
    layer: { type: null, required: !0 }
  },
  emits: ["clickEdit", "clickInfo"],
  setup(t, { emit: e }) {
    const n = t, { t: a, onClickInfo: s } = NI(n.layer, { emit: e }), f = ar(
      () => a('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: o()
      })
    );
    function o() {
      return a(n.layer.name, { ns: "client" });
    }
    return (m, g) => (Be(), rt("div", nj, [
      Fe("button", {
        class: "fa fa-info w-3",
        title: se(f),
        onClick: g[0] || (g[0] = (...b) => se(s) && se(s)(...b))
      }, null, 8, ij),
      Fe("span", oj, Ht(o()), 1),
      t.showEditButton ? (Be(), rt("button", {
        key: 0,
        class: "fa fa-pencil",
        "aria-label": se(a)("Open editor panel", { ns: "client" }),
        title: se(a)("Open editor panel", { ns: "client" }),
        onClick: g[1] || (g[1] = (b) => m.$emit("clickEdit"))
      }, null, 8, aj)) : Ye("v-if", !0)
    ]));
  }
}), lj = /* @__PURE__ */ lr(sj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item-background.vue"]]), uj = ["id"], cj = ["aria-checked", "title"], hj = ["id", "value", "aria-label"], fj = ["aria-checked", "aria-label"], pj = /* @__PURE__ */ ir({
  __name: "layer-item-sub",
  props: {
    layer: { type: null, required: !0 },
    isOpen: { type: Boolean, required: !0 },
    isLayerComparatorOpen: { type: Boolean, required: !0 },
    displayLayerComparatorOpen: { type: Boolean, required: !0 }
  },
  emits: ["changeOpacity", "clickToggleLayerComparator"],
  setup(t, { emit: e }) {
    var I, A, z, V;
    const n = t, { t: a } = En(), s = cs(), f = ar(
      () => a(s.getLayerCurrentLabel(n.layer), { ns: "client" })
    ), o = Bn(
      ((A = (I = n.layer) == null ? void 0 : I.opacity) != null ? A : 1) * 100
    ), m = Bn(
      ((V = (z = n.layer) == null ? void 0 : z.previousOpacity) != null ? V : o.value) * 100
    );
    function g() {
      o.value === 0 ? o.value = m.value : (m.value = o.value, o.value = 0), M();
    }
    function b(q) {
      q.target && (o.value = parseInt(q.target.value), M());
    }
    function T() {
      e("clickToggleLayerComparator", n.layer);
    }
    function M() {
      e("changeOpacity", n.layer, o.value);
    }
    return (q, re) => (Be(), rt("div", {
      class: Br(["lux-layer-manager-item-content", t.isOpen ? "h-6" : "h-0"]),
      id: `layer-manager-item-content-${t.layer.id}`
    }, [
      Fe("button", {
        class: Br(["w-5 fa-solid", se(o) === 0 ? "fa-eye-slash" : "fa-eye"]),
        role: "switch",
        "aria-checked": se(o) === 0,
        title: se(a)("Toggle layer opacity for {{layerName}}", {
          layerName: se(f)
        }),
        onClick: g
      }, null, 10, cj),
      Fe("input", {
        id: `${t.layer.id}-steps-range`,
        type: "range",
        min: "0",
        max: "100",
        value: se(o),
        step: "25",
        onChange: b,
        class: "m-2.5 w-16 h-[5px] rounded-lg appearance-none cursor-pointer",
        "aria-label": se(a)("Change opacity for {{ layerName }}", { layerName: se(f) })
      }, null, 40, hj),
      t.displayLayerComparatorOpen ? (Be(), rt("button", {
        key: 0,
        role: "switch",
        class: Br(["fa ml-auto text-sm cursor-pointer", t.isLayerComparatorOpen ? "fa-adjust" : "fa-circle"]),
        "aria-checked": t.isLayerComparatorOpen,
        "aria-label": se(a)("Toggle layer comparator for {{ layerName }}", {
          layerName: se(f)
        }),
        onClick: T
      }, null, 10, fj)) : Ye("v-if", !0)
    ], 10, uj));
  }
}), dj = /* @__PURE__ */ lr(pj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item-sub.vue"]]), mj = ["min", "max", "value"], yj = /* @__PURE__ */ ir({
  __name: "layer-time-datepicker",
  props: {
    minDateAllowed: { type: String, required: !1, default: "" },
    maxDateAllowed: { type: String, required: !1, default: "" },
    dateValue: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, a = ar(() => n0(n.minDateAllowed)), s = ar(() => n0(n.maxDateAllowed));
    function f(o) {
      e("change", o.target.value);
    }
    return (o, m) => (Be(), rt("input", {
      class: "lux-time-datepicker",
      type: "date",
      min: se(a),
      max: se(s),
      value: t.dateValue ? se(n0)(t.dateValue) : "",
      onChange: f
    }, null, 40, mj));
  }
}), vx = /* @__PURE__ */ lr(yj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker.vue"]]), gj = { class: "lux-time-slider w-full" }, vj = ["for"], _j = /* @__PURE__ */ ir({
  __name: "layer-time-datepicker-value",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t) {
    const e = t, { t: n } = En(), a = Bn(
      e.layer.currentTimeMinValue
    );
    return (s, f) => {
      var o, m;
      return Be(), rt("div", gj, [
        Fe("div", null, [
          Fe("label", {
            for: `${t.layer.id}-time-slider-start`,
            class: "lux-time-slider-label"
          }, Ht(se(n)("Date:")), 9, vj),
          kt(vx, {
            id: `${t.layer.id}-time-slider-start`,
            "date-value": se(a),
            "min-date-allowed": (o = e.layer.time) == null ? void 0 : o.minValue,
            "max-date-allowed": (m = e.layer.time) == null ? void 0 : m.maxValue,
            onChange: f[0] || (f[0] = (g) => s.$emit("changeTime", g))
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ])
      ]);
    };
  }
}), xj = /* @__PURE__ */ lr(_j, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker-value.vue"]]), bj = { class: "lux-time-slider w-full" }, wj = ["for"], Ej = ["for"], Sj = /* @__PURE__ */ ir({
  __name: "layer-time-datepicker-range",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    const n = t, { t: a } = En(), s = Bn(
      n.layer.currentTimeMinValue
    ), f = Bn(
      n.layer.currentTimeMaxValue
    );
    function o(g) {
      e("changeTime", g, n.layer.currentTimeMaxValue);
    }
    function m(g) {
      e("changeTime", n.layer.currentTimeMinValue, g);
    }
    return (g, b) => {
      var T, M, I, A;
      return Be(), rt("div", bj, [
        Ye(" Date START datepicker input "),
        Fe("div", null, [
          Fe("label", {
            for: `${t.layer.id}-time-slider-start`,
            class: "lux-time-slider-label"
          }, Ht(se(a)("From:")), 9, wj),
          kt(vx, {
            id: `${t.layer.id}-time-slider-start`,
            "date-value": se(s),
            "min-date-allowed": (T = n.layer.time) == null ? void 0 : T.minValue,
            "max-date-allowed": (M = n.layer.time) == null ? void 0 : M.maxValue,
            onChange: o
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ]),
        Ye(" Date END datepicker input "),
        Fe("div", null, [
          Fe("label", {
            for: `${t.layer.id}-time-slider-end`,
            class: "lux-time-slider-label"
          }, Ht(se(a)("To:")), 9, Ej),
          kt(vx, {
            id: `${t.layer.id}-time-slider-end`,
            "date-value": se(f),
            "min-date-allowed": (I = n.layer.time) == null ? void 0 : I.minValue,
            "max-date-allowed": (A = n.layer.time) == null ? void 0 : A.maxValue,
            onChange: m
          }, null, 8, ["id", "date-value", "min-date-allowed", "max-date-allowed"])
        ])
      ]);
    };
  }
}), Tj = /* @__PURE__ */ lr(Sj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-datepicker-range.vue"]]), Mj = ["onKeydown", "aria-label", "title"], Ij = /* @__PURE__ */ ir({
  __name: "slider-range-thumb",
  props: {
    ariaLabel: { type: String, required: !1 },
    maxLimit: { type: Number, required: !1, default: 100 },
    minLimit: { type: Number, required: !1, default: 0 },
    selectedValue: { type: Number, required: !0 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, a = Er(!1), s = Er(), f = Er(), o = ar(() => {
      var X;
      return ((X = s.value) == null ? void 0 : X.offsetWidth) || 0;
    }), m = ar(() => {
      var X;
      return ((X = f.value) == null ? void 0 : X.offsetWidth) || 40;
    }), g = Er(n.selectedValue), b = ar(() => o.value * g.value / 100 - m.value / 2), T = ar(() => ({ left: `${b.value}px` }));
    $u(() => {
      document.removeEventListener("mousemove", V), document.removeEventListener("mouseup", q);
    }), An(
      () => n.selectedValue,
      (X) => {
        g.value = X;
      }
    );
    function M(X) {
      g.value = Math.max(Math.min(X, 100), 0), e("change", g.value, a.value);
    }
    function I() {
      M(g.value - 1);
    }
    function A() {
      M(g.value + 1);
    }
    function z() {
      a.value = !0, document.addEventListener("mousemove", V), document.addEventListener("mouseup", q);
    }
    function V(X) {
      !a.value || M(re(X));
    }
    function q(X) {
      a.value = !1, M(re(X)), document.removeEventListener("mousemove", V), document.removeEventListener("mouseup", q);
    }
    function re(X) {
      var ce, ve;
      const ae = (ce = s.value) != null && ce.offsetWidth ? (X.clientX - m.value * 2) * 100 / ((ve = s.value) == null ? void 0 : ve.offsetWidth) : 0;
      return Math.round(Math.max(Math.min(ae, n.maxLimit), n.minLimit));
    }
    return (X, ae) => (Be(), rt("div", {
      class: "w-full",
      role: "slider",
      ref_key: "elRefTrack",
      ref: s
    }, [
      Fe("button", {
        class: Br(["lux-slidebar-thumb", a.value ? "dragging" : ""]),
        ref_key: "elRefThumb",
        ref: f,
        style: Gu(se(T)),
        onKeydown: [
          Gs(js(A, ["stop"]), ["space"]),
          Gs(js(A, ["stop"]), ["right"]),
          Gs(js(I, ["stop"]), ["left"]),
          Gs(js(I, ["stop"]), ["delete"])
        ],
        onMousedown: z,
        onMousemove: V,
        onMouseup: q,
        "aria-label": t.ariaLabel,
        title: t.ariaLabel
      }, null, 46, Mj)
    ], 512));
  }
}), bE = /* @__PURE__ */ lr(Ij, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/common/slider-range/slider-range-thumb.vue"]]), Oj = /* @__PURE__ */ ir({
  __name: "slider-range-active-track",
  props: {
    selectedMinValue: { type: Number, required: !0 },
    selectedMaxValue: { type: Number, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, a = Er(), s = Er(), f = ar(
      () => a.value ? Math.round(
        a.value.offsetWidth * n.selectedMinValue / 100
      ) : 0
    ), o = ar(() => {
      var T, M;
      let b = 0;
      return n.selectedMaxValue !== void 0 && ((T = a.value) == null ? void 0 : T.offsetWidth) && (b = ((M = a.value) == null ? void 0 : M.offsetWidth) * n.selectedMaxValue / 100 - f.value), Math.round(b);
    }), m = ar(() => ({
      left: `${f.value}px`,
      width: `${o.value}px`
    }));
    function g(b) {
      if (a.value) {
        const T = a.value.getBoundingClientRect().x, M = (b.clientX - T) * 100 / a.value.offsetWidth;
        e("change", M);
      }
    }
    return (b, T) => (Be(), rt("div", {
      ref_key: "elRefFullTrack",
      ref: a,
      class: "lux-slidebar-track"
    }, [
      t.selectedMaxValue !== void 0 ? (Be(), rt("div", {
        key: 0,
        ref_key: "elRefSelectionTrack",
        ref: s,
        class: "lux-slidebar-track-selection",
        style: Gu(se(m)),
        onClick: g
      }, null, 4)) : Ye("v-if", !0),
      Fe("div", {
        class: "lux-slidebar-track-full",
        onClick: g
      })
    ], 512));
  }
}), Cj = /* @__PURE__ */ lr(Oj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/common/slider-range/slider-range-active-track.vue"]]), Pj = { class: "lux-slidebar-fake" }, Aj = /* @__PURE__ */ ir({
  __name: "slider-range",
  props: {
    selectedMinValue: { type: Number, required: !0 },
    selectedMaxValue: { type: Number, required: !1 },
    ariaLabelMin: { type: String, required: !1 },
    ariaLabelMax: { type: String, required: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, a = Er(n.selectedMinValue), s = Er(n.selectedMaxValue);
    function f(g, b) {
      e("change", g, n.selectedMaxValue, b);
    }
    function o(g, b) {
      e("change", n.selectedMinValue, g, b);
    }
    function m(g) {
      s.value === void 0 ? a.value = g : g >= s.value ? s.value = g : g <= n.selectedMinValue ? a.value = g : Math.abs(s.value - g) < Math.abs(a.value - g) ? s.value = g : a.value = g, e("change", a.value, s.value, !1);
    }
    return (g, b) => (Be(), rt("div", Pj, [
      Ye(" Draggable Max thumb button "),
      s.value !== void 0 ? (Be(), an(bE, {
        key: 0,
        ariaLabel: t.ariaLabelMax,
        minLimit: t.selectedMinValue,
        selectedValue: s.value,
        onChange: o
      }, null, 8, ["ariaLabel", "minLimit", "selectedValue"])) : Ye("v-if", !0),
      Ye(" Draggable Min thumb button "),
      Ye(" put Min value after Max value, this is just for z-index grabbing "),
      kt(bE, {
        ariaLabel: t.ariaLabelMin,
        maxLimit: t.selectedMaxValue,
        selectedValue: a.value,
        onChange: f
      }, null, 8, ["ariaLabel", "maxLimit", "selectedValue"]),
      Ye(" Selection highlight "),
      kt(Cj, {
        selectedMinValue: t.selectedMinValue,
        selectedMaxValue: t.selectedMaxValue,
        onChange: m
      }, null, 8, ["selectedMinValue", "selectedMaxValue"])
    ]));
  }
}), wE = /* @__PURE__ */ lr(Aj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/common/slider-range/slider-range.vue"]]), kj = { class: "lux-time-slider w-full" }, Lj = {
  key: 0,
  class: "lux-time-slider-value mr-1.5"
}, Dj = {
  key: 1,
  class: "lux-time-slider-range mr-1.5"
}, Nj = { class: "lux-time-displayed-dates" }, Rj = {
  key: 0,
  class: "lux-time-start-date grow"
}, zj = {
  key: 1,
  class: "lux-time-slider-end-date grow text-right"
}, Fj = /* @__PURE__ */ ir({
  __name: "layer-time-slider",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    const n = t, { t: a } = En(), s = ar(V), f = ar(
      () => {
        var ae, ce;
        return (ae = n.layer.time) != null && ae.minValue ? new Date((ce = n.layer.time) == null ? void 0 : ce.minValue).getTime() : 0;
      }
    ), o = ar(
      () => {
        var ae, ce;
        return (ae = n.layer.time) != null && ae.maxValue ? new Date((ce = n.layer.time) == null ? void 0 : ce.maxValue).getTime() : 0;
      }
    ), m = ar(() => o.value - f.value), g = Er(n.layer.currentTimeMaxValue), b = Er(n.layer.currentTimeMinValue), T = ar(
      () => b.value ? new Date(b.value).getTime() : void 0
    ), M = ar(
      () => g.value ? new Date(g.value).getTime() : void 0
    ), I = ar(
      () => z(T.value)
    ), A = ar(
      () => z(M.value)
    );
    function z(ae) {
      return ae ? (ae - f.value) / m.value * 100 : 0;
    }
    function V() {
      var Ie, Xe;
      const ae = n.layer.time, ce = [];
      if (!ae)
        return;
      if (ae.values)
        return ae.values.map(($e) => new Date($e).getTime());
      const ve = new Date(ae.minValue), Ne = new Date((Ie = ae.maxValue) != null ? Ie : Date.now()), ze = 1024, Ae = new Date(ve.getTime()), Se = (Xe = ae.interval) != null ? Xe : WM;
      if (Ae.setFullYear(
        ve.getFullYear() + ze * Se[0]
      ), Ae.setMonth(
        ve.getMonth() + ze * Se[1],
        ve.getDate() + ze * Se[2]
      ), Ae.setSeconds(ve.getSeconds() + ze * Se[3]), Ae > Ne)
        for (let $e = 0; ; $e++) {
          const at = new Date(ve.getTime());
          if (at.setFullYear(ve.getFullYear() + $e * Se[0]), at.setMonth(
            ve.getMonth() + $e * Se[1],
            ve.getDate() + $e * Se[2]
          ), at.setSeconds(ve.getSeconds() + $e * Se[3]), at <= Ne)
            ce.push(at.getTime());
          else
            break;
        }
      return ce;
    }
    function q(ae) {
      var Ne;
      const ce = ae / 100 * (o.value - f.value) + f.value, ve = B6(ce, {
        minValue: f.value,
        maxValue: o.value,
        timeValueList: s.value,
        timeInterval: (Ne = n.layer.time) == null ? void 0 : Ne.interval
      });
      return sx(ve);
    }
    function re(ae, ce) {
      const ve = q(ae);
      if (b.value = ve, ce) {
        const Ne = q(ce);
        g.value = Ne;
      }
    }
    function X(ae, ce, ve) {
      re(ae, ce), ve || e("changeTime", b.value, g.value);
    }
    return (ae, ce) => {
      var ve, Ne, ze, Ae, Se, Ie, Xe;
      return Be(), rt("div", kj, [
        Ye(" Slider LayerTimeMode.VALUE "),
        ((ve = t.layer.time) == null ? void 0 : ve.mode) === se(zl).VALUE ? (Be(), rt("div", Lj, [
          kt(wE, {
            ariaLabelMin: `${se(a)("Modifier la date de d\xE9but", { ns: "client" })}`,
            selectedMinValue: se(I),
            onChange: X
          }, null, 8, ["ariaLabelMin", "selectedMinValue"])
        ])) : Ye("v-if", !0),
        Ye(" Slider LayerTimeMode.RANGE "),
        ((Ne = t.layer.time) == null ? void 0 : Ne.mode) === se(zl).RANGE ? (Be(), rt("div", Dj, [
          kt(wE, {
            ariaLabelMin: `${se(a)("Modifier la date de d\xE9but", { ns: "client" })}`,
            ariaLabelMax: `${se(a)("Modifier la date de fin", { ns: "client" })}`,
            selectedMinValue: se(I),
            selectedMaxValue: se(A),
            onChange: X
          }, null, 8, ["ariaLabelMin", "ariaLabelMax", "selectedMinValue", "selectedMaxValue"])
        ])) : Ye("v-if", !0),
        Ye(" Display localized time values "),
        Fe("div", Nj, [
          Ye(" Display localized time values Min value "),
          ((ze = t.layer.time) == null ? void 0 : ze.mode) === se(zl).RANGE || ((Ae = t.layer.time) == null ? void 0 : Ae.mode) === se(zl).VALUE ? (Be(), rt("div", Rj, [
            Fe("span", null, Ht(b.value ? se(W2)(b.value, (Se = t.layer.time) == null ? void 0 : Se.resolution) : "-"), 1)
          ])) : Ye("v-if", !0),
          Ye(" Display localized time values Max value "),
          ((Ie = t.layer.time) == null ? void 0 : Ie.mode) === se(zl).RANGE ? (Be(), rt("div", zj, [
            Fe("span", null, Ht(g.value ? se(W2)(g.value, (Xe = t.layer.time) == null ? void 0 : Xe.resolution) : "-"), 1)
          ])) : Ye("v-if", !0)
        ])
      ]);
    };
  }
}), Bj = /* @__PURE__ */ lr(Fj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time-slider.vue"]]), Vj = /* @__PURE__ */ ir({
  __name: "layer-time",
  props: {
    layer: { type: null, required: !0 }
  },
  emits: ["changeTime"],
  setup(t, { emit: e }) {
    function n(a, s) {
      e("changeTime", a, s);
    }
    return (a, s) => {
      var f, o, m, g, b;
      return Be(), rt(on, null, [
        Ye(" Layer time: slider widget "),
        ((f = t.layer.time) == null ? void 0 : f.widget) === se(cg).SLIDER ? (Be(), an(Bj, {
          key: 0,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : Ye("v-if", !0),
        Ye(" Layer time: datepicker VALUE (one date) widget "),
        ((o = t.layer.time) == null ? void 0 : o.widget) === se(cg).DATEPICKER && ((m = t.layer.time) == null ? void 0 : m.mode) === se(zl).VALUE ? (Be(), an(xj, {
          key: 1,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : Ye("v-if", !0),
        Ye(' Layer time: datepicker RANGE ("from:" date - "to:" date) widget '),
        ((g = t.layer.time) == null ? void 0 : g.widget) === se(cg).DATEPICKER && ((b = t.layer.time) == null ? void 0 : b.mode) === se(zl).RANGE ? (Be(), an(Tj, {
          key: 2,
          layer: t.layer,
          onChangeTime: n
        }, null, 8, ["layer"])) : Ye("v-if", !0)
      ], 64);
    };
  }
}), Uj = /* @__PURE__ */ lr(Vj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-time/layer-time.vue"]]), jj = { class: "lux-layer-manager-item relative" }, Gj = { class: "w-full flex flex-nowrap items-start gap-x-2" }, $j = ["title"], qj = ["aria-label", "title"], Wj = ["aria-expanded", "aria-controls", "data-cy"], Hj = { class: "grow" }, Zj = ["title", "aria-label"], Xj = /* @__PURE__ */ ir({
  __name: "layer-item",
  props: {
    is3d: { type: Boolean, required: !0 },
    layer: { type: null, required: !0 },
    dragHandleClassName: { type: String, required: !0 },
    isOpen: { type: Boolean, required: !0 },
    isLayerComparatorOpen: { type: Boolean, required: !0 },
    displayLayerComparatorOpen: { type: Boolean, required: !0 }
  },
  emits: ["clickInfo", "clickToggle", "clickToggleLayerComparator", "clickRemove", "changeOpacity", "changeTime"],
  setup(t, { emit: e }) {
    const n = t, { t: a, onClickInfo: s } = NI(n.layer, { emit: e }), f = cs(), o = ar(
      () => a(f.getLayerCurrentLabel(n.layer), { ns: "client" })
    ), m = ar(
      () => a('Sort "{{layerName}}" in the list', {
        ns: "client",
        layerName: o.value
      })
    ), g = ar(
      () => a('Display informations for "{{layerName}}"', {
        ns: "client",
        layerName: o.value
      })
    ), b = ar(
      () => a('Remove layer "{{layerName}}"', {
        ns: "client",
        layerName: o.value
      })
    );
    function T(M, I) {
      e("changeTime", M, I);
    }
    return (M, I) => (Be(), rt("div", jj, [
      Fe("div", Gj, [
        Fe("button", {
          class: Br(["fa-solid fa-bars cursor-move mt-1", t.dragHandleClassName]),
          title: se(m)
        }, null, 10, $j),
        Fe("button", {
          class: "fa-solid fa-info mt-1",
          "aria-label": se(g),
          title: se(g),
          onClick: I[0] || (I[0] = (...A) => se(s) && se(s)(...A))
        }, null, 8, qj),
        Fe("button", {
          "aria-expanded": t.isOpen,
          "aria-controls": `layer-manager-item-content-${t.layer.id}`,
          "data-cy": `myLayerItemLabel-${t.layer.id}`,
          class: Br([t.is3d ? "cursor-default" : "", "grow text-left break-words w-[70%] flex items-center"]),
          onClick: I[1] || (I[1] = (A) => M.$emit("clickToggle", t.layer))
        }, [
          Fe("span", Hj, Ht(se(o)), 1),
          t.is3d ? Ye("v-if", !0) : (Be(), rt("span", {
            key: 0,
            class: Br(["w-3.5 fa-solid", t.isOpen ? "fa-xmark" : "fa-ellipsis"]),
            "aria-hidden": "true"
          }, null, 2))
        ], 10, Wj),
        Fe("button", {
          class: "mt-1 fa-regular fa-trash-can",
          title: se(b),
          "aria-label": se(b),
          onClick: I[2] || (I[2] = (A) => M.$emit("clickRemove", t.layer))
        }, null, 8, Zj)
      ]),
      Ye(" Layer item sub content (opacity and toggle comparator) "),
      t.is3d ? Ye("v-if", !0) : (Be(), an(dj, {
        key: 0,
        layer: t.layer,
        isOpen: t.isOpen,
        isLayerComparatorOpen: t.isLayerComparatorOpen,
        displayLayerComparatorOpen: t.displayLayerComparatorOpen,
        onClickToggleLayerComparator: I[3] || (I[3] = (A) => M.$emit("clickToggleLayerComparator", A)),
        onChangeOpacity: I[4] || (I[4] = (A, z) => M.$emit("changeOpacity", A, z))
      }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen"])),
      Ye(" Layer time: slider OR datepicker widgets "),
      t.layer.time ? (Be(), an(Uj, {
        key: 1,
        layer: t.layer,
        onChangeTime: T
      }, null, 8, ["layer"])) : Ye("v-if", !0)
    ]));
  }
}), EE = /* @__PURE__ */ lr(Xj, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-item/layer-item.vue"]]), Kj = {
  key: 0,
  class: "mb-4 sortable-layers-3d"
}, Yj = ["id"], Jj = { class: "sortable-layers" }, Qj = ["id"], e9 = { class: "flex flex-row justify-center space-x-1 my-2" }, t9 = /* @__PURE__ */ ir({
  __name: "layer-manager",
  emits: ["displayCatalog"],
  setup(t, { emit: e }) {
    const { t: n } = En(), { setMetadataId: a } = n1(), s = Ei(), f = Ai(), o = qf(), m = av(), { bgLayer: g } = pn(s), { sliderActive: b } = pn(m), T = ar(() => [...s.layers].reverse()), M = ar(() => [...s.layers3d].reverse()), I = Bn(), A = "drag-handle", z = ar(
      () => o.isLayerStyleEditable(g.value)
    ), { setRemoteLayersOpen: V } = Ai();
    _a(() => {
      const Ae = {
        dragClass: "lux-sortable-drag",
        ghostClass: "lux-sortable-ghost",
        sort: !0,
        handle: `.${A}`,
        forceFallback: H6
      }, Se = document.querySelector(".sortable-layers"), Ie = document.querySelector(".sortable-layers-3d");
      Se && ur.create(Se, {
        ...Ae,
        onSort: q
      }), Ie && ur.create(Ie, {
        ...Ae,
        onSort: re
      });
    });
    function q(Ae, Se) {
      const Ie = [...Ae.to.children].map((Xe) => Number(Xe.id)).reverse();
      s.reorderLayers(Ie, Se);
    }
    function re(Ae) {
      q(Ae, !0);
    }
    function X(Ae, Se) {
      s.setLayerOpacity(Ae.id, Se / 100);
    }
    function ae(Ae, Se, Ie) {
      s.setLayerTime(Ae.id, Se, Ie);
    }
    function ce(Ae) {
      s.removeLayers(Ae.id);
    }
    function ve(Ae) {
      I.value = I.value !== Ae.id ? Ae.id : void 0;
    }
    function Ne() {
      f.openStyleEditorPanel();
    }
    function ze() {
      m.toggleSlider();
    }
    return (Ae, Se) => (Be(), rt("div", null, [
      se(M).length > 0 ? (Be(), rt("ul", Kj, [
        (Be(!0), rt(on, null, Ra(se(M), (Ie, Xe) => (Be(), rt("li", {
          key: Ie.id,
          id: Ie.id
        }, [
          kt(EE, {
            is3d: !0,
            dragHandleClassName: A,
            layer: Ie,
            isOpen: se(I) === Ie.id,
            isLayerComparatorOpen: se(b),
            displayLayerComparatorOpen: Xe === 0,
            onClickRemove: ce,
            onClickToggle: ve,
            onClickToggleLayerComparator: ze,
            onClickInfo: ($e) => se(a)(Ie.id),
            onChangeOpacity: X,
            onChangeTime: ($e, at) => ae(Ie, $e, at)
          }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen", "onClickInfo", "onChangeTime"])
        ], 8, Yj))), 128))
      ])) : Ye("v-if", !0),
      Fe("ul", Jj, [
        (Be(!0), rt(on, null, Ra(se(T), (Ie, Xe) => (Be(), rt("li", {
          key: Ie.id,
          id: Ie.id
        }, [
          kt(EE, {
            is3d: !1,
            dragHandleClassName: A,
            layer: Ie,
            isOpen: se(I) === Ie.id,
            isLayerComparatorOpen: se(b),
            displayLayerComparatorOpen: Xe === 0,
            onClickRemove: ce,
            onClickToggle: ve,
            onClickToggleLayerComparator: ze,
            onClickInfo: ($e) => se(a)(Ie.id),
            onChangeOpacity: X,
            onChangeTime: ($e, at) => ae(Ie, $e, at)
          }, null, 8, ["layer", "isOpen", "isLayerComparatorOpen", "displayLayerComparatorOpen", "onClickInfo", "onChangeTime"])
        ], 8, Qj))), 128))
      ]),
      kt(lj, {
        layer: se(g) || se(Jg),
        showEditButton: se(z),
        onClickInfo: Se[0] || (Se[0] = () => se(g) && se(a)(se(g).id)),
        onClickEdit: Ne
      }, null, 8, ["layer", "showEditButton"]),
      Fe("div", e9, [
        Fe("button", {
          class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
          onClick: Se[1] || (Se[1] = (Ie) => e("displayCatalog"))
        }, Ht(se(n)("+ Add layers", { ns: "client" })), 1),
        Fe("button", {
          class: "bg-white text-primary hover:bg-primary hover:text-white border border-slate-300 py-1.5 px-2.5",
          onClick: Se[2] || (Se[2] = (Ie) => se(V)(!0))
        }, Ht(se(n)("+ Add external Wms", { ns: "client" })), 1)
      ])
    ]));
  }
}), r9 = /* @__PURE__ */ lr(t9, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-manager/layer-manager.vue"]]), n9 = { class: "flex flex-col h-full pt-1.5" }, i9 = { class: "h-16 shrink-0 flex justify-between lux-panel-title" }, o9 = ["aria-label"], a9 = { class: "flex flex-row gap-2 h-10 text-2xl" }, s9 = ["aria-expanded"], l9 = { key: 0 }, u9 = ["aria-expanded"], c9 = { class: "relative grow p-2.5 bg-primary overflow-auto" }, h9 = /* @__PURE__ */ ir({
  __name: "layer-panel",
  setup(t) {
    const { t: e } = En(), n = Ai(), { setLayersOpen: a } = n, { myLayersTabOpen: s } = pn(n), { layers: f } = pn(Ei());
    function o() {
      n.setMyLayersTabOpen(!0);
    }
    function m() {
      n.setMyLayersTabOpen(!1);
    }
    return (g, b) => (Be(), rt("div", n9, [
      Ye(" Panel title and close button "),
      Fe("div", i9, [
        Fe("h1", null, Ht(se(e)("layers", { ns: "client" })), 1),
        Fe("span", null, [
          Fe("button", {
            onClick: b[0] || (b[0] = () => se(a)(!1)),
            "aria-label": se(e)("Close", { ns: "client" }),
            class: "fa-sharp fa-solid fa-close"
          }, null, 8, o9)
        ])
      ]),
      Ye(" My Layers and Catalog tab labels "),
      Fe("div", a9, [
        Fe("button", {
          onClick: o,
          class: Br(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", se(s) ? "bg-primary" : "bg-tertiary"]),
          "aria-expanded": se(s)
        }, [
          Ag(Ht(se(e)("my_layers", { ns: "client" })) + " ", 1),
          se(f).length ? (Be(), rt("span", l9, "(" + Ht(se(f).length) + ")", 1)) : Ye("v-if", !0)
        ], 10, s9),
        Fe("button", {
          onClick: m,
          class: Br(["text-white px-4 hover:bg-primary cursor-pointer text-center uppercase", se(s) ? "bg-tertiary" : "bg-primary"]),
          "aria-expanded": !se(s)
        }, Ht(se(e)("Catalog", { ns: "client" })), 11, u9)
      ]),
      Ye(" Panel content (MyLayers and Catalog) "),
      Fe("div", c9, [
        se(s) ? (Be(), an(r9, {
          key: 0,
          onDisplayCatalog: m
        })) : Ye("v-if", !0),
        se(s) ? Ye("v-if", !0) : (Be(), an(CU, { key: 1 }))
      ])
    ]));
  }
}), f9 = /* @__PURE__ */ lr(h9, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/layer-panel/layer-panel.vue"]]);
class p9 {
  bootstrap() {
    let e;
    e = va(() => {
      this.restore(), this.persist(), e && e();
    });
  }
  persist() {
    const e = av();
    An(
      [() => e.sliderActive, () => e.sliderRatio],
      ([n, a], [s]) => {
        n !== s && Cr.setValue(ux, n), Cr.setValue(
          cx,
          a
        );
      }
    );
  }
  restore() {
    const e = Cr.getValue(ux, r1), n = Cr.getValue(cx, Cf), { toggleSlider: a, setRatio: s } = av();
    typeof e < "u" && e !== null && (a(e), typeof n !== void 0 && n !== null && s(n != null ? n : DI));
  }
}
const d9 = new p9(), m9 = ["onKeydown"], y9 = /* @__PURE__ */ Fe("span", { class: "lux-slider-line" }, null, -1), g9 = /* @__PURE__ */ Fe("span", { class: "lux-slider-arrows" }, [
  /* @__PURE__ */ Fe("span"),
  /* @__PURE__ */ Fe("span")
], -1), v9 = {
  key: 0,
  class: "lux-slider-layer-label"
}, _9 = /* @__PURE__ */ Fe("i", { class: "fa fa-arrow-left mr-2" }, null, -1), x9 = /* @__PURE__ */ ir({
  __name: "splitter-element",
  props: {
    sliderActive: { type: Boolean, required: !0 },
    sliderRatio: { type: Number, required: !0 },
    sliderTopLayer: { type: null, required: !0 },
    sliderOffset: { type: Number, required: !0 },
    containerOffset: { type: Number, required: !0 }
  },
  emits: ["moveSplitBar", "escSplitBar"],
  setup(t, { expose: e, emit: n }) {
    const a = t, s = 30, { t: f } = En(), o = Er(null), m = ar(() => ({ left: `${a.sliderOffset}px` }));
    let g = !1;
    e({
      sliderElement: o
    });
    function b(q) {
      n("moveSplitBar", q + o.value.offsetWidth / 2);
    }
    function T() {
      g = !0, document.addEventListener("mousemove", M), document.addEventListener("mouseup", I);
    }
    function M(q) {
      !g || b(q.clientX);
    }
    function I() {
      g = !1, document.removeEventListener("mousemove", M), document.removeEventListener("mouseup", I);
    }
    function A() {
      const q = a.containerOffset + o.value.offsetLeft;
      b(q + s);
    }
    function z() {
      const q = a.containerOffset + o.value.offsetLeft;
      b(q - s);
    }
    function V() {
      n("escSplitBar");
    }
    return _a(() => {
      var q;
      (q = o.value) == null || q.focus({ focusVisible: !0 });
    }), $u(() => {
      document.removeEventListener("mousemove", M), document.removeEventListener("mouseup", I);
    }), (q, re) => (Be(), rt("button", {
      ref_key: "sliderElement",
      ref: o,
      onMousedown: T,
      onMousemove: M,
      onMouseup: I,
      onKeydown: [
        Gs(js(A, ["stop"]), ["space"]),
        Gs(js(A, ["stop"]), ["right"]),
        Gs(js(z, ["stop"]), ["left"]),
        Gs(js(z, ["stop"]), ["delete"]),
        Gs(js(V, ["stop"]), ["esc"])
      ],
      class: "left-[20px] absolute h-full w-[32px] block",
      style: Gu(se(m)),
      role: "seperator",
      "aria-controls": "map-container"
    }, [
      y9,
      g9,
      t.sliderTopLayer ? (Be(), rt("span", v9, [
        _9,
        Fe("span", null, Ht(se(f)(t.sliderTopLayer.name)), 1)
      ])) : Ye("v-if", !0)
    ], 44, m9));
  }
}), b9 = /* @__PURE__ */ lr(x9, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/slider/splitter-element.vue"]]), w9 = /* @__PURE__ */ ir({
  __name: "slider-comparator",
  setup(t) {
    const e = av(), n = oI(), a = Vl().olMap, s = Er(null), { sliderActive: f, sliderRatio: o, sliderTopLayer: m } = pn(e), g = ar(
      () => {
        var X, ae;
        return ((ae = (X = s.value) == null ? void 0 : X.sliderElement) == null ? void 0 : ae.offsetWidth) || 0;
      }
    ), b = function() {
      var ae, ce, ve;
      let X = (ve = (ce = (ae = a.value) == null ? void 0 : ae.getViewport()) == null ? void 0 : ce.parentElement) == null ? void 0 : ve.offsetLeft;
      return (X === void 0 || X === 0) && (X = A == null ? void 0 : A.offsetLeft), X !== void 0 ? X : 0;
    }, T = ar(() => {
      var X, ae;
      return a.value && s.value ? o.value * a.value.getSize()[0] - ((ae = (X = s.value) == null ? void 0 : X.sliderElement) == null ? void 0 : ae.offsetWidth) / 2 : 0;
    });
    let M, I, A;
    d9.bootstrap(), An([m, f], ([X, ae], [ce]) => {
      var ve;
      X && ae ? (X !== ce && V(), z()) : V(), (ve = a.value) == null || ve.render();
    }), An(T, () => {
      var X;
      (X = a.value) == null || X.render();
    });
    function z() {
      const X = n.getLayerFromCache(m.value);
      !X || (M = X.on(
        Rb.PRERENDER,
        function(ae) {
          var Xe;
          const ce = ae.context, ve = (Xe = a.value) == null ? void 0 : Xe.getSize(), Ne = T.value + g.value / 2, ze = gy(ae, [0, 0]), Ae = gy(ae, [Ne, 0]), Se = gy(ae, [0, ve[1]]), Ie = gy(ae, [Ne, ve[0]]);
          ce.save(), ce.beginPath(), ce.moveTo(ze[0], ze[1]), ce.lineTo(Se[0], Se[1]), ce.lineTo(Ie[0], Ie[1]), ce.lineTo(Ae[0], Ae[1]), ce.closePath(), ce.clip();
        }
      ), I = X.on(
        Rb.POSTRENDER,
        function(ae) {
          ae.context.restore();
        }
      ));
    }
    function V() {
      VC([M, I]);
    }
    function q(X) {
      var ve;
      const ae = (ve = a.value) == null ? void 0 : ve.getSize(), ce = (X - b()) / ae[0];
      e.setRatio(ce);
    }
    function re() {
      e.toggleSlider();
    }
    return _a(() => {
      var X, ae;
      A = (ae = (X = a.value) == null ? void 0 : X.getTargetElement()) == null ? void 0 : ae.closest(".map-wrapper");
    }), $u(() => {
      V();
    }), (X, ae) => se(m) && se(f) ? (Be(), an(b9, {
      key: 0,
      ref_key: "splitterElement",
      ref: s,
      sliderActive: se(f),
      sliderRatio: se(o),
      sliderTopLayer: se(m),
      sliderOffset: se(T),
      containerOffset: b(),
      onMoveSplitBar: q,
      onEscSplitBar: re
    }, null, 8, ["sliderActive", "sliderRatio", "sliderTopLayer", "sliderOffset", "containerOffset"])) : Ye("v-if", !0);
  }
}), E9 = /* @__PURE__ */ lr(w9, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/slider/slider-comparator.vue"]]), Zy = "-", w0 = ",", SE = "--";
class S9 {
  constructor() {
    ri(this, "layersOpacitiesToNumbersV2", (e) => this.layersOpacitiesToNumbers(e, w0));
  }
  layerTimesToStrings(e) {
    return e ? e.split(SE) : [];
  }
  layerIdsToLayers(e) {
    const n = Kc(), a = cs();
    return (e ? e.split(Zy) : []).map((f) => {
      const o = Fd.isRemoteLayer(f) ? IB(f) : n.findById(parseInt(f, 10));
      return o ? a.initLayer(o) : void 0;
    });
  }
  layerNamesToLayersV2(e) {
    const n = Kc(), a = cs();
    return (e ? e.split(w0) : []).map((f) => {
      const o = n.findByName(f);
      return o ? a.initLayer(o) : void 0;
    });
  }
  layersOpacitiesToNumbers(e, n = Zy) {
    return q6(e, n);
  }
  layersVisibilitiesToBooleansV2(e) {
    return W6(e, w0);
  }
  layersToLayerIds(e) {
    return (e == null ? void 0 : e.map((n) => n.id).join(Zy)) || "";
  }
  layersToLayerOpacities(e) {
    return (e == null ? void 0 : e.map((n) => {
      var a;
      return (a = n.opacity) != null ? a : 1;
    }).join(Zy)) || "";
  }
  layersToLayerTimes(e) {
    return (e == null ? void 0 : e.map((n) => {
      var a;
      return (a = cs().getLayerCurrentTime(n)) != null ? a : "";
    }).join(SE)) || "";
  }
  bgLayerNameToBgLayer(e) {
    const n = Kc();
    return e ? n.findBgLayerByName(e) : null;
  }
  bgLayerToBgLayerName(e) {
    return (e == null ? void 0 : e.name) || Jg.name;
  }
}
const da = new S9(), T9 = "basemap_2015_global", M9 = "orthogr_2013_global", I9 = {
  webbasemap: "basemap_2015_global",
  "pixelmaps-color": "topogr_global",
  "pixelmaps-gray": "topo_bw_jpeg",
  streets: "streets_jpeg",
  voidlayer: "blank"
};
class O9 {
  bootstrap() {
    const e = Ro();
    let n;
    n = va(() => {
      e.bgLayers.length > 0 && (this.restore(), this.persist(), n && n());
    });
  }
  persist() {
    const e = Ei(), { bgLayer: n } = pn(e);
    An(
      n,
      (a, s) => {
        s !== a && Cr.setValue(
          K2,
          a,
          da.bgLayerToBgLayerName
        );
      },
      { immediate: !0 }
    );
  }
  restore() {
    const { setMapBackground: e } = aI(), n = this.getBgLayerFromStorage();
    e(n);
  }
  getBgLayerFromStorage() {
    const e = Cr.getInitialVersion(), n = Cr.getValue(K2);
    return n ? e === 2 ? this.getBgLayerFromStorageV2(n) : da.bgLayerNameToBgLayer(n) : da.bgLayerNameToBgLayer(T9);
  }
  getBgLayerFromStorageV2(e) {
    const n = Cr.getValue(
      XM,
      Cf
    );
    let a = "";
    return e ? a = I9[e] : n === 0 && (a = M9), da.bgLayerNameToBgLayer(a);
  }
}
const C9 = new O9();
class P9 {
  bootstrap() {
    const e = Ro();
    let n;
    n = va(() => {
      e.themes && (this.restore(), this.persist(), n && n());
    });
  }
  persist() {
    const e = Ei(), { layers: n } = pn(e);
    An(
      n,
      (a, s) => {
        s !== a && (Cr.setValue(
          X2,
          a,
          da.layersToLayerIds
        ), Cr.setValue(
          Y2,
          a,
          da.layersToLayerOpacities
        ), Cr.setValue(
          J2,
          a,
          da.layersToLayerTimes
        ));
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Cr.getInitialVersion(), n = Ei(), a = Cr.getValue(
      X2,
      e === 2 ? da.layerNamesToLayersV2 : da.layerIdsToLayers
    );
    this.restoreLayersOpacities(a, e), this.restoreLayersTimes(a), e === 2 && (Cr.removeItem(XM), Cr.removeItem(K6), Cr.removeItem(rE), Cr.removeItem(nE)), n.addLayers(...(a == null ? void 0 : a.filter((s) => s)) || []);
  }
  restoreLayersOpacities(e, n) {
    const a = n === 2 ? this.getOpacitiesFromStorageV2() : this.getOpacitiesFromStorage();
    a.length && (e == null || e.forEach(
      (s, f) => {
        var o;
        return s && (s.opacity = (o = a[f]) != null ? o : 1);
      }
    ));
  }
  restoreLayersTimes(e) {
    const n = Cr.getValue(
      J2,
      da.layerTimesToStrings
    );
    n.length && (e == null || e.forEach(
      (a, s) => a && n[s] && this.restoreLayerTime(a, n[s])
    ));
  }
  restoreLayerTime(e, n) {
    const a = n.split("/");
    e.currentTimeMinValue = a[0], e.currentTimeMaxValue = a[1];
  }
  getOpacitiesFromStorage() {
    return Cr.getValue(
      Y2,
      da.layersOpacitiesToNumbers
    );
  }
  getOpacitiesFromStorageV2() {
    const e = Cr.getValue(
      rE,
      da.layersOpacitiesToNumbersV2
    ), n = Cr.getValue(
      nE,
      da.layersVisibilitiesToBooleansV2
    );
    return e.map((a, s) => n[s] ? a : 0);
  }
}
const A9 = new P9();
class k9 {
  themeToThemeName(e) {
    return (e == null ? void 0 : e.name) || "";
  }
}
const L9 = new k9();
class D9 {
  bootstrap() {
    this.restore();
    let e;
    e = va(() => {
      this.persist(), e && e();
    });
  }
  persist() {
    const e = Ro();
    An(
      () => e.theme,
      (n, a) => {
        a !== n && n && Cr.setValue(
          zd,
          n,
          L9.themeToThemeName
        );
      },
      { immediate: !0 }
    );
  }
  restore() {
    const e = Cr.getValue(zd);
    if (e) {
      const { setTheme: n } = Ro();
      n(e);
    }
  }
}
const N9 = new D9();
class R9 {
  bootstrapLayersOpen() {
    this.restoreLayersOpen();
    let e;
    e = va(() => {
      this.persistLayersOpen(), e && e();
    });
  }
  persistLayersOpen() {
    const e = Ai(), { layersOpen: n } = pn(e);
    An(
      n,
      (a, s) => {
        s !== a && Cr.setValue(Hg, a);
      },
      { immediate: !0 }
    );
  }
  restoreLayersOpen() {
    const e = Cr.getValue(Hg) !== "false", { setLayersOpen: n } = Ai();
    n(e);
  }
}
const z9 = new R9();
class F9 {
  bootstrap() {
    this.restore();
    let e;
    e = va(() => {
      this.persist(), e && e();
    });
  }
  persist() {
  }
  restore() {
    const e = Cr.getValue(Z6);
    Ai().setMapId(e);
  }
}
const B9 = new F9(), V9 = /* @__PURE__ */ ir({
  __name: "simple-style-item",
  props: {
    styleName: { type: String, required: !0 },
    colors: { type: Array, required: !0 }
  },
  setup(t) {
    const e = t;
    return (n, a) => (Be(!0), rt(on, null, Ra(e.colors, (s, f) => (Be(), rt("span", {
      key: `${t.styleName}-${f}`,
      class: "grow m-px",
      style: Gu(`background-color: ${s}`)
    }, " \xA0 ", 4))), 128));
  }
}), U9 = /* @__PURE__ */ lr(V9, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/simple-style-item.vue"]]), j9 = { class: "text-white border-2 p-[10px] m-[10px]" }, G9 = { class: "text-center mb-3" }, $9 = ["title"], q9 = { class: "text-white" }, W9 = ["title", "onClick"], H9 = { class: "flex" }, Z9 = /* @__PURE__ */ ir({
  __name: "simple-style-selector",
  setup(t) {
    const { t: e } = En(), n = Ks(), a = qf(), { bgStyle: s } = pn(n), f = as().simple_styles.road, o = Er(f);
    An(
      s,
      (g) => o.value = a.checkSelection(
        g || [],
        f
      ),
      { immediate: !0 }
    );
    function m(g) {
      n.setSimpleStyle(g);
    }
    return (g, b) => (Be(), rt("div", j9, [
      Ye(" TODO: create clean container for simple and advanced style editors "),
      Fe("h5", G9, Ht(se(e)("Select a style", { ns: "client" })), 1),
      (Be(!0), rt(on, null, Ra(o.value, (T) => (Be(), rt("div", {
        key: T.unlocalized_label,
        title: se(e)(T.unlocalized_label, { ns: "client" }),
        class: Br(`${T.selected ? "border-dotted" : "border-hidden"} border-2 p-px`)
      }, [
        Fe("span", q9, Ht(se(e)(T.unlocalized_label, { ns: "client" })) + " : ", 1),
        Fe("button", {
          title: se(e)("Select style: {{styleName}}", {
            styleName: se(e)(T.unlocalized_label)
          }),
          onClick: (M) => m(T),
          class: "w-full"
        }, [
          Fe("span", H9, [
            kt(U9, {
              colors: T.colors,
              "style-name": T.unlocalized_label
            }, null, 8, ["colors", "style-name"])
          ])
        ], 8, W9)
      ], 10, $9))), 128))
    ]));
  }
}), X9 = /* @__PURE__ */ lr(Z9, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/simple-style-selector.vue"]]);
function K9(t) {
  const e = Y9(t);
  return !e || !e.medium_style_class ? [] : as().medium_default_styles[e.medium_style_class];
}
function Y9(t) {
  return as().bg_layers.find((e) => e.id == (t == null ? void 0 : t.id));
}
const J9 = { class: "flex w-full items-center" }, Q9 = {
  for: "colorId",
  class: "w-40 m-0 font-medium"
}, e7 = { class: "grow" }, t7 = ["value"], r7 = ["checked", "aria-label"], n7 = /* @__PURE__ */ ir({
  __name: "medium-style-item",
  props: {
    style: { type: null, required: !0 },
    colorEditable: { type: Boolean, required: !0 }
  },
  emits: ["changeStyle"],
  setup(t, { emit: e }) {
    const n = t, { t: a } = En();
    function s(o) {
      if (o.target) {
        const m = {
          ...n.style,
          color: o.target.value
        };
        e("changeStyle", m);
      }
    }
    function f(o) {
      if (o) {
        const m = {
          ...n.style,
          visible: o.target.checked
        };
        e("changeStyle", m);
      }
    }
    return (o, m) => (Be(), rt("div", J9, [
      Fe("label", Q9, Ht(se(a)(t.style.label)), 1),
      Fe("div", e7, [
        t.colorEditable && n.style.color ? (Be(), rt("input", {
          key: 0,
          id: "colorId",
          type: "color",
          class: "w-11 h-5 py-[1px] px-[2px]",
          value: n.style.color,
          onInput: s
        }, null, 40, t7)) : Ye("v-if", !0)
      ]),
      Fe("input", {
        type: "checkbox",
        class: "flex-none mr-3",
        checked: n.style.visible,
        onChange: f,
        "aria-label": se(a)("Show or hide {{ thematicName }}", {
          thematicName: n.style.label
        })
      }, null, 40, r7)
    ]));
  }
}), i7 = /* @__PURE__ */ lr(n7, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/medium-style-item.vue"]]), o7 = { class: "text-white border-2 p-[10px] m-[10px]" }, a7 = { class: "text-center mb-3" }, s7 = /* @__PURE__ */ ir({
  __name: "medium-style-selector",
  props: {
    layer: { type: null, required: !0 }
  },
  setup(t) {
    const e = t, n = ["basemap_2015_global"], a = Ks(), { bgStyle: s } = pn(a), { t: f } = En(), o = ar(
      () => n.includes(e.layer.name)
    ), m = ar(
      () => s.value || K9(e.layer)
    );
    function g(b, T) {
      s.value = m.value.map(
        (M, I) => I === b ? T : M
      ), a.disableExpertStyle();
    }
    return (b, T) => (Be(), rt("div", o7, [
      Fe("h5", a7, Ht(se(o) ? se(f)("Select a colour for every theme") : se(f)("Activate categories")), 1),
      (Be(!0), rt(on, null, Ra(se(m), (M, I) => (Be(), an(i7, {
        key: M.label,
        style: Gu(M),
        onChangeStyle: (A) => g(I, A),
        colorEditable: se(o)
      }, null, 8, ["style", "onChangeStyle", "colorEditable"]))), 128))
    ]));
  }
}), l7 = /* @__PURE__ */ lr(s7, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/medium-style-selector.vue"]]);
var RI = { exports: {} };
(function(t, e) {
  (function(n, a) {
    a();
  })($s, function() {
    function n(b, T) {
      return typeof T > "u" ? T = { autoBom: !1 } : typeof T != "object" && (console.warn("Deprecated: Expected third argument to be a object"), T = { autoBom: !T }), T.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(b.type) ? new Blob(["\uFEFF", b], { type: b.type }) : b;
    }
    function a(b, T, M) {
      var I = new XMLHttpRequest();
      I.open("GET", b), I.responseType = "blob", I.onload = function() {
        g(I.response, T, M);
      }, I.onerror = function() {
        console.error("could not download file");
      }, I.send();
    }
    function s(b) {
      var T = new XMLHttpRequest();
      T.open("HEAD", b, !1);
      try {
        T.send();
      } catch {
      }
      return 200 <= T.status && 299 >= T.status;
    }
    function f(b) {
      try {
        b.dispatchEvent(new MouseEvent("click"));
      } catch {
        var T = document.createEvent("MouseEvents");
        T.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), b.dispatchEvent(T);
      }
    }
    var o = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof $s == "object" && $s.global === $s ? $s : void 0, m = o.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = o.saveAs || (typeof window != "object" || window !== o ? function() {
    } : "download" in HTMLAnchorElement.prototype && !m ? function(b, T, M) {
      var I = o.URL || o.webkitURL, A = document.createElement("a");
      T = T || b.name || "download", A.download = T, A.rel = "noopener", typeof b == "string" ? (A.href = b, A.origin === location.origin ? f(A) : s(A.href) ? a(b, T, M) : f(A, A.target = "_blank")) : (A.href = I.createObjectURL(b), setTimeout(function() {
        I.revokeObjectURL(A.href);
      }, 4e4), setTimeout(function() {
        f(A);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(b, T, M) {
      if (T = T || b.name || "download", typeof b != "string")
        navigator.msSaveOrOpenBlob(n(b, M), T);
      else if (s(b))
        a(b, T, M);
      else {
        var I = document.createElement("a");
        I.href = b, I.target = "_blank", setTimeout(function() {
          f(I);
        });
      }
    } : function(b, T, M, I) {
      if (I = I || open("", "_blank"), I && (I.document.title = I.document.body.innerText = "downloading..."), typeof b == "string")
        return a(b, T, M);
      var A = b.type === "application/octet-stream", z = /constructor/i.test(o.HTMLElement) || o.safari, V = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((V || A && z || m) && typeof FileReader < "u") {
        var q = new FileReader();
        q.onloadend = function() {
          var ae = q.result;
          ae = V ? ae : ae.replace(/^data:[^;]*;/, "data:attachment/file;"), I ? I.location.href = ae : location = ae, I = null;
        }, q.readAsDataURL(b);
      } else {
        var re = o.URL || o.webkitURL, X = re.createObjectURL(b);
        I ? I.location = X : location.href = X, I = null, setTimeout(function() {
          re.revokeObjectURL(X);
        }, 4e4);
      }
    });
    o.saveAs = g.saveAs = g, t.exports = g;
  });
})(RI);
const u7 = { class: "text-white border-2 p-[10px] m-[10px] flex flex-col" }, c7 = { class: "text-center mb-3" }, h7 = { class: "flex flex-row justify-center" }, f7 = { class: "absolute top-[70px] w-full text-center text-base leading-3 font-medium text-white" }, p7 = { class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] text-sm" }, d7 = {
  class: "'block z-[5] w-full h-full cursor-pointer after:absolute after:pt-[15px] after:px-[15px] after:w-full after:text-center after:content-upload",
  for: "uploadMvtStyle"
}, m7 = { class: "absolute top-[70px] w-full text-center text-base leading-3 font-medium" }, y7 = ["href"], g7 = /* @__PURE__ */ ir({
  __name: "expert-style-selector",
  setup(t) {
    const e = Ei(), n = Ks(), a = qf(), { appliedStyle: s } = pn(n), { t: f } = En();
    function o() {
      const b = s.value, T = JSON.stringify(b), M = new Blob([T], { type: "text/plain;charset=utf-8" }), I = "styles.json";
      RI.exports.saveAs(M, I);
    }
    function m(b) {
      const T = b.target.files;
      if ((T == null ? void 0 : T.length) !== 1)
        return;
      const M = T[0];
      new File([], "./text.txt").text().then((A) => console.log(A)), M.type === "application/json" && (M.text().then((A) => {
        n.enableExpertStyle(), s.value = JSON.parse(A);
      }), b.target.value = "");
    }
    function g() {
      return n.styleSerial === null ? a.getDefaultMapBoxStyleUrl(
        a.getVectorId(e.bgLayer)
      ) : `${n.registerUrls.get("get")}?id=${n.styleSerial}`;
    }
    return (b, T) => (Be(), rt("div", u7, [
      Fe("h5", c7, Ht(se(f)("Lancer \xE9diteur externe ou importer json")), 1),
      Fe("div", h7, [
        Fe("a", {
          href: "#",
          class: "text-white border-2 relative h-[100px] w-[85px] mx-[10px] my-0 mb-[15px] z-5 text-sm after:absolute after:left-[20px] after:top-[10px] after:z-4 after:w-[3.6em] after:text-center after:content-download",
          onClick: T[0] || (T[0] = (M) => o())
        }, [
          Fe("span", f7, Ht(se(f)("Download style")), 1)
        ]),
        Fe("div", p7, [
          Fe("label", d7, [
            Fe("span", m7, Ht(se(f)("Upload style")), 1)
          ]),
          Fe("input", {
            class: "invisible",
            type: "file",
            name: "uploadMvtStyle",
            id: "uploadMvtStyle",
            onChange: m
          }, null, 32)
        ])
      ]),
      Fe("a", {
        href: `https://maputnik.github.io/editor/?style=${g()}`,
        target: "_blank",
        class: "lux-btn text-center"
      }, Ht(se(f)("Open Maputnik editor")), 9, y7)
    ]));
  }
}), v7 = /* @__PURE__ */ lr(g7, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/expert-style-selector.vue"]]), _7 = { key: 0 }, x7 = {
  key: 0,
  class: "mb-px"
}, b7 = {
  key: 1,
  class: "mb-px"
}, w7 = {
  key: 2,
  class: "mb-px"
}, E7 = /* @__PURE__ */ ir({
  __name: "style-selector",
  setup(t) {
    const { t: e } = En(), n = Ei(), a = Ai(), s = Ks(), { bgStyle: f } = pn(s), { bgLayer: o } = pn(n), m = qf(), g = ar(
      () => m.getStyleCapabilitiesFromLayer(o.value)
    );
    An(o, (M) => {
      m.isLayerStyleEditable(M) || a.closeStyleEditorPanel();
    });
    let b = Er(void 0);
    function T() {
      s.setStyle(null);
    }
    return (M, I) => se(g).isEditable ? (Be(), rt("div", _7, [
      se(g).hasSimpleStyle ? (Be(), rt("div", x7, [
        kt(pg, {
          title: se(e)("Simple"),
          expanded: se(b) === "simpleStyle",
          onTogglePanel: I[0] || (I[0] = () => hn(b) ? b.value = se(b) === "simpleStyle" ? void 0 : "simpleStyle" : b = se(b) === "simpleStyle" ? void 0 : "simpleStyle")
        }, {
          default: ku(() => [
            kt(X9)
          ]),
          _: 1
        }, 8, ["title", "expanded"])
      ])) : Ye("v-if", !0),
      se(g).hasAdvancedStyle ? (Be(), rt("div", b7, [
        kt(pg, {
          title: se(e)("Medium"),
          expanded: se(b) === "mediumStyle",
          onTogglePanel: I[1] || (I[1] = () => hn(b) ? b.value = se(b) === "mediumStyle" ? void 0 : "mediumStyle" : b = se(b) === "mediumStyle" ? void 0 : "mediumStyle")
        }, {
          default: ku(() => [
            se(o) ? (Be(), an(l7, {
              key: 0,
              layer: se(o)
            }, null, 8, ["layer"])) : Ye("v-if", !0)
          ]),
          _: 1
        }, 8, ["title", "expanded"])
      ])) : Ye("v-if", !0),
      se(g).hasExpertStyle ? (Be(), rt("div", w7, [
        kt(pg, {
          title: se(e)("Expert (style.json)"),
          expanded: se(b) === "advancedStyle",
          onTogglePanel: I[2] || (I[2] = () => hn(b) ? b.value = se(b) === "advancedStyle" ? void 0 : "advancedStyle" : b = se(b) === "advancedStyle" ? void 0 : "advancedStyle")
        }, {
          default: ku(() => [
            se(o) ? (Be(), an(v7, {
              key: 0,
              layer: se(o)
            }, null, 8, ["layer"])) : Ye("v-if", !0)
          ]),
          _: 1
        }, 8, ["title", "expanded"])
      ])) : Ye("v-if", !0),
      se(f) ? (Be(), rt("button", {
        key: 3,
        onClick: T,
        class: "lux-btn my-2"
      }, Ht(se(e)("Reset style", { ns: "client" })), 1)) : Ye("v-if", !0)
    ])) : Ye("v-if", !0);
  }
}), S7 = /* @__PURE__ */ lr(E7, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/components/style-selector/style-selector.vue"]]);
function _x(t) {
  return _x = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _x(t);
}
var zI = [], T7 = zI.forEach, M7 = zI.slice;
function xx(t) {
  return T7.call(M7.call(arguments, 1), function(e) {
    if (e)
      for (var n in e)
        t[n] === void 0 && (t[n] = e[n]);
  }), t;
}
function FI() {
  return typeof XMLHttpRequest == "function" || (typeof XMLHttpRequest > "u" ? "undefined" : _x(XMLHttpRequest)) === "object";
}
function I7(t) {
  return !!t && typeof t.then == "function";
}
function O7(t) {
  return I7(t) ? t : Promise.resolve(t);
}
function C7(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var sv = { exports: {} }, Xy = { exports: {} }, TE;
function P7() {
  return TE || (TE = 1, function(t, e) {
    var n = typeof self < "u" ? self : $s, a = function() {
      function f() {
        this.fetch = !1, this.DOMException = n.DOMException;
      }
      return f.prototype = n, new f();
    }();
    (function(f) {
      (function(o) {
        var m = {
          searchParams: "URLSearchParams" in f,
          iterable: "Symbol" in f && "iterator" in Symbol,
          blob: "FileReader" in f && "Blob" in f && function() {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          }(),
          formData: "FormData" in f,
          arrayBuffer: "ArrayBuffer" in f
        };
        function g(be) {
          return be && DataView.prototype.isPrototypeOf(be);
        }
        if (m.arrayBuffer)
          var b = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ], T = ArrayBuffer.isView || function(be) {
            return be && b.indexOf(Object.prototype.toString.call(be)) > -1;
          };
        function M(be) {
          if (typeof be != "string" && (be = String(be)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(be))
            throw new TypeError("Invalid character in header field name");
          return be.toLowerCase();
        }
        function I(be) {
          return typeof be != "string" && (be = String(be)), be;
        }
        function A(be) {
          var Je = {
            next: function() {
              var ht = be.shift();
              return { done: ht === void 0, value: ht };
            }
          };
          return m.iterable && (Je[Symbol.iterator] = function() {
            return Je;
          }), Je;
        }
        function z(be) {
          this.map = {}, be instanceof z ? be.forEach(function(Je, ht) {
            this.append(ht, Je);
          }, this) : Array.isArray(be) ? be.forEach(function(Je) {
            this.append(Je[0], Je[1]);
          }, this) : be && Object.getOwnPropertyNames(be).forEach(function(Je) {
            this.append(Je, be[Je]);
          }, this);
        }
        z.prototype.append = function(be, Je) {
          be = M(be), Je = I(Je);
          var ht = this.map[be];
          this.map[be] = ht ? ht + ", " + Je : Je;
        }, z.prototype.delete = function(be) {
          delete this.map[M(be)];
        }, z.prototype.get = function(be) {
          return be = M(be), this.has(be) ? this.map[be] : null;
        }, z.prototype.has = function(be) {
          return this.map.hasOwnProperty(M(be));
        }, z.prototype.set = function(be, Je) {
          this.map[M(be)] = I(Je);
        }, z.prototype.forEach = function(be, Je) {
          for (var ht in this.map)
            this.map.hasOwnProperty(ht) && be.call(Je, this.map[ht], ht, this);
        }, z.prototype.keys = function() {
          var be = [];
          return this.forEach(function(Je, ht) {
            be.push(ht);
          }), A(be);
        }, z.prototype.values = function() {
          var be = [];
          return this.forEach(function(Je) {
            be.push(Je);
          }), A(be);
        }, z.prototype.entries = function() {
          var be = [];
          return this.forEach(function(Je, ht) {
            be.push([ht, Je]);
          }), A(be);
        }, m.iterable && (z.prototype[Symbol.iterator] = z.prototype.entries);
        function V(be) {
          if (be.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
          be.bodyUsed = !0;
        }
        function q(be) {
          return new Promise(function(Je, ht) {
            be.onload = function() {
              Je(be.result);
            }, be.onerror = function() {
              ht(be.error);
            };
          });
        }
        function re(be) {
          var Je = new FileReader(), ht = q(Je);
          return Je.readAsArrayBuffer(be), ht;
        }
        function X(be) {
          var Je = new FileReader(), ht = q(Je);
          return Je.readAsText(be), ht;
        }
        function ae(be) {
          for (var Je = new Uint8Array(be), ht = new Array(Je.length), vt = 0; vt < Je.length; vt++)
            ht[vt] = String.fromCharCode(Je[vt]);
          return ht.join("");
        }
        function ce(be) {
          if (be.slice)
            return be.slice(0);
          var Je = new Uint8Array(be.byteLength);
          return Je.set(new Uint8Array(be)), Je.buffer;
        }
        function ve() {
          return this.bodyUsed = !1, this._initBody = function(be) {
            this._bodyInit = be, be ? typeof be == "string" ? this._bodyText = be : m.blob && Blob.prototype.isPrototypeOf(be) ? this._bodyBlob = be : m.formData && FormData.prototype.isPrototypeOf(be) ? this._bodyFormData = be : m.searchParams && URLSearchParams.prototype.isPrototypeOf(be) ? this._bodyText = be.toString() : m.arrayBuffer && m.blob && g(be) ? (this._bodyArrayBuffer = ce(be.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : m.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(be) || T(be)) ? this._bodyArrayBuffer = ce(be) : this._bodyText = be = Object.prototype.toString.call(be) : this._bodyText = "", this.headers.get("content-type") || (typeof be == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : m.searchParams && URLSearchParams.prototype.isPrototypeOf(be) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
          }, m.blob && (this.blob = function() {
            var be = V(this);
            if (be)
              return be;
            if (this._bodyBlob)
              return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]));
          }, this.arrayBuffer = function() {
            return this._bodyArrayBuffer ? V(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(re);
          }), this.text = function() {
            var be = V(this);
            if (be)
              return be;
            if (this._bodyBlob)
              return X(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(ae(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }, m.formData && (this.formData = function() {
            return this.text().then(Se);
          }), this.json = function() {
            return this.text().then(JSON.parse);
          }, this;
        }
        var Ne = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function ze(be) {
          var Je = be.toUpperCase();
          return Ne.indexOf(Je) > -1 ? Je : be;
        }
        function Ae(be, Je) {
          Je = Je || {};
          var ht = Je.body;
          if (be instanceof Ae) {
            if (be.bodyUsed)
              throw new TypeError("Already read");
            this.url = be.url, this.credentials = be.credentials, Je.headers || (this.headers = new z(be.headers)), this.method = be.method, this.mode = be.mode, this.signal = be.signal, !ht && be._bodyInit != null && (ht = be._bodyInit, be.bodyUsed = !0);
          } else
            this.url = String(be);
          if (this.credentials = Je.credentials || this.credentials || "same-origin", (Je.headers || !this.headers) && (this.headers = new z(Je.headers)), this.method = ze(Je.method || this.method || "GET"), this.mode = Je.mode || this.mode || null, this.signal = Je.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && ht)
            throw new TypeError("Body not allowed for GET or HEAD requests");
          this._initBody(ht);
        }
        Ae.prototype.clone = function() {
          return new Ae(this, { body: this._bodyInit });
        };
        function Se(be) {
          var Je = new FormData();
          return be.trim().split("&").forEach(function(ht) {
            if (ht) {
              var vt = ht.split("="), At = vt.shift().replace(/\+/g, " "), tr = vt.join("=").replace(/\+/g, " ");
              Je.append(decodeURIComponent(At), decodeURIComponent(tr));
            }
          }), Je;
        }
        function Ie(be) {
          var Je = new z(), ht = be.replace(/\r?\n[\t ]+/g, " ");
          return ht.split(/\r?\n/).forEach(function(vt) {
            var At = vt.split(":"), tr = At.shift().trim();
            if (tr) {
              var kn = At.join(":").trim();
              Je.append(tr, kn);
            }
          }), Je;
        }
        ve.call(Ae.prototype);
        function Xe(be, Je) {
          Je || (Je = {}), this.type = "default", this.status = Je.status === void 0 ? 200 : Je.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in Je ? Je.statusText : "OK", this.headers = new z(Je.headers), this.url = Je.url || "", this._initBody(be);
        }
        ve.call(Xe.prototype), Xe.prototype.clone = function() {
          return new Xe(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new z(this.headers),
            url: this.url
          });
        }, Xe.error = function() {
          var be = new Xe(null, { status: 0, statusText: "" });
          return be.type = "error", be;
        };
        var $e = [301, 302, 303, 307, 308];
        Xe.redirect = function(be, Je) {
          if ($e.indexOf(Je) === -1)
            throw new RangeError("Invalid status code");
          return new Xe(null, { status: Je, headers: { location: be } });
        }, o.DOMException = f.DOMException;
        try {
          new o.DOMException();
        } catch {
          o.DOMException = function(Je, ht) {
            this.message = Je, this.name = ht;
            var vt = Error(Je);
            this.stack = vt.stack;
          }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException;
        }
        function at(be, Je) {
          return new Promise(function(ht, vt) {
            var At = new Ae(be, Je);
            if (At.signal && At.signal.aborted)
              return vt(new o.DOMException("Aborted", "AbortError"));
            var tr = new XMLHttpRequest();
            function kn() {
              tr.abort();
            }
            tr.onload = function() {
              var Nr = {
                status: tr.status,
                statusText: tr.statusText,
                headers: Ie(tr.getAllResponseHeaders() || "")
              };
              Nr.url = "responseURL" in tr ? tr.responseURL : Nr.headers.get("X-Request-URL");
              var pr = "response" in tr ? tr.response : tr.responseText;
              ht(new Xe(pr, Nr));
            }, tr.onerror = function() {
              vt(new TypeError("Network request failed"));
            }, tr.ontimeout = function() {
              vt(new TypeError("Network request failed"));
            }, tr.onabort = function() {
              vt(new o.DOMException("Aborted", "AbortError"));
            }, tr.open(At.method, At.url, !0), At.credentials === "include" ? tr.withCredentials = !0 : At.credentials === "omit" && (tr.withCredentials = !1), "responseType" in tr && m.blob && (tr.responseType = "blob"), At.headers.forEach(function(Nr, pr) {
              tr.setRequestHeader(pr, Nr);
            }), At.signal && (At.signal.addEventListener("abort", kn), tr.onreadystatechange = function() {
              tr.readyState === 4 && At.signal.removeEventListener("abort", kn);
            }), tr.send(typeof At._bodyInit > "u" ? null : At._bodyInit);
          });
        }
        return at.polyfill = !0, f.fetch || (f.fetch = at, f.Headers = z, f.Request = Ae, f.Response = Xe), o.Headers = z, o.Request = Ae, o.Response = Xe, o.fetch = at, Object.defineProperty(o, "__esModule", { value: !0 }), o;
      })({});
    })(a), a.fetch.ponyfill = !0, delete a.fetch.polyfill;
    var s = a;
    e = s.fetch, e.default = s.fetch, e.fetch = s.fetch, e.Headers = s.Headers, e.Request = s.Request, e.Response = s.Response, t.exports = e;
  }(Xy, Xy.exports)), Xy.exports;
}
(function(t, e) {
  var n;
  if (typeof fetch == "function" && (typeof $s < "u" && $s.fetch ? n = $s.fetch : typeof window < "u" && window.fetch ? n = window.fetch : n = fetch), typeof C7 < "u" && (typeof window > "u" || typeof window.document > "u")) {
    var a = n || P7();
    a.default && (a = a.default), e.default = a, t.exports = e.default;
  }
})(sv, sv.exports);
const BI = sv.exports, ME = /* @__PURE__ */ jC({
  __proto__: null,
  default: BI
}, [sv.exports]);
function lv(t) {
  return lv = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, lv(t);
}
var jl;
typeof fetch == "function" && (typeof global < "u" && global.fetch ? jl = global.fetch : typeof window < "u" && window.fetch ? jl = window.fetch : jl = fetch);
var Bd;
FI() && (typeof global < "u" && global.XMLHttpRequest ? Bd = global.XMLHttpRequest : typeof window < "u" && window.XMLHttpRequest && (Bd = window.XMLHttpRequest));
var uv;
typeof ActiveXObject == "function" && (typeof global < "u" && global.ActiveXObject ? uv = global.ActiveXObject : typeof window < "u" && window.ActiveXObject && (uv = window.ActiveXObject));
!jl && ME && !Bd && !uv && (jl = BI || ME);
typeof jl != "function" && (jl = void 0);
var bx = function(e, n) {
  if (n && lv(n) === "object") {
    var a = "";
    for (var s in n)
      a += "&" + encodeURIComponent(s) + "=" + encodeURIComponent(n[s]);
    if (!a)
      return e;
    e = e + (e.indexOf("?") !== -1 ? "&" : "?") + a.slice(1);
  }
  return e;
}, IE = function(e, n, a) {
  jl(e, n).then(function(s) {
    if (!s.ok)
      return a(s.statusText || "Error", {
        status: s.status
      });
    s.text().then(function(f) {
      a(null, {
        status: s.status,
        data: f
      });
    }).catch(a);
  }).catch(a);
}, OE = !1, A7 = function(e, n, a, s) {
  e.queryStringParams && (n = bx(n, e.queryStringParams));
  var f = xx({}, typeof e.customHeaders == "function" ? e.customHeaders() : e.customHeaders);
  a && (f["Content-Type"] = "application/json");
  var o = typeof e.requestOptions == "function" ? e.requestOptions(a) : e.requestOptions, m = xx({
    method: a ? "POST" : "GET",
    body: a ? e.stringify(a) : void 0,
    headers: f
  }, OE ? {} : o);
  try {
    IE(n, m, s);
  } catch (g) {
    if (!o || Object.keys(o).length === 0 || !g.message || g.message.indexOf("not implemented") < 0)
      return s(g);
    try {
      Object.keys(o).forEach(function(b) {
        delete m[b];
      }), IE(n, m, s), OE = !0;
    } catch (b) {
      s(b);
    }
  }
}, k7 = function(e, n, a, s) {
  a && lv(a) === "object" && (a = bx("", a).slice(1)), e.queryStringParams && (n = bx(n, e.queryStringParams));
  try {
    var f;
    Bd ? f = new Bd() : f = new uv("MSXML2.XMLHTTP.3.0"), f.open(a ? "POST" : "GET", n, 1), e.crossDomain || f.setRequestHeader("X-Requested-With", "XMLHttpRequest"), f.withCredentials = !!e.withCredentials, a && f.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), f.overrideMimeType && f.overrideMimeType("application/json");
    var o = e.customHeaders;
    if (o = typeof o == "function" ? o() : o, o)
      for (var m in o)
        f.setRequestHeader(m, o[m]);
    f.onreadystatechange = function() {
      f.readyState > 3 && s(f.status >= 400 ? f.statusText : null, {
        status: f.status,
        data: f.responseText
      });
    }, f.send(a);
  } catch (g) {
    console && console.log(g);
  }
}, L7 = function(e, n, a, s) {
  if (typeof a == "function" && (s = a, a = void 0), s = s || function() {
  }, jl && n.indexOf("file:") !== 0)
    return A7(e, n, a, s);
  if (FI() || typeof ActiveXObject == "function")
    return k7(e, n, a, s);
  s(new Error("No fetch and no xhr implementation found!"));
};
function Vd(t) {
  return Vd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Vd(t);
}
function D7(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function CE(t, e) {
  for (var n = 0; n < e.length; n++) {
    var a = e[n];
    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, VI(a.key), a);
  }
}
function N7(t, e, n) {
  return e && CE(t.prototype, e), n && CE(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function R7(t, e, n) {
  return e = VI(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function VI(t) {
  var e = z7(t, "string");
  return Vd(e) === "symbol" ? e : String(e);
}
function z7(t, e) {
  if (Vd(t) !== "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var a = n.call(t, e || "default");
    if (Vd(a) !== "object")
      return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var F7 = function() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    allowMultiLoading: !1,
    parse: function(n) {
      return JSON.parse(n);
    },
    stringify: JSON.stringify,
    parsePayload: function(n, a, s) {
      return R7({}, a, s || "");
    },
    request: L7,
    reloadInterval: typeof window < "u" ? !1 : 60 * 60 * 1e3,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: !1,
    withCredentials: !1,
    overrideMimeType: !1,
    requestOptions: {
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
}, UI = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    D7(this, t), this.services = e, this.options = n, this.allOptions = a, this.type = "backend", this.init(e, n, a);
  }
  return N7(t, [{
    key: "init",
    value: function(n) {
      var a = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = n, this.options = xx(s, this.options || {}, F7()), this.allOptions = f, this.services && this.options.reloadInterval && setInterval(function() {
        return a.reload();
      }, this.options.reloadInterval);
    }
  }, {
    key: "readMulti",
    value: function(n, a, s) {
      this._readAny(n, n, a, a, s);
    }
  }, {
    key: "read",
    value: function(n, a, s) {
      this._readAny([n], n, [a], a, s);
    }
  }, {
    key: "_readAny",
    value: function(n, a, s, f, o) {
      var m = this, g = this.options.loadPath;
      typeof this.options.loadPath == "function" && (g = this.options.loadPath(n, s)), g = O7(g), g.then(function(b) {
        if (!b)
          return o(null, {});
        var T = m.services.interpolator.interpolate(b, {
          lng: n.join("+"),
          ns: s.join("+")
        });
        m.loadUrl(T, o, a, f);
      });
    }
  }, {
    key: "loadUrl",
    value: function(n, a, s, f) {
      var o = this;
      this.options.request(this.options, n, void 0, function(m, g) {
        if (g && (g.status >= 500 && g.status < 600 || !g.status))
          return a("failed loading " + n + "; status code: " + g.status, !0);
        if (g && g.status >= 400 && g.status < 500)
          return a("failed loading " + n + "; status code: " + g.status, !1);
        if (!g && m && m.message && m.message.indexOf("Failed to fetch") > -1)
          return a("failed loading " + n + ": " + m.message, !0);
        if (m)
          return a(m, !1);
        var b, T;
        try {
          typeof g.data == "string" ? b = o.options.parse(g.data, s, f) : b = g.data;
        } catch {
          T = "failed parsing " + n + " to json";
        }
        if (T)
          return a(T, !1);
        a(null, b);
      });
    }
  }, {
    key: "create",
    value: function(n, a, s, f, o) {
      var m = this;
      if (!!this.options.addPath) {
        typeof n == "string" && (n = [n]);
        var g = this.options.parsePayload(a, s, f), b = 0, T = [], M = [];
        n.forEach(function(I) {
          var A = m.options.addPath;
          typeof m.options.addPath == "function" && (A = m.options.addPath(I, a));
          var z = m.services.interpolator.interpolate(A, {
            lng: I,
            ns: a
          });
          m.options.request(m.options, z, g, function(V, q) {
            b += 1, T.push(V), M.push(q), b === n.length && typeof o == "function" && o(T, M);
          });
        });
      }
    }
  }, {
    key: "reload",
    value: function() {
      var n = this, a = this.services, s = a.backendConnector, f = a.languageUtils, o = a.logger, m = s.language;
      if (!(m && m.toLowerCase() === "cimode")) {
        var g = [], b = function(M) {
          var I = f.toResolveHierarchy(M);
          I.forEach(function(A) {
            g.indexOf(A) < 0 && g.push(A);
          });
        };
        b(m), this.allOptions.preload && this.allOptions.preload.forEach(function(T) {
          return b(T);
        }), g.forEach(function(T) {
          n.allOptions.ns.forEach(function(M) {
            s.read(T, M, "read", null, null, function(I, A) {
              I && o.warn("loading namespace ".concat(M, " for language ").concat(T, " failed"), I), !I && A && o.log("loaded namespace ".concat(M, " for language ").concat(T), A), s.loaded("".concat(T, "|").concat(M), I, A);
            });
          });
        });
      }
    }
  }]), t;
}();
UI.type = "backend";
function jI(t, e, n) {
  n(t, e) && t instanceof UC && t.getLayers().forEach((s) => {
    jI(s, [...e, t], n);
  });
}
const B7 = { class: "h-screen flex flex-col overflow-hidden" }, V7 = { class: "flex grow" }, U7 = {
  key: 0,
  class: "w-full sm:w-80 bg-secondary z-10"
}, j7 = {
  key: 1,
  class: "w-80 bg-primary"
}, G7 = { class: "map-wrapper grow bg-blue-100 relative" }, $7 = { class: "absolute right-1 top-16" }, q7 = /* @__PURE__ */ ir({
  __name: "App",
  setup(t) {
    const e = Ai();
    B9.bootstrap(), A9.bootstrap(), N9.bootstrap(), z9.bootstrapLayersOpen(), JM.bootstrapStyle(), C9.bootstrap();
    const { layersOpen: n, styleEditorOpen: a } = pn(e);
    An(
      n,
      () => setTimeout(() => {
        s();
      }, 50)
    ), _a(() => window.addEventListener("resize", s)), $u(() => window.removeEventListener("resize", s));
    function s() {
      const f = Vl().getOlMap();
      f.updateSize(), jI(f.getLayerGroup(), [], (o) => (o instanceof iI && o.getMapLibreMap().resize(), !0));
    }
    return (f, o) => (Be(), rt("div", B7, [
      kt(QV),
      Fe("main", V7, [
        Ye(" Layer panel "),
        se(n) ? (Be(), rt("div", U7, [
          kt(f9)
        ])) : Ye("v-if", !0),
        Ye(" Style editor "),
        se(a) ? (Be(), rt("div", j7, [
          kt(S7)
        ])) : Ye("v-if", !0),
        Ye(" Map container and slider comparator "),
        Fe("div", G7, [
          kt(ZF, { v4_standalone: !0 }),
          kt(E9, { class: "absolute top-0" }),
          kt(Z8),
          kt(FV)
        ]),
        Ye(" Background selector "),
        Fe("div", $7, [
          kt(nB)
        ])
      ]),
      kt(uU, { class: "fixed bottom-5 sm:static z-20" }),
      kt(K4)
    ]));
  }
}), W7 = /* @__PURE__ */ lr(q7, [["__file", "/home/tkohr/Projets/luxembourg/git/luxembourg-geoportail/src/App.vue"]]);
V4();
oi.use(UI);
oi.init({
  lng: "fr",
  debug: !1,
  defaultNS: "client",
  supportedLngs: ["de", "en", "fr", "lb"],
  ns: ["client", "legends", "server", "tooltips"],
  fallbackLng: "fr",
  backend: {
    loadPath: "/static-ngeo/web-components/assets/locales/{{ns}}.{{lng}}.json"
  },
  nsSeparator: "|"
});
const p1 = Jk(W7);
p1.use(oD());
p1.use(V5, { i18next: oi });
p1.use(DL);
const vG = (t = {}, e = null) => U4(
  {
    setup: () => {
      const n = wv();
      Object.assign(n.appContext, e._context), Object.assign(n.provides, e._context.provides);
    },
    render: () => YS(t)
  },
  { shadowRoot: !1 }
);
export {
  K4 as AlertNotifications,
  W7 as App,
  nB as BackgroundSelector,
  BT as DropdownList,
  uU as FooterBar,
  QV as HeaderBar,
  V5 as I18NextVue,
  FV as LayerMetadata,
  f9 as LayerPanel,
  ZF as MapContainer,
  iI as MapLibreLayer,
  Z8 as RemoteLayers,
  E9 as SliderComparator,
  S7 as StyleSelector,
  DL as VueDOMPurifyHTML,
  p1 as app,
  UI as backend,
  vG as createElementInstance,
  oD as createPinia,
  U4 as defineCustomElement,
  oi as i18next,
  Ff as proxyUrlHelper,
  C9 as statePersistorBgLayerService,
  z9 as statePersistorLayersOpenService,
  A9 as statePersistorLayersService,
  B9 as statePersistorMyMapService,
  JM as statePersistorStyleService,
  N9 as statePersistorThemeService,
  pn as storeToRefs,
  qV as themeSelectorService,
  Ai as useAppStore,
  aI as useBackgroundLayer,
  cs as useLayers,
  Vl as useMap,
  Ei as useMapStore,
  qf as useMvtStyles,
  oI as useOpenLayers,
  Ks as useStyleStore,
  Ro as useThemeStore,
  Kc as useThemes,
  An as watch
};
